diff --git a/CHANGES.md b/CHANGES.md
index 9c2ab0a..abe2ac9 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -1,5 +1,11 @@
 # StreamEx changes
 
+### 0.6.0
+* [#70] Fixed: `MoreCollectors.least()/greatest()` now support null element (if the supplied `Comparator` supports nulls).
+* [#70] Fixed: `MoreCollectors.least()/greatest()` now returns stable result (the order of equal elements is not changed).
+* [#70] Optimized: `MoreCollectors.least()/greatest()` is usually faster now, especially when the selected elements are close to the stream end.
+
+
 ### 0.5.5
 * [#41] Added: `IntStreamEx/LongStreamEx/StreamEx.without()` accepting several elements.
 * [#60] Added: `StreamEx.zipWith()` to zip the stream with another.
diff --git a/src/main/java/one/util/streamex/Limiter.java b/src/main/java/one/util/streamex/Limiter.java
index 77365ac..08ac3c3 100644
--- a/src/main/java/one/util/streamex/Limiter.java
+++ b/src/main/java/one/util/streamex/Limiter.java
@@ -17,248 +17,149 @@ package one.util.streamex;
 
 import java.util.AbstractCollection;
 import java.util.Arrays;
-import java.util.Collections;
 import java.util.Comparator;
 import java.util.Iterator;
 
 /**
- * A container to keep limit least elements according to given comparator
+ * Extracts least limit elements from the input sorting them according to the
+ * given comparator. Works for 2 <= limit < Integer.MAX_VALUE/2. Uses
+ * O(min(limit, inputSize)) additional memory.
  * 
- * First stage (less than limit elements): fill the pq sequentially until limit
- * elements is created.
- * 
- * Second stage: bootstrap. First fill series as a circular buffer until new
- * element cannot be appended or prepended to it, then drain circular buffer
- * elements to the pq (replacing greatest current element with the new one) and
- * start circular buffer again.
- * 
- * Finally, sort the pq array respecting the insertion order (which is tracked
- * in order array).
+ * @param <T> type of input elements
  * 
  * @author Tagir Valeev
- *
- * @param <T>
  */
 /* package */class Limiter<T> extends AbstractCollection<T> {
-    private final T[] pq;
-    private T[] series;
-    private int[] order;
+    private T[] data;
+    private final int limit;
     private final Comparator<? super T> comparator;
-    private int size, maxOrder, head, tail;
+    private int size;
+    private boolean initial = true;
 
     @SuppressWarnings("unchecked")
     public Limiter(int limit, Comparator<? super T> comparator) {
-        // limit >= 2
-        this.pq = (T[]) new Object[limit];
+        this.limit = limit;
         this.comparator = comparator;
+        this.data = (T[]) new Object[Math.min(1000, limit) * 2];
     }
 
-    public Limiter<T> putAll(Limiter<T> other) {
-        if (other.size + size < pq.length) {
-            System.arraycopy(other.pq, 0, pq, size, other.size);
-            size += other.size;
-        } else {
-            other.sort();
-            for (int i = 0; i < other.size; i++) {
-                if (!put(other.pq[i]))
-                    break;
-            }
-        }
-        return this;
-    }
-
-    private static int inc(int val, int limit) {
-        return (val + 1) % limit;
-    }
-
-    private static int dec(int val, int limit) {
-        return (val + limit - 1) % limit;
-    }
-
-    @SuppressWarnings("unchecked")
+    /**
+     * Accumulate new element
+     * 
+     * @param t element to accumulate
+     * 
+     * @return false if the element is definitely not included into result, so
+     *         any bigger element could be skipped as well, or true if element
+     *         will probably be included into result.
+     */
     public boolean put(T t) {
-        int limit = pq.length;
-        if (size < limit) {
-            pq[size++] = t;
+        if (initial) {
+            if (size == data.length) {
+                if (size < limit * 2) {
+                    @SuppressWarnings("unchecked")
+                    T[] newData = (T[]) new Object[Math.min(limit, size) * 2];
+                    System.arraycopy(data, 0, newData, 0, size);
+                    data = newData;
+                } else {
+                    Arrays.sort(data, comparator);
+                    initial = false;
+                    size = limit;
+                }
+                put(t);
+            } else {
+                data[size++] = t;
+            }
             return true;
         }
-        if (maxOrder == 0) {
-            Arrays.sort(pq, comparator);
-            Collections.reverse(Arrays.asList(pq));
-            maxOrder = limit;
+        if (size == data.length) {
+            sortTail();
         }
-        T[] s = series;
-        if (s != null && comparator.compare(t, s[head]) < 0) {
-            // prepend to the series possibly removing the biggest element
-            s[head = dec(head, limit)] = t;
-            if (head == tail)
-                tail = dec(tail, limit);
+        if (comparator.compare(t, data[limit - 1]) < 0) {
+            data[size++] = t;
             return true;
         }
-        if (comparator.compare(t, pq[0]) >= 0)
-            return false;
-        if (s == null) {
-            order = new int[limit];
-            for (int j = 0; j < limit; j++) {
-                order[j] = limit - j - 1;
-            }
-            series = (T[]) new Object[limit];
-            series[0] = t;
-            return true;
-        }
-        int next = inc(tail, limit);
-        if (head == tail) { // one element in the series
-            s[tail = next] = t;
-        } else {
-            if (comparator.compare(t, s[tail]) >= 0) {
-                // append to the series or ignore new element
-                if (next == head)
-                    return false;
-                s[tail = next] = t;
-            } else {
-                drain(s, limit);
-                s[head = tail = 0] = t;
-            }
-        }
-        return true;
+        return false;
     }
 
-    private void drain(T[] series, int limit) {
-        for (int i = head; putPQ(series[i], limit) && i != tail; i = inc(i, limit))
-            ;
-    }
-
-    private boolean putPQ(T t, int limit) {
-        if (comparator.compare(t, pq[0]) >= 0)
-            return false;
-        // sift-down
-        int mid = limit >>> 1, cmp = 0, k = 0;
-        while (k < mid) {
-            int child = (k << 1) + 1;
-            T c = pq[child];
-            int oc = order[child];
-            int right = child + 1;
-            if (right < limit && ((cmp = comparator.compare(c, pq[right])) < 0 || cmp == 0 && oc < order[right])) {
-                c = pq[child = right];
-                oc = order[child];
+    /**
+     * Merge other {@code Limiter} object into this (other object becomes unusable after that).
+     * 
+     * @param ls other object to merge
+     * @return this object
+     */
+    public Limiter<T> putAll(Limiter<T> ls) {
+        if (!ls.initial) {
+            for (int i = 0; i < limit; i++) {
+                if (!put(ls.data[i]))
+                    break;
             }
-            if (comparator.compare(t, c) >= 0)
-                break;
-            pq[k] = c;
-            order[k] = oc;
-            k = child;
-        }
-        pq[k] = t;
-        order[k] = maxOrder++;
-        return true;
-    }
-
-    public void sort() {
-        if (maxOrder == 0)
-            Arrays.sort(pq, 0, size, comparator);
-        else {
-            if (order == null) {
-                Collections.reverse(Arrays.asList(pq));
-            } else {
-                // Respect order also
-                quickSort(0, pq.length - 1);
-                merge();
+            for (int i = limit; i < ls.size; i++) {
+                put(ls.data[i]);
+            }
+        } else {
+            for (int i = 0; i < ls.size; i++) {
+                put(ls.data[i]);
             }
         }
-    }
-    
-    private int binSearch(int from, int to, T t) {
-        while (from <= to) {
-            int mid = (from + to) >>> 1;
-            if (comparator.compare(pq[mid], t) <= 0)
-                from = mid + 1;
-            else
-                to = mid - 1;
-        }
-        return from;
+        return this;
     }
 
-    private void merge() {
-        int j = head, limit = pq.length;
-        int start = binSearch(0, limit - 1, series[j]);
-        if(head == tail) {
-            if(start < limit) {
-                System.arraycopy(pq, start, pq, start+1, pq.length-start-1);
-                pq[start] = series[j];
-            }
-            return;
-        }
-        int end = binSearch(start, limit - 1, series[tail]);
-        int i = start;
-        for (int k = start; k < limit; k++) {
-            if (k != start && comparator.compare(series[j], pq[i]) >= 0) {
-                order[k] = i++;
-            } else {
-                order[k] = ~j;
-                j = inc(j, limit);
-                if (j == tail) {
-                    while (i < end && ++k < limit)
-                        order[k] = i++;
-                    if(++k < limit) {
-                        order[k] = ~j;
-                        while (++k < limit)
-                            order[k] = i++;
-                    }
-                    break;
+    private void sortTail() {
+        // size > limit here
+        T[] d = data;
+        int l = limit, s = size;
+        Comparator<? super T> cmp = comparator;
+        Arrays.sort(d, l, s, cmp);
+        if (cmp.compare(d[s - 1], d[0]) < 0) {
+            // Common case: descending sequence
+            // Assume size - limit <= limit here
+            System.arraycopy(d, 0, d, s - l, 2 * l - s);
+            System.arraycopy(d, l, d, 0, s - l);
+        } else {
+            // Merge presorted 0..limit-1 and limit..size-1
+            @SuppressWarnings("unchecked")
+            T[] buf = (T[]) new Object[l];
+            int i = 0, j = l, k = 0;
+            // d[l-1] is guaranteed to be the worst element, thus no need to
+            // check it
+            while (i < l - 1 && k < l && j < s) {
+                if (cmp.compare(d[i], d[j]) <= 0) {
+                    buf[k++] = d[i++];
+                } else {
+                    buf[k++] = d[j++];
                 }
             }
+            if (k < l) {
+                System.arraycopy(d, i < l - 1 ? i : j, d, k, l - k);
+            }
+            System.arraycopy(buf, 0, d, 0, k);
         }
-        for (int k = limit - 1; k >= start; k--) {
-            int o = order[k];
-            pq[k] = o >= 0 ? pq[o] : series[~o];
-        }
+        size = l;
     }
 
-    private void quickSort(int lowerIndex, int higherIndex) {
-        int i = lowerIndex;
-        int j = higherIndex;
-        int mid = lowerIndex + (higherIndex - lowerIndex) / 2;
-        T pivot = pq[mid];
-        int pivotOrder = order[mid];
-        int cmp;
-        while (i <= j) {
-            while ((cmp = comparator.compare(pq[i], pivot)) < 0 || cmp == 0 && order[i] < pivotOrder) {
-                i++;
-            }
-            while ((cmp = comparator.compare(pq[j], pivot)) > 0 || cmp == 0 && order[j] > pivotOrder) {
-                j--;
-            }
-            if (i <= j) {
-                int temp = order[i];
-                order[i] = order[j];
-                order[j] = temp;
-                T t = pq[i];
-                pq[i] = pq[j];
-                pq[j] = t;
-                i++;
-                j--;
-            }
-        }
-        if (lowerIndex < j)
-            quickSort(lowerIndex, j);
-        if (i < higherIndex)
-            quickSort(i, higherIndex);
+    /**
+     * Must be called after accumulation is finished. After calling
+     * {@code sort()} this Limiter represents the resulting collection.
+     */
+    public void sort() {
+        if (initial)
+            Arrays.sort(data, 0, size, comparator);
+        else if (size > limit)
+            sortTail();
     }
 
     @Override
-    public Iterator<T> iterator() {
-        return Arrays.asList(pq).subList(0, size).iterator();
+    public Object[] toArray() {
+        return Arrays.copyOfRange(data, 0, size());
     }
 
     @Override
-    public int size() {
-        return size;
+    public Iterator<T> iterator() {
+        return Arrays.asList(data).subList(0, size()).iterator();
     }
 
     @Override
-    public Object[] toArray() {
-        if (size == pq.length)
-            return pq;
-        return Arrays.copyOfRange(pq, 0, size);
+    public int size() {
+        return initial && size < limit ? size : limit;
     }
 }
diff --git a/src/main/java/one/util/streamex/LimiterSort.java b/src/main/java/one/util/streamex/LimiterSort.java
deleted file mode 100644
index 5c44330..0000000
--- a/src/main/java/one/util/streamex/LimiterSort.java
+++ /dev/null
@@ -1,169 +0,0 @@
-/*
- * Copyright 2015, 2016 Tagir Valeev
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package one.util.streamex;
-
-import java.util.AbstractCollection;
-import java.util.Arrays;
-import java.util.Comparator;
-import java.util.Iterator;
-
-/**
- * Extracts least limit elements from the input sorting them according to the
- * given comparator. Works for 2 <= limit < Integer.MAX_VALUE/2. Uses
- * O(min(limit, inputSize)) additional memory.
- * 
- * @param <T> type of input elements
- * 
- * @author Tagir Valeev
- */
-/* package */class LimiterSort<T> extends AbstractCollection<T> {
-    private T[] data;
-    private final int limit;
-    private final Comparator<? super T> comparator;
-    private int size;
-    private boolean initial = true;
-
-    @SuppressWarnings("unchecked")
-    public LimiterSort(int limit, Comparator<? super T> comparator) {
-        this.limit = limit;
-        this.comparator = comparator;
-        this.data = (T[]) new Object[Math.min(1000, limit) * 2];
-    }
-
-    /**
-     * Accumulate new element
-     * 
-     * @param t element to accumulate
-     * 
-     * @return false if the element is definitely not included into result, so
-     *         any bigger element could be skipped as well, or true if element
-     *         will probably be included into result.
-     */
-    public boolean put(T t) {
-        if (initial) {
-            if (size == data.length) {
-                if (size < limit * 2) {
-                    @SuppressWarnings("unchecked")
-                    T[] newData = (T[]) new Object[Math.min(limit, size) * 2];
-                    System.arraycopy(data, 0, newData, 0, size);
-                    data = newData;
-                } else {
-                    Arrays.sort(data, comparator);
-                    initial = false;
-                    size = limit;
-                }
-                put(t);
-            } else {
-                data[size++] = t;
-            }
-            return true;
-        }
-        if (size == data.length) {
-            sortTail();
-        }
-        if (comparator.compare(t, data[limit - 1]) < 0) {
-            data[size++] = t;
-            return true;
-        }
-        return false;
-    }
-
-    /**
-     * Merge other {@code LimiterSort} object into this (other object becomes unusable after that).
-     * 
-     * @param ls other object to merge
-     * @return this object
-     */
-    public LimiterSort<T> putAll(LimiterSort<T> ls) {
-        if (!ls.initial) {
-            for (int i = 0; i < limit; i++) {
-                if (!put(ls.data[i]))
-                    break;
-            }
-            for (int i = limit; i < ls.size; i++) {
-                put(ls.data[i]);
-            }
-        } else {
-            for (int i = 0; i < ls.size; i++) {
-                put(ls.data[i]);
-            }
-        }
-        return this;
-    }
-
-    private void sortTail() {
-        // size > limit here
-        T[] d = data;
-        int l = limit, s = size;
-        Comparator<? super T> cmp = comparator;
-        Arrays.sort(d, l, s, cmp);
-        if (cmp.compare(d[s - 1], d[0]) < 0) {
-            // Common case: descending sequence
-            // Assume size - limit <= limit here
-            System.arraycopy(d, 0, d, s - l, 2 * l - s);
-            System.arraycopy(d, l, d, 0, s - l);
-        } else {
-            // Merge presorted 0..limit-1 and limit..size-1
-            @SuppressWarnings("unchecked")
-            T[] buf = (T[]) new Object[l];
-            int i = 0, j = l, k = 0;
-            // d[l-1] is guaranteed to be the worst element, thus no need to
-            // check it
-            while (i < l - 1 && k < l && j < s) {
-                if (cmp.compare(d[i], d[j]) <= 0) {
-                    buf[k++] = d[i++];
-                } else {
-                    buf[k++] = d[j++];
-                }
-            }
-            if (k < l) {
-                if (i < l - 1) {
-                    System.arraycopy(d, i, d, k, l - k);
-                } else { // j < s
-                    System.arraycopy(d, j, d, k, l - k);
-                }
-            }
-            System.arraycopy(buf, 0, d, 0, k);
-        }
-        size = l;
-    }
-
-    /**
-     * Must be called after accumulation is finished. After calling
-     * {@code sort()} this LimiterSort represents the resulting collection.
-     */
-    public void sort() {
-        if (initial)
-            Arrays.sort(data, 0, size, comparator);
-        else if (size > limit)
-            sortTail();
-    }
-
-    @Override
-    public Object[] toArray() {
-        return Arrays.copyOfRange(data, 0, size());
-    }
-
-    @Override
-    public Iterator<T> iterator() {
-        return Arrays.asList(data).subList(0, size()).iterator();
-    }
-
-    @Override
-    public int size() {
-        return initial && size < limit ? size : limit;
-    }
-}
diff --git a/src/main/java/one/util/streamex/MoreCollectors.java b/src/main/java/one/util/streamex/MoreCollectors.java
index b2ad7f7..5334cbe 100644
--- a/src/main/java/one/util/streamex/MoreCollectors.java
+++ b/src/main/java/one/util/streamex/MoreCollectors.java
@@ -592,13 +592,14 @@ public final class MoreCollectors {
      * Returns a {@code Collector} which collects at most specified number of
      * the greatest stream elements according to the specified
      * {@link Comparator} into the {@link List}. The resulting {@code List} is
-     * sorted in comparator reverse order (greatest element is the first).
+     * sorted in comparator reverse order (greatest element is the first). The
+     * order of equal elements is the same as in the input stream.
      * 
      * <p>
      * The operation performed by the returned collector is equivalent to
      * {@code stream.sorted(comparator.reversed()).limit(n).collect(Collectors.toList())}
-     * , but can be performed much faster if the input is not sorted and
-     * {@code n} is much less than the stream size.
+     * , but usually performed much faster if {@code n} is much less than the
+     * stream size.
      * 
      * <p>
      * There are no guarantees on the type, mutability, serializability, or
@@ -623,13 +624,14 @@ public final class MoreCollectors {
      * Returns a {@code Collector} which collects at most specified number of
      * the greatest stream elements according to the natural order into the
      * {@link List}. The resulting {@code List} is sorted in reverse order
-     * (greatest element is the first).
+     * (greatest element is the first). The order of equal elements is the same
+     * as in the input stream.
      * 
      * <p>
      * The operation performed by the returned collector is equivalent to
      * {@code stream.sorted(Comparator.reverseOrder()).limit(n).collect(Collectors.toList())}
-     * , but can be performed much faster if the input is not sorted and
-     * {@code n} is much less than the stream size.
+     * , but usually performed much faster if {@code n} is much less than the
+     * stream size.
      * 
      * <p>
      * There are no guarantees on the type, mutability, serializability, or
@@ -653,13 +655,14 @@ public final class MoreCollectors {
      * Returns a {@code Collector} which collects at most specified number of
      * the least stream elements according to the specified {@link Comparator}
      * into the {@link List}. The resulting {@code List} is sorted in comparator
-     * order (least element is the first).
+     * order (least element is the first). The order of equal elements is the
+     * same as in the input stream.
      * 
      * <p>
      * The operation performed by the returned collector is equivalent to
      * {@code stream.sorted(comparator).limit(n).collect(Collectors.toList())},
-     * but can be performed much faster if the input is not sorted and {@code n}
-     * is much less than the stream size.
+     * but usually performed much faster if {@code n} is much less than the
+     * stream size.
      * 
      * <p>
      * There are no guarantees on the type, mutability, serializability, or
@@ -686,31 +689,32 @@ public final class MoreCollectors {
             }, (box1, box2) -> (box2.a != NONE && (box1.a == NONE || comparator.compare(box2.a, box1.a) < 0)) ? box2
                     : box1, box -> box.a == NONE ? new ArrayList<>() : new ArrayList<>(Collections.singleton(box.a)));
         }
-        if (n >= Integer.MAX_VALUE/2)
+        if (n >= Integer.MAX_VALUE / 2)
             return collectingAndThen(Collectors.toList(), list -> {
                 list.sort(comparator);
                 if (list.size() <= n)
                     return list;
                 return new ArrayList<>(list.subList(0, n));
             });
-        return Collector.<T, LimiterSort<T>, List<T>> of(() -> new LimiterSort<>(n, comparator), LimiterSort::put, 
-            LimiterSort::putAll, pq -> {
-            pq.sort();
-            return new ArrayList<>(pq);
-        });
+        return Collector.<T, Limiter<T>, List<T>> of(() -> new Limiter<>(n, comparator), Limiter::put, Limiter::putAll,
+            pq -> {
+                pq.sort();
+                return new ArrayList<>(pq);
+            });
     }
 
     /**
      * Returns a {@code Collector} which collects at most specified number of
      * the least stream elements according to the natural order into the
      * {@link List}. The resulting {@code List} is sorted in natural order
-     * (least element is the first).
+     * (least element is the first). The order of equal elements is the same as
+     * in the input stream.
      * 
      * <p>
      * The operation performed by the returned collector is equivalent to
-     * {@code stream.sorted().limit(n).collect(Collectors.toList())}, but can be
-     * performed much faster if the input is not sorted and {@code n} is much
-     * less than the stream size.
+     * {@code stream.sorted().limit(n).collect(Collectors.toList())}, but
+     * usually performed much faster if {@code n} is much less than the stream
+     * size.
      * 
      * <p>
      * There are no guarantees on the type, mutability, serializability, or
