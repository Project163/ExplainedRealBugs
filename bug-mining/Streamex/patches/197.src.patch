diff --git a/src/main/java/one/util/streamex/StreamEx.java b/src/main/java/one/util/streamex/StreamEx.java
index 8410306..1e41031 100644
--- a/src/main/java/one/util/streamex/StreamEx.java
+++ b/src/main/java/one/util/streamex/StreamEx.java
@@ -2616,8 +2616,8 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see #ofTree(Object, Class, Function)
      */
     public static <T> StreamEx<T> ofTree(T root, Function<T, Stream<T>> mapper) {
-        Stream<T> rootStream = mapper.apply(root);
-        return rootStream == null ? of(root) : flatTraverse(rootStream, mapper).prepend(root);
+        TreeSpliterator<T> spliterator = new TreeSpliterator<>(root, mapper);
+        return new StreamEx<>(spliterator, StreamContext.SEQUENTIAL.onClose(spliterator::close));
     }
 
     /**
diff --git a/src/main/java/one/util/streamex/TreeSpliterator.java b/src/main/java/one/util/streamex/TreeSpliterator.java
new file mode 100644
index 0000000..0a8047d
--- /dev/null
+++ b/src/main/java/one/util/streamex/TreeSpliterator.java
@@ -0,0 +1,141 @@
+/*
+ * Copyright 2015, 2016 Tagir Valeev
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package one.util.streamex;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Spliterator;
+import java.util.function.Consumer;
+import java.util.function.Function;
+import java.util.stream.Stream;
+
+import one.util.streamex.StreamExInternals.PairBox;
+
+/**
+ * @author Tagir Valeev
+ *
+ */
+/* package */ class TreeSpliterator<T> implements Spliterator<T>, Consumer<T> {
+    private T cur;
+    private ArrayList<PairBox<Spliterator<T>, Stream<T>>> spliterators; 
+    private final Function<T, Stream<T>> mapper;
+
+    TreeSpliterator(T root, Function<T, Stream<T>> mapper) {
+        this.cur = root;
+        this.mapper = mapper;
+    }
+
+    @Override
+    public boolean tryAdvance(Consumer<? super T> action) {
+        List<PairBox<Spliterator<T>, Stream<T>>> spltrs = spliterators;
+        if(spltrs == null) {
+            spliterators = new ArrayList<>();
+            return processOne(action);
+        }
+        int lastIdx = spltrs.size()-1;
+        while(lastIdx >= 0) {
+            PairBox<Spliterator<T>, Stream<T>> pair = spltrs.get(lastIdx);
+            Spliterator<T> spltr = pair.a;
+            if(spltr.tryAdvance(this)) {
+                return processOne(action);
+            }
+            pair.b.close();
+            spltrs.remove(lastIdx--);
+        }
+        return false;
+    }
+
+    private boolean processOne(Consumer<? super T> action) {
+        T e = this.cur;
+        action.accept(e);
+        Stream<T> stream = mapper.apply(e);
+        if(stream != null) {
+            spliterators.add(new PairBox<>(stream.spliterator(), stream));
+        }
+        return true;
+    }
+
+    @Override
+    public Spliterator<T> trySplit() {
+        // TODO Auto-generated method stub
+        return null;
+    }
+    
+    static class Acceptor<T> implements Consumer<T> {
+        private final Consumer<? super T> action;
+        private final Function<T, Stream<T>> mapper;
+        
+        public Acceptor(Consumer<? super T> action, Function<T, Stream<T>> mapper) {
+            super();
+            this.action = action;
+            this.mapper = mapper;
+        }
+
+        @Override
+        public void accept(T t) {
+            action.accept(t);
+            try(Stream<T> stream = mapper.apply(t)) {
+                if(stream != null) {
+                    stream.spliterator().forEachRemaining(this);
+                }
+            }
+        }
+    }
+    
+    @Override
+    public void forEachRemaining(Consumer<? super T> action) {
+        if(spliterators != null) {
+            Spliterator.super.forEachRemaining(action);
+        } else {
+            new Acceptor<>(action, mapper).accept(cur);
+        }
+    }
+
+    @Override
+    public long estimateSize() {
+        return Long.MAX_VALUE;
+    }
+
+    @Override
+    public int characteristics() {
+        return ORDERED;
+    }
+
+    @Override
+    public void accept(T t) {
+        cur = t;
+    }
+    
+    void close() {
+        if(spliterators != null) {
+            Throwable t = null;
+            for(int i=spliterators.size()-1; i>=0; i--) {
+                try {
+                    spliterators.get(i).b.close();
+                } catch (Error | RuntimeException e) {
+                    if(t == null)
+                        t = e;
+                    else
+                        t.addSuppressed(e);
+                }
+            }
+            if(t instanceof RuntimeException)
+                throw (RuntimeException)t;
+            if(t instanceof Error)
+                throw (Error)t;
+        }
+    }
+}
diff --git a/src/test/java/one/util/streamex/StreamExTest.java b/src/test/java/one/util/streamex/StreamExTest.java
index d1fe4ae..21344f4 100644
--- a/src/test/java/one/util/streamex/StreamExTest.java
+++ b/src/test/java/one/util/streamex/StreamExTest.java
@@ -55,6 +55,7 @@ import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.BinaryOperator;
+import java.util.function.Consumer;
 import java.util.function.Function;
 import java.util.function.IntPredicate;
 import java.util.function.Predicate;
@@ -68,6 +69,7 @@ import java.util.stream.Stream;
 import one.util.streamex.IntStreamEx;
 import one.util.streamex.MoreCollectors;
 import one.util.streamex.StreamEx;
+
 import org.junit.FixMethodOrder;
 import org.junit.Rule;
 import org.junit.Test;
@@ -963,8 +965,59 @@ public class StreamExTest {
         r.add(new CompositeNode("childA").add(new TreeNode("grandA1")).add(new TreeNode("grandA2")));
         r.add(new CompositeNode("childB").add(new TreeNode("grandB1")));
         r.add(new TreeNode("childC"));
-        assertEquals("root,childA,grandA1,grandA2,childB,grandB1,childC", r.flatStream().joining(","));
-        assertEquals("root,childA,grandA1,grandA2,childB,grandB1,childC", r.flatStream().parallel().joining(","));
+        
+        streamEx(r::flatStream, s -> {
+            assertEquals("root,childA,grandA1,grandA2,childB,grandB1,childC", s.get().joining(","));
+            assertEquals(Optional.of("grandB1"), s.get().findFirst(tn -> tn.title.contains("B1")).map(tn -> tn.title));
+            assertEquals(Optional.empty(), s.get().findFirst(tn -> tn.title.contains("C1")).map(tn -> tn.title));
+        });
+        
+        List<Consumer<StreamEx<TreeNode>>> tests = Arrays.<Consumer<StreamEx<TreeNode>>>asList(
+            stream -> assertEquals(Optional.empty(), stream.findFirst(tn -> tn.title.contains("abc"))),
+            stream -> assertEquals(Optional.of("grandB1"), stream.findFirst(tn -> tn.title.contains("B1")).map(tn -> tn.title)),
+            stream -> assertEquals(7, stream.count())
+            );
+        for(Consumer<StreamEx<TreeNode>> test : tests) {
+            Set<String> set = new HashSet<>();
+            try(StreamEx<TreeNode> closableTree = StreamEx.ofTree(r, CompositeNode.class, cn -> cn.elements().onClose(
+                () -> set.add(cn.title)))) {
+                test.accept(closableTree);
+            }
+            assertEquals(set, StreamEx.of("root", "childA", "childB").toSet());
+            boolean catched = false;
+            try (StreamEx<TreeNode> closableTree = StreamEx.ofTree(r, CompositeNode.class, cn -> cn.elements().onClose(
+                () -> {
+                    if (!cn.title.equals("childA"))
+                        throw new IllegalArgumentException(cn.title);
+                }))) {
+                test.accept(closableTree);
+            }
+            catch(IllegalArgumentException ex) {
+                catched = true;
+                assertEquals("childB", ex.getMessage());
+                assertEquals(1, ex.getSuppressed().length);
+                assertTrue(ex.getSuppressed()[0] instanceof IllegalArgumentException);
+                assertEquals("root", ex.getSuppressed()[0].getMessage());
+            }
+            assertTrue(catched);
+
+            catched = false;
+            try (StreamEx<TreeNode> closableTree = StreamEx.ofTree(r, CompositeNode.class, cn -> cn.elements().onClose(
+                () -> {
+                    if (!cn.title.equals("childA"))
+                        throw new InternalError(cn.title);
+                }))) {
+                test.accept(closableTree);
+            }
+            catch(InternalError ex) {
+                catched = true;
+                assertEquals("childB", ex.getMessage());
+                assertEquals(1, ex.getSuppressed().length);
+                assertTrue(ex.getSuppressed()[0] instanceof InternalError);
+                assertEquals("root", ex.getSuppressed()[0].getMessage());
+            }
+            assertTrue(catched);
+        }
 
         streamEx(() -> StreamEx.ofTree("", (String str) -> str.length() >= 3 ? null : Stream.of("a", "b").map(
             str::concat)), supplier -> {
