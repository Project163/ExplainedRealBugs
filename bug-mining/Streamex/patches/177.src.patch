diff --git a/CHANGES.md b/CHANGES.md
index 59dc058..0ec4bd5 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -6,6 +6,7 @@
 * [#70] Optimized: `MoreCollectors.least()/greatest()` is usually faster now, especially when the selected elements are close to the stream end.
 * [#74] Added: `EntryStream.removeKeyValue()`.
 * [#77] Added: `MoreCollectors.filtering()/mapping()/flatMapping()` with default downstream Collector `toList()`.
+* [#79] Added: `iterate(seed, predicate, op)` for all stream types.
 * [#83] Changed: `StreamEx.of(Collection)`, `of(Iterator)`, etc. now use `? extends T` type instead of just `T`.
 
 
diff --git a/CHEATSHEET.md b/CHEATSHEET.md
index c123717..844f9c6 100644
--- a/CHEATSHEET.md
+++ b/CHEATSHEET.md
@@ -43,6 +43,7 @@ Stream of `byte[]`, `char[]`, `short[]` array | `IntStreamEx.of()`
 Stream of `float[]` array | `DoubleStreamEx.of()`
 Infinite Stream from `Supplier` | `any.generate()`
 Infinite Stream using iterative function | `any.iterate()`
+Convert three-argument for loop to Stream | `any.iterate()`
 Fixed length Stream of constant elements | `any.constant()`
 Stream of array or `List` with indices | `EntryStream.of()`
 Stream of single value or empty if null supplied | `StreamEx.ofNullable()`
diff --git a/src/main/java/one/util/streamex/DoubleStreamEx.java b/src/main/java/one/util/streamex/DoubleStreamEx.java
index a21a01d..7a19055 100644
--- a/src/main/java/one/util/streamex/DoubleStreamEx.java
+++ b/src/main/java/one/util/streamex/DoubleStreamEx.java
@@ -1755,10 +1755,86 @@ public class DoubleStreamEx extends BaseStreamEx<Double, DoubleStream, Spliterat
      * @param f a function to be applied to to the previous element to produce a
      *        new element
      * @return A new sequential {@code DoubleStream}
-     * @see DoubleStream#iterate(double, DoubleUnaryOperator)
+     * @see #iterate(double, DoublePredicate, DoubleUnaryOperator)
      */
     public static DoubleStreamEx iterate(final double seed, final DoubleUnaryOperator f) {
-        return seq(DoubleStream.iterate(seed, f));
+        return iterate(seed, x -> true, f);
+    }
+
+    /**
+     * Returns a sequential ordered {@code DoubleStreamEx} produced by iterative
+     * application of a function to an initial element, conditioned on
+     * satisfying the supplied predicate. The stream terminates as soon as the
+     * predicate function returns false.
+     *
+     * <p>
+     * {@code DoubleStreamEx.iterate} should produce the same sequence of
+     * elements as produced by the corresponding for-loop:
+     * 
+     * <pre>{@code
+     *     for (double index=seed; predicate.test(index); index = f.apply(index)) {
+     *         ... 
+     *     }
+     * }</pre>
+     *
+     * <p>
+     * The resulting sequence may be empty if the predicate does not hold on the
+     * seed value. Otherwise the first element will be the supplied seed value,
+     * the next element (if present) will be the result of applying the function
+     * f to the seed value, and so on iteratively until the predicate indicates
+     * that the stream should terminate.
+     *
+     * @param seed the initial element
+     * @param predicate a predicate to apply to elements to determine when the
+     *        stream must terminate.
+     * @param f a function to be applied to the previous element to produce a
+     *        new element
+     * @return a new sequential {@code DoubleStreamEx}
+     * @see #iterate(double, DoubleUnaryOperator)
+     * @since 0.6.0
+     */
+    public static DoubleStreamEx iterate(double seed, DoublePredicate predicate, DoubleUnaryOperator f) {
+        Objects.requireNonNull(f);
+        Objects.requireNonNull(predicate);
+        Spliterator.OfDouble spliterator = new Spliterators.AbstractDoubleSpliterator(Long.MAX_VALUE,
+                Spliterator.ORDERED | Spliterator.IMMUTABLE | Spliterator.NONNULL) {
+            double prev;
+            boolean started, finished;
+
+            @Override
+            public boolean tryAdvance(DoubleConsumer action) {
+                Objects.requireNonNull(action);
+                if (finished)
+                    return false;
+                double t;
+                if (started)
+                    t = f.applyAsDouble(prev);
+                else {
+                    t = seed;
+                    started = true;
+                }
+                if (!predicate.test(t)) {
+                    finished = true;
+                    return false;
+                }
+                action.accept(prev = t);
+                return true;
+            }
+
+            @Override
+            public void forEachRemaining(DoubleConsumer action) {
+                Objects.requireNonNull(action);
+                if (finished)
+                    return;
+                finished = true;
+                double t = started ? f.applyAsDouble(prev) : seed;
+                while (predicate.test(t)) {
+                    action.accept(t);
+                    t = f.applyAsDouble(t);
+                }
+            }
+        };
+        return of(spliterator);
     }
 
     /**
@@ -1804,15 +1880,16 @@ public class DoubleStreamEx extends BaseStreamEx<Double, DoubleStream, Spliterat
         return of(new RangeBasedSpliterator.ZipDouble(0, checkLength(first.length, second.length), mapper, first,
                 second));
     }
-    
+
     /**
      * A helper interface to build a new stream by emitting elements and
      * creating new emitters in a chain.
      * 
      * <p>
      * Using this interface it's possible to create custom sources which cannot
-     * be easily expressed using {@link DoubleStreamEx#iterate(double, DoubleUnaryOperator)}
-     * or {@link DoubleStreamEx#generate(DoubleSupplier)}.
+     * be easily expressed using
+     * {@link DoubleStreamEx#iterate(double, DoubleUnaryOperator)} or
+     * {@link DoubleStreamEx#generate(DoubleSupplier)}.
      * 
      * @author Tagir Valeev
      *
@@ -1822,8 +1899,8 @@ public class DoubleStreamEx extends BaseStreamEx<Double, DoubleStream, Spliterat
     public interface DoubleEmitter {
         /**
          * Calls the supplied consumer zero or more times to emit some elements,
-         * then returns the next emitter which will emit more, or null if nothing
-         * more to emit.
+         * then returns the next emitter which will emit more, or null if
+         * nothing more to emit.
          * 
          * <p>
          * It's allowed not to emit anything (don't call the consumer). However
diff --git a/src/main/java/one/util/streamex/IntStreamEx.java b/src/main/java/one/util/streamex/IntStreamEx.java
index f2a552f..6548f47 100644
--- a/src/main/java/one/util/streamex/IntStreamEx.java
+++ b/src/main/java/one/util/streamex/IntStreamEx.java
@@ -2265,10 +2265,86 @@ public class IntStreamEx extends BaseStreamEx<Integer, IntStream, Spliterator.Of
      * @param f a function to be applied to to the previous element to produce a
      *        new element
      * @return A new sequential {@code IntStream}
-     * @see IntStream#iterate(int, IntUnaryOperator)
+     * @see #iterate(int, IntPredicate, IntUnaryOperator)
      */
     public static IntStreamEx iterate(final int seed, final IntUnaryOperator f) {
-        return seq(IntStream.iterate(seed, f));
+        return iterate(seed, x -> true, f);
+    }
+
+    /**
+     * Returns a sequential ordered {@code IntStreamEx} produced by iterative
+     * application of a function to an initial element, conditioned on
+     * satisfying the supplied predicate. The stream terminates as soon as the
+     * predicate function returns false.
+     *
+     * <p>
+     * {@code IntStreamEx.iterate} should produce the same sequence of elements
+     * as produced by the corresponding for-loop:
+     * 
+     * <pre>{@code
+     *     for (int index=seed; predicate.test(index); index = f.apply(index)) { 
+     *         ... 
+     *     }
+     * }</pre>
+     *
+     * <p>
+     * The resulting sequence may be empty if the predicate does not hold on the
+     * seed value. Otherwise the first element will be the supplied seed value,
+     * the next element (if present) will be the result of applying the function
+     * f to the seed value, and so on iteratively until the predicate indicates
+     * that the stream should terminate.
+     *
+     * @param seed the initial element
+     * @param predicate a predicate to apply to elements to determine when the
+     *        stream must terminate.
+     * @param f a function to be applied to the previous element to produce a
+     *        new element
+     * @return a new sequential {@code IntStreamEx}
+     * @see #iterate(int, IntUnaryOperator)
+     * @since 0.6.0
+     */
+    public static IntStreamEx iterate(int seed, IntPredicate predicate, IntUnaryOperator f) {
+        Objects.requireNonNull(f);
+        Objects.requireNonNull(predicate);
+        Spliterator.OfInt spliterator = new Spliterators.AbstractIntSpliterator(Long.MAX_VALUE, Spliterator.ORDERED
+            | Spliterator.IMMUTABLE | Spliterator.NONNULL) {
+            int prev;
+            boolean started, finished;
+
+            @Override
+            public boolean tryAdvance(IntConsumer action) {
+                Objects.requireNonNull(action);
+                if (finished)
+                    return false;
+                int t;
+                if (started)
+                    t = f.applyAsInt(prev);
+                else {
+                    t = seed;
+                    started = true;
+                }
+                if (!predicate.test(t)) {
+                    finished = true;
+                    return false;
+                }
+                action.accept(prev = t);
+                return true;
+            }
+
+            @Override
+            public void forEachRemaining(IntConsumer action) {
+                Objects.requireNonNull(action);
+                if (finished)
+                    return;
+                finished = true;
+                int t = started ? f.applyAsInt(prev) : seed;
+                while (predicate.test(t)) {
+                    action.accept(t);
+                    t = f.applyAsInt(t);
+                }
+            }
+        };
+        return of(spliterator);
     }
 
     /**
@@ -2283,10 +2359,11 @@ public class IntStreamEx extends BaseStreamEx<Integer, IntStream, Spliterator.Of
     public static IntStreamEx generate(IntSupplier s) {
         return seq(IntStream.generate(s));
     }
-    
+
     /**
      * Returns a sequential ordered {@code IntStreamEx} from 0 (inclusive) to
-     * {@code Integer.MAX_VALUE} (exclusive) by an incremental step of {@code 1}.
+     * {@code Integer.MAX_VALUE} (exclusive) by an incremental step of {@code 1}
+     * .
      *
      * @return a sequential {@code IntStreamEx} for the range of {@code int}
      *         elements
@@ -2435,16 +2512,17 @@ public class IntStreamEx extends BaseStreamEx<Integer, IntStream, Spliterator.Of
     public static IntStreamEx zip(int[] first, int[] second, IntBinaryOperator mapper) {
         return of(new RangeBasedSpliterator.ZipInt(0, checkLength(first.length, second.length), mapper, first, second));
     }
-    
+
     /**
      * A helper interface to build a new stream by emitting elements and
      * creating new emitters in a chain.
      * 
      * <p>
      * Using this interface it's possible to create custom sources which cannot
-     * be easily expressed using {@link IntStreamEx#iterate(int, IntUnaryOperator)}
-     * or {@link IntStreamEx#generate(IntSupplier)}. For example, the following method
-     * generates a Collatz sequence starting from given number:
+     * be easily expressed using
+     * {@link IntStreamEx#iterate(int, IntUnaryOperator)} or
+     * {@link IntStreamEx#generate(IntSupplier)}. For example, the following
+     * method generates a Collatz sequence starting from given number:
      * 
      * <pre>{@code
      * public static IntEmitter collatz(int start) {
@@ -2455,7 +2533,8 @@ public class IntStreamEx extends BaseStreamEx<Integer, IntStream, Spliterator.Of
      * }}</pre>
      * 
      * <p>
-     * Now you can use {@code collatz(17).stream()} to get the stream of Collatz numbers.
+     * Now you can use {@code collatz(17).stream()} to get the stream of Collatz
+     * numbers.
      * 
      * @author Tagir Valeev
      *
@@ -2465,8 +2544,8 @@ public class IntStreamEx extends BaseStreamEx<Integer, IntStream, Spliterator.Of
     public interface IntEmitter {
         /**
          * Calls the supplied consumer zero or more times to emit some elements,
-         * then returns the next emitter which will emit more, or null if nothing
-         * more to emit.
+         * then returns the next emitter which will emit more, or null if
+         * nothing more to emit.
          * 
          * <p>
          * It's allowed not to emit anything (don't call the consumer). However
diff --git a/src/main/java/one/util/streamex/LongStreamEx.java b/src/main/java/one/util/streamex/LongStreamEx.java
index 2a61ed0..9ae0294 100644
--- a/src/main/java/one/util/streamex/LongStreamEx.java
+++ b/src/main/java/one/util/streamex/LongStreamEx.java
@@ -1779,10 +1779,86 @@ public class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterator.OfL
      * @param f a function to be applied to to the previous element to produce a
      *        new element
      * @return A new sequential {@code LongStream}
-     * @see LongStream#iterate(long, LongUnaryOperator)
+     * @see #iterate(long, LongPredicate, LongUnaryOperator)
      */
     public static LongStreamEx iterate(final long seed, final LongUnaryOperator f) {
-        return seq(LongStream.iterate(seed, f));
+        return iterate(seed, x -> true, f);
+    }
+
+    /**
+     * Returns a sequential ordered {@code LongStreamEx} produced by iterative
+     * application of a function to an initial element, conditioned on
+     * satisfying the supplied predicate. The stream terminates as soon as the
+     * predicate function returns false.
+     *
+     * <p>
+     * {@code LongStreamEx.iterate} should produce the same sequence of elements
+     * as produced by the corresponding for-loop:
+     * 
+     * <pre>{@code
+     *     for (long index=seed; predicate.test(index); index = f.apply(index)) { 
+     *         ... 
+     *     }
+     * }</pre>
+     *
+     * <p>
+     * The resulting sequence may be empty if the predicate does not hold on the
+     * seed value. Otherwise the first element will be the supplied seed value,
+     * the next element (if present) will be the result of applying the function
+     * f to the seed value, and so on iteratively until the predicate indicates
+     * that the stream should terminate.
+     *
+     * @param seed the initial element
+     * @param predicate a predicate to apply to elements to determine when the
+     *        stream must terminate.
+     * @param f a function to be applied to the previous element to produce a
+     *        new element
+     * @return a new sequential {@code LongStreamEx}
+     * @see #iterate(long, LongUnaryOperator)
+     * @since 0.6.0
+     */
+    public static LongStreamEx iterate(long seed, LongPredicate predicate, LongUnaryOperator f) {
+        Objects.requireNonNull(f);
+        Objects.requireNonNull(predicate);
+        Spliterator.OfLong spliterator = new Spliterators.AbstractLongSpliterator(Long.MAX_VALUE, Spliterator.ORDERED
+            | Spliterator.IMMUTABLE | Spliterator.NONNULL) {
+            long prev;
+            boolean started, finished;
+
+            @Override
+            public boolean tryAdvance(LongConsumer action) {
+                Objects.requireNonNull(action);
+                if (finished)
+                    return false;
+                long t;
+                if (started)
+                    t = f.applyAsLong(prev);
+                else {
+                    t = seed;
+                    started = true;
+                }
+                if (!predicate.test(t)) {
+                    finished = true;
+                    return false;
+                }
+                action.accept(prev = t);
+                return true;
+            }
+
+            @Override
+            public void forEachRemaining(LongConsumer action) {
+                Objects.requireNonNull(action);
+                if (finished)
+                    return;
+                finished = true;
+                long t = started ? f.applyAsLong(prev) : seed;
+                while (predicate.test(t)) {
+                    action.accept(t);
+                    t = f.applyAsLong(t);
+                }
+            }
+        };
+        return of(spliterator);
     }
 
     /**
@@ -1956,9 +2032,10 @@ public class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterator.OfL
      * 
      * <p>
      * Using this interface it's possible to create custom sources which cannot
-     * be easily expressed using {@link LongStreamEx#iterate(long, LongUnaryOperator)}
-     * or {@link LongStreamEx#generate(LongSupplier)}. For example, the following method
-     * generates a Collatz sequence starting from given number:
+     * be easily expressed using
+     * {@link LongStreamEx#iterate(long, LongUnaryOperator)} or
+     * {@link LongStreamEx#generate(LongSupplier)}. For example, the following
+     * method generates a Collatz sequence starting from given number:
      * 
      * <pre>{@code
      * public static LongEmitter collatz(long start) {
@@ -1969,7 +2046,8 @@ public class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterator.OfL
      * }}</pre>
      * 
      * <p>
-     * Now you can use {@code collatz(17).stream()} to get the stream of Collatz numbers.
+     * Now you can use {@code collatz(17).stream()} to get the stream of Collatz
+     * numbers.
      * 
      * @author Tagir Valeev
      *
@@ -1979,8 +2057,8 @@ public class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterator.OfL
     public interface LongEmitter {
         /**
          * Calls the supplied consumer zero or more times to emit some elements,
-         * then returns the next emitter which will emit more, or null if nothing
-         * more to emit.
+         * then returns the next emitter which will emit more, or null if
+         * nothing more to emit.
          * 
          * <p>
          * It's allowed not to emit anything (don't call the consumer). However
diff --git a/src/main/java/one/util/streamex/StreamEx.java b/src/main/java/one/util/streamex/StreamEx.java
index 561fa8a..3a62d9e 100644
--- a/src/main/java/one/util/streamex/StreamEx.java
+++ b/src/main/java/one/util/streamex/StreamEx.java
@@ -102,7 +102,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
                 spliterator());
         return new StreamEx<>(spliterator, context);
     }
-    
+
     private static <T> StreamEx<T> flatTraverse(Stream<T> src, Function<T, Stream<T>> streamProvider) {
         return StreamEx.of(src).flatMap(t -> {
             Stream<T> result = streamProvider.apply(t);
@@ -2185,10 +2185,89 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @param f a function to be applied to to the previous element to produce a
      *        new element
      * @return a new sequential {@code StreamEx}
-     * @see Stream#iterate(Object, UnaryOperator)
+     * @see #iterate(Object, Predicate, UnaryOperator)
      */
     public static <T> StreamEx<T> iterate(final T seed, final UnaryOperator<T> f) {
-        return new StreamEx<>(Stream.iterate(seed, f), StreamContext.SEQUENTIAL);
+        return iterate(seed, x -> true, f);
+    }
+
+    /**
+     * Returns a sequential ordered {@code StreamEx} produced by iterative
+     * application of a function to an initial element, conditioned on
+     * satisfying the supplied predicate. The stream terminates as soon as the
+     * predicate function returns false.
+     *
+     * <p>
+     * {@code StreamEx.iterate} should produce the same sequence of elements as
+     * produced by the corresponding for-loop:
+     * 
+     * <pre>{@code
+     *     for (T index=seed; predicate.test(index); index = f.apply(index)) { 
+     *         ... 
+     *     }
+     * }</pre>
+     *
+     * <p>
+     * The resulting sequence may be empty if the predicate does not hold on the
+     * seed value. Otherwise the first element will be the supplied seed value,
+     * the next element (if present) will be the result of applying the function
+     * f to the seed value, and so on iteratively until the predicate indicates
+     * that the stream should terminate.
+     *
+     * @param <T> the type of stream elements
+     * @param seed the initial element
+     * @param predicate a predicate to apply to elements to determine when the
+     *        stream must terminate.
+     * @param f a function to be applied to the previous element to produce a
+     *        new element
+     * @return a new sequential {@code StreamEx}
+     * @see #iterate(Object, UnaryOperator)
+     * @since 0.6.0
+     */
+    public static <T> StreamEx<T> iterate(T seed, Predicate<? super T> predicate, UnaryOperator<T> f) {
+        Objects.requireNonNull(f);
+        Objects.requireNonNull(predicate);
+        Spliterator<T> spliterator = new Spliterators.AbstractSpliterator<T>(Long.MAX_VALUE, Spliterator.ORDERED
+            | Spliterator.IMMUTABLE) {
+            T prev;
+            boolean started, finished;
+
+            @Override
+            public boolean tryAdvance(Consumer<? super T> action) {
+                Objects.requireNonNull(action);
+                if (finished)
+                    return false;
+                T t;
+                if (started)
+                    t = f.apply(prev);
+                else {
+                    t = seed;
+                    started = true;
+                }
+                if (!predicate.test(t)) {
+                    prev = null;
+                    finished = true;
+                    return false;
+                }
+                action.accept(prev = t);
+                return true;
+            }
+
+            @Override
+            public void forEachRemaining(Consumer<? super T> action) {
+                Objects.requireNonNull(action);
+                if (finished)
+                    return;
+                finished = true;
+                T t = started ? f.apply(prev) : seed;
+                prev = null;
+                while (predicate.test(t)) {
+                    action.accept(t);
+                    t = f.apply(t);
+                }
+            }
+        };
+        return of(spliterator);
     }
 
     /**
@@ -2619,7 +2698,8 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * }}</pre>
      * 
      * <p>
-     * Now you can use {@code collatz(17).stream()} to get the stream of Collatz numbers.
+     * Now you can use {@code collatz(17).stream()} to get the stream of Collatz
+     * numbers.
      * 
      * @author Tagir Valeev
      *
@@ -2630,8 +2710,8 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
     public interface Emitter<T> {
         /**
          * Calls the supplied consumer zero or more times to emit some elements,
-         * then returns the next emitter which will emit more, or null if nothing
-         * more to emit.
+         * then returns the next emitter which will emit more, or null if
+         * nothing more to emit.
          * 
          * <p>
          * It's allowed not to emit anything (don't call the consumer). However
diff --git a/src/test/java/one/util/streamex/DoubleStreamExTest.java b/src/test/java/one/util/streamex/DoubleStreamExTest.java
index f995a97..ca1969e 100644
--- a/src/test/java/one/util/streamex/DoubleStreamExTest.java
+++ b/src/test/java/one/util/streamex/DoubleStreamExTest.java
@@ -38,6 +38,7 @@ import java.util.stream.DoubleStream.Builder;
 
 import org.junit.Test;
 
+import static one.util.streamex.TestHelpers.*;
 import static org.junit.Assert.*;
 
 public class DoubleStreamExTest {
@@ -81,6 +82,17 @@ public class DoubleStreamExTest {
         assertArrayEquals(new double[] { 2, 4, 6 }, DoubleStreamEx.of(new Double[] { 2.0, 4.0, 6.0 }).toArray(), 0.0);
     }
 
+    @Test
+    public void testIterate() {
+        assertArrayEquals(new double[] { 1, 2, 4, 8, 16 }, DoubleStreamEx.iterate(1, x -> x * 2).limit(5).toArray(),
+            0.0);
+        assertArrayEquals(new double[] { 1, 2, 4, 8, 16, 32, 64 }, DoubleStreamEx.iterate(1, x -> x < 100, x -> x * 2)
+                .toArray(), 0.0);
+        assertEquals(0, DoubleStreamEx.iterate(0, x -> x < 0, x -> 1 / x).count());
+        assertFalse(DoubleStreamEx.iterate(1, x -> x < 100, x -> x * 2).findFirst(x -> x == 10).isPresent());
+        checkSpliterator("iterate", () -> DoubleStreamEx.iterate(1, x -> x < 100, x -> x * 2).spliterator());
+    }
+
     @Test
     public void testBasics() {
         assertFalse(DoubleStreamEx.of(1).isParallel());
diff --git a/src/test/java/one/util/streamex/IntStreamExTest.java b/src/test/java/one/util/streamex/IntStreamExTest.java
index 313a7b8..56b8166 100644
--- a/src/test/java/one/util/streamex/IntStreamExTest.java
+++ b/src/test/java/one/util/streamex/IntStreamExTest.java
@@ -73,7 +73,6 @@ public class IntStreamExTest {
         assertArrayEquals(new int[] { 0, 1, 2 }, IntStreamEx.range(3).toArray());
         assertArrayEquals(new int[] { 1, 2, 3 }, IntStreamEx.range(1, 4).toArray());
         assertArrayEquals(new int[] { 1, 2, 3 }, IntStreamEx.rangeClosed(1, 3).toArray());
-        assertArrayEquals(new int[] { 1, 2, 4, 8, 16 }, IntStreamEx.iterate(1, x -> x * 2).limit(5).toArray());
         assertArrayEquals(new int[] { 1, 1, 1, 1 }, IntStreamEx.generate(() -> 1).limit(4).toArray());
         assertArrayEquals(new int[] { 1, 1, 1, 1 }, IntStreamEx.constant(1, 4).toArray());
         assertArrayEquals(new int[] { 'a', 'b', 'c' }, IntStreamEx.ofChars("abc").toArray());
@@ -104,6 +103,15 @@ public class IntStreamExTest {
         assertArrayEquals(new int[] { 2, 4, 6 }, IntStreamEx.of(new Integer[] { 2, 4, 6 }).toArray());
     }
     
+    @Test
+    public void testIterate() {
+        assertArrayEquals(new int[] { 1, 2, 4, 8, 16 }, IntStreamEx.iterate(1, x -> x * 2).limit(5).toArray());
+        assertArrayEquals(new int[] { 1, 2, 4, 8, 16, 32, 64 }, IntStreamEx.iterate(1, x -> x < 100, x -> x * 2).toArray());
+        assertEquals(0, IntStreamEx.iterate(0, x -> x < 0, x -> 1 / x).count());
+        assertFalse(IntStreamEx.iterate(1, x -> x < 100, x -> x * 2).has(10));
+        checkSpliterator("iterate", () -> IntStreamEx.iterate(1, x -> x < 100, x -> x * 2).spliterator());
+    }
+    
     @Test
     public void testInts() {
         assertEquals(Integer.MAX_VALUE, IntStreamEx.ints().spliterator().getExactSizeIfKnown());
diff --git a/src/test/java/one/util/streamex/LongStreamExTest.java b/src/test/java/one/util/streamex/LongStreamExTest.java
index 2b13cb2..af8a7ce 100644
--- a/src/test/java/one/util/streamex/LongStreamExTest.java
+++ b/src/test/java/one/util/streamex/LongStreamExTest.java
@@ -38,6 +38,7 @@ import java.util.stream.LongStream.Builder;
 
 import org.junit.Test;
 
+import static one.util.streamex.TestHelpers.*;
 import static org.junit.Assert.*;
 
 public class LongStreamExTest {
@@ -60,7 +61,6 @@ public class LongStreamExTest {
         assertArrayEquals(new long[] { 1, 2, 3 }, LongStreamEx.range(1L, 4L).toArray());
         assertArrayEquals(new long[] { 0, 1, 2 }, LongStreamEx.range(3L).toArray());
         assertArrayEquals(new long[] { 1, 2, 3 }, LongStreamEx.rangeClosed(1, 3).toArray());
-        assertArrayEquals(new long[] { 1, 2, 4, 8, 16 }, LongStreamEx.iterate(1, x -> x * 2).limit(5).toArray());
         assertArrayEquals(new long[] { 1, 1, 1, 1 }, LongStreamEx.generate(() -> 1).limit(4).toArray());
         assertArrayEquals(new long[] { 1, 1, 1, 1 }, LongStreamEx.constant(1L, 4).toArray());
         assertEquals(10, LongStreamEx.of(new Random(), 10).count());
@@ -85,6 +85,15 @@ public class LongStreamExTest {
 
         assertArrayEquals(new long[] { 2, 4, 6 }, LongStreamEx.of(new Long[] { 2L, 4L, 6L }).toArray());
     }
+    
+    @Test
+    public void testIterate() {
+        assertArrayEquals(new long[] { 1, 2, 4, 8, 16 }, LongStreamEx.iterate(1, x -> x * 2).limit(5).toArray());
+        assertArrayEquals(new long[] { 1, 2, 4, 8, 16, 32, 64 }, LongStreamEx.iterate(1, x -> x < 100, x -> x * 2).toArray());
+        assertEquals(0, LongStreamEx.iterate(0, x -> x < 0, x -> 1 / x).count());
+        assertFalse(LongStreamEx.iterate(1, x -> x < 100, x -> x * 2).has(10));
+        checkSpliterator("iterate", () -> LongStreamEx.iterate(1, x -> x < 100, x -> x * 2).spliterator());
+    }
 
     @Test
     public void testLongs() {
diff --git a/src/test/java/one/util/streamex/StreamExTest.java b/src/test/java/one/util/streamex/StreamExTest.java
index cfe28f2..30ee087 100644
--- a/src/test/java/one/util/streamex/StreamExTest.java
+++ b/src/test/java/one/util/streamex/StreamExTest.java
@@ -97,7 +97,6 @@ public class StreamExTest {
         assertEquals(asList("a", "b"), StreamEx.ofLines(new StringReader("a\nb")).toList());
         assertEquals(asList("a", "b"), StreamEx.ofLines(new BufferedReader(new StringReader("a\nb"))).toList());
         assertEquals(asList("a", "b"), StreamEx.ofLines(getReader()).toList());
-        assertEquals(asList("a", "aa", "aaa", "aaaa"), StreamEx.iterate("a", x -> x + "a").limit(4).toList());
         assertEquals(asList("a", "a", "a", "a"), StreamEx.generate(() -> "a").limit(4).toList());
         assertEquals(asList("a", "a", "a", "a"), StreamEx.constant("a", 4).toList());
         assertEquals(asList("c", "d", "e"), StreamEx.of("abcdef".split(""), 2, 5).toList());
@@ -117,6 +116,16 @@ public class StreamExTest {
         assertEquals(asList("a", "b"), StreamEx.of(new Vector<>(asList("a", "b")).elements()).toList());
     }
 
+    @Test
+    public void testIterate() {
+        assertEquals(asList("a", "aa", "aaa", "aaaa"), StreamEx.iterate("a", x -> x + "a").limit(4).toList());
+        assertEquals(asList("a", "aa", "aaa", "aaaa"), StreamEx.iterate("a", x -> x.length() <= 4, x -> x + "a")
+                .toList());
+        assertFalse(StreamEx.iterate("a", x -> x.length() <= 10, x -> x + "a").has("b"));
+        assertEquals(0, StreamEx.iterate("", x -> !x.isEmpty(), x -> x.substring(1)).count());
+        checkSpliterator("iterate", () -> StreamEx.iterate(1, x -> x < 100, x -> x * 2).spliterator());
+    }
+
     @Test
     public void testCreateFromFile() throws IOException {
         File f = tmp.newFile();
@@ -206,13 +215,13 @@ public class StreamExTest {
         assertTrue(StreamEx.of("a", "b", "c").spliterator().hasCharacteristics(Spliterator.ORDERED));
         assertFalse(StreamEx.of("a", "b", "c").unordered().spliterator().hasCharacteristics(Spliterator.ORDERED));
     }
-    
+
     @Test
     public void testCovariance() {
         StreamEx<Number> stream = StreamEx.of(1, 2, 3);
         List<Number> list = stream.toList();
-        assertEquals(asList(1,2,3), list);
-        
+        assertEquals(asList(1, 2, 3), list);
+
         StreamEx<Object> objStream = StreamEx.of(list.spliterator());
         List<Object> objList = objStream.toList();
         assertEquals(asList(1, 2, 3), objList);
@@ -227,7 +236,7 @@ public class StreamExTest {
         list.addAll(list2);
         assertEquals(asList(1, 2, 3, 4, 5, 6, 7), list);
     }
-    
+
     @Test
     public void testForEach() {
         List<Integer> list = new ArrayList<>();
@@ -446,18 +455,20 @@ public class StreamExTest {
     public void testPrepend() {
         Supplier<Stream<String>> sized = () -> StreamEx.of("a", "b", "c", "dd");
         Supplier<Stream<String>> notSized = () -> StreamEx.of(StreamEx.of("a", "b", "c", "dd").iterator());
-        for(Supplier<Stream<String>> supplier : asList(sized, notSized)) {
-            streamEx(supplier, s -> {
-                assertEquals(asList("d", "e", "a", "b", "c"), s.get().remove(str -> str.length() > 1).prepend("d", "e")
-                        .toList());
-                assertEquals(asList("d", "e", "a", "b", "c", "dd"), s.get().prepend(asList("d", "e").stream()).toList());
-                assertEquals(asList("d", "e", "a", "b", "c", "dd"), s.get().prepend(asList("d", "e")).toList());
-            });
+        for (Supplier<Stream<String>> supplier : asList(sized, notSized)) {
+            streamEx(supplier,
+                s -> {
+                    assertEquals(asList("d", "e", "a", "b", "c"), s.get().remove(str -> str.length() > 1).prepend("d",
+                        "e").toList());
+                    assertEquals(asList("d", "e", "a", "b", "c", "dd"), s.get().prepend(asList("d", "e").stream())
+                            .toList());
+                    assertEquals(asList("d", "e", "a", "b", "c", "dd"), s.get().prepend(asList("d", "e")).toList());
+                });
         }
         assertArrayEquals(new Object[] { 1, 2, 3, 1, 1 }, StreamEx.constant(1, Long.MAX_VALUE - 1).prepend(1, 2, 3)
                 .limit(5).toArray());
-        
-        assertEquals(asList(4,3,2,1), StreamEx.of(1).prepend(2).prepend(StreamEx.of(3).prepend(4)).toList());
+
+        assertEquals(asList(4, 3, 2, 1), StreamEx.of(1).prepend(2).prepend(StreamEx.of(3).prepend(4)).toList());
 
         StreamEx<Integer> s = StreamEx.of(1, 2, 3);
         assertSame(s, s.prepend());
@@ -465,13 +476,13 @@ public class StreamExTest {
         assertSame(s, s.prepend(new ArrayList<>()));
         assertSame(s, s.prepend(Stream.empty()));
         assertNotSame(s, s.prepend(new ConcurrentLinkedQueue<>()));
-        
+
         assertTrue(StreamEx.of("a", "b").prepend(Stream.of("c").parallel()).isParallel());
         assertTrue(StreamEx.of("a", "b").parallel().prepend(Stream.of("c").parallel()).isParallel());
         assertTrue(StreamEx.of("a", "b").parallel().prepend(Stream.of("c")).isParallel());
         assertFalse(StreamEx.of("a", "b").prepend(Stream.of("c")).isParallel());
     }
-    
+
     @Test
     public void testPrependTSO() {
         List<Integer> expected = IntStreamEx.rangeClosed(19999, 0, -1).boxed().toList();
@@ -553,10 +564,10 @@ public class StreamExTest {
         assertEquals(asList("a", "bb", "c"), StreamEx.of("a", "bb", null, "c", null).without(s).toList());
         assertTrue(StreamEx.of("bb", "bb", "bb").without("bb").toList().isEmpty());
         assertEquals(asList("bb", "bb", "bb"), StreamEx.of("bb", "bb", "bb").without(s).toList());
-        
+
         StreamEx<String> stream = StreamEx.of("a", "b", "c");
         assertSame(stream, stream.without());
-        assertEquals(asList("a", "b", "c"), StreamEx.of("a", "b", null, "c").without(new String[] {null}).toList());
+        assertEquals(asList("a", "b", "c"), StreamEx.of("a", "b", null, "c").without(new String[] { null }).toList());
         assertEquals(asList(), StreamEx.of("a", "b", null, "c").without("c", null, "b", "a").toList());
     }
 
@@ -1394,14 +1405,15 @@ public class StreamExTest {
             assertEquals(asList("aaa"), s.get().takeWhileInclusive(x -> x.length() > 5).toList());
         });
     }
-    
+
     @Test
     public void testDropWhile() {
         streamEx(asList("aaa", "b", "cccc")::stream, s -> {
             assertEquals(asList("b", "cccc"), s.get().dropWhile(x -> x.length() > 1).toList());
             assertEquals(asList(), s.get().dropWhile(x -> x.length() > 0).toList());
             assertEquals(asList("aaa", "b", "cccc"), s.get().dropWhile(x -> x.length() > 5).toList());
-            // Saving to Optional is necessary as javac <8u40 fails to compile this without intermediate variable
+            // Saving to Optional is necessary as javac <8u40 fails to compile
+            // this without intermediate variable
             Optional<String> opt1 = s.get().dropWhile(x -> x.length() > 1).findFirst();
             assertEquals(Optional.of("b"), opt1);
             Optional<String> opt0 = s.get().dropWhile(x -> x.length() > 0).findFirst();
@@ -1537,8 +1549,8 @@ public class StreamExTest {
         streamEx(() -> StreamEx.of(0, 343, 999), s -> assertEquals(asList(2, 343, 997), s.get().mapFirst(x -> x + 2)
                 .mapLast(x -> x - 2).toList()));
         streamEx(() -> IntStreamEx.range(1000).boxed(), s -> {
-            assertEquals(asList(2, 343, 997), s.get().filter(
-                x -> x == 0 || x == 343 || x == 999).mapFirst(x -> x + 2).mapLast(x -> x - 2).toList());
+            assertEquals(asList(2, 343, 997), s.get().filter(x -> x == 0 || x == 343 || x == 999).mapFirst(x -> x + 2)
+                    .mapLast(x -> x - 2).toList());
             assertEquals(asList(4, 343, 997), s.get().filter(x -> x == 0 || x == 343 || x == 999).mapFirst(x -> x + 2)
                     .mapFirst(x -> x + 2).mapLast(x -> x - 2).toList());
         });
@@ -1591,37 +1603,36 @@ public class StreamExTest {
                 String[]::new)));
         });
     }
-    
+
     @Test
     public void testWithFirst() {
         repeat(10, i -> {
             streamEx(() -> StreamEx.of(0, 2, 4), s -> assertEquals(asList(1, 2, 3, 4, 5), s.get().flatMap(
                 x -> Stream.of(x, x + 1)).withFirst().values().toList()));
-            
+
             streamEx(() -> StreamEx.of("a", "b", "c", "d"), s -> assertEquals(Collections.singletonMap("a", asList("b",
                 "c", "d")), s.get().withFirst().grouping()));
 
             streamEx(() -> StreamEx.of("a", "b", "c", "d"), s -> assertEquals(asList("ab", "ac", "ad"), s.get()
                     .withFirst(String::concat).toList()));
-            
+
             // Header mapping
             String input = "name,type,value\nID,int,5\nSurname,string,Smith\nGiven name,string,John";
-            List<Map<String, String>> expected = asList(EntryStream.of("name", "ID", "type", "int", "value", "5").toMap(),
-                EntryStream.of("name", "Surname", "type", "string", "value", "Smith").toMap(),
-                EntryStream.of("name", "Given name", "type", "string", "value", "John").toMap()
-                    );
+            List<Map<String, String>> expected = asList(EntryStream.of("name", "ID", "type", "int", "value", "5")
+                    .toMap(), EntryStream.of("name", "Surname", "type", "string", "value", "Smith").toMap(),
+                EntryStream.of("name", "Given name", "type", "string", "value", "John").toMap());
             streamEx(() -> StreamEx.ofLines(new StringReader(input)), s -> {
                 assertEquals(expected, s.get().map(str -> str.split(",")).withFirst().mapKeyValue(
                     (header, row) -> EntryStream.zip(header, row).toMap()).toList());
-                assertEquals(expected, s.get().map(str -> str.split(","))
-                    .withFirst((header, row) -> EntryStream.zip(header, row).toMap()).toList());
+                assertEquals(expected, s.get().map(str -> str.split(",")).withFirst(
+                    (header, row) -> EntryStream.zip(header, row).toMap()).toList());
             });
         });
         Map<Integer, List<Integer>> expected = Collections
                 .singletonMap(0, IntStreamEx.range(1, 10000).boxed().toList());
         streamEx(() -> IntStreamEx.range(10000).boxed(), s -> assertEquals(expected, s.get().withFirst().grouping()));
     }
-    
+
     @Test
     public void testZipWith() {
         List<String> input = asList("John", "Mary", "Jane", "Jimmy");
