diff --git a/src/main/java/one/util/streamex/EntryStream.java b/src/main/java/one/util/streamex/EntryStream.java
index 0e8d846..2da33f2 100644
--- a/src/main/java/one/util/streamex/EntryStream.java
+++ b/src/main/java/one/util/streamex/EntryStream.java
@@ -2148,8 +2148,8 @@ public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream
      * @see #ofTree(Object, Class, BiFunction)
      */
     public static <T> EntryStream<Integer, T> ofTree(T root, BiFunction<Integer, T, Stream<T>> mapper) {
-        TreeSpliterator<T, Entry<Integer, T>> spliterator = new TreeSpliterator.Depth<>(root, mapper);
-        return new EntryStream<>(spliterator, StreamContext.SEQUENTIAL.onClose(spliterator::close));
+        TreeSpliterator<T, Entry<Integer, T>> spliterator = new TreeSpliterator.Depth<>(root, mapper, 0);
+        return new EntryStream<>(spliterator, StreamContext.SEQUENTIAL.onClose(spliterator));
     }
 
     /**
diff --git a/src/main/java/one/util/streamex/StreamEx.java b/src/main/java/one/util/streamex/StreamEx.java
index 1cfe0f9..8ca9a62 100644
--- a/src/main/java/one/util/streamex/StreamEx.java
+++ b/src/main/java/one/util/streamex/StreamEx.java
@@ -2972,7 +2972,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      */
     public static <T> StreamEx<T> ofTree(T root, Function<T, Stream<T>> mapper) {
         TreeSpliterator<T, T> spliterator = new TreeSpliterator.Plain<>(root, mapper);
-        return new StreamEx<>(spliterator, StreamContext.SEQUENTIAL.onClose(spliterator::close));
+        return new StreamEx<>(spliterator, StreamContext.SEQUENTIAL.onClose(spliterator));
     }
 
     /**
diff --git a/src/main/java/one/util/streamex/TreeSpliterator.java b/src/main/java/one/util/streamex/TreeSpliterator.java
index 9f05a78..08099f5 100644
--- a/src/main/java/one/util/streamex/TreeSpliterator.java
+++ b/src/main/java/one/util/streamex/TreeSpliterator.java
@@ -31,7 +31,9 @@ import static one.util.streamex.StreamExInternals.*;
  * @author Tagir Valeev
  *
  */
-/* package */ abstract class TreeSpliterator<T, U> extends CloneableSpliterator<U, TreeSpliterator<T, U>> implements Consumer<T> {
+/* package */ abstract class TreeSpliterator<T, U> extends CloneableSpliterator<U, TreeSpliterator<T, U>> 
+        implements Consumer<T>, AutoCloseable, Runnable {
+    private static final int MAX_RECURSION_DEPTH = Integer.getInteger("one.util.streamex.tree.recursiondepth", 128);
     T cur;
     List<PairBox<Spliterator<T>, Stream<T>>> spliterators;
     private Runnable closeHandler = null;
@@ -113,7 +115,13 @@ import static one.util.streamex.StreamExInternals.*;
         cur = t;
     }
     
-    void close() {
+    @Override
+    public void run() {
+        close();
+    }
+    
+    @Override
+    public void close() {
         if(spliterators != null) {
             Throwable t = null;
             for(int i=spliterators.size()-1; i>=0; i--) {
@@ -148,6 +156,7 @@ import static one.util.streamex.StreamExInternals.*;
     static class Acceptor<T> implements Consumer<T> {
         private final Consumer<? super T> action;
         private final Function<T, Stream<T>> mapper;
+        private int depth;
         
         public Acceptor(Consumer<? super T> action, Function<T, Stream<T>> mapper) {
             this.action = action;
@@ -156,11 +165,21 @@ import static one.util.streamex.StreamExInternals.*;
     
         @Override
         public void accept(T t) {
+            if (depth > MAX_RECURSION_DEPTH) {
+                try (TreeSpliterator<T, T> spliterator = new Plain<>(t, mapper)) {
+                    do { // nothing
+                    } while (spliterator.tryAdvance(action));
+                }
+                return;
+            }
             action.accept(t);
-            try(Stream<T> stream = mapper.apply(t)) {
-                if(stream != null) {
+            depth++;
+            try (Stream<T> stream = mapper.apply(t)) {
+                if (stream != null) {
                     stream.spliterator().forEachRemaining(this);
                 }
+            } finally {
+                depth--;
             }
         }
     }
@@ -222,6 +241,13 @@ import static one.util.streamex.StreamExInternals.*;
     
         @Override
         public void accept(T t) {
+            if (depth > MAX_RECURSION_DEPTH) {
+                try (TreeSpliterator<T, Entry<Integer, T>> spliterator = new Depth<>(t, mapper, depth)) {
+                    do { // nothing
+                    } while (spliterator.tryAdvance(action));
+                }
+                return;
+            }
             action.accept(new AbstractMap.SimpleImmutableEntry<>(depth, t));
             try(Stream<T> stream = mapper.apply(depth, t)) {
                 if(stream != null) {
@@ -235,10 +261,12 @@ import static one.util.streamex.StreamExInternals.*;
 
     static class Depth<T> extends TreeSpliterator<T, Entry<Integer, T>> {
         private final BiFunction<Integer, T, Stream<T>> mapper;
+        private final int initialDepth;
 
-        Depth(T root, BiFunction<Integer, T, Stream<T>> mapper) {
+        Depth(T root, BiFunction<Integer, T, Stream<T>> mapper, int depth) {
             super(root);
             this.mapper = mapper;
+            initialDepth = depth;
         }
 
         @Override
@@ -246,14 +274,14 @@ import static one.util.streamex.StreamExInternals.*;
             if(!advance())
                 return false;
             T e = this.cur;
-            int depth = spliterators.size();
+            int depth = initialDepth + spliterators.size();
             action.accept(new ObjIntBox<>(e, depth));
             return append(mapper.apply(depth, e));
         }
 
         @Override
         public void forEachRemaining(Consumer<? super Entry<Integer, T>> action) {
-            DepthAcceptor<T> acceptor = new DepthAcceptor<>(action, mapper, 0);
+            DepthAcceptor<T> acceptor = new DepthAcceptor<>(action, mapper, initialDepth);
             if(spliterators != null) {
                 for(int i=spliterators.size()-1; i>=0; i--) {
                     PairBox<Spliterator<T>, Stream<T>> pair = spliterators.get(i);
diff --git a/src/test/java/one/util/streamex/EntryStreamTest.java b/src/test/java/one/util/streamex/EntryStreamTest.java
index 2a84ae2..b920e70 100644
--- a/src/test/java/one/util/streamex/EntryStreamTest.java
+++ b/src/test/java/one/util/streamex/EntryStreamTest.java
@@ -671,16 +671,16 @@ public class EntryStreamTest {
         }
         assertEquals(StreamEx.of(0, 1, 2).toSet(), set);
         boolean catched = false;
-        try(EntryStream<Integer, String> stream = EntryStream.ofTree("", (Integer depth, String str) -> depth >= 3 ? null : Stream.of("a", "b")
+        try(EntryStream<Integer, String> stream = EntryStream.ofTree("", (Integer depth, String str) -> depth > 1000 ? null : Stream.of("a", "b")
                 .map(str::concat).onClose(() -> {throw new IllegalArgumentException(String.valueOf(depth));}))) {
             stream.count();
         }
         catch(IllegalArgumentException iae) {
             catched = true;
-            assertEquals("2", iae.getMessage());
-            assertEquals(2, iae.getSuppressed().length);
-            assertEquals("1", iae.getSuppressed()[0].getMessage());
-            assertEquals("0", iae.getSuppressed()[1].getMessage());
+            assertEquals("1000", iae.getMessage());
+            assertArrayEquals(IntStreamEx.rangeClosed(1000, 0, -1).toArray(), 
+                    StreamEx.<Throwable>ofTree(iae, ex -> StreamEx.of(ex.getSuppressed()))
+                    .mapToInt(throwable -> Integer.parseInt(throwable.getMessage())).toArray());
         }
         assertTrue(catched);
 
@@ -695,6 +695,17 @@ public class EntryStreamTest {
         });
     }
 
+    @Test
+    public void testOfTreeDeep() {
+        List<Integer> numbers = EntryStream.ofTree(1, (d, n) -> n >= 10000 ? null : StreamEx.of(n + 1))
+                .values().toList();
+        assertEquals(IntStreamEx.rangeClosed(1, 10000).boxed().toList(), numbers);
+
+        assertEquals(700, EntryStream.ofTree(1, (d, n) -> n >= 300 ? null : StreamEx.constant(n + 1, n % 100 == 0 ? 2 : 1))
+                .peekKeyValue((d, n) -> assertEquals(d + 1, (int) n))
+                .count());
+    }
+
     @Test
     public void testCollapseKeys() {
         entryStream(() -> EntryStream.of(1, "a", 1, "b", 2, "c", 3, "d", 1, "e", 1, "f", 1, "g"), s -> checkAsString(
diff --git a/src/test/java/one/util/streamex/StreamExTest.java b/src/test/java/one/util/streamex/StreamExTest.java
index e3decab..35afa8f 100644
--- a/src/test/java/one/util/streamex/StreamExTest.java
+++ b/src/test/java/one/util/streamex/StreamExTest.java
@@ -85,17 +85,17 @@ public class StreamExTest {
 
         assertEquals(asList("a1", "b2", "c3"), StreamEx.zip(asList("a", "b", "c"), asList(1, 2, 3), (s, i) -> s + i)
                 .toList());
-        assertEquals(asList("a1", "b2", "c3"), StreamEx.zip(new String[] { "a", "b", "c" }, new Integer[] { 1, 2, 3 }, (
+        assertEquals(asList("a1", "b2", "c3"), StreamEx.zip(new String[]{"a", "b", "c"}, new Integer[]{1, 2, 3}, (
                 s, i) -> s + i).toList());
 
         assertEquals(asList("a", "b"), StreamEx.of(asList("a", "b").spliterator()).toList());
         assertEquals(asList("a", "b"), StreamEx.of(asList("a", "b").iterator()).toList());
-        assertEquals(asList(), StreamEx.of(asList().iterator()).toList());
-        assertEquals(asList(), StreamEx.of(asList().iterator()).parallel().toList());
+        assertEquals(asList(), StreamEx.of(Collections.emptyIterator()).toList());
+        assertEquals(asList(), StreamEx.of(Collections.emptyIterator()).parallel().toList());
         assertEquals(asList("a", "b"), StreamEx.of(new Vector<>(asList("a", "b")).elements()).toList());
 
         assertEquals(asList("a", "b", "c", "d"), StreamEx.ofReversed(asList("d", "c", "b", "a")).toList());
-        assertEquals(asList("a", "b", "c", "d"), StreamEx.ofReversed(new String[] { "d", "c", "b", "a" }).toList());
+        assertEquals(asList("a", "b", "c", "d"), StreamEx.ofReversed(new String[]{"d", "c", "b", "a"}).toList());
     }
 
     @Test
@@ -1003,14 +1003,24 @@ public class StreamExTest {
 
         streamEx(() -> StreamEx.ofTree("", (String str) -> str.length() >= 3 ? null
                 : Stream.of("a", "b").map(str::concat)), supplier -> {
-                    assertEquals(Arrays.asList("", "a", "aa", "aaa", "aab", "ab", "aba", "abb", "b", "ba", "baa", "bab",
-                        "bb", "bba", "bbb"), supplier.get().toList());
-                    assertEquals(Arrays.asList("a", "b", "aa", "ab", "ba", "bb", "aaa", "aab", "aba", "abb", "baa",
-                        "bab", "bba", "bbb"), supplier.get().sortedByInt(String::length).without("").toList());
-                });
+            assertEquals(Arrays.asList("", "a", "aa", "aaa", "aab", "ab", "aba", "abb", "b", "ba", "baa", "bab",
+                    "bb", "bba", "bbb"), supplier.get().toList());
+            assertEquals(Arrays.asList("a", "b", "aa", "ab", "ba", "bb", "aaa", "aab", "aba", "abb", "baa",
+                    "bab", "bba", "bbb"), supplier.get().sortedByInt(String::length).without("").toList());
+        });
 
         assertEquals(1000001, StreamEx.ofTree("x", s -> s.equals("x") ? IntStreamEx.range(1000000).mapToObj(
-            String::valueOf) : null).parallel().count());
+                String::valueOf) : null).parallel().count());
+    }
+
+    @Test
+    public void testOfTreeDeep() {
+        List<Integer> numbers = StreamEx.ofTree(1, n -> n >= 10000 ? null : StreamEx.of(n + 1))
+                .toList();
+        assertEquals(IntStreamEx.rangeClosed(1, 10000).boxed().toList(), numbers);
+
+        assertEquals(700, StreamEx.ofTree(1, n -> n >= 300 ? null : StreamEx.constant(n + 1, n % 100 == 0 ? 2 : 1))
+                .count());
     }
 
     @Test
@@ -1020,7 +1030,7 @@ public class StreamExTest {
         r.flatStream().close(); // should not fail
 
         List<Consumer<StreamEx<TreeNode>>> tests = Arrays.asList(stream -> assertEquals(
-            Optional.empty(), stream.findFirst(tn -> tn.title.contains("abc"))), stream -> assertEquals(Optional.of(
+                Optional.empty(), stream.findFirst(tn -> tn.title.contains("abc"))), stream -> assertEquals(Optional.of(
                 "grandB1"), stream.findFirst(tn -> tn.title.contains("B1")).map(tn -> tn.title)),
             stream -> assertEquals(7, stream.count()));
         for (Consumer<StreamEx<TreeNode>> test : tests) {
diff --git a/src/test/java/one/util/streamex/TreeSpliteratorTest.java b/src/test/java/one/util/streamex/TreeSpliteratorTest.java
index c9c9f92..7bad400 100644
--- a/src/test/java/one/util/streamex/TreeSpliteratorTest.java
+++ b/src/test/java/one/util/streamex/TreeSpliteratorTest.java
@@ -34,7 +34,7 @@ public class TreeSpliteratorTest {
         List<String> expected = Arrays.asList("", "a", "aa", "aaa", "aaaa", "aaab", "aab", "aaba", "aabb", "ab", "aba",
             "abaa", "abab", "abb", "abba", "abbb", "b", "ba", "baa", "baaa", "baab", "bab", "baba", "babb", "bb", "bba",
             "bbaa", "bbab", "bbb", "bbba", "bbbb");
-        checkSpliterator("tree", expected, () -> new TreeSpliterator.Plain<String>("", s -> s.length() == 4 ? null
+        checkSpliterator("tree", expected, () -> new TreeSpliterator.Plain<>("", s -> s.length() == 4 ? null
                 : Stream.of("a", "b").map(s::concat)));
     }
 
@@ -42,7 +42,7 @@ public class TreeSpliteratorTest {
     public void testDepthSpliterator() {
         List<Entry<Integer, String>> expected = StreamEx.of("", "a", "aa", "ab", "ac", "b", "ba", "bb", "bc", "c", "ca",
             "cb", "cc").mapToEntry(String::length).invert().toList();
-        checkSpliterator("tree", expected, () -> new TreeSpliterator.Depth<String>("", (depth, s) -> depth == 2 ? null
-                : Stream.of("a", "b", "c").map(s::concat)));
+        checkSpliterator("tree", expected, () -> new TreeSpliterator.Depth<>("", (depth, s) -> depth == 2 ? null
+                : Stream.of("a", "b", "c").map(s::concat), 0));
     }
 }
