diff --git a/CHANGES.md b/CHANGES.md
index c99075b..2c965c0 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -5,6 +5,7 @@ Check also [MIGRATION.md](MIGRATION.md) for possible compatibility problems.
 ### 0.7.0
 * [#193] Removed optimizations which rely on internal implementation details of Stream API (unwrap IteratorSpliterator;
   do not delegate to Stream::close when unnecessary)
+* [#194] Removed: `skipOrdered`.
 
 ### 0.6.8
 * [#183] Added: `StreamEx.mapPartial`, `EntryStream.mapToKeyPartial/mapToValuePartial/mapKeyValuePartial`
diff --git a/CHEATSHEET.md b/CHEATSHEET.md
index 8eba67d..c9a7d8b 100644
--- a/CHEATSHEET.md
+++ b/CHEATSHEET.md
@@ -183,7 +183,6 @@ What I want | How to get it
 Extract first stream element and use it to alternate the rest of the stream | `StreamEx.headTail()`
 Define almost any custom intermediate operation recursively | `StreamEx.headTail()`
 Execute custom-defined operation in fluent manner | `any.chain()`
-Work-around parallel stream skip bug prior to Java 8u60 | `any.skipOrdered()`
 Perform parallel stream computation using the custom `ForkJoinPool` | `any.parallel(pool)`
 Zip two streams together | `StreamEx.zipWith()`
 Get the stream of cumulative prefixes | `any.prefix()`/`EntryStream.prefixKeys()`/`EntryStream.prefixValues()`
diff --git a/src/main/java/one/util/streamex/AbstractStreamEx.java b/src/main/java/one/util/streamex/AbstractStreamEx.java
index dcbd555..204bb3b 100644
--- a/src/main/java/one/util/streamex/AbstractStreamEx.java
+++ b/src/main/java/one/util/streamex/AbstractStreamEx.java
@@ -1652,43 +1652,6 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
         });
     }
 
-    /**
-     * Returns a stream consisting of the remaining elements of this stream
-     * after discarding the first {@code n} elements of the stream even if the
-     * stream is unordered. If this stream contains fewer than {@code n}
-     * elements then an empty stream will be returned.
-     *
-     * <p>
-     * This is a stateful <a
-     * href="package-summary.html#StreamOps">quasi-intermediate</a> operation.
-     * Unlike {@link #skip(long)} it skips the first elements even if the stream
-     * is unordered. The main purpose of this method is to workaround the
-     * problem of skipping the first elements from non-sized source with further
-     * parallel processing and unordered terminal operation (such as
-     * {@link #forEach(Consumer)}). For example,
-     * {@code StreamEx.ofLines(br).skip(1).parallel().toSet()} will skip
-     * arbitrary line, but
-     * {@code StreamEx.ofLines(br).skipOrdered(1).parallel().toSet()} will skip
-     * the first one. This problem was fixed in OracleJDK 8u60.
-     *
-     * <p>
-     * Also it behaves much better with infinite streams processed in parallel.
-     *
-     * <p>
-     * For sequential streams this method behaves exactly like
-     * {@link #skip(long)}.
-     *
-     * @param n the number of leading elements to skip
-     * @return the new stream
-     * @throws IllegalArgumentException if {@code n} is negative
-     * @see #skip(long)
-     * @since 0.3.2
-     * @deprecated Unnecessary for JDK newer than 8u60 (use {@link #skip(long)}). Will be removed in future versions.
-     */
-    public S skipOrdered(long n) {
-        return supply((isParallel() ? StreamSupport.stream(spliterator(), false) : stream()).skip(n).spliterator());
-    }
-
     /**
      * Returns a stream consisting of all elements from this stream until the
      * first element which does not match the given predicate is found.
diff --git a/src/main/java/one/util/streamex/DoubleStreamEx.java b/src/main/java/one/util/streamex/DoubleStreamEx.java
index 64348f5..59f1630 100644
--- a/src/main/java/one/util/streamex/DoubleStreamEx.java
+++ b/src/main/java/one/util/streamex/DoubleStreamEx.java
@@ -542,45 +542,6 @@ public class DoubleStreamEx extends BaseStreamEx<Double, DoubleStream, Spliterat
         return new DoubleStreamEx(stream().skip(n), context);
     }
 
-    /**
-     * Returns a stream consisting of the remaining elements of this stream
-     * after discarding the first {@code n} elements of the stream. If this
-     * stream contains fewer than {@code n} elements then an empty stream will
-     * be returned.
-     *
-     * <p>
-     * This is a stateful quasi-intermediate operation. Unlike
-     * {@link #skip(long)} it skips the first elements even if the stream is
-     * unordered. The main purpose of this method is to workaround the problem
-     * of skipping the first elements from non-sized source with further
-     * parallel processing and unordered terminal operation (such as
-     * {@link #forEach(DoubleConsumer)}). This problem was fixed in OracleJDK
-     * 8u60.
-     * 
-     * <p>
-     * Also it behaves much better with infinite streams processed in parallel.
-     * For example,
-     * {@code DoubleStreamEx.iterate(0.0, i->i+1).skip(1).limit(100).parallel().toArray()}
-     * will likely to fail with {@code OutOfMemoryError}, but will work nicely
-     * if {@code skip} is replaced with {@code skipOrdered}.
-     *
-     * <p>
-     * For sequential streams this method behaves exactly like
-     * {@link #skip(long)}.
-     *
-     * @param n the number of leading elements to skip
-     * @return the new stream
-     * @throws IllegalArgumentException if {@code n} is negative
-     * @see #skip(long)
-     * @since 0.3.2
-     * @deprecated Unnecessary for JDK newer than 8u60 (use {@link #skip(long)}). Will be removed in future versions.
-     */
-    public DoubleStreamEx skipOrdered(long n) {
-        Spliterator.OfDouble spliterator = (isParallel() ? StreamSupport.doubleStream(spliterator(), false) : stream())
-                .skip(n).spliterator();
-        return delegate(spliterator);
-    }
-
     @Override
     public void forEach(DoubleConsumer action) {
         if (spliterator != null && !isParallel()) {
diff --git a/src/main/java/one/util/streamex/IntStreamEx.java b/src/main/java/one/util/streamex/IntStreamEx.java
index 52f3dfe..f7c1402 100644
--- a/src/main/java/one/util/streamex/IntStreamEx.java
+++ b/src/main/java/one/util/streamex/IntStreamEx.java
@@ -583,44 +583,6 @@ public class IntStreamEx extends BaseStreamEx<Integer, IntStream, Spliterator.Of
         return new IntStreamEx(stream().skip(n), context);
     }
 
-    /**
-     * Returns a stream consisting of the remaining elements of this stream
-     * after discarding the first {@code n} elements of the stream. If this
-     * stream contains fewer than {@code n} elements then an empty stream will
-     * be returned.
-     *
-     * <p>
-     * This is a stateful quasi-intermediate operation. Unlike
-     * {@link #skip(long)} it skips the first elements even if the stream is
-     * unordered. The main purpose of this method is to workaround the problem
-     * of skipping the first elements from non-sized source with further
-     * parallel processing and unordered terminal operation (such as
-     * {@link #forEach(IntConsumer)}). This problem was fixed in OracleJDK 8u60.
-     * 
-     * <p>
-     * Also it behaves much better with infinite streams processed in parallel.
-     * For example,
-     * {@code IntStreamEx.iterate(0, i->i+1).skip(1).limit(100).parallel().toArray()}
-     * will likely to fail with {@code OutOfMemoryError}, but will work nicely
-     * if {@code skip} is replaced with {@code skipOrdered}.
-     *
-     * <p>
-     * For sequential streams this method behaves exactly like
-     * {@link #skip(long)}.
-     *
-     * @param n the number of leading elements to skip
-     * @return the new stream
-     * @throws IllegalArgumentException if {@code n} is negative
-     * @see #skip(long)
-     * @since 0.3.2
-     * @deprecated Unnecessary for JDK newer than 8u60 (use {@link #skip(long)}). Will be removed in future versions.
-     */
-    public IntStreamEx skipOrdered(long n) {
-        Spliterator.OfInt spliterator = (isParallel() ? StreamSupport.intStream(spliterator(), false) : stream()).skip(
-            n).spliterator();
-        return delegate(spliterator);
-    }
-
     @Override
     public void forEach(IntConsumer action) {
         if (spliterator != null && !isParallel()) {
diff --git a/src/main/java/one/util/streamex/LongStreamEx.java b/src/main/java/one/util/streamex/LongStreamEx.java
index 7ca1107..172f236 100644
--- a/src/main/java/one/util/streamex/LongStreamEx.java
+++ b/src/main/java/one/util/streamex/LongStreamEx.java
@@ -607,45 +607,6 @@ public class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterator.OfL
         return new LongStreamEx(stream().skip(n), context);
     }
 
-    /**
-     * Returns a stream consisting of the remaining elements of this stream
-     * after discarding the first {@code n} elements of the stream. If this
-     * stream contains fewer than {@code n} elements then an empty stream will
-     * be returned.
-     *
-     * <p>
-     * This is a stateful quasi-intermediate operation. Unlike
-     * {@link #skip(long)} it skips the first elements even if the stream is
-     * unordered. The main purpose of this method is to workaround the problem
-     * of skipping the first elements from non-sized source with further
-     * parallel processing and unordered terminal operation (such as
-     * {@link #forEach(LongConsumer)}). This problem was fixed in OracleJDK
-     * 8u60.
-     * 
-     * <p>
-     * Also it behaves much better with infinite streams processed in parallel.
-     * For example,
-     * {@code LongStreamEx.iterate(0L, i->i+1).skip(1).limit(100).parallel().toArray()}
-     * will likely to fail with {@code OutOfMemoryError}, but will work nicely
-     * if {@code skip} is replaced with {@code skipOrdered}.
-     *
-     * <p>
-     * For sequential streams this method behaves exactly like
-     * {@link #skip(long)}.
-     *
-     * @param n the number of leading elements to skip
-     * @return the new stream
-     * @throws IllegalArgumentException if {@code n} is negative
-     * @see #skip(long)
-     * @since 0.3.2
-     * @deprecated Unnecessary for JDK newer than 8u60 (use {@link #skip(long)}). Will be removed in future versions.
-     */
-    public LongStreamEx skipOrdered(long n) {
-        Spliterator.OfLong spliterator = (isParallel() ? StreamSupport.longStream(spliterator(), false) : stream())
-                .skip(n).spliterator();
-        return delegate(spliterator);
-    }
-
     @Override
     public void forEach(LongConsumer action) {
         if (spliterator != null && !isParallel()) {
diff --git a/src/test/java/one/util/streamex/DoubleStreamExTest.java b/src/test/java/one/util/streamex/DoubleStreamExTest.java
index d8d2961..8a9f24b 100644
--- a/src/test/java/one/util/streamex/DoubleStreamExTest.java
+++ b/src/test/java/one/util/streamex/DoubleStreamExTest.java
@@ -352,14 +352,6 @@ public class DoubleStreamExTest {
         assertEquals(Arrays.asList(2.1), map.get(2));
     }
 
-    @Test
-    public void testRecreate() {
-        assertEquals(500, DoubleStreamEx.iterate(0, i -> i + 1).skipOrdered(1).greater(0).boxed().parallel().findAny(
-            i -> i == 500).get(), 0.0);
-        assertEquals(500, DoubleStreamEx.iterate(0, i -> i + 1).parallel().skipOrdered(1).greater(0).boxed().findAny(
-            i -> i == 500).get(), 0.0);
-    }
-
     @Test
     public void testTakeWhile() {
         assertArrayEquals(LongStreamEx.range(100).asDoubleStream().toArray(), DoubleStreamEx.iterate(0, i -> i + 1)
diff --git a/src/test/java/one/util/streamex/IntStreamExTest.java b/src/test/java/one/util/streamex/IntStreamExTest.java
index c0d68eb..84a8ffe 100644
--- a/src/test/java/one/util/streamex/IntStreamExTest.java
+++ b/src/test/java/one/util/streamex/IntStreamExTest.java
@@ -571,32 +571,6 @@ public class IntStreamExTest {
         }
     }
 
-    @Test
-    public void testRecreate() {
-        Set<Integer> expected = IntStreamEx.range(1, 100).boxed().toSet();
-        assertEquals(expected, IntStreamEx.of(
-            StreamSupport.intStream(Spliterators.spliteratorUnknownSize(new HundredIterator(), Spliterator.ORDERED),
-                false)).skip(1).boxed().toSet());
-        assertEquals(expected, IntStreamEx.of(
-            StreamSupport.intStream(Spliterators.spliteratorUnknownSize(new HundredIterator(), Spliterator.ORDERED),
-                true)).skip(1).boxed().toCollection(HashSet::new));
-        assertEquals(expected, IntStreamEx.of(
-            StreamSupport.intStream(Spliterators.spliteratorUnknownSize(new HundredIterator(), Spliterator.ORDERED),
-                true)).skipOrdered(1).boxed().toSet());
-        assertEquals(expected, IntStreamEx.of(
-            StreamSupport.intStream(Spliterators.spliterator(new HundredIterator(), 100, Spliterator.ORDERED
-                | Spliterator.CONCURRENT), true)).skipOrdered(1).boxed().toSet());
-        assertEquals(expected, IntStreamEx.of(
-            StreamSupport.intStream(Spliterators.spliteratorUnknownSize(new HundredIterator(), Spliterator.ORDERED),
-                true)).unordered().skipOrdered(1).boxed().toCollection(HashSet::new));
-
-        assertEquals(expected, IntStreamEx.iterate(0, i -> i + 1).skip(1).greater(0).limit(99).boxed().toSet());
-        assertEquals(500, (int) IntStreamEx.iterate(0, i -> i + 1).skipOrdered(1).greater(0).boxed().parallel()
-                .findAny(i -> i == 500).get());
-        assertEquals(expected, IntStreamEx.iterate(0, i -> i + 1).skipOrdered(1).greater(0).limit(99).boxed()
-                .parallel().toSet());
-    }
-
     @Test
     public void testTakeWhile() {
         assertArrayEquals(IntStreamEx.range(100).toArray(), IntStreamEx.iterate(0, i -> i + 1).takeWhile(i -> i < 100)
diff --git a/src/test/java/one/util/streamex/LongStreamExTest.java b/src/test/java/one/util/streamex/LongStreamExTest.java
index 9ed9d9d..bb7d782 100644
--- a/src/test/java/one/util/streamex/LongStreamExTest.java
+++ b/src/test/java/one/util/streamex/LongStreamExTest.java
@@ -438,14 +438,6 @@ public class LongStreamExTest {
         assertEquals(Arrays.asList(1L, 3L, 5L, 7L, 9L), result.get(1L));
     }
 
-    @Test
-    public void testRecreate() {
-        assertEquals(500, (long) LongStreamEx.iterate(0, i -> i + 1).skipOrdered(1).greater(0).boxed().parallel()
-                .findAny(i -> i == 500).get());
-        assertEquals(500, (long) LongStreamEx.iterate(0, i -> i + 1).parallel().skipOrdered(1).greater(0).boxed()
-                .findAny(i -> i == 500).get());
-    }
-
     @Test
     public void testTakeWhile() {
         assertArrayEquals(LongStreamEx.range(100).toArray(), LongStreamEx.iterate(0, i -> i + 1)
diff --git a/src/test/java/one/util/streamex/StreamExTest.java b/src/test/java/one/util/streamex/StreamExTest.java
index 47e3911..eaa95d2 100644
--- a/src/test/java/one/util/streamex/StreamExTest.java
+++ b/src/test/java/one/util/streamex/StreamExTest.java
@@ -133,11 +133,6 @@ public class StreamExTest {
         assertEquals(expectedSet, actualSet);
         actualSet = StreamEx.ofLines(new StringReader(input)).skip(1).parallel().toCollection(HashSet::new);
         assertEquals(expectedSet, actualSet);
-
-        actualSet = StreamEx.ofLines(new StringReader(input)).parallel().skipOrdered(1).toSet();
-        assertEquals(expectedSet, actualSet);
-        actualSet = StreamEx.ofLines(new StringReader(input)).skipOrdered(1).parallel().toSet();
-        assertEquals(expectedSet, actualSet);
     }
 
     @Test(expected = IllegalArgumentException.class)
