diff --git a/src/main/java/one/util/streamex/StreamEx.java b/src/main/java/one/util/streamex/StreamEx.java
index ea1156e..3edd334 100644
--- a/src/main/java/one/util/streamex/StreamEx.java
+++ b/src/main/java/one/util/streamex/StreamEx.java
@@ -1404,12 +1404,12 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
     }
     
     public <V, R> StreamEx<R> zipWith(Stream<V> other, BiFunction<? super T, ? super V, ? extends R> mapper) {
-        return new StreamEx<>(new ZipSpliterator<>(spliterator(), other.spliterator(), mapper), context.combine(other));
+        return new StreamEx<>(new ZipSpliterator<>(spliterator(), other.spliterator(), mapper, true), context.combine(other));
     }
 
     public <V> EntryStream<T, V> zipWith(Stream<V> other) {
         return new EntryStream<>(new ZipSpliterator<>(spliterator(), other.spliterator(),
-                AbstractMap.SimpleImmutableEntry<T, V>::new), context.combine(other));
+                AbstractMap.SimpleImmutableEntry<T, V>::new, true), context.combine(other));
     }
     
     /**
diff --git a/src/main/java/one/util/streamex/StreamExInternals.java b/src/main/java/one/util/streamex/StreamExInternals.java
index b3e039d..3c6315a 100644
--- a/src/main/java/one/util/streamex/StreamExInternals.java
+++ b/src/main/java/one/util/streamex/StreamExInternals.java
@@ -1081,4 +1081,13 @@ import java.util.stream.Stream;
         }
         return true;
     }
+
+    static <T> int drainTo(T[] array, Spliterator<T> spliterator) {
+        Box<T> box = new Box<>(null);
+        int index = 0;
+        while(index < array.length && spliterator.tryAdvance(box::setA)) {
+            array[index++] = box.a;
+        }
+        return index;
+    }
 }
diff --git a/src/main/java/one/util/streamex/TailConcatSpliterator.java b/src/main/java/one/util/streamex/TailConcatSpliterator.java
index cb0a1ca..78e25b0 100644
--- a/src/main/java/one/util/streamex/TailConcatSpliterator.java
+++ b/src/main/java/one/util/streamex/TailConcatSpliterator.java
@@ -98,7 +98,7 @@ import one.util.streamex.StreamExInternals.TailSpliterator;
     @Override
     public long estimateSize() {
         if (left == null)
-            return right.estimateSize();
+            return right == null ? 0 : right.estimateSize();
         return size;
     }
 
diff --git a/src/main/java/one/util/streamex/ZipSpliterator.java b/src/main/java/one/util/streamex/ZipSpliterator.java
index d384fd2..41c217f 100644
--- a/src/main/java/one/util/streamex/ZipSpliterator.java
+++ b/src/main/java/one/util/streamex/ZipSpliterator.java
@@ -16,23 +16,31 @@
 package one.util.streamex;
 
 import java.util.Spliterator;
+import java.util.Spliterators;
 import java.util.function.BiFunction;
 import java.util.function.Consumer;
 
+import one.util.streamex.UnknownSizeSpliterator.USOfRef;
 import static one.util.streamex.StreamExInternals.*;
 
 /**
  * @author Tagir Valeev
  */
 /* package */class ZipSpliterator<U, V, R> implements Spliterator<R> {
-    private final Spliterator<U> left;
-    private final Spliterator<V> right;
+    static final int BATCH_UNIT = UnknownSizeSpliterator.BATCH_UNIT;
+    static final int MAX_BATCH = UnknownSizeSpliterator.MAX_BATCH;
+
+    private Spliterator<U> left;
+    private Spliterator<V> right;
     private final BiFunction<? super U, ? super V, ? extends R> mapper;
+    private boolean trySplit;
+    private int batch = 0;
 
-    ZipSpliterator(Spliterator<U> left, Spliterator<V> right, BiFunction<? super U, ? super V, ? extends R> mapper) {
+    ZipSpliterator(Spliterator<U> left, Spliterator<V> right, BiFunction<? super U, ? super V, ? extends R> mapper, boolean trySplit) {
         this.left = left;
         this.right = right;
         this.mapper = mapper;
+        this.trySplit = trySplit;
     }
 
     @Override
@@ -72,10 +80,72 @@ import static one.util.streamex.StreamExInternals.*;
 
     @Override
     public Spliterator<R> trySplit() {
-        // TODO Support array-based splitting
-        // TODO Support SUBSIZED splitting if parts match exactly
-        // TODO Support SUBSIZED splitting if parts differ a little bit
-        return null;
+        if(trySplit && hasCharacteristics(SIZED | SUBSIZED))
+        {
+            Spliterator<U> leftPrefix = left.trySplit();
+            if(leftPrefix == null)
+                return arraySplit();
+            Spliterator<V> rightPrefix = right.trySplit();
+            if(rightPrefix == null)
+            {
+                left = new TailConcatSpliterator<>(leftPrefix, left);
+                return arraySplit();
+            }
+            long leftSize = leftPrefix.getExactSizeIfKnown();
+            long rightSize = rightPrefix.getExactSizeIfKnown();
+            if(leftSize >= 0 && rightSize >= 0)
+            {
+                if(leftSize == rightSize)
+                {
+                    return new ZipSpliterator<>(leftPrefix, rightPrefix, mapper, true);
+                }
+                if(Math.abs(leftSize-rightSize) < Math.min(BATCH_UNIT, Math.max(leftSize, rightSize)/8))
+                {
+                    if(leftSize < rightSize)
+                    {
+                        @SuppressWarnings("unchecked")
+                        U[] array = (U[]) new Object[(int) (rightSize-leftSize)];
+                        leftSize += drainTo(array, left);
+                        leftPrefix = new TailConcatSpliterator<>(leftPrefix, Spliterators.spliterator(array, characteristics()));
+                    } else
+                    {
+                        @SuppressWarnings("unchecked")
+                        V[] array = (V[]) new Object[(int) (leftSize-rightSize)];
+                        rightSize += drainTo(array, right);
+                        rightPrefix = new TailConcatSpliterator<>(rightPrefix, Spliterators.spliterator(array, characteristics()));
+                    }
+                    this.trySplit = false;
+                    return new ZipSpliterator<>(leftPrefix, rightPrefix, mapper, false);
+                }
+            }
+            left = new TailConcatSpliterator<>(leftPrefix, left);
+            right = new TailConcatSpliterator<>(rightPrefix, right);
+        }
+        return arraySplit();
+    }
+    
+    private Spliterator<R> arraySplit() {
+        long s = estimateSize();
+        if (s <= 1) return null;
+        int n = batch + BATCH_UNIT;
+        if (n > s)
+            n = (int) s;
+        if (n > MAX_BATCH)
+            n = MAX_BATCH;
+        @SuppressWarnings("unchecked")
+        R[] array = (R[]) new Object[n];
+        int index = drainTo(array, this);
+        if((batch = index) == 0)
+            return null;
+        long s2 = estimateSize();
+        USOfRef<R> prefix = new UnknownSizeSpliterator.USOfRef<>(array, 0, index);
+        if(hasCharacteristics(SUBSIZED))
+            prefix.est = index;
+        else if(s == s2)
+            prefix.est = Math.max(index, s/2);
+        else
+            prefix.est = Math.max(index, s2 - s);
+        return prefix;
     }
 
     @Override
diff --git a/src/test/java/one/util/streamex/ZipSpliteratorTest.java b/src/test/java/one/util/streamex/ZipSpliteratorTest.java
new file mode 100644
index 0000000..62b1c30
--- /dev/null
+++ b/src/test/java/one/util/streamex/ZipSpliteratorTest.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2015, 2016 Tagir Valeev
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package one.util.streamex;
+
+import static one.util.streamex.TestHelpers.*;
+
+import java.util.List;
+import java.util.Spliterator;
+import java.util.function.Supplier;
+
+import org.junit.Test;
+
+/**
+ * @author Tagir Valeev
+ */
+public class ZipSpliteratorTest {
+    @Test
+    public void testEven() {
+        Supplier<Spliterator<String>> s = () -> new ZipSpliterator<>(IntStreamEx.range(1000).spliterator(), 
+                IntStreamEx.range(1, 1001).spliterator(), (x, y) -> x+":"+y, true);
+        List<String> expected = IntStreamEx.range(1000).mapToObj(x -> x+":"+(x+1)).toList();
+        checkSpliterator("even", expected, s);
+        s = () -> new ZipSpliterator<>(IntStreamEx.range(1000).spliterator(), 
+                IntStreamEx.range(2, 1002).map(x -> x - 1).spliterator(), (x, y) -> x+":"+y, true);
+        checkSpliterator("evenMap", expected, s);
+        int[] nums = IntStreamEx.range(1000).toArray();
+        s = () -> new ZipSpliterator<>(IntStreamEx.of(nums).spliterator(), 
+                IntStreamEx.range(2, 1002).map(x -> x - 1).spliterator(), (x, y) -> x+":"+y, true);
+        checkSpliterator("evenArray", expected, s);
+    }
+}
