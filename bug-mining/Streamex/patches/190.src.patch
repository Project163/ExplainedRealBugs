diff --git a/src/main/java/one/util/streamex/AbstractStreamEx.java b/src/main/java/one/util/streamex/AbstractStreamEx.java
index c3a144c..c182002 100644
--- a/src/main/java/one/util/streamex/AbstractStreamEx.java
+++ b/src/main/java/one/util/streamex/AbstractStreamEx.java
@@ -1679,22 +1679,11 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
     }
     
     public S prefix(BinaryOperator<T> op) {
-        Spliterator<T> spltr = spliterator();
-        return supply(new PrefixOps.OfRef<>(spltr, op));
-    }
-
-    public S prefix2(BinaryOperator<T> op) {
         Spliterator<T> spltr = spliterator();
         return supply(spltr.hasCharacteristics(Spliterator.ORDERED) ? new PrefixOps.OfRef<>(spltr, op)
                 : new PrefixOps.OfUnordRef<>(spltr, op));
     }
 
-    public S prefix3(BinaryOperator<T> op) {
-        Spliterator<T> spltr = spliterator();
-        return supply(spltr.hasCharacteristics(Spliterator.ORDERED) ? new PrefixOps.OfRef<>(spltr, op)
-                : new PrefixOps.OfUnordRef3<>(spltr, op));
-    }
-    
     // Necessary to generate proper JavaDoc
     @SuppressWarnings("unchecked")
     @Override
diff --git a/src/main/java/one/util/streamex/DoubleStreamEx.java b/src/main/java/one/util/streamex/DoubleStreamEx.java
index c303d40..d3c46a8 100644
--- a/src/main/java/one/util/streamex/DoubleStreamEx.java
+++ b/src/main/java/one/util/streamex/DoubleStreamEx.java
@@ -1572,6 +1572,10 @@ public class DoubleStreamEx extends BaseStreamEx<Double, DoubleStream, Spliterat
         return delegate(new DoubleStreamEx.TDOfDouble(spliterator(), true, false, predicate));
     }
 
+    public DoubleStreamEx prefix(DoubleBinaryOperator op) {
+        return delegate(new PrefixOps.OfDouble(spliterator(), op));
+    }
+
     // Necessary to generate proper JavaDoc
     // does not add overhead as it appears in bytecode anyways as bridge method
     @Override
diff --git a/src/main/java/one/util/streamex/IntStreamEx.java b/src/main/java/one/util/streamex/IntStreamEx.java
index ce1b38c..6f9e96f 100644
--- a/src/main/java/one/util/streamex/IntStreamEx.java
+++ b/src/main/java/one/util/streamex/IntStreamEx.java
@@ -1866,6 +1866,10 @@ public class IntStreamEx extends BaseStreamEx<Integer, IntStream, Spliterator.Of
         return delegate(new PairSpliterator.PSOfInt((a, b) -> a, mapper, spliterator(), PairSpliterator.MODE_MAP_LAST));
     }
 
+    public IntStreamEx prefix(IntBinaryOperator op) {
+        return delegate(new PrefixOps.OfInt(spliterator(), op));
+    }
+
     // Necessary to generate proper JavaDoc
     // does not add overhead as it appears in bytecode anyways as bridge method
     @Override
diff --git a/src/main/java/one/util/streamex/LongStreamEx.java b/src/main/java/one/util/streamex/LongStreamEx.java
index a43d57f..a3e522a 100644
--- a/src/main/java/one/util/streamex/LongStreamEx.java
+++ b/src/main/java/one/util/streamex/LongStreamEx.java
@@ -1632,6 +1632,10 @@ public class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterator.OfL
         return delegate(new LongStreamEx.TDOfLong(spliterator(), true, false, predicate));
     }
 
+    public LongStreamEx prefix(LongBinaryOperator op) {
+        return delegate(new PrefixOps.OfLong(spliterator(), op));
+    }
+
     // Necessary to generate proper JavaDoc
     // does not add overhead as it appears in bytecode anyways as bridge method
     @Override
diff --git a/src/main/java/one/util/streamex/PrefixOps.java b/src/main/java/one/util/streamex/PrefixOps.java
index b01e65f..353f9e0 100644
--- a/src/main/java/one/util/streamex/PrefixOps.java
+++ b/src/main/java/one/util/streamex/PrefixOps.java
@@ -18,10 +18,19 @@ package one.util.streamex;
 import static one.util.streamex.StreamExInternals.*;
 
 import java.util.Spliterator;
+import java.util.Spliterators.AbstractDoubleSpliterator;
+import java.util.Spliterators.AbstractIntSpliterator;
+import java.util.Spliterators.AbstractLongSpliterator;
 import java.util.Spliterators.AbstractSpliterator;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.BinaryOperator;
 import java.util.function.Consumer;
+import java.util.function.DoubleBinaryOperator;
+import java.util.function.DoubleConsumer;
+import java.util.function.IntBinaryOperator;
+import java.util.function.IntConsumer;
+import java.util.function.LongBinaryOperator;
+import java.util.function.LongConsumer;
 
 import one.util.streamex.StreamExInternals.CloneableSpliterator;
 
@@ -29,12 +38,17 @@ import one.util.streamex.StreamExInternals.CloneableSpliterator;
  * @author Tagir Valeev
  */
 /* package */ abstract class PrefixOps<T, S extends Spliterator<T>> extends CloneableSpliterator<T, PrefixOps<T, S>>{
+    private static final int BUF_SIZE = 128;
+    
     S source;
     AtomicReference<T> accRef;
     T acc = none();
+    int idx = 0;
+    final BinaryOperator<T> op;
     
-    PrefixOps(S source) {
+    PrefixOps(S source, BinaryOperator<T> op) {
         this.source = source;
+        this.op = op;
     }
     
     @Override
@@ -68,7 +82,8 @@ import one.util.streamex.StreamExInternals.CloneableSpliterator;
     static final class OfRef<T> extends AbstractSpliterator<T> implements Consumer<T> {
         private final BinaryOperator<T> op;
         private final Spliterator<T> source;
-        private T acc = none();
+        private boolean started;
+        private T acc;
 
         OfRef(Spliterator<T> source, BinaryOperator<T> op) {
             super(source.estimateSize(), source.characteristics() & (ORDERED | IMMUTABLE | CONCURRENT | SIZED));
@@ -94,69 +109,146 @@ import one.util.streamex.StreamExInternals.CloneableSpliterator;
 
         @Override
         public void accept(T next) {
-            acc = acc == NONE ? next : op.apply(acc, next);
+            if(started) {
+                acc = op.apply(acc, next);
+            } else {
+                started = true;
+                acc = next;
+            }
         }
     }
     
-    static final class OfUnordRef<T> extends PrefixOps<T, Spliterator<T>> {
-        private final BinaryOperator<T> op;
-
-        OfUnordRef(Spliterator<T> source, BinaryOperator<T> op) {
-            super(source);
-            this.op = (a, b) -> a == NONE ? b : op.apply(a, b);
+    static final class OfInt extends AbstractIntSpliterator implements IntConsumer {
+        private final IntBinaryOperator op;
+        private final Spliterator.OfInt source;
+        private boolean started;
+        private int acc;
+        
+        OfInt(Spliterator.OfInt source, IntBinaryOperator op) {
+            super(source.estimateSize(), source.characteristics() & (ORDERED | IMMUTABLE | CONCURRENT | SIZED | NONNULL));
+            this.source = source;
+            this.op = op;
         }
-
+        
         @Override
-        public boolean tryAdvance(Consumer<? super T> action) {
-            Box<T> box = new Box<>();
-            if(!source.tryAdvance(box)) {
+        public boolean tryAdvance(IntConsumer action) {
+            if(!source.tryAdvance(this))
                 return false;
-            }
-            if(accRef == null) {
-                action.accept(acc = op.apply(acc, box.a));
+            action.accept(acc);
+            return true;
+        }
+        
+        @Override
+        public void forEachRemaining(IntConsumer action) {
+            source.forEachRemaining((int next) -> {
+                this.accept(next);
+                action.accept(acc);
+            });
+        }
+        
+        @Override
+        public void accept(int next) {
+            if(started) {
+                acc = op.applyAsInt(acc, next);
             } else {
-                action.accept(accRef.accumulateAndGet(box.a, op));
+                started = true;
+                acc = next;
             }
+        }
+    }
+
+    static final class OfLong extends AbstractLongSpliterator implements LongConsumer {
+        private final LongBinaryOperator op;
+        private final Spliterator.OfLong source;
+        private boolean started;
+        private long acc;
+        
+        OfLong(Spliterator.OfLong source, LongBinaryOperator op) {
+            super(source.estimateSize(), source.characteristics() & (ORDERED | IMMUTABLE | CONCURRENT | SIZED | NONNULL));
+            this.source = source;
+            this.op = op;
+        }
+        
+        @Override
+        public boolean tryAdvance(LongConsumer action) {
+            if(!source.tryAdvance(this))
+                return false;
+            action.accept(acc);
             return true;
         }
+        
+        @Override
+        public void forEachRemaining(LongConsumer action) {
+            source.forEachRemaining((long next) -> {
+                this.accept(next);
+                action.accept(acc);
+            });
+        }
+        
+        @Override
+        public void accept(long next) {
+            if(started) {
+                acc = op.applyAsLong(acc, next);
+            } else {
+                started = true;
+                acc = next;
+            }
+        }
+    }
 
+    static final class OfDouble extends AbstractDoubleSpliterator implements DoubleConsumer {
+        private final DoubleBinaryOperator op;
+        private final Spliterator.OfDouble source;
+        private boolean started;
+        private double acc;
+        
+        OfDouble(Spliterator.OfDouble source, DoubleBinaryOperator op) {
+            super(source.estimateSize(), source.characteristics() & (ORDERED | IMMUTABLE | CONCURRENT | SIZED | NONNULL));
+            this.source = source;
+            this.op = op;
+        }
+        
         @Override
-        public void forEachRemaining(Consumer<? super T> action) {
-            if(accRef == null) {
-                source.forEachRemaining(next -> action.accept(acc = op.apply(acc, next)));
+        public boolean tryAdvance(DoubleConsumer action) {
+            if(!source.tryAdvance(this))
+                return false;
+            action.accept(acc);
+            return true;
+        }
+        
+        @Override
+        public void forEachRemaining(DoubleConsumer action) {
+            source.forEachRemaining((double next) -> {
+                this.accept(next);
+                action.accept(acc);
+            });
+        }
+        
+        @Override
+        public void accept(double next) {
+            if(started) {
+                acc = op.applyAsDouble(acc, next);
             } else {
-                source.forEachRemaining(next -> action.accept(accRef.accumulateAndGet(next, op)));
+                started = true;
+                acc = next;
             }
         }
     }
     
-    static final class OfUnordRef3<T> extends PrefixOps<T, Spliterator<T>> {
-        private static final int BUF_SIZE = 128;
-        
-        private final BinaryOperator<T> op;
+    static final class OfUnordRef<T> extends PrefixOps<T, Spliterator<T>> implements Consumer<T> {
         private final BinaryOperator<T> localOp;
-        private final T[] buf;
-        private int idx = 0;
         
-        @SuppressWarnings("unchecked")
-        OfUnordRef3(Spliterator<T> source, BinaryOperator<T> op) {
-            super(source);
-            this.buf = (T[]) new Object[BUF_SIZE];
-            this.op = (a, b) -> a == NONE ? b : op.apply(a, b);
+        OfUnordRef(Spliterator<T> source, BinaryOperator<T> op) {
+            super(source, (a, b) -> a == NONE ? b : op.apply(a, b));
             this.localOp = op;
         }
         
         @Override
         public boolean tryAdvance(Consumer<? super T> action) {
-            Box<T> box = new Box<>();
-            if(!source.tryAdvance(box)) {
+            if(!source.tryAdvance(this)) {
                 return false;
             }
-            if(accRef == null) {
-                action.accept(acc = op.apply(acc, box.a));
-            } else {
-                action.accept(accRef.accumulateAndGet(box.a, op));
-            }
+            action.accept(acc);
             return true;
         }
         
@@ -165,6 +257,8 @@ import one.util.streamex.StreamExInternals.CloneableSpliterator;
             if(accRef == null) {
                 source.forEachRemaining(next -> action.accept(acc = op.apply(acc, next)));
             } else {
+                @SuppressWarnings("unchecked")
+                T[] buf = (T[]) new Object[BUF_SIZE];
                 source.forEachRemaining(next -> {
                     if(idx == 0) {
                         buf[idx++] = next;
@@ -172,17 +266,17 @@ import one.util.streamex.StreamExInternals.CloneableSpliterator;
                         T prev = buf[idx-1];
                         buf[idx++] = localOp.apply(prev, next);
                         if(idx == buf.length) {
-                            drain(action);
+                            drain(action, buf);
                             idx = 0;
                         }
                     }
                 });
                 if(idx > 0)
-                    drain(action);
+                    drain(action, buf);
             }
         }
 
-        private void drain(Consumer<? super T> action) {
+        private void drain(Consumer<? super T> action, T[] buf) {
             T last = buf[idx-1];
             T acc = accRef.getAndAccumulate(last, op);
             if(acc != NONE) {
@@ -195,5 +289,14 @@ import one.util.streamex.StreamExInternals.CloneableSpliterator;
                 }
             }
         }
+
+        @Override
+        public void accept(T next) {
+            if(accRef == null) {
+                acc = op.apply(acc, next);
+            } else {
+                acc = accRef.accumulateAndGet(next, op);
+            }
+        }
     }
 }
diff --git a/src/test/java/one/util/streamex/DoubleStreamExTest.java b/src/test/java/one/util/streamex/DoubleStreamExTest.java
index 12074cf..00ae36e 100644
--- a/src/test/java/one/util/streamex/DoubleStreamExTest.java
+++ b/src/test/java/one/util/streamex/DoubleStreamExTest.java
@@ -481,4 +481,11 @@ public class DoubleStreamExTest {
         assertArrayEquals(new double[] {1, 2.5, 3, -4.6}, scannerDoubles(sc).stream().toArray(), 0.0);
         assertEquals("test", sc.next());
     }
+
+    @Test
+    public void testPrefix() {
+        assertArrayEquals(new double[] { 1, 3, 6, 10, 20 }, DoubleStreamEx.of(1, 2, 3, 4, 10).prefix(Double::sum).toArray(), 0.0);
+        assertEquals(OptionalDouble.of(10), DoubleStreamEx.of(1, 2, 3, 4, 10).prefix(Double::sum).findFirst(x -> x > 7));
+        assertEquals(OptionalDouble.empty(), DoubleStreamEx.of(1, 2, 3, 4, 10).prefix(Double::sum).findFirst(x -> x > 20));
+    }
 }
diff --git a/src/test/java/one/util/streamex/IntStreamExTest.java b/src/test/java/one/util/streamex/IntStreamExTest.java
index e5fb18f..de4f028 100644
--- a/src/test/java/one/util/streamex/IntStreamExTest.java
+++ b/src/test/java/one/util/streamex/IntStreamExTest.java
@@ -772,4 +772,11 @@ public class IntStreamExTest {
         is.close();
         assertTrue(flag.get());
     }
+
+    @Test
+    public void testPrefix() {
+        assertArrayEquals(new int[] { 1, 3, 6, 10, 20 }, IntStreamEx.of(1, 2, 3, 4, 10).prefix(Integer::sum).toArray());
+        assertEquals(OptionalInt.of(10), IntStreamEx.of(1, 2, 3, 4, 10).prefix(Integer::sum).findFirst(x -> x > 7));
+        assertEquals(OptionalInt.empty(), IntStreamEx.of(1, 2, 3, 4, 10).prefix(Integer::sum).findFirst(x -> x > 20));
+    }
 }
diff --git a/src/test/java/one/util/streamex/LongStreamExTest.java b/src/test/java/one/util/streamex/LongStreamExTest.java
index 02850c3..13cd21e 100644
--- a/src/test/java/one/util/streamex/LongStreamExTest.java
+++ b/src/test/java/one/util/streamex/LongStreamExTest.java
@@ -578,4 +578,11 @@ public class LongStreamExTest {
         assertArrayEquals(new long[] {1, 2, 3, 4, 20000000000L}, scannerLongs(sc).stream().toArray());
         assertEquals("test", sc.next());
     }
+
+    @Test
+    public void testPrefix() {
+        assertArrayEquals(new long[] { 1, 3, 6, 10, 20 }, LongStreamEx.of(1, 2, 3, 4, 10).prefix(Long::sum).toArray());
+        assertEquals(OptionalLong.of(10), LongStreamEx.of(1, 2, 3, 4, 10).prefix(Long::sum).findFirst(x -> x > 7));
+        assertEquals(OptionalLong.empty(), LongStreamEx.of(1, 2, 3, 4, 10).prefix(Long::sum).findFirst(x -> x > 20));
+    }
 }
diff --git a/src/test/java/one/util/streamex/StreamExTest.java b/src/test/java/one/util/streamex/StreamExTest.java
index d6a9968..999933a 100644
--- a/src/test/java/one/util/streamex/StreamExTest.java
+++ b/src/test/java/one/util/streamex/StreamExTest.java
@@ -1784,31 +1784,12 @@ public class StreamExTest {
         streamEx(input::stream, s -> assertEquals(Optional.of("abcd"), s.get().prefix(String::concat).findFirst(
             str -> str.length() > 3)));
 
-        streamEx(input::stream, s -> assertEquals(asList("a", "ab", "abc", "abcd", "abcde"), s.get().prefix2(
-            String::concat).toList()));
-        streamEx(input::stream, s -> assertEquals(Optional.of("abcd"), s.get().prefix2(String::concat).findFirst(
-            str -> str.length() > 3)));
-
         streamEx(() -> StreamEx.constant("a", 5), s -> assertEquals(new HashSet<>(asList("a", "aa", "aaa", "aaaa",
-            "aaaaa")), s.get().prefix2(String::concat).toSet()));
-        streamEx(() -> StreamEx.constant("a", 5), s -> assertEquals(Optional.of("aaaaa"), s.get().prefix2(
-            String::concat).findFirst(str -> str.length() > 4)));
-        
-        streamEx(input::stream, s -> assertEquals(asList("a", "ab", "abc", "abcd", "abcde"), s.get().prefix3(
-            String::concat).toList()));
-        streamEx(input::stream, s -> assertEquals(Optional.of("abcd"), s.get().prefix3(String::concat).findFirst(
-            str -> str.length() > 3)));
-        
-        streamEx(() -> StreamEx.constant("a", 5), s -> assertEquals(new HashSet<>(asList("a", "aa", "aaa", "aaaa",
-                "aaaaa")), s.get().prefix3(String::concat).toSet()));
-        streamEx(() -> StreamEx.constant("a", 5), s -> assertEquals(Optional.of("aaaaa"), s.get().prefix3(
+            "aaaaa")), s.get().prefix(String::concat).toSet()));
+        streamEx(() -> StreamEx.constant("a", 5), s -> assertEquals(Optional.of("aaaaa"), s.get().prefix(
             String::concat).findFirst(str -> str.length() > 4)));
         
         streamEx(() -> StreamEx.constant(100L, 10000), s -> assertEquals(5000500000L,
             (long) s.get().prefix(Long::sum).reduce(0L, Long::sum)));
-        streamEx(() -> StreamEx.constant(100L, 10000), s -> assertEquals(5000500000L,
-            (long) s.get().prefix2(Long::sum).reduce(0L, Long::sum)));
-        streamEx(() -> StreamEx.constant(100L, 10000), s -> assertEquals(5000500000L,
-            (long) s.get().prefix3(Long::sum).reduce(0L, Long::sum)));
     }
 }
