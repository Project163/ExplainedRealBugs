diff --git a/src/main/java/one/util/streamex/AbstractStreamEx.java b/src/main/java/one/util/streamex/AbstractStreamEx.java
index 9d613a2..a986917 100644
--- a/src/main/java/one/util/streamex/AbstractStreamEx.java
+++ b/src/main/java/one/util/streamex/AbstractStreamEx.java
@@ -54,6 +54,7 @@ import static one.util.streamex.Internals.ArrayCollection;
 import static one.util.streamex.Internals.Box;
 import static one.util.streamex.Internals.CancelException;
 import static one.util.streamex.Internals.CancellableCollectorImpl;
+import static one.util.streamex.Internals.IMMUTABLE_TO_LIST;
 import static one.util.streamex.Internals.NONE;
 import static one.util.streamex.Internals.NO_CHARACTERISTICS;
 import static one.util.streamex.Internals.ObjDoubleBox;
@@ -69,7 +70,7 @@ import static one.util.streamex.Internals.none;
  * @author Tagir Valeev
  *
  * @param <T> the type of the stream elements
- * @param <S> the type of of the stream extending {@code AbstractStreamEx}
+ * @param <S> the type of the stream extending {@code AbstractStreamEx}
  */
 public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> extends
         BaseStreamEx<T, Stream<T>, Spliterator<T>, S> implements Stream<T>, Iterable<T> {
@@ -293,7 +294,7 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
      *
      * <p>
      * This operation is not guaranteed to be stable: any of equal elements can
-     * be selected for the output. However if this stream is ordered then order
+     * be selected for the output. However, if this stream is ordered then order
      * is preserved.
      *
      * <p>
@@ -1273,7 +1274,7 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
     }
 
     /**
-     * Returns a stream which contents is the same as this stream, except the case when
+     * Returns a stream whose content is the same as this stream, except the case when
      * this stream is empty. In this case, its contents is replaced with other stream contents.
      *
      * <p>
@@ -1287,7 +1288,7 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
      * operation</a>.
      *
      * @param other other stream to replace the contents of this stream if this stream is empty.
-     * @return the stream which contents is replaced by other stream contents only if this stream is empty.
+     * @return the stream whose content is replaced by other stream contents only if this stream is empty.
      * @since 0.6.6
      */
     public S ifEmpty(Stream<? extends T> other) {
@@ -1295,21 +1296,39 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
     }
 
     /**
-     * Returns a {@link List} containing the elements of this stream. The
-     * returned {@code List} is guaranteed to be mutable, but there are no
-     * guarantees on the type, serializability, or thread-safety; if more
-     * control over the returned {@code List} is required, use
-     * {@link #toCollection(Supplier)}.
+     * Returns a {@link List} containing the elements of this stream. There
+     * are no guarantees on the type, mutability, serializability, or thread-safety
+     * of the returned {@code List}; if more control over the returned
+     * {@code List} is required, use {@link #toCollection(Supplier)}.
      *
      * <p>
      * This is a terminal operation.
      *
      * @return a {@code List} containing the elements of this stream
      * @see Collectors#toList()
+     * @see #toMutableList()
      * @see #toImmutableList()
      */
-    @SuppressWarnings("unchecked")
     public List<T> toList() {
+        return IMMUTABLE_TO_LIST ? toImmutableList() : toMutableList();
+    }
+
+    /**
+     * Returns a mutable {@link List} containing the elements of this stream.
+     * There are no guarantees on the type, serializability, or thread-safety
+     * of the returned {@code List}; if more control over the returned
+     * {@code List} is required, use {@link #toCollection(Supplier)}.
+     *
+     * <p>
+     * This is a terminal operation.
+     *
+     * @return a {@code List} containing the elements of this stream
+     * @see Collectors#toList()
+     * @see #toImmutableList()
+     * @since 0.8.0
+     */
+    @SuppressWarnings("unchecked")
+    public List<T> toMutableList() {
         return new ArrayList<>((Collection<T>) new ArrayCollection(toArray(Object[]::new)));
     }
 
@@ -1324,6 +1343,7 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
      *
      * @return a {@code List} containing the elements of this stream
      * @see #toList()
+     * @see #toMutableList()
      * @since 0.6.3
      */
     @SuppressWarnings("unchecked")
@@ -1357,24 +1377,43 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
      */
     public <R> R toListAndThen(Function<? super List<T>, R> finisher) {
         if (context.fjp != null)
-            return context.terminate(() -> finisher.apply(toList()));
-        return finisher.apply(toList());
+            return context.terminate(() -> finisher.apply(toMutableList()));
+        return finisher.apply(toMutableList());
     }
 
     /**
-     * Returns a {@link Set} containing the elements of this stream. The
-     * returned {@code Set} is guaranteed to be mutable, but there are no
-     * guarantees on the type, serializability, or thread-safety; if more
-     * control over the returned {@code Set} is required, use
-     * {@link #toCollection(Supplier)}.
+     * Returns a {@link Set} containing the elements of this stream. There
+     * are no guarantees on the type, mutability, serializability, or thread-safety
+     * of the returned {@code Set}; if more control over the returned
+     * {@code Set} is required, use {@link #toCollection(Supplier)}.
      *
      * <p>
      * This is a terminal operation.
      *
      * @return a {@code Set} containing the elements of this stream
      * @see Collectors#toSet()
+     * @see #toMutableSet()
+     * @see #toImmutableSet()
      */
     public Set<T> toSet() {
+        return IMMUTABLE_TO_LIST ? toImmutableSet() : toMutableSet();
+    }
+
+    /**
+     * Returns a mutable {@link Set} containing the elements of this stream.
+     * There are no guarantees on the type, serializability, or thread-safety
+     * of the returned {@code Set}; if more control over the returned
+     * {@code Set} is required, use {@link #toCollection(Supplier)}.
+     *
+     * <p>
+     * This is a terminal operation.
+     *
+     * @return a {@code Set} containing the elements of this stream
+     * @see Collectors#toSet()
+     * @see #toImmutableSet()
+     * @since 0.8.0
+     */
+    public Set<T> toMutableSet() {
         return rawCollect(Collectors.toSet());
     }
 
@@ -1390,10 +1429,11 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
      *
      * @return a {@code Set} containing the elements of this stream
      * @see #toSet()
+     * @see #toMutableSet()
      * @since 0.6.3
      */
     public Set<T> toImmutableSet() {
-        Set<T> result = toSet();
+        Set<T> result = toMutableSet();
         if (result.size() == 0)
             return Collections.emptySet();
         return Collections.unmodifiableSet(result);
@@ -1417,8 +1457,8 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
      */
     public <R> R toSetAndThen(Function<? super Set<T>, R> finisher) {
         if (context.fjp != null)
-            return context.terminate(() -> finisher.apply(toSet()));
-        return finisher.apply(toSet());
+            return context.terminate(() -> finisher.apply(toMutableSet()));
+        return finisher.apply(toMutableSet());
     }
 
     /**
@@ -1483,7 +1523,7 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
      * <p>
      * This method cannot take all the advantages of parallel streams as it must
      * process elements strictly left to right. If your accumulator function is
-     * associative and you can provide a combiner function, consider using
+     * associative, and you can provide a combiner function, consider using
      * {@link #reduce(Object, BiFunction, BinaryOperator)} method.
      *
      * <p>
@@ -1565,10 +1605,10 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
      *
      * <p>
      * As this method must process elements strictly right to left, it cannot
-     * start processing till all the previous stream stages complete. Also it
+     * start processing till all the previous stream stages complete. Also, it
      * requires intermediate memory to store the whole content of the stream as
      * the stream natural order is left to right. If your accumulator function
-     * is associative and you can provide a combiner function, consider using
+     * is associative, and you can provide a combiner function, consider using
      * {@link #reduce(Object, BiFunction, BinaryOperator)} method.
      *
      * <p>
@@ -1605,7 +1645,7 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
      *
      * <p>
      * As this method must process elements strictly right to left, it cannot
-     * start processing till all the previous stream stages complete. Also it
+     * start processing till all the previous stream stages complete. Also, it
      * requires intermediate memory to store the whole content of the stream as
      * the stream natural order is left to right. If your accumulator function
      * is associative, consider using {@link #reduce(BinaryOperator)} method.
diff --git a/src/main/java/one/util/streamex/Internals.java b/src/main/java/one/util/streamex/Internals.java
index ae0a55d..5a1aab0 100644
--- a/src/main/java/one/util/streamex/Internals.java
+++ b/src/main/java/one/util/streamex/Internals.java
@@ -58,6 +58,15 @@ import java.util.stream.Collector.Characteristics;
     Set<Characteristics> UNORDERED_ID_CHARACTERISTICS = EnumSet.of(Characteristics.UNORDERED,
         Characteristics.IDENTITY_FINISH);
     Set<Characteristics> ID_CHARACTERISTICS = EnumSet.of(Characteristics.IDENTITY_FINISH);
+    boolean IMMUTABLE_TO_LIST = isImmutableToSetToList();
+
+    static boolean isImmutableToSetToList() {
+        try {
+            return Boolean.parseBoolean(System.getProperty("streamex.default.immutable", "false"));
+        } catch (SecurityException e) {
+            return false;
+        }
+    }
 
     static void checkNonNegative(String name, int value) {
         if (value < 0) {
diff --git a/src/test/java/one/util/streamex/TestHelpers.java b/src/test/java/one/util/streamex/TestHelpers.java
index e3cf731..7b7334f 100644
--- a/src/test/java/one/util/streamex/TestHelpers.java
+++ b/src/test/java/one/util/streamex/TestHelpers.java
@@ -395,7 +395,7 @@ public class TestHelpers {
                     if (split != null)
                         spliterators.add(idx, split);
                 }
-                List<Integer> order = IntStreamEx.ofIndices(spliterators).boxed().toList();
+                List<Integer> order = IntStreamEx.ofIndices(spliterators).boxed().toMutableList();
                 Collections.shuffle(order, r);
                 List<T> list = StreamEx.of(order).mapToEntry(idx -> {
                     Spliterator<T> s = spliterators.get(idx);
@@ -419,7 +419,7 @@ public class TestHelpers {
                         spliterators.add(idx, split);
                 }
                 List<List<T>> results = StreamEx.<List<T>>generate(ArrayList::new).limit(spliterators.size())
-                        .toList();
+                        .toMutableList();
                 int count = spliterators.size();
                 while (count > 0) {
                     int i;
diff --git a/src/test/java/one/util/streamex/api/StreamExTest.java b/src/test/java/one/util/streamex/api/StreamExTest.java
index c10ef11..45b47ec 100644
--- a/src/test/java/one/util/streamex/api/StreamExTest.java
+++ b/src/test/java/one/util/streamex/api/StreamExTest.java
@@ -258,15 +258,22 @@ public class StreamExTest {
     }
 
     @Test
-    public void testToList() {
-        List<Integer> list = StreamEx.of(1, 2, 3).toList();
+    public void testToMutableList() {
+        List<Integer> list = StreamEx.of(1, 2, 3).toMutableList();
         // Test that returned list is mutable
-        List<Integer> list2 = StreamEx.of(4, 5, 6).parallel().toList();
+        List<Integer> list2 = StreamEx.of(4, 5, 6).parallel().toMutableList();
         list2.add(7);
         list.addAll(list2);
         assertEquals(asList(1, 2, 3, 4, 5, 6, 7), list);
     }
 
+    @Test
+    public void testToMutableSet() {
+        Set<Integer> set = StreamEx.of(1, 2, 3).toMutableSet();
+        set.add(4);
+        assertEquals(new HashSet<>(Arrays.asList(1, 2, 3, 4)), set);
+    }
+
     @Test
     public void testToArray() {
         Number[] numbers = StreamEx.of(1, 2, 3).toArray(Number.class);
@@ -2074,18 +2081,8 @@ public class StreamExTest {
         repeat(4, n -> streamEx(() -> IntStreamEx.range(4).atLeast(n).boxed(), s -> {
             List<Integer> list = s.get().toImmutableList();
             assertEquals(expected.subList(n - 1, expected.size()), list);
-            try {
-                list.add(0);
-                fail("added");
-            } catch (UnsupportedOperationException e) {
-                // expected
-            }
-            try {
-                list.set(0, 0);
-                fail("set");
-            } catch (UnsupportedOperationException e) {
-                // expected
-            }
+            assertThrows(UnsupportedOperationException.class, () -> list.add(0));
+            assertThrows(UnsupportedOperationException.class, () -> list.set(0, 0));
         }));
     }
 
@@ -2095,12 +2092,7 @@ public class StreamExTest {
         repeat(4, n -> streamEx(() -> IntStreamEx.range(4).atLeast(n).boxed(), s -> {
             Set<Integer> set = s.get().toImmutableSet();
             assertEquals(new HashSet<>(expected.subList(n - 1, expected.size())), set);
-            try {
-                set.add(-1);
-                fail("added");
-            } catch (UnsupportedOperationException e) {
-                // expected
-            }
+            assertThrows(UnsupportedOperationException.class, () -> set.add(-1));
         }));
     }
 
diff --git a/wiki/CHANGES.md b/wiki/CHANGES.md
index 6ec67b8..ce699d4 100644
--- a/wiki/CHANGES.md
+++ b/wiki/CHANGES.md
@@ -3,6 +3,9 @@
 Check also [MIGRATION.md](MIGRATION.md) for possible compatibility problems.
 
 ### 0.8.0
+* [#244] Added: `StreamEx.toMutableList` and `StreamEx.toMutableSet`.  
+ Removed mutability guarantee for `toList` and `toSet`.
+ Added temporary system property `streamex.default.immutable` (set it to 'true' to test with immutable `toList` and `toSet`)
 * Fixed: `EntryStream.withoutKeys` and `EntryStream.withoutValues` declared as `@SafeVarargs`
 * [#251] Changed: public classes like `StreamEx` and `EntryStream` declared as final now. 
 * Minor documentation fixes
diff --git a/wiki/CHEATSHEET.md b/wiki/CHEATSHEET.md
index 26d6254..d5949c9 100644
--- a/wiki/CHEATSHEET.md
+++ b/wiki/CHEATSHEET.md
@@ -200,6 +200,7 @@ What I want | How to get it
 Collect elements to `List`, `Set` or custom `Collection` | `StreamEx/EntryStream.toList()/toSet()/toCollection()`
 Collect elements to `Collection` adding custom final step | `StreamEx/EntryStream.toListAndThen()/toSetAndThen()/toCollectionAndThen()`
 Collect elements to immutable `List` or `Set` | `StreamEx/EntryStream.toImmutableList()/toImmutableSet()`
+Collect elements to mutable `List` or `Set` | `StreamEx/EntryStream.toMutableList()/toMutableSet()`
 Collect elements or entries to `Map` | `StreamEx/EntryStream.toMap()/toSortedMap()/toNavigableMap()`
 Collect entries to immutable `Map` | `EntryStream.toImmutableMap()`
 Collect entries to `Map` adding custom final step | `EntryStream.toMapAndThen()`
diff --git a/wiki/MIGRATION.md b/wiki/MIGRATION.md
index 7369b94..40e160a 100644
--- a/wiki/MIGRATION.md
+++ b/wiki/MIGRATION.md
@@ -2,6 +2,13 @@
 
 This document describes StreamEx changes which may break the backwards compatibility. For full list of changes see [CHANGES.md](CHANGES.md).
 
+### 0.8.0
+Issue#244: To align with Java 16 `Stream.toList` specification, we no more guarantee that the results of 
+`AbstractStreamEx.toList` and `AbstractStreamEx.toSet` are mutable. They are still mutable by default 
+but this will change in future release. You can switch their implementation to immutable, using temporary 
+system property `-Dstreamex.default.immutable=true` and test how your code behaves. If you actually need mutability, 
+use new methods `AbstractStreamEx.toMutableList` and `AbstractStreamEx.toMutableSet`.
+
 ### 0.7.3
 Issue#219: Now many collectors defined in `MoreCollectors` may throw NullPointerException more eagerly, before the
  collector is used. Also, `MoreCollectors.last` now throws NullPointerException if the last element is null (this
