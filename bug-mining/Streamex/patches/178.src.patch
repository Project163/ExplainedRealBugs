diff --git a/CHANGES.md b/CHANGES.md
index 0ec4bd5..00b3b68 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -1,6 +1,9 @@
 # StreamEx changes
 
 ### 0.6.0
+Warning: this release introduces some changes which may break backwards compatibility.
+
+* [#67] Changed: `StreamEx.withFirst()` now includes `(first, first)` pair into result as well. If you want to exclude it, use `.withFirst().skip(1)`. 
 * [#70] Fixed: `MoreCollectors.least()/greatest()` now support null element (if the supplied `Comparator` supports nulls).
 * [#70] Fixed: `MoreCollectors.least()/greatest()` now returns stable result (the order of equal elements is not changed).
 * [#70] Optimized: `MoreCollectors.least()/greatest()` is usually faster now, especially when the selected elements are close to the stream end.
diff --git a/MIGRATION.md b/MIGRATION.md
new file mode 100644
index 0000000..fbed525
--- /dev/null
+++ b/MIGRATION.md
@@ -0,0 +1,23 @@
+# Migration between StreamEx releases
+
+This document describes StreamEx changes which may break the backwards compatibility. For full list of changes see [CHANGES.md](CHANGES.md).  
+
+### 0.6.0
+
+Issue#67: Now `StreamEx.withFirst()` as well as `StreamEx.withFirst(BinaryOperator)` include `(first, first)` pair. If you used these operations in StreamEx 0.5.3-0.5.5, you should update the existing code: replace `.withFirst()` with `.withFirst().skip(1)`.
+
+### 0.5.5
+
+Issue#41: As `StreamEx.without(T...)` was added, the existing code may become ambiguous now. If you've used `.without(null)` before, replace it with dedicated `.nonNull()` operation.
+Issue#63: `DoubleStreamEx.reverseSorted()` may change the order of non-canonical `NaN` values (actually sorting them).
+
+### 0.5.3
+
+Issue#52: `StreamEx.append(T...)` and `prepend(T...)` are final now, so if you extend `StreamEx` class, you cannot override them anymore. 
+
+### 0.5.0
+
+Issue#8: The package `javax.util.streamex` is renamed to `one.util.streamex`. The OSGi bundle name and Maven groupId are changed correspondingly. To migrate to StreamEx 0.5.0 you should:
+
+* Replace every occurrence of `javax.util.streamex` to `one.util.streamex` in your Java files and OSGi manifests.
+* Replace `io.github.amaembo` groupID with `one.util` in your build files (pom.xml, ivy.xml, build.gradle, etc.)
diff --git a/README.md b/README.md
index 0dbdf52..1106dbb 100644
--- a/README.md
+++ b/README.md
@@ -1,13 +1,3 @@
-## StreamEx changes the package name
-
-Since version 0.5.0 the package name is changed from `javax.util.streamex` to `one.util.streamex`. 
-The OSGi bundle name and Maven groupId are changed correspondingly. To migrate to StreamEx 0.5.0 you should:
-
-* Replace every occurrence of `javax.util.streamex` to `one.util.streamex` in your Java files and OSGi manifests.
-* Replace `io.github.amaembo` groupID with `one.util` in your build files (pom.xml, ivy.xml, build.gradle, etc.)
- 
-This change is discussed [here](https://github.com/amaembo/streamex/issues/8). Sorry for possible inconvenience.
-
 # StreamEx 0.5.5
 Enhancing Java 8 Streams.
 
@@ -25,6 +15,8 @@ Full API documentation is available [here](http://amaembo.github.io/streamex/jav
 
 Take a look at the [Cheatsheet](CHEATSHEET.md) for brief introduction to the StreamEx!
 
+Before updating StreamEx check the [Migration notes](MIGRATION.md) and full list of [changes](CHANGES.md).
+
 StreamEx library main points are following:
 
 * Shorter and convenient ways to do the common tasks.
@@ -130,6 +122,8 @@ This project is licensed under [Apache License, version 2.0](https://www.apache.
 
 Releases are available in [Maven Central](https://repo1.maven.org/maven2/one/util/streamex/)
 
+Before updating StreamEx check the [Migration notes](MIGRATION.md) and full list of [changes](CHANGES.md).
+
 To use from maven add this snippet to the pom.xml `dependencies` section:
 
 ```xml
diff --git a/src/main/java/one/util/streamex/WithFirstSpliterator.java b/src/main/java/one/util/streamex/WithFirstSpliterator.java
index e9b85e0..c91f3a8 100644
--- a/src/main/java/one/util/streamex/WithFirstSpliterator.java
+++ b/src/main/java/one/util/streamex/WithFirstSpliterator.java
@@ -27,8 +27,9 @@ import one.util.streamex.StreamExInternals.CloneableSpliterator;
  */
 /* package */final class WithFirstSpliterator<T, R> extends CloneableSpliterator<R, WithFirstSpliterator<T, R>> {
     private static final int STATE_NONE = 0;
-    private static final int STATE_INIT = 1;
-    private static final int STATE_EMPTY = 2;
+    private static final int STATE_FIRST_READ = 1;
+    private static final int STATE_INIT = 2;
+    private static final int STATE_EMPTY = 3;
 
     private ReentrantLock lock;
     private Spliterator<T> source;
@@ -65,9 +66,18 @@ import one.util.streamex.StreamExInternals.CloneableSpliterator;
                 release();
             }
         }
+        if (state == STATE_FIRST_READ) {
+            state = STATE_INIT;
+            action.accept(mapper.apply(first, first));
+            return true;
+        }
         if (state != STATE_INIT)
             return false;
-        return source.tryAdvance(x -> action.accept(mapper.apply(first, x)));
+        return source.tryAdvance(consumer(action));
+    }
+
+    private Consumer<T> consumer(Consumer<? super R> action) {
+        return x -> action.accept(mapper.apply(first, x));
     }
 
     private void doInit() {
@@ -78,43 +88,40 @@ import one.util.streamex.StreamExInternals.CloneableSpliterator;
             prefix.doInit();
             prefixState = prefix.state;
         }
-        if (prefixState == STATE_INIT) {
-            this.first = prefix.first;
-            this.state = STATE_INIT;
+        if (prefixState == STATE_FIRST_READ || prefixState == STATE_INIT) {
+            first = prefix.first;
+            state = STATE_INIT;
             return;
         }
-        state = source.tryAdvance(x -> first = x) ? STATE_INIT : STATE_EMPTY;
-    }
-
-    private boolean initForEach(T x) {
-        int prefixState = STATE_NONE;
-        if (prefix != null) {
-            prefix.doInit();
-            prefixState = prefix.state;
-        }
-        state = STATE_INIT;
-        if (prefixState == STATE_INIT) {
-            this.first = prefix.first;
-            return false;
-        }
-        this.first = x;
-        return true;
+        state = source.tryAdvance(x -> first = x) ? STATE_FIRST_READ : STATE_EMPTY;
     }
 
     @Override
     public void forEachRemaining(Consumer<? super R> action) {
+        Consumer<T> accept = consumer(action);
         acquire();
+        int myState = state;
+        if(myState == STATE_FIRST_READ || myState == STATE_INIT) {
+            release();
+            if(myState == STATE_FIRST_READ) {
+                state = STATE_INIT;
+                accept.accept(first);
+            }
+            source.forEachRemaining(accept);
+            return;
+        }
         try {
-            source.forEachRemaining(x -> {
+            Consumer<T> init = x -> {
                 if (state == STATE_NONE) {
-                    if (initForEach(x)) {
-                        release();
-                        return;
+                    if (prefix != null) {
+                        prefix.doInit();
                     }
+                    this.first = (prefix == null || prefix.state == STATE_EMPTY) ? x : prefix.first;
+                    state = STATE_INIT;
                 }
                 release();
-                action.accept(mapper.apply(first, x));
-            });
+            };
+            source.forEachRemaining(init.andThen(accept));
         }
         finally {
             release();
@@ -123,11 +130,15 @@ import one.util.streamex.StreamExInternals.CloneableSpliterator;
 
     @Override
     public Spliterator<R> trySplit() {
+        if(state != STATE_NONE)
+            return null;
         Spliterator<T> prefix;
         if(lock == null)
             lock = new ReentrantLock();
         acquire();
         try {
+            if(state != STATE_NONE)
+                return null;
             prefix = source.trySplit();
             if (prefix == null)
                 return null;
@@ -141,11 +152,7 @@ import one.util.streamex.StreamExInternals.CloneableSpliterator;
 
     @Override
     public long estimateSize() {
-        long size = source.estimateSize();
-        if (size > 0 && (size < Long.MAX_VALUE || source.hasCharacteristics(SIZED)) && lock == null
-            && state == STATE_NONE)
-            size--;
-        return size;
+        return source.estimateSize();
     }
 
     @Override
diff --git a/src/test/java/one/util/streamex/StreamExTest.java b/src/test/java/one/util/streamex/StreamExTest.java
index 30ee087..7a369ad 100644
--- a/src/test/java/one/util/streamex/StreamExTest.java
+++ b/src/test/java/one/util/streamex/StreamExTest.java
@@ -1607,13 +1607,21 @@ public class StreamExTest {
     @Test
     public void testWithFirst() {
         repeat(10, i -> {
-            streamEx(() -> StreamEx.of(0, 2, 4), s -> assertEquals(asList(1, 2, 3, 4, 5), s.get().flatMap(
-                x -> Stream.of(x, x + 1)).withFirst().values().toList()));
-
-            streamEx(() -> StreamEx.of("a", "b", "c", "d"), s -> assertEquals(Collections.singletonMap("a", asList("b",
+            streamEx(() -> StreamEx.of(0, 2, 4), s -> assertEquals(asList("0|0", "0|1", "0|2", "0|3", "0|4", "0|5"), s
+                    .get().flatMap(x -> Stream.of(x, x + 1)).withFirst().mapKeyValue((a, b) -> a + "|" + b).toList()));
+            
+            // Check exception-friendliness: short-circuiting collectors use Exceptions for control flow
+            streamEx(() -> IntStreamEx.range(100).boxed(), s -> {
+                assertEquals("0|0, 0|1, 0|2, ...",
+                    s.get().withFirst((a, b) -> a+"|"+b).collect(Joining.with(", ").maxChars(18)));
+                assertEquals(asList(),
+                    s.get().withFirst((a, b) -> a+"|"+b).collect(MoreCollectors.head(0)));
+            });
+            
+            streamEx(() -> StreamEx.of("a", "b", "c", "d"), s -> assertEquals(Collections.singletonMap("a", asList("a", "b",
                 "c", "d")), s.get().withFirst().grouping()));
 
-            streamEx(() -> StreamEx.of("a", "b", "c", "d"), s -> assertEquals(asList("ab", "ac", "ad"), s.get()
+            streamEx(() -> StreamEx.of("a", "b", "c", "d"), s -> assertEquals(asList("aa", "ab", "ac", "ad"), s.get()
                     .withFirst(String::concat).toList()));
 
             // Header mapping
@@ -1622,14 +1630,14 @@ public class StreamExTest {
                     .toMap(), EntryStream.of("name", "Surname", "type", "string", "value", "Smith").toMap(),
                 EntryStream.of("name", "Given name", "type", "string", "value", "John").toMap());
             streamEx(() -> StreamEx.ofLines(new StringReader(input)), s -> {
-                assertEquals(expected, s.get().map(str -> str.split(",")).withFirst().mapKeyValue(
-                    (header, row) -> EntryStream.zip(header, row).toMap()).toList());
-                assertEquals(expected, s.get().map(str -> str.split(",")).withFirst(
+                assertEquals(expected, s.get().map(str -> str.split(",")).withFirst().skip(1).mapKeyValue(
                     (header, row) -> EntryStream.zip(header, row).toMap()).toList());
+                assertEquals(expected, s.get().map(str -> str.split(","))
+                    .withFirst((header, row) -> EntryStream.zip(header, row).toMap()).skip(1).toList());
             });
         });
         Map<Integer, List<Integer>> expected = Collections
-                .singletonMap(0, IntStreamEx.range(1, 10000).boxed().toList());
+                .singletonMap(0, IntStreamEx.range(0, 10000).boxed().toList());
         streamEx(() -> IntStreamEx.range(10000).boxed(), s -> assertEquals(expected, s.get().withFirst().grouping()));
     }
 
diff --git a/src/test/java/one/util/streamex/WithFirstSpliteratorTest.java b/src/test/java/one/util/streamex/WithFirstSpliteratorTest.java
index baa2321..de745ec 100644
--- a/src/test/java/one/util/streamex/WithFirstSpliteratorTest.java
+++ b/src/test/java/one/util/streamex/WithFirstSpliteratorTest.java
@@ -31,10 +31,10 @@ import static org.junit.Assert.*;
 public class WithFirstSpliteratorTest {
     @Test
     public void testSpliterator() {
-        checkSpliterator("withFirst", EntryStream.of(0, 1, 0, 2, 0, 3, 0, 4, 0, 5).toList(),
+        checkSpliterator("withFirst", EntryStream.of(0, 0, 0, 1, 0, 2, 0, 3, 0, 4, 0, 5).toList(),
             () -> new WithFirstSpliterator<>(Stream.of(0, 1, 2, 3, 4, 5).spliterator(),
                     AbstractMap.SimpleImmutableEntry<Integer, Integer>::new));
-        checkSpliterator("withFirstFlatMap", EntryStream.of(0, 1, 0, 2, 0, 3, 0, 4, 0, 5).toList(),
+        checkSpliterator("withFirstFlatMap", EntryStream.of(0, 0, 0, 1, 0, 2, 0, 3, 0, 4, 0, 5).toList(),
             () -> new WithFirstSpliterator<>(Stream.of(0, 2, 4).flatMap(x -> Stream.of(x, x + 1)).parallel()
                     .spliterator(), AbstractMap.SimpleImmutableEntry<Integer, Integer>::new));
     }
@@ -44,6 +44,8 @@ public class WithFirstSpliteratorTest {
         WithFirstSpliterator<Integer, Integer> spltr = new WithFirstSpliterator<>(Stream.of(6, 1, 2, 3, 4, 5)
                 .spliterator(), (a, b) -> a + b);
         assertTrue(spltr.hasCharacteristics(Spliterator.SIZED));
+        assertEquals(6, spltr.getExactSizeIfKnown());
+        assertTrue(spltr.tryAdvance(x -> assertEquals(12, (int)x)));
         assertEquals(5, spltr.getExactSizeIfKnown());
         assertTrue(spltr.tryAdvance(x -> assertEquals(7, (int)x)));
         assertEquals(4, spltr.getExactSizeIfKnown());
@@ -57,9 +59,9 @@ public class WithFirstSpliteratorTest {
         WithFirstSpliterator<Long, Long> longSpltr = new WithFirstSpliterator<>(LongStreamEx.range(Long.MAX_VALUE)
                 .spliterator(), Long::sum);
         assertTrue(longSpltr.hasCharacteristics(Spliterator.SIZED));
+        assertEquals(Long.MAX_VALUE, longSpltr.getExactSizeIfKnown());
+        assertTrue(longSpltr.tryAdvance(x -> assertEquals(0, (long)x)));
         assertEquals(Long.MAX_VALUE-1, longSpltr.getExactSizeIfKnown());
-        assertTrue(longSpltr.tryAdvance(x -> assertEquals(1, (long)x)));
-        assertEquals(Long.MAX_VALUE-2, longSpltr.getExactSizeIfKnown());
         
         longSpltr = new WithFirstSpliterator<>(LongStreamEx.range(-1, Long.MAX_VALUE)
                 .spliterator(), Long::sum);
