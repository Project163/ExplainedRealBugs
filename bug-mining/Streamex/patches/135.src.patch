diff --git a/src/main/java/one/util/streamex/StreamEx.java b/src/main/java/one/util/streamex/StreamEx.java
index 1c99bf5..ea1156e 100644
--- a/src/main/java/one/util/streamex/StreamEx.java
+++ b/src/main/java/one/util/streamex/StreamEx.java
@@ -1402,7 +1402,16 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
                 AbstractMap.SimpleImmutableEntry<T, T>::new);
         return new EntryStream<>(spliterator, context);
     }
+    
+    public <V, R> StreamEx<R> zipWith(Stream<V> other, BiFunction<? super T, ? super V, ? extends R> mapper) {
+        return new StreamEx<>(new ZipSpliterator<>(spliterator(), other.spliterator(), mapper), context.combine(other));
+    }
 
+    public <V> EntryStream<T, V> zipWith(Stream<V> other) {
+        return new EntryStream<>(new ZipSpliterator<>(spliterator(), other.spliterator(),
+                AbstractMap.SimpleImmutableEntry<T, V>::new), context.combine(other));
+    }
+    
     /**
      * Creates a new Stream which is the result of applying of the mapper
      * {@code BiFunction} to the first element of the current stream (head) and
diff --git a/src/main/java/one/util/streamex/StreamExInternals.java b/src/main/java/one/util/streamex/StreamExInternals.java
index bcb8854..b3e039d 100644
--- a/src/main/java/one/util/streamex/StreamExInternals.java
+++ b/src/main/java/one/util/streamex/StreamExInternals.java
@@ -672,6 +672,10 @@ import java.util.stream.Stream;
         Box(A obj) {
             this.a = obj;
         }
+        
+        public void setA(A a) {
+            this.a = a;
+        }
 
         static <A, R> PartialCollector<Box<A>, R> partialCollector(Collector<?, A, R> c) {
             Supplier<A> supplier = c.supplier();
@@ -698,6 +702,10 @@ import java.util.stream.Stream;
             return new PairBox<>(a, a);
         }
 
+        public void setB(B b) {
+            this.b = b;
+        }
+
         @Override
         public int hashCode() {
             return b == null ? 0 : b.hashCode();
diff --git a/src/main/java/one/util/streamex/ZipSpliterator.java b/src/main/java/one/util/streamex/ZipSpliterator.java
new file mode 100644
index 0000000..d384fd2
--- /dev/null
+++ b/src/main/java/one/util/streamex/ZipSpliterator.java
@@ -0,0 +1,91 @@
+/*
+ * Copyright 2015, 2016 Tagir Valeev
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package one.util.streamex;
+
+import java.util.Spliterator;
+import java.util.function.BiFunction;
+import java.util.function.Consumer;
+
+import static one.util.streamex.StreamExInternals.*;
+
+/**
+ * @author Tagir Valeev
+ */
+/* package */class ZipSpliterator<U, V, R> implements Spliterator<R> {
+    private final Spliterator<U> left;
+    private final Spliterator<V> right;
+    private final BiFunction<? super U, ? super V, ? extends R> mapper;
+
+    ZipSpliterator(Spliterator<U> left, Spliterator<V> right, BiFunction<? super U, ? super V, ? extends R> mapper) {
+        this.left = left;
+        this.right = right;
+        this.mapper = mapper;
+    }
+
+    @Override
+    public boolean tryAdvance(Consumer<? super R> action) {
+        PairBox<U, V> box = new PairBox<>(null, null);
+        if (left.tryAdvance(box::setA) && right.tryAdvance(box::setB)) {
+            action.accept(mapper.apply(box.a, box.b));
+            return true;
+        }
+        return false;
+    }
+
+    @Override
+    public void forEachRemaining(Consumer<? super R> action) {
+        if(!hasCharacteristics(SIZED)) {
+            Spliterator.super.forEachRemaining(action);
+            return;
+        }
+        long leftSize = left.getExactSizeIfKnown();
+        long rightSize = right.getExactSizeIfKnown();
+        if(leftSize <= rightSize) {
+            Box<V> box = new Box<>(null);
+            left.forEachRemaining(u -> {
+                if(right.tryAdvance(box::setA)) {
+                    action.accept(mapper.apply(u, box.a));
+                }
+            });
+        } else {
+            Box<U> box = new Box<>(null);
+            right.forEachRemaining(v -> {
+                if(left.tryAdvance(box::setA)) {
+                    action.accept(mapper.apply(box.a, v));
+                }
+            });
+        }
+    }
+
+    @Override
+    public Spliterator<R> trySplit() {
+        // TODO Support array-based splitting
+        // TODO Support SUBSIZED splitting if parts match exactly
+        // TODO Support SUBSIZED splitting if parts differ a little bit
+        return null;
+    }
+
+    @Override
+    public long estimateSize() {
+        return Math.min(left.estimateSize(), right.estimateSize());
+    }
+
+    @Override
+    public int characteristics() {
+        // Remove SORTED, NONNULL, DISTINCT
+        return left.characteristics() & right.characteristics() & (SIZED | SUBSIZED | ORDERED | IMMUTABLE | CONCURRENT);
+    }
+}
diff --git a/src/test/java/one/util/streamex/StreamExTest.java b/src/test/java/one/util/streamex/StreamExTest.java
index 9716fda..e8d63ae 100644
--- a/src/test/java/one/util/streamex/StreamExTest.java
+++ b/src/test/java/one/util/streamex/StreamExTest.java
@@ -57,6 +57,7 @@ import java.util.function.Predicate;
 import java.util.function.Supplier;
 import java.util.regex.Pattern;
 import java.util.stream.Collectors;
+import java.util.stream.IntStream;
 import java.util.stream.Stream;
 
 import one.util.streamex.IntStreamEx;
@@ -1585,4 +1586,17 @@ public class StreamExTest {
                 .singletonMap(0, IntStreamEx.range(1, 10000).boxed().toList());
         streamEx(() -> IntStreamEx.range(10000).boxed(), s -> assertEquals(expected, s.get().withFirst().grouping()));
     }
+    
+    @Test
+    public void testZipWith() {
+        List<String> input = asList("John", "Mary", "Jane", "Jimmy");
+        Spliterator<String> spliterator = StreamEx.of(input).zipWith(IntStreamEx.range(1, Integer.MAX_VALUE).boxed(),
+            (name, idx) -> idx + ". " + name).spliterator();
+        assertEquals(4, spliterator.getExactSizeIfKnown());
+        List<String> expected = asList("1. John", "2. Mary", "3. Jane", "4. Jimmy");
+        streamEx(input::stream, s -> assertEquals(expected, s.get().zipWith(
+            IntStream.range(1, Integer.MAX_VALUE).boxed(), (name, idx) -> idx + ". " + name).toList()));
+        streamEx(() -> IntStream.range(1, Integer.MAX_VALUE).boxed(), s -> assertEquals(expected, s.get().zipWith(
+            input.stream(), (idx, name) -> idx + ". " + name).toList()));
+    }
 }
