diff --git a/CHANGES.md b/CHANGES.md
index f50cfbf..8b8632a 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -2,6 +2,9 @@
 
 Check also [MIGRATION.md](MIGRATION.md) for possible compatibility problems.
 
+### 0.6.7
+* [#76] Added: `StreamEx.zipWith` accepting `BaseStream` (so zipWith(IntStreamEx.ints()) works)
+
 ### 0.6.6
 * [#145] Added: `intersperse` method for all stream types.
 * [#144] Added: `EntryStream.generate`
diff --git a/src/main/java/one/util/streamex/StreamEx.java b/src/main/java/one/util/streamex/StreamEx.java
index 71ac9bb..b493159 100644
--- a/src/main/java/one/util/streamex/StreamEx.java
+++ b/src/main/java/one/util/streamex/StreamEx.java
@@ -34,6 +34,7 @@ import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.ConcurrentSkipListMap;
 import java.util.function.*;
 import java.util.regex.Pattern;
+import java.util.stream.BaseStream;
 import java.util.stream.Collector;
 import java.util.stream.Collector.Characteristics;
 import java.util.stream.Collectors;
@@ -1835,6 +1836,45 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see #zipWith(Stream)
      */
     public <V, R> StreamEx<R> zipWith(Stream<V> other, BiFunction<? super T, ? super V, ? extends R> mapper) {
+        return zipWith((BaseStream<V, ?>) other, mapper);
+    }
+
+    /**
+     * Creates a new {@link StreamEx} which is the result of applying of the
+     * mapper {@code BiFunction} to the corresponding elements of this stream
+     * and the supplied other stream. The resulting stream is ordered if both of
+     * the input streams are ordered, and parallel if either of the input
+     * streams is parallel. When the resulting stream is closed, the close
+     * handlers for both input streams are invoked.
+     *
+     * <p>
+     * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
+     * operation</a>.
+     *
+     * <p>
+     * The resulting stream finishes when either of the input streams finish:
+     * the rest of the longer stream is discarded. It's unspecified whether the
+     * rest elements of the longer stream are actually consumed.
+     *
+     * <p>
+     * The stream created by this operation may have poor characteristics and
+     * parallelize badly, so it should be used only when there's no other
+     * choice. If both input streams are random-access lists or arrays, consider
+     * using {@link #zip(List, List, BiFunction)} or
+     * {@link #zip(Object[], Object[], BiFunction)} respectively. If you want to
+     * zip the stream with the stream of indices, consider using
+     * {@link EntryStream#of(List)} instead.
+     *
+     * @param <V> the type of the other stream elements
+     * @param <R> the type of the resulting stream elements
+     * @param other the stream to zip this stream with
+     * @param mapper a non-interfering, stateless function to apply to the
+     *        corresponding pairs of this stream and other stream elements
+     * @return the new stream
+     * @since 0.6.7
+     * @see #zipWith(BaseStream)
+     */
+    public <V, R> StreamEx<R> zipWith(BaseStream<V, ?> other, BiFunction<? super T, ? super V, ? extends R> mapper) {
         return new StreamEx<>(new ZipSpliterator<>(spliterator(), other.spliterator(), mapper, true), context
                 .combine(other));
     }
@@ -1872,6 +1912,42 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @since 0.5.5
      */
     public <V> EntryStream<T, V> zipWith(Stream<V> other) {
+        return zipWith((BaseStream<V, ?>)other);
+    }
+
+    /**
+     * Creates a new {@link EntryStream} which keys are elements of this stream
+     * and values are the corresponding elements of the supplied other stream.
+     * The resulting stream is ordered if both of the input streams are ordered,
+     * and parallel if either of the input streams is parallel. When the
+     * resulting stream is closed, the close handlers for both input streams are
+     * invoked.
+     *
+     * <p>
+     * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
+     * operation</a>.
+     *
+     * <p>
+     * The resulting stream finishes when either of the input streams finish:
+     * the rest of the longer stream is discarded. It's unspecified whether the
+     * rest elements of the longer stream are actually consumed.
+     *
+     * <p>
+     * The stream created by this operation may have poor characteristics and
+     * parallelize badly, so it should be used only when there's no other
+     * choice. If both input streams are random-access lists or arrays, consider
+     * using {@link EntryStream#zip(List, List)} or
+     * {@link EntryStream#zip(Object[], Object[])} respectively. If you want to
+     * zip the stream with the stream of indices, consider using
+     * {@link EntryStream#of(List)} instead.
+     *
+     * @param <V> the type of the other stream elements
+     * @param other the stream to zip this stream with
+     * @return the new stream
+     * @see #zipWith(BaseStream, BiFunction)
+     * @since 0.6.7
+     */
+    public <V> EntryStream<T, V> zipWith(BaseStream<V, ?> other) {
         return new EntryStream<>(new ZipSpliterator<>(spliterator(), other.spliterator(),
                 SimpleImmutableEntry::new, true), context.combine(other));
     }
diff --git a/src/test/java/one/util/streamex/StreamExTest.java b/src/test/java/one/util/streamex/StreamExTest.java
index 9dbfe8d..6f9dc30 100644
--- a/src/test/java/one/util/streamex/StreamExTest.java
+++ b/src/test/java/one/util/streamex/StreamExTest.java
@@ -1842,6 +1842,10 @@ public class StreamExTest {
                 .boxed()).mapKeyValue((name, idx) -> idx + ". " + name).toList()));
         streamEx(() -> IntStream.range(1, Integer.MAX_VALUE).boxed(), s -> assertEquals(expected, s.get().zipWith(input
                 .stream(), (idx, name) -> idx + ". " + name).toList()));
+        streamEx(input::stream, s -> assertEquals(expected, s.get().zipWith(IntStreamEx.ints())
+                .mapKeyValue((name, idx) -> (idx + 1) + ". " + name).toList()));
+        streamEx(input::stream, s -> assertEquals(expected, s.get()
+                .zipWith(IntStreamEx.ints(), (name, idx) -> (idx + 1) + ". " + name).toList()));
     }
 
     // Like Stream.generate(supplier)
@@ -1944,9 +1948,9 @@ public class StreamExTest {
         // Infinite stream, stop is reached
         assertEquals(Optional.of(1000), maxWithStop(IntStreamEx.of(new Random(1), 0, 1001).boxed(), Comparator
                 .naturalOrder(), 1000));
-        // FInite stream, stop is not reached
+        // Finite stream, stop is not reached
         assertEquals(Optional.of(999), maxWithStop(IntStreamEx.of(new Random(1), 10000, 0, 1000).boxed(), Comparator
-                .naturalOrder(), 1000));
+                .naturalOrder(), 1001));
     }
 
     @Test
