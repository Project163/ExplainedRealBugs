diff --git a/src/main/java/one/util/streamex/AbstractStreamEx.java b/src/main/java/one/util/streamex/AbstractStreamEx.java
index adcf8a2..c1f9402 100644
--- a/src/main/java/one/util/streamex/AbstractStreamEx.java
+++ b/src/main/java/one/util/streamex/AbstractStreamEx.java
@@ -409,11 +409,57 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
             return context.terminate(() -> stream().reduce(identity, accumulator, combiner));
         return stream().reduce(identity, accumulator, combiner);
     }
-    
+
+    /**
+     * Performs a possibly short-circuiting reduction of the stream elements using 
+     * the provided {@code BinaryOperator}. The result is described as an {@code Optional<T>}.
+     *
+     * <p>
+     * This is a short-circuiting terminal operation. It behaves like {@link #reduce(BinaryOperator)}. However,
+     * it additionally accepts a zero element (also known as absorbing element). When zero element
+     * is passed to the accumulator then the result must be zero as well. So the operation
+     * takes the advantage of this and may short-circuit if zero is reached during the reduction.
+     *
+     * @param zero zero element
+     * @param accumulator an <a href="package-summary.html#Associativity">associative</a>
+     *        , <a href="package-summary.html#NonInterference">non-interfering
+     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
+     *        function to combine two elements into one.
+     * @return the result of reduction. Empty Optional is returned if the input stream is empty.
+     * @throws NullPointerException if accumulator is null or the result of reduction is null
+     * @see MoreCollectors#reducingWithZero(Object, BinaryOperator) 
+     * @see #reduceWithZero(Object, Object, BinaryOperator)
+     * @see #reduce(BinaryOperator) 
+     * @since 0.7.3
+     */
     public Optional<T> reduceWithZero(T zero, BinaryOperator<T> accumulator) {
         return collect(MoreCollectors.reducingWithZero(zero, accumulator));
     }
-    
+
+    /**
+     * Performs a possibly short-circuiting reduction of the stream elements using 
+     * the provided identity value and a {@code BinaryOperator}.
+     *
+     * <p>
+     * This is a short-circuiting terminal operation. It behaves like {@link #reduce(Object, BinaryOperator)}. 
+     * However, it additionally accepts a zero element (also known as absorbing element). When zero element
+     * is passed to the accumulator then the result must be zero as well. So the operation
+     * takes the advantage of this and may short-circuit if zero is reached during the reduction.
+     *
+     * @param zero zero element
+     * @param identity an identity element. For all {@code t}, {@code accumulator.apply(t, identity)} is
+     *                 equal to {@code accumulator.apply(identity, t)} and is equal to {@code t}.
+     * @param accumulator an <a href="package-summary.html#Associativity">associative</a>
+     *        , <a href="package-summary.html#NonInterference">non-interfering
+     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
+     *        function to combine two elements into one.
+     * @return the result of reduction. Empty Optional is returned if the input stream is empty.
+     * @throws NullPointerException if accumulator is null or the result of reduction is null
+     * @see MoreCollectors#reducingWithZero(Object, Object, BinaryOperator) 
+     * @see #reduceWithZero(Object, BinaryOperator) 
+     * @see #reduce(Object, BinaryOperator) 
+     * @since 0.7.3
+     */
     public T reduceWithZero(T zero, T identity, BinaryOperator<T> accumulator) {
         return collect(MoreCollectors.reducingWithZero(zero, identity, accumulator));
     }
diff --git a/src/main/java/one/util/streamex/MoreCollectors.java b/src/main/java/one/util/streamex/MoreCollectors.java
index ed2bb1a..807559b 100644
--- a/src/main/java/one/util/streamex/MoreCollectors.java
+++ b/src/main/java/one/util/streamex/MoreCollectors.java
@@ -1858,7 +1858,7 @@ public final class MoreCollectors {
     }
 
     /**
-     * Returns a {@code Collector} which performs a possibly short-circuting reduction of its
+     * Returns a {@code Collector} which performs a possibly short-circuiting reduction of its
      * input elements under a specified {@code BinaryOperator}. The result
      * is described as an {@code Optional<T>}.
      *
@@ -1929,14 +1929,49 @@ public final class MoreCollectors {
         );
     }
 
-    public static <T> Collector<T, ?, T> reducingWithZero(T zero, T identity, BinaryOperator<T> accumulator) {
-        Objects.requireNonNull(accumulator);
+    /**
+     * Returns a {@code Collector} which performs a possibly short-circuiting reduction of its
+     * input elements using the provided identity value and a {@code BinaryOperator}.
+     *
+     * <p>
+     * This collector behaves like {@link Collectors#reducing(Object, BinaryOperator)}. However,
+     * it additionally accepts a zero element (also known as absorbing element). When zero element
+     * is passed to the accumulator then the result must be zero as well. So the collector
+     * takes the advantage of this and may short-circuit if zero is reached during the collection.
+     *
+     * <p>
+     * This method returns a
+     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting
+     * collector</a>: it may not process all the elements if the result of reduction is equal to zero.
+     *
+     * <p>
+     * This collector is mostly useful as a downstream collector. To perform simple
+     * short-circuiting reduction, use {@link AbstractStreamEx#reduceWithZero(Object, BinaryOperator)}
+     * instead.
+     *
+     * @param zero zero element
+     * @param identity an identity element. For all {@code t}, {@code op.apply(t, identity)} is
+     *                 equal to {@code op.apply(identity, t)} and is equal to {@code t}.
+     * @param op an <a href="package-summary.html#Associativity">associative</a>
+     *        , <a href="package-summary.html#NonInterference">non-interfering
+     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
+     *        function to combine two elements into one.
+     * @param <T> the type of input elements
+     * @return a collector which returns the reduction result.
+     * @throws NullPointerException if op is null
+     * @see #reducingWithZero(Object, BinaryOperator) 
+     * @see AbstractStreamEx#reduceWithZero(Object, Object, BinaryOperator) 
+     * @see Collectors#reducing(Object, BinaryOperator) 
+     * @since 0.7.3
+     */
+    public static <T> Collector<T, ?, T> reducingWithZero(T zero, T identity, BinaryOperator<T> op) {
+        Objects.requireNonNull(op);
         // acc.b: 1 = has element, 2 = zero reached
         return new CancellableCollectorImpl<>(
             () -> new ObjIntBox<>(identity, 1),
             (acc, t) -> {
                 if (acc.b != 2) {
-                    t = accumulator.apply(t, acc.a);
+                    t = op.apply(t, acc.a);
                     if (Objects.equals(t, zero)) {
                         acc.b = 2;
                         acc.a = zero;
@@ -1949,7 +1984,7 @@ public final class MoreCollectors {
             (acc1, acc2) -> {
                 if (acc2.b == 2) return acc2;
                 if (acc1.b == 2) return acc1;
-                T t = accumulator.apply(acc1.a, acc2.a);
+                T t = op.apply(acc1.a, acc2.a);
                 if (Objects.equals(t, zero)) {
                     acc1.b = 2;
                     acc1.a = zero;
diff --git a/src/test/java/one/util/streamex/MoreCollectorsTest.java b/src/test/java/one/util/streamex/MoreCollectorsTest.java
index 0bb9274..0b75dd2 100644
--- a/src/test/java/one/util/streamex/MoreCollectorsTest.java
+++ b/src/test/java/one/util/streamex/MoreCollectorsTest.java
@@ -25,6 +25,7 @@ import java.util.Comparator;
 import java.util.EnumMap;
 import java.util.EnumSet;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.IdentityHashMap;
 import java.util.LinkedHashMap;
 import java.util.List;
@@ -34,6 +35,7 @@ import java.util.NavigableMap;
 import java.util.Optional;
 import java.util.OptionalInt;
 import java.util.OptionalLong;
+import java.util.Set;
 import java.util.TreeMap;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -492,22 +494,6 @@ public class MoreCollectorsTest {
                 .mapping(str -> str.substring(0, 1)));
     }
 
-    @Test
-    public void testIntersecting() {
-        for (int i = 0; i < 5; i++) {
-            List<List<String>> input = asList(asList("aa", "bb", "cc"), asList("cc", "bb", "dd"), asList("ee", "dd"),
-                asList("aa", "bb", "dd"));
-            checkShortCircuitCollector("#" + i, Collections.emptySet(), 3, input::stream, MoreCollectors.intersecting());
-            List<List<Integer>> copies = new ArrayList<>(Collections.nCopies(100, asList(1, 2)));
-            checkShortCircuitCollector("#" + i, StreamEx.of(1, 2).toSet(), 100, copies::stream, MoreCollectors
-                    .intersecting());
-            copies.addAll(Collections.nCopies(100, asList(3)));
-            checkShortCircuitCollector("#" + i, Collections.emptySet(), 101, copies::stream, MoreCollectors
-                    .intersecting());
-            checkCollectorEmpty("#" + i, Collections.emptySet(), MoreCollectors.intersecting());
-        }
-    }
-
     @Test
     public void testAndInt() {
         assertThrows(NullPointerException.class, () -> MoreCollectors.andingInt(null));
@@ -1094,4 +1080,43 @@ public class MoreCollectorsTest {
         checkShortCircuitCollector("reducingWithZero: multiply", 0, 32,
             () -> StreamEx.constant(2, 64), multiplication);
     }
+
+    @FunctionalInterface
+    interface Intersector {
+        <T> Collector<List<T>, ?, Set<T>> get();
+    }
+
+    @Test
+    public void testIntersecting() {
+        checkIntersecting(MoreCollectors::intersecting);
+    }
+
+    @Test
+    public void testIntersectingViaReducingWithZero() {
+        checkIntersecting(new Intersector() {
+            @Override
+            public <T> Collector<List<T>, ?, Set<T>> get() {
+                Collector<Set<T>, ?, Optional<Set<T>>> reducing = MoreCollectors.reducingWithZero(
+                    Collections.emptySet(), (c1, c2) -> {
+                        c1.retainAll(c2);
+                        return c1;
+                    });
+                return MoreCollectors.mapping(HashSet::new,
+                    MoreCollectors.collectingAndThen(reducing, res -> res.orElse(Collections.emptySet())));
+            }
+        });
+    }
+
+    private static void checkIntersecting(Intersector intersector) {
+        for (int i = 0; i < 5; i++) {
+            List<List<String>> input = asList(asList("aa", "bb", "cc"), asList("cc", "bb", "dd"), asList("ee", "dd"),
+                asList("aa", "bb", "dd"));
+            checkShortCircuitCollector("#" + i, Collections.emptySet(), 3, input::stream, intersector.get());
+            List<List<Integer>> copies = new ArrayList<>(Collections.nCopies(100, asList(1, 2)));
+            checkShortCircuitCollector("#" + i, StreamEx.of(1, 2).toSet(), 100, copies::stream, intersector.get());
+            copies.addAll(Collections.nCopies(100, asList(3)));
+            checkShortCircuitCollector("#" + i, Collections.emptySet(), 101, copies::stream, intersector.get());
+            checkCollectorEmpty("#" + i, Collections.emptySet(), intersector.get());
+        }
+    }
 }
diff --git a/wiki/CHANGES.md b/wiki/CHANGES.md
index b719606..c6c52b3 100644
--- a/wiki/CHANGES.md
+++ b/wiki/CHANGES.md
@@ -4,6 +4,7 @@ Check also [MIGRATION.md](MIGRATION.md) for possible compatibility problems.
 
 ### 0.7.3
 * [#028]: Added: `StreamEx.toCollectionAndThen`
+* [#039]: Added: `AbstractStreamEx.reducingWithZero` and `MoreCollectors.reducingWithZero`.
 * [#043]: Added: Add `MoreCollectors.entriesToMap` and `MoreCollectors.entriesToCustomMap` methods accepting Entry<K,V>. 
 * [#219]: Changed: MoreCollectors now reject eagerly null parameters where possible; `MoreCollectors.last` throws NPE if last stream element is null.
 * [#221]: Fixed: `rangeClosed(x, x, step)` returned empty stream instead of stream of `x` if step absolute value is
diff --git a/wiki/CHEATSHEET.md b/wiki/CHEATSHEET.md
index 791e49a..0da9d21 100644
--- a/wiki/CHEATSHEET.md
+++ b/wiki/CHEATSHEET.md
@@ -226,6 +226,7 @@ Fold elements left-to-right | `any.foldLeft()`
 Fold elements right-to-left | `StreamEx/EntryStream.foldRight()`
 Get `List` of cumulative prefixes or suffixes | `StreamEx/EntryStream.scanLeft()/scanRight()`
 Get primitive array of cumulative prefixes | `IntStreamEx/LongStreamEx/DoubleStreamEx.scanLeft()`
+Reduce elements possibly short-circuiting the reduction | `StreamEx/EntryStream.reducingWithZero()`
 
 ### Primitive operations
 
@@ -279,6 +280,7 @@ Perform a group-by with the specified keys domain, so every key is initialized e
 Partition input according to the `Predicate` | `MoreCollectors.partitioningBy()`
 Get the common prefix or common suffix `String` of input elements | `MoreCollectors.commonPrefix()/commonSuffix()`
 Get the list of input elements removing the elements which follow their dominator element | `MoreCollectors.dominators()`
+Reduce elements possibly short-circuiting the reduction | `MoreCollectors.reducingWithZero()`
 
 ### Adaptor collectors
 
