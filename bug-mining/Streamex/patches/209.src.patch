diff --git a/CHANGES.md b/CHANGES.md
index ca6a231..4ee77b9 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -2,6 +2,9 @@
 
 Check also [MIGRATION.md](MIGRATION.md) for possible compatibility problems.
 
+### 0.6.4
+* [#128] Added: `EntryStream.prefixKeys`, `EntryStream.prefixValues`
+
 ### 0.6.3
 
 * [#111] Added: `StreamEx.toArray(elementClass)`
diff --git a/CHEATSHEET.md b/CHEATSHEET.md
index 3eefc40..892aa2c 100644
--- a/CHEATSHEET.md
+++ b/CHEATSHEET.md
@@ -181,7 +181,7 @@ Execute custom-defined operation in fluent manner | `any.chain()`
 Work-around parallel stream skip bug prior to Java 8u60 | `any.skipOrdered()`
 Perform parallel stream computation using the custom `ForkJoinPool` | `any.parallel(pool)`
 Zip two streams together | `StreamEx.zipWith()`
-Get the stream of cumulative prefixes | `any.prefix()`
+Get the stream of cumulative prefixes | `any.prefix()`/`EntryStream.prefixKeys()`/`EntryStream.prefixValues()`
 
 ## New terminal operations
 
diff --git a/src/main/java/one/util/streamex/EntryStream.java b/src/main/java/one/util/streamex/EntryStream.java
index 487151d..e118b52 100644
--- a/src/main/java/one/util/streamex/EntryStream.java
+++ b/src/main/java/one/util/streamex/EntryStream.java
@@ -950,6 +950,64 @@ public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream
             return pb1;
         }, spliterator()), context).mapToEntry(pb -> pb.a, pb -> finisher.apply(pb.b));
     }
+    
+    /**
+     * Returns a new {@code EntryStream} which values are the same as this
+     * stream values and keys are the results of applying the accumulation
+     * function to this stream keys, going left to right.
+     * 
+     * <p>
+     * This is a stateful
+     * <a href="package-summary.html#StreamOps">quasi-intermediate</a>
+     * operation.
+     *
+     * <p>
+     * This method cannot take all the advantages of parallel streams as it must
+     * process elements strictly left to right. Using an unordered source or
+     * removing the ordering constraint with {@link #unordered()} may improve
+     * the parallel processing speed.
+     *
+     * @param op an <a href="package-summary.html#Associativity">associative</a>
+     *        , <a href="package-summary.html#NonInterference">non-interfering
+     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
+     *        function for computing the next key based on the previous one
+     * @return the new stream.
+     * @see #prefix(BinaryOperator)
+     * @see #prefixValues(BinaryOperator)
+     * @since 0.6.4
+     */
+    public EntryStream<K, V> prefixKeys(BinaryOperator<K> op) {
+        return prefix((a, b) -> new SimpleImmutableEntry<>(op.apply(a.getKey(), b.getKey()), b.getValue()));
+    }
+
+    /**
+     * Returns a new {@code EntryStream} which keys are the same as this stream
+     * keys and values are the results of applying the accumulation function to
+     * this stream values, going left to right.
+     * 
+     * <p>
+     * This is a stateful
+     * <a href="package-summary.html#StreamOps">quasi-intermediate</a>
+     * operation.
+     *
+     * <p>
+     * This method cannot take all the advantages of parallel streams as it must
+     * process elements strictly left to right. Using an unordered source or
+     * removing the ordering constraint with {@link #unordered()} may improve
+     * the parallel processing speed.
+     *
+     * @param op an <a href="package-summary.html#Associativity">associative</a>
+     *        , <a href="package-summary.html#NonInterference">non-interfering
+     *        </a>, <a href="package-summary.html#Statelessness">stateless</a>
+     *        function for computing the next value based on the previous one
+     * @return the new stream.
+     * @see #prefix(BinaryOperator)
+     * @see #prefixKeys(BinaryOperator)
+     * @since 0.6.4
+     */
+    public EntryStream<K, V> prefixValues(BinaryOperator<V> op) {
+        return prefix((a, b) -> new SimpleImmutableEntry<>(b.getKey(), op.apply(a.getValue(), b.getValue())));
+    }
 
     /**
      * Returns a {@link Map} containing the elements of this stream. There are
diff --git a/src/test/java/one/util/streamex/EntryStreamTest.java b/src/test/java/one/util/streamex/EntryStreamTest.java
index 22e8612..6821cdf 100644
--- a/src/test/java/one/util/streamex/EntryStreamTest.java
+++ b/src/test/java/one/util/streamex/EntryStreamTest.java
@@ -660,4 +660,16 @@ public class EntryStreamTest {
             checkIllegalStateException(() -> EntryStream.of("y", 20, "d", 5).parallel().into(m), "d", "4", "5");
         }
     }
+    
+    @Test
+    public void testPrefixKeys() {
+        Map<String, Integer> map = EntryStream.of("a", 1, "b", 2, "c", 3, "d", 4).prefixValues(Integer::sum).toMap();
+        assertEquals(EntryStream.of("a", 1, "b", 3, "c", 6, "d", 10).toMap(), map);
+    }
+    
+    @Test
+    public void testPrefixValues() {
+        Map<String, Integer> map = EntryStream.of("a", 1, "b", 2, "c", 3, "d", 4).prefixKeys(String::concat).toMap();
+        assertEquals(EntryStream.of("a", 1, "ab", 2, "abc", 3, "abcd", 4).toMap(), map);
+    }
 }
