diff --git a/src/main/java/one/util/streamex/AbstractStreamEx.java b/src/main/java/one/util/streamex/AbstractStreamEx.java
index 55a5e88..1a141be 100644
--- a/src/main/java/one/util/streamex/AbstractStreamEx.java
+++ b/src/main/java/one/util/streamex/AbstractStreamEx.java
@@ -29,7 +29,6 @@ import java.util.OptionalLong;
 import java.util.Set;
 import java.util.Spliterator;
 import java.util.Spliterators;
-import java.util.Spliterators.AbstractSpliterator;
 import java.util.concurrent.ForkJoinPool;
 import java.util.function.BiConsumer;
 import java.util.function.BiFunction;
@@ -63,77 +62,6 @@ import static one.util.streamex.StreamExInternals.*;
  */
 public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> extends
         BaseStreamEx<T, Stream<T>, Spliterator<T>, S> implements Stream<T>, Iterable<T> {
-    private static final class TDOfRef<T> extends AbstractSpliterator<T> implements Consumer<T> {
-        private final Predicate<? super T> predicate;
-        private final boolean drop;
-        private final boolean inclusive;
-        private boolean checked;
-        private final Spliterator<T> source;
-        private T cur;
-
-        TDOfRef(Spliterator<T> source, boolean drop, boolean inclusive, Predicate<? super T> predicate) {
-            super(source.estimateSize(), source.characteristics()
-                & (ORDERED | SORTED | CONCURRENT | IMMUTABLE | NONNULL | DISTINCT));
-            this.drop = drop;
-            this.predicate = predicate;
-            this.inclusive = inclusive;
-            this.source = source;
-        }
-
-        @Override
-        public Comparator<? super T> getComparator() {
-            return source.getComparator();
-        }
-
-        @Override
-        public boolean tryAdvance(Consumer<? super T> action) {
-            if (drop) {
-                if (checked)
-                    return source.tryAdvance(action);
-                while (source.tryAdvance(this)) {
-                    if (!predicate.test(cur)) {
-                        checked = true;
-                        action.accept(cur);
-                        return true;
-                    }
-                }
-                return false;
-            }
-            if (!checked && source.tryAdvance(this) && (predicate.test(cur) || (checked = inclusive))) {
-                action.accept(cur);
-                return true;
-            }
-            checked = true;
-            return false;
-        }
-
-        @Override
-        public void forEachRemaining(Consumer<? super T> action) {
-            if (drop) {
-                if (checked)
-                    source.forEachRemaining(action);
-                else {
-                    source.forEachRemaining(e -> {
-                        if (checked)
-                            action.accept(e);
-                        else {
-                            if (!predicate.test(e)) {
-                                checked = true;
-                                action.accept(e);
-                            }
-                        }
-                    });
-                }
-            } else
-                super.forEachRemaining(action);
-        }
-
-        @Override
-        public void accept(T t) {
-            this.cur = t;
-        }
-    }
-
     @SuppressWarnings("unchecked")
     AbstractStreamEx(Stream<? extends T> stream, StreamContext context) {
         super((Stream<T>)stream, context);
@@ -1704,7 +1632,10 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
         if (JDK9_METHODS != null) {
             return callWhile(predicate, IDX_TAKE_WHILE);
         }
-        return supply(new AbstractStreamEx.TDOfRef<>(spliterator(), false, false, predicate));
+        Spliterator<T> spltr = spliterator();
+        return supply(
+            spltr.hasCharacteristics(Spliterator.ORDERED) ? new TakeDrop.TDOfRef<>(spltr, false, false, predicate)
+                    : new TakeDrop.UnorderedTDOfRef<>(spltr, false, false, predicate));
     }
 
     /**
@@ -1728,7 +1659,10 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
      */
     public S takeWhileInclusive(Predicate<? super T> predicate) {
         Objects.requireNonNull(predicate);
-        return supply(new AbstractStreamEx.TDOfRef<>(spliterator(), false, true, predicate));
+        Spliterator<T> spltr = spliterator();
+        return supply(
+            spltr.hasCharacteristics(Spliterator.ORDERED) ? new TakeDrop.TDOfRef<>(spltr, false, true, predicate)
+                    : new TakeDrop.UnorderedTDOfRef<>(spltr, false, true, predicate));
     }
 
     /**
@@ -1757,7 +1691,10 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
         if (JDK9_METHODS != null) {
             return callWhile(predicate, IDX_DROP_WHILE);
         }
-        return supply(new AbstractStreamEx.TDOfRef<>(spliterator(), true, false, predicate));
+        Spliterator<T> spltr = spliterator();
+        return supply(
+            spltr.hasCharacteristics(Spliterator.ORDERED) ? new TakeDrop.TDOfRef<>(spltr, true, false, predicate)
+                    : new TakeDrop.UnorderedTDOfRef<>(spltr, true, false, predicate));
     }
     
     /**
diff --git a/src/main/java/one/util/streamex/DoubleStreamEx.java b/src/main/java/one/util/streamex/DoubleStreamEx.java
index d032aae..5cc8e7d 100644
--- a/src/main/java/one/util/streamex/DoubleStreamEx.java
+++ b/src/main/java/one/util/streamex/DoubleStreamEx.java
@@ -30,7 +30,6 @@ import java.util.Spliterator;
 import java.util.Spliterators;
 import java.util.Map.Entry;
 import java.util.PrimitiveIterator.OfDouble;
-import java.util.Spliterators.AbstractDoubleSpliterator;
 import java.util.concurrent.ForkJoinPool;
 import java.util.function.BiConsumer;
 import java.util.function.DoubleBinaryOperator;
@@ -62,77 +61,6 @@ import static one.util.streamex.StreamExInternals.*;
  */
 public class DoubleStreamEx extends BaseStreamEx<Double, DoubleStream, Spliterator.OfDouble, DoubleStreamEx> implements
         DoubleStream {
-    private static final class TDOfDouble extends AbstractDoubleSpliterator implements DoubleConsumer {
-        private final DoublePredicate predicate;
-        private final boolean drop;
-        private final boolean inclusive;
-        private boolean checked;
-        private final Spliterator.OfDouble source;
-        private double cur;
-
-        TDOfDouble(Spliterator.OfDouble source, boolean drop, boolean inclusive, DoublePredicate predicate) {
-            super(source.estimateSize(), source.characteristics() & (ORDERED | SORTED | CONCURRENT | IMMUTABLE | NONNULL
-                | DISTINCT));
-            this.drop = drop;
-            this.predicate = predicate;
-            this.inclusive = inclusive;
-            this.source = source;
-        }
-
-        @Override
-        public Comparator<? super Double> getComparator() {
-            return source.getComparator();
-        }
-
-        @Override
-        public boolean tryAdvance(DoubleConsumer action) {
-            if (drop) {
-                if (checked)
-                    return source.tryAdvance(action);
-                while (source.tryAdvance(this)) {
-                    if (!predicate.test(cur)) {
-                        checked = true;
-                        action.accept(cur);
-                        return true;
-                    }
-                }
-                return false;
-            }
-            if (!checked && source.tryAdvance(this) && (predicate.test(cur) || (checked = inclusive))) {
-                action.accept(cur);
-                return true;
-            }
-            checked = true;
-            return false;
-        }
-
-        @Override
-        public void forEachRemaining(DoubleConsumer action) {
-            if (drop) {
-                if (checked)
-                    source.forEachRemaining(action);
-                else {
-                    source.forEachRemaining((double e) -> {
-                        if (checked)
-                            action.accept(e);
-                        else {
-                            if (!predicate.test(e)) {
-                                checked = true;
-                                action.accept(e);
-                            }
-                        }
-                    });
-                }
-            } else
-                super.forEachRemaining(action);
-        }
-
-        @Override
-        public void accept(double t) {
-            this.cur = t;
-        }
-    }
-
     DoubleStreamEx(DoubleStream stream, StreamContext context) {
         super(stream, context);
     }
@@ -1519,7 +1447,7 @@ public class DoubleStreamEx extends BaseStreamEx<Double, DoubleStream, Spliterat
         if (JDK9_METHODS != null) {
             return callWhile(predicate, IDX_TAKE_WHILE);
         }
-        return delegate(new DoubleStreamEx.TDOfDouble(spliterator(), false, false, predicate));
+        return delegate(new TakeDrop.TDOfDouble(spliterator(), false, false, predicate));
     }
 
     /**
@@ -1543,7 +1471,7 @@ public class DoubleStreamEx extends BaseStreamEx<Double, DoubleStream, Spliterat
      */
     public DoubleStreamEx takeWhileInclusive(DoublePredicate predicate) {
         Objects.requireNonNull(predicate);
-        return delegate(new DoubleStreamEx.TDOfDouble(spliterator(), false, true, predicate));
+        return delegate(new TakeDrop.TDOfDouble(spliterator(), false, true, predicate));
     }
 
     /**
@@ -1572,7 +1500,7 @@ public class DoubleStreamEx extends BaseStreamEx<Double, DoubleStream, Spliterat
         if (JDK9_METHODS != null) {
             return callWhile(predicate, IDX_DROP_WHILE);
         }
-        return delegate(new DoubleStreamEx.TDOfDouble(spliterator(), true, false, predicate));
+        return delegate(new TakeDrop.TDOfDouble(spliterator(), true, false, predicate));
     }
 
     /**
diff --git a/src/main/java/one/util/streamex/IntStreamEx.java b/src/main/java/one/util/streamex/IntStreamEx.java
index 1869a2e..dfb9991 100644
--- a/src/main/java/one/util/streamex/IntStreamEx.java
+++ b/src/main/java/one/util/streamex/IntStreamEx.java
@@ -69,77 +69,6 @@ import static one.util.streamex.StreamExInternals.*;
  * @author Tagir Valeev
  */
 public class IntStreamEx extends BaseStreamEx<Integer, IntStream, Spliterator.OfInt, IntStreamEx> implements IntStream {
-    private static final class TDOfInt extends AbstractIntSpliterator implements IntConsumer {
-        private final IntPredicate predicate;
-        private final boolean drop;
-        private final boolean inclusive;
-        private boolean checked;
-        private final Spliterator.OfInt source;
-        private int cur;
-
-        TDOfInt(Spliterator.OfInt source, boolean drop, boolean inclusive, IntPredicate predicate) {
-            super(source.estimateSize(), source.characteristics() & (ORDERED | SORTED | CONCURRENT | IMMUTABLE | NONNULL
-                | DISTINCT));
-            this.drop = drop;
-            this.predicate = predicate;
-            this.inclusive = inclusive;
-            this.source = source;
-        }
-
-        @Override
-        public Comparator<? super Integer> getComparator() {
-            return source.getComparator();
-        }
-
-        @Override
-        public boolean tryAdvance(IntConsumer action) {
-            if (drop) {
-                if (checked)
-                    return source.tryAdvance(action);
-                while (source.tryAdvance(this)) {
-                    if (!predicate.test(cur)) {
-                        checked = true;
-                        action.accept(cur);
-                        return true;
-                    }
-                }
-                return false;
-            }
-            if (!checked && source.tryAdvance(this) && (predicate.test(cur) || (checked = inclusive))) {
-                action.accept(cur);
-                return true;
-            }
-            checked = true;
-            return false;
-        }
-
-        @Override
-        public void forEachRemaining(IntConsumer action) {
-            if (drop) {
-                if (checked)
-                    source.forEachRemaining(action);
-                else {
-                    source.forEachRemaining((int e) -> {
-                        if (checked)
-                            action.accept(e);
-                        else {
-                            if (!predicate.test(e)) {
-                                checked = true;
-                                action.accept(e);
-                            }
-                        }
-                    });
-                }
-            } else
-                super.forEachRemaining(action);
-        }
-
-        @Override
-        public void accept(int t) {
-            this.cur = t;
-        }
-    }
-
     IntStreamEx(IntStream stream, StreamContext context) {
         super(stream, context);
     }
@@ -1772,7 +1701,7 @@ public class IntStreamEx extends BaseStreamEx<Integer, IntStream, Spliterator.Of
         if (JDK9_METHODS != null) {
             return callWhile(predicate, IDX_TAKE_WHILE);
         }
-        return delegate(new IntStreamEx.TDOfInt(spliterator(), false, false, predicate));
+        return delegate(new TakeDrop.TDOfInt(spliterator(), false, false, predicate));
     }
 
     /**
@@ -1796,7 +1725,7 @@ public class IntStreamEx extends BaseStreamEx<Integer, IntStream, Spliterator.Of
      */
     public IntStreamEx takeWhileInclusive(IntPredicate predicate) {
         Objects.requireNonNull(predicate);
-        return delegate(new IntStreamEx.TDOfInt(spliterator(), false, true, predicate));
+        return delegate(new TakeDrop.TDOfInt(spliterator(), false, true, predicate));
     }
 
     /**
@@ -1825,7 +1754,7 @@ public class IntStreamEx extends BaseStreamEx<Integer, IntStream, Spliterator.Of
         if (JDK9_METHODS != null) {
             return callWhile(predicate, IDX_DROP_WHILE);
         }
-        return delegate(new IntStreamEx.TDOfInt(spliterator(), true, false, predicate));
+        return delegate(new TakeDrop.TDOfInt(spliterator(), true, false, predicate));
     }
 
     /**
diff --git a/src/main/java/one/util/streamex/LongStreamEx.java b/src/main/java/one/util/streamex/LongStreamEx.java
index 8c41aba..ee57835 100644
--- a/src/main/java/one/util/streamex/LongStreamEx.java
+++ b/src/main/java/one/util/streamex/LongStreamEx.java
@@ -30,7 +30,6 @@ import java.util.Spliterator;
 import java.util.Spliterators;
 import java.util.Map.Entry;
 import java.util.PrimitiveIterator.OfLong;
-import java.util.Spliterators.AbstractLongSpliterator;
 import java.util.concurrent.ForkJoinPool;
 import java.util.function.BiConsumer;
 import java.util.function.Function;
@@ -62,77 +61,6 @@ import static one.util.streamex.StreamExInternals.*;
  */
 public class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterator.OfLong, LongStreamEx> implements
         LongStream {
-    private static final class TDOfLong extends AbstractLongSpliterator implements LongConsumer {
-        private final LongPredicate predicate;
-        private final boolean drop;
-        private final boolean inclusive;
-        private boolean checked;
-        private final Spliterator.OfLong source;
-        private long cur;
-
-        TDOfLong(Spliterator.OfLong source, boolean drop, boolean inclusive, LongPredicate predicate) {
-            super(source.estimateSize(), source.characteristics() & (ORDERED | SORTED | CONCURRENT | IMMUTABLE | NONNULL
-                | DISTINCT));
-            this.drop = drop;
-            this.predicate = predicate;
-            this.inclusive = inclusive;
-            this.source = source;
-        }
-
-        @Override
-        public Comparator<? super Long> getComparator() {
-            return source.getComparator();
-        }
-
-        @Override
-        public boolean tryAdvance(LongConsumer action) {
-            if (drop) {
-                if (checked)
-                    return source.tryAdvance(action);
-                while (source.tryAdvance(this)) {
-                    if (!predicate.test(cur)) {
-                        checked = true;
-                        action.accept(cur);
-                        return true;
-                    }
-                }
-                return false;
-            }
-            if (!checked && source.tryAdvance(this) && (predicate.test(cur) || (checked = inclusive))) {
-                action.accept(cur);
-                return true;
-            }
-            checked = true;
-            return false;
-        }
-
-        @Override
-        public void forEachRemaining(LongConsumer action) {
-            if (drop) {
-                if (checked)
-                    source.forEachRemaining(action);
-                else {
-                    source.forEachRemaining((long e) -> {
-                        if (checked)
-                            action.accept(e);
-                        else {
-                            if (!predicate.test(e)) {
-                                checked = true;
-                                action.accept(e);
-                            }
-                        }
-                    });
-                }
-            } else
-                super.forEachRemaining(action);
-        }
-
-        @Override
-        public void accept(long t) {
-            this.cur = t;
-        }
-    }
-
     LongStreamEx(LongStream stream, StreamContext context) {
         super(stream, context);
     }
@@ -1581,7 +1509,7 @@ public class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterator.OfL
         if (JDK9_METHODS != null) {
             return callWhile(predicate, IDX_TAKE_WHILE);
         }
-        return delegate(new LongStreamEx.TDOfLong(spliterator(), false, false, predicate));
+        return delegate(new TakeDrop.TDOfLong(spliterator(), false, false, predicate));
     }
 
     /**
@@ -1605,7 +1533,7 @@ public class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterator.OfL
      */
     public LongStreamEx takeWhileInclusive(LongPredicate predicate) {
         Objects.requireNonNull(predicate);
-        return delegate(new LongStreamEx.TDOfLong(spliterator(), false, true, predicate));
+        return delegate(new TakeDrop.TDOfLong(spliterator(), false, true, predicate));
     }
 
     /**
@@ -1634,7 +1562,7 @@ public class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterator.OfL
         if (JDK9_METHODS != null) {
             return callWhile(predicate, IDX_DROP_WHILE);
         }
-        return delegate(new LongStreamEx.TDOfLong(spliterator(), true, false, predicate));
+        return delegate(new TakeDrop.TDOfLong(spliterator(), true, false, predicate));
     }
 
     /**
diff --git a/src/main/java/one/util/streamex/TakeDrop.java b/src/main/java/one/util/streamex/TakeDrop.java
new file mode 100644
index 0000000..0139416
--- /dev/null
+++ b/src/main/java/one/util/streamex/TakeDrop.java
@@ -0,0 +1,391 @@
+/*
+ * Copyright 2015, 2016 Tagir Valeev
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package one.util.streamex;
+
+import java.util.Comparator;
+import java.util.Spliterator;
+import java.util.Spliterators;
+import java.util.Spliterators.AbstractDoubleSpliterator;
+import java.util.Spliterators.AbstractIntSpliterator;
+import java.util.Spliterators.AbstractLongSpliterator;
+import java.util.Spliterators.AbstractSpliterator;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.function.Consumer;
+import java.util.function.DoubleConsumer;
+import java.util.function.DoublePredicate;
+import java.util.function.IntConsumer;
+import java.util.function.IntPredicate;
+import java.util.function.LongConsumer;
+import java.util.function.LongPredicate;
+import java.util.function.Predicate;
+
+import one.util.streamex.StreamExInternals.CloneableSpliterator;
+
+/**
+ * @author Tagir Valeev
+ */
+class TakeDrop {
+    static final class TDOfRef<T> extends AbstractSpliterator<T> implements Consumer<T> {
+        private final Predicate<? super T> predicate;
+        private final boolean drop;
+        private final boolean inclusive;
+        private boolean checked;
+        private final Spliterator<T> source;
+        private T cur;
+    
+        TDOfRef(Spliterator<T> source, boolean drop, boolean inclusive, Predicate<? super T> predicate) {
+            super(source.estimateSize(), source.characteristics()
+                & (ORDERED | SORTED | CONCURRENT | IMMUTABLE | NONNULL | DISTINCT));
+            this.drop = drop;
+            this.predicate = predicate;
+            this.inclusive = inclusive;
+            this.source = source;
+        }
+    
+        @Override
+        public Comparator<? super T> getComparator() {
+            return source.getComparator();
+        }
+    
+        @Override
+        public boolean tryAdvance(Consumer<? super T> action) {
+            if (drop) {
+                if (checked)
+                    return source.tryAdvance(action);
+                while (source.tryAdvance(this)) {
+                    if (!predicate.test(cur)) {
+                        checked = true;
+                        action.accept(cur);
+                        return true;
+                    }
+                }
+                return false;
+            }
+            if (!checked && source.tryAdvance(this) && (predicate.test(cur) || (checked = inclusive))) {
+                action.accept(cur);
+                return true;
+            }
+            checked = true;
+            return false;
+        }
+    
+        @Override
+        public void forEachRemaining(Consumer<? super T> action) {
+            if (drop) {
+                if (checked)
+                    source.forEachRemaining(action);
+                else {
+                    source.forEachRemaining(e -> {
+                        if (checked)
+                            action.accept(e);
+                        else {
+                            if (!predicate.test(e)) {
+                                checked = true;
+                                action.accept(e);
+                            }
+                        }
+                    });
+                }
+            } else
+                super.forEachRemaining(action);
+        }
+    
+        @Override
+        public void accept(T t) {
+            this.cur = t;
+        }
+    }
+    
+    static final class UnorderedTDOfRef<T> extends CloneableSpliterator<T, UnorderedTDOfRef<T>> implements Consumer<T> {
+        private final Predicate<? super T> predicate;
+        private final boolean drop;
+        private final boolean inclusive;
+        private final AtomicBoolean checked = new AtomicBoolean();
+        private Spliterator<T> source;
+        private T cur;
+
+        UnorderedTDOfRef(Spliterator<T> source, boolean drop, boolean inclusive, Predicate<? super T> predicate) {
+            this.drop = drop;
+            this.predicate = predicate;
+            this.inclusive = inclusive;
+            this.source = source;
+        }
+
+        @Override
+        public void accept(T t) {
+            this.cur = t;
+        }
+
+        @Override
+        public boolean tryAdvance(Consumer<? super T> action) {
+            if (drop) {
+                if (checked.get())
+                    return source.tryAdvance(action);
+                while (source.tryAdvance(this)) {
+                    if (!predicate.test(cur)) {
+                        checked.set(true);
+                        action.accept(cur);
+                        return true;
+                    }
+                }
+                return false;
+            }
+            if (!checked.get() && source.tryAdvance(this) && 
+                    (predicate.test(cur) || (checked.compareAndSet(false, true) && inclusive))) {
+                action.accept(cur);
+                return true;
+            }
+            return false;
+        }
+
+        @Override
+        public Spliterator<T> trySplit() {
+            Spliterator<T> prefix = source.trySplit();
+            if(prefix == null) {
+                return null;
+            }
+            if(checked.get()) {
+                return drop ? prefix : Spliterators.emptySpliterator();
+            }
+            UnorderedTDOfRef<T> clone = doClone();
+            clone.source = prefix;
+            return clone;
+        }
+
+        @Override
+        public long estimateSize() {
+            return source.estimateSize();
+        }
+
+        @Override
+        public int characteristics() {
+            return source.characteristics() & (DISTINCT | NONNULL);
+        }
+    }
+    
+    static final class TDOfInt extends AbstractIntSpliterator implements IntConsumer {
+        private final IntPredicate predicate;
+        private final boolean drop;
+        private final boolean inclusive;
+        private boolean checked;
+        private final Spliterator.OfInt source;
+        private int cur;
+    
+        TDOfInt(Spliterator.OfInt source, boolean drop, boolean inclusive, IntPredicate predicate) {
+            super(source.estimateSize(), source.characteristics() & (ORDERED | SORTED | CONCURRENT | IMMUTABLE | NONNULL
+                | DISTINCT));
+            this.drop = drop;
+            this.predicate = predicate;
+            this.inclusive = inclusive;
+            this.source = source;
+        }
+    
+        @Override
+        public Comparator<? super Integer> getComparator() {
+            return source.getComparator();
+        }
+    
+        @Override
+        public boolean tryAdvance(IntConsumer action) {
+            if (drop) {
+                if (checked)
+                    return source.tryAdvance(action);
+                while (source.tryAdvance(this)) {
+                    if (!predicate.test(cur)) {
+                        checked = true;
+                        action.accept(cur);
+                        return true;
+                    }
+                }
+                return false;
+            }
+            if (!checked && source.tryAdvance(this) && (predicate.test(cur) || (checked = inclusive))) {
+                action.accept(cur);
+                return true;
+            }
+            checked = true;
+            return false;
+        }
+    
+        @Override
+        public void forEachRemaining(IntConsumer action) {
+            if (drop) {
+                if (checked)
+                    source.forEachRemaining(action);
+                else {
+                    source.forEachRemaining((int e) -> {
+                        if (checked)
+                            action.accept(e);
+                        else {
+                            if (!predicate.test(e)) {
+                                checked = true;
+                                action.accept(e);
+                            }
+                        }
+                    });
+                }
+            } else
+                super.forEachRemaining(action);
+        }
+    
+        @Override
+        public void accept(int t) {
+            this.cur = t;
+        }
+    }
+
+    static final class TDOfLong extends AbstractLongSpliterator implements LongConsumer {
+        private final LongPredicate predicate;
+        private final boolean drop;
+        private final boolean inclusive;
+        private boolean checked;
+        private final Spliterator.OfLong source;
+        private long cur;
+    
+        TDOfLong(Spliterator.OfLong source, boolean drop, boolean inclusive, LongPredicate predicate) {
+            super(source.estimateSize(), source.characteristics() & (ORDERED | SORTED | CONCURRENT | IMMUTABLE | NONNULL
+                | DISTINCT));
+            this.drop = drop;
+            this.predicate = predicate;
+            this.inclusive = inclusive;
+            this.source = source;
+        }
+    
+        @Override
+        public Comparator<? super Long> getComparator() {
+            return source.getComparator();
+        }
+    
+        @Override
+        public boolean tryAdvance(LongConsumer action) {
+            if (drop) {
+                if (checked)
+                    return source.tryAdvance(action);
+                while (source.tryAdvance(this)) {
+                    if (!predicate.test(cur)) {
+                        checked = true;
+                        action.accept(cur);
+                        return true;
+                    }
+                }
+                return false;
+            }
+            if (!checked && source.tryAdvance(this) && (predicate.test(cur) || (checked = inclusive))) {
+                action.accept(cur);
+                return true;
+            }
+            checked = true;
+            return false;
+        }
+    
+        @Override
+        public void forEachRemaining(LongConsumer action) {
+            if (drop) {
+                if (checked)
+                    source.forEachRemaining(action);
+                else {
+                    source.forEachRemaining((long e) -> {
+                        if (checked)
+                            action.accept(e);
+                        else {
+                            if (!predicate.test(e)) {
+                                checked = true;
+                                action.accept(e);
+                            }
+                        }
+                    });
+                }
+            } else
+                super.forEachRemaining(action);
+        }
+    
+        @Override
+        public void accept(long t) {
+            this.cur = t;
+        }
+    }
+
+    static final class TDOfDouble extends AbstractDoubleSpliterator implements DoubleConsumer {
+        private final DoublePredicate predicate;
+        private final boolean drop;
+        private final boolean inclusive;
+        private boolean checked;
+        private final Spliterator.OfDouble source;
+        private double cur;
+    
+        TDOfDouble(Spliterator.OfDouble source, boolean drop, boolean inclusive, DoublePredicate predicate) {
+            super(source.estimateSize(), source.characteristics() & (ORDERED | SORTED | CONCURRENT | IMMUTABLE | NONNULL
+                | DISTINCT));
+            this.drop = drop;
+            this.predicate = predicate;
+            this.inclusive = inclusive;
+            this.source = source;
+        }
+    
+        @Override
+        public Comparator<? super Double> getComparator() {
+            return source.getComparator();
+        }
+    
+        @Override
+        public boolean tryAdvance(DoubleConsumer action) {
+            if (drop) {
+                if (checked)
+                    return source.tryAdvance(action);
+                while (source.tryAdvance(this)) {
+                    if (!predicate.test(cur)) {
+                        checked = true;
+                        action.accept(cur);
+                        return true;
+                    }
+                }
+                return false;
+            }
+            if (!checked && source.tryAdvance(this) && (predicate.test(cur) || (checked = inclusive))) {
+                action.accept(cur);
+                return true;
+            }
+            checked = true;
+            return false;
+        }
+    
+        @Override
+        public void forEachRemaining(DoubleConsumer action) {
+            if (drop) {
+                if (checked)
+                    source.forEachRemaining(action);
+                else {
+                    source.forEachRemaining((double e) -> {
+                        if (checked)
+                            action.accept(e);
+                        else {
+                            if (!predicate.test(e)) {
+                                checked = true;
+                                action.accept(e);
+                            }
+                        }
+                    });
+                }
+            } else
+                super.forEachRemaining(action);
+        }
+    
+        @Override
+        public void accept(double t) {
+            this.cur = t;
+        }
+    }
+}
diff --git a/src/test/java/one/util/streamex/StreamExTest.java b/src/test/java/one/util/streamex/StreamExTest.java
index c2d69da..d1d1c94 100644
--- a/src/test/java/one/util/streamex/StreamExTest.java
+++ b/src/test/java/one/util/streamex/StreamExTest.java
@@ -1597,6 +1597,25 @@ public class StreamExTest {
         Spliterator<String> spliterator = StreamEx.of("aaa", "b", "cccc").dropWhile(x -> x.length() > 1).spliterator();
         assertEquals(hasDropWhile, !spliterator.getClass().getSimpleName().equals("TDOfRef"));
     }
+    
+    @Test
+    public void testTakeDropUnordered() {
+        repeat(10, n -> {
+            withRandom(rnd -> {
+                List<Boolean> data = IntStreamEx.of(rnd, n*100, 0, rnd.nextInt(10)+2).mapToObj(x -> x != 0).toList();
+                List<Boolean> sorted = StreamEx.of(data).sorted().toList();
+                streamEx(() -> data.stream().unordered(), s -> {
+                    assertFalse(StreamEx.of(s.get().takeWhile(b -> b).toList()).has(false));
+                    assertEquals(1L, StreamEx.of(s.get().takeWhileInclusive(b -> b).toList()).without(true).count());
+                    assertTrue(s.get().dropWhile(b -> true).toList().isEmpty());
+                    assertTrue(s.get().takeWhile(b -> false).toList().isEmpty());
+                    assertEquals(1L, s.get().takeWhileInclusive(b -> false).count());
+                    assertEquals(sorted, s.get().dropWhile(b -> false).sorted().toList());
+                    assertEquals(sorted, s.get().takeWhileInclusive(b -> true).sorted().toList());
+                });
+            });    
+        });
+    }
 
     @Test
     public void testOfPairs() {
