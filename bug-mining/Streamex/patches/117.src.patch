diff --git a/src/main/java/one/util/streamex/AbstractStreamEx.java b/src/main/java/one/util/streamex/AbstractStreamEx.java
index f79af17..8be4ca8 100644
--- a/src/main/java/one/util/streamex/AbstractStreamEx.java
+++ b/src/main/java/one/util/streamex/AbstractStreamEx.java
@@ -28,6 +28,7 @@ import java.util.Set;
 import java.util.Spliterator;
 import java.util.Spliterators;
 import java.util.Spliterators.AbstractSpliterator;
+import java.util.concurrent.ForkJoinPool;
 import java.util.function.BiConsumer;
 import java.util.function.BiFunction;
 import java.util.function.BinaryOperator;
@@ -50,9 +51,8 @@ import java.util.stream.Collector.Characteristics;
 
 import static one.util.streamex.StreamExInternals.*;
 
-/* package */abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> implements Stream<T>, Iterable<T> {
-    private static final String CONSUMED_MESSAGE = "Stream is already consumed";
-
+/* package */abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> extends
+        BaseStreamEx<T, Stream<T>, Spliterator<T>> implements Stream<T>, Iterable<T> {
     private static final class TDOfRef<T> extends AbstractSpliterator<T> implements Consumer<T> {
         private final Predicate<? super T> predicate;
         private final boolean drop;
@@ -101,34 +101,21 @@ import static one.util.streamex.StreamExInternals.*;
         }
     }
 
-    Stream<T> stream;
-    private Spliterator<T> spliterator;
-    private boolean isParallel;
-
-    AbstractStreamEx(Stream<T> stream) {
-        this.stream = stream;
+    AbstractStreamEx(Stream<T> stream, ExecutionStrategy strategy) {
+        super(stream, strategy);
     }
 
-    AbstractStreamEx(Spliterator<T> spliterator) {
-        this.spliterator = spliterator;
+    AbstractStreamEx(Spliterator<T> spliterator, ExecutionStrategy strategy) {
+        super(spliterator, strategy);
     }
     
-    StreamFactory strategy() {
-        return StreamFactory.DEFAULT;
-    }
-
-    Stream<T> stream() {
-        if(stream != null)
-            return stream;
-        if(spliterator == null)
-            throw new IllegalStateException(CONSUMED_MESSAGE);
-        stream = StreamSupport.stream(spliterator, isParallel);
-        spliterator = null;
-        return stream;
+    @Override
+    final Stream<T> createStream() {
+        return StreamSupport.stream(spliterator, strategy.isParallel());
     }
 
     final <R> Stream<R> delegate(Spliterator<R> spliterator) {
-        return delegateClose(StreamSupport.stream(spliterator, isParallel()), stream);
+        return forwardClose(StreamSupport.stream(spliterator, isParallel()));
     }
 
     final S callWhile(Predicate<? super T> predicate, int methodId) {
@@ -156,6 +143,8 @@ import static one.util.streamex.StreamExInternals.*;
     }
 
     <R, A> R rawCollect(Collector<? super T, A, R> collector) {
+        if(strategy.getFjp() != null)
+            return strategy.terminate(collector, stream()::collect);
         return stream().collect(collector);
     }
 
@@ -169,7 +158,7 @@ import static one.util.streamex.StreamExInternals.*;
             result = (Spliterator<T>) right;
         else
             result = new TailConcatSpliterator<>(left, right);
-        return supply(delegateClose(delegateClose(StreamSupport.stream(result, isParallel()), stream), other));
+        return supply(StreamExInternals.delegateClose(forwardClose(StreamSupport.stream(result, isParallel())), other));
     }
 
     @SuppressWarnings("unchecked")
@@ -182,7 +171,7 @@ import static one.util.streamex.StreamExInternals.*;
             result = (Spliterator<T>) left;
         else
             result = new TailConcatSpliterator<>(left, right);
-        return supply(delegateClose(delegateClose(StreamSupport.stream(result, isParallel()), stream), other));
+        return supply(StreamExInternals.delegateClose(forwardClose(StreamSupport.stream(result, isParallel())), other));
     }
 
     abstract S supply(Stream<T> stream);
@@ -192,38 +181,34 @@ import static one.util.streamex.StreamExInternals.*;
         return Spliterators.iterator(spliterator());
     }
 
+    @SuppressWarnings("unchecked")
     @Override
-    public Spliterator<T> spliterator() {
-        if(stream != null)
-            return stream.spliterator();
-        if(spliterator != null)
-            return spliterator;
-        throw new IllegalStateException(CONSUMED_MESSAGE);
+    public S sequential() {
+        return (S) super.sequential();
     }
 
+    @SuppressWarnings("unchecked")
     @Override
-    public boolean isParallel() {
-        return stream == null ? isParallel : stream.isParallel();
+    public S parallel() {
+        return (S) super.parallel();
     }
 
-    @SuppressWarnings("unchecked")
     @Override
-    public S unordered() {
-        stream = stream().unordered();
-        return (S) this;
+    @SuppressWarnings("unchecked")
+    public S parallel(ForkJoinPool fjp) {
+        return (S) super.parallel(fjp);
     }
 
     @SuppressWarnings("unchecked")
     @Override
-    public S onClose(Runnable closeHandler) {
-        stream = stream().onClose(closeHandler);
-        return (S) this;
+    public S unordered() {
+        return (S) super.unordered();
     }
 
+    @SuppressWarnings("unchecked")
     @Override
-    public void close() {
-        if(stream != null)
-            stream.close();
+    public S onClose(Runnable closeHandler) {
+        return (S) super.onClose(closeHandler);
     }
 
     @Override
@@ -233,42 +218,42 @@ import static one.util.streamex.StreamExInternals.*;
 
     @Override
     public <R> StreamEx<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper) {
-        return strategy().newStreamEx(stream().flatMap(mapper));
+        return new StreamEx<>(stream().flatMap(mapper), strategy);
     }
 
     @Override
     public <R> StreamEx<R> map(Function<? super T, ? extends R> mapper) {
-        return strategy().newStreamEx(stream().map(mapper));
+        return new StreamEx<>(stream().map(mapper), strategy);
     }
 
     @Override
     public IntStreamEx mapToInt(ToIntFunction<? super T> mapper) {
-        return strategy().newIntStreamEx(stream().mapToInt(mapper));
+        return new IntStreamEx(stream().mapToInt(mapper), strategy);
     }
 
     @Override
     public LongStreamEx mapToLong(ToLongFunction<? super T> mapper) {
-        return strategy().newLongStreamEx(stream().mapToLong(mapper));
+        return new LongStreamEx(stream().mapToLong(mapper), strategy);
     }
 
     @Override
     public DoubleStreamEx mapToDouble(ToDoubleFunction<? super T> mapper) {
-        return strategy().newDoubleStreamEx(stream().mapToDouble(mapper));
+        return new DoubleStreamEx(stream().mapToDouble(mapper), strategy);
     }
 
     @Override
     public IntStreamEx flatMapToInt(Function<? super T, ? extends IntStream> mapper) {
-        return strategy().newIntStreamEx(stream().flatMapToInt(mapper));
+        return new IntStreamEx(stream().flatMapToInt(mapper), strategy);
     }
 
     @Override
     public LongStreamEx flatMapToLong(Function<? super T, ? extends LongStream> mapper) {
-        return strategy().newLongStreamEx(stream().flatMapToLong(mapper));
+        return new LongStreamEx(stream().flatMapToLong(mapper), strategy);
     }
 
     @Override
     public DoubleStreamEx flatMapToDouble(Function<? super T, ? extends DoubleStream> mapper) {
-        return strategy().newDoubleStreamEx(stream().flatMapToDouble(mapper));
+        return new DoubleStreamEx(stream().flatMapToDouble(mapper), strategy);
     }
 
     @Override
@@ -326,18 +311,36 @@ import static one.util.streamex.StreamExInternals.*;
 
     @Override
     public void forEach(Consumer<? super T> action) {
-        if(spliterator != null && !isParallel)
+        if (spliterator != null && !isParallel()) {
             spliterator.forEachRemaining(action);
-        else
-            stream().forEach(action);
+            spliterator = null;
+        } else {
+            if(strategy.getFjp() != null)
+                strategy.terminate(() -> {
+                    stream().forEach(action);
+                    return null;
+                });
+            else {
+                stream().forEach(action);
+            }
+        }
     }
 
     @Override
     public void forEachOrdered(Consumer<? super T> action) {
-        if(spliterator != null && !isParallel)
+        if (spliterator != null && !isParallel()) {
             spliterator.forEachRemaining(action);
-        else
-            stream().forEachOrdered(action);
+            spliterator = null;
+        } else {
+            if(strategy.getFjp() != null)
+                strategy.terminate(() -> {
+                    stream().forEachOrdered(action);
+                    return null;
+                });
+            else {
+                stream().forEachOrdered(action);
+            }
+        }
     }
 
     @Override
@@ -347,26 +350,36 @@ import static one.util.streamex.StreamExInternals.*;
 
     @Override
     public <A> A[] toArray(IntFunction<A[]> generator) {
+        if(strategy.getFjp() != null)
+            return strategy.terminate(generator, stream()::toArray);
         return stream().toArray(generator);
     }
 
     @Override
     public T reduce(T identity, BinaryOperator<T> accumulator) {
+        if(strategy.getFjp() != null)
+            return strategy.terminate(() -> stream().reduce(identity, accumulator));
         return stream().reduce(identity, accumulator);
     }
 
     @Override
     public Optional<T> reduce(BinaryOperator<T> accumulator) {
+        if(strategy.getFjp() != null)
+            return strategy.terminate(accumulator, stream()::reduce);
         return stream().reduce(accumulator);
     }
 
     @Override
     public <U> U reduce(U identity, BiFunction<U, ? super T, U> accumulator, BinaryOperator<U> combiner) {
+        if(strategy.getFjp() != null)
+            return strategy.terminate(() -> stream().reduce(identity, accumulator, combiner));
         return stream().reduce(identity, accumulator, combiner);
     }
 
     @Override
     public <R> R collect(Supplier<R> supplier, BiConsumer<R, ? super T> accumulator, BiConsumer<R, R> combiner) {
+        if(strategy.getFjp() != null)
+            return strategy.terminate(() -> stream().collect(supplier, accumulator, combiner));
         return stream().collect(supplier, accumulator, combiner);
     }
 
@@ -412,7 +425,7 @@ import static one.util.streamex.StreamExInternals.*;
                 spltr = new OrderedCancellableSpliterator<>(spliterator, collector.supplier(), acc, combiner, finished);
             }
             return collector.finisher().apply(
-                strategy().newStreamEx(StreamSupport.stream(spltr, true)).findFirst().get());
+                new StreamEx<>(StreamSupport.stream(spltr, true), strategy).findFirst().get());
         }
         return rawCollect(collector);
     }
@@ -429,16 +442,22 @@ import static one.util.streamex.StreamExInternals.*;
 
     @Override
     public long count() {
+        if(strategy.getFjp() != null)
+            return strategy.terminate(stream()::count);
         return stream().count();
     }
 
     @Override
     public boolean anyMatch(Predicate<? super T> predicate) {
+        if(strategy.getFjp() != null)
+            return strategy.terminate(predicate, stream()::anyMatch);
         return stream().anyMatch(predicate);
     }
 
     @Override
     public boolean allMatch(Predicate<? super T> predicate) {
+        if(strategy.getFjp() != null)
+            return strategy.terminate(predicate, stream()::allMatch);
         return stream().allMatch(predicate);
     }
 
@@ -449,11 +468,15 @@ import static one.util.streamex.StreamExInternals.*;
 
     @Override
     public Optional<T> findFirst() {
+        if(strategy.getFjp() != null)
+            return strategy.terminate(stream()::findFirst);
         return stream().findFirst();
     }
 
     @Override
     public Optional<T> findAny() {
+        if(strategy.getFjp() != null)
+            return strategy.terminate(stream()::findAny);
         return stream().findAny();
     }
 
@@ -1102,6 +1125,8 @@ import static one.util.streamex.StreamExInternals.*;
      * @see #toList()
      */
     public <R> R toListAndThen(Function<List<T>, R> finisher) {
+        if(strategy.getFjp() != null)
+            return strategy.terminate(() -> finisher.apply(toList()));
         return finisher.apply(toList());
     }
 
diff --git a/src/main/java/one/util/streamex/BaseStreamEx.java b/src/main/java/one/util/streamex/BaseStreamEx.java
new file mode 100644
index 0000000..d949310
--- /dev/null
+++ b/src/main/java/one/util/streamex/BaseStreamEx.java
@@ -0,0 +1,146 @@
+/*
+ * Copyright 2015, 2016 Tagir Valeev
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package one.util.streamex;
+
+import java.util.Spliterator;
+import java.util.concurrent.ForkJoinPool;
+import java.util.stream.BaseStream;
+
+/**
+ * @author Tagir Valeev
+ */
+/* package */abstract class BaseStreamEx<T, S extends BaseStream<T, S>, SPLTR extends Spliterator<T>>
+        implements BaseStream<T, S> {
+    static final String CONSUMED_MESSAGE = "Stream is already consumed";
+
+    private S stream;
+    SPLTR spliterator;
+    ExecutionStrategy strategy;
+    
+    BaseStreamEx(S stream, ExecutionStrategy strategy) {
+        this.stream = stream;
+        this.strategy = strategy;
+    }
+
+    BaseStreamEx(SPLTR spliterator, ExecutionStrategy strategy) {
+        this.spliterator = spliterator;
+        this.strategy = strategy;
+    }
+    
+    abstract S createStream();
+
+    S stream() {
+        if(stream != null)
+            return stream;
+        if(spliterator == null)
+            throw new IllegalStateException(CONSUMED_MESSAGE);
+        stream = createStream();
+        spliterator = null;
+        return stream;
+    }
+    
+    <B extends BaseStream<?, ?>> B forwardClose(B proxy) {
+        return StreamExInternals.delegateClose(proxy, stream);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public SPLTR spliterator() {
+        if(stream != null)
+            return (SPLTR) stream.spliterator();
+        if(spliterator != null)
+            return spliterator;
+        throw new IllegalStateException(CONSUMED_MESSAGE);
+    }
+
+    @Override
+    public boolean isParallel() {
+        return strategy.isParallel();
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public S sequential() {
+        strategy = ExecutionStrategy.SEQUENTIAL;
+        if(stream != null)
+            stream = stream.sequential();
+        return (S) this;
+    }
+
+    /**
+     * {@inheritDoc}
+     * 
+     * <p>
+     * If this stream was created using {@link #parallel(ForkJoinPool)}, the new
+     * stream forgets about supplied custom {@link ForkJoinPool} and its
+     * terminal operation will be executed in common pool.
+     */
+    @SuppressWarnings("unchecked")
+    @Override
+    public S parallel() {
+        strategy = ExecutionStrategy.PARALLEL;
+        if(stream != null)
+            stream = stream.parallel();
+        return (S)this;
+    }
+
+    /**
+     * Returns an equivalent stream that is parallel and bound to the supplied
+     * {@link ForkJoinPool}.
+     *
+     * <p>
+     * This is an <a href="package-summary.html#StreamOps">intermediate</a>
+     * operation.
+     * 
+     * <p>
+     * The terminal operation of this stream or any derived stream (except the
+     * streams created via {@link #parallel()} or {@link #sequential()} methods)
+     * will be executed inside the supplied {@code ForkJoinPool}. If current
+     * thread does not belong to that pool, it will wait till calculation
+     * finishes.
+     *
+     * @param fjp a {@code ForkJoinPool} to submit the stream operation to.
+     * @return a parallel stream bound to the supplied {@code ForkJoinPool}
+     * @since 0.2.0
+     */
+    @SuppressWarnings("unchecked")
+    public S parallel(ForkJoinPool fjp) {
+        strategy = new ExecutionStrategy(fjp);
+        return (S) this;
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public S unordered() {
+        stream = stream().unordered();
+        return (S) this;
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public S onClose(Runnable closeHandler) {
+        stream = stream().onClose(closeHandler);
+        return (S) this;
+    }
+
+    @Override
+    public void close() {
+        if(stream != null)
+            stream.close();
+    }
+
+    
+}
diff --git a/src/main/java/one/util/streamex/DoubleStreamEx.java b/src/main/java/one/util/streamex/DoubleStreamEx.java
index 84b883e..d9b3282 100644
--- a/src/main/java/one/util/streamex/DoubleStreamEx.java
+++ b/src/main/java/one/util/streamex/DoubleStreamEx.java
@@ -26,6 +26,7 @@ import java.util.OptionalLong;
 import java.util.PrimitiveIterator;
 import java.util.Random;
 import java.util.Spliterator;
+import java.util.Spliterators;
 import java.util.Map.Entry;
 import java.util.PrimitiveIterator.OfDouble;
 import java.util.Spliterators.AbstractDoubleSpliterator;
@@ -56,7 +57,7 @@ import static one.util.streamex.StreamExInternals.*;
  * 
  * @author Tagir Valeev
  */
-public class DoubleStreamEx implements DoubleStream {
+public class DoubleStreamEx extends BaseStreamEx<Double, DoubleStream, Spliterator.OfDouble> implements DoubleStream {
     private static final class TDOfDouble extends AbstractDoubleSpliterator implements DoubleConsumer {
         private final DoublePredicate predicate;
         private final boolean drop;
@@ -105,25 +106,27 @@ public class DoubleStreamEx implements DoubleStream {
         }
     }
 
-    final DoubleStream stream;
+    DoubleStreamEx(DoubleStream stream, ExecutionStrategy strategy) {
+        super(stream, strategy);
+    }
 
-    DoubleStreamEx(DoubleStream stream) {
-        this.stream = stream;
+    DoubleStreamEx(Spliterator.OfDouble spliterator, ExecutionStrategy strategy) {
+        super(spliterator, strategy);
     }
 
-    StreamFactory strategy() {
-        return StreamFactory.DEFAULT;
+    @Override
+    DoubleStream createStream() {
+        return StreamSupport.doubleStream(spliterator, isParallel());
     }
 
     final DoubleStreamEx delegate(Spliterator.OfDouble spliterator) {
-        return strategy().newDoubleStreamEx(
-            delegateClose(StreamSupport.doubleStream(spliterator, stream.isParallel()), stream));
+        return new DoubleStreamEx(forwardClose(StreamSupport.doubleStream(spliterator, isParallel())), strategy);
     }
 
     final DoubleStreamEx callWhile(DoublePredicate predicate, int methodId) {
         try {
-            return strategy().newDoubleStreamEx(
-                (DoubleStream) JDK9_METHODS[IDX_DOUBLE_STREAM][methodId].invokeExact(stream, predicate));
+            return new DoubleStreamEx(
+                (DoubleStream) JDK9_METHODS[IDX_DOUBLE_STREAM][methodId].invokeExact(stream(), predicate), strategy);
         } catch (Error | RuntimeException e) {
             throw e;
         } catch (Throwable e) {
@@ -131,29 +134,19 @@ public class DoubleStreamEx implements DoubleStream {
         }
     }
 
-    @Override
-    public boolean isParallel() {
-        return stream.isParallel();
-    }
-
     @Override
     public DoubleStreamEx unordered() {
-        return strategy().newDoubleStreamEx(stream.unordered());
+        return (DoubleStreamEx) super.unordered();
     }
 
     @Override
     public DoubleStreamEx onClose(Runnable closeHandler) {
-        return strategy().newDoubleStreamEx(stream.onClose(closeHandler));
-    }
-
-    @Override
-    public void close() {
-        stream.close();
+        return (DoubleStreamEx) super.onClose(closeHandler);
     }
 
     @Override
     public DoubleStreamEx filter(DoublePredicate predicate) {
-        return strategy().newDoubleStreamEx(stream.filter(predicate));
+        return new DoubleStreamEx(stream().filter(predicate), strategy);
     }
 
     /**
@@ -233,7 +226,7 @@ public class DoubleStreamEx implements DoubleStream {
 
     @Override
     public DoubleStreamEx map(DoubleUnaryOperator mapper) {
-        return strategy().newDoubleStreamEx(stream.map(mapper));
+        return new DoubleStreamEx(stream().map(mapper), strategy);
     }
 
     /**
@@ -252,7 +245,8 @@ public class DoubleStreamEx implements DoubleStream {
      * @since 0.4.1
      */
     public DoubleStreamEx mapFirst(DoubleUnaryOperator mapper) {
-        return delegate(new PairSpliterator.PSOfDouble((a, b) -> b, mapper, stream.spliterator(), PairSpliterator.MODE_MAP_FIRST));
+        return delegate(new PairSpliterator.PSOfDouble((a, b) -> b, mapper, spliterator(),
+                PairSpliterator.MODE_MAP_FIRST));
     }
 
     /**
@@ -271,22 +265,22 @@ public class DoubleStreamEx implements DoubleStream {
      * @since 0.4.1
      */
     public DoubleStreamEx mapLast(DoubleUnaryOperator mapper) {
-        return delegate(new PairSpliterator.PSOfDouble((a, b) -> a, mapper, stream.spliterator(), PairSpliterator.MODE_MAP_LAST));
+        return delegate(new PairSpliterator.PSOfDouble((a, b) -> a, mapper, spliterator(), PairSpliterator.MODE_MAP_LAST));
     }
 
     @Override
     public <U> StreamEx<U> mapToObj(DoubleFunction<? extends U> mapper) {
-        return strategy().newStreamEx(stream.mapToObj(mapper));
+        return new StreamEx<>(stream().mapToObj(mapper), strategy);
     }
 
     @Override
     public IntStreamEx mapToInt(DoubleToIntFunction mapper) {
-        return strategy().newIntStreamEx(stream.mapToInt(mapper));
+        return new IntStreamEx(stream().mapToInt(mapper), strategy);
     }
 
     @Override
     public LongStreamEx mapToLong(DoubleToLongFunction mapper) {
-        return strategy().newLongStreamEx(stream.mapToLong(mapper));
+        return new LongStreamEx(stream().mapToLong(mapper), strategy);
     }
 
     /**
@@ -308,13 +302,13 @@ public class DoubleStreamEx implements DoubleStream {
      */
     public <K, V> EntryStream<K, V> mapToEntry(DoubleFunction<? extends K> keyMapper,
             DoubleFunction<? extends V> valueMapper) {
-        return strategy().newEntryStream(
-            stream.mapToObj(t -> new AbstractMap.SimpleImmutableEntry<>(keyMapper.apply(t), valueMapper.apply(t))));
+        return new EntryStream<>(stream().mapToObj(
+            t -> new AbstractMap.SimpleImmutableEntry<>(keyMapper.apply(t), valueMapper.apply(t))), strategy);
     }
 
     @Override
     public DoubleStreamEx flatMap(DoubleFunction<? extends DoubleStream> mapper) {
-        return strategy().newDoubleStreamEx(stream.flatMap(mapper));
+        return new DoubleStreamEx(stream().flatMap(mapper), strategy);
     }
 
     /**
@@ -333,7 +327,7 @@ public class DoubleStreamEx implements DoubleStream {
      * @since 0.3.0
      */
     public IntStreamEx flatMapToInt(DoubleFunction<? extends IntStream> mapper) {
-        return strategy().newIntStreamEx(stream.mapToObj(mapper).flatMapToInt(Function.identity()));
+        return new IntStreamEx(stream().mapToObj(mapper).flatMapToInt(Function.identity()), strategy);
     }
 
     /**
@@ -352,7 +346,7 @@ public class DoubleStreamEx implements DoubleStream {
      * @since 0.3.0
      */
     public LongStreamEx flatMapToLong(DoubleFunction<? extends LongStream> mapper) {
-        return strategy().newLongStreamEx(stream.mapToObj(mapper).flatMapToLong(Function.identity()));
+        return new LongStreamEx(stream().mapToObj(mapper).flatMapToLong(Function.identity()), strategy);
     }
 
     /**
@@ -372,17 +366,17 @@ public class DoubleStreamEx implements DoubleStream {
      * @since 0.3.0
      */
     public <R> StreamEx<R> flatMapToObj(DoubleFunction<? extends Stream<R>> mapper) {
-        return strategy().newStreamEx(stream.mapToObj(mapper).flatMap(Function.identity()));
+        return new StreamEx<>(stream().mapToObj(mapper).flatMap(Function.identity()), strategy);
     }
 
     @Override
     public DoubleStreamEx distinct() {
-        return strategy().newDoubleStreamEx(stream.distinct());
+        return new DoubleStreamEx(stream().distinct(), strategy);
     }
 
     @Override
     public DoubleStreamEx sorted() {
-        return strategy().newDoubleStreamEx(stream.sorted());
+        return new DoubleStreamEx(stream().sorted(), strategy);
     }
 
     /**
@@ -405,7 +399,7 @@ public class DoubleStreamEx implements DoubleStream {
      * @return the new stream
      */
     public DoubleStreamEx sorted(Comparator<Double> comparator) {
-        return strategy().newDoubleStreamEx(stream.boxed().sorted(comparator).mapToDouble(Double::doubleValue));
+        return new DoubleStreamEx(stream().boxed().sorted(comparator).mapToDouble(Double::doubleValue), strategy);
     }
 
     /**
@@ -515,17 +509,17 @@ public class DoubleStreamEx implements DoubleStream {
 
     @Override
     public DoubleStreamEx peek(DoubleConsumer action) {
-        return strategy().newDoubleStreamEx(stream.peek(action));
+        return new DoubleStreamEx(stream().peek(action), strategy);
     }
 
     @Override
     public DoubleStreamEx limit(long maxSize) {
-        return strategy().newDoubleStreamEx(stream.limit(maxSize));
+        return new DoubleStreamEx(stream().limit(maxSize), strategy);
     }
 
     @Override
     public DoubleStreamEx skip(long n) {
-        return strategy().newDoubleStreamEx(stream.skip(n));
+        return new DoubleStreamEx(stream().skip(n), strategy);
     }
 
     /**
@@ -561,24 +555,50 @@ public class DoubleStreamEx implements DoubleStream {
      * @since 0.3.2
      */
     public DoubleStreamEx skipOrdered(long n) {
-        Spliterator.OfDouble spliterator = (stream.isParallel() ? StreamSupport.doubleStream(stream.spliterator(),
-            false) : stream).skip(n).spliterator();
+        Spliterator.OfDouble spliterator = (isParallel() ? StreamSupport.doubleStream(spliterator(), false) : stream())
+                .skip(n).spliterator();
         return delegate(spliterator);
     }
 
     @Override
     public void forEach(DoubleConsumer action) {
-        stream.forEach(action);
+        if (spliterator != null && !isParallel()) {
+            spliterator.forEachRemaining(action);
+            spliterator = null;
+        } else {
+            if(strategy.getFjp() != null)
+                strategy.terminate(() -> {
+                    stream().forEach(action);
+                    return null;
+                });
+            else {
+                stream().forEach(action);
+            }
+        }
     }
 
     @Override
     public void forEachOrdered(DoubleConsumer action) {
-        stream.forEachOrdered(action);
+        if (spliterator != null && !isParallel()) {
+            spliterator.forEachRemaining(action);
+            spliterator = null;
+        } else {
+            if(strategy.getFjp() != null)
+                strategy.terminate(() -> {
+                    stream().forEachOrdered(action);
+                    return null;
+                });
+            else {
+                stream().forEachOrdered(action);
+            }
+        }
     }
 
     @Override
     public double[] toArray() {
-        return stream.toArray();
+        if(strategy.getFjp() != null)
+            return strategy.terminate(stream()::toArray);
+        return stream().toArray();
     }
 
     /**
@@ -594,7 +614,7 @@ public class DoubleStreamEx implements DoubleStream {
     public float[] toFloatArray() {
         if (isParallel())
             return collect(DoubleCollector.toFloatArray());
-        java.util.Spliterator.OfDouble spliterator = stream.spliterator();
+        java.util.Spliterator.OfDouble spliterator = spliterator();
         long size = spliterator.getExactSizeIfKnown();
         FloatBuffer buf;
         if (size >= 0 && size <= Integer.MAX_VALUE) {
@@ -609,12 +629,16 @@ public class DoubleStreamEx implements DoubleStream {
 
     @Override
     public double reduce(double identity, DoubleBinaryOperator op) {
-        return stream.reduce(identity, op);
+        if(strategy.getFjp() != null)
+            return strategy.terminate(() -> stream().reduce(identity, op));
+        return stream().reduce(identity, op);
     }
 
     @Override
     public OptionalDouble reduce(DoubleBinaryOperator op) {
-        return stream.reduce(op);
+        if(strategy.getFjp() != null)
+            return strategy.terminate(op, stream()::reduce);
+        return stream().reduce(op);
     }
 
     /**
@@ -660,7 +684,7 @@ public class DoubleStreamEx implements DoubleStream {
      */
     public OptionalDouble foldLeft(DoubleBinaryOperator accumulator) {
         PrimitiveBox b = new PrimitiveBox();
-        stream.forEachOrdered(t -> {
+        forEachOrdered(t -> {
             if (b.b)
                 b.d = accumulator.applyAsDouble(b.d, t);
             else {
@@ -709,7 +733,7 @@ public class DoubleStreamEx implements DoubleStream {
      */
     public double foldLeft(double seed, DoubleBinaryOperator accumulator) {
         double[] box = new double[] { seed };
-        stream.forEachOrdered(t -> box[0] = accumulator.applyAsDouble(box[0], t));
+        forEachOrdered(t -> box[0] = accumulator.applyAsDouble(box[0], t));
         return box[0];
     }
 
@@ -741,7 +765,7 @@ public class DoubleStreamEx implements DoubleStream {
      * @since 0.5.1
      */
     public double[] scanLeft(DoubleBinaryOperator accumulator) {
-        Spliterator.OfDouble spliterator = stream.spliterator();
+        Spliterator.OfDouble spliterator = spliterator();
         double size = spliterator.getExactSizeIfKnown();
         DoubleBuffer buf = new DoubleBuffer(size >= 0 && size <= Integer.MAX_VALUE ? (int) size : INITIAL_SIZE);
         delegate(spliterator).forEachOrdered(
@@ -787,7 +811,9 @@ public class DoubleStreamEx implements DoubleStream {
      */
     @Override
     public <R> R collect(Supplier<R> supplier, ObjDoubleConsumer<R> accumulator, BiConsumer<R, R> combiner) {
-        return stream.collect(supplier, accumulator, combiner);
+        if(strategy.getFjp() != null)
+            return strategy.terminate(() -> stream().collect(supplier, accumulator, combiner));
+        return stream().collect(supplier, accumulator, combiner);
     }
 
     /**
@@ -822,7 +848,9 @@ public class DoubleStreamEx implements DoubleStream {
 
     @Override
     public double sum() {
-        return stream.sum();
+        if(strategy.getFjp() != null)
+            return strategy.terminate(stream()::sum);
+        return stream().sum();
     }
 
     @Override
@@ -1082,12 +1110,16 @@ public class DoubleStreamEx implements DoubleStream {
 
     @Override
     public long count() {
-        return stream.count();
+        if(strategy.getFjp() != null)
+            return strategy.terminate(stream()::count);
+        return stream().count();
     }
 
     @Override
     public OptionalDouble average() {
-        return stream.average();
+        if(strategy.getFjp() != null)
+            return strategy.terminate(stream()::average);
+        return stream().average();
     }
 
     @Override
@@ -1097,12 +1129,16 @@ public class DoubleStreamEx implements DoubleStream {
 
     @Override
     public boolean anyMatch(DoublePredicate predicate) {
-        return stream.anyMatch(predicate);
+        if(strategy.getFjp() != null)
+            return strategy.terminate(predicate, stream()::anyMatch);
+        return stream().anyMatch(predicate);
     }
 
     @Override
     public boolean allMatch(DoublePredicate predicate) {
-        return stream.allMatch(predicate);
+        if(strategy.getFjp() != null)
+            return strategy.terminate(predicate, stream()::allMatch);
+        return stream().allMatch(predicate);
     }
 
     @Override
@@ -1112,7 +1148,9 @@ public class DoubleStreamEx implements DoubleStream {
 
     @Override
     public OptionalDouble findFirst() {
-        return stream.findFirst();
+        if(strategy.getFjp() != null)
+            return strategy.terminate(stream()::findFirst);
+        return stream().findFirst();
     }
 
     /**
@@ -1138,7 +1176,9 @@ public class DoubleStreamEx implements DoubleStream {
 
     @Override
     public OptionalDouble findAny() {
-        return stream.findAny();
+        if(strategy.getFjp() != null)
+            return strategy.terminate(stream()::findAny);
+        return stream().findAny();
     }
 
     /**
@@ -1194,57 +1234,27 @@ public class DoubleStreamEx implements DoubleStream {
 
     @Override
     public StreamEx<Double> boxed() {
-        return strategy().newStreamEx(stream.boxed());
+        return new StreamEx<>(stream().boxed(), strategy);
     }
 
     @Override
     public DoubleStreamEx sequential() {
-        return StreamFactory.DEFAULT.newDoubleStreamEx(stream.sequential());
+        return (DoubleStreamEx) super.sequential();
     }
 
-    /**
-     * {@inheritDoc}
-     * 
-     * <p>
-     * If this stream was created using {@link #parallel(ForkJoinPool)}, the new
-     * stream forgets about supplied custom {@link ForkJoinPool} and its
-     * terminal operation will be executed in common pool.
-     */
     @Override
     public DoubleStreamEx parallel() {
-        return StreamFactory.DEFAULT.newDoubleStreamEx(stream.parallel());
+        return (DoubleStreamEx) super.parallel();
     }
 
-    /**
-     * Returns an equivalent stream that is parallel and bound to the supplied
-     * {@link ForkJoinPool}.
-     *
-     * <p>
-     * This is an intermediate operation.
-     * 
-     * <p>
-     * The terminal operation of this stream or any derived stream (except the
-     * streams created via {@link #parallel()} or {@link #sequential()} methods)
-     * will be executed inside the supplied {@code ForkJoinPool}. If current
-     * thread does not belong to that pool, it will wait till calculation
-     * finishes.
-     *
-     * @param fjp a {@code ForkJoinPool} to submit the stream operation to.
-     * @return a parallel stream bound to the supplied {@code ForkJoinPool}
-     * @since 0.2.0
-     */
+    @Override
     public DoubleStreamEx parallel(ForkJoinPool fjp) {
-        return StreamFactory.forCustomPool(fjp).newDoubleStreamEx(stream.parallel());
+        return (DoubleStreamEx) super.parallel(fjp);
     }
 
     @Override
     public OfDouble iterator() {
-        return stream.iterator();
-    }
-
-    @Override
-    public java.util.Spliterator.OfDouble spliterator() {
-        return stream.spliterator();
+        return Spliterators.iterator(spliterator());
     }
 
     /**
@@ -1261,7 +1271,7 @@ public class DoubleStreamEx implements DoubleStream {
     public DoubleStreamEx append(double... values) {
         if (values.length == 0)
             return this;
-        return strategy().newDoubleStreamEx(DoubleStream.concat(stream, DoubleStream.of(values)));
+        return new DoubleStreamEx(DoubleStream.concat(stream(), DoubleStream.of(values)), strategy);
     }
 
     /**
@@ -1276,7 +1286,7 @@ public class DoubleStreamEx implements DoubleStream {
      * @see DoubleStream#concat(DoubleStream, DoubleStream)
      */
     public DoubleStreamEx append(DoubleStream other) {
-        return strategy().newDoubleStreamEx(DoubleStream.concat(stream, other));
+        return new DoubleStreamEx(DoubleStream.concat(stream(), other), strategy.combine(other));
     }
 
     /**
@@ -1293,7 +1303,7 @@ public class DoubleStreamEx implements DoubleStream {
     public DoubleStreamEx prepend(double... values) {
         if (values.length == 0)
             return this;
-        return strategy().newDoubleStreamEx(DoubleStream.concat(DoubleStream.of(values), stream));
+        return new DoubleStreamEx(DoubleStream.concat(DoubleStream.of(values), stream()), strategy);
     }
 
     /**
@@ -1308,7 +1318,7 @@ public class DoubleStreamEx implements DoubleStream {
      * @see DoubleStream#concat(DoubleStream, DoubleStream)
      */
     public DoubleStreamEx prepend(DoubleStream other) {
-        return strategy().newDoubleStreamEx(DoubleStream.concat(other, stream));
+        return new DoubleStreamEx(DoubleStream.concat(other, stream()), strategy.combine(other));
     }
 
     /**
@@ -1329,7 +1339,7 @@ public class DoubleStreamEx implements DoubleStream {
      * @since 0.2.1
      */
     public DoubleStreamEx pairMap(DoubleBinaryOperator mapper) {
-        return delegate(new PairSpliterator.PSOfDouble(mapper, null, stream.spliterator(), PairSpliterator.MODE_PAIRS));
+        return delegate(new PairSpliterator.PSOfDouble(mapper, null, spliterator(), PairSpliterator.MODE_PAIRS));
     }
 
     /**
@@ -1396,7 +1406,7 @@ public class DoubleStreamEx implements DoubleStream {
         if (JDK9_METHODS != null) {
             return callWhile(predicate, IDX_TAKE_WHILE);
         }
-        return delegate(new DoubleStreamEx.TDOfDouble(stream.spliterator(), false, predicate));
+        return delegate(new DoubleStreamEx.TDOfDouble(spliterator(), false, predicate));
     }
 
     /**
@@ -1425,7 +1435,7 @@ public class DoubleStreamEx implements DoubleStream {
         if (JDK9_METHODS != null) {
             return callWhile(predicate, IDX_DROP_WHILE);
         }
-        return delegate(new DoubleStreamEx.TDOfDouble(stream.spliterator(), true, predicate));
+        return delegate(new DoubleStreamEx.TDOfDouble(spliterator(), true, predicate));
     }
 
     /**
@@ -1530,7 +1540,8 @@ public class DoubleStreamEx implements DoubleStream {
      * @since 0.0.8
      */
     public static DoubleStreamEx of(DoubleStream stream) {
-        return stream instanceof DoubleStreamEx ? (DoubleStreamEx) stream : new DoubleStreamEx(stream);
+        return stream instanceof DoubleStreamEx ? (DoubleStreamEx) stream : new DoubleStreamEx(stream,
+                ExecutionStrategy.of(stream));
     }
 
     /**
diff --git a/src/main/java/one/util/streamex/EntryStream.java b/src/main/java/one/util/streamex/EntryStream.java
index 3f10f07..125f5e9 100644
--- a/src/main/java/one/util/streamex/EntryStream.java
+++ b/src/main/java/one/util/streamex/EntryStream.java
@@ -30,7 +30,6 @@ import java.util.TreeMap;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.ConcurrentSkipListMap;
-import java.util.concurrent.ForkJoinPool;
 import java.util.function.BiConsumer;
 import java.util.function.BiFunction;
 import java.util.function.BiPredicate;
@@ -64,13 +63,18 @@ import static one.util.streamex.StreamExInternals.*;
  */
 public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream<K, V>> {
     @SuppressWarnings("unchecked")
-    EntryStream(Stream<? extends Entry<K, V>> stream) {
-        super((Stream<Entry<K, V>>) stream);
+    EntryStream(Stream<? extends Entry<K, V>> stream, ExecutionStrategy strategy) {
+        super((Stream<Entry<K, V>>) stream, strategy);
+    }
+
+    @SuppressWarnings("unchecked")
+    EntryStream(Spliterator<? extends Entry<K, V>> spliterator, ExecutionStrategy strategy) {
+        super((Spliterator<Entry<K, V>>) spliterator, strategy);
     }
 
     @Override
     EntryStream<K, V> supply(Stream<Map.Entry<K, V>> stream) {
-        return strategy().newEntryStream(stream);
+        return new EntryStream<>(stream, strategy);
     }
 
     static <K, V> Consumer<? super Entry<K, V>> toConsumer(BiConsumer<? super K, ? super V> action) {
@@ -94,47 +98,6 @@ public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream
         return entry -> mapper.apply(entry.getKey(), entry.getValue());
     }
 
-    @Override
-    public EntryStream<K, V> sequential() {
-        return StreamFactory.DEFAULT.newEntryStream(stream().sequential());
-    }
-
-    /**
-     * {@inheritDoc}
-     * 
-     * <p>
-     * If this stream was created using {@link #parallel(ForkJoinPool)}, the new
-     * stream forgets about supplied custom {@link ForkJoinPool} and its
-     * terminal operation will be executed in common pool.
-     */
-    @Override
-    public EntryStream<K, V> parallel() {
-        return StreamFactory.DEFAULT.newEntryStream(stream().parallel());
-    }
-
-    /**
-     * Returns an equivalent stream that is parallel and bound to the supplied
-     * {@link ForkJoinPool}.
-     *
-     * <p>
-     * This is an <a href="package-summary.html#StreamOps">intermediate</a>
-     * operation.
-     * 
-     * <p>
-     * The terminal operation of this stream or any derived stream (except the
-     * streams created via {@link #parallel()} or {@link #sequential()} methods)
-     * will be executed inside the supplied {@code ForkJoinPool}. If current
-     * thread does not belong to that pool, it will wait till calculation
-     * finishes.
-     *
-     * @param fjp a {@code ForkJoinPool} to submit the stream operation to.
-     * @return a parallel stream bound to the supplied {@code ForkJoinPool}
-     * @since 0.2.0
-     */
-    public EntryStream<K, V> parallel(ForkJoinPool fjp) {
-        return StreamFactory.forCustomPool(fjp).newEntryStream(stream().parallel());
-    }
-
     /**
      * Returns a {@link StreamEx} of strings which are created joining the keys
      * and values of the current stream using the specified delimiter.
@@ -195,7 +158,7 @@ public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream
      * @return the new stream
      */
     public <KK> EntryStream<KK, V> flatMapKeys(Function<? super K, ? extends Stream<? extends KK>> mapper) {
-        return strategy().newEntryStream(stream().flatMap(e -> withValue(mapper.apply(e.getKey()), e.getValue())));
+        return new EntryStream<>(stream().flatMap(e -> withValue(mapper.apply(e.getKey()), e.getValue())), strategy);
     }
 
     /**
@@ -220,8 +183,8 @@ public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream
      * @since 0.5.2
      */
     public <KK> EntryStream<KK, V> flatMapToKey(BiFunction<? super K, ? super V, ? extends Stream<? extends KK>> mapper) {
-        return strategy().newEntryStream(
-            stream().flatMap(e -> withValue(mapper.apply(e.getKey(), e.getValue()), e.getValue())));
+        return new EntryStream<>(
+                stream().flatMap(e -> withValue(mapper.apply(e.getKey(), e.getValue()), e.getValue())), strategy);
     }
 
     /**
@@ -246,7 +209,7 @@ public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream
      * @return the new stream
      */
     public <VV> EntryStream<K, VV> flatMapValues(Function<? super V, ? extends Stream<? extends VV>> mapper) {
-        return strategy().newEntryStream(stream().flatMap(e -> withKey(e.getKey(), mapper.apply(e.getValue()))));
+        return new EntryStream<>(stream().flatMap(e -> withKey(e.getKey(), mapper.apply(e.getValue()))), strategy);
     }
 
     /**
@@ -272,8 +235,8 @@ public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream
      */
     public <VV> EntryStream<K, VV> flatMapToValue(
             BiFunction<? super K, ? super V, ? extends Stream<? extends VV>> mapper) {
-        return strategy().newEntryStream(
-            stream().flatMap(e -> withKey(e.getKey(), mapper.apply(e.getKey(), e.getValue()))));
+        return new EntryStream<>(
+            stream().flatMap(e -> withKey(e.getKey(), mapper.apply(e.getKey(), e.getValue()))), strategy);
     }
 
     /**
@@ -511,8 +474,8 @@ public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream
      * @return the new stream
      */
     public <KK> EntryStream<KK, V> mapKeys(Function<? super K, ? extends KK> keyMapper) {
-        return strategy().newEntryStream(
-            stream().map(e -> new SimpleImmutableEntry<>(keyMapper.apply(e.getKey()), e.getValue())));
+        return new EntryStream<>(stream().map(
+            e -> new SimpleImmutableEntry<>(keyMapper.apply(e.getKey()), e.getValue())), strategy);
     }
 
     /**
@@ -529,8 +492,8 @@ public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream
      * @return the new stream
      */
     public <VV> EntryStream<K, VV> mapValues(Function<? super V, ? extends VV> valueMapper) {
-        return strategy().newEntryStream(
-            stream().map(e -> new SimpleImmutableEntry<>(e.getKey(), valueMapper.apply(e.getValue()))));
+        return new EntryStream<>(
+            stream().map(e -> new SimpleImmutableEntry<>(e.getKey(), valueMapper.apply(e.getValue()))), strategy);
     }
 
     /**
@@ -565,8 +528,8 @@ public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream
      * @since 0.3.0
      */
     public <KK> EntryStream<KK, V> mapToKey(BiFunction<? super K, ? super V, ? extends KK> keyMapper) {
-        return strategy().newEntryStream(
-            stream().map(e -> new SimpleImmutableEntry<>(keyMapper.apply(e.getKey(), e.getValue()), e.getValue())));
+        return new EntryStream<>(stream().map(
+            e -> new SimpleImmutableEntry<>(keyMapper.apply(e.getKey(), e.getValue()), e.getValue())), strategy);
     }
 
     /**
@@ -584,8 +547,8 @@ public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream
      * @since 0.3.0
      */
     public <VV> EntryStream<K, VV> mapToValue(BiFunction<? super K, ? super V, ? extends VV> valueMapper) {
-        return strategy().newEntryStream(
-            stream().map(e -> new SimpleImmutableEntry<>(e.getKey(), valueMapper.apply(e.getKey(), e.getValue()))));
+        return new EntryStream<>(stream().map(
+            e -> new SimpleImmutableEntry<>(e.getKey(), valueMapper.apply(e.getKey(), e.getValue()))), strategy);
     }
 
     /**
@@ -599,7 +562,7 @@ public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream
      * @return the new stream
      */
     public EntryStream<V, K> invert() {
-        return strategy().newEntryStream(stream().map(e -> new SimpleImmutableEntry<>(e.getValue(), e.getKey())));
+        return new EntryStream<>(stream().map(e -> new SimpleImmutableEntry<>(e.getValue(), e.getKey())), strategy);
     }
 
     /**
@@ -1117,7 +1080,7 @@ public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream
      * @return the wrapped stream
      */
     public static <K, V> EntryStream<K, V> of(Stream<? extends Entry<K, V>> stream) {
-        return new EntryStream<>(unwrap(stream));
+        return new EntryStream<>(unwrap(stream), ExecutionStrategy.of(stream));
     }
 
     /**
diff --git a/src/main/java/one/util/streamex/ExecutionStrategy.java b/src/main/java/one/util/streamex/ExecutionStrategy.java
new file mode 100644
index 0000000..fe81217
--- /dev/null
+++ b/src/main/java/one/util/streamex/ExecutionStrategy.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright 2015, 2016 Tagir Valeev
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package one.util.streamex;
+
+import java.util.concurrent.ForkJoinPool;
+import java.util.function.Function;
+import java.util.function.Supplier;
+import java.util.stream.BaseStream;
+
+/**
+ * @author Tagir Valeev
+ */
+/*package*/class ExecutionStrategy {
+    static final ExecutionStrategy SEQUENTIAL = new ExecutionStrategy(false);
+    static final ExecutionStrategy PARALLEL = new ExecutionStrategy(true);
+    
+    private final boolean parallel;
+    private final ForkJoinPool fjp;
+
+    private ExecutionStrategy(boolean parallel) {
+        this.parallel = parallel;
+        this.fjp = null;
+    }
+    
+    ExecutionStrategy(ForkJoinPool fjp) {
+        this.parallel = true;
+        this.fjp = fjp;
+    }
+
+    public boolean isParallel() {
+        return parallel;
+    }
+
+    public ForkJoinPool getFjp() {
+        return fjp;
+    }
+
+    public <T> T terminate(Supplier<T> terminalOperation) {
+        return fjp.submit(terminalOperation::get).join();
+    }
+
+    public <T, U> T terminate(U value, Function<U, T> terminalOperation) {
+        return fjp.submit(() -> terminalOperation.apply(value)).join();
+    }
+
+    public ExecutionStrategy combine(BaseStream<?,?> other) {
+        if(other.isParallel() && !isParallel())
+            return PARALLEL;
+        return this;
+    }
+    
+    public static ExecutionStrategy of(BaseStream<?,?> stream) {
+        if(stream instanceof BaseStreamEx)
+            return ((BaseStreamEx<?,?,?>)stream).strategy;
+        return stream.isParallel() ? PARALLEL : SEQUENTIAL;
+    }
+}
diff --git a/src/main/java/one/util/streamex/IntStreamEx.java b/src/main/java/one/util/streamex/IntStreamEx.java
index 148b4b4..46252cb 100644
--- a/src/main/java/one/util/streamex/IntStreamEx.java
+++ b/src/main/java/one/util/streamex/IntStreamEx.java
@@ -31,6 +31,7 @@ import java.util.Random;
 import java.util.Map.Entry;
 import java.util.PrimitiveIterator.OfInt;
 import java.util.Spliterator;
+import java.util.Spliterators;
 import java.util.Spliterators.AbstractIntSpliterator;
 import java.util.concurrent.ForkJoinPool;
 import java.util.function.BiConsumer;
@@ -62,7 +63,7 @@ import static one.util.streamex.StreamExInternals.*;
  * 
  * @author Tagir Valeev
  */
-public class IntStreamEx implements IntStream {
+public class IntStreamEx extends BaseStreamEx<Integer, IntStream, Spliterator.OfInt> implements IntStream {
     private static final class TDOfInt extends AbstractIntSpliterator implements IntConsumer {
         private final IntPredicate predicate;
         private final boolean drop;
@@ -111,25 +112,27 @@ public class IntStreamEx implements IntStream {
         }
     }
 
-    final IntStream stream;
-
-    IntStreamEx(IntStream stream) {
-        this.stream = stream;
+    IntStreamEx(IntStream stream, ExecutionStrategy strategy) {
+        super(stream, strategy);
     }
 
-    StreamFactory strategy() {
-        return StreamFactory.DEFAULT;
+    IntStreamEx(Spliterator.OfInt spliterator, ExecutionStrategy strategy) {
+        super(spliterator, strategy);
+    }
+    
+    @Override
+    IntStream createStream() {
+        return StreamSupport.intStream(spliterator, strategy.isParallel());
     }
 
     final IntStreamEx delegate(Spliterator.OfInt spliterator) {
-        return strategy().newIntStreamEx(
-            delegateClose(StreamSupport.intStream(spliterator, stream.isParallel()), stream));
+        return new IntStreamEx(forwardClose(StreamSupport.intStream(spliterator, isParallel())), strategy);
     }
 
     final IntStreamEx callWhile(IntPredicate predicate, int methodId) {
         try {
-            return strategy().newIntStreamEx(
-                (IntStream) JDK9_METHODS[IDX_INT_STREAM][methodId].invokeExact(stream, predicate));
+            return new IntStreamEx(
+                (IntStream) JDK9_METHODS[IDX_INT_STREAM][methodId].invokeExact(stream(), predicate), strategy);
         } catch (Error | RuntimeException e) {
             throw e;
         } catch (Throwable e) {
@@ -141,7 +144,7 @@ public class IntStreamEx implements IntStream {
             IntFunction<A> sizedSupplier, ObjIntConsumer<A> sizedAccumulator) {
         if (isParallel())
             return collect(supplier, accumulator, combiner);
-        java.util.Spliterator.OfInt spliterator = stream.spliterator();
+        java.util.Spliterator.OfInt spliterator = spliterator();
         long size = spliterator.getExactSizeIfKnown();
         A intermediate;
         if (size >= 0 && size <= Integer.MAX_VALUE) {
@@ -154,29 +157,19 @@ public class IntStreamEx implements IntStream {
         return intermediate;
     }
 
-    @Override
-    public boolean isParallel() {
-        return stream.isParallel();
-    }
-
     @Override
     public IntStreamEx unordered() {
-        return strategy().newIntStreamEx(stream.unordered());
+        return (IntStreamEx) super.unordered();
     }
 
     @Override
     public IntStreamEx onClose(Runnable closeHandler) {
-        return strategy().newIntStreamEx(stream.onClose(closeHandler));
-    }
-
-    @Override
-    public void close() {
-        stream.close();
+        return (IntStreamEx) super.onClose(closeHandler);
     }
 
     @Override
     public IntStreamEx filter(IntPredicate predicate) {
-        return strategy().newIntStreamEx(stream.filter(predicate));
+        return new IntStreamEx(stream().filter(predicate), strategy);
     }
 
     /**
@@ -285,22 +278,22 @@ public class IntStreamEx implements IntStream {
 
     @Override
     public IntStreamEx map(IntUnaryOperator mapper) {
-        return strategy().newIntStreamEx(stream.map(mapper));
+        return new IntStreamEx(stream().map(mapper), strategy);
     }
 
     @Override
     public <U> StreamEx<U> mapToObj(IntFunction<? extends U> mapper) {
-        return strategy().newStreamEx(stream.mapToObj(mapper));
+        return new StreamEx<>(stream().mapToObj(mapper), strategy);
     }
 
     @Override
     public LongStreamEx mapToLong(IntToLongFunction mapper) {
-        return strategy().newLongStreamEx(stream.mapToLong(mapper));
+        return new LongStreamEx(stream().mapToLong(mapper), strategy);
     }
 
     @Override
     public DoubleStreamEx mapToDouble(IntToDoubleFunction mapper) {
-        return strategy().newDoubleStreamEx(stream.mapToDouble(mapper));
+        return new DoubleStreamEx(stream().mapToDouble(mapper), strategy);
     }
 
     /**
@@ -321,13 +314,13 @@ public class IntStreamEx implements IntStream {
      * @since 0.3.1
      */
     public <K, V> EntryStream<K, V> mapToEntry(IntFunction<? extends K> keyMapper, IntFunction<? extends V> valueMapper) {
-        return strategy().newEntryStream(
-            stream.mapToObj(t -> new AbstractMap.SimpleImmutableEntry<>(keyMapper.apply(t), valueMapper.apply(t))));
+        return new EntryStream<>(stream().mapToObj(
+            t -> new AbstractMap.SimpleImmutableEntry<>(keyMapper.apply(t), valueMapper.apply(t))), strategy);
     }
 
     @Override
     public IntStreamEx flatMap(IntFunction<? extends IntStream> mapper) {
-        return strategy().newIntStreamEx(stream.flatMap(mapper));
+        return new IntStreamEx(stream().flatMap(mapper), strategy);
     }
 
     /**
@@ -346,7 +339,7 @@ public class IntStreamEx implements IntStream {
      * @since 0.3.0
      */
     public LongStreamEx flatMapToLong(IntFunction<? extends LongStream> mapper) {
-        return strategy().newLongStreamEx(stream.mapToObj(mapper).flatMapToLong(Function.identity()));
+        return new LongStreamEx(stream().mapToObj(mapper).flatMapToLong(Function.identity()), strategy);
     }
 
     /**
@@ -365,7 +358,7 @@ public class IntStreamEx implements IntStream {
      * @since 0.3.0
      */
     public DoubleStreamEx flatMapToDouble(IntFunction<? extends DoubleStream> mapper) {
-        return strategy().newDoubleStreamEx(stream.mapToObj(mapper).flatMapToDouble(Function.identity()));
+        return new DoubleStreamEx(stream().mapToObj(mapper).flatMapToDouble(Function.identity()), strategy);
     }
 
     /**
@@ -385,17 +378,17 @@ public class IntStreamEx implements IntStream {
      * @since 0.3.0
      */
     public <R> StreamEx<R> flatMapToObj(IntFunction<? extends Stream<R>> mapper) {
-        return strategy().newStreamEx(stream.mapToObj(mapper).flatMap(Function.identity()));
+        return new StreamEx<>(stream().mapToObj(mapper).flatMap(Function.identity()), strategy);
     }
 
     @Override
     public IntStreamEx distinct() {
-        return strategy().newIntStreamEx(stream.distinct());
+        return new IntStreamEx(stream().distinct(), strategy);
     }
 
     @Override
     public IntStreamEx sorted() {
-        return strategy().newIntStreamEx(stream.sorted());
+        return new IntStreamEx(stream().sorted(), strategy);
     }
 
     /**
@@ -418,7 +411,7 @@ public class IntStreamEx implements IntStream {
      * @return the new stream
      */
     public IntStreamEx sorted(Comparator<Integer> comparator) {
-        return strategy().newIntStreamEx(stream.boxed().sorted(comparator).mapToInt(Integer::intValue));
+        return new IntStreamEx(stream().boxed().sorted(comparator).mapToInt(Integer::intValue), strategy);
     }
 
     /**
@@ -527,17 +520,17 @@ public class IntStreamEx implements IntStream {
 
     @Override
     public IntStreamEx peek(IntConsumer action) {
-        return strategy().newIntStreamEx(stream.peek(action));
+        return new IntStreamEx(stream().peek(action), strategy);
     }
 
     @Override
     public IntStreamEx limit(long maxSize) {
-        return strategy().newIntStreamEx(stream.limit(maxSize));
+        return new IntStreamEx(stream().limit(maxSize), strategy);
     }
 
     @Override
     public IntStreamEx skip(long n) {
-        return strategy().newIntStreamEx(stream.skip(n));
+        return new IntStreamEx(stream().skip(n), strategy);
     }
 
     /**
@@ -572,24 +565,50 @@ public class IntStreamEx implements IntStream {
      * @since 0.3.2
      */
     public IntStreamEx skipOrdered(long n) {
-        Spliterator.OfInt spliterator = (stream.isParallel() ? StreamSupport.intStream(stream.spliterator(), false)
-                : stream).skip(n).spliterator();
+        Spliterator.OfInt spliterator = (isParallel() ? StreamSupport.intStream(spliterator(), false) : stream()).skip(
+            n).spliterator();
         return delegate(spliterator);
     }
 
     @Override
     public void forEach(IntConsumer action) {
-        stream.forEach(action);
+        if (spliterator != null && !isParallel()) {
+            spliterator.forEachRemaining(action);
+            spliterator = null;
+        } else {
+            if(strategy.getFjp() != null)
+                strategy.terminate(() -> {
+                    stream().forEach(action);
+                    return null;
+                });
+            else {
+                stream().forEach(action);
+            }
+        }
     }
 
     @Override
     public void forEachOrdered(IntConsumer action) {
-        stream.forEachOrdered(action);
+        if (spliterator != null && !isParallel()) {
+            spliterator.forEachRemaining(action);
+            spliterator = null;
+        } else {
+            if(strategy.getFjp() != null)
+                strategy.terminate(() -> {
+                    stream().forEachOrdered(action);
+                    return null;
+                });
+            else {
+                stream().forEachOrdered(action);
+            }
+        }
     }
 
     @Override
     public int[] toArray() {
-        return stream.toArray();
+        if(strategy.getFjp() != null)
+            return strategy.terminate(stream()::toArray);
+        return stream().toArray();
     }
 
     /**
@@ -653,12 +672,16 @@ public class IntStreamEx implements IntStream {
 
     @Override
     public int reduce(int identity, IntBinaryOperator op) {
-        return stream.reduce(identity, op);
+        if(strategy.getFjp() != null)
+            return strategy.terminate(() -> stream().reduce(identity, op));
+        return stream().reduce(identity, op);
     }
 
     @Override
     public OptionalInt reduce(IntBinaryOperator op) {
-        return stream.reduce(op);
+        if(strategy.getFjp() != null)
+            return strategy.terminate(op, stream()::reduce);
+        return stream().reduce(op);
     }
 
     /**
@@ -704,7 +727,7 @@ public class IntStreamEx implements IntStream {
      */
     public OptionalInt foldLeft(IntBinaryOperator accumulator) {
         PrimitiveBox b = new PrimitiveBox();
-        stream.forEachOrdered(t -> {
+        forEachOrdered(t -> {
             if (b.b)
                 b.i = accumulator.applyAsInt(b.i, t);
             else {
@@ -753,7 +776,7 @@ public class IntStreamEx implements IntStream {
      */
     public int foldLeft(int seed, IntBinaryOperator accumulator) {
         int[] box = new int[] { seed };
-        stream.forEachOrdered(t -> box[0] = accumulator.applyAsInt(box[0], t));
+        forEachOrdered(t -> box[0] = accumulator.applyAsInt(box[0], t));
         return box[0];
     }
 
@@ -785,7 +808,7 @@ public class IntStreamEx implements IntStream {
      * @since 0.5.1
      */
     public int[] scanLeft(IntBinaryOperator accumulator) {
-        Spliterator.OfInt spliterator = stream.spliterator();
+        Spliterator.OfInt spliterator = spliterator();
         long size = spliterator.getExactSizeIfKnown();
         IntBuffer buf = new IntBuffer(size >= 0 && size <= Integer.MAX_VALUE ? (int) size : INITIAL_SIZE);
         delegate(spliterator).forEachOrdered(
@@ -831,7 +854,9 @@ public class IntStreamEx implements IntStream {
      */
     @Override
     public <R> R collect(Supplier<R> supplier, ObjIntConsumer<R> accumulator, BiConsumer<R, R> combiner) {
-        return stream.collect(supplier, accumulator, combiner);
+        if(strategy.getFjp() != null)
+            return strategy.terminate(() -> stream().collect(supplier, accumulator, combiner));
+        return stream().collect(supplier, accumulator, combiner);
     }
 
     /**
@@ -1124,12 +1149,16 @@ public class IntStreamEx implements IntStream {
 
     @Override
     public long count() {
-        return stream.count();
+        if(strategy.getFjp() != null)
+            return strategy.terminate(stream()::count);
+        return stream().count();
     }
 
     @Override
     public OptionalDouble average() {
-        return stream.average();
+        if(strategy.getFjp() != null)
+            return strategy.terminate(stream()::average);
+        return stream().average();
     }
 
     @Override
@@ -1139,12 +1168,16 @@ public class IntStreamEx implements IntStream {
 
     @Override
     public boolean anyMatch(IntPredicate predicate) {
-        return stream.anyMatch(predicate);
+        if(strategy.getFjp() != null)
+            return strategy.terminate(predicate, stream()::anyMatch);
+        return stream().anyMatch(predicate);
     }
 
     @Override
     public boolean allMatch(IntPredicate predicate) {
-        return stream.allMatch(predicate);
+        if(strategy.getFjp() != null)
+            return strategy.terminate(predicate, stream()::allMatch);
+        return stream().allMatch(predicate);
     }
 
     @Override
@@ -1154,7 +1187,9 @@ public class IntStreamEx implements IntStream {
 
     @Override
     public OptionalInt findFirst() {
-        return stream.findFirst();
+        if(strategy.getFjp() != null)
+            return strategy.terminate(stream()::findFirst);
+        return stream().findFirst();
     }
 
     /**
@@ -1180,7 +1215,9 @@ public class IntStreamEx implements IntStream {
 
     @Override
     public OptionalInt findAny() {
-        return stream.findAny();
+        if(strategy.getFjp() != null)
+            return strategy.terminate(stream()::findAny);
+        return stream().findAny();
     }
 
     /**
@@ -1255,67 +1292,37 @@ public class IntStreamEx implements IntStream {
 
     @Override
     public LongStreamEx asLongStream() {
-        return strategy().newLongStreamEx(stream.asLongStream());
+        return new LongStreamEx(stream().asLongStream(), strategy);
     }
 
     @Override
     public DoubleStreamEx asDoubleStream() {
-        return strategy().newDoubleStreamEx(stream.asDoubleStream());
+        return new DoubleStreamEx(stream().asDoubleStream(), strategy);
     }
 
     @Override
     public StreamEx<Integer> boxed() {
-        return strategy().newStreamEx(stream.boxed());
+        return new StreamEx<>(stream().boxed(), strategy);
     }
 
     @Override
     public IntStreamEx sequential() {
-        return StreamFactory.DEFAULT.newIntStreamEx(stream.sequential());
+        return (IntStreamEx) super.sequential();
     }
 
-    /**
-     * {@inheritDoc}
-     * 
-     * <p>
-     * If this stream was created using {@link #parallel(ForkJoinPool)}, the new
-     * stream forgets about supplied custom {@link ForkJoinPool} and its
-     * terminal operation will be executed in common pool.
-     */
     @Override
     public IntStreamEx parallel() {
-        return StreamFactory.DEFAULT.newIntStreamEx(stream.parallel());
+        return (IntStreamEx) super.parallel();
     }
 
-    /**
-     * Returns an equivalent stream that is parallel and bound to the supplied
-     * {@link ForkJoinPool}.
-     *
-     * <p>
-     * This is an intermediate operation.
-     * 
-     * <p>
-     * The terminal operation of this stream or any derived stream (except the
-     * streams created via {@link #parallel()} or {@link #sequential()} methods)
-     * will be executed inside the supplied {@code ForkJoinPool}. If current
-     * thread does not belong to that pool, it will wait till calculation
-     * finishes.
-     *
-     * @param fjp a {@code ForkJoinPool} to submit the stream operation to.
-     * @return a parallel stream bound to the supplied {@code ForkJoinPool}
-     * @since 0.2.0
-     */
+    @Override
     public IntStreamEx parallel(ForkJoinPool fjp) {
-        return StreamFactory.forCustomPool(fjp).newIntStreamEx(stream.parallel());
+        return (IntStreamEx) super.parallel(fjp);
     }
 
     @Override
     public OfInt iterator() {
-        return stream.iterator();
-    }
-
-    @Override
-    public java.util.Spliterator.OfInt spliterator() {
-        return stream.spliterator();
+        return Spliterators.iterator(spliterator());
     }
 
     /**
@@ -1332,7 +1339,7 @@ public class IntStreamEx implements IntStream {
     public IntStreamEx append(int... values) {
         if (values.length == 0)
             return this;
-        return strategy().newIntStreamEx(IntStream.concat(stream, IntStream.of(values)));
+        return new IntStreamEx(IntStream.concat(stream(), IntStream.of(values)), strategy);
     }
 
     /**
@@ -1347,7 +1354,7 @@ public class IntStreamEx implements IntStream {
      * @see IntStream#concat(IntStream, IntStream)
      */
     public IntStreamEx append(IntStream other) {
-        return strategy().newIntStreamEx(IntStream.concat(stream, other));
+        return new IntStreamEx(IntStream.concat(stream(), other), strategy.combine(other));
     }
 
     /**
@@ -1364,7 +1371,7 @@ public class IntStreamEx implements IntStream {
     public IntStreamEx prepend(int... values) {
         if (values.length == 0)
             return this;
-        return strategy().newIntStreamEx(IntStream.concat(IntStream.of(values), stream));
+        return new IntStreamEx(IntStream.concat(IntStream.of(values), stream()), strategy);
     }
 
     /**
@@ -1379,7 +1386,7 @@ public class IntStreamEx implements IntStream {
      * @see IntStream#concat(IntStream, IntStream)
      */
     public IntStreamEx prepend(IntStream other) {
-        return strategy().newIntStreamEx(IntStream.concat(other, stream));
+        return new IntStreamEx(IntStream.concat(other, stream()), strategy.combine(other));
     }
 
     /**
@@ -1513,7 +1520,7 @@ public class IntStreamEx implements IntStream {
      * @since 0.2.1
      */
     public IntStreamEx pairMap(IntBinaryOperator mapper) {
-        return delegate(new PairSpliterator.PSOfInt(mapper, null, stream.spliterator(), PairSpliterator.MODE_PAIRS));
+        return delegate(new PairSpliterator.PSOfInt(mapper, null, spliterator(), PairSpliterator.MODE_PAIRS));
     }
 
     /**
@@ -1580,7 +1587,7 @@ public class IntStreamEx implements IntStream {
         if (JDK9_METHODS != null) {
             return callWhile(predicate, IDX_TAKE_WHILE);
         }
-        return delegate(new IntStreamEx.TDOfInt(stream.spliterator(), false, predicate));
+        return delegate(new IntStreamEx.TDOfInt(spliterator(), false, predicate));
     }
 
     /**
@@ -1609,7 +1616,7 @@ public class IntStreamEx implements IntStream {
         if (JDK9_METHODS != null) {
             return callWhile(predicate, IDX_DROP_WHILE);
         }
-        return delegate(new IntStreamEx.TDOfInt(stream.spliterator(), true, predicate));
+        return delegate(new IntStreamEx.TDOfInt(spliterator(), true, predicate));
     }
 
     /**
@@ -1628,7 +1635,7 @@ public class IntStreamEx implements IntStream {
      * @since 0.4.1
      */
     public IntStreamEx mapFirst(IntUnaryOperator mapper) {
-        return delegate(new PairSpliterator.PSOfInt((a, b) -> b, mapper, stream.spliterator(), PairSpliterator.MODE_MAP_FIRST));
+        return delegate(new PairSpliterator.PSOfInt((a, b) -> b, mapper, spliterator(), PairSpliterator.MODE_MAP_FIRST));
     }
 
     /**
@@ -1647,7 +1654,7 @@ public class IntStreamEx implements IntStream {
      * @since 0.4.1
      */
     public IntStreamEx mapLast(IntUnaryOperator mapper) {
-        return delegate(new PairSpliterator.PSOfInt((a, b) -> a, mapper, stream.spliterator(), PairSpliterator.MODE_MAP_LAST));
+        return delegate(new PairSpliterator.PSOfInt((a, b) -> a, mapper, spliterator(), PairSpliterator.MODE_MAP_LAST));
     }
 
     /**
@@ -1952,7 +1959,7 @@ public class IntStreamEx implements IntStream {
      * @since 0.0.8
      */
     public static IntStreamEx of(IntStream stream) {
-        return stream instanceof IntStreamEx ? (IntStreamEx) stream : new IntStreamEx(stream);
+        return stream instanceof IntStreamEx ? (IntStreamEx) stream : new IntStreamEx(stream, ExecutionStrategy.of(stream));
     }
 
     /**
diff --git a/src/main/java/one/util/streamex/LongStreamEx.java b/src/main/java/one/util/streamex/LongStreamEx.java
index 59662c7..38b3563 100644
--- a/src/main/java/one/util/streamex/LongStreamEx.java
+++ b/src/main/java/one/util/streamex/LongStreamEx.java
@@ -26,6 +26,7 @@ import java.util.OptionalLong;
 import java.util.PrimitiveIterator;
 import java.util.Random;
 import java.util.Spliterator;
+import java.util.Spliterators;
 import java.util.Map.Entry;
 import java.util.PrimitiveIterator.OfLong;
 import java.util.Spliterators.AbstractLongSpliterator;
@@ -56,7 +57,7 @@ import static one.util.streamex.StreamExInternals.*;
  * 
  * @author Tagir Valeev
  */
-public class LongStreamEx implements LongStream {
+public class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterator.OfLong> implements LongStream {
     private static final class TDOfLong extends AbstractLongSpliterator implements LongConsumer {
         private final LongPredicate predicate;
         private final boolean drop;
@@ -105,25 +106,27 @@ public class LongStreamEx implements LongStream {
         }
     }
 
-    final LongStream stream;
+    LongStreamEx(LongStream stream, ExecutionStrategy strategy) {
+        super(stream, strategy);
+    }
 
-    LongStreamEx(LongStream stream) {
-        this.stream = stream;
+    LongStreamEx(Spliterator.OfLong spliterator, ExecutionStrategy strategy) {
+        super(spliterator, strategy);
     }
 
-    StreamFactory strategy() {
-        return StreamFactory.DEFAULT;
+    @Override
+    LongStream createStream() {
+        return StreamSupport.longStream(spliterator, isParallel());
     }
 
     final LongStreamEx delegate(Spliterator.OfLong spliterator) {
-        return strategy().newLongStreamEx(
-            delegateClose(StreamSupport.longStream(spliterator, stream.isParallel()), stream));
+        return new LongStreamEx(forwardClose(StreamSupport.longStream(spliterator, isParallel())), strategy);
     }
 
     final LongStreamEx callWhile(LongPredicate predicate, int methodId) {
         try {
-            return strategy().newLongStreamEx(
-                (LongStream) JDK9_METHODS[IDX_LONG_STREAM][methodId].invokeExact(stream, predicate));
+            return new LongStreamEx(
+                (LongStream) JDK9_METHODS[IDX_LONG_STREAM][methodId].invokeExact(stream(), predicate), strategy);
         } catch (Error | RuntimeException e) {
             throw e;
         } catch (Throwable e) {
@@ -131,29 +134,19 @@ public class LongStreamEx implements LongStream {
         }
     }
 
-    @Override
-    public boolean isParallel() {
-        return stream.isParallel();
-    }
-
     @Override
     public LongStreamEx unordered() {
-        return strategy().newLongStreamEx(stream.unordered());
+        return (LongStreamEx) super.unordered();
     }
 
     @Override
     public LongStreamEx onClose(Runnable closeHandler) {
-        return strategy().newLongStreamEx(stream.onClose(closeHandler));
-    }
-
-    @Override
-    public void close() {
-        stream.close();
+        return (LongStreamEx) super.onClose(closeHandler);
     }
 
     @Override
     public LongStreamEx filter(LongPredicate predicate) {
-        return strategy().newLongStreamEx(stream.filter(predicate));
+        return new LongStreamEx(stream().filter(predicate), strategy);
     }
 
     /**
@@ -262,7 +255,7 @@ public class LongStreamEx implements LongStream {
 
     @Override
     public LongStreamEx map(LongUnaryOperator mapper) {
-        return strategy().newLongStreamEx(stream.map(mapper));
+        return new LongStreamEx(stream().map(mapper), strategy);
     }
 
     /**
@@ -281,7 +274,7 @@ public class LongStreamEx implements LongStream {
      * @since 0.4.1
      */
     public LongStreamEx mapFirst(LongUnaryOperator mapper) {
-        return delegate(new PairSpliterator.PSOfLong((a, b) -> b, mapper, stream.spliterator(), PairSpliterator.MODE_MAP_FIRST));
+        return delegate(new PairSpliterator.PSOfLong((a, b) -> b, mapper, spliterator(), PairSpliterator.MODE_MAP_FIRST));
     }
 
     /**
@@ -300,22 +293,22 @@ public class LongStreamEx implements LongStream {
      * @since 0.4.1
      */
     public LongStreamEx mapLast(LongUnaryOperator mapper) {
-        return delegate(new PairSpliterator.PSOfLong((a, b) -> a, mapper, stream.spliterator(), PairSpliterator.MODE_MAP_LAST));
+        return delegate(new PairSpliterator.PSOfLong((a, b) -> a, mapper, spliterator(), PairSpliterator.MODE_MAP_LAST));
     }
 
     @Override
     public <U> StreamEx<U> mapToObj(LongFunction<? extends U> mapper) {
-        return strategy().newStreamEx(stream.mapToObj(mapper));
+        return new StreamEx<>(stream().mapToObj(mapper), strategy);
     }
 
     @Override
     public IntStreamEx mapToInt(LongToIntFunction mapper) {
-        return strategy().newIntStreamEx(stream.mapToInt(mapper));
+        return new IntStreamEx(stream().mapToInt(mapper), strategy);
     }
 
     @Override
     public DoubleStreamEx mapToDouble(LongToDoubleFunction mapper) {
-        return strategy().newDoubleStreamEx(stream.mapToDouble(mapper));
+        return new DoubleStreamEx(stream().mapToDouble(mapper), strategy);
     }
 
     /**
@@ -337,13 +330,13 @@ public class LongStreamEx implements LongStream {
      */
     public <K, V> EntryStream<K, V> mapToEntry(LongFunction<? extends K> keyMapper,
             LongFunction<? extends V> valueMapper) {
-        return strategy().newEntryStream(
-            stream.mapToObj(t -> new AbstractMap.SimpleImmutableEntry<>(keyMapper.apply(t), valueMapper.apply(t))));
+        return new EntryStream<>(stream().mapToObj(
+            t -> new AbstractMap.SimpleImmutableEntry<>(keyMapper.apply(t), valueMapper.apply(t))), strategy);
     }
 
     @Override
     public LongStreamEx flatMap(LongFunction<? extends LongStream> mapper) {
-        return strategy().newLongStreamEx(stream.flatMap(mapper));
+        return new LongStreamEx(stream().flatMap(mapper), strategy);
     }
 
     /**
@@ -362,7 +355,7 @@ public class LongStreamEx implements LongStream {
      * @since 0.3.0
      */
     public IntStreamEx flatMapToInt(LongFunction<? extends IntStream> mapper) {
-        return strategy().newIntStreamEx(stream.mapToObj(mapper).flatMapToInt(Function.identity()));
+        return new IntStreamEx(stream().mapToObj(mapper).flatMapToInt(Function.identity()), strategy);
     }
 
     /**
@@ -381,7 +374,7 @@ public class LongStreamEx implements LongStream {
      * @since 0.3.0
      */
     public DoubleStreamEx flatMapToDouble(LongFunction<? extends DoubleStream> mapper) {
-        return strategy().newDoubleStreamEx(stream.mapToObj(mapper).flatMapToDouble(Function.identity()));
+        return new DoubleStreamEx(stream().mapToObj(mapper).flatMapToDouble(Function.identity()), strategy);
     }
 
     /**
@@ -401,17 +394,17 @@ public class LongStreamEx implements LongStream {
      * @since 0.3.0
      */
     public <R> StreamEx<R> flatMapToObj(LongFunction<? extends Stream<R>> mapper) {
-        return strategy().newStreamEx(stream.mapToObj(mapper).flatMap(Function.identity()));
+        return new StreamEx<>(stream().mapToObj(mapper).flatMap(Function.identity()), strategy);
     }
 
     @Override
     public LongStreamEx distinct() {
-        return strategy().newLongStreamEx(stream.distinct());
+        return new LongStreamEx(stream().distinct(), strategy);
     }
 
     @Override
     public LongStreamEx sorted() {
-        return strategy().newLongStreamEx(stream.sorted());
+        return new LongStreamEx(stream().sorted(), strategy);
     }
 
     /**
@@ -434,7 +427,7 @@ public class LongStreamEx implements LongStream {
      * @return the new stream
      */
     public LongStreamEx sorted(Comparator<Long> comparator) {
-        return strategy().newLongStreamEx(stream.boxed().sorted(comparator).mapToLong(Long::longValue));
+        return new LongStreamEx(stream().boxed().sorted(comparator).mapToLong(Long::longValue), strategy);
     }
 
     /**
@@ -543,17 +536,17 @@ public class LongStreamEx implements LongStream {
 
     @Override
     public LongStreamEx peek(LongConsumer action) {
-        return strategy().newLongStreamEx(stream.peek(action));
+        return new LongStreamEx(stream().peek(action), strategy);
     }
 
     @Override
     public LongStreamEx limit(long maxSize) {
-        return strategy().newLongStreamEx(stream.limit(maxSize));
+        return new LongStreamEx(stream().limit(maxSize), strategy);
     }
 
     @Override
     public LongStreamEx skip(long n) {
-        return strategy().newLongStreamEx(stream.skip(n));
+        return new LongStreamEx(stream().skip(n), strategy);
     }
 
     /**
@@ -589,34 +582,64 @@ public class LongStreamEx implements LongStream {
      * @since 0.3.2
      */
     public LongStreamEx skipOrdered(long n) {
-        Spliterator.OfLong spliterator = (stream.isParallel() ? StreamSupport.longStream(stream.spliterator(), false)
-                : stream).skip(n).spliterator();
+        Spliterator.OfLong spliterator = (isParallel() ? StreamSupport.longStream(spliterator(), false)
+                : stream()).skip(n).spliterator();
         return delegate(spliterator);
     }
 
     @Override
     public void forEach(LongConsumer action) {
-        stream.forEach(action);
+        if (spliterator != null && !isParallel()) {
+            spliterator.forEachRemaining(action);
+            spliterator = null;
+        } else {
+            if(strategy.getFjp() != null)
+                strategy.terminate(() -> {
+                    stream().forEach(action);
+                    return null;
+                });
+            else {
+                stream().forEach(action);
+            }
+        }
     }
 
     @Override
     public void forEachOrdered(LongConsumer action) {
-        stream.forEachOrdered(action);
+        if (spliterator != null && !isParallel()) {
+            spliterator.forEachRemaining(action);
+            spliterator = null;
+        } else {
+            if(strategy.getFjp() != null)
+                strategy.terminate(() -> {
+                    stream().forEachOrdered(action);
+                    return null;
+                });
+            else {
+                stream().forEachOrdered(action);
+            }
+        }
     }
 
     @Override
     public long[] toArray() {
-        return stream.toArray();
+        if(strategy.getFjp() != null)
+            return strategy.terminate(stream()::toArray);
+        return stream().toArray();
     }
 
     @Override
     public long reduce(long identity, LongBinaryOperator op) {
-        return stream.reduce(identity, op);
+        if(strategy.getFjp() != null)
+            return strategy.terminate(() -> stream().reduce(identity, op));
+        return stream().reduce(identity, op);
     }
 
     @Override
     public OptionalLong reduce(LongBinaryOperator op) {
-        return stream.reduce(op);
+        if(strategy.getFjp() != null)
+            return strategy.terminate(op, stream()::reduce);
+        return stream().reduce(op);
     }
 
     /**
@@ -662,7 +685,7 @@ public class LongStreamEx implements LongStream {
      */
     public OptionalLong foldLeft(LongBinaryOperator accumulator) {
         PrimitiveBox b = new PrimitiveBox();
-        stream.forEachOrdered(t -> {
+        forEachOrdered(t -> {
             if (b.b)
                 b.l = accumulator.applyAsLong(b.l, t);
             else {
@@ -711,7 +734,7 @@ public class LongStreamEx implements LongStream {
      */
     public long foldLeft(long seed, LongBinaryOperator accumulator) {
         long[] box = new long[] { seed };
-        stream.forEachOrdered(t -> box[0] = accumulator.applyAsLong(box[0], t));
+        forEachOrdered(t -> box[0] = accumulator.applyAsLong(box[0], t));
         return box[0];
     }
 
@@ -743,7 +766,7 @@ public class LongStreamEx implements LongStream {
      * @since 0.5.1
      */
     public long[] scanLeft(LongBinaryOperator accumulator) {
-        Spliterator.OfLong spliterator = stream.spliterator();
+        Spliterator.OfLong spliterator = spliterator();
         long size = spliterator.getExactSizeIfKnown();
         LongBuffer buf = new LongBuffer(size >= 0 && size <= Integer.MAX_VALUE ? (int) size : INITIAL_SIZE);
         delegate(spliterator).forEachOrdered(
@@ -789,7 +812,9 @@ public class LongStreamEx implements LongStream {
      */
     @Override
     public <R> R collect(Supplier<R> supplier, ObjLongConsumer<R> accumulator, BiConsumer<R, R> combiner) {
-        return stream.collect(supplier, accumulator, combiner);
+        if(strategy.getFjp() != null)
+            return strategy.terminate(() -> stream().collect(supplier, accumulator, combiner));
+        return stream().collect(supplier, accumulator, combiner);
     }
 
     /**
@@ -1085,12 +1110,16 @@ public class LongStreamEx implements LongStream {
 
     @Override
     public long count() {
-        return stream.count();
+        if(strategy.getFjp() != null)
+            return strategy.terminate(stream()::count);
+        return stream().count();
     }
 
     @Override
     public OptionalDouble average() {
-        return stream.average();
+        if(strategy.getFjp() != null)
+            return strategy.terminate(stream()::average);
+        return stream().average();
     }
 
     @Override
@@ -1100,12 +1129,16 @@ public class LongStreamEx implements LongStream {
 
     @Override
     public boolean anyMatch(LongPredicate predicate) {
-        return stream.anyMatch(predicate);
+        if(strategy.getFjp() != null)
+            return strategy.terminate(predicate, stream()::anyMatch);
+        return stream().anyMatch(predicate);
     }
 
     @Override
     public boolean allMatch(LongPredicate predicate) {
-        return stream.allMatch(predicate);
+        if(strategy.getFjp() != null)
+            return strategy.terminate(predicate, stream()::allMatch);
+        return stream().allMatch(predicate);
     }
 
     @Override
@@ -1115,7 +1148,9 @@ public class LongStreamEx implements LongStream {
 
     @Override
     public OptionalLong findFirst() {
-        return stream.findFirst();
+        if(strategy.getFjp() != null)
+            return strategy.terminate(stream()::findFirst);
+        return stream().findFirst();
     }
 
     /**
@@ -1141,7 +1176,9 @@ public class LongStreamEx implements LongStream {
 
     @Override
     public OptionalLong findAny() {
-        return stream.findAny();
+        if(strategy.getFjp() != null)
+            return strategy.terminate(stream()::findAny);
+        return stream().findAny();
     }
 
     /**
@@ -1216,62 +1253,32 @@ public class LongStreamEx implements LongStream {
 
     @Override
     public DoubleStreamEx asDoubleStream() {
-        return strategy().newDoubleStreamEx(stream.asDoubleStream());
+        return new DoubleStreamEx(stream().asDoubleStream(), strategy);
     }
 
     @Override
     public StreamEx<Long> boxed() {
-        return strategy().newStreamEx(stream.boxed());
+        return new StreamEx<>(stream().boxed(), strategy);
     }
 
     @Override
     public LongStreamEx sequential() {
-        return StreamFactory.DEFAULT.newLongStreamEx(stream.sequential());
+        return (LongStreamEx) super.sequential();
     }
 
-    /**
-     * {@inheritDoc}
-     * 
-     * <p>
-     * If this stream was created using {@link #parallel(ForkJoinPool)}, the new
-     * stream forgets about supplied custom {@link ForkJoinPool} and its
-     * terminal operation will be executed in common pool.
-     */
     @Override
     public LongStreamEx parallel() {
-        return StreamFactory.DEFAULT.newLongStreamEx(stream.parallel());
+        return (LongStreamEx) super.parallel();
     }
 
-    /**
-     * Returns an equivalent stream that is parallel and bound to the supplied
-     * {@link ForkJoinPool}.
-     *
-     * <p>
-     * This is an intermediate operation.
-     * 
-     * <p>
-     * The terminal operation of this stream or any derived stream (except the
-     * streams created via {@link #parallel()} or {@link #sequential()} methods)
-     * will be executed inside the supplied {@code ForkJoinPool}. If current
-     * thread does not belong to that pool, it will wait till calculation
-     * finishes.
-     *
-     * @param fjp a {@code ForkJoinPool} to submit the stream operation to.
-     * @return a parallel stream bound to the supplied {@code ForkJoinPool}
-     * @since 0.2.0
-     */
+    @Override
     public LongStreamEx parallel(ForkJoinPool fjp) {
-        return StreamFactory.forCustomPool(fjp).newLongStreamEx(stream.parallel());
+        return (LongStreamEx) super.parallel(fjp);
     }
 
     @Override
     public OfLong iterator() {
-        return stream.iterator();
-    }
-
-    @Override
-    public java.util.Spliterator.OfLong spliterator() {
-        return stream.spliterator();
+        return Spliterators.iterator(spliterator());
     }
 
     /**
@@ -1288,7 +1295,7 @@ public class LongStreamEx implements LongStream {
     public LongStreamEx append(long... values) {
         if (values.length == 0)
             return this;
-        return strategy().newLongStreamEx(LongStream.concat(stream, LongStream.of(values)));
+        return new LongStreamEx(LongStream.concat(stream(), LongStream.of(values)), strategy);
     }
 
     /**
@@ -1303,7 +1310,7 @@ public class LongStreamEx implements LongStream {
      * @see LongStream#concat(LongStream, LongStream)
      */
     public LongStreamEx append(LongStream other) {
-        return strategy().newLongStreamEx(LongStream.concat(stream, other));
+        return new LongStreamEx(LongStream.concat(stream(), other), strategy.combine(other));
     }
 
     /**
@@ -1320,7 +1327,7 @@ public class LongStreamEx implements LongStream {
     public LongStreamEx prepend(long... values) {
         if (values.length == 0)
             return this;
-        return strategy().newLongStreamEx(LongStream.concat(LongStream.of(values), stream));
+        return new LongStreamEx(LongStream.concat(LongStream.of(values), stream()), strategy);
     }
 
     /**
@@ -1335,7 +1342,7 @@ public class LongStreamEx implements LongStream {
      * @see LongStream#concat(LongStream, LongStream)
      */
     public LongStreamEx prepend(LongStream other) {
-        return strategy().newLongStreamEx(LongStream.concat(other, stream));
+        return new LongStreamEx(LongStream.concat(other, stream()), strategy.combine(other));
     }
 
     /**
@@ -1356,7 +1363,7 @@ public class LongStreamEx implements LongStream {
      * @since 0.2.1
      */
     public LongStreamEx pairMap(LongBinaryOperator mapper) {
-        return delegate(new PairSpliterator.PSOfLong(mapper, null, stream.spliterator(), PairSpliterator.MODE_PAIRS));
+        return delegate(new PairSpliterator.PSOfLong(mapper, null, spliterator(), PairSpliterator.MODE_PAIRS));
     }
 
     /**
@@ -1423,7 +1430,7 @@ public class LongStreamEx implements LongStream {
         if (JDK9_METHODS != null) {
             return callWhile(predicate, IDX_TAKE_WHILE);
         }
-        return delegate(new LongStreamEx.TDOfLong(stream.spliterator(), false, predicate));
+        return delegate(new LongStreamEx.TDOfLong(spliterator(), false, predicate));
     }
 
     /**
@@ -1452,7 +1459,7 @@ public class LongStreamEx implements LongStream {
         if (JDK9_METHODS != null) {
             return callWhile(predicate, IDX_DROP_WHILE);
         }
-        return delegate(new LongStreamEx.TDOfLong(stream.spliterator(), true, predicate));
+        return delegate(new LongStreamEx.TDOfLong(spliterator(), true, predicate));
     }
 
     /**
@@ -1526,7 +1533,8 @@ public class LongStreamEx implements LongStream {
      * @since 0.0.8
      */
     public static LongStreamEx of(LongStream stream) {
-        return stream instanceof LongStreamEx ? (LongStreamEx) stream : new LongStreamEx(stream);
+        return stream instanceof LongStreamEx ? (LongStreamEx) stream : new LongStreamEx(stream, ExecutionStrategy
+                .of(stream));
     }
 
     /**
diff --git a/src/main/java/one/util/streamex/StreamEx.java b/src/main/java/one/util/streamex/StreamEx.java
index f7221eb..bdf6429 100644
--- a/src/main/java/one/util/streamex/StreamEx.java
+++ b/src/main/java/one/util/streamex/StreamEx.java
@@ -45,7 +45,6 @@ import java.util.TreeMap;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.ConcurrentSkipListMap;
-import java.util.concurrent.ForkJoinPool;
 import java.util.function.BiConsumer;
 import java.util.function.BiFunction;
 import java.util.function.BiPredicate;
@@ -78,60 +77,23 @@ import static one.util.streamex.StreamExInternals.*;
  */
 public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
 
-    StreamEx(Stream<T> stream) {
-        super(stream);
+    StreamEx(Stream<T> stream, ExecutionStrategy strategy) {
+        super(stream, strategy);
     }
 
+    StreamEx(Spliterator<T> spliterator, ExecutionStrategy strategy) {
+        super(spliterator, strategy);
+    }
+    
     @Override
     StreamEx<T> supply(Stream<T> stream) {
-        return strategy().newStreamEx(stream);
+        return new StreamEx<>(stream, strategy);
     }
 
     final <R> StreamEx<R> collapseInternal(BiPredicate<? super T, ? super T> collapsible, Function<T, R> mapper,
             BiFunction<R, T, R> accumulator, BinaryOperator<R> combiner) {
-        return strategy().newStreamEx(
-            delegate(new CollapseSpliterator<>(collapsible, mapper, accumulator, combiner, spliterator())));
-    }
-
-    @Override
-    public StreamEx<T> sequential() {
-        return StreamFactory.DEFAULT.newStreamEx(stream().sequential());
-    }
-
-    /**
-     * {@inheritDoc}
-     * 
-     * <p>
-     * If this stream was created using {@link #parallel(ForkJoinPool)}, the new
-     * stream forgets about supplied custom {@link ForkJoinPool} and its
-     * terminal operation will be executed in common pool.
-     */
-    @Override
-    public StreamEx<T> parallel() {
-        return StreamFactory.DEFAULT.newStreamEx(stream().parallel());
-    }
-
-    /**
-     * Returns an equivalent stream that is parallel and bound to the supplied
-     * {@link ForkJoinPool}.
-     *
-     * <p>
-     * This is an <a href="package-summary.html#StreamOps">intermediate</a>
-     * operation.
-     * 
-     * <p>
-     * The terminal operation of this stream or any derived stream (except the
-     * streams created via {@link #parallel()} or {@link #sequential()} methods)
-     * will be executed inside the supplied {@code ForkJoinPool}. If current
-     * thread does not belong to that pool, it will wait till calculation
-     * finishes.
-     *
-     * @param fjp a {@code ForkJoinPool} to submit the stream operation to.
-     * @return a parallel stream bound to the supplied {@code ForkJoinPool}
-     * @since 0.2.0
-     */
-    public StreamEx<T> parallel(ForkJoinPool fjp) {
-        return StreamFactory.forCustomPool(fjp).newStreamEx(stream().parallel());
+        return new StreamEx<>(
+            delegate(new CollapseSpliterator<>(collapsible, mapper, accumulator, combiner, spliterator())), strategy);
     }
 
     /**
@@ -166,7 +128,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @return the new stream
      */
     public <V> EntryStream<T, V> mapToEntry(Function<? super T, ? extends V> valueMapper) {
-        return strategy().newEntryStream(stream().map(e -> new SimpleImmutableEntry<>(e, valueMapper.apply(e))));
+        return new EntryStream<>(stream().map(e -> new SimpleImmutableEntry<>(e, valueMapper.apply(e))), strategy);
     }
 
     /**
@@ -188,8 +150,8 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      */
     public <K, V> EntryStream<K, V> mapToEntry(Function<? super T, ? extends K> keyMapper,
             Function<? super T, ? extends V> valueMapper) {
-        return strategy().newEntryStream(
-            stream().map(e -> new SimpleImmutableEntry<>(keyMapper.apply(e), valueMapper.apply(e))));
+        return new EntryStream<>(
+            stream().map(e -> new SimpleImmutableEntry<>(keyMapper.apply(e), valueMapper.apply(e))), strategy);
     }
 
     /**
@@ -209,7 +171,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @since 0.4.1
      */
     public StreamEx<T> mapFirst(Function<? super T, ? extends T> mapper) {
-        return strategy().newStreamEx(delegate(new PairSpliterator.PSOfRef<>(mapper, spliterator(), true)));
+        return new StreamEx<>(delegate(new PairSpliterator.PSOfRef<>(mapper, spliterator(), true)), strategy);
     }
 
     /**
@@ -228,7 +190,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @since 0.4.1
      */
     public StreamEx<T> mapLast(Function<? super T, ? extends T> mapper) {
-        return strategy().newStreamEx(delegate(new PairSpliterator.PSOfRef<>(mapper, spliterator(), false)));
+        return new StreamEx<>(delegate(new PairSpliterator.PSOfRef<>(mapper, spliterator(), false)), strategy);
     }
 
     /**
@@ -250,10 +212,10 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @return the new {@code EntryStream}
      */
     public <K, V> EntryStream<K, V> flatMapToEntry(Function<? super T, ? extends Map<K, V>> mapper) {
-        return strategy().newEntryStream(stream().flatMap(e -> {
+        return new EntryStream<>(stream().flatMap(e -> {
             Map<K, V> s = mapper.apply(e);
             return s == null ? null : s.entrySet().stream();
-        }));
+        }), strategy);
     }
 
     /**
@@ -279,10 +241,10 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
     @SuppressWarnings("unchecked")
     public <V> EntryStream<T, V> cross(V... other) {
         if (other.length == 0)
-            return strategy().<T, V> newEntryStream(delegate(Spliterators.emptySpliterator()));
+            return new EntryStream<>(delegate(Spliterators.emptySpliterator()), strategy);
         if (other.length == 1)
             return mapToEntry(e -> other[0]);
-        return strategy().newEntryStream(stream().flatMap(a -> EntryStream.withKey(a, Arrays.stream(other))));
+        return new EntryStream<>(stream().flatMap(a -> EntryStream.withKey(a, Arrays.stream(other))), strategy);
     }
 
     /**
@@ -307,8 +269,8 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      */
     public <V> EntryStream<T, V> cross(Collection<? extends V> other) {
         if (other.isEmpty())
-            return strategy().<T, V> newEntryStream(delegate(Spliterators.emptySpliterator()));
-        return strategy().newEntryStream(stream().flatMap(a -> EntryStream.withKey(a, other.stream())));
+            return new EntryStream<>(delegate(Spliterators.emptySpliterator()), strategy);
+        return new EntryStream<>(stream().flatMap(a -> EntryStream.withKey(a, other.stream())), strategy);
     }
 
     /**
@@ -330,7 +292,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @since 0.2.3
      */
     public <V> EntryStream<T, V> cross(Function<? super T, ? extends Stream<? extends V>> mapper) {
-        return strategy().newEntryStream(stream().flatMap(a -> EntryStream.withKey(a, mapper.apply(a))));
+        return new EntryStream<>(stream().flatMap(a -> EntryStream.withKey(a, mapper.apply(a))), strategy);
     }
 
     /**
@@ -1089,7 +1051,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
             result = Spliterators.emptySpliterator();
         else
             result = new DistinctSpliterator<>(spliterator, atLeast);
-        return strategy().newStreamEx(delegate(result));
+        return new StreamEx<>(delegate(result), strategy);
     }
 
     /**
@@ -1111,7 +1073,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @since 0.2.1
      */
     public <R> StreamEx<R> pairMap(BiFunction<? super T, ? super T, ? extends R> mapper) {
-        return strategy().newStreamEx(delegate(new PairSpliterator.PSOfRef<T, R>(mapper, spliterator())));
+        return new StreamEx<>(delegate(new PairSpliterator.PSOfRef<T, R>(mapper, spliterator())), strategy);
     }
 
     /**
@@ -1259,13 +1221,13 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @since 0.3.3
      */
     public EntryStream<T, Long> runLengths() {
-        return strategy().newEntryStream(collapseInternal(Objects::equals, t -> new ObjLongBox<>(t, 1L), (acc, t) -> {
+        return new EntryStream<>(collapseInternal(Objects::equals, t -> new ObjLongBox<>(t, 1L), (acc, t) -> {
             acc.b++;
             return acc;
         }, (e1, e2) -> {
             e1.b += e2.b;
             return e1;
-        }));
+        }), strategy);
     }
 
     /**
@@ -1371,7 +1333,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @since 0.5.3
      */
     public <R> StreamEx<R> withFirst(BiFunction<? super T, ? super T, ? extends R> mapper) {
-        return strategy().newStreamEx(delegate(new WithFirstSpliterator<>(spliterator(), mapper)));
+        return new StreamEx<>(delegate(new WithFirstSpliterator<>(spliterator(), mapper)), strategy);
     }
 
     /**
@@ -1394,8 +1356,8 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @since 0.5.3
      */
     public EntryStream<T, T> withFirst() {
-        return strategy().newEntryStream(
-            delegate(new WithFirstSpliterator<>(spliterator(), AbstractMap.SimpleImmutableEntry<T, T>::new)));
+        return new EntryStream<>(
+            delegate(new WithFirstSpliterator<>(spliterator(), AbstractMap.SimpleImmutableEntry<T, T>::new)), strategy);
     }
 
     /**
@@ -1513,7 +1475,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
         HeadTailSpliterator<T, R> spliterator = new HeadTailSpliterator<>(spliterator(), mapper, supplier);
         Stream<R> delegate = delegate(spliterator);
         spliterator.owner = delegate;
-        return strategy().newStreamEx(delegate);
+        return new StreamEx<>(delegate, strategy);
     }
 
     /**
@@ -1594,7 +1556,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @return the wrapped stream
      */
     public static <T> StreamEx<T> of(Stream<T> stream) {
-        return new StreamEx<>(unwrap(stream));
+        return new StreamEx<>(unwrap(stream), ExecutionStrategy.of(stream));
     }
 
     /**
diff --git a/src/main/java/one/util/streamex/StreamExInternals.java b/src/main/java/one/util/streamex/StreamExInternals.java
index cb227ac..d20cdd8 100644
--- a/src/main/java/one/util/streamex/StreamExInternals.java
+++ b/src/main/java/one/util/streamex/StreamExInternals.java
@@ -1075,11 +1075,8 @@ import java.util.stream.Stream;
         if (target == null) {
             return proxy;
         }
-        if (target instanceof AbstractStreamEx) {
-            target = ((AbstractStreamEx<?, ?>) target).stream;
-            if (target == null) {
-                return proxy;
-            }
+        if (target instanceof BaseStreamEx) {
+            return ((BaseStreamEx<?,?,?>)target).forwardClose(proxy);
         }
         try {
             if (SOURCE_STAGE != null && SOURCE_CLOSE_ACTION != null
diff --git a/src/main/java/one/util/streamex/StreamFactory.java b/src/main/java/one/util/streamex/StreamFactory.java
deleted file mode 100644
index 2ec7e55..0000000
--- a/src/main/java/one/util/streamex/StreamFactory.java
+++ /dev/null
@@ -1,545 +0,0 @@
-/*
- * Copyright 2015, 2016 Tagir Valeev
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *     http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package one.util.streamex;
-
-import java.util.List;
-import java.util.Map.Entry;
-import java.util.Optional;
-import java.util.OptionalDouble;
-import java.util.OptionalInt;
-import java.util.OptionalLong;
-import java.util.concurrent.ForkJoinPool;
-import java.util.function.BiConsumer;
-import java.util.function.BiFunction;
-import java.util.function.BinaryOperator;
-import java.util.function.Consumer;
-import java.util.function.DoubleBinaryOperator;
-import java.util.function.DoubleConsumer;
-import java.util.function.DoublePredicate;
-import java.util.function.Function;
-import java.util.function.IntBinaryOperator;
-import java.util.function.IntConsumer;
-import java.util.function.IntFunction;
-import java.util.function.IntPredicate;
-import java.util.function.LongBinaryOperator;
-import java.util.function.LongConsumer;
-import java.util.function.LongPredicate;
-import java.util.function.ObjDoubleConsumer;
-import java.util.function.ObjIntConsumer;
-import java.util.function.ObjLongConsumer;
-import java.util.function.Predicate;
-import java.util.function.Supplier;
-import java.util.stream.Collector;
-import java.util.stream.DoubleStream;
-import java.util.stream.IntStream;
-import java.util.stream.LongStream;
-import java.util.stream.Stream;
-
-/* package */class StreamFactory {
-
-    static final class CustomPoolStreamFactory extends StreamFactory {
-        private final ForkJoinPool fjp;
-
-        public CustomPoolStreamFactory(ForkJoinPool fjp) {
-            this.fjp = fjp;
-        }
-
-        @Override
-        public <T> StreamEx<T> newStreamEx(Stream<T> src) {
-            return new CustomStreamEx<>(src, this);
-        }
-
-        @Override
-        public <K, V> EntryStream<K, V> newEntryStream(Stream<? extends Entry<K, V>> src) {
-            return new CustomEntryStream<>(src, this);
-        }
-
-        @Override
-        public LongStreamEx newLongStreamEx(LongStream src) {
-            return new CustomLongStreamEx(src, this);
-        }
-
-        @Override
-        public IntStreamEx newIntStreamEx(IntStream src) {
-            return new CustomIntStreamEx(src, this);
-        }
-
-        @Override
-        public DoubleStreamEx newDoubleStreamEx(DoubleStream src) {
-            return new CustomDoubleStreamEx(src, this);
-        }
-
-        public <T> T terminate(Supplier<T> terminalOperation) {
-            return fjp.submit(terminalOperation::get).join();
-        }
-
-        public <T, U> T terminate(U value, Function<U, T> terminalOperation) {
-            return fjp.submit(() -> terminalOperation.apply(value)).join();
-        }
-    }
-
-    static final class CustomEntryStream<K, V> extends EntryStream<K, V> {
-        private final CustomPoolStreamFactory strategy;
-
-        CustomEntryStream(Stream<? extends Entry<K, V>> stream, CustomPoolStreamFactory strategy) {
-            super(stream);
-            this.strategy = strategy;
-        }
-
-        @Override
-        StreamFactory strategy() {
-            return strategy;
-        }
-
-        @Override
-        public void forEach(Consumer<? super Entry<K, V>> action) {
-            strategy.terminate(() -> {
-                stream().forEach(action);
-                return null;
-            });
-        }
-
-        @Override
-        public void forEachOrdered(Consumer<? super Entry<K, V>> action) {
-            strategy.terminate(() -> {
-                stream().forEachOrdered(action);
-                return null;
-            });
-        }
-
-        @Override
-        public <A> A[] toArray(IntFunction<A[]> generator) {
-            return strategy.terminate(generator, stream()::toArray);
-        }
-
-        @Override
-        public <R> R toListAndThen(Function<List<Entry<K, V>>, R> finisher) {
-            return strategy.terminate(finisher, super::toListAndThen);
-        }
-
-        @Override
-        public Entry<K, V> reduce(Entry<K, V> identity, BinaryOperator<Entry<K, V>> accumulator) {
-            return strategy.terminate(() -> stream().reduce(identity, accumulator));
-        }
-
-        @Override
-        public Optional<Entry<K, V>> reduce(BinaryOperator<Entry<K, V>> accumulator) {
-            return strategy.terminate(accumulator, stream()::reduce);
-        }
-
-        @Override
-        public <U> U reduce(U identity, BiFunction<U, ? super Entry<K, V>, U> accumulator, BinaryOperator<U> combiner) {
-            return strategy.terminate(() -> stream().reduce(identity, accumulator, combiner));
-        }
-
-        @Override
-        public <R> R collect(Supplier<R> supplier, BiConsumer<R, ? super Entry<K, V>> accumulator,
-                BiConsumer<R, R> combiner) {
-            return strategy.terminate(() -> stream().collect(supplier, accumulator, combiner));
-        }
-
-        @Override
-        <R, A> R rawCollect(Collector<? super Entry<K, V>, A, R> collector) {
-            return strategy.terminate(collector, stream()::collect);
-        }
-
-        @Override
-        public long count() {
-            return strategy.terminate(stream()::count);
-        }
-
-        @Override
-        public boolean anyMatch(Predicate<? super Entry<K, V>> predicate) {
-            return strategy.terminate(predicate, stream()::anyMatch);
-        }
-
-        @Override
-        public boolean allMatch(Predicate<? super Entry<K, V>> predicate) {
-            return strategy.terminate(predicate, stream()::allMatch);
-        }
-
-        @Override
-        public Optional<Entry<K, V>> findFirst() {
-            return strategy.terminate(stream()::findFirst);
-        }
-
-        @Override
-        public Optional<Entry<K, V>> findAny() {
-            return strategy.terminate(stream()::findAny);
-        }
-    }
-
-    static final class CustomStreamEx<T> extends StreamEx<T> {
-        private final CustomPoolStreamFactory strategy;
-
-        CustomStreamEx(Stream<T> stream, CustomPoolStreamFactory strategy) {
-            super(stream);
-            this.strategy = strategy;
-        }
-
-        @Override
-        StreamFactory strategy() {
-            return strategy;
-        }
-
-        @Override
-        public void forEach(Consumer<? super T> action) {
-            strategy.terminate(() -> {
-                stream().forEach(action);
-                return null;
-            });
-        }
-
-        @Override
-        public void forEachOrdered(Consumer<? super T> action) {
-            strategy.terminate(() -> {
-                stream().forEachOrdered(action);
-                return null;
-            });
-        }
-
-        @Override
-        public <A> A[] toArray(IntFunction<A[]> generator) {
-            return strategy.terminate(generator, stream()::toArray);
-        }
-
-        @Override
-        public <R> R toListAndThen(Function<List<T>, R> finisher) {
-            return strategy.terminate(finisher, super::toListAndThen);
-        }
-
-        @Override
-        public T reduce(T identity, BinaryOperator<T> accumulator) {
-            return strategy.terminate(() -> stream().reduce(identity, accumulator));
-        }
-
-        @Override
-        public Optional<T> reduce(BinaryOperator<T> accumulator) {
-            return strategy.terminate(accumulator, stream()::reduce);
-        }
-
-        @Override
-        public <U> U reduce(U identity, BiFunction<U, ? super T, U> accumulator, BinaryOperator<U> combiner) {
-            return strategy.terminate(() -> stream().reduce(identity, accumulator, combiner));
-        }
-
-        @Override
-        public <R> R collect(Supplier<R> supplier, BiConsumer<R, ? super T> accumulator, BiConsumer<R, R> combiner) {
-            return strategy.terminate(() -> stream().collect(supplier, accumulator, combiner));
-        }
-
-        @Override
-        <R, A> R rawCollect(Collector<? super T, A, R> collector) {
-            return strategy.terminate(collector, stream()::collect);
-        }
-
-        @Override
-        public long count() {
-            return strategy.terminate(stream()::count);
-        }
-
-        @Override
-        public boolean anyMatch(Predicate<? super T> predicate) {
-            return strategy.terminate(predicate, stream()::anyMatch);
-        }
-
-        @Override
-        public boolean allMatch(Predicate<? super T> predicate) {
-            return strategy.terminate(predicate, stream()::allMatch);
-        }
-
-        @Override
-        public Optional<T> findFirst() {
-            return strategy.terminate(stream()::findFirst);
-        }
-
-        @Override
-        public Optional<T> findAny() {
-            return strategy.terminate(stream()::findAny);
-        }
-    }
-
-    static final class CustomIntStreamEx extends IntStreamEx {
-        private final CustomPoolStreamFactory strategy;
-
-        CustomIntStreamEx(IntStream stream, CustomPoolStreamFactory strategy) {
-            super(stream);
-            this.strategy = strategy;
-        }
-
-        @Override
-        StreamFactory strategy() {
-            return strategy;
-        }
-
-        @Override
-        public void forEach(IntConsumer action) {
-            strategy.terminate(() -> {
-                stream.forEach(action);
-                return null;
-            });
-        }
-
-        @Override
-        public void forEachOrdered(IntConsumer action) {
-            strategy.terminate(() -> {
-                stream.forEachOrdered(action);
-                return null;
-            });
-        }
-
-        @Override
-        public int[] toArray() {
-            return strategy.terminate(stream::toArray);
-        }
-
-        @Override
-        public int reduce(int identity, IntBinaryOperator op) {
-            return strategy.terminate(() -> stream.reduce(identity, op));
-        }
-
-        @Override
-        public OptionalInt reduce(IntBinaryOperator op) {
-            return strategy.terminate(op, stream::reduce);
-        }
-
-        @Override
-        public <R> R collect(Supplier<R> supplier, ObjIntConsumer<R> accumulator, BiConsumer<R, R> combiner) {
-            return strategy.terminate(() -> stream.collect(supplier, accumulator, combiner));
-        }
-
-        @Override
-        public long count() {
-            return strategy.terminate(stream::count);
-        }
-
-        @Override
-        public OptionalDouble average() {
-            return strategy.terminate(stream::average);
-        }
-
-        @Override
-        public boolean anyMatch(IntPredicate predicate) {
-            return strategy.terminate(predicate, stream::anyMatch);
-        }
-
-        @Override
-        public boolean allMatch(IntPredicate predicate) {
-            return strategy.terminate(predicate, stream::allMatch);
-        }
-
-        @Override
-        public OptionalInt findFirst() {
-            return strategy.terminate(stream::findFirst);
-        }
-
-        @Override
-        public OptionalInt findAny() {
-            return strategy.terminate(stream::findAny);
-        }
-    }
-
-    static final class CustomLongStreamEx extends LongStreamEx {
-        private final CustomPoolStreamFactory strategy;
-
-        CustomLongStreamEx(LongStream stream, CustomPoolStreamFactory strategy) {
-            super(stream);
-            this.strategy = strategy;
-        }
-
-        @Override
-        StreamFactory strategy() {
-            return strategy;
-        }
-
-        @Override
-        public void forEach(LongConsumer action) {
-            strategy.terminate(() -> {
-                stream.forEach(action);
-                return null;
-            });
-        }
-
-        @Override
-        public void forEachOrdered(LongConsumer action) {
-            strategy.terminate(() -> {
-                stream.forEachOrdered(action);
-                return null;
-            });
-        }
-
-        @Override
-        public long[] toArray() {
-            return strategy.terminate(stream::toArray);
-        }
-
-        @Override
-        public long reduce(long identity, LongBinaryOperator op) {
-            return strategy.terminate(() -> stream.reduce(identity, op));
-        }
-
-        @Override
-        public OptionalLong reduce(LongBinaryOperator op) {
-            return strategy.terminate(op, stream::reduce);
-        }
-
-        @Override
-        public <R> R collect(Supplier<R> supplier, ObjLongConsumer<R> accumulator, BiConsumer<R, R> combiner) {
-            return strategy.terminate(() -> stream.collect(supplier, accumulator, combiner));
-        }
-
-        @Override
-        public long count() {
-            return strategy.terminate(stream::count);
-        }
-
-        @Override
-        public OptionalDouble average() {
-            return strategy.terminate(stream::average);
-        }
-
-        @Override
-        public boolean anyMatch(LongPredicate predicate) {
-            return strategy.terminate(predicate, stream::anyMatch);
-        }
-
-        @Override
-        public boolean allMatch(LongPredicate predicate) {
-            return strategy.terminate(predicate, stream::allMatch);
-        }
-
-        @Override
-        public OptionalLong findFirst() {
-            return strategy.terminate(stream::findFirst);
-        }
-
-        @Override
-        public OptionalLong findAny() {
-            return strategy.terminate(stream::findAny);
-        }
-    }
-
-    static final class CustomDoubleStreamEx extends DoubleStreamEx {
-        private final CustomPoolStreamFactory strategy;
-
-        CustomDoubleStreamEx(DoubleStream stream, CustomPoolStreamFactory strategy) {
-            super(stream);
-            this.strategy = strategy;
-        }
-
-        @Override
-        StreamFactory strategy() {
-            return strategy;
-        }
-
-        @Override
-        public void forEach(DoubleConsumer action) {
-            strategy.terminate(() -> {
-                stream.forEach(action);
-                return null;
-            });
-        }
-
-        @Override
-        public void forEachOrdered(DoubleConsumer action) {
-            strategy.terminate(() -> {
-                stream.forEachOrdered(action);
-                return null;
-            });
-        }
-
-        @Override
-        public double[] toArray() {
-            return strategy.terminate(stream::toArray);
-        }
-
-        @Override
-        public double reduce(double identity, DoubleBinaryOperator op) {
-            return strategy.terminate(() -> stream.reduce(identity, op));
-        }
-
-        @Override
-        public OptionalDouble reduce(DoubleBinaryOperator op) {
-            return strategy.terminate(op, stream::reduce);
-        }
-
-        @Override
-        public <R> R collect(Supplier<R> supplier, ObjDoubleConsumer<R> accumulator, BiConsumer<R, R> combiner) {
-            return strategy.terminate(() -> stream.collect(supplier, accumulator, combiner));
-        }
-
-        @Override
-        public double sum() {
-            return strategy.terminate(stream::sum);
-        }
-
-        @Override
-        public long count() {
-            return strategy.terminate(stream::count);
-        }
-
-        @Override
-        public OptionalDouble average() {
-            return strategy.terminate(stream::average);
-        }
-
-        @Override
-        public boolean anyMatch(DoublePredicate predicate) {
-            return strategy.terminate(predicate, stream::anyMatch);
-        }
-
-        @Override
-        public boolean allMatch(DoublePredicate predicate) {
-            return strategy.terminate(predicate, stream::allMatch);
-        }
-
-        @Override
-        public OptionalDouble findFirst() {
-            return strategy.terminate(stream::findFirst);
-        }
-
-        @Override
-        public OptionalDouble findAny() {
-            return strategy.terminate(stream::findAny);
-        }
-    }
-
-    public <T> StreamEx<T> newStreamEx(Stream<T> src) {
-        return new StreamEx<>(src);
-    }
-
-    public <K, V> EntryStream<K, V> newEntryStream(Stream<? extends Entry<K, V>> src) {
-        return new EntryStream<>(src);
-    }
-
-    public LongStreamEx newLongStreamEx(LongStream src) {
-        return new LongStreamEx(src);
-    }
-
-    public IntStreamEx newIntStreamEx(IntStream src) {
-        return new IntStreamEx(src);
-    }
-
-    public DoubleStreamEx newDoubleStreamEx(DoubleStream src) {
-        return new DoubleStreamEx(src);
-    }
-
-    static final StreamFactory DEFAULT = new StreamFactory();
-
-    static StreamFactory forCustomPool(ForkJoinPool fjp) {
-        return new CustomPoolStreamFactory(fjp);
-    }
-}
