diff --git a/src/main/java/one/util/streamex/WithFirstMapperSpliterator.java b/src/main/java/one/util/streamex/HeadTailSpliterator.java
similarity index 88%
rename from src/main/java/one/util/streamex/WithFirstMapperSpliterator.java
rename to src/main/java/one/util/streamex/HeadTailSpliterator.java
index 93ebe83..e196eef 100644
--- a/src/main/java/one/util/streamex/WithFirstMapperSpliterator.java
+++ b/src/main/java/one/util/streamex/HeadTailSpliterator.java
@@ -28,13 +28,13 @@ import static one.util.streamex.StreamExInternals.*;
 /**
  * @author Tagir Valeev
  */
-/*package*/ final class WithFirstMapperSpliterator<T, U> extends AbstractSpliterator<U> {
+/*package*/ final class HeadTailSpliterator<T, U> extends AbstractSpliterator<U> {
     private final Spliterator<T> source;
     private final BiFunction<? super T, ? super StreamEx<T>, ? extends Stream<U>> mapper;
     private Spliterator<U> target;
     private BaseStream<?, ?> stream;
     
-    WithFirstMapperSpliterator(Spliterator<T> source, BiFunction<? super T, ? super StreamEx<T>, ? extends Stream<U>> mapper) {
+    HeadTailSpliterator(Spliterator<T> source, BiFunction<? super T, ? super StreamEx<T>, ? extends Stream<U>> mapper) {
         super(Long.MAX_VALUE, ORDERED);
         this.source = source;
         this.mapper = mapper;
diff --git a/src/main/java/one/util/streamex/StreamEx.java b/src/main/java/one/util/streamex/StreamEx.java
index 2e53eb0..2d9f419 100644
--- a/src/main/java/one/util/streamex/StreamEx.java
+++ b/src/main/java/one/util/streamex/StreamEx.java
@@ -23,6 +23,7 @@ import java.nio.charset.Charset;
 import java.nio.charset.StandardCharsets;
 import java.nio.file.Files;
 import java.nio.file.Path;
+import java.util.AbstractMap;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
@@ -1324,6 +1325,31 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
         }).map(pair -> mapper.apply(pair.a, pair.b));
     }
 
+    /**
+     * Returns a stream consisting of the results of applying the given function
+     * to the the first element and every other element of this stream.
+     * 
+     * <p>
+     * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
+     * operation</a>.
+     * 
+     * <p>
+     * The size of the resulting stream is one element less than the input
+     * stream. If the input stream is empty or contains just one element, then
+     * the output stream will be empty.
+     *
+     * @param <R> The element type of the new stream
+     * @param mapper a non-interfering, stateless function to apply to the first
+     *        stream element and every other element
+     * @return the new stream
+     * @see #withFirst()
+     * @see #headTail(BiFunction)
+     * @since 0.5.3
+     */
+    public <R> StreamEx<R> withFirst(BiFunction<? super T, ? super T, ? extends R> mapper) {
+        return strategy().newStreamEx(delegate(new WithFirstSpliterator<>(stream.spliterator(), mapper)));
+    }
+
     /**
      * Creates an {@link EntryStream} consisting of the {@link Entry} objects
      * which keys are all the same and equal to the first element of this stream
@@ -1340,10 +1366,12 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      *
      * @return the new stream
      * @see #withFirst(BiFunction)
+     * @see #headTail(BiFunction)
      * @since 0.5.3
      */
     public EntryStream<T, T> withFirst() {
-        return strategy().newEntryStream(delegate(new WithFirstSpliterator<>(stream.spliterator())));
+        return strategy().newEntryStream(
+            delegate(new WithFirstSpliterator<>(stream.spliterator(), AbstractMap.SimpleImmutableEntry<T, T>::new)));
     }
 
     /**
@@ -1389,8 +1417,8 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see #withFirst()
      * @since 0.5.3
      */
-    public <R> StreamEx<R> withFirst(BiFunction<? super T, ? super StreamEx<T>, ? extends Stream<R>> mapper) {
-        WithFirstMapperSpliterator<T, R> spliterator = new WithFirstMapperSpliterator<>(stream.spliterator(), mapper);
+    public <R> StreamEx<R> headTail(BiFunction<? super T, ? super StreamEx<T>, ? extends Stream<R>> mapper) {
+        HeadTailSpliterator<T, R> spliterator = new HeadTailSpliterator<>(stream.spliterator(), mapper);
         return strategy().newStreamEx(delegate(spliterator).onClose(spliterator::close));
     }
 
diff --git a/src/main/java/one/util/streamex/WithFirstSpliterator.java b/src/main/java/one/util/streamex/WithFirstSpliterator.java
index e8d24b1..209a09c 100644
--- a/src/main/java/one/util/streamex/WithFirstSpliterator.java
+++ b/src/main/java/one/util/streamex/WithFirstSpliterator.java
@@ -15,29 +15,29 @@
  */
 package one.util.streamex;
 
-import java.util.AbstractMap;
-import java.util.Map;
-import java.util.Map.Entry;
 import java.util.Spliterator;
 import java.util.concurrent.locks.ReentrantLock;
+import java.util.function.BiFunction;
 import java.util.function.Consumer;
 
 /**
  * @author Tagir Valeev
  */
-/* package */final class WithFirstSpliterator<T> implements Spliterator<Map.Entry<T, T>>, Cloneable {
+/* package */final class WithFirstSpliterator<T, R> implements Spliterator<R>, Cloneable {
     private static final int STATE_NONE = 0;
     private static final int STATE_INIT = 1;
     private static final int STATE_EMPTY = 2;
 
     private ReentrantLock lock;
     private Spliterator<T> source;
-    private WithFirstSpliterator<T> prefix;
+    private WithFirstSpliterator<T, R> prefix;
     private volatile T first;
     private volatile int state = STATE_NONE;
+    private final BiFunction<? super T, ? super T, ? extends R> mapper;
     
-    WithFirstSpliterator(Spliterator<T> source) {
+    WithFirstSpliterator(Spliterator<T> source, BiFunction<? super T, ? super T, ? extends R> mapper) {
         this.source = source;
+        this.mapper = mapper;
     }
     
     private void acquire() {
@@ -53,7 +53,7 @@ import java.util.function.Consumer;
     }
 
     @Override
-    public boolean tryAdvance(Consumer<? super Entry<T, T>> action) {
+    public boolean tryAdvance(Consumer<? super R> action) {
         if (state == STATE_NONE) {
             acquire();
             try {
@@ -65,7 +65,7 @@ import java.util.function.Consumer;
         }
         if (state != STATE_INIT)
             return false;
-        return source.tryAdvance(x -> action.accept(new AbstractMap.SimpleImmutableEntry<>(first, x)));
+        return source.tryAdvance(x -> action.accept(mapper.apply(first, x)));
     }
 
     private void doInit() {
@@ -102,7 +102,7 @@ import java.util.function.Consumer;
     }
 
     @Override
-    public void forEachRemaining(Consumer<? super Entry<T, T>> action) {
+    public void forEachRemaining(Consumer<? super R> action) {
         acquire();
         try {
             source.forEachRemaining(x -> {
@@ -113,7 +113,7 @@ import java.util.function.Consumer;
                     }
                 }
                 release();
-                action.accept(new AbstractMap.SimpleImmutableEntry<>(first, x));
+                action.accept(mapper.apply(first, x));
             });
         }
         finally {
@@ -122,7 +122,7 @@ import java.util.function.Consumer;
     }
 
     @Override
-    public Spliterator<Entry<T, T>> trySplit() {
+    public Spliterator<R> trySplit() {
         Spliterator<T> prefix;
         if(lock == null)
             lock = new ReentrantLock();
@@ -132,7 +132,7 @@ import java.util.function.Consumer;
             if (prefix == null)
                 return null;
             @SuppressWarnings("unchecked")
-            WithFirstSpliterator<T> result = (WithFirstSpliterator<T>) super.clone();
+            WithFirstSpliterator<T, R> result = (WithFirstSpliterator<T, R>) super.clone();
             result.source = prefix;
             return this.prefix = result;
         } catch (CloneNotSupportedException e) {
diff --git a/src/test/java/one/util/streamex/StreamExTest.java b/src/test/java/one/util/streamex/StreamExTest.java
index eb9f1a7..1e9583e 100644
--- a/src/test/java/one/util/streamex/StreamExTest.java
+++ b/src/test/java/one/util/streamex/StreamExTest.java
@@ -1512,6 +1512,9 @@ public class StreamExTest {
             
             streamEx(() -> StreamEx.of("a", "b", "c", "d"), s -> assertEquals(Collections.singletonMap("a", asList("b",
                 "c", "d")), s.get().withFirst().grouping()));
+
+            streamEx(() -> StreamEx.of("a", "b", "c", "d"), s -> assertEquals(asList("ab", "ac", "ad"), s.get()
+                    .withFirst(String::concat).toList()));
             
             // Header mapping
             String input = "name,type,value\nID,int,5\nSurname,string,Smith\nGiven name,string,John";
@@ -1522,35 +1525,49 @@ public class StreamExTest {
             streamEx(() -> StreamEx.ofLines(new StringReader(input)), s -> {
                 assertEquals(expected, s.get().map(str -> str.split(",")).withFirst().mapKeyValue(
                     (header, row) -> EntryStream.zip(header, row).toMap()).toList());
-                assertEquals(expected, s.get().map(str -> str.split(",")).withFirst((header, stream) -> 
-                    stream.map(row -> EntryStream.zip(header, row).toMap())).toList());
+                assertEquals(expected, s.get().map(str -> str.split(","))
+                    .withFirst((header, row) -> EntryStream.zip(header, row).toMap()).toList());
             });
         });
         Map<Integer, List<Integer>> expected = Collections
                 .singletonMap(0, IntStreamEx.range(1, 10000).boxed().toList());
         streamEx(() -> IntStreamEx.range(10000).boxed(), s -> assertEquals(expected, s.get().withFirst().grouping()));
-
+    }
+    
+    @Test
+    public void testHeadTail() {
+        repeat(10, i -> {
+            // Header mapping
+            String input = "name,type,value\nID,int,5\nSurname,string,Smith\nGiven name,string,John";
+            List<Map<String, String>> expected = asList(EntryStream.of("name", "ID", "type", "int", "value", "5").toMap(),
+                EntryStream.of("name", "Surname", "type", "string", "value", "Smith").toMap(),
+                EntryStream.of("name", "Given name", "type", "string", "value", "John").toMap()
+                    );
+            streamEx(() -> StreamEx.ofLines(new StringReader(input)), s -> 
+                assertEquals(expected, s.get().map(str -> str.split(",")).headTail((header, stream) -> 
+                stream.map(row -> EntryStream.zip(header, row).toMap())).toList()));
+        });
         streamEx(() -> StreamEx.of("a", "b", "c", "d"), s -> assertEquals(Collections.singletonMap("a", asList("b",
-            "c", "d")), s.get().withFirst((x, str) -> str.mapToEntry(e -> x, e -> e)).mapToEntry(Entry::getKey,
-            Entry::getValue).grouping()));
-
+            "c", "d")), s.get().headTail((x, str) -> str.mapToEntry(e -> x, e -> e)).mapToEntry(Entry::getKey,
+                Entry::getValue).grouping()));
+        
         streamEx(() -> StreamEx.iterate(2, x -> x + 1), s -> assertEquals(asList(2, 3, 5, 7, 11, 13, 17, 19, 23, 29,
             31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97), sieve(s.get()).takeWhile(x -> x < 100)
-                .toList()));
+            .toList()));
         
         emptyStreamEx(Integer.class, s -> {
-            assertEquals(0L, s.get().withFirst((first, head) -> {
+            assertEquals(0L, s.get().headTail((first, head) -> {
                 throw new IllegalStateException();
             }).count());
-            assertFalse(s.get().withFirst((first, head) -> {
+            assertFalse(s.get().headTail((first, head) -> {
                 throw new IllegalStateException();
             }).findFirst().isPresent());
         });
         
         streamEx(() -> IntStreamEx.range(100).boxed(), s -> assertEquals(IntStreamEx.rangeClosed(99, 0, -1).boxed()
-                .toList(), reverse(s.get()).toList()));
+            .toList(), reverse(s.get()).toList()));
         
-        streamEx(() -> StreamEx.of(1, 2), s -> assertEquals(0, s.get().withFirst((head, stream) -> null).count()));
+        streamEx(() -> StreamEx.of(1, 2), s -> assertEquals(0, s.get().headTail((head, stream) -> null).count()));
         
         streamEx(() -> StreamEx.iterate(1, x -> x + 1), s -> assertEquals(asList(1, 3, 6, 10, 15, 21, 28, 36, 45, 55,
             66, 78, 91), scanLeft(s.get(), Integer::sum).takeWhile(x -> x < 100).toList()));
@@ -1559,32 +1576,32 @@ public class StreamExTest {
         int[] input = { 1, 2, 3, -1, 3, -10, 9, 100, 1, 100, 0 };
         AtomicInteger counter = new AtomicInteger();
         assertEquals(5, scanLeft(IntStreamEx.of(input).peek(x -> counter.incrementAndGet()).boxed(), Integer::sum)
-                .indexOf(x -> x < 0).getAsLong());
+            .indexOf(x -> x < 0).getAsLong());
         assertEquals(6, counter.get());
     }
     
     // Filters the input stream of natural numbers (2, 3, 4...) leaving only prime numbers
     private static StreamEx<Integer> sieve(StreamEx<Integer> input) {
-        return input.withFirst((head, stream) -> sieve(stream.filter(n -> n % head != 0)).prepend(head));
+        return input.headTail((head, stream) -> sieve(stream.filter(n -> n % head != 0)).prepend(head));
     }
 
     // Creates a reversed stream
     private static <T> StreamEx<T> reverse(StreamEx<T> input) {
-        return input.withFirst((head, stream) -> reverse(stream).append(head));
+        return input.headTail((head, stream) -> reverse(stream).append(head));
     }
     
     // Creates lazy scanLeft stream
     private static <T> StreamEx<T> scanLeft(StreamEx<T> input, BinaryOperator<T> operator) {
-        return input.withFirst((head, stream) -> scanLeft(stream.mapFirst(cur -> operator.apply(head, cur)), operator)
+        return input.headTail((head, stream) -> scanLeft(stream.mapFirst(cur -> operator.apply(head, cur)), operator)
                 .prepend(head));
     }
     
     @Test
-    public void testWithFirstClose() {
+    public void testHeadTailClose() {
         AtomicBoolean origClosed = new AtomicBoolean();
         AtomicBoolean internalClosed = new AtomicBoolean();
         AtomicBoolean finalClosed = new AtomicBoolean();
-        StreamEx<Integer> res = StreamEx.of(1, 2, 3).onClose(() -> origClosed.set(true)).<Integer>withFirst(
+        StreamEx<Integer> res = StreamEx.of(1, 2, 3).onClose(() -> origClosed.set(true)).<Integer>headTail(
             (head, stream) -> stream.onClose(() -> internalClosed.set(true)).map(x -> x + head)).onClose(
             () -> finalClosed.set(true));
         assertEquals(asList(3, 4), res.toList());
@@ -1593,7 +1610,7 @@ public class StreamExTest {
         assertTrue(internalClosed.get());
         assertTrue(finalClosed.get());
         
-        res = StreamEx.<Integer>empty().withFirst((head, tail) -> tail);
+        res = StreamEx.<Integer>empty().headTail((head, tail) -> tail);
         assertEquals(0, res.count());
         res.close();
     }
diff --git a/src/test/java/one/util/streamex/WithFirstSpliteratorTest.java b/src/test/java/one/util/streamex/WithFirstSpliteratorTest.java
index c09adcf..1d230e6 100644
--- a/src/test/java/one/util/streamex/WithFirstSpliteratorTest.java
+++ b/src/test/java/one/util/streamex/WithFirstSpliteratorTest.java
@@ -15,6 +15,7 @@
  */
 package one.util.streamex;
 
+import java.util.AbstractMap;
 import java.util.stream.Stream;
 
 import org.junit.Test;
@@ -28,9 +29,10 @@ public class WithFirstSpliteratorTest {
     @Test
     public void testSpliterator() {
         checkSpliterator("withFirst", EntryStream.of(0, 1, 0, 2, 0, 3, 0, 4, 0, 5).toList(),
-            () -> new WithFirstSpliterator<>(Stream.of(0, 1, 2, 3, 4, 5).spliterator()));
+            () -> new WithFirstSpliterator<>(Stream.of(0, 1, 2, 3, 4, 5).spliterator(),
+                    AbstractMap.SimpleImmutableEntry<Integer, Integer>::new));
         checkSpliterator("withFirstFlatMap", EntryStream.of(0, 1, 0, 2, 0, 3, 0, 4, 0, 5).toList(),
             () -> new WithFirstSpliterator<>(Stream.of(0, 2, 4).flatMap(x -> Stream.of(x, x + 1)).parallel()
-                    .spliterator()));
+                    .spliterator(), AbstractMap.SimpleImmutableEntry<Integer, Integer>::new));
     }
 }
