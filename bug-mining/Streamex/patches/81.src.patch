diff --git a/src/main/java/one/util/streamex/WithFirstSpliterator.java b/src/main/java/one/util/streamex/WithFirstSpliterator.java
index 74077c6..253ae3d 100644
--- a/src/main/java/one/util/streamex/WithFirstSpliterator.java
+++ b/src/main/java/one/util/streamex/WithFirstSpliterator.java
@@ -19,70 +19,140 @@ import java.util.AbstractMap;
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Spliterator;
+import java.util.concurrent.locks.ReentrantLock;
 import java.util.function.Consumer;
 
 /**
  * @author Tagir Valeev
  */
-/*package*/ final class WithFirstSpliterator<T> implements Spliterator<Map.Entry<T, T>> {
-    private final Spliterator<T> source;
-    private T first;
-    private boolean initialized;
+/* package */final class WithFirstSpliterator<T> implements Spliterator<Map.Entry<T, T>>, Cloneable {
+    private static final int STATE_NONE = 0;
+    private static final int STATE_INIT = 1;
+    private static final int STATE_EMPTY = 2;
+
+    private ReentrantLock lock;
+    private Spliterator<T> source;
+    private WithFirstSpliterator<T> prefix;
+    private volatile T first;
+    private volatile int state = STATE_NONE;
     
     WithFirstSpliterator(Spliterator<T> source) {
         this.source = source;
     }
     
-    private WithFirstSpliterator(Spliterator<T> source, T first) {
-        this.source = source;
-        this.first = first;
-        this.initialized = true;
+    private void acquire() {
+        if(lock != null && state == STATE_NONE) {
+            lock.lock();
+        }
     }
     
+    private void release() {
+        if(lock != null && lock.isHeldByCurrentThread()) {
+            lock.unlock();
+        }
+    }
+
     @Override
     public boolean tryAdvance(Consumer<? super Entry<T, T>> action) {
-        if(!init())
+        if (state == STATE_NONE) {
+            acquire();
+            try {
+                doInit();
+            }
+            finally {
+                release();
+            }
+        }
+        if (state != STATE_INIT)
             return false;
         return source.tryAdvance(x -> action.accept(new AbstractMap.SimpleImmutableEntry<>(first, x)));
     }
 
-    private boolean init() {
-        if(initialized)
-            return true;
-        initialized = true;
-        return source.tryAdvance(x -> first = x);
+    private void doInit() {
+        int prefixState = state;
+        if (prefixState != STATE_NONE)
+            return;
+        if (prefix != null) {
+            prefix.doInit();
+            prefixState = prefix.state;
+        }
+        if (prefixState == STATE_INIT) {
+            this.first = prefix.first;
+            this.state = STATE_INIT;
+            return;
+        }
+        state = source.tryAdvance(x -> first = x) ? STATE_INIT : STATE_EMPTY;
+    }
+
+    private boolean initForEach(T x) {
+        int prefixState = state;
+        if (prefixState != STATE_NONE)
+            return false;
+        if (prefix != null) {
+            prefix.doInit();
+            prefixState = prefix.state;
+        }
+        state = STATE_INIT;
+        if (prefixState == STATE_INIT) {
+            this.first = prefix.first;
+            return false;
+        }
+        this.first = x;
+        return true;
     }
 
     @Override
     public void forEachRemaining(Consumer<? super Entry<T, T>> action) {
-        source.forEachRemaining(x -> {
-            if(!initialized) {
-                first = x;
-                initialized = true;
-            } else {
+        acquire();
+        try {
+            source.forEachRemaining(x -> {
+                if (state == STATE_NONE) {
+                    if (initForEach(x)) {
+                        release();
+                        return;
+                    }
+                }
+                release();
                 action.accept(new AbstractMap.SimpleImmutableEntry<>(first, x));
-            }
-        });
+            });
+        }
+        finally {
+            release();
+        }
     }
 
     @Override
     public Spliterator<Entry<T, T>> trySplit() {
-        if(!init())
-            return null;
-        Spliterator<T> prefix = source.trySplit();
-        if(prefix == null)
-            return null;
-        return new WithFirstSpliterator<>(prefix, first);
+        Spliterator<T> prefix;
+        if(lock == null)
+            lock = new ReentrantLock();
+        acquire();
+        try {
+            prefix = source.trySplit();
+            if (prefix == null)
+                return null;
+            @SuppressWarnings("unchecked")
+            WithFirstSpliterator<T> result = (WithFirstSpliterator<T>) super.clone();
+            result.source = prefix;
+            return this.prefix = result;
+        } catch (CloneNotSupportedException e) {
+            throw new InternalError();
+        } finally {
+            release();
+        }
     }
 
     @Override
     public long estimateSize() {
         long size = source.estimateSize();
-        return size == Long.MAX_VALUE || size <= 0 ? size : size - 1;
+        if (size > 0 && size < Long.MAX_VALUE && lock == null)
+            size--;
+        return size;
     }
 
     @Override
     public int characteristics() {
-        return NONNULL | (source.characteristics() & (DISTINCT | SIZED | SUBSIZED | IMMUTABLE | CONCURRENT | ORDERED));
+        return NONNULL
+            | (source.characteristics() & (DISTINCT | IMMUTABLE | CONCURRENT | ORDERED | (lock == null ? SIZED : 0)));
     }
 }
diff --git a/src/test/java/one/util/streamex/StreamExTest.java b/src/test/java/one/util/streamex/StreamExTest.java
index 6850432..7925f3e 100644
--- a/src/test/java/one/util/streamex/StreamExTest.java
+++ b/src/test/java/one/util/streamex/StreamExTest.java
@@ -1499,11 +1499,21 @@ public class StreamExTest {
     
     @Test
     public void testWithFirst() {
-        assertEquals(asList(1, 2, 3, 4, 5), StreamEx.of(0, 2, 4).flatMap(x -> Stream.of(x, x + 1))
-                .withFirst().values().toList());
-        
-        streamEx(() -> StreamEx.of("a", "b", "c", "d"), s -> assertEquals(Collections.singletonMap("a", asList("b",
-            "c", "d")), s.get().withFirst().grouping()));
+        repeat(100, i -> {
+            streamEx(() -> StreamEx.of(0, 2, 4), s -> assertEquals(asList(1, 2, 3, 4, 5), s.get().flatMap(
+                x -> Stream.of(x, x + 1)).withFirst().values().toList()));
+            
+            streamEx(() -> StreamEx.of("a", "b", "c", "d"), s -> assertEquals(Collections.singletonMap("a", asList("b",
+                "c", "d")), s.get().withFirst().grouping()));
+            
+            String input = "name,type,value\nID,int,5\nSurname,string,Smith\nGiven name,string,John";
+            List<Map<String, String>> data = StreamEx.ofLines(new StringReader(input)).map(s -> s.split(","))
+                    .withFirst().mapKeyValue((header, row) -> EntryStream.zip(header, row).toMap()).toList();
+            assertEquals(asList(EntryStream.of("name", "ID", "type", "int", "value", "5").toMap(),
+                EntryStream.of("name", "Surname", "type", "string", "value", "Smith").toMap(),
+                EntryStream.of("name", "Given name", "type", "string", "value", "John").toMap()
+                ), data);
+        });
 
         streamEx(() -> StreamEx.of("a", "b", "c", "d"), s -> assertEquals(Collections.singletonMap("a", asList("b",
             "c", "d")), s.get().withFirst((x, str) -> str.mapToEntry(e -> x, e -> e)).mapToEntry(Entry::getKey,
@@ -1512,7 +1522,6 @@ public class StreamExTest {
         streamEx(() -> StreamEx.iterate(2, x -> x + 1), s -> assertEquals(asList(2, 3, 5, 7, 11, 13, 17, 19, 23, 29,
             31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97), sieve(s.get()).takeWhile(x -> x < 100)
                 .toList()));
-        
     }
     
     private static StreamEx<Integer> sieve(StreamEx<Integer> input) {
diff --git a/src/test/java/one/util/streamex/WithFirstSpliteratorTest.java b/src/test/java/one/util/streamex/WithFirstSpliteratorTest.java
new file mode 100644
index 0000000..c09adcf
--- /dev/null
+++ b/src/test/java/one/util/streamex/WithFirstSpliteratorTest.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2015, 2016 Tagir Valeev
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package one.util.streamex;
+
+import java.util.stream.Stream;
+
+import org.junit.Test;
+
+import static one.util.streamex.TestHelpers.*;
+
+/**
+ * @author Tagir Valeev
+ */
+public class WithFirstSpliteratorTest {
+    @Test
+    public void testSpliterator() {
+        checkSpliterator("withFirst", EntryStream.of(0, 1, 0, 2, 0, 3, 0, 4, 0, 5).toList(),
+            () -> new WithFirstSpliterator<>(Stream.of(0, 1, 2, 3, 4, 5).spliterator()));
+        checkSpliterator("withFirstFlatMap", EntryStream.of(0, 1, 0, 2, 0, 3, 0, 4, 0, 5).toList(),
+            () -> new WithFirstSpliterator<>(Stream.of(0, 2, 4).flatMap(x -> Stream.of(x, x + 1)).parallel()
+                    .spliterator()));
+    }
+}
