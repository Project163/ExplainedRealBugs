diff --git a/src/main/java/javax/util/streamex/Joining.java b/src/main/java/javax/util/streamex/Joining.java
index a586f36..75451cc 100644
--- a/src/main/java/javax/util/streamex/Joining.java
+++ b/src/main/java/javax/util/streamex/Joining.java
@@ -83,6 +83,11 @@ public class Joining extends CancellableCollector<CharSequence, Joining.Accumula
         }
     }
     
+    private static int copy(char[] buf, int pos, String str) {
+        str.getChars(0, str.length(), buf, pos);
+        return pos+str.length();
+    }
+    
     private int copyCut(char[] buf, int pos, String str, int limit, int cutStrategy) {
         int endPos = str.length();
         switch(lenStrategy) {
@@ -136,6 +141,7 @@ public class Joining extends CancellableCollector<CharSequence, Joining.Accumula
             case CUT_CODEPOINT:
                 if(Character.isHighSurrogate(str.charAt(endPos)) && Character.isLowSurrogate(str.charAt(endPos+1)))
                     endPos--;
+                break;
             default:
                 throw new InternalError();
             }
@@ -150,7 +156,7 @@ public class Joining extends CancellableCollector<CharSequence, Joining.Accumula
         return limit;
     }
 
-    public static Joining on(CharSequence delimiter) {
+    public static Joining with(CharSequence delimiter) {
         return new Joining(delimiter.toString(), "...", "", "", CUT_CODEPOINT, LENGTH_CHARS, -1);
     }
 
@@ -290,38 +296,65 @@ public class Joining extends CancellableCollector<CharSequence, Joining.Accumula
         int delimCount = length(delimiter);
         int limit = maxLength - addCount;
         if(limit <= 0) {
-            // TODO: handle prefix/suffix here
-            return acc -> "";
+            char[] buf = new char[prefix.length()+suffix.length()];
+            int rest = maxLength;
+            int pos = copyCut(buf, 0, prefix, rest, cutStrategy);
+            rest -= length(prefix);
+            if(rest > 0)
+                pos = copyCut(buf, pos, suffix, rest, cutStrategy);
+            String result = new String(buf, 0, pos);
+            return acc -> result;
         }
         return acc -> {
             if(acc.count <= limit)
                 return noOverflow.apply(acc);
             char[] buf = new char[acc.chars+prefix.length()+suffix.length()];
             int size = acc.data.size();
-            prefix.getChars(0, prefix.length(), buf, 0);
-            int pos = prefix.length();
+            int pos = copy(buf, 0, prefix);
             int ellipsisCount = length(ellipsis);
             int rest = limit - ellipsisCount;
             if(rest < 0) {
                 pos = copyCut(buf, pos, ellipsis, limit, CUT_ANYWHERE);
             } else {
                 for (int i = 0; i < size; i++) {
+                    String s = acc.data.get(i).toString();
+                    int count = length(s);
                     if(i > 0) {
-                        
+                        if(cutStrategy == CUT_BEFORE_DELIMITER && delimCount+count > rest) {
+                            pos = copy(buf, pos, ellipsis);
+                            break;
+                        }
+                        if(delimCount > rest) {
+                            pos = copyCut(buf, pos, delimiter, rest, cutStrategy);
+                            pos = copy(buf, pos, ellipsis);
+                            break;
+                        }
+                        rest -= delimCount;
+                        pos = copy(buf, pos, delimiter);
                     }
-                    String s = acc.data.get(i).toString();
-                    
-                    // todo
+                    if (cutStrategy == CUT_AFTER_DELIMITER && delimCount + count > rest) {
+                        pos = copy(buf, pos, ellipsis);
+                        break;
+                    }
+                    if(count > rest) {
+                        pos = copyCut(buf, pos, s, rest, cutStrategy);
+                        pos = copy(buf, pos, ellipsis);
+                        break;
+                    }
+                    pos = copy(buf, pos, s);
+                    rest -= count;
                 }
             }
-            suffix.getChars(0, suffix.length(), buf, pos);
-            pos += suffix.length();
+            pos = copy(buf, pos, suffix);
             return new String(buf, 0, pos);
         };
     }
 
     @Override
-    public Set<java.util.stream.Collector.Characteristics> characteristics() {
+    public Set<Characteristics> characteristics() {
+        int addCount = length(prefix)+length(suffix);
+        if(maxLength <= addCount)
+            return Collections.singleton(Characteristics.UNORDERED);
         return Collections.emptySet();
     }
 
diff --git a/src/main/java/javax/util/streamex/MoreCollectors.java b/src/main/java/javax/util/streamex/MoreCollectors.java
index 204918b..691c30a 100644
--- a/src/main/java/javax/util/streamex/MoreCollectors.java
+++ b/src/main/java/javax/util/streamex/MoreCollectors.java
@@ -1337,74 +1337,6 @@ public final class MoreCollectors {
             downstream.characteristics().toArray(new Characteristics[downstream.characteristics().size()]));
     }
 
-    public static Collector<CharSequence, ?, String> joining(CharSequence delimiter, CharSequence ellipsis, int maxChars,
-            boolean partial) {
-        if (maxChars <= 0)
-            return empty(() -> "");
-        int delimLength = delimiter.length();
-        BiConsumer<ObjIntBox<ArrayList<String>>, CharSequence> accumulator = (acc, str) -> {
-            if (acc.b <= maxChars) {
-                acc.b += str.length() + (acc.a.isEmpty() ? 0 : delimLength);
-                acc.a.add(str.toString());
-            }
-        };
-        BinaryOperator<ObjIntBox<ArrayList<String>>> combiner = (acc1, acc2) -> {
-            int len = acc1.b + acc2.b + ((acc1.a.isEmpty() || acc2.a.isEmpty()) ? 0 : delimLength);
-            if (len <= maxChars) {
-                acc1.b = len;
-                acc1.a.addAll(acc2.a);
-            } else {
-                for (CharSequence s : acc2.a) {
-                    if (acc1.b > maxChars)
-                        break;
-                    accumulator.accept(acc1, s);
-                }
-            }
-            return acc1;
-        };
-        Function<ObjIntBox<ArrayList<String>>, String> finisher = acc -> {
-            char[] result = new char[Math.min(maxChars, acc.b)];
-            char[] delimArray = delimiter.toString().toCharArray();
-            int ellipsisLength = Math.min(ellipsis.length(), maxChars);
-            int pos = 0;
-            boolean overflow = false;
-            int prevPos = 0;
-            for (int i = 0; i < acc.a.size(); i++) {
-                String s = acc.a.get(i);
-                int nextPos;
-                if (i > 0) {
-                    nextPos = pos + delimArray.length;
-                    System.arraycopy(delimArray, 0, result, pos, Math.min(nextPos, maxChars) - pos);
-                    if (nextPos > maxChars) {
-                        overflow = true;
-                        break;
-                    }
-                    pos = nextPos;
-                    if (!partial && pos <= maxChars - ellipsisLength) {
-                        prevPos = pos;
-                    }
-                }
-                nextPos = pos + s.length();
-                s.getChars(0, Math.min(nextPos, maxChars) - pos, result, pos);
-                if (nextPos > maxChars) {
-                    overflow = true;
-                    break;
-                }
-                pos = nextPos;
-            }
-            if (overflow) {
-                if (!partial) {
-                    ellipsis.toString().getChars(0, ellipsisLength, result, prevPos);
-                    return new String(result, 0, prevPos + ellipsisLength);
-                }
-                ellipsis.toString().getChars(0, ellipsisLength, result, maxChars - ellipsisLength);
-            }
-            return new String(result);
-        };
-        return new CancellableCollectorImpl<>(() -> new ObjIntBox<>(new ArrayList<String>(), 0), accumulator, combiner,
-                finisher, acc -> acc.b > maxChars, NO_CHARACTERISTICS);
-    }
-
     /**
      * Returns a {@code Collector} which performs the bitwise-and operation of a
      * integer-valued function applied to the input elements. If no elements are
diff --git a/src/test/java/javax/util/streamex/JoiningTest.java b/src/test/java/javax/util/streamex/JoiningTest.java
index eddbf87..82d31bd 100644
--- a/src/test/java/javax/util/streamex/JoiningTest.java
+++ b/src/test/java/javax/util/streamex/JoiningTest.java
@@ -15,13 +15,18 @@
  */
 package javax.util.streamex;
 
-import static javax.util.streamex.TestHelpers.checkCollector;
+import static javax.util.streamex.TestHelpers.*;
+import static org.junit.Assert.assertEquals;
 
+import java.util.Arrays;
+import java.util.List;
+import java.util.Locale;
 import java.util.function.Supplier;
 import java.util.stream.Collectors;
 import java.util.stream.IntStream;
 import java.util.stream.Stream;
 
+import org.junit.Assert;
 import org.junit.Test;
 
 /**
@@ -31,10 +36,105 @@ public class JoiningTest {
     @Test
     public void testSimple() {
         Supplier<Stream<String>> s = () -> IntStream.range(0, 100).mapToObj(String::valueOf);
-        checkCollector("joiningSimple", s.get().collect(Collectors.joining(", ")), s, Joining.on(", "));
+        checkCollector("joiningSimple", s.get().collect(Collectors.joining(", ")), s, Joining.with(", "));
         checkCollector("joiningWrap", s.get().collect(Collectors.joining(", ", "[", "]")), s,
-            Joining.on(", ").wrap("[", "]"));
-        checkCollector("joiningWrap2", s.get().collect(Collectors.joining(", ", "[(", ")]")), s, Joining.on(", ")
+            Joining.with(", ").wrap("[", "]"));
+        checkCollector("joiningWrap2", s.get().collect(Collectors.joining(", ", "[(", ")]")), s, Joining.with(", ")
                 .wrap("(", ")").wrap("[", "]"));
     }
+
+    @Test
+    public void testCutSimple() {
+        List<String> input = Arrays.asList("one", "two", "three", "four", "five", "six", "seven", "eight", "nine",
+            "ten");
+        assertEquals("", StreamEx.of(input).peek(Assert::fail).collect(Joining.with(", ").maxChars(0).cutAnywhere()));
+        assertEquals("",
+            StreamEx.of(input).parallel().peek(Assert::fail).collect(Joining.with(", ").maxChars(0).cutAnywhere()));
+        String expected = "one, two, three, four, five, six, seven, eight, nine, ten";
+        for (int i = 3; i < expected.length() + 5; i++) {
+            String exp = expected;
+            if (exp.length() > i) {
+                exp = exp.substring(0, i - 3) + "...";
+            }
+            String exp2 = expected;
+            while (exp2.length() > i) {
+                int pos = exp2.lastIndexOf(", ", exp2.endsWith(", ...") ? exp2.length() - 6 : exp2.length());
+                exp2 = pos >= 0 ? exp2.substring(0, pos + 2) + "..." : "...";
+            }
+            for (StreamExSupplier<String> supplier : streamEx(input::stream)) {
+                assertEquals(supplier + "/#" + i, exp,
+                    supplier.get().collect(Joining.with(", ").maxChars(i).cutAnywhere()));
+                assertEquals(supplier + "/#" + i, expected.substring(0, Math.min(i, expected.length())), supplier.get()
+                        .collect(Joining.with(", ").ellipsis("").maxChars(i).cutAnywhere()));
+                assertEquals(supplier + "/#" + i, exp2,
+                    supplier.get().collect(Joining.with(", ").maxChars(i).cutAfterDelimiter()));
+            }
+        }
+
+        byte[] data = { (byte) 0xFF, 0x30, 0x40, 0x50, 0x70, 0x12, (byte) 0xF0 };
+        assertEquals(
+            "FF 30 40 50 ...",
+            IntStreamEx.of(data).mapToObj(b -> String.format(Locale.ENGLISH, "%02X", b & 0xFF))
+                    .collect(Joining.with(" ").maxChars(15).cutAfterDelimiter()));
+    }
+
+    @Test
+    public void testCuts() {
+        List<String> input = Arrays.asList("one two", "three four", "five", "six seven");
+
+        checkShortCircuitCollector("cutBefore", "one two, three four...", 4, input::stream, Joining.with(", ")
+                .maxChars(25).cutBeforeDelimiter());
+        checkShortCircuitCollector("cutBefore", "one two...", 2, input::stream, Joining.with(", ").maxChars(10)
+                .cutBeforeDelimiter());
+        checkShortCircuitCollector("cutBefore", "...", 2, input::stream, Joining.with(", ").maxChars(9)
+                .cutBeforeDelimiter());
+
+        checkShortCircuitCollector("cutAfter", "one two, three four, ...", 4, input::stream, Joining.with(", ")
+                .maxChars(25).cutAfterDelimiter());
+        checkShortCircuitCollector("cutAfter", "one two, ...", 2, input::stream, Joining.with(", ").maxChars(12)
+                .cutAfterDelimiter());
+        checkShortCircuitCollector("cutAfter", "...", 2, input::stream, Joining.with(", ").maxChars(11)
+                .cutAfterDelimiter());
+
+        checkShortCircuitCollector("cutWord", "one two, three four, ...", 4, input::stream, Joining.with(", ")
+                .maxChars(25).cutAfterWord());
+        checkShortCircuitCollector("cutWord", "one two, ...", 2, input::stream, Joining.with(", ").maxChars(12)
+                .cutAfterWord());
+        checkShortCircuitCollector("cutWord", "one two,...", 2, input::stream, Joining.with(", ").maxChars(11)
+                .cutAfterWord());
+        checkShortCircuitCollector("cutWord", "one two...", 2, input::stream, Joining.with(", ").maxChars(10)
+                .cutAfterWord());
+        checkShortCircuitCollector("cutWord", "one ...", 2, input::stream, Joining.with(", ").maxChars(9)
+                .cutAfterWord());
+        checkShortCircuitCollector("cutWord", "one...", 1, input::stream, Joining.with(", ").maxChars(6).cutAfterWord());
+
+        checkShortCircuitCollector("cutCodePoint", "one two, three four, f...", 4, input::stream, Joining.with(", ")
+                .maxChars(25));
+        checkShortCircuitCollector("cutCodePoint", "one two, ...", 2, input::stream, Joining.with(", ").maxChars(12));
+        checkShortCircuitCollector("cutCodePoint", "one two,...", 2, input::stream, Joining.with(", ").maxChars(11));
+        checkShortCircuitCollector("cutCodePoint", "one two...", 2, input::stream, Joining.with(", ").maxChars(10));
+        checkShortCircuitCollector("cutCodePoint", "one tw...", 2, input::stream, Joining.with(", ").maxChars(9));
+        checkShortCircuitCollector("cutCodePoint", "one...", 1, input::stream, Joining.with(", ").maxChars(6));
+    }
+
+    @Test
+    public void testPrefixSuffix() {
+        List<String> input = Arrays.asList("one two", "three four", "five", "six seven");
+        checkShortCircuitCollector("cutWord", "[one two, three four,...]", 3, input::stream, Joining.with(", ")
+                .wrap("[", "]").maxChars(25).cutAfterWord());
+        checkShortCircuitCollector("cutWord", "[one two...]", 2, input::stream, Joining.with(", ").maxChars(12)
+            .wrap("[", "]").cutAfterWord());
+        checkShortCircuitCollector("cutWord", "[one ...]", 2, input::stream, Joining.with(", ").maxChars(11)
+            .wrap("[", "]").cutAfterWord());
+        checkShortCircuitCollector("cutWord", "[one ...]", 2, input::stream, Joining.with(", ").maxChars(10)
+            .wrap("[", "]").cutAfterWord());
+        checkShortCircuitCollector("cutWord", "[one...]", 1, input::stream, Joining.with(", ").maxChars(8)
+            .wrap("[", "]").cutAfterWord());
+        checkShortCircuitCollector("cutWord", "[...]", 1, input::stream, Joining.with(", ").maxChars(6).wrap("[", "]").cutAfterWord());
+        checkShortCircuitCollector("cutWord", "[..]", 1, input::stream, Joining.with(", ").maxChars(4).wrap("[", "]").cutAfterWord());
+        checkShortCircuitCollector("cutWord", "[.]", 1, input::stream, Joining.with(", ").maxChars(3).wrap("[", "]").cutAfterWord());
+        checkShortCircuitCollector("cutWord", "[]", 0, input::stream, Joining.with(", ").maxChars(2).wrap("[", "]").cutAfterWord());
+        checkShortCircuitCollector("cutWord", "[", 0, input::stream, Joining.with(", ").maxChars(1).wrap("[", "]").cutAfterWord());
+        checkShortCircuitCollector("cutWord", "", 0, input::stream, Joining.with(", ").maxChars(0).wrap("[", "]").cutAfterWord());
+    }
 }
diff --git a/src/test/java/javax/util/streamex/MoreCollectorsTest.java b/src/test/java/javax/util/streamex/MoreCollectorsTest.java
index 836075f..5ab97e1 100644
--- a/src/test/java/javax/util/streamex/MoreCollectorsTest.java
+++ b/src/test/java/javax/util/streamex/MoreCollectorsTest.java
@@ -30,7 +30,6 @@ import java.util.EnumMap;
 import java.util.EnumSet;
 import java.util.HashMap;
 import java.util.LinkedHashMap;
-import java.util.Locale;
 import java.util.List;
 import java.util.Map;
 import java.util.OptionalInt;
@@ -52,7 +51,6 @@ import java.util.stream.Collector.Characteristics;
 
 import javax.util.streamex.StreamExInternals.BooleanMap;
 
-import org.junit.Assert;
 import org.junit.Test;
 
 public class MoreCollectorsTest {
@@ -324,7 +322,7 @@ public class MoreCollectorsTest {
 
         Collector<Entry<String, String>, ?, Map<String, String>> groupingByJoin = MoreCollectors.groupingBy(
             Entry::getValue, StreamEx.of("Girl", "Boy").toSet(),
-            MoreCollectors.mapping(Entry::getKey, MoreCollectors.joining(", ", "...", 16, false)));
+            MoreCollectors.mapping(Entry::getKey, Joining.with(", ").maxChars(16).cutAfterDelimiter()));
         counter.set(0);
         Map<String, String> mapJoin = EntryStream.of(name2sex).peek(c -> counter.incrementAndGet()).collect(groupingByJoin);
         assertEquals("Mary, Lucie, ...", mapJoin.get("Girl"));
@@ -398,41 +396,6 @@ public class MoreCollectorsTest {
         }
     }
 
-    @Test
-    public void testJoining() {
-        List<String> input = Arrays.asList("one", "two", "three", "four", "five", "six", "seven", "eight", "nine",
-            "ten");
-        assertEquals("", StreamEx.of(input).peek(Assert::fail).collect(MoreCollectors.joining(", ", "...", 0, true)));
-        assertEquals("",
-            StreamEx.of(input).parallel().peek(Assert::fail).collect(MoreCollectors.joining(", ", "...", 0, true)));
-        String expected = "one, two, three, four, five, six, seven, eight, nine, ten";
-        for (int i = 3; i < expected.length() + 5; i++) {
-            String exp = expected;
-            if (exp.length() > i) {
-                exp = exp.substring(0, i - 3) + "...";
-            }
-            String exp2 = expected;
-            while (exp2.length() > i) {
-                int pos = exp2.lastIndexOf(", ", exp2.endsWith(", ...") ? exp2.length() - 6 : exp2.length());
-                exp2 = pos >= 0 ? exp2.substring(0, pos + 2) + "..." : "...";
-            }
-            for (StreamExSupplier<String> supplier : streamEx(input::stream)) {
-                assertEquals(supplier + "/#" + i, exp,
-                    supplier.get().collect(MoreCollectors.joining(", ", "...", i, true)));
-                assertEquals(supplier + "/#" + i, expected.substring(0, Math.min(i, expected.length())), supplier.get()
-                        .collect(MoreCollectors.joining(", ", "", i, true)));
-                assertEquals(supplier + "/#" + i, exp2,
-                    supplier.get().collect(MoreCollectors.joining(", ", "...", i, false)));
-            }
-        }
-
-        byte[] data = { (byte) 0xFF, 0x30, 0x40, 0x50, 0x70, 0x12, (byte) 0xF0 };
-        assertEquals(
-            "FF 30 40 50 ...",
-            IntStreamEx.of(data).mapToObj(b -> String.format(Locale.ENGLISH, "%02X", b & 0xFF))
-                    .collect(MoreCollectors.joining(" ", "...", 15, false)));
-    }
-
     @Test
     public void testAndInt() {
         List<Integer> ints = Arrays.asList(0b1100, 0b0110, 0b101110, 0b11110011);
