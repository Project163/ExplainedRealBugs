diff --git a/src/main/java/one/util/streamex/EmitterSpliterator.java b/src/main/java/one/util/streamex/EmitterSpliterator.java
new file mode 100644
index 0000000..ae63968
--- /dev/null
+++ b/src/main/java/one/util/streamex/EmitterSpliterator.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright 2015, 2016 Tagir Valeev
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package one.util.streamex;
+
+import java.util.Spliterator;
+import java.util.Spliterators;
+import java.util.function.Consumer;
+import java.util.stream.Stream;
+import java.util.stream.Stream.Builder;
+
+/* package */final class EmitterSpliterator<T> extends Spliterators.AbstractSpliterator<T> implements Consumer<T> {
+    StreamEx.Emitter<T> e;
+    Spliterator<T> buf;
+    boolean hasValue;
+    Consumer<? super T> action;
+    Builder<T> builder;
+
+    EmitterSpliterator(StreamEx.Emitter<T> e) {
+        super(Long.MAX_VALUE, Spliterator.ORDERED | Spliterator.IMMUTABLE);
+        this.e = e;
+    }
+
+    @Override
+    public boolean tryAdvance(Consumer<? super T> action) {
+        if (buf != null) {
+            if (buf.tryAdvance(action))
+                return true;
+            buf = null;
+        }
+        hasValue = false;
+        this.action = action;
+        while (!hasValue) {
+            e = e.next(this);
+        }
+        this.action = null;
+        if (builder != null) {
+            buf = builder.build().spliterator();
+            builder = null;
+        }
+        return hasValue;
+    }
+
+    @Override
+    public void forEachRemaining(Consumer<? super T> action) {
+        if (buf != null) {
+            buf.forEachRemaining(action);
+            buf = null;
+        }
+        StreamEx.Emitter<T> e = this.e;
+        this.e = null;
+        while (e != null)
+            e = e.next(action);
+    }
+
+    @Override
+    public void accept(T t) {
+        if (hasValue) {
+            if (builder == null) {
+                builder = Stream.builder();
+            }
+            builder.accept(t);
+        } else {
+            action.accept(t);
+            hasValue = true;
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/one/util/streamex/StreamEx.java b/src/main/java/one/util/streamex/StreamEx.java
index 3498bbd..453e211 100644
--- a/src/main/java/one/util/streamex/StreamEx.java
+++ b/src/main/java/one/util/streamex/StreamEx.java
@@ -2643,46 +2643,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
          * @return the new spliterator
          */
         default Spliterator<T> spliterator() {
-            return new Spliterators.AbstractSpliterator<T>(Long.MAX_VALUE, Spliterator.ORDERED | Spliterator.IMMUTABLE) {
-                Emitter<T> e = Emitter.this;
-                Spliterator<T> buf;
-
-                @Override
-                public boolean tryAdvance(Consumer<? super T> action) {
-                    if (!fillBuf())
-                        return false;
-                    while (!buf.tryAdvance(action)) {
-                        buf = null;
-                        if (!fillBuf())
-                            return false;
-                    }
-                    return true;
-                }
-
-                @Override
-                public void forEachRemaining(Consumer<? super T> action) {
-                    if (buf != null) {
-                        buf.forEachRemaining(action);
-                        buf = null;
-                    }
-                    Emitter<T> e = this.e;
-                    this.e = null;
-                    while (e != null)
-                        e = e.next(action);
-                }
-
-                private boolean fillBuf() {
-                    while (buf == null) {
-                        if (e == null)
-                            return false;
-                        Builder<T> b = Stream.builder();
-                        Emitter<T> next = e.next(b);
-                        buf = b.build().spliterator();
-                        e = next;
-                    }
-                    return true;
-                }
-            };
+            return new EmitterSpliterator<>(this);
         }
 
         /**
diff --git a/src/test/java/one/util/streamex/StreamExEmitterTest.java b/src/test/java/one/util/streamex/StreamExEmitterTest.java
index 2efef99..1c7a93c 100644
--- a/src/test/java/one/util/streamex/StreamExEmitterTest.java
+++ b/src/test/java/one/util/streamex/StreamExEmitterTest.java
@@ -64,7 +64,7 @@ public class StreamExEmitterTest {
             return start == 1 ? null : collatz(start % 2 == 0 ? start / 2 : start * 3 + 1);
         };
     }
-    
+
     // Reads numbers from scanner stopping when non-number is encountered
     public static Emitter<Integer> scannerInts(Scanner sc) {
         return sc.hasNextInt() ? action -> {
@@ -77,7 +77,7 @@ public class StreamExEmitterTest {
     public static StreamEx<BigInteger> fibonacci() {
         return fibonacci(BigInteger.ONE, BigInteger.ZERO).stream();
     }
-    
+
     private static Emitter<BigInteger> fibonacci(BigInteger first, BigInteger second) {
         return action -> {
             BigInteger next = first.add(second);
@@ -94,24 +94,24 @@ public class StreamExEmitterTest {
     // Adapt iterator to emitter
     public static <T> Emitter<T> fromIterator(Iterator<T> iter) {
         return action -> {
-            if(!iter.hasNext()) 
+            if (!iter.hasNext())
                 return null;
             action.accept(iter.next());
             return fromIterator(iter);
         };
     }
 
-    // Perform scanLeft on the iterator 
+    // Perform scanLeft on the iterator
     public static <T> Emitter<T> scanLeft(Iterator<T> iter, T initial, BinaryOperator<T> reducer) {
         return action -> {
-            if(!iter.hasNext()) 
+            if (!iter.hasNext())
                 return null;
             T sum = reducer.apply(initial, iter.next());
             action.accept(sum);
             return scanLeft(iter, sum, reducer);
         };
     }
-    
+
     // Stream of all matches of given matcher
     public static Emitter<String> matches(Matcher m) {
         return m.find() ? action -> {
@@ -119,7 +119,15 @@ public class StreamExEmitterTest {
             return matches(m);
         } : null;
     }
-    
+
+    public static Emitter<Integer> flatTest(int start) {
+        return action -> {
+            for (int i = 0; i < start; i++)
+                action.accept(start);
+            return start == 0 ? null : flatTest(start - 1);
+        };
+    }
+
     @Test
     public void testEmitter() {
         assertEquals(asList(17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1), collatz(17).stream().toList());
@@ -129,21 +137,26 @@ public class StreamExEmitterTest {
         Scanner sc = new Scanner("1 2 3 4 test");
         assertEquals(asList(1, 2, 3, 4), scannerInts(sc).stream().toList());
         assertEquals("test", sc.next());
-        
+
         // Extracting to variables is necessary to work-around javac <8u40 bug
         String expected = "354224848179261915075";
         String actual = fibonacci().skip(99).findFirst().get().toString();
         assertEquals(expected, actual);
         assertEquals(asList(1, 1, 2, 3, 5, 8, 13, 21, 34, 55), fibonacci().map(BigInteger::intValueExact).limit(10)
                 .toList());
-        
-        assertEquals(asList("foo", "bar", "baz"), fromSpliterator(asList("foo", "bar", "baz").spliterator()).stream().toList());
-        assertEquals(asList("foo", "bar", "baz"), fromIterator(asList("foo", "bar", "baz").iterator()).stream().toList());
-        
+
+        assertEquals(asList("foo", "bar", "baz"), fromSpliterator(asList("foo", "bar", "baz").spliterator()).stream()
+                .toList());
+        assertEquals(asList("foo", "bar", "baz"), fromIterator(asList("foo", "bar", "baz").iterator()).stream()
+                .toList());
+
         assertEquals(asList("123", "543", "111", "5432"), matches(Pattern.compile("\\d+").matcher("123 543,111:5432"))
                 .stream().toList());
+
+        assertEquals(asList("aa", "aabbb", "aabbbc"), scanLeft(asList("aa", "bbb", "c").iterator(), "", String::concat)
+                .stream().toList());
         
-        assertEquals(asList("aa", "aabbb", "aabbbc"), 
-            scanLeft(asList("aa", "bbb", "c").iterator(), "", String::concat).stream().toList());
+        assertEquals(asList(4, 4, 4, 4, 3, 3, 3, 2, 2, 1), flatTest(4).stream().toList());
+        assertEquals(asList(4, 4, 4, 4, 3, 3, 3, 2, 2), flatTest(4).stream().limit(9).toList());
     }
 }
