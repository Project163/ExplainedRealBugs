diff --git a/src/main/java/one/util/streamex/AbstractStreamEx.java b/src/main/java/one/util/streamex/AbstractStreamEx.java
index e553f6e..f23326d 100644
--- a/src/main/java/one/util/streamex/AbstractStreamEx.java
+++ b/src/main/java/one/util/streamex/AbstractStreamEx.java
@@ -52,7 +52,7 @@ import java.util.stream.Collector.Characteristics;
 import static one.util.streamex.StreamExInternals.*;
 
 /* package */abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> extends
-        BaseStreamEx<T, Stream<T>, Spliterator<T>> implements Stream<T>, Iterable<T> {
+        BaseStreamEx<T, Stream<T>, Spliterator<T>, S> implements Stream<T>, Iterable<T> {
     private static final class TDOfRef<T> extends AbstractSpliterator<T> implements Consumer<T> {
         private final Predicate<? super T> predicate;
         private final boolean drop;
diff --git a/src/main/java/one/util/streamex/BaseStreamEx.java b/src/main/java/one/util/streamex/BaseStreamEx.java
index 0ddab46..1cfe689 100644
--- a/src/main/java/one/util/streamex/BaseStreamEx.java
+++ b/src/main/java/one/util/streamex/BaseStreamEx.java
@@ -17,19 +17,20 @@ package one.util.streamex;
 
 import java.util.Spliterator;
 import java.util.concurrent.ForkJoinPool;
+import java.util.function.Function;
 import java.util.stream.BaseStream;
 
 /**
  * @author Tagir Valeev
  */
-/* package */abstract class BaseStreamEx<T, S extends BaseStream<T, S>, SPLTR extends Spliterator<T>>
+/* package */abstract class BaseStreamEx<T, S extends BaseStream<T, S>, SPLTR extends Spliterator<T>, B extends BaseStreamEx<T, S, SPLTR, B>>
         implements BaseStream<T, S> {
     static final String CONSUMED_MESSAGE = "Stream is already consumed";
 
     private S stream;
     SPLTR spliterator;
     StreamContext context;
-    
+
     BaseStreamEx(S stream, StreamContext context) {
         this.stream = stream;
         this.context = context;
@@ -39,13 +40,13 @@ import java.util.stream.BaseStream;
         this.spliterator = spliterator;
         this.context = context;
     }
-    
+
     abstract S createStream();
 
     final S stream() {
-        if(stream != null)
+        if (stream != null)
             return stream;
-        if(spliterator == null)
+        if (spliterator == null)
             throw new IllegalStateException(CONSUMED_MESSAGE);
         stream = createStream();
         spliterator = null;
@@ -55,9 +56,9 @@ import java.util.stream.BaseStream;
     @SuppressWarnings("unchecked")
     @Override
     public SPLTR spliterator() {
-        if(stream != null)
+        if (stream != null)
             return (SPLTR) stream.spliterator();
-        if(spliterator != null) {
+        if (spliterator != null) {
             SPLTR s = spliterator;
             spliterator = null;
             return s;
@@ -74,7 +75,7 @@ import java.util.stream.BaseStream;
     @Override
     public S sequential() {
         context = context.sequential();
-        if(stream != null)
+        if (stream != null)
             stream = stream.sequential();
         return (S) this;
     }
@@ -91,9 +92,9 @@ import java.util.stream.BaseStream;
     @Override
     public S parallel() {
         context = context.parallel();
-        if(stream != null)
+        if (stream != null)
             stream = stream.parallel();
-        return (S)this;
+        return (S) this;
     }
 
     /**
@@ -139,4 +140,26 @@ import java.util.stream.BaseStream;
     public void close() {
         context.close();
     }
+
+    /**
+     * Applies the supplied function to this stream and returns the result of
+     * the function.
+     * 
+     * <p>
+     * This method can be used to add more functionality in the fluent style.
+     * For example, consider user-defined static method
+     * {@code batches(stream, n)} which breaks the stream into batches of given
+     * length. Normally you would write
+     * {@code batches(StreamEx.of(input).map(...), 10).filter(...)}. Using the
+     * {@code chain()} method you can write in more fluent manner:
+     * {@code StreamEx.of(input).map(...).chain(s -> batches(s, 10)).filter(...)}.
+     * 
+     * @param mapper function to invoke.
+     * @return the result of the function invocation.
+     * @since 0.5.4
+     */
+    @SuppressWarnings("unchecked")
+    public <U> U chain(Function<? super B, U> mapper) {
+        return mapper.apply((B) this);
+    }
 }
diff --git a/src/main/java/one/util/streamex/DoubleStreamEx.java b/src/main/java/one/util/streamex/DoubleStreamEx.java
index bcdfe0e..01d7324 100644
--- a/src/main/java/one/util/streamex/DoubleStreamEx.java
+++ b/src/main/java/one/util/streamex/DoubleStreamEx.java
@@ -57,7 +57,8 @@ import static one.util.streamex.StreamExInternals.*;
  * 
  * @author Tagir Valeev
  */
-public class DoubleStreamEx extends BaseStreamEx<Double, DoubleStream, Spliterator.OfDouble> implements DoubleStream {
+public class DoubleStreamEx extends BaseStreamEx<Double, DoubleStream, Spliterator.OfDouble, DoubleStreamEx> implements
+        DoubleStream {
     private static final class TDOfDouble extends AbstractDoubleSpliterator implements DoubleConsumer {
         private final DoublePredicate predicate;
         private final boolean drop;
diff --git a/src/main/java/one/util/streamex/IntStreamEx.java b/src/main/java/one/util/streamex/IntStreamEx.java
index fb2efe7..6eaff92 100644
--- a/src/main/java/one/util/streamex/IntStreamEx.java
+++ b/src/main/java/one/util/streamex/IntStreamEx.java
@@ -63,7 +63,7 @@ import static one.util.streamex.StreamExInternals.*;
  * 
  * @author Tagir Valeev
  */
-public class IntStreamEx extends BaseStreamEx<Integer, IntStream, Spliterator.OfInt> implements IntStream {
+public class IntStreamEx extends BaseStreamEx<Integer, IntStream, Spliterator.OfInt, IntStreamEx> implements IntStream {
     private static final class TDOfInt extends AbstractIntSpliterator implements IntConsumer {
         private final IntPredicate predicate;
         private final boolean drop;
diff --git a/src/main/java/one/util/streamex/LongStreamEx.java b/src/main/java/one/util/streamex/LongStreamEx.java
index 80db89f..b08052f 100644
--- a/src/main/java/one/util/streamex/LongStreamEx.java
+++ b/src/main/java/one/util/streamex/LongStreamEx.java
@@ -57,7 +57,8 @@ import static one.util.streamex.StreamExInternals.*;
  * 
  * @author Tagir Valeev
  */
-public class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterator.OfLong> implements LongStream {
+public class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterator.OfLong, LongStreamEx> implements
+        LongStream {
     private static final class TDOfLong extends AbstractLongSpliterator implements LongConsumer {
         private final LongPredicate predicate;
         private final boolean drop;
@@ -129,8 +130,8 @@ public class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterator.OfL
 
     final LongStreamEx callWhile(LongPredicate predicate, int methodId) {
         try {
-            return new LongStreamEx(
-                (LongStream) JDK9_METHODS[IDX_LONG_STREAM][methodId].invokeExact(stream(), predicate), context);
+            return new LongStreamEx((LongStream) JDK9_METHODS[IDX_LONG_STREAM][methodId].invokeExact(stream(),
+                predicate), context);
         } catch (Error | RuntimeException e) {
             throw e;
         } catch (Throwable e) {
@@ -586,8 +587,8 @@ public class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterator.OfL
      * @since 0.3.2
      */
     public LongStreamEx skipOrdered(long n) {
-        Spliterator.OfLong spliterator = (isParallel() ? StreamSupport.longStream(spliterator(), false)
-                : stream()).skip(n).spliterator();
+        Spliterator.OfLong spliterator = (isParallel() ? StreamSupport.longStream(spliterator(), false) : stream())
+                .skip(n).spliterator();
         return delegate(spliterator);
     }
 
@@ -596,7 +597,7 @@ public class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterator.OfL
         if (spliterator != null && !isParallel()) {
             spliterator().forEachRemaining(action);
         } else {
-            if(context.fjp != null)
+            if (context.fjp != null)
                 context.terminate(() -> {
                     stream().forEach(action);
                     return null;
@@ -612,7 +613,7 @@ public class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterator.OfL
         if (spliterator != null && !isParallel()) {
             spliterator().forEachRemaining(action);
         } else {
-            if(context.fjp != null)
+            if (context.fjp != null)
                 context.terminate(() -> {
                     stream().forEachOrdered(action);
                     return null;
@@ -625,21 +626,21 @@ public class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterator.OfL
 
     @Override
     public long[] toArray() {
-        if(context.fjp != null)
+        if (context.fjp != null)
             return context.terminate(stream()::toArray);
         return stream().toArray();
     }
 
     @Override
     public long reduce(long identity, LongBinaryOperator op) {
-        if(context.fjp != null)
+        if (context.fjp != null)
             return context.terminate(() -> stream().reduce(identity, op));
         return stream().reduce(identity, op);
     }
 
     @Override
     public OptionalLong reduce(LongBinaryOperator op) {
-        if(context.fjp != null)
+        if (context.fjp != null)
             return context.terminate(op, stream()::reduce);
         return stream().reduce(op);
     }
@@ -814,7 +815,7 @@ public class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterator.OfL
      */
     @Override
     public <R> R collect(Supplier<R> supplier, ObjLongConsumer<R> accumulator, BiConsumer<R, R> combiner) {
-        if(context.fjp != null)
+        if (context.fjp != null)
             return context.terminate(() -> stream().collect(supplier, accumulator, combiner));
         return stream().collect(supplier, accumulator, combiner);
     }
@@ -1112,14 +1113,14 @@ public class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterator.OfL
 
     @Override
     public long count() {
-        if(context.fjp != null)
+        if (context.fjp != null)
             return context.terminate(stream()::count);
         return stream().count();
     }
 
     @Override
     public OptionalDouble average() {
-        if(context.fjp != null)
+        if (context.fjp != null)
             return context.terminate(stream()::average);
         return stream().average();
     }
@@ -1131,14 +1132,14 @@ public class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterator.OfL
 
     @Override
     public boolean anyMatch(LongPredicate predicate) {
-        if(context.fjp != null)
+        if (context.fjp != null)
             return context.terminate(predicate, stream()::anyMatch);
         return stream().anyMatch(predicate);
     }
 
     @Override
     public boolean allMatch(LongPredicate predicate) {
-        if(context.fjp != null)
+        if (context.fjp != null)
             return context.terminate(predicate, stream()::allMatch);
         return stream().allMatch(predicate);
     }
@@ -1150,7 +1151,7 @@ public class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterator.OfL
 
     @Override
     public OptionalLong findFirst() {
-        if(context.fjp != null)
+        if (context.fjp != null)
             return context.terminate(stream()::findFirst);
         return stream().findFirst();
     }
@@ -1178,7 +1179,7 @@ public class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterator.OfL
 
     @Override
     public OptionalLong findAny() {
-        if(context.fjp != null)
+        if (context.fjp != null)
             return context.terminate(stream()::findAny);
         return stream().findAny();
     }
diff --git a/src/main/java/one/util/streamex/StreamContext.java b/src/main/java/one/util/streamex/StreamContext.java
index f64c0ba..afa6137 100644
--- a/src/main/java/one/util/streamex/StreamContext.java
+++ b/src/main/java/one/util/streamex/StreamContext.java
@@ -132,7 +132,7 @@ import static one.util.streamex.StreamExInternals.*;
 
     static StreamContext of(BaseStream<?, ?> stream) {
         if (stream instanceof BaseStreamEx)
-            return ((BaseStreamEx<?, ?, ?>) stream).context;
+            return ((BaseStreamEx<?, ?, ?, ?>) stream).context;
         if (mustCloseStream(stream))
             return new StreamContext(stream.isParallel()).onClose(stream::close);
         return stream.isParallel() ? PARALLEL : SEQUENTIAL;
diff --git a/src/test/java/one/util/streamex/StreamExHeadTailTest.java b/src/test/java/one/util/streamex/StreamExHeadTailTest.java
index d0d76ee..c80e3e0 100644
--- a/src/test/java/one/util/streamex/StreamExHeadTailTest.java
+++ b/src/test/java/one/util/streamex/StreamExHeadTailTest.java
@@ -203,6 +203,10 @@ public class StreamExHeadTailTest {
         return input.headTail((head, tail) -> scanLeft(tail.mapFirst(cur -> operator.apply(head, cur)), operator)
                 .prepend(head));
     }
+    
+    static <T> UnaryOperator<StreamEx<T>> scanLeft(BinaryOperator<T> operator) {
+        return stream -> scanLeft(stream, operator);
+    }
 
     // takeWhileClosed: takeWhile+first element violating the predicate (TSO)
     static <T> StreamEx<T> takeWhileClosed(StreamEx<T> input, Predicate<T> predicate) {
@@ -323,8 +327,8 @@ public class StreamExHeadTailTest {
     @Test
     public void testHeadTailRecursive() {
         streamEx(() -> StreamEx.iterate(2, x -> x + 1), s -> assertEquals(asList(2, 3, 5, 7, 11, 13, 17, 19, 23, 29,
-            31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97), sieve(s.get()).takeWhile(x -> x < 100)
-                .toList()));
+            31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97), s.get().chain(str -> sieve(str)).takeWhile(
+            x -> x < 100).toList()));
 
         emptyStreamEx(Integer.class, s -> {
             assertEquals(0L, s.get().headTail((first, head) -> {
@@ -343,13 +347,13 @@ public class StreamExHeadTailTest {
         streamEx(() -> StreamEx.of(1, 2), s -> assertEquals(0, s.get().headTail((head, stream) -> null).count()));
 
         streamEx(() -> StreamEx.iterate(1, x -> x + 1), s -> assertEquals(asList(1, 3, 6, 10, 15, 21, 28, 36, 45, 55,
-            66, 78, 91), scanLeft(s.get(), Integer::sum).takeWhile(x -> x < 100).toList()));
+            66, 78, 91), s.get().chain(scanLeft(Integer::sum)).takeWhile(x -> x < 100).toList()));
 
         streamEx(() -> StreamEx.iterate(1, x -> x + 1), s -> assertEquals(IntStreamEx.range(1, 100).boxed().toList(),
             takeWhile(s.get(), x -> x < 100).toList()));
 
         streamEx(() -> StreamEx.iterate(1, x -> x + 1), s -> assertEquals(IntStreamEx.rangeClosed(1, 100).boxed()
-                .toList(), takeWhileClosed(s.get(), x -> x < 100).toList()));
+                .toList(), s.get().chain(str -> takeWhileClosed(str, x -> x < 100)).toList()));
 
         streamEx(() -> IntStreamEx.range(1000).boxed(), s -> assertEquals(IntStreamEx.range(0, 1000, 20).boxed()
                 .toList(), every(s.get(), 20).toList()));
@@ -357,8 +361,8 @@ public class StreamExHeadTailTest {
         // http://stackoverflow.com/q/34395943/4856258
         int[] input = { 1, 2, 3, -1, 3, -10, 9, 100, 1, 100, 0 };
         AtomicInteger counter = new AtomicInteger();
-        assertEquals(5, scanLeft(IntStreamEx.of(input).peek(x -> counter.incrementAndGet()).boxed(), Integer::sum)
-                .indexOf(x -> x < 0).getAsLong());
+        assertEquals(5, IntStreamEx.of(input).peek(x -> counter.incrementAndGet()).boxed()
+                .chain(scanLeft(Integer::sum)).indexOf(x -> x < 0).getAsLong());
         assertEquals(6, counter.get());
 
         assertEquals(4, (int) firstMatchingOrFirst(StreamEx.of(1, 2, 3, 4, 5), x -> x > 3));
