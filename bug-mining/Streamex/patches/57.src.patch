diff --git a/src/main/java/one/util/streamex/MoreCollectors.java b/src/main/java/one/util/streamex/MoreCollectors.java
index 1c527ae..40752ee 100644
--- a/src/main/java/one/util/streamex/MoreCollectors.java
+++ b/src/main/java/one/util/streamex/MoreCollectors.java
@@ -1602,4 +1602,46 @@ public final class MoreCollectors {
             BiPredicate<? super E, ? super E> isPartOf) {
         return collapsingNested(Comparator.naturalOrder(), isPartOf);
     }
+
+    /**
+     * Returns a collector which collects input elements into {@code List}
+     * replacing the series of adjacent elements which satisfy given
+     * {@code BiPredicate} with the leftmost element.
+     * 
+     * <p>
+     * This operation is similar to
+     * {@code streamEx.collapse(mergeable).toList()}. The important difference
+     * is that in this method {@code BiPredicate} accepts not the adjacent
+     * stream elements, but the leftmost element of the series and the current
+     * element. This collector is useful to remove elements which are considered
+     * to be the part of some parent element assuming the input is pre-sorted so
+     * all child elements immediately follow their parent.
+     * 
+     * @param <T>
+     *            type of the input elements.
+     * @param mergeable
+     *            a {@code BiPredicate} which takes the leftmost element of the
+     *            series and the current element and returns true if the current
+     *            element belongs to the same series.
+     * @return a collector which collects input element into {@code List}
+     *         leaving only leftmost element of every series.
+     * @see StreamEx#collapse(BiPredicate)
+     * @since 0.5.1
+     */
+    public static <T> Collector<T, ?, List<T>> merging(BiPredicate<? super T, ? super T> mergeable) {
+        return Collector.of(ArrayList::new, (acc, t) -> {
+            if (acc.isEmpty() || !mergeable.test(acc.get(acc.size() - 1), t))
+                acc.add(t);
+        }, (acc1, acc2) -> {
+            if (acc1.isEmpty())
+                return acc2;
+            int i = 0, l = acc2.size();
+            T last = acc1.get(acc1.size() - 1);
+            while (i < l && mergeable.test(last, acc2.get(i)))
+                i++;
+            if (i < l)
+                acc1.addAll(acc2.subList(i, l));
+            return acc1;
+        });
+    }
 }
diff --git a/src/test/java/one/util/streamex/MoreCollectorsTest.java b/src/test/java/one/util/streamex/MoreCollectorsTest.java
index 4fc948a..af5c192 100644
--- a/src/test/java/one/util/streamex/MoreCollectorsTest.java
+++ b/src/test/java/one/util/streamex/MoreCollectorsTest.java
@@ -639,26 +639,54 @@ public class MoreCollectorsTest {
             checkCollector("#"+i, expected, input::stream, MoreCollectors.collapsingNested(String::startsWith));
         }
         
-        List<String> longInput = StreamEx.generate(() -> IntStreamEx.of(r, r.nextInt(10)+2, 'a', 'h').mapToObj(ch -> (char)ch).joining("/", "", "/"))
+        List<String> longInput = StreamEx.generate(() -> IntStreamEx.of(r, r.nextInt(10)+3, 'a', 'z').mapToObj(ch -> (char)ch).joining("/", "", "/"))
                 .limit(1000).toList();
-        
-        List<String> result = StreamEx.of(longInput).sorted().toList();
-        Iterator<String> it = result.iterator();
+
+        List<String> tmp = StreamEx.of(longInput).sorted().toList();
+        List<String> result = new ArrayList<>();
         String curr, last;
         curr = last = null;
+        Iterator<String> it = tmp.iterator();
         while (it.hasNext()) {
             String oldLast = last;
             last = curr;
             curr = it.next();
             if (last != null && curr.startsWith(last)) {
-                it.remove();
                 curr = last;
                 last = oldLast;
-            }
+            } else result.add(curr);
         }
         for(int i=0; i<10; i++) {
             Collections.shuffle(longInput, r);
             checkCollector("#"+i, result, longInput::stream, MoreCollectors.collapsingNested(String::startsWith));
         }
     }
+    
+    @Test
+    public void testMerging() {
+        List<String> input = Arrays.asList("a/", "a/b/c/", "b/c/", "b/d/", "c/a/", "d/a/b/", "c/a/b/", "c/b/", "b/c/d/");
+        List<String> expected = Arrays.asList("a/", "b/c/", "b/d/", "c/a/", "c/b/", "d/a/b/");
+        checkCollector("merging", expected, () -> input.stream().sorted(), MoreCollectors.merging((a, b) -> b.startsWith(a)));
+        
+        Random r = new Random(1);
+        
+        List<String> longInput = StreamEx.generate(() -> IntStreamEx.of(r, r.nextInt(10)+3, 'a', 'z').mapToObj(ch -> (char)ch).joining("/", "", "/"))
+                .limit(1000).toList();
+
+        List<String> tmp = StreamEx.of(longInput).sorted().toList();
+        List<String> result = new ArrayList<>();
+        String curr, last;
+        curr = last = null;
+        Iterator<String> it = tmp.iterator();
+        while (it.hasNext()) {
+            String oldLast = last;
+            last = curr;
+            curr = it.next();
+            if (last != null && curr.startsWith(last)) {
+                curr = last;
+                last = oldLast;
+            } else result.add(curr);
+        }
+        checkCollector("merginglong", result, () -> longInput.stream().sorted(), MoreCollectors.merging((a, b) -> b.startsWith(a)));
+    }
 }
