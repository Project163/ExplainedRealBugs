diff --git a/pom.xml b/pom.xml
index cf124a8..005accd 100644
--- a/pom.xml
+++ b/pom.xml
@@ -20,7 +20,7 @@
 
   <groupId>one.util</groupId>
   <artifactId>streamex</artifactId>
-  <version>0.8.4</version>
+  <version>0.9.0-SNAPSHOT</version>
   <packaging>jar</packaging>
 
   <name>StreamEx</name>
@@ -48,6 +48,12 @@
   </licenses>
 
   <dependencies>
+    <dependency>
+      <groupId>org.jspecify</groupId>
+      <artifactId>jspecify</artifactId>
+      <version>1.0.0</version>
+      <optional>true</optional>
+    </dependency>
     <dependency>
       <groupId>junit</groupId>
       <artifactId>junit</artifactId>
diff --git a/src/main/java/one/util/streamex/AbstractStreamEx.java b/src/main/java/one/util/streamex/AbstractStreamEx.java
index d216f91..aeddccf 100644
--- a/src/main/java/one/util/streamex/AbstractStreamEx.java
+++ b/src/main/java/one/util/streamex/AbstractStreamEx.java
@@ -15,6 +15,11 @@
  */
 package one.util.streamex;
 
+import org.jspecify.annotations.NonNull;
+import org.jspecify.annotations.NullMarked;
+import org.jspecify.annotations.NullUnmarked;
+import org.jspecify.annotations.Nullable;
+
 import java.util.*;
 import java.util.concurrent.ForkJoinPool;
 import java.util.function.*;
@@ -31,7 +36,8 @@ import static one.util.streamex.Internals.*;
  * @param <T> the type of the stream elements
  * @param <S> the type of the stream extending {@code AbstractStreamEx}
  */
-public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> extends
+@NullMarked
+public abstract class AbstractStreamEx<T extends @Nullable Object, S extends AbstractStreamEx<T, S>> extends
         BaseStreamEx<T, Stream<T>, Spliterator<T>, S> implements Stream<T>, Iterable<T> {
     @SuppressWarnings("unchecked")
     AbstractStreamEx(Stream<? extends T> stream, StreamContext context) {
@@ -48,13 +54,14 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
         return StreamSupport.stream(spliterator, context.parallel);
     }
 
-    final <K, V, M extends Map<K, V>> M toMapThrowing(Function<? super T, ? extends K> keyMapper,
+    final <K extends @Nullable Object, V, M extends Map<K, V>> M toMapThrowing(
+            Function<? super T, ? extends K> keyMapper,
             Function<? super T, ? extends V> valMapper, M map) {
         forEach(t -> addToMap(map, keyMapper.apply(t), Objects.requireNonNull(valMapper.apply(t))));
         return map;
     }
 
-    static <K, V, M extends Map<K, V>> void addToMap(M map, K key, V val) {
+    static <K extends @Nullable Object, V, M extends Map<K, V>> void addToMap(M map, K key, V val) {
         V oldVal = map.putIfAbsent(key, val);
         if (oldVal != null) {
             throw new IllegalStateException("Duplicate entry for key '" + key + "' (attempt to merge values '" + oldVal
@@ -62,14 +69,14 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
         }
     }
 
-    <R, A> R rawCollect(Collector<? super T, A, R> collector) {
+    <R extends @Nullable Object, A extends @Nullable Object> R rawCollect(Collector<? super T, A, R> collector) {
         if (context.fjp != null)
             return context.terminate(collector, stream()::collect);
         return stream().collect(collector);
     }
 
     @SuppressWarnings("unchecked")
-    S appendSpliterator(Stream<? extends T> other, Spliterator<? extends T> right) {
+    S appendSpliterator(@Nullable Stream<? extends T> other, Spliterator<? extends T> right) {
         if (right.getExactSizeIfKnown() == 0)
             return (S) this;
         Spliterator<T> left = spliterator();
@@ -83,7 +90,7 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
     }
 
     @SuppressWarnings("unchecked")
-    S prependSpliterator(Stream<? extends T> other, Spliterator<? extends T> left) {
+    S prependSpliterator(@Nullable Stream<? extends T> other, Spliterator<? extends T> left) {
         if (left.getExactSizeIfKnown() == 0)
             return (S) this;
         Spliterator<T> right = spliterator();
@@ -97,7 +104,7 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
     }
 
     @SuppressWarnings("unchecked")
-    S ifEmpty(Stream<? extends T> other, Spliterator<? extends T> right) {
+    S ifEmpty(@Nullable Stream<? extends T> other, Spliterator<? extends T> right) {
         if (right.getExactSizeIfKnown() == 0)
             return (S) this;
         Spliterator<T> left = spliterator();
@@ -121,31 +128,31 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
 
     @SuppressWarnings("unchecked")
     @Override
-    public S sequential() {
+    public @NonNull S sequential() {
         return (S) super.sequential();
     }
 
     @SuppressWarnings("unchecked")
     @Override
-    public S parallel() {
+    public @NonNull S parallel() {
         return (S) super.parallel();
     }
 
     @Override
     @SuppressWarnings("unchecked")
-    public S parallel(ForkJoinPool fjp) {
+    public @NonNull S parallel(ForkJoinPool fjp) {
         return (S) super.parallel(fjp);
     }
 
     @SuppressWarnings("unchecked")
     @Override
-    public S unordered() {
+    public @NonNull S unordered() {
         return (S) super.unordered();
     }
 
     @SuppressWarnings("unchecked")
     @Override
-    public S onClose(Runnable closeHandler) {
+    public @NonNull S onClose(Runnable closeHandler) {
         return (S) super.onClose(closeHandler);
     }
     
@@ -155,12 +162,12 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
      * @see StreamEx#select(Class)
      */
     @Override
-    public S filter(Predicate<? super T> predicate) {
+    public @NonNull S filter(Predicate<? super T> predicate) {
         return supply(stream().filter(predicate));
     }
 
     @Override
-    public <R> StreamEx<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper) {
+    public <R extends @Nullable Object> StreamEx<R> flatMap(Function<? super T, ? extends @Nullable Stream<? extends R>> mapper) {
         return new StreamEx<>(stream().flatMap(mapper), context);
     }
 
@@ -179,7 +186,7 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
      * @param <R> type of the resulting elements
      * @since 0.8.3
      */
-    public <R> StreamEx<R> mapMulti(BiConsumer<? super T, ? super Consumer<R>> mapper) {
+    public <R extends @Nullable Object> StreamEx<R> mapMulti(BiConsumer<? super T, ? super Consumer<R>> mapper) {
         Objects.requireNonNull(mapper);
         return VerSpec.VER_SPEC.callMapMulti(this, mapper);
     }
@@ -242,7 +249,7 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
     }
 
     @Override
-    public <R> StreamEx<R> map(Function<? super T, ? extends R> mapper) {
+    public <R extends @Nullable Object> StreamEx<R> map(Function<? super T, ? extends R> mapper) {
         return new StreamEx<>(stream().map(mapper), context);
     }
 
@@ -262,23 +269,23 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
     }
 
     @Override
-    public IntStreamEx flatMapToInt(Function<? super T, ? extends IntStream> mapper) {
+    public IntStreamEx flatMapToInt(Function<? super T, ? extends @Nullable IntStream> mapper) {
         return new IntStreamEx(stream().flatMapToInt(mapper), context);
     }
 
     @Override
-    public LongStreamEx flatMapToLong(Function<? super T, ? extends LongStream> mapper) {
+    public LongStreamEx flatMapToLong(Function<? super T, ? extends @Nullable LongStream> mapper) {
         return new LongStreamEx(stream().flatMapToLong(mapper), context);
     }
 
     @Override
-    public DoubleStreamEx flatMapToDouble(Function<? super T, ? extends DoubleStream> mapper) {
+    public DoubleStreamEx flatMapToDouble(Function<? super T, ? extends @Nullable DoubleStream> mapper) {
         return new DoubleStreamEx(stream().flatMapToDouble(mapper), context);
     }
 
     /**
      * Returns a new stream containing all the elements of the original stream interspersed with
-     * given delimiter.
+     * a given delimiter.
      *
      * <p>
      * For example, {@code StreamEx.of("a", "b", "c").intersperse("x")} will yield a stream containing
@@ -291,12 +298,12 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
      * @return the new stream
      * @since 0.6.6
      */
-    public S intersperse(T delimiter) {
+    public @NonNull S intersperse(T delimiter) {
         return supply(stream().flatMap(s -> StreamEx.of(delimiter, s)).skip(1));
     }
 
     @Override
-    public S distinct() {
+    public @NonNull S distinct() {
         return supply(stream().distinct());
     }
 
@@ -319,7 +326,7 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
      * @return the new stream
      * @since 0.3.8
      */
-    public S distinct(Function<? super T, ?> keyExtractor) {
+    public @NonNull S distinct(Function<? super T, ? extends @Nullable Object> keyExtractor) {
         return supply(stream().map(t -> new PairBox<>(t, keyExtractor.apply(t))).distinct().map(box -> box.a));
     }
 
@@ -329,7 +336,7 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
      * of times in this stream.
      *
      * <p>
-     * This operation is not guaranteed to be stable: any of equal elements can
+     * This operation is not guaranteed to be stable: any of the equal elements can
      * be selected for the output. However, if this stream is ordered then order
      * is preserved.
      *
@@ -344,7 +351,7 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
      * @see #distinct()
      * @since 0.3.1
      */
-    public S distinct(long atLeast) {
+    public @NonNull S distinct(long atLeast) {
         if (atLeast <= 1)
             return distinct();
         Spliterator<T> spliterator = spliterator();
@@ -358,27 +365,27 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
     }
 
     @Override
-    public S sorted() {
+    public @NonNull S sorted() {
         return supply(stream().sorted());
     }
 
     @Override
-    public S sorted(Comparator<? super T> comparator) {
+    public @NonNull S sorted(Comparator<? super T> comparator) {
         return supply(stream().sorted(comparator));
     }
 
     @Override
-    public S peek(Consumer<? super T> action) {
+    public @NonNull S peek(Consumer<? super T> action) {
         return supply(stream().peek(action));
     }
 
     @Override
-    public S limit(long maxSize) {
+    public @NonNull S limit(long maxSize) {
         return supply(stream().limit(maxSize));
     }
 
     @Override
-    public S skip(long n) {
+    public @NonNull S skip(long n) {
         return supply(stream().skip(n));
     }
 
@@ -415,12 +422,14 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
     }
 
     @Override
-    public Object[] toArray() {
+    @NullUnmarked // may return nulls inside the array
+    public Object @NonNull [] toArray() {
         return toArray(Object[]::new);
     }
 
     @Override
-    public <A> A[] toArray(IntFunction<A[]> generator) {
+    @NullUnmarked // may return nulls inside the array
+    public <A> A @NonNull [] toArray(@NonNull IntFunction<A @NonNull []> generator) {
         if (context.fjp != null)
             return context.terminate(generator, stream()::toArray);
         return stream().toArray(generator);
@@ -441,7 +450,7 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
     }
 
     @Override
-    public <U> U reduce(U identity, BiFunction<U, ? super T, U> accumulator, BinaryOperator<U> combiner) {
+    public <U extends @Nullable Object> U reduce(U identity, BiFunction<U, ? super T, U> accumulator, BinaryOperator<U> combiner) {
         if (context.fjp != null)
             return context.terminate(() -> stream().reduce(identity, accumulator, combiner));
         return stream().reduce(identity, accumulator, combiner);
@@ -502,7 +511,7 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
     }
 
     @Override
-    public <R> R collect(Supplier<R> supplier, BiConsumer<R, ? super T> accumulator, BiConsumer<R, R> combiner) {
+    public <R extends @Nullable Object> R collect(Supplier<R> supplier, BiConsumer<R, ? super T> accumulator, BiConsumer<R, R> combiner) {
         if (context.fjp != null)
             return context.terminate(() -> stream().collect(supplier, accumulator, combiner));
         return stream().collect(supplier, accumulator, combiner);
@@ -517,7 +526,7 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
      * collector</a> is passed, this operation becomes short-circuiting as well.
      */
     @Override
-    public <R, A> R collect(Collector<? super T, A, R> collector) {
+    public <R extends @Nullable Object, A extends @Nullable Object> R collect(Collector<? super T, A, R> collector) {
         Predicate<A> finished = finished(collector);
         if (finished != null) {
             BiConsumer<A, ? super T> acc = collector.accumulator();
@@ -700,7 +709,8 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
      *        {@link Collection} of new values
      * @return the new stream
      */
-    public <R> StreamEx<R> flatCollection(Function<? super T, ? extends Collection<? extends R>> mapper) {
+    public <R extends @Nullable Object> StreamEx<R> flatCollection(
+            Function<? super T, ? extends @Nullable Collection<? extends R>> mapper) {
         return flatMap(t -> {
             Collection<? extends R> c = mapper.apply(t);
             return c == null ? null : StreamEx.of(c.spliterator());
@@ -731,7 +741,7 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
      * @return the new stream
      * @since 0.6.5
      */
-    public <R> StreamEx<R> flatArray(Function<? super T, ? extends R[]> mapper) {
+    public <R extends @Nullable Object> StreamEx<R> flatArray(Function<? super T, ? extends R @Nullable []> mapper) {
         return flatMap(t -> {
             R[] a = mapper.apply(t);
             return a == null ? null : StreamEx.of(Arrays.spliterator(a));
@@ -788,7 +798,7 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
      * @return the new stream
      * @since 0.2.1
      */
-    public <R> StreamEx<R> pairMap(BiFunction<? super T, ? super T, ? extends R> mapper) {
+    public <R extends @Nullable Object> StreamEx<R> pairMap(BiFunction<? super T, ? super T, ? extends R> mapper) {
         PairSpliterator.PSOfRef<T, R> spliterator = new PairSpliterator.PSOfRef<>(mapper, spliterator());
         return new StreamEx<>(spliterator, context);
     }
@@ -811,7 +821,7 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
      * @see #nonNull()
      * @see StreamEx#select(Class)
      */
-    public S remove(Predicate<? super T> predicate) {
+    public @NonNull S remove(Predicate<? super T> predicate) {
         return filter(predicate.negate());
     }
 
@@ -828,7 +838,7 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
      * @see #remove(Predicate)
      * @see StreamEx#select(Class)
      */
-    public S nonNull() {
+    public @NonNull S nonNull() {
         return filter(Objects::nonNull);
     }
 
@@ -902,7 +912,7 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
      *        {@code Comparator} to be used to compare stream elements
      * @return the new stream
      */
-    public S reverseSorted(Comparator<? super T> comparator) {
+    public @NonNull S reverseSorted(Comparator<? super T> comparator) {
         return sorted(comparator.reversed());
     }
 
@@ -926,7 +936,7 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
      *        function to be used to extract sorting keys
      * @return the new stream
      */
-    public <V extends Comparable<? super V>> S sortedBy(Function<? super T, ? extends V> keyExtractor) {
+    public <V extends Comparable<? super V>> @NonNull S sortedBy(Function<? super T, ? extends V> keyExtractor) {
         return sorted(Comparator.comparing(keyExtractor));
     }
 
@@ -948,7 +958,7 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
      *        function to be used to extract sorting keys
      * @return the new stream
      */
-    public S sortedByInt(ToIntFunction<? super T> keyExtractor) {
+    public @NonNull S sortedByInt(ToIntFunction<? super T> keyExtractor) {
         return sorted(Comparator.comparingInt(keyExtractor));
     }
 
@@ -970,7 +980,7 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
      *        function to be used to extract sorting keys
      * @return the new stream
      */
-    public S sortedByLong(ToLongFunction<? super T> keyExtractor) {
+    public @NonNull S sortedByLong(ToLongFunction<? super T> keyExtractor) {
         return sorted(Comparator.comparingLong(keyExtractor));
     }
 
@@ -992,7 +1002,7 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
      *        function to be used to extract sorting keys
      * @return the new stream
      */
-    public S sortedByDouble(ToDoubleFunction<? super T> keyExtractor) {
+    public @NonNull S sortedByDouble(ToDoubleFunction<? super T> keyExtractor) {
         return sorted(Comparator.comparingDouble(keyExtractor));
     }
 
@@ -1295,7 +1305,7 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
      * @return this stream appended by the other stream
      * @see Stream#concat(Stream, Stream)
      */
-    public S append(Stream<? extends T> other) {
+    public @NonNull S append(Stream<? extends T> other) {
         return appendSpliterator(other, other.spliterator());
     }
 
@@ -1318,7 +1328,7 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
      * @return this stream prepended by the other stream
      * @see Stream#concat(Stream, Stream)
      */
-    public S prepend(Stream<? extends T> other) {
+    public @NonNull S prepend(Stream<? extends T> other) {
         return prependSpliterator(other, other.spliterator());
     }
 
@@ -1340,7 +1350,7 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
      * @return the stream whose content is replaced by other stream contents only if this stream is empty.
      * @since 0.6.6
      */
-    public S ifEmpty(Stream<? extends T> other) {
+    public @NonNull S ifEmpty(Stream<? extends T> other) {
         return ifEmpty(other, other.spliterator());
     }
 
@@ -1424,7 +1434,7 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
      * @since 0.2.3
      * @see #toList()
      */
-    public <R> R toListAndThen(Function<? super List<T>, R> finisher) {
+    public <R extends @Nullable Object> R toListAndThen(Function<? super List<T>, R> finisher) {
         if (context.fjp != null)
             return context.terminate(() -> finisher.apply(toMutableList()));
         return finisher.apply(toMutableList());
@@ -1483,7 +1493,7 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
      */
     public Set<T> toImmutableSet() {
         Set<T> result = toMutableSet();
-        if (result.size() == 0)
+        if (result.isEmpty())
             return Collections.emptySet();
         return Collections.unmodifiableSet(result);
     }
@@ -1504,7 +1514,7 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
      * @since 0.2.3
      * @see #toSet()
      */
-    public <R> R toSetAndThen(Function<? super Set<T>, R> finisher) {
+    public <R extends @Nullable Object> R toSetAndThen(Function<? super Set<T>, R> finisher) {
         if (context.fjp != null)
             return context.terminate(() -> finisher.apply(toMutableSet()));
         return finisher.apply(toMutableSet());
@@ -1528,8 +1538,9 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
      * @since 0.7.3
      * @see #toCollection(Supplier) 
      */
-    public <C extends Collection<T>, R> R toCollectionAndThen(Supplier<C> collectionFactory, 
-                                                              Function<? super C, R> finisher) {
+    public <C extends Collection<T>, R extends @Nullable Object> R toCollectionAndThen(
+            Supplier<C> collectionFactory, 
+            Function<? super C, R> finisher) {
         if (context.fjp != null)
             return context.terminate(() -> finisher.apply(toCollection(collectionFactory)));
         return finisher.apply(toCollection(collectionFactory));
@@ -1591,7 +1602,7 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
      * @see #reduce(Object, BiFunction, BinaryOperator)
      * @since 0.2.0
      */
-    public <U> U foldLeft(U seed, BiFunction<U, ? super T, U> accumulator) {
+    public <U extends @Nullable Object> U foldLeft(U seed, BiFunction<U, ? super T, U> accumulator) {
         Box<U> result = new Box<>(seed);
         forEachOrdered(t -> result.a = accumulator.apply(result.a, t));
         return result.a;
@@ -1676,7 +1687,7 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
      * @see #reduce(Object, BiFunction, BinaryOperator)
      * @since 0.2.2
      */
-    public <U> U foldRight(U seed, BiFunction<? super T, U, U> accumulator) {
+    public <U extends @Nullable Object> U foldRight(U seed, BiFunction<? super T, U, U> accumulator) {
         return toListAndThen(list -> {
             U result = seed;
             for (int i = list.size() - 1; i >= 0; i--)
@@ -1758,7 +1769,7 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
      * @see #scanRight(Object, BiFunction)
      * @since 0.2.1
      */
-    public <U> List<U> scanLeft(U seed, BiFunction<U, ? super T, U> accumulator) {
+    public <U extends @Nullable Object> List<U> scanLeft(U seed, BiFunction<U, ? super T, U> accumulator) {
         List<U> result = new ArrayList<>();
         result.add(seed);
         forEachOrdered(t -> result.add(accumulator.apply(result.get(result.size() - 1), t)));
@@ -1842,7 +1853,7 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
      * @since 0.2.2
      */
     @SuppressWarnings("unchecked")
-    public <U> List<U> scanRight(U seed, BiFunction<? super T, U, U> accumulator) {
+    public <U extends @Nullable Object> List<U> scanRight(U seed, BiFunction<? super T, U, U> accumulator) {
         return toListAndThen(list -> {
             // Reusing the list for different object type as it will save memory
             List<U> result = (List<U>) list;
@@ -1918,7 +1929,7 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
      * @see #takeWhileInclusive(Predicate)
      * @see #dropWhile(Predicate)
      */
-    public S takeWhile(Predicate<? super T> predicate) {
+    public @NonNull S takeWhile(Predicate<? super T> predicate) {
         Objects.requireNonNull(predicate);
         return VerSpec.VER_SPEC.callWhile(this, predicate, false);
     }
@@ -1944,7 +1955,7 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
      * @since 0.5.5
      * @see #takeWhile(Predicate)
      */
-    public S takeWhileInclusive(Predicate<? super T> predicate) {
+    public @NonNull S takeWhileInclusive(Predicate<? super T> predicate) {
         Objects.requireNonNull(predicate);
         Spliterator<T> spltr = spliterator();
         return supply(
@@ -1975,7 +1986,7 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
      * @return the new stream.
      * @since 0.3.6
      */
-    public S dropWhile(Predicate<? super T> predicate) {
+    public @NonNull S dropWhile(Predicate<? super T> predicate) {
         Objects.requireNonNull(predicate);
         return VerSpec.VER_SPEC.callWhile(this, predicate, true);
     }
@@ -2008,7 +2019,7 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
      * @see #scanLeft(BinaryOperator)
      * @since 0.6.1
      */
-    public S prefix(BinaryOperator<T> op) {
+    public @NonNull S prefix(BinaryOperator<T> op) {
         Spliterator<T> spltr = spliterator();
         return supply(spltr.hasCharacteristics(Spliterator.ORDERED) ? new PrefixOps.OfRef<>(spltr, op)
                 : new PrefixOps.OfUnordRef<>(spltr, op));
@@ -2017,7 +2028,7 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
     // Necessary to generate proper JavaDoc
     @SuppressWarnings("unchecked")
     @Override
-    public <U> U chain(Function<? super S, U> mapper) {
+    public <U extends @Nullable Object> U chain(Function<? super S, U> mapper) {
         return mapper.apply((S) this);
     }
 }
diff --git a/src/main/java/one/util/streamex/BaseStreamEx.java b/src/main/java/one/util/streamex/BaseStreamEx.java
index 6d06829..cec5121 100644
--- a/src/main/java/one/util/streamex/BaseStreamEx.java
+++ b/src/main/java/one/util/streamex/BaseStreamEx.java
@@ -15,6 +15,10 @@
  */
 package one.util.streamex;
 
+import org.jspecify.annotations.NonNull;
+import org.jspecify.annotations.NullMarked;
+import org.jspecify.annotations.Nullable;
+
 import java.util.Spliterator;
 import java.util.concurrent.ForkJoinPool;
 import java.util.function.Function;
@@ -23,27 +27,32 @@ import java.util.stream.BaseStream;
 /**
  * @author Tagir Valeev
  */
-/* package */abstract class BaseStreamEx<T, S extends BaseStream<T, S>, SPLTR extends Spliterator<T>, B extends BaseStreamEx<T, S, SPLTR, B>>
+@NullMarked
+/* package */abstract class BaseStreamEx<
+        T extends @Nullable Object, 
+        S extends BaseStream<T, S>, 
+        SPLTR extends Spliterator<T>, 
+        B extends BaseStreamEx<T, S, SPLTR, B>>
         implements BaseStream<T, S> {
     static final String CONSUMED_MESSAGE = "Stream is already consumed";
 
-    private S stream;
-    SPLTR spliterator;
+    private @Nullable S stream;
+    @Nullable SPLTR spliterator;
     StreamContext context;
 
-    BaseStreamEx(S stream, StreamContext context) {
+    BaseStreamEx(@NonNull S stream, StreamContext context) {
         this.stream = stream;
         this.context = context;
     }
 
-    BaseStreamEx(SPLTR spliterator, StreamContext context) {
+    BaseStreamEx(@NonNull SPLTR spliterator, StreamContext context) {
         this.spliterator = spliterator;
         this.context = context;
     }
 
     abstract S createStream();
 
-    final S stream() {
+    final @NonNull S stream() {
         if (stream != null)
             return stream;
         if (spliterator == null)
@@ -55,7 +64,7 @@ import java.util.stream.BaseStream;
 
     @SuppressWarnings("unchecked")
     @Override
-    public SPLTR spliterator() {
+    public @NonNull SPLTR spliterator() {
         if (stream != null)
             return (SPLTR) stream.spliterator();
         if (spliterator != null) {
@@ -73,7 +82,7 @@ import java.util.stream.BaseStream;
 
     @SuppressWarnings("unchecked")
     @Override
-    public S sequential() {
+    public @NonNull S sequential() {
         context = context.sequential();
         if (stream != null)
             stream = stream.sequential();
@@ -90,7 +99,7 @@ import java.util.stream.BaseStream;
      */
     @SuppressWarnings("unchecked")
     @Override
-    public S parallel() {
+    public @NonNull S parallel() {
         context = context.parallel();
         if (stream != null)
             stream = stream.parallel();
@@ -117,7 +126,7 @@ import java.util.stream.BaseStream;
      * @since 0.2.0
      */
     @SuppressWarnings("unchecked")
-    public S parallel(ForkJoinPool fjp) {
+    public @NonNull S parallel(ForkJoinPool fjp) {
         context = context.parallel(fjp);
         if (stream != null)
             stream = stream.parallel();
@@ -126,14 +135,14 @@ import java.util.stream.BaseStream;
 
     @SuppressWarnings("unchecked")
     @Override
-    public S unordered() {
+    public @NonNull S unordered() {
         stream = stream().unordered();
         return (S) this;
     }
 
     @SuppressWarnings("unchecked")
     @Override
-    public S onClose(Runnable closeHandler) {
+    public @NonNull S onClose(Runnable closeHandler) {
         context = context.onClose(closeHandler);
         return (S) this;
     }
@@ -167,5 +176,5 @@ import java.util.stream.BaseStream;
      * @return the result of the function invocation.
      * @since 0.5.4
      */
-    public abstract <U> U chain(Function<? super B, U> mapper);
+    public abstract <U extends @Nullable Object> U chain(Function<? super B, U> mapper);
 }
diff --git a/src/main/java/one/util/streamex/DoubleCollector.java b/src/main/java/one/util/streamex/DoubleCollector.java
index ba9f360..2a99387 100644
--- a/src/main/java/one/util/streamex/DoubleCollector.java
+++ b/src/main/java/one/util/streamex/DoubleCollector.java
@@ -15,6 +15,9 @@
  */
 package one.util.streamex;
 
+import org.jspecify.annotations.NullMarked;
+import org.jspecify.annotations.Nullable;
+
 import java.util.*;
 import java.util.function.*;
 import java.util.stream.Collector;
@@ -32,7 +35,8 @@ import static one.util.streamex.Internals.*;
  * @see DoubleStreamEx#collect(DoubleCollector)
  * @since 0.3.0
  */
-public interface DoubleCollector<A, R> extends MergingCollector<Double, A, R> {
+@NullMarked
+public interface DoubleCollector<A extends @Nullable Object, R extends @Nullable Object> extends MergingCollector<Double, A, R> {
     /**
      * A function that folds a value into a mutable result container.
      *
@@ -64,7 +68,7 @@ public interface DoubleCollector<A, R> extends MergingCollector<Double, A, R> {
      *         by an additional finishing step
      * @since 0.3.7
      */
-    default <RR> DoubleCollector<A, RR> andThen(Function<R, RR> finisher) {
+    default <RR extends @Nullable Object> DoubleCollector<A, RR> andThen(Function<R, RR> finisher) {
         return of(supplier(), doubleAccumulator(), merger(), finisher().andThen(finisher));
     }
 
@@ -82,7 +86,9 @@ public interface DoubleCollector<A, R> extends MergingCollector<Double, A, R> {
      *        result, for the new collector
      * @return the new {@code DoubleCollector}
      */
-    static <R> DoubleCollector<R, R> of(Supplier<R> supplier, ObjDoubleConsumer<R> doubleAccumulator,
+    static <R extends @Nullable Object> DoubleCollector<R, R> of(
+            Supplier<R> supplier, 
+            ObjDoubleConsumer<R> doubleAccumulator,
             BiConsumer<R, R> merger) {
         return new DoubleCollectorImpl<>(supplier, doubleAccumulator, merger, Function.identity(), ID_CHARACTERISTICS);
     }
@@ -97,7 +103,8 @@ public interface DoubleCollector<A, R> extends MergingCollector<Double, A, R> {
      * @return a {@code DoubleCollector} which behaves in the same way as input
      *         collector.
      */
-    static <A, R> DoubleCollector<?, R> of(Collector<Double, A, R> collector) {
+    static <A extends @Nullable Object, R extends @Nullable Object> DoubleCollector<?, R> of(
+            Collector<Double, A, R> collector) {
         if (collector instanceof DoubleCollector) {
             return (DoubleCollector<A, R>) collector;
         }
@@ -118,7 +125,8 @@ public interface DoubleCollector<A, R> extends MergingCollector<Double, A, R> {
      * @param <R> The final result type of the new collector
      * @return the new {@code DoubleCollector}
      */
-    static <A, R> DoubleCollector<A, R> of(Supplier<A> supplier, ObjDoubleConsumer<A> doubleAccumulator,
+    static <A extends @Nullable Object, R extends @Nullable Object> DoubleCollector<A, R> of(
+            Supplier<A> supplier, ObjDoubleConsumer<A> doubleAccumulator,
             BiConsumer<A, A> merger, Function<A, R> finisher) {
         return new DoubleCollectorImpl<>(supplier, doubleAccumulator, merger, finisher, NO_CHARACTERISTICS);
     }
@@ -236,7 +244,8 @@ public interface DoubleCollector<A, R> extends MergingCollector<Double, A, R> {
      *         elements and provides the mapped results to the downstream
      *         collector
      */
-    static <A, R> DoubleCollector<?, R> mapping(DoubleUnaryOperator mapper, DoubleCollector<A, R> downstream) {
+    static <A extends @Nullable Object, R extends @Nullable Object> DoubleCollector<?, R> mapping(
+            DoubleUnaryOperator mapper, DoubleCollector<A, R> downstream) {
         ObjDoubleConsumer<A> downstreamAccumulator = downstream.doubleAccumulator();
         return new DoubleCollectorImpl<>(downstream.supplier(), (r, t) -> downstreamAccumulator.accept(r, mapper
                 .applyAsDouble(t)), downstream.merger(), downstream.finisher(), downstream.characteristics());
@@ -256,7 +265,8 @@ public interface DoubleCollector<A, R> extends MergingCollector<Double, A, R> {
      *         elements and provides the mapped results to the downstream
      *         collector
      */
-    static <U, A, R> DoubleCollector<?, R> mappingToObj(DoubleFunction<U> mapper, Collector<U, A, R> downstream) {
+    static <U extends @Nullable Object, A extends @Nullable Object, R extends @Nullable Object> DoubleCollector<?, R> mappingToObj(
+            DoubleFunction<U> mapper, Collector<U, A, R> downstream) {
         BiConsumer<A, U> accumulator = downstream.accumulator();
         if (downstream instanceof MergingCollector) {
             return new DoubleCollectorImpl<>(downstream.supplier(), (acc, i) -> accumulator
@@ -356,7 +366,8 @@ public interface DoubleCollector<A, R> extends MergingCollector<Double, A, R> {
      * @return a {@code DoubleCollector} implementing the cascaded partitioning
      *         operation
      */
-    static <A, D> DoubleCollector<?, Map<Boolean, D>> partitioningBy(DoublePredicate predicate,
+    static <A extends @Nullable Object, D extends @Nullable Object> DoubleCollector<?, Map<Boolean, D>> partitioningBy(
+            DoublePredicate predicate,
             DoubleCollector<A, D> downstream) {
         ObjDoubleConsumer<A> downstreamAccumulator = downstream.doubleAccumulator();
         ObjDoubleConsumer<BooleanMap<A>> accumulator = (result, t) -> downstreamAccumulator.accept(
@@ -413,7 +424,8 @@ public interface DoubleCollector<A, R> extends MergingCollector<Double, A, R> {
      * @return a {@code DoubleCollector} implementing the cascaded group-by
      *         operation
      */
-    static <K, D, A> DoubleCollector<?, Map<K, D>> groupingBy(DoubleFunction<? extends K> classifier,
+    static <K, D extends @Nullable Object, A extends @Nullable Object> DoubleCollector<?, Map<K, D>> groupingBy(
+            DoubleFunction<? extends K> classifier,
             DoubleCollector<A, D> downstream) {
         return groupingBy(classifier, HashMap::new, downstream);
     }
@@ -443,8 +455,10 @@ public interface DoubleCollector<A, R> extends MergingCollector<Double, A, R> {
      * @return a {@code DoubleCollector} implementing the cascaded group-by
      *         operation
      */
-    static <K, D, A, M extends Map<K, D>> DoubleCollector<?, M> groupingBy(DoubleFunction<? extends K> classifier,
-            Supplier<M> mapFactory, DoubleCollector<A, D> downstream) {
+    static <K, D extends @Nullable Object, A extends @Nullable Object, M extends Map<K, D>> DoubleCollector<?, M> groupingBy(
+            DoubleFunction<? extends K> classifier,
+            Supplier<M> mapFactory, 
+            DoubleCollector<A, D> downstream) {
         Supplier<A> downstreamSupplier = downstream.supplier();
         Function<K, A> supplier = k -> downstreamSupplier.get();
         ObjDoubleConsumer<A> downstreamAccumulator = downstream.doubleAccumulator();
diff --git a/src/main/java/one/util/streamex/DoubleStreamEx.java b/src/main/java/one/util/streamex/DoubleStreamEx.java
index c8ead84..92d370a 100644
--- a/src/main/java/one/util/streamex/DoubleStreamEx.java
+++ b/src/main/java/one/util/streamex/DoubleStreamEx.java
@@ -15,6 +15,9 @@
  */
 package one.util.streamex;
 
+import org.jspecify.annotations.NullMarked;
+import org.jspecify.annotations.Nullable;
+
 import java.nio.Buffer;
 import java.util.*;
 import java.util.Map.Entry;
@@ -30,6 +33,7 @@ import static one.util.streamex.Internals.*;
  * 
  * @author Tagir Valeev
  */
+@NullMarked
 public final class DoubleStreamEx extends BaseStreamEx<Double, DoubleStream, Spliterator.OfDouble, DoubleStreamEx> implements
         DoubleStream {
     DoubleStreamEx(DoubleStream stream, StreamContext context) {
@@ -193,7 +197,7 @@ public final class DoubleStreamEx extends BaseStreamEx<Double, DoubleStream, Spl
     }
 
     @Override
-    public <U> StreamEx<U> mapToObj(DoubleFunction<? extends U> mapper) {
+    public <U extends @Nullable Object> StreamEx<U> mapToObj(DoubleFunction<? extends U> mapper) {
         return new StreamEx<>(stream().mapToObj(mapper), context);
     }
 
@@ -224,14 +228,16 @@ public final class DoubleStreamEx extends BaseStreamEx<Double, DoubleStream, Spl
      * @return the new stream
      * @since 0.3.1
      */
-    public <K, V> EntryStream<K, V> mapToEntry(DoubleFunction<? extends K> keyMapper,
+    public <K extends @Nullable Object,
+            V extends @Nullable Object> EntryStream<K, V> mapToEntry(
+            DoubleFunction<? extends K> keyMapper,
             DoubleFunction<? extends V> valueMapper) {
         return new EntryStream<>(stream().mapToObj(t -> new AbstractMap.SimpleImmutableEntry<>(keyMapper.apply(t),
                 valueMapper.apply(t))), context);
     }
 
     @Override
-    public DoubleStreamEx flatMap(DoubleFunction<? extends DoubleStream> mapper) {
+    public DoubleStreamEx flatMap(DoubleFunction<? extends @Nullable DoubleStream> mapper) {
         return new DoubleStreamEx(stream().flatMap(mapper), context);
     }
 
@@ -250,7 +256,7 @@ public final class DoubleStreamEx extends BaseStreamEx<Double, DoubleStream, Spl
      * @return the new stream
      * @since 0.3.0
      */
-    public IntStreamEx flatMapToInt(DoubleFunction<? extends IntStream> mapper) {
+    public IntStreamEx flatMapToInt(DoubleFunction<? extends @Nullable IntStream> mapper) {
         return new IntStreamEx(stream().mapToObj(mapper).flatMapToInt(Function.identity()), context);
     }
 
@@ -269,7 +275,7 @@ public final class DoubleStreamEx extends BaseStreamEx<Double, DoubleStream, Spl
      * @return the new stream
      * @since 0.3.0
      */
-    public LongStreamEx flatMapToLong(DoubleFunction<? extends LongStream> mapper) {
+    public LongStreamEx flatMapToLong(DoubleFunction<? extends @Nullable LongStream> mapper) {
         return new LongStreamEx(stream().mapToObj(mapper).flatMapToLong(Function.identity()), context);
     }
 
@@ -289,7 +295,7 @@ public final class DoubleStreamEx extends BaseStreamEx<Double, DoubleStream, Spl
      * @return the new stream
      * @since 0.3.0
      */
-    public <R> StreamEx<R> flatMapToObj(DoubleFunction<? extends Stream<R>> mapper) {
+    public <R extends @Nullable Object> StreamEx<R> flatMapToObj(DoubleFunction<? extends @Nullable Stream<R>> mapper) {
         return new StreamEx<>(stream().mapToObj(mapper).flatMap(Function.identity()), context);
     }
 
@@ -793,7 +799,7 @@ public final class DoubleStreamEx extends BaseStreamEx<Double, DoubleStream, Spl
      * @see #collect(DoubleCollector)
      */
     @Override
-    public <R> R collect(Supplier<R> supplier, ObjDoubleConsumer<R> accumulator, BiConsumer<R, R> combiner) {
+    public <R extends @Nullable Object> R collect(Supplier<R> supplier, ObjDoubleConsumer<R> accumulator, BiConsumer<R, R> combiner) {
         if (context.fjp != null)
             return context.terminate(() -> stream().collect(supplier, accumulator, combiner));
         return stream().collect(supplier, accumulator, combiner);
@@ -822,7 +828,7 @@ public final class DoubleStreamEx extends BaseStreamEx<Double, DoubleStream, Spl
      * @since 0.3.0
      */
     @SuppressWarnings("unchecked")
-    public <A, R> R collect(DoubleCollector<A, R> collector) {
+    public <A extends @Nullable Object, R extends @Nullable Object> R collect(DoubleCollector<A, R> collector) {
         if (collector.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH))
             return (R) collect(collector.supplier(), collector.doubleAccumulator(), collector.merger());
         return collector.finisher().apply(collect(collector.supplier(), collector.doubleAccumulator(), collector
@@ -1491,7 +1497,7 @@ public final class DoubleStreamEx extends BaseStreamEx<Double, DoubleStream, Spl
     // Necessary to generate proper JavaDoc
     // does not add overhead as it appears in bytecode anyways as bridge method
     @Override
-    public <U> U chain(Function<? super DoubleStreamEx, U> mapper) {
+    public <U extends @Nullable Object> U chain(Function<? super DoubleStreamEx, U> mapper) {
         return mapper.apply(this);
     }
 
@@ -1961,7 +1967,7 @@ public final class DoubleStreamEx extends BaseStreamEx<Double, DoubleStream, Spl
          * @param action consumer to be called to emit elements
          * @return next emitter or null
          */
-        DoubleEmitter next(DoubleConsumer action);
+        @Nullable DoubleEmitter next(DoubleConsumer action);
 
         /**
          * Returns the spliterator which covers all the elements emitted by this
diff --git a/src/main/java/one/util/streamex/EntryStream.java b/src/main/java/one/util/streamex/EntryStream.java
index 2125bf6..0483f95 100644
--- a/src/main/java/one/util/streamex/EntryStream.java
+++ b/src/main/java/one/util/streamex/EntryStream.java
@@ -15,6 +15,10 @@
  */
 package one.util.streamex;
 
+import org.jspecify.annotations.NonNull;
+import org.jspecify.annotations.NullMarked;
+import org.jspecify.annotations.Nullable;
+
 import java.util.AbstractMap.SimpleImmutableEntry;
 import java.util.*;
 import java.util.Map.Entry;
@@ -46,7 +50,9 @@ import static one.util.streamex.Internals.checkLength;
  * @param <K> the type of {@code Entry} keys
  * @param <V> the type of {@code Entry} values
  */
-public final class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream<K, V>> {
+@NullMarked
+public final class EntryStream<K extends @Nullable Object, V extends @Nullable Object> extends
+        AbstractStreamEx<Entry<K, V>, EntryStream<K, V>> {
     EntryStream(Stream<? extends Entry<K, V>> stream, StreamContext context) {
         super(stream, context);
     }
@@ -65,11 +71,12 @@ public final class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, Entry
         return new EntryStream<>(spliterator, context);
     }
 
-    static <K, V> Consumer<? super Entry<K, V>> toConsumer(BiConsumer<? super K, ? super V> action) {
+    static <K extends @Nullable Object, V extends @Nullable Object> Consumer<? super Entry<K, V>> toConsumer(
+            BiConsumer<? super K, ? super V> action) {
         return entry -> action.accept(entry.getKey(), entry.getValue());
     }
 
-    static <K, V, M extends Map<K, V>> Consumer<? super Entry<K, V>> toMapConsumer(M map) {
+    static <K extends @Nullable Object, V extends @Nullable Object, M extends Map<K, V>> Consumer<? super Entry<K, V>> toMapConsumer(M map) {
         return entry -> addToMap(map, entry.getKey(), Objects.requireNonNull(entry.getValue()));
     }
 
@@ -77,15 +84,17 @@ public final class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, Entry
         return (e1, e2) -> Objects.equals(e1.getKey(), e2.getKey());
     }
 
-    static <K, V> Stream<Entry<K, V>> withValue(Stream<? extends K> s, V value) {
+    static <K extends @Nullable Object, V extends @Nullable Object> @Nullable Stream<Entry<K, V>> withValue(
+            @Nullable Stream<? extends K> s, V value) {
         return s == null ? null : s.map(key -> new SimpleImmutableEntry<>(key, value));
     }
 
-    static <K, V> Stream<Entry<K, V>> withKey(K key, Stream<? extends V> s) {
+    static <K extends @Nullable Object, V extends @Nullable Object> @Nullable Stream<Entry<K, V>> withKey(
+            K key, @Nullable Stream<? extends V> s) {
         return s == null ? null : s.map(value -> new SimpleImmutableEntry<>(key, value));
     }
 
-    static <K, V, R> Function<? super Entry<K, V>, ? extends R> toFunction(
+    static <K extends @Nullable Object, V extends @Nullable Object, R extends @Nullable Object> Function<? super Entry<K, V>, ? extends R> toFunction(
             BiFunction<? super K, ? super V, ? extends R> mapper) {
         return entry -> mapper.apply(entry.getKey(), entry.getValue());
     }
@@ -147,7 +156,7 @@ public final class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, Entry
      *        function to apply to each key which produces a stream of new keys
      * @return the new stream
      */
-    public <KK> EntryStream<KK, V> flatMapKeys(Function<? super K, ? extends Stream<? extends KK>> mapper) {
+    public <KK extends @Nullable Object> EntryStream<KK, V> flatMapKeys(Function<? super K, ? extends @Nullable Stream<? extends KK>> mapper) {
         return new EntryStream<>(stream().flatMap(e -> withValue(mapper.apply(e.getKey()), e.getValue())), context);
     }
 
@@ -172,7 +181,7 @@ public final class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, Entry
      * @return the new stream
      * @since 0.5.2
      */
-    public <KK> EntryStream<KK, V> flatMapToKey(BiFunction<? super K, ? super V, ? extends Stream<? extends KK>> mapper) {
+    public <KK extends @Nullable Object> EntryStream<KK, V> flatMapToKey(BiFunction<? super K, ? super V, ? extends @Nullable Stream<? extends KK>> mapper) {
         return new EntryStream<>(
                 stream().flatMap(e -> withValue(mapper.apply(e.getKey(), e.getValue()), e.getValue())), context);
     }
@@ -198,7 +207,7 @@ public final class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, Entry
      *        values
      * @return the new stream
      */
-    public <VV> EntryStream<K, VV> flatMapValues(Function<? super V, ? extends Stream<? extends VV>> mapper) {
+    public <VV extends @Nullable Object> EntryStream<K, VV> flatMapValues(Function<? super V, ? extends @Nullable Stream<? extends VV>> mapper) {
         return new EntryStream<>(stream().flatMap(e -> withKey(e.getKey(), mapper.apply(e.getValue()))), context);
     }
 
@@ -223,8 +232,8 @@ public final class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, Entry
      * @return the new stream
      * @since 0.5.2
      */
-    public <VV> EntryStream<K, VV> flatMapToValue(
-            BiFunction<? super K, ? super V, ? extends Stream<? extends VV>> mapper) {
+    public <VV extends @Nullable Object> EntryStream<K, VV> flatMapToValue(
+            BiFunction<? super K, ? super V, ? extends @Nullable Stream<? extends VV>> mapper) {
         return new EntryStream<>(stream().flatMap(e -> withKey(e.getKey(), mapper.apply(e.getKey(), e.getValue()))),
                 context);
     }
@@ -246,8 +255,9 @@ public final class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, Entry
      * @return the new stream
      * @since 0.3.0
      */
-    public <R> StreamEx<R> flatMapKeyValue(BiFunction<? super K, ? super V, ? extends Stream<? extends R>> mapper) {
-        return this.<R>flatMap(toFunction(mapper));
+    public <R extends @Nullable Object> StreamEx<R> flatMapKeyValue(BiFunction<? super K, ? super V,
+            ? extends @Nullable Stream<? extends R>> mapper) {
+        return this.flatMap(toFunction(mapper));
     }
 
     /**
@@ -471,7 +481,7 @@ public final class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, Entry
      *        key
      * @return the new stream
      */
-    public <KK> EntryStream<KK, V> mapKeys(Function<? super K, ? extends KK> keyMapper) {
+    public <KK extends @Nullable Object> EntryStream<KK, V> mapKeys(Function<? super K, ? extends KK> keyMapper) {
         return new EntryStream<>(stream().map(
             e -> new SimpleImmutableEntry<>(keyMapper.apply(e.getKey()), e.getValue())), context);
     }
@@ -527,7 +537,7 @@ public final class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, Entry
      *        value
      * @return the new stream
      */
-    public <VV> EntryStream<K, VV> mapValues(Function<? super V, ? extends VV> valueMapper) {
+    public <VV extends @Nullable Object> EntryStream<K, VV> mapValues(Function<? super V, ? extends VV> valueMapper) {
         return new EntryStream<>(stream().map(
             e -> new SimpleImmutableEntry<>(e.getKey(), valueMapper.apply(e.getValue()))), context);
     }
@@ -584,7 +594,7 @@ public final class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, Entry
      *        value of each {@link Entry} in this stream
      * @return the new stream
      */
-    public <R> StreamEx<R> mapKeyValue(BiFunction<? super K, ? super V, ? extends R> mapper) {
+    public <R extends @Nullable Object> StreamEx<R> mapKeyValue(BiFunction<? super K, ? super V, ? extends R> mapper) {
         return this.<R>map(toFunction(mapper));
     }
 
@@ -615,10 +625,10 @@ public final class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, Entry
      * @return the new stream
      * @since 0.6.8
      */
-    public <R> StreamEx<R> mapKeyValuePartial(
+    public <R extends @Nullable Object> StreamEx<R> mapKeyValuePartial(
             BiFunction<? super K, ? super V, ? extends Optional<? extends R>> mapper
     ) {
-        return this.<R>mapPartial(toFunction(mapper));
+        return this.mapPartial(toFunction(mapper));
     }
 
     /**
@@ -635,7 +645,7 @@ public final class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, Entry
      * @return the new stream
      * @since 0.3.0
      */
-    public <KK> EntryStream<KK, V> mapToKey(BiFunction<? super K, ? super V, ? extends KK> keyMapper) {
+    public <KK extends @Nullable Object> EntryStream<KK, V> mapToKey(BiFunction<? super K, ? super V, ? extends KK> keyMapper) {
         return new EntryStream<>(stream().map(
             e -> new SimpleImmutableEntry<>(keyMapper.apply(e.getKey(), e.getValue()), e.getValue())), context);
     }
@@ -691,7 +701,7 @@ public final class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, Entry
      * @return the new stream
      * @since 0.3.0
      */
-    public <VV> EntryStream<K, VV> mapToValue(BiFunction<? super K, ? super V, ? extends VV> valueMapper) {
+    public <VV extends @Nullable Object> EntryStream<K, VV> mapToValue(BiFunction<? super K, ? super V, ? extends VV> valueMapper) {
         return new EntryStream<>(stream().map(
             e -> new SimpleImmutableEntry<>(e.getKey(), valueMapper.apply(e.getKey(), e.getValue()))), context);
     }
@@ -951,7 +961,7 @@ public final class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, Entry
      * @see #selectKeys(Class)
      * @see #selectValues(Class)
      */
-    public EntryStream<K, V> nonNullKeys() {
+    public EntryStream<@NonNull K, V> nonNullKeys() {
         return filter(e -> e.getKey() != null);
     }
 
@@ -970,7 +980,7 @@ public final class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, Entry
      * @see #selectKeys(Class)
      * @see #selectValues(Class)
      */
-    public EntryStream<K, V> nonNullValues() {
+    public EntryStream<K, @NonNull V> nonNullValues() {
         return filter(e -> e.getValue() != null);
     }
 
@@ -1218,7 +1228,7 @@ public final class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, Entry
      * @see StreamEx#collapse(BiPredicate, Collector)
      * @since 0.5.5
      */
-    public <A, R> EntryStream<K, R> collapseKeys(Collector<? super V, A, R> collector) {
+    public <A extends @Nullable Object, R extends @Nullable Object> EntryStream<K, R> collapseKeys(Collector<? super V, A, R> collector) {
         Supplier<A> supplier = collector.supplier();
         BiConsumer<A, ? super V> accumulator = collector.accumulator();
         BinaryOperator<A> combiner = collector.combiner();
@@ -1368,7 +1378,7 @@ public final class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, Entry
      * @see #toMap()
      * @since 0.5.5
      */
-    public <R> R toMapAndThen(Function<? super Map<K, V>, R> finisher) {
+    public <R extends @Nullable Object> R toMapAndThen(Function<? super Map<K, V>, R> finisher) {
         if (context.fjp != null)
             return context.terminate(() -> finisher.apply(toMap()));
         return finisher.apply(toMap());
@@ -1680,7 +1690,7 @@ public final class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, Entry
      * @return a {@code Map} containing the elements of this stream
      * @see Collectors#groupingBy(Function, Collector)
      */
-    public <A, D> Map<K, D> grouping(Collector<? super V, A, D> downstream) {
+    public <A extends @Nullable Object, D extends @Nullable Object> Map<K, D> grouping(Collector<? super V, A, D> downstream) {
         Function<Entry<K, V>, K> keyMapper = Entry::getKey;
         Collector<Entry<K, V>, ?, D> mapping = Collectors.mapping(Entry::getValue, downstream);
         if (isParallel() && downstream.characteristics().contains(Characteristics.UNORDERED)) {
@@ -1711,7 +1721,8 @@ public final class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, Entry
      * @see Collectors#groupingBy(Function, Supplier, Collector)
      */
     @SuppressWarnings("unchecked")
-    public <A, D, M extends Map<K, D>> M grouping(Supplier<M> mapSupplier, Collector<? super V, A, D> downstream) {
+    public <A extends @Nullable Object, D extends @Nullable Object, M extends Map<K, D>> M grouping(
+            Supplier<M> mapSupplier, Collector<? super V, A, D> downstream) {
         Function<Entry<K, V>, K> keyMapper = Entry::getKey;
         Collector<Entry<K, V>, ?, D> mapping = Collectors.mapping(Entry::getValue, downstream);
         if (isParallel() && downstream.characteristics().contains(Characteristics.UNORDERED)
@@ -1803,20 +1814,20 @@ public final class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, Entry
      * @return an empty sequential stream
      * @since 0.0.8
      */
-    public static <K, V> EntryStream<K, V> empty() {
+    public static <K extends @Nullable Object, V extends @Nullable Object> EntryStream<K, V> empty() {
         return of(Stream.empty());
     }
 
     /**
      * Returns an {@code EntryStream} object which wraps given {@link Stream} of
-     * {@link Entry} elements
+     * non-null {@link Entry} elements
      *
      * @param <K> the type of original stream keys
      * @param <V> the type of original stream values
-     * @param stream original stream
+     * @param stream original stream that contains {@code Entry} elements and does not contain nulls.
      * @return the wrapped stream
      */
-    public static <K, V> EntryStream<K, V> of(Stream<? extends Entry<K, V>> stream) {
+    public static <K extends @Nullable Object, V extends @Nullable Object> EntryStream<K, V> of(Stream<? extends Entry<K, V>> stream) {
         if (stream instanceof AbstractStreamEx) {
             @SuppressWarnings("unchecked")
             AbstractStreamEx<Entry<K, V>, ?> ase = (AbstractStreamEx<Entry<K, V>, ?>) stream;
@@ -1833,11 +1844,11 @@ public final class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, Entry
      *
      * @param <K> the type of stream keys
      * @param <V> the type of stream values
-     * @param spliterator a spliterator to create the stream from.
+     * @param spliterator a spliterator to create the stream from. The spliterator should not contain null elements.
      * @return the new stream
      * @since 0.3.4
      */
-    public static <K, V> EntryStream<K, V> of(Spliterator<? extends Entry<K, V>> spliterator) {
+    public static <K extends @Nullable Object, V extends @Nullable Object> EntryStream<K, V> of(Spliterator<? extends Entry<K, V>> spliterator) {
         return of(StreamSupport.stream(spliterator, false));
     }
 
@@ -1856,11 +1867,11 @@ public final class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, Entry
      *
      * @param <K> the type of stream keys
      * @param <V> the type of stream values
-     * @param iterator an iterator to create the stream from.
+     * @param iterator an iterator to create the stream from. The iterator should not contain null elements.
      * @return the new stream
      * @since 0.5.1
      */
-    public static <K, V> EntryStream<K, V> of(Iterator<? extends Entry<K, V>> iterator) {
+    public static <K extends @Nullable Object, V extends @Nullable Object> EntryStream<K, V> of(Iterator<? extends Entry<K, V>> iterator) {
         return of(new UnknownSizeSpliterator.USOfRef<>(iterator));
     }
 
@@ -1873,7 +1884,7 @@ public final class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, Entry
      * @param map the map to create the stream from
      * @return a new {@code EntryStream}
      */
-    public static <K, V> EntryStream<K, V> of(Map<K, V> map) {
+    public static <K extends @Nullable Object, V extends @Nullable Object> EntryStream<K, V> of(Map<K, V> map) {
         return of(map.entrySet().stream());
     }
 
@@ -1891,7 +1902,7 @@ public final class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, Entry
      * @return a new {@code EntryStream}
      * @since 0.2.3
      */
-    public static <V> EntryStream<Integer, V> of(List<V> list) {
+    public static <V extends @Nullable Object> EntryStream<Integer, V> of(List<V> list) {
         return EntryStream.of(new RangeBasedSpliterator.AsEntry<>(list));
     }
 
@@ -1904,7 +1915,7 @@ public final class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, Entry
      * @return a new {@code EntryStream}
      * @since 0.2.3
      */
-    public static <V> EntryStream<Integer, V> of(V[] array) {
+    public static <V extends @Nullable Object> EntryStream<Integer, V> of(V[] array) {
         return of(Arrays.asList(array));
     }
 
@@ -1918,7 +1929,7 @@ public final class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, Entry
      * @param value the value of the single element
      * @return a singleton sequential stream
      */
-    public static <K, V> EntryStream<K, V> of(K key, V value) {
+    public static <K extends @Nullable Object, V extends @Nullable Object> EntryStream<K, V> of(K key, V value) {
         return of(Stream.of(new SimpleImmutableEntry<>(key, value)));
     }
 
@@ -1934,7 +1945,7 @@ public final class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, Entry
      * @return a sequential stream
      * @since 0.2.3
      */
-    public static <K, V> EntryStream<K, V> of(K k1, V v1, K k2, V v2) {
+    public static <K extends @Nullable Object, V extends @Nullable Object> EntryStream<K, V> of(K k1, V v1, K k2, V v2) {
         return of(Stream.of(new SimpleImmutableEntry<>(k1, v1), new SimpleImmutableEntry<>(k2, v2)));
     }
 
@@ -1952,7 +1963,7 @@ public final class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, Entry
      * @return a sequential stream
      * @since 0.2.3
      */
-    public static <K, V> EntryStream<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3) {
+    public static <K extends @Nullable Object, V extends @Nullable Object> EntryStream<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3) {
         return of(Stream.of(new SimpleImmutableEntry<>(k1, v1), new SimpleImmutableEntry<>(k2, v2),
             new SimpleImmutableEntry<>(k3, v3)));
     }
@@ -1973,7 +1984,7 @@ public final class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, Entry
      * @return a sequential stream
      * @since 0.5.2
      */
-    public static <K, V> EntryStream<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4) {
+    public static <K extends @Nullable Object, V extends @Nullable Object> EntryStream<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4) {
         return of(Stream.of(new SimpleImmutableEntry<>(k1, v1), new SimpleImmutableEntry<>(k2, v2),
             new SimpleImmutableEntry<>(k3, v3), new SimpleImmutableEntry<>(k4, v4)));
     }
@@ -1996,7 +2007,7 @@ public final class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, Entry
      * @return a sequential stream
      * @since 0.5.2
      */
-    public static <K, V> EntryStream<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5) {
+    public static <K extends @Nullable Object, V extends @Nullable Object> EntryStream<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5) {
         return of(Stream.of(new SimpleImmutableEntry<>(k1, v1), new SimpleImmutableEntry<>(k2, v2),
             new SimpleImmutableEntry<>(k3, v3), new SimpleImmutableEntry<>(k4, v4), new SimpleImmutableEntry<>(k5, v5)));
     }
@@ -2021,7 +2032,7 @@ public final class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, Entry
      * @return a sequential stream
      * @since 0.5.2
      */
-    public static <K, V> EntryStream<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6) {
+    public static <K extends @Nullable Object, V extends @Nullable Object> EntryStream<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6) {
         return of(Stream.of(new SimpleImmutableEntry<>(k1, v1), new SimpleImmutableEntry<>(k2, v2),
             new SimpleImmutableEntry<>(k3, v3), new SimpleImmutableEntry<>(k4, v4), new SimpleImmutableEntry<>(k5, v5),
             new SimpleImmutableEntry<>(k6, v6)));
@@ -2049,7 +2060,7 @@ public final class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, Entry
      * @return a sequential stream
      * @since 0.5.2
      */
-    public static <K, V> EntryStream<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6,
+    public static <K extends @Nullable Object, V extends @Nullable Object> EntryStream<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6,
             K k7, V v7) {
         return of(Stream.of(new SimpleImmutableEntry<>(k1, v1), new SimpleImmutableEntry<>(k2, v2),
             new SimpleImmutableEntry<>(k3, v3), new SimpleImmutableEntry<>(k4, v4), new SimpleImmutableEntry<>(k5, v5),
@@ -2080,7 +2091,7 @@ public final class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, Entry
      * @return a sequential stream
      * @since 0.5.2
      */
-    public static <K, V> EntryStream<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6,
+    public static <K extends @Nullable Object, V extends @Nullable Object> EntryStream<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6,
             K k7, V v7, K k8, V v8) {
         return of(Stream.of(new SimpleImmutableEntry<>(k1, v1), new SimpleImmutableEntry<>(k2, v2),
             new SimpleImmutableEntry<>(k3, v3), new SimpleImmutableEntry<>(k4, v4), new SimpleImmutableEntry<>(k5, v5),
@@ -2113,7 +2124,7 @@ public final class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, Entry
      * @return a sequential stream
      * @since 0.5.2
      */
-    public static <K, V> EntryStream<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6,
+    public static <K extends @Nullable Object, V extends @Nullable Object> EntryStream<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6,
             K k7, V v7, K k8, V v8, K k9, V v9) {
         return of(Stream.of(new SimpleImmutableEntry<>(k1, v1), new SimpleImmutableEntry<>(k2, v2),
             new SimpleImmutableEntry<>(k3, v3), new SimpleImmutableEntry<>(k4, v4), new SimpleImmutableEntry<>(k5, v5),
@@ -2149,7 +2160,7 @@ public final class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, Entry
      * @return a sequential stream
      * @since 0.5.2
      */
-    public static <K, V> EntryStream<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6,
+    public static <K extends @Nullable Object, V extends @Nullable Object> EntryStream<K, V> of(K k1, V v1, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6,
             K k7, V v7, K k8, V v8, K k9, V v9, K k10, V v10) {
         return of(Stream.of(new SimpleImmutableEntry<>(k1, v1), new SimpleImmutableEntry<>(k2, v2),
             new SimpleImmutableEntry<>(k3, v3), new SimpleImmutableEntry<>(k4, v4), new SimpleImmutableEntry<>(k5, v5),
@@ -2175,7 +2186,7 @@ public final class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, Entry
      * @see StreamEx#zip(List, List, BiFunction)
      * @since 0.2.1
      */
-    public static <K, V> EntryStream<K, V> zip(List<K> keys, List<V> values) {
+    public static <K extends @Nullable Object, V extends @Nullable Object> EntryStream<K, V> zip(List<K> keys, List<V> values) {
         return of(new RangeBasedSpliterator.ZipRef<>(0, checkLength(keys.size(), values.size()),
                 SimpleImmutableEntry::new, keys, values));
     }
@@ -2193,7 +2204,7 @@ public final class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, Entry
      * @see StreamEx#zip(Object[], Object[], BiFunction)
      * @since 0.2.1
      */
-    public static <K, V> EntryStream<K, V> zip(K[] keys, V[] values) {
+    public static <K extends @Nullable Object, V extends @Nullable Object> EntryStream<K, V> zip(K[] keys, V[] values) {
         return zip(Arrays.asList(keys), Arrays.asList(values));
     }
 
@@ -2222,7 +2233,7 @@ public final class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, Entry
      * @see StreamEx#ofPairs(List, BiFunction)
      * @since 0.3.6
      */
-    public static <T> EntryStream<T, T> ofPairs(List<T> list) {
+    public static <T extends @Nullable Object> EntryStream<T, T> ofPairs(List<T> list) {
         return of(new PairPermutationSpliterator<>(list, SimpleImmutableEntry::new));
     }
 
@@ -2246,7 +2257,7 @@ public final class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, Entry
      * @see StreamEx#ofPairs(Object[], BiFunction)
      * @since 0.3.6
      */
-    public static <T> EntryStream<T, T> ofPairs(T[] array) {
+    public static <T extends @Nullable Object> EntryStream<T, T> ofPairs(T[] array) {
         return ofPairs(Arrays.asList(array));
     }
 
@@ -2278,7 +2289,7 @@ public final class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, Entry
      * @see StreamEx#ofTree(Object, Function)
      * @see #ofTree(Object, Class, BiFunction)
      */
-    public static <T> EntryStream<Integer, T> ofTree(T root, BiFunction<Integer, T, Stream<T>> mapper) {
+    public static <T extends @Nullable Object> EntryStream<Integer, T> ofTree(T root, BiFunction<Integer, T, @Nullable Stream<T>> mapper) {
         TreeSpliterator<T, Entry<Integer, T>> spliterator = new TreeSpliterator.Depth<>(root, mapper, 0);
         return new EntryStream<>(spliterator, StreamContext.SEQUENTIAL.onClose(spliterator));
     }
@@ -2314,8 +2325,8 @@ public final class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, Entry
      * @see #ofTree(Object, BiFunction)
      */
     @SuppressWarnings("unchecked")
-    public static <T, TT extends T> EntryStream<Integer, T> ofTree(T root, Class<TT> collectionClass,
-            BiFunction<Integer, TT, Stream<T>> mapper) {
+    public static <T extends @Nullable Object, TT extends T> EntryStream<Integer, T> ofTree(T root, Class<TT> collectionClass,
+                                                                                            BiFunction<Integer, TT, @Nullable Stream<T>> mapper) {
         return ofTree(root, (d, t) -> collectionClass.isInstance(t) ? mapper.apply(d, (TT) t) : null);
     }
 
@@ -2332,8 +2343,9 @@ public final class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, Entry
      * @since 0.6.6
      * @see StreamEx#generate(Supplier)
      */
-    public static <K, V> EntryStream<K, V> generate(Supplier<? extends K> keySupplier,
-                                                    Supplier<? extends V> valueSupplier) {
+    public static <K extends @Nullable Object, V extends @Nullable Object> EntryStream<K, V> generate(
+            Supplier<? extends K> keySupplier,
+            Supplier<? extends V> valueSupplier) {
         return new EntryStream<>(
                 Stream.generate(() -> new SimpleImmutableEntry<>(keySupplier.get(), valueSupplier.get())),
                 StreamContext.SEQUENTIAL);
@@ -2366,7 +2378,7 @@ public final class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, Entry
      * @see StreamEx#without(Object...)
      */
     @SafeVarargs
-    public final EntryStream<K, V> withoutKeys(K... keys) {
+    public final EntryStream<K, V> withoutKeys(@Nullable K... keys) {
         if (keys.length == 0)
             return this;
         if (keys.length == 1)
@@ -2407,7 +2419,7 @@ public final class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, Entry
      * @see StreamEx#without(Object...)
      */
     @SafeVarargs
-    public final EntryStream<K, V> withoutValues(V... values) {
+    public final EntryStream<K, V> withoutValues(@Nullable V... values) {
         if (values.length == 0)
             return this;
         if (values.length == 1)
diff --git a/src/main/java/one/util/streamex/IntCollector.java b/src/main/java/one/util/streamex/IntCollector.java
index 63ae9bb..58b95a9 100644
--- a/src/main/java/one/util/streamex/IntCollector.java
+++ b/src/main/java/one/util/streamex/IntCollector.java
@@ -15,6 +15,9 @@
  */
 package one.util.streamex;
 
+import org.jspecify.annotations.NullMarked;
+import org.jspecify.annotations.Nullable;
+
 import java.util.*;
 import java.util.function.*;
 import java.util.stream.Collector;
@@ -34,7 +37,8 @@ import static one.util.streamex.Internals.*;
  * @see IntStreamEx#collect(IntCollector)
  * @since 0.3.0
  */
-public interface IntCollector<A, R> extends MergingCollector<Integer, A, R> {
+@NullMarked
+public interface IntCollector<A extends @Nullable Object, R extends @Nullable Object> extends MergingCollector<Integer, A, R> {
     /**
      * A function that folds a value into a mutable result container.
      *
@@ -66,7 +70,7 @@ public interface IntCollector<A, R> extends MergingCollector<Integer, A, R> {
      *         by an additional finishing step
      * @since 0.3.7
      */
-    default <RR> IntCollector<A, RR> andThen(Function<R, RR> finisher) {
+    default <RR extends @Nullable Object> IntCollector<A, RR> andThen(Function<R, RR> finisher) {
         return of(supplier(), intAccumulator(), merger(), finisher().andThen(finisher));
     }
 
@@ -83,7 +87,10 @@ public interface IntCollector<A, R> extends MergingCollector<Integer, A, R> {
      *        result, for the new collector
      * @return the new {@code IntCollector}
      */
-    static <R> IntCollector<R, R> of(Supplier<R> supplier, ObjIntConsumer<R> intAccumulator, BiConsumer<R, R> merger) {
+    static <R extends @Nullable Object> IntCollector<R, R> of(
+            Supplier<R> supplier,
+            ObjIntConsumer<R> intAccumulator,
+            BiConsumer<R, R> merger) {
         return new IntCollectorImpl<>(supplier, intAccumulator, merger, Function.identity(), ID_CHARACTERISTICS);
     }
 
@@ -97,7 +104,8 @@ public interface IntCollector<A, R> extends MergingCollector<Integer, A, R> {
      * @return an {@code IntCollector} which behaves in the same way as input
      *         collector.
      */
-    static <A, R> IntCollector<?, R> of(Collector<Integer, A, R> collector) {
+    static <A extends @Nullable Object, R extends @Nullable Object> IntCollector<?, R> of(
+            Collector<Integer, A, R> collector) {
         if (collector instanceof IntCollector) {
             return (IntCollector<A, R>) collector;
         }
@@ -117,7 +125,8 @@ public interface IntCollector<A, R> extends MergingCollector<Integer, A, R> {
      * @param <R> The final result type of the new collector
      * @return the new {@code IntCollector}
      */
-    static <A, R> IntCollector<A, R> of(Supplier<A> supplier, ObjIntConsumer<A> intAccumulator,
+    static <A extends @Nullable Object, R extends @Nullable Object> IntCollector<A, R> of(
+            Supplier<A> supplier, ObjIntConsumer<A> intAccumulator,
             BiConsumer<A, A> merger, Function<A, R> finisher) {
         return new IntCollectorImpl<>(supplier, intAccumulator, merger, finisher, NO_CHARACTERISTICS);
     }
@@ -239,7 +248,8 @@ public interface IntCollector<A, R> extends MergingCollector<Integer, A, R> {
      *         elements and provides the mapped results to the downstream
      *         collector
      */
-    static <A, R> IntCollector<?, R> mapping(IntUnaryOperator mapper, IntCollector<A, R> downstream) {
+    static <A extends @Nullable Object, R extends @Nullable Object> IntCollector<?, R> mapping(
+            IntUnaryOperator mapper, IntCollector<A, R> downstream) {
         ObjIntConsumer<A> downstreamAccumulator = downstream.intAccumulator();
         return new IntCollectorImpl<>(downstream.supplier(), (r, t) -> downstreamAccumulator.accept(r, mapper
                 .applyAsInt(t)), downstream.merger(), downstream.finisher(), downstream.characteristics());
@@ -259,7 +269,8 @@ public interface IntCollector<A, R> extends MergingCollector<Integer, A, R> {
      *         elements and provides the mapped results to the downstream
      *         collector
      */
-    static <U, A, R> IntCollector<?, R> mappingToObj(IntFunction<U> mapper, Collector<U, A, R> downstream) {
+    static <U extends @Nullable Object, A extends @Nullable Object, R extends @Nullable Object> IntCollector<?, R> mappingToObj(
+            IntFunction<U> mapper, Collector<U, A, R> downstream) {
         BiConsumer<A, U> accumulator = downstream.accumulator();
         if (downstream instanceof MergingCollector) {
             return new IntCollectorImpl<>(downstream.supplier(), (acc, i) -> accumulator.accept(acc, mapper.apply(i)),
@@ -357,7 +368,9 @@ public interface IntCollector<A, R> extends MergingCollector<Integer, A, R> {
      * @return an {@code IntCollector} implementing the cascaded partitioning
      *         operation
      */
-    static <A, D> IntCollector<?, Map<Boolean, D>> partitioningBy(IntPredicate predicate, IntCollector<A, D> downstream) {
+    static <A extends @Nullable Object, D extends @Nullable Object> IntCollector<?, Map<Boolean, D>> partitioningBy(
+            IntPredicate predicate, 
+            IntCollector<A, D> downstream) {
         ObjIntConsumer<A> downstreamAccumulator = downstream.intAccumulator();
         ObjIntConsumer<BooleanMap<A>> accumulator = (result, t) -> downstreamAccumulator.accept(
             predicate.test(t) ? result.trueValue : result.falseValue, t);
@@ -413,7 +426,8 @@ public interface IntCollector<A, R> extends MergingCollector<Integer, A, R> {
      * @return an {@code IntCollector} implementing the cascaded group-by
      *         operation
      */
-    static <K, D, A> IntCollector<?, Map<K, D>> groupingBy(IntFunction<? extends K> classifier,
+    static <K, D extends @Nullable Object, A extends @Nullable Object> IntCollector<?, Map<K, D>> groupingBy(
+            IntFunction<? extends K> classifier,
             IntCollector<A, D> downstream) {
         return groupingBy(classifier, HashMap::new, downstream);
     }
@@ -443,7 +457,8 @@ public interface IntCollector<A, R> extends MergingCollector<Integer, A, R> {
      * @return an {@code IntCollector} implementing the cascaded group-by
      *         operation
      */
-    static <K, D, A, M extends Map<K, D>> IntCollector<?, M> groupingBy(IntFunction<? extends K> classifier,
+    static <K, D extends @Nullable Object, A extends @Nullable Object, M extends Map<K, D>> IntCollector<?, M> groupingBy(
+            IntFunction<? extends K> classifier,
             Supplier<M> mapFactory, IntCollector<A, D> downstream) {
         Supplier<A> downstreamSupplier = downstream.supplier();
         Function<K, A> supplier = k -> downstreamSupplier.get();
diff --git a/src/main/java/one/util/streamex/IntStreamEx.java b/src/main/java/one/util/streamex/IntStreamEx.java
index d3b0083..ad0c9cb 100644
--- a/src/main/java/one/util/streamex/IntStreamEx.java
+++ b/src/main/java/one/util/streamex/IntStreamEx.java
@@ -15,6 +15,9 @@
  */
 package one.util.streamex;
 
+import org.jspecify.annotations.NullMarked;
+import org.jspecify.annotations.Nullable;
+
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.UncheckedIOException;
@@ -34,6 +37,7 @@ import static one.util.streamex.Internals.*;
  * 
  * @author Tagir Valeev
  */
+@NullMarked
 public final class IntStreamEx extends BaseStreamEx<Integer, IntStream, Spliterator.OfInt, IntStreamEx> implements IntStream {
     IntStreamEx(IntStream stream, StreamContext context) {
         super(stream, context);
@@ -237,7 +241,7 @@ public final class IntStreamEx extends BaseStreamEx<Integer, IntStream, Splitera
     }
 
     @Override
-    public <U> StreamEx<U> mapToObj(IntFunction<? extends U> mapper) {
+    public <U extends @Nullable Object> StreamEx<U> mapToObj(IntFunction<? extends U> mapper) {
         return new StreamEx<>(stream().mapToObj(mapper), context);
     }
 
@@ -268,14 +272,15 @@ public final class IntStreamEx extends BaseStreamEx<Integer, IntStream, Splitera
      * @return the new stream
      * @since 0.3.1
      */
-    public <K, V> EntryStream<K, V> mapToEntry(IntFunction<? extends K> keyMapper,
+    public <K extends @Nullable Object, 
+            V extends @Nullable Object> EntryStream<K, V> mapToEntry(IntFunction<? extends K> keyMapper,
             IntFunction<? extends V> valueMapper) {
         return new EntryStream<>(stream().mapToObj(t -> new AbstractMap.SimpleImmutableEntry<>(keyMapper.apply(t),
                 valueMapper.apply(t))), context);
     }
 
     @Override
-    public IntStreamEx flatMap(IntFunction<? extends IntStream> mapper) {
+    public IntStreamEx flatMap(IntFunction<? extends @Nullable IntStream> mapper) {
         return new IntStreamEx(stream().flatMap(mapper), context);
     }
 
@@ -294,7 +299,7 @@ public final class IntStreamEx extends BaseStreamEx<Integer, IntStream, Splitera
      * @return the new stream
      * @since 0.3.0
      */
-    public LongStreamEx flatMapToLong(IntFunction<? extends LongStream> mapper) {
+    public LongStreamEx flatMapToLong(IntFunction<? extends @Nullable LongStream> mapper) {
         return new LongStreamEx(stream().mapToObj(mapper).flatMapToLong(Function.identity()), context);
     }
 
@@ -313,7 +318,7 @@ public final class IntStreamEx extends BaseStreamEx<Integer, IntStream, Splitera
      * @return the new stream
      * @since 0.3.0
      */
-    public DoubleStreamEx flatMapToDouble(IntFunction<? extends DoubleStream> mapper) {
+    public DoubleStreamEx flatMapToDouble(IntFunction<? extends @Nullable DoubleStream> mapper) {
         return new DoubleStreamEx(stream().mapToObj(mapper).flatMapToDouble(Function.identity()), context);
     }
 
@@ -333,7 +338,7 @@ public final class IntStreamEx extends BaseStreamEx<Integer, IntStream, Splitera
      * @return the new stream
      * @since 0.3.0
      */
-    public <R> StreamEx<R> flatMapToObj(IntFunction<? extends Stream<R>> mapper) {
+    public <R extends @Nullable Object> StreamEx<R> flatMapToObj(IntFunction<? extends @Nullable Stream<R>> mapper) {
         return new StreamEx<>(stream().mapToObj(mapper).flatMap(Function.identity()), context);
     }
 
@@ -902,7 +907,7 @@ public final class IntStreamEx extends BaseStreamEx<Integer, IntStream, Splitera
      * @see #collect(IntCollector)
      */
     @Override
-    public <R> R collect(Supplier<R> supplier, ObjIntConsumer<R> accumulator, BiConsumer<R, R> combiner) {
+    public <R extends @Nullable Object> R collect(Supplier<R> supplier, ObjIntConsumer<R> accumulator, BiConsumer<R, R> combiner) {
         if (context.fjp != null)
             return context.terminate(() -> stream().collect(supplier, accumulator, combiner));
         return stream().collect(supplier, accumulator, combiner);
@@ -929,7 +934,7 @@ public final class IntStreamEx extends BaseStreamEx<Integer, IntStream, Splitera
      * @since 0.3.0
      */
     @SuppressWarnings("unchecked")
-    public <A, R> R collect(IntCollector<A, R> collector) {
+    public <A extends @Nullable Object, R extends @Nullable Object> R collect(IntCollector<A, R> collector) {
         if (collector.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH))
             return (R) collect(collector.supplier(), collector.intAccumulator(), collector.merger());
         return collector.finisher().apply(collect(collector.supplier(), collector.intAccumulator(), collector
@@ -1467,7 +1472,7 @@ public final class IntStreamEx extends BaseStreamEx<Integer, IntStream, Splitera
      * @return the new stream
      * @since 0.1.2
      */
-    public <U> StreamEx<U> elements(U[] array) {
+    public <U extends @Nullable Object> StreamEx<U> elements(U[] array) {
         return mapToObj(idx -> array[idx]);
     }
 
@@ -1489,7 +1494,7 @@ public final class IntStreamEx extends BaseStreamEx<Integer, IntStream, Splitera
      * @return the new stream
      * @since 0.1.2
      */
-    public <U> StreamEx<U> elements(List<U> list) {
+    public <U extends @Nullable Object> StreamEx<U> elements(List<U> list) {
         return mapToObj(list::get);
     }
 
@@ -1783,7 +1788,7 @@ public final class IntStreamEx extends BaseStreamEx<Integer, IntStream, Splitera
     // Necessary to generate proper JavaDoc
     // does not add overhead as it appears in bytecode anyways as bridge method
     @Override
-    public <U> U chain(Function<? super IntStreamEx, U> mapper) {
+    public <U extends @Nullable Object> U chain(Function<? super IntStreamEx, U> mapper) {
         return mapper.apply(this);
     }
 
@@ -2020,13 +2025,12 @@ public final class IntStreamEx extends BaseStreamEx<Integer, IntStream, Splitera
      * Returns a sequential ordered {@code IntStreamEx} containing all the
      * indices of the supplied list.
      *
-     * @param <T> list element type
      * @param list list to get the stream of its indices
      * @return a sequential {@code IntStreamEx} for the range of {@code int}
      *         elements starting from 0 to (not inclusive) list.size()
      * @since 0.1.1
      */
-    public static <T> IntStreamEx ofIndices(List<T> list) {
+    public static IntStreamEx ofIndices(List<?> list) {
         return range(list.size());
     }
 
@@ -2045,7 +2049,7 @@ public final class IntStreamEx extends BaseStreamEx<Integer, IntStream, Splitera
      * @return a sequential {@code IntStreamEx} of the matched list indices
      * @since 0.1.1
      */
-    public static <T> IntStreamEx ofIndices(List<T> list, Predicate<T> predicate) {
+    public static <T extends @Nullable Object> IntStreamEx ofIndices(List<T> list, Predicate<? super T> predicate) {
         return seq(IntStream.range(0, list.size()).filter(i -> predicate.test(list.get(i))));
     }
 
@@ -2053,13 +2057,12 @@ public final class IntStreamEx extends BaseStreamEx<Integer, IntStream, Splitera
      * Returns a sequential ordered {@code IntStreamEx} containing all the
      * indices of the supplied array.
      *
-     * @param <T> array element type
      * @param array array to get the stream of its indices
      * @return a sequential {@code IntStreamEx} for the range of {@code int}
      *         elements starting from 0 to (not inclusive) array.length
      * @since 0.1.1
      */
-    public static <T> IntStreamEx ofIndices(T[] array) {
+    public static IntStreamEx ofIndices(@Nullable Object[] array) {
         return range(array.length);
     }
 
@@ -2073,7 +2076,7 @@ public final class IntStreamEx extends BaseStreamEx<Integer, IntStream, Splitera
      * @return a sequential {@code IntStreamEx} of the matched array indices
      * @since 0.1.1
      */
-    public static <T> IntStreamEx ofIndices(T[] array, Predicate<T> predicate) {
+    public static <T extends @Nullable Object> IntStreamEx ofIndices(T[] array, Predicate<? super T> predicate) {
         return seq(IntStream.range(0, array.length).filter(i -> predicate.test(array[i])));
     }
 
@@ -2695,7 +2698,7 @@ public final class IntStreamEx extends BaseStreamEx<Integer, IntStream, Splitera
          * @param action consumer to be called to emit elements
          * @return next emitter or null
          */
-        IntEmitter next(IntConsumer action);
+        @Nullable IntEmitter next(IntConsumer action);
 
         /**
          * Returns the spliterator which covers all the elements emitted by this
diff --git a/src/main/java/one/util/streamex/Joining.java b/src/main/java/one/util/streamex/Joining.java
index eb19e27..c93f399 100644
--- a/src/main/java/one/util/streamex/Joining.java
+++ b/src/main/java/one/util/streamex/Joining.java
@@ -15,6 +15,8 @@
  */
 package one.util.streamex;
 
+import org.jspecify.annotations.NullMarked;
+
 import java.text.BreakIterator;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -70,6 +72,7 @@ import static one.util.streamex.Internals.checkNonNegative;
  * @author Tagir Valeev
  * @since 0.4.1
  */
+@NullMarked
 public class Joining extends CancellableCollector<CharSequence, Joining.Accumulator, String> {
     static final class Accumulator {
         final List<CharSequence> data = new ArrayList<>();
diff --git a/src/main/java/one/util/streamex/LongCollector.java b/src/main/java/one/util/streamex/LongCollector.java
index 691671d..6e7b78d 100644
--- a/src/main/java/one/util/streamex/LongCollector.java
+++ b/src/main/java/one/util/streamex/LongCollector.java
@@ -15,6 +15,9 @@
  */
 package one.util.streamex;
 
+import org.jspecify.annotations.NullMarked;
+import org.jspecify.annotations.Nullable;
+
 import java.util.*;
 import java.util.function.*;
 import java.util.stream.Collector;
@@ -34,7 +37,8 @@ import static one.util.streamex.Internals.*;
  * @see LongStreamEx#collect(LongCollector)
  * @since 0.3.0
  */
-public interface LongCollector<A, R> extends MergingCollector<Long, A, R> {
+@NullMarked
+public interface LongCollector<A extends @Nullable Object, R extends @Nullable Object> extends MergingCollector<Long, A, R> {
     /**
      * A function that folds a value into a mutable result container.
      *
@@ -66,7 +70,7 @@ public interface LongCollector<A, R> extends MergingCollector<Long, A, R> {
      *         by an additional finishing step
      * @since 0.3.7
      */
-    default <RR> LongCollector<A, RR> andThen(Function<R, RR> finisher) {
+    default <RR extends @Nullable Object> LongCollector<A, RR> andThen(Function<R, RR> finisher) {
         return of(supplier(), longAccumulator(), merger(), finisher().andThen(finisher));
     }
 
@@ -83,7 +87,10 @@ public interface LongCollector<A, R> extends MergingCollector<Long, A, R> {
      *        result, for the new collector
      * @return the new {@code LongCollector}
      */
-    static <R> LongCollector<R, R> of(Supplier<R> supplier, ObjLongConsumer<R> longAccumulator, BiConsumer<R, R> merger) {
+    static <R extends @Nullable Object> LongCollector<R, R> of(
+            Supplier<R> supplier, 
+            ObjLongConsumer<R> longAccumulator, 
+            BiConsumer<R, R> merger) {
         return new LongCollectorImpl<>(supplier, longAccumulator, merger, Function.identity(), ID_CHARACTERISTICS);
     }
 
@@ -97,7 +104,8 @@ public interface LongCollector<A, R> extends MergingCollector<Long, A, R> {
      * @return a {@code LongCollector} which behaves in the same way as input
      *         collector.
      */
-    static <A, R> LongCollector<?, R> of(Collector<Long, A, R> collector) {
+    static <A extends @Nullable Object, R extends @Nullable Object> LongCollector<?, R> of(
+            Collector<Long, A, R> collector) {
         if (collector instanceof LongCollector) {
             return (LongCollector<A, R>) collector;
         }
@@ -117,7 +125,8 @@ public interface LongCollector<A, R> extends MergingCollector<Long, A, R> {
      * @param <R> The final result type of the new collector
      * @return the new {@code LongCollector}
      */
-    static <A, R> LongCollector<A, R> of(Supplier<A> supplier, ObjLongConsumer<A> longAccumulator,
+    static <A extends @Nullable Object, R extends @Nullable Object> LongCollector<A, R> of(
+            Supplier<A> supplier, ObjLongConsumer<A> longAccumulator,
             BiConsumer<A, A> merger, Function<A, R> finisher) {
         return new LongCollectorImpl<>(supplier, longAccumulator, merger, finisher, NO_CHARACTERISTICS);
     }
@@ -239,7 +248,8 @@ public interface LongCollector<A, R> extends MergingCollector<Long, A, R> {
      *         elements and provides the mapped results to the downstream
      *         collector
      */
-    static <A, R> LongCollector<?, R> mapping(LongUnaryOperator mapper, LongCollector<A, R> downstream) {
+    static <A extends @Nullable Object, R extends @Nullable Object> LongCollector<?, R> mapping(
+            LongUnaryOperator mapper, LongCollector<A, R> downstream) {
         ObjLongConsumer<A> downstreamAccumulator = downstream.longAccumulator();
         return new LongCollectorImpl<>(downstream.supplier(), (r, t) -> downstreamAccumulator.accept(r, mapper
                 .applyAsLong(t)), downstream.merger(), downstream.finisher(), downstream.characteristics());
@@ -259,7 +269,8 @@ public interface LongCollector<A, R> extends MergingCollector<Long, A, R> {
      *         elements and provides the mapped results to the downstream
      *         collector
      */
-    static <U, A, R> LongCollector<?, R> mappingToObj(LongFunction<U> mapper, Collector<U, A, R> downstream) {
+    static <U extends @Nullable Object, A extends @Nullable Object, R extends @Nullable Object> LongCollector<?, R> mappingToObj(
+            LongFunction<U> mapper, Collector<U, A, R> downstream) {
         BiConsumer<A, U> accumulator = downstream.accumulator();
         if (downstream instanceof MergingCollector) {
             return new LongCollectorImpl<>(downstream.supplier(), (acc, i) -> accumulator.accept(acc, mapper.apply(i)),
@@ -357,7 +368,8 @@ public interface LongCollector<A, R> extends MergingCollector<Long, A, R> {
      * @return a {@code LongCollector} implementing the cascaded partitioning
      *         operation
      */
-    static <A, D> LongCollector<?, Map<Boolean, D>> partitioningBy(LongPredicate predicate,
+    static <A extends @Nullable Object, D extends @Nullable Object> LongCollector<?, Map<Boolean, D>> partitioningBy(
+            LongPredicate predicate,
             LongCollector<A, D> downstream) {
         ObjLongConsumer<A> downstreamAccumulator = downstream.longAccumulator();
         ObjLongConsumer<BooleanMap<A>> accumulator = (result, t) -> downstreamAccumulator.accept(
@@ -414,7 +426,8 @@ public interface LongCollector<A, R> extends MergingCollector<Long, A, R> {
      * @return a {@code LongCollector} implementing the cascaded group-by
      *         operation
      */
-    static <K, D, A> LongCollector<?, Map<K, D>> groupingBy(LongFunction<? extends K> classifier,
+    static <K, D extends @Nullable Object, A extends @Nullable Object> LongCollector<?, Map<K, D>> groupingBy(
+            LongFunction<? extends K> classifier,
             LongCollector<A, D> downstream) {
         return groupingBy(classifier, HashMap::new, downstream);
     }
@@ -444,7 +457,8 @@ public interface LongCollector<A, R> extends MergingCollector<Long, A, R> {
      * @return a {@code LongCollector} implementing the cascaded group-by
      *         operation
      */
-    static <K, D, A, M extends Map<K, D>> LongCollector<?, M> groupingBy(LongFunction<? extends K> classifier,
+    static <K, D extends @Nullable Object, A extends @Nullable Object, M extends Map<K, D>> LongCollector<?, M> groupingBy(
+            LongFunction<? extends K> classifier,
             Supplier<M> mapFactory, LongCollector<A, D> downstream) {
         Supplier<A> downstreamSupplier = downstream.supplier();
         Function<K, A> supplier = k -> downstreamSupplier.get();
diff --git a/src/main/java/one/util/streamex/LongStreamEx.java b/src/main/java/one/util/streamex/LongStreamEx.java
index af232ad..2ca3cc4 100644
--- a/src/main/java/one/util/streamex/LongStreamEx.java
+++ b/src/main/java/one/util/streamex/LongStreamEx.java
@@ -15,6 +15,9 @@
  */
 package one.util.streamex;
 
+import org.jspecify.annotations.NullMarked;
+import org.jspecify.annotations.Nullable;
+
 import java.nio.Buffer;
 import java.util.*;
 import java.util.Map.Entry;
@@ -30,6 +33,7 @@ import static one.util.streamex.Internals.*;
  * 
  * @author Tagir Valeev
  */
+@NullMarked
 public final class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterator.OfLong, LongStreamEx> implements
         LongStream {
     LongStreamEx(LongStream stream, StreamContext context) {
@@ -261,7 +265,7 @@ public final class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterat
     }
 
     @Override
-    public <U> StreamEx<U> mapToObj(LongFunction<? extends U> mapper) {
+    public <U extends @Nullable Object> StreamEx<U> mapToObj(LongFunction<? extends U> mapper) {
         return new StreamEx<>(stream().mapToObj(mapper), context);
     }
 
@@ -292,14 +296,16 @@ public final class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterat
      * @return the new stream
      * @since 0.3.1
      */
-    public <K, V> EntryStream<K, V> mapToEntry(LongFunction<? extends K> keyMapper,
+    public <K extends @Nullable Object,
+            V extends @Nullable Object> EntryStream<K, V> mapToEntry(
+            LongFunction<? extends K> keyMapper,
             LongFunction<? extends V> valueMapper) {
         return new EntryStream<>(stream().mapToObj(t -> new AbstractMap.SimpleImmutableEntry<>(keyMapper.apply(t),
                 valueMapper.apply(t))), context);
     }
 
     @Override
-    public LongStreamEx flatMap(LongFunction<? extends LongStream> mapper) {
+    public LongStreamEx flatMap(LongFunction<? extends @Nullable LongStream> mapper) {
         return new LongStreamEx(stream().flatMap(mapper), context);
     }
 
@@ -318,7 +324,7 @@ public final class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterat
      * @return the new stream
      * @since 0.3.0
      */
-    public IntStreamEx flatMapToInt(LongFunction<? extends IntStream> mapper) {
+    public IntStreamEx flatMapToInt(LongFunction<? extends @Nullable IntStream> mapper) {
         return new IntStreamEx(stream().mapToObj(mapper).flatMapToInt(Function.identity()), context);
     }
 
@@ -337,7 +343,7 @@ public final class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterat
      * @return the new stream
      * @since 0.3.0
      */
-    public DoubleStreamEx flatMapToDouble(LongFunction<? extends DoubleStream> mapper) {
+    public DoubleStreamEx flatMapToDouble(LongFunction<? extends @Nullable DoubleStream> mapper) {
         return new DoubleStreamEx(stream().mapToObj(mapper).flatMapToDouble(Function.identity()), context);
     }
 
@@ -357,7 +363,7 @@ public final class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterat
      * @return the new stream
      * @since 0.3.0
      */
-    public <R> StreamEx<R> flatMapToObj(LongFunction<? extends Stream<R>> mapper) {
+    public <R extends @Nullable Object> StreamEx<R> flatMapToObj(LongFunction<? extends @Nullable Stream<R>> mapper) {
         return new StreamEx<>(stream().mapToObj(mapper).flatMap(Function.identity()), context);
     }
 
@@ -829,7 +835,7 @@ public final class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterat
      * @see #collect(LongCollector)
      */
     @Override
-    public <R> R collect(Supplier<R> supplier, ObjLongConsumer<R> accumulator, BiConsumer<R, R> combiner) {
+    public <R extends @Nullable Object> R collect(Supplier<R> supplier, ObjLongConsumer<R> accumulator, BiConsumer<R, R> combiner) {
         if (context.fjp != null)
             return context.terminate(() -> stream().collect(supplier, accumulator, combiner));
         return stream().collect(supplier, accumulator, combiner);
@@ -858,7 +864,7 @@ public final class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterat
      * @since 0.3.0
      */
     @SuppressWarnings("unchecked")
-    public <A, R> R collect(LongCollector<A, R> collector) {
+    public <A extends @Nullable Object, R extends @Nullable Object> R collect(LongCollector<A, R> collector) {
         if (collector.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH))
             return (R) collect(collector.supplier(), collector.longAccumulator(), collector.merger());
         return collector.finisher().apply(collect(collector.supplier(), collector.longAccumulator(), collector
@@ -1552,7 +1558,7 @@ public final class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterat
     // Necessary to generate proper JavaDoc
     // does not add overhead as it appears in bytecode anyways as bridge method
     @Override
-    public <U> U chain(Function<? super LongStreamEx, U> mapper) {
+    public <U extends @Nullable Object> U chain(Function<? super LongStreamEx, U> mapper) {
         return mapper.apply(this);
     }
 
@@ -2123,7 +2129,7 @@ public final class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterat
          * @param action consumer to be called to emit elements
          * @return next emitter or null
          */
-        LongEmitter next(LongConsumer action);
+        @Nullable LongEmitter next(LongConsumer action);
 
         /**
          * Returns the spliterator which covers all the elements emitted by this
diff --git a/src/main/java/one/util/streamex/MoreCollectors.java b/src/main/java/one/util/streamex/MoreCollectors.java
index e25f372..b130e7a 100644
--- a/src/main/java/one/util/streamex/MoreCollectors.java
+++ b/src/main/java/one/util/streamex/MoreCollectors.java
@@ -15,6 +15,9 @@
  */
 package one.util.streamex;
 
+import org.jspecify.annotations.NullMarked;
+import org.jspecify.annotations.Nullable;
+
 import java.util.*;
 import java.util.Map.Entry;
 import java.util.function.*;
@@ -34,6 +37,7 @@ import static one.util.streamex.Internals.*;
  * @see Joining
  * @since 0.3.2
  */
+@NullMarked
 public final class MoreCollectors {
     private MoreCollectors() {
         throw new UnsupportedOperationException();
@@ -49,15 +53,16 @@ public final class MoreCollectors {
      * @return a {@code Collector} which just ignores the input and calls the
      *         provided supplier once to return the output.
      */
-    private static <T, U> Collector<T, ?, U> empty(Supplier<U> supplier) {
+    private static <T extends @Nullable Object, U extends @Nullable Object> Collector<T, ?, U> empty(
+            Supplier<U> supplier) {
         return new CancellableCollectorImpl<>(() -> NONE, (acc, t) -> {
             // empty
         }, selectFirst(), acc -> supplier.get(), alwaysTrue(), EnumSet.of(Characteristics.UNORDERED,
             Characteristics.CONCURRENT));
     }
 
-    private static <T> Collector<T, ?, List<T>> empty() {
-        return empty(ArrayList<T>::new);
+    private static <T extends @Nullable Object> Collector<T, ?, List<T>> empty() {
+        return empty(ArrayList::new);
     }
 
     /**
@@ -76,7 +81,7 @@ public final class MoreCollectors {
      *         array, in encounter order
      * @throws NullPointerException if generator is null.
      */
-    public static <T> Collector<T, ?, T[]> toArray(IntFunction<T[]> generator) {
+    public static <T extends @Nullable Object> Collector<T, ?, T[]> toArray(IntFunction<T[]> generator) {
         Objects.requireNonNull(generator);
         return Collectors.collectingAndThen(Collectors.toList(), list -> list.toArray(generator.apply(list.size())));
     }
@@ -95,7 +100,7 @@ public final class MoreCollectors {
      * @throws NullPointerException if predicate is null.
      * @since 0.3.8
      */
-    public static <T> Collector<T, ?, boolean[]> toBooleanArray(Predicate<T> predicate) {
+    public static <T extends @Nullable Object> Collector<T, ?, boolean[]> toBooleanArray(Predicate<? super T> predicate) {
         Objects.requireNonNull(predicate);
         return PartialCollector.booleanArray().asRef((box, t) -> {
             if (predicate.test(t))
@@ -149,7 +154,7 @@ public final class MoreCollectors {
      * @see Collectors#toMap(Function, Function)
      * @since 0.7.3
      */
-    public static <K, V> Collector<Entry<? extends K, ? extends V>, ?, Map<K, V>> entriesToMap() {
+    public static <K extends @Nullable Object, V extends @Nullable Object> Collector<Entry<? extends K, ? extends V>, ?, Map<K, V>> entriesToMap() {
         return entriesToCustomMap(HashMap::new);
     }
 
@@ -182,7 +187,7 @@ public final class MoreCollectors {
      * @see Collectors#toMap(Function, Function, BinaryOperator)
      * @since 0.7.3
      */
-    public static <K, V> Collector<Entry<? extends K, ? extends V>, ?, Map<K, V>> entriesToMap(
+    public static <K extends @Nullable Object, V extends @Nullable Object> Collector<Entry<? extends K, ? extends V>, ?, Map<K, V>> entriesToMap(
             BinaryOperator<V> combiner) {
         return entriesToCustomMap(combiner, HashMap::new);
     }
@@ -208,7 +213,10 @@ public final class MoreCollectors {
      * @see Collector#of(Supplier, BiConsumer, BinaryOperator, Collector.Characteristics...)
      * @since 0.7.3
      */
-    public static <K, V, M extends Map<K, V>> Collector<Entry<? extends K, ? extends V>, ?, M> entriesToCustomMap(
+    public static <
+            K extends @Nullable Object,
+            V extends @Nullable Object,
+            M extends Map<K, V>> Collector<Entry<? extends K, ? extends V>, ?, M> entriesToCustomMap(
             Supplier<M> mapSupplier) {
         return Collector.of(mapSupplier,
                 (m, entry) -> addToMap(m, entry.getKey(), Objects.requireNonNull(entry.getValue())),
@@ -246,7 +254,10 @@ public final class MoreCollectors {
      * @see Collectors#toMap(Function, Function, BinaryOperator, Supplier)
      * @since 0.7.3
      */
-    public static <K, V, M extends Map<K, V>> Collector<Entry<? extends K, ? extends V>, ?, M> entriesToCustomMap(
+    public static <
+            K extends @Nullable Object,
+            V extends @Nullable Object,
+            M extends Map<K, V>> Collector<Entry<? extends K, ? extends V>, ?, M> entriesToCustomMap(
             BinaryOperator<V> combiner, Supplier<M> mapSupplier) {
         Objects.requireNonNull(combiner);
         Objects.requireNonNull(mapSupplier);
@@ -268,7 +279,7 @@ public final class MoreCollectors {
      *         function returns for the stream elements.
      * @throws NullPointerException if mapper is null.
      */
-    public static <T> Collector<T, ?, Integer> distinctCount(Function<? super T, ?> mapper) {
+    public static <T extends @Nullable Object> Collector<T, ?, Integer> distinctCount(Function<? super T, ?> mapper) {
         Objects.requireNonNull(mapper);
         return Collectors.collectingAndThen(Collectors.mapping(mapper, Collectors.toSet()), Set::size);
     }
@@ -296,7 +307,7 @@ public final class MoreCollectors {
      * @throws NullPointerException if mapper is null.
      * @since 0.3.8
      */
-    public static <T> Collector<T, ?, List<T>> distinctBy(Function<? super T, ?> mapper) {
+    public static <T extends @Nullable Object> Collector<T, ?, List<T>> distinctBy(Function<? super T, ?> mapper) {
         Objects.requireNonNull(mapper);
         return Collector.<T, Map<Object, T>, List<T>>of(LinkedHashMap::new, (map, t) -> map.putIfAbsent(mapper.apply(
             t), t), (m1, m2) -> {
@@ -317,7 +328,7 @@ public final class MoreCollectors {
      * @since 0.3.3
      * @see Collectors#counting()
      */
-    public static <T> Collector<T, ?, Integer> countingInt() {
+    public static <T extends @Nullable Object> Collector<T, ?, Integer> countingInt() {
         return PartialCollector.intSum().asRef((acc, t) -> acc[0]++);
     }
 
@@ -351,8 +362,16 @@ public final class MoreCollectors {
      *         collectors.
      * @throws NullPointerException if c1 is null, or c2 is null, or finisher is null.
      */
-    public static <T, A1, A2, R1, R2, R> Collector<T, ?, R> pairing(Collector<? super T, A1, R1> c1,
-            Collector<? super T, A2, R2> c2, BiFunction<? super R1, ? super R2, ? extends R> finisher) {
+    public static <
+            T extends @Nullable Object,
+            A1 extends @Nullable Object,
+            A2 extends @Nullable Object,
+            R1 extends @Nullable Object,
+            R2 extends @Nullable Object,
+            R extends @Nullable Object> Collector<T, ?, R> pairing(
+            Collector<? super T, A1, R1> c1,
+            Collector<? super T, A2, R2> c2,
+            BiFunction<? super R1, ? super R2, ? extends R> finisher) {
         Objects.requireNonNull(finisher);
         EnumSet<Characteristics> c = EnumSet.noneOf(Characteristics.class);
         c.addAll(c1.characteristics());
@@ -415,7 +434,7 @@ public final class MoreCollectors {
      * @throws NullPointerException if comparator is null, finisher is null,
      * or finisher returns null.
      */
-    public static <T, R> Collector<T, ?, Optional<R>> minMax(Comparator<? super T> comparator,
+    public static <T extends @Nullable Object, R> Collector<T, ?, Optional<R>> minMax(Comparator<? super T> comparator,
             BiFunction<? super T, ? super T, ? extends R> finisher) {
         Objects.requireNonNull(finisher);
         return pairing(Collectors.minBy(comparator), Collectors.maxBy(comparator),
@@ -440,7 +459,11 @@ public final class MoreCollectors {
      * @see #maxAll(Collector)
      * @see #maxAll()
      */
-    public static <T, A, D> Collector<T, ?, D> maxAll(Comparator<? super T> comparator,
+    public static <
+            T extends @Nullable Object,
+            A extends @Nullable Object,
+            D extends @Nullable Object> Collector<T, ?, D> maxAll(
+            Comparator<? super T> comparator,
             Collector<? super T, A, D> downstream) {
         Objects.requireNonNull(comparator);
         Supplier<A> downstreamSupplier = downstream.supplier();
@@ -496,7 +519,7 @@ public final class MoreCollectors {
      * @see #maxAll(Comparator, Collector)
      * @see #maxAll()
      */
-    public static <T> Collector<T, ?, List<T>> maxAll(Comparator<? super T> comparator) {
+    public static <T extends @Nullable Object> Collector<T, ?, List<T>> maxAll(Comparator<? super T> comparator) {
         return maxAll(comparator, Collectors.toList());
     }
 
@@ -517,7 +540,10 @@ public final class MoreCollectors {
      * @see #maxAll(Comparator)
      * @see #maxAll()
      */
-    public static <T extends Comparable<? super T>, A, D> Collector<T, ?, D> maxAll(Collector<T, A, D> downstream) {
+    public static <
+            T extends Comparable<? super T>,
+            A extends @Nullable Object,
+            D extends @Nullable Object> Collector<T, ?, D> maxAll(Collector<T, A, D> downstream) {
         return maxAll(Comparator.<T>naturalOrder(), downstream);
     }
 
@@ -533,7 +559,7 @@ public final class MoreCollectors {
      * @see #maxAll(Collector)
      */
     public static <T extends Comparable<? super T>> Collector<T, ?, List<T>> maxAll() {
-        return maxAll(Comparator.<T>naturalOrder(), Collectors.toList());
+        return maxAll(Comparator.naturalOrder(), Collectors.toList());
     }
 
     /**
@@ -554,7 +580,11 @@ public final class MoreCollectors {
      * @see #minAll(Collector)
      * @see #minAll()
      */
-    public static <T, A, D> Collector<T, ?, D> minAll(Comparator<? super T> comparator, Collector<T, A, D> downstream) {
+    public static <
+            T extends @Nullable Object,
+            A extends @Nullable Object,
+            D extends @Nullable Object> Collector<T, ?, D> minAll(
+            Comparator<? super T> comparator, Collector<T, A, D> downstream) {
         return maxAll(comparator.reversed(), downstream);
     }
 
@@ -572,7 +602,7 @@ public final class MoreCollectors {
      * @see #minAll(Comparator, Collector)
      * @see #minAll()
      */
-    public static <T> Collector<T, ?, List<T>> minAll(Comparator<? super T> comparator) {
+    public static <T extends @Nullable Object> Collector<T, ?, List<T>> minAll(Comparator<? super T> comparator) {
         return maxAll(comparator.reversed(), Collectors.toList());
     }
 
@@ -593,7 +623,9 @@ public final class MoreCollectors {
      * @see #minAll(Comparator)
      * @see #minAll()
      */
-    public static <T extends Comparable<? super T>, A, D> Collector<T, ?, D> minAll(Collector<T, A, D> downstream) {
+    public static <T extends Comparable<? super T>,
+            A extends @Nullable Object,
+            D extends @Nullable Object> Collector<T, ?, D> minAll(Collector<T, A, D> downstream) {
         return maxAll(Comparator.<T>reverseOrder(), downstream);
     }
 
@@ -609,7 +641,7 @@ public final class MoreCollectors {
      * @see #minAll(Collector)
      */
     public static <T extends Comparable<? super T>> Collector<T, ?, List<T>> minAll() {
-        return maxAll(Comparator.<T>reverseOrder(), Collectors.toList());
+        return maxAll(Comparator.reverseOrder(), Collectors.toList());
     }
 
     /**
@@ -722,7 +754,7 @@ public final class MoreCollectors {
      * @return a collector which returns a {@code List} containing the first n
      *         stream elements or less if the stream was shorter.
      */
-    public static <T> Collector<T, ?, List<T>> head(int n) {
+    public static <T extends @Nullable Object> Collector<T, ?, List<T>> head(int n) {
         if (n <= 0)
             return empty();
         return new CancellableCollectorImpl<>(ArrayList::new, (acc, t) -> {
@@ -752,7 +784,7 @@ public final class MoreCollectors {
      * @return a collector which returns a {@code List} containing the last n
      *         stream elements or less if the stream was shorter.
      */
-    public static <T> Collector<T, ?, List<T>> tail(int n) {
+    public static <T extends @Nullable Object> Collector<T, ?, List<T>> tail(int n) {
         if (n <= 0)
             return empty();
         return Collector.<T, Deque<T>, List<T>>of(ArrayDeque::new, (acc, t) -> {
@@ -796,7 +828,7 @@ public final class MoreCollectors {
      *         n stream elements or less if the stream was shorter.
      * @throws NullPointerException if comparator is null.
      */
-    public static <T> Collector<T, ?, List<T>> greatest(Comparator<? super T> comparator, int n) {
+    public static <T extends @Nullable Object> Collector<T, ?, List<T>> greatest(Comparator<? super T> comparator, int n) {
         return least(comparator.reversed(), n);
     }
 
@@ -828,7 +860,7 @@ public final class MoreCollectors {
      *         n stream elements or less if the stream was shorter.
      */
     public static <T extends Comparable<? super T>> Collector<T, ?, List<T>> greatest(int n) {
-        return least(Comparator.<T>reverseOrder(), n);
+        return least(Comparator.reverseOrder(), n);
     }
 
     /**
@@ -860,7 +892,7 @@ public final class MoreCollectors {
      *         stream elements or less if the stream was shorter.
      * @throws NullPointerException if comparator is null.
      */
-    public static <T> Collector<T, ?, List<T>> least(Comparator<? super T> comparator, int n) {
+    public static <T extends @Nullable Object> Collector<T, ?, List<T>> least(Comparator<? super T> comparator, int n) {
         Objects.requireNonNull(comparator);
         if (n <= 0)
             return empty();
@@ -913,7 +945,7 @@ public final class MoreCollectors {
      *         stream elements or less if the stream was shorter.
      */
     public static <T extends Comparable<? super T>> Collector<T, ?, List<T>> least(int n) {
-        return least(Comparator.<T>naturalOrder(), n);
+        return least(Comparator.naturalOrder(), n);
     }
 
     /**
@@ -928,7 +960,7 @@ public final class MoreCollectors {
      * @see #minIndex()
      * @since 0.3.5
      */
-    public static <T> Collector<T, ?, OptionalLong> minIndex(Comparator<? super T> comparator) {
+    public static <T extends @Nullable Object> Collector<T, ?, OptionalLong> minIndex(Comparator<? super T> comparator) {
         Objects.requireNonNull(comparator);
         class Container {
             T value;
@@ -979,7 +1011,7 @@ public final class MoreCollectors {
      * @see #maxIndex()
      * @since 0.3.5
      */
-    public static <T> Collector<T, ?, OptionalLong> maxIndex(Comparator<? super T> comparator) {
+    public static <T extends @Nullable Object> Collector<T, ?, OptionalLong> maxIndex(Comparator<? super T> comparator) {
         return minIndex(comparator.reversed());
     }
 
@@ -1033,8 +1065,14 @@ public final class MoreCollectors {
      * @see #groupingBy(Function, Set, Supplier, Collector)
      * @since 0.3.7
      */
-    public static <T, K extends Enum<K>, A, D> Collector<T, ?, EnumMap<K, D>> groupingByEnum(Class<K> enumClass,
-            Function<? super T, K> classifier, Collector<? super T, A, D> downstream) {
+    public static <
+            T extends @Nullable Object,
+            K extends Enum<K>,
+            A extends @Nullable Object,
+            D extends @Nullable Object> Collector<T, ?, EnumMap<K, D>> groupingByEnum(
+            Class<K> enumClass,
+            Function<? super T, K> classifier,
+            Collector<? super T, A, D> downstream) {
         return groupingBy(classifier, EnumSet.allOf(enumClass), () -> new EnumMap<>(enumClass), downstream);
     }
 
@@ -1082,7 +1120,11 @@ public final class MoreCollectors {
      * @see #groupingByEnum(Class, Function, Collector)
      * @since 0.4.0
      */
-    public static <T, K, D, A> Collector<T, ?, Map<K, D>> groupingBy(Function<? super T, ? extends K> classifier,
+    public static <
+            T extends @Nullable Object,
+            K,
+            D extends @Nullable Object,
+            A extends @Nullable Object> Collector<T, ?, Map<K, D>> groupingBy(Function<? super T, ? extends K> classifier,
             Set<K> domain, Collector<? super T, A, D> downstream) {
         return groupingBy(classifier, domain, HashMap::new, downstream);
     }
@@ -1131,8 +1173,15 @@ public final class MoreCollectors {
      * @see #groupingByEnum(Class, Function, Collector)
      * @since 0.4.0
      */
-    public static <T, K, D, A, M extends Map<K, D>> Collector<T, ?, M> groupingBy(
-            Function<? super T, ? extends K> classifier, Set<K> domain, Supplier<M> mapFactory,
+    public static <
+            T extends @Nullable Object,
+            K,
+            D extends @Nullable Object,
+            A extends @Nullable Object,
+            M extends Map<K, D>> Collector<T, ?, M> groupingBy(
+            Function<? super T, ? extends K> classifier,
+            Set<K> domain,
+            Supplier<M> mapFactory,
             Collector<? super T, A, D> downstream) {
         Objects.requireNonNull(classifier);
         Objects.requireNonNull(domain);
@@ -1197,7 +1246,7 @@ public final class MoreCollectors {
      *         collects them to the {@code List}.
      * @since 0.4.0
      */
-    public static <T, S extends Collection<T>> Collector<S, ?, Set<T>> intersecting() {
+    public static <T extends @Nullable Object, S extends Collection<T>> Collector<S, ?, Set<T>> intersecting() {
         return new CancellableCollectorImpl<S, Box<Set<T>>, Set<T>>(Box::new, (b, t) -> {
             if (b.a == null) {
                 b.a = new HashSet<>(t);
@@ -1237,7 +1286,11 @@ public final class MoreCollectors {
      * @see Collectors#collectingAndThen(Collector, Function)
      * @since 0.4.0
      */
-    public static <T, A, R, RR> Collector<T, A, RR> collectingAndThen(Collector<T, A, R> downstream,
+    public static <
+            T extends @Nullable Object,
+            A extends @Nullable Object,
+            R extends @Nullable Object,
+            RR extends @Nullable Object> Collector<T, A, RR> collectingAndThen(Collector<T, A, R> downstream,
             Function<R, RR> finisher) {
         Predicate<A> finished = finished(downstream);
         if (finished != null) {
@@ -1273,7 +1326,10 @@ public final class MoreCollectors {
      * @since 0.4.0
      * @see Collectors#partitioningBy(Predicate, Collector)
      */
-    public static <T, D, A> Collector<T, ?, Map<Boolean, D>> partitioningBy(Predicate<? super T> predicate,
+    public static <
+            T extends @Nullable Object,
+            D extends @Nullable Object,
+            A extends @Nullable Object> Collector<T, ?, Map<Boolean, D>> partitioningBy(Predicate<? super T> predicate,
             Collector<? super T, A, D> downstream) {
         Objects.requireNonNull(predicate);
         Predicate<A> finished = finished(downstream);
@@ -1310,7 +1366,11 @@ public final class MoreCollectors {
      * @see Collectors#mapping(Function, Collector)
      * @since 0.4.0
      */
-    public static <T, U, A, R> Collector<T, ?, R> mapping(Function<? super T, ? extends U> mapper,
+    public static <
+            T extends @Nullable Object,
+            U extends @Nullable Object,
+            A extends @Nullable Object,
+            R extends @Nullable Object> Collector<T, ?, R> mapping(Function<? super T, ? extends U> mapper,
             Collector<? super U, A, R> downstream) {
         Objects.requireNonNull(mapper);
         Predicate<A> finished = finished(downstream);
@@ -1345,7 +1405,9 @@ public final class MoreCollectors {
      * @see #mapping(Function, Collector)
      * @since 0.6.0
      */
-    public static <T, U> Collector<T, ?, List<U>> mapping(Function<? super T, ? extends U> mapper) {
+    public static <
+            T extends @Nullable Object,
+            U extends @Nullable Object> Collector<T, ?, List<U>> mapping(Function<? super T, ? extends U> mapper) {
         return Collectors.mapping(mapper, Collectors.toList());
     }
 
@@ -1379,7 +1441,12 @@ public final class MoreCollectors {
      * @throws NullPointerException if mapper is null, or downstream is null.
      * @since 0.4.1
      */
-    public static <T, U, A, R> Collector<T, ?, R> flatMapping(Function<? super T, ? extends Stream<? extends U>> mapper,
+    public static <
+            T extends @Nullable Object,
+            U extends @Nullable Object,
+            A extends @Nullable Object,
+            R extends @Nullable Object> Collector<T, ?, R> flatMapping(
+            Function<? super T, ? extends @Nullable Stream<? extends U>> mapper,
             Collector<? super U, A, R> downstream) {
         Objects.requireNonNull(mapper);
         BiConsumer<A, ? super U> downstreamAccumulator = downstream.accumulator();
@@ -1435,8 +1502,8 @@ public final class MoreCollectors {
      * @throws NullPointerException if mapper is null.
      * @since 0.6.0
      */
-    public static <T, U> Collector<T, ?, List<U>> flatMapping(
-            Function<? super T, ? extends Stream<? extends U>> mapper) {
+    public static <T extends @Nullable Object, U extends @Nullable Object> Collector<T, ?, List<U>> flatMapping(
+            Function<? super T, ? extends @Nullable Stream<? extends U>> mapper) {
         return flatMapping(mapper, Collectors.toList());
     }
 
@@ -1473,7 +1540,10 @@ public final class MoreCollectors {
      * @see #pairing(Collector, Collector, BiFunction)
      * @since 0.4.0
      */
-    public static <T, A, R> Collector<T, ?, R> filtering(Predicate<? super T> predicate,
+    public static <
+            T extends @Nullable Object, 
+            A extends @Nullable Object, 
+            R extends @Nullable Object> Collector<T, ?, R> filtering(Predicate<? super T> predicate,
             Collector<T, A, R> downstream) {
         Objects.requireNonNull(predicate);
         BiConsumer<A, T> downstreamAccumulator = downstream.accumulator();
@@ -1511,7 +1581,7 @@ public final class MoreCollectors {
      * @see #filtering(Predicate, Collector)
      * @since 0.6.0
      */
-    public static <T> Collector<T, ?, List<T>> filtering(Predicate<? super T> predicate) {
+    public static <T extends @Nullable Object> Collector<T, ?, List<T>> filtering(Predicate<? super T> predicate) {
         return filtering(predicate, Collectors.toList());
     }
 
@@ -1532,7 +1602,7 @@ public final class MoreCollectors {
      * @throws NullPointerException if mapper is null.
      * @since 0.4.0
      */
-    public static <T> Collector<T, ?, OptionalInt> andingInt(ToIntFunction<T> mapper) {
+    public static <T extends @Nullable Object> Collector<T, ?, OptionalInt> andingInt(ToIntFunction<T> mapper) {
         Objects.requireNonNull(mapper);
         return new CancellableCollectorImpl<>(PrimitiveBox::new, (acc, t) -> {
             if (!acc.b) {
@@ -1568,7 +1638,7 @@ public final class MoreCollectors {
      * @throws NullPointerException if mapper is null.
      * @since 0.4.0
      */
-    public static <T> Collector<T, ?, OptionalLong> andingLong(ToLongFunction<T> mapper) {
+    public static <T extends @Nullable Object> Collector<T, ?, OptionalLong> andingLong(ToLongFunction<T> mapper) {
         Objects.requireNonNull(mapper);
         return new CancellableCollectorImpl<>(PrimitiveBox::new, (acc, t) -> {
             if (!acc.b) {
@@ -1732,7 +1802,8 @@ public final class MoreCollectors {
      * @see StreamEx#collapse(BiPredicate)
      * @since 0.5.1
      */
-    public static <T> Collector<T, ?, List<T>> dominators(BiPredicate<? super T, ? super T> isDominator) {
+    public static <T extends @Nullable Object> Collector<T, ?, List<T>> dominators(
+            BiPredicate<? super T, ? super T> isDominator) {
         Objects.requireNonNull(isDominator);
         return Collector.of(ArrayList::new, (acc, t) -> {
             if (acc.isEmpty() || !isDominator.test(acc.get(acc.size() - 1), t))
@@ -1786,7 +1857,10 @@ public final class MoreCollectors {
      * @see AbstractStreamEx#takeWhile(Predicate)
      * @since 0.6.3
      */
-    public static <T, A, R> Collector<T, ?, Optional<R>> ifAllMatch(Predicate<T> predicate,
+    public static <
+            T extends @Nullable Object, 
+            A extends @Nullable Object, 
+            R> Collector<T, ?, Optional<R>> ifAllMatch(Predicate<T> predicate,
             Collector<T, A, R> downstream) {
         Objects.requireNonNull(predicate);
         Predicate<A> finished = finished(downstream);
@@ -1923,7 +1997,7 @@ public final class MoreCollectors {
      * @see Collectors#reducing(Object, BinaryOperator) 
      * @since 0.7.3
      */
-    public static <T> Collector<T, ?, T> reducingWithZero(T zero, T identity, BinaryOperator<T> op) {
+    public static <T extends @Nullable Object> Collector<T, ?, T> reducingWithZero(T zero, T identity, BinaryOperator<T> op) {
         Objects.requireNonNull(op);
         // acc.b: 1 = has element, 2 = zero reached
         return new CancellableCollectorImpl<>(
diff --git a/src/main/java/one/util/streamex/StreamContext.java b/src/main/java/one/util/streamex/StreamContext.java
index ce434ca..3bb7f99 100644
--- a/src/main/java/one/util/streamex/StreamContext.java
+++ b/src/main/java/one/util/streamex/StreamContext.java
@@ -15,6 +15,9 @@
  */
 package one.util.streamex;
 
+import org.jspecify.annotations.NullMarked;
+import org.jspecify.annotations.Nullable;
+
 import java.util.concurrent.ForkJoinPool;
 import java.util.function.Function;
 import java.util.function.Supplier;
@@ -36,13 +39,14 @@ import java.util.stream.BaseStream;
  * 
  * @author Tagir Valeev
  */
+@NullMarked
 /* package */class StreamContext {
     static final StreamContext SEQUENTIAL = new StreamContext(false);
     static final StreamContext PARALLEL = new StreamContext(true);
 
     boolean parallel;
-    ForkJoinPool fjp;
-    Runnable closeHandler;
+    @Nullable ForkJoinPool fjp;
+    @Nullable Runnable closeHandler;
 
     private StreamContext(boolean parallel) {
         this.parallel = parallel;
@@ -99,7 +103,7 @@ import java.util.stream.BaseStream;
         }
     }
 
-    static Runnable compose(Runnable r1, Runnable r2) {
+    static Runnable compose(@Nullable Runnable r1, Runnable r2) {
         if (r1 == null)
             return r2;
         return () -> {
@@ -117,7 +121,7 @@ import java.util.stream.BaseStream;
         };
     }
 
-    StreamContext combine(BaseStream<?, ?> other) {
+    StreamContext combine(@Nullable BaseStream<?, ?> other) {
         if (other == null)
             return this;
         StreamContext otherStrategy = of(other);
diff --git a/src/main/java/one/util/streamex/StreamEx.java b/src/main/java/one/util/streamex/StreamEx.java
index 118e052..8dffb41 100644
--- a/src/main/java/one/util/streamex/StreamEx.java
+++ b/src/main/java/one/util/streamex/StreamEx.java
@@ -15,6 +15,11 @@
  */
 package one.util.streamex;
 
+import org.jspecify.annotations.NonNull;
+import org.jspecify.annotations.NullMarked;
+import org.jspecify.annotations.NullUnmarked;
+import org.jspecify.annotations.Nullable;
+
 import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.Reader;
@@ -53,7 +58,8 @@ import static one.util.streamex.Internals.*;
  *
  * @param <T> the type of the stream elements
  */
-public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
+@NullMarked
+public final class StreamEx<T extends @Nullable Object> extends AbstractStreamEx<T, StreamEx<T>> {
 
     StreamEx(Stream<? extends T> stream, StreamContext context) {
         super(stream, context);
@@ -73,8 +79,9 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
         return new StreamEx<>(spliterator, context);
     }
 
-    private <R> StreamEx<R> collapseInternal(BiPredicate<? super T, ? super T> collapsible, Function<T, R> mapper,
-                                             BiFunction<R, T, R> accumulator, BinaryOperator<R> combiner) {
+    private <R extends @Nullable Object> StreamEx<R> collapseInternal(
+            BiPredicate<? super T, ? super T> collapsible, Function<T, R> mapper,
+            BiFunction<R, T, R> accumulator, BinaryOperator<R> combiner) {
         CollapseSpliterator<T, R> spliterator = new CollapseSpliterator<>(collapsible, mapper, accumulator, combiner,
                 spliterator());
         return new StreamEx<>(spliterator, context);
@@ -82,7 +89,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
 
     @SuppressWarnings("EmptyMethod")
     @Override
-    public StreamEx<T> nonNull() {
+    public StreamEx<@NonNull T> nonNull() {
         // this overload is useful to make Eclipse external Null annotations working
         return super.nonNull();
     }
@@ -127,7 +134,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @since 0.6.4
      * @see #filter(Predicate)
      */
-    public <K> StreamEx<T> filterBy(Function<? super T, ? extends K> mapper, K value) {
+    public <K extends @Nullable Object> StreamEx<T> filterBy(Function<? super T, ? extends K> mapper, K value) {
         return value == null ? filter(t -> mapper.apply(t) == null) : filter(t -> value.equals(mapper.apply(t)));
     }
 
@@ -155,7 +162,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @since 0.6.4
      * @see #remove(Predicate)
      */
-    public <K> StreamEx<T> removeBy(Function<? super T, ? extends K> mapper, K value) {
+    public <K extends @Nullable Object> StreamEx<T> removeBy(Function<? super T, ? extends K> mapper, K value) {
         return value == null ? filter(t -> mapper.apply(t) != null) : filter(t -> !value.equals(mapper.apply(t)));
     }
     
@@ -173,7 +180,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      *        element
      * @return the new stream
      */
-    public <V> EntryStream<T, V> mapToEntry(Function<? super T, ? extends V> valueMapper) {
+    public <V extends @Nullable Object> EntryStream<T, V> mapToEntry(Function<? super T, ? extends V> valueMapper) {
         return new EntryStream<>(stream().map(e -> new SimpleImmutableEntry<>(e, valueMapper.apply(e))), context);
     }
 
@@ -194,7 +201,8 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      *        element
      * @return the new stream
      */
-    public <K, V> EntryStream<K, V> mapToEntry(Function<? super T, ? extends K> keyMapper,
+    public <K extends @Nullable Object, V extends @Nullable Object> EntryStream<K, V> mapToEntry(
+            Function<? super T, ? extends K> keyMapper,
             Function<? super T, ? extends V> valueMapper) {
         return new EntryStream<>(stream()
                 .map(e -> new SimpleImmutableEntry<>(keyMapper.apply(e), valueMapper.apply(e))), context);
@@ -242,7 +250,8 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @since 0.6.0
      * @see #mapFirst(Function)
      */
-    public <R> StreamEx<R> mapFirstOrElse(Function<? super T, ? extends R> firstMapper,
+    public <R extends @Nullable Object> StreamEx<R> mapFirstOrElse(
+            Function<? super T, ? extends R> firstMapper,
             Function<? super T, ? extends R> notFirstMapper) {
         return new StreamEx<>(new PairSpliterator.PSOfRef<>(firstMapper, notFirstMapper, spliterator(), true), context);
     }
@@ -292,7 +301,8 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @since 0.6.0
      * @see #mapFirst(Function)
      */
-    public <R> StreamEx<R> mapLastOrElse(Function<? super T, ? extends R> notLastMapper,
+    public <R extends @Nullable Object> StreamEx<R> mapLastOrElse(
+            Function<? super T, ? extends R> notLastMapper,
             Function<? super T, ? extends R> lastMapper) {
         return new StreamEx<>(new PairSpliterator.PSOfRef<>(lastMapper, notLastMapper, spliterator(), false), context);
     }
@@ -387,7 +397,8 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      *        correspond to some element.
      * @return the new {@code EntryStream}
      */
-    public <K, V> EntryStream<K, V> flatMapToEntry(Function<? super T, ? extends Map<K, V>> mapper) {
+    public <K extends @Nullable Object, V extends @Nullable Object> EntryStream<K, V> flatMapToEntry(
+            Function<? super T, ? extends @Nullable Map<K, V>> mapper) {
         return new EntryStream<>(stream().flatMap(e -> {
             Map<K, V> s = mapper.apply(e);
             return s == null ? null : s.entrySet().stream();
@@ -459,7 +470,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @since 0.2.3
      */
     @SuppressWarnings("unchecked")
-    public <V> EntryStream<T, V> cross(V... other) {
+    public <V extends @Nullable Object> EntryStream<T, V> cross(V... other) {
         if (other.length == 0)
             return new EntryStream<>(Spliterators.emptySpliterator(), context);
         if (other.length == 1)
@@ -487,7 +498,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @throws NullPointerException if other is null
      * @since 0.2.3
      */
-    public <V> EntryStream<T, V> cross(Collection<? extends V> other) {
+    public <V extends @Nullable Object> EntryStream<T, V> cross(Collection<? extends V> other) {
         if (other.isEmpty())
             return new EntryStream<>(Spliterators.emptySpliterator(), context);
         return cross(t -> of(other));
@@ -511,7 +522,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @return the new {@code EntryStream}
      * @since 0.2.3
      */
-    public <V> EntryStream<T, V> cross(Function<? super T, ? extends Stream<? extends V>> mapper) {
+    public <V extends @Nullable Object> EntryStream<T, V> cross(Function<? super T, ? extends Stream<? extends V>> mapper) {
         return new EntryStream<>(stream().flatMap(a -> EntryStream.withKey(a, mapper.apply(a))), context);
     }
 
@@ -537,7 +548,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see Collectors#groupingBy(Function)
      * @see Collectors#groupingByConcurrent(Function)
      */
-    public <K> Map<K, List<T>> groupingBy(Function<? super T, ? extends K> classifier) {
+    public <K extends @Nullable Object> Map<K, List<T>> groupingBy(Function<? super T, ? extends K> classifier) {
         return groupingBy(classifier, Collectors.toList());
     }
 
@@ -566,8 +577,9 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see Collectors#groupingBy(Function, Collector)
      * @see Collectors#groupingByConcurrent(Function, Collector)
      */
-    public <K, D> Map<K, D> groupingBy(Function<? super T, ? extends K> classifier,
-            Collector<? super T, ?, D> downstream) {
+    public <K extends @Nullable Object, D extends @Nullable Object> Map<K, D> groupingBy(
+            Function<? super T, ? extends K> classifier,
+            Collector<? super T, ? extends @Nullable Object, D> downstream) {
         if (isParallel() && downstream.characteristics().contains(Characteristics.UNORDERED))
             return rawCollect(Collectors.groupingByConcurrent(classifier, downstream));
         return rawCollect(Collectors.groupingBy(classifier, downstream));
@@ -601,7 +613,8 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see Collectors#groupingByConcurrent(Function, Supplier, Collector)
      */
     @SuppressWarnings("unchecked")
-    public <K, D, M extends Map<K, D>> M groupingBy(Function<? super T, ? extends K> classifier,
+    public <K extends @Nullable Object, D extends @Nullable Object, M extends Map<K, D>> M groupingBy(
+            Function<? super T, ? extends K> classifier,
             Supplier<M> mapFactory, Collector<? super T, ?, D> downstream) {
         if (isParallel() && downstream.characteristics().contains(Characteristics.UNORDERED)
             && mapFactory.get() instanceof ConcurrentMap)
@@ -638,7 +651,8 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see Collectors#groupingByConcurrent(Function, Collector)
      * @since 0.2.2
      */
-    public <K, C extends Collection<T>> Map<K, C> groupingTo(Function<? super T, ? extends K> classifier,
+    public <K extends @Nullable Object, C extends Collection<T>> Map<K, C> groupingTo(
+            Function<? super T, ? extends K> classifier,
             Supplier<C> collectionFactory) {
         return groupingBy(classifier, Collectors.toCollection(collectionFactory));
     }
@@ -673,7 +687,8 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see Collectors#groupingByConcurrent(Function, Supplier, Collector)
      * @since 0.2.2
      */
-    public <K, C extends Collection<T>, M extends Map<K, C>> M groupingTo(Function<? super T, ? extends K> classifier,
+    public <K extends @Nullable Object, C extends Collection<T>, M extends Map<K, C>> M groupingTo(
+            Function<? super T, ? extends K> classifier,
             Supplier<M> mapFactory, Supplier<C> collectionFactory) {
         return groupingBy(classifier, mapFactory, Collectors.toCollection(collectionFactory));
     }
@@ -733,7 +748,8 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see Collectors#partitioningBy(Predicate, Collector)
      * @since 0.2.2
      */
-    public <D> Map<Boolean, D> partitioningBy(Predicate<? super T> predicate, Collector<? super T, ?, D> downstream) {
+    public <D extends @Nullable Object> Map<Boolean, D> partitioningBy(
+            Predicate<? super T> predicate, Collector<? super T, ?, D> downstream) {
         return collect(MoreCollectors.partitioningBy(predicate, downstream));
     }
 
@@ -842,7 +858,8 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @since 0.6.3
      */
     @SuppressWarnings("unchecked")
-    public <A> A[] toArray(Class<A> elementClass) {
+    @NullUnmarked // may return nulls inside the array
+    public <A> A @NonNull [] toArray(@NonNull Class<A> elementClass) {
         return stream().toArray(size -> (A[]) Array.newInstance(elementClass, size));
     }
 
@@ -872,7 +889,8 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @since 0.6.3
      */
     @SuppressWarnings("unchecked")
-    public <A> A[] toArray(A[] emptyArray) {
+    @NullUnmarked // may return nulls inside the array
+    public <A> A @NonNull [] toArray(A @NonNull [] emptyArray) {
         if (emptyArray.length != 0) {
             throw new IllegalArgumentException("Empty array must be supplied");
         }
@@ -905,7 +923,8 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @return the new collection.
      * @since 0.3.7
      */
-    public <U, C extends Collection<U>> C toFlatCollection(Function<? super T, ? extends Collection<U>> mapper,
+    public <U extends @Nullable Object, C extends Collection<U>> C toFlatCollection(
+            Function<? super T, ? extends Collection<U>> mapper,
             Supplier<C> supplier) {
         return map(mapper).collect(supplier, Collection::addAll, Collection::addAll);
     }
@@ -935,7 +954,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @return the new list.
      * @since 0.3.7
      */
-    public <U> List<U> toFlatList(Function<? super T, ? extends Collection<U>> mapper) {
+    public <U extends @Nullable Object> List<U> toFlatList(Function<? super T, ? extends Collection<U>> mapper) {
         return toFlatCollection(mapper, ArrayList::new);
     }
 
@@ -968,7 +987,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see Collectors#toConcurrentMap(Function, Function)
      * @see #toMap(Function, Function)
      */
-    public <V> Map<T, V> toMap(Function<? super T, ? extends V> valMapper) {
+    public <V extends @Nullable Object> Map<T, V> toMap(Function<? super T, ? extends V> valMapper) {
         return toMap(Function.identity(), valMapper);
     }
 
@@ -1000,7 +1019,9 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see #toMap(Function)
      * @see #valuesToMap(Function)
      */
-    public <K, V> Map<K, V> toMap(Function<? super T, ? extends K> keyMapper, Function<? super T, ? extends V> valMapper) {
+    public <K extends @Nullable Object, V extends @Nullable Object> Map<K, V> toMap(
+            Function<? super T, ? extends K> keyMapper, 
+            Function<? super T, ? extends V> valMapper) {
         Map<K, V> map = isParallel() ? new ConcurrentHashMap<>() : new HashMap<>();
         return toMapThrowing(keyMapper, valMapper, map);
     }
@@ -1039,7 +1060,8 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see #toMap(Function, Function)
      * @since 0.1.0
      */
-    public <K, V> Map<K, V> toMap(Function<? super T, ? extends K> keyMapper,
+    public <K extends @Nullable Object, V extends @Nullable Object> Map<K, V> toMap(
+            Function<? super T, ? extends K> keyMapper,
             Function<? super T, ? extends V> valMapper, BinaryOperator<V> mergeFunction) {
         return rawCollect(Collectors.toMap(keyMapper, valMapper, mergeFunction, HashMap::new));
     }
@@ -1070,7 +1092,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see #toMap(Function, Function)
      * @since 0.8.0
      */
-    public <K> Map<K, T> valuesToMap(Function<? super T, ? extends K> keyMapper) {
+    public <K extends @Nullable Object> Map<K, T> valuesToMap(Function<? super T, ? extends K> keyMapper) {
         return toMap(keyMapper, Function.identity());
     }
 
@@ -1144,7 +1166,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see #toNavigableMap(Function)
      * @since 0.1.0
      */
-    public <V> SortedMap<T, V> toSortedMap(Function<? super T, ? extends V> valMapper) {
+    public <V extends @Nullable Object> SortedMap<T, V> toSortedMap(Function<? super T, ? extends V> valMapper) {
         return toSortedMap(Function.identity(), valMapper);
     }
 
@@ -1181,7 +1203,8 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see #toNavigableMap(Function, Function)
      * @since 0.1.0
      */
-    public <K, V> SortedMap<K, V> toSortedMap(Function<? super T, ? extends K> keyMapper,
+    public <K extends @Nullable Object, V extends @Nullable Object> SortedMap<K, V> toSortedMap(
+            Function<? super T, ? extends K> keyMapper,
             Function<? super T, ? extends V> valMapper) {
         SortedMap<K, V> map = isParallel() ? new ConcurrentSkipListMap<>() : new TreeMap<>();
         return toMapThrowing(keyMapper, valMapper, map);
@@ -1221,7 +1244,8 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see #toNavigableMap(Function, Function, BinaryOperator)
      * @since 0.1.0
      */
-    public <K, V> SortedMap<K, V> toSortedMap(Function<? super T, ? extends K> keyMapper,
+    public <K extends @Nullable Object, V extends @Nullable Object> SortedMap<K, V> toSortedMap(
+            Function<? super T, ? extends K> keyMapper,
             Function<? super T, ? extends V> valMapper, BinaryOperator<V> mergeFunction) {
         return rawCollect(Collectors.toMap(keyMapper, valMapper, mergeFunction, TreeMap::new));
     }
@@ -1254,7 +1278,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see #toSortedMap(Function, Function)
      * @since 0.8.0
      */
-    public <K> SortedMap<K, T> valuesToSortedMap(Function<? super T, ? extends K> keyMapper) {
+    public <K extends @Nullable Object> SortedMap<K, T> valuesToSortedMap(Function<? super T, ? extends K> keyMapper) {
         return toSortedMap(keyMapper, Function.identity());
     }
 
@@ -1293,7 +1317,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see #toNavigableMap(Function, Function)
      * @since 0.6.5
      */
-    public <V> NavigableMap<T, V> toNavigableMap(Function<? super T, ? extends V> valMapper) {
+    public <V extends @Nullable Object> NavigableMap<T, V> toNavigableMap(Function<? super T, ? extends V> valMapper) {
         return toNavigableMap(Function.identity(), valMapper);
     }
     
@@ -1329,7 +1353,8 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see #valuesToNavigableMap(Function) 
      * @since 0.6.5
      */
-    public <K, V> NavigableMap<K, V> toNavigableMap(Function<? super T, ? extends K> keyMapper,
+    public <K extends @Nullable Object, V extends @Nullable Object> NavigableMap<K, V> toNavigableMap(
+            Function<? super T, ? extends K> keyMapper,
             Function<? super T, ? extends V> valMapper) {
         NavigableMap<K, V> map = isParallel() ? new ConcurrentSkipListMap<>() : new TreeMap<>();
         return toMapThrowing(keyMapper, valMapper, map);
@@ -1369,7 +1394,8 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see #toNavigableMap(Function, Function)
      * @since 0.6.5
      */
-    public <K, V> NavigableMap<K, V> toNavigableMap(Function<? super T, ? extends K> keyMapper,
+    public <K extends @Nullable Object, V extends @Nullable Object> NavigableMap<K, V> toNavigableMap(
+            Function<? super T, ? extends K> keyMapper,
             Function<? super T, ? extends V> valMapper, BinaryOperator<V> mergeFunction) {
         return rawCollect(Collectors.toMap(keyMapper, valMapper, mergeFunction, TreeMap::new));
     }
@@ -1403,7 +1429,8 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see #toNavigableMap(Function, Function) 
      * @since 0.8.0
      */
-    public <K> NavigableMap<K, T> valuesToNavigableMap(Function<? super T, ? extends K> keyMapper) {
+    public <K extends @Nullable Object> NavigableMap<K, T> valuesToNavigableMap(
+            Function<? super T, ? extends K> keyMapper) {
         return toNavigableMap(keyMapper, Function.identity());
     }
 
@@ -1543,14 +1570,14 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * This is a short-circuiting <a
      * href="package-summary.html#StreamOps">terminal</a> operation.
      * 
-     * @param value the value to look for in the stream. If the value is null
+     * @param value the value to look for in the stream. If the value is null, 
      *        then the method will return true if this stream contains at least
      *        one null. Otherwise {@code value.equals()} will be called to
      *        compare stream elements with the value.
      * @return true if this stream contains the specified value
      * @see Stream#anyMatch(Predicate)
      */
-    public boolean has(T value) {
+    public boolean has(@Nullable T value) {
         return anyMatch(Predicate.isEqual(value));
     }
 
@@ -1571,7 +1598,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see #without(Object...)
      * @see #remove(Predicate)
      */
-    public StreamEx<T> without(T value) {
+    public StreamEx<T> without(@Nullable T value) {
         if (value == null)
             return filter(Objects::nonNull);
         return remove(value::equals);
@@ -1608,7 +1635,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see #remove(Predicate)
      */
     @SafeVarargs
-    public final StreamEx<T> without(T... values) {
+    public final StreamEx<T> without(@Nullable T... values) {
         if (values.length == 0)
             return this;
         if (values.length == 1)
@@ -1709,7 +1736,8 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @return the new stream
      * @since 0.3.6
      */
-    public <R, A> StreamEx<R> collapse(BiPredicate<? super T, ? super T> collapsible,
+    public <R extends @Nullable Object, A extends @Nullable Object> StreamEx<R> collapse(
+            BiPredicate<? super T, ? super T> collapsible,
             Collector<? super T, A, R> collector) {
         Supplier<A> supplier = collector.supplier();
         BiConsumer<A, ? super T> accumulator = collector.accumulator();
@@ -1862,7 +1890,8 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see #groupRuns(BiPredicate)
      * @since 0.3.3
      */
-    public <U> StreamEx<U> intervalMap(BiPredicate<? super T, ? super T> sameInterval,
+    public <U extends @Nullable Object> StreamEx<U> intervalMap(
+            BiPredicate<? super T, ? super T> sameInterval,
             BiFunction<? super T, ? super T, ? extends U> mapper) {
         return collapseInternal(sameInterval, PairBox::single, (box, t) -> {
             box.b = t;
@@ -1874,7 +1903,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
     }
 
     /**
-     * Returns a stream consisting of the results of applying the given function
+     * Returns a stream consisting of the results of applying the given bi-function
      * to the first element and every single element of this stream.
      * When the mapper is called for the first element of the resulting stream,
      * both its arguments are the same and equal to the first element of this stream.
@@ -1895,7 +1924,8 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see #headTail(BiFunction)
      * @since 0.5.3
      */
-    public <R> StreamEx<R> withFirst(BiFunction<? super T, ? super T, ? extends R> mapper) {
+    public <R extends @Nullable Object> StreamEx<R> withFirst(
+            BiFunction<? super T, ? super T, ? extends R> mapper) {
         WithFirstSpliterator<T, R> spliterator = new WithFirstSpliterator<>(spliterator(), mapper);
         return new StreamEx<>(spliterator, context);
     }
@@ -1960,7 +1990,8 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @since 0.5.5
      * @see #zipWith(Stream)
      */
-    public <V, R> StreamEx<R> zipWith(Stream<V> other, BiFunction<? super T, ? super V, ? extends R> mapper) {
+    public <V extends @Nullable Object, R extends @Nullable Object> StreamEx<R> zipWith(
+            Stream<V> other, BiFunction<? super T, ? super V, ? extends R> mapper) {
         return zipWith((BaseStream<V, ?>) other, mapper);
     }
 
@@ -1999,7 +2030,8 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @since 0.6.7
      * @see #zipWith(BaseStream)
      */
-    public <V, R> StreamEx<R> zipWith(BaseStream<V, ?> other, BiFunction<? super T, ? super V, ? extends R> mapper) {
+    public <V extends @Nullable Object, R extends @Nullable Object> StreamEx<R> zipWith(
+            BaseStream<V, ?> other, BiFunction<? super T, ? super V, ? extends R> mapper) {
         return new StreamEx<>(new ZipSpliterator<>(spliterator(), other.spliterator(), mapper, true), context
                 .combine(other));
     }
@@ -2036,7 +2068,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see #zipWith(Stream, BiFunction)
      * @since 0.5.5
      */
-    public <V> EntryStream<T, V> zipWith(Stream<V> other) {
+    public <V extends @Nullable Object> EntryStream<T, V> zipWith(Stream<V> other) {
         return zipWith((BaseStream<V, ?>) other);
     }
 
@@ -2072,7 +2104,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see #zipWith(BaseStream, BiFunction)
      * @since 0.6.7
      */
-    public <V> EntryStream<T, V> zipWith(BaseStream<V, ?> other) {
+    public <V extends @Nullable Object> EntryStream<T, V> zipWith(BaseStream<V, ?> other) {
         return new EntryStream<>(new ZipSpliterator<>(spliterator(), other.spliterator(),
                 SimpleImmutableEntry::new, true), context.combine(other));
     }
@@ -2126,7 +2158,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see #withFirst()
      * @since 0.5.3
      */
-    public <R> StreamEx<R> headTail(BiFunction<? super T, ? super StreamEx<T>, ? extends Stream<R>> mapper) {
+    public <R extends @Nullable Object> StreamEx<R> headTail(BiFunction<? super T, ? super StreamEx<T>, ? extends @Nullable Stream<R>> mapper) {
         return headTail(mapper, () -> null);
     }
 
@@ -2187,8 +2219,9 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see #headTail(BiFunction)
      * @since 0.5.3
      */
-    public <R> StreamEx<R> headTail(BiFunction<? super T, ? super StreamEx<T>, ? extends Stream<R>> mapper,
-            Supplier<? extends Stream<R>> supplier) {
+    public <R extends @Nullable Object> StreamEx<R> headTail(
+            BiFunction<? super T, ? super StreamEx<T>, ? extends @Nullable Stream<R>> mapper,
+            Supplier<? extends @Nullable Stream<R>> supplier) {
         HeadTailSpliterator<T, R> spliterator = new HeadTailSpliterator<>(spliterator(), mapper, supplier);
         spliterator.context = context = context.detach();
         return new StreamEx<>(spliterator, context);
@@ -2200,7 +2233,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @param <T> the type of stream elements
      * @return an empty sequential stream
      */
-    public static <T> StreamEx<T> empty() {
+    public static <T extends @Nullable Object> StreamEx<T> empty() {
         return of(Spliterators.emptySpliterator());
     }
 
@@ -2212,7 +2245,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @return a singleton sequential stream
      * @see Stream#of(Object)
      */
-    public static <T> StreamEx<T> of(T element) {
+    public static <T extends @Nullable Object> StreamEx<T> of(T element) {
         return of(new ConstSpliterator.OfRef<>(element, 1, true));
     }
 
@@ -2226,7 +2259,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see Stream#of(Object...)
      */
     @SafeVarargs
-    public static <T> StreamEx<T> of(T... elements) {
+    public static <T extends @Nullable Object> StreamEx<T> of(T... elements) {
         return of(Arrays.spliterator(elements));
     }
 
@@ -2246,7 +2279,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @since 0.1.1
      * @see Arrays#stream(Object[], int, int)
      */
-    public static <T> StreamEx<T> of(T[] array, int startInclusive, int endExclusive) {
+    public static <T extends @Nullable Object> StreamEx<T> of(T[] array, int startInclusive, int endExclusive) {
         return of(Arrays.spliterator(array, startInclusive, endExclusive));
     }
 
@@ -2260,7 +2293,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      *         collection
      * @see Collection#stream()
      */
-    public static <T> StreamEx<T> of(Collection<? extends T> collection) {
+    public static <T extends @Nullable Object> StreamEx<T> of(Collection<? extends T> collection) {
         return of(collection.spliterator());
     }
 
@@ -2277,7 +2310,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @param list list to get the elements from
      * @return the new stream
      */
-    public static <T> StreamEx<T> ofReversed(List<? extends T> list) {
+    public static <T extends @Nullable Object> StreamEx<T> ofReversed(List<? extends T> list) {
         int size = list.size();
         return IntStreamEx.ofIndices(list).mapToObj(idx -> list.get(size - idx - 1));
     }
@@ -2290,7 +2323,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @param array array to get the elements from
      * @return the new stream
      */
-    public static <T> StreamEx<T> ofReversed(T[] array) {
+    public static <T extends @Nullable Object> StreamEx<T> ofReversed(T[] array) {
         int size = array.length;
         return IntStreamEx.ofIndices(array).mapToObj(idx -> array[size - idx - 1]);
     }
@@ -2307,7 +2340,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @param stream original stream
      * @return the wrapped stream
      */
-    public static <T> StreamEx<T> of(Stream<T> stream) {
+    public static <T extends @Nullable Object> StreamEx<T> of(Stream<T> stream) {
         if (stream instanceof AbstractStreamEx) {
             AbstractStreamEx<T, ?> ase = (AbstractStreamEx<T, ?>) stream;
             if (ase.spliterator != null)
@@ -2326,7 +2359,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @return the new stream
      * @since 0.3.4
      */
-    public static <T> StreamEx<T> of(Spliterator<? extends T> spliterator) {
+    public static <T extends @Nullable Object> StreamEx<T> of(Spliterator<? extends T> spliterator) {
         return new StreamEx<>(spliterator, StreamContext.SEQUENTIAL);
     }
 
@@ -2348,7 +2381,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @return the new stream
      * @since 0.5.1
      */
-    public static <T> StreamEx<T> of(Iterator<? extends T> iterator) {
+    public static <T extends @Nullable Object> StreamEx<T> of(Iterator<? extends T> iterator) {
         return of(new UnknownSizeSpliterator.USOfRef<>(iterator));
     }
 
@@ -2365,7 +2398,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @return the new stream
      * @since 0.5.1
      */
-    public static <T> StreamEx<T> of(Enumeration<? extends T> enumeration) {
+    public static <T extends @Nullable Object> StreamEx<T> of(Enumeration<? extends T> enumeration) {
         return of(new Iterator<T>() {
             @Override
             public boolean hasNext() {
@@ -2403,7 +2436,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      *         non-null, otherwise an empty stream
      * @since 0.1.1
      */
-    public static <T> StreamEx<T> ofNullable(T element) {
+    public static <T extends @Nullable Object> StreamEx<@NonNull T> ofNullable(T element) {
         return element == null ? empty() : of(element);
     }
 
@@ -2548,7 +2581,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @throws NullPointerException if map is null
      * @see Map#keySet()
      */
-    public static <T> StreamEx<T> ofKeys(Map<T, ?> map) {
+    public static <T extends @Nullable Object> StreamEx<T> ofKeys(Map<T, ? extends @Nullable Object> map) {
         return of(map.keySet().spliterator());
     }
 
@@ -2565,7 +2598,8 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @throws NullPointerException if map is null
      * @see Map#keySet()
      */
-    public static <T, V> StreamEx<T> ofKeys(Map<T, V> map, Predicate<? super V> valueFilter) {
+    public static <T extends @Nullable Object, V extends @Nullable Object> StreamEx<T> ofKeys(
+            Map<T, V> map, Predicate<? super V> valueFilter) {
         return EntryStream.of(map).filterValues(valueFilter).keys();
     }
 
@@ -2580,7 +2614,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @throws NullPointerException if map is null
      * @see Map#values()
      */
-    public static <T> StreamEx<T> ofValues(Map<?, T> map) {
+    public static <T extends @Nullable Object> StreamEx<T> ofValues(Map<? extends @Nullable Object, T> map) {
         return of(map.values().spliterator());
     }
 
@@ -2597,7 +2631,8 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @throws NullPointerException if map is null
      * @see Map#values()
      */
-    public static <K, T> StreamEx<T> ofValues(Map<K, T> map, Predicate<? super K> keyFilter) {
+    public static <K extends @Nullable Object, T extends @Nullable Object> StreamEx<T> ofValues(
+            Map<K, T> map, Predicate<? super K> keyFilter) {
         return EntryStream.of(map).filterKeys(keyFilter).values();
     }
 
@@ -2810,7 +2845,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @return a new sequential {@code StreamEx}
      * @see #iterate(Object, Predicate, UnaryOperator)
      */
-    public static <T> StreamEx<T> iterate(final T seed, final UnaryOperator<T> f) {
+    public static <T extends @Nullable Object> StreamEx<T> iterate(final T seed, final UnaryOperator<T> f) {
         return iterate(seed, alwaysTrue(), f);
     }
 
@@ -2847,7 +2882,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see #iterate(Object, UnaryOperator)
      * @since 0.6.0
      */
-    public static <T> StreamEx<T> iterate(T seed, Predicate<? super T> predicate, UnaryOperator<T> f) {
+    public static <T extends @Nullable Object> StreamEx<T> iterate(T seed, Predicate<? super T> predicate, UnaryOperator<T> f) {
         Objects.requireNonNull(f);
         Objects.requireNonNull(predicate);
         Spliterator<T> spliterator = new Spliterators.AbstractSpliterator<T>(Long.MAX_VALUE, Spliterator.ORDERED
@@ -2904,7 +2939,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see Stream#generate(Supplier)
      * @see EntryStream#generate(Supplier, Supplier)
      */
-    public static <T> StreamEx<T> generate(Supplier<T> s) {
+    public static <T extends @Nullable Object> StreamEx<T> generate(Supplier<T> s) {
         return new StreamEx<>(Stream.generate(s), StreamContext.SEQUENTIAL);
     }
 
@@ -2945,7 +2980,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @return the new stream
      * @since 0.6.0
      */
-    public static <T> StreamEx<T> produce(Predicate<Consumer<? super T>> producer) {
+    public static <T extends @Nullable Object> StreamEx<T> produce(Predicate<Consumer<? super T>> producer) {
         Box<Emitter<T>> box = new Box<>();
         return (box.a = action -> producer.test(action) ? box.a : null).stream();
     }
@@ -2960,7 +2995,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @return a new {@code StreamEx}
      * @since 0.1.2
      */
-    public static <T> StreamEx<T> constant(T value, long length) {
+    public static <T extends @Nullable Object> StreamEx<T> constant(T value, long length) {
         return of(new ConstSpliterator.OfRef<>(value, length, false));
     }
 
@@ -2993,7 +3028,8 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see EntryStream#ofPairs(List)
      * @since 0.3.6
      */
-    public static <U, T> StreamEx<T> ofPairs(List<U> list, BiFunction<? super U, ? super U, ? extends T> mapper) {
+    public static <U extends @Nullable Object, T extends @Nullable Object> StreamEx<T> ofPairs(
+            List<U> list, BiFunction<? super U, ? super U, ? extends T> mapper) {
         return of(new PairPermutationSpliterator<>(list, mapper));
     }
 
@@ -3021,7 +3057,8 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see EntryStream#ofPairs(Object[])
      * @since 0.3.6
      */
-    public static <U, T> StreamEx<T> ofPairs(U[] array, BiFunction<? super U, ? super U, ? extends T> mapper) {
+    public static <U extends @Nullable Object, T extends @Nullable Object> StreamEx<T> ofPairs(
+            U[] array, BiFunction<? super U, ? super U, ? extends T> mapper) {
         return ofPairs(Arrays.asList(array), mapper);
     }
 
@@ -3047,7 +3084,8 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see EntryStream#zip(List, List)
      * @since 0.2.1
      */
-    public static <U, V, T> StreamEx<T> zip(List<U> first, List<V> second,
+    public static <U extends @Nullable Object, V extends @Nullable Object, T extends @Nullable Object> StreamEx<T> zip(
+            List<U> first, List<V> second,
             BiFunction<? super U, ? super V, ? extends T> mapper) {
         return of(new RangeBasedSpliterator.ZipRef<>(0, checkLength(first.size(), second.size()), mapper, first, second));
     }
@@ -3069,7 +3107,8 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see EntryStream#zip(Object[], Object[])
      * @since 0.2.1
      */
-    public static <U, V, T> StreamEx<T> zip(U[] first, V[] second, BiFunction<? super U, ? super V, ? extends T> mapper) {
+    public static <U extends @Nullable Object, V extends @Nullable Object, T extends @Nullable Object> StreamEx<T> zip(
+            U[] first, V[] second, BiFunction<? super U, ? super V, ? extends T> mapper) {
         return zip(Arrays.asList(first), Arrays.asList(second), mapper);
     }
 
@@ -3095,7 +3134,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see EntryStream#ofTree(Object, BiFunction)
      * @see #ofTree(Object, Class, Function)
      */
-    public static <T> StreamEx<T> ofTree(T root, Function<T, Stream<T>> mapper) {
+    public static <T extends @Nullable Object> StreamEx<T> ofTree(T root, Function<T, @Nullable Stream<T>> mapper) {
         TreeSpliterator<T, T> spliterator = new TreeSpliterator.Plain<>(root, mapper);
         return new StreamEx<>(spliterator, StreamContext.SEQUENTIAL.onClose(spliterator));
     }
@@ -3125,7 +3164,8 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see #ofTree(Object, Function)
      */
     @SuppressWarnings("unchecked")
-    public static <T, TT extends T> StreamEx<T> ofTree(T root, Class<TT> collectionClass, Function<TT, Stream<T>> mapper) {
+    public static <T extends @Nullable Object, TT extends T> StreamEx<T> ofTree(
+            T root, Class<TT> collectionClass, Function<TT, @Nullable Stream<T>> mapper) {
         return ofTree(root, t -> collectionClass.isInstance(t) ? mapper.apply((TT) t) : null);
     }
 
@@ -3153,7 +3193,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see #ofSubLists(List, int, int)
      * @see List#subList(int, int)
      */
-    public static <T> StreamEx<List<T>> ofSubLists(List<T> source, int length) {
+    public static <T extends @Nullable Object> StreamEx<List<T>> ofSubLists(List<T> source, int length) {
         return ofSubLists(source, length, length);
     }
 
@@ -3185,7 +3225,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @since 0.3.7
      * @see List#subList(int, int)
      */
-    public static <T> StreamEx<List<T>> ofSubLists(List<T> source, int length, int shift) {
+    public static <T extends @Nullable Object> StreamEx<List<T>> ofSubLists(List<T> source, int length, int shift) {
         if (length <= 0)
             throw new IllegalArgumentException("length = " + length);
         if (shift <= 0)
@@ -3222,7 +3262,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see #cartesianPower(int, Collection)
      * @since 0.3.8
      */
-    public static <T> StreamEx<List<T>> cartesianProduct(Collection<? extends Collection<T>> source) {
+    public static <T extends @Nullable Object> StreamEx<List<T>> cartesianProduct(Collection<? extends Collection<T>> source) {
         if (source.isEmpty())
             return StreamEx.of(new ConstSpliterator.OfRef<>(Collections.emptyList(), 1, true));
         return of(new CrossSpliterator.ToList<>(source));
@@ -3270,7 +3310,8 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see #cartesianPower(int, Collection, Object, BiFunction)
      * @since 0.4.0
      */
-    public static <T, U> StreamEx<U> cartesianProduct(Collection<? extends Collection<T>> source, U identity,
+    public static <T extends @Nullable Object, U extends @Nullable Object> StreamEx<U> cartesianProduct(
+            Collection<? extends Collection<T>> source, U identity,
             BiFunction<U, ? super T, U> accumulator) {
         if (source.isEmpty())
             return of(identity);
@@ -3304,7 +3345,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see #cartesianProduct(Collection)
      * @since 0.3.8
      */
-    public static <T> StreamEx<List<T>> cartesianPower(int n, Collection<T> source) {
+    public static <T extends @Nullable Object> StreamEx<List<T>> cartesianPower(int n, Collection<T> source) {
         if (n == 0)
             return StreamEx.of(new ConstSpliterator.OfRef<>(Collections.emptyList(), 1, true));
         return of(new CrossSpliterator.ToList<>(Collections.nCopies(n, source)));
@@ -3354,7 +3395,8 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see #cartesianPower(int, Collection)
      * @since 0.4.0
      */
-    public static <T, U> StreamEx<U> cartesianPower(int n, Collection<T> source, U identity,
+    public static <T extends @Nullable Object, U extends @Nullable Object> StreamEx<U> cartesianPower(
+            int n, Collection<T> source, U identity,
             BiFunction<U, ? super T, U> accumulator) {
         if (n == 0)
             return of(identity);
@@ -3389,7 +3431,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @since 0.6.0
      */
     @FunctionalInterface
-    public interface Emitter<T> {
+    public interface Emitter<T extends @Nullable Object> {
         /**
          * Calls the supplied consumer zero or more times to emit some elements,
          * then returns the next emitter which will emit more, or null if
@@ -3409,7 +3451,7 @@ public final class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
          * @param action consumer to be called to emit elements
          * @return next emitter or null
          */
-        Emitter<T> next(Consumer<? super T> action);
+        @Nullable Emitter<T> next(Consumer<? super T> action);
 
         /**
          * Returns the spliterator which covers all the elements emitted by this
diff --git a/src/test/java/one/util/streamex/api/StreamExTest.java b/src/test/java/one/util/streamex/api/StreamExTest.java
index 1139b1a..dc0ab84 100644
--- a/src/test/java/one/util/streamex/api/StreamExTest.java
+++ b/src/test/java/one/util/streamex/api/StreamExTest.java
@@ -56,11 +56,11 @@ public class StreamExTest {
     @Test
     public void testCreate() {
         assertEquals(asList(), StreamEx.empty().toList());
-        // double test is intended
+        // a repeating test is intended: check that empty() is not a singleton and can be called twice
         assertEquals(asList(), StreamEx.empty().toList());
         assertEquals(asList("a"), StreamEx.of("a").toList());
         assertEquals(asList("a"), StreamEx.of(Optional.of("a")).toList());
-        assertEquals(asList(), StreamEx.of(Optional.ofNullable(null)).toList());
+        assertEquals(asList(), StreamEx.of(Optional.empty()).toList());
         assertEquals(asList(), StreamEx.ofNullable(null).toList());
         assertEquals(asList("a"), StreamEx.ofNullable("a").toList());
         assertEquals(asList((String) null), StreamEx.of((String) null).toList());
@@ -121,8 +121,6 @@ public class StreamExTest {
         String input = IntStreamEx.range(5000).joining("\n");
         List<String> expectedList = IntStreamEx.range(1, 5000).mapToObj(String::valueOf).toList();
         Set<String> expectedSet = IntStreamEx.range(1, 5000).mapToObj(String::valueOf).toSet();
-        // Saving actual to separate variable helps to work-around
-        // javac <8u40 issue JDK-8056984
         List<String> actualList = StreamEx.ofLines(new StringReader(input)).skip(1).parallel().toList();
         assertEquals(expectedList, actualList);
         actualList = StreamEx.ofLines(new StringReader(input)).pairMap((a, b) -> b).parallel().toList();
@@ -198,7 +196,7 @@ public class StreamExTest {
     @Test
     public void testToMutableList() {
         List<Integer> list = StreamEx.of(1, 2, 3).toMutableList();
-        // Test that returned list is mutable
+        // Test that the returned list is mutable
         List<Integer> list2 = StreamEx.of(4, 5, 6).parallel().toMutableList();
         list2.add(7);
         list.addAll(list2);
@@ -659,12 +657,6 @@ public class StreamExTest {
         List<String> input = asList("a", "bb", "ccc");
         streamEx(input::stream, supplier -> {
             assertEquals("ccc;bb;a;", supplier.get().foldLeft("", (u, v) -> v + ";" + u));
-            // Removing types here causes internal error in Javac compiler
-            // java.lang.AssertionError: attribution shouldn't be happening here
-            // Bug appears in javac 1.8.0.20 and javac 1.8.0.45
-            // javac 1.9.0b55 and ecj compiles normally
-            // Probably this ticket:
-            // https://bugs.openjdk.java.net/browse/JDK-8068399
             assertTrue(supplier.get().foldLeft(false, (Boolean acc, String s) -> acc || s.equals("bb")));
             assertFalse(supplier.get().foldLeft(false, (Boolean acc, String s) -> acc || s.equals("d")));
             assertEquals(6, (int) supplier.get().foldLeft(0, (acc, v) -> acc + v.length()));
@@ -750,8 +742,6 @@ public class StreamExTest {
         assertEquals(IntStreamEx.range(10).boxed().toList(), IntStreamEx.range(100).mapToObj(x -> x / 10).sorted()
                 .distinct(3).sorted().toList());
 
-        // Saving actual to separate variable helps to work-around
-        // javac <8u40 issue JDK-8056984
         List<String> actual = StreamEx.split("a,b,a,c,d,b,a", ",").parallel().distinct(2).sorted().toList();
         assertEquals(asList("a", "b"), actual);
     }
@@ -820,13 +810,13 @@ public class StreamExTest {
         List<Integer> res = StreamEx.of(numbers).pairMap((a, b) -> a < b ? a : null).nonNull().toList();
         assertEquals(asList(1, 15, 2), res);
 
-        // Check whether stream is sorted
+        // Check whether the stream is sorted
         assertTrue(isSorted(asList("a", "bb", "bb", "c")));
         assertFalse(isSorted(asList("a", "bb", "bb", "bba", "bb", "c")));
         withRandom(r -> assertTrue(isSorted(IntStreamEx.of(r).boxed().distinct().limit(1000).toCollection(
             TreeSet::new))));
 
-        // Find first element which violates the sorting
+        // Find the first element that violates the sorting
         assertEquals("bba", firstMisplaced(asList("a", "bb", "bb", "bba", "bb", "c")).get());
         assertFalse(firstMisplaced(asList("a", "bb", "bb", "bb", "c")).isPresent());
         assertFalse(firstMisplaced(Arrays.<String>asList()).isPresent());
@@ -1389,7 +1379,7 @@ public class StreamExTest {
                     .joining(", "));
         });
         Entry<Integer, Long> entry = StreamEx.of(input).runLengths().findFirst().get();
-        // Test qeuals contract for custom entry
+        // Test equals contract for custom entry
         assertNotEquals(entry, new Object());
         assertNotEquals(new Object(), entry);
         assertEquals(entry, new AbstractMap.SimpleImmutableEntry<>(1, 1L));
@@ -1574,7 +1564,7 @@ public class StreamExTest {
             assertEquals(asList(), s.get().dropWhile(x -> x.length() > 0).toList());
             assertEquals(asList("aaa", "b", "cccc"), s.get().dropWhile(x -> x.length() > 5).toList());
             // Saving to Optional is necessary as javac <8u40 fails to compile
-            // this without intermediate variable
+            // this without an intermediate variable
             Optional<String> opt1 = s.get().dropWhile(x -> x.length() > 1).findFirst();
             assertEquals(Optional.of("b"), opt1);
             Optional<String> opt0 = s.get().dropWhile(x -> x.length() > 0).findFirst();
@@ -2016,7 +2006,7 @@ public class StreamExTest {
      * @param stream stream to process
      * @param comparator comparator to compare stream values
      * @param stopValue value to short-circuit at
-     * @return optional describing maximal value or empty optional if input
+     * @return optional describing maximal value or empty optional if the input
      *         stream is empty
      */
     static <T> Optional<T> maxWithStop(StreamEx<T> stream, Comparator<T> comparator, T stopValue) {
diff --git a/wiki/CHANGES.md b/wiki/CHANGES.md
index 6e23495..f618d31 100644
--- a/wiki/CHANGES.md
+++ b/wiki/CHANGES.md
@@ -2,6 +2,10 @@
 
 Check also [MIGRATION.md](MIGRATION.md) for possible compatibility problems.
 
+### 0.9.0
+* [#282] JSpecify nullity annotations added.
+* [#283] Redundant type arguments on IntStreamEx.ofIndices removed
+
 ### 0.8.4
 * [#279] Added: `AbstractStreamEx.mapToEntryPartial`.
 * [#280] Added: `EntryStream.mapKeysPartial` and `mapValuesPartial`
diff --git a/wiki/MIGRATION.md b/wiki/MIGRATION.md
index 40e160a..7afaa92 100644
--- a/wiki/MIGRATION.md
+++ b/wiki/MIGRATION.md
@@ -2,6 +2,13 @@
 
 This document describes StreamEx changes which may break the backwards compatibility. For full list of changes see [CHANGES.md](CHANGES.md).
 
+### 0.9.0
+Issue#282: JSpecify nullity annotations were added. This may break the source compatibility if the library was used from Kotlin code with incompatible types.
+Also, this may issue new static analyzer warnings. For example, it may cause build failure if NullAway is used as a part of the build pipeline.
+
+Issue#283: Redundant type arguments were removed from single-argument `IntStreamEx.ofIndices` overloads. This may cause warnings or errors if they were explicitly specified.
+To fix this, just remove them from the code.
+
 ### 0.8.0
 Issue#244: To align with Java 16 `Stream.toList` specification, we no more guarantee that the results of 
 `AbstractStreamEx.toList` and `AbstractStreamEx.toSet` are mutable. They are still mutable by default 
