diff --git a/src/main/java/one/util/streamex/HeadTailSpliterator.java b/src/main/java/one/util/streamex/HeadTailSpliterator.java
index 34c807d..f17d077 100644
--- a/src/main/java/one/util/streamex/HeadTailSpliterator.java
+++ b/src/main/java/one/util/streamex/HeadTailSpliterator.java
@@ -24,13 +24,13 @@ import java.util.function.Supplier;
 import java.util.stream.BaseStream;
 import java.util.stream.Stream;
 
-import one.util.streamex.StreamExInternals.TailCallSpliterator;
+import one.util.streamex.StreamExInternals.TailSpliterator;
 import static one.util.streamex.StreamExInternals.*;
 
 /**
  * @author Tagir Valeev
  */
-/*package*/ final class HeadTailSpliterator<T, U> extends AbstractSpliterator<U> implements TailCallSpliterator<U> {
+/*package*/ final class HeadTailSpliterator<T, U> extends AbstractSpliterator<U> implements TailSpliterator<U> {
     private Spliterator<T> source;
     private BiFunction<? super T, ? super StreamEx<T>, ? extends Stream<U>> mapper;
     private Supplier<? extends Stream<U>> emptyMapper;
@@ -50,7 +50,7 @@ import static one.util.streamex.StreamExInternals.*;
     public boolean tryAdvance(Consumer<? super U> action) {
         if(!init())
             return false;
-        target = TailCallSpliterator.tryAdvanceWithTail(target, action);
+        target = TailSpliterator.tryAdvanceWithTail(target, action);
         if(target == null) {
             finished = true;
             return false;
@@ -72,7 +72,7 @@ import static one.util.streamex.StreamExInternals.*;
     public void forEachRemaining(Consumer<? super U> action) {
         if(!init())
             return;
-        TailCallSpliterator.forEachWithTail(target, action);
+        TailSpliterator.forEachWithTail(target, action);
         target = null;
         finished = true;
     }
@@ -87,7 +87,7 @@ import static one.util.streamex.StreamExInternals.*;
             return false;
         if(target == null) {
             Box<T> first = new Box<>(null);
-            source = TailCallSpliterator.tryAdvanceWithTail(source, x -> first.a = x);
+            source = TailSpliterator.tryAdvanceWithTail(source, x -> first.a = x);
             Stream<U> stream = source == null ? emptyMapper.get() : mapper.apply(first.a, StreamEx.of(source));
             source = null;
             mapper = null;
diff --git a/src/main/java/one/util/streamex/PairSpliterator.java b/src/main/java/one/util/streamex/PairSpliterator.java
index 3f33710..e5d05a7 100644
--- a/src/main/java/one/util/streamex/PairSpliterator.java
+++ b/src/main/java/one/util/streamex/PairSpliterator.java
@@ -30,7 +30,7 @@ import java.util.function.LongBinaryOperator;
 import java.util.function.LongConsumer;
 import java.util.function.LongUnaryOperator;
 
-import one.util.streamex.StreamExInternals.TailCallSpliterator;
+import one.util.streamex.StreamExInternals.TailSpliterator;
 import static one.util.streamex.StreamExInternals.*;
 
 /**
@@ -173,7 +173,7 @@ import static one.util.streamex.StreamExInternals.*;
     }
 
     static class PSOfRef<T, R> extends PairSpliterator<T, Spliterator<T>, R, PSOfRef<T, R>> implements
-            Consumer<T>, TailCallSpliterator<R> {
+            Consumer<T>, TailSpliterator<R> {
         private static final Object HEAD_TAIL = new Object();
 
         private final BiFunction<? super T, ? super T, ? extends R> mapper;
@@ -246,7 +246,7 @@ import static one.util.streamex.StreamExInternals.*;
             if (left != null) {
                 Sink<T> l = left;
                 left = null;
-                source = TailCallSpliterator.tryAdvanceWithTail(source, this);
+                source = TailSpliterator.tryAdvanceWithTail(source, this);
                 if (source == null) {
                     right = null;
                     return null;
diff --git a/src/main/java/one/util/streamex/StreamEx.java b/src/main/java/one/util/streamex/StreamEx.java
index 8ffd463..90e1b12 100644
--- a/src/main/java/one/util/streamex/StreamEx.java
+++ b/src/main/java/one/util/streamex/StreamEx.java
@@ -79,7 +79,7 @@ import static one.util.streamex.StreamExInternals.*;
  */
 public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
 
-    private static class PrependSpliterator<T> implements TailCallSpliterator<T> {
+    private static class PrependSpliterator<T> implements TailSpliterator<T> {
         private Spliterator<T> source;
         private T[] prepended;
         private int position;
@@ -285,7 +285,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      *
      * <p>
      * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
-     * operation</a> with <a href="package-summary.html#TCO">tail-call
+     * operation</a> with <a href="package-summary.html#TSO">tail-stream
      * optimization</a>.
      *
      * @param mapper a <a
@@ -1048,7 +1048,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * 
      * <p>
      * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
-     * operation</a> with <a href="package-summary.html#TCO">tail-call
+     * operation</a> with <a href="package-summary.html#TSO">tail-stream
      * optimization</a>.
      * 
      * @param values the values to prepend to the stream
@@ -1488,7 +1488,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * 
      * <p>
      * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
-     * operation</a> with <a href="package-summary.html#TCO">tail-call
+     * operation</a> with <a href="package-summary.html#TSO">tail-stream
      * optimization</a>.
      * 
      * <p>
@@ -1506,10 +1506,10 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * }}</pre>
      * 
      * <p>
-     * When possible, use tail-call optimized operations to reduce the call
+     * When possible, use tail-stream optimized operations to reduce the call
      * stack depth. In particular, the example shown above uses only
      * {@code headTail()}, {@link #mapFirst(Function)} and
-     * {@link #prepend(Object...)} operations, all of them are tail-call
+     * {@link #prepend(Object...)} operations, all of them are tail-stream
      * optimized, so it will not fail with {@code StackOverflowError} on long
      * input stream.
      * 
@@ -1522,8 +1522,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      *
      * @param <R> The element type of the new stream
      * @param mapper a <a
-     *        href="package-summary.html#NonInterference">non-interfering</a>,
-     *        <a href="package-summary.html#Statelessness">stateless</a>
+     *        href="package-summary.html#NonInterference">non-interfering</a>
      *        function to apply to the first stream element and the stream of
      *        the rest elements which creates a new stream.
      * @return the new stream
@@ -1543,7 +1542,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * 
      * <p>
      * This is a <a href="package-summary.html#StreamOps">quasi-intermediate
-     * operation</a> with <a href="package-summary.html#TCO">tail-call
+     * operation</a> with <a href="package-summary.html#TSO">tail-stream
      * optimization</a>.
      * 
      * <p>
@@ -1565,10 +1564,10 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * }}</pre>
      * 
      * <p>
-     * When possible, use tail-call optimized operations to reduce the call
+     * When possible, use tail-stream optimized operations to reduce the call
      * stack depth. In particular, the example shown above uses only
      * {@code headTail()}, and {@link #prepend(Object...)} operations, both of
-     * them are tail-call optimized, so it will not fail with
+     * them are tail-stream optimized, so it will not fail with
      * {@code StackOverflowError} on long input stream.
      * 
      * <p>
@@ -1580,13 +1579,11 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      *
      * @param <R> The element type of the new stream
      * @param mapper a <a
-     *        href="package-summary.html#NonInterference">non-interfering</a>,
-     *        <a href="package-summary.html#Statelessness">stateless</a>
+     *        href="package-summary.html#NonInterference">non-interfering</a>
      *        function to apply to the first stream element and the stream of
      *        the rest elements which creates a new stream.
      * @param supplier a <a
-     *        href="package-summary.html#NonInterference">non-interfering</a>,
-     *        <a href="package-summary.html#Statelessness">stateless</a>
+     *        href="package-summary.html#NonInterference">non-interfering</a>
      *        supplier which creates a resulting stream when this stream is
      *        empty.
      * @return the new stream
diff --git a/src/main/java/one/util/streamex/StreamExInternals.java b/src/main/java/one/util/streamex/StreamExInternals.java
index 02b3349..67bcfe8 100644
--- a/src/main/java/one/util/streamex/StreamExInternals.java
+++ b/src/main/java/one/util/streamex/StreamExInternals.java
@@ -936,11 +936,11 @@ import java.util.stream.Stream;
     }
 
     /**
-     * A spliterator which may perform tail-call optimization
+     * A spliterator which may perform tail-stream optimization
      *
      * @param <T>
      */
-    static interface TailCallSpliterator<T> extends Spliterator<T> {
+    static interface TailSpliterator<T> extends Spliterator<T> {
         /**
          * Either advances by one element feeding it to consumer and returns
          * this or returns tail spliterator (this spliterator becomes invalid
@@ -962,8 +962,8 @@ import java.util.stream.Stream;
 
         static <T> Spliterator<T> tryAdvanceWithTail(Spliterator<T> target, Consumer<? super T> action) {
             while (true) {
-                if (target instanceof TailCallSpliterator) {
-                    Spliterator<T> spltr = ((TailCallSpliterator<T>) target).tryAdvanceOrTail(action);
+                if (target instanceof TailSpliterator) {
+                    Spliterator<T> spltr = ((TailSpliterator<T>) target).tryAdvanceOrTail(action);
                     if (spltr == null || spltr == target)
                         return spltr;
                     target = spltr;
@@ -975,8 +975,8 @@ import java.util.stream.Stream;
 
         static <T> void forEachWithTail(Spliterator<T> target, Consumer<? super T> action) {
             while (true) {
-                if (target instanceof TailCallSpliterator) {
-                    Spliterator<T> spltr = ((TailCallSpliterator<T>) target).forEachOrTail(action);
+                if (target instanceof TailSpliterator) {
+                    Spliterator<T> spltr = ((TailSpliterator<T>) target).forEachOrTail(action);
                     if (spltr == null)
                         break;
                     target = spltr;
diff --git a/src/main/java/one/util/streamex/package-info.java b/src/main/java/one/util/streamex/package-info.java
index 9f7aa58..fb9f5a4 100644
--- a/src/main/java/one/util/streamex/package-info.java
+++ b/src/main/java/one/util/streamex/package-info.java
@@ -63,13 +63,13 @@
  * operation, then unordered mode is not propagated through it, so the operations prior to the quasi-intermediate operation 
  * (including the quasi-intermediate operation itself) will remain ordered.
  * 
- * <h3><a name="TCO">Tail call optimization</a></h3>
+ * <h3><a name="TSO">Tail stream optimization</a></h3>
  *
- * A few quasi-intermediate operations are tail-call optimized (TCO) which is important when using 
+ * A few quasi-intermediate operations are tail-stream optimized (TSO) which is important when using 
  * {@link one.util.streamex.StreamEx#headTail(java.util.function.BiFunction) headTail}
- * method recursively. When the TCO-compatible operation understands that it should just pass-through 
+ * method recursively. When the TSO-compatible operation understands that it should just pass-through 
  * the rest of the stream as-is, it notifies the surrounding {@code headTail} operation, and {@code headTail} operation 
- * removes the TCO-compatible operation from the pipeline shortening the call stack.
+ * removes the TSO-compatible operation from the pipeline shortening the call stack.
  * This allows writing many recursively defined operations which consume constant amount of the call stack and the heap.
  *
  * <h3><a name="NonInterference">Non-interference</a></h3>
diff --git a/src/test/java/one/util/streamex/StreamExHeadTailTest.java b/src/test/java/one/util/streamex/StreamExHeadTailTest.java
index dca5f34..a838638 100644
--- a/src/test/java/one/util/streamex/StreamExHeadTailTest.java
+++ b/src/test/java/one/util/streamex/StreamExHeadTailTest.java
@@ -55,17 +55,17 @@ public class StreamExHeadTailTest {
     // ///////////////////////
     // JDK-8 intermediate ops
 
-    // Stream.skip (TCO)
+    // Stream.skip (TSO)
     static <T> StreamEx<T> skip(StreamEx<T> input, int n) {
         return input.headTail((head, tail) -> n > 0 ? skip(tail, n - 1) : tail.prepend(head));
     }
 
-    // Stream.limit (TCO)
+    // Stream.limit (TSO)
     static <T> StreamEx<T> limit(StreamEx<T> input, int n) {
         return input.headTail((head, tail) -> n > 1 ? limit(tail, n - 1).prepend(head) : Stream.of(head));
     }
 
-    // Stream.filter (TCO)
+    // Stream.filter (TSO)
     static <T> StreamEx<T> filter(StreamEx<T> input, Predicate<T> predicate) {
         return input.<T> headTail((head, tail) -> {
             StreamEx<T> filtered = filter(tail, predicate);
@@ -78,22 +78,22 @@ public class StreamExHeadTailTest {
         return input.headTail((head, tail) -> distinct(tail.filter(n -> !Objects.equals(head, n))).prepend(head));
     }
 
-    // Stream.distinct (TCO)
-    static <T> StreamEx<T> distinctTCO(StreamEx<T> input) {
-        return distinctTCO(input, new HashSet<>());
+    // Stream.distinct (TSO)
+    static <T> StreamEx<T> distinctTSO(StreamEx<T> input) {
+        return distinctTSO(input, new HashSet<>());
     }
 
-    private static <T> StreamEx<T> distinctTCO(StreamEx<T> input, Set<T> observed) {
-        return input.headTail((head, tail) -> observed.add(head) ? distinctTCO(tail, observed).prepend(head)
-                : distinctTCO(tail, observed));
+    private static <T> StreamEx<T> distinctTSO(StreamEx<T> input, Set<T> observed) {
+        return input.headTail((head, tail) -> observed.add(head) ? distinctTSO(tail, observed).prepend(head)
+                : distinctTSO(tail, observed));
     }
 
-    // Stream.map (TCO)
+    // Stream.map (TSO)
     static <T, R> StreamEx<R> map(StreamEx<T> input, Function<T, R> mapper) {
         return input.headTail((head, tail) -> map(tail, mapper).prepend(mapper.apply(head)));
     }
 
-    // Stream.peek (TCO)
+    // Stream.peek (TSO)
     static <T> StreamEx<T> peek(StreamEx<T> input, Consumer<T> consumer) {
         return input.headTail((head, tail) -> {
             consumer.accept(head);
@@ -119,12 +119,12 @@ public class StreamExHeadTailTest {
     // ///////////////////////
     // JDK-9 intermediate ops
 
-    // Stream.takeWhile (TCO)
+    // Stream.takeWhile (TSO)
     static <T> StreamEx<T> takeWhile(StreamEx<T> input, Predicate<T> predicate) {
         return input.headTail((head, tail) -> predicate.test(head) ? takeWhile(tail, predicate).prepend(head) : null);
     }
 
-    // Stream.dropWhile (TCO)
+    // Stream.dropWhile (TSO)
     static <T> StreamEx<T> dropWhile(StreamEx<T> input, Predicate<T> predicate) {
         return input.headTail((head, tail) -> predicate.test(head) ? dropWhile(tail, predicate) : tail.prepend(head));
     }
@@ -153,24 +153,24 @@ public class StreamExHeadTailTest {
         return input.headTail((head, tail) -> cycle(tail.append(head)).prepend(head));
     }
 
-    // mapFirst (TCO)
+    // mapFirst (TSO)
     static <T> StreamEx<T> mapFirst(StreamEx<T> input, UnaryOperator<T> operator) {
         return input.headTail((head, tail) -> tail.prepend(operator.apply(head)));
     }
 
-    // Creates lazy scanLeft stream (TCO)
+    // Creates lazy scanLeft stream (TSO)
     static <T> StreamEx<T> scanLeft(StreamEx<T> input, BinaryOperator<T> operator) {
         return input.headTail((head, tail) -> scanLeft(tail.mapFirst(cur -> operator.apply(head, cur)), operator)
                 .prepend(head));
     }
 
-    // takeWhileClosed: takeWhile+first element violating the predicate (TCO)
+    // takeWhileClosed: takeWhile+first element violating the predicate (TSO)
     static <T> StreamEx<T> takeWhileClosed(StreamEx<T> input, Predicate<T> predicate) {
         return input.headTail((head, tail) -> predicate.test(head) ? takeWhileClosed(tail, predicate).prepend(head)
                 : Stream.of(head));
     }
 
-    // take every nth stream element (starting from the first) (TCO)
+    // take every nth stream element (starting from the first) (TSO)
     static <T> StreamEx<T> every(StreamEx<T> input, int n) {
         return input.headTail((head, tail) -> every(skip(tail, n - 1), n).prepend(head));
     }
@@ -187,7 +187,7 @@ public class StreamExHeadTailTest {
                 .prepend(mapper.apply(left, right))));
     }
 
-    // Stream of fixed size batches (TCO)
+    // Stream of fixed size batches (TSO)
     static <T> StreamEx<List<T>> batches(StreamEx<T> input, int size) {
         return batches(input, size, Collections.emptyList());
     }
@@ -199,7 +199,7 @@ public class StreamExHeadTailTest {
                 () -> Stream.of(cur));
     }
 
-    // Stream of single element lists -> stream of sliding windows (TCO)
+    // Stream of single element lists -> stream of sliding windows (TSO)
     static <T> StreamEx<List<T>> sliding(StreamEx<List<T>> input, int size) {
         return input.headTail((head, tail) -> head.size() == size ? sliding(
             tail.mapFirst(next -> StreamEx.of(head.subList(1, size), next).toFlatList(l -> l)), size).prepend(head)
@@ -207,13 +207,13 @@ public class StreamExHeadTailTest {
     }
 
     // Stream of dominators (removes immediately following elements which the
-    // current element dominates on) (TCO)
+    // current element dominates on) (TSO)
     static <T> StreamEx<T> dominators(StreamEx<T> input, BiPredicate<T, T> isDominator) {
         return input.headTail((head, tail) -> dominators(dropWhile(tail, e -> isDominator.test(head, e)), isDominator)
                 .prepend(head));
     }
 
-    // Stream of mappings of (index, element) (TCO)
+    // Stream of mappings of (index, element) (TSO)
     static <T, R> StreamEx<R> withIndices(StreamEx<T> input, BiFunction<Integer, T, R> mapper) {
         return withIndices(input, 0, mapper);
     }
@@ -363,9 +363,9 @@ public class StreamExHeadTailTest {
         assertEquals(20000, withIndices(IntStreamEx.of(new Random(1), 20000).boxed(), (idx, e) -> idx + ": " + e)
                 .count());
 
-        assertEquals(20000, limit(distinctTCO(IntStreamEx.of(new Random(1)).boxed()), 20000).toSet().size());
+        assertEquals(20000, limit(distinctTSO(IntStreamEx.of(new Random(1)).boxed()), 20000).toSet().size());
         assertEquals(IntStreamEx.range(20000).boxed().toList(), sorted(limit(
-            distinctTCO(IntStreamEx.of(new Random(1), 0, 20000).boxed()), 20000)).toList());
+            distinctTSO(IntStreamEx.of(new Random(1), 0, 20000).boxed()), 20000)).toList());
     }
 
     @Test
