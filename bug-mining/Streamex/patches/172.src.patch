diff --git a/src/main/java/one/util/streamex/DoubleStreamEx.java b/src/main/java/one/util/streamex/DoubleStreamEx.java
index fce984b..a21a01d 100644
--- a/src/main/java/one/util/streamex/DoubleStreamEx.java
+++ b/src/main/java/one/util/streamex/DoubleStreamEx.java
@@ -1804,4 +1804,55 @@ public class DoubleStreamEx extends BaseStreamEx<Double, DoubleStream, Spliterat
         return of(new RangeBasedSpliterator.ZipDouble(0, checkLength(first.length, second.length), mapper, first,
                 second));
     }
+    
+    /**
+     * A helper interface to build a new stream by emitting elements and
+     * creating new emitters in a chain.
+     * 
+     * <p>
+     * Using this interface it's possible to create custom sources which cannot
+     * be easily expressed using {@link DoubleStreamEx#iterate(double, DoubleUnaryOperator)}
+     * or {@link DoubleStreamEx#generate(DoubleSupplier)}.
+     * 
+     * @author Tagir Valeev
+     *
+     * @since 0.6.0
+     */
+    @FunctionalInterface
+    public interface DoubleEmitter {
+        /**
+         * Calls the supplied consumer zero or more times to emit some elements,
+         * then returns the next emitter which will emit more, or null if nothing
+         * more to emit.
+         * 
+         * <p>
+         * It's allowed not to emit anything (don't call the consumer). However
+         * if you do this and return new emitter which also does not emit
+         * anything, you will end up in endless loop.
+         * 
+         * @param cons consumer to be called to emit elements
+         * @return next emitter or null
+         */
+        DoubleEmitter next(DoubleConsumer cons);
+
+        /**
+         * Returns the spliterator which covers all the elements emitted by this
+         * emitter.
+         * 
+         * @return the new spliterator
+         */
+        default Spliterator.OfDouble spliterator() {
+            return new EmitterSpliterator.OfDouble(this);
+        }
+
+        /**
+         * Returns the stream which covers all the elements emitted by this
+         * emitter.
+         * 
+         * @return the new stream
+         */
+        default DoubleStreamEx stream() {
+            return of(spliterator());
+        }
+    }
 }
diff --git a/src/main/java/one/util/streamex/EmitterSpliterator.java b/src/main/java/one/util/streamex/EmitterSpliterator.java
index ae63968..7b8177c 100644
--- a/src/main/java/one/util/streamex/EmitterSpliterator.java
+++ b/src/main/java/one/util/streamex/EmitterSpliterator.java
@@ -18,15 +18,20 @@ package one.util.streamex;
 import java.util.Spliterator;
 import java.util.Spliterators;
 import java.util.function.Consumer;
+import java.util.function.DoubleConsumer;
+import java.util.function.IntConsumer;
+import java.util.function.LongConsumer;
+import java.util.stream.DoubleStream;
+import java.util.stream.IntStream;
+import java.util.stream.LongStream;
 import java.util.stream.Stream;
-import java.util.stream.Stream.Builder;
 
 /* package */final class EmitterSpliterator<T> extends Spliterators.AbstractSpliterator<T> implements Consumer<T> {
     StreamEx.Emitter<T> e;
     Spliterator<T> buf;
     boolean hasValue;
     Consumer<? super T> action;
-    Builder<T> builder;
+    Stream.Builder<T> builder;
 
     EmitterSpliterator(StreamEx.Emitter<T> e) {
         super(Long.MAX_VALUE, Spliterator.ORDERED | Spliterator.IMMUTABLE);
@@ -42,7 +47,7 @@ import java.util.stream.Stream.Builder;
         }
         hasValue = false;
         this.action = action;
-        while (!hasValue) {
+        while (!hasValue && e != null) {
             e = e.next(this);
         }
         this.action = null;
@@ -77,4 +82,178 @@ import java.util.stream.Stream.Builder;
             hasValue = true;
         }
     }
+
+    static final class OfInt extends Spliterators.AbstractIntSpliterator implements IntConsumer {
+        IntStreamEx.IntEmitter e;
+        Spliterator.OfInt buf;
+        boolean hasValue;
+        IntConsumer action;
+        IntStream.Builder builder;
+
+        OfInt(IntStreamEx.IntEmitter e) {
+            super(Long.MAX_VALUE, Spliterator.ORDERED | Spliterator.IMMUTABLE | Spliterator.NONNULL);
+            this.e = e;
+        }
+
+        @Override
+        public boolean tryAdvance(IntConsumer action) {
+            if (buf != null) {
+                if (buf.tryAdvance(action))
+                    return true;
+                buf = null;
+            }
+            hasValue = false;
+            this.action = action;
+            while (!hasValue && e != null) {
+                e = e.next(this);
+            }
+            this.action = null;
+            if (builder != null) {
+                buf = builder.build().spliterator();
+                builder = null;
+            }
+            return hasValue;
+        }
+
+        @Override
+        public void forEachRemaining(IntConsumer action) {
+            if (buf != null) {
+                buf.forEachRemaining(action);
+                buf = null;
+            }
+            IntStreamEx.IntEmitter e = this.e;
+            this.e = null;
+            while (e != null)
+                e = e.next(action);
+        }
+
+        @Override
+        public void accept(int t) {
+            if (hasValue) {
+                if (builder == null) {
+                    builder = IntStream.builder();
+                }
+                builder.accept(t);
+            } else {
+                action.accept(t);
+                hasValue = true;
+            }
+        }
+    }
+
+    static final class OfLong extends Spliterators.AbstractLongSpliterator implements LongConsumer {
+        LongStreamEx.LongEmitter e;
+        Spliterator.OfLong buf;
+        boolean hasValue;
+        LongConsumer action;
+        LongStream.Builder builder;
+
+        OfLong(LongStreamEx.LongEmitter e) {
+            super(Long.MAX_VALUE, Spliterator.ORDERED | Spliterator.IMMUTABLE | Spliterator.NONNULL);
+            this.e = e;
+        }
+
+        @Override
+        public boolean tryAdvance(LongConsumer action) {
+            if (buf != null) {
+                if (buf.tryAdvance(action))
+                    return true;
+                buf = null;
+            }
+            hasValue = false;
+            this.action = action;
+            while (!hasValue && e != null) {
+                e = e.next(this);
+            }
+            this.action = null;
+            if (builder != null) {
+                buf = builder.build().spliterator();
+                builder = null;
+            }
+            return hasValue;
+        }
+
+        @Override
+        public void forEachRemaining(LongConsumer action) {
+            if (buf != null) {
+                buf.forEachRemaining(action);
+                buf = null;
+            }
+            LongStreamEx.LongEmitter e = this.e;
+            this.e = null;
+            while (e != null)
+                e = e.next(action);
+        }
+
+        @Override
+        public void accept(long t) {
+            if (hasValue) {
+                if (builder == null) {
+                    builder = LongStream.builder();
+                }
+                builder.accept(t);
+            } else {
+                action.accept(t);
+                hasValue = true;
+            }
+        }
+    }
+
+    static final class OfDouble extends Spliterators.AbstractDoubleSpliterator implements DoubleConsumer {
+        DoubleStreamEx.DoubleEmitter e;
+        Spliterator.OfDouble buf;
+        boolean hasValue;
+        DoubleConsumer action;
+        DoubleStream.Builder builder;
+
+        OfDouble(DoubleStreamEx.DoubleEmitter e) {
+            super(Long.MAX_VALUE, Spliterator.ORDERED | Spliterator.IMMUTABLE | Spliterator.NONNULL);
+            this.e = e;
+        }
+
+        @Override
+        public boolean tryAdvance(DoubleConsumer action) {
+            if (buf != null) {
+                if (buf.tryAdvance(action))
+                    return true;
+                buf = null;
+            }
+            hasValue = false;
+            this.action = action;
+            while (!hasValue && e != null) {
+                e = e.next(this);
+            }
+            this.action = null;
+            if (builder != null) {
+                buf = builder.build().spliterator();
+                builder = null;
+            }
+            return hasValue;
+        }
+
+        @Override
+        public void forEachRemaining(DoubleConsumer action) {
+            if (buf != null) {
+                buf.forEachRemaining(action);
+                buf = null;
+            }
+            DoubleStreamEx.DoubleEmitter e = this.e;
+            this.e = null;
+            while (e != null)
+                e = e.next(action);
+        }
+
+        @Override
+        public void accept(double t) {
+            if (hasValue) {
+                if (builder == null) {
+                    builder = DoubleStream.builder();
+                }
+                builder.accept(t);
+            } else {
+                action.accept(t);
+                hasValue = true;
+            }
+        }
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/one/util/streamex/IntStreamEx.java b/src/main/java/one/util/streamex/IntStreamEx.java
index 8e81180..f2a552f 100644
--- a/src/main/java/one/util/streamex/IntStreamEx.java
+++ b/src/main/java/one/util/streamex/IntStreamEx.java
@@ -2435,4 +2435,67 @@ public class IntStreamEx extends BaseStreamEx<Integer, IntStream, Spliterator.Of
     public static IntStreamEx zip(int[] first, int[] second, IntBinaryOperator mapper) {
         return of(new RangeBasedSpliterator.ZipInt(0, checkLength(first.length, second.length), mapper, first, second));
     }
+    
+    /**
+     * A helper interface to build a new stream by emitting elements and
+     * creating new emitters in a chain.
+     * 
+     * <p>
+     * Using this interface it's possible to create custom sources which cannot
+     * be easily expressed using {@link IntStreamEx#iterate(int, IntUnaryOperator)}
+     * or {@link IntStreamEx#generate(IntSupplier)}. For example, the following method
+     * generates a Collatz sequence starting from given number:
+     * 
+     * <pre>{@code
+     * public static IntEmitter collatz(int start) {
+     *    return action -> {
+     *       action.accept(start);
+     *       return start == 1 ? null : collatz(start % 2 == 0 ? start / 2 : start * 3 + 1);
+     *    };
+     * }}</pre>
+     * 
+     * <p>
+     * Now you can use {@code collatz(17).stream()} to get the stream of Collatz numbers.
+     * 
+     * @author Tagir Valeev
+     *
+     * @since 0.6.0
+     */
+    @FunctionalInterface
+    public interface IntEmitter {
+        /**
+         * Calls the supplied consumer zero or more times to emit some elements,
+         * then returns the next emitter which will emit more, or null if nothing
+         * more to emit.
+         * 
+         * <p>
+         * It's allowed not to emit anything (don't call the consumer). However
+         * if you do this and return new emitter which also does not emit
+         * anything, you will end up in endless loop.
+         * 
+         * @param cons consumer to be called to emit elements
+         * @return next emitter or null
+         */
+        IntEmitter next(IntConsumer cons);
+
+        /**
+         * Returns the spliterator which covers all the elements emitted by this
+         * emitter.
+         * 
+         * @return the new spliterator
+         */
+        default Spliterator.OfInt spliterator() {
+            return new EmitterSpliterator.OfInt(this);
+        }
+
+        /**
+         * Returns the stream which covers all the elements emitted by this
+         * emitter.
+         * 
+         * @return the new stream
+         */
+        default IntStreamEx stream() {
+            return of(spliterator());
+        }
+    }
 }
diff --git a/src/main/java/one/util/streamex/LongStreamEx.java b/src/main/java/one/util/streamex/LongStreamEx.java
index 572a054..2a61ed0 100644
--- a/src/main/java/one/util/streamex/LongStreamEx.java
+++ b/src/main/java/one/util/streamex/LongStreamEx.java
@@ -1949,4 +1949,67 @@ public class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterator.OfL
     public static LongStreamEx zip(long[] first, long[] second, LongBinaryOperator mapper) {
         return of(new RangeBasedSpliterator.ZipLong(0, checkLength(first.length, second.length), mapper, first, second));
     }
+
+    /**
+     * A helper interface to build a new stream by emitting elements and
+     * creating new emitters in a chain.
+     * 
+     * <p>
+     * Using this interface it's possible to create custom sources which cannot
+     * be easily expressed using {@link LongStreamEx#iterate(long, LongUnaryOperator)}
+     * or {@link LongStreamEx#generate(LongSupplier)}. For example, the following method
+     * generates a Collatz sequence starting from given number:
+     * 
+     * <pre>{@code
+     * public static LongEmitter collatz(long start) {
+     *    return action -> {
+     *       action.accept(start);
+     *       return start == 1 ? null : collatz(start % 2 == 0 ? start / 2 : start * 3 + 1);
+     *    };
+     * }}</pre>
+     * 
+     * <p>
+     * Now you can use {@code collatz(17).stream()} to get the stream of Collatz numbers.
+     * 
+     * @author Tagir Valeev
+     *
+     * @since 0.6.0
+     */
+    @FunctionalInterface
+    public interface LongEmitter {
+        /**
+         * Calls the supplied consumer zero or more times to emit some elements,
+         * then returns the next emitter which will emit more, or null if nothing
+         * more to emit.
+         * 
+         * <p>
+         * It's allowed not to emit anything (don't call the consumer). However
+         * if you do this and return new emitter which also does not emit
+         * anything, you will end up in endless loop.
+         * 
+         * @param cons consumer to be called to emit elements
+         * @return next emitter or null
+         */
+        LongEmitter next(LongConsumer cons);
+
+        /**
+         * Returns the spliterator which covers all the elements emitted by this
+         * emitter.
+         * 
+         * @return the new spliterator
+         */
+        default Spliterator.OfLong spliterator() {
+            return new EmitterSpliterator.OfLong(this);
+        }
+
+        /**
+         * Returns the stream which covers all the elements emitted by this
+         * emitter.
+         * 
+         * @return the new stream
+         */
+        default LongStreamEx stream() {
+            return of(spliterator());
+        }
+    }
 }
diff --git a/src/test/java/one/util/streamex/StreamExEmitterTest.java b/src/test/java/one/util/streamex/EmitterTest.java
similarity index 67%
rename from src/test/java/one/util/streamex/StreamExEmitterTest.java
rename to src/test/java/one/util/streamex/EmitterTest.java
index 1c7a93c..51c93b2 100644
--- a/src/test/java/one/util/streamex/StreamExEmitterTest.java
+++ b/src/test/java/one/util/streamex/EmitterTest.java
@@ -16,6 +16,7 @@
 package one.util.streamex;
 
 import static org.junit.Assert.*;
+import static one.util.streamex.TestHelpers.*;
 import static java.util.Arrays.asList;
 
 import java.math.BigInteger;
@@ -30,6 +31,9 @@ import java.util.function.UnaryOperator;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
+import one.util.streamex.DoubleStreamEx.DoubleEmitter;
+import one.util.streamex.IntStreamEx.IntEmitter;
+import one.util.streamex.LongStreamEx.LongEmitter;
 import one.util.streamex.StreamEx.Emitter;
 
 import org.junit.Test;
@@ -37,7 +41,7 @@ import org.junit.Test;
 /**
  * @author Tagir Valeev
  */
-public class StreamExEmitterTest {
+public class EmitterTest {
     // Like Stream.generate(supplier)
     public static <T> Emitter<T> generate(Supplier<T> supplier) {
         return new Emitter<T>() {
@@ -65,6 +69,20 @@ public class StreamExEmitterTest {
         };
     }
 
+    public static IntEmitter collatzInt(int start) {
+        return action -> {
+            action.accept(start);
+            return start == 1 ? null : collatzInt(start % 2 == 0 ? start / 2 : start * 3 + 1);
+        };
+    }
+    
+    public static LongEmitter collatzLong(long start) {
+        return action -> {
+            action.accept(start);
+            return start == 1 ? null : collatzLong(start % 2 == 0 ? start / 2 : start * 3 + 1);
+        };
+    }
+
     // Reads numbers from scanner stopping when non-number is encountered
     public static Emitter<Integer> scannerInts(Scanner sc) {
         return sc.hasNextInt() ? action -> {
@@ -128,10 +146,42 @@ public class StreamExEmitterTest {
         };
     }
 
+    public static IntEmitter flatTestInt(int start) {
+        return action -> {
+            for (int i = 0; i < start; i++)
+                action.accept(start);
+            return start == 0 ? null : flatTestInt(start - 1);
+        };
+    }
+    
+    public static LongEmitter flatTestLong(int start) {
+        return action -> {
+            for (int i = 0; i < start; i++)
+                action.accept(start);
+            return start == 0 ? null : flatTestLong(start - 1);
+        };
+    }
+    
+    public static DoubleEmitter flatTestDouble(int start) {
+        return action -> {
+            for (int i = 0; i < start; i++)
+                action.accept(start);
+            return start == 0 ? null : flatTestDouble(start - 1);
+        };
+    }
+    
     @Test
     public void testEmitter() {
         assertEquals(asList(17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1), collatz(17).stream().toList());
+        checkSpliterator("collatz", asList(17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1), collatz(17)::spliterator);
+        assertArrayEquals(new int[] {17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1}, collatzInt(17).stream().toArray());
+        checkSpliterator("collatzInt", asList(17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1), collatzInt(17)::spliterator);
+        assertArrayEquals(new long[] {17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1}, collatzLong(17).stream().toArray());
+        checkSpliterator("collatzLong", asList(17L, 52L, 26L, 13L, 40L, 20L, 10L, 5L, 16L, 8L, 4L, 2L, 1L),
+            collatzLong(17)::spliterator);
         assertTrue(collatz(17).stream().has(1));
+        assertTrue(collatzInt(17).stream().has(1));
+        assertFalse(collatzLong(17).stream().has(0));
         assertEquals(asList(4, 4, 4, 4, 4), generate(() -> 4).stream().limit(5).toList());
         assertEquals(asList(1, 2, 3, 4, 5, 6, 7, 8, 9), iterate(1, x -> x < 10, x -> x + 1).stream().toList());
         Scanner sc = new Scanner("1 2 3 4 test");
@@ -158,5 +208,10 @@ public class StreamExEmitterTest {
         
         assertEquals(asList(4, 4, 4, 4, 3, 3, 3, 2, 2, 1), flatTest(4).stream().toList());
         assertEquals(asList(4, 4, 4, 4, 3, 3, 3, 2, 2), flatTest(4).stream().limit(9).toList());
+        
+        checkSpliterator("flatTest", asList(4, 4, 4, 4, 3, 3, 3, 2, 2, 1), flatTest(4)::spliterator);
+        checkSpliterator("flatTest", asList(4, 4, 4, 4, 3, 3, 3, 2, 2, 1), flatTestInt(4)::spliterator);
+        checkSpliterator("flatTest", asList(4L, 4L, 4L, 4L, 3L, 3L, 3L, 2L, 2L, 1L), flatTestLong(4)::spliterator);
+        checkSpliterator("flatTest", asList(4.0, 4.0, 4.0, 4.0, 3.0, 3.0, 3.0, 2.0, 2.0, 1.0), flatTestDouble(4)::spliterator);
     }
 }
diff --git a/src/test/java/one/util/streamex/TestHelpers.java b/src/test/java/one/util/streamex/TestHelpers.java
index 154ce00..23a9e38 100644
--- a/src/test/java/one/util/streamex/TestHelpers.java
+++ b/src/test/java/one/util/streamex/TestHelpers.java
@@ -304,6 +304,15 @@ public class TestHelpers {
             }
         }
         assertEquals(msg, expected, seq);
+        
+        // Test advance+remaining
+        for (int i = 1; i < Math.min(4, expected.size() - 1); i++) {
+            seq.clear();
+            sequential = supplier.get();
+            for(int j=0; j<i; j++) assertTrue(msg, sequential.tryAdvance(seq::add));
+            sequential.forEachRemaining(seq::add);
+            assertEquals(msg, expected, seq);
+        }
 
         // Test trySplit
         Random r = new Random(1);
