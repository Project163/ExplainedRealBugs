diff --git a/src/main/java/javax/util/streamex/Joining.java b/src/main/java/javax/util/streamex/Joining.java
index c540c06..9f5e5bd 100644
--- a/src/main/java/javax/util/streamex/Joining.java
+++ b/src/main/java/javax/util/streamex/Joining.java
@@ -15,6 +15,7 @@
  */
 package javax.util.streamex;
 
+import java.text.BreakIterator;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
@@ -30,22 +31,113 @@ import static javax.util.streamex.StreamExInternals.*;
 /**
  * @author Tagir Valeev
  */
-public class Joining extends CancellableCollector<CharSequence, Joining.Accumulator, String>{
+public class Joining extends CancellableCollector<CharSequence, Joining.Accumulator, String> {
     static class Accumulator {
         List<CharSequence> data = new ArrayList<>();
-        int count = 0;
+        int chars = 0, count = 0;
+    }
+
+    private static final int CUT_ANYWHERE = 0;
+    private static final int CUT_CODEPOINT = 1;
+    private static final int CUT_SYMBOL = 2;
+    private static final int CUT_WORD = 3;
+    private static final int CUT_BEFORE_DELIMITER = 4;
+    private static final int CUT_AFTER_DELIMITER = 5;
+
+    private static final int LENGTH_CHARS = 0;
+    private static final int LENGTH_CODEPOINTS = 1;
+    private static final int LENGTH_SYMBOLS = 2;
+
+    private final String delimiter, ellipsis, prefix, suffix;
+    private final int cutStrategy, lenStrategy, maxLength;
+
+    private Joining(String delimiter, String ellipsis, String prefix, String suffix, int cutStrategy, int lenStrategy,
+            int maxLength) {
+        this.delimiter = delimiter;
+        this.ellipsis = ellipsis;
+        this.prefix = prefix;
+        this.suffix = suffix;
+        this.cutStrategy = cutStrategy;
+        this.lenStrategy = lenStrategy;
+        this.maxLength = maxLength;
     }
     
-    private final String delimiter;
+    private int length(CharSequence s) {
+        switch(lenStrategy) {
+        case LENGTH_CHARS:
+            return s.length();
+        case LENGTH_CODEPOINTS:
+            if(s instanceof String)
+                return ((String)s).codePointCount(0, s.length());
+            return (int) s.codePoints().count();
+        case LENGTH_SYMBOLS:
+            BreakIterator bi = BreakIterator.getCharacterInstance();
+            bi.setText(s.toString());
+            int count = 0;
+            for (int end = bi.next();
+                 end != BreakIterator.DONE;
+                 end = bi.next()) count++;
+            return count;
+        default:
+            throw new InternalError();
+        }
+    }
+    
+    private static int nonNegative(int limit) {
+        if(limit < 0)
+            throw new IllegalArgumentException(limit+": must be positive");
+        return limit;
+    }
+
+    public static Joining on(CharSequence delimiter) {
+        return new Joining(delimiter.toString(), "...", "", "", CUT_CODEPOINT, LENGTH_CHARS, -1);
+    }
+
+    public Joining wrap(CharSequence prefix, CharSequence suffix) {
+        return new Joining(delimiter, ellipsis, prefix.toString().concat(this.prefix), this.suffix.concat(suffix
+                .toString()), cutStrategy, lenStrategy, maxLength);
+    }
     
-    private Joining(CharSequence delimiter) {
-        this.delimiter = delimiter.toString();
+    public Joining ellipsis(CharSequence ellipsis) {
+        return new Joining(delimiter, ellipsis.toString(), prefix, suffix, cutStrategy, lenStrategy, maxLength);
     }
     
-    public static Joining with(CharSequence delimiter) {
-        return new Joining(delimiter);
+    public Joining maxChars(int limit) {
+        return new Joining(delimiter, ellipsis, prefix, suffix, cutStrategy, LENGTH_CHARS, nonNegative(limit));
+    }
+
+    public Joining maxCodePoints(int limit) {
+        return new Joining(delimiter, ellipsis, prefix, suffix, cutStrategy, LENGTH_CODEPOINTS, nonNegative(limit));
     }
 
+    public Joining maxSymbols(int limit) {
+        return new Joining(delimiter, ellipsis, prefix, suffix, cutStrategy, LENGTH_SYMBOLS, nonNegative(limit));
+    }
+    
+    public Joining cutAnywhere() {
+        return new Joining(delimiter, ellipsis, prefix, suffix, CUT_ANYWHERE, lenStrategy, maxLength);
+    }
+    
+    public Joining cutAfterCodePoint() {
+        return new Joining(delimiter, ellipsis, prefix, suffix, CUT_CODEPOINT, lenStrategy, maxLength);
+    }
+    
+    public Joining cutAfterSymbol() {
+        return new Joining(delimiter, ellipsis, prefix, suffix, CUT_SYMBOL, lenStrategy, maxLength);
+    }
+    
+    public Joining cutAfterWord() {
+        return new Joining(delimiter, ellipsis, prefix, suffix, CUT_WORD, lenStrategy, maxLength);
+    }
+    
+    public Joining cutBeforeDelimiter() {
+        return new Joining(delimiter, ellipsis, prefix, suffix, CUT_BEFORE_DELIMITER, lenStrategy, maxLength);
+    }
+    
+    public Joining cutAfterDelimiter() {
+        return new Joining(delimiter, ellipsis, prefix, suffix, CUT_AFTER_DELIMITER, lenStrategy, maxLength);
+    }
+    
     @Override
     public Supplier<Accumulator> supplier() {
         return Accumulator::new;
@@ -53,44 +145,85 @@ public class Joining extends CancellableCollector<CharSequence, Joining.Accumula
 
     @Override
     public BiConsumer<Accumulator, CharSequence> accumulator() {
+        if(maxLength == -1)
+            return (acc, str) -> {
+                if (!acc.data.isEmpty())
+                    acc.chars += delimiter.length();
+                acc.chars += str.length();
+                acc.data.add(str);
+            };
+        int delimCount = length(delimiter);
+        int reducedMax = maxLength-length(prefix)-length(suffix);
         return (acc, str) -> {
-            if(!acc.data.isEmpty())
-                acc.count+=delimiter.length();
-            acc.count+=str.length();
-            acc.data.add(str);
+            if(acc.count <= reducedMax) {
+                if (!acc.data.isEmpty()) {
+                    acc.chars += delimiter.length();
+                    acc.count += delimCount;
+                }
+                acc.chars += str.length();
+                acc.count += length(str);
+                acc.data.add(str);
+            }
         };
     }
 
     @Override
     public BinaryOperator<Accumulator> combiner() {
+        if(maxLength == -1)
+            return (acc1, acc2) -> {
+                if (acc1.data.isEmpty())
+                    return acc2;
+                if (acc2.data.isEmpty())
+                    return acc1;
+                acc1.chars += delimiter.length() + acc2.chars;
+                acc1.data.addAll(acc2.data);
+                return acc1;
+            };
+        int delimCount = length(delimiter);
+        int reducedMax = maxLength-length(prefix)-length(suffix);
+        BiConsumer<Accumulator, CharSequence> accumulator = accumulator();
         return (acc1, acc2) -> {
-            if(acc1.data.isEmpty())
+            if (acc1.data.isEmpty())
                 return acc2;
-            if(acc2.data.isEmpty())
+            if (acc2.data.isEmpty())
                 return acc1;
-            acc1.count+=delimiter.length()+acc2.count;
-            acc1.data.addAll(acc2.data);
+            int len = acc1.count + acc2.count + delimCount;
+            if (len <= reducedMax) {
+                acc1.count = len;
+                acc1.chars += delimiter.length() + acc2.chars;
+                acc1.data.addAll(acc2.data);
+            } else {
+                for (CharSequence s : acc2.data) {
+                    if (acc1.count > reducedMax)
+                        break;
+                    accumulator.accept(acc1, s);
+                }
+            }
             return acc1;
         };
     }
 
     @Override
     public Function<Accumulator, String> finisher() {
-        return acc -> {
-            char[] buf = new char[acc.count];
-            int pos = 0;
-            int size = acc.data.size();
-            for(int i=0; i<size; i++) {
-                if(i > 0) {
-                    delimiter.getChars(0, delimiter.length(), buf, pos);
-                    pos+=delimiter.length();
+        if(maxLength == -1)
+            return acc -> {
+                char[] buf = new char[acc.chars+prefix.length()+suffix.length()];
+                int size = acc.data.size();
+                prefix.getChars(0, prefix.length(), buf, 0);
+                int pos = prefix.length();
+                for (int i = 0; i < size; i++) {
+                    if (i > 0) {
+                        delimiter.getChars(0, delimiter.length(), buf, pos);
+                        pos += delimiter.length();
+                    }
+                    String cs = acc.data.get(i).toString();
+                    cs.getChars(0, cs.length(), buf, pos);
+                    pos += cs.length();
                 }
-                String cs = acc.data.get(i).toString();
-                cs.getChars(0, cs.length(), buf, pos);
-                pos+=cs.length();
-            }
-            return new String(buf);
-        };
+                suffix.getChars(0, suffix.length(), buf, pos);
+                return new String(buf);
+            };
+        throw new UnsupportedOperationException(); // TODO
     }
 
     @Override
@@ -100,6 +233,11 @@ public class Joining extends CancellableCollector<CharSequence, Joining.Accumula
 
     @Override
     Predicate<Accumulator> finished() {
-        return null;
+        if(maxLength == -1)
+            return null;
+        int addCount = length(prefix)+length(suffix);
+        if(maxLength <= addCount)
+            return acc -> true;
+        return acc -> acc.count > addCount;
     }
 }
diff --git a/src/test/java/javax/util/streamex/JoiningTest.java b/src/test/java/javax/util/streamex/JoiningTest.java
index 7e7815a..eddbf87 100644
--- a/src/test/java/javax/util/streamex/JoiningTest.java
+++ b/src/test/java/javax/util/streamex/JoiningTest.java
@@ -15,14 +15,13 @@
  */
 package javax.util.streamex;
 
+import static javax.util.streamex.TestHelpers.checkCollector;
+
 import java.util.function.Supplier;
-import java.util.stream.Collector;
 import java.util.stream.Collectors;
 import java.util.stream.IntStream;
 import java.util.stream.Stream;
 
-import static javax.util.streamex.TestHelpers.*;
-
 import org.junit.Test;
 
 /**
@@ -31,8 +30,11 @@ import org.junit.Test;
 public class JoiningTest {
     @Test
     public void testSimple() {
-        Collector<CharSequence, ?, String> joining = Joining.with(", ");
         Supplier<Stream<String>> s = () -> IntStream.range(0, 100).mapToObj(String::valueOf);
-        checkCollector("joiningSimple", s.get().collect(Collectors.joining(", ")), s, joining);
+        checkCollector("joiningSimple", s.get().collect(Collectors.joining(", ")), s, Joining.on(", "));
+        checkCollector("joiningWrap", s.get().collect(Collectors.joining(", ", "[", "]")), s,
+            Joining.on(", ").wrap("[", "]"));
+        checkCollector("joiningWrap2", s.get().collect(Collectors.joining(", ", "[(", ")]")), s, Joining.on(", ")
+                .wrap("(", ")").wrap("[", "]"));
     }
 }
