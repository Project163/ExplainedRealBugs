diff --git a/src/main/java/one/util/streamex/StreamEx.java b/src/main/java/one/util/streamex/StreamEx.java
index ba79050..b3b645a 100644
--- a/src/main/java/one/util/streamex/StreamEx.java
+++ b/src/main/java/one/util/streamex/StreamEx.java
@@ -1339,15 +1339,77 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
             return left;
         }).map(pair -> mapper.apply(pair.a, pair.b));
     }
-    
+
+    /**
+     * Creates an {@link EntryStream} consisting of the {@link Entry} objects
+     * which keys are all the same and equal to the first element of this stream
+     * and values are the rest elements of this stream.
+     * 
+     * <p>
+     * This is an <a href="package-summary.html#StreamOps">quasi-intermediate
+     * operation</a>.
+     * 
+     * <p>
+     * The size of the resulting stream is one element less than the input
+     * stream. If the input stream is empty or contains just one element, then
+     * the output stream will be empty.
+     *
+     * @return the new stream
+     * @see #withFirst(BiFunction)
+     * @since 0.5.3
+     */
     public EntryStream<T, T> withFirst() {
         return strategy().newEntryStream(delegate(new WithFirstSpliterator<>(stream.spliterator())));
     }
 
-    public <U> StreamEx<U> withFirst(BiFunction<? super T, ? super StreamEx<T>, ? extends Stream<U>> mapper) {
-        return strategy().newStreamEx(delegate(new WithFirstMapperSpliterator<>(stream.spliterator(), mapper)));
+    /**
+     * Creates a new Stream which is the result of applying of the supplied
+     * mapper {@code BiFunction} to the first element of the current stream and
+     * the stream containing the rest elements. (If a mapped stream is
+     * {@code null} an empty stream is used, instead.)
+     * 
+     * <p>
+     * This is an <a href="package-summary.html#StreamOps">quasi-intermediate
+     * operation</a>.
+     * 
+     * <p>
+     * The mapper function is not applied when the input stream is empty.
+     * Otherwise it's applied at most once during the stream terminal operation
+     * execution. Sometimes it's useful to generate stream recursively like
+     * this:
+     * 
+     * <pre>{@code
+     * // Returns lazily-generated stream which performs scanLeft operation on the input
+     * static <T> StreamEx<T> scanLeft(StreamEx<T> input, BinaryOperator<T> operator) {
+     *     return input.withFirst((head, stream) -> scanLeft(stream.mapFirst(cur -> operator.apply(head, cur)), operator)
+     *           .prepend(head));
+     * }}</pre>
+     * 
+     * <p>
+     * Use caution though as this might lead to {@code StackOverflowError} for
+     * long input stream.
+     * 
+     * <p>
+     * This operation might perform badly with parallel streams. Sometimes the
+     * same semantics could be expressed using {@link #withFirst()} method with
+     * subsequent mapping or filtering. Consider using {@code withFirst()} if
+     * its possible in your case.
+     *
+     * @param <R> The element type of the new stream
+     * @param mapper a <a
+     *        href="package-summary.html#NonInterference">non-interfering</a>,
+     *        <a href="package-summary.html#Statelessness">stateless</a>
+     *        function to apply to the first stream element and the stream of
+     *        the rest elements which creates a new stream.
+     * @return the new stream
+     * @see #withFirst()
+     * @since 0.5.3
+     */
+    public <R> StreamEx<R> withFirst(BiFunction<? super T, ? super StreamEx<T>, ? extends Stream<R>> mapper) {
+        WithFirstMapperSpliterator<T, R> spliterator = new WithFirstMapperSpliterator<>(stream.spliterator(), mapper);
+        return strategy().newStreamEx(delegate(spliterator).onClose(spliterator::close));
     }
-    
+
     /**
      * Returns an empty sequential {@code StreamEx}.
      *
diff --git a/src/main/java/one/util/streamex/WithFirstMapperSpliterator.java b/src/main/java/one/util/streamex/WithFirstMapperSpliterator.java
index d11fc0c..93ebe83 100644
--- a/src/main/java/one/util/streamex/WithFirstMapperSpliterator.java
+++ b/src/main/java/one/util/streamex/WithFirstMapperSpliterator.java
@@ -16,9 +16,11 @@
 package one.util.streamex;
 
 import java.util.Spliterator;
+import java.util.Spliterators;
 import java.util.Spliterators.AbstractSpliterator;
 import java.util.function.BiFunction;
 import java.util.function.Consumer;
+import java.util.stream.BaseStream;
 import java.util.stream.Stream;
 
 import static one.util.streamex.StreamExInternals.*;
@@ -30,6 +32,7 @@ import static one.util.streamex.StreamExInternals.*;
     private final Spliterator<T> source;
     private final BiFunction<? super T, ? super StreamEx<T>, ? extends Stream<U>> mapper;
     private Spliterator<U> target;
+    private BaseStream<?, ?> stream;
     
     WithFirstMapperSpliterator(Spliterator<T> source, BiFunction<? super T, ? super StreamEx<T>, ? extends Stream<U>> mapper) {
         super(Long.MAX_VALUE, ORDERED);
@@ -56,10 +59,17 @@ import static one.util.streamex.StreamExInternals.*;
             if(!source.tryAdvance(x -> first.a = x)) {
                 return false;
             }
-            target = mapper.apply(first.a, StreamEx.of(source)).spliterator();
+            Stream<U> stream = mapper.apply(first.a, StreamEx.of(source));
+            this.stream = stream;
+            target = stream == null ? Spliterators.emptySpliterator() : stream.spliterator();
         }
         return true;
     }
+    
+    void close() {
+        if(stream != null)
+            stream.close();
+    }
 
     @Override
     public long estimateSize() {
diff --git a/src/test/java/one/util/streamex/StreamExTest.java b/src/test/java/one/util/streamex/StreamExTest.java
index 7173bda..3f3094b 100644
--- a/src/test/java/one/util/streamex/StreamExTest.java
+++ b/src/test/java/one/util/streamex/StreamExTest.java
@@ -1542,13 +1542,45 @@ public class StreamExTest {
         
         streamEx(() -> IntStreamEx.range(100).boxed(), s -> assertEquals(IntStreamEx.rangeClosed(99, 0, -1).boxed()
                 .toList(), reverse(s.get()).toList()));
+        
+        streamEx(() -> StreamEx.of(1, 2), s -> assertEquals(0, s.get().withFirst((head, stream) -> null).count()));
+        
+        streamEx(() -> StreamEx.iterate(1, x -> x + 1), s -> assertEquals(asList(1, 3, 6, 10, 15, 21, 28, 36, 45, 55,
+            66, 78, 91), scanLeft(s.get(), Integer::sum).takeWhile(x -> x < 100).toList()));
     }
     
+    // Filters the input stream of natural numbers (2, 3, 4...) leaving only prime numbers
     private static StreamEx<Integer> sieve(StreamEx<Integer> input) {
         return input.withFirst((head, stream) -> sieve(stream.filter(n -> n % head != 0)).prepend(head));
     }
-    
+
+    // Creates a reversed stream
     private static <T> StreamEx<T> reverse(StreamEx<T> input) {
         return input.withFirst((head, stream) -> reverse(stream).append(head));
     }
+    
+    // Creates lazy scanLeft stream
+    private static <T> StreamEx<T> scanLeft(StreamEx<T> input, BinaryOperator<T> operator) {
+        return input.withFirst((head, stream) -> scanLeft(stream.mapFirst(cur -> operator.apply(head, cur)), operator)
+                .prepend(head));
+    }
+    
+    @Test
+    public void testWithFirstClose() {
+        AtomicBoolean origClosed = new AtomicBoolean();
+        AtomicBoolean internalClosed = new AtomicBoolean();
+        AtomicBoolean finalClosed = new AtomicBoolean();
+        StreamEx<Object> res = StreamEx.of(1, 2, 3).onClose(() -> origClosed.set(true)).withFirst(
+            (head, stream) -> stream.onClose(() -> internalClosed.set(true)).map(x -> x + head)).onClose(
+            () -> finalClosed.set(true));
+        assertEquals(asList(3, 4), res.toList());
+        res.close();
+        assertTrue(origClosed.get());
+        assertTrue(internalClosed.get());
+        assertTrue(finalClosed.get());
+        
+        res = StreamEx.empty().withFirst((head, tail) -> tail);
+        assertEquals(0, res.count());
+        res.close();
+    }
 }
