diff --git a/src/main/java/one/util/streamex/Limiter.java b/src/main/java/one/util/streamex/Limiter.java
index 7420de7..bf4099f 100644
--- a/src/main/java/one/util/streamex/Limiter.java
+++ b/src/main/java/one/util/streamex/Limiter.java
@@ -43,17 +43,15 @@ import java.util.stream.Collector;
  */
 /* package */class Limiter<T> extends AbstractCollection<T> {
     private final T[] pq;
-    private final T[] series;
-    private final int[] order;
+    private T[] series;
+    private int[] order;
     private final Comparator<? super T> comparator;
     private int size, maxOrder, head, tail;
 
     @SuppressWarnings("unchecked")
     public Limiter(int limit, Comparator<? super T> comparator) {
         // limit >= 2
-        pq = (T[]) new Object[limit];
-        series = (T[]) new Object[limit];
-        order = new int[limit];
+        this.pq = (T[]) new Object[limit];
         this.comparator = comparator;
     }
 
@@ -66,23 +64,26 @@ import java.util.stream.Collector;
         return this;
     }
 
+    @SuppressWarnings("unchecked")
     public boolean put(T t) {
         int limit = pq.length;
         if (size < limit) {
-            pq[size] = t;
-            if (++size == limit) {
-                Arrays.sort(pq, comparator);
-                Collections.reverse(Arrays.asList(pq));
-                for (int j = 0; j < limit; j++) {
-                    order[j] = limit - j - 1;
-                }
-            }
+            pq[size++] = t;
             return true;
         }
-        if (comparator.compare(t, pq[0]) >= 0)
-            return false;
         if (maxOrder == 0) {
+            Arrays.sort(pq, comparator);
+            Collections.reverse(Arrays.asList(pq));
             maxOrder = limit;
+        }
+        if (comparator.compare(t, pq[0]) >= 0)
+            return false;
+        if (order == null) {
+            order = new int[limit];
+            for (int j = 0; j < limit; j++) {
+                order[j] = limit - j - 1;
+            }
+            series = (T[]) new Object[limit];
             series[0] = t;
             return true;
         }
@@ -158,17 +159,16 @@ import java.util.stream.Collector;
     }
 
     public void sort() {
-        int limit = pq.length;
-        if (size < limit)
+        if (maxOrder == 0)
             Arrays.sort(pq, 0, size, comparator);
         else {
-            if (maxOrder == 0) {
+            if (order == null) {
                 Collections.reverse(Arrays.asList(pq));
-                return;
+            } else {
+                drain();
+                // Respect order also
+                quickSort(0, pq.length - 1);
             }
-            drain();
-            // Respect order also
-            quickSort(0, limit - 1);
         }
     }
 
diff --git a/src/main/java/one/util/streamex/MoreCollectors.java b/src/main/java/one/util/streamex/MoreCollectors.java
index 19ba177..18913b4 100644
--- a/src/main/java/one/util/streamex/MoreCollectors.java
+++ b/src/main/java/one/util/streamex/MoreCollectors.java
@@ -680,15 +680,11 @@ public final class MoreCollectors {
         if (n <= 0)
             return empty();
         if (n == 1) {
-            BiConsumer<Box<T>, T> accumulator = (box, t) -> {
+            return Collector.of(() -> new Box<T>(none()), (box, t) -> {
                 if (box.a == NONE || comparator.compare(t, box.a) < 0)
                     box.a = t;
-            };
-            return Collector.of(() -> new Box<T>(none()), accumulator, (box1, box2) -> {
-                if(box2.a != NONE)
-                    accumulator.accept(box1, box2.a);
-                return box1;
-            }, box -> box.a == NONE ? new ArrayList<>() : new ArrayList<>(Collections.singleton(box.a)));
+            }, (box1, box2) -> (box2.a != NONE && (box1.a == NONE || comparator.compare(box2.a, box1.a) < 0)) ? box2
+                    : box1, box -> box.a == NONE ? new ArrayList<>() : new ArrayList<>(Collections.singleton(box.a)));
         }
         if (n > 10000)
             return collectingAndThen(Collectors.toList(), list -> {
diff --git a/src/test/java/one/util/streamex/LimiterTest.java b/src/test/java/one/util/streamex/LimiterTest.java
index bef0469..10134a1 100644
--- a/src/test/java/one/util/streamex/LimiterTest.java
+++ b/src/test/java/one/util/streamex/LimiterTest.java
@@ -36,24 +36,24 @@ public class LimiterTest {
         exerciseLimiter("str", Arrays.asList("abc", "abgdc", "abd", "a", "fgssdfg", "sfsvsx", null,
             "wrffvs", "xcvbxvcb", "sffg", "abe", "adf", "abh"), cmp);
         for(int i : new int[] {10, 100, 1000, 10000, 100000}) {
-            exerciseLimiter("asc, nat, "+i, IntStream.range(0, i).boxed().collect(Collectors.toList()), Comparator.<Integer>naturalOrder());
+            exerciseLimiter("asc, nat, "+i, IntStream.range(0, i).boxed().collect(Collectors.toList()), Comparator.naturalOrder());
             exerciseLimiter("asc, dec, "+i, IntStream.range(0, i).boxed().collect(Collectors.toList()), Comparator.comparingInt(x -> x/10));
-            exerciseLimiter("desc, nat, "+i, IntStream.range(0, i).mapToObj(x -> ~x).collect(Collectors.toList()), Comparator.<Integer>naturalOrder());
+            exerciseLimiter("desc, nat, "+i, IntStream.range(0, i).mapToObj(x -> ~x).collect(Collectors.toList()), Comparator.naturalOrder());
             exerciseLimiter("desc, dec, "+i, IntStream.range(0, i).mapToObj(x -> ~x).collect(Collectors.toList()), Comparator.comparingInt(x -> x/10));
-            exerciseLimiter("rnd, nat, "+i, new Random(1).ints(i).boxed().collect(Collectors.toList()), Comparator.<Integer>naturalOrder());
+            exerciseLimiter("rnd, nat, "+i, new Random(1).ints(i).boxed().collect(Collectors.toList()), Comparator.naturalOrder());
             exerciseLimiter("rnd, dec, "+i, new Random(1).ints(i).boxed().collect(Collectors.toList()), Comparator.comparingInt(x -> x/10));
-            exerciseLimiter("rnd2, nat, "+i, new Random(1).ints(i, -1000, 1000).boxed().collect(Collectors.toList()), Comparator.<Integer>naturalOrder());
+            exerciseLimiter("rnd2, nat, "+i, new Random(1).ints(i, -1000, 1000).boxed().collect(Collectors.toList()), Comparator.naturalOrder());
             exerciseLimiter("rnd2, dec, "+i, new Random(1).ints(i, -1000, 1000).boxed().collect(Collectors.toList()), Comparator.comparingInt(x -> x/10));
         }
     }
     
-    public static <T> void exerciseLimiter(String msg, Collection<T> input, Comparator<? super T> comp) {
+    public static <T> void exerciseLimiter(String msg, Collection<T> input, Comparator<T> comp) {
         for(int limit : new int[] {0, 1, 2, 5, 10, 20, 100, 1000}) {
             exerciseLimiter(msg, input, limit, comp);
         }
     }
 
-    public static <T> void exerciseLimiter(String msg, Collection<T> input, int limit, Comparator<? super T> comp) {
+    public static <T> void exerciseLimiter(String msg, Collection<T> input, int limit, Comparator<T> comp) {
         List<T> expected = input.stream().sorted(comp).limit(limit).collect(Collectors.toList());
         List<T> actual = input.stream().collect(MoreCollectors.least(comp, limit));
         assertEquals("Mismatch (sequential), "+msg+", limit="+limit, expected, actual);
