diff --git a/CHANGES.md b/CHANGES.md
index 579fdef..71aff77 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -7,6 +7,7 @@ Check also [MIGRATION.md](MIGRATION.md) for possible compatibility problems.
 * [#90] Changed: `AbstractStreamEx` class (which shares common functionality of `StreamEx` and `EntryStream`) is public now.
 * [#92] Added: `IntStreamEx.of(InputStream)`.
 * [#93] Added: `IntStreamEx.asByteInputStream()`.
+* [#94] Added: `prefix` method for all stream types.
 
 ### 0.6.0
 Warning: this release introduces some changes which may break backwards compatibility.
diff --git a/CHEATSHEET.md b/CHEATSHEET.md
index 9fb781e..4a36677 100644
--- a/CHEATSHEET.md
+++ b/CHEATSHEET.md
@@ -177,6 +177,7 @@ Execute custom-defined operation in fluent manner | `any.chain()`
 Work-around parallel stream skip bug prior to Java 8u60 | `any.skipOrdered()`
 Perform parallel stream computation using the custom `ForkJoinPool` | `any.parallel(pool)`
 Zip two streams together | `StreamEx.zipWith()`
+Get the stream of cumulative prefixes | `any.prefix()`
 
 ## New terminal operations
 
diff --git a/src/main/java/one/util/streamex/AbstractStreamEx.java b/src/main/java/one/util/streamex/AbstractStreamEx.java
index c182002..fdc1215 100644
--- a/src/main/java/one/util/streamex/AbstractStreamEx.java
+++ b/src/main/java/one/util/streamex/AbstractStreamEx.java
@@ -1392,14 +1392,14 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
     }
 
     /**
-     * Produces a collection containing cumulative results of applying the
+     * Produces a list containing cumulative results of applying the
      * accumulation function going left to right using given seed value.
      * 
      * <p>
      * This is a terminal operation.
      * 
      * <p>
-     * The result {@link List} is guaranteed to be mutable.
+     * The resulting {@link List} is guaranteed to be mutable.
      * 
      * <p>
      * For parallel stream it's not guaranteed that accumulator will always be
@@ -1432,14 +1432,14 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
     }
 
     /**
-     * Produces a collection containing cumulative results of applying the
+     * Produces a list containing cumulative results of applying the
      * accumulation function going left to right.
      * 
      * <p>
      * This is a terminal operation.
      * 
      * <p>
-     * The result {@link List} is guaranteed to be mutable.
+     * The resulting {@link List} is guaranteed to be mutable.
      * 
      * <p>
      * For parallel stream it's not guaranteed that accumulator will always be
@@ -1460,6 +1460,7 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
      *         size as this stream.
      * @see #foldLeft(BinaryOperator)
      * @see #scanRight(BinaryOperator)
+     * @see #prefix(BinaryOperator)
      * @since 0.4.0
      */
     public List<T> scanLeft(BinaryOperator<T> accumulator) {
@@ -1474,14 +1475,14 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
     }
 
     /**
-     * Produces a collection containing cumulative results of applying the
+     * Produces a list containing cumulative results of applying the
      * accumulation function going right to left using given seed value.
      * 
      * <p>
      * This is a terminal operation.
      * 
      * <p>
-     * The result {@link List} is guaranteed to be mutable.
+     * The resulting {@link List} is guaranteed to be mutable.
      * 
      * <p>
      * For parallel stream it's not guaranteed that accumulator will always be
@@ -1678,6 +1679,34 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
         return supply(new AbstractStreamEx.TDOfRef<>(spliterator(), true, false, predicate));
     }
     
+    /**
+     * Returns a stream containing cumulative results of applying the
+     * accumulation function going left to right.
+     * 
+     * <p>
+     * This is a stateful <a
+     * href="package-summary.html#StreamOps">quasi-intermediate</a> operation.
+     *
+     * <p>
+     * This operation resembles {@link #scanLeft(BinaryOperator)}, but unlike
+     * {@code scanLeft} this operation is intermediate and accumulation function
+     * must be associative.
+     * 
+     * <p>
+     * This method cannot take all the advantages of parallel streams as it must
+     * process elements strictly left to right. Using an unordered source or
+     * removing the ordering constraint with {@link #unordered()} may improve
+     * the parallel processing speed.
+     *
+     * @param op an <a
+     *        href="package-summary.html#Associativity">associative</a>, <a
+     *        href="package-summary.html#NonInterference">non-interfering </a>,
+     *        <a href="package-summary.html#Statelessness">stateless</a>
+     *        function for computing the next element based on the previous one
+     * @return the new stream.
+     * @see #scanLeft(BinaryOperator)
+     * @since 0.6.1
+     */
     public S prefix(BinaryOperator<T> op) {
         Spliterator<T> spltr = spliterator();
         return supply(spltr.hasCharacteristics(Spliterator.ORDERED) ? new PrefixOps.OfRef<>(spltr, op)
diff --git a/src/main/java/one/util/streamex/DoubleStreamEx.java b/src/main/java/one/util/streamex/DoubleStreamEx.java
index d3c46a8..b27b22b 100644
--- a/src/main/java/one/util/streamex/DoubleStreamEx.java
+++ b/src/main/java/one/util/streamex/DoubleStreamEx.java
@@ -1572,6 +1572,34 @@ public class DoubleStreamEx extends BaseStreamEx<Double, DoubleStream, Spliterat
         return delegate(new DoubleStreamEx.TDOfDouble(spliterator(), true, false, predicate));
     }
 
+    /**
+     * Returns a stream containing cumulative results of applying the
+     * accumulation function going left to right.
+     * 
+     * <p>
+     * This is a stateful <a
+     * href="package-summary.html#StreamOps">quasi-intermediate</a> operation.
+     *
+     * <p>
+     * This operation resembles {@link #scanLeft(DoubleBinaryOperator)}, but
+     * unlike {@code scanLeft} this operation is intermediate and accumulation
+     * function must be associative.
+     * 
+     * <p>
+     * This method cannot take all the advantages of parallel streams as it must
+     * process elements strictly left to right. Using an unordered source or
+     * removing the ordering constraint with {@link #unordered()} may improve
+     * the parallel processing speed.
+     *
+     * @param op an <a
+     *        href="package-summary.html#Associativity">associative</a>, <a
+     *        href="package-summary.html#NonInterference">non-interfering </a>,
+     *        <a href="package-summary.html#Statelessness">stateless</a>
+     *        function for computing the next element based on the previous one
+     * @return the new stream.
+     * @see #scanLeft(DoubleBinaryOperator)
+     * @since 0.6.1
+     */
     public DoubleStreamEx prefix(DoubleBinaryOperator op) {
         return delegate(new PrefixOps.OfDouble(spliterator(), op));
     }
diff --git a/src/main/java/one/util/streamex/IntStreamEx.java b/src/main/java/one/util/streamex/IntStreamEx.java
index 6f9e96f..1ec8616 100644
--- a/src/main/java/one/util/streamex/IntStreamEx.java
+++ b/src/main/java/one/util/streamex/IntStreamEx.java
@@ -1866,6 +1866,34 @@ public class IntStreamEx extends BaseStreamEx<Integer, IntStream, Spliterator.Of
         return delegate(new PairSpliterator.PSOfInt((a, b) -> a, mapper, spliterator(), PairSpliterator.MODE_MAP_LAST));
     }
 
+    /**
+     * Returns a stream containing cumulative results of applying the
+     * accumulation function going left to right.
+     * 
+     * <p>
+     * This is a stateful <a
+     * href="package-summary.html#StreamOps">quasi-intermediate</a> operation.
+     *
+     * <p>
+     * This operation resembles {@link #scanLeft(IntBinaryOperator)}, but unlike
+     * {@code scanLeft} this operation is intermediate and accumulation function
+     * must be associative.
+     * 
+     * <p>
+     * This method cannot take all the advantages of parallel streams as it must
+     * process elements strictly left to right. Using an unordered source or
+     * removing the ordering constraint with {@link #unordered()} may improve
+     * the parallel processing speed.
+     *
+     * @param op an <a
+     *        href="package-summary.html#Associativity">associative</a>, <a
+     *        href="package-summary.html#NonInterference">non-interfering </a>,
+     *        <a href="package-summary.html#Statelessness">stateless</a>
+     *        function for computing the next element based on the previous one
+     * @return the new stream.
+     * @see #scanLeft(IntBinaryOperator)
+     * @since 0.6.1
+     */
     public IntStreamEx prefix(IntBinaryOperator op) {
         return delegate(new PrefixOps.OfInt(spliterator(), op));
     }
diff --git a/src/main/java/one/util/streamex/LongStreamEx.java b/src/main/java/one/util/streamex/LongStreamEx.java
index a3e522a..1f64c10 100644
--- a/src/main/java/one/util/streamex/LongStreamEx.java
+++ b/src/main/java/one/util/streamex/LongStreamEx.java
@@ -1632,6 +1632,34 @@ public class LongStreamEx extends BaseStreamEx<Long, LongStream, Spliterator.OfL
         return delegate(new LongStreamEx.TDOfLong(spliterator(), true, false, predicate));
     }
 
+    /**
+     * Returns a stream containing cumulative results of applying the
+     * accumulation function going left to right.
+     * 
+     * <p>
+     * This is a stateful <a
+     * href="package-summary.html#StreamOps">quasi-intermediate</a> operation.
+     *
+     * <p>
+     * This operation resembles {@link #scanLeft(LongBinaryOperator)}, but
+     * unlike {@code scanLeft} this operation is intermediate and accumulation
+     * function must be associative.
+     * 
+     * <p>
+     * This method cannot take all the advantages of parallel streams as it must
+     * process elements strictly left to right. Using an unordered source or
+     * removing the ordering constraint with {@link #unordered()} may improve
+     * the parallel processing speed.
+     *
+     * @param op an <a
+     *        href="package-summary.html#Associativity">associative</a>, <a
+     *        href="package-summary.html#NonInterference">non-interfering </a>,
+     *        <a href="package-summary.html#Statelessness">stateless</a>
+     *        function for computing the next element based on the previous one
+     * @return the new stream.
+     * @see #scanLeft(LongBinaryOperator)
+     * @since 0.6.1
+     */
     public LongStreamEx prefix(LongBinaryOperator op) {
         return delegate(new PrefixOps.OfLong(spliterator(), op));
     }
diff --git a/src/test/java/one/util/streamex/StreamExTest.java b/src/test/java/one/util/streamex/StreamExTest.java
index 999933a..8646f59 100644
--- a/src/test/java/one/util/streamex/StreamExTest.java
+++ b/src/test/java/one/util/streamex/StreamExTest.java
@@ -1791,5 +1791,8 @@ public class StreamExTest {
         
         streamEx(() -> StreamEx.constant(100L, 10000), s -> assertEquals(5000500000L,
             (long) s.get().prefix(Long::sum).reduce(0L, Long::sum)));
+
+        streamEx(() -> IntStreamEx.range(10000).boxed().unordered(), s -> assertEquals(49995000, s.get().prefix(
+            Integer::sum).mapToInt(Integer::intValue).max().getAsInt()));
     }
 }
