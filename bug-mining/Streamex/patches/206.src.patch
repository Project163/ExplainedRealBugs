diff --git a/CHANGES.md b/CHANGES.md
index 08c0749..959f26f 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -7,6 +7,7 @@ Check also [MIGRATION.md](MIGRATION.md) for possible compatibility problems.
 * [#111] Added: `StreamEx.toArray(elementClass)`
 * [#112] Added: `StreamEx.toArray(emptyArray)`
 * [#116] Added: `MoreCollectors.ifAllMatch()`
+* [#119] Added: `AbstractStreamEx.toImmutableList()`, `AbstractStreamEx.toImmutableSet()`, `EntryStream.toImmutableMap()`
 
 ### 0.6.2
 
diff --git a/CHEATSHEET.md b/CHEATSHEET.md
index f8a7f56..75e59e2 100644
--- a/CHEATSHEET.md
+++ b/CHEATSHEET.md
@@ -191,7 +191,9 @@ What I want | How to get it
 --- | ---
 Collect elements to `List`, `Set` or custom `Collection` | `StreamEx/EntryStream.toList()/toSet()/toCollection()`
 Collect elements to `List` or `Set` adding custom final step | `StreamEx/EntryStream.toListAndThen()/toSetAndThen()`
+Collect elements to immutable `List` or `Set` | `StreamEx/EntryStream.toImmutableList()/toImmutableSet()`
 Collect elements or entries to `Map` | `StreamEx/EntryStream.toMap()/toSortedMap()`
+Collect entries to immutable `Map` | `EntryStream.toImmutableMap()`
 Collect entries to `Map` adding custom final step | `EntryStream.toMapAndThen()`
 Collect entries to custom `Map` | `EntryStream.toCustomMap()`
 Partition elements using the `Predicate` | `StreamEx.partitioningBy()/partitioningTo()`
diff --git a/src/main/java/one/util/streamex/AbstractStreamEx.java b/src/main/java/one/util/streamex/AbstractStreamEx.java
index fdc1215..722284e 100644
--- a/src/main/java/one/util/streamex/AbstractStreamEx.java
+++ b/src/main/java/one/util/streamex/AbstractStreamEx.java
@@ -16,7 +16,9 @@
 package one.util.streamex;
 
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.Comparator;
 import java.util.Iterator;
 import java.util.List;
@@ -1135,11 +1137,38 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
      *
      * @return a {@code List} containing the elements of this stream
      * @see Collectors#toList()
+     * @see #toImmutableList()
      */
     @SuppressWarnings("unchecked")
     public List<T> toList() {
         return new ArrayList<>((Collection<T>) new ArrayCollection(toArray(Object[]::new)));
     }
+    
+    /**
+     * Returns an immutable {@link List} containing the elements of this stream.
+     * There's no guarantees on exact type of the returned {@code List}. The
+     * returned {@code List} is guaranteed to be serializable if all its
+     * elements are serializable.
+     *
+     * <p>
+     * This is a terminal operation.
+     *
+     * @return a {@code List} containing the elements of this stream
+     * @see #toList()
+     * @since 0.6.3
+     */
+    @SuppressWarnings("unchecked")
+    public List<T> toImmutableList() {
+        Object[] array = toArray(Object[]::new);
+        switch(array.length) {
+        case 0:
+            return Collections.emptyList();
+        case 1:
+            return Collections.singletonList((T) array[0]);
+        default:
+            return Collections.unmodifiableList(Arrays.asList((T[]) array));
+        }
+    }
 
     /**
      * Creates a {@link List} containing the elements of this stream, then
@@ -1179,6 +1208,27 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
     public Set<T> toSet() {
         return rawCollect(Collectors.toSet());
     }
+    
+    /**
+     * Returns an immutable {@link Set} containing the elements of this stream.
+     * There's no guarantees on exact type of the returned {@code Set}. In
+     * particular, no specific element order in the resulting set is guaranteed.
+     * The returned {@code Set} is guaranteed to be serializable if all its
+     * elements are serializable.
+     *
+     * <p>
+     * This is a terminal operation.
+     *
+     * @return a {@code Set} containing the elements of this stream
+     * @see #toSet()
+     * @since 0.6.3
+     */
+    public Set<T> toImmutableSet() {
+        Set<T> result = toSet();
+        if (result.size() == 0)
+            return Collections.emptySet();
+        return Collections.unmodifiableSet(result);
+    }
 
     /**
      * Creates a {@link Set} containing the elements of this stream, then
diff --git a/src/main/java/one/util/streamex/EntryStream.java b/src/main/java/one/util/streamex/EntryStream.java
index 7a49308..3ca0282 100644
--- a/src/main/java/one/util/streamex/EntryStream.java
+++ b/src/main/java/one/util/streamex/EntryStream.java
@@ -96,7 +96,7 @@ public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream
     }
 
     static <K, V> Stream<Entry<K, V>> withValue(Stream<? extends K> s, V value) {
-        return s == null ? null : s.map(key -> new SimpleImmutableEntry<K, V>(key, value));
+        return s == null ? null : s.map(key -> new SimpleImmutableEntry<>(key, value));
     }
 
     static <K, V> Stream<Entry<K, V>> withKey(K key, Stream<? extends V> s) {
@@ -972,6 +972,7 @@ public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream
      *         (according to {@link Object#equals(Object)})
      * @see Collectors#toMap(Function, Function)
      * @see Collectors#toConcurrentMap(Function, Function)
+     * @see #toImmutableMap()
      */
     public Map<K, V> toMap() {
         Map<K, V> map = isParallel() ? new ConcurrentHashMap<>() : new HashMap<>();
@@ -979,6 +980,27 @@ public class EntryStream<K, V> extends AbstractStreamEx<Entry<K, V>, EntryStream
         return map;
     }
 
+    /**
+     * Returns an immutable {@link Map} containing the elements of this stream.
+     * There's no guarantees on exact type of the returned {@code Map}. In
+     * particular, no specific element order in the resulting {@code Map} is
+     * guaranteed. The returned {@code Map} is guaranteed to be serializable if
+     * all its elements are serializable.
+     *
+     * <p>
+     * This is a terminal operation.
+     *
+     * @return a {@code Map} containing the elements of this stream
+     * @throws IllegalStateException if this stream contains duplicate keys
+     *         (according to {@link Object#equals(Object)})
+     * @see #toMap()
+     * @since 0.6.3
+     */
+    public Map<K, V> toImmutableMap() {
+        Map<K, V> map = toMap();
+        return map.isEmpty() ? Collections.emptyMap() : Collections.unmodifiableMap(map);
+    }
+    
     /**
      * Creates a {@link Map} containing the elements of this stream, then
      * performs finishing transformation and returns its result. There are no
diff --git a/src/test/java/one/util/streamex/EntryStreamTest.java b/src/test/java/one/util/streamex/EntryStreamTest.java
index 036c7b2..12c4bf9 100644
--- a/src/test/java/one/util/streamex/EntryStreamTest.java
+++ b/src/test/java/one/util/streamex/EntryStreamTest.java
@@ -627,4 +627,24 @@ public class EntryStreamTest {
         assertEquals(EntryStream.of(1, "a", 2, "b", 3, "c").toList(), EntryStream.of(1, "a", 2, "b", 2, "b", 3, "c")
                 .chain(StreamEx::of).collapse(Objects::equals).toList());
     }
+    
+    @Test
+    public void testImmutableMap() {
+        repeat(4, n -> {
+            Map<Integer, Integer> expected = new HashMap<>();
+            for (int i = n; i < 4; i++)
+                expected.put(i, i);
+            streamEx(() -> IntStreamEx.range(4).atLeast(n).boxed(), s -> {
+                Map<Integer, Integer> map = s.get().mapToEntry(Function.identity()).toImmutableMap();
+                assertEquals(expected, map);
+                try {
+                    map.put(-1, -1);
+                    fail("added");
+                } catch (UnsupportedOperationException e) {
+                    // expected
+                }
+            });
+        });
+
+    }
 }
diff --git a/src/test/java/one/util/streamex/StreamExTest.java b/src/test/java/one/util/streamex/StreamExTest.java
index 0247a39..563270f 100644
--- a/src/test/java/one/util/streamex/StreamExTest.java
+++ b/src/test/java/one/util/streamex/StreamExTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2015, 2016 Tagir Valeev
+ * Copyright 2015, 2016 Tagir Vetaleev
  * 
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -1933,4 +1933,46 @@ public class StreamExTest {
         assertEquals(Optional.of(999), maxWithStop(IntStreamEx.of(new Random(1), 10000, 0, 1000).boxed(), Comparator
                 .naturalOrder(), 1000));
     }
+    
+    @Test
+    public void testToImmutableList() {
+        List<Integer> expected = asList(1,2,3);
+        repeat(4, n -> {
+            streamEx(() -> IntStreamEx.range(4).atLeast(n).boxed(), s -> 
+            {
+                List<Integer> list = s.get().toImmutableList();
+                assertEquals(expected.subList(n-1, expected.size()), list);
+                try {
+                    list.add(0);
+                    fail("added");
+                } catch (UnsupportedOperationException e) {
+                    // expected
+                }
+                try {
+                    list.set(0, 0);
+                    fail("set");
+                } catch (UnsupportedOperationException e) {
+                    // expected
+                }
+            });
+        });
+    }
+
+    @Test
+    public void testToImmutableSet() {
+        List<Integer> expected = asList(1,2,3);
+        repeat(4, n -> {
+            streamEx(() -> IntStreamEx.range(4).atLeast(n).boxed(), s -> 
+            {
+                Set<Integer> set = s.get().toImmutableSet();
+                assertEquals(new HashSet<>(expected.subList(n-1, expected.size())), set);
+                try {
+                    set.add(-1);
+                    fail("added");
+                } catch (UnsupportedOperationException e) {
+                    // expected
+                }
+            });
+        });
+    }
 }
