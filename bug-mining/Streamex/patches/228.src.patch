diff --git a/CHANGES.md b/CHANGES.md
index c2368a5..c99075b 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -2,6 +2,10 @@
 
 Check also [MIGRATION.md](MIGRATION.md) for possible compatibility problems.
 
+### 0.7.0
+* [#193] Removed optimizations which rely on internal implementation details of Stream API (unwrap IteratorSpliterator;
+  do not delegate to Stream::close when unnecessary)
+
 ### 0.6.8
 * [#183] Added: `StreamEx.mapPartial`, `EntryStream.mapToKeyPartial/mapToValuePartial/mapKeyValuePartial`
 * [#191] Deprecated: `skipOrdered`.
diff --git a/src/main/java/one/util/streamex/StreamContext.java b/src/main/java/one/util/streamex/StreamContext.java
index 91b9593..940b5c2 100644
--- a/src/main/java/one/util/streamex/StreamContext.java
+++ b/src/main/java/one/util/streamex/StreamContext.java
@@ -20,8 +20,6 @@ import java.util.function.Function;
 import java.util.function.Supplier;
 import java.util.stream.BaseStream;
 
-import static one.util.streamex.StreamExInternals.*;
-
 /**
  * This class controls stream execution mode (parallel/sequential), custom FJP
  * and close handlers.
@@ -132,8 +130,6 @@ import static one.util.streamex.StreamExInternals.*;
     static StreamContext of(BaseStream<?, ?> stream) {
         if (stream instanceof BaseStreamEx)
             return ((BaseStreamEx<?, ?, ?, ?>) stream).context;
-        if (mustCloseStream(stream))
-            return new StreamContext(stream.isParallel()).onClose(stream::close);
-        return stream.isParallel() ? PARALLEL : SEQUENTIAL;
+        return new StreamContext(stream.isParallel()).onClose(stream::close);
     }
 }
diff --git a/src/main/java/one/util/streamex/StreamEx.java b/src/main/java/one/util/streamex/StreamEx.java
index fe92270..8ebcea8 100644
--- a/src/main/java/one/util/streamex/StreamEx.java
+++ b/src/main/java/one/util/streamex/StreamEx.java
@@ -1522,7 +1522,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * operation.
      *
      * <p>
-     * The behavior of this operation is explicitly nondeterministic. For
+     * The behavior of this operation is explicitly non-deterministic. For
      * parallel stream pipelines, this operation does <em>not</em> guarantee to
      * respect the encounter order of the stream, as doing so would sacrifice
      * the benefit of parallelism. For any given element, the action may be
@@ -2184,7 +2184,6 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      */
     public static <T> StreamEx<T> of(Stream<T> stream) {
         if (stream instanceof AbstractStreamEx) {
-            @SuppressWarnings("unchecked")
             AbstractStreamEx<T, ?> ase = (AbstractStreamEx<T, ?>) stream;
             if (ase.spliterator != null)
                 return new StreamEx<>(ase.spliterator(), ase.context);
@@ -2313,7 +2312,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see BufferedReader#lines()
      */
     public static StreamEx<String> ofLines(BufferedReader reader) {
-        return of(UnknownSizeSpliterator.optimize(reader.lines()));
+        return new StreamEx<>(reader.lines(), StreamContext.SEQUENTIAL);
     }
 
     /**
@@ -2348,7 +2347,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
     public static StreamEx<String> ofLines(Reader reader) {
         if (reader instanceof BufferedReader)
             return ofLines((BufferedReader) reader);
-        return of(UnknownSizeSpliterator.optimize(new BufferedReader(reader).lines()));
+        return ofLines(new BufferedReader(reader));
     }
 
     /**
@@ -2378,7 +2377,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @see Files#lines(Path)
      */
     public static StreamEx<String> ofLines(Path path) throws IOException {
-        return of(UnknownSizeSpliterator.optimize(Files.lines(path)));
+        return of(Files.lines(path));
     }
 
     /**
@@ -2411,7 +2410,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
      * @since 0.5.0
      */
     public static StreamEx<String> ofLines(Path path, Charset charset) throws IOException {
-        return of(UnknownSizeSpliterator.optimize(Files.lines(path, charset)));
+        return of(Files.lines(path, charset));
     }
 
     /**
@@ -2564,7 +2563,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
     public static StreamEx<String> split(CharSequence str, Pattern pattern) {
         if (str.length() == 0)
             return of("");
-        return of(UnknownSizeSpliterator.optimize(pattern.splitAsStream(str)));
+        return new StreamEx<>(pattern.splitAsStream(str), StreamContext.SEQUENTIAL);
     }
 
     /**
@@ -2599,7 +2598,7 @@ public class StreamEx<T> extends AbstractStreamEx<T, StreamEx<T>> {
                 return split(str, ch);
             }
         }
-        return of(UnknownSizeSpliterator.optimize(Pattern.compile(regex).splitAsStream(str)));
+        return new StreamEx<>(Pattern.compile(regex).splitAsStream(str), StreamContext.SEQUENTIAL);
     }
 
     /**
diff --git a/src/main/java/one/util/streamex/StreamExInternals.java b/src/main/java/one/util/streamex/StreamExInternals.java
index 3a3bb7b..adf5554 100644
--- a/src/main/java/one/util/streamex/StreamExInternals.java
+++ b/src/main/java/one/util/streamex/StreamExInternals.java
@@ -43,52 +43,9 @@ import java.util.stream.Collector.Characteristics;
         Characteristics.IDENTITY_FINISH);
     static final Set<Characteristics> ID_CHARACTERISTICS = EnumSet.of(Characteristics.IDENTITY_FINISH);
 
-    static final Field SOURCE_SPLITERATOR;
-    static final Field SOURCE_STAGE;
-    static final Field SOURCE_CLOSE_ACTION;
-    static final Field SPLITERATOR_ITERATOR;
     static final VersionSpecific VER_SPEC = System.getProperty("java.version", "")
             .compareTo("1.9") > 0 ? new Java9Specific() : new VersionSpecific();
 
-    static {
-        Deque<Field> fields = new ArrayDeque<>();
-        /*
-         * Fields accessed via reflection are used only for reading and only to
-         * make some performance optimizations decisions. They must be never
-         * written and absence of these fields should not break anything.
-         */
-        try {
-            AccessController.doPrivileged((PrivilegedExceptionAction<Void>) () -> {
-                Class<?> abstractPipelineClass = Class.forName("java.util.stream.AbstractPipeline");
-                fields.add(abstractPipelineClass.getDeclaredField("sourceSpliterator"));
-                fields.add(abstractPipelineClass.getDeclaredField("sourceStage"));
-                fields.add(abstractPipelineClass.getDeclaredField("sourceCloseAction"));
-                fields.add(Class.forName("java.util.Spliterators$IteratorSpliterator").getDeclaredField("it"));
-                try {
-                    // Work-around Java 9 security model
-                    Field unsafeField = sun.misc.Unsafe.class.getDeclaredField("theUnsafe");
-                    unsafeField.setAccessible(true);
-                    sun.misc.Unsafe U = (sun.misc.Unsafe)unsafeField.get(null);
-                    Field override = AccessibleObject.class.getDeclaredField("override");
-                    long offset = U.objectFieldOffset(override);
-                    for (Field f : fields) {
-                        U.putBoolean(f, offset, true);
-                    }
-                } catch (LinkageError | ReflectiveOperationException | SecurityException ex) {
-                    for (Field f : fields)
-                        f.setAccessible(true);
-                }
-                return null;
-            });
-        } catch (PrivilegedActionException e) {
-            fields.clear();
-        }
-        SOURCE_SPLITERATOR = fields.poll();
-        SOURCE_STAGE = fields.poll();
-        SOURCE_CLOSE_ACTION = fields.poll();
-        SPLITERATOR_ITERATOR = fields.poll();
-    }
-
     static void checkNonNegative(String name, int value) {
         if (value < 0) {
             throw new IllegalArgumentException(name + " must be non-negative: " + value);
@@ -1010,17 +967,6 @@ import java.util.stream.Collector.Characteristics;
         return (T) NONE;
     }
 
-    static boolean mustCloseStream(BaseStream<?, ?> target) {
-        try {
-            if (SOURCE_STAGE != null && SOURCE_CLOSE_ACTION != null
-                && SOURCE_CLOSE_ACTION.get(SOURCE_STAGE.get(target)) == null)
-                return false;
-        } catch (IllegalArgumentException | IllegalAccessException e) {
-            // ignore
-        }
-        return true;
-    }
-
     static <T> int drainTo(T[] array, Spliterator<T> spliterator) {
         Box<T> box = new Box<>();
         int index = 0;
diff --git a/src/main/java/one/util/streamex/UnknownSizeSpliterator.java b/src/main/java/one/util/streamex/UnknownSizeSpliterator.java
index f928739..c690ca4 100644
--- a/src/main/java/one/util/streamex/UnknownSizeSpliterator.java
+++ b/src/main/java/one/util/streamex/UnknownSizeSpliterator.java
@@ -33,34 +33,6 @@ import static one.util.streamex.StreamExInternals.*;
     static final int BATCH_UNIT = 1 << 10; // batch array size increment
     static final int MAX_BATCH = 1 << 25; // max batch array size;
 
-    /**
-     * Optimize the stream created on IteratorSpliterator replacing it with
-     * UnknownSizeSpliterator.
-     * 
-     * @param stream original stream
-     * @return either original or optimized stream
-     */
-    @SuppressWarnings("unchecked")
-    static <T> Stream<T> optimize(Stream<T> stream) {
-        if (SOURCE_SPLITERATOR == null || SPLITERATOR_ITERATOR == null)
-            return stream;
-        Iterator<T> it = null;
-        try {
-            Spliterator<T> spliterator = (Spliterator<T>) SOURCE_SPLITERATOR.get(stream);
-            if (spliterator != null && !spliterator.hasCharacteristics(SIZED)
-                && spliterator.getClass().getName().equals("java.util.Spliterators$IteratorSpliterator")) {
-                it = (Iterator<T>) SPLITERATOR_ITERATOR.get(spliterator);
-            }
-        } catch (IllegalArgumentException | IllegalAccessException e) {
-            // ignore
-        }
-        if (it == null)
-            return stream;
-        //noinspection ResultOfMethodCallIgnored
-        stream.spliterator(); // consume stream
-        return StreamSupport.stream(new USOfRef<>(it), stream.isParallel()).onClose(stream::close);
-    }
-
     I it;
     int index, fence;
     long est = Long.MAX_VALUE;
diff --git a/src/test/java/one/util/streamex/StreamExTest.java b/src/test/java/one/util/streamex/StreamExTest.java
index 61f7e64..47e3911 100644
--- a/src/test/java/one/util/streamex/StreamExTest.java
+++ b/src/test/java/one/util/streamex/StreamExTest.java
@@ -138,9 +138,6 @@ public class StreamExTest {
         assertEquals(expectedSet, actualSet);
         actualSet = StreamEx.ofLines(new StringReader(input)).skipOrdered(1).parallel().toSet();
         assertEquals(expectedSet, actualSet);
-
-        assertFalse(StreamEx.ofLines(new StringReader(input)).spliterator().getClass().getSimpleName().endsWith(
-            "IteratorSpliterator"));
     }
 
     @Test(expected = IllegalArgumentException.class)
@@ -1764,10 +1761,6 @@ public class StreamExTest {
 
     @Test
     public void testSplit() {
-        assertFalse(StreamEx.split("str", "abcd").spliterator().getClass().getSimpleName().endsWith(
-            "IteratorSpliterator"));
-        assertFalse(StreamEx.split("str", Pattern.compile("abcd")).spliterator().getClass().getSimpleName().endsWith(
-            "IteratorSpliterator"));
         streamEx(() -> StreamEx.split("", "abcd"), s -> assertEquals(1, s.get().count()));
         streamEx(() -> StreamEx.split("", Pattern.compile("abcd")), s -> assertEquals(1, s.get().count()));
         streamEx(() -> StreamEx.split("ab.cd...", '.'), s -> assertEquals("ab|cd", s.get().joining("|")));
diff --git a/src/test/java/one/util/streamex/UnknownSizeSpliteratorTest.java b/src/test/java/one/util/streamex/UnknownSizeSpliteratorTest.java
index 84a1fe6..931e35c 100644
--- a/src/test/java/one/util/streamex/UnknownSizeSpliteratorTest.java
+++ b/src/test/java/one/util/streamex/UnknownSizeSpliteratorTest.java
@@ -97,37 +97,4 @@ public class UnknownSizeSpliteratorTest {
         assertEquals(12497500, StreamSupport.stream(new UnknownSizeSpliterator.USOfRef<>(input.iterator()), true)
                 .mapToInt(x -> x).sum());
     }
-
-    @Test
-    public void testOptimize() {
-        Stream<String> stream = Stream.of("a", "b");
-        assertSame(stream, UnknownSizeSpliterator.optimize(stream));
-        stream = StreamSupport.stream(
-            Spliterators.spliteratorUnknownSize(Arrays.asList("a", "b").iterator(), Spliterator.ORDERED), false)
-                .distinct(); // not Head
-        assertSame(stream, UnknownSizeSpliterator.optimize(stream));
-        stream = StreamSupport.stream(Spliterators.spliterator(Arrays.asList("a", "b").iterator(), 2,
-            Spliterator.ORDERED), false); // SIZED
-        assertSame(stream, UnknownSizeSpliterator.optimize(stream));
-        stream = new ConcurrentLinkedDeque<String>().stream(); // not SIZED
-        assertSame(stream, UnknownSizeSpliterator.optimize(stream));
-
-        AtomicBoolean flag = new AtomicBoolean();
-        stream = StreamSupport.stream(
-            Spliterators.spliteratorUnknownSize(Arrays.asList("a", "b").iterator(), Spliterator.ORDERED), false)
-                .onClose(() -> flag.set(true));
-        Stream<String> optimized = UnknownSizeSpliterator.optimize(stream);
-        assertNotSame(stream, optimized);
-        assertTrue(optimized.spliterator() instanceof UnknownSizeSpliterator);
-        assertFalse(optimized.isParallel());
-        optimized.close();
-        assertTrue(flag.get());
-
-        stream = StreamSupport.stream(Spliterators.spliteratorUnknownSize(Arrays.asList("a", "b").iterator(),
-            Spliterator.ORDERED), true);
-        optimized = UnknownSizeSpliterator.optimize(stream);
-        assertNotSame(stream, optimized);
-        assertTrue(optimized.spliterator() instanceof UnknownSizeSpliterator);
-        assertTrue(optimized.isParallel());
-    }
 }
