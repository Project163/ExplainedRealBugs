diff --git a/src/main/java/one/util/streamex/DoubleStreamEx.java b/src/main/java/one/util/streamex/DoubleStreamEx.java
index 08a72b3..49ee3c6 100644
--- a/src/main/java/one/util/streamex/DoubleStreamEx.java
+++ b/src/main/java/one/util/streamex/DoubleStreamEx.java
@@ -395,8 +395,11 @@ public class DoubleStreamEx extends BaseStreamEx<Double, DoubleStream, Spliterat
     public DoubleStreamEx reverseSorted() {
         return new DoubleStreamEx(stream().mapToLong(d -> {
             long l = Double.doubleToRawLongBits(d);
-            return l ^ (((l >>> 63) - 1) | Long.MIN_VALUE);
-        }).sorted().mapToDouble(l -> Double.longBitsToDouble(l ^ ((-(l >>> 63)) | Long.MIN_VALUE))), context);
+            return (l ^ (((l >>> 63) - 1) | Long.MIN_VALUE)) + 0xfffffffffffffL;
+        }).sorted().mapToDouble(l -> {
+            l -= 0xfffffffffffffL;
+            return Double.longBitsToDouble(l ^ ((-(l >>> 63)) | Long.MIN_VALUE));
+        }), context);
     }
 
     /**
diff --git a/src/test/java/one/util/streamex/DoubleStreamExTest.java b/src/test/java/one/util/streamex/DoubleStreamExTest.java
index 455043d..7022296 100644
--- a/src/test/java/one/util/streamex/DoubleStreamExTest.java
+++ b/src/test/java/one/util/streamex/DoubleStreamExTest.java
@@ -268,6 +268,18 @@ public class DoubleStreamExTest {
 
         assertArrayEquals(new double[] { 0.4, 1.5, 1.3, 2.3, 2.1, 2.0, 3.7 }, DoubleStreamEx.of(1.5, 2.3, 1.3, 2.1,
             3.7, 0.4, 2.0).sortedByLong(x -> (long) x).toArray(), 0.0);
+        double nonCanonicalNan = Double.longBitsToDouble(0xfff8000000000001L);
+        double nonCanonicalNan2 = Double.longBitsToDouble(0x7ff8000000000000L);
+        assertTrue(Double.isNaN(nonCanonicalNan));
+        assertTrue(Double.isNaN(nonCanonicalNan2));
+        double[] data = {Double.NEGATIVE_INFINITY, 0.0, 1.0, Double.POSITIVE_INFINITY, Double.NaN, nonCanonicalNan,
+            nonCanonicalNan2};
+        double[] reverseData = {nonCanonicalNan, nonCanonicalNan2, Double.NaN, Double.POSITIVE_INFINITY, 1.0, 0.0,
+            Double.NEGATIVE_INFINITY};
+        assertArrayEquals(DoubleStreamEx.of(data).mapToLong(Double::doubleToRawLongBits).toArray(), 
+            DoubleStreamEx.of(data).sorted().mapToLong(Double::doubleToRawLongBits).toArray());
+        assertArrayEquals(DoubleStreamEx.of(reverseData).mapToLong(Double::doubleToRawLongBits).toArray(), 
+            DoubleStreamEx.of(data).reverseSorted().mapToLong(Double::doubleToRawLongBits).toArray());
     }
 
     @SafeVarargs
diff --git a/wiki/CHANGES.md b/wiki/CHANGES.md
index e049282..683d57f 100644
--- a/wiki/CHANGES.md
+++ b/wiki/CHANGES.md
@@ -10,6 +10,7 @@ Check also [MIGRATION.md](MIGRATION.md) for possible compatibility problems.
 * [#221]: Fixed: `rangeClosed(x, x, step)` returned empty stream instead of stream of `x` if step absolute value is
  bigger than one.
 * [#226]: Added: `EntryStream.pairMap` (pairMap pulled up to AbstractStreamEx).
+* [#229]: Fixed: Some non-canonical nans were sorted incorrectly with `Double.reverseSorted()`.
 
 ### 0.7.2
 * Fixed: accidental use of Java 9 API in CrossSpliterator
