diff --git a/CHANGES.md b/CHANGES.md
index b7b6c81..e69f3bb 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -4,6 +4,8 @@ Check also [MIGRATION.md](MIGRATION.md) for possible compatibility problems.
 
 ### 0.7.3
 * [#028]: Added: `StreamEx.toCollectionAndThen`
+* [#219]: Changed: MoreCollectors now reject eagerly null parameters where possible; `MoreCollectors.last` throws NPE
+ if last stream element is null. 
 
 ### 0.7.2
 * Fixed: accidental use of Java 9 API in CrossSpliterator
diff --git a/MIGRATION.md b/MIGRATION.md
index 2da03e5..293ae52 100644
--- a/MIGRATION.md
+++ b/MIGRATION.md
@@ -2,6 +2,11 @@
 
 This document describes StreamEx changes which may break the backwards compatibility. For full list of changes see [CHANGES.md](CHANGES.md).
 
+### 0.7.3
+Issue#219: Now many collectors defined in `MoreCollectors` may throw NullPointerException more eagerly, before the
+ collector is used. Also, `MoreCollectors.last` now throws NullPointerException if the last element is null (this
+  makes it conformant to `MoreCollectors.first`).
+
 ### 0.7.0
 Issue#194: Method `skipOrdered` is removed, which may break source and binary compatibility if in was used. Use simply `skip` instead.
 PR#200: Overloads added to `EntryStream.allMatch/anyMatch/noneMatch` which accept a `BiPredicate`. Such overloads may cause
diff --git a/src/main/java/one/util/streamex/MoreCollectors.java b/src/main/java/one/util/streamex/MoreCollectors.java
index 473ed34..7445919 100644
--- a/src/main/java/one/util/streamex/MoreCollectors.java
+++ b/src/main/java/one/util/streamex/MoreCollectors.java
@@ -1,1728 +1,1786 @@
-/*
- * Copyright 2015, 2019 StreamEx contributors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package one.util.streamex;
-
-import java.util.ArrayDeque;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.Deque;
-import java.util.EnumMap;
-import java.util.EnumSet;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Objects;
-import java.util.OptionalInt;
-import java.util.Map.Entry;
-import java.util.Optional;
-import java.util.OptionalLong;
-import java.util.Set;
-import java.util.function.BiConsumer;
-import java.util.function.BiFunction;
-import java.util.function.BiPredicate;
-import java.util.function.BinaryOperator;
-import java.util.function.Function;
-import java.util.function.IntFunction;
-import java.util.function.Predicate;
-import java.util.function.Supplier;
-import java.util.function.ToIntFunction;
-import java.util.function.ToLongFunction;
-import java.util.stream.Collector;
-import java.util.stream.Collector.Characteristics;
-import java.util.stream.Collectors;
-import java.util.stream.Stream;
-
-import static one.util.streamex.Internals.*;
-
-/**
- * Implementations of several collectors in addition to ones available in JDK.
- * 
- * @author Tagir Valeev
- * @see Collectors
- * @see Joining
- * @since 0.3.2
- */
-public final class MoreCollectors {
-    private MoreCollectors() {
-        throw new UnsupportedOperationException();
-    }
-
-    /**
-     * Returns a {@code Collector} which just ignores the input and calls the
-     * provided supplier once to return the output.
-     * 
-     * @param <T> the type of input elements
-     * @param <U> the type of output
-     * @param supplier the supplier of the output
-     * @return a {@code Collector} which just ignores the input and calls the
-     *         provided supplier once to return the output.
-     */
-    private static <T, U> Collector<T, ?, U> empty(Supplier<U> supplier) {
-        return new CancellableCollectorImpl<>(() -> NONE, (acc, t) -> {
-            // empty
-        }, selectFirst(), acc -> supplier.get(), alwaysTrue(), EnumSet.of(Characteristics.UNORDERED,
-            Characteristics.CONCURRENT));
-    }
-
-    private static <T> Collector<T, ?, List<T>> empty() {
-        return empty(ArrayList<T>::new);
-    }
-
-    /**
-     * Returns a {@code Collector} that accumulates the input elements into a
-     * new array.
-     * 
-     * The operation performed by the returned collector is equivalent to
-     * {@code stream.toArray(generator)}. This collector is mostly useful as a
-     * downstream collector.
-     *
-     * @param <T> the type of the input elements
-     * @param generator a function which produces a new array of the desired
-     *        type and the provided length
-     * @return a {@code Collector} which collects all the input elements into an
-     *         array, in encounter order
-     */
-    public static <T> Collector<T, ?, T[]> toArray(IntFunction<T[]> generator) {
-        return Collectors.collectingAndThen(Collectors.toList(), list -> list.toArray(generator.apply(list.size())));
-    }
-
-    /**
-     * Returns a {@code Collector} which produces a boolean array containing the
-     * results of applying the given predicate to the input elements, in
-     * encounter order.
-     * 
-     * @param <T> the type of the input elements
-     * @param predicate a non-interfering, stateless predicate to apply to each
-     *        input element. The result values of this predicate are collected
-     *        to the resulting boolean array.
-     * @return a {@code Collector} which collects the results of the predicate
-     *         function to the boolean array, in encounter order.
-     * @since 0.3.8
-     */
-    public static <T> Collector<T, ?, boolean[]> toBooleanArray(Predicate<T> predicate) {
-        return PartialCollector.booleanArray().asRef((box, t) -> {
-            if (predicate.test(t))
-                box.a.set(box.b);
-            box.b = StrictMath.addExact(box.b, 1);
-        });
-    }
-
-    /**
-     * Returns a {@code Collector} that accumulates the input enum values into a
-     * new {@code EnumSet}.
-     *
-     * <p>
-     * This method returns a
-     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting
-     * collector</a>: it may not process all the elements if the resulting set
-     * contains all possible enum values.
-     * 
-     * @param <T> the type of the input elements
-     * @param enumClass the class of input enum values
-     * @return a {@code Collector} which collects all the input elements into a
-     *         {@code EnumSet}
-     */
-    public static <T extends Enum<T>> Collector<T, ?, EnumSet<T>> toEnumSet(Class<T> enumClass) {
-        int size = EnumSet.allOf(enumClass).size();
-        return new CancellableCollectorImpl<>(() -> EnumSet.noneOf(enumClass), EnumSet::add, (s1, s2) -> {
-            s1.addAll(s2);
-            return s1;
-        }, Function.identity(), set -> set.size() == size, UNORDERED_ID_CHARACTERISTICS);
-    }
-
-    /**
-     * Returns a {@code Collector} which counts a number of distinct values the
-     * mapper function returns for the stream elements.
-     * 
-     * <p>
-     * The operation performed by the returned collector is equivalent to
-     * {@code stream.map(mapper).distinct().count()}. This collector is mostly
-     * useful as a downstream collector.
-     * 
-     * @param <T> the type of the input elements
-     * @param mapper a function which classifies input elements.
-     * @return a collector which counts a number of distinct classes the mapper
-     *         function returns for the stream elements.
-     */
-    public static <T> Collector<T, ?, Integer> distinctCount(Function<? super T, ?> mapper) {
-        return Collectors.collectingAndThen(Collectors.mapping(mapper, Collectors.toSet()), Set::size);
-    }
-
-    /**
-     * Returns a {@code Collector} which collects into the {@link List} the
-     * input elements for which given mapper function returns distinct results.
-     *
-     * <p>
-     * For ordered source the order of collected elements is preserved. If the
-     * same result is returned by mapper function for several elements, only the
-     * first element is included into the resulting list.
-     * 
-     * <p>
-     * There are no guarantees on the type, mutability, serializability, or
-     * thread-safety of the {@code List} returned.
-     * 
-     * <p>
-     * The operation performed by the returned collector is equivalent to
-     * {@code stream.distinct(mapper).toList()}, but may work faster.
-     * 
-     * @param <T> the type of the input elements
-     * @param mapper a function which classifies input elements.
-     * @return a collector which collects distinct elements to the {@code List}.
-     * @since 0.3.8
-     */
-    public static <T> Collector<T, ?, List<T>> distinctBy(Function<? super T, ?> mapper) {
-        return Collector.<T, Map<Object, T>, List<T>> of(LinkedHashMap::new, (map, t) -> map.putIfAbsent(mapper.apply(
-            t), t), (m1, m2) -> {
-                for (Entry<Object, T> e : m2.entrySet()) {
-                    m1.putIfAbsent(e.getKey(), e.getValue());
-                }
-                return m1;
-            }, map -> new ArrayList<>(map.values()));
-    }
-
-    /**
-     * Returns a {@code Collector} accepting elements of type {@code T} that
-     * counts the number of input elements and returns result as {@code Integer}
-     * . If no elements are present, the result is 0.
-     *
-     * @param <T> the type of the input elements
-     * @return a {@code Collector} that counts the input elements
-     * @since 0.3.3
-     * @see Collectors#counting()
-     */
-    public static <T> Collector<T, ?, Integer> countingInt() {
-        return PartialCollector.intSum().asRef((acc, t) -> acc[0]++);
-    }
-
-    /**
-     * Returns a {@code Collector} which aggregates the results of two supplied
-     * collectors using the supplied finisher function.
-     * 
-     * <p>
-     * This method returns a
-     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting
-     * collector</a> if both downstream collectors are short-circuiting. The
-     * collection might stop when both downstream collectors report that the
-     * collection is complete.
-     * 
-     * <p>
-     * This collector is similar to the {@code teeing} collector available since
-     * JDK 12. The only difference is that this collector correctly combines 
-     * short-circuiting collectors.
-     * 
-     * @param <T> the type of the input elements
-     * @param <A1> the intermediate accumulation type of the first collector
-     * @param <A2> the intermediate accumulation type of the second collector
-     * @param <R1> the result type of the first collector
-     * @param <R2> the result type of the second collector
-     * @param <R> the final result type
-     * @param c1 the first collector
-     * @param c2 the second collector
-     * @param finisher the function which merges two results into the single
-     *        one.
-     * @return a {@code Collector} which aggregates the results of two supplied
-     *         collectors.
-     */
-    public static <T, A1, A2, R1, R2, R> Collector<T, ?, R> pairing(Collector<? super T, A1, R1> c1,
-            Collector<? super T, A2, R2> c2, BiFunction<? super R1, ? super R2, ? extends R> finisher) {
-        EnumSet<Characteristics> c = EnumSet.noneOf(Characteristics.class);
-        c.addAll(c1.characteristics());
-        c.retainAll(c2.characteristics());
-        c.remove(Characteristics.IDENTITY_FINISH);
-
-        Supplier<A1> c1Supplier = c1.supplier();
-        Supplier<A2> c2Supplier = c2.supplier();
-        BiConsumer<A1, ? super T> c1Accumulator = c1.accumulator();
-        BiConsumer<A2, ? super T> c2Accumulator = c2.accumulator();
-        BinaryOperator<A1> c1Combiner = c1.combiner();
-        BinaryOperator<A2> c2combiner = c2.combiner();
-
-        Supplier<PairBox<A1, A2>> supplier = () -> new PairBox<>(c1Supplier.get(), c2Supplier.get());
-        BiConsumer<PairBox<A1, A2>, T> accumulator = (acc, v) -> {
-            c1Accumulator.accept(acc.a, v);
-            c2Accumulator.accept(acc.b, v);
-        };
-        BinaryOperator<PairBox<A1, A2>> combiner = (acc1, acc2) -> {
-            acc1.a = c1Combiner.apply(acc1.a, acc2.a);
-            acc1.b = c2combiner.apply(acc1.b, acc2.b);
-            return acc1;
-        };
-        Function<PairBox<A1, A2>, R> resFinisher = acc -> {
-            R1 r1 = c1.finisher().apply(acc.a);
-            R2 r2 = c2.finisher().apply(acc.b);
-            return finisher.apply(r1, r2);
-        };
-        Predicate<A1> c1Finished = finished(c1);
-        Predicate<A2> c2Finished = finished(c2);
-        if (c1Finished != null && c2Finished != null) {
-            Predicate<PairBox<A1, A2>> finished = acc -> c1Finished.test(acc.a) && c2Finished.test(acc.b);
-            return new CancellableCollectorImpl<>(supplier, accumulator, combiner, resFinisher, finished, c);
-        }
-        return Collector.of(supplier, accumulator, combiner, resFinisher, c.toArray(new Characteristics[0]));
-    }
-
-    /**
-     * Returns a {@code Collector} which finds the minimal and maximal element
-     * according to the supplied comparator, then applies finisher function to
-     * them producing the final result.
-     * 
-     * <p>
-     * This collector produces stable result for ordered stream: if several
-     * minimal or maximal elements appear, the collector always selects the
-     * first encountered.
-     * 
-     * <p>
-     * If there are no input elements, the finisher method is not called and
-     * empty {@code Optional} is returned. Otherwise the finisher result is
-     * wrapped into {@code Optional}.
-     *
-     * @param <T> the type of the input elements
-     * @param <R> the type of the result wrapped into {@code Optional}
-     * @param comparator comparator which is used to find minimal and maximal
-     *        element
-     * @param finisher a {@link BiFunction} which takes minimal and maximal
-     *        element and produces the final result.
-     * @return a {@code Collector} which finds minimal and maximal elements.
-     */
-    public static <T, R> Collector<T, ?, Optional<R>> minMax(Comparator<? super T> comparator,
-            BiFunction<? super T, ? super T, ? extends R> finisher) {
-        return pairing(Collectors.minBy(comparator), Collectors.maxBy(comparator), (min, max) -> min.isPresent()
-                ? Optional.of(finisher.apply(min.get(), max.get())) : Optional.empty());
-    }
-
-    /**
-     * Returns a {@code Collector} which finds all the elements which are equal
-     * to each other and bigger than any other element according to the
-     * specified {@link Comparator}. The found elements are reduced using the
-     * specified downstream {@code Collector}.
-     *
-     * @param <T> the type of the input elements
-     * @param <A> the intermediate accumulation type of the downstream collector
-     * @param <D> the result type of the downstream reduction
-     * @param comparator a {@code Comparator} to compare the elements
-     * @param downstream a {@code Collector} implementing the downstream
-     *        reduction
-     * @return a {@code Collector} which finds all the maximal elements.
-     * @see #maxAll(Comparator)
-     * @see #maxAll(Collector)
-     * @see #maxAll()
-     */
-    public static <T, A, D> Collector<T, ?, D> maxAll(Comparator<? super T> comparator,
-            Collector<? super T, A, D> downstream) {
-        Supplier<A> downstreamSupplier = downstream.supplier();
-        BiConsumer<A, ? super T> downstreamAccumulator = downstream.accumulator();
-        BinaryOperator<A> downstreamCombiner = downstream.combiner();
-        Supplier<PairBox<A, T>> supplier = () -> new PairBox<>(downstreamSupplier.get(), none());
-        BiConsumer<PairBox<A, T>, T> accumulator = (acc, t) -> {
-            if (acc.b == NONE) {
-                downstreamAccumulator.accept(acc.a, t);
-                acc.b = t;
-            } else {
-                int cmp = comparator.compare(t, acc.b);
-                if (cmp > 0) {
-                    acc.a = downstreamSupplier.get();
-                    acc.b = t;
-                }
-                if (cmp >= 0)
-                    downstreamAccumulator.accept(acc.a, t);
-            }
-        };
-        BinaryOperator<PairBox<A, T>> combiner = (acc1, acc2) -> {
-            if (acc2.b == NONE) {
-                return acc1;
-            }
-            if (acc1.b == NONE) {
-                return acc2;
-            }
-            int cmp = comparator.compare(acc1.b, acc2.b);
-            if (cmp > 0) {
-                return acc1;
-            }
-            if (cmp < 0) {
-                return acc2;
-            }
-            acc1.a = downstreamCombiner.apply(acc1.a, acc2.a);
-            return acc1;
-        };
-        Function<PairBox<A, T>, D> finisher = acc -> downstream.finisher().apply(acc.a);
-        return Collector.of(supplier, accumulator, combiner, finisher);
-    }
-
-    /**
-     * Returns a {@code Collector} which finds all the elements which are equal
-     * to each other and bigger than any other element according to the
-     * specified {@link Comparator}. The found elements are collected to
-     * {@link List}.
-     *
-     * @param <T> the type of the input elements
-     * @param comparator a {@code Comparator} to compare the elements
-     * @return a {@code Collector} which finds all the maximal elements and
-     *         collects them to the {@code List}.
-     * @see #maxAll(Comparator, Collector)
-     * @see #maxAll()
-     */
-    public static <T> Collector<T, ?, List<T>> maxAll(Comparator<? super T> comparator) {
-        return maxAll(comparator, Collectors.toList());
-    }
-
-    /**
-     * Returns a {@code Collector} which finds all the elements which are equal
-     * to each other and bigger than any other element according to the natural
-     * order. The found elements are reduced using the specified downstream
-     * {@code Collector}.
-     *
-     * @param <T> the type of the input elements
-     * @param <A> the intermediate accumulation type of the downstream collector
-     * @param <D> the result type of the downstream reduction
-     * @param downstream a {@code Collector} implementing the downstream
-     *        reduction
-     * @return a {@code Collector} which finds all the maximal elements.
-     * @see #maxAll(Comparator, Collector)
-     * @see #maxAll(Comparator)
-     * @see #maxAll()
-     */
-    public static <T extends Comparable<? super T>, A, D> Collector<T, ?, D> maxAll(Collector<T, A, D> downstream) {
-        return maxAll(Comparator.<T> naturalOrder(), downstream);
-    }
-
-    /**
-     * Returns a {@code Collector} which finds all the elements which are equal
-     * to each other and bigger than any other element according to the natural
-     * order. The found elements are collected to {@link List}.
-     *
-     * @param <T> the type of the input elements
-     * @return a {@code Collector} which finds all the maximal elements and
-     *         collects them to the {@code List}.
-     * @see #maxAll(Comparator)
-     * @see #maxAll(Collector)
-     */
-    public static <T extends Comparable<? super T>> Collector<T, ?, List<T>> maxAll() {
-        return maxAll(Comparator.<T> naturalOrder(), Collectors.toList());
-    }
-
-    /**
-     * Returns a {@code Collector} which finds all the elements which are equal
-     * to each other and smaller than any other element according to the
-     * specified {@link Comparator}. The found elements are reduced using the
-     * specified downstream {@code Collector}.
-     *
-     * @param <T> the type of the input elements
-     * @param <A> the intermediate accumulation type of the downstream collector
-     * @param <D> the result type of the downstream reduction
-     * @param comparator a {@code Comparator} to compare the elements
-     * @param downstream a {@code Collector} implementing the downstream
-     *        reduction
-     * @return a {@code Collector} which finds all the minimal elements.
-     * @see #minAll(Comparator)
-     * @see #minAll(Collector)
-     * @see #minAll()
-     */
-    public static <T, A, D> Collector<T, ?, D> minAll(Comparator<? super T> comparator, Collector<T, A, D> downstream) {
-        return maxAll(comparator.reversed(), downstream);
-    }
-
-    /**
-     * Returns a {@code Collector} which finds all the elements which are equal
-     * to each other and smaller than any other element according to the
-     * specified {@link Comparator}. The found elements are collected to
-     * {@link List}.
-     *
-     * @param <T> the type of the input elements
-     * @param comparator a {@code Comparator} to compare the elements
-     * @return a {@code Collector} which finds all the minimal elements and
-     *         collects them to the {@code List}.
-     * @see #minAll(Comparator, Collector)
-     * @see #minAll()
-     */
-    public static <T> Collector<T, ?, List<T>> minAll(Comparator<? super T> comparator) {
-        return maxAll(comparator.reversed(), Collectors.toList());
-    }
-
-    /**
-     * Returns a {@code Collector} which finds all the elements which are equal
-     * to each other and smaller than any other element according to the natural
-     * order. The found elements are reduced using the specified downstream
-     * {@code Collector}.
-     *
-     * @param <T> the type of the input elements
-     * @param <A> the intermediate accumulation type of the downstream collector
-     * @param <D> the result type of the downstream reduction
-     * @param downstream a {@code Collector} implementing the downstream
-     *        reduction
-     * @return a {@code Collector} which finds all the minimal elements.
-     * @see #minAll(Comparator, Collector)
-     * @see #minAll(Comparator)
-     * @see #minAll()
-     */
-    public static <T extends Comparable<? super T>, A, D> Collector<T, ?, D> minAll(Collector<T, A, D> downstream) {
-        return maxAll(Comparator.<T> reverseOrder(), downstream);
-    }
-
-    /**
-     * Returns a {@code Collector} which finds all the elements which are equal
-     * to each other and smaller than any other element according to the natural
-     * order. The found elements are collected to {@link List}.
-     *
-     * @param <T> the type of the input elements
-     * @return a {@code Collector} which finds all the minimal elements and
-     *         collects them to the {@code List}.
-     * @see #minAll(Comparator)
-     * @see #minAll(Collector)
-     */
-    public static <T extends Comparable<? super T>> Collector<T, ?, List<T>> minAll() {
-        return maxAll(Comparator.<T> reverseOrder(), Collectors.toList());
-    }
-
-    /**
-     * Returns a {@code Collector} which collects the stream element if stream
-     * contains exactly one element.
-     * 
-     * <p>
-     * This method returns a
-     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting
-     * collector</a>.
-     * 
-     * @param <T> the type of the input elements
-     * @return a collector which returns an {@link Optional} describing the only
-     *         element of the stream. For empty stream or stream containing more
-     *         than one element an empty {@code Optional} is returned.
-     * @since 0.4.0
-     */
-    public static <T> Collector<T, ?, Optional<T>> onlyOne() {
-        return new CancellableCollectorImpl<T, Box<Optional<T>>, Optional<T>>(Box::new, (box,
-                t) -> box.a = box.a == null ? Optional.of(t) : Optional.empty(), (box1, box2) -> box1.a == null ? box2
-                        : box2.a == null ? box1 : new Box<>(Optional.empty()), box -> box.a == null ? Optional.empty()
-                                : box.a, box -> box.a != null && !box.a.isPresent(), UNORDERED_CHARACTERISTICS);
-    }
-
-    /**
-     * Returns a {@code Collector} which collects the stream element satisfying the predicate
-     * if there is only one such element.
-     *
-     * <p>
-     * This method returns a
-     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting
-     * collector</a>.
-     *
-     * @param predicate a predicate to be applied to the stream elements
-     * @param <T> the type of the input elements
-     * @return a collector which returns an {@link Optional} describing the only
-     *         element of the stream satisfying the predicate. If stream contains no elements satisfying the predicate,
-     *         or more than one such element, an empty {@code Optional} is returned.
-     * @since 0.6.7
-     */
-    public static <T> Collector<T, ?, Optional<T>> onlyOne(Predicate<? super T> predicate) {
-        return filtering(predicate, onlyOne());
-    }
-
-    /**
-     * Returns a {@code Collector} which collects only the first stream element
-     * if any.
-     * 
-     * <p>
-     * This method returns a
-     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting
-     * collector</a>.
-     * 
-     * <p>
-     * The operation performed by the returned collector is equivalent to
-     * {@code stream.findFirst()}. This collector is mostly useful as a
-     * downstream collector.
-     * 
-     * @param <T> the type of the input elements
-     * @return a collector which returns an {@link Optional} which describes the
-     *         first element of the stream. For empty stream an empty
-     *         {@code Optional} is returned.
-     */
-    public static <T> Collector<T, ?, Optional<T>> first() {
-        return new CancellableCollectorImpl<>(() -> new Box<T>(none()), (box, t) -> {
-            if (box.a == NONE)
-                box.a = t;
-        }, (box1, box2) -> box1.a == NONE ? box2 : box1, box -> box.a == NONE ? Optional.empty() : Optional.of(box.a),
-                box -> box.a != NONE, NO_CHARACTERISTICS);
-    }
-
-    /**
-     * Returns a {@code Collector} which collects only the last stream element
-     * if any.
-     * 
-     * @param <T> the type of the input elements
-     * @return a collector which returns an {@link Optional} which describes the
-     *         last element of the stream. For empty stream an empty
-     *         {@code Optional} is returned.
-     */
-    public static <T> Collector<T, ?, Optional<T>> last() {
-        return Collectors.reducing((u, v) -> v);
-    }
-
-    /**
-     * Returns a {@code Collector} which collects at most specified number of
-     * the first stream elements into the {@link List}.
-     *
-     * <p>
-     * This method returns a
-     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting
-     * collector</a>.
-     * 
-     * <p>
-     * There are no guarantees on the type, mutability, serializability, or
-     * thread-safety of the {@code List} returned.
-     * 
-     * <p>
-     * The operation performed by the returned collector is equivalent to
-     * {@code stream.limit(n).collect(Collectors.toList())}. This collector is
-     * mostly useful as a downstream collector.
-     * 
-     * @param <T> the type of the input elements
-     * @param n maximum number of stream elements to preserve
-     * @return a collector which returns a {@code List} containing the first n
-     *         stream elements or less if the stream was shorter.
-     */
-    public static <T> Collector<T, ?, List<T>> head(int n) {
-        if (n <= 0)
-            return empty();
-        return new CancellableCollectorImpl<>(ArrayList::new, (acc, t) -> {
-            if (acc.size() < n)
-                acc.add(t);
-        }, (acc1, acc2) -> {
-            acc1.addAll(acc2.subList(0, Math.min(acc2.size(), n - acc1.size())));
-            return acc1;
-        }, Function.identity(), acc -> acc.size() >= n, ID_CHARACTERISTICS);
-    }
-
-    /**
-     * Returns a {@code Collector} which collects at most specified number of
-     * the last stream elements into the {@link List}.
-     * 
-     * <p>
-     * There are no guarantees on the type, mutability, serializability, or
-     * thread-safety of the {@code List} returned.
-     * 
-     * <p>
-     * When supplied {@code n} is less or equal to zero, this method returns a
-     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting
-     * collector</a> which ignores the input and produces an empty list.
-     * 
-     * @param <T> the type of the input elements
-     * @param n maximum number of stream elements to preserve
-     * @return a collector which returns a {@code List} containing the last n
-     *         stream elements or less if the stream was shorter.
-     */
-    public static <T> Collector<T, ?, List<T>> tail(int n) {
-        if (n <= 0)
-            return empty();
-        return Collector.<T, Deque<T>, List<T>> of(ArrayDeque::new, (acc, t) -> {
-            if (acc.size() == n)
-                acc.pollFirst();
-            acc.addLast(t);
-        }, (acc1, acc2) -> {
-            while (acc2.size() < n && !acc1.isEmpty()) {
-                acc2.addFirst(acc1.pollLast());
-            }
-            return acc2;
-        }, ArrayList::new);
-    }
-
-    /**
-     * Returns a {@code Collector} which collects at most specified number of
-     * the greatest stream elements according to the specified
-     * {@link Comparator} into the {@link List}. The resulting {@code List} is
-     * sorted in comparator reverse order (greatest element is the first). The
-     * order of equal elements is the same as in the input stream.
-     * 
-     * <p>
-     * The operation performed by the returned collector is equivalent to
-     * {@code stream.sorted(comparator.reversed()).limit(n).collect(Collectors.toList())}
-     * , but usually performed much faster if {@code n} is much less than the
-     * stream size.
-     * 
-     * <p>
-     * There are no guarantees on the type, mutability, serializability, or
-     * thread-safety of the {@code List} returned.
-     * 
-     * <p>
-     * When supplied {@code n} is less or equal to zero, this method returns a
-     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting
-     * collector</a> which ignores the input and produces an empty list.
-     * 
-     * @param <T> the type of the input elements
-     * @param comparator the comparator to compare the elements by
-     * @param n maximum number of stream elements to preserve
-     * @return a collector which returns a {@code List} containing the greatest
-     *         n stream elements or less if the stream was shorter.
-     */
-    public static <T> Collector<T, ?, List<T>> greatest(Comparator<? super T> comparator, int n) {
-        return least(comparator.reversed(), n);
-    }
-
-    /**
-     * Returns a {@code Collector} which collects at most specified number of
-     * the greatest stream elements according to the natural order into the
-     * {@link List}. The resulting {@code List} is sorted in reverse order
-     * (greatest element is the first). The order of equal elements is the same
-     * as in the input stream.
-     * 
-     * <p>
-     * The operation performed by the returned collector is equivalent to
-     * {@code stream.sorted(Comparator.reverseOrder()).limit(n).collect(Collectors.toList())}
-     * , but usually performed much faster if {@code n} is much less than the
-     * stream size.
-     * 
-     * <p>
-     * There are no guarantees on the type, mutability, serializability, or
-     * thread-safety of the {@code List} returned.
-     * 
-     * <p>
-     * When supplied {@code n} is less or equal to zero, this method returns a
-     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting
-     * collector</a> which ignores the input and produces an empty list.
-     * 
-     * @param <T> the type of the input elements
-     * @param n maximum number of stream elements to preserve
-     * @return a collector which returns a {@code List} containing the greatest
-     *         n stream elements or less if the stream was shorter.
-     */
-    public static <T extends Comparable<? super T>> Collector<T, ?, List<T>> greatest(int n) {
-        return least(Comparator.<T> reverseOrder(), n);
-    }
-
-    /**
-     * Returns a {@code Collector} which collects at most specified number of
-     * the least stream elements according to the specified {@link Comparator}
-     * into the {@link List}. The resulting {@code List} is sorted in comparator
-     * order (least element is the first). The order of equal elements is the
-     * same as in the input stream.
-     * 
-     * <p>
-     * The operation performed by the returned collector is equivalent to
-     * {@code stream.sorted(comparator).limit(n).collect(Collectors.toList())},
-     * but usually performed much faster if {@code n} is much less than the
-     * stream size.
-     * 
-     * <p>
-     * There are no guarantees on the type, mutability, serializability, or
-     * thread-safety of the {@code List} returned.
-     * 
-     * <p>
-     * When supplied {@code n} is less or equal to zero, this method returns a
-     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting
-     * collector</a> which ignores the input and produces an empty list.
-     * 
-     * @param <T> the type of the input elements
-     * @param comparator the comparator to compare the elements by
-     * @param n maximum number of stream elements to preserve
-     * @return a collector which returns a {@code List} containing the least n
-     *         stream elements or less if the stream was shorter.
-     */
-    public static <T> Collector<T, ?, List<T>> least(Comparator<? super T> comparator, int n) {
-        if (n <= 0)
-            return empty();
-        if (n == 1) {
-            return Collector.of(() -> new Box<T>(none()), (box, t) -> {
-                if (box.a == NONE || comparator.compare(t, box.a) < 0)
-                    box.a = t;
-            }, (box1, box2) -> (box2.a != NONE && (box1.a == NONE || comparator.compare(box2.a, box1.a) < 0)) ? box2
-                    : box1, box -> box.a == NONE ? new ArrayList<>() : new ArrayList<>(Collections.singleton(box.a)));
-        }
-        if (n >= Integer.MAX_VALUE / 2)
-            return collectingAndThen(Collectors.toList(), list -> {
-                list.sort(comparator);
-                if (list.size() <= n)
-                    return list;
-                return new ArrayList<>(list.subList(0, n));
-            });
-        return Collector.<T, Limiter<T>, List<T>> of(() -> new Limiter<>(n, comparator), Limiter::put, Limiter::putAll,
-            pq -> {
-                pq.sort();
-                return new ArrayList<>(pq);
-            });
-    }
-
-    /**
-     * Returns a {@code Collector} which collects at most specified number of
-     * the least stream elements according to the natural order into the
-     * {@link List}. The resulting {@code List} is sorted in natural order
-     * (least element is the first). The order of equal elements is the same as
-     * in the input stream.
-     * 
-     * <p>
-     * The operation performed by the returned collector is equivalent to
-     * {@code stream.sorted().limit(n).collect(Collectors.toList())}, but
-     * usually performed much faster if {@code n} is much less than the stream
-     * size.
-     * 
-     * <p>
-     * There are no guarantees on the type, mutability, serializability, or
-     * thread-safety of the {@code List} returned.
-     * 
-     * <p>
-     * When supplied {@code n} is less or equal to zero, this method returns a
-     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting
-     * collector</a> which ignores the input and produces an empty list.
-     * 
-     * @param <T> the type of the input elements
-     * @param n maximum number of stream elements to preserve
-     * @return a collector which returns a {@code List} containing the least n
-     *         stream elements or less if the stream was shorter.
-     */
-    public static <T extends Comparable<? super T>> Collector<T, ?, List<T>> least(int n) {
-        return least(Comparator.<T> naturalOrder(), n);
-    }
-
-    /**
-     * Returns a {@code Collector} which finds the index of the minimal stream
-     * element according to the specified {@link Comparator}. If there are
-     * several minimal elements, the index of the first one is returned.
-     *
-     * @param <T> the type of the input elements
-     * @param comparator a {@code Comparator} to compare the elements
-     * @return a {@code Collector} which finds the index of the minimal element.
-     * @see #minIndex()
-     * @since 0.3.5
-     */
-    public static <T> Collector<T, ?, OptionalLong> minIndex(Comparator<? super T> comparator) {
-        class Container {
-            T value;
-            long count = 0;
-            long index = -1;
-        }
-        return Collector.of(Container::new, (c, t) -> {
-            if (c.index == -1 || comparator.compare(c.value, t) > 0) {
-                c.value = t;
-                c.index = c.count;
-            }
-            c.count++;
-        }, (c1, c2) -> {
-            if (c1.index == -1 || (c2.index != -1 && comparator.compare(c1.value, c2.value) > 0)) {
-                c2.index += c1.count;
-                c2.count += c1.count;
-                return c2;
-            }
-            c1.count += c2.count;
-            return c1;
-        }, c -> c.index == -1 ? OptionalLong.empty() : OptionalLong.of(c.index));
-    }
-
-    /**
-     * Returns a {@code Collector} which finds the index of the minimal stream
-     * element according to the elements natural order. If there are several
-     * minimal elements, the index of the first one is returned.
-     *
-     * @param <T> the type of the input elements
-     * @return a {@code Collector} which finds the index of the minimal element.
-     * @see #minIndex(Comparator)
-     * @since 0.3.5
-     */
-    public static <T extends Comparable<? super T>> Collector<T, ?, OptionalLong> minIndex() {
-        return minIndex(Comparator.naturalOrder());
-    }
-
-    /**
-     * Returns a {@code Collector} which finds the index of the maximal stream
-     * element according to the specified {@link Comparator}. If there are
-     * several maximal elements, the index of the first one is returned.
-     *
-     * @param <T> the type of the input elements
-     * @param comparator a {@code Comparator} to compare the elements
-     * @return a {@code Collector} which finds the index of the maximal element.
-     * @see #maxIndex()
-     * @since 0.3.5
-     */
-    public static <T> Collector<T, ?, OptionalLong> maxIndex(Comparator<? super T> comparator) {
-        return minIndex(comparator.reversed());
-    }
-
-    /**
-     * Returns a {@code Collector} which finds the index of the maximal stream
-     * element according to the elements natural order. If there are several
-     * maximal elements, the index of the first one is returned.
-     *
-     * @param <T> the type of the input elements
-     * @return a {@code Collector} which finds the index of the maximal element.
-     * @see #maxIndex(Comparator)
-     * @since 0.3.5
-     */
-    public static <T extends Comparable<? super T>> Collector<T, ?, OptionalLong> maxIndex() {
-        return minIndex(Comparator.reverseOrder());
-    }
-
-    /**
-     * Returns a {@code Collector} implementing a cascaded "group by" operation
-     * on input elements of type {@code T}, for classification function which
-     * maps input elements to the enum values. The downstream reduction for
-     * repeating keys is performed using the specified downstream
-     * {@code Collector}.
-     *
-     * <p>
-     * Unlike the {@link Collectors#groupingBy(Function, Collector)} collector
-     * this collector produces an {@link EnumMap} which contains all possible
-     * keys including keys which were never returned by the classification
-     * function. These keys are mapped to the default collector value which is
-     * equivalent to collecting an empty stream with the same collector.
-     * 
-     * <p>
-     * This method returns a
-     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting
-     * collector</a> if the downstream collector is short-circuiting. The
-     * collection might stop when for every possible enum key the downstream
-     * collection is known to be finished.
-     *
-     * @param <T> the type of the input elements
-     * @param <K> the type of the enum values returned by the classifier
-     * @param <A> the intermediate accumulation type of the downstream collector
-     * @param <D> the result type of the downstream reduction
-     * @param enumClass the class of enum values returned by the classifier
-     * @param classifier a classifier function mapping input elements to enum
-     *        values
-     * @param downstream a {@code Collector} implementing the downstream
-     *        reduction
-     * @return a {@code Collector} implementing the cascaded group-by operation
-     * @see Collectors#groupingBy(Function, Collector)
-     * @see #groupingBy(Function, Set, Supplier, Collector)
-     * @since 0.3.7
-     */
-    public static <T, K extends Enum<K>, A, D> Collector<T, ?, EnumMap<K, D>> groupingByEnum(Class<K> enumClass,
-            Function<? super T, K> classifier, Collector<? super T, A, D> downstream) {
-        return groupingBy(classifier, EnumSet.allOf(enumClass), () -> new EnumMap<>(enumClass), downstream);
-    }
-
-    /**
-     * Returns a {@code Collector} implementing a cascaded "group by" operation
-     * on input elements of type {@code T}, grouping elements according to a
-     * classification function, and then performing a reduction operation on the
-     * values associated with a given key using the specified downstream
-     * {@code Collector}.
-     *
-     * <p>
-     * There are no guarantees on the type, mutability, serializability, or
-     * thread-safety of the {@code Map} returned.
-     *
-     * <p>
-     * The main difference of this collector from
-     * {@link Collectors#groupingBy(Function, Collector)} is that it accepts
-     * additional domain parameter which is the {@code Set} of all possible map
-     * keys. If the mapper function produces the key out of domain, an
-     * {@code IllegalStateException} will occur. If the mapper function does not
-     * produce some of domain keys at all, they are also added to the result.
-     * These keys are mapped to the default collector value which is equivalent
-     * to collecting an empty stream with the same collector.
-     * 
-     * <p>
-     * This method returns a
-     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting
-     * collector</a> if the downstream collector is short-circuiting. The
-     * collection might stop when for every possible key from the domain the
-     * downstream collection is known to be finished.
-     *
-     * @param <T> the type of the input elements
-     * @param <K> the type of the keys
-     * @param <A> the intermediate accumulation type of the downstream collector
-     * @param <D> the result type of the downstream reduction
-     * @param classifier a classifier function mapping input elements to keys
-     * @param domain a domain of all possible key values
-     * @param downstream a {@code Collector} implementing the downstream
-     *        reduction
-     * @return a {@code Collector} implementing the cascaded group-by operation
-     *         with given domain
-     *
-     * @see #groupingBy(Function, Set, Supplier, Collector)
-     * @see #groupingByEnum(Class, Function, Collector)
-     * @since 0.4.0
-     */
-    public static <T, K, D, A> Collector<T, ?, Map<K, D>> groupingBy(Function<? super T, ? extends K> classifier,
-            Set<K> domain, Collector<? super T, A, D> downstream) {
-        return groupingBy(classifier, domain, HashMap::new, downstream);
-    }
-
-    /**
-     * Returns a {@code Collector} implementing a cascaded "group by" operation
-     * on input elements of type {@code T}, grouping elements according to a
-     * classification function, and then performing a reduction operation on the
-     * values associated with a given key using the specified downstream
-     * {@code Collector}. The {@code Map} produced by the Collector is created
-     * with the supplied factory function.
-     *
-     * <p>
-     * The main difference of this collector from
-     * {@link Collectors#groupingBy(Function, Supplier, Collector)} is that it
-     * accepts additional domain parameter which is the {@code Set} of all
-     * possible map keys. If the mapper function produces the key out of domain,
-     * an {@code IllegalStateException} will occur. If the mapper function does
-     * not produce some of domain keys at all, they are also added to the
-     * result. These keys are mapped to the default collector value which is
-     * equivalent to collecting an empty stream with the same collector.
-     * 
-     * <p>
-     * This method returns a
-     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting
-     * collector</a> if the downstream collector is short-circuiting. The
-     * collection might stop when for every possible key from the domain the
-     * downstream collection is known to be finished.
-     *
-     * @param <T> the type of the input elements
-     * @param <K> the type of the keys
-     * @param <A> the intermediate accumulation type of the downstream collector
-     * @param <D> the result type of the downstream reduction
-     * @param <M> the type of the resulting {@code Map}
-     * @param classifier a classifier function mapping input elements to keys
-     * @param domain a domain of all possible key values
-     * @param downstream a {@code Collector} implementing the downstream
-     *        reduction
-     * @param mapFactory a function which, when called, produces a new empty
-     *        {@code Map} of the desired type
-     * @return a {@code Collector} implementing the cascaded group-by operation
-     *         with given domain
-     *
-     * @see #groupingBy(Function, Set, Collector)
-     * @see #groupingByEnum(Class, Function, Collector)
-     * @since 0.4.0
-     */
-    public static <T, K, D, A, M extends Map<K, D>> Collector<T, ?, M> groupingBy(
-            Function<? super T, ? extends K> classifier, Set<K> domain, Supplier<M> mapFactory,
-            Collector<? super T, A, D> downstream) {
-        Supplier<A> downstreamSupplier = downstream.supplier();
-        Collector<T, ?, M> groupingBy;
-        Function<K, A> supplier = k -> {
-            if (!domain.contains(k))
-                throw new IllegalStateException("Classifier returned value '" + k + "' which is out of domain");
-            return downstreamSupplier.get();
-        };
-        BiConsumer<A, ? super T> downstreamAccumulator = downstream.accumulator();
-        BiConsumer<Map<K, A>, T> accumulator = (m, t) -> {
-            K key = Objects.requireNonNull(classifier.apply(t));
-            A container = m.computeIfAbsent(key, supplier);
-            downstreamAccumulator.accept(container, t);
-        };
-        PartialCollector<Map<K, A>, M> partial = PartialCollector.grouping(mapFactory, downstream);
-        Predicate<A> downstreamFinished = finished(downstream);
-        if (downstreamFinished != null) {
-            int size = domain.size();
-            groupingBy = partial.asCancellable(accumulator, map -> {
-                if (map.size() < size)
-                    return false;
-                for (A container : map.values()) {
-                    if (!downstreamFinished.test(container))
-                        return false;
-                }
-                return true;
-            });
-        } else {
-            groupingBy = partial.asRef(accumulator);
-        }
-        return collectingAndThen(groupingBy, map -> {
-            Function<A, D> finisher = downstream.finisher();
-            domain.forEach(key -> map.computeIfAbsent(key, k -> finisher.apply(downstreamSupplier.get())));
-            return map;
-        });
-    }
-
-    /**
-     * Returns a {@code Collector} which collects the intersection of the input
-     * collections into the newly-created {@link Set}.
-     *
-     * <p>
-     * The returned collector produces an empty set if the input is empty or
-     * intersection of the input collections is empty.
-     * 
-     * <p>
-     * There are no guarantees on the type, mutability, serializability, or
-     * thread-safety of the {@code Set} returned.
-     *
-     * <p>
-     * This method returns a
-     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting
-     * collector</a>: it may not process all the elements if the resulting
-     * intersection is empty.
-     * 
-     * @param <T> the type of the elements in the input collections
-     * @param <S> the type of the input collections
-     * @return a {@code Collector} which finds all the minimal elements and
-     *         collects them to the {@code List}.
-     * @since 0.4.0
-     */
-    public static <T, S extends Collection<T>> Collector<S, ?, Set<T>> intersecting() {
-        return new CancellableCollectorImpl<S, Box<Set<T>>, Set<T>>(Box::new, (b, t) -> {
-            if (b.a == null) {
-                b.a = new HashSet<>(t);
-            } else {
-                b.a.retainAll(t);
-            }
-        }, (b1, b2) -> {
-            if (b1.a == null)
-                return b2;
-            if (b2.a != null)
-                b1.a.retainAll(b2.a);
-            return b1;
-        }, b -> b.a == null ? Collections.emptySet() : b.a, b -> b.a != null && b.a.isEmpty(),
-                UNORDERED_CHARACTERISTICS);
-    }
-
-    /**
-     * Adapts a {@code Collector} to perform an additional finishing
-     * transformation.
-     * 
-     * <p>
-     * Unlike {@link Collectors#collectingAndThen(Collector, Function)} this
-     * method returns a
-     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting
-     * collector</a> if the downstream collector is short-circuiting.
-     *
-     * @param <T> the type of the input elements
-     * @param <A> intermediate accumulation type of the downstream collector
-     * @param <R> result type of the downstream collector
-     * @param <RR> result type of the resulting collector
-     * @param downstream a collector
-     * @param finisher a function to be applied to the final result of the
-     *        downstream collector
-     * @return a collector which performs the action of the downstream
-     *         collector, followed by an additional finishing step
-     * @see Collectors#collectingAndThen(Collector, Function)
-     * @since 0.4.0
-     */
-    public static <T, A, R, RR> Collector<T, A, RR> collectingAndThen(Collector<T, A, R> downstream,
-            Function<R, RR> finisher) {
-        Predicate<A> finished = finished(downstream);
-        if (finished != null) {
-            return new CancellableCollectorImpl<>(downstream.supplier(), downstream.accumulator(), downstream
-                    .combiner(), downstream.finisher().andThen(finisher), finished, downstream.characteristics()
-                            .contains(Characteristics.UNORDERED) ? UNORDERED_CHARACTERISTICS : NO_CHARACTERISTICS);
-        }
-        return Collectors.collectingAndThen(downstream, finisher);
-    }
-
-    /**
-     * Returns a {@code Collector} which partitions the input elements according
-     * to a {@code Predicate}, reduces the values in each partition according to
-     * another {@code Collector}, and organizes them into a
-     * {@code Map<Boolean, D>} whose values are the result of the downstream
-     * reduction.
-     * 
-     * <p>
-     * Unlike {@link Collectors#partitioningBy(Predicate, Collector)} this
-     * method returns a
-     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting
-     * collector</a> if the downstream collector is short-circuiting.
-     * 
-     * @param <T> the type of the input elements
-     * @param <A> the intermediate accumulation type of the downstream collector
-     * @param <D> the result type of the downstream reduction
-     * @param predicate a predicate used for classifying input elements
-     * @param downstream a {@code Collector} implementing the downstream
-     *        reduction
-     * @return a {@code Collector} implementing the cascaded partitioning
-     *         operation
-     * @since 0.4.0
-     * @see Collectors#partitioningBy(Predicate, Collector)
-     */
-    public static <T, D, A> Collector<T, ?, Map<Boolean, D>> partitioningBy(Predicate<? super T> predicate,
-            Collector<? super T, A, D> downstream) {
-        Predicate<A> finished = finished(downstream);
-        if (finished != null) {
-            BiConsumer<A, ? super T> accumulator = downstream.accumulator();
-            return BooleanMap.partialCollector(downstream).asCancellable((map, t) -> accumulator.accept(predicate.test(
-                t) ? map.trueValue : map.falseValue, t), map -> finished.test(map.trueValue) && finished.test(
-                    map.falseValue));
-        }
-        return Collectors.partitioningBy(predicate, downstream);
-    }
-
-    /**
-     * Adapts a {@code Collector} accepting elements of type {@code U} to one
-     * accepting elements of type {@code T} by applying a mapping function to
-     * each input element before accumulation.
-     *
-     * <p>
-     * Unlike {@link Collectors#mapping(Function, Collector)} this method
-     * returns a
-     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting
-     * collector</a> if the downstream collector is short-circuiting.
-     * 
-     * @param <T> the type of the input elements
-     * @param <U> type of elements accepted by downstream collector
-     * @param <A> intermediate accumulation type of the downstream collector
-     * @param <R> result type of collector
-     * @param mapper a function to be applied to the input elements
-     * @param downstream a collector which will accept mapped values
-     * @return a collector which applies the mapping function to the input
-     *         elements and provides the mapped results to the downstream
-     *         collector
-     * @see Collectors#mapping(Function, Collector)
-     * @since 0.4.0
-     */
-    public static <T, U, A, R> Collector<T, ?, R> mapping(Function<? super T, ? extends U> mapper,
-            Collector<? super U, A, R> downstream) {
-        Predicate<A> finished = finished(downstream);
-        if (finished != null) {
-            BiConsumer<A, ? super U> downstreamAccumulator = downstream.accumulator();
-            return new CancellableCollectorImpl<>(downstream.supplier(), (acc, t) -> {
-                if (!finished.test(acc))
-                    downstreamAccumulator.accept(acc, mapper.apply(t));
-            }, downstream.combiner(), downstream.finisher(), finished, downstream.characteristics());
-        }
-        return Collectors.mapping(mapper, downstream);
-    }
-
-    /**
-     * Returns a collector which collects input elements to the new {@code List}
-     * transforming them with the supplied function beforehand.
-     * 
-     * <p>
-     * This method behaves like
-     * {@code Collectors.mapping(mapper, Collectors.toList())}.
-     * 
-     * <p>
-     * There are no guarantees on the type, mutability, serializability, or
-     * thread-safety of the {@code List} returned.
-     * 
-     * @param <T> the type of the input elements
-     * @param <U> the resulting type of the mapper function
-     * @param mapper a function to be applied to the input elements
-     * @return a collector which applies the mapping function to the input
-     *         elements and collects the mapped results to the {@code List}
-     * @see #mapping(Function, Collector)
-     * @since 0.6.0
-     */
-    public static <T, U> Collector<T, ?, List<U>> mapping(Function<? super T, ? extends U> mapper) {
-        return Collectors.mapping(mapper, Collectors.toList());
-    }
-
-    /**
-     * Adapts a {@code Collector} accepting elements of type {@code U} to one
-     * accepting elements of type {@code T} by applying a flat mapping function
-     * to each input element before accumulation. The flat mapping function maps
-     * an input element to a {@link Stream stream} covering zero or more output
-     * elements that are then accumulated downstream. Each mapped stream is
-     * {@link java.util.stream.BaseStream#close() closed} after its contents
-     * have been placed downstream. (If a mapped stream is {@code null} an empty
-     * stream is used, instead.)
-     * 
-     * <p>
-     * This method is similar to {@code Collectors.flatMapping} method which
-     * appears in JDK 9. However when downstream collector is
-     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting</a>
-     * , this method will also return a short-circuiting collector.
-     * 
-     * @param <T> the type of the input elements
-     * @param <U> type of elements accepted by downstream collector
-     * @param <A> intermediate accumulation type of the downstream collector
-     * @param <R> result type of collector
-     * @param mapper a function to be applied to the input elements, which
-     *        returns a stream of results
-     * @param downstream a collector which will receive the elements of the
-     *        stream returned by mapper
-     * @return a collector which applies the mapping function to the input
-     *         elements and provides the flat mapped results to the downstream
-     *         collector
-     * @since 0.4.1
-     */
-    public static <T, U, A, R> Collector<T, ?, R> flatMapping(Function<? super T, ? extends Stream<? extends U>> mapper,
-            Collector<? super U, A, R> downstream) {
-        BiConsumer<A, ? super U> downstreamAccumulator = downstream.accumulator();
-        Predicate<A> finished = finished(downstream);
-        if (finished != null) {
-            return new CancellableCollectorImpl<>(downstream.supplier(), (acc, t) -> {
-                if (finished.test(acc))
-                    return;
-                try (Stream<? extends U> stream = mapper.apply(t)) {
-                    if (stream != null) {
-                        stream.spliterator().forEachRemaining(u -> {
-                            downstreamAccumulator.accept(acc, u);
-                            if (finished.test(acc))
-                                throw new CancelException();
-                        });
-                    }
-                } catch (CancelException ex) {
-                    // ignore
-                }
-            }, downstream.combiner(), downstream.finisher(), finished, downstream.characteristics());
-        }
-        return Collector.of(downstream.supplier(), (acc, t) -> {
-            try (Stream<? extends U> stream = mapper.apply(t)) {
-                if (stream != null) {
-                    stream.spliterator().forEachRemaining(u -> downstreamAccumulator.accept(acc, u));
-                }
-            }
-        }, downstream.combiner(), downstream.finisher(), downstream.characteristics().toArray(new Characteristics[0]));
-    }
-
-    /**
-     * Returns a collector which launches a flat mapping function for each input
-     * element and collects the elements of the resulting streams to the flat
-     * {@code List}. Each mapped stream is
-     * {@link java.util.stream.BaseStream#close() closed} after its contents
-     * have been placed downstream. (If a mapped stream is {@code null} an empty
-     * stream is used, instead.)
-     * 
-     * <p>
-     * This method behaves like {@code flatMapping(mapper, Collectors.toList())}
-     * .
-     * 
-     * <p>
-     * There are no guarantees on the type, mutability, serializability, or
-     * thread-safety of the {@code List} returned.
-     * 
-     * @param <T> the type of the input elements
-     * @param <U> type of the resulting elements
-     * @param mapper a function to be applied to the input elements, which
-     *        returns a stream of results
-     * @return a collector which applies the mapping function to the input
-     *         elements and collects the flat mapped results to the {@code List}
-     * @since 0.6.0
-     */
-    public static <T, U> Collector<T, ?, List<U>> flatMapping(
-            Function<? super T, ? extends Stream<? extends U>> mapper) {
-        return flatMapping(mapper, Collectors.toList());
-    }
-
-    /**
-     * Returns a {@code Collector} which passes only those elements to the
-     * specified downstream collector which match given predicate.
-     *
-     * <p>
-     * This method returns a
-     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting
-     * collector</a> if downstream collector is short-circuiting.
-     * 
-     * <p>
-     * The operation performed by the returned collector is equivalent to
-     * {@code stream.filter(predicate).collect(downstream)}. This collector is
-     * mostly useful as a downstream collector in cascaded operation involving
-     * {@link #pairing(Collector, Collector, BiFunction)} collector.
-     *
-     * <p>
-     * This method is similar to {@code Collectors.filtering} method which
-     * appears in JDK 9. However when downstream collector is
-     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting</a>
-     * , this method will also return a short-circuiting collector.
-     * 
-     * @param <T> the type of the input elements
-     * @param <A> intermediate accumulation type of the downstream collector
-     * @param <R> result type of collector
-     * @param predicate a filter function to be applied to the input elements
-     * @param downstream a collector which will accept filtered values
-     * @return a collector which applies the predicate to the input elements and
-     *         provides the elements for which predicate returned true to the
-     *         downstream collector
-     * @see #pairing(Collector, Collector, BiFunction)
-     * @since 0.4.0
-     */
-    public static <T, A, R> Collector<T, ?, R> filtering(Predicate<? super T> predicate,
-            Collector<T, A, R> downstream) {
-        BiConsumer<A, T> downstreamAccumulator = downstream.accumulator();
-        BiConsumer<A, T> accumulator = (acc, t) -> {
-            if (predicate.test(t))
-                downstreamAccumulator.accept(acc, t);
-        };
-        Predicate<A> finished = finished(downstream);
-        if (finished != null) {
-            return new CancellableCollectorImpl<>(downstream.supplier(), accumulator, downstream.combiner(), downstream
-                    .finisher(), finished, downstream.characteristics());
-        }
-        return Collector.of(downstream.supplier(), accumulator, downstream.combiner(), downstream.finisher(), downstream
-                .characteristics().toArray(new Characteristics[0]));
-    }
-
-    /**
-     * Returns a {@code Collector} which filters input elements by the supplied
-     * predicate, collecting them to the list.
-     *
-     * <p>
-     * This method behaves like
-     * {@code filtering(predicate, Collectors.toList())}.
-     * 
-     * <p>
-     * There are no guarantees on the type, mutability, serializability, or
-     * thread-safety of the {@code List} returned.
-     * 
-     * @param <T> the type of the input elements
-     * @param predicate a filter function to be applied to the input elements
-     * @return a collector which applies the predicate to the input elements and
-     *         collects the elements for which predicate returned true to the
-     *         {@code List}
-     * @see #filtering(Predicate, Collector)
-     * @since 0.6.0
-     */
-    public static <T> Collector<T, ?, List<T>> filtering(Predicate<? super T> predicate) {
-        return filtering(predicate, Collectors.toList());
-    }
-
-    /**
-     * Returns a {@code Collector} which performs the bitwise-and operation of a
-     * integer-valued function applied to the input elements. If no elements are
-     * present, the result is empty {@link OptionalInt}.
-     *
-     * <p>
-     * This method returns a
-     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting
-     * collector</a>: it may not process all the elements if the result is zero.
-     * 
-     * @param <T> the type of the input elements
-     * @param mapper a function extracting the property to be processed
-     * @return a {@code Collector} that produces the bitwise-and operation of a
-     *         derived property
-     * @since 0.4.0
-     */
-    public static <T> Collector<T, ?, OptionalInt> andingInt(ToIntFunction<T> mapper) {
-        return new CancellableCollectorImpl<>(PrimitiveBox::new, (acc, t) -> {
-            if (!acc.b) {
-                acc.i = mapper.applyAsInt(t);
-                acc.b = true;
-            } else {
-                acc.i &= mapper.applyAsInt(t);
-            }
-        }, (acc1, acc2) -> {
-            if (!acc1.b)
-                return acc2;
-            if (!acc2.b)
-                return acc1;
-            acc1.i &= acc2.i;
-            return acc1;
-        }, PrimitiveBox::asInt, acc -> acc.b && acc.i == 0, UNORDERED_CHARACTERISTICS);
-    }
-
-    /**
-     * Returns a {@code Collector} which performs the bitwise-and operation of a
-     * long-valued function applied to the input elements. If no elements are
-     * present, the result is empty {@link OptionalLong}.
-     *
-     * <p>
-     * This method returns a
-     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting
-     * collector</a>: it may not process all the elements if the result is zero.
-     * 
-     * @param <T> the type of the input elements
-     * @param mapper a function extracting the property to be processed
-     * @return a {@code Collector} that produces the bitwise-and operation of a
-     *         derived property
-     * @since 0.4.0
-     */
-    public static <T> Collector<T, ?, OptionalLong> andingLong(ToLongFunction<T> mapper) {
-        return new CancellableCollectorImpl<>(PrimitiveBox::new, (acc, t) -> {
-            if (!acc.b) {
-                acc.l = mapper.applyAsLong(t);
-                acc.b = true;
-            } else {
-                acc.l &= mapper.applyAsLong(t);
-            }
-        }, (acc1, acc2) -> {
-            if (!acc1.b)
-                return acc2;
-            if (!acc2.b)
-                return acc1;
-            acc1.l &= acc2.l;
-            return acc1;
-        }, PrimitiveBox::asLong, acc -> acc.b && acc.l == 0, UNORDERED_CHARACTERISTICS);
-    }
-
-    /**
-     * Returns a {@code Collector} which computes a common prefix of input
-     * {@code CharSequence} objects returning the result as {@code String}. For
-     * empty input the empty {@code String} is returned.
-     *
-     * <p>
-     * The returned {@code Collector} handles specially Unicode surrogate pairs:
-     * the returned prefix may end with
-     * <a href="http://www.unicode.org/glossary/#high_surrogate_code_unit">
-     * Unicode high-surrogate code unit</a> only if it's not succeeded by
-     * <a href="http://www.unicode.org/glossary/#low_surrogate_code_unit">
-     * Unicode low-surrogate code unit</a> in any of the input sequences.
-     * Normally the ending high-surrogate code unit is removed from the prefix.
-     * 
-     * <p>
-     * This method returns a
-     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting
-     * collector</a>: it may not process all the elements if the common prefix
-     * is empty.
-     * 
-     * @return a {@code Collector} which computes a common prefix.
-     * @since 0.5.0
-     */
-    public static Collector<CharSequence, ?, String> commonPrefix() {
-        BiConsumer<ObjIntBox<CharSequence>, CharSequence> accumulator = (acc, t) -> {
-            if (acc.b == -1) {
-                acc.a = t;
-                acc.b = t.length();
-            } else if (acc.b > 0) {
-                if (t.length() < acc.b)
-                    acc.b = t.length();
-                for (int i = 0; i < acc.b; i++) {
-                    if (acc.a.charAt(i) != t.charAt(i)) {
-                        if (i > 0 && Character.isHighSurrogate(t.charAt(i - 1)) && (Character.isLowSurrogate(t.charAt(
-                            i)) || Character.isLowSurrogate(acc.a.charAt(i))))
-                            i--;
-                        acc.b = i;
-                        break;
-                    }
-                }
-            }
-        };
-        return new CancellableCollectorImpl<>(() -> new ObjIntBox<>(null, -1), accumulator, (acc1, acc2) -> {
-            if (acc1.b == -1)
-                return acc2;
-            if (acc2.b != -1)
-                accumulator.accept(acc1, acc2.a.subSequence(0, acc2.b));
-            return acc1;
-        }, acc -> acc.a == null ? "" : acc.a.subSequence(0, acc.b).toString(), acc -> acc.b == 0,
-                UNORDERED_CHARACTERISTICS);
-    }
-
-    /**
-     * Returns a {@code Collector} which computes a common suffix of input
-     * {@code CharSequence} objects returning the result as {@code String}. For
-     * empty input the empty {@code String} is returned.
-     *
-     * <p>
-     * The returned {@code Collector} handles specially Unicode surrogate pairs:
-     * the returned suffix may start with
-     * <a href="http://www.unicode.org/glossary/#low_surrogate_code_unit">
-     * Unicode low-surrogate code unit</a> only if it's not preceded by
-     * <a href="http://www.unicode.org/glossary/#high_surrogate_code_unit">
-     * Unicode high-surrogate code unit</a> in any of the input sequences.
-     * Normally the starting low-surrogate code unit is removed from the suffix.
-     * 
-     * <p>
-     * This method returns a
-     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting
-     * collector</a>: it may not process all the elements if the common suffix
-     * is empty.
-     * 
-     * @return a {@code Collector} which computes a common suffix.
-     * @since 0.5.0
-     */
-    public static Collector<CharSequence, ?, String> commonSuffix() {
-        BiConsumer<ObjIntBox<CharSequence>, CharSequence> accumulator = (acc, t) -> {
-            if (acc.b == -1) {
-                acc.a = t;
-                acc.b = t.length();
-            } else if (acc.b > 0) {
-                int aLen = acc.a.length();
-                int bLen = t.length();
-                if (bLen < acc.b)
-                    acc.b = bLen;
-                for (int i = 0; i < acc.b; i++) {
-                    if (acc.a.charAt(aLen - 1 - i) != t.charAt(bLen - 1 - i)) {
-                        if (i > 0 && Character.isLowSurrogate(t.charAt(bLen - i)) && (Character.isHighSurrogate(t
-                                .charAt(bLen - 1 - i)) || Character.isHighSurrogate(acc.a.charAt(aLen - 1 - i))))
-                            i--;
-                        acc.b = i;
-                        break;
-                    }
-                }
-            }
-        };
-        return new CancellableCollectorImpl<>(() -> new ObjIntBox<>(null, -1), accumulator, (acc1, acc2) -> {
-            if (acc1.b == -1)
-                return acc2;
-            if (acc2.b != -1)
-                accumulator.accept(acc1, acc2.a.subSequence(acc2.a.length() - acc2.b, acc2.a.length()));
-            return acc1;
-        }, acc -> acc.a == null ? "" : acc.a.subSequence(acc.a.length() - acc.b, acc.a.length()).toString(),
-                acc -> acc.b == 0, UNORDERED_CHARACTERISTICS);
-    }
-
-    /**
-     * Returns a collector which collects input elements into {@code List}
-     * removing the elements following their dominator element. The dominator
-     * elements are defined according to given isDominator {@code BiPredicate}.
-     * The isDominator relation must be transitive (if A dominates over B and B
-     * dominates over C, then A also dominates over C).
-     * 
-     * <p>
-     * This operation is similar to
-     * {@code streamEx.collapse(isDominator).toList()}. The important difference
-     * is that in this method {@code BiPredicate} accepts not the adjacent
-     * stream elements, but the leftmost element of the series (current
-     * dominator) and the current element.
-     * 
-     * <p>
-     * For example, consider the stream of numbers:
-     * 
-     * <pre>{@code
-     * StreamEx<Integer> stream = StreamEx.of(1, 5, 3, 4, 2, 7);
-     * }</pre>
-     * 
-     * <p>
-     * Using {@code stream.collapse((a, b) -> a >= b).toList()} you will get the
-     * numbers which are bigger than their immediate predecessor (
-     * {@code [1, 5, 4, 7]}), because (3, 4) pair is not collapsed. However
-     * using {@code stream.collect(dominators((a, b) -> a >= b))} you will get
-     * the numbers which are bigger than any predecessor ({@code [1, 5, 7]}) as
-     * 5 is the dominator element for the subsequent 3, 4 and 2.
-     * 
-     * @param <T> type of the input elements.
-     * @param isDominator a non-interfering, stateless, transitive
-     *        {@code BiPredicate} which returns true if the first argument is
-     *        the dominator for the second argument.
-     * @return a collector which collects input element into {@code List}
-     *         leaving only dominator elements.
-     * @see StreamEx#collapse(BiPredicate)
-     * @since 0.5.1
-     */
-    public static <T> Collector<T, ?, List<T>> dominators(BiPredicate<? super T, ? super T> isDominator) {
-        return Collector.of(ArrayList::new, (acc, t) -> {
-            if (acc.isEmpty() || !isDominator.test(acc.get(acc.size() - 1), t))
-                acc.add(t);
-        }, (acc1, acc2) -> {
-            if (acc1.isEmpty())
-                return acc2;
-            int i = 0, l = acc2.size();
-            T last = acc1.get(acc1.size() - 1);
-            while (i < l && isDominator.test(last, acc2.get(i)))
-                i++;
-            if (i < l)
-                acc1.addAll(acc2.subList(i, l));
-            return acc1;
-        });
-    }
-
-    /**
-     * Returns a {@code Collector} which performs downstream reduction if all
-     * elements satisfy the {@code Predicate}. The result is described as an
-     * {@code Optional<R>}.
-     * 
-     * <p>
-     * The resulting collector returns an empty optional if at least one input
-     * element does not satisfy the predicate. Otherwise it returns an optional
-     * which contains the result of the downstream collector.
-     * 
-     * <p>
-     * This method returns a
-     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting
-     * collector</a>: it may not process all the elements if some of items don't
-     * satisfy the predicate or if downstream collector is a short-circuiting
-     * collector.
-     * 
-     * <p>
-     * It's guaranteed that the downstream collector is not called for elements
-     * which don't satisfy the predicate.
-     *
-     * @param <T> the type of input elements
-     * @param <A> intermediate accumulation type of the downstream collector
-     * @param <R> result type of the downstream collector
-     * @param predicate a non-interfering, stateless predicate to checks whether
-     *        collector should proceed with element
-     * @param downstream a {@code Collector} implementing the downstream
-     *        reduction
-     * @return a {@code Collector} witch performs downstream reduction if all
-     *         elements satisfy the predicate
-     * @see Stream#allMatch(Predicate)
-     * @see AbstractStreamEx#dropWhile(Predicate)
-     * @see AbstractStreamEx#takeWhile(Predicate)
-     * @since 0.6.3
-     */
-    public static <T, A, R> Collector<T, ?, Optional<R>> ifAllMatch(Predicate<T> predicate,
-            Collector<T, A, R> downstream) {
-        Predicate<A> finished = finished(downstream);
-        Supplier<A> supplier = downstream.supplier();
-        BiConsumer<A, T> accumulator = downstream.accumulator();
-        BinaryOperator<A> combiner = downstream.combiner();
-        return new CancellableCollectorImpl<>(
-                () -> new PairBox<>(supplier.get(), Boolean.TRUE),
-                (acc, t) -> {
-                    if (acc.b && predicate.test(t)) {
-                        accumulator.accept(acc.a, t);
-                    } else {
-                        acc.b = Boolean.FALSE;
-                    }
-                },
-                (acc1, acc2) -> {
-                    if (acc1.b && acc2.b) {
-                        acc1.a = combiner.apply(acc1.a, acc2.a);
-                    } else {
-                        acc1.b = Boolean.FALSE;
-                    }
-                    return acc1;
-                },
-                acc -> acc.b ? Optional.of(downstream.finisher().apply(acc.a)) : Optional.empty(),
-                finished == null ? acc -> !acc.b : acc -> !acc.b || finished.test(acc.a),
-                downstream.characteristics().contains(Characteristics.UNORDERED) ? UNORDERED_CHARACTERISTICS
-                        : NO_CHARACTERISTICS);
-    }
-    
-    public static <T> Collector<T, ?, Optional<T>> reducingWithZero(T zero, BinaryOperator<T> accumulator) {
-        // acc.b: 0 = no element, 1 = has element, 2 = zero reached
-        return new CancellableCollectorImpl<>(
-            () -> new ObjIntBox<T>(null, 0),
-            (acc, t) -> {
-                if (acc.b != 2) {
-                    if (acc.b == 1) {
-                        t = accumulator.apply(t, acc.a);
-                    }
-                    if (Objects.equals(t, zero)) {
-                        acc.b = 2;
-                        acc.a = zero;
-                    } else {
-                        acc.b = 1;
-                        acc.a = t;
-                    }
-                }
-            },
-            (acc1, acc2) -> {
-                if (acc1.b == 0 || acc2.b == 2) return acc2;
-                if (acc2.b == 0 || acc1.b == 2) return acc1;
-                T t = accumulator.apply(acc1.a, acc2.a);
-                if (Objects.equals(t, zero)) {
-                    acc1.b = 2;
-                    acc1.a = zero;
-                } else {
-                    acc1.a = t;
-                }
-                return acc1;
-            },
-            acc -> acc.b == 0 ? Optional.empty() : Optional.of(acc.a),
-            acc -> acc.b == 2,
-            UNORDERED_CHARACTERISTICS
-        );
-    }
-    
-    public static <T> Collector<T, ?, T> reducingWithZero(T zero, T identity, BinaryOperator<T> accumulator) {
-        // acc.b: 1 = has element, 2 = zero reached
-        return new CancellableCollectorImpl<>(
-            () -> new ObjIntBox<>(identity, 1),
-            (acc, t) -> {
-                if (acc.b != 2) {
-                    t = accumulator.apply(t, acc.a);
-                    if (Objects.equals(t, zero)) {
-                        acc.b = 2;
-                        acc.a = zero;
-                    } else {
-                        acc.b = 1;
-                        acc.a = t;
-                    }
-                }
-            },
-            (acc1, acc2) -> {
-                if (acc2.b == 2) return acc2;
-                if (acc1.b == 2) return acc1;
-                T t = accumulator.apply(acc1.a, acc2.a);
-                if (Objects.equals(t, zero)) {
-                    acc1.b = 2;
-                    acc1.a = zero;
-                } else {
-                    acc1.a = t;
-                }
-                return acc1;
-            },
-            acc -> acc.a,
-            acc -> acc.b == 2,
-            UNORDERED_CHARACTERISTICS
-        );
-    }
-}
+/*
+ * Copyright 2015, 2019 StreamEx contributors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package one.util.streamex;
+
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.Deque;
+import java.util.EnumMap;
+import java.util.EnumSet;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+import java.util.OptionalInt;
+import java.util.Map.Entry;
+import java.util.Optional;
+import java.util.OptionalLong;
+import java.util.Set;
+import java.util.function.BiConsumer;
+import java.util.function.BiFunction;
+import java.util.function.BiPredicate;
+import java.util.function.BinaryOperator;
+import java.util.function.Function;
+import java.util.function.IntFunction;
+import java.util.function.Predicate;
+import java.util.function.Supplier;
+import java.util.function.ToIntFunction;
+import java.util.function.ToLongFunction;
+import java.util.stream.Collector;
+import java.util.stream.Collector.Characteristics;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+import static one.util.streamex.Internals.*;
+
+/**
+ * Implementations of several collectors in addition to ones available in JDK.
+ * 
+ * @author Tagir Valeev
+ * @see Collectors
+ * @see Joining
+ * @since 0.3.2
+ */
+public final class MoreCollectors {
+    private MoreCollectors() {
+        throw new UnsupportedOperationException();
+    }
+
+    /**
+     * Returns a {@code Collector} which just ignores the input and calls the
+     * provided supplier once to return the output.
+     * 
+     * @param <T> the type of input elements
+     * @param <U> the type of output
+     * @param supplier the supplier of the output
+     * @return a {@code Collector} which just ignores the input and calls the
+     *         provided supplier once to return the output.
+     */
+    private static <T, U> Collector<T, ?, U> empty(Supplier<U> supplier) {
+        return new CancellableCollectorImpl<>(() -> NONE, (acc, t) -> {
+            // empty
+        }, selectFirst(), acc -> supplier.get(), alwaysTrue(), EnumSet.of(Characteristics.UNORDERED,
+            Characteristics.CONCURRENT));
+    }
+
+    private static <T> Collector<T, ?, List<T>> empty() {
+        return empty(ArrayList<T>::new);
+    }
+
+    /**
+     * Returns a {@code Collector} that accumulates the input elements into a
+     * new array.
+     * 
+     * The operation performed by the returned collector is equivalent to
+     * {@code stream.toArray(generator)}. This collector is mostly useful as a
+     * downstream collector.
+     *
+     * @param <T> the type of the input elements
+     * @param generator a function which produces a new array of the desired
+     *        type and the provided length
+     * @return a {@code Collector} which collects all the input elements into an
+     *         array, in encounter order
+     * @throws NullPointerException if generator is null.
+     */
+    public static <T> Collector<T, ?, T[]> toArray(IntFunction<T[]> generator) {
+        Objects.requireNonNull(generator);
+        return Collectors.collectingAndThen(Collectors.toList(), list -> list.toArray(generator.apply(list.size())));
+    }
+
+    /**
+     * Returns a {@code Collector} which produces a boolean array containing the
+     * results of applying the given predicate to the input elements, in
+     * encounter order.
+     * 
+     * @param <T> the type of the input elements
+     * @param predicate a non-interfering, stateless predicate to apply to each
+     *        input element. The result values of this predicate are collected
+     *        to the resulting boolean array.
+     * @return a {@code Collector} which collects the results of the predicate
+     *         function to the boolean array, in encounter order.
+     * @throws NullPointerException if predicate is null.
+     * @since 0.3.8
+     */
+    public static <T> Collector<T, ?, boolean[]> toBooleanArray(Predicate<T> predicate) {
+        Objects.requireNonNull(predicate);
+        return PartialCollector.booleanArray().asRef((box, t) -> {
+            if (predicate.test(t))
+                box.a.set(box.b);
+            box.b = StrictMath.addExact(box.b, 1);
+        });
+    }
+
+    /**
+     * Returns a {@code Collector} that accumulates the input enum values into a
+     * new {@code EnumSet}.
+     *
+     * <p>
+     * This method returns a
+     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting
+     * collector</a>: it may not process all the elements if the resulting set
+     * contains all possible enum values.
+     * 
+     * @param <T> the type of the input elements
+     * @param enumClass the class of input enum values
+     * @return a {@code Collector} which collects all the input elements into a
+     *         {@code EnumSet}
+     * @throws NullPointerException if enumClass is null.
+     */
+    public static <T extends Enum<T>> Collector<T, ?, EnumSet<T>> toEnumSet(Class<T> enumClass) {
+        int size = EnumSet.allOf(enumClass).size();
+        return new CancellableCollectorImpl<>(() -> EnumSet.noneOf(enumClass), EnumSet::add, (s1, s2) -> {
+            s1.addAll(s2);
+            return s1;
+        }, Function.identity(), set -> set.size() == size, UNORDERED_ID_CHARACTERISTICS);
+    }
+
+    /**
+     * Returns a {@code Collector} which counts a number of distinct values the
+     * mapper function returns for the stream elements.
+     * 
+     * <p>
+     * The operation performed by the returned collector is equivalent to
+     * {@code stream.map(mapper).distinct().count()}. This collector is mostly
+     * useful as a downstream collector.
+     * 
+     * @param <T> the type of the input elements
+     * @param mapper a function which classifies input elements.
+     * @return a collector which counts a number of distinct classes the mapper
+     *         function returns for the stream elements.
+     * @throws NullPointerException if mapper is null.
+     */
+    public static <T> Collector<T, ?, Integer> distinctCount(Function<? super T, ?> mapper) {
+        Objects.requireNonNull(mapper);
+        return Collectors.collectingAndThen(Collectors.mapping(mapper, Collectors.toSet()), Set::size);
+    }
+
+    /**
+     * Returns a {@code Collector} which collects into the {@link List} the
+     * input elements for which given mapper function returns distinct results.
+     *
+     * <p>
+     * For ordered source the order of collected elements is preserved. If the
+     * same result is returned by mapper function for several elements, only the
+     * first element is included into the resulting list.
+     * 
+     * <p>
+     * There are no guarantees on the type, mutability, serializability, or
+     * thread-safety of the {@code List} returned.
+     * 
+     * <p>
+     * The operation performed by the returned collector is equivalent to
+     * {@code stream.distinct(mapper).toList()}, but may work faster.
+     * 
+     * @param <T> the type of the input elements
+     * @param mapper a function which classifies input elements.
+     * @return a collector which collects distinct elements to the {@code List}.
+     * @throws NullPointerException if mapper is null.
+     * @since 0.3.8
+     */
+    public static <T> Collector<T, ?, List<T>> distinctBy(Function<? super T, ?> mapper) {
+        Objects.requireNonNull(mapper);
+        return Collector.<T, Map<Object, T>, List<T>> of(LinkedHashMap::new, (map, t) -> map.putIfAbsent(mapper.apply(
+            t), t), (m1, m2) -> {
+                for (Entry<Object, T> e : m2.entrySet()) {
+                    m1.putIfAbsent(e.getKey(), e.getValue());
+                }
+                return m1;
+            }, map -> new ArrayList<>(map.values()));
+    }
+
+    /**
+     * Returns a {@code Collector} accepting elements of type {@code T} that
+     * counts the number of input elements and returns result as {@code Integer}
+     * . If no elements are present, the result is 0.
+     *
+     * @param <T> the type of the input elements
+     * @return a {@code Collector} that counts the input elements
+     * @since 0.3.3
+     * @see Collectors#counting()
+     */
+    public static <T> Collector<T, ?, Integer> countingInt() {
+        return PartialCollector.intSum().asRef((acc, t) -> acc[0]++);
+    }
+
+    /**
+     * Returns a {@code Collector} which aggregates the results of two supplied
+     * collectors using the supplied finisher function.
+     * 
+     * <p>
+     * This method returns a
+     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting
+     * collector</a> if both downstream collectors are short-circuiting. The
+     * collection might stop when both downstream collectors report that the
+     * collection is complete.
+     * 
+     * <p>
+     * This collector is similar to the {@code teeing} collector available since
+     * JDK 12. The only difference is that this collector correctly combines 
+     * short-circuiting collectors.
+     * 
+     * @param <T> the type of the input elements
+     * @param <A1> the intermediate accumulation type of the first collector
+     * @param <A2> the intermediate accumulation type of the second collector
+     * @param <R1> the result type of the first collector
+     * @param <R2> the result type of the second collector
+     * @param <R> the final result type
+     * @param c1 the first collector
+     * @param c2 the second collector
+     * @param finisher the function which merges two results into the single
+     *        one.
+     * @return a {@code Collector} which aggregates the results of two supplied
+     *         collectors.
+     * @throws NullPointerException if c1 is null, or c2 is null, or finisher is null.
+     */
+    public static <T, A1, A2, R1, R2, R> Collector<T, ?, R> pairing(Collector<? super T, A1, R1> c1,
+            Collector<? super T, A2, R2> c2, BiFunction<? super R1, ? super R2, ? extends R> finisher) {
+        Objects.requireNonNull(finisher);
+        EnumSet<Characteristics> c = EnumSet.noneOf(Characteristics.class);
+        c.addAll(c1.characteristics());
+        c.retainAll(c2.characteristics());
+        c.remove(Characteristics.IDENTITY_FINISH);
+
+        Supplier<A1> c1Supplier = c1.supplier();
+        Supplier<A2> c2Supplier = c2.supplier();
+        BiConsumer<A1, ? super T> c1Accumulator = c1.accumulator();
+        BiConsumer<A2, ? super T> c2Accumulator = c2.accumulator();
+        BinaryOperator<A1> c1Combiner = c1.combiner();
+        BinaryOperator<A2> c2combiner = c2.combiner();
+
+        Supplier<PairBox<A1, A2>> supplier = () -> new PairBox<>(c1Supplier.get(), c2Supplier.get());
+        BiConsumer<PairBox<A1, A2>, T> accumulator = (acc, v) -> {
+            c1Accumulator.accept(acc.a, v);
+            c2Accumulator.accept(acc.b, v);
+        };
+        BinaryOperator<PairBox<A1, A2>> combiner = (acc1, acc2) -> {
+            acc1.a = c1Combiner.apply(acc1.a, acc2.a);
+            acc1.b = c2combiner.apply(acc1.b, acc2.b);
+            return acc1;
+        };
+        Function<PairBox<A1, A2>, R> resFinisher = acc -> {
+            R1 r1 = c1.finisher().apply(acc.a);
+            R2 r2 = c2.finisher().apply(acc.b);
+            return finisher.apply(r1, r2);
+        };
+        Predicate<A1> c1Finished = finished(c1);
+        Predicate<A2> c2Finished = finished(c2);
+        if (c1Finished != null && c2Finished != null) {
+            Predicate<PairBox<A1, A2>> finished = acc -> c1Finished.test(acc.a) && c2Finished.test(acc.b);
+            return new CancellableCollectorImpl<>(supplier, accumulator, combiner, resFinisher, finished, c);
+        }
+        return Collector.of(supplier, accumulator, combiner, resFinisher, c.toArray(new Characteristics[0]));
+    }
+
+    /**
+     * Returns a {@code Collector} which finds the minimal and maximal element
+     * according to the supplied comparator, then applies finisher function to
+     * them producing the final result.
+     * 
+     * <p>
+     * This collector produces stable result for ordered stream: if several
+     * minimal or maximal elements appear, the collector always selects the
+     * first encountered.
+     * 
+     * <p>
+     * If there are no input elements, the finisher method is not called and
+     * empty {@code Optional} is returned. Otherwise the finisher result is
+     * wrapped into {@code Optional}.
+     *
+     * @param <T> the type of the input elements
+     * @param <R> the type of the result wrapped into {@code Optional}
+     * @param comparator comparator which is used to find minimal and maximal
+     *        element
+     * @param finisher a {@link BiFunction} which takes minimal and maximal
+     *        element and produces the final result.
+     * @return a {@code Collector} which finds minimal and maximal elements.
+     * @throws NullPointerException if comparator is null, finisher is null, 
+     * or finisher returns null.
+     */
+    public static <T, R> Collector<T, ?, Optional<R>> minMax(Comparator<? super T> comparator,
+            BiFunction<? super T, ? super T, ? extends R> finisher) {
+        Objects.requireNonNull(finisher);
+        return pairing(Collectors.minBy(comparator), Collectors.maxBy(comparator), 
+            (min, max) -> min.isPresent() ? Optional.of(finisher.apply(min.get(), max.get())) : Optional.empty());
+    }
+
+    /**
+     * Returns a {@code Collector} which finds all the elements which are equal
+     * to each other and bigger than any other element according to the
+     * specified {@link Comparator}. The found elements are reduced using the
+     * specified downstream {@code Collector}.
+     *
+     * @param <T> the type of the input elements
+     * @param <A> the intermediate accumulation type of the downstream collector
+     * @param <D> the result type of the downstream reduction
+     * @param comparator a {@code Comparator} to compare the elements
+     * @param downstream a {@code Collector} implementing the downstream
+     *        reduction
+     * @return a {@code Collector} which finds all the maximal elements.
+     * @throws NullPointerException if comparator is null, or downstream is null.
+     * @see #maxAll(Comparator)
+     * @see #maxAll(Collector)
+     * @see #maxAll()
+     */
+    public static <T, A, D> Collector<T, ?, D> maxAll(Comparator<? super T> comparator,
+            Collector<? super T, A, D> downstream) {
+        Objects.requireNonNull(comparator);
+        Supplier<A> downstreamSupplier = downstream.supplier();
+        BiConsumer<A, ? super T> downstreamAccumulator = downstream.accumulator();
+        BinaryOperator<A> downstreamCombiner = downstream.combiner();
+        Supplier<PairBox<A, T>> supplier = () -> new PairBox<>(downstreamSupplier.get(), none());
+        BiConsumer<PairBox<A, T>, T> accumulator = (acc, t) -> {
+            if (acc.b == NONE) {
+                downstreamAccumulator.accept(acc.a, t);
+                acc.b = t;
+            } else {
+                int cmp = comparator.compare(t, acc.b);
+                if (cmp > 0) {
+                    acc.a = downstreamSupplier.get();
+                    acc.b = t;
+                }
+                if (cmp >= 0)
+                    downstreamAccumulator.accept(acc.a, t);
+            }
+        };
+        BinaryOperator<PairBox<A, T>> combiner = (acc1, acc2) -> {
+            if (acc2.b == NONE) {
+                return acc1;
+            }
+            if (acc1.b == NONE) {
+                return acc2;
+            }
+            int cmp = comparator.compare(acc1.b, acc2.b);
+            if (cmp > 0) {
+                return acc1;
+            }
+            if (cmp < 0) {
+                return acc2;
+            }
+            acc1.a = downstreamCombiner.apply(acc1.a, acc2.a);
+            return acc1;
+        };
+        Function<PairBox<A, T>, D> finisher = acc -> downstream.finisher().apply(acc.a);
+        return Collector.of(supplier, accumulator, combiner, finisher);
+    }
+
+    /**
+     * Returns a {@code Collector} which finds all the elements which are equal
+     * to each other and bigger than any other element according to the
+     * specified {@link Comparator}. The found elements are collected to
+     * {@link List}.
+     *
+     * @param <T> the type of the input elements
+     * @param comparator a {@code Comparator} to compare the elements
+     * @return a {@code Collector} which finds all the maximal elements and
+     *         collects them to the {@code List}.
+     * @throws NullPointerException if comparator is null.
+     * @see #maxAll(Comparator, Collector)
+     * @see #maxAll()
+     */
+    public static <T> Collector<T, ?, List<T>> maxAll(Comparator<? super T> comparator) {
+        return maxAll(comparator, Collectors.toList());
+    }
+
+    /**
+     * Returns a {@code Collector} which finds all the elements which are equal
+     * to each other and bigger than any other element according to the natural
+     * order. The found elements are reduced using the specified downstream
+     * {@code Collector}.
+     *
+     * @param <T> the type of the input elements
+     * @param <A> the intermediate accumulation type of the downstream collector
+     * @param <D> the result type of the downstream reduction
+     * @param downstream a {@code Collector} implementing the downstream
+     *        reduction
+     * @return a {@code Collector} which finds all the maximal elements.
+     * @throws NullPointerException if downstream is null.
+     * @see #maxAll(Comparator, Collector)
+     * @see #maxAll(Comparator)
+     * @see #maxAll()
+     */
+    public static <T extends Comparable<? super T>, A, D> Collector<T, ?, D> maxAll(Collector<T, A, D> downstream) {
+        return maxAll(Comparator.<T> naturalOrder(), downstream);
+    }
+
+    /**
+     * Returns a {@code Collector} which finds all the elements which are equal
+     * to each other and bigger than any other element according to the natural
+     * order. The found elements are collected to {@link List}.
+     *
+     * @param <T> the type of the input elements
+     * @return a {@code Collector} which finds all the maximal elements and
+     *         collects them to the {@code List}.
+     * @see #maxAll(Comparator)
+     * @see #maxAll(Collector)
+     */
+    public static <T extends Comparable<? super T>> Collector<T, ?, List<T>> maxAll() {
+        return maxAll(Comparator.<T> naturalOrder(), Collectors.toList());
+    }
+
+    /**
+     * Returns a {@code Collector} which finds all the elements which are equal
+     * to each other and smaller than any other element according to the
+     * specified {@link Comparator}. The found elements are reduced using the
+     * specified downstream {@code Collector}.
+     *
+     * @param <T> the type of the input elements
+     * @param <A> the intermediate accumulation type of the downstream collector
+     * @param <D> the result type of the downstream reduction
+     * @param comparator a {@code Comparator} to compare the elements
+     * @param downstream a {@code Collector} implementing the downstream
+     *        reduction
+     * @return a {@code Collector} which finds all the minimal elements.
+     * @throws NullPointerException if comparator is null, or downstream is null.
+     * @see #minAll(Comparator)
+     * @see #minAll(Collector)
+     * @see #minAll()
+     */
+    public static <T, A, D> Collector<T, ?, D> minAll(Comparator<? super T> comparator, Collector<T, A, D> downstream) {
+        return maxAll(comparator.reversed(), downstream);
+    }
+
+    /**
+     * Returns a {@code Collector} which finds all the elements which are equal
+     * to each other and smaller than any other element according to the
+     * specified {@link Comparator}. The found elements are collected to
+     * {@link List}.
+     *
+     * @param <T> the type of the input elements
+     * @param comparator a {@code Comparator} to compare the elements
+     * @return a {@code Collector} which finds all the minimal elements and
+     *         collects them to the {@code List}.
+     * @throws NullPointerException if comparator is null.
+     * @see #minAll(Comparator, Collector)
+     * @see #minAll()
+     */
+    public static <T> Collector<T, ?, List<T>> minAll(Comparator<? super T> comparator) {
+        return maxAll(comparator.reversed(), Collectors.toList());
+    }
+
+    /**
+     * Returns a {@code Collector} which finds all the elements which are equal
+     * to each other and smaller than any other element according to the natural
+     * order. The found elements are reduced using the specified downstream
+     * {@code Collector}.
+     *
+     * @param <T> the type of the input elements
+     * @param <A> the intermediate accumulation type of the downstream collector
+     * @param <D> the result type of the downstream reduction
+     * @param downstream a {@code Collector} implementing the downstream
+     *        reduction
+     * @return a {@code Collector} which finds all the minimal elements.
+     * @throws NullPointerException if downstream is null.
+     * @see #minAll(Comparator, Collector)
+     * @see #minAll(Comparator)
+     * @see #minAll()
+     */
+    public static <T extends Comparable<? super T>, A, D> Collector<T, ?, D> minAll(Collector<T, A, D> downstream) {
+        return maxAll(Comparator.<T> reverseOrder(), downstream);
+    }
+
+    /**
+     * Returns a {@code Collector} which finds all the elements which are equal
+     * to each other and smaller than any other element according to the natural
+     * order. The found elements are collected to {@link List}.
+     *
+     * @param <T> the type of the input elements
+     * @return a {@code Collector} which finds all the minimal elements and
+     *         collects them to the {@code List}.
+     * @see #minAll(Comparator)
+     * @see #minAll(Collector)
+     */
+    public static <T extends Comparable<? super T>> Collector<T, ?, List<T>> minAll() {
+        return maxAll(Comparator.<T> reverseOrder(), Collectors.toList());
+    }
+
+    /**
+     * Returns a {@code Collector} which collects the stream element if stream
+     * contains exactly one element.
+     * 
+     * <p>
+     * This method returns a
+     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting
+     * collector</a>.
+     * 
+     * @param <T> the type of the input elements
+     * @return a collector which returns an {@link Optional} describing the only
+     *         element of the stream. For empty stream or stream containing more
+     *         than one element an empty {@code Optional} is returned.
+     * @throws NullPointerException if the only stream element is null.
+     * @since 0.4.0
+     */
+    public static <T> Collector<T, ?, Optional<T>> onlyOne() {
+        return new CancellableCollectorImpl<T, Box<Optional<T>>, Optional<T>>(Box::new, (box,
+                t) -> box.a = box.a == null ? Optional.of(t) : Optional.empty(), (box1, box2) -> box1.a == null ? box2
+                        : box2.a == null ? box1 : new Box<>(Optional.empty()), box -> box.a == null ? Optional.empty()
+                                : box.a, box -> box.a != null && !box.a.isPresent(), UNORDERED_CHARACTERISTICS);
+    }
+
+    /**
+     * Returns a {@code Collector} which collects the stream element satisfying the predicate
+     * if there is only one such element.
+     *
+     * <p>
+     * This method returns a
+     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting
+     * collector</a>.
+     *
+     * @param predicate a predicate to be applied to the stream elements
+     * @param <T> the type of the input elements
+     * @return a collector which returns an {@link Optional} describing the only
+     *         element of the stream satisfying the predicate. If stream contains no elements satisfying the predicate,
+     *         or more than one such element, an empty {@code Optional} is returned.
+     * @throws NullPointerException if predicate is null or the only stream element is null.
+     * @since 0.6.7
+     */
+    public static <T> Collector<T, ?, Optional<T>> onlyOne(Predicate<? super T> predicate) {
+        return filtering(predicate, onlyOne());
+    }
+
+    /**
+     * Returns a {@code Collector} which collects only the first stream element
+     * if any.
+     * 
+     * <p>
+     * This method returns a
+     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting
+     * collector</a>.
+     * 
+     * <p>
+     * The operation performed by the returned collector is equivalent to
+     * {@code stream.findFirst()}. This collector is mostly useful as a
+     * downstream collector.
+     * 
+     * @param <T> the type of the input elements
+     * @return a collector which returns an {@link Optional} which describes the
+     *         first element of the stream. For empty stream an empty
+     *         {@code Optional} is returned.
+     * @throws NullPointerException if the first stream element is null.
+     */
+    public static <T> Collector<T, ?, Optional<T>> first() {
+        return new CancellableCollectorImpl<>(() -> new Box<T>(none()), (box, t) -> {
+            if (box.a == NONE)
+                box.a = t;
+        }, (box1, box2) -> box1.a == NONE ? box2 : box1, box -> box.a == NONE ? Optional.empty() : Optional.of(box.a),
+                box -> box.a != NONE, NO_CHARACTERISTICS);
+    }
+
+    /**
+     * Returns a {@code Collector} which collects only the last stream element
+     * if any.
+     * 
+     * @param <T> the type of the input elements
+     * @return a collector which returns an {@link Optional} which describes the
+     *         last element of the stream. For empty stream an empty
+     *         {@code Optional} is returned.
+     * @throws NullPointerException if the last stream element is null.
+     */
+    public static <T> Collector<T, ?, Optional<T>> last() {
+        return Collector.of(() -> new Box<T>(none()), (box, t) -> box.a = t, 
+            (box1, box2) -> box2.a == NONE ? box1 : box2, box -> box.a == NONE ? Optional.empty() : Optional.of(box.a));
+    }
+
+    /**
+     * Returns a {@code Collector} which collects at most specified number of
+     * the first stream elements into the {@link List}.
+     *
+     * <p>
+     * This method returns a
+     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting
+     * collector</a>.
+     * 
+     * <p>
+     * There are no guarantees on the type, mutability, serializability, or
+     * thread-safety of the {@code List} returned.
+     * 
+     * <p>
+     * The operation performed by the returned collector is equivalent to
+     * {@code stream.limit(n).collect(Collectors.toList())}. This collector is
+     * mostly useful as a downstream collector.
+     * 
+     * @param <T> the type of the input elements
+     * @param n maximum number of stream elements to preserve
+     * @return a collector which returns a {@code List} containing the first n
+     *         stream elements or less if the stream was shorter.
+     */
+    public static <T> Collector<T, ?, List<T>> head(int n) {
+        if (n <= 0)
+            return empty();
+        return new CancellableCollectorImpl<>(ArrayList::new, (acc, t) -> {
+            if (acc.size() < n)
+                acc.add(t);
+        }, (acc1, acc2) -> {
+            acc1.addAll(acc2.subList(0, Math.min(acc2.size(), n - acc1.size())));
+            return acc1;
+        }, Function.identity(), acc -> acc.size() >= n, ID_CHARACTERISTICS);
+    }
+
+    /**
+     * Returns a {@code Collector} which collects at most specified number of
+     * the last stream elements into the {@link List}.
+     * 
+     * <p>
+     * There are no guarantees on the type, mutability, serializability, or
+     * thread-safety of the {@code List} returned.
+     * 
+     * <p>
+     * When supplied {@code n} is less or equal to zero, this method returns a
+     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting
+     * collector</a> which ignores the input and produces an empty list.
+     * 
+     * @param <T> the type of the input elements
+     * @param n maximum number of stream elements to preserve
+     * @return a collector which returns a {@code List} containing the last n
+     *         stream elements or less if the stream was shorter.
+     */
+    public static <T> Collector<T, ?, List<T>> tail(int n) {
+        if (n <= 0)
+            return empty();
+        return Collector.<T, Deque<T>, List<T>> of(ArrayDeque::new, (acc, t) -> {
+            if (acc.size() == n)
+                acc.pollFirst();
+            acc.addLast(t);
+        }, (acc1, acc2) -> {
+            while (acc2.size() < n && !acc1.isEmpty()) {
+                acc2.addFirst(acc1.pollLast());
+            }
+            return acc2;
+        }, ArrayList::new);
+    }
+
+    /**
+     * Returns a {@code Collector} which collects at most specified number of
+     * the greatest stream elements according to the specified
+     * {@link Comparator} into the {@link List}. The resulting {@code List} is
+     * sorted in comparator reverse order (greatest element is the first). The
+     * order of equal elements is the same as in the input stream.
+     * 
+     * <p>
+     * The operation performed by the returned collector is equivalent to
+     * {@code stream.sorted(comparator.reversed()).limit(n).collect(Collectors.toList())}
+     * , but usually performed much faster if {@code n} is much less than the
+     * stream size.
+     * 
+     * <p>
+     * There are no guarantees on the type, mutability, serializability, or
+     * thread-safety of the {@code List} returned.
+     * 
+     * <p>
+     * When supplied {@code n} is less or equal to zero, this method returns a
+     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting
+     * collector</a> which ignores the input and produces an empty list.
+     * 
+     * @param <T> the type of the input elements
+     * @param comparator the comparator to compare the elements by
+     * @param n maximum number of stream elements to preserve
+     * @return a collector which returns a {@code List} containing the greatest
+     *         n stream elements or less if the stream was shorter.
+     * @throws NullPointerException if comparator is null.
+     */
+    public static <T> Collector<T, ?, List<T>> greatest(Comparator<? super T> comparator, int n) {
+        return least(comparator.reversed(), n);
+    }
+
+    /**
+     * Returns a {@code Collector} which collects at most specified number of
+     * the greatest stream elements according to the natural order into the
+     * {@link List}. The resulting {@code List} is sorted in reverse order
+     * (greatest element is the first). The order of equal elements is the same
+     * as in the input stream.
+     * 
+     * <p>
+     * The operation performed by the returned collector is equivalent to
+     * {@code stream.sorted(Comparator.reverseOrder()).limit(n).collect(Collectors.toList())}
+     * , but usually performed much faster if {@code n} is much less than the
+     * stream size.
+     * 
+     * <p>
+     * There are no guarantees on the type, mutability, serializability, or
+     * thread-safety of the {@code List} returned.
+     * 
+     * <p>
+     * When supplied {@code n} is less or equal to zero, this method returns a
+     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting
+     * collector</a> which ignores the input and produces an empty list.
+     * 
+     * @param <T> the type of the input elements
+     * @param n maximum number of stream elements to preserve
+     * @return a collector which returns a {@code List} containing the greatest
+     *         n stream elements or less if the stream was shorter.
+     */
+    public static <T extends Comparable<? super T>> Collector<T, ?, List<T>> greatest(int n) {
+        return least(Comparator.<T> reverseOrder(), n);
+    }
+
+    /**
+     * Returns a {@code Collector} which collects at most specified number of
+     * the least stream elements according to the specified {@link Comparator}
+     * into the {@link List}. The resulting {@code List} is sorted in comparator
+     * order (least element is the first). The order of equal elements is the
+     * same as in the input stream.
+     * 
+     * <p>
+     * The operation performed by the returned collector is equivalent to
+     * {@code stream.sorted(comparator).limit(n).collect(Collectors.toList())},
+     * but usually performed much faster if {@code n} is much less than the
+     * stream size.
+     * 
+     * <p>
+     * There are no guarantees on the type, mutability, serializability, or
+     * thread-safety of the {@code List} returned.
+     * 
+     * <p>
+     * When supplied {@code n} is less or equal to zero, this method returns a
+     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting
+     * collector</a> which ignores the input and produces an empty list.
+     * 
+     * @param <T> the type of the input elements
+     * @param comparator the comparator to compare the elements by
+     * @param n maximum number of stream elements to preserve
+     * @return a collector which returns a {@code List} containing the least n
+     *         stream elements or less if the stream was shorter.
+     * @throws NullPointerException if comparator is null.
+     */
+    public static <T> Collector<T, ?, List<T>> least(Comparator<? super T> comparator, int n) {
+        Objects.requireNonNull(comparator);
+        if (n <= 0)
+            return empty();
+        if (n == 1) {
+            return Collector.of(() -> new Box<T>(none()), (box, t) -> {
+                if (box.a == NONE || comparator.compare(t, box.a) < 0)
+                    box.a = t;
+            }, (box1, box2) -> (box2.a != NONE && (box1.a == NONE || comparator.compare(box2.a, box1.a) < 0)) ? box2
+                    : box1, box -> box.a == NONE ? new ArrayList<>() : new ArrayList<>(Collections.singleton(box.a)));
+        }
+        if (n >= Integer.MAX_VALUE / 2)
+            return collectingAndThen(Collectors.toList(), list -> {
+                list.sort(comparator);
+                if (list.size() <= n)
+                    return list;
+                return new ArrayList<>(list.subList(0, n));
+            });
+        return Collector.<T, Limiter<T>, List<T>> of(() -> new Limiter<>(n, comparator), Limiter::put, Limiter::putAll,
+            pq -> {
+                pq.sort();
+                return new ArrayList<>(pq);
+            });
+    }
+
+    /**
+     * Returns a {@code Collector} which collects at most specified number of
+     * the least stream elements according to the natural order into the
+     * {@link List}. The resulting {@code List} is sorted in natural order
+     * (least element is the first). The order of equal elements is the same as
+     * in the input stream.
+     * 
+     * <p>
+     * The operation performed by the returned collector is equivalent to
+     * {@code stream.sorted().limit(n).collect(Collectors.toList())}, but
+     * usually performed much faster if {@code n} is much less than the stream
+     * size.
+     * 
+     * <p>
+     * There are no guarantees on the type, mutability, serializability, or
+     * thread-safety of the {@code List} returned.
+     * 
+     * <p>
+     * When supplied {@code n} is less or equal to zero, this method returns a
+     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting
+     * collector</a> which ignores the input and produces an empty list.
+     * 
+     * @param <T> the type of the input elements
+     * @param n maximum number of stream elements to preserve
+     * @return a collector which returns a {@code List} containing the least n
+     *         stream elements or less if the stream was shorter.
+     */
+    public static <T extends Comparable<? super T>> Collector<T, ?, List<T>> least(int n) {
+        return least(Comparator.<T> naturalOrder(), n);
+    }
+
+    /**
+     * Returns a {@code Collector} which finds the index of the minimal stream
+     * element according to the specified {@link Comparator}. If there are
+     * several minimal elements, the index of the first one is returned.
+     *
+     * @param <T> the type of the input elements
+     * @param comparator a {@code Comparator} to compare the elements
+     * @return a {@code Collector} which finds the index of the minimal element.
+     * @throws NullPointerException if comparator is null.
+     * @see #minIndex()
+     * @since 0.3.5
+     */
+    public static <T> Collector<T, ?, OptionalLong> minIndex(Comparator<? super T> comparator) {
+        Objects.requireNonNull(comparator);
+        class Container {
+            T value;
+            long count = 0;
+            long index = -1;
+        }
+        return Collector.of(Container::new, (c, t) -> {
+            if (c.index == -1 || comparator.compare(c.value, t) > 0) {
+                c.value = t;
+                c.index = c.count;
+            }
+            c.count++;
+        }, (c1, c2) -> {
+            if (c1.index == -1 || (c2.index != -1 && comparator.compare(c1.value, c2.value) > 0)) {
+                c2.index += c1.count;
+                c2.count += c1.count;
+                return c2;
+            }
+            c1.count += c2.count;
+            return c1;
+        }, c -> c.index == -1 ? OptionalLong.empty() : OptionalLong.of(c.index));
+    }
+
+    /**
+     * Returns a {@code Collector} which finds the index of the minimal stream
+     * element according to the elements natural order. If there are several
+     * minimal elements, the index of the first one is returned.
+     *
+     * @param <T> the type of the input elements
+     * @return a {@code Collector} which finds the index of the minimal element.
+     * @see #minIndex(Comparator)
+     * @since 0.3.5
+     */
+    public static <T extends Comparable<? super T>> Collector<T, ?, OptionalLong> minIndex() {
+        return minIndex(Comparator.naturalOrder());
+    }
+
+    /**
+     * Returns a {@code Collector} which finds the index of the maximal stream
+     * element according to the specified {@link Comparator}. If there are
+     * several maximal elements, the index of the first one is returned.
+     *
+     * @param <T> the type of the input elements
+     * @param comparator a {@code Comparator} to compare the elements
+     * @return a {@code Collector} which finds the index of the maximal element.
+     * @throws NullPointerException if comparator is null.
+     * @see #maxIndex()
+     * @since 0.3.5
+     */
+    public static <T> Collector<T, ?, OptionalLong> maxIndex(Comparator<? super T> comparator) {
+        return minIndex(comparator.reversed());
+    }
+
+    /**
+     * Returns a {@code Collector} which finds the index of the maximal stream
+     * element according to the elements natural order. If there are several
+     * maximal elements, the index of the first one is returned.
+     *
+     * @param <T> the type of the input elements
+     * @return a {@code Collector} which finds the index of the maximal element.
+     * @see #maxIndex(Comparator)
+     * @since 0.3.5
+     */
+    public static <T extends Comparable<? super T>> Collector<T, ?, OptionalLong> maxIndex() {
+        return minIndex(Comparator.reverseOrder());
+    }
+
+    /**
+     * Returns a {@code Collector} implementing a cascaded "group by" operation
+     * on input elements of type {@code T}, for classification function which
+     * maps input elements to the enum values. The downstream reduction for
+     * repeating keys is performed using the specified downstream
+     * {@code Collector}.
+     *
+     * <p>
+     * Unlike the {@link Collectors#groupingBy(Function, Collector)} collector
+     * this collector produces an {@link EnumMap} which contains all possible
+     * keys including keys which were never returned by the classification
+     * function. These keys are mapped to the default collector value which is
+     * equivalent to collecting an empty stream with the same collector.
+     * 
+     * <p>
+     * This method returns a
+     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting
+     * collector</a> if the downstream collector is short-circuiting. The
+     * collection might stop when for every possible enum key the downstream
+     * collection is known to be finished.
+     *
+     * @param <T> the type of the input elements
+     * @param <K> the type of the enum values returned by the classifier
+     * @param <A> the intermediate accumulation type of the downstream collector
+     * @param <D> the result type of the downstream reduction
+     * @param enumClass the class of enum values returned by the classifier
+     * @param classifier a classifier function mapping input elements to enum
+     *        values
+     * @param downstream a {@code Collector} implementing the downstream
+     *        reduction
+     * @return a {@code Collector} implementing the cascaded group-by operation
+     * @throws NullPointerException if enumClass is null, classifier is null, or downstream is null.
+     * @see Collectors#groupingBy(Function, Collector)
+     * @see #groupingBy(Function, Set, Supplier, Collector)
+     * @since 0.3.7
+     */
+    public static <T, K extends Enum<K>, A, D> Collector<T, ?, EnumMap<K, D>> groupingByEnum(Class<K> enumClass,
+            Function<? super T, K> classifier, Collector<? super T, A, D> downstream) {
+        return groupingBy(classifier, EnumSet.allOf(enumClass), () -> new EnumMap<>(enumClass), downstream);
+    }
+
+    /**
+     * Returns a {@code Collector} implementing a cascaded "group by" operation
+     * on input elements of type {@code T}, grouping elements according to a
+     * classification function, and then performing a reduction operation on the
+     * values associated with a given key using the specified downstream
+     * {@code Collector}.
+     *
+     * <p>
+     * There are no guarantees on the type, mutability, serializability, or
+     * thread-safety of the {@code Map} returned.
+     *
+     * <p>
+     * The main difference of this collector from
+     * {@link Collectors#groupingBy(Function, Collector)} is that it accepts
+     * additional domain parameter which is the {@code Set} of all possible map
+     * keys. If the mapper function produces the key out of domain, an
+     * {@code IllegalStateException} will occur. If the mapper function does not
+     * produce some of domain keys at all, they are also added to the result.
+     * These keys are mapped to the default collector value which is equivalent
+     * to collecting an empty stream with the same collector.
+     * 
+     * <p>
+     * This method returns a
+     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting
+     * collector</a> if the downstream collector is short-circuiting. The
+     * collection might stop when for every possible key from the domain the
+     * downstream collection is known to be finished.
+     *
+     * @param <T> the type of the input elements
+     * @param <K> the type of the keys
+     * @param <A> the intermediate accumulation type of the downstream collector
+     * @param <D> the result type of the downstream reduction
+     * @param classifier a classifier function mapping input elements to keys
+     * @param domain a domain of all possible key values
+     * @param downstream a {@code Collector} implementing the downstream
+     *        reduction
+     * @return a {@code Collector} implementing the cascaded group-by operation
+     *         with given domain
+     * @throws NullPointerException if classifier is null, domain is null, or downstream is null.
+     *
+     * @see #groupingBy(Function, Set, Supplier, Collector)
+     * @see #groupingByEnum(Class, Function, Collector)
+     * @since 0.4.0
+     */
+    public static <T, K, D, A> Collector<T, ?, Map<K, D>> groupingBy(Function<? super T, ? extends K> classifier,
+            Set<K> domain, Collector<? super T, A, D> downstream) {
+        return groupingBy(classifier, domain, HashMap::new, downstream);
+    }
+
+    /**
+     * Returns a {@code Collector} implementing a cascaded "group by" operation
+     * on input elements of type {@code T}, grouping elements according to a
+     * classification function, and then performing a reduction operation on the
+     * values associated with a given key using the specified downstream
+     * {@code Collector}. The {@code Map} produced by the Collector is created
+     * with the supplied factory function.
+     *
+     * <p>
+     * The main difference of this collector from
+     * {@link Collectors#groupingBy(Function, Supplier, Collector)} is that it
+     * accepts additional domain parameter which is the {@code Set} of all
+     * possible map keys. If the mapper function produces the key out of domain,
+     * an {@code IllegalStateException} will occur. If the mapper function does
+     * not produce some of domain keys at all, they are also added to the
+     * result. These keys are mapped to the default collector value which is
+     * equivalent to collecting an empty stream with the same collector.
+     * 
+     * <p>
+     * This method returns a
+     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting
+     * collector</a> if the downstream collector is short-circuiting. The
+     * collection might stop when for every possible key from the domain the
+     * downstream collection is known to be finished.
+     *
+     * @param <T> the type of the input elements
+     * @param <K> the type of the keys
+     * @param <A> the intermediate accumulation type of the downstream collector
+     * @param <D> the result type of the downstream reduction
+     * @param <M> the type of the resulting {@code Map}
+     * @param classifier a classifier function mapping input elements to keys
+     * @param domain a domain of all possible key values
+     * @param downstream a {@code Collector} implementing the downstream
+     *        reduction
+     * @param mapFactory a function which, when called, produces a new empty
+     *        {@code Map} of the desired type
+     * @return a {@code Collector} implementing the cascaded group-by operation
+     *         with given domain
+     * @throws NullPointerException if classifier is null, domain is null, mapFactory is null, or downstream is null.
+     *
+     * @see #groupingBy(Function, Set, Collector)
+     * @see #groupingByEnum(Class, Function, Collector)
+     * @since 0.4.0
+     */
+    public static <T, K, D, A, M extends Map<K, D>> Collector<T, ?, M> groupingBy(
+            Function<? super T, ? extends K> classifier, Set<K> domain, Supplier<M> mapFactory,
+            Collector<? super T, A, D> downstream) {
+        Objects.requireNonNull(classifier);
+        Objects.requireNonNull(domain);
+        Objects.requireNonNull(mapFactory);
+        Supplier<A> downstreamSupplier = downstream.supplier();
+        Collector<T, ?, M> groupingBy;
+        Function<K, A> supplier = k -> {
+            if (!domain.contains(k))
+                throw new IllegalStateException("Classifier returned value '" + k + "' which is out of domain");
+            return downstreamSupplier.get();
+        };
+        BiConsumer<A, ? super T> downstreamAccumulator = downstream.accumulator();
+        BiConsumer<Map<K, A>, T> accumulator = (m, t) -> {
+            K key = Objects.requireNonNull(classifier.apply(t));
+            A container = m.computeIfAbsent(key, supplier);
+            downstreamAccumulator.accept(container, t);
+        };
+        PartialCollector<Map<K, A>, M> partial = PartialCollector.grouping(mapFactory, downstream);
+        Predicate<A> downstreamFinished = finished(downstream);
+        if (downstreamFinished != null) {
+            int size = domain.size();
+            groupingBy = partial.asCancellable(accumulator, map -> {
+                if (map.size() < size)
+                    return false;
+                for (A container : map.values()) {
+                    if (!downstreamFinished.test(container))
+                        return false;
+                }
+                return true;
+            });
+        } else {
+            groupingBy = partial.asRef(accumulator);
+        }
+        return collectingAndThen(groupingBy, map -> {
+            Function<A, D> finisher = downstream.finisher();
+            domain.forEach(key -> map.computeIfAbsent(key, k -> finisher.apply(downstreamSupplier.get())));
+            return map;
+        });
+    }
+
+    /**
+     * Returns a {@code Collector} which collects the intersection of the input
+     * collections into the newly-created {@link Set}.
+     *
+     * <p>
+     * The returned collector produces an empty set if the input is empty or
+     * intersection of the input collections is empty.
+     * 
+     * <p>
+     * There are no guarantees on the type, mutability, serializability, or
+     * thread-safety of the {@code Set} returned.
+     *
+     * <p>
+     * This method returns a
+     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting
+     * collector</a>: it may not process all the elements if the resulting
+     * intersection is empty.
+     * 
+     * @param <T> the type of the elements in the input collections
+     * @param <S> the type of the input collections
+     * @return a {@code Collector} which finds all the minimal elements and
+     *         collects them to the {@code List}.
+     * @since 0.4.0
+     */
+    public static <T, S extends Collection<T>> Collector<S, ?, Set<T>> intersecting() {
+        return new CancellableCollectorImpl<S, Box<Set<T>>, Set<T>>(Box::new, (b, t) -> {
+            if (b.a == null) {
+                b.a = new HashSet<>(t);
+            } else {
+                b.a.retainAll(t);
+            }
+        }, (b1, b2) -> {
+            if (b1.a == null)
+                return b2;
+            if (b2.a != null)
+                b1.a.retainAll(b2.a);
+            return b1;
+        }, b -> b.a == null ? Collections.emptySet() : b.a, b -> b.a != null && b.a.isEmpty(),
+                UNORDERED_CHARACTERISTICS);
+    }
+
+    /**
+     * Adapts a {@code Collector} to perform an additional finishing
+     * transformation.
+     * 
+     * <p>
+     * Unlike {@link Collectors#collectingAndThen(Collector, Function)} this
+     * method returns a
+     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting
+     * collector</a> if the downstream collector is short-circuiting.
+     *
+     * @param <T> the type of the input elements
+     * @param <A> intermediate accumulation type of the downstream collector
+     * @param <R> result type of the downstream collector
+     * @param <RR> result type of the resulting collector
+     * @param downstream a collector
+     * @param finisher a function to be applied to the final result of the
+     *        downstream collector
+     * @return a collector which performs the action of the downstream
+     *         collector, followed by an additional finishing step
+     * @throws NullPointerException if downstream is null, or finisher is null.
+     * @see Collectors#collectingAndThen(Collector, Function)
+     * @since 0.4.0
+     */
+    public static <T, A, R, RR> Collector<T, A, RR> collectingAndThen(Collector<T, A, R> downstream,
+            Function<R, RR> finisher) {
+        Predicate<A> finished = finished(downstream);
+        if (finished != null) {
+            return new CancellableCollectorImpl<>(downstream.supplier(), downstream.accumulator(), downstream
+                    .combiner(), downstream.finisher().andThen(finisher), finished, downstream.characteristics()
+                            .contains(Characteristics.UNORDERED) ? UNORDERED_CHARACTERISTICS : NO_CHARACTERISTICS);
+        }
+        return Collectors.collectingAndThen(downstream, finisher);
+    }
+
+    /**
+     * Returns a {@code Collector} which partitions the input elements according
+     * to a {@code Predicate}, reduces the values in each partition according to
+     * another {@code Collector}, and organizes them into a
+     * {@code Map<Boolean, D>} whose values are the result of the downstream
+     * reduction.
+     * 
+     * <p>
+     * Unlike {@link Collectors#partitioningBy(Predicate, Collector)} this
+     * method returns a
+     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting
+     * collector</a> if the downstream collector is short-circuiting.
+     * 
+     * @param <T> the type of the input elements
+     * @param <A> the intermediate accumulation type of the downstream collector
+     * @param <D> the result type of the downstream reduction
+     * @param predicate a predicate used for classifying input elements
+     * @param downstream a {@code Collector} implementing the downstream
+     *        reduction
+     * @return a {@code Collector} implementing the cascaded partitioning
+     *         operation
+     * @throws NullPointerException if predicate is null, or downstream is null.
+     * @since 0.4.0
+     * @see Collectors#partitioningBy(Predicate, Collector)
+     */
+    public static <T, D, A> Collector<T, ?, Map<Boolean, D>> partitioningBy(Predicate<? super T> predicate,
+            Collector<? super T, A, D> downstream) {
+        Objects.requireNonNull(predicate);
+        Predicate<A> finished = finished(downstream);
+        if (finished != null) {
+            BiConsumer<A, ? super T> accumulator = downstream.accumulator();
+            return BooleanMap.partialCollector(downstream).asCancellable((map, t) -> accumulator.accept(predicate.test(
+                t) ? map.trueValue : map.falseValue, t), map -> finished.test(map.trueValue) && finished.test(
+                    map.falseValue));
+        }
+        return Collectors.partitioningBy(predicate, downstream);
+    }
+
+    /**
+     * Adapts a {@code Collector} accepting elements of type {@code U} to one
+     * accepting elements of type {@code T} by applying a mapping function to
+     * each input element before accumulation.
+     *
+     * <p>
+     * Unlike {@link Collectors#mapping(Function, Collector)} this method
+     * returns a
+     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting
+     * collector</a> if the downstream collector is short-circuiting.
+     * 
+     * @param <T> the type of the input elements
+     * @param <U> type of elements accepted by downstream collector
+     * @param <A> intermediate accumulation type of the downstream collector
+     * @param <R> result type of collector
+     * @param mapper a function to be applied to the input elements
+     * @param downstream a collector which will accept mapped values
+     * @return a collector which applies the mapping function to the input
+     *         elements and provides the mapped results to the downstream
+     *         collector
+     * @throws NullPointerException if mapper is null, or downstream is null.
+     * @see Collectors#mapping(Function, Collector)
+     * @since 0.4.0
+     */
+    public static <T, U, A, R> Collector<T, ?, R> mapping(Function<? super T, ? extends U> mapper,
+            Collector<? super U, A, R> downstream) {
+        Objects.requireNonNull(mapper);
+        Predicate<A> finished = finished(downstream);
+        if (finished != null) {
+            BiConsumer<A, ? super U> downstreamAccumulator = downstream.accumulator();
+            return new CancellableCollectorImpl<>(downstream.supplier(), (acc, t) -> {
+                if (!finished.test(acc))
+                    downstreamAccumulator.accept(acc, mapper.apply(t));
+            }, downstream.combiner(), downstream.finisher(), finished, downstream.characteristics());
+        }
+        return Collectors.mapping(mapper, downstream);
+    }
+
+    /**
+     * Returns a collector which collects input elements to the new {@code List}
+     * transforming them with the supplied function beforehand.
+     * 
+     * <p>
+     * This method behaves like
+     * {@code Collectors.mapping(mapper, Collectors.toList())}.
+     * 
+     * <p>
+     * There are no guarantees on the type, mutability, serializability, or
+     * thread-safety of the {@code List} returned.
+     * 
+     * @param <T> the type of the input elements
+     * @param <U> the resulting type of the mapper function
+     * @param mapper a function to be applied to the input elements
+     * @return a collector which applies the mapping function to the input
+     *         elements and collects the mapped results to the {@code List}
+     * @throws NullPointerException if mapper is null.
+     * @see #mapping(Function, Collector)
+     * @since 0.6.0
+     */
+    public static <T, U> Collector<T, ?, List<U>> mapping(Function<? super T, ? extends U> mapper) {
+        return Collectors.mapping(mapper, Collectors.toList());
+    }
+
+    /**
+     * Adapts a {@code Collector} accepting elements of type {@code U} to one
+     * accepting elements of type {@code T} by applying a flat mapping function
+     * to each input element before accumulation. The flat mapping function maps
+     * an input element to a {@link Stream stream} covering zero or more output
+     * elements that are then accumulated downstream. Each mapped stream is
+     * {@link java.util.stream.BaseStream#close() closed} after its contents
+     * have been placed downstream. (If a mapped stream is {@code null} an empty
+     * stream is used, instead.)
+     * 
+     * <p>
+     * This method is similar to {@code Collectors.flatMapping} method which
+     * appears in JDK 9. However when downstream collector is
+     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting</a>
+     * , this method will also return a short-circuiting collector.
+     * 
+     * @param <T> the type of the input elements
+     * @param <U> type of elements accepted by downstream collector
+     * @param <A> intermediate accumulation type of the downstream collector
+     * @param <R> result type of collector
+     * @param mapper a function to be applied to the input elements, which
+     *        returns a stream of results
+     * @param downstream a collector which will receive the elements of the
+     *        stream returned by mapper
+     * @return a collector which applies the mapping function to the input
+     *         elements and provides the flat mapped results to the downstream
+     *         collector
+     * @throws NullPointerException if mapper is null, or downstream is null.
+     * @since 0.4.1
+     */
+    public static <T, U, A, R> Collector<T, ?, R> flatMapping(Function<? super T, ? extends Stream<? extends U>> mapper,
+            Collector<? super U, A, R> downstream) {
+        Objects.requireNonNull(mapper);
+        BiConsumer<A, ? super U> downstreamAccumulator = downstream.accumulator();
+        Predicate<A> finished = finished(downstream);
+        if (finished != null) {
+            return new CancellableCollectorImpl<>(downstream.supplier(), (acc, t) -> {
+                if (finished.test(acc))
+                    return;
+                try (Stream<? extends U> stream = mapper.apply(t)) {
+                    if (stream != null) {
+                        stream.spliterator().forEachRemaining(u -> {
+                            downstreamAccumulator.accept(acc, u);
+                            if (finished.test(acc))
+                                throw new CancelException();
+                        });
+                    }
+                } catch (CancelException ex) {
+                    // ignore
+                }
+            }, downstream.combiner(), downstream.finisher(), finished, downstream.characteristics());
+        }
+        return Collector.of(downstream.supplier(), (acc, t) -> {
+            try (Stream<? extends U> stream = mapper.apply(t)) {
+                if (stream != null) {
+                    stream.spliterator().forEachRemaining(u -> downstreamAccumulator.accept(acc, u));
+                }
+            }
+        }, downstream.combiner(), downstream.finisher(), downstream.characteristics().toArray(new Characteristics[0]));
+    }
+
+    /**
+     * Returns a collector which launches a flat mapping function for each input
+     * element and collects the elements of the resulting streams to the flat
+     * {@code List}. Each mapped stream is
+     * {@link java.util.stream.BaseStream#close() closed} after its contents
+     * have been placed downstream. (If a mapped stream is {@code null} an empty
+     * stream is used, instead.)
+     * 
+     * <p>
+     * This method behaves like {@code flatMapping(mapper, Collectors.toList())}
+     * .
+     * 
+     * <p>
+     * There are no guarantees on the type, mutability, serializability, or
+     * thread-safety of the {@code List} returned.
+     * 
+     * @param <T> the type of the input elements
+     * @param <U> type of the resulting elements
+     * @param mapper a function to be applied to the input elements, which
+     *        returns a stream of results
+     * @return a collector which applies the mapping function to the input
+     *         elements and collects the flat mapped results to the {@code List}
+     * @throws NullPointerException if mapper is null.
+     * @since 0.6.0
+     */
+    public static <T, U> Collector<T, ?, List<U>> flatMapping(
+            Function<? super T, ? extends Stream<? extends U>> mapper) {
+        return flatMapping(mapper, Collectors.toList());
+    }
+
+    /**
+     * Returns a {@code Collector} which passes only those elements to the
+     * specified downstream collector which match given predicate.
+     *
+     * <p>
+     * This method returns a
+     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting
+     * collector</a> if downstream collector is short-circuiting.
+     * 
+     * <p>
+     * The operation performed by the returned collector is equivalent to
+     * {@code stream.filter(predicate).collect(downstream)}. This collector is
+     * mostly useful as a downstream collector in cascaded operation involving
+     * {@link #pairing(Collector, Collector, BiFunction)} collector.
+     *
+     * <p>
+     * This method is similar to {@code Collectors.filtering} method which
+     * appears in JDK 9. However when downstream collector is
+     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting</a>
+     * , this method will also return a short-circuiting collector.
+     * 
+     * @param <T> the type of the input elements
+     * @param <A> intermediate accumulation type of the downstream collector
+     * @param <R> result type of collector
+     * @param predicate a filter function to be applied to the input elements
+     * @param downstream a collector which will accept filtered values
+     * @return a collector which applies the predicate to the input elements and
+     *         provides the elements for which predicate returned true to the
+     *         downstream collector
+     * @throws NullPointerException if predicate is null, or downstream is null.
+     * @see #pairing(Collector, Collector, BiFunction)
+     * @since 0.4.0
+     */
+    public static <T, A, R> Collector<T, ?, R> filtering(Predicate<? super T> predicate,
+            Collector<T, A, R> downstream) {
+        Objects.requireNonNull(predicate);
+        BiConsumer<A, T> downstreamAccumulator = downstream.accumulator();
+        BiConsumer<A, T> accumulator = (acc, t) -> {
+            if (predicate.test(t))
+                downstreamAccumulator.accept(acc, t);
+        };
+        Predicate<A> finished = finished(downstream);
+        if (finished != null) {
+            return new CancellableCollectorImpl<>(downstream.supplier(), accumulator, downstream.combiner(), downstream
+                    .finisher(), finished, downstream.characteristics());
+        }
+        return Collector.of(downstream.supplier(), accumulator, downstream.combiner(), downstream.finisher(), downstream
+                .characteristics().toArray(new Characteristics[0]));
+    }
+
+    /**
+     * Returns a {@code Collector} which filters input elements by the supplied
+     * predicate, collecting them to the list.
+     *
+     * <p>
+     * This method behaves like
+     * {@code filtering(predicate, Collectors.toList())}.
+     * 
+     * <p>
+     * There are no guarantees on the type, mutability, serializability, or
+     * thread-safety of the {@code List} returned.
+     * 
+     * @param <T> the type of the input elements
+     * @param predicate a filter function to be applied to the input elements
+     * @return a collector which applies the predicate to the input elements and
+     *         collects the elements for which predicate returned true to the
+     *         {@code List}
+     * @throws NullPointerException if predicate is null.
+     * @see #filtering(Predicate, Collector)
+     * @since 0.6.0
+     */
+    public static <T> Collector<T, ?, List<T>> filtering(Predicate<? super T> predicate) {
+        return filtering(predicate, Collectors.toList());
+    }
+
+    /**
+     * Returns a {@code Collector} which performs the bitwise-and operation of a
+     * integer-valued function applied to the input elements. If no elements are
+     * present, the result is empty {@link OptionalInt}.
+     *
+     * <p>
+     * This method returns a
+     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting
+     * collector</a>: it may not process all the elements if the result is zero.
+     * 
+     * @param <T> the type of the input elements
+     * @param mapper a function extracting the property to be processed
+     * @return a {@code Collector} that produces the bitwise-and operation of a
+     *         derived property
+     * @throws NullPointerException if mapper is null.
+     * @since 0.4.0
+     */
+    public static <T> Collector<T, ?, OptionalInt> andingInt(ToIntFunction<T> mapper) {
+        Objects.requireNonNull(mapper);
+        return new CancellableCollectorImpl<>(PrimitiveBox::new, (acc, t) -> {
+            if (!acc.b) {
+                acc.i = mapper.applyAsInt(t);
+                acc.b = true;
+            } else {
+                acc.i &= mapper.applyAsInt(t);
+            }
+        }, (acc1, acc2) -> {
+            if (!acc1.b)
+                return acc2;
+            if (!acc2.b)
+                return acc1;
+            acc1.i &= acc2.i;
+            return acc1;
+        }, PrimitiveBox::asInt, acc -> acc.b && acc.i == 0, UNORDERED_CHARACTERISTICS);
+    }
+
+    /**
+     * Returns a {@code Collector} which performs the bitwise-and operation of a
+     * long-valued function applied to the input elements. If no elements are
+     * present, the result is empty {@link OptionalLong}.
+     *
+     * <p>
+     * This method returns a
+     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting
+     * collector</a>: it may not process all the elements if the result is zero.
+     * 
+     * @param <T> the type of the input elements
+     * @param mapper a function extracting the property to be processed
+     * @return a {@code Collector} that produces the bitwise-and operation of a
+     *         derived property
+     * @throws NullPointerException if mapper is null.
+     * @since 0.4.0
+     */
+    public static <T> Collector<T, ?, OptionalLong> andingLong(ToLongFunction<T> mapper) {
+        Objects.requireNonNull(mapper);
+        return new CancellableCollectorImpl<>(PrimitiveBox::new, (acc, t) -> {
+            if (!acc.b) {
+                acc.l = mapper.applyAsLong(t);
+                acc.b = true;
+            } else {
+                acc.l &= mapper.applyAsLong(t);
+            }
+        }, (acc1, acc2) -> {
+            if (!acc1.b)
+                return acc2;
+            if (!acc2.b)
+                return acc1;
+            acc1.l &= acc2.l;
+            return acc1;
+        }, PrimitiveBox::asLong, acc -> acc.b && acc.l == 0, UNORDERED_CHARACTERISTICS);
+    }
+
+    /**
+     * Returns a {@code Collector} which computes a common prefix of input
+     * {@code CharSequence} objects returning the result as {@code String}. For
+     * empty input the empty {@code String} is returned.
+     *
+     * <p>
+     * The returned {@code Collector} handles specially Unicode surrogate pairs:
+     * the returned prefix may end with
+     * <a href="http://www.unicode.org/glossary/#high_surrogate_code_unit">
+     * Unicode high-surrogate code unit</a> only if it's not succeeded by
+     * <a href="http://www.unicode.org/glossary/#low_surrogate_code_unit">
+     * Unicode low-surrogate code unit</a> in any of the input sequences.
+     * Normally the ending high-surrogate code unit is removed from the prefix.
+     * 
+     * <p>
+     * This method returns a
+     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting
+     * collector</a>: it may not process all the elements if the common prefix
+     * is empty.
+     * 
+     * @return a {@code Collector} which computes a common prefix.
+     * @since 0.5.0
+     */
+    public static Collector<CharSequence, ?, String> commonPrefix() {
+        BiConsumer<ObjIntBox<CharSequence>, CharSequence> accumulator = (acc, t) -> {
+            if (acc.b == -1) {
+                acc.a = t;
+                acc.b = t.length();
+            } else if (acc.b > 0) {
+                if (t.length() < acc.b)
+                    acc.b = t.length();
+                for (int i = 0; i < acc.b; i++) {
+                    if (acc.a.charAt(i) != t.charAt(i)) {
+                        if (i > 0 && Character.isHighSurrogate(t.charAt(i - 1)) && (Character.isLowSurrogate(t.charAt(
+                            i)) || Character.isLowSurrogate(acc.a.charAt(i))))
+                            i--;
+                        acc.b = i;
+                        break;
+                    }
+                }
+            }
+        };
+        return new CancellableCollectorImpl<>(() -> new ObjIntBox<>(null, -1), accumulator, (acc1, acc2) -> {
+            if (acc1.b == -1)
+                return acc2;
+            if (acc2.b != -1)
+                accumulator.accept(acc1, acc2.a.subSequence(0, acc2.b));
+            return acc1;
+        }, acc -> acc.a == null ? "" : acc.a.subSequence(0, acc.b).toString(), acc -> acc.b == 0,
+                UNORDERED_CHARACTERISTICS);
+    }
+
+    /**
+     * Returns a {@code Collector} which computes a common suffix of input
+     * {@code CharSequence} objects returning the result as {@code String}. For
+     * empty input the empty {@code String} is returned.
+     *
+     * <p>
+     * The returned {@code Collector} handles specially Unicode surrogate pairs:
+     * the returned suffix may start with
+     * <a href="http://www.unicode.org/glossary/#low_surrogate_code_unit">
+     * Unicode low-surrogate code unit</a> only if it's not preceded by
+     * <a href="http://www.unicode.org/glossary/#high_surrogate_code_unit">
+     * Unicode high-surrogate code unit</a> in any of the input sequences.
+     * Normally the starting low-surrogate code unit is removed from the suffix.
+     * 
+     * <p>
+     * This method returns a
+     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting
+     * collector</a>: it may not process all the elements if the common suffix
+     * is empty.
+     * 
+     * @return a {@code Collector} which computes a common suffix.
+     * @since 0.5.0
+     */
+    public static Collector<CharSequence, ?, String> commonSuffix() {
+        BiConsumer<ObjIntBox<CharSequence>, CharSequence> accumulator = (acc, t) -> {
+            if (acc.b == -1) {
+                acc.a = t;
+                acc.b = t.length();
+            } else if (acc.b > 0) {
+                int aLen = acc.a.length();
+                int bLen = t.length();
+                if (bLen < acc.b)
+                    acc.b = bLen;
+                for (int i = 0; i < acc.b; i++) {
+                    if (acc.a.charAt(aLen - 1 - i) != t.charAt(bLen - 1 - i)) {
+                        if (i > 0 && Character.isLowSurrogate(t.charAt(bLen - i)) && (Character.isHighSurrogate(t
+                                .charAt(bLen - 1 - i)) || Character.isHighSurrogate(acc.a.charAt(aLen - 1 - i))))
+                            i--;
+                        acc.b = i;
+                        break;
+                    }
+                }
+            }
+        };
+        return new CancellableCollectorImpl<>(() -> new ObjIntBox<>(null, -1), accumulator, (acc1, acc2) -> {
+            if (acc1.b == -1)
+                return acc2;
+            if (acc2.b != -1)
+                accumulator.accept(acc1, acc2.a.subSequence(acc2.a.length() - acc2.b, acc2.a.length()));
+            return acc1;
+        }, acc -> acc.a == null ? "" : acc.a.subSequence(acc.a.length() - acc.b, acc.a.length()).toString(),
+                acc -> acc.b == 0, UNORDERED_CHARACTERISTICS);
+    }
+
+    /**
+     * Returns a collector which collects input elements into {@code List}
+     * removing the elements following their dominator element. The dominator
+     * elements are defined according to given isDominator {@code BiPredicate}.
+     * The isDominator relation must be transitive (if A dominates over B and B
+     * dominates over C, then A also dominates over C).
+     * 
+     * <p>
+     * This operation is similar to
+     * {@code streamEx.collapse(isDominator).toList()}. The important difference
+     * is that in this method {@code BiPredicate} accepts not the adjacent
+     * stream elements, but the leftmost element of the series (current
+     * dominator) and the current element.
+     * 
+     * <p>
+     * For example, consider the stream of numbers:
+     * 
+     * <pre>{@code
+     * StreamEx<Integer> stream = StreamEx.of(1, 5, 3, 4, 2, 7);
+     * }</pre>
+     * 
+     * <p>
+     * Using {@code stream.collapse((a, b) -> a >= b).toList()} you will get the
+     * numbers which are bigger than their immediate predecessor (
+     * {@code [1, 5, 4, 7]}), because (3, 4) pair is not collapsed. However
+     * using {@code stream.collect(dominators((a, b) -> a >= b))} you will get
+     * the numbers which are bigger than any predecessor ({@code [1, 5, 7]}) as
+     * 5 is the dominator element for the subsequent 3, 4 and 2.
+     * 
+     * @param <T> type of the input elements.
+     * @param isDominator a non-interfering, stateless, transitive
+     *        {@code BiPredicate} which returns true if the first argument is
+     *        the dominator for the second argument.
+     * @return a collector which collects input element into {@code List}
+     *         leaving only dominator elements.
+     * @throws NullPointerException if isDominator is null.
+     * @see StreamEx#collapse(BiPredicate)
+     * @since 0.5.1
+     */
+    public static <T> Collector<T, ?, List<T>> dominators(BiPredicate<? super T, ? super T> isDominator) {
+        Objects.requireNonNull(isDominator);
+        return Collector.of(ArrayList::new, (acc, t) -> {
+            if (acc.isEmpty() || !isDominator.test(acc.get(acc.size() - 1), t))
+                acc.add(t);
+        }, (acc1, acc2) -> {
+            if (acc1.isEmpty())
+                return acc2;
+            int i = 0, l = acc2.size();
+            T last = acc1.get(acc1.size() - 1);
+            while (i < l && isDominator.test(last, acc2.get(i)))
+                i++;
+            if (i < l)
+                acc1.addAll(acc2.subList(i, l));
+            return acc1;
+        });
+    }
+
+    /**
+     * Returns a {@code Collector} which performs downstream reduction if all
+     * elements satisfy the {@code Predicate}. The result is described as an
+     * {@code Optional<R>}.
+     * 
+     * <p>
+     * The resulting collector returns an empty optional if at least one input
+     * element does not satisfy the predicate. Otherwise it returns an optional
+     * which contains the result of the downstream collector.
+     * 
+     * <p>
+     * This method returns a
+     * <a href="package-summary.html#ShortCircuitReduction">short-circuiting
+     * collector</a>: it may not process all the elements if some of items don't
+     * satisfy the predicate or if downstream collector is a short-circuiting
+     * collector.
+     * 
+     * <p>
+     * It's guaranteed that the downstream collector is not called for elements
+     * which don't satisfy the predicate.
+     *
+     * @param <T> the type of input elements
+     * @param <A> intermediate accumulation type of the downstream collector
+     * @param <R> result type of the downstream collector
+     * @param predicate a non-interfering, stateless predicate to checks whether
+     *        collector should proceed with element
+     * @param downstream a {@code Collector} implementing the downstream
+     *        reduction
+     * @return a {@code Collector} witch performs downstream reduction if all
+     *         elements satisfy the predicate
+     * @throws NullPointerException if mapper is null.
+     * @see Stream#allMatch(Predicate)
+     * @see AbstractStreamEx#dropWhile(Predicate)
+     * @see AbstractStreamEx#takeWhile(Predicate)
+     * @since 0.6.3
+     */
+    public static <T, A, R> Collector<T, ?, Optional<R>> ifAllMatch(Predicate<T> predicate,
+            Collector<T, A, R> downstream) {
+        Objects.requireNonNull(predicate);
+        Predicate<A> finished = finished(downstream);
+        Supplier<A> supplier = downstream.supplier();
+        BiConsumer<A, T> accumulator = downstream.accumulator();
+        BinaryOperator<A> combiner = downstream.combiner();
+        return new CancellableCollectorImpl<>(
+                () -> new PairBox<>(supplier.get(), Boolean.TRUE),
+                (acc, t) -> {
+                    if (acc.b && predicate.test(t)) {
+                        accumulator.accept(acc.a, t);
+                    } else {
+                        acc.b = Boolean.FALSE;
+                    }
+                },
+                (acc1, acc2) -> {
+                    if (acc1.b && acc2.b) {
+                        acc1.a = combiner.apply(acc1.a, acc2.a);
+                    } else {
+                        acc1.b = Boolean.FALSE;
+                    }
+                    return acc1;
+                },
+                acc -> acc.b ? Optional.of(downstream.finisher().apply(acc.a)) : Optional.empty(),
+                finished == null ? acc -> !acc.b : acc -> !acc.b || finished.test(acc.a),
+                downstream.characteristics().contains(Characteristics.UNORDERED) ? UNORDERED_CHARACTERISTICS
+                        : NO_CHARACTERISTICS);
+    }
+    
+    public static <T> Collector<T, ?, Optional<T>> reducingWithZero(T zero, BinaryOperator<T> accumulator) {
+        // acc.b: 0 = no element, 1 = has element, 2 = zero reached
+        return new CancellableCollectorImpl<>(
+            () -> new ObjIntBox<T>(null, 0),
+            (acc, t) -> {
+                if (acc.b != 2) {
+                    if (acc.b == 1) {
+                        t = accumulator.apply(t, acc.a);
+                    }
+                    if (Objects.equals(t, zero)) {
+                        acc.b = 2;
+                        acc.a = zero;
+                    } else {
+                        acc.b = 1;
+                        acc.a = t;
+                    }
+                }
+            },
+            (acc1, acc2) -> {
+                if (acc1.b == 0 || acc2.b == 2) return acc2;
+                if (acc2.b == 0 || acc1.b == 2) return acc1;
+                T t = accumulator.apply(acc1.a, acc2.a);
+                if (Objects.equals(t, zero)) {
+                    acc1.b = 2;
+                    acc1.a = zero;
+                } else {
+                    acc1.a = t;
+                }
+                return acc1;
+            },
+            acc -> acc.b == 0 ? Optional.empty() : Optional.of(acc.a),
+            acc -> acc.b == 2,
+            UNORDERED_CHARACTERISTICS
+        );
+    }
+    
+    public static <T> Collector<T, ?, T> reducingWithZero(T zero, T identity, BinaryOperator<T> accumulator) {
+        // acc.b: 1 = has element, 2 = zero reached
+        return new CancellableCollectorImpl<>(
+            () -> new ObjIntBox<>(identity, 1),
+            (acc, t) -> {
+                if (acc.b != 2) {
+                    t = accumulator.apply(t, acc.a);
+                    if (Objects.equals(t, zero)) {
+                        acc.b = 2;
+                        acc.a = zero;
+                    } else {
+                        acc.b = 1;
+                        acc.a = t;
+                    }
+                }
+            },
+            (acc1, acc2) -> {
+                if (acc2.b == 2) return acc2;
+                if (acc1.b == 2) return acc1;
+                T t = accumulator.apply(acc1.a, acc2.a);
+                if (Objects.equals(t, zero)) {
+                    acc1.b = 2;
+                    acc1.a = zero;
+                } else {
+                    acc1.a = t;
+                }
+                return acc1;
+            },
+            acc -> acc.a,
+            acc -> acc.b == 2,
+            UNORDERED_CHARACTERISTICS
+        );
+    }
+}
diff --git a/src/test/java/one/util/streamex/MoreCollectorsTest.java b/src/test/java/one/util/streamex/MoreCollectorsTest.java
index 85bcefc..aba8572 100644
--- a/src/test/java/one/util/streamex/MoreCollectorsTest.java
+++ b/src/test/java/one/util/streamex/MoreCollectorsTest.java
@@ -1,808 +1,863 @@
-/*
- * Copyright 2015, 2019 StreamEx contributors
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package one.util.streamex;
-
-import one.util.streamex.Internals.BooleanMap;
-import org.junit.FixMethodOrder;
-import org.junit.Test;
-import org.junit.runners.MethodSorters;
-
-import java.lang.reflect.Constructor;
-import java.lang.reflect.InvocationTargetException;
-import java.util.*;
-import java.util.AbstractMap.SimpleEntry;
-import java.util.Map.Entry;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicInteger;
-import java.util.function.Function;
-import java.util.function.Supplier;
-import java.util.stream.*;
-import java.util.stream.Collector.Characteristics;
-
-import static java.util.Arrays.asList;
-import static one.util.streamex.TestHelpers.*;
-import static org.junit.Assert.*;
-
-/**
- * @author Tagir Valeev
- */
-@FixMethodOrder(MethodSorters.NAME_ASCENDING)
-public class MoreCollectorsTest {
-    static class MyNumber implements Comparable<MyNumber> {
-        final int value;
-        
-        MyNumber(int value) {
-            this.value = value;
-        }
-
-        @Override
-        public int hashCode() {
-            return value;
-        }
-
-        @Override
-        public boolean equals(Object obj) {
-            return obj instanceof MyNumber && ((MyNumber)obj).value == value;
-        }
-
-        @Override
-        public int compareTo(MyNumber o) {
-            return Integer.compare(value, o.value);
-        }
-    }
-
-    @Test(expected = UnsupportedOperationException.class)
-    public void testInstantiate() throws Throwable {
-        Constructor<MoreCollectors> constructor = MoreCollectors.class.getDeclaredConstructor();
-        constructor.setAccessible(true);
-        try {
-            constructor.newInstance();
-        } catch (InvocationTargetException e) {
-            throw e.getCause();
-        }
-    }
-
-    @Test
-    public void testToArray() {
-        List<String> input = asList("a", "bb", "c", "", "cc", "eee", "bb", "ddd");
-        streamEx(input::stream, supplier -> {
-            Map<Integer, String[]> result = supplier.get().groupingBy(String::length, HashMap::new,
-                MoreCollectors.toArray(String[]::new));
-            assertArrayEquals(new String[] { "" }, result.get(0));
-            assertArrayEquals(new String[] { "a", "c" }, result.get(1));
-            assertArrayEquals(new String[] { "bb", "cc", "bb" }, result.get(2));
-            assertArrayEquals(new String[] { "eee", "ddd" }, result.get(3));
-        });
-    }
-
-    @Test
-    public void testEmpty() {
-        List<Integer> list = Stream.of(1, 2, 3).collect(MoreCollectors.head(0));
-        assertTrue(list.isEmpty());
-    }
-
-    @Test
-    public void testDistinctCount() {
-        List<String> input = asList("a", "bb", "c", "cc", "eee", "bb", "bc", "ddd");
-        streamEx(input::stream, supplier -> {
-            Map<String, Integer> result = supplier.get().groupingBy(s -> s.substring(0, 1), HashMap::new,
-                MoreCollectors.distinctCount(String::length));
-            assertEquals(1, (int) result.get("a"));
-            assertEquals(1, (int) result.get("b"));
-            assertEquals(2, (int) result.get("c"));
-            assertEquals(1, (int) result.get("d"));
-            assertEquals(1, (int) result.get("e"));
-        });
-    }
-
-    @Test
-    public void testDistinctBy() {
-        List<String> input = asList("a", "bb", "c", "cc", "eee", "bb", "bc", "ddd", "ca", "ce", "cf", "ded", "dump");
-        streamEx(input::stream, supplier -> {
-            Map<String, List<String>> result = supplier.get().groupingBy(s -> s.substring(0, 1), HashMap::new,
-                MoreCollectors.distinctBy(String::length));
-            assertEquals(asList("a"), result.get("a"));
-            assertEquals(asList("bb"), result.get("b"));
-            assertEquals(asList("c", "cc"), result.get("c"));
-            assertEquals(asList("ddd", "dump"), result.get("d"));
-            assertEquals(asList("eee"), result.get("e"));
-        });
-    }
-
-    @Test
-    public void testMaxAll() {
-        List<String> input = asList("a", "bb", "c", "", "cc", "eee", "bb", "ddd");
-        checkCollector("maxAll", asList("eee", "ddd"), input::stream, MoreCollectors.maxAll(Comparator
-                .comparingInt(String::length)));
-        Collector<String, ?, String> maxAllJoin = MoreCollectors.maxAll(Comparator.comparingInt(String::length),
-            Collectors.joining(","));
-        checkCollector("maxAllJoin", "eee,ddd", input::stream, maxAllJoin);
-        checkCollector("minAll", 1L, input::stream, MoreCollectors.minAll(Comparator.comparingInt(String::length),
-            Collectors.counting()));
-        checkCollector("minAllEmpty", asList(""), input::stream, MoreCollectors.minAll(Comparator
-                .comparingInt(String::length)));
-        checkCollectorEmpty("maxAll", Collections.emptyList(), MoreCollectors.maxAll(Comparator
-                .comparingInt(String::length)));
-        checkCollectorEmpty("maxAllJoin", "", maxAllJoin);
-
-        withRandom(r -> {
-            List<Integer> ints = IntStreamEx.of(r, 10000, 1, 1000).boxed().toList();
-            List<Integer> expectedMax = getMaxAll(ints, Comparator.naturalOrder());
-            List<Integer> expectedMin = getMaxAll(ints, Comparator.reverseOrder());
-            Collector<Integer, ?, SimpleEntry<Integer, Long>> downstream = MoreCollectors.pairing(MoreCollectors.first(),
-                Collectors.counting(), (opt, cnt) -> new AbstractMap.SimpleEntry<>(opt.get(), cnt));
-
-            checkCollector("maxAll", expectedMax, ints::stream, MoreCollectors.maxAll(Integer::compare));
-            checkCollector("minAll", expectedMin, ints::stream, MoreCollectors.minAll());
-            checkCollector("entry", new SimpleEntry<>(expectedMax.get(0), (long) expectedMax.size()), ints::stream,
-                MoreCollectors.maxAll(downstream));
-            checkCollector("entry", new SimpleEntry<>(expectedMin.get(0), (long) expectedMin.size()), ints::stream,
-                MoreCollectors.minAll(downstream));
-        });
-        
-        MyNumber a = new MyNumber(1), b = new MyNumber(1), c = new MyNumber(1000), d = new MyNumber(1000);
-        List<MyNumber> nums = IntStreamEx.range(10, 100).mapToObj(MyNumber::new).append(a, c).prepend(b, d).toList();
-        streamEx(nums::stream, supplier -> {
-            List<MyNumber> list = supplier.get().collect(MoreCollectors.maxAll());
-            assertEquals(2, list.size());
-            assertSame(d, list.get(0));
-            assertSame(c, list.get(1));
-
-            list = supplier.get().collect(MoreCollectors.minAll());
-            assertEquals(2, list.size());
-            assertSame(b, list.get(0));
-            assertSame(a, list.get(1));
-        });
-    }
-
-    private static List<Integer> getMaxAll(List<Integer> ints, Comparator<Integer> c) {
-        List<Integer> expectedMax = null;
-        for (Integer i : ints) {
-            if (expectedMax == null || c.compare(i, expectedMax.get(0)) > 0) {
-                expectedMax = new ArrayList<>();
-                expectedMax.add(i);
-            } else if (i.equals(expectedMax.get(0))) {
-                expectedMax.add(i);
-            }
-        }
-        return expectedMax;
-    }
-
-    @Test
-    public void testFirstLast() {
-        Supplier<Stream<Integer>> s = () -> IntStreamEx.range(1000).boxed();
-        checkShortCircuitCollector("first", Optional.of(0), 1, s, MoreCollectors.first());
-        checkShortCircuitCollector("firstLong", Optional.of(0), 1, () -> Stream.of(1).flatMap(
-            x -> IntStream.range(0, 1000000000).boxed()), MoreCollectors.first(), true);
-        checkShortCircuitCollector("first", Optional.of(1), 1, () -> Stream.iterate(1, x -> x + 1), MoreCollectors
-                .first(), true);
-        assertEquals(1, (int) StreamEx.iterate(1, x -> x + 1).parallel().collect(MoreCollectors.first()).get());
-
-        checkCollector("last", Optional.of(999), s, MoreCollectors.last());
-        checkCollectorEmpty("first", Optional.empty(), MoreCollectors.first());
-        checkCollectorEmpty("last", Optional.empty(), MoreCollectors.last());
-    }
-
-    @Test
-    public void testHeadParallel() {
-        List<Integer> expected = IntStreamEx.range(0, 2000, 2).boxed().toList();
-        List<Integer> expectedShort = asList(0, 1);
-        for (int i = 0; i < 1000; i++) {
-            assertEquals("#" + i, expectedShort, IntStreamEx.range(1000).boxed().parallel().collect(
-                MoreCollectors.head(2)));
-            assertEquals("#" + i, expected, IntStreamEx.range(10000).boxed().parallel().filter(x -> x % 2 == 0)
-                    .collect(MoreCollectors.head(1000)));
-        }
-        assertEquals(expectedShort, StreamEx.iterate(0, x -> x + 1).parallel().collect(MoreCollectors.head(2)));
-    }
-
-    @Test
-    public void testHeadTail() {
-        List<Integer> ints = IntStreamEx.range(1000).boxed().toList();
-        checkShortCircuitCollector("tail(0)", asList(), 0, ints::stream, MoreCollectors.tail(0));
-        checkCollector("tail(1)", asList(999), ints::stream, MoreCollectors.tail(1));
-        checkCollector("tail(2)", asList(998, 999), ints::stream, MoreCollectors.tail(2));
-        checkCollector("tail(500)", ints.subList(500, 1000), ints::stream, MoreCollectors.tail(500));
-        checkCollector("tail(999)", ints.subList(1, 1000), ints::stream, MoreCollectors.tail(999));
-        checkCollector("tail(1000)", ints, ints::stream, MoreCollectors.tail(1000));
-        checkCollector("tail(MAX)", ints, ints::stream, MoreCollectors.tail(Integer.MAX_VALUE));
-
-        checkShortCircuitCollector("head(0)", asList(), 0, ints::stream, MoreCollectors.head(0));
-        checkShortCircuitCollector("head(1)", asList(0), 1, ints::stream, MoreCollectors.head(1));
-        checkShortCircuitCollector("head(2)", asList(0, 1), 2, ints::stream, MoreCollectors.head(2));
-        checkShortCircuitCollector("head(500)", ints.subList(0, 500), 500, ints::stream, MoreCollectors.head(500));
-        checkShortCircuitCollector("head(999)", ints.subList(0, 999), 999, ints::stream, MoreCollectors.head(999));
-        checkShortCircuitCollector("head(1000)", ints, 1000, ints::stream, MoreCollectors.head(1000));
-        checkShortCircuitCollector("head(MAX)", ints, 1000, ints::stream, MoreCollectors.head(Integer.MAX_VALUE));
-
-        checkShortCircuitCollector("head(10000)", IntStreamEx.rangeClosed(1, 10000).boxed().toList(), 10000,
-            () -> Stream.iterate(1, x -> x + 1), MoreCollectors.head(10000), true);
-
-        for (int size : new int[] { 1, 10, 20, 40, 60, 80, 90, 98, 99, 100 }) {
-            checkShortCircuitCollector("head-unordered-" + size, Collections.nCopies(size, "test"), size,
-                () -> StreamEx.constant("test", 100), MoreCollectors.head(size));
-        }
-    }
-
-    @Test
-    public void testGreatest() {
-        withRandom(r -> {
-            List<Integer> ints = IntStreamEx.of(r, 1000, 1, 1000).boxed().toList();
-            List<Integer> sorted = StreamEx.of(ints).sorted().toList();
-            List<Integer> revSorted = StreamEx.of(ints).reverseSorted().toList();
-            Comparator<Integer> byString = Comparator.comparing(String::valueOf);
-            checkShortCircuitCollector("least(0)", Collections.emptyList(), 0, ints::stream, MoreCollectors.least(0));
-            checkCollector("least(5)", sorted.subList(0, 5), ints::stream, MoreCollectors.least(5));
-            checkCollector("least(20)", sorted.subList(0, 20), ints::stream, MoreCollectors.least(20));
-            checkCollector("least(MAX)", sorted, ints::stream, MoreCollectors.least(Integer.MAX_VALUE));
-            checkCollector("least(byString, 20)", StreamEx.of(ints).sorted(byString).limit(20).toList(), ints::stream,
-                MoreCollectors.least(byString, 20));
-
-            checkShortCircuitCollector("greatest(0)", Collections.emptyList(), 0, ints::stream, MoreCollectors.greatest(0));
-            checkCollector("greatest(5)", revSorted.subList(0, 5), ints::stream, MoreCollectors.greatest(5));
-            checkCollector("greatest(20)", revSorted.subList(0, 20), ints::stream, MoreCollectors.greatest(20));
-            checkCollector("greatest(MAX)", revSorted, ints::stream, MoreCollectors.greatest(Integer.MAX_VALUE));
-            checkCollector("greatest(byString, 20)", StreamEx.of(ints).reverseSorted(byString).limit(20).toList(),
-                ints::stream, MoreCollectors.greatest(byString, 20));
-            checkCollector("greatest(byString, 30)", StreamEx.of(ints).reverseSorted(byString).limit(30).toList(),
-                ints::stream, MoreCollectors.greatest(byString, 30));
-        });
-
-        Supplier<Stream<Integer>> s = () -> IntStreamEx.range(100).boxed();
-        checkCollector("1", IntStreamEx.range(1).boxed().toList(), s, MoreCollectors.least(1));
-        checkCollector("2", IntStreamEx.range(2).boxed().toList(), s, MoreCollectors.least(2));
-        checkCollector("10", IntStreamEx.range(10).boxed().toList(), s, MoreCollectors.least(10));
-        checkCollector("100", IntStreamEx.range(100).boxed().toList(), s, MoreCollectors.least(100));
-        checkCollector("200", IntStreamEx.range(100).boxed().toList(), s, MoreCollectors.least(200));
-    }
-
-    @Test
-    public void testCountingInt() {
-        checkCollector("counting", 1000, () -> IntStreamEx.range(1000).boxed(), MoreCollectors.countingInt());
-        checkCollectorEmpty("counting", 0, MoreCollectors.countingInt());
-    }
-
-    @Test
-    public void testMinIndex() {
-        withRandom(r -> {
-            List<Integer> ints = IntStreamEx.of(r, 1000, 5, 47).boxed().toList();
-            long expectedMin = IntStreamEx.ofIndices(ints).minBy(ints::get).getAsInt();
-            long expectedMax = IntStreamEx.ofIndices(ints).maxBy(ints::get).getAsInt();
-            long expectedMinString = IntStreamEx.ofIndices(ints).minBy(i -> String.valueOf(ints.get(i))).getAsInt();
-            long expectedMaxString = IntStreamEx.ofIndices(ints).maxBy(i -> String.valueOf(ints.get(i))).getAsInt();
-            Comparator<Integer> cmp = Comparator.comparing(String::valueOf);
-            checkCollector("minIndex", OptionalLong.of(expectedMin), ints::stream, MoreCollectors.minIndex());
-            checkCollector("maxIndex", OptionalLong.of(expectedMax), ints::stream, MoreCollectors.maxIndex());
-            checkCollector("minIndex", OptionalLong.of(expectedMinString), ints::stream, MoreCollectors.minIndex(cmp));
-            checkCollector("maxIndex", OptionalLong.of(expectedMaxString), ints::stream, MoreCollectors.maxIndex(cmp));
-            Supplier<Stream<String>> supplier = () -> ints.stream().map(Object::toString);
-            checkCollector("minIndex", OptionalLong.of(expectedMinString), supplier, MoreCollectors.minIndex());
-            checkCollector("maxIndex", OptionalLong.of(expectedMaxString), supplier, MoreCollectors.maxIndex());
-            checkCollectorEmpty("minIndex", OptionalLong.empty(), MoreCollectors.<String> minIndex());
-            checkCollectorEmpty("maxIndex", OptionalLong.empty(), MoreCollectors.<String> maxIndex());
-        });
-    }
-
-    @Test
-    public void testGroupingByEnum() {
-        EnumMap<TimeUnit, Long> expected = new EnumMap<>(TimeUnit.class);
-        EnumSet.allOf(TimeUnit.class).forEach(tu -> expected.put(tu, 0L));
-        expected.put(TimeUnit.SECONDS, 1L);
-        expected.put(TimeUnit.DAYS, 2L);
-        expected.put(TimeUnit.NANOSECONDS, 1L);
-        checkCollector("groupingByEnum", expected, () -> Stream.of(TimeUnit.SECONDS, TimeUnit.DAYS, TimeUnit.DAYS,
-            TimeUnit.NANOSECONDS), MoreCollectors.groupingByEnum(TimeUnit.class, Function.identity(), Collectors
-                .counting()));
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void testGroupingByWithDomainException() {
-        List<Integer> list = asList(1, 2, 20, 3, 31, 4);
-        Collector<Integer, ?, Map<Integer, List<Integer>>> c = MoreCollectors.groupingBy(i -> i % 10, StreamEx.of(0, 1,
-            2, 3).toSet(), Collectors.toList());
-        Map<Integer, List<Integer>> map = list.stream().collect(c);
-        System.out.println(map);
-    }
-
-    @Test
-    public void testGroupingByWithDomain() {
-        List<String> data = asList("a", "foo", "test", "ququq", "bar", "blahblah");
-        Collector<String, ?, String> collector = MoreCollectors.collectingAndThen(MoreCollectors.groupingBy(
-            String::length, IntStreamEx.range(10).boxed().toSet(), TreeMap::new, MoreCollectors.first()),
-            Object::toString);
-        checkShortCircuitCollector("groupingWithDomain",
-            "{0=Optional.empty, 1=Optional[a], 2=Optional.empty, 3=Optional[foo], 4=Optional[test], 5=Optional[ququq], "
-                + "6=Optional.empty, 7=Optional.empty, 8=Optional[blahblah], 9=Optional.empty}", data.size(),
-            data::stream, collector);
-
-        Map<String, String> name2sex = new LinkedHashMap<>();
-        name2sex.put("Mary", "Girl");
-        name2sex.put("John", "Boy");
-        name2sex.put("James", "Boy");
-        name2sex.put("Lucie", "Girl");
-        name2sex.put("Fred", "Boy");
-        name2sex.put("Thomas", "Boy");
-        name2sex.put("Jane", "Girl");
-        name2sex.put("Ruth", "Girl");
-        name2sex.put("Melanie", "Girl");
-        Collector<Entry<String, String>, ?, Map<String, List<String>>> groupingBy = MoreCollectors.groupingBy(
-            Entry::getValue, StreamEx.of("Girl", "Boy").toSet(), MoreCollectors.mapping(Entry::getKey, MoreCollectors
-                    .head(2)));
-        AtomicInteger counter = new AtomicInteger();
-        Map<String, List<String>> map = EntryStream.of(name2sex).peek(c -> counter.incrementAndGet()).collect(
-            groupingBy);
-        assertEquals(asList("Mary", "Lucie"), map.get("Girl"));
-        assertEquals(asList("John", "James"), map.get("Boy"));
-        assertEquals(4, counter.get());
-
-        Collector<Entry<String, String>, ?, Map<String, String>> groupingByJoin = MoreCollectors.groupingBy(
-            Entry::getValue, StreamEx.of("Girl", "Boy").toSet(), MoreCollectors.mapping(Entry::getKey, Joining.with(
-                ", ").maxChars(16).cutAfterDelimiter()));
-        counter.set(0);
-        Map<String, String> mapJoin = EntryStream.of(name2sex).peek(c -> counter.incrementAndGet()).collect(
-            groupingByJoin);
-        assertEquals("Mary, Lucie, ...", mapJoin.get("Girl"));
-        assertEquals("John, James, ...", mapJoin.get("Boy"));
-        assertEquals(7, counter.get());
-    }
-
-    @Test
-    public void testToBooleanArray() {
-        withRandom(r -> {
-            List<Integer> input = IntStreamEx.of(r, 1000, 1, 100).boxed().toList();
-            boolean[] expected = new boolean[input.size()];
-            for (int i = 0; i < expected.length; i++)
-                expected[i] = input.get(i) > 50;
-            streamEx(input::stream, supplier -> assertArrayEquals(expected, supplier.get().collect(
-                MoreCollectors.toBooleanArray(x -> x > 50))));
-        });
-    }
-
-    @Test
-    public void testPartitioningBy() {
-        Collector<Integer, ?, Map<Boolean, Optional<Integer>>> by20 = MoreCollectors.partitioningBy(x -> x % 20 == 0,
-            MoreCollectors.first());
-        Collector<Integer, ?, Map<Boolean, Optional<Integer>>> by200 = MoreCollectors.partitioningBy(x -> x % 200 == 0,
-            MoreCollectors.first());
-        Supplier<Stream<Integer>> supplier = () -> IntStreamEx.range(1, 100).boxed();
-        checkShortCircuitCollector("by20", new BooleanMap<>(Optional.of(20), Optional.of(1)), 20, supplier, by20);
-        checkShortCircuitCollector("by200", new BooleanMap<>(Optional.empty(), Optional.of(1)), 99, supplier, by200);
-    }
-
-    @Test
-    public void testMapping() {
-        List<String> input = asList("Capital", "lower", "Foo", "bar");
-        Collector<String, ?, Map<Boolean, Optional<Integer>>> collector = MoreCollectors
-                .partitioningBy(str -> Character.isUpperCase(str.charAt(0)), MoreCollectors.mapping(String::length,
-                    MoreCollectors.first()));
-        checkShortCircuitCollector("mapping", new BooleanMap<>(Optional.of(7), Optional.of(5)), 2, input::stream,
-            collector);
-        Collector<String, ?, Map<Boolean, Optional<Integer>>> collectorLast = MoreCollectors.partitioningBy(
-            str -> Character.isUpperCase(str.charAt(0)), MoreCollectors.mapping(String::length, MoreCollectors.last()));
-        checkCollector("last", new BooleanMap<>(Optional.of(3), Optional.of(3)), input::stream, collectorLast);
-
-        input = asList("Abc", "Bac", "Aac", "Abv", "Bbc", "Bgd", "Atc", "Bpv");
-        Map<Character, List<String>> expected = EntryStream.of('A', asList("Abc", "Aac"), 'B', asList("Bac", "Bbc"))
-                .toMap();
-        AtomicInteger cnt = new AtomicInteger();
-        Collector<String, ?, Map<Character, List<String>>> groupMap = Collectors.groupingBy(s -> s.charAt(0),
-            MoreCollectors.mapping(x -> {
-                cnt.incrementAndGet();
-                return x;
-            }, MoreCollectors.head(2)));
-        checkCollector("groupMap", expected, input::stream, groupMap);
-        cnt.set(0);
-        assertEquals(expected, input.stream().collect(groupMap));
-        assertEquals(4, cnt.get());
-
-        checkCollector("mapping-toList", asList("a", "b", "c"), asList("a1", "b2", "c3")::stream, MoreCollectors
-                .mapping(str -> str.substring(0, 1)));
-    }
-
-    @Test
-    public void testIntersecting() {
-        for (int i = 0; i < 5; i++) {
-            List<List<String>> input = asList(asList("aa", "bb", "cc"), asList("cc", "bb", "dd"), asList("ee", "dd"),
-                asList("aa", "bb", "dd"));
-            checkShortCircuitCollector("#" + i, Collections.emptySet(), 3, input::stream, MoreCollectors.intersecting());
-            List<List<Integer>> copies = new ArrayList<>(Collections.nCopies(100, asList(1, 2)));
-            checkShortCircuitCollector("#" + i, StreamEx.of(1, 2).toSet(), 100, copies::stream, MoreCollectors
-                    .intersecting());
-            copies.addAll(Collections.nCopies(100, asList(3)));
-            checkShortCircuitCollector("#" + i, Collections.emptySet(), 101, copies::stream, MoreCollectors
-                    .intersecting());
-            checkCollectorEmpty("#" + i, Collections.emptySet(), MoreCollectors.intersecting());
-        }
-    }
-
-    @Test
-    public void testAndInt() {
-        List<Integer> ints = asList(0b1100, 0b0110, 0b101110, 0b11110011);
-        Collector<Integer, ?, OptionalInt> collector = MoreCollectors.andingInt(Integer::intValue);
-        checkShortCircuitCollector("andInt", OptionalInt.of(0), 4, ints::stream, collector);
-        checkCollectorEmpty("andIntEmpty", OptionalInt.empty(), collector);
-        assertEquals(OptionalInt.of(0), IntStreamEx.iterate(16384, i -> i + 1).parallel().boxed().collect(collector));
-        assertEquals(OptionalInt.of(16384), IntStreamEx.iterate(16384, i -> i + 1).parallel().limit(16383).boxed()
-                .collect(collector));
-        Collector<Integer, ?, Integer> unwrapped = MoreCollectors.collectingAndThen(MoreCollectors
-                .andingInt(Integer::intValue), OptionalInt::getAsInt);
-        assertTrue(unwrapped.characteristics().contains(Characteristics.UNORDERED));
-        checkShortCircuitCollector("andIntUnwrapped", 0, 4, ints::stream, unwrapped);
-        checkShortCircuitCollector("andIntUnwrapped", 0, 2, asList(0x1, 0x10, 0x100)::stream, unwrapped);
-    }
-
-    @Test
-    public void testAndLong() {
-        List<Long> longs = asList(0xFFFFFFFFFFFFFFFFL, 0xFFFFFFFF00000000L, 0xFFFFFFFF0000L);
-        checkShortCircuitCollector("andLong", OptionalLong.of(0xFFFF00000000L), 3, longs::stream, MoreCollectors
-                .andingLong(Long::longValue));
-        longs = asList(1L, 2L, 3L, 4L);
-        checkShortCircuitCollector("andLong", OptionalLong.of(0), 2, longs::stream, MoreCollectors
-                .andingLong(Long::longValue));
-        checkCollectorEmpty("andLongEmpty", OptionalLong.empty(), MoreCollectors.andingLong(Long::longValue));
-    }
-
-    @Test
-    public void testAndLongFlatMap() {
-        checkShortCircuitCollector("andLongFlat", OptionalLong.of(0), 2, () -> LongStreamEx.of(0).flatMap(
-            x -> LongStream.range(1, 100000000)).boxed(), MoreCollectors.andingLong(Long::longValue), true);
-    }
-
-    @Test
-    public void testFiltering() {
-        Collector<Integer, ?, Optional<Integer>> firstEven = MoreCollectors.filtering(x -> x % 2 == 0, MoreCollectors
-                .first());
-        Collector<Integer, ?, Optional<Integer>> firstOdd = MoreCollectors.filtering(x -> x % 2 != 0, MoreCollectors
-                .first());
-        Collector<Integer, ?, Integer> sumOddEven = MoreCollectors.pairing(firstEven, firstOdd, (e, o) -> e.get()
-            + o.get());
-        List<Integer> ints = asList(1, 3, 5, 7, 9, 10, 8, 6, 4, 2, 3, 7, 11);
-        checkShortCircuitCollector("sumOddEven", 11, 6, ints::stream, sumOddEven);
-        Collector<Integer, ?, Long> countEven = MoreCollectors.filtering(x -> x % 2 == 0, Collectors.counting());
-        checkCollector("filtering", 5L, ints::stream, countEven);
-        
-        checkCollector("filtering-toList", asList(1, 5, 3, 7), asList(1, 2, 4, 5, 4, 3, 0, 7, 8, 10)::stream,
-            MoreCollectors.filtering(x -> x % 2 == 1));
-    }
-
-    @Test
-    public void testOnlyOne() {
-        List<Integer> ints = IntStreamEx.rangeClosed(1, 100).boxed().toList();
-        checkShortCircuitCollector("One", Optional.empty(), 2, ints::stream, MoreCollectors.onlyOne());
-        checkShortCircuitCollector("FilterSeveral", Optional.empty(), 2, () -> ints.stream().filter(x -> x % 20 == 0),
-            MoreCollectors.onlyOne());
-        checkShortCircuitCollector("FilterSeveral2", Optional.empty(), 40, ints::stream, MoreCollectors.filtering(
-            x -> x % 20 == 0, MoreCollectors.onlyOne()));
-        checkShortCircuitCollector("FilterOne", Optional.of(60), 1, () -> ints.stream().filter(x -> x % 60 == 0),
-            MoreCollectors.onlyOne());
-        checkShortCircuitCollector("FilterNone", Optional.empty(), 0, () -> ints.stream().filter(x -> x % 110 == 0),
-            MoreCollectors.onlyOne());
-        checkShortCircuitCollector("FilterSeveral", Optional.empty(), 40, ints::stream, MoreCollectors.onlyOne(x -> x % 20 == 0));
-        checkShortCircuitCollector("FilterOne", Optional.of(60), 100, ints::stream, MoreCollectors.onlyOne(x -> x % 60 == 0));
-        checkShortCircuitCollector("FilterNone", Optional.empty(), 100, ints::stream, MoreCollectors.onlyOne(x -> x % 110 == 0));
-    }
-
-    @Test
-    public void testToEnumSet() {
-        TimeUnit[] vals = TimeUnit.values();
-        List<TimeUnit> enumValues = IntStreamEx.range(100).map(x -> x % vals.length).elements(vals).toList();
-        checkShortCircuitCollector("toEnumSet", EnumSet.allOf(TimeUnit.class), vals.length, enumValues::stream,
-            MoreCollectors.toEnumSet(TimeUnit.class));
-        enumValues = IntStreamEx.range(100).map(x -> x % (vals.length - 1)).elements(vals).toList();
-        EnumSet<TimeUnit> expected = EnumSet.allOf(TimeUnit.class);
-        expected.remove(vals[vals.length - 1]);
-        checkShortCircuitCollector("toEnumSet", expected, 100, enumValues::stream, MoreCollectors
-                .toEnumSet(TimeUnit.class));
-        checkCollectorEmpty("Empty", EnumSet.noneOf(TimeUnit.class), MoreCollectors.toEnumSet(TimeUnit.class));
-    }
-
-    @Test
-    public void testFlatMapping() {
-        {
-            Map<Integer, List<Integer>> expected = IntStreamEx.rangeClosed(1, 100).boxed().toMap(
-                x -> IntStreamEx.rangeClosed(1, x).boxed().toList());
-            Collector<Integer, ?, Map<Integer, List<Integer>>> groupingBy = Collectors.groupingBy(Function.identity(),
-                MoreCollectors.flatMapping(x -> IntStream.rangeClosed(1, x).boxed(), Collectors.toList()));
-            checkCollector("flatMappingSimple", expected, () -> IntStreamEx.rangeClosed(1, 100).boxed(), groupingBy);
-        }
-
-        Function<Entry<String, List<String>>, Stream<String>> valuesStream = e -> e.getValue() == null ? null : e
-                .getValue().stream();
-        List<Entry<String, List<String>>> list = EntryStream.of("a", asList("bb", "cc", "dd"), "b", asList("ee", "ff"),
-            "c", null).append("c", asList("gg"), "b", null, "a", asList("hh")).toList();
-        {
-            Map<String, List<String>> expected = EntryStream.of(list.stream()).flatMapValues(
-                l -> l == null ? null : l.stream()).grouping();
-            checkCollector("flatMappingCombine", expected, list::stream, Collectors.groupingBy(Entry::getKey,
-                MoreCollectors.flatMapping(valuesStream, Collectors.toList())));
-            AtomicInteger openClose = new AtomicInteger();
-            Collector<Entry<String, List<String>>, ?, Map<String, List<String>>> groupingBy = Collectors.groupingBy(
-                Entry::getKey, MoreCollectors.flatMapping(valuesStream.andThen(s -> {
-                    if (s == null)
-                        return null;
-                    openClose.incrementAndGet();
-                    return s.onClose(openClose::decrementAndGet);
-                }), Collectors.toList()));
-            checkCollector("flatMappingCombineClosed", expected, list::stream, MoreCollectors.collectingAndThen(
-                groupingBy, res -> {
-                    assertEquals(0, openClose.get());
-                    return res;
-                }));
-            boolean catched = false;
-            try {
-                Collector<Entry<String, List<String>>, ?, Map<String, List<String>>> groupingByException = Collectors
-                        .groupingBy(Entry::getKey, MoreCollectors.flatMapping(valuesStream.andThen(s -> {
-                            if (s == null)
-                                return null;
-                            openClose.incrementAndGet();
-                            return s.onClose(openClose::decrementAndGet).peek(e -> {
-                                if (e.equals("gg"))
-                                    throw new IllegalArgumentException(e);
-                            });
-                        }), Collectors.toList()));
-                list.stream().collect(MoreCollectors.collectingAndThen(groupingByException, res -> {
-                    assertEquals(0, openClose.get());
-                    return res;
-                }));
-            } catch (IllegalArgumentException e1) {
-                assertEquals("gg", e1.getMessage());
-                catched = true;
-            }
-            assertTrue(catched);
-        }
-        {
-            Map<String, List<String>> expected = EntryStream
-                    .of("a", asList("bb"), "b", asList("ee"), "c", asList("gg")).toMap();
-            Collector<Entry<String, List<String>>, ?, List<String>> headOne = MoreCollectors.flatMapping(valuesStream,
-                MoreCollectors.head(1));
-            checkCollector("flatMappingSubShort", expected, list::stream, Collectors.groupingBy(Entry::getKey, headOne));
-            checkShortCircuitCollector("flatMappingShort", expected, 4, list::stream, MoreCollectors.groupingBy(
-                Entry::getKey, StreamEx.of("a", "b", "c").toSet(), headOne));
-            AtomicInteger cnt = new AtomicInteger();
-            Collector<Entry<String, List<String>>, ?, List<String>> headPeek = MoreCollectors.flatMapping(valuesStream
-                    .andThen(s -> s == null ? null : s.peek(x -> cnt.incrementAndGet())), MoreCollectors.head(1));
-            assertEquals(expected, StreamEx.of(list).collect(Collectors.groupingBy(Entry::getKey, headPeek)));
-            assertEquals(3, cnt.get());
-            cnt.set(0);
-            assertEquals(expected, StreamEx.of(list).collect(
-                MoreCollectors.groupingBy(Entry::getKey, StreamEx.of("a", "b", "c").toSet(), headPeek)));
-            assertEquals(3, cnt.get());
-        }
-        {
-            Map<String, List<String>> expected = EntryStream.of("a", asList("bb", "cc"), "b", asList("ee", "ff"), "c",
-                asList("gg")).toMap();
-            Collector<Entry<String, List<String>>, ?, List<String>> headTwo = MoreCollectors.flatMapping(valuesStream,
-                MoreCollectors.head(2));
-            checkCollector("flatMappingSubShort", expected, list::stream, Collectors.groupingBy(Entry::getKey, headTwo));
-            AtomicInteger openClose = new AtomicInteger();
-            boolean catched = false;
-            try {
-                Collector<Entry<String, List<String>>, ?, Map<String, List<String>>> groupingByException = Collectors
-                        .groupingBy(Entry::getKey, MoreCollectors.flatMapping(valuesStream.andThen(s -> {
-                            if (s == null)
-                                return null;
-                            openClose.incrementAndGet();
-                            return s.onClose(openClose::decrementAndGet).peek(e -> {
-                                if (e.equals("gg"))
-                                    throw new IllegalArgumentException(e);
-                            });
-                        }), MoreCollectors.head(2)));
-                list.stream().collect(MoreCollectors.collectingAndThen(groupingByException, res -> {
-                    assertEquals(0, openClose.get());
-                    return res;
-                }));
-            } catch (IllegalArgumentException e1) {
-                assertEquals("gg", e1.getMessage());
-                catched = true;
-            }
-            assertTrue(catched);
-        }
-        checkCollector("flatMapping-toList", asList(0, 1, 2, 3, 0, 1, 2, 0, 1, 2, 3, 4), asList(4, 3, 5)::stream,
-            MoreCollectors.flatMapping(x -> IntStreamEx.range(x).boxed()));
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void testFlatMappingExceptional() {
-        Stream.of(1, 2, 3).collect(MoreCollectors.flatMapping(x -> Stream.of(1, x).onClose(() -> {
-            if (x == 3)
-                throw new IllegalStateException();
-        }), Collectors.toList()));
-    }
-
-    @Test(expected = IllegalStateException.class)
-    public void testFlatMappingShortCircuitExceptional() {
-        Stream.of(1, 2, 3).collect(MoreCollectors.flatMapping(x -> Stream.of(1, x).onClose(() -> {
-            if (x == 3)
-                throw new IllegalStateException();
-        }), MoreCollectors.head(10)));
-    }
-
-    @Test
-    public void testFlatMappingExceptionalSuppressed() {
-        List<Collector<Integer, ?, List<Integer>>> downstreams = asList(MoreCollectors.head(10), Collectors.toList());
-        for (Collector<Integer, ?, List<Integer>> downstream : downstreams) {
-            try {
-                Stream.of(1, 2, 3).collect(MoreCollectors.flatMapping(x -> Stream.of(1, x).peek(y -> {
-                    throw new IllegalArgumentException();
-                }).onClose(() -> {
-                    throw new IllegalStateException();
-                }), downstream));
-            } catch (Exception e) {
-                assertTrue(e instanceof IllegalArgumentException);
-                assertTrue(e.getSuppressed()[0] instanceof IllegalStateException);
-                continue;
-            }
-            fail("No exception");
-        }
-    }
-
-    @Test
-    public void testCommonPrefix() {
-        checkCollectorEmpty("prefix", "", MoreCollectors.commonPrefix());
-        List<String> input = asList("abcdef", "abcdefg", "abcdfgfg", "abcefgh", "abcdfg");
-        checkShortCircuitCollector("prefix", "abc", input.size(), input::stream, MoreCollectors.commonPrefix());
-        List<CharSequence> inputSeq = asList(new StringBuffer("abcdef"), "abcdefg", "abcdfgfg", "abcefgh",
-            new StringBuilder("abcdfg"));
-        checkShortCircuitCollector("prefix", "abc", inputSeq.size(), inputSeq::stream, MoreCollectors.commonPrefix());
-        List<String> input2 = asList("abcdef", "abcdefg", "dabcdfgfg", "abcefgh", "abcdfg");
-        checkShortCircuitCollector("prefix", "", 3, input2::stream, MoreCollectors.commonPrefix());
-        List<String> inputHalf = new ArrayList<>();
-        inputHalf.addAll(Collections.nCopies(1000, "abc"));
-        inputHalf.addAll(Collections.nCopies(1000, "def"));
-        checkShortCircuitCollector("prefix", "", 1001, inputHalf::stream, MoreCollectors.commonPrefix());
-        List<String> inputSurrogate = asList("abc\ud801\udc2f", "abc\ud801\udc2f", "abc\ud801\udc14");
-        checkShortCircuitCollector("prefix", "abc", inputSurrogate.size(), inputSurrogate::stream, MoreCollectors
-                .commonPrefix());
-        List<String> inputSurrogateBad = asList("abc\ud801x", "abc\ud801y", "abc\ud801z");
-        checkShortCircuitCollector("prefix", "abc\ud801", inputSurrogateBad.size(), inputSurrogateBad::stream,
-            MoreCollectors.commonPrefix());
-        List<String> inputSurrogateMix = asList("abc\ud801\udc2f", "abc\ud801x", "abc\ud801\udc14");
-        checkShortCircuitCollector("prefix", "abc", inputSurrogateMix.size(), inputSurrogateMix::stream, MoreCollectors
-                .commonPrefix());
-    }
-
-    @Test
-    public void testCommonSuffix() {
-        checkCollectorEmpty("suffix", "", MoreCollectors.commonSuffix());
-        List<String> input = asList("defabc", "degfabc", "dfgfgabc", "efghabc", "dfgabc");
-        checkShortCircuitCollector("suffix", "abc", input.size(), input::stream, MoreCollectors.commonSuffix());
-        List<CharSequence> inputSeq = asList(new StringBuffer("degfabc"), "dfgfgabc", new StringBuilder("efghabc"),
-            "defabc", "dfgabc");
-        checkShortCircuitCollector("suffix", "abc", inputSeq.size(), inputSeq::stream, MoreCollectors.commonSuffix());
-        List<String> input2 = asList("defabc", "defgabc", "dabcdfgfg", "efghabc", "dfgabc");
-        checkShortCircuitCollector("suffix", "", 3, input2::stream, MoreCollectors.commonSuffix());
-        List<String> inputHalf = new ArrayList<>();
-        inputHalf.addAll(Collections.nCopies(1000, "abc"));
-        inputHalf.addAll(Collections.nCopies(1000, "def"));
-        checkShortCircuitCollector("suffix", "", 1001, inputHalf::stream, MoreCollectors.commonSuffix());
-        List<String> inputSurrogate = asList("\ud801\udc2fabc", "\ud802\udc2fabc", "\ud803\udc2fabc");
-        checkShortCircuitCollector("suffix", "abc", inputSurrogate.size(), inputSurrogate::stream, MoreCollectors
-                .commonSuffix());
-        List<String> inputSurrogateBad = asList("x\udc2fabc", "y\udc2fabc", "z\udc2fabc");
-        checkShortCircuitCollector("suffix", "\udc2fabc", inputSurrogateBad.size(), inputSurrogateBad::stream,
-            MoreCollectors.commonSuffix());
-        List<String> inputSurrogateMix = asList("\ud801\udc2fabc", "x\udc2fabc", "\ud801\udc14abc");
-        checkShortCircuitCollector("suffix", "abc", inputSurrogateMix.size(), inputSurrogateMix::stream, MoreCollectors
-                .commonSuffix());
-    }
-
-    @Test
-    public void testDominators() {
-        List<String> input = asList("a/", "a/b/c/", "b/c/", "b/d/", "c/a/", "d/a/b/", "c/a/b/", "c/b/", "b/c/d/");
-        List<String> expected = asList("a/", "b/c/", "b/d/", "c/a/", "c/b/", "d/a/b/");
-        checkCollector("dominators", expected, () -> input.stream().sorted(), MoreCollectors.dominators((a, b) -> b
-                .startsWith(a)));
-
-        withRandom(r -> {
-            List<String> longInput = StreamEx.generate(
-                () -> IntStreamEx.of(r, r.nextInt(10) + 3, 'a', 'z').mapToObj(ch -> (char) ch).joining("/", "", "/"))
-                    .limit(1000).toList();
-
-            List<String> tmp = StreamEx.of(longInput).sorted().toList();
-            List<String> result = new ArrayList<>();
-            String curr, last;
-            curr = last = null;
-            for (String next : tmp) {
-                String oldLast = last;
-                last = curr;
-                curr = next;
-                if (last != null && curr.startsWith(last)) {
-                    curr = last;
-                    last = oldLast;
-                } else
-                    result.add(curr);
-            }
-            checkCollector("dominatorsLong", result, () -> longInput.stream().sorted(), MoreCollectors
-                    .dominators((a, b) -> b.startsWith(a)));
-        });
-    }
-
-    @Test
-    public void testIncreasingDominators() {
-        int[] input = { 1, 3, 4, 2, 1, 7, 5, 3, 4, 0, 4, 6, 7, 10, 4, 3, 2, 1 };
-        List<Integer> result = asList(1, 3, 4, 7, 10);
-        checkCollector("increasing", result, () -> IntStreamEx.of(input).boxed(), MoreCollectors
-                .dominators((a, b) -> a >= b));
-        withRandom(r -> {
-            int[] longInput = r.ints(10000, 0, 1000000).toArray();
-            List<Integer> longResult = new ArrayList<>();
-            int curMax = -1;
-            for (int val : longInput) {
-                if (val > curMax) {
-                    curMax = val;
-                    longResult.add(curMax);
-                }
-            }
-            checkCollector("increasingLong", longResult, () -> IntStreamEx.of(longInput).boxed(), MoreCollectors
-                    .dominators((a, b) -> a >= b));
-        });
-    }
-    
-    @Test
-    public void testMinMax() {
-        List<String> input = asList("abc", "a", "asdf", "gdasa", "gffsd", "sfgs", "b", "c", "dsgs");
-        checkCollector("minMax", Optional.of("agdasa"), input::stream, MoreCollectors.minMax(Comparator
-                .comparingInt(String::length), String::concat));
-        Collector<String, ?, Optional<Object>> collector = MoreCollectors.minMax(Comparator.naturalOrder(),
-            (min, max) -> {
-                throw new IllegalStateException("Should not be called");
-            });
-        checkCollectorEmpty("minMax", Optional.empty(), collector);
-    }
-
-    @Test
-    public void testIfAllMatch() {
-        Supplier<Stream<Integer>> five = () -> IntStreamEx.range(5).boxed();
-        checkShortCircuitCollector("ifAllMatch: all match", Optional.of(asList(0, 1, 2, 3, 4)), 5, five,
-                MoreCollectors.ifAllMatch(i -> true, Collectors.toList()));
-
-        Supplier<Stream<Integer>> ints = () -> IntStreamEx.ints().boxed();
-        checkShortCircuitCollector("ifAllMatch: shirtCircuit downstream", Optional.of(asList(0, 1, 2)), 3, ints,
-                MoreCollectors.ifAllMatch(i -> true, MoreCollectors.head(3)), true);
-
-        checkShortCircuitCollector("ifAllMatch: some match", Optional.empty(), 11, ints,
-                MoreCollectors.ifAllMatch(i -> i < 10, Collectors.toList()), true);
-
-        checkShortCircuitCollector("ifAllMatch: empty stream", Optional.of(Collections.emptyList()), 0, Stream::empty,
-                MoreCollectors.ifAllMatch(i -> true, Collectors.toList()));
-    }
-    
-    @Test
-    public void testReducingWithZero() {
-        Collector<Integer, ?, Optional<Integer>> multiplication = MoreCollectors.reducingWithZero(0, (a, b) -> a * b);
-        checkShortCircuitCollector("reducingWithZero: multiply", Optional.of(0), 4,
-            () -> StreamEx.of(3, 5, 10, 0, 1, 4), multiplication);
-        checkShortCircuitCollector("reducingWithZero: multiply", Optional.of(1200), 6,
-            () -> StreamEx.of(3, 5, 10, 2, 1, 4), multiplication);
-        checkShortCircuitCollector("reducingWithZero: multiply", Optional.empty(), 0,
-            StreamEx::empty, multiplication);
-        checkShortCircuitCollector("reducingWithZero: multiply", Optional.of(0), 32,
-            () -> StreamEx.constant(2, 64), multiplication);
-    }
-    
-    @Test
-    public void testReducingWithZeroAndIdentity() {
-        Collector<Integer, ?, Integer> multiplication = MoreCollectors.reducingWithZero(0, 1, (a, b) -> a * b);
-        checkShortCircuitCollector("reducingWithZero: multiply", 0, 4,
-            () -> StreamEx.of(3, 5, 10, 0, 1, 4), multiplication);
-        checkShortCircuitCollector("reducingWithZero: multiply", 1200, 6,
-            () -> StreamEx.of(3, 5, 10, 2, 1, 4), multiplication);
-        checkShortCircuitCollector("reducingWithZero: multiply", 1, 0,
-            StreamEx::empty, multiplication);
-        checkShortCircuitCollector("reducingWithZero: multiply", 0, 32,
-            () -> StreamEx.constant(2, 64), multiplication);
-    }
-}
+/*
+ * Copyright 2015, 2019 StreamEx contributors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package one.util.streamex;
+
+import one.util.streamex.Internals.BooleanMap;
+import org.junit.FixMethodOrder;
+import org.junit.Test;
+import org.junit.runners.MethodSorters;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.util.*;
+import java.util.AbstractMap.SimpleEntry;
+import java.util.Map.Entry;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.Function;
+import java.util.function.Supplier;
+import java.util.stream.*;
+import java.util.stream.Collector.Characteristics;
+
+import static java.util.Arrays.asList;
+import static one.util.streamex.TestHelpers.*;
+import static org.junit.Assert.*;
+
+/**
+ * @author Tagir Valeev
+ */
+@FixMethodOrder(MethodSorters.NAME_ASCENDING)
+public class MoreCollectorsTest {
+    static class MyNumber implements Comparable<MyNumber> {
+        final int value;
+        
+        MyNumber(int value) {
+            this.value = value;
+        }
+
+        @Override
+        public int hashCode() {
+            return value;
+        }
+
+        @Override
+        public boolean equals(Object obj) {
+            return obj instanceof MyNumber && ((MyNumber)obj).value == value;
+        }
+
+        @Override
+        public int compareTo(MyNumber o) {
+            return Integer.compare(value, o.value);
+        }
+    }
+
+    @Test(expected = UnsupportedOperationException.class)
+    public void testInstantiate() throws Throwable {
+        Constructor<MoreCollectors> constructor = MoreCollectors.class.getDeclaredConstructor();
+        constructor.setAccessible(true);
+        try {
+            constructor.newInstance();
+        } catch (InvocationTargetException e) {
+            throw e.getCause();
+        }
+    }
+
+    @Test
+    public void testToArray() {
+        assertThrows(NullPointerException.class, () -> MoreCollectors.toArray(null));
+        List<String> input = asList("a", "bb", "c", "", "cc", "eee", "bb", "ddd");
+        streamEx(input::stream, supplier -> {
+            Map<Integer, String[]> result = supplier.get().groupingBy(String::length, HashMap::new,
+                MoreCollectors.toArray(String[]::new));
+            assertArrayEquals(new String[] { "" }, result.get(0));
+            assertArrayEquals(new String[] { "a", "c" }, result.get(1));
+            assertArrayEquals(new String[] { "bb", "cc", "bb" }, result.get(2));
+            assertArrayEquals(new String[] { "eee", "ddd" }, result.get(3));
+        });
+    }
+
+    @Test
+    public void testEmpty() {
+        List<Integer> list = Stream.of(1, 2, 3).collect(MoreCollectors.head(0));
+        assertTrue(list.isEmpty());
+    }
+
+    @Test
+    public void testDistinctCount() {
+        assertThrows(NullPointerException.class, () -> MoreCollectors.distinctCount(null));
+        List<String> input = asList("a", "bb", "c", "cc", "eee", "bb", "bc", "ddd");
+        streamEx(input::stream, supplier -> {
+            Map<String, Integer> result = supplier.get().groupingBy(s -> s.substring(0, 1), HashMap::new,
+                MoreCollectors.distinctCount(String::length));
+            assertEquals(1, (int) result.get("a"));
+            assertEquals(1, (int) result.get("b"));
+            assertEquals(2, (int) result.get("c"));
+            assertEquals(1, (int) result.get("d"));
+            assertEquals(1, (int) result.get("e"));
+        });
+    }
+
+    @Test
+    public void testDistinctBy() {
+        assertThrows(NullPointerException.class, () -> MoreCollectors.distinctBy(null));
+        List<String> input = asList("a", "bb", "c", "cc", "eee", "bb", "bc", "ddd", "ca", "ce", "cf", "ded", "dump");
+        streamEx(input::stream, supplier -> {
+            Map<String, List<String>> result = supplier.get().groupingBy(s -> s.substring(0, 1), HashMap::new,
+                MoreCollectors.distinctBy(String::length));
+            assertEquals(asList("a"), result.get("a"));
+            assertEquals(asList("bb"), result.get("b"));
+            assertEquals(asList("c", "cc"), result.get("c"));
+            assertEquals(asList("ddd", "dump"), result.get("d"));
+            assertEquals(asList("eee"), result.get("e"));
+        });
+    }
+
+    @Test
+    public void testMaxAll() {
+        assertThrows(NullPointerException.class, () -> MoreCollectors.maxAll((Comparator<String>)null));
+        assertThrows(NullPointerException.class, () -> MoreCollectors.maxAll((Collector<String, ?, ?>)null));
+        assertThrows(NullPointerException.class, () -> MoreCollectors.maxAll(null, null));
+        assertThrows(NullPointerException.class, () -> MoreCollectors.minAll((Comparator<String>)null));
+        assertThrows(NullPointerException.class, () -> MoreCollectors.minAll((Collector<String, ?, ?>)null));
+        assertThrows(NullPointerException.class, () -> MoreCollectors.minAll(null, null));
+        List<String> input = asList("a", "bb", "c", "", "cc", "eee", "bb", "ddd");
+        checkCollector("maxAll", asList("eee", "ddd"), input::stream, MoreCollectors.maxAll(Comparator
+                .comparingInt(String::length)));
+        Collector<String, ?, String> maxAllJoin = MoreCollectors.maxAll(Comparator.comparingInt(String::length),
+            Collectors.joining(","));
+        checkCollector("maxAllJoin", "eee,ddd", input::stream, maxAllJoin);
+        checkCollector("minAll", 1L, input::stream, MoreCollectors.minAll(Comparator.comparingInt(String::length),
+            Collectors.counting()));
+        checkCollector("minAllEmpty", asList(""), input::stream, MoreCollectors.minAll(Comparator
+                .comparingInt(String::length)));
+        checkCollectorEmpty("maxAll", Collections.emptyList(), MoreCollectors.maxAll(Comparator
+                .comparingInt(String::length)));
+        checkCollectorEmpty("maxAllJoin", "", maxAllJoin);
+
+        withRandom(r -> {
+            List<Integer> ints = IntStreamEx.of(r, 10000, 1, 1000).boxed().toList();
+            List<Integer> expectedMax = getMaxAll(ints, Comparator.naturalOrder());
+            List<Integer> expectedMin = getMaxAll(ints, Comparator.reverseOrder());
+            Collector<Integer, ?, SimpleEntry<Integer, Long>> downstream = MoreCollectors.pairing(MoreCollectors.first(),
+                Collectors.counting(), (opt, cnt) -> new AbstractMap.SimpleEntry<>(opt.get(), cnt));
+
+            checkCollector("maxAll", expectedMax, ints::stream, MoreCollectors.maxAll(Integer::compare));
+            checkCollector("minAll", expectedMin, ints::stream, MoreCollectors.minAll());
+            checkCollector("entry", new SimpleEntry<>(expectedMax.get(0), (long) expectedMax.size()), ints::stream,
+                MoreCollectors.maxAll(downstream));
+            checkCollector("entry", new SimpleEntry<>(expectedMin.get(0), (long) expectedMin.size()), ints::stream,
+                MoreCollectors.minAll(downstream));
+        });
+        
+        MyNumber a = new MyNumber(1), b = new MyNumber(1), c = new MyNumber(1000), d = new MyNumber(1000);
+        List<MyNumber> nums = IntStreamEx.range(10, 100).mapToObj(MyNumber::new).append(a, c).prepend(b, d).toList();
+        streamEx(nums::stream, supplier -> {
+            List<MyNumber> list = supplier.get().collect(MoreCollectors.maxAll());
+            assertEquals(2, list.size());
+            assertSame(d, list.get(0));
+            assertSame(c, list.get(1));
+
+            list = supplier.get().collect(MoreCollectors.minAll());
+            assertEquals(2, list.size());
+            assertSame(b, list.get(0));
+            assertSame(a, list.get(1));
+        });
+    }
+
+    private static List<Integer> getMaxAll(List<Integer> ints, Comparator<Integer> c) {
+        List<Integer> expectedMax = null;
+        for (Integer i : ints) {
+            if (expectedMax == null || c.compare(i, expectedMax.get(0)) > 0) {
+                expectedMax = new ArrayList<>();
+                expectedMax.add(i);
+            } else if (i.equals(expectedMax.get(0))) {
+                expectedMax.add(i);
+            }
+        }
+        return expectedMax;
+    }
+
+    @Test
+    public void testFirstLast() {
+        Supplier<Stream<Integer>> s = () -> IntStreamEx.range(1000).boxed();
+        checkShortCircuitCollector("first", Optional.of(0), 1, s, MoreCollectors.first());
+        checkShortCircuitCollector("firstLong", Optional.of(0), 1, () -> Stream.of(1).flatMap(
+            x -> IntStream.range(0, 1000000000).boxed()), MoreCollectors.first(), true);
+        checkShortCircuitCollector("first", Optional.of(1), 1, () -> Stream.iterate(1, x -> x + 1), MoreCollectors
+                .first(), true);
+        assertEquals(1, (int) StreamEx.iterate(1, x -> x + 1).parallel().collect(MoreCollectors.first()).get());
+
+        checkCollector("last", Optional.of(999), s, MoreCollectors.last());
+        checkCollectorEmpty("first", Optional.empty(), MoreCollectors.first());
+        checkCollectorEmpty("last", Optional.empty(), MoreCollectors.last());
+        assertThrows(NullPointerException.class, () -> StreamEx.of(null, 1).collect(MoreCollectors.first()));
+        assertThrows(NullPointerException.class, () -> StreamEx.of(1, null).collect(MoreCollectors.last()));
+        assertEquals(Optional.of(1), StreamEx.of(null, 1).collect(MoreCollectors.last()));
+        assertEquals(Optional.of(1), StreamEx.of(1, null).collect(MoreCollectors.first()));
+    }
+
+    @Test
+    public void testHeadParallel() {
+        List<Integer> expected = IntStreamEx.range(0, 2000, 2).boxed().toList();
+        List<Integer> expectedShort = asList(0, 1);
+        for (int i = 0; i < 1000; i++) {
+            assertEquals("#" + i, expectedShort, IntStreamEx.range(1000).boxed().parallel().collect(
+                MoreCollectors.head(2)));
+            assertEquals("#" + i, expected, IntStreamEx.range(10000).boxed().parallel().filter(x -> x % 2 == 0)
+                    .collect(MoreCollectors.head(1000)));
+        }
+        assertEquals(expectedShort, StreamEx.iterate(0, x -> x + 1).parallel().collect(MoreCollectors.head(2)));
+    }
+
+    @Test
+    public void testHeadTail() {
+        List<Integer> ints = IntStreamEx.range(1000).boxed().toList();
+        checkShortCircuitCollector("tail(0)", asList(), 0, ints::stream, MoreCollectors.tail(0));
+        checkCollector("tail(1)", asList(999), ints::stream, MoreCollectors.tail(1));
+        checkCollector("tail(2)", asList(998, 999), ints::stream, MoreCollectors.tail(2));
+        checkCollector("tail(500)", ints.subList(500, 1000), ints::stream, MoreCollectors.tail(500));
+        checkCollector("tail(999)", ints.subList(1, 1000), ints::stream, MoreCollectors.tail(999));
+        checkCollector("tail(1000)", ints, ints::stream, MoreCollectors.tail(1000));
+        checkCollector("tail(MAX)", ints, ints::stream, MoreCollectors.tail(Integer.MAX_VALUE));
+
+        checkShortCircuitCollector("head(0)", asList(), 0, ints::stream, MoreCollectors.head(0));
+        checkShortCircuitCollector("head(1)", asList(0), 1, ints::stream, MoreCollectors.head(1));
+        checkShortCircuitCollector("head(2)", asList(0, 1), 2, ints::stream, MoreCollectors.head(2));
+        checkShortCircuitCollector("head(500)", ints.subList(0, 500), 500, ints::stream, MoreCollectors.head(500));
+        checkShortCircuitCollector("head(999)", ints.subList(0, 999), 999, ints::stream, MoreCollectors.head(999));
+        checkShortCircuitCollector("head(1000)", ints, 1000, ints::stream, MoreCollectors.head(1000));
+        checkShortCircuitCollector("head(MAX)", ints, 1000, ints::stream, MoreCollectors.head(Integer.MAX_VALUE));
+
+        checkShortCircuitCollector("head(10000)", IntStreamEx.rangeClosed(1, 10000).boxed().toList(), 10000,
+            () -> Stream.iterate(1, x -> x + 1), MoreCollectors.head(10000), true);
+
+        for (int size : new int[] { 1, 10, 20, 40, 60, 80, 90, 98, 99, 100 }) {
+            checkShortCircuitCollector("head-unordered-" + size, Collections.nCopies(size, "test"), size,
+                () -> StreamEx.constant("test", 100), MoreCollectors.head(size));
+        }
+    }
+
+    @Test
+    public void testGreatest() {
+        assertThrows(NullPointerException.class, () -> MoreCollectors.greatest(null, 0));
+        assertThrows(NullPointerException.class, () -> MoreCollectors.least(null, 0));
+        withRandom(r -> {
+            List<Integer> ints = IntStreamEx.of(r, 1000, 1, 1000).boxed().toList();
+            List<Integer> sorted = StreamEx.of(ints).sorted().toList();
+            List<Integer> revSorted = StreamEx.of(ints).reverseSorted().toList();
+            Comparator<Integer> byString = Comparator.comparing(String::valueOf);
+            checkShortCircuitCollector("least(0)", Collections.emptyList(), 0, ints::stream, MoreCollectors.least(0));
+            checkCollector("least(5)", sorted.subList(0, 5), ints::stream, MoreCollectors.least(5));
+            checkCollector("least(20)", sorted.subList(0, 20), ints::stream, MoreCollectors.least(20));
+            checkCollector("least(MAX)", sorted, ints::stream, MoreCollectors.least(Integer.MAX_VALUE));
+            checkCollector("least(byString, 20)", StreamEx.of(ints).sorted(byString).limit(20).toList(), ints::stream,
+                MoreCollectors.least(byString, 20));
+
+            checkShortCircuitCollector("greatest(0)", Collections.emptyList(), 0, ints::stream, MoreCollectors.greatest(0));
+            checkCollector("greatest(5)", revSorted.subList(0, 5), ints::stream, MoreCollectors.greatest(5));
+            checkCollector("greatest(20)", revSorted.subList(0, 20), ints::stream, MoreCollectors.greatest(20));
+            checkCollector("greatest(MAX)", revSorted, ints::stream, MoreCollectors.greatest(Integer.MAX_VALUE));
+            checkCollector("greatest(byString, 20)", StreamEx.of(ints).reverseSorted(byString).limit(20).toList(),
+                ints::stream, MoreCollectors.greatest(byString, 20));
+            checkCollector("greatest(byString, 30)", StreamEx.of(ints).reverseSorted(byString).limit(30).toList(),
+                ints::stream, MoreCollectors.greatest(byString, 30));
+        });
+
+        Supplier<Stream<Integer>> s = () -> IntStreamEx.range(100).boxed();
+        checkCollector("1", IntStreamEx.range(1).boxed().toList(), s, MoreCollectors.least(1));
+        checkCollector("2", IntStreamEx.range(2).boxed().toList(), s, MoreCollectors.least(2));
+        checkCollector("10", IntStreamEx.range(10).boxed().toList(), s, MoreCollectors.least(10));
+        checkCollector("100", IntStreamEx.range(100).boxed().toList(), s, MoreCollectors.least(100));
+        checkCollector("200", IntStreamEx.range(100).boxed().toList(), s, MoreCollectors.least(200));
+    }
+
+    @Test
+    public void testCountingInt() {
+        checkCollector("counting", 1000, () -> IntStreamEx.range(1000).boxed(), MoreCollectors.countingInt());
+        checkCollectorEmpty("counting", 0, MoreCollectors.countingInt());
+    }
+
+    @Test
+    public void testMinIndex() {
+        assertThrows(NullPointerException.class, () -> MoreCollectors.minIndex(null));
+        withRandom(r -> {
+            List<Integer> ints = IntStreamEx.of(r, 1000, 5, 47).boxed().toList();
+            long expectedMin = IntStreamEx.ofIndices(ints).minBy(ints::get).getAsInt();
+            long expectedMax = IntStreamEx.ofIndices(ints).maxBy(ints::get).getAsInt();
+            long expectedMinString = IntStreamEx.ofIndices(ints).minBy(i -> String.valueOf(ints.get(i))).getAsInt();
+            long expectedMaxString = IntStreamEx.ofIndices(ints).maxBy(i -> String.valueOf(ints.get(i))).getAsInt();
+            Comparator<Integer> cmp = Comparator.comparing(String::valueOf);
+            checkCollector("minIndex", OptionalLong.of(expectedMin), ints::stream, MoreCollectors.minIndex());
+            checkCollector("maxIndex", OptionalLong.of(expectedMax), ints::stream, MoreCollectors.maxIndex());
+            checkCollector("minIndex", OptionalLong.of(expectedMinString), ints::stream, MoreCollectors.minIndex(cmp));
+            checkCollector("maxIndex", OptionalLong.of(expectedMaxString), ints::stream, MoreCollectors.maxIndex(cmp));
+            Supplier<Stream<String>> supplier = () -> ints.stream().map(Object::toString);
+            checkCollector("minIndex", OptionalLong.of(expectedMinString), supplier, MoreCollectors.minIndex());
+            checkCollector("maxIndex", OptionalLong.of(expectedMaxString), supplier, MoreCollectors.maxIndex());
+            checkCollectorEmpty("minIndex", OptionalLong.empty(), MoreCollectors.<String> minIndex());
+            checkCollectorEmpty("maxIndex", OptionalLong.empty(), MoreCollectors.<String> maxIndex());
+        });
+    }
+
+    @Test
+    public void testGroupingByEnum() {
+        assertThrows(NullPointerException.class, () -> MoreCollectors.groupingByEnum((Class<TimeUnit>)null, 
+            Function.identity(), Collectors.toList()));
+        assertThrows(NullPointerException.class, () -> MoreCollectors.groupingByEnum(TimeUnit.class, 
+            null, Collectors.toList()));
+        assertThrows(NullPointerException.class, () -> MoreCollectors.groupingByEnum(TimeUnit.class, 
+            Function.identity(), null));
+        EnumMap<TimeUnit, Long> expected = new EnumMap<>(TimeUnit.class);
+        EnumSet.allOf(TimeUnit.class).forEach(tu -> expected.put(tu, 0L));
+        expected.put(TimeUnit.SECONDS, 1L);
+        expected.put(TimeUnit.DAYS, 2L);
+        expected.put(TimeUnit.NANOSECONDS, 1L);
+        checkCollector("groupingByEnum", expected, () -> Stream.of(TimeUnit.SECONDS, TimeUnit.DAYS, TimeUnit.DAYS,
+            TimeUnit.NANOSECONDS), MoreCollectors.groupingByEnum(TimeUnit.class, Function.identity(), Collectors
+                .counting()));
+    }
+
+    @Test(expected = IllegalStateException.class)
+    public void testGroupingByWithDomainException() {
+        List<Integer> list = asList(1, 2, 20, 3, 31, 4);
+        Collector<Integer, ?, Map<Integer, List<Integer>>> c = MoreCollectors.groupingBy(i -> i % 10, StreamEx.of(0, 1,
+            2, 3).toSet(), Collectors.toList());
+        Map<Integer, List<Integer>> map = list.stream().collect(c);
+        System.out.println(map);
+    }
+
+    @Test
+    public void testGroupingByWithDomain() {
+        assertThrows(NullPointerException.class, () -> MoreCollectors.groupingBy(null,
+            Collections.emptySet(), Collectors.toList()));
+        assertThrows(NullPointerException.class, () -> MoreCollectors.groupingBy(Function.identity(),
+            null, Collectors.toList()));
+        assertThrows(NullPointerException.class, () -> MoreCollectors.groupingBy(Function.identity(),
+            Collections.emptySet(), null));
+        assertThrows(NullPointerException.class, () -> MoreCollectors.groupingBy(null,
+            Collections.emptySet(), HashMap::new, Collectors.toList()));
+        assertThrows(NullPointerException.class, () -> MoreCollectors.groupingBy(Function.identity(),
+            null, HashMap::new, Collectors.toList()));
+        assertThrows(NullPointerException.class, () -> MoreCollectors.groupingBy(Function.identity(),
+            Collections.emptySet(), null, Collectors.toList()));
+        assertThrows(NullPointerException.class, () -> MoreCollectors.groupingBy(Function.identity(),
+            Collections.emptySet(), HashMap::new, null));
+        List<String> data = asList("a", "foo", "test", "ququq", "bar", "blahblah");
+        Collector<String, ?, String> collector = MoreCollectors.collectingAndThen(MoreCollectors.groupingBy(
+            String::length, IntStreamEx.range(10).boxed().toSet(), TreeMap::new, MoreCollectors.first()),
+            Object::toString);
+        checkShortCircuitCollector("groupingWithDomain",
+            "{0=Optional.empty, 1=Optional[a], 2=Optional.empty, 3=Optional[foo], 4=Optional[test], 5=Optional[ququq], "
+                + "6=Optional.empty, 7=Optional.empty, 8=Optional[blahblah], 9=Optional.empty}", data.size(),
+            data::stream, collector);
+
+        Map<String, String> name2sex = new LinkedHashMap<>();
+        name2sex.put("Mary", "Girl");
+        name2sex.put("John", "Boy");
+        name2sex.put("James", "Boy");
+        name2sex.put("Lucie", "Girl");
+        name2sex.put("Fred", "Boy");
+        name2sex.put("Thomas", "Boy");
+        name2sex.put("Jane", "Girl");
+        name2sex.put("Ruth", "Girl");
+        name2sex.put("Melanie", "Girl");
+        Collector<Entry<String, String>, ?, Map<String, List<String>>> groupingBy = MoreCollectors.groupingBy(
+            Entry::getValue, StreamEx.of("Girl", "Boy").toSet(), MoreCollectors.mapping(Entry::getKey, MoreCollectors
+                    .head(2)));
+        AtomicInteger counter = new AtomicInteger();
+        Map<String, List<String>> map = EntryStream.of(name2sex).peek(c -> counter.incrementAndGet()).collect(
+            groupingBy);
+        assertEquals(asList("Mary", "Lucie"), map.get("Girl"));
+        assertEquals(asList("John", "James"), map.get("Boy"));
+        assertEquals(4, counter.get());
+
+        Collector<Entry<String, String>, ?, Map<String, String>> groupingByJoin = MoreCollectors.groupingBy(
+            Entry::getValue, StreamEx.of("Girl", "Boy").toSet(), MoreCollectors.mapping(Entry::getKey, Joining.with(
+                ", ").maxChars(16).cutAfterDelimiter()));
+        counter.set(0);
+        Map<String, String> mapJoin = EntryStream.of(name2sex).peek(c -> counter.incrementAndGet()).collect(
+            groupingByJoin);
+        assertEquals("Mary, Lucie, ...", mapJoin.get("Girl"));
+        assertEquals("John, James, ...", mapJoin.get("Boy"));
+        assertEquals(7, counter.get());
+    }
+
+    @Test
+    public void testToBooleanArray() {
+        assertThrows(NullPointerException.class, () -> MoreCollectors.toBooleanArray(null));
+        withRandom(r -> {
+            List<Integer> input = IntStreamEx.of(r, 1000, 1, 100).boxed().toList();
+            boolean[] expected = new boolean[input.size()];
+            for (int i = 0; i < expected.length; i++)
+                expected[i] = input.get(i) > 50;
+            streamEx(input::stream, supplier -> assertArrayEquals(expected, supplier.get().collect(
+                MoreCollectors.toBooleanArray(x -> x > 50))));
+        });
+    }
+
+    @Test
+    public void testPartitioningBy() {
+        assertThrows(NullPointerException.class, () -> MoreCollectors.partitioningBy(null, Collectors.toList()));
+        assertThrows(NullPointerException.class, () -> MoreCollectors.partitioningBy(x -> x.hashCode() > 0, null));
+        Collector<Integer, ?, Map<Boolean, Optional<Integer>>> by20 = MoreCollectors.partitioningBy(x -> x % 20 == 0,
+            MoreCollectors.first());
+        Collector<Integer, ?, Map<Boolean, Optional<Integer>>> by200 = MoreCollectors.partitioningBy(x -> x % 200 == 0,
+            MoreCollectors.first());
+        Supplier<Stream<Integer>> supplier = () -> IntStreamEx.range(1, 100).boxed();
+        checkShortCircuitCollector("by20", new BooleanMap<>(Optional.of(20), Optional.of(1)), 20, supplier, by20);
+        checkShortCircuitCollector("by200", new BooleanMap<>(Optional.empty(), Optional.of(1)), 99, supplier, by200);
+    }
+
+    @Test
+    public void testMapping() {
+        assertThrows(NullPointerException.class, () -> MoreCollectors.mapping(null, Collectors.toList()));
+        assertThrows(NullPointerException.class, () -> MoreCollectors.mapping(Function.identity(), null));
+        List<String> input = asList("Capital", "lower", "Foo", "bar");
+        Collector<String, ?, Map<Boolean, Optional<Integer>>> collector = MoreCollectors
+                .partitioningBy(str -> Character.isUpperCase(str.charAt(0)), MoreCollectors.mapping(String::length,
+                    MoreCollectors.first()));
+        checkShortCircuitCollector("mapping", new BooleanMap<>(Optional.of(7), Optional.of(5)), 2, input::stream,
+            collector);
+        Collector<String, ?, Map<Boolean, Optional<Integer>>> collectorLast = MoreCollectors.partitioningBy(
+            str -> Character.isUpperCase(str.charAt(0)), MoreCollectors.mapping(String::length, MoreCollectors.last()));
+        checkCollector("last", new BooleanMap<>(Optional.of(3), Optional.of(3)), input::stream, collectorLast);
+
+        input = asList("Abc", "Bac", "Aac", "Abv", "Bbc", "Bgd", "Atc", "Bpv");
+        Map<Character, List<String>> expected = EntryStream.of('A', asList("Abc", "Aac"), 'B', asList("Bac", "Bbc"))
+                .toMap();
+        AtomicInteger cnt = new AtomicInteger();
+        Collector<String, ?, Map<Character, List<String>>> groupMap = Collectors.groupingBy(s -> s.charAt(0),
+            MoreCollectors.mapping(x -> {
+                cnt.incrementAndGet();
+                return x;
+            }, MoreCollectors.head(2)));
+        checkCollector("groupMap", expected, input::stream, groupMap);
+        cnt.set(0);
+        assertEquals(expected, input.stream().collect(groupMap));
+        assertEquals(4, cnt.get());
+
+        checkCollector("mapping-toList", asList("a", "b", "c"), asList("a1", "b2", "c3")::stream, MoreCollectors
+                .mapping(str -> str.substring(0, 1)));
+    }
+
+    @Test
+    public void testIntersecting() {
+        for (int i = 0; i < 5; i++) {
+            List<List<String>> input = asList(asList("aa", "bb", "cc"), asList("cc", "bb", "dd"), asList("ee", "dd"),
+                asList("aa", "bb", "dd"));
+            checkShortCircuitCollector("#" + i, Collections.emptySet(), 3, input::stream, MoreCollectors.intersecting());
+            List<List<Integer>> copies = new ArrayList<>(Collections.nCopies(100, asList(1, 2)));
+            checkShortCircuitCollector("#" + i, StreamEx.of(1, 2).toSet(), 100, copies::stream, MoreCollectors
+                    .intersecting());
+            copies.addAll(Collections.nCopies(100, asList(3)));
+            checkShortCircuitCollector("#" + i, Collections.emptySet(), 101, copies::stream, MoreCollectors
+                    .intersecting());
+            checkCollectorEmpty("#" + i, Collections.emptySet(), MoreCollectors.intersecting());
+        }
+    }
+
+    @Test
+    public void testAndInt() {
+        assertThrows(NullPointerException.class, () -> MoreCollectors.andingInt(null));
+        List<Integer> ints = asList(0b1100, 0b0110, 0b101110, 0b11110011);
+        Collector<Integer, ?, OptionalInt> collector = MoreCollectors.andingInt(Integer::intValue);
+        checkShortCircuitCollector("andInt", OptionalInt.of(0), 4, ints::stream, collector);
+        checkCollectorEmpty("andIntEmpty", OptionalInt.empty(), collector);
+        assertEquals(OptionalInt.of(0), IntStreamEx.iterate(16384, i -> i + 1).parallel().boxed().collect(collector));
+        assertEquals(OptionalInt.of(16384), IntStreamEx.iterate(16384, i -> i + 1).parallel().limit(16383).boxed()
+                .collect(collector));
+        Collector<Integer, ?, Integer> unwrapped = MoreCollectors.collectingAndThen(MoreCollectors
+                .andingInt(Integer::intValue), OptionalInt::getAsInt);
+        assertTrue(unwrapped.characteristics().contains(Characteristics.UNORDERED));
+        checkShortCircuitCollector("andIntUnwrapped", 0, 4, ints::stream, unwrapped);
+        checkShortCircuitCollector("andIntUnwrapped", 0, 2, asList(0x1, 0x10, 0x100)::stream, unwrapped);
+    }
+
+    @Test
+    public void testAndLong() {
+        assertThrows(NullPointerException.class, () -> MoreCollectors.andingLong(null));
+        List<Long> longs = asList(0xFFFFFFFFFFFFFFFFL, 0xFFFFFFFF00000000L, 0xFFFFFFFF0000L);
+        checkShortCircuitCollector("andLong", OptionalLong.of(0xFFFF00000000L), 3, longs::stream, MoreCollectors
+                .andingLong(Long::longValue));
+        longs = asList(1L, 2L, 3L, 4L);
+        checkShortCircuitCollector("andLong", OptionalLong.of(0), 2, longs::stream, MoreCollectors
+                .andingLong(Long::longValue));
+        checkCollectorEmpty("andLongEmpty", OptionalLong.empty(), MoreCollectors.andingLong(Long::longValue));
+    }
+
+    @Test
+    public void testAndLongFlatMap() {
+        checkShortCircuitCollector("andLongFlat", OptionalLong.of(0), 2, () -> LongStreamEx.of(0).flatMap(
+            x -> LongStream.range(1, 100000000)).boxed(), MoreCollectors.andingLong(Long::longValue), true);
+    }
+
+    @Test
+    public void testFiltering() {
+        assertThrows(NullPointerException.class, () -> MoreCollectors.filtering(null, Collectors.toList()));
+        assertThrows(NullPointerException.class, () -> MoreCollectors.filtering(x -> true, null));
+        Collector<Integer, ?, Optional<Integer>> firstEven = MoreCollectors.filtering(x -> x % 2 == 0, MoreCollectors
+                .first());
+        Collector<Integer, ?, Optional<Integer>> firstOdd = MoreCollectors.filtering(x -> x % 2 != 0, MoreCollectors
+                .first());
+        Collector<Integer, ?, Integer> sumOddEven = MoreCollectors.pairing(firstEven, firstOdd, (e, o) -> e.get()
+            + o.get());
+        List<Integer> ints = asList(1, 3, 5, 7, 9, 10, 8, 6, 4, 2, 3, 7, 11);
+        checkShortCircuitCollector("sumOddEven", 11, 6, ints::stream, sumOddEven);
+        Collector<Integer, ?, Long> countEven = MoreCollectors.filtering(x -> x % 2 == 0, Collectors.counting());
+        checkCollector("filtering", 5L, ints::stream, countEven);
+        
+        checkCollector("filtering-toList", asList(1, 5, 3, 7), asList(1, 2, 4, 5, 4, 3, 0, 7, 8, 10)::stream,
+            MoreCollectors.filtering(x -> x % 2 == 1));
+    }
+
+    @Test
+    public void testOnlyOne() {
+        List<Integer> ints = IntStreamEx.rangeClosed(1, 100).boxed().toList();
+        checkShortCircuitCollector("One", Optional.empty(), 2, ints::stream, MoreCollectors.onlyOne());
+        checkShortCircuitCollector("FilterSeveral", Optional.empty(), 2, () -> ints.stream().filter(x -> x % 20 == 0),
+            MoreCollectors.onlyOne());
+        checkShortCircuitCollector("FilterSeveral2", Optional.empty(), 40, ints::stream, MoreCollectors.filtering(
+            x -> x % 20 == 0, MoreCollectors.onlyOne()));
+        checkShortCircuitCollector("FilterOne", Optional.of(60), 1, () -> ints.stream().filter(x -> x % 60 == 0),
+            MoreCollectors.onlyOne());
+        checkShortCircuitCollector("FilterNone", Optional.empty(), 0, () -> ints.stream().filter(x -> x % 110 == 0),
+            MoreCollectors.onlyOne());
+        checkShortCircuitCollector("FilterSeveral", Optional.empty(), 40, ints::stream, MoreCollectors.onlyOne(x -> x % 20 == 0));
+        checkShortCircuitCollector("FilterOne", Optional.of(60), 100, ints::stream, MoreCollectors.onlyOne(x -> x % 60 == 0));
+        checkShortCircuitCollector("FilterNone", Optional.empty(), 100, ints::stream, MoreCollectors.onlyOne(x -> x % 110 == 0));
+        assertThrows(NullPointerException.class, () -> StreamEx.of((String)null).collect(MoreCollectors.onlyOne()));
+    }
+
+    @Test
+    public void testToEnumSet() {
+        assertThrows(NullPointerException.class, () -> MoreCollectors.toEnumSet(null));
+        TimeUnit[] vals = TimeUnit.values();
+        List<TimeUnit> enumValues = IntStreamEx.range(100).map(x -> x % vals.length).elements(vals).toList();
+        checkShortCircuitCollector("toEnumSet", EnumSet.allOf(TimeUnit.class), vals.length, enumValues::stream,
+            MoreCollectors.toEnumSet(TimeUnit.class));
+        enumValues = IntStreamEx.range(100).map(x -> x % (vals.length - 1)).elements(vals).toList();
+        EnumSet<TimeUnit> expected = EnumSet.allOf(TimeUnit.class);
+        expected.remove(vals[vals.length - 1]);
+        checkShortCircuitCollector("toEnumSet", expected, 100, enumValues::stream, MoreCollectors
+                .toEnumSet(TimeUnit.class));
+        checkCollectorEmpty("Empty", EnumSet.noneOf(TimeUnit.class), MoreCollectors.toEnumSet(TimeUnit.class));
+    }
+
+    @Test
+    public void testFlatMapping() {
+        assertThrows(NullPointerException.class, () -> MoreCollectors.flatMapping(null));
+        assertThrows(NullPointerException.class, () -> MoreCollectors.flatMapping(null, Collectors.toList()));
+        assertThrows(NullPointerException.class, () -> MoreCollectors.flatMapping(Stream::of, null));
+        {
+            Map<Integer, List<Integer>> expected = IntStreamEx.rangeClosed(1, 100).boxed().toMap(
+                x -> IntStreamEx.rangeClosed(1, x).boxed().toList());
+            Collector<Integer, ?, Map<Integer, List<Integer>>> groupingBy = Collectors.groupingBy(Function.identity(),
+                MoreCollectors.flatMapping(x -> IntStream.rangeClosed(1, x).boxed(), Collectors.toList()));
+            checkCollector("flatMappingSimple", expected, () -> IntStreamEx.rangeClosed(1, 100).boxed(), groupingBy);
+        }
+
+        Function<Entry<String, List<String>>, Stream<String>> valuesStream = e -> e.getValue() == null ? null : e
+                .getValue().stream();
+        List<Entry<String, List<String>>> list = EntryStream.of("a", asList("bb", "cc", "dd"), "b", asList("ee", "ff"),
+            "c", null).append("c", asList("gg"), "b", null, "a", asList("hh")).toList();
+        {
+            Map<String, List<String>> expected = EntryStream.of(list.stream()).flatMapValues(
+                l -> l == null ? null : l.stream()).grouping();
+            checkCollector("flatMappingCombine", expected, list::stream, Collectors.groupingBy(Entry::getKey,
+                MoreCollectors.flatMapping(valuesStream, Collectors.toList())));
+            AtomicInteger openClose = new AtomicInteger();
+            Collector<Entry<String, List<String>>, ?, Map<String, List<String>>> groupingBy = Collectors.groupingBy(
+                Entry::getKey, MoreCollectors.flatMapping(valuesStream.andThen(s -> {
+                    if (s == null)
+                        return null;
+                    openClose.incrementAndGet();
+                    return s.onClose(openClose::decrementAndGet);
+                }), Collectors.toList()));
+            checkCollector("flatMappingCombineClosed", expected, list::stream, MoreCollectors.collectingAndThen(
+                groupingBy, res -> {
+                    assertEquals(0, openClose.get());
+                    return res;
+                }));
+            boolean catched = false;
+            try {
+                Collector<Entry<String, List<String>>, ?, Map<String, List<String>>> groupingByException = Collectors
+                        .groupingBy(Entry::getKey, MoreCollectors.flatMapping(valuesStream.andThen(s -> {
+                            if (s == null)
+                                return null;
+                            openClose.incrementAndGet();
+                            return s.onClose(openClose::decrementAndGet).peek(e -> {
+                                if (e.equals("gg"))
+                                    throw new IllegalArgumentException(e);
+                            });
+                        }), Collectors.toList()));
+                list.stream().collect(MoreCollectors.collectingAndThen(groupingByException, res -> {
+                    assertEquals(0, openClose.get());
+                    return res;
+                }));
+            } catch (IllegalArgumentException e1) {
+                assertEquals("gg", e1.getMessage());
+                catched = true;
+            }
+            assertTrue(catched);
+        }
+        {
+            Map<String, List<String>> expected = EntryStream
+                    .of("a", asList("bb"), "b", asList("ee"), "c", asList("gg")).toMap();
+            Collector<Entry<String, List<String>>, ?, List<String>> headOne = MoreCollectors.flatMapping(valuesStream,
+                MoreCollectors.head(1));
+            checkCollector("flatMappingSubShort", expected, list::stream, Collectors.groupingBy(Entry::getKey, headOne));
+            checkShortCircuitCollector("flatMappingShort", expected, 4, list::stream, MoreCollectors.groupingBy(
+                Entry::getKey, StreamEx.of("a", "b", "c").toSet(), headOne));
+            AtomicInteger cnt = new AtomicInteger();
+            Collector<Entry<String, List<String>>, ?, List<String>> headPeek = MoreCollectors.flatMapping(valuesStream
+                    .andThen(s -> s == null ? null : s.peek(x -> cnt.incrementAndGet())), MoreCollectors.head(1));
+            assertEquals(expected, StreamEx.of(list).collect(Collectors.groupingBy(Entry::getKey, headPeek)));
+            assertEquals(3, cnt.get());
+            cnt.set(0);
+            assertEquals(expected, StreamEx.of(list).collect(
+                MoreCollectors.groupingBy(Entry::getKey, StreamEx.of("a", "b", "c").toSet(), headPeek)));
+            assertEquals(3, cnt.get());
+        }
+        {
+            Map<String, List<String>> expected = EntryStream.of("a", asList("bb", "cc"), "b", asList("ee", "ff"), "c",
+                asList("gg")).toMap();
+            Collector<Entry<String, List<String>>, ?, List<String>> headTwo = MoreCollectors.flatMapping(valuesStream,
+                MoreCollectors.head(2));
+            checkCollector("flatMappingSubShort", expected, list::stream, Collectors.groupingBy(Entry::getKey, headTwo));
+            AtomicInteger openClose = new AtomicInteger();
+            boolean catched = false;
+            try {
+                Collector<Entry<String, List<String>>, ?, Map<String, List<String>>> groupingByException = Collectors
+                        .groupingBy(Entry::getKey, MoreCollectors.flatMapping(valuesStream.andThen(s -> {
+                            if (s == null)
+                                return null;
+                            openClose.incrementAndGet();
+                            return s.onClose(openClose::decrementAndGet).peek(e -> {
+                                if (e.equals("gg"))
+                                    throw new IllegalArgumentException(e);
+                            });
+                        }), MoreCollectors.head(2)));
+                list.stream().collect(MoreCollectors.collectingAndThen(groupingByException, res -> {
+                    assertEquals(0, openClose.get());
+                    return res;
+                }));
+            } catch (IllegalArgumentException e1) {
+                assertEquals("gg", e1.getMessage());
+                catched = true;
+            }
+            assertTrue(catched);
+        }
+        checkCollector("flatMapping-toList", asList(0, 1, 2, 3, 0, 1, 2, 0, 1, 2, 3, 4), asList(4, 3, 5)::stream,
+            MoreCollectors.flatMapping(x -> IntStreamEx.range(x).boxed()));
+    }
+
+    @Test(expected = IllegalStateException.class)
+    public void testFlatMappingExceptional() {
+        Stream.of(1, 2, 3).collect(MoreCollectors.flatMapping(x -> Stream.of(1, x).onClose(() -> {
+            if (x == 3)
+                throw new IllegalStateException();
+        }), Collectors.toList()));
+    }
+
+    @Test(expected = IllegalStateException.class)
+    public void testFlatMappingShortCircuitExceptional() {
+        Stream.of(1, 2, 3).collect(MoreCollectors.flatMapping(x -> Stream.of(1, x).onClose(() -> {
+            if (x == 3)
+                throw new IllegalStateException();
+        }), MoreCollectors.head(10)));
+    }
+
+    @Test
+    public void testFlatMappingExceptionalSuppressed() {
+        List<Collector<Integer, ?, List<Integer>>> downstreams = asList(MoreCollectors.head(10), Collectors.toList());
+        for (Collector<Integer, ?, List<Integer>> downstream : downstreams) {
+            try {
+                Stream.of(1, 2, 3).collect(MoreCollectors.flatMapping(x -> Stream.of(1, x).peek(y -> {
+                    throw new IllegalArgumentException();
+                }).onClose(() -> {
+                    throw new IllegalStateException();
+                }), downstream));
+            } catch (Exception e) {
+                assertTrue(e instanceof IllegalArgumentException);
+                assertTrue(e.getSuppressed()[0] instanceof IllegalStateException);
+                continue;
+            }
+            fail("No exception");
+        }
+    }
+
+    @Test
+    public void testCommonPrefix() {
+        checkCollectorEmpty("prefix", "", MoreCollectors.commonPrefix());
+        List<String> input = asList("abcdef", "abcdefg", "abcdfgfg", "abcefgh", "abcdfg");
+        checkShortCircuitCollector("prefix", "abc", input.size(), input::stream, MoreCollectors.commonPrefix());
+        List<CharSequence> inputSeq = asList(new StringBuffer("abcdef"), "abcdefg", "abcdfgfg", "abcefgh",
+            new StringBuilder("abcdfg"));
+        checkShortCircuitCollector("prefix", "abc", inputSeq.size(), inputSeq::stream, MoreCollectors.commonPrefix());
+        List<String> input2 = asList("abcdef", "abcdefg", "dabcdfgfg", "abcefgh", "abcdfg");
+        checkShortCircuitCollector("prefix", "", 3, input2::stream, MoreCollectors.commonPrefix());
+        List<String> inputHalf = new ArrayList<>();
+        inputHalf.addAll(Collections.nCopies(1000, "abc"));
+        inputHalf.addAll(Collections.nCopies(1000, "def"));
+        checkShortCircuitCollector("prefix", "", 1001, inputHalf::stream, MoreCollectors.commonPrefix());
+        List<String> inputSurrogate = asList("abc\ud801\udc2f", "abc\ud801\udc2f", "abc\ud801\udc14");
+        checkShortCircuitCollector("prefix", "abc", inputSurrogate.size(), inputSurrogate::stream, MoreCollectors
+                .commonPrefix());
+        List<String> inputSurrogateBad = asList("abc\ud801x", "abc\ud801y", "abc\ud801z");
+        checkShortCircuitCollector("prefix", "abc\ud801", inputSurrogateBad.size(), inputSurrogateBad::stream,
+            MoreCollectors.commonPrefix());
+        List<String> inputSurrogateMix = asList("abc\ud801\udc2f", "abc\ud801x", "abc\ud801\udc14");
+        checkShortCircuitCollector("prefix", "abc", inputSurrogateMix.size(), inputSurrogateMix::stream, MoreCollectors
+                .commonPrefix());
+    }
+
+    @Test
+    public void testCommonSuffix() {
+        checkCollectorEmpty("suffix", "", MoreCollectors.commonSuffix());
+        List<String> input = asList("defabc", "degfabc", "dfgfgabc", "efghabc", "dfgabc");
+        checkShortCircuitCollector("suffix", "abc", input.size(), input::stream, MoreCollectors.commonSuffix());
+        List<CharSequence> inputSeq = asList(new StringBuffer("degfabc"), "dfgfgabc", new StringBuilder("efghabc"),
+            "defabc", "dfgabc");
+        checkShortCircuitCollector("suffix", "abc", inputSeq.size(), inputSeq::stream, MoreCollectors.commonSuffix());
+        List<String> input2 = asList("defabc", "defgabc", "dabcdfgfg", "efghabc", "dfgabc");
+        checkShortCircuitCollector("suffix", "", 3, input2::stream, MoreCollectors.commonSuffix());
+        List<String> inputHalf = new ArrayList<>();
+        inputHalf.addAll(Collections.nCopies(1000, "abc"));
+        inputHalf.addAll(Collections.nCopies(1000, "def"));
+        checkShortCircuitCollector("suffix", "", 1001, inputHalf::stream, MoreCollectors.commonSuffix());
+        List<String> inputSurrogate = asList("\ud801\udc2fabc", "\ud802\udc2fabc", "\ud803\udc2fabc");
+        checkShortCircuitCollector("suffix", "abc", inputSurrogate.size(), inputSurrogate::stream, MoreCollectors
+                .commonSuffix());
+        List<String> inputSurrogateBad = asList("x\udc2fabc", "y\udc2fabc", "z\udc2fabc");
+        checkShortCircuitCollector("suffix", "\udc2fabc", inputSurrogateBad.size(), inputSurrogateBad::stream,
+            MoreCollectors.commonSuffix());
+        List<String> inputSurrogateMix = asList("\ud801\udc2fabc", "x\udc2fabc", "\ud801\udc14abc");
+        checkShortCircuitCollector("suffix", "abc", inputSurrogateMix.size(), inputSurrogateMix::stream, MoreCollectors
+                .commonSuffix());
+    }
+
+    @Test
+    public void testDominators() {
+        assertThrows(NullPointerException.class, () -> MoreCollectors.dominators(null));
+        List<String> input = asList("a/", "a/b/c/", "b/c/", "b/d/", "c/a/", "d/a/b/", "c/a/b/", "c/b/", "b/c/d/");
+        List<String> expected = asList("a/", "b/c/", "b/d/", "c/a/", "c/b/", "d/a/b/");
+        checkCollector("dominators", expected, () -> input.stream().sorted(), MoreCollectors.dominators((a, b) -> b
+                .startsWith(a)));
+
+        withRandom(r -> {
+            List<String> longInput = StreamEx.generate(
+                () -> IntStreamEx.of(r, r.nextInt(10) + 3, 'a', 'z').mapToObj(ch -> (char) ch).joining("/", "", "/"))
+                    .limit(1000).toList();
+
+            List<String> tmp = StreamEx.of(longInput).sorted().toList();
+            List<String> result = new ArrayList<>();
+            String curr, last;
+            curr = last = null;
+            for (String next : tmp) {
+                String oldLast = last;
+                last = curr;
+                curr = next;
+                if (last != null && curr.startsWith(last)) {
+                    curr = last;
+                    last = oldLast;
+                } else
+                    result.add(curr);
+            }
+            checkCollector("dominatorsLong", result, () -> longInput.stream().sorted(), MoreCollectors
+                    .dominators((a, b) -> b.startsWith(a)));
+        });
+    }
+
+    @Test
+    public void testIncreasingDominators() {
+        int[] input = { 1, 3, 4, 2, 1, 7, 5, 3, 4, 0, 4, 6, 7, 10, 4, 3, 2, 1 };
+        List<Integer> result = asList(1, 3, 4, 7, 10);
+        checkCollector("increasing", result, () -> IntStreamEx.of(input).boxed(), MoreCollectors
+                .dominators((a, b) -> a >= b));
+        withRandom(r -> {
+            int[] longInput = r.ints(10000, 0, 1000000).toArray();
+            List<Integer> longResult = new ArrayList<>();
+            int curMax = -1;
+            for (int val : longInput) {
+                if (val > curMax) {
+                    curMax = val;
+                    longResult.add(curMax);
+                }
+            }
+            checkCollector("increasingLong", longResult, () -> IntStreamEx.of(longInput).boxed(), MoreCollectors
+                    .dominators((a, b) -> a >= b));
+        });
+    }
+    
+    @Test
+    public void testMinMax() {
+        assertThrows(NullPointerException.class, () -> MoreCollectors.minMax(null, String::concat));
+        assertThrows(NullPointerException.class, () -> MoreCollectors.minMax(Comparator.naturalOrder(), null));
+        List<String> input = asList("abc", "a", "asdf", "gdasa", "gffsd", "sfgs", "b", "c", "dsgs");
+        checkCollector("minMax", Optional.of("agdasa"), input::stream, MoreCollectors.minMax(Comparator
+                .comparingInt(String::length), String::concat));
+        Collector<String, ?, Optional<Object>> collector = MoreCollectors.minMax(Comparator.naturalOrder(),
+            (min, max) -> {
+                throw new IllegalStateException("Should not be called");
+            });
+        checkCollectorEmpty("minMax", Optional.empty(), collector);
+    }
+
+    @Test
+    public void testIfAllMatch() {
+        assertThrows(NullPointerException.class, () -> MoreCollectors.ifAllMatch(null, Collectors.toList()));
+        assertThrows(NullPointerException.class, () -> MoreCollectors.ifAllMatch(i -> true, null));
+        Supplier<Stream<Integer>> five = () -> IntStreamEx.range(5).boxed();
+        checkShortCircuitCollector("ifAllMatch: all match", Optional.of(asList(0, 1, 2, 3, 4)), 5, five,
+                MoreCollectors.ifAllMatch(i -> true, Collectors.toList()));
+
+        Supplier<Stream<Integer>> ints = () -> IntStreamEx.ints().boxed();
+        checkShortCircuitCollector("ifAllMatch: shirtCircuit downstream", Optional.of(asList(0, 1, 2)), 3, ints,
+                MoreCollectors.ifAllMatch(i -> true, MoreCollectors.head(3)), true);
+
+        checkShortCircuitCollector("ifAllMatch: some match", Optional.empty(), 11, ints,
+                MoreCollectors.ifAllMatch(i -> i < 10, Collectors.toList()), true);
+
+        checkShortCircuitCollector("ifAllMatch: empty stream", Optional.of(Collections.emptyList()), 0, Stream::empty,
+                MoreCollectors.ifAllMatch(i -> true, Collectors.toList()));
+    }
+    
+    @Test
+    public void testReducingWithZero() {
+        Collector<Integer, ?, Optional<Integer>> multiplication = MoreCollectors.reducingWithZero(0, (a, b) -> a * b);
+        checkShortCircuitCollector("reducingWithZero: multiply", Optional.of(0), 4,
+            () -> StreamEx.of(3, 5, 10, 0, 1, 4), multiplication);
+        checkShortCircuitCollector("reducingWithZero: multiply", Optional.of(1200), 6,
+            () -> StreamEx.of(3, 5, 10, 2, 1, 4), multiplication);
+        checkShortCircuitCollector("reducingWithZero: multiply", Optional.empty(), 0,
+            StreamEx::empty, multiplication);
+        checkShortCircuitCollector("reducingWithZero: multiply", Optional.of(0), 32,
+            () -> StreamEx.constant(2, 64), multiplication);
+    }
+    
+    @Test
+    public void testReducingWithZeroAndIdentity() {
+        Collector<Integer, ?, Integer> multiplication = MoreCollectors.reducingWithZero(0, 1, (a, b) -> a * b);
+        checkShortCircuitCollector("reducingWithZero: multiply", 0, 4,
+            () -> StreamEx.of(3, 5, 10, 0, 1, 4), multiplication);
+        checkShortCircuitCollector("reducingWithZero: multiply", 1200, 6,
+            () -> StreamEx.of(3, 5, 10, 2, 1, 4), multiplication);
+        checkShortCircuitCollector("reducingWithZero: multiply", 1, 0,
+            StreamEx::empty, multiplication);
+        checkShortCircuitCollector("reducingWithZero: multiply", 0, 32,
+            () -> StreamEx.constant(2, 64), multiplication);
+    }
+}
