diff --git a/src/main/java/one/util/streamex/AbstractStreamEx.java b/src/main/java/one/util/streamex/AbstractStreamEx.java
index 10c5b1e..d1caa1c 100644
--- a/src/main/java/one/util/streamex/AbstractStreamEx.java
+++ b/src/main/java/one/util/streamex/AbstractStreamEx.java
@@ -30,17 +30,7 @@ import java.util.Set;
 import java.util.Spliterator;
 import java.util.Spliterators;
 import java.util.concurrent.ForkJoinPool;
-import java.util.function.BiConsumer;
-import java.util.function.BiFunction;
-import java.util.function.BinaryOperator;
-import java.util.function.Consumer;
-import java.util.function.Function;
-import java.util.function.IntFunction;
-import java.util.function.Predicate;
-import java.util.function.Supplier;
-import java.util.function.ToDoubleFunction;
-import java.util.function.ToIntFunction;
-import java.util.function.ToLongFunction;
+import java.util.function.*;
 import java.util.stream.Collector;
 import java.util.stream.Collector.Characteristics;
 import java.util.stream.Collectors;
@@ -205,6 +195,83 @@ public abstract class AbstractStreamEx<T, S extends AbstractStreamEx<T, S>> exte
         return new StreamEx<>(stream().flatMap(mapper), context);
     }
 
+    /**
+     * Returns a stream where every element of this stream is replaced by elements produced
+     * by a mapper function.
+     *
+     * <p>This is an <a href="package-summary.html#StreamOps">intermediate
+     * operation</a>.
+     *
+     * @param mapper a <a href="package-summary.html#NonInterference">non-interfering</a>,
+     *               <a href="package-summary.html#Statelessness">stateless</a>
+     *               function that generates replacement elements. It accepts an element of this
+     *               stream and a consumer that accepts new elements produced from the input element.
+     * @return the new stream
+     * @param <R> type of the resulting elements
+     * @since 0.8.3
+     */
+    public <R> StreamEx<R> mapMulti(BiConsumer<? super T, ? super Consumer<R>> mapper) {
+        Objects.requireNonNull(mapper);
+        return VerSpec.VER_SPEC.callMapMulti(this, mapper);
+    }
+
+    /**
+     * Returns an {@link IntStreamEx} where every element of this stream is replaced by elements produced
+     * by a mapper function.
+     *
+     * <p>This is an <a href="package-summary.html#StreamOps">intermediate
+     * operation</a>.
+     *
+     * @param mapper a <a href="package-summary.html#NonInterference">non-interfering</a>,
+     *               <a href="package-summary.html#Statelessness">stateless</a>
+     *               function that generates replacement elements. It accepts an element of this
+     *               stream and a consumer that accepts new elements produced from the input element.
+     * @return the new stream
+     * @since 0.8.3
+     */
+    public IntStreamEx mapMultiToInt(BiConsumer<? super T, ? super IntConsumer> mapper) {
+        Objects.requireNonNull(mapper);
+        return VerSpec.VER_SPEC.callMapMultiToInt(this, mapper);
+    }
+
+    /**
+     * Returns a {@link LongStreamEx} where every element of this stream is replaced by elements produced
+     * by a mapper function.
+     *
+     * <p>This is an <a href="package-summary.html#StreamOps">intermediate
+     * operation</a>.
+     *
+     * @param mapper a <a href="package-summary.html#NonInterference">non-interfering</a>,
+     *               <a href="package-summary.html#Statelessness">stateless</a>
+     *               function that generates replacement elements. It accepts an element of this
+     *               stream and a consumer that accepts new elements produced from the input element.
+     * @return the new stream
+     * @since 0.8.3
+     */
+    public LongStreamEx mapMultiToLong(BiConsumer<? super T, ? super LongConsumer> mapper) {
+        Objects.requireNonNull(mapper);
+        return VerSpec.VER_SPEC.callMapMultiToLong(this, mapper);
+    }
+
+    /**
+     * Returns a {@link DoubleStreamEx} where every element of this stream is replaced by elements produced
+     * by a mapper function.
+     *
+     * <p>This is an <a href="package-summary.html#StreamOps">intermediate
+     * operation</a>.
+     *
+     * @param mapper a <a href="package-summary.html#NonInterference">non-interfering</a>,
+     *               <a href="package-summary.html#Statelessness">stateless</a>
+     *               function that generates replacement elements. It accepts an element of this
+     *               stream and a consumer that accepts new elements produced from the input element.
+     * @return the new stream
+     * @since 0.8.3
+     */
+    public DoubleStreamEx mapMultiToDouble(BiConsumer<? super T, ? super DoubleConsumer> mapper) {
+        Objects.requireNonNull(mapper);
+        return VerSpec.VER_SPEC.callMapMultiToDouble(this, mapper);
+    }
+
     @Override
     public <R> StreamEx<R> map(Function<? super T, ? extends R> mapper) {
         return new StreamEx<>(stream().map(mapper), context);
diff --git a/src/main/java/one/util/streamex/Internals.java b/src/main/java/one/util/streamex/Internals.java
index 0488b91..0ad0e55 100644
--- a/src/main/java/one/util/streamex/Internals.java
+++ b/src/main/java/one/util/streamex/Internals.java
@@ -244,6 +244,10 @@ import java.util.stream.Collector.Characteristics;
             System.arraycopy(buf.data, 0, data, size, buf.size);
             size += buf.size;
         }
+        
+        IntStreamEx stream() {
+            return IntStreamEx.of(data, 0, size);
+        }
 
         int[] toArray() {
             return data.length == size ? data : Arrays.copyOfRange(data, 0, size);
@@ -277,6 +281,10 @@ import java.util.stream.Collector.Characteristics;
             size += buf.size;
         }
 
+        LongStreamEx stream() {
+            return LongStreamEx.of(data, 0, size);
+        }
+
         long[] toArray() {
             return data.length == size ? data : Arrays.copyOfRange(data, 0, size);
         }
@@ -309,6 +317,10 @@ import java.util.stream.Collector.Characteristics;
             size += buf.size;
         }
 
+        DoubleStreamEx stream() {
+            return DoubleStreamEx.of(data, 0, size);
+        }
+
         double[] toArray() {
             return data.length == size ? data : Arrays.copyOfRange(data, 0, size);
         }
diff --git a/src/main/java/one/util/streamex/VersionSpecific.java b/src/main/java/one/util/streamex/VersionSpecific.java
index b027a69..d111e8c 100644
--- a/src/main/java/one/util/streamex/VersionSpecific.java
+++ b/src/main/java/one/util/streamex/VersionSpecific.java
@@ -16,11 +16,10 @@
 package one.util.streamex;
 
 import java.nio.CharBuffer;
+import java.util.ArrayList;
+import java.util.List;
 import java.util.Spliterator;
-import java.util.function.DoublePredicate;
-import java.util.function.IntPredicate;
-import java.util.function.LongPredicate;
-import java.util.function.Predicate;
+import java.util.function.*;
 import java.util.stream.IntStream;
 
 /**
@@ -47,6 +46,38 @@ import java.util.stream.IntStream;
         return stream.delegate(new TakeDrop.TDOfDouble(stream.spliterator(), drop, false, predicate));
     }
 
+    <T, R> StreamEx<R> callMapMulti(AbstractStreamEx<T, ?> s, BiConsumer<? super T, ? super Consumer<R>> mapper) {
+        return s.flatCollection(e -> {
+            List<R> result = new ArrayList<>();
+            mapper.accept(e, (Consumer<R>) result::add);
+            return result;
+        });
+    }
+
+    <T> IntStreamEx callMapMultiToInt(AbstractStreamEx<T, ?> s, BiConsumer<? super T, ? super IntConsumer> mapper) {
+        return s.flatMapToInt(e -> {
+            Internals.IntBuffer result = new Internals.IntBuffer();
+            mapper.accept(e, (IntConsumer) result::add);
+            return result.stream();
+        });
+    }
+    
+    <T> LongStreamEx callMapMultiToLong(AbstractStreamEx<T, ?> s, BiConsumer<? super T, ? super LongConsumer> mapper) {
+        return s.flatMapToLong(e -> {
+            Internals.LongBuffer result = new Internals.LongBuffer();
+            mapper.accept(e, (LongConsumer) result::add);
+            return result.stream();
+        });
+    }
+
+    <T> DoubleStreamEx callMapMultiToDouble(AbstractStreamEx<T, ?> s, BiConsumer<? super T, ? super DoubleConsumer> mapper) {
+        return s.flatMapToDouble(e -> {
+            Internals.DoubleBuffer result = new Internals.DoubleBuffer();
+            mapper.accept(e, (DoubleConsumer) result::add);
+            return result.stream();
+        });
+    }
+    
     IntStream ofChars(CharSequence seq) {
         // In JDK 8 there's only default chars() method which uses
         // IteratorSpliterator
diff --git a/src/test/java/one/util/streamex/api/StreamExApiTest.java b/src/test/java/one/util/streamex/api/StreamExApiTest.java
index 5bc5912..eb84fa1 100644
--- a/src/test/java/one/util/streamex/api/StreamExApiTest.java
+++ b/src/test/java/one/util/streamex/api/StreamExApiTest.java
@@ -24,6 +24,7 @@ import org.junit.Test;
 import one.util.streamex.StreamEx;
 
 import static java.util.Arrays.asList;
+import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 
 /**
@@ -48,4 +49,37 @@ public class StreamExApiTest {
         List<String> expected = asList("c", "b", "a");
         assertEquals(expected, input.stream().map(StreamEx::of).reduce(StreamEx::prepend).get().toList());
     }
+    
+    @Test
+    public void testMapMulti() {
+        List<String> result = StreamEx.of("abc", "def", "gh")
+                .<String>mapMulti((s, cons) -> s.chars()
+                        .mapToObj(ch -> ""+(char)ch).forEach(cons))
+                .toList();
+        assertEquals(asList("a", "b", "c", "d", "e", "f", "g", "h"), result);
+    }
+    
+    @Test
+    public void testMapMultiToInt() {
+        int[] result = StreamEx.of("abc", "def", "gh")
+                .mapMultiToInt((s, cons) -> s.chars().forEach(cons))
+                .toArray();
+        assertArrayEquals(new int[] {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'}, result);
+    }
+    
+    @Test
+    public void testMapMultiToLong() {
+        long[] result = StreamEx.of("abc", "def", "gh")
+                .mapMultiToLong((s, cons) -> s.chars().asLongStream().forEach(cons))
+                .toArray();
+        assertArrayEquals(new long[] {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'}, result);
+    }
+    
+    @Test
+    public void testMapMultiToDouble() {
+        double[] result = StreamEx.of("abc", "def", "gh")
+                .mapMultiToDouble((s, cons) -> s.chars().asDoubleStream().forEach(cons))
+                .toArray();
+        assertArrayEquals(new double[] {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'}, result, 0.0);
+    }
 }
