diff --git a/CHANGES.md b/CHANGES.md
index e458df0..6f08e05 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -5,6 +5,7 @@ Check also [MIGRATION.md](MIGRATION.md) for possible compatibility problems.
 ### 0.6.2
 
 * [#104] Added: `StreamEx.ofReversed()`.
+* [#105] Added: `MoreCollectors.minMax()`.
 
 ### 0.6.1
 
diff --git a/CHEATSHEET.md b/CHEATSHEET.md
index 5012a84..73200ae 100644
--- a/CHEATSHEET.md
+++ b/CHEATSHEET.md
@@ -256,6 +256,7 @@ Get the given number of first or last elements in the `List` | `MoreCollectors.h
 Get the given number of greatest/least elements according to the given `Comparator` or natural order | `MoreCollectors.greatest()/least()`
 Get all the maximal or minimal elements according to the given `Comparator` or natural order | `MoreCollectors.maxAll()/minAll()`
 Get the index of maximal or minimal element according to the given `Comparator` or natural order | `MoreCollectors.minIndex()/maxIndex()`
+Get both maximal and minimal stream element according to the given `Comparator` | `MoreCollectors.minMax()`
 Get the intersection of input collections | `MoreCollectors.intersecting()`
 Get the result bitwise-and operation | `MoreCollectors.andingInt()/andingLong()`
 Join the elements into string with possible limit to the string length (adding ellipsis if necessary) | `Joining.with()`
diff --git a/src/main/java/one/util/streamex/MoreCollectors.java b/src/main/java/one/util/streamex/MoreCollectors.java
index 3dfe09f..b292bce 100644
--- a/src/main/java/one/util/streamex/MoreCollectors.java
+++ b/src/main/java/one/util/streamex/MoreCollectors.java
@@ -274,6 +274,33 @@ public final class MoreCollectors {
         return Collector.of(supplier, accumulator, combiner, resFinisher, c.toArray(new Characteristics[0]));
     }
 
+    /**
+     * Returns a {@code Collector} which finds the minimal and maximal element
+     * according to the supplied comparator, then applies finisher function to
+     * them producing the final result.
+     * 
+     * <p>
+     * This collector produces stable result for ordered stream: if several
+     * minimal or maximal elements appear, the collector always selects the
+     * first encountered.
+     * 
+     * <p>
+     * If there are no input elements, the finisher method is not called and
+     * empty {@code Optional} is returned. Otherwise the finisher result is
+     * wrapped into {@code Optional}.
+     * 
+     * @param comparator comparator which is used to find minimal and maximal
+     *        element
+     * @param finisher a {@link BiFunction} which takes minimal and maximal
+     *        element and produces the final result.
+     * @return a {@code Collector} which finds minimal and maximal elements.
+     */
+    public static <T, R> Collector<T, ?, Optional<R>> minMax(Comparator<? super T> comparator,
+            BiFunction<? super T, ? super T, ? extends R> finisher) {
+        return pairing(Collectors.minBy(comparator), Collectors.maxBy(comparator),
+            (min, max) -> min.isPresent() ? Optional.of(finisher.apply(min.get(), max.get())) : Optional.empty());
+    }
+
     /**
      * Returns a {@code Collector} which finds all the elements which are equal
      * to each other and bigger than any other element according to the
diff --git a/src/test/java/one/util/streamex/MoreCollectorsTest.java b/src/test/java/one/util/streamex/MoreCollectorsTest.java
index 6987ce6..c092924 100644
--- a/src/test/java/one/util/streamex/MoreCollectorsTest.java
+++ b/src/test/java/one/util/streamex/MoreCollectorsTest.java
@@ -748,4 +748,14 @@ public class MoreCollectorsTest {
                     .dominators((a, b) -> a >= b));
         });
     }
+    
+    @Test
+    public void testMinMax() {
+        List<String> input = asList("abc", "a", "asdf", "gdasa", "gffsd", "sfgs", "b", "c", "dsgs");
+        checkCollector("minMax", Optional.of("agdasa"), input::stream, MoreCollectors.minMax(Comparator
+                .comparingInt(String::length), String::concat));
+        checkCollectorEmpty("minMax", Optional.empty(), MoreCollectors.minMax(Comparator.naturalOrder(), (min, max) -> {
+            throw new IllegalStateException("Should not be called");
+        }));
+    }
 }
