diff --git a/src/test/java/one/util/streamex/EntryStreamTest.java b/src/test/java/one/util/streamex/EntryStreamTest.java
index 431c00c..f834851 100644
--- a/src/test/java/one/util/streamex/EntryStreamTest.java
+++ b/src/test/java/one/util/streamex/EntryStreamTest.java
@@ -508,8 +508,19 @@ public class EntryStreamTest {
             null,
             Arrays.asList(Arrays.asList("bbbb", "cc", null, Arrays.asList()), "ddd", Arrays.asList("e"),
                 Arrays.asList("fff")), "ggg");
-        EntryStream<Integer, Object> ofTree = EntryStream.ofTree(input, List.class, (depth, l) -> l.stream());
-        assertEquals("{1=[aa, ggg], 2=[ddd], 3=[bbbb, cc, e, fff]}",
-            ofTree.selectValues(String.class).grouping(TreeMap::new).toString());
+        Supplier<Stream<Entry<Integer, Object>>> base = () -> EntryStream.ofTree(input, List.class, (depth, l) -> l.stream());
+        for(EntryStreamSupplier<Integer, Object> supplier : entryStream(base)) {
+            assertEquals("{1=[aa, ggg], 2=[ddd], 3=[bbbb, cc, e, fff]}", supplier.get().selectValues(String.class)
+                    .grouping(TreeMap::new).toString());
+        }
+        
+        for (EntryStreamSupplier<Integer, String> supplier : entryStream(() -> EntryStream.ofTree("",
+            (depth, str) -> depth >= 3 ? null : Stream.of("a", "b").map(str::concat)))) {
+            assertEquals(Arrays.asList("", "a", "aa", "aaa", "aab", "ab", "aba", "abb", "b", "ba", "baa", "bab", "bb",
+                "bba", "bbb"), supplier.get().values().toList());
+            assertEquals(
+                Arrays.asList("a", "b", "aa", "ab", "ba", "bb", "aaa", "aab", "aba", "abb", "baa", "bab", "bba", "bbb"),
+                supplier.get().sorted(Entry.comparingByKey()).values().without("").toList());
+        }
     }
 }
diff --git a/src/test/java/one/util/streamex/TestHelpers.java b/src/test/java/one/util/streamex/TestHelpers.java
index 0495de6..7007e44 100644
--- a/src/test/java/one/util/streamex/TestHelpers.java
+++ b/src/test/java/one/util/streamex/TestHelpers.java
@@ -23,6 +23,7 @@ import java.util.Arrays;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.List;
+import java.util.Map;
 import java.util.Objects;
 import java.util.Random;
 import java.util.Spliterator;
@@ -49,22 +50,22 @@ public class TestHelpers {
         NORMAL, PARALLEL, APPEND, PREPEND, RANDOM
     }
 
-    static class StreamExSupplier<T> {
+    static class StreamSupplier<T> {
         private final Mode mode;
         private final Supplier<Stream<T>> base;
 
-        public StreamExSupplier(Supplier<Stream<T>> base, Mode mode) {
+        public StreamSupplier(Supplier<Stream<T>> base, Mode mode) {
             this.base = base;
             this.mode = mode;
         }
 
-        public StreamEx<T> get() {
+        public Stream<T> get() {
             Stream<T> res = base.get();
             switch (mode) {
             case NORMAL:
-                return StreamEx.of(res.sequential());
+                return res.sequential();
             case PARALLEL:
-                return StreamEx.of(res.parallel());
+                return res.parallel();
             case APPEND:
                 // using Stream.empty() here makes the resulting stream
                 // unordered which is undesired
@@ -84,11 +85,40 @@ public class TestHelpers {
         }
     }
 
+    static class StreamExSupplier<T> extends StreamSupplier<T> {
+        
+        public StreamExSupplier(Supplier<Stream<T>> base, Mode mode) {
+            super(base, mode);
+        }
+        
+        @Override
+        public StreamEx<T> get() {
+            return StreamEx.of(super.get());
+        }
+    }
+    
+    static class EntryStreamSupplier<K, V> extends StreamSupplier<Map.Entry<K, V>> {
+        
+        public EntryStreamSupplier(Supplier<Stream<Map.Entry<K, V>>> base, Mode mode) {
+            super(base, mode);
+        }
+        
+        @Override
+        public EntryStream<K, V> get() {
+            return EntryStream.of(super.get());
+        }
+    }
+    
     static <T> List<StreamExSupplier<T>> streamEx(Supplier<Stream<T>> base) {
         return StreamEx.of(Mode.values())
                 .map(mode -> new StreamExSupplier<>(base, mode)).toList();
     }
     
+    static <K, V> List<EntryStreamSupplier<K, V>> entryStream(Supplier<Stream<Map.Entry<K, V>>> base) {
+        return StreamEx.of(Mode.values())
+                .map(mode -> new EntryStreamSupplier<>(base, mode)).toList();
+    }
+    
     /**
      * Spliterator which randomly inserts empty spliterators on splitting
      * 
