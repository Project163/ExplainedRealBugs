{"url":"https://api.github.com/repos/amaembo/streamex/issues/61","repository_url":"https://api.github.com/repos/amaembo/streamex","labels_url":"https://api.github.com/repos/amaembo/streamex/issues/61/labels{/name}","comments_url":"https://api.github.com/repos/amaembo/streamex/issues/61/comments","events_url":"https://api.github.com/repos/amaembo/streamex/issues/61/events","html_url":"https://github.com/amaembo/streamex/issues/61","id":129322288,"node_id":"MDU6SXNzdWUxMjkzMjIyODg=","number":61,"title":"New method skipSorted(n) in StreamEx ","user":{"login":"amaembo","id":5114450,"node_id":"MDQ6VXNlcjUxMTQ0NTA=","avatar_url":"https://avatars.githubusercontent.com/u/5114450?v=4","gravatar_id":"","url":"https://api.github.com/users/amaembo","html_url":"https://github.com/amaembo","followers_url":"https://api.github.com/users/amaembo/followers","following_url":"https://api.github.com/users/amaembo/following{/other_user}","gists_url":"https://api.github.com/users/amaembo/gists{/gist_id}","starred_url":"https://api.github.com/users/amaembo/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/amaembo/subscriptions","organizations_url":"https://api.github.com/users/amaembo/orgs","repos_url":"https://api.github.com/users/amaembo/repos","events_url":"https://api.github.com/users/amaembo/events{/privacy}","received_events_url":"https://api.github.com/users/amaembo/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":198134866,"node_id":"MDU6TGFiZWwxOTgxMzQ4NjY=","url":"https://api.github.com/repos/amaembo/streamex/labels/enhancement","name":"enhancement","color":"84b6eb","default":true,"description":null}],"state":"open","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":4,"created_at":"2016-01-28T03:33:35Z","updated_at":"2016-02-09T11:27:53Z","closed_at":null,"author_association":"OWNER","active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"Requested [here](https://github.com/amaembo/amaembo.github.io/issues/1) by @AgnetaWalterscheidt:\n\nI would like to implement a new method in `StreamEx` (or `AbstractStreamEx`):\n\n```\npublic StreamEx<E> skipSorted(int n, Comparator<? super E> comparator);\n```\n\nThe method skips the first n elements of the stream as if the stream was sorted using the comparator but without actually sorting the whole stream.\nThe method is similar to `MoreCollectors.greatest(Comparator<? super T>, int)` but \n- it uses the quickselect algorithm to do the partial sort and \n- it returns a stream instead of a Collector (which makes sense because skipping n elements can still return a stream with an infinite number of elements).\n\nFor symmetry I would like to implement a second method: \n\n```\npublic StreamEx<E> limitSorted(int n, Comparator<? super E> comparator);\n```\n\nwhich is the counterpart to the first method because it limits the stream by returning only the first n elements of the stream (after \"sorting\" it like in the first method). This method obviously does not return a stream with an infinite number of elements (the stream will have n or less elements) but I think it would be confusing for the users of your library to look for the second method somewhere else.\n\nI have already implemented a method `skipSorted()` that takes and returns an `Iterator`. You find the code below including a small test method (currently called from a main method).\nI have also implemented (not included but I can send you the code if you are interested) a method `skipSorted()` using a `PriorityQueue` for sorting, and one using a `TreeSet`. The quickselect implementation is on average about factor 3 faster than the others. \n\nThe `StreamEx` method could be implemented as a small wrapper around these methods.\n\nPlease tell me if you would like me to implement this!\n\nCheers\nAgneta\n\nCode:\n\n```\n/**\n * Implementation details: a buffer of size 2*n is filled. Then this buffer is partially sorted with the quickselect algorithm\n * (see below). Then the elements from the right half of the buffer will be returned. When all these elements have been returned\n * then the buffer is filled again.\n * Additionally while filling the buffer elements are returned if they are greater than the nth smallest element seen so far. \n * \n * @param iterator        the iterator that returns the elements of which n elements are to be skipped\n * @param comparator      the comparator used for sorting\n * @param n               the number of elements to skip\n * @return                an iterator that will return the rest of the elements\n */\npublic static <E> Iterator<E> skipSorted(Iterator<E> iterator, Comparator<? super E> comparator, int n) {\n\n    Iterator<E> result = precheck(iterator, comparator, n);\n\n    if (result == null) {\n\n        @SuppressWarnings(\"unchecked\") // this is wrong the error will not be noticed (only E's inside)\n        E[] buffer = (E[]) new Object[n * 2];\n\n        E nthSmallest = iterator.next(); // when we have seen n elements this is the maximum (the nth smallest element seen so far); \n        // this means that when we see more elements we can already deliver the ones that are greater (because obviously they cannot \n        // be among the n smallest)\n\n        buffer[0] = nthSmallest; \n        int bufferIndex = 1;\n\n        while (bufferIndex < n && iterator.hasNext()) {\n            E e = iterator.next();\n            buffer[bufferIndex++] = e;\n            if (comparator.compare(e, nthSmallest) > 0) {\n                nthSmallest = e;\n            }\n        }\n\n        if (!iterator.hasNext()) { // not enough elements\n            result = iterator; \n        }\n\n        result = new SkipSortedIterator<>(iterator, n, buffer, comparator, nthSmallest);\n    }   \n\n    return result;\n}\n\nprivate static <E> Iterator<E> precheck(Iterator<E> iterator, Comparator<? super E> comparator, int n) {\n    Objects.requireNonNull(iterator);\n\n    if (n < 0) {\n        throw new IllegalArgumentException(\"n must not be negative but was: \" + n);\n    }\n\n    if (n == 0 || !iterator.hasNext()) { // nothing to do\n\n        return iterator;\n\n    } else if (n >= Integer.MAX_VALUE / 2) {\n\n        // if n is very large then sort all elements\n        Iterable<E> iterable = () -> iterator;\n        return StreamSupport.stream(iterable.spliterator(), false)\n                .sorted(comparator)\n                .skip(n)\n                .iterator();\n\n    } else {\n\n        return null;\n    }\n}\n\nprivate static class SkipSortedIterator<E> implements Iterator<E> {\n    private E toReturn; // will contain an element that can be returned without sorting the buffer\n    private int beyondBuffer; // necessary for the last run (when the iterator is done) to mark the end of the elements in the buffer\n    private int bufferIndex; // index when filling the buffer with the next elements or returning elements from the buffer\n    private boolean returningFromTheBuffer = false;\n    private E nthSmallest;\n    private final int n;\n    private final E[] buffer;\n    private final Comparator<? super E> comparator;\n    private final Random random = new Random(1);\n    private Iterator<E> iterator;\n\n    private SkipSortedIterator(Iterator<E> iterator, int n, E[] buffer, Comparator<? super E> comparator, E nthSmallest) {\n        this.iterator = iterator;\n        this.n = this.bufferIndex = n;\n        this.buffer = buffer;\n        this.comparator = comparator;\n        this.nthSmallest = nthSmallest;\n        this.beyondBuffer = buffer.length;\n    }\n\n    @Override\n    public boolean hasNext() {\n        if (toReturn != null) {\n            return true;\n        }\n        if (returningFromTheBuffer && (bufferIndex < beyondBuffer)) { // there are elements in the buffer that can be returned\n            return true;\n        }\n        while (iterator.hasNext()) {\n            E e = iterator.next();\n            if (comparator.compare(e, nthSmallest) >= 0) {\n                toReturn = e; \n                return true;\n            }\n            buffer[bufferIndex++] = e;\n            if (bufferIndex == buffer.length) {\n                // now we sort the elements of the buffer: all elements starting with the nth one will not be the n smallest elements\n                quickselect_n();\n\n                bufferIndex = n;\n                returningFromTheBuffer = true;\n                nthSmallest = buffer[n - 1];\n\n                return true;\n            }\n        }\n        // the iterator has reached its end, maybe sort again\n        if (bufferIndex > n) {\n            beyondBuffer = bufferIndex;\n            quickselect_n();\n\n            bufferIndex = n;\n            returningFromTheBuffer = true;\n\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * We are using quickselect to partially sort the buffer. Quickselect works like this: choose an arbitrary array element\n     * and iterate over all elements of the array and \n     * - leave the inspected element where it is when it is greater than or equal to the chosen value\n     * - move the inspected element to a new position at the left of the array when it is smaller than the chosen value (the \n     *   \"store index\" used will then be incremented)\n     * When all elements have been inspected then the chosen value will be put at the \"store index\" and the store index will be \n     * returned.\n     * The buffer is now partially sorted: below the \"store index\" all values are lower than the chosen value, beyond the \"store index\"\n     * all values are greater than or equal to the chosen value.\n     * Now if the \"store index\" is n then we are done. Otherwise we have to \"sort\" again but only left to the \"store index\" or only \n     * right to the \"store index\". \n     * Pseudocode for quickselect from wikipedia (pseudocode for function partition() see below):\n     * function select(list, left, right, n)\n     *    loop\n     *       if left = right\n     *          return list[left]\n     *       pivotIndex := ...     // select pivotIndex between left and right\n     *       pivotIndex := partition(list, left, right, pivotIndex)\n     *       if n = pivotIndex\n     *          return list[n]\n     *       else if n < pivotIndex\n     *          right := pivotIndex - 1\n     *       else\n     *          left := pivotIndex + 1\n     */\n    void quickselect_n() {\n        int left = 0;\n        int right = beyondBuffer - 1;\n\n        while (left < right) {\n            int pivotIndex = left + random.nextInt(right - left + 1);\n\n            int pivotNewIndex = partition(left, right, pivotIndex);\n            if (pivotNewIndex == n - 1) {\n                break;\n            } else if (n - 1 < pivotNewIndex) {\n                right = pivotNewIndex - 1;\n            } else {\n                left = pivotNewIndex + 1;\n            } \n        }\n    }\n\n    /**\n     * Pseudocode for function partition() from wikipedia:\n     * function partition(list, left, right, pivotIndex)\n     *    pivotValue := list[pivotIndex]\n     *    swap list[pivotIndex] and list[right]  // Move pivot to end\n     *    storeIndex := left\n     *    for i from left to right-1\n     *       if list[i] < pivotValue\n     *          swap list[storeIndex] and list[i]\n     *          increment storeIndex\n     *    swap list[right] and list[storeIndex]  // Move pivot to its final place\n     *    return storeIndex\n     */\n    private int partition(int left, int right, int pivotIndex) {\n        // 1. the chosen value is the one at the pivotIndex\n        E pivotValue = buffer[pivotIndex];\n\n        // 2. the buffer elemnt at the pivotIndex is set to the value of the rightmost array element (this way the rightmost element does not need\n        //    to be inspected\n        buffer[pivotIndex] = buffer[right];\n\n        // 3. iterate from left to right and keep the value where it is if it is smaller than the chosen value\n        int storeIndex = left;\n        int i = left;\n        for (; i < right; i++) {\n            if (comparator.compare(buffer[i], pivotValue) < 0) {\n                storeIndex++;\n            } else {\n                break;\n            }\n        }\n        // 4. continue iterating but now move the value to the left if it is smaller than the chosen value\n        for (i++; i < right; i++) {\n            if (comparator.compare(buffer[i], pivotValue) < 0) {\n                E tmp = buffer[storeIndex];\n                buffer[storeIndex] = buffer[i];\n                buffer[i] = tmp;\n                storeIndex++;\n            }\n        }\n\n        // 5. move the chosen value to the store index\n        buffer[right] = buffer[storeIndex];\n        buffer[storeIndex] = pivotValue;\n        return storeIndex;\n    }   \n\n    @Override\n    public E next() {\n        if (hasNext()) {\n            if (returningFromTheBuffer && bufferIndex < beyondBuffer) {\n                E tmp = buffer[bufferIndex];\n                if (++bufferIndex == beyondBuffer) {\n                    bufferIndex = n;\n                    returningFromTheBuffer = false;\n                }\n                return tmp;\n            }\n            E tmp = toReturn;\n            toReturn = null;\n            return tmp;\n        } else {\n            throw new NoSuchElementException();\n        }\n    }\n}\n\n\n\n\n\n\n\n\n\npublic static void test(int k, int factor) {\n    int bufferCap = factor * k;\n    int[] values = new int[bufferCap];\n    Map<Integer, Integer> map = new TreeMap<>();\n    Random random = new Random();\n    int j = 0;\n    while (j < bufferCap) {\n        int value = random.nextInt();\n        Integer oldCount = map.put(value, 1);\n        if (oldCount != null) {\n            map.put(value, oldCount + 1);\n        }\n        values[j++] = value;\n    }\n    int value = 0;\n    int count = 0;\n    for (Entry<Integer, Integer> entry : map.entrySet()) {\n        count += entry.getValue();\n        if (count >= k) {\n            value = entry.getKey();\n            break;\n        }\n    }\n\n    Iterator<Integer> iterator = new Iterator<Integer>() {\n\n        int index = 0;\n        @Override\n        public boolean hasNext() {\n            return (index < bufferCap ? true : false);\n        }\n\n        @Override\n        public Integer next() {\n            return values[index++];\n        }\n    };\n\n    Iterator<Integer> x = skipSorted(iterator, Comparator.naturalOrder(), k);\n\n    count = 0;\n    while (x.hasNext()) {\n        Integer num = x.next();\n        count++;\n        if (num < value) {\n            throw new RuntimeException();\n        }\n    }\n    if (count != bufferCap - k) {\n        throw new RuntimeException();\n    }\n\n}\n\npublic static void main(String[] args) {\n    Random random = new Random();\n    for (int i = 0; i < 1000; i++) {\n        int k = 50 + random.nextInt(1000);\n        int size = 2 + random.nextInt(10);\n        test(k, size);\n    }\n}\n```\n","closed_by":null,"reactions":{"url":"https://api.github.com/repos/amaembo/streamex/issues/61/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/amaembo/streamex/issues/61/timeline","performed_via_github_app":null,"state_reason":null}