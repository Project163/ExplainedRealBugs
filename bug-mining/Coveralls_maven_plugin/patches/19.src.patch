diff --git a/src/main/java/org/eluder/coveralls/maven/plugin/CoverallsReportMojo.java b/src/main/java/org/eluder/coveralls/maven/plugin/CoverallsReportMojo.java
index ead5e07..717c5c6 100644
--- a/src/main/java/org/eluder/coveralls/maven/plugin/CoverallsReportMojo.java
+++ b/src/main/java/org/eluder/coveralls/maven/plugin/CoverallsReportMojo.java
@@ -60,6 +60,7 @@ import org.eluder.coveralls.maven.plugin.service.ServiceSetup;
 import org.eluder.coveralls.maven.plugin.service.Travis;
 import org.eluder.coveralls.maven.plugin.source.SourceCallback;
 import org.eluder.coveralls.maven.plugin.source.SourceLoader;
+import org.eluder.coveralls.maven.plugin.source.UniqueSourceCallback;
 import org.eluder.coveralls.maven.plugin.util.CoverageParsersFactory;
 import org.eluder.coveralls.maven.plugin.util.SourceLoaderFactory;
 
@@ -310,6 +311,7 @@ public class CoverallsReportMojo extends AbstractMojo {
             chain = coverageTracingReporter;
             reporters.add(coverageTracingReporter);
         }
+        chain = new UniqueSourceCallback(chain);
         return chain;
     }
     
diff --git a/src/main/java/org/eluder/coveralls/maven/plugin/source/UniqueSourceCallback.java b/src/main/java/org/eluder/coveralls/maven/plugin/source/UniqueSourceCallback.java
new file mode 100644
index 0000000..c64abd5
--- /dev/null
+++ b/src/main/java/org/eluder/coveralls/maven/plugin/source/UniqueSourceCallback.java
@@ -0,0 +1,49 @@
+package org.eluder.coveralls.maven.plugin.source;
+
+import java.io.IOException;
+import java.util.HashSet;
+import java.util.Set;
+
+import org.eluder.coveralls.maven.plugin.ProcessingException;
+import org.eluder.coveralls.maven.plugin.domain.Source;
+
+/**
+ * Source callback that tracks passed by source files and provides only unique
+ * source files to the delegate. Note that the implementation is not thread
+ * safe so the {@link #onSource(org.eluder.coveralls.maven.plugin.domain.Source)}
+ * can be called only from single thread concurrently.
+ */
+public class UniqueSourceCallback implements SourceCallback {
+    
+    private static final String LINES_SEPARATOR = "#";
+    
+    private final Set<String> cache = new HashSet<String>();
+    private final SourceCallback delegate;
+
+    public UniqueSourceCallback(final SourceCallback delegate) {
+        this.delegate = delegate;
+    }
+
+    @Override
+    public void onSource(final Source source) throws ProcessingException, IOException {
+        String key = getKey(source);
+        if (!cache.contains(key)) {
+            cache.add(key);
+            delegate.onSource(source);
+        }
+    }
+    
+    private String getKey(final Source source) {
+        return source.getFullName() + LINES_SEPARATOR + getRelevantLines(source);
+    }
+    
+    private int getRelevantLines(final Source source) {
+        int relevant = 0;
+        for (Integer cov : source.getCoverage()) {
+            if (cov != null) {
+                relevant++;
+            }
+        }
+        return relevant;
+    }
+}
diff --git a/src/test/java/org/eluder/coveralls/maven/plugin/source/UniqueSourceCallbackTest.java b/src/test/java/org/eluder/coveralls/maven/plugin/source/UniqueSourceCallbackTest.java
new file mode 100644
index 0000000..a94bbaf
--- /dev/null
+++ b/src/test/java/org/eluder/coveralls/maven/plugin/source/UniqueSourceCallbackTest.java
@@ -0,0 +1,62 @@
+package org.eluder.coveralls.maven.plugin.source;
+
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+
+import org.eluder.coveralls.maven.plugin.domain.Source;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.mockito.Mock;
+import org.mockito.Mockito;
+import org.mockito.runners.MockitoJUnitRunner;
+
+@RunWith(MockitoJUnitRunner.class)
+public class UniqueSourceCallbackTest {
+
+    @Mock
+    private SourceCallback sourceCallbackMock;
+    
+    @Test
+    public void testOnSourceWithUniqueSources() throws Exception {
+        Source s1 = createSource("Foo.java", "{\n  void();\n}\n", 2);
+        Source s2 = createSource("Bar.java", "{\n  bar();\n}\n", 2);
+        
+        UniqueSourceCallback cb = createUniqueSourceCallback();
+        cb.onSource(s1);
+        cb.onSource(s2);
+        verify(sourceCallbackMock, times(2)).onSource(Mockito.any(Source.class));
+    }
+
+    @Test
+    public void testOnSourceWithDuplicateSources() throws Exception {
+        Source s1 = createSource("Foo.java", "{\n  void();\n}\n", 2);
+
+        UniqueSourceCallback cb = createUniqueSourceCallback();
+        cb.onSource(s1);
+        cb.onSource(s1);
+        verify(sourceCallbackMock, times(1)).onSource(Mockito.any(Source.class));
+    }
+
+    @Test
+    public void testOnSourceWithUniqueRelevantLines() throws Exception {
+        Source s1 = createSource("Foo.java", "{\n  void();\n}\n", 2);
+        Source s2 = createSource("Foo.java", "{\n  void();\n}\n", 1, 3);
+
+        UniqueSourceCallback cb = createUniqueSourceCallback();
+        cb.onSource(s1);
+        cb.onSource(s2);
+        verify(sourceCallbackMock, times(2)).onSource(Mockito.any(Source.class));
+    }
+
+    private UniqueSourceCallback createUniqueSourceCallback() {
+        return new UniqueSourceCallback(sourceCallbackMock);
+    }
+    
+    private Source createSource(final String name, final String source, final int... relevant) {
+        Source s = new Source(name, source);
+        for (int i : relevant) {
+            s.addCoverage(i, 1);
+        }
+        return s;
+    }
+}
\ No newline at end of file
