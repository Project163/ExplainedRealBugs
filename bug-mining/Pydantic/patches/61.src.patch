diff --git a/changes/752-dmontagu.rst b/changes/752-dmontagu.rst
new file mode 100644
index 000000000..c15af682f
--- /dev/null
+++ b/changes/752-dmontagu.rst
@@ -0,0 +1 @@
+**Breaking Change:** Make ``BaseModel.json()`` only serialize the ``__root__`` key for models with custom root
diff --git a/docs/examples/custom_root_field.json b/docs/examples/custom_root_field.json
deleted file mode 100644
index 859dcefbc..000000000
--- a/docs/examples/custom_root_field.json
+++ /dev/null
@@ -1,11 +0,0 @@
-{
-  "definitions": {
-    "Pets": {
-      "title": "Pets",
-      "type": "array",
-      "items": {
-        "type": "string"
-      }
-    }
-  }
-}
\ No newline at end of file
diff --git a/docs/examples/custom_root_field.py b/docs/examples/custom_root_field.py
index eef7898ed..5e0274960 100644
--- a/docs/examples/custom_root_field.py
+++ b/docs/examples/custom_root_field.py
@@ -9,6 +9,9 @@ class Pets(BaseModel):
 print(Pets(__root__=['dog', 'cat']))
 # > Pets __root__=['dog', 'cat']
 
+print(Pets(__root__=['dog', 'cat']).json())
+# ["dog", "cat"]
+
 print(Pets.parse_obj(['dog', 'cat']))
 # > Pets __root__=['dog', 'cat']
 
@@ -17,11 +20,16 @@ print(Pets.schema())
 
 pets_schema = schema([Pets])
 print(json.dumps(pets_schema, indent=2))
-
-# {
-#  "definitions": {
-#    "Pets": {
-#      "title": "Pets",
-#      "type": "array",
-#      ...
-
+"""
+{
+  "definitions": {
+    "Pets": {
+      "title": "Pets",
+      "type": "array",
+      "items": {
+        "type": "string"
+      }
+    }
+  }
+}
+"""
diff --git a/docs/index.rst b/docs/index.rst
index 50bf7c894..385e6080a 100644
--- a/docs/index.rst
+++ b/docs/index.rst
@@ -746,6 +746,8 @@ to get validators to parse and validate the input data.
 
 (This script is complete, it should run "as is")
 
+.. _custom_root:
+
 Custom Root Types
 .................
 
@@ -753,14 +755,11 @@ Pydantic models which do not represent a ``dict`` ("object" in JSON parlance) ca
 root type defined via the ``__root__`` field. The root type can of any type: list, float, int etc.
 
 The root type can be defined via the type hint on the ``__root__`` field.
-The root value can be passed to model ``__init__`` via the ``__root__`` keyword argument or as the first and only argument
-to ``parse_obj``.
+The root value can be passed to model ``__init__`` via the ``__root__`` keyword argument or as
+the first and only argument to ``parse_obj``.
 
 .. literalinclude::  examples/custom_root_field.py
 
-Outputs:
-
-.. literalinclude:: examples/custom_root_field.json
 
 Helper Functions
 ................
@@ -1018,7 +1017,9 @@ Example:
 ``model.json(...)``
 ~~~~~~~~~~~~~~~~~~~
 
-The ``json()`` method will serialise a model to JSON, ``json()`` in turn calls ``dict()`` and serialises its result.
+The ``.json()`` method will serialise a model to JSON. Typically, ``.json()`` in turn calls ``.dict()`` and
+serialises its result. (For models with a :ref:`custom root type <custom_root>`, after calling ``.dict()``,
+only the value for the ``__root__`` key is serialised.)
 
 Serialisation can be customised on a model using the ``json_encoders`` config property, the keys should be types and
 the values should be functions which serialise that type, see the example below.
diff --git a/pydantic/main.py b/pydantic/main.py
index bf359e74c..5bea0807b 100644
--- a/pydantic/main.py
+++ b/pydantic/main.py
@@ -329,11 +329,10 @@ class BaseModel(metaclass=MetaModel):
         `encoder` is an optional function to supply as `default` to json.dumps(), other arguments as per `json.dumps()`.
         """
         encoder = cast(Callable[[Any], Any], encoder or self._json_encoder)
-        return json.dumps(
-            self.dict(include=include, exclude=exclude, by_alias=by_alias, skip_defaults=skip_defaults),
-            default=encoder,
-            **dumps_kwargs,
-        )
+        data = self.dict(include=include, exclude=exclude, by_alias=by_alias, skip_defaults=skip_defaults)
+        if self._custom_root_type:
+            data = data['__root__']
+        return json.dumps(data, default=encoder, **dumps_kwargs)
 
     @classmethod
     def parse_obj(cls: Type['Model'], obj: Any) -> 'Model':
diff --git a/tests/test_json.py b/tests/test_json.py
index b55082338..63372a7c7 100644
--- a/tests/test_json.py
+++ b/tests/test_json.py
@@ -6,6 +6,7 @@ from decimal import Decimal
 from enum import Enum
 from ipaddress import IPv4Address, IPv4Interface, IPv4Network, IPv6Address, IPv6Interface, IPv6Network
 from pathlib import Path
+from typing import List
 from uuid import UUID
 
 import pytest
@@ -159,3 +160,10 @@ def test_encode_pydantic_dataclass():
 
     f = Foo(bar=123, spam='apple pie')
     assert '{"bar": 123, "spam": "apple pie"}' == json.dumps(f, default=pydantic_encoder)
+
+
+def test_encode_custom_root():
+    class Model(BaseModel):
+        __root__: List[str]
+
+    assert Model(__root__=['a', 'b']).json() == '["a", "b"]'
