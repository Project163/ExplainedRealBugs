diff --git a/HISTORY.rst b/HISTORY.rst
index e4b799132..684436623 100644
--- a/HISTORY.rst
+++ b/HISTORY.rst
@@ -10,6 +10,8 @@ v0.17.0 (unreleased)
 * prevent duplicate validator check in ipython, fix #312 by @samuelcolvin
 * add "Using Pydantic" section to docs, #323 by @tiangolo & #326 by @samuelcolvin
 * fix schema generation for fields annotated as ``: dict``, #330 by @nkonin
+* support for passing Config class in dataclasses decorator, #276 by @jarekkar
+  (**breaking change**: this supersedes the ``validate_assignment`` argument with ``config``)
 
 v0.16.1 (2018-12-10)
 ....................
diff --git a/docs/examples/ex_dataclasses_config.py b/docs/examples/ex_dataclasses_config.py
new file mode 100644
index 000000000..bdb2e4960
--- /dev/null
+++ b/docs/examples/ex_dataclasses_config.py
@@ -0,0 +1,31 @@
+from datetime import datetime
+
+from pydantic import ValidationError
+from pydantic.dataclasses import dataclass
+
+
+class MyConfig:
+    max_anystr_length = 10
+    validate_assignment = True
+    error_msg_templates = {
+        'value_error.any_str.max_length': 'max_length:{limit_value}',
+    }
+
+
+@dataclass(config=MyConfig)
+class User:
+    id: int
+    name: str = 'John Doe'
+    signup_ts: datetime = None
+
+
+user = User(id='42', signup_ts='2032-06-21T12:00')
+try:
+    user.name = 'x' * 20
+except ValidationError as e:
+    print(e)
+"""
+1 validation error
+name
+  max_length:10 (type=value_error.any_str.max_length; limit_value=10)
+"""
diff --git a/docs/index.rst b/docs/index.rst
index 047f8311b..204a3722b 100644
--- a/docs/index.rst
+++ b/docs/index.rst
@@ -124,7 +124,7 @@ You can use all the standard pydantic field types and the resulting dataclass wi
 created by the standard library ``dataclass`` decorator.
 
 ``pydantic.dataclasses.dataclass``'s arguments are the same as the standard decorator, except one extra
-key word argument ``validate_assignment`` which has the same meaning as :ref:`Config.validate_assignment <config>`.
+key word argument ``config`` which has the same meaning as :ref:`Config <config>`.
 
 Currently validators don't work on validators, if it's something you want please create an issue on github.
 
@@ -456,6 +456,12 @@ Options:
 
 (This script is complete, it should run "as is")
 
+Version for models based on ``@dataclass`` decorator:
+
+.. literalinclude:: examples/ex_dataclasses_config.py
+
+(This script is complete, it should run "as is")
+
 .. _settings:
 
 Settings
diff --git a/pydantic/dataclasses.py b/pydantic/dataclasses.py
index 4b1e7de96..4121cd351 100644
--- a/pydantic/dataclasses.py
+++ b/pydantic/dataclasses.py
@@ -24,7 +24,7 @@ def setattr_validate_assignment(self, name, value):
     object.__setattr__(self, name, value)
 
 
-def _process_class(_cls, init, repr, eq, order, unsafe_hash, frozen, validate_assignment):
+def _process_class(_cls, init, repr, eq, order, unsafe_hash, frozen, config):
     post_init_original = getattr(_cls, '__post_init__', None)
     if post_init_original and post_init_original.__name__ == '_pydantic_post_init':
         post_init_original = None
@@ -33,17 +33,18 @@ def _process_class(_cls, init, repr, eq, order, unsafe_hash, frozen, validate_as
 
     fields = {name: (field.type, field.default) for name, field in cls.__dataclass_fields__.items()}
     cls.__post_init_original__ = post_init_original
-    cls.__pydantic_model__ = create_model(cls.__name__, **fields)
+
+    cls.__pydantic_model__ = create_model(cls.__name__, __config__=config, **fields)
+
     cls.__initialised__ = False
 
-    if validate_assignment and not frozen:
+    if cls.__pydantic_model__.__config__.validate_assignment and not frozen:
         cls.__setattr__ = setattr_validate_assignment
+
     return cls
 
 
-def dataclass(
-    _cls=None, *, init=True, repr=True, eq=True, order=False, unsafe_hash=False, frozen=False, validate_assignment=False
-):
+def dataclass(_cls=None, *, init=True, repr=True, eq=True, order=False, unsafe_hash=False, frozen=False, config=None):
     """
     Like the python standard lib dataclasses but with type validation.
 
@@ -52,7 +53,7 @@ def dataclass(
     """
 
     def wrap(cls):
-        return _process_class(cls, init, repr, eq, order, unsafe_hash, frozen, validate_assignment)
+        return _process_class(cls, init, repr, eq, order, unsafe_hash, frozen, config)
 
     if _cls is None:
         return wrap
diff --git a/pydantic/main.py b/pydantic/main.py
index b59a96105..2f700d9ed 100644
--- a/pydantic/main.py
+++ b/pydantic/main.py
@@ -44,7 +44,7 @@ class BaseConfig:
         return field_config
 
 
-def inherit_config(self_config: Type[BaseConfig], parent_config: Type[BaseConfig]) -> Type[BaseConfig]:
+def inherit_config(self_config: Type, parent_config: Type[BaseConfig]) -> Type[BaseConfig]:
     if not self_config:
         base_classes = (parent_config,)
     elif self_config == parent_config:
@@ -402,9 +402,7 @@ class BaseModel(metaclass=MetaModel):
         return self.to_string()
 
 
-def create_model(
-    model_name: str, *, __config__: Type[BaseConfig] = None, __base__: Type[BaseModel] = None, **field_definitions
-):
+def create_model(model_name: str, *, __config__: Type = None, __base__: Type[BaseModel] = None, **field_definitions):
     """
     Dynamically create a model.
     :param model_name: name of the created model
@@ -444,7 +442,7 @@ def create_model(
     namespace = {'__annotations__': annotations}
     namespace.update(fields)
     if __config__:
-        namespace['Config'] = __config__
+        namespace['Config'] = inherit_config(__config__, BaseConfig)
 
     return type(model_name, (__base__,), namespace)
 
diff --git a/tests/test_create_model.py b/tests/test_create_model.py
index c12838a76..92dda0ca3 100644
--- a/tests/test_create_model.py
+++ b/tests/test_create_model.py
@@ -52,11 +52,23 @@ def test_inheritance():
 
 
 def test_custom_config():
+    class Config:
+        fields = {'foo': 'api-foo-field'}
+
+    model = create_model('FooModel', foo=(int, ...), __config__=Config)
+    assert model(**{'api-foo-field': '987'}).foo == 987
+    assert issubclass(model.__config__, BaseModel.Config)
+    with pytest.raises(ValidationError):
+        model(foo=654)
+
+
+def test_custom_config_inherits():
     class Config(BaseModel.Config):
         fields = {'foo': 'api-foo-field'}
 
     model = create_model('FooModel', foo=(int, ...), __config__=Config)
     assert model(**{'api-foo-field': '987'}).foo == 987
+    assert issubclass(model.__config__, BaseModel.Config)
     with pytest.raises(ValidationError):
         model(foo=654)
 
diff --git a/tests/test_dataclasses.py b/tests/test_dataclasses.py
index 3f1170ad0..f0f88af2f 100644
--- a/tests/test_dataclasses.py
+++ b/tests/test_dataclasses.py
@@ -1,7 +1,7 @@
 import pytest
 
 import pydantic
-from pydantic import ValidationError
+from pydantic import BaseConfig, ValidationError
 
 
 def test_simple():
@@ -45,7 +45,10 @@ def test_frozen():
 
 
 def test_validate_assignment():
-    @pydantic.dataclasses.dataclass(validate_assignment=True)
+    class Config:
+        validate_assignment = True
+
+    @pydantic.dataclasses.dataclass(config=Config)
     class MyDataclass:
         a: int
 
@@ -57,7 +60,10 @@ def test_validate_assignment():
 
 
 def test_validate_assignment_error():
-    @pydantic.dataclasses.dataclass(validate_assignment=True)
+    class Config:
+        validate_assignment = True
+
+    @pydantic.dataclasses.dataclass(config=Config)
     class MyDataclass:
         a: int
 
@@ -113,3 +119,63 @@ def test_inheritance():
 
     with pytest.raises(ValidationError):
         B(a='a', b='b')
+
+
+def test_validate_long_string_error():
+    class Config:
+        max_anystr_length = 3
+
+    @pydantic.dataclasses.dataclass(config=Config)
+    class MyDataclass:
+        a: str
+
+    with pytest.raises(ValidationError) as exc_info:
+        MyDataclass('xxxx')
+
+    assert exc_info.value.errors() == [
+        {
+            'loc': ('a',),
+            'msg': 'ensure this value has at most 3 characters',
+            'type': 'value_error.any_str.max_length',
+            'ctx': {'limit_value': 3},
+        }
+    ]
+
+
+def test_validate_assigment_long_string_error():
+    class Config:
+        max_anystr_length = 3
+        validate_assignment = True
+
+    @pydantic.dataclasses.dataclass(config=Config)
+    class MyDataclass:
+        a: str
+
+    d = MyDataclass('xxx')
+    with pytest.raises(ValidationError) as exc_info:
+        d.a = 'xxxx'
+
+    assert issubclass(MyDataclass.__pydantic_model__.__config__, BaseConfig)
+    assert exc_info.value.errors() == [
+        {
+            'loc': ('a',),
+            'msg': 'ensure this value has at most 3 characters',
+            'type': 'value_error.any_str.max_length',
+            'ctx': {'limit_value': 3},
+        }
+    ]
+
+
+def test_no_validate_assigment_long_string_error():
+    class Config:
+        max_anystr_length = 3
+        validate_assignment = False
+
+    @pydantic.dataclasses.dataclass(config=Config)
+    class MyDataclass:
+        a: str
+
+    d = MyDataclass('xxx')
+    d.a = 'xxxx'
+
+    assert d.a == 'xxxx'
