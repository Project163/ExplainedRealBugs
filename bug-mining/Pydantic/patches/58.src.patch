diff --git a/HISTORY.rst b/HISTORY.rst
index 740e0540b..c8cab0502 100644
--- a/HISTORY.rst
+++ b/HISTORY.rst
@@ -3,6 +3,10 @@
 History
 -------
 
+v0.31 (unreleased)
+..................
+* fix schema generation for ``NewType`` and ``Literal``, #649 by @dmontagu
+
 v0.30.1 (2019-07-15)
 ....................
 * fix so nested classes which inherit and change ``__init__`` are correctly processed while still allowing ``self`` as a
diff --git a/pydantic/fields.py b/pydantic/fields.py
index aaf8f115d..848ac1c5d 100644
--- a/pydantic/fields.py
+++ b/pydantic/fields.py
@@ -23,7 +23,17 @@ from . import errors as errors_
 from .class_validators import Validator, make_generic_validator
 from .error_wrappers import ErrorWrapper
 from .types import Json, JsonWrapper
-from .utils import AnyCallable, AnyType, Callable, ForwardRef, display_as_type, lenient_issubclass, sequence_like
+from .utils import (
+    AnyCallable,
+    AnyType,
+    Callable,
+    ForwardRef,
+    display_as_type,
+    is_literal_type,
+    lenient_issubclass,
+    literal_values,
+    sequence_like,
+)
 from .validators import NoneType, constant_validator, dict_validator, find_validators
 
 try:
@@ -186,14 +196,18 @@ class Field:
         if self.type_ is Pattern:
             # python 3.7 only, Pattern is a typing object but without sub fields
             return
+        if is_literal_type(self.type_):
+            values = literal_values(self.type_)
+            if len(values) > 1:
+                self.type_ = Union[tuple(Literal[value] for value in values)]
+            else:
+                return
         origin = getattr(self.type_, '__origin__', None)
         if origin is None:
             # field is not "typing" object eg. Union, Dict, List etc.
             return
         if origin is Callable:
             return
-        if Literal is not None and origin is Literal:
-            return
         if origin is Union:
             types_ = []
             for type_ in self.type_.__args__:  # type: ignore
diff --git a/pydantic/schema.py b/pydantic/schema.py
index dbae2c4b9..bba7f7d5f 100644
--- a/pydantic/schema.py
+++ b/pydantic/schema.py
@@ -46,7 +46,15 @@ from .types import (
     conlist,
     constr,
 )
-from .utils import clean_docstring, is_callable_type, lenient_issubclass
+from .utils import (
+    clean_docstring,
+    is_callable_type,
+    is_literal_type,
+    is_new_type,
+    lenient_issubclass,
+    literal_values,
+    new_type_supertype,
+)
 
 if TYPE_CHECKING:  # pragma: no cover
     from . import dataclasses  # noqa: F401
@@ -742,27 +750,34 @@ def field_singleton_schema(  # noqa: C901 (ignore complexity)
     f_schema: Dict[str, Any] = {}
     if field.schema is not None and field.schema.const:
         f_schema['const'] = field.default
-    if issubclass(field.type_, Enum):
-        f_schema.update({'enum': [item.value for item in field.type_]})
+    field_type = field.type_
+    if is_new_type(field_type):
+        field_type = new_type_supertype(field_type)
+    if is_literal_type(field_type):
+        # If there were multiple literal values, field.sub_fields would not be falsy
+        literal_value = literal_values(field_type)[0]
+        field_type = type(literal_value)
+        f_schema['const'] = literal_value
+    if issubclass(field_type, Enum):
+        f_schema.update({'enum': [item.value for item in field_type]})
         # Don't return immediately, to allow adding specific types
     for field_name, schema_name in validation_attribute_to_schema_keyword.items():
-        field_value = getattr(field.type_, field_name, None)
+        field_value = getattr(field_type, field_name, None)
         if field_value is not None:
             if field_name == 'regex':
                 field_value = field_value.pattern
             f_schema[schema_name] = field_value
     for type_, t_schema in field_class_to_schema_enum_enabled:
-        if issubclass(field.type_, type_):
+        if issubclass(field_type, type_):
             f_schema.update(t_schema)
             break
     # Return schema, with or without enum definitions
     if f_schema:
         return f_schema, definitions, nested_models
     for type_, t_schema in field_class_to_schema_enum_disabled:
-        if issubclass(field.type_, type_):
+        if issubclass(field_type, type_):
             return t_schema, definitions, nested_models
     # Handle dataclass-based models
-    field_type = field.type_
     if lenient_issubclass(getattr(field_type, '__pydantic_model__', None), pydantic.BaseModel):
         field_type = field_type.__pydantic_model__  # type: ignore
     if issubclass(field_type, pydantic.BaseModel):
diff --git a/pydantic/utils.py b/pydantic/utils.py
index 94b059be9..3a392f659 100644
--- a/pydantic/utils.py
+++ b/pydantic/utils.py
@@ -13,6 +13,7 @@ from typing import (  # type: ignore
     Dict,
     Generator,
     List,
+    NewType,
     Optional,
     Pattern,
     Set,
@@ -298,12 +299,31 @@ if sys.version_info >= (3, 7):
     def is_literal_type(type_: AnyType) -> bool:
         return Literal is not None and getattr(type_, '__origin__', None) is Literal
 
+    def literal_values(type_: AnyType) -> Tuple[Any, ...]:
+        return type_.__args__
+
 
 else:
 
     def is_literal_type(type_: AnyType) -> bool:
         return Literal is not None and hasattr(type_, '__values__') and type_ == Literal[type_.__values__]
 
+    def literal_values(type_: AnyType) -> Tuple[Any, ...]:
+        return type_.__values__
+
+
+test_type = NewType('test_type', str)
+
+
+def is_new_type(type_: AnyType) -> bool:
+    return isinstance(type_, type(test_type)) and hasattr(type_, '__supertype__')
+
+
+def new_type_supertype(type_: AnyType) -> AnyType:
+    while hasattr(type_, '__supertype__'):
+        type_ = type_.__supertype__
+    return type_
+
 
 def _check_classvar(v: AnyType) -> bool:
     return type(v) == type(ClassVar) and (sys.version_info < (3, 7) or getattr(v, '_name', None) == 'ClassVar')
diff --git a/tests/test_schema.py b/tests/test_schema.py
index 80fbf4947..4d77488fc 100644
--- a/tests/test_schema.py
+++ b/tests/test_schema.py
@@ -5,7 +5,7 @@ from datetime import date, datetime, time, timedelta
 from decimal import Decimal
 from enum import Enum, IntEnum
 from pathlib import Path
-from typing import Any, Callable, Dict, List, Optional, Set, Tuple, Union
+from typing import Any, Callable, Dict, List, NewType, Optional, Set, Tuple, Union
 from uuid import UUID
 
 import pytest
@@ -64,12 +64,18 @@ from pydantic.types import (
     constr,
     urlstr,
 )
+from pydantic.utils import Literal
 
 try:
     import email_validator
 except ImportError:
     email_validator = None
 
+try:
+    import typing_extensions
+except ImportError:
+    typing_extensions = None
+
 
 def test_key():
     class ApplePie(BaseModel):
@@ -1411,3 +1417,44 @@ def test_root_nested_model():
             }
         },
     }
+
+
+def test_new_type_schema():
+    a_type = NewType('a_type', int)
+    b_type = NewType('b_type', a_type)
+    c_type = NewType('c_type', str)
+
+    class Model(BaseModel):
+        a: a_type
+        b: b_type
+        c: c_type
+
+    assert Model.schema() == {
+        'properties': {
+            'a': {'title': 'A', 'type': 'integer'},
+            'b': {'title': 'B', 'type': 'integer'},
+            'c': {'title': 'C', 'type': 'string'},
+        },
+        'required': ['a', 'b', 'c'],
+        'title': 'Model',
+        'type': 'object',
+    }
+
+
+@pytest.mark.skipif(not typing_extensions, reason='typing_extensions not installed')
+def test_literal_schema():
+    class Model(BaseModel):
+        a: Literal[1]
+        b: Literal['a']
+        c: Literal['a', 1]
+
+    assert Model.schema() == {
+        'properties': {
+            'a': {'title': 'A', 'type': 'integer', 'const': 1},
+            'b': {'title': 'B', 'type': 'string', 'const': 'a'},
+            'c': {'anyOf': [{'type': 'string', 'const': 'a'}, {'type': 'integer', 'const': 1}], 'title': 'C'},
+        },
+        'required': ['a', 'b', 'c'],
+        'title': 'Model',
+        'type': 'object',
+    }
diff --git a/tests/test_types.py b/tests/test_types.py
index 77110d09f..83f4a0633 100644
--- a/tests/test_types.py
+++ b/tests/test_types.py
@@ -1698,8 +1698,14 @@ def test_literal_multiple():
     assert exc_info.value.errors() == [
         {
             'loc': ('a_or_b',),
-            'msg': "unexpected value; permitted: 'a', 'b'",
+            'msg': "unexpected value; permitted: 'a'",
             'type': 'value_error.const',
-            'ctx': {'given': 'c', 'permitted': ('a', 'b')},
-        }
+            'ctx': {'given': 'c', 'permitted': ('a',)},
+        },
+        {
+            'loc': ('a_or_b',),
+            'msg': "unexpected value; permitted: 'b'",
+            'type': 'value_error.const',
+            'ctx': {'given': 'c', 'permitted': ('b',)},
+        },
     ]
diff --git a/tests/test_utils.py b/tests/test_utils.py
index f997cfe97..0af6b7d52 100644
--- a/tests/test_utils.py
+++ b/tests/test_utils.py
@@ -1,10 +1,19 @@
 import os
 from enum import Enum
-from typing import Union
+from typing import NewType, Union
 
 import pytest
 
-from pydantic.utils import display_as_type, import_string, lenient_issubclass, make_dsn, truncate, validate_email
+from pydantic.utils import (
+    display_as_type,
+    import_string,
+    is_new_type,
+    lenient_issubclass,
+    make_dsn,
+    new_type_supertype,
+    truncate,
+    validate_email,
+)
 
 try:
     import email_validator
@@ -150,3 +159,18 @@ def test_lenient_issubclass_is_lenient():
 
 def test_truncate_type():
     assert truncate(object) == "<class 'object'>"
+
+
+def test_is_new_type():
+    new_type = NewType('new_type', str)
+    new_new_type = NewType('new_new_type', new_type)
+    assert is_new_type(new_type)
+    assert is_new_type(new_new_type)
+    assert not is_new_type(str)
+
+
+def test_new_type_supertype():
+    new_type = NewType('new_type', str)
+    new_new_type = NewType('new_new_type', new_type)
+    assert new_type_supertype(new_type) == str
+    assert new_type_supertype(new_new_type) == str
