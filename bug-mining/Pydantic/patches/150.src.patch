diff --git a/changes/1201-PrettyWood.md b/changes/1201-PrettyWood.md
new file mode 100644
index 000000000..d22cd864c
--- /dev/null
+++ b/changes/1201-PrettyWood.md
@@ -0,0 +1 @@
+Fix: some recursive models did not require `update_forward_refs` and silently behaved incorrectly
\ No newline at end of file
diff --git a/pydantic/fields.py b/pydantic/fields.py
index 4a0469f97..ebe2d56ef 100644
--- a/pydantic/fields.py
+++ b/pydantic/fields.py
@@ -25,7 +25,7 @@ from typing import (
 from . import errors as errors_
 from .class_validators import Validator, make_generic_validator, prep_validators
 from .error_wrappers import ErrorWrapper
-from .errors import NoneIsNotAllowedError
+from .errors import ConfigError, NoneIsNotAllowedError
 from .types import Json, JsonWrapper
 from .typing import (
     NONE_TYPES,
@@ -565,6 +565,13 @@ class ModelField(Representation):
         self, v: Any, values: Dict[str, Any], *, loc: 'LocStr', cls: Optional['ModelOrDc'] = None
     ) -> 'ValidateReturn':
 
+        if self.type_.__class__ is ForwardRef:
+            assert cls is not None
+            raise ConfigError(
+                f'field "{self.name}" not yet prepared so type is still a ForwardRef, '
+                f'you might need to call {cls.__name__}.update_forward_refs().'
+            )
+
         errors: Optional['ErrorList']
         if self.pre_validators:
             v, errors = self._apply_validators(v, values, loc, cls, self.pre_validators)
diff --git a/pydantic/main.py b/pydantic/main.py
index 10a3ee889..786ee2296 100644
--- a/pydantic/main.py
+++ b/pydantic/main.py
@@ -34,15 +34,7 @@ from .json import custom_pydantic_encoder, pydantic_encoder
 from .parse import Protocol, load_file, load_str_bytes
 from .schema import default_ref_template, model_schema
 from .types import PyObject, StrBytes
-from .typing import (
-    AnyCallable,
-    ForwardRef,
-    get_args,
-    get_origin,
-    is_classvar,
-    resolve_annotations,
-    update_field_forward_refs,
-)
+from .typing import AnyCallable, get_args, get_origin, is_classvar, resolve_annotations, update_field_forward_refs
 from .utils import (
     ROOT_KEY,
     ClassAttribute,
@@ -968,12 +960,6 @@ def validate_model(  # noqa: C901 (ignore complexity)
             return {}, set(), ValidationError([ErrorWrapper(exc, loc=ROOT_KEY)], cls_)
 
     for name, field in model.__fields__.items():
-        if field.type_.__class__ == ForwardRef:
-            raise ConfigError(
-                f'field "{field.name}" not yet prepared so type is still a ForwardRef, '
-                f'you might need to call {cls_.__name__}.update_forward_refs().'
-            )
-
         value = input_data.get(field.alias, _missing)
         using_name = False
         if value is _missing and config.allow_population_by_field_name and field.alt_alias:
diff --git a/tests/test_forward_ref.py b/tests/test_forward_ref.py
index f762eb11c..459c384dc 100644
--- a/tests/test_forward_ref.py
+++ b/tests/test_forward_ref.py
@@ -1,8 +1,9 @@
 import sys
+from typing import Optional, Tuple
 
 import pytest
 
-from pydantic import ConfigError, ValidationError
+from pydantic import BaseModel, ConfigError, ValidationError
 
 skip_pre_37 = pytest.mark.skipif(sys.version_info < (3, 7), reason='testing >= 3.7 behaviour only')
 
@@ -477,3 +478,19 @@ def test_forward_ref_with_create_model(create_module):
         Main = pydantic.create_model('Main', sub=('Sub', ...), __module__=__name__)
         instance = Main(sub={})
         assert instance.sub.dict() == {'foo': 'bar'}
+
+
+def test_nested_forward_ref():
+    class NestedTuple(BaseModel):
+        x: Tuple[int, Optional['NestedTuple']]  # noqa: F821
+
+    with pytest.raises(ConfigError) as exc_info:
+        NestedTuple.parse_obj({'x': ('1', {'x': ('2', {'x': ('3', None)})})})
+    assert str(exc_info.value) == (
+        'field "x_1" not yet prepared so type is still a ForwardRef, '
+        'you might need to call NestedTuple.update_forward_refs().'
+    )
+
+    NestedTuple.update_forward_refs()
+    obj = NestedTuple.parse_obj({'x': ('1', {'x': ('2', {'x': ('3', None)})})})
+    assert obj.dict() == {'x': (1, {'x': (2, {'x': (3, None)})})}
