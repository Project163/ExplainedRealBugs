diff --git a/HISTORY.rst b/HISTORY.rst
index e4674ca88..83d4364b1 100644
--- a/HISTORY.rst
+++ b/HISTORY.rst
@@ -8,6 +8,7 @@ v0.12.0 (2018-XX-XX)
 * add ``by_alias`` argument in ``.dict()`` and ``.json()`` model methods #205
 * add Json type support #214
 * support tuples #227
+* major improvements and changes to schema #213
 
 v0.11.2 (2018-07-05)
 ....................
diff --git a/pydantic/fields.py b/pydantic/fields.py
index 075ae0b8f..70934cbe8 100644
--- a/pydantic/fields.py
+++ b/pydantic/fields.py
@@ -136,31 +136,77 @@ class Field:
         self._populate_validators()
 
     def schema(self, by_alias=True):
-        s = self.type_.schema(by_alias) if hasattr(self.type_, 'schema') else {}
-        s.update(
-            type=s.get('type') or display_as_type(self.type_),
-            title=self._schema.title or s.get('title') or self.alias.title(),
+        s = dict(
+            title=self._schema.title or self.alias.title(),
             required=self.required,
         )
 
         if not self.required and self.default is not None:
             s['default'] = self.default
-        if issubclass(self.type_, Enum):
-            choice_names = self._schema.choice_names or {}
-            s['choices'] = [
-                (v.value, choice_names.get(v.value) or k.title())
-                for k, v in self.type_.__members__.items()
-            ]
         s.update(self._schema.extra)
+
+        ts = self.type_schema(by_alias)
+        s.update(ts if isinstance(ts, dict) else {'type': ts})
         return s
 
+    def type_schema(self, by_alias):
+        if self.shape is Shape.LIST:
+            return {
+                'type': 'list',
+                'item_type': self._singleton_schema(by_alias),
+            }
+        if self.shape is Shape.SET:
+            return {
+                'type': 'set',
+                'item_type': self._singleton_schema(by_alias),
+            }
+        elif self.shape is Shape.MAPPING:
+            return {
+                'type': 'mapping',
+                'item_type': self._singleton_schema(by_alias),
+                'key_type': self.key_field.type_schema(by_alias)
+            }
+        elif self.shape is Shape.TUPLE:
+            return {
+                'type': 'tuple',
+                'item_types': [sf.type_schema(by_alias) for sf in self.sub_fields],
+            }
+        else:
+            assert self.shape is Shape.SINGLETON, self.shape
+            return self._singleton_schema(by_alias)
+
+    def _singleton_schema(self, by_alias):
+        if self.sub_fields:
+            if len(self.sub_fields) == 1:
+                return self.sub_fields[0].type_schema(by_alias)
+            else:
+                return {
+                    'type': 'any_of',
+                    'types': [sf.type_schema(by_alias) for sf in self.sub_fields]
+                }
+        elif issubclass(self.type_, Enum):
+            choice_names = self._schema.choice_names or {}
+            return {
+                'type': display_as_type(self.type_),
+                'choices': [
+                    (v.value, choice_names.get(v.value) or k.title())
+                    for k, v in self.type_.__members__.items()
+                ]
+            }
+
+        type_schema_method = getattr(self.type_, 'type_schema', None)
+        if callable(type_schema_method):
+            return type_schema_method(by_alias)
+        else:
+            return display_as_type(self.type_)
+
     def _populate_sub_fields(self):
         # typing interface is horrible, we have to do some ugly checks
         if isinstance(self.type_, type) and issubclass(self.type_, JsonWrapper):
             self.type_ = self.type_.inner_type
             self.parse_json = True
 
-        origin = _get_type_origin(self.type_)
+        origin = getattr(self.type_, '__origin__', None)
         if origin is None:
             # field is not "typing" object eg. Union, Dict, List etc.
             return
@@ -169,6 +215,7 @@ class Field:
             for type_ in self.type_.__args__:
                 if type_ is NoneType:
                     self.allow_none = True
+                    self.required = False
                 else:
                     types_.append(type_)
             self.sub_fields = [self._create_sub_type(t, f'{self.name}_{display_as_type(t)}') for t in types_]
@@ -193,7 +240,7 @@ class Field:
             self.type_ = self.type_.__args__[1]
             self.shape = Shape.MAPPING
 
-        if _get_type_origin(self.type_):
+        if getattr(self.type_, '__origin__', None):
             # type_ has been refined eg. as the type of a List and sub_fields needs to be populated
             self.sub_fields = [self._create_sub_type(self.type_, '_' + self.name)]
 
@@ -413,10 +460,3 @@ def _get_validator_signature(validator):
         raise errors_.ConfigError(f'Invalid signature for validator {validator}: {signature}, should be: '
                                   f'(value) or (value, *, values, config, field) or for class validators '
                                   f'(cls, value) or (cls, value, *, values, config, field)') from e
-
-
-def _get_type_origin(obj):
-    """
-    Like obj.__class__ or type(obj) but for typing objects
-    """
-    return getattr(obj, '__origin__', None)
diff --git a/pydantic/main.py b/pydantic/main.py
index 3b50b8a42..1bd6b386c 100644
--- a/pydantic/main.py
+++ b/pydantic/main.py
@@ -276,24 +276,27 @@ class BaseModel(metaclass=MetaModel):
     def fields(self):
         return self.__fields__
 
+    @classmethod
+    def type_schema(cls, by_alias):
+        return {
+            'type': 'object',
+            'properties': (
+                {f.alias: f.schema(by_alias) for f in cls.__fields__.values()}
+                if by_alias else
+                {k: f.schema(by_alias) for k, f in cls.__fields__.items()}
+            )
+        }
+
     @classmethod
     def schema(cls, by_alias=True) -> Dict[str, Any]:
         cached = cls._schema_cache.get(by_alias)
         if cached is not None:
             return cached
-
-        s = {
-            'type': 'object',
-            'title': cls.__config__.title or cls.__name__,
-        }
+        s = {'title': cls.__config__.title or cls.__name__}
         if cls.__doc__:
             s['description'] = clean_docstring(cls.__doc__)
 
-        if by_alias:
-            s['properties'] = {f.alias: f.schema(by_alias) for f in cls.__fields__.values()}
-        else:
-            s['properties'] = {k: f.schema(by_alias) for k, f in cls.__fields__.items()}
-
+        s.update(cls.type_schema(by_alias))
         cls._schema_cache[by_alias] = s
         return s
 
diff --git a/pydantic/version.py b/pydantic/version.py
index 485d0cf0b..383d63648 100644
--- a/pydantic/version.py
+++ b/pydantic/version.py
@@ -2,4 +2,4 @@ from distutils.version import StrictVersion
 
 __all__ = ['VERSION']
 
-VERSION = StrictVersion('0.11.2')
+VERSION = StrictVersion('0.12a1')
diff --git a/setup.cfg b/setup.cfg
index 78dd6741a..5d8fe40e6 100644
--- a/setup.cfg
+++ b/setup.cfg
@@ -24,3 +24,5 @@ exclude_lines =
 
 [isort]
 line_length=120
+known_first_party=
+    pydantic
diff --git a/tests/test_complex.py b/tests/test_complex.py
index 99244dad6..fd7008d00 100644
--- a/tests/test_complex.py
+++ b/tests/test_complex.py
@@ -1,7 +1,7 @@
 import re
 from decimal import Decimal
 from enum import Enum
-from typing import Any, Dict, List, Set, Tuple, Union
+from typing import Any, Dict, List, Optional, Set, Tuple, Union
 
 import pytest
 
@@ -674,3 +674,12 @@ def test_return_errors_error():
             'type': 'value_error.missing'
         }
     ]
+
+
+def test_optional_required():
+    class Model(BaseModel):
+        bar: Optional[int]
+
+    assert Model(bar=123).dict() == {'bar': 123}
+    assert Model().dict() == {'bar': None}
+    assert Model(bar=None).dict() == {'bar': None}
diff --git a/tests/test_schema.py b/tests/test_schema.py
index 1c9fac741..00ea0e532 100644
--- a/tests/test_schema.py
+++ b/tests/test_schema.py
@@ -1,6 +1,7 @@
 import json
 from decimal import Decimal
 from enum import Enum, IntEnum
+from typing import Dict, List, Optional, Set, Tuple, Union
 
 import pytest
 
@@ -17,8 +18,6 @@ def test_key():
 
     s = {
         'type': 'object',
-        'title': 'ApplePie',
-        'description': 'This is a test.',
         'properties': {
             'a': {
                 'type': 'float',
@@ -32,6 +31,8 @@ def test_key():
                 'default': 10,
             },
         },
+        'title': 'ApplePie',
+        'description': 'This is a test.',
     }
     assert True not in ApplePie._schema_cache
     assert False not in ApplePie._schema_cache
@@ -93,7 +94,7 @@ def test_sub_model():
             },
             'b': {
                 'type': 'object',
-                'title': 'Foo',
+                'title': 'B',
                 'properties': {
                     'b': {
                         'type': 'float',
@@ -101,7 +102,6 @@ def test_sub_model():
                         'required': True,
                     },
                 },
-                'description': 'hello',
                 'required': False,
             },
         },
@@ -205,21 +205,179 @@ def test_json_schema():
 
     assert Model.schema_json(indent=2) == (
         '{\n'
-        '  "type": "object",\n'
         '  "title": "Model",\n'
+        '  "type": "object",\n'
         '  "properties": {\n'
         '    "a": {\n'
-        '      "type": "bytes",\n'
         '      "title": "A",\n'
         '      "required": false,\n'
-        '      "default": "foobar"\n'
+        '      "default": "foobar",\n'
+        '      "type": "bytes"\n'
         '    },\n'
         '    "b": {\n'
-        '      "type": "Decimal",\n'
         '      "title": "B",\n'
         '      "required": false,\n'
-        '      "default": 12.34\n'
+        '      "default": 12.34,\n'
+        '      "type": "Decimal"\n'
         '    }\n'
         '  }\n'
         '}'
     )
+
+
+def test_list_sub_model():
+    class Foo(BaseModel):
+        a: float
+
+    class Bar(BaseModel):
+        b: List[Foo]
+
+    assert Bar.schema() == {
+        'title': 'Bar',
+        'type': 'object',
+        'properties': {
+            'b': {
+                'type': 'list',
+                'item_type': {
+                    'type': 'object',
+                    'properties': {
+                        'a': {
+                            'type': 'float',
+                            'title': 'A',
+                            'required': True,
+                        },
+                    },
+                },
+                'title': 'B',
+                'required': True,
+            },
+        },
+    }
+
+
+def test_optional():
+    class Model(BaseModel):
+        a: Optional[str]
+
+    assert Model.schema() == {
+        'title': 'Model',
+        'type': 'object',
+        'properties': {
+            'a': {
+                'type': 'str',
+                'title': 'A',
+                'required': False,
+            },
+        },
+    }
+
+
+def test_set():
+    class Model(BaseModel):
+        a: Set[int]
+
+    assert Model.schema() == {
+        'title': 'Model',
+        'type': 'object',
+        'properties': {
+            'a': {
+                'title': 'A',
+                'required': True,
+                'type': 'set',
+                'item_type': 'int'
+            }
+        }
+    }
+
+
+def test_tuple():
+    class Model(BaseModel):
+        a: Tuple[str, int, Union[str, int, float], float]
+
+    assert Model.schema() == {
+        'title': 'Model',
+        'type': 'object',
+        'properties': {
+            'a': {
+                'title': 'A',
+                'required': True,
+                'type': 'tuple',
+                'item_types': [
+                    'str',
+                    'int',
+                    {
+                        'type': 'any_of',
+                        'types': [
+                            'str',
+                            'int',
+                            'float',
+                        ],
+                    },
+                    'float',
+                ],
+            },
+        },
+    }
+
+
+def test_list_union_dict():
+    class Foo(BaseModel):
+        a: float
+
+    class Model(BaseModel):
+        """party time"""
+        a: Union[int, str]
+        b: List[int]
+        c: Dict[int, Foo]
+        d: Union[None, Foo]
+
+    assert Model.schema() == {
+        'title': 'Model',
+        'description': 'party time',
+        'type': 'object',
+        'properties': {
+            'a': {
+                'title': 'A',
+                'required': True,
+                'type': 'any_of',
+                'types': [
+                    'int',
+                    'str',
+                ],
+            },
+            'b': {
+                'title': 'B',
+                'required': True,
+                'type': 'list',
+                'item_type': 'int',
+            },
+            'c': {
+                'title': 'C',
+                'required': True,
+                'type': 'mapping',
+                'item_type': {
+                    'type': 'object',
+                    'properties': {
+                        'a': {
+                            'title': 'A',
+                            'required': True,
+                            'type': 'float',
+                        },
+                    },
+                },
+                'key_type': 'int',
+            },
+            'd': {
+                'title': 'D',
+                'required': False,
+                'type': 'object',
+                'properties': {
+                    'a': {
+                        'title': 'A',
+                        'required': True,
+                        'type': 'float',
+                    },
+                },
+            },
+        },
+    }
