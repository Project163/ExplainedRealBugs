diff --git a/HISTORY.rst b/HISTORY.rst
index 684436623..5c20d7af3 100644
--- a/HISTORY.rst
+++ b/HISTORY.rst
@@ -10,6 +10,7 @@ v0.17.0 (unreleased)
 * prevent duplicate validator check in ipython, fix #312 by @samuelcolvin
 * add "Using Pydantic" section to docs, #323 by @tiangolo & #326 by @samuelcolvin
 * fix schema generation for fields annotated as ``: dict``, #330 by @nkonin
+* add support for constrained strings as dict keys in schema, #332 by @tiangolo
 * support for passing Config class in dataclasses decorator, #276 by @jarekkar
   (**breaking change**: this supersedes the ``validate_assignment`` argument with ``config``)
 
diff --git a/pydantic/schema.py b/pydantic/schema.py
index 5997469d3..51cca5847 100644
--- a/pydantic/schema.py
+++ b/pydantic/schema.py
@@ -376,7 +376,7 @@ def get_long_model_name(model: Type['main.BaseModel']):
     return f'{model.__module__}__{model.__name__}'.replace('.', '__')
 
 
-def field_type_schema(
+def field_type_schema(  # noqa: C901 (ignore complexity)
     field: Field,
     *,
     by_alias: bool,
@@ -405,16 +405,20 @@ def field_type_schema(
         definitions.update(f_definitions)
         return {'type': 'array', 'uniqueItems': True, 'items': f_schema}, definitions
     elif field.shape is Shape.MAPPING:
+        dict_schema = {'type': 'object'}
+        regex = getattr(field.key_field.type_, 'regex', None)
         f_schema, f_definitions = field_singleton_schema(
             field, by_alias=by_alias, model_name_map=model_name_map, ref_prefix=ref_prefix
         )
         definitions.update(f_definitions)
-        if f_schema:
-            # The dict values are not simply Any
-            return {'type': 'object', 'additionalProperties': f_schema}, definitions
-        else:
-            # The dict values are Any, no need to declare it
-            return {'type': 'object'}, definitions
+        if regex:
+            # Dict keys have a regex pattern
+            # f_schema might be a schema or empty dict, add it either way
+            dict_schema['patternProperties'] = {regex.pattern: f_schema}
+        elif f_schema:
+            # The dict values are not simply Any, so they need a schema
+            dict_schema['additionalProperties'] = f_schema
+        return dict_schema, definitions
     elif field.shape is Shape.TUPLE:
         sub_schema = []
         for sf in field.sub_fields:
diff --git a/tests/test_schema.py b/tests/test_schema.py
index 2489dff55..0de31a2f6 100644
--- a/tests/test_schema.py
+++ b/tests/test_schema.py
@@ -1019,3 +1019,20 @@ def test_schema_kwargs():
         'type': 'object',
         'properties': {'a': {'type': 'string', 'title': 'A', 'default': 'foo', 'examples': ['bar']}},
     }
+
+
+def test_schema_dict_constr():
+    regex_str = r'^([a-zA-Z_][a-zA-Z0-9_]*)$'
+    ConStrType = constr(regex=regex_str)
+    ConStrKeyDict = Dict[ConStrType, str]
+
+    class Foo(BaseModel):
+        a: ConStrKeyDict = {}
+
+    assert Foo.schema() == {
+        'title': 'Foo',
+        'type': 'object',
+        'properties': {
+            'a': {'type': 'object', 'title': 'A', 'default': {}, 'patternProperties': {regex_str: {'type': 'string'}}}
+        },
+    }
