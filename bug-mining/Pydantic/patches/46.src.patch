diff --git a/HISTORY.rst b/HISTORY.rst
index 1ba6a350f..18cdfa118 100644
--- a/HISTORY.rst
+++ b/HISTORY.rst
@@ -4,7 +4,9 @@ History
 -------
 
 v0.26 (unreleased)
+..................
 * fix to schema generation for ``IPvAnyAddress``, ``IPvAnyInterface``, ``IPvAnyNetwork`` #498 by @pilosus
+* fix variable length tuples support, #495 by @pilosus
 
 v0.25 (2019-05-05)
 ..................
diff --git a/pydantic/fields.py b/pydantic/fields.py
index 4b19c84ae..551cb846e 100644
--- a/pydantic/fields.py
+++ b/pydantic/fields.py
@@ -46,7 +46,8 @@ class Shape(IntEnum):
     SET = 3
     MAPPING = 4
     TUPLE = 5
-    SEQUENCE = 6
+    TUPLE_ELLIPS = 6
+    SEQUENCE = 7
 
 
 class Field:
@@ -198,9 +199,13 @@ class Field:
 
         if issubclass(origin, Tuple):  # type: ignore
             self.shape = Shape.TUPLE
-            self.sub_fields = [
-                self._create_sub_type(t, f'{self.name}_{i}') for i, t in enumerate(self.type_.__args__)  # type: ignore
-            ]
+            self.sub_fields = []
+            for i, t in enumerate(self.type_.__args__):  # type: ignore
+                if t is Ellipsis:
+                    self.type_ = self.type_.__args__[0]  # type: ignore
+                    self.shape = Shape.TUPLE_ELLIPS
+                    return
+                self.sub_fields.append(self._create_sub_type(t, f'{self.name}_{i}'))
             return
 
         if issubclass(origin, List):
@@ -301,13 +306,12 @@ class Field:
         except (ValueError, TypeError) as exc:
             return v, ErrorWrapper(exc, loc=loc, config=self.model_config)
 
-    def _validate_sequence_like(
+    def _validate_sequence_like(  # noqa: C901 (ignore complexity)
         self, v: Any, values: Dict[str, Any], loc: 'LocType', cls: Optional['ModelOrDc']
     ) -> 'ValidateReturn':
         """
         Validate sequence-like containers: lists, tuples, sets and generators
         """
-
         if not sequence_like(v):
             e: errors_.PydanticTypeError
             if self.shape is Shape.LIST:
@@ -335,6 +339,8 @@ class Field:
 
         if self.shape is Shape.SET:
             converted = set(result)
+        elif self.shape is Shape.TUPLE_ELLIPS:
+            converted = tuple(result)
         elif self.shape is Shape.SEQUENCE:
             if isinstance(v, tuple):
                 converted = tuple(result)
diff --git a/tests/test_types.py b/tests/test_types.py
index 9eaab201e..06115cef2 100644
--- a/tests/test_types.py
+++ b/tests/test_types.py
@@ -539,6 +539,45 @@ def test_tuple_fails(value):
     assert exc_info.value.errors() == [{'loc': ('v',), 'msg': 'value is not a valid tuple', 'type': 'type_error.tuple'}]
 
 
+@pytest.mark.parametrize(
+    'value,cls,result',
+    (
+        ([1, 2, '3'], int, (1, 2, 3)),
+        ((1, 2, '3'), int, (1, 2, 3)),
+        ((i ** 2 for i in range(5)), int, (0, 1, 4, 9, 16)),
+        (('a', 'b', 'c'), str, ('a', 'b', 'c')),
+    ),
+)
+def test_tuple_variable_len_success(value, cls, result):
+    class Model(BaseModel):
+        v: Tuple[cls, ...]
+
+    assert Model(v=value).v == result
+
+
+@pytest.mark.parametrize(
+    'value, cls, exc',
+    [
+        (('a', 'b', [1, 2], 'c'), str, [{'loc': ('v', 2), 'msg': 'str type expected', 'type': 'type_error.str'}]),
+        (
+            ('a', 'b', [1, 2], 'c', [3, 4]),
+            str,
+            [
+                {'loc': ('v', 2), 'msg': 'str type expected', 'type': 'type_error.str'},
+                {'loc': ('v', 4), 'msg': 'str type expected', 'type': 'type_error.str'},
+            ],
+        ),
+    ],
+)
+def test_tuple_variable_len_fails(value, cls, exc):
+    class Model(BaseModel):
+        v: Tuple[cls, ...]
+
+    with pytest.raises(ValidationError) as exc_info:
+        Model(v=value)
+    assert exc_info.value.errors() == exc
+
+
 @pytest.mark.parametrize(
     'value,result',
     (
