diff --git a/changes/3679-samuelcolvin.md b/changes/3679-samuelcolvin.md
new file mode 100644
index 000000000..ac589451f
--- /dev/null
+++ b/changes/3679-samuelcolvin.md
@@ -0,0 +1 @@
+Allow self referencing `ClassVar`s in models but checking for class vars after forward refs are resolved.
diff --git a/pydantic/fields.py b/pydantic/fields.py
index e6736f023..8890ede93 100644
--- a/pydantic/fields.py
+++ b/pydantic/fields.py
@@ -37,6 +37,7 @@ from .typing import (
     display_as_type,
     get_args,
     get_origin,
+    is_classvar,
     is_literal_type,
     is_new_type,
     is_none_type,
@@ -611,6 +612,8 @@ class ModelField(Representation):
             return
         elif origin is Callable:
             return
+        elif is_classvar(origin):
+            return
         elif is_union(origin):
             types_ = []
             for type_ in get_args(self.type_):
diff --git a/tests/test_forward_ref.py b/tests/test_forward_ref.py
index 61e7be5cf..969c3f59b 100644
--- a/tests/test_forward_ref.py
+++ b/tests/test_forward_ref.py
@@ -1,3 +1,4 @@
+import sys
 from typing import Optional, Tuple
 
 import pytest
@@ -669,3 +670,19 @@ class User(BaseModel):
 
     m = module.User(name='anne', friends=[{'name': 'ben'}, {'name': 'charlie'}])
     assert m.json(models_as_dict=False) == '{"name": "anne", "friends": ["User(ben)", "User(charlie)"]}'
+
+
+@pytest.mark.skipif(sys.version_info < (3, 9), reason='needs 3.9 or newer')
+def test_class_var_forward_ref(create_module):
+    # see #3679
+    create_module(
+        # language=Python
+        """
+from __future__ import annotations
+from typing import ClassVar
+from pydantic import BaseModel
+
+class WithClassVar(BaseModel):
+    Instances: ClassVar[dict[str, WithClassVar]] = {}
+"""
+    )
