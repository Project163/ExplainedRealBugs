diff --git a/HISTORY.rst b/HISTORY.rst
index 31fe5634d..c00ef6af0 100644
--- a/HISTORY.rst
+++ b/HISTORY.rst
@@ -3,15 +3,20 @@
 History
 -------
 
-v0.15 (2018-11-15)
-..................
+v0.15.1 (2018-11-18)
+....................
+* fix ``PyObject = None``, fix #305 by @samuelcolvin
+* allow ``Pattern`` type, fix #303 by @samuelcolvin
+
+v0.15.0 (2018-11-15)
+....................
 * move codebase to use black, #287 by @samuelcolvin
 * fix alias use in settings, #286 by @jasonkuhrt and @samuelcolvin
 * fix datetime parsing in ``parse_date``, #298 by @samuelcolvin
 * allow dataclass inheritance, fix #293 by @samuelcolvin
 
-v0.14 (2018-10-02)
-..................
+v0.14.0 (2018-10-02)
+....................
 * dataclasses decorator, #269 by @Gaunt and @samuelcolvin
 
 v0.13.1 (2018-09-21)
diff --git a/pydantic/errors.py b/pydantic/errors.py
index ea7cd56ec..434911491 100644
--- a/pydantic/errors.py
+++ b/pydantic/errors.py
@@ -261,3 +261,8 @@ class JsonError(PydanticValueError):
 class JsonTypeError(PydanticTypeError):
     code = 'json'
     msg_template = 'JSON object must be str, bytes or bytearray'
+
+
+class PatternError(PydanticValueError):
+    code = 'regex_pattern'
+    msg_template = 'Invalid regular expression'
diff --git a/pydantic/fields.py b/pydantic/fields.py
index 120cedb6d..249a8bd3b 100644
--- a/pydantic/fields.py
+++ b/pydantic/fields.py
@@ -1,6 +1,6 @@
 import inspect
 from enum import Enum, IntEnum
-from typing import Any, Callable, List, Mapping, NamedTuple, Set, Tuple, Type, Union
+from typing import Any, Callable, List, Mapping, NamedTuple, Pattern, Set, Tuple, Type, Union
 
 from . import errors as errors_
 from .error_wrappers import ErrorWrapper
@@ -205,12 +205,15 @@ class Field:
         else:
             return display_as_type(self.type_)
 
-    def _populate_sub_fields(self):
+    def _populate_sub_fields(self):  # noqa: C901 (ignore complexity)
         # typing interface is horrible, we have to do some ugly checks
         if isinstance(self.type_, type) and issubclass(self.type_, JsonWrapper):
             self.type_ = self.type_.inner_type
             self.parse_json = True
 
+        if self.type_ is Pattern:
+            # python 3.7 only, Pattern is a typing object but without sub fields
+            return
         origin = getattr(self.type_, '__origin__', None)
         if origin is None:
             # field is not "typing" object eg. Union, Dict, List etc.
diff --git a/pydantic/types.py b/pydantic/types.py
index aeb8b42da..ebd5afe00 100644
--- a/pydantic/types.py
+++ b/pydantic/types.py
@@ -219,8 +219,9 @@ class PyObject:
 
     @classmethod
     def validate(cls, value):
-        with change_exception(errors.PyObjectError, ImportError):
-            return import_string(value)
+        if value is not None:
+            with change_exception(errors.PyObjectError, ImportError):
+                return import_string(value)
 
 
 class DSN(str):
diff --git a/pydantic/validators.py b/pydantic/validators.py
index 455fe1047..67cd3c401 100644
--- a/pydantic/validators.py
+++ b/pydantic/validators.py
@@ -1,9 +1,10 @@
+import re
 from collections import OrderedDict
 from datetime import date, datetime, time, timedelta
 from decimal import Decimal, DecimalException
 from enum import Enum
 from pathlib import Path
-from typing import Any
+from typing import Any, Pattern
 from uuid import UUID
 
 from . import errors
@@ -217,6 +218,12 @@ def make_arbitrary_type_validator(type_):
     return arbitrary_type_validator
 
 
+def pattern_validator(v) -> Pattern:
+    with change_exception(errors.PatternError, re.error):
+        return re.compile(v)
+
+
+pattern_validators = [not_none_validator, str_validator, pattern_validator]
 # order is important here, for example: bool is a subclass of int so has to come first, datetime before date same
 _VALIDATORS = [
     (Enum, [enum_validator]),
@@ -243,6 +250,8 @@ _VALIDATORS = [
 def find_validators(type_, arbitrary_types_allowed=False):
     if type_ is Any:
         return []
+    if type_ is Pattern:
+        return pattern_validators
 
     supertype = _find_supertype(type_)
     if supertype is not None:
diff --git a/pydantic/version.py b/pydantic/version.py
index e3b7144b3..887b62b2a 100644
--- a/pydantic/version.py
+++ b/pydantic/version.py
@@ -2,4 +2,4 @@ from distutils.version import StrictVersion
 
 __all__ = ['VERSION']
 
-VERSION = StrictVersion('0.15')
+VERSION = StrictVersion('0.15.1')
diff --git a/setup.py b/setup.py
index 281731790..b72178b90 100644
--- a/setup.py
+++ b/setup.py
@@ -1,14 +1,39 @@
+import re
 from importlib.machinery import SourceFileLoader
 from pathlib import Path
 from setuptools import setup
 
+
+class ReplaceLinks:
+    def __init__(self):
+        self.links = set()
+
+    def replace_issues(self, m):
+        id = m.group(1)
+        self.links.add(f'.. _#{id}: https://github.com/samuelcolvin/pydantic/issues/{id}')
+        return f'`#{id}`_'
+
+    def replace_users(self, m):
+        name = m.group(2)
+        self.links.add(f'.. _@{name}: https://github.com/{name}')
+        return f'{m.group(1)}`@{name}`_'
+
+    def extra(self):
+        return '\n\n' + '\n'.join(self.links) + '\n'
+
+
 description = 'Data validation and settings management using python 3.6 type hinting'
 THIS_DIR = Path(__file__).resolve().parent
 try:
-    long_description = '\n\n'.join([
-        THIS_DIR.joinpath('README.rst').read_text(),
-        THIS_DIR.joinpath('HISTORY.rst').read_text()
-    ])
+    history = THIS_DIR.joinpath('HISTORY.rst').read_text()
+
+    replacer = ReplaceLinks()
+    history = re.sub(r'#(\d+)', replacer.replace_issues, history)
+    history = re.sub(r'( +)@(\w+)', replacer.replace_users, history, flags=re.I)
+    history = re.sub(r'@@', '@', history)
+    history += replacer.extra()
+
+    long_description = '\n\n'.join([THIS_DIR.joinpath('README.rst').read_text(), history])
 except FileNotFoundError:
     long_description = description + '.\n\nSee https://pydantic-docs.helpmanual.io/ for documentation.'
 
diff --git a/tests/test_types.py b/tests/test_types.py
index 58d18c2c4..bd8910819 100644
--- a/tests/test_types.py
+++ b/tests/test_types.py
@@ -105,11 +105,10 @@ def test_dsn_no_driver():
     ]
 
 
-class PyObjectModel(BaseModel):
-    module: PyObject = 'os.path'
-
-
 def test_module_import():
+    class PyObjectModel(BaseModel):
+        module: PyObject = 'os.path'
+
     m = PyObjectModel()
     assert m.module == os.path
     with pytest.raises(ValidationError) as exc_info:
@@ -119,6 +118,14 @@ def test_module_import():
     ]
 
 
+def test_pyobject_none():
+    class PyObjectModel(BaseModel):
+        module: PyObject = None
+
+    m = PyObjectModel()
+    assert m.module is None
+
+
 class CheckModel(BaseModel):
     bool_check = True
     str_check = 's'
diff --git a/tests/test_validators.py b/tests/test_validators.py
index cabdb4a6f..aae75490b 100644
--- a/tests/test_validators.py
+++ b/tests/test_validators.py
@@ -1,4 +1,4 @@
-from typing import List
+from typing import List, Pattern
 
 import pytest
 
@@ -349,3 +349,26 @@ def test_validate_parent_extra():
     assert Child(a='this is foobar good').a == 'THIS IS FOOBAR GOOD'
     with pytest.raises(ValidationError):
         Child(a='snap')
+
+
+def test_pattern():
+    class Foobar(BaseModel):
+        pattern: Pattern
+
+    f = Foobar(pattern=r'^whatev.r\d$')
+    # SRE_Pattern for 3.6, Pattern for 3.7
+    assert f.pattern.__class__.__name__ in {'SRE_Pattern', 'Pattern'}
+    # check it's really a proper pattern
+    assert f.pattern.match('whatever1')
+    assert not f.pattern.match(' whatever1')
+
+
+def test_pattern_error():
+    class Foobar(BaseModel):
+        pattern: Pattern
+
+    with pytest.raises(ValidationError) as exc_info:
+        Foobar(pattern=f'[xx')
+    assert exc_info.value.errors() == [
+        {'loc': ('pattern',), 'msg': 'Invalid regular expression', 'type': 'value_error.regex_pattern'}
+    ]
