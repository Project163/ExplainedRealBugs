diff --git a/changes/5595-lig.md b/changes/5595-lig.md
new file mode 100644
index 000000000..c5c6a424c
--- /dev/null
+++ b/changes/5595-lig.md
@@ -0,0 +1 @@
+It is now impossible to use strings (`str` or `bytes`) subclasses as values for `Sequence[str]` and `Sequence[bytes]` schema.
diff --git a/docs/usage/types/sequence_iterable.md b/docs/usage/types/sequence_iterable.md
index 05201a1a7..3f5a584d0 100644
--- a/docs/usage/types/sequence_iterable.md
+++ b/docs/usage/types/sequence_iterable.md
@@ -64,6 +64,53 @@ print(Model(deque=[1, 2, 3]).deque)
 #> deque([1, 2, 3])
 ```
 
+### Strings aren't Sequences
+
+
+*pydantic* doesn't treat strings, i.e. `str` and `bytes` subclasses, as sequences:
+
+```py
+from typing import Optional, Sequence
+
+from pydantic import BaseModel, ValidationError
+
+
+class Model(BaseModel):
+    sequence_of_strs: Optional[Sequence[str]] = None
+    sequence_of_bytes: Optional[Sequence[bytes]] = None
+
+
+print(Model(sequence_of_strs=['a', 'bc']).sequence_of_strs)
+#> ['a', 'bc']
+print(Model(sequence_of_strs=('a', 'bc')).sequence_of_strs)
+#> ('a', 'bc')
+print(Model(sequence_of_bytes=[b'a', b'bc']).sequence_of_bytes)
+#> [b'a', b'bc']
+print(Model(sequence_of_bytes=(b'a', b'bc')).sequence_of_bytes)
+#> (b'a', b'bc')
+
+
+try:
+    Model(sequence_of_strs='abc')
+except ValidationError as e:
+    print(e)
+    """
+    1 validation error for Model
+    sequence_of_strs
+      'str' instances are not allowed as a Sequence value [type=sequence_str, input_value='abc', input_type=str]
+    """
+try:
+    Model(sequence_of_bytes=b'abc')
+except ValidationError as e:
+    print(e)
+    """
+    1 validation error for Model
+    sequence_of_bytes
+      'bytes' instances are not allowed as a Sequence value [type=sequence_str, input_value=b'abc', input_type=bytes]
+    """
+```
+
+
 ## Infinite Generators
 
 If you have a generator you can use `Sequence` as described above. In that case, the
diff --git a/pydantic/_internal/_validators.py b/pydantic/_internal/_validators.py
index 2206dff76..8c2d61b66 100644
--- a/pydantic/_internal/_validators.py
+++ b/pydantic/_internal/_validators.py
@@ -55,23 +55,21 @@ def sequence_validator(
     Validator for `Sequence` types, isinstance(v, Sequence) has already been called.
     """
     value_type = type(__input_value)
+
+    # We don't accept any plain string as a sequence
+    # Relevant issue: https://github.com/pydantic/pydantic/issues/5595
+    if issubclass(value_type, (str, bytes)):
+        raise PydanticCustomError(
+            'sequence_str',
+            "'{type_name}' instances are not allowed as a Sequence value",
+            {'type_name': value_type.__name__},
+        )
+
     v_list = validator(__input_value)
 
     # the rest of the logic is just re-creating the original type from `v_list`
     if value_type == list:
         return v_list
-    elif issubclass(value_type, str):
-        try:
-            return ''.join(v_list)
-        except TypeError:
-            # can happen if you pass a string like '123' to `Sequence[int]`
-            raise PydanticKnownError('string_type')
-    elif issubclass(value_type, bytes):
-        try:
-            return b''.join(v_list)
-        except TypeError:
-            # can happen if you pass a string like '123' to `Sequence[int]`
-            raise PydanticKnownError('bytes_type')
     elif issubclass(value_type, range):
         # return the list as we probably can't re-create the range
         return v_list
diff --git a/tests/test_edge_cases.py b/tests/test_edge_cases.py
index 4f4e5fa12..341bdafc2 100644
--- a/tests/test_edge_cases.py
+++ b/tests/test_edge_cases.py
@@ -2448,3 +2448,48 @@ def test_invalid_forward_ref_model():
     assert exc_info.value.errors() == [
         {'input': C(), 'loc': ('B',), 'msg': 'Input should be a valid dictionary', 'type': 'dict_type'}
     ]
+
+
+@pytest.mark.skipif(sys.version_info < (3, 9), reason='cannot parametrize types before 3.9')
+@pytest.mark.parametrize(
+    ('sequence_type', 'input_data', 'expected_error_type', 'expected_error_msg', 'expected_error_ctx'),
+    [
+        pytest.param(List[str], '1bc', 'list_type', 'Input should be a valid list', None, id='list[str]'),
+        pytest.param(
+            Sequence[str],
+            '1bc',
+            'sequence_str',
+            "'str' instances are not allowed as a Sequence value",
+            {'type_name': 'str'},
+            id='Sequence[str]',
+        ),
+        pytest.param(
+            Sequence[bytes],
+            b'1bc',
+            'sequence_str',
+            "'bytes' instances are not allowed as a Sequence value",
+            {'type_name': 'bytes'},
+            id='Sequence[bytes]',
+        ),
+    ],
+)
+def test_sequences_str(sequence_type, input_data, expected_error_type, expected_error_msg, expected_error_ctx):
+    input_sequence = [input_data[:1], input_data[1:]]
+    expected_error = {
+        'type': expected_error_type,
+        'input': input_data,
+        'loc': ('str_sequence',),
+        'msg': expected_error_msg,
+    }
+    if expected_error_ctx is not None:
+        expected_error.update(ctx=expected_error_ctx)
+
+    class Model(BaseModel):
+        str_sequence: sequence_type
+
+    assert Model(str_sequence=input_sequence).str_sequence == input_sequence
+
+    with pytest.raises(ValidationError) as e:
+        Model(str_sequence=input_data)
+
+    assert e.value.errors() == [expected_error]
