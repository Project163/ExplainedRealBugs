diff --git a/HISTORY.rst b/HISTORY.rst
index 21b5a2c72..043168a9b 100644
--- a/HISTORY.rst
+++ b/HISTORY.rst
@@ -9,6 +9,7 @@ v0.24 (unreleased)
 * fix secret serialization, #465 by @atheuz
 * Support custom validators for dataclasses, #454 by @primal100
 * fix ``parse_obj`` to cope with dict-like objects, #472 by @samuelcolvin
+* fix to schema generation in nested dataclass-based models, #474 by @NoAnyLove
 
 v0.23 (2019-04-04)
 ..................
diff --git a/pydantic/schema.py b/pydantic/schema.py
index bdc0923f9..c06c5133b 100644
--- a/pydantic/schema.py
+++ b/pydantic/schema.py
@@ -3,7 +3,7 @@ from datetime import date, datetime, time, timedelta
 from decimal import Decimal
 from enum import Enum
 from pathlib import Path
-from typing import Any, Callable, Dict, List, Optional, Sequence, Set, Tuple, Type, Union, cast
+from typing import TYPE_CHECKING, Any, Callable, Dict, List, Optional, Sequence, Set, Tuple, Type, Union, cast
 from uuid import UUID
 
 from . import main
@@ -34,6 +34,9 @@ from .types import (
 )
 from .utils import clean_docstring, is_callable_type, lenient_issubclass
 
+if TYPE_CHECKING:  # pragma: no cover
+    from . import dataclasses  # noqa: F401
+
 __all__ = [
     'Schema',
     'schema',
@@ -363,6 +366,9 @@ def get_flat_models_from_field(field: Field) -> Set[Type['main.BaseModel']]:
         flat_models |= get_flat_models_from_fields(field.sub_fields)
     elif lenient_issubclass(field.type_, main.BaseModel):
         flat_models |= get_flat_models_from_model(field.type_)
+    elif lenient_issubclass(getattr(field.type_, '__pydantic_model__', None), main.BaseModel):
+        field.type_ = cast(Type['dataclasses.DataclassType'], field.type_)
+        flat_models |= get_flat_models_from_model(field.type_.__pydantic_model__)
     return flat_models
 
 
@@ -671,13 +677,18 @@ def field_singleton_schema(  # noqa: C901 (ignore complexity)
     for type_, t_schema in field_class_to_schema_enum_disabled:
         if issubclass(field.type_, type_):
             return t_schema, definitions
-    if issubclass(field.type_, main.BaseModel):
+    # Handle dataclass-based models
+    field_type = field.type_
+    if lenient_issubclass(getattr(field_type, '__pydantic_model__', None), main.BaseModel):
+        field_type = cast(Type['dataclasses.DataclassType'], field_type)
+        field_type = field_type.__pydantic_model__
+    if issubclass(field_type, main.BaseModel):
         sub_schema, sub_definitions = model_process_schema(
-            field.type_, by_alias=by_alias, model_name_map=model_name_map, ref_prefix=ref_prefix
+            field_type, by_alias=by_alias, model_name_map=model_name_map, ref_prefix=ref_prefix
         )
         definitions.update(sub_definitions)
         if not schema_overrides:
-            model_name = model_name_map[field.type_]
+            model_name = model_name_map[field_type]
             definitions[model_name] = sub_schema
             return {'$ref': f'{ref_prefix}{model_name}'}, definitions
         else:
diff --git a/tests/test_dataclasses.py b/tests/test_dataclasses.py
index 0d0dd55e6..7cdd4b1bf 100644
--- a/tests/test_dataclasses.py
+++ b/tests/test_dataclasses.py
@@ -301,3 +301,28 @@ def test_schema():
         },
         'required': ['id'],
     }
+
+
+def test_nested_schema():
+    @pydantic.dataclasses.dataclass
+    class Nested:
+        number: int
+
+    @pydantic.dataclasses.dataclass
+    class Outer:
+        n: Nested
+
+    assert Outer.__pydantic_model__.schema() == {
+        'title': 'Outer',
+        'type': 'object',
+        'properties': {'n': {'$ref': '#/definitions/Nested'}},
+        'required': ['n'],
+        'definitions': {
+            'Nested': {
+                'title': 'Nested',
+                'type': 'object',
+                'properties': {'number': {'title': 'Number', 'type': 'integer'}},
+                'required': ['number'],
+            }
+        },
+    }
