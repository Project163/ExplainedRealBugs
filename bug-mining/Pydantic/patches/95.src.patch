diff --git a/changes/1210-prettywood.md b/changes/1210-prettywood.md
new file mode 100644
index 000000000..df5e7ceec
--- /dev/null
+++ b/changes/1210-prettywood.md
@@ -0,0 +1 @@
+Add `default_factory` argument to `Field` to create a dynamic default value by passing a zero-argument callable.
diff --git a/docs/examples/models_default_factory.py b/docs/examples/models_default_factory.py
new file mode 100644
index 000000000..67fc1569a
--- /dev/null
+++ b/docs/examples/models_default_factory.py
@@ -0,0 +1,9 @@
+from pydantic import BaseModel, Field
+from uuid import UUID, uuid4
+
+class Model(BaseModel):
+    uid: UUID = Field(default_factory=uuid4)
+
+m1 = Model()
+m2 = Model()
+assert m1.uid != m2.uid
diff --git a/docs/usage/models.md b/docs/usage/models.md
index 541530bc2..0ea40d716 100644
--- a/docs/usage/models.md
+++ b/docs/usage/models.md
@@ -471,6 +471,26 @@ _(This script is complete, it should run "as is")_
 In this model, `a`, `b`, and `c` can take `None` as a value. But `a` is optional, while `b` and `c` are required.
 `b` and `c` require a value, even if the value is `None`.
 
+## Field with dynamic default value
+
+When declaring a field with a default value, you may want it to be dynamic (i.e. different for each model).
+To do this, you may want to use a `default_factory`.
+
+!!! info "In Beta"
+    The `default_factory` argument is in **beta**, it has been added to *pydantic* in **v1.5** on a
+    **provisional basis**. It may change significantly in future releases and its signature or behaviour will not
+    be concrete until **v2**. Feedback from the community while it's still provisional would be extremely useful;
+    either comment on [#866](https://github.com/samuelcolvin/pydantic/issues/866) or create a new issue.
+
+Example of usage:
+
+```py
+{!.tmp_examples/models_default_factory.py!}
+```
+_(This script is complete, it should run "as is")_
+
+Where `Field` refers to the [field function](schema.md#field-customisation).
+
 ## Parsing data into a specified type
 
 Pydantic includes a standalone utility function `parse_obj_as` that can be used to apply the parsing
diff --git a/docs/usage/schema.md b/docs/usage/schema.md
index a02cdde97..02ba8e0c4 100644
--- a/docs/usage/schema.md
+++ b/docs/usage/schema.md
@@ -41,6 +41,9 @@ It has the following arguments:
 * `default`: (a positional argument) the default value of the field.
     Since the `Field` replaces the field's default, this first argument can be used to set the default.
     Use ellipsis (`...`) to indicate the field is required.
+* `default_factory`: a zero-argument callable that will be called when a default value is needed for this field.
+    Among other purposes, this can be used to set dynamic default values.
+    It is forbidden to set both `default` and `default_factory`.
 * `alias`: the public name of the field
 * `title`: if omitted, `field_name.title()` is used
 * `description`: if omitted and the annotation is a sub-model,
diff --git a/pydantic/fields.py b/pydantic/fields.py
index 5d5a5043c..5e1422888 100644
--- a/pydantic/fields.py
+++ b/pydantic/fields.py
@@ -1,5 +1,6 @@
 import warnings
 from collections.abc import Iterable as CollectionsIterable
+from copy import deepcopy
 from typing import (
     TYPE_CHECKING,
     Any,
@@ -29,6 +30,7 @@ from .typing import (
     AnyType,
     Callable,
     ForwardRef,
+    NoArgAnyCallable,
     NoneType,
     display_as_type,
     is_literal_type,
@@ -67,6 +69,7 @@ class FieldInfo(Representation):
 
     __slots__ = (
         'default',
+        'default_factory',
         'alias',
         'alias_priority',
         'title',
@@ -85,8 +88,9 @@ class FieldInfo(Representation):
         'extra',
     )
 
-    def __init__(self, default: Any, **kwargs: Any) -> None:
+    def __init__(self, default: Any = Undefined, **kwargs: Any) -> None:
         self.default = default
+        self.default_factory = kwargs.pop('default_factory', None)
         self.alias = kwargs.pop('alias', None)
         self.alias_priority = kwargs.pop('alias_priority', 2 if self.alias else None)
         self.title = kwargs.pop('title', None)
@@ -106,8 +110,9 @@ class FieldInfo(Representation):
 
 
 def Field(
-    default: Any,
+    default: Any = Undefined,
     *,
+    default_factory: Optional[NoArgAnyCallable] = None,
     alias: str = None,
     title: str = None,
     description: str = None,
@@ -130,6 +135,8 @@ def Field(
 
     :param default: since this is replacing the fieldâ€™s default, its first argument is used
       to set the default, use ellipsis (``...``) to indicate the field is required
+    :param default_factory: callable that will be called when a default value is needed for this field
+      If both `default` and `default_factory` are set, an error is raised.
     :param alias: the public name of the field
     :param title: can be any string, used in the schema
     :param description: can be any string, used in the schema
@@ -152,8 +159,12 @@ def Field(
       pattern string. The schema will have a ``pattern`` validation keyword
     :param **extra: any additional keyword arguments will be added as is to the schema
     """
+    if default is not Undefined and default_factory is not None:
+        raise ValueError('cannot specify both default and default_factory')
+
     return FieldInfo(
         default,
+        default_factory=default_factory,
         alias=alias,
         title=title,
         description=description,
@@ -208,6 +219,7 @@ class ModelField(Representation):
         'pre_validators',
         'post_validators',
         'default',
+        'default_factory',
         'required',
         'model_config',
         'name',
@@ -229,6 +241,7 @@ class ModelField(Representation):
         class_validators: Optional[Dict[str, Validator]],
         model_config: Type['BaseConfig'],
         default: Any = None,
+        default_factory: Optional[NoArgAnyCallable] = None,
         required: 'BoolUndefined' = Undefined,
         alias: str = None,
         field_info: Optional[FieldInfo] = None,
@@ -241,6 +254,7 @@ class ModelField(Representation):
         self.outer_type_: Any = type_
         self.class_validators = class_validators or {}
         self.default: Any = default
+        self.default_factory: Optional[NoArgAnyCallable] = default_factory
         self.required: 'BoolUndefined' = required
         self.model_config = model_config
         self.field_info: FieldInfo = field_info or FieldInfo(default)
@@ -257,6 +271,16 @@ class ModelField(Representation):
         self.model_config.prepare_field(self)
         self.prepare()
 
+    def get_default(self) -> Any:
+        if self.default_factory is not None:
+            value = self.default_factory()
+        elif self.default is None:
+            # deepcopy is quite slow on None
+            value = None
+        else:
+            value = deepcopy(self.default)
+        return value
+
     @classmethod
     def infer(
         cls,
@@ -272,13 +296,13 @@ class ModelField(Representation):
 
         if isinstance(value, FieldInfo):
             field_info = value
-            value = field_info.default
+            value = field_info.default_factory() if field_info.default_factory is not None else field_info.default
         else:
             field_info = FieldInfo(value, **field_info_from_config)
         required: 'BoolUndefined' = Undefined
         if value is Required:
             required = True
-            value = None
+            field_info.default = None
         elif value is not Undefined:
             required = False
         field_info.alias = field_info.alias or field_info_from_config.get('alias')
@@ -288,7 +312,8 @@ class ModelField(Representation):
             type_=annotation,
             alias=field_info.alias,
             class_validators=class_validators,
-            default=value,
+            default=field_info.default,
+            default_factory=field_info.default_factory,
             required=required,
             model_config=config,
             field_info=field_info,
@@ -316,8 +341,9 @@ class ModelField(Representation):
         Note: this method is **not** idempotent (because _type_analysis is not idempotent),
         e.g. calling it it multiple times may modify the field and configure it incorrectly.
         """
-        if self.default is not None and self.type_ is None:
-            self.type_ = type(self.default)
+        default_value = self.get_default()
+        if default_value is not None and self.type_ is None:
+            self.type_ = type(default_value)
             self.outer_type_ = self.type_
 
         if self.type_ is None:
@@ -332,14 +358,14 @@ class ModelField(Representation):
             v.always for v in self.class_validators.values()
         )
 
-        if self.required is False and self.default is None:
+        if self.required is False and default_value is None:
             self.allow_none = True
 
         self._type_analysis()
         if self.required is Undefined:
             self.required = True
             self.field_info.default = Required
-        if self.default is Undefined:
+        if self.default is Undefined and self.default_factory is None:
             self.default = None
         self.populate_validators()
 
@@ -726,7 +752,10 @@ class ModelField(Representation):
         args = [('name', self.name), ('type', self._type_display()), ('required', self.required)]
 
         if not self.required:
-            args.append(('default', self.default))
+            if self.default_factory is not None:
+                args.append(('default_factory', f'<function {self.default_factory.__name__}>'))
+            else:
+                args.append(('default', self.default))
 
         if self.alt_alias:
             args.append(('alias', self.alias))
diff --git a/pydantic/main.py b/pydantic/main.py
index 5b50bd4b0..a508eb80f 100644
--- a/pydantic/main.py
+++ b/pydantic/main.py
@@ -853,11 +853,7 @@ def validate_model(  # noqa: C901 (ignore complexity)
                 errors.append(ErrorWrapper(MissingError(), loc=field.alias))
                 continue
 
-            if field.default is None:
-                # deepcopy is quite slow on None
-                value = None
-            else:
-                value = deepcopy(field.default)
+            value = field.get_default()
 
             if not config.validate_all and not field.validate_always:
                 values[name] = value
diff --git a/pydantic/typing.py b/pydantic/typing.py
index 256eb409a..1b577c2a2 100644
--- a/pydantic/typing.py
+++ b/pydantic/typing.py
@@ -42,11 +42,13 @@ if sys.version_info < (3, 7):
     from typing import Callable as Callable
 
     AnyCallable = Callable[..., Any]
+    NoArgAnyCallable = Callable[[], Any]
 else:
     from collections.abc import Callable as Callable
     from typing import Callable as TypingCallable
 
     AnyCallable = TypingCallable[..., Any]
+    NoArgAnyCallable = TypingCallable[[], Any]
 
 if sys.version_info < (3, 8):
     if TYPE_CHECKING:
@@ -77,6 +79,7 @@ __all__ = (
     'ForwardRef',
     'Callable',
     'AnyCallable',
+    'NoArgAnyCallable',
     'AnyType',
     'NoneType',
     'display_as_type',
diff --git a/tests/test_main.py b/tests/test_main.py
index 678c70eea..1121ce6f9 100644
--- a/tests/test_main.py
+++ b/tests/test_main.py
@@ -1,5 +1,6 @@
 from enum import Enum
-from typing import Any, ClassVar, List, Mapping, Type
+from typing import Any, Callable, ClassVar, List, Mapping, Type
+from uuid import UUID, uuid4
 
 import pytest
 
@@ -50,6 +51,28 @@ def test_ultra_simple_repr():
         assert m.to_string() == 'a=10.2 b=10'
 
 
+def test_default_dict_repr():
+    def myfunc():
+        return 1
+
+    class Model(BaseModel):
+        a: int = Field(default_factory=myfunc)
+        b = Field(default_factory=myfunc)
+
+    m = Model()
+    assert str(m) == 'a=1 b=1'
+    assert repr(m) == 'Model(a=1, b=1)'
+    assert (
+        repr(m.__fields__['a']) == "ModelField(name='a', type=int, required=False, default_factory='<function myfunc>')"
+    )
+    assert (
+        repr(m.__fields__['b']) == "ModelField(name='b', type=int, required=False, default_factory='<function myfunc>')"
+    )
+    assert dict(m) == {'a': 1, 'b': 1}
+    assert m.dict() == {'a': 1, 'b': 1}
+    assert m.json() == '{"a": 1, "b": 1}'
+
+
 def test_comparing():
     m = UltraSimpleModel(a=10.2, b='100')
     assert m == {'a': 10.2, 'b': 100}
@@ -970,3 +993,35 @@ def test_custom_init_subclass_params():
         something = 1
 
     assert NewModel.something == 2
+
+
+def test_two_defaults():
+    with pytest.raises(ValueError, match='^cannot specify both default and default_factory$'):
+
+        class Model(BaseModel):
+            a: int = Field(default=3, default_factory=lambda: 3)
+
+
+def test_default_factory():
+    class ValueModel(BaseModel):
+        uid: UUID = uuid4()
+
+    m1 = ValueModel()
+    m2 = ValueModel()
+    assert m1.uid == m2.uid
+
+    class DynamicValueModel(BaseModel):
+        uid: UUID = Field(default_factory=uuid4)
+
+    m1 = DynamicValueModel()
+    m2 = DynamicValueModel()
+    assert isinstance(m1.uid, UUID)
+    assert m1.uid != m2.uid
+
+    # With a callable: we still should be able to set callables as defaults
+    class FunctionModel(BaseModel):
+        a: int = 1
+        uid: Callable[[], UUID] = Field(uuid4)
+
+    m = FunctionModel()
+    assert m.uid is uuid4
