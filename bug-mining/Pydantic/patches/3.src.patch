diff --git a/HISTORY.rst b/HISTORY.rst
index 3a58a8a2d..caf66134c 100644
--- a/HISTORY.rst
+++ b/HISTORY.rst
@@ -3,6 +3,10 @@
 History
 -------
 
+v0.12.2 (XXXX-XX-XX)
+....................
+* raise an exception if a field's name shadows an existing ``BaseModel`` attribute #242
+
 v0.12.1 (2018-07-31)
 ....................
 * fix schema generation for fields defined using ``typing.Any`` #237
diff --git a/pydantic/main.py b/pydantic/main.py
index 1bd6b386c..374d7d861 100644
--- a/pydantic/main.py
+++ b/pydantic/main.py
@@ -13,7 +13,7 @@ from .errors import ConfigError, ExtraError, MissingError
 from .fields import Field, Validator
 from .parse import Protocol, load_file, load_str_bytes
 from .types import StrBytes
-from .utils import clean_docstring, truncate
+from .utils import clean_docstring, truncate, validate_field_name
 from .validators import dict_validator
 
 
@@ -113,6 +113,7 @@ class MetaModel(ABCMeta):
         # annotation only fields need to come first in fields
         for ann_name, ann_type in annotations.items():
             if not ann_name.startswith('_') and ann_name not in namespace:
+                validate_field_name(bases, ann_name)
                 fields[ann_name] = Field.infer(
                     name=ann_name,
                     value=...,
@@ -123,6 +124,7 @@ class MetaModel(ABCMeta):
 
         for var_name, value in namespace.items():
             if not var_name.startswith('_') and not isinstance(value, TYPE_BLACKLIST):
+                validate_field_name(bases, var_name)
                 fields[var_name] = Field.infer(
                     name=var_name,
                     value=value,
diff --git a/pydantic/utils.py b/pydantic/utils.py
index f9ca2d024..1cfd6d8a1 100644
--- a/pydantic/utils.py
+++ b/pydantic/utils.py
@@ -4,7 +4,7 @@ from contextlib import contextmanager
 from enum import Enum
 from importlib import import_module
 from textwrap import dedent
-from typing import Tuple
+from typing import List, Tuple, Type
 
 from . import errors
 
@@ -155,3 +155,13 @@ def clean_docstring(d):
 
 def list_like(v):
     return isinstance(v, (list, tuple, set)) or inspect.isgenerator(v)
+
+
+def validate_field_name(bases: List[Type['BaseModel']], field_name: str) -> None:
+    """
+    Ensure that the field's name does not shadow an existing attribute of the model.
+    """
+    for base in bases:
+        if getattr(base, field_name, None):
+            raise NameError(f'Field name "{field_name}" shadows a BaseModel attribute; '
+                            f'use a different field name with "alias=\'{field_name}\'".')
diff --git a/tests/test_main.py b/tests/test_main.py
index c75ae2078..bb3330750 100644
--- a/tests/test_main.py
+++ b/tests/test_main.py
@@ -528,3 +528,17 @@ def test_arbitrary_types_not_allowed():
         class ArbitraryTypeNotAllowedModel(BaseModel):
             t: ArbitraryType
     assert exc_info.value.args[0].startswith('no validator found for')
+
+
+def test_annotation_field_name_shadows_attribute():
+    with pytest.raises(NameError):
+        # When defining a model that has an attribute with the name of a built-in attribute, an exception is raised
+        class BadModel(BaseModel):
+            schema: str  # This conflicts with the BaseModel's schema() class method
+
+
+def test_value_field_name_shadows_attribute():
+    # When defining a model that has an attribute with the name of a built-in attribute, an exception is raised
+    with pytest.raises(NameError):
+        class BadModel(BaseModel):
+            schema = 'abc'  # This conflicts with the BaseModel's schema() class method
