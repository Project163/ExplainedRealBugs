diff --git a/changes/2094-PrettyWood.md b/changes/2094-PrettyWood.md
new file mode 100644
index 000000000..b94bdbc20
--- /dev/null
+++ b/changes/2094-PrettyWood.md
@@ -0,0 +1 @@
+Handle properly fields of type `Callable` with a default value
\ No newline at end of file
diff --git a/pydantic/main.py b/pydantic/main.py
index 786ee2296..cefdceeb8 100644
--- a/pydantic/main.py
+++ b/pydantic/main.py
@@ -198,7 +198,11 @@ def validate_custom_root_type(fields: Dict[str, ModelField]) -> None:
         raise ValueError('__root__ cannot be mixed with other fields')
 
 
-UNTOUCHED_TYPES = FunctionType, property, type, classmethod, staticmethod
+# Annotated fields can have many types like `str`, `int`, `List[str]`, `Callable`...
+# If a field is of type `Callable`, its default value should be a function and cannot to ignored.
+ANNOTATED_FIELD_UNTOUCHED_TYPES: Tuple[Any, ...] = (property, type, classmethod, staticmethod)
+# When creating a `BaseModel` instance, we bypass all the methods, properties... added to the model
+UNTOUCHED_TYPES: Tuple[Any, ...] = (FunctionType,) + ANNOTATED_FIELD_UNTOUCHED_TYPES
 
 # Note `ModelMetaclass` refers to `BaseModel`, but is also used to *create* `BaseModel`, so we need to add this extra
 # (somewhat hacky) boolean to keep track of whether we've created the `BaseModel` class yet, and therefore whether it's
@@ -245,7 +249,6 @@ class ModelMetaclass(ABCMeta):
         class_vars = set()
         if (namespace.get('__module__'), namespace.get('__qualname__')) != ('pydantic.main', 'BaseModel'):
             annotations = resolve_annotations(namespace.get('__annotations__', {}), namespace.get('__module__', None))
-            untouched_types = UNTOUCHED_TYPES + config.keep_untouched
             # annotation only fields need to come first in fields
             for ann_name, ann_type in annotations.items():
                 if is_classvar(ann_type):
@@ -255,14 +258,14 @@ class ModelMetaclass(ABCMeta):
                     value = namespace.get(ann_name, Undefined)
                     allowed_types = get_args(ann_type) if get_origin(ann_type) is Union else (ann_type,)
                     if (
-                        isinstance(value, untouched_types)
+                        isinstance(value, ANNOTATED_FIELD_UNTOUCHED_TYPES)
                         and ann_type != PyObject
                         and not any(
                             lenient_issubclass(get_origin(allowed_type), Type) for allowed_type in allowed_types
                         )
                     ):
                         continue
-                    fields[ann_name] = inferred = ModelField.infer(
+                    fields[ann_name] = ModelField.infer(
                         name=ann_name,
                         value=value,
                         annotation=ann_type,
@@ -272,6 +275,7 @@ class ModelMetaclass(ABCMeta):
                 elif ann_name not in namespace and config.underscore_attrs_are_private:
                     private_attributes[ann_name] = PrivateAttr()
 
+            untouched_types = UNTOUCHED_TYPES + config.keep_untouched
             for var_name, value in namespace.items():
                 can_be_changed = var_name not in class_vars and not isinstance(value, untouched_types)
                 if isinstance(value, ModelPrivateAttr):
diff --git a/pydantic/schema.py b/pydantic/schema.py
index cf4dc4c7b..fbd592bac 100644
--- a/pydantic/schema.py
+++ b/pydantic/schema.py
@@ -188,7 +188,12 @@ def get_field_info_schema(field: ModelField) -> Tuple[Dict[str, Any], bool]:
         schema['description'] = field.field_info.description
         schema_overrides = True
 
-    if not field.required and not field.field_info.const and field.default is not None:
+    if (
+        not field.required
+        and not field.field_info.const
+        and field.default is not None
+        and not is_callable_type(field.outer_type_)
+    ):
         schema['default'] = encode_default(field.default)
         schema_overrides = True
 
diff --git a/tests/test_dataclasses.py b/tests/test_dataclasses.py
index 197db324b..80d79dc97 100644
--- a/tests/test_dataclasses.py
+++ b/tests/test_dataclasses.py
@@ -3,7 +3,7 @@ import pickle
 from collections.abc import Hashable
 from datetime import datetime
 from pathlib import Path
-from typing import ClassVar, Dict, FrozenSet, List, Optional
+from typing import Callable, ClassVar, Dict, FrozenSet, List, Optional
 
 import pytest
 
@@ -801,6 +801,60 @@ def test_forward_stdlib_dataclass_params():
         e.item.name = 'pika2'
 
 
+def test_pydantic_callable_field():
+    """pydantic callable fields behaviour should be the same as stdlib dataclass"""
+
+    def foo(arg1, arg2):
+        return arg1, arg2
+
+    def bar(x: int, y: float, z: str) -> bool:
+        return str(x + y) == z
+
+    class PydanticModel(BaseModel):
+        required_callable: Callable
+        required_callable_2: Callable[[int, float, str], bool]
+
+        default_callable: Callable = foo
+        default_callable_2: Callable[[int, float, str], bool] = bar
+
+    @pydantic.dataclasses.dataclass
+    class PydanticDataclass:
+        required_callable: Callable
+        required_callable_2: Callable[[int, float, str], bool]
+
+        default_callable: Callable = foo
+        default_callable_2: Callable[[int, float, str], bool] = bar
+
+    @dataclasses.dataclass
+    class StdlibDataclass:
+        required_callable: Callable
+        required_callable_2: Callable[[int, float, str], bool]
+
+        default_callable: Callable = foo
+        default_callable_2: Callable[[int, float, str], bool] = bar
+
+    pyd_m = PydanticModel(required_callable=foo, required_callable_2=bar)
+    pyd_dc = PydanticDataclass(required_callable=foo, required_callable_2=bar)
+    std_dc = StdlibDataclass(required_callable=foo, required_callable_2=bar)
+
+    assert (
+        pyd_m.required_callable
+        is pyd_m.default_callable
+        is pyd_dc.required_callable
+        is pyd_dc.default_callable
+        is std_dc.required_callable
+        is std_dc.default_callable
+    )
+    assert (
+        pyd_m.required_callable_2
+        is pyd_m.default_callable_2
+        is pyd_dc.required_callable_2
+        is pyd_dc.default_callable_2
+        is std_dc.required_callable_2
+        is std_dc.default_callable_2
+    )
+
+
 def test_pickle_overriden_builtin_dataclass(create_module):
     module = create_module(
         # language=Python
diff --git a/tests/test_schema.py b/tests/test_schema.py
index 356671623..99725fda3 100644
--- a/tests/test_schema.py
+++ b/tests/test_schema.py
@@ -1006,10 +1006,18 @@ def test_ipvanynetwork_type():
     }
 
 
-@pytest.mark.parametrize('annotation', [Callable, Callable[[int], int]])
-def test_callable_type(annotation):
+@pytest.mark.parametrize(
+    'type_,default_value',
+    (
+        (Callable, ...),
+        (Callable, lambda x: x),
+        (Callable[[int], int], ...),
+        (Callable[[int], int], lambda x: x),
+    ),
+)
+def test_callable_type(type_, default_value):
     class Model(BaseModel):
-        callback: annotation
+        callback: type_ = default_value
         foo: int
 
     with pytest.warns(UserWarning):
