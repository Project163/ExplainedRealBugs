diff --git a/changes/2109-bm424.md b/changes/2109-bm424.md
new file mode 100644
index 000000000..0d3c29cc6
--- /dev/null
+++ b/changes/2109-bm424.md
@@ -0,0 +1 @@
+Fix a regression where Enum fields would not propagate keyword arguments to the schema
\ No newline at end of file
diff --git a/pydantic/schema.py b/pydantic/schema.py
index a6a2777fd..e51d74ce1 100644
--- a/pydantic/schema.py
+++ b/pydantic/schema.py
@@ -260,7 +260,9 @@ def get_field_schema_validations(field: ModelField) -> Dict[str, Any]:
     f_schema: Dict[str, Any] = {}
 
     if lenient_issubclass(field.type_, Enum):
-        # schema is already updated by `enum_process_schema`
+        # schema is already updated by `enum_process_schema`; just update with field extra
+        if field.field_info.extra:
+            f_schema.update(field.field_info.extra)
         return f_schema
 
     if lenient_issubclass(field.type_, (str, bytes)):
diff --git a/tests/test_schema.py b/tests/test_schema.py
index 13d92585a..ddea9ede3 100644
--- a/tests/test_schema.py
+++ b/tests/test_schema.py
@@ -378,6 +378,33 @@ def test_enum_and_model_have_same_behaviour():
     }
 
 
+def test_list_enum_schema_extras():
+    class FoodChoice(str, Enum):
+        spam = 'spam'
+        egg = 'egg'
+        chips = 'chips'
+
+    class Model(BaseModel):
+        foods: List[FoodChoice] = Field(examples=[['spam', 'egg']])
+
+    assert Model.schema() == {
+        'definitions': {
+            'FoodChoice': {
+                'description': 'An enumeration.',
+                'enum': ['spam', 'egg', 'chips'],
+                'title': 'FoodChoice',
+                'type': 'string',
+            }
+        },
+        'properties': {
+            'foods': {'type': 'array', 'items': {'$ref': '#/definitions/FoodChoice'}, 'examples': [['spam', 'egg']]},
+        },
+        'required': ['foods'],
+        'title': 'Model',
+        'type': 'object',
+    }
+
+
 def test_json_schema():
     class Model(BaseModel):
         a = b'foobar'
