diff --git a/pydantic/_internal/_generate_schema.py b/pydantic/_internal/_generate_schema.py
index 2b9ab07cf..8aabb7e06 100644
--- a/pydantic/_internal/_generate_schema.py
+++ b/pydantic/_internal/_generate_schema.py
@@ -80,7 +80,7 @@ def generate_config(cls: type[BaseModel]) -> core_schema.CoreConfig:
 
 
 class GenerateSchema:
-    __slots__ = 'arbitrary_types', 'types_namespace', 'typevars_map'
+    __slots__ = 'arbitrary_types', 'types_namespace', 'typevars_map', '_recursion_cache'
 
     def __init__(
         self, arbitrary_types: bool, types_namespace: dict[str, Any] | None, typevars_map: dict[Any, Any] | None
@@ -88,6 +88,7 @@ class GenerateSchema:
         self.arbitrary_types = arbitrary_types
         self.types_namespace = types_namespace
         self.typevars_map = typevars_map
+        self._recursion_cache: dict[str, core_schema.DefinitionReferenceSchema] = {}
 
     def generate_schema(self, obj: Any) -> core_schema.CoreSchema:
         schema = self._generate_schema(obj)
@@ -326,7 +327,9 @@ class GenerateSchema:
         assert expected, f'literal "expected" cannot be empty, obj={literal_type}'
         return core_schema.literal_schema(*expected)
 
-    def _typed_dict_schema(self, typed_dict_cls: Any) -> core_schema.TypedDictSchema:
+    def _typed_dict_schema(
+        self, typed_dict_cls: Any
+    ) -> core_schema.TypedDictSchema | core_schema.DefinitionReferenceSchema:
         """
         Generate schema for a TypedDict.
 
@@ -351,6 +354,13 @@ class GenerateSchema:
         validation_functions = ValidationFunctions(())
         serialization_functions = SerializationFunctions(())
 
+        obj_ref = f'{typed_dict_cls.__module__}.{typed_dict_cls.__qualname__}:{id(typed_dict_cls)}'
+        if obj_ref in self._recursion_cache:
+            return self._recursion_cache[obj_ref]
+        else:
+            recursive_schema = core_schema.definition_reference_schema(obj_ref)
+            self._recursion_cache[obj_ref] = recursive_schema
+
         for field_name, annotation in _typing_extra.get_type_hints(typed_dict_cls, include_extras=True).items():
             required = field_name in required_keys
 
diff --git a/tests/test_types_typeddict.py b/tests/test_types_typeddict.py
index ae5891309..35a511467 100644
--- a/tests/test_types_typeddict.py
+++ b/tests/test_types_typeddict.py
@@ -3,7 +3,7 @@ Tests for TypedDict
 """
 import sys
 import typing
-from typing import Optional
+from typing import Generic, List, Optional, TypeVar
 
 import pytest
 import typing_extensions
@@ -378,3 +378,111 @@ def test_typeddict_annotated(TypedDict, input_value, expected):
             Model(d=input_value)
     else:
         assert Model(d=input_value).d == expected
+
+
+class RecursiveTypedDict(typing_extensions.TypedDict):
+    # TODO: See if we can get this working if defined in a function (right now, needs to be module-level)
+    foo: Optional['RecursiveTypedDict']
+
+
+def test_recursive_typeddict():
+    class RecursiveTypedDictModel(BaseModel):
+        rec: RecursiveTypedDict
+
+    assert RecursiveTypedDictModel(rec={'foo': {'foo': None}}).rec == {'foo': {'foo': None}}
+    with pytest.raises(ValidationError) as exc_info:
+        RecursiveTypedDictModel(rec={'foo': {'foo': {'foo': 1}}})
+    assert exc_info.value.errors() == [
+        {
+            'input': 1,
+            'loc': ('rec', 'foo', 'foo', 'foo'),
+            'msg': 'Input should be a valid dictionary',
+            'type': 'dict_type',
+        }
+    ]
+
+
+T = TypeVar('T')
+
+
+@pytest.mark.xfail(reason='generic typed dict')
+def test_generic_typeddict_in_concrete_model():
+    T = TypeVar('T')
+
+    class GenericTypedDict(typing_extensions.TypedDict, Generic[T]):
+        x: T
+
+    class Model(BaseModel):
+        y: GenericTypedDict[int]
+
+    Model[int](y={'x': 1})
+    with pytest.raises(ValidationError) as exc_info:
+        Model[int](y={'x': 'a'})
+    assert exc_info.value.errors() == [
+        {
+            'input': 'a',
+            'loc': ('y', 'x'),
+            'msg': 'Input should be a valid integer, unable to parse string as an ' 'integer',
+            'type': 'int_parsing',
+        }
+    ]
+
+
+@pytest.mark.xfail(reason='generic typed dict')
+def test_generic_typeddict_in_generic_model():
+    T = TypeVar('T')
+
+    class GenericTypedDict(typing_extensions.TypedDict, Generic[T]):
+        x: T
+
+    class Model(BaseModel, Generic[T]):
+        y: GenericTypedDict[T]
+
+    Model[int](y={'x': 1})
+    with pytest.raises(ValidationError) as exc_info:
+        Model[int](y={'x': 'a'})
+    assert exc_info.value.errors() == [
+        {
+            'input': 'a',
+            'loc': ('y', 'x'),
+            'msg': 'Input should be a valid integer, unable to parse string as an ' 'integer',
+            'type': 'int_parsing',
+        }
+    ]
+
+
+T = TypeVar('T')
+
+
+class RecursiveGenTypedDict(typing_extensions.TypedDict, Generic[T]):
+    # TODO: See if we can get this working if defined in a function (right now, needs to be module-level)
+    foo: Optional['RecursiveGenTypedDict[T]']
+    ls: List[T]
+
+
+@pytest.mark.xfail(reason='Generic typed dict')
+def test_recursive_generic_typeddict():
+    class RecursiveGenTypedDictModel(BaseModel, Generic[T]):
+        # TODO: check what happens if RecursiveGenTypedDict is a forward reference
+        rec: RecursiveGenTypedDict[T]
+
+    int_data: RecursiveGenTypedDict[int] = {'foo': {'foo': None, 'ls': [1]}, 'ls': [1]}
+    assert RecursiveGenTypedDictModel[int](rec=int_data).rec == int_data
+
+    str_data: RecursiveGenTypedDict[str] = {'foo': {'foo': None, 'ls': ['a']}, 'ls': ['a']}
+    with pytest.raises(ValidationError) as exc_info:
+        RecursiveGenTypedDictModel[int](rec=str_data)
+    assert exc_info.value.errors() == [
+        {
+            'input': 'a',
+            'loc': ('rec', 'foo', 'ls', 0),
+            'msg': 'Input should be a valid integer, unable to parse string as an ' 'integer',
+            'type': 'int_parsing',
+        },
+        {
+            'input': 'a',
+            'loc': ('rec', 'ls', 0),
+            'msg': 'Input should be a valid integer, unable to parse string as an ' 'integer',
+            'type': 'int_parsing',
+        },
+    ]
