diff --git a/HISTORY.rst b/HISTORY.rst
index 5d2530f3f..e1940d19f 100644
--- a/HISTORY.rst
+++ b/HISTORY.rst
@@ -3,6 +3,10 @@
 History
 -------
 
+v0.19.0 (unreleased)
+....................
+* Support ``Callable`` type hint, fix #279 by @proofit404
+
 v0.18.2 (2019-01-22)
 ....................
 * Fix to schema generation with ``Optional`` fields, fix #361 by @samuelcolvin
diff --git a/docs/examples/callable.py b/docs/examples/callable.py
new file mode 100644
index 000000000..a235bb8bd
--- /dev/null
+++ b/docs/examples/callable.py
@@ -0,0 +1,9 @@
+from typing import Callable
+from pydantic import BaseModel
+
+class Foo(BaseModel):
+    callback: Callable[[int], int]
+
+m = Foo(callback=lambda x: x)
+print(m)
+# Foo callback=<function <lambda> at 0x7f16bc73e1e0>
diff --git a/docs/index.rst b/docs/index.rst
index 660ea561a..b5f37df46 100644
--- a/docs/index.rst
+++ b/docs/index.rst
@@ -287,7 +287,7 @@ Optionally the ``Schema`` class can be used to provide extra information about t
   JSON Schema
 * ``max_length`` for string values, adds a corresponding validation and an annotation of ``maxLength`` to the
   JSON Schema
-* ``regex`` for string values, adds a Regular Expression validation generated from the passed string and an 
+* ``regex`` for string values, adds a Regular Expression validation generated from the passed string and an
   annotation of ``pattern`` to the JSON Schema
 * ``**`` any other keyword arguments (eg. ``examples``) will be added verbatim to the field's schema
 
@@ -390,6 +390,18 @@ Exotic Types
 
 (This script is complete, it should run "as is")
 
+Fields can also be of type ``Callable``:
+
+.. literalinclude:: examples/callable.py
+
+(This script is complete, it should run "as is")
+
+.. warning::
+
+    Callable fields only perform a simple check that the argument is
+    callable, no validation of arguments, their types or the return
+    type is performed.
+
 Json Type
 .........
 
diff --git a/pydantic/errors.py b/pydantic/errors.py
index d763dc8de..e1fb42718 100644
--- a/pydantic/errors.py
+++ b/pydantic/errors.py
@@ -276,3 +276,7 @@ class PatternError(PydanticValueError):
 class DataclassTypeError(PydanticTypeError):
     code = 'dataclass'
     msg_template = 'instance of {class_name}, tuple or dict expected'
+
+
+class CallableError(PydanticTypeError):
+    msg_template = '{value} is not callable'
diff --git a/pydantic/fields.py b/pydantic/fields.py
index 9f7f85e35..42604f825 100644
--- a/pydantic/fields.py
+++ b/pydantic/fields.py
@@ -6,7 +6,7 @@ from . import errors as errors_
 from .class_validators import Validator, ValidatorSignature, get_validator_signature
 from .error_wrappers import ErrorWrapper
 from .types import Json, JsonWrapper
-from .utils import ForwardRef, display_as_type, lenient_issubclass, list_like
+from .utils import Callable, ForwardRef, display_as_type, lenient_issubclass, list_like
 from .validators import NoneType, dict_validator, find_validators, is_none_validator
 
 Required: Any = Ellipsis
@@ -146,6 +146,8 @@ class Field:
         if origin is None:
             # field is not "typing" object eg. Union, Dict, List etc.
             return
+        if origin is Callable:
+            return
         if origin is Union:
             types_ = []
             for type_ in self.type_.__args__:
diff --git a/pydantic/schema.py b/pydantic/schema.py
index 048cac02b..da35fe507 100644
--- a/pydantic/schema.py
+++ b/pydantic/schema.py
@@ -1,3 +1,4 @@
+import warnings
 from datetime import date, datetime, time, timedelta
 from decimal import Decimal
 from enum import Enum
@@ -29,7 +30,7 @@ from .types import (
     conint,
     constr,
 )
-from .utils import clean_docstring, lenient_issubclass
+from .utils import clean_docstring, is_callable_type, lenient_issubclass
 
 __all__ = [
     'Schema',
@@ -478,9 +479,13 @@ def model_type_schema(
     required = []
     definitions = {}
     for k, f in model.__fields__.items():
-        f_schema, f_definitions = field_schema(
-            f, by_alias=by_alias, model_name_map=model_name_map, ref_prefix=ref_prefix
-        )
+        try:
+            f_schema, f_definitions = field_schema(
+                f, by_alias=by_alias, model_name_map=model_name_map, ref_prefix=ref_prefix
+            )
+        except SkipField as skip:
+            warnings.warn(skip.message, UserWarning)
+            continue
         definitions.update(f_definitions)
         if by_alias:
             properties[f.alias] = f_schema
@@ -609,6 +614,8 @@ def field_singleton_schema(  # noqa: C901 (ignore complexity)
         )
     if field.type_ is Any:
         return {}, definitions  # no restrictions
+    if is_callable_type(field.type_):
+        raise SkipField(f'Callable {field.name} was excluded from schema since JSON schema has no equivalent type.')
     f_schema = {}
     if issubclass(field.type_, Enum):
         f_schema.update({'enum': [item.value for item in field.type_]})
@@ -688,3 +695,12 @@ def get_annotation_from_schema(annotation, schema):
             if kwargs:
                 return constraint_func(**kwargs)
     return annotation
+
+
+class SkipField(Exception):
+    """
+    Utility exception used to exclude fields from schema.
+    """
+
+    def __init__(self, message):
+        self.message = message
diff --git a/pydantic/utils.py b/pydantic/utils.py
index f8822e47d..a6a80d67a 100644
--- a/pydantic/utils.py
+++ b/pydantic/utils.py
@@ -26,6 +26,11 @@ except ImportError:
     # python 3.6
     ForwardRef = None
 
+if sys.version_info < (3, 7):
+    from typing import Callable
+else:
+    from collections.abc import Callable
+
 PRETTY_REGEX = re.compile(r'([\w ]*?) *<(.*)> *')
 
 
@@ -246,3 +251,7 @@ def resolve_annotations(raw_annotations, module):
             pass
         annotations[name] = value
     return annotations
+
+
+def is_callable_type(type_):
+    return type_ is Callable or getattr(type_, '__origin__', None) is Callable
diff --git a/pydantic/validators.py b/pydantic/validators.py
index 26af4816b..2e471ff52 100644
--- a/pydantic/validators.py
+++ b/pydantic/validators.py
@@ -4,12 +4,12 @@ from datetime import date, datetime, time, timedelta
 from decimal import Decimal, DecimalException
 from enum import Enum
 from pathlib import Path
-from typing import Any, Pattern
+from typing import Any, Callable, Pattern
 from uuid import UUID
 
 from . import errors
 from .datetime_parse import parse_date, parse_datetime, parse_duration, parse_time
-from .utils import change_exception, display_as_type, list_like
+from .utils import change_exception, display_as_type, is_callable_type, list_like
 
 NoneType = type(None)
 
@@ -214,6 +214,18 @@ def path_exists_validator(v) -> Path:
     return v
 
 
+def callable_validator(v) -> Callable:
+    """
+    Perform a simple check if the value is callable.
+
+    Note: complete matching of argument type hints and return types is not performed
+    """
+    if callable(v):
+        return v
+
+    raise errors.CallableError(value=v)
+
+
 def make_arbitrary_type_validator(type_):
     def arbitrary_type_validator(v) -> type_:
         if isinstance(v, type_):
@@ -258,6 +270,8 @@ def find_validators(type_, arbitrary_types_allowed=False):
         return []
     if type_ is Pattern:
         return pattern_validators
+    if is_callable_type(type_):
+        return [callable_validator]
 
     supertype = _find_supertype(type_)
     if supertype is not None:
diff --git a/tests/test_callable.py b/tests/test_callable.py
new file mode 100644
index 000000000..037b692e1
--- /dev/null
+++ b/tests/test_callable.py
@@ -0,0 +1,23 @@
+from typing import Callable
+
+import pytest
+
+from pydantic import BaseModel, ValidationError
+
+
+@pytest.mark.parametrize('annotation', [Callable, Callable[[int], int]])
+def test_callable(annotation):
+    class Model(BaseModel):
+        callback: annotation
+
+    m = Model(callback=lambda x: x)
+    assert callable(m.callback)
+
+
+@pytest.mark.parametrize('annotation', [Callable, Callable[[int], int]])
+def test_non_callable(annotation):
+    class Model(BaseModel):
+        callback: annotation
+
+    with pytest.raises(ValidationError):
+        Model(callback=1)
diff --git a/tests/test_schema.py b/tests/test_schema.py
index 829f94bcc..ff6b6c1bd 100644
--- a/tests/test_schema.py
+++ b/tests/test_schema.py
@@ -5,7 +5,7 @@ from datetime import date, datetime, time, timedelta
 from decimal import Decimal
 from enum import Enum, IntEnum
 from pathlib import Path
-from typing import Any, Dict, List, Optional, Set, Tuple, Union
+from typing import Any, Callable, Dict, List, Optional, Set, Tuple, Union
 from uuid import UUID
 
 import pytest
@@ -620,6 +620,18 @@ def test_json_type():
     }
 
 
+@pytest.mark.parametrize('annotation', [Callable, Callable[[int], int]])
+def test_callable_type(annotation):
+    class Model(BaseModel):
+        callback: annotation
+        foo: int
+
+    with pytest.warns(UserWarning):
+        model_schema = Model.schema()
+
+    assert 'callback' not in model_schema['properties']
+
+
 def test_error_non_supported_types():
     class Model(BaseModel):
         a: PyObject
