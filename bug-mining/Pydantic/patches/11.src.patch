diff --git a/HISTORY.rst b/HISTORY.rst
index cbd54166e..059690fab 100644
--- a/HISTORY.rst
+++ b/HISTORY.rst
@@ -7,6 +7,7 @@ v0.x.x (xxx-xx-xx)
 ..................
 * fix schema for ``timedelta`` as number, #325 by @tiangolo
 * prevent validators being called repeatedly after inheritance, #327 by @samuelcolvin
+* prevent duplicate validator check in ipython, fix #312 by @samuelcolvin
 
 v0.16.1 (2018-12-10)
 ....................
diff --git a/pydantic/main.py b/pydantic/main.py
index 794fe6207..b59a96105 100644
--- a/pydantic/main.py
+++ b/pydantic/main.py
@@ -15,7 +15,7 @@ from .json import custom_pydantic_encoder, pydantic_encoder
 from .parse import Protocol, load_file, load_str_bytes
 from .schema import model_schema
 from .types import StrBytes
-from .utils import truncate, validate_field_name
+from .utils import in_ipython, truncate, validate_field_name
 from .validators import dict_validator
 
 
@@ -470,10 +470,13 @@ def validator(*fields, pre: bool = False, whole: bool = False, always: bool = Fa
         )
 
     def dec(f):
-        ref = f.__module__ + '.' + f.__qualname__
-        if ref in _FUNCS:
-            raise ConfigError(f'duplicate validator function "{ref}"')
-        _FUNCS.add(ref)
+        # avoid validators with duplicated names since without this validators can be overwritten silently
+        # which generally isn't the intended behaviour, don't run in ipython - see #312
+        if not in_ipython():  # pragma: no branch
+            ref = f.__module__ + '.' + f.__qualname__
+            if ref in _FUNCS:
+                raise ConfigError(f'duplicate validator function "{ref}"')
+            _FUNCS.add(ref)
         f_cls = classmethod(f)
         f_cls.__validator_config = fields, Validator(f, pre, whole, always, check_fields)
         return f_cls
diff --git a/pydantic/utils.py b/pydantic/utils.py
index 50f14ca6d..71632289d 100644
--- a/pydantic/utils.py
+++ b/pydantic/utils.py
@@ -205,3 +205,15 @@ def url_regex_generator(*, relative: bool, require_tld: bool) -> Pattern:
 
 def lenient_issubclass(cls, class_or_tuple):
     return isinstance(cls, type) and issubclass(cls, class_or_tuple)
+
+
+def in_ipython():
+    """
+    Check whether we're in an ipython environment, including jupyter notebooks.
+    """
+    try:
+        __IPYTHON__
+    except NameError:
+        return False
+    else:  # pragma: no cover
+        return True
