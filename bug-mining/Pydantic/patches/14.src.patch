diff --git a/HISTORY.rst b/HISTORY.rst
index 5c20d7af3..690eb2446 100644
--- a/HISTORY.rst
+++ b/HISTORY.rst
@@ -13,6 +13,7 @@ v0.17.0 (unreleased)
 * add support for constrained strings as dict keys in schema, #332 by @tiangolo
 * support for passing Config class in dataclasses decorator, #276 by @jarekkar
   (**breaking change**: this supersedes the ``validate_assignment`` argument with ``config``)
+* support for nested dataclasses, #334 by @samuelcolvin
 
 v0.16.1 (2018-12-10)
 ....................
diff --git a/docs/examples/ex_nested_dataclasses.py b/docs/examples/ex_nested_dataclasses.py
new file mode 100644
index 000000000..21e644992
--- /dev/null
+++ b/docs/examples/ex_nested_dataclasses.py
@@ -0,0 +1,14 @@
+from pydantic import UrlStr
+from pydantic.dataclasses import dataclass
+
+@dataclass
+class NavbarButton:
+    href: UrlStr
+
+@dataclass
+class Navbar:
+    button: NavbarButton
+
+navbar = Navbar(button=('https://example.com',))
+print(navbar)
+# > Navbar(button=NavbarButton(href='https://example.com'))
diff --git a/docs/index.rst b/docs/index.rst
index 204a3722b..255149bb2 100644
--- a/docs/index.rst
+++ b/docs/index.rst
@@ -109,7 +109,7 @@ dataclasses
 
 .. note::
 
-   New in version ``v0.14.0``.
+   New in version ``v0.14``.
 
 If you don't want to use pydantic's ``BaseModel`` you can instead get the same data validation on standard
 `dataclasses <https://docs.python.org/3/library/dataclasses.html>`_ (introduced in python 3.7).
@@ -126,7 +126,16 @@ created by the standard library ``dataclass`` decorator.
 ``pydantic.dataclasses.dataclass``'s arguments are the same as the standard decorator, except one extra
 key word argument ``config`` which has the same meaning as :ref:`Config <config>`.
 
-Currently validators don't work on validators, if it's something you want please create an issue on github.
+
+Since version ``v0.17`` nested dataclasses are support both in dataclasses and normal models.
+
+.. literalinclude:: examples/ex_nested_dataclasses.py
+
+(This script is complete, it should run "as is")
+
+Dataclasses attributes can be populated by tuples, dictionaries or instances of that dataclass.
+
+Currently validators don't work with dataclasses, if it's something you want please create an issue on github.
 
 Choices
 .......
diff --git a/pydantic/dataclasses.py b/pydantic/dataclasses.py
index 4121cd351..486f4b26e 100644
--- a/pydantic/dataclasses.py
+++ b/pydantic/dataclasses.py
@@ -1,7 +1,6 @@
 import dataclasses
 
-from pydantic import ValidationError
-
+from . import ValidationError, errors
 from .main import create_model, validate_model
 
 
@@ -13,6 +12,21 @@ def _pydantic_post_init(self):
         self.__post_init_original__()
 
 
+def _validate_dataclass(cls, v):
+    if isinstance(v, cls):
+        return v
+    elif isinstance(v, (cls, list, tuple)):
+        return cls(*v)
+    elif isinstance(v, dict):
+        return cls(**v)
+    else:
+        raise errors.DataclassTypeError(class_name=cls.__name__)
+
+
+def _get_validators(cls):
+    yield cls.__validate__
+
+
 def setattr_validate_assignment(self, name, value):
     if self.__initialised__:
         d = dict(self.__dict__)
@@ -37,6 +51,8 @@ def _process_class(_cls, init, repr, eq, order, unsafe_hash, frozen, config):
     cls.__pydantic_model__ = create_model(cls.__name__, __config__=config, **fields)
 
     cls.__initialised__ = False
+    cls.__validate__ = classmethod(_validate_dataclass)
+    cls.__get_validators__ = classmethod(_get_validators)
 
     if cls.__pydantic_model__.__config__.validate_assignment and not frozen:
         cls.__setattr__ = setattr_validate_assignment
diff --git a/pydantic/errors.py b/pydantic/errors.py
index 434911491..42a550a20 100644
--- a/pydantic/errors.py
+++ b/pydantic/errors.py
@@ -266,3 +266,8 @@ class JsonTypeError(PydanticTypeError):
 class PatternError(PydanticValueError):
     code = 'regex_pattern'
     msg_template = 'Invalid regular expression'
+
+
+class DataclassTypeError(PydanticTypeError):
+    code = 'dataclass'
+    msg_template = 'instance of {class_name}, tuple or dict expected'
diff --git a/pydantic/fields.py b/pydantic/fields.py
index d397d0e22..939a579b7 100644
--- a/pydantic/fields.py
+++ b/pydantic/fields.py
@@ -202,6 +202,7 @@ class Field:
         class_validators_ = self.class_validators.values()
         if not self.sub_fields:
             get_validators = getattr(self.type_, 'get_validators', None)
+            get_validators = get_validators or getattr(self.type_, '__get_validators__', None)
             v_funcs = (
                 *tuple(v.func for v in class_validators_ if not v.whole and v.pre),
                 *(
diff --git a/tests/test_dataclasses.py b/tests/test_dataclasses.py
index f0f88af2f..8487e2c49 100644
--- a/tests/test_dataclasses.py
+++ b/tests/test_dataclasses.py
@@ -1,7 +1,9 @@
+import dataclasses
+
 import pytest
 
 import pydantic
-from pydantic import BaseConfig, ValidationError
+from pydantic import BaseModel, ValidationError
 
 
 def test_simple():
@@ -155,7 +157,7 @@ def test_validate_assigment_long_string_error():
     with pytest.raises(ValidationError) as exc_info:
         d.a = 'xxxx'
 
-    assert issubclass(MyDataclass.__pydantic_model__.__config__, BaseConfig)
+    assert issubclass(MyDataclass.__pydantic_model__.__config__, BaseModel.Config)
     assert exc_info.value.errors() == [
         {
             'loc': ('a',),
@@ -179,3 +181,82 @@ def test_no_validate_assigment_long_string_error():
     d.a = 'xxxx'
 
     assert d.a == 'xxxx'
+
+
+def test_nested_dataclass():
+    @pydantic.dataclasses.dataclass
+    class Nested:
+        number: int
+
+    @pydantic.dataclasses.dataclass
+    class Outer:
+        n: Nested
+
+    navbar = Outer(n=Nested(number='1'))
+    assert isinstance(navbar.n, Nested)
+    assert navbar.n.number == 1
+
+    navbar = Outer(n=('2',))
+    assert isinstance(navbar.n, Nested)
+    assert navbar.n.number == 2
+
+    navbar = Outer(n={'number': '3'})
+    assert isinstance(navbar.n, Nested)
+    assert navbar.n.number == 3
+
+    with pytest.raises(ValidationError) as exc_info:
+        Outer(n='not nested')
+    assert exc_info.value.errors() == [
+        {
+            'loc': ('n',),
+            'msg': 'instance of Nested, tuple or dict expected',
+            'type': 'type_error.dataclass',
+            'ctx': {'class_name': 'Nested'},
+        }
+    ]
+
+    with pytest.raises(ValidationError) as exc_info:
+        Outer(n=('x',))
+    assert exc_info.value.errors() == [
+        {'loc': ('n', 'number'), 'msg': 'value is not a valid integer', 'type': 'type_error.integer'}
+    ]
+
+
+def test_arbitrary_types_allowed():
+    @dataclasses.dataclass
+    class Button:
+        href: str
+
+    class Config:
+        arbitrary_types_allowed = True
+
+    @pydantic.dataclasses.dataclass(config=Config)
+    class Navbar:
+        button: Button
+
+    btn = Button(href='a')
+    navbar = Navbar(button=btn)
+    assert navbar.button.href == 'a'
+
+    with pytest.raises(ValidationError) as exc_info:
+        Navbar(button=('b',))
+    assert exc_info.value.errors() == [
+        {
+            'loc': ('button',),
+            'msg': 'instance of Button expected',
+            'type': 'type_error.arbitrary_type',
+            'ctx': {'expected_arbitrary_type': 'Button'},
+        }
+    ]
+
+
+def test_nested_dataclass_model():
+    @pydantic.dataclasses.dataclass
+    class Nested:
+        number: int
+
+    class Outer(BaseModel):
+        n: Nested
+
+    navbar = Outer(n=Nested(number='1'))
+    assert navbar.n.number == 1
