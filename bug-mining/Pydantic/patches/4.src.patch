diff --git a/HISTORY.rst b/HISTORY.rst
index caf66134c..a5655eec8 100644
--- a/HISTORY.rst
+++ b/HISTORY.rst
@@ -6,6 +6,7 @@ History
 v0.12.2 (XXXX-XX-XX)
 ....................
 * raise an exception if a field's name shadows an existing ``BaseModel`` attribute #242
+* add ``UrlStr`` and ``urlstr`` types #236
 
 v0.12.1 (2018-07-31)
 ....................
diff --git a/docs/examples/exotic.py b/docs/examples/exotic.py
index e334d58ad..4e7c259da 100644
--- a/docs/examples/exotic.py
+++ b/docs/examples/exotic.py
@@ -4,8 +4,8 @@ from pathlib import Path
 from uuid import UUID
 
 from pydantic import (DSN, UUID1, UUID3, UUID4, UUID5, BaseModel, DirectoryPath, EmailStr, FilePath, NameEmail,
-                      NegativeFloat, NegativeInt, PositiveFloat, PositiveInt, PyObject, condecimal, confloat, conint,
-                      constr)
+                      NegativeFloat, NegativeInt, PositiveFloat, PositiveInt, PyObject, UrlStr, condecimal, confloat,
+                      conint, constr)
 
 
 class Model(BaseModel):
@@ -31,6 +31,8 @@ class Model(BaseModel):
     email_address: EmailStr = None
     email_and_name: NameEmail = None
 
+    url: UrlStr = None
+
     db_name = 'foobar'
     db_user = 'postgres'
     db_password: str = None
@@ -66,6 +68,7 @@ m = Model(
     unit_interval=0.5,
     email_address='Samuel Colvin <s@muelcolvin.com >',
     email_and_name='Samuel Colvin <s@muelcolvin.com >',
+    url='http://example.com',
     decimal=Decimal('42.24'),
     decimal_positive=Decimal('21.12'),
     decimal_negative=Decimal('-21.12'),
@@ -95,6 +98,7 @@ print(m.dict())
     'unit_interval': 0.5,
     'email_address': 's@muelcolvin.com',
     'email_and_name': <NameEmail("Samuel Colvin <s@muelcolvin.com>")>,
+    'url': 'http://example.com',
     ...
     'dsn': 'postgres://postgres@localhost:5432/foobar',
     'decimal': Decimal('42.24'),
diff --git a/pydantic/errors.py b/pydantic/errors.py
index 7f51fd641..ea7cd56ec 100644
--- a/pydantic/errors.py
+++ b/pydantic/errors.py
@@ -59,6 +59,19 @@ class EmailError(PydanticValueError):
     msg_template = 'value is not a valid email address'
 
 
+class UrlSchemeError(PydanticValueError):
+    code = 'url.scheme'
+    msg_template = 'url scheme "{scheme}" is not allowed'
+
+    def __init__(self, *, scheme: str) -> None:
+        super().__init__(scheme=scheme)
+
+
+class UrlRegexError(PydanticValueError):
+    code = 'url.regex'
+    msg_template = 'url string does not match regex'
+
+
 class EnumError(PydanticTypeError):
     msg_template = 'value is not a valid enumeration member'
 
diff --git a/pydantic/types.py b/pydantic/types.py
index 76fbed694..a4e773d64 100644
--- a/pydantic/types.py
+++ b/pydantic/types.py
@@ -2,11 +2,11 @@ import json
 import re
 from decimal import Decimal
 from pathlib import Path
-from typing import Optional, Pattern, Type, Union
+from typing import Optional, Pattern, Set, Type, Union
 from uuid import UUID
 
 from . import errors
-from .utils import change_exception, import_string, make_dsn, validate_email
+from .utils import change_exception, import_string, make_dsn, url_regex_generator, validate_email
 from .validators import (anystr_length_validator, anystr_strip_whitespace, decimal_validator, float_validator,
                          int_validator, not_none_validator, number_size_validator, path_exists_validator,
                          path_validator, str_validator)
@@ -25,6 +25,8 @@ __all__ = [
     'ConstrainedStr',
     'constr',
     'EmailStr',
+    'UrlStr',
+    'urlstr',
     'NameEmail',
     'PyObject',
     'DSN',
@@ -92,6 +94,18 @@ class ConstrainedStr(str):
         return value
 
 
+def constr(*, strip_whitespace=False, min_length=0, max_length=2**16, curtail_length=None, regex=None) -> Type[str]:
+    # use kwargs then define conf in a dict to aid with IDE type hinting
+    namespace = dict(
+        strip_whitespace=strip_whitespace,
+        min_length=min_length,
+        max_length=max_length,
+        curtail_length=curtail_length,
+        regex=regex and re.compile(regex)
+    )
+    return type('ConstrainedStrValue', (ConstrainedStr,), namespace)
+
+
 class EmailStr(str):
     @classmethod
     def get_validators(cls):
@@ -107,6 +121,59 @@ class EmailStr(str):
         return validate_email(value)[1]
 
 
+class UrlStr(str):
+    strip_whitespace = True
+    min_length = 1
+    max_length = 2 ** 16
+    schemes: Optional[Set[str]] = None
+    relative = False  # whether to allow relative URLs
+    require_tld = True  # whether to reject non-FQDN hostnames
+
+    @classmethod
+    def get_validators(cls):
+        yield not_none_validator
+        yield str_validator
+        yield anystr_strip_whitespace
+        yield anystr_length_validator
+        yield cls.validate
+
+    @classmethod
+    def validate(cls, value: str) -> str:
+        # Check first if the scheme is valid
+        schemes = cls.schemes or {'http', 'https', 'ftp', 'ftps'}
+        if '://' in value:
+            scheme = value.split('://')[0].lower()
+            if scheme not in schemes:
+                raise errors.UrlSchemeError(scheme=scheme)
+
+        regex = url_regex_generator(relative=cls.relative, require_tld=cls.require_tld)
+        if not regex.match(value):
+            raise errors.UrlRegexError()
+
+        return value
+
+
+def urlstr(
+    *,
+    strip_whitespace=True,
+    min_length=1,
+    max_length=2**16,
+    relative=False,
+    require_tld=True,
+    schemes: Optional[Set[str]] = None
+) -> Type[str]:
+    # use kwargs then define conf in a dict to aid with IDE type hinting
+    namespace = dict(
+        strip_whitespace=strip_whitespace,
+        min_length=min_length,
+        max_length=max_length,
+        relative=relative,
+        require_tld=require_tld,
+        schemes=schemes,
+    )
+    return type('UrlStrValue', (UrlStr,), namespace)
+
+
 class NameEmail:
     __slots__ = 'name', 'email'
 
@@ -133,18 +200,6 @@ class NameEmail:
         return f'<NameEmail("{self}")>'
 
 
-def constr(*, strip_whitespace=False, min_length=0, max_length=2**16, curtail_length=None, regex=None) -> Type[str]:
-    # use kwargs then define conf in a dict to aid with IDE type hinting
-    namespace = dict(
-        strip_whitespace=strip_whitespace,
-        min_length=min_length,
-        max_length=max_length,
-        curtail_length=curtail_length,
-        regex=regex and re.compile(regex)
-    )
-    return type('ConstrainedStrValue', (ConstrainedStr,), namespace)
-
-
 class PyObject:
     validate_always = True
 
diff --git a/pydantic/utils.py b/pydantic/utils.py
index 1cfd6d8a1..9a98cb7cc 100644
--- a/pydantic/utils.py
+++ b/pydantic/utils.py
@@ -2,9 +2,10 @@ import inspect
 import re
 from contextlib import contextmanager
 from enum import Enum
+from functools import lru_cache
 from importlib import import_module
 from textwrap import dedent
-from typing import List, Tuple, Type
+from typing import List, Pattern, Tuple, Type
 
 from . import errors
 
@@ -165,3 +166,32 @@ def validate_field_name(bases: List[Type['BaseModel']], field_name: str) -> None
         if getattr(base, field_name, None):
             raise NameError(f'Field name "{field_name}" shadows a BaseModel attribute; '
                             f'use a different field name with "alias=\'{field_name}\'".')
+
+
+@lru_cache(maxsize=None)
+def url_regex_generator(*, relative: bool, require_tld: bool) -> Pattern:
+    """
+    Url regex generator taken from Marshmallow library,
+    for details please follow library source code:
+        https://github.com/marshmallow-code/marshmallow/blob/298870ef6c089fb4d91efae9ca4168453ffe00d2/marshmallow/validate.py#L37
+    """
+    return re.compile(
+        r''.join((
+            r'^',
+            r'(' if relative else r'',
+            r'(?:[a-z0-9\.\-\+]*)://',  # scheme is validated separately
+            r'(?:[^:@]+?:[^:@]*?@|)',  # basic auth
+            r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+',
+            r'(?:[A-Z]{2,6}\.?|[A-Z0-9-]{2,}\.?)|',  # domain...
+            r'localhost|',  # localhost...
+            (
+                r'(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.?)|'
+                if not require_tld else r''
+            ),  # allow dotless hostnames
+            r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}|',  # ...or ipv4
+            r'\[[A-F0-9]*:[A-F0-9:]+\])',  # ...or ipv6
+            r'(?::\d+)?',  # optional port
+            r')?' if relative else r'',  # host is optional, allow for relative URLs
+            r'(?:/?|[/?]\S+)$',
+        )), re.IGNORECASE,
+    )
diff --git a/tests/test_types_url_str.py b/tests/test_types_url_str.py
new file mode 100644
index 000000000..778c11574
--- /dev/null
+++ b/tests/test_types_url_str.py
@@ -0,0 +1,514 @@
+import pytest
+
+from pydantic import BaseModel, ValidationError, urlstr
+
+
+@pytest.mark.parametrize(
+    'value', [
+        'http://example.org',
+        'https://example.org',
+        'ftp://example.org',
+        'ftps://example.org',
+        'http://example.co.jp',
+        'http://www.example.com/a%C2%B1b',
+        'http://www.example.com/~username/',
+        'http://info.example.com/?fred',
+        'http://xn--mgbh0fb.xn--kgbechtv/',
+        'http://example.com/blue/red%3Fand+green',
+        'http://www.example.com/?array%5Bkey%5D=value',
+        'http://xn--rsum-bpad.example.org/',
+        'http://123.45.67.8/',
+        'http://123.45.67.8:8329/',
+        'http://[2001:db8::ff00:42]:8329',
+        'http://[2001::1]:8329',
+        'http://www.example.com:8000/foo',
+    ],
+)
+def test_url_str_absolute_success(value):
+    class Model(BaseModel):
+        v: urlstr(relative=False)
+
+    assert Model(v=value).v == value
+
+
+@pytest.mark.parametrize(
+    'value,errors', [
+        (
+            'http:///example.com/',
+            [
+                {
+                    'loc': ('v',),
+                    'msg': 'url string does not match regex',
+                    'type': 'value_error.url.regex',
+                },
+            ],
+        ),
+        (
+            'https:///example.com/',
+            [
+                {
+                    'loc': ('v',),
+                    'msg': 'url string does not match regex',
+                    'type': 'value_error.url.regex',
+                },
+            ],
+        ),
+        (
+            'https://example.org\\',
+            [
+                {
+                    'loc': ('v',),
+                    'msg': 'url string does not match regex',
+                    'type': 'value_error.url.regex',
+                },
+            ],
+        ),
+        (
+            'ftp:///example.com/',
+            [
+                {
+                    'loc': ('v',),
+                    'msg': 'url string does not match regex',
+                    'type': 'value_error.url.regex',
+                },
+            ],
+        ),
+        (
+            'ftps:///example.com/',
+            [
+                {
+                    'loc': ('v',),
+                    'msg': 'url string does not match regex',
+                    'type': 'value_error.url.regex',
+                },
+            ],
+        ),
+        (
+            'http//example.org',
+            [
+                {
+                    'loc': ('v',),
+                    'msg': 'url string does not match regex',
+                    'type': 'value_error.url.regex',
+                },
+            ],
+        ),
+        (
+            'http:///',
+            [
+                {
+                    'loc': ('v',),
+                    'msg': 'url string does not match regex',
+                    'type': 'value_error.url.regex',
+                },
+            ],
+        ),
+        (
+            'http:/example.org',
+            [
+                {
+                    'loc': ('v',),
+                    'msg': 'url string does not match regex',
+                    'type': 'value_error.url.regex',
+                },
+            ],
+        ),
+        (
+            'foo://example.org',
+            [
+                {
+                    'loc': ('v',),
+                    'msg': 'url scheme "foo" is not allowed',
+                    'type': 'value_error.url.scheme',
+                    'ctx': {
+                        'scheme': 'foo',
+                    },
+                },
+            ],
+        ),
+        (
+            '../icons/logo.gif',
+            [
+                {
+                    'loc': ('v',),
+                    'msg': 'url string does not match regex',
+                    'type': 'value_error.url.regex',
+                },
+            ],
+        ),
+        (
+            'http://2001:db8::ff00:42:8329',
+            [
+                {
+                    'loc': ('v',),
+                    'msg': 'url string does not match regex',
+                    'type': 'value_error.url.regex',
+                },
+            ],
+        ),
+        (
+            'http://[192.168.1.1]:8329',
+            [
+                {
+                    'loc': ('v',),
+                    'msg': 'url string does not match regex',
+                    'type': 'value_error.url.regex',
+                },
+            ],
+        ),
+        (
+            'abc',
+            [
+                {
+                    'loc': ('v',),
+                    'msg': 'url string does not match regex',
+                    'type': 'value_error.url.regex',
+                },
+            ],
+        ),
+        (
+            '..',
+            [
+                {
+                    'loc': ('v',),
+                    'msg': 'url string does not match regex',
+                    'type': 'value_error.url.regex',
+                },
+            ],
+        ),
+        (
+            '/',
+            [
+                {
+                    'loc': ('v',),
+                    'msg': 'url string does not match regex',
+                    'type': 'value_error.url.regex',
+                },
+            ],
+        ),
+        (
+            ' ',
+            [
+                {
+                    'loc': ('v',),
+                    'msg': 'ensure this value has at least 1 characters',
+                    'type': 'value_error.any_str.min_length',
+                    'ctx': {
+                        'limit_value': 1,
+                    },
+                },
+            ],
+        ),
+        (
+            '',
+            [
+                {
+                    'loc': ('v',),
+                    'msg': 'ensure this value has at least 1 characters',
+                    'type': 'value_error.any_str.min_length',
+                    'ctx': {
+                        'limit_value': 1,
+                    },
+                },
+            ],
+        ),
+        (
+            None,
+            [
+                {
+                    'loc': ('v',),
+                    'msg': 'none is not an allow value',
+                    'type': 'type_error.none.not_allowed',
+                },
+            ],
+        ),
+    ],
+)
+def test_url_str_absolute_fails(value, errors):
+    class Model(BaseModel):
+        v: urlstr(relative=False)
+
+    with pytest.raises(ValidationError) as exc_info:
+        Model(v=value)
+    assert exc_info.value.errors() == errors
+
+
+@pytest.mark.parametrize(
+    'value', [
+        'http://example.org',
+        'http://123.45.67.8/',
+        'http://example.com/foo/bar/../baz',
+        'https://example.com/../icons/logo.gif',
+        'http://example.com/./icons/logo.gif',
+        'ftp://example.com/../../../../g',
+        'http://example.com/g?y/./x',
+    ],
+)
+def test_url_str_relative_success(value):
+    class Model(BaseModel):
+        v: urlstr(relative=True)
+
+    assert Model(v=value).v == value
+
+
+@pytest.mark.parametrize(
+    'value,errors', [
+        (
+            'http//example.org',
+            [
+                {
+                    'loc': ('v',),
+                    'msg': 'url string does not match regex',
+                    'type': 'value_error.url.regex',
+                },
+            ],
+        ),
+        (
+            'suppliers.html',
+            [
+                {
+                    'loc': ('v',),
+                    'msg': 'url string does not match regex',
+                    'type': 'value_error.url.regex',
+                },
+            ],
+        ),
+        (
+            '../icons/logo.gif',
+            [
+                {
+                    'loc': ('v',),
+                    'msg': 'url string does not match regex',
+                    'type': 'value_error.url.regex',
+                },
+            ],
+        ),
+        (
+            '\icons/logo.gif',
+            [
+                {
+                    'loc': ('v',),
+                    'msg': 'url string does not match regex',
+                    'type': 'value_error.url.regex',
+                },
+            ],
+        ),
+        (
+            '../.../g',
+            [
+                {
+                    'loc': ('v',),
+                    'msg': 'url string does not match regex',
+                    'type': 'value_error.url.regex',
+                },
+            ],
+        ),
+        (
+            '...',
+            [
+                {
+                    'loc': ('v',),
+                    'msg': 'url string does not match regex',
+                    'type': 'value_error.url.regex',
+                },
+            ],
+        ),
+        (
+            '\\',
+            [
+                {
+                    'loc': ('v',),
+                    'msg': 'url string does not match regex',
+                    'type': 'value_error.url.regex',
+                },
+            ],
+        ),
+        (
+            ' ',
+            [
+                {
+                    'loc': ('v',),
+                    'msg': 'ensure this value has at least 1 characters',
+                    'type': 'value_error.any_str.min_length',
+                    'ctx': {
+                        'limit_value': 1,
+                    },
+                },
+            ],
+        ),
+        (
+            '',
+            [
+                {
+                    'loc': ('v',),
+                    'msg': 'ensure this value has at least 1 characters',
+                    'type': 'value_error.any_str.min_length',
+                    'ctx': {
+                        'limit_value': 1,
+                    },
+                },
+            ],
+        ),
+        (
+            None,
+            [
+                {
+                    'loc': ('v',),
+                    'msg': 'none is not an allow value',
+                    'type': 'type_error.none.not_allowed',
+                },
+            ],
+        ),
+    ],
+)
+def test_url_str_relative_fails(value, errors):
+    class Model(BaseModel):
+        v: urlstr(relative=True)
+
+    with pytest.raises(ValidationError) as exc_info:
+        Model(v=value)
+    assert exc_info.value.errors() == errors
+
+
+@pytest.mark.parametrize(
+    'value', [
+        'http://example.org',
+        'http://123.45.67.8/',
+        'http://example',
+        'http://example.',
+        'http://example:80',
+        'http://user.name:pass.word@example',
+        'http://example/foo/bar',
+    ],
+)
+def test_url_str_dont_require_tld_success(value):
+    class Model(BaseModel):
+        v: urlstr(require_tld=False)
+
+    assert Model(v=value).v == value
+
+
+@pytest.mark.parametrize(
+    'value,errors', [
+        (
+            'http//example',
+            [
+                {
+                    'loc': ('v',),
+                    'msg': 'url string does not match regex',
+                    'type': 'value_error.url.regex',
+                },
+            ],
+        ),
+        (
+            'http://.example.org',
+            [
+                {
+                    'loc': ('v',),
+                    'msg': 'url string does not match regex',
+                    'type': 'value_error.url.regex',
+                },
+            ],
+        ),
+        (
+            'http:///foo/bar',
+            [
+                {
+                    'loc': ('v',),
+                    'msg': 'url string does not match regex',
+                    'type': 'value_error.url.regex',
+                },
+            ],
+        ),
+        (
+            'http:// /foo/bar',
+            [
+                {
+                    'loc': ('v',),
+                    'msg': 'url string does not match regex',
+                    'type': 'value_error.url.regex',
+                },
+            ],
+        ),
+        (
+            '',
+            [
+                {
+                    'loc': ('v',),
+                    'msg': 'ensure this value has at least 1 characters',
+                    'type': 'value_error.any_str.min_length',
+                    'ctx': {
+                        'limit_value': 1,
+                    },
+                },
+            ],
+        ),
+        (
+            None,
+            [
+                {
+                    'loc': ('v',),
+                    'msg': 'none is not an allow value',
+                    'type': 'type_error.none.not_allowed',
+                },
+            ],
+        ),
+    ],
+)
+def test_url_str_dont_require_tld_fails(value, errors):
+    class Model(BaseModel):
+        v: urlstr(require_tld=False)
+
+    with pytest.raises(ValidationError) as exc_info:
+        Model(v=value)
+    assert exc_info.value.errors() == errors
+
+
+def test_url_str_absolute_custom_scheme():
+    class Model(BaseModel):
+        v: urlstr(relative=False)
+
+    # By default, ws not allowed
+    url = 'ws://test.test'
+    with pytest.raises(ValidationError) as exc_info:
+        Model(v=url)
+    assert exc_info.value.errors() == [
+        {
+            'loc': ('v',),
+            'msg': 'url scheme "ws" is not allowed',
+            'type': 'value_error.url.scheme',
+            'ctx': {
+                'scheme': 'ws',
+            },
+        },
+    ]
+
+    class Model(BaseModel):
+        v: urlstr(relative=False, schemes={'http', 'https', 'ws'})
+
+    assert Model(v=url).v == url
+
+
+def test_url_str_relative_and_custom_schemes():
+    class Model(BaseModel):
+        v: urlstr(relative=True)
+
+    # By default, ws not allowed
+    url = 'ws://test.test'
+    with pytest.raises(ValidationError) as exc_info:
+        Model(v=url)
+    assert exc_info.value.errors() == [
+        {
+            'loc': ('v',),
+            'msg': 'url scheme "ws" is not allowed',
+            'type': 'value_error.url.scheme',
+            'ctx': {
+                'scheme': 'ws',
+            },
+        },
+    ]
+
+    class Model(BaseModel):
+        v: urlstr(relative=True, schemes={'http', 'https', 'ws'})
+
+    assert Model(v=url).v == url
