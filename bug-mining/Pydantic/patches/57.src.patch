diff --git a/HISTORY.rst b/HISTORY.rst
index 9b9becd05..d00ffb73e 100644
--- a/HISTORY.rst
+++ b/HISTORY.rst
@@ -14,6 +14,7 @@ v0.30 (unreleased)
 * fix unparameterized generic type schema generation, #625 by @dmontagu
 * fix schema generation with multiple/circular references to the same model, #621 by @tiangolo and @wongpat
 * support custom root types, #628 by @koxudaxi
+* support ``self`` as a field name in ``parse_obj``, #632 by @samuelcolvin
 
 v0.29 (2019-06-19)
 ..................
diff --git a/pydantic/main.py b/pydantic/main.py
index 69d6984d2..1ef8a7bf7 100644
--- a/pydantic/main.py
+++ b/pydantic/main.py
@@ -358,7 +358,12 @@ class BaseModel(metaclass=MetaModel):
                 except (TypeError, ValueError) as e:
                     exc = TypeError(f'{cls.__name__} expected dict not {type(obj).__name__}')
                     raise ValidationError([ErrorWrapper(exc, loc='__obj__')]) from e
-        return cls(**obj)
+
+        m = cls.__new__(cls)
+        values, fields_set, _ = validate_model(m, obj)
+        object.__setattr__(m, '__values__', values)
+        object.__setattr__(m, '__fields_set__', fields_set)
+        return m
 
     @classmethod
     def parse_raw(
@@ -472,14 +477,14 @@ class BaseModel(metaclass=MetaModel):
     @classmethod
     def validate(cls: Type['Model'], value: Any) -> 'Model':
         if isinstance(value, dict):
-            return cls(**value)
+            return cls.parse_obj(value)
         elif isinstance(value, cls):
             return value.copy()
         elif cls.__config__.orm_mode:
             return cls.from_orm(value)
         else:
             with change_exception(DictError, TypeError, ValueError):
-                return cls(**dict(value))
+                return cls.parse_obj(value)
 
     @classmethod
     def _decompose_class(cls: Type['Model'], obj: Any) -> GetterDict:
diff --git a/tests/test_edge_cases.py b/tests/test_edge_cases.py
index b61ed1b21..6336997aa 100644
--- a/tests/test_edge_cases.py
+++ b/tests/test_edge_cases.py
@@ -880,3 +880,29 @@ def test_submodel_different_type():
     assert Spam(c=Foo(a='123')).dict() == {'c': {'a': 123}}
     with pytest.raises(ValidationError):
         Spam(c=Bar(b='123'))
+
+
+def test_self():
+    class Model(BaseModel):
+        self: str
+
+    m = Model.parse_obj(dict(self='some value'))
+    assert m.dict() == {'self': 'some value'}
+    assert m.self == 'some value'
+    assert m.schema() == {
+        'title': 'Model',
+        'type': 'object',
+        'properties': {'self': {'title': 'Self', 'type': 'string'}},
+        'required': ['self'],
+    }
+
+
+def test_self_recursive():
+    class SubModel(BaseModel):
+        self: int
+
+    class Model(BaseModel):
+        sm: SubModel
+
+    m = Model.parse_obj({'sm': {'self': '123'}})
+    assert m.dict() == {'sm': {'self': 123}}
