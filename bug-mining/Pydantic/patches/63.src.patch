diff --git a/changes/745-djpetti.rst b/changes/745-djpetti.rst
new file mode 100644
index 000000000..592811b59
--- /dev/null
+++ b/changes/745-djpetti.rst
@@ -0,0 +1 @@
+Added support for ``FrozenSet`` members in dataclasses, and a better error when attempting to use types from the ``typing`` module that are not supported by Pydantic.
\ No newline at end of file
diff --git a/docs/examples/ex_typing.py b/docs/examples/ex_typing.py
index 701e50ec7..8604c8052 100644
--- a/docs/examples/ex_typing.py
+++ b/docs/examples/ex_typing.py
@@ -1,4 +1,4 @@
-from typing import Dict, List, Optional, Sequence, Set, Tuple, Union
+from typing import Dict, FrozenSet, List, Optional, Sequence, Set, Tuple, Union
 
 from pydantic import BaseModel
 
@@ -15,6 +15,7 @@ class Model(BaseModel):
 
     simple_set: set = None
     set_bytes: Set[bytes] = None
+    frozen_set: FrozenSet[int] = None
 
     str_or_bytes: Union[str, bytes] = None
     none_or_str: Optional[str] = None
diff --git a/pydantic/errors.py b/pydantic/errors.py
index 2717c1e36..265bfce57 100644
--- a/pydantic/errors.py
+++ b/pydantic/errors.py
@@ -143,6 +143,10 @@ class SetError(PydanticTypeError):
     msg_template = 'value is not a valid set'
 
 
+class FrozenSetError(PydanticTypeError):
+    msg_template = 'value is not a valid frozenset'
+
+
 class TupleError(PydanticTypeError):
     msg_template = 'value is not a valid tuple'
 
diff --git a/pydantic/fields.py b/pydantic/fields.py
index 87b667cc3..6d6fc2e54 100644
--- a/pydantic/fields.py
+++ b/pydantic/fields.py
@@ -2,6 +2,7 @@ from typing import (
     TYPE_CHECKING,
     Any,
     Dict,
+    FrozenSet,
     Generator,
     Iterable,
     Iterator,
@@ -61,6 +62,7 @@ SHAPE_MAPPING = 4
 SHAPE_TUPLE = 5
 SHAPE_TUPLE_ELLIPS = 6
 SHAPE_SEQUENCE = 7
+SHAPE_FROZENSET = 8
 
 
 class Field:
@@ -243,16 +245,20 @@ class Field:
         elif issubclass(origin, Set):
             self.type_ = self.type_.__args__[0]  # type: ignore
             self.shape = SHAPE_SET
+        elif issubclass(origin, FrozenSet):
+            self.type_ = self.type_.__args__[0]  # type: ignore
+            self.shape = SHAPE_FROZENSET
         elif issubclass(origin, Sequence):
             self.type_ = self.type_.__args__[0]  # type: ignore
             self.shape = SHAPE_SEQUENCE
-        else:
-            assert issubclass(origin, Mapping)
+        elif issubclass(origin, Mapping):
             self.key_field = self._create_sub_type(
                 self.type_.__args__[0], 'key_' + self.name, for_keys=True  # type: ignore
             )
             self.type_ = self.type_.__args__[1]  # type: ignore
             self.shape = SHAPE_MAPPING
+        else:
+            raise TypeError(f'Fields of type "{origin}" are not supported.')
 
         if getattr(self.type_, '__origin__', None):
             # type_ has been refined eg. as the type of a List and sub_fields needs to be populated
@@ -325,11 +331,13 @@ class Field:
         except (ValueError, TypeError) as exc:
             return v, ErrorWrapper(exc, loc=loc)
 
-    def _validate_sequence_like(
+    def _validate_sequence_like(  # noqa: C901 (ignore complexity)
         self, v: Any, values: Dict[str, Any], loc: 'LocType', cls: Optional['ModelOrDc']
     ) -> 'ValidateReturn':
         """
         Validate sequence-like containers: lists, tuples, sets and generators
+        Note that large if-else blocks are necessary to enable Cython
+        optimization, which is why we disable the complexity check above.
         """
         if not sequence_like(v):
             e: errors_.PydanticTypeError
@@ -337,6 +345,8 @@ class Field:
                 e = errors_.ListError()
             elif self.shape == SHAPE_SET:
                 e = errors_.SetError()
+            elif self.shape == SHAPE_FROZENSET:
+                e = errors_.FrozenSetError()
             else:
                 e = errors_.SequenceError()
             return v, ErrorWrapper(e, loc=loc)
@@ -354,10 +364,12 @@ class Field:
         if errors:
             return v, errors
 
-        converted: Union[List[Any], Set[Any], Tuple[Any, ...], Iterator[Any]] = result
+        converted: Union[List[Any], Set[Any], FrozenSet[Any], Tuple[Any, ...], Iterator[Any]] = result
 
         if self.shape == SHAPE_SET:
             converted = set(result)
+        elif self.shape == SHAPE_FROZENSET:
+            converted = frozenset(result)
         elif self.shape == SHAPE_TUPLE_ELLIPS:
             converted = tuple(result)
         elif self.shape == SHAPE_SEQUENCE:
diff --git a/pydantic/utils.py b/pydantic/utils.py
index da93f0903..dbcada510 100644
--- a/pydantic/utils.py
+++ b/pydantic/utils.py
@@ -137,7 +137,7 @@ def change_exception(raise_exc: ExcType, *except_types: ExcType) -> Generator[No
 
 
 def sequence_like(v: AnyType) -> bool:
-    return isinstance(v, (list, tuple, set)) or inspect.isgenerator(v)
+    return isinstance(v, (list, tuple, set, frozenset)) or inspect.isgenerator(v)
 
 
 def validate_field_name(bases: List[Type['BaseModel']], field_name: str) -> None:
diff --git a/pydantic/validators.py b/pydantic/validators.py
index a0c3120e1..76d30daec 100644
--- a/pydantic/validators.py
+++ b/pydantic/validators.py
@@ -11,6 +11,7 @@ from typing import (
     Any,
     Callable,
     Dict,
+    FrozenSet,
     Generator,
     List,
     Optional,
@@ -215,6 +216,15 @@ def set_validator(v: Any) -> Set[Any]:
         raise errors.SetError()
 
 
+def frozenset_validator(v: Any) -> FrozenSet[Any]:
+    if isinstance(v, frozenset):
+        return v
+    elif sequence_like(v):
+        return frozenset(v)
+    else:
+        raise errors.FrozenSetError()
+
+
 def enum_validator(v: Any, field: 'Field', config: 'BaseConfig') -> Enum:
     try:
         enum_v = field.type_(v)
@@ -424,6 +434,7 @@ _VALIDATORS: List[Tuple[AnyType, List[Any]]] = [
     (list, [list_validator]),
     (tuple, [tuple_validator]),
     (set, [set_validator]),
+    (frozenset, [frozenset_validator]),
     (UUID, [not_none_validator, uuid_validator]),
     (Decimal, [not_none_validator, decimal_validator]),
     (IPv4Interface, [not_none_validator, ip_v4_interface_validator]),
diff --git a/tests/test_dataclasses.py b/tests/test_dataclasses.py
index 421325a64..0ece0ef11 100644
--- a/tests/test_dataclasses.py
+++ b/tests/test_dataclasses.py
@@ -1,7 +1,7 @@
 import dataclasses
 from datetime import datetime
 from pathlib import Path
-from typing import ClassVar, Optional
+from typing import ClassVar, FrozenSet, Optional
 
 import pytest
 
@@ -489,3 +489,14 @@ def test_classvar():
 
     tcv = TestClassVar(2)
     assert tcv.klassvar == "I'm a Class variable"
+
+
+def test_frozenset_field():
+    @pydantic.dataclasses.dataclass
+    class TestFrozenSet:
+        set: FrozenSet[int]
+
+    test_set = frozenset({1, 2, 3})
+    object_under_test = TestFrozenSet(set=test_set)
+
+    assert object_under_test.set == test_set
diff --git a/tests/test_types.py b/tests/test_types.py
index 63bdc8456..ec52e3a33 100644
--- a/tests/test_types.py
+++ b/tests/test_types.py
@@ -6,7 +6,7 @@ from datetime import date, datetime, time, timedelta
 from decimal import Decimal
 from enum import Enum, IntEnum
 from pathlib import Path
-from typing import Dict, Iterator, List, NewType, Optional, Pattern, Sequence, Set, Tuple
+from typing import Dict, FrozenSet, Iterator, List, MutableSet, NewType, Optional, Pattern, Sequence, Set, Tuple
 from uuid import UUID
 
 import pytest
@@ -1789,3 +1789,39 @@ def test_literal_multiple():
             'ctx': {'given': 'c', 'permitted': ('b',)},
         },
     ]
+
+
+def test_unsupported_field_type():
+    with pytest.raises(TypeError, match=r'MutableSet(.*)not supported'):
+
+        class UnsupportedModel(BaseModel):
+            unsupported: MutableSet[int]
+
+
+def test_frozenset_field():
+    class FrozenSetModel(BaseModel):
+        set: FrozenSet[int]
+
+    test_set = frozenset({1, 2, 3})
+    object_under_test = FrozenSetModel(set=test_set)
+
+    assert object_under_test.set == test_set
+
+
+def test_frozenset_field_conversion():
+    class FrozenSetModel(BaseModel):
+        set: FrozenSet[int]
+
+    test_list = [1, 2, 3]
+    test_set = frozenset(test_list)
+    object_under_test = FrozenSetModel(set=test_list)
+
+    assert object_under_test.set == test_set
+
+
+def test_frozenset_field_not_convertible():
+    class FrozenSetModel(BaseModel):
+        set: FrozenSet[int]
+
+    with pytest.raises(ValidationError, match=r'frozenset'):
+        FrozenSetModel(set=42)
diff --git a/tests/test_validators.py b/tests/test_validators.py
index b1f674679..b13062cab 100644
--- a/tests/test_validators.py
+++ b/tests/test_validators.py
@@ -39,6 +39,21 @@ def test_int_validation():
     assert Model(a=4.5).a == 4
 
 
+def test_frozenset_validation():
+    class Model(BaseModel):
+        a: frozenset
+
+    with pytest.raises(ValidationError) as exc_info:
+        Model(a='snap')
+    assert exc_info.value.errors() == [
+        {'loc': ('a',), 'msg': 'value is not a valid frozenset', 'type': 'type_error.frozenset'}
+    ]
+    assert Model(a={1, 2, 3}).a == frozenset({1, 2, 3})
+    assert Model(a=frozenset({1, 2, 3})).a == frozenset({1, 2, 3})
+    assert Model(a=[4, 5]).a == frozenset({4, 5})
+    assert Model(a=(6,)).a == frozenset({6})
+
+
 def test_validate_whole():
     class Model(BaseModel):
         a: List[int]
