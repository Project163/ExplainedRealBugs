diff --git a/pydantic/_internal/_std_types_schema.py b/pydantic/_internal/_std_types_schema.py
index e2126880b..9fd4978da 100644
--- a/pydantic/_internal/_std_types_schema.py
+++ b/pydantic/_internal/_std_types_schema.py
@@ -12,6 +12,7 @@ from datetime import date, datetime, time, timedelta
 from decimal import Decimal
 from enum import Enum
 from ipaddress import IPv4Address, IPv4Interface, IPv4Network, IPv6Address, IPv6Interface, IPv6Network
+from os import PathLike
 from pathlib import PurePath
 from typing import Any, Callable
 from uuid import UUID
@@ -203,31 +204,32 @@ def uuid_schema(_schema_generator: GenerateSchema, uuid_type: type[UUID]) -> cor
 
 
 @schema_function(PurePath)
-def path_schema(_schema_generator: GenerateSchema, path_type: type[PurePath]) -> core_schema.LaxOrStrictSchema:
+@schema_function(PathLike)
+def path_schema(_schema_generator: GenerateSchema, path_type: type[PathLike]) -> core_schema.LaxOrStrictSchema:
+    construct_path = PurePath if path_type is PathLike else path_type
     metadata = build_metadata_dict(js_functions=[lambda _c, _h: {'type': 'string', 'format': 'path'}])
-    # TODO, is this actually faster than `function_after(...)` as above?
-    lax = core_schema.union_schema(
-        [
-            core_schema.is_instance_schema(path_type, json_types={'str'}, metadata=metadata),
-            core_schema.general_after_validator_function(
-                _validators.path_validator,
-                core_schema.str_schema(),
-                metadata=metadata,
-            ),
-        ],
-        custom_error_type='path_type',
-        custom_error_message='Input is not a valid path',
-        strict=True,
-    )
+
+    def path_validator(__input_value: str) -> PathLike:
+        try:
+            return construct_path(__input_value)  # type: ignore
+        except TypeError as e:
+            raise PydanticCustomError('path_type', 'Input is not a valid path') from e
+
+    instance_schema = core_schema.is_instance_schema(path_type, json_types={'str'}, json_function=path_validator)
 
     return core_schema.lax_or_strict_schema(
-        lax_schema=lax,
-        strict_schema=core_schema.general_after_validator_function(
-            lambda x, _: path_type(x),
-            core_schema.is_instance_schema(path_type, json_types={'str'}),
-            serialization=core_schema.to_string_ser_schema(),
-            metadata=metadata,
+        lax_schema=core_schema.union_schema(
+            [
+                instance_schema,
+                core_schema.no_info_after_validator_function(path_validator, core_schema.str_schema()),
+            ],
+            custom_error_type='path_type',
+            custom_error_message='Input is not a valid path',
+            strict=True,
         ),
+        strict_schema=instance_schema,
+        serialization=core_schema.to_string_ser_schema(),
+        metadata=metadata,
     )
 
 
diff --git a/pydantic/_internal/_validators.py b/pydantic/_internal/_validators.py
index d8084f6b8..d76ec3398 100644
--- a/pydantic/_internal/_validators.py
+++ b/pydantic/_internal/_validators.py
@@ -11,7 +11,6 @@ import typing
 from collections import OrderedDict, defaultdict, deque
 from decimal import Decimal, DecimalException
 from ipaddress import IPv4Address, IPv4Interface, IPv4Network, IPv6Address, IPv6Interface, IPv6Network
-from pathlib import Path
 from typing import Any
 from uuid import UUID
 
@@ -272,13 +271,6 @@ def uuid_validator(__input_value: str | bytes, _: core_schema.ValidationInfo) ->
         raise PydanticCustomError('uuid_parsing', 'Input should be a valid UUID, unable to parse string as an UUID')
 
 
-def path_validator(__input_value: str, _: core_schema.ValidationInfo) -> Path:
-    try:
-        return Path(__input_value)
-    except TypeError:
-        raise PydanticCustomError('path_type', 'Input is not a valid path')
-
-
 def pattern_either_validator(__input_value: Any, _: core_schema.ValidationInfo) -> typing.Pattern[Any]:
     if isinstance(__input_value, typing.Pattern):
         return __input_value  # type: ignore
diff --git a/tests/test_types.py b/tests/test_types.py
index f6d1d0e36..5a1858d33 100644
--- a/tests/test_types.py
+++ b/tests/test_types.py
@@ -1,4 +1,5 @@
 import itertools
+import json
 import math
 import os
 import re
@@ -2914,6 +2915,42 @@ def test_path_validation_success(value, result):
         foo: Path
 
     assert Model(foo=value).foo == result
+    assert Model.model_validate_json(json.dumps({'foo': str(value)})).foo == result
+
+
+def test_path_like():
+    class Model(BaseModel):
+        foo: os.PathLike
+
+    assert Model(foo='/foo/bar').foo == Path('/foo/bar')
+    assert Model(foo=Path('/foo/bar')).foo == Path('/foo/bar')
+    assert Model.model_validate_json('{"foo": "abc"}').foo == Path('abc')
+    # insert_assert(Model.model_json_schema())
+    assert Model.model_json_schema() == {
+        'type': 'object',
+        'properties': {'foo': {'type': 'string', 'format': 'path', 'title': 'Foo'}},
+        'required': ['foo'],
+        'title': 'Model',
+    }
+
+
+def test_path_like_strict():
+    class Model(BaseModel):
+        model_config = dict(strict=True)
+
+        foo: os.PathLike
+
+    with pytest.raises(ValidationError, match='Input should be an instance of PathLike'):
+        Model(foo='/foo/bar')
+    assert Model(foo=Path('/foo/bar')).foo == Path('/foo/bar')
+    assert Model.model_validate_json('{"foo": "abc"}').foo == Path('abc')
+    # insert_assert(Model.model_json_schema())
+    assert Model.model_json_schema() == {
+        'type': 'object',
+        'properties': {'foo': {'type': 'string', 'format': 'path', 'title': 'Foo'}},
+        'required': ['foo'],
+        'title': 'Model',
+    }
 
 
 def test_path_validation_fails():
