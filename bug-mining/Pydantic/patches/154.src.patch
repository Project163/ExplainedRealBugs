diff --git a/changes/265-PrettyWood.md b/changes/265-PrettyWood.md
new file mode 100644
index 000000000..56a600fd6
--- /dev/null
+++ b/changes/265-PrettyWood.md
@@ -0,0 +1,2 @@
+Add `Config.copy_on_model_validation` flag. When set to `False`, _pydantic_ will keep models used as fields
+untouched on validation instead of reconstructing (copying) them
\ No newline at end of file
diff --git a/docs/examples/model_config_change_globally_custom.py b/docs/examples/model_config_change_globally_custom.py
new file mode 100644
index 000000000..5cf1011e9
--- /dev/null
+++ b/docs/examples/model_config_change_globally_custom.py
@@ -0,0 +1,14 @@
+from pydantic import BaseModel as PydanticBaseModel
+
+
+class BaseModel(PydanticBaseModel):
+    class Config:
+        arbitrary_types_allowed = True
+
+
+class MyClass:
+    """A random class"""
+
+
+class Model(BaseModel):
+    x: MyClass
diff --git a/docs/usage/model_config.md b/docs/usage/model_config.md
index 24219c951..91c8d3d64 100644
--- a/docs/usage/model_config.md
+++ b/docs/usage/model_config.md
@@ -1,4 +1,4 @@
-Behaviour of pydantic can be controlled via the `Config` class on a model.
+Behaviour of _pydantic_ can be controlled via the `Config` class on a model or a _pydantic_ dataclass.
 
 Options:
 
@@ -100,6 +100,17 @@ _(This script is complete, it should run "as is")_
 **`underscore_attrs_are_private`**
 : whether to treat any underscore non-class var attrs as private, or leave them as is; See [Private model attributes](models.md#private-model-attributes)
 
+**`copy_on_model_validation`**
+: whether or not inherited models used as fields should be reconstructed (copied) on validation instead of being kept untouched (default: `True`)
+
+## Change behaviour globally
+
+If you wish to change the behaviour of _pydantic_ globally, you can create your own custom `BaseModel`
+with custom `Config` since the config is inherited
+```py
+{!.tmp_examples/model_config_change_globally_custom.py!}
+```
+_(This script is complete, it should run "as is")_
 
 ## Alias Generator
 
diff --git a/pydantic/main.py b/pydantic/main.py
index 6eb98457c..94b054a7e 100644
--- a/pydantic/main.py
+++ b/pydantic/main.py
@@ -129,6 +129,9 @@ class BaseConfig:
     json_encoders: Dict[Type[Any], AnyCallable] = {}
     underscore_attrs_are_private: bool = False
 
+    # Whether or not inherited models as fields should be reconstructed as base model
+    copy_on_model_validation: bool = True
+
     @classmethod
     def get_field_info(cls, name: str) -> Dict[str, Any]:
         fields_value = cls.fields.get(name)
@@ -670,7 +673,7 @@ class BaseModel(Representation, metaclass=ModelMetaclass):
         if isinstance(value, dict):
             return cls(**value)
         elif isinstance(value, cls):
-            return value.copy()
+            return value.copy() if cls.__config__.copy_on_model_validation else value
         elif cls.__config__.orm_mode:
             return cls.from_orm(value)
         elif cls.__custom_root_type__:
diff --git a/tests/test_main.py b/tests/test_main.py
index e026f59d0..86cafabac 100644
--- a/tests/test_main.py
+++ b/tests/test_main.py
@@ -1425,3 +1425,50 @@ def test_base_config_type_hinting():
         a: int
 
     get_type_hints(M.__config__)
+
+
+def test_inherited_model_field_copy():
+    """It should copy models used as fields by default"""
+
+    class Image(BaseModel):
+        path: str
+
+        def __hash__(self):
+            return id(self)
+
+    class Item(BaseModel):
+        images: List[Image]
+
+    image_1 = Image(path='my_image1.png')
+    image_2 = Image(path='my_image2.png')
+
+    item = Item(images={image_1, image_2})
+    assert image_1 in item.images
+
+    assert id(image_1) != id(item.images[0])
+    assert id(image_2) != id(item.images[1])
+
+
+def test_inherited_model_field_untouched():
+    """It should not copy models used as fields if explicitly asked"""
+
+    class Image(BaseModel):
+        path: str
+
+        def __hash__(self):
+            return id(self)
+
+        class Config:
+            copy_on_model_validation = False
+
+    class Item(BaseModel):
+        images: List[Image]
+
+    image_1 = Image(path='my_image1.png')
+    image_2 = Image(path='my_image2.png')
+
+    item = Item(images={image_1, image_2})
+    assert image_1 in item.images
+
+    assert id(image_1) == id(item.images[0])
+    assert id(image_2) == id(item.images[1])
