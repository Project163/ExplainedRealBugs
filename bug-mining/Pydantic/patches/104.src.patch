diff --git a/changes/1209-mostaphaRoudsari.md b/changes/1209-mostaphaRoudsari.md
new file mode 100644
index 000000000..7d5293a1a
--- /dev/null
+++ b/changes/1209-mostaphaRoudsari.md
@@ -0,0 +1 @@
+Remove extra `allOf` from schema for fields with `Union` and custom `Field`.
diff --git a/pydantic/schema.py b/pydantic/schema.py
index ec0a08546..8157bacff 100644
--- a/pydantic/schema.py
+++ b/pydantic/schema.py
@@ -559,6 +559,11 @@ def field_singleton_sub_fields_schema(
                 known_models=known_models,
             )
             definitions.update(sub_definitions)
+            if schema_overrides and 'allOf' in sub_schema:
+                # if the sub_field is a referenced schema we only need the referenced
+                # object. Otherwise we will end up with several allOf inside anyOf.
+                # See https://github.com/samuelcolvin/pydantic/issues/1209
+                sub_schema = sub_schema['allOf'][0]
             sub_field_schemas.append(sub_schema)
             nested_models.update(sub_nested_models)
         return {'anyOf': sub_field_schemas}, definitions, nested_models
diff --git a/tests/test_schema.py b/tests/test_schema.py
index 3dd902a19..536440599 100644
--- a/tests/test_schema.py
+++ b/tests/test_schema.py
@@ -960,6 +960,22 @@ def test_schema_overrides():
     }
 
 
+def test_schema_overrides_w_union():
+    class Foo(BaseModel):
+        pass
+
+    class Bar(BaseModel):
+        pass
+
+    class Model_1(BaseModel):
+        a: Union[Foo, Bar]
+
+    class Model_2(BaseModel):
+        a: Union[Foo, Bar] = Field(...)
+
+    assert Model_1.schema()['properties'] == Model_2.schema()['properties']
+
+
 def test_schema_from_models():
     class Foo(BaseModel):
         a: str
