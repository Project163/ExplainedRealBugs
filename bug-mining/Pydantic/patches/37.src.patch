diff --git a/HISTORY.rst b/HISTORY.rst
index d1e909a16..08294cd20 100644
--- a/HISTORY.rst
+++ b/HISTORY.rst
@@ -3,6 +3,10 @@
 History
 -------
 
+v0.x (xxxx-xx-xx)
+..................
+* fix handling ``ForwardRef`` in sub-types, like ``Union``, #464 by @tiangolo
+
 v0.23 (2019-04-04)
 ..................
 * improve documentation for contributing section, #441 by @pilosus
diff --git a/pydantic/main.py b/pydantic/main.py
index ab536f1a3..0331e076e 100644
--- a/pydantic/main.py
+++ b/pydantic/main.py
@@ -40,6 +40,7 @@ from .utils import (
     is_classvar,
     resolve_annotations,
     truncate,
+    update_field_forward_refs,
     validate_field_name,
 )
 
@@ -454,9 +455,7 @@ class BaseModel(metaclass=MetaModel):
         globalns = sys.modules[cls.__module__].__dict__
         globalns.setdefault(cls.__name__, cls)
         for f in cls.__fields__.values():
-            if type(f.type_) == ForwardRef:
-                f.type_ = f.type_._evaluate(globalns, localns or None)  # type: ignore
-                f.prepare()
+            update_field_forward_refs(f, globalns=globalns, localns=localns)
 
     def __iter__(self) -> 'AnyGenerator':
         """
diff --git a/pydantic/utils.py b/pydantic/utils.py
index fae2e06a4..bac492789 100644
--- a/pydantic/utils.py
+++ b/pydantic/utils.py
@@ -29,6 +29,7 @@ except ImportError:
 
 if TYPE_CHECKING:  # pragma: no cover
     from .main import BaseModel  # noqa: F401
+    from .main import Field  # noqa: F401
 
 if sys.version_info < (3, 7):
     from typing import Callable
@@ -276,3 +277,15 @@ def _check_classvar(v: AnyType) -> bool:
 
 def is_classvar(ann_type: AnyType) -> bool:
     return _check_classvar(ann_type) or _check_classvar(getattr(ann_type, '__origin__', None))
+
+
+def update_field_forward_refs(field: 'Field', globalns: Any, localns: Any) -> None:
+    """
+    Try to update ForwardRefs on fields based on this Field, globalns and localns.
+    """
+    if type(field.type_) == ForwardRef:
+        field.type_ = field.type_._evaluate(globalns, localns or None)  # type: ignore
+        field.prepare()
+    if field.sub_fields:
+        for sub_f in field.sub_fields:
+            update_field_forward_refs(sub_f, globalns=globalns, localns=localns)
diff --git a/tests/test_py37.py b/tests/test_py37.py
index d8c98a2cf..a1b17a3c6 100644
--- a/tests/test_py37.py
+++ b/tests/test_py37.py
@@ -174,3 +174,75 @@ class Dataclass:
     )
     m = module.Dataclass('http://example.com  ')
     assert m.url == 'http://example.com'
+
+
+@skip_not_37
+def test_forward_ref_sub_types(create_module):
+    module = create_module(
+        """
+from typing import ForwardRef, Union
+
+from pydantic import BaseModel
+
+
+class Leaf(BaseModel):
+    a: str
+
+
+TreeType = Union[ForwardRef('Node'), Leaf]
+
+
+class Node(BaseModel):
+    value: int
+    left: TreeType
+    right: TreeType
+
+
+Node.update_forward_refs()
+    """
+    )
+    Node = module.Node
+    Leaf = module.Leaf
+    data = {"value": 3, "left": {"a": "foo"}, "right": {"value": 5, "left": {"a": "bar"}, "right": {"a": "buzz"}}}
+
+    node = Node(**data)
+    assert isinstance(node.left, Leaf)
+    assert isinstance(node.right, Node)
+
+
+@skip_not_37
+def test_forward_ref_nested_sub_types(create_module):
+    module = create_module(
+        """
+from typing import ForwardRef, Tuple, Union
+
+from pydantic import BaseModel
+
+
+class Leaf(BaseModel):
+    a: str
+
+
+TreeType = Union[Union[Tuple[ForwardRef('Node'), str], int], Leaf]
+
+
+class Node(BaseModel):
+    value: int
+    left: TreeType
+    right: TreeType
+
+
+Node.update_forward_refs()
+    """
+    )
+    Node = module.Node
+    Leaf = module.Leaf
+    data = {
+        "value": 3,
+        "left": {"a": "foo"},
+        "right": [{"value": 5, "left": {"a": "bar"}, "right": {"a": "buzz"}}, "test"],
+    }
+
+    node = Node(**data)
+    assert isinstance(node.left, Leaf)
+    assert isinstance(node.right[0], Node)
