diff --git a/src/main/java/org/snomed/otf/owltoolkit/normalform/NormalFormGenerator.java b/src/main/java/org/snomed/otf/owltoolkit/normalform/NormalFormGenerator.java
index 5f31834..989c066 100644
--- a/src/main/java/org/snomed/otf/owltoolkit/normalform/NormalFormGenerator.java
+++ b/src/main/java/org/snomed/otf/owltoolkit/normalform/NormalFormGenerator.java
@@ -18,6 +18,7 @@ package org.snomed.otf.owltoolkit.normalform;
 
 import com.google.common.collect.Ordering;
 import org.snomed.otf.owltoolkit.classification.ReasonerTaxonomy;
+import org.snomed.otf.owltoolkit.ontology.PropertyChain;
 import org.snomed.otf.owltoolkit.taxonomy.SnomedTaxonomy;
 
 import java.util.Collection;
@@ -38,20 +39,15 @@ public abstract class NormalFormGenerator<T> {
 	
 	protected final SnomedTaxonomy snomedTaxonomy;
 
-	protected final Set<Long> allTransitiveProperties;
+	protected final Set<PropertyChain> propertyChains;
 
 	protected boolean preprocessingComplete = false;// TODO Remove this if not needed
 
-	public NormalFormGenerator(final ReasonerTaxonomy reasonerTaxonomy, SnomedTaxonomy snomedTaxonomy, Set<Long> propertiesDeclaredAsTransitive) {
+	public NormalFormGenerator(final ReasonerTaxonomy reasonerTaxonomy, SnomedTaxonomy snomedTaxonomy, Set<PropertyChain> propertyChains) {
+
 		this.reasonerTaxonomy = reasonerTaxonomy;
 		this.snomedTaxonomy = snomedTaxonomy;
-		Set<Long> allTransitiveProperties = new HashSet<>(propertiesDeclaredAsTransitive);
-
-		// Make sure that the sub types of the attributes declared as transitive are also recognised
-		for (Long transitivePropertyId : propertiesDeclaredAsTransitive) {
-			allTransitiveProperties.addAll(snomedTaxonomy.getDescendants(transitivePropertyId));
-		}
-		this.allTransitiveProperties = allTransitiveProperties;
+		this.propertyChains = propertyChains;
 	}
 	
 	/**
@@ -94,7 +90,7 @@ public abstract class NormalFormGenerator<T> {
 
 	/**
 	 * Performs additional normalisation as required before returning components in normal form for the specified concept.
-	 * The second pass uses the hierarchies of any other transitive properties in order to further normalise components.
+	 * The second pass uses property chains and transitive properties in order to further normalise components.
 	 * Other transitive hierarchies can not be guaranteed to be complete during the first pass because the super-type of a
 	 * concept in a transitive property hierarchy may be at a lower level in the is-a hierarchy meaning that it's processed later during the first pass.
 	 *
diff --git a/src/main/java/org/snomed/otf/owltoolkit/normalform/RelationshipNormalFormGenerator.java b/src/main/java/org/snomed/otf/owltoolkit/normalform/RelationshipNormalFormGenerator.java
index 664a9e2..8a7cfdb 100644
--- a/src/main/java/org/snomed/otf/owltoolkit/normalform/RelationshipNormalFormGenerator.java
+++ b/src/main/java/org/snomed/otf/owltoolkit/normalform/RelationshipNormalFormGenerator.java
@@ -24,7 +24,6 @@ import com.google.common.base.Stopwatch;
 import com.google.common.collect.*;
 import com.google.common.collect.Maps.EntryTransformer;
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
-import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.snomed.otf.owltoolkit.classification.ReasonerTaxonomy;
@@ -33,6 +32,7 @@ import org.snomed.otf.owltoolkit.domain.AxiomRepresentation;
 import org.snomed.otf.owltoolkit.domain.Relationship;
 import org.snomed.otf.owltoolkit.normalform.internal.*;
 import org.snomed.otf.owltoolkit.normalform.transitive.NodeGraph;
+import org.snomed.otf.owltoolkit.ontology.PropertyChain;
 import org.snomed.otf.owltoolkit.taxonomy.SnomedTaxonomy;
 
 import java.text.MessageFormat;
@@ -60,10 +60,11 @@ public final class RelationshipNormalFormGenerator extends NormalFormGenerator<R
 
 	private final Map<Long, NodeGraph> transitiveNodeGraphs = new HashMap<>();
 
-	private final Map<Long, Collection<Relationship>> generatedNonIsACache = new Long2ObjectOpenHashMap<>();
+	private final Set<Long> traversableProperties;
+
+	private boolean secondStage = false;
 
-	// Concepts in this set should be processed a second time to try to normalise their relationships further
-	private final Set<Long> conceptsWithTransitiveAttributeValue = new LongOpenHashSet();
+	private final Map<Long, Collection<Relationship>> generatedNonIsACache = new Long2ObjectOpenHashMap<>();
 
 	private static final long INTERNATIONAL_CORE_MODULE_ID = Long.parseLong(Concepts.SNOMED_CT_CORE_MODULE);
 
@@ -84,18 +85,20 @@ public final class RelationshipNormalFormGenerator extends NormalFormGenerator<R
 	 * Creates a new distribution normal form generator instance.
 	 * @param reasonerTaxonomy the reasoner to extract results from (may not be {@code null})
 	 * @param snomedTaxonomy the taxonomy as it existed before this classification run (may not be {@code null})
-	 * @param conceptAxiomStatementMap
-	 * @param propertiesDeclaredAsTransitive the identifiers of properties declared as having transitive behaviour
+	 * @param conceptAxiomStatementMap map of concept id to axiom set
+	 * @param propertyChains collection of property chains
 	 */
 	public RelationshipNormalFormGenerator(final ReasonerTaxonomy reasonerTaxonomy, final SnomedTaxonomy snomedTaxonomy,
-										   final Map<Long, Set<AxiomRepresentation>> conceptAxiomStatementMap, Set<Long> propertiesDeclaredAsTransitive) {
-		super(reasonerTaxonomy, snomedTaxonomy, propertiesDeclaredAsTransitive);
+			final Map<Long, Set<AxiomRepresentation>> conceptAxiomStatementMap, final Set<PropertyChain> propertyChains) {
+		super(reasonerTaxonomy, snomedTaxonomy, propertyChains);
 		
 		this.conceptAxiomStatementMap = conceptAxiomStatementMap;
 
-		// Initialise node graphs for each transitive property
-		LOGGER.info("Initialising node graphs for transitive properties {}", allTransitiveProperties);
-		allTransitiveProperties.forEach(id -> transitiveNodeGraphs.put(id, new NodeGraph()));
+		traversableProperties = propertyChains.stream().map(PropertyChain::getDestinationType).collect(Collectors.toSet());
+
+		// Initialise node graphs for properties we need to traverse
+		LOGGER.info("Initialising node graphs for traversable properties {}", traversableProperties);
+		traversableProperties.forEach(id -> transitiveNodeGraphs.put(id, new NodeGraph()));
 	}
 
 	@Override
@@ -111,25 +114,30 @@ public final class RelationshipNormalFormGenerator extends NormalFormGenerator<R
 		generatedNonIsACache.put(conceptId, ImmutableList.copyOf(inferredNonIsAFragments));
 
 		// Add to transitive graphs
-		inferredNonIsAFragments.stream().filter(r -> allTransitiveProperties.contains(r.getTypeId())).forEach(r -> {
+		inferredNonIsAFragments.stream().filter(r -> traversableProperties.contains(r.getTypeId())).forEach(r -> {
 			transitiveNodeGraphs.get(r.getTypeId()).addParent(conceptId, r.getDestinationId());
-			conceptsWithTransitiveAttributeValue.add(conceptId);
 		});
 	}
 
 	@Override
 	public Collection<Relationship> secondNormalisationPass(final long conceptId) {
+		secondStage = true;
 		final Set<Long> directSuperTypes = reasonerTaxonomy.getParents(conceptId);
 
-		// Step 1: create IS-A relationships
+		// Step 1: collect IS-A relationships
 		final Iterable<Relationship> inferredIsAFragments = getInferredIsAFragments(conceptId, directSuperTypes);
 
-		Iterable<Relationship> inferredNonIsAFragments;
-		inferredNonIsAFragments = generatedNonIsACache.get(conceptId);
-		for (Relationship inferredNonIsAFragment : inferredNonIsAFragments) {
-			if (conceptsWithTransitiveAttributeValue.contains(inferredNonIsAFragment.getDestinationId())) {
-				inferredNonIsAFragments = getInferredNonIsAFragmentsInNormalForm(conceptId);
-				break;
+		Iterable<Relationship> inferredNonIsAFragments = generatedNonIsACache.get(conceptId);
+		if (!propertyChains.isEmpty()) {
+			for (Relationship inferredNonIsAFragment : inferredNonIsAFragments) {
+				// Is there a property chain for this relationship?
+				if (propertyChains.stream()
+						.filter(propertyChain -> propertyChain.getSourceType().equals(inferredNonIsAFragment.getTypeId()))
+						.count() > 0) {
+
+					inferredNonIsAFragments = getInferredNonIsAFragmentsInNormalForm(conceptId);
+					break;
+				}
 			}
 		}
 
@@ -416,11 +424,16 @@ public final class RelationshipNormalFormGenerator extends NormalFormGenerator<R
 		return snomedTaxonomy;
 	}
 
-	public Set<Long> getAllTransitiveProperties() {
-		return allTransitiveProperties;
+	public Set<PropertyChain> getPropertyChains() {
+		return propertyChains;
 	}
 
 	public Map<Long, NodeGraph> getTransitiveNodeGraphs() {
 		return transitiveNodeGraphs;
 	}
+
+	public boolean isSecondStage() {
+		return secondStage;
+	}
+
 }
diff --git a/src/main/java/org/snomed/otf/owltoolkit/normalform/internal/RelationshipFragment.java b/src/main/java/org/snomed/otf/owltoolkit/normalform/internal/RelationshipFragment.java
index 84e3716..8fe45a9 100644
--- a/src/main/java/org/snomed/otf/owltoolkit/normalform/internal/RelationshipFragment.java
+++ b/src/main/java/org/snomed/otf/owltoolkit/normalform/internal/RelationshipFragment.java
@@ -23,15 +23,16 @@ package org.snomed.otf.owltoolkit.normalform.internal;
 import com.google.common.base.Objects;
 import com.google.common.collect.Sets;
 import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
+import org.snomed.otf.owltoolkit.classification.ReasonerTaxonomy;
 import org.snomed.otf.owltoolkit.domain.Relationship;
 import org.snomed.otf.owltoolkit.normalform.RelationshipNormalFormGenerator;
 import org.snomed.otf.owltoolkit.normalform.transitive.NodeGraph;
+import org.snomed.otf.owltoolkit.ontology.PropertyChain;
 
 import java.text.MessageFormat;
-import java.util.Collection;
+import java.util.HashSet;
 import java.util.Set;
+import java.util.stream.Collectors;
 
 import static com.google.common.base.Preconditions.checkNotNull;
 
@@ -103,22 +104,58 @@ public final class RelationshipFragment implements SemanticComparable<Relationsh
 
 		if (!isDestinationNegated() && !other.isDestinationNegated()) {
 
+			// noinspection UnnecessaryLocalVariable
+			RelationshipFragment A = other;
+			RelationshipFragment B = this;
+
 			/*
-			 * Things same or stronger than (some/all) rA:
+			 * We will return true if A is redundant.
+			 *
+			 * Rules for determining redundant relationships.
+			 *
+			 * Rule 1 - Class and Role inclusions
+			 * 	Given two relationships, A and B, A with r = C and B with s = D, within the same role group,
+			 * 	A is redundant if:
+			 * 		r is the same as or a supertype of s, and
+			 * 		C is the same as or a supertype of D
+			 *
+			 * Rule 2 - Property chains including transitive properties
+			 * 	Given attribute r, s and t with a property chain SubObjectPropertyOf(ObjectPropertyChain(t s) r),
+			 * 	and two relationships A and B, A with r = C and B with u = D, within the same role group,
+			 * 	A is redundant if:
+			 * 		Attribute u is the same as or a subtype of t, and
+			 * 		D has relationship to C via attribute s
 			 *
-			 * - (some/all) r'A, where r' is equal to r or is a descendant of r
-			 * - (some/all) rA', where A' is equal to A or is a descendant of A
-			 * - (some/all) r'A', where both of the above applies
 			 */
-			final Set<Long> attributeClosure = getConceptAndAllSuperTypes(getTypeId());
-			final Set<Long> valueClosure = getValueClosure(getDestinationId());
 
-			return attributeClosure.contains(other.getTypeId()) && valueClosure.contains(other.getDestinationId());
+			final Set<Long> BAttributeClosure = getTransitiveClosure(B.getTypeId());
+			final Set<Long> BValueClosure = getTransitiveClosure(B.getDestinationId());
+
+			// Rule 1
+			if (BAttributeClosure.contains(A.getTypeId()) && BValueClosure.contains(A.getDestinationId())) {
+				return true;
+			}
+
+			// Rule 2
+			else {
+				Set<PropertyChain> relevantPropertyChains = relationshipNormalFormGenerator.getPropertyChains().stream()
+						.filter(propertyChain -> BAttributeClosure.contains(propertyChain.getSourceType()))
+						.filter(propertyChain -> propertyChain.getInferredType().equals(A.getTypeId()))
+						.collect(Collectors.toSet());
+				for (PropertyChain propertyChain : relevantPropertyChains) {
+					if (getPropertyChainTransitiveClosure(B.getDestinationId(), propertyChain.getDestinationType())
+							.contains(A.getDestinationId())) {
+						return true;
+					}
+				}
+			}
+			return false;
 
+		// TODO: Remove all negation logic - Snomed International does not use it.
 		} else if (isDestinationNegated() && !other.isDestinationNegated()) {
 
-			final Set<Long> otherAttributeClosure = getConceptAndAllSuperTypes(other.getTypeId());
-			final Set<Long> superTypes = getValueClosure(getDestinationId());
+			final Set<Long> otherAttributeClosure = getTransitiveClosure(other.getTypeId());
+			final Set<Long> superTypes = getTransitiveClosure(getDestinationId());
 			superTypes.remove(getDestinationId());
 
 			/*
@@ -135,7 +172,7 @@ public final class RelationshipFragment implements SemanticComparable<Relationsh
 
 		} else if (!isDestinationNegated() && other.isDestinationNegated()) {
 
-			final Set<Long> attributeClosure = getConceptAndAllSuperTypes(getTypeId());
+			final Set<Long> attributeClosure = getTransitiveClosure(getTypeId());
 
 			/*
 			 * Any contradictions should be filtered out by the reasoner beforehand, so we just check if the two concepts
@@ -149,8 +186,8 @@ public final class RelationshipFragment implements SemanticComparable<Relationsh
 			 * Note that the comparison is the exact opposite of the first case - if both fragments are negated,
 			 * the one which negates a more loose definition is the one that is more strict in the end.
 			 */
-			final Set<Long> otherAttributeClosure = getConceptAndAllSuperTypes(other.getTypeId());
-			final Set<Long> otherValueClosure = getValueClosure(other.getDestinationId());
+			final Set<Long> otherAttributeClosure = getTransitiveClosure(other.getTypeId());
+			final Set<Long> otherValueClosure = getTransitiveClosure(other.getDestinationId());
 
 			return otherAttributeClosure.contains(getTypeId()) && otherValueClosure.contains(getDestinationId());
 		}
@@ -189,21 +226,29 @@ public final class RelationshipFragment implements SemanticComparable<Relationsh
 	 * @return a set containing the starting concept and all reachable
 	 *         supertypes
 	 */
-	private Set<Long> getConceptAndAllSuperTypes(final long conceptId) {
+	private Set<Long> getTransitiveClosure(final long conceptId) {
 		final Set<Long> ancestors = relationshipNormalFormGenerator.getReasonerTaxonomy().getAncestors(conceptId);
 		final Set<Long> conceptAndAncestors = new LongOpenHashSet(ancestors);
 		conceptAndAncestors.add(conceptId);
 		return conceptAndAncestors;
 	}
 
-	private Set<Long> getValueClosure(final long conceptId) {
-		Set<Long> closure = getConceptAndAllSuperTypes(conceptId);
-		Collection<NodeGraph> graphs = relationshipNormalFormGenerator.getTransitiveNodeGraphs().values();
-		for (NodeGraph graph : graphs) {
-			Set<Long> ancestors = graph.getAncestors(conceptId);
-			closure.addAll(ancestors);
+	private Set<Long> getPropertyChainTransitiveClosure(final long conceptId, Long chainDestinationType) {
+		// Build closure containing all possible hops using chainDestinationType
+		// For every concept found also add its super types
+
+		NodeGraph nodeGraph = relationshipNormalFormGenerator.getTransitiveNodeGraphs().getOrDefault(chainDestinationType, new NodeGraph());
+		ReasonerTaxonomy reasonerTaxonomy = relationshipNormalFormGenerator.getReasonerTaxonomy();
+
+		Set<Long> chainPaths = new HashSet<>();
+		chainPaths.add(conceptId);
+		chainPaths.addAll(nodeGraph.getAncestors(conceptId));
+		Set<Long> chainStepAncestors = new HashSet<>();
+		for (Long chainNode : chainPaths) {
+			chainStepAncestors.addAll(reasonerTaxonomy.getAncestors(chainNode));
 		}
-		return closure;
+		chainPaths.addAll(chainStepAncestors);
+		return chainPaths;
 	}
 
 	@Override
diff --git a/src/main/java/org/snomed/otf/owltoolkit/service/SnomedReasonerService.java b/src/main/java/org/snomed/otf/owltoolkit/service/SnomedReasonerService.java
index 189e5d0..c085b14 100644
--- a/src/main/java/org/snomed/otf/owltoolkit/service/SnomedReasonerService.java
+++ b/src/main/java/org/snomed/otf/owltoolkit/service/SnomedReasonerService.java
@@ -33,6 +33,7 @@ import org.snomed.otf.owltoolkit.normalform.RelationshipInactivationProcessor;
 import org.snomed.otf.owltoolkit.normalform.RelationshipNormalFormGenerator;
 import org.snomed.otf.owltoolkit.ontology.OntologyDebugUtil;
 import org.snomed.otf.owltoolkit.ontology.OntologyService;
+import org.snomed.otf.owltoolkit.ontology.PropertyChain;
 import org.snomed.otf.owltoolkit.taxonomy.SnomedTaxonomy;
 import org.snomed.otf.owltoolkit.taxonomy.SnomedTaxonomyBuilder;
 import org.snomed.otf.owltoolkit.util.InputStreamSet;
@@ -130,7 +131,7 @@ public class SnomedReasonerService {
 		}
 		timer.checkpoint("Create OWL Ontology");
 
-		Set<Long> propertiesDeclaredAsTransitive = ontologyService.getPropertiesDeclaredAsTransitive(owlOntology);
+		Set<PropertyChain> propertyChains = ontologyService.getPropertyChains(owlOntology);
 
 		if (outputOntologyFileForDebug) {
 			OntologyDebugUtil.serialiseOntologyForDebug(classificationId, owlOntology);
@@ -161,7 +162,8 @@ public class SnomedReasonerService {
 		} catch (ConversionException e) {
 			throw new ReasonerServiceException("Failed to convert OWL Axiom Expressions into relationships for normal form generation.", e);
 		}
-		RelationshipNormalFormGenerator normalFormGenerator = new RelationshipNormalFormGenerator(reasonerTaxonomy, snomedTaxonomy, conceptAxiomStatementMap, propertiesDeclaredAsTransitive);
+		RelationshipNormalFormGenerator normalFormGenerator = new RelationshipNormalFormGenerator(reasonerTaxonomy, snomedTaxonomy, conceptAxiomStatementMap, propertyChains);
+
 		RelationshipChangeCollector changeCollector = new RelationshipChangeCollector(true);
 		normalFormGenerator.collectNormalFormChanges(changeCollector);
 		timer.checkpoint("Generate normal form");
