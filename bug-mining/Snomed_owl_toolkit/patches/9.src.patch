diff --git a/src/main/java/org/snomed/otf/owltoolkit/domain/Relationship.java b/src/main/java/org/snomed/otf/owltoolkit/domain/Relationship.java
index a862bd5..d846585 100644
--- a/src/main/java/org/snomed/otf/owltoolkit/domain/Relationship.java
+++ b/src/main/java/org/snomed/otf/owltoolkit/domain/Relationship.java
@@ -19,7 +19,7 @@ import java.util.Objects;
 
 public class Relationship {
 
-	private final long relationshipId;
+	private long relationshipId;
 	private int effectiveTime;
 	private final long moduleId;
 	private final long typeId;
@@ -60,6 +60,10 @@ public class Relationship {
 		this.characteristicTypeId = characteristicTypeId;
 	}
 
+	public void clearId() {
+		relationshipId = -1;
+	}
+
 	public long getRelationshipId() {
 		return relationshipId;
 	}
@@ -133,7 +137,8 @@ public class Relationship {
 	@Override
 	public String toString() {
 		return "Relationship{" +
-				"typeId=" + typeId +
+				"group=" + group +
+				", typeId=" + typeId +
 				", destinationId=" + destinationId +
 				'}';
 	}
diff --git a/src/main/java/org/snomed/otf/owltoolkit/normalform/RelationshipChangeProcessor.java b/src/main/java/org/snomed/otf/owltoolkit/normalform/RelationshipChangeProcessor.java
index 2972eea..51b3a09 100644
--- a/src/main/java/org/snomed/otf/owltoolkit/normalform/RelationshipChangeProcessor.java
+++ b/src/main/java/org/snomed/otf/owltoolkit/normalform/RelationshipChangeProcessor.java
@@ -35,6 +35,13 @@ public class RelationshipChangeProcessor {
 			.thenComparing(Relationship::isUniversal)
 			.thenComparing(Relationship::isDestinationNegated);
 
+	private static final Comparator<Relationship> RELATIONSHIP_COMPARATOR_WITHOUT_GROUP = Comparator
+			.comparing(Relationship::getTypeId)
+			.thenComparing(Relationship::getDestinationId)
+			.thenComparing(Relationship::getUnionGroup)
+			.thenComparing(Relationship::isUniversal)
+			.thenComparing(Relationship::isDestinationNegated);
+
 	private final Map<Long, Set<Relationship>> addedStatements;
 	private final Map<Long, Set<Relationship>> removedStatements;
 	private Long addedCount;
@@ -55,22 +62,37 @@ public class RelationshipChangeProcessor {
 		final List<Relationship> sortedOld = newSortedList(existingRelationships, RELATIONSHIP_COMPARATOR_ALL_FIELDS);
 		final List<Relationship> sortedNew = newSortedList(newRelationships, RELATIONSHIP_COMPARATOR_ALL_FIELDS);
 
-
-		// Collect removed subjects and added subjects
-		// Use secondary compare to find matching groups with a new number.. we should mark this during groups.adjustOrder(inferredGroups) to be sure they are from the same group!
+		final Map<Relationship, Relationship> updatedRelationshipNewOldMap = new HashMap<>();
 
 		// For each existing relationship if it can not be found in the new set mark it as removed
 		for (final Relationship oldSubject : sortedOld) {
 			final int i = Collections.binarySearch(sortedNew, oldSubject, RELATIONSHIP_COMPARATOR_ALL_FIELDS);
 			if (i < 0 || !uniqueOlds.add(oldSubject)) {
 
+				// Handle the case where existing relationships are being moved out of group 0.
+				// This will happen as editions move from stated relationships to OWL axioms.
+				if (oldSubject.getGroup() == 0 && oldSubject.getTypeId() != Concepts.IS_A_LONG) {
+					final int y = Collections.binarySearch(sortedNew, oldSubject, RELATIONSHIP_COMPARATOR_WITHOUT_GROUP);
+					if (y != -1) {
+						// Update existing relationship rather than creating new
+						updatedRelationshipNewOldMap.put(sortedNew.get(y), oldSubject);
+						continue;
+					}
+				}
+
 				handleRemovedSubject(conceptId, oldSubject);
 			}
 		}
 
 		// For each relationship in the new set if it does not match one in the old set mark is as added
 		for (final Relationship newMini : sortedNew) {
-			if (Collections.binarySearch(sortedOld, newMini, RELATIONSHIP_COMPARATOR_ALL_FIELDS) < 0) {
+			if (updatedRelationshipNewOldMap.containsKey(newMini)) {
+				// Update existing relationship
+				Relationship existingRelationship = updatedRelationshipNewOldMap.get(newMini);
+				existingRelationship.setGroup(newMini.getGroup());
+				handleAddedSubject(conceptId, existingRelationship);
+			} else if (Collections.binarySearch(sortedOld, newMini, RELATIONSHIP_COMPARATOR_ALL_FIELDS) < 0) {
+				newMini.clearId();// Make sure stated relationship ids don't get through into new inferred relationship results
 				handleAddedSubject(conceptId, newMini);
 			}
 		}
diff --git a/src/main/java/org/snomed/otf/owltoolkit/normalform/internal/GroupSet.java b/src/main/java/org/snomed/otf/owltoolkit/normalform/internal/GroupSet.java
index 61e85eb..b7991db 100644
--- a/src/main/java/org/snomed/otf/owltoolkit/normalform/internal/GroupSet.java
+++ b/src/main/java/org/snomed/otf/owltoolkit/normalform/internal/GroupSet.java
@@ -20,9 +20,6 @@
  */
 package org.snomed.otf.owltoolkit.normalform.internal;
 
-import com.google.common.base.Optional;
-import com.google.common.base.Predicates;
-import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
@@ -84,27 +81,29 @@ public final class GroupSet extends AbstractSet<Group> {
 		return groups.size();
 	}
 
-	public void adjustOrder(final GroupSet other) {
+	public void adjustOrder(final GroupSet previousInferredSet) {
 		if (isEmpty()) {
 			return;
 		}
 
 		final Map<Integer, Group> oldNumberMap = new Int2ObjectOpenHashMap<>(groups.size());
-		for (final Group group : groups) {
-			oldNumberMap.put(group.getGroupNumber(), group);
+		for (final Group statedGroup : groups) {
+			oldNumberMap.put(statedGroup.getGroupNumber(), statedGroup);
 		}
 
 		final Map<Group, Integer> newNumberMap = new Object2IntOpenHashMap<>(groups.size());
-		for (final Group group : groups) {
-			final Optional<Group> otherGroup = Iterables.tryFind(other.groups, Predicates.equalTo(group));
-			if (otherGroup.isPresent()) {
-				final int oldNumber = group.getGroupNumber();
-				final int newNumber = otherGroup.get().getGroupNumber();
-
-				// If the current group number is 0, it has a single relationship only, and should be kept that way
-				if (oldNumber != 0 && oldNumber != newNumber) {
-					newNumberMap.put(group, newNumber);
-					group.adjustOrder(otherGroup.get());
+		for (final Group statedGroup : groups) {
+			final Optional<Group> previousInferredGroup = previousInferredSet.groups.stream().filter(group -> group.equals(statedGroup)).findAny();
+			if (previousInferredGroup.isPresent()) {
+				final int statedNumber = statedGroup.getGroupNumber();
+				final int previouslyInferredNumber = previousInferredGroup.get().getGroupNumber();
+
+				if (statedNumber != previouslyInferredNumber) {
+					// Allow groups to move out of group 0 if they are no longer stated that way
+					if (previouslyInferredNumber != 0) {
+						newNumberMap.put(statedGroup, previouslyInferredNumber);
+						statedGroup.adjustOrder(previousInferredGroup.get());
+					}
 				}
 			}
 		}
diff --git a/src/main/java/org/snomed/otf/owltoolkit/service/ClassificationResultsWriter.java b/src/main/java/org/snomed/otf/owltoolkit/service/ClassificationResultsWriter.java
index 768fa54..11a0f4a 100644
--- a/src/main/java/org/snomed/otf/owltoolkit/service/ClassificationResultsWriter.java
+++ b/src/main/java/org/snomed/otf/owltoolkit/service/ClassificationResultsWriter.java
@@ -66,11 +66,10 @@ class ClassificationResultsWriter {
 
 		// Write newly inferred relationships
 		for (Long sourceId : addedStatements.keySet()) {
-			String relationshipId = "";
 			String active = "1";
 			for (Relationship relationship : addedStatements.get(sourceId)) {
 				writeRelationship(writer,
-						relationshipId,
+						relationship.getRelationshipId() == -1 ? "" : relationship.getRelationshipId() + "",
 						active,
 						sourceId,
 						relationship.getDestinationId(),
diff --git a/src/test/java/org/snomed/otf/owltoolkit/conversion/GroupZeroConversionIntegrationTest.java b/src/test/java/org/snomed/otf/owltoolkit/conversion/GroupZeroConversionIntegrationTest.java
new file mode 100644
index 0000000..2083d43
--- /dev/null
+++ b/src/test/java/org/snomed/otf/owltoolkit/conversion/GroupZeroConversionIntegrationTest.java
@@ -0,0 +1,69 @@
+package org.snomed.otf.owltoolkit.conversion;
+
+import org.junit.Test;
+import org.semanticweb.owlapi.model.OWLOntologyCreationException;
+import org.snomed.otf.owltoolkit.service.ReasonerServiceException;
+import org.snomed.otf.owltoolkit.service.SnomedReasonerService;
+import org.snomed.otf.owltoolkit.service.classification.TestFileUtil;
+import org.snomed.otf.owltoolkit.util.OptionalFileInputStream;
+import org.snomed.otf.snomedboot.testutil.ZipUtil;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.nio.file.Files;
+import java.util.List;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.snomed.otf.owltoolkit.service.SnomedReasonerService.ELK_REASONER_FACTORY;
+import static org.snomed.otf.owltoolkit.service.classification.TestFileUtil.readInferredRelationshipLinesTrim;
+
+public class GroupZeroConversionIntegrationTest {
+
+	private final StatedRelationshipToOwlRefsetService statedRelationshipToOwlRefsetService;
+	private final SnomedReasonerService snomedReasonerService;
+
+	public GroupZeroConversionIntegrationTest() {
+		statedRelationshipToOwlRefsetService = new StatedRelationshipToOwlRefsetService();
+		snomedReasonerService = new SnomedReasonerService();
+	}
+
+	@Test
+	/*
+		In this test we:
+		- Convert stated relationships to OWL axiom refset members
+			- This will include converting a group 0 relationship to be self grouped in the axiom
+		- Classify
+		- Check that self grouped relationships come out in a non-zero group and that the original record was kept and updated
+	 */
+	public void testConvertToOwlAxiomRefsetAndClassify() throws Exception {
+
+		// Convert stated relationships to OWL Axiom refset
+		File baseRF2SnapshotZip = ZipUtil.zipDirectoryRemovingCommentsAndBlankLines("src/test/resources/SnomedCT_MiniRF2_Base_snapshot");
+//		File baseRF2DeltaZip = ZipUtil.zipDirectoryRemovingCommentsAndBlankLines("src/test/resources/SnomedCT_MiniRF2_Add_Laterality_delta");
+		File owlOutputZip = Files.createTempFile("OWL_Delta", ".zip").toFile();
+		try (FileInputStream snapshotStream = new FileInputStream(baseRF2SnapshotZip);
+			 OptionalFileInputStream deltaStream = new OptionalFileInputStream(null);
+			 FileOutputStream outputStream = new FileOutputStream(owlOutputZip)) {
+
+			statedRelationshipToOwlRefsetService.convertStatedRelationshipsToOwlRefsetAndInactiveRelationshipsArchive(snapshotStream, deltaStream, outputStream, "20180731");
+		}
+
+		// Overlay zip files to create release file with all necessary files
+		TestFileUtil.addFilesToZipFlatteningPaths(new File("src/test/resources/SnomedCT_MiniRF2_Empty_delta"), owlOutputZip, false);
+
+		// Run classification
+		File results = TestFileUtil.newTemporaryFile();
+		snomedReasonerService.classify("", baseRF2SnapshotZip, owlOutputZip, results, ELK_REASONER_FACTORY, false);
+
+		// Assert results
+		List<String> lines = readInferredRelationshipLinesTrim(results);
+		assertEquals(2, lines.size());
+
+		String inferredGroupNumber = "1";
+		assertEquals("200010001\t\t1\t\t362969004\t113331007\t" + inferredGroupNumber + "\t363698007\t900000000000011006\t900000000000451002", lines.get(1));
+	}
+
+}
diff --git a/src/test/java/org/snomed/otf/owltoolkit/service/classification/TestFileUtil.java b/src/test/java/org/snomed/otf/owltoolkit/service/classification/TestFileUtil.java
index e3b1481..96572ef 100644
--- a/src/test/java/org/snomed/otf/owltoolkit/service/classification/TestFileUtil.java
+++ b/src/test/java/org/snomed/otf/owltoolkit/service/classification/TestFileUtil.java
@@ -15,25 +15,35 @@
  */
 package org.snomed.otf.owltoolkit.service.classification;
 
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 import org.snomed.otf.snomedboot.testutil.ZipUtil;
+import org.springframework.util.StreamUtils;
 
-import java.io.BufferedReader;
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStreamReader;
+import java.io.*;
+import java.nio.file.CopyOption;
 import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.StandardCopyOption;
 import java.util.ArrayList;
 import java.util.Date;
+import java.util.Enumeration;
 import java.util.List;
+import java.util.stream.StreamSupport;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipFile;
+import java.util.zip.ZipInputStream;
+import java.util.zip.ZipOutputStream;
 
 import static org.junit.Assert.assertTrue;
 
-class TestFileUtil {
+public class TestFileUtil {
 
 	private static final String EQUIVALENT_DELTA = "der2_sRefset_EquivalentConceptSimpleMapDelta_Classification_";
 	private static final String RELATIONSHIP_DELTA = "sct2_Relationship_Delta_Classification_";
+	private static final Logger LOGGER = LoggerFactory.getLogger(TestFileUtil.class);
 
-	static List<String> readInferredRelationshipLinesTrim(File zipFile) throws IOException {
+	public static List<String> readInferredRelationshipLinesTrim(File zipFile) throws IOException {
 		return readLinesTrim(zipFile, RELATIONSHIP_DELTA);
 	}
 
@@ -62,7 +72,54 @@ class TestFileUtil {
 		return lines;
 	}
 
-	static File newTemporaryFile() throws IOException {
+	public static File newTemporaryFile() throws IOException {
 		return Files.createTempFile(new Date().getTime() + "", ".txt").toFile();
 	}
+
+	public static void addFilesToZipFlatteningPaths(File directoryOfFiles, File existingZipFile, boolean allowEntryOverwriting) throws IOException {
+
+		List<String> newFilenames = new ArrayList<>();
+		List<String> newPaths = new ArrayList<>();
+		Files.walk(directoryOfFiles.toPath())
+				.forEach(path -> {
+					if (path.toFile().isFile()) {
+						newFilenames.add(path.toFile().getName());
+						String absolutePath = path.toFile().getAbsolutePath();
+						newPaths.add(absolutePath.replace(directoryOfFiles.getAbsolutePath(), ""));
+					}
+				});
+
+		File tempFile = Files.createTempFile("temp-file", ".zip").toFile();
+		try (ZipInputStream zipInputStream = new ZipInputStream(new FileInputStream(existingZipFile));
+			 ZipOutputStream zipOutputStream = new ZipOutputStream(new FileOutputStream(tempFile))) {
+
+			// Copy existing zip entries to new zip file
+			List<String> zipEntriesFilenames = new ArrayList<>();
+			ZipEntry nextEntry;
+			while ((nextEntry = zipInputStream.getNextEntry()) != null) {
+				String existingEntry = nextEntry.getName();
+				existingEntry = existingEntry.replaceFirst(".*/", "");
+				if (newFilenames.contains(existingEntry) && !allowEntryOverwriting) {
+					LOGGER.info("Adding existing zip entry {}", existingEntry);
+					zipEntriesFilenames.add(existingEntry);
+					zipOutputStream.putNextEntry(nextEntry);
+					StreamUtils.copy(zipInputStream, zipOutputStream);
+					zipOutputStream.closeEntry();
+				}
+			}
+
+			// Copy files to new zip file
+			for (String entryPath : newPaths) {
+				String entryFilename = entryPath.replaceFirst(".*/", "");
+				if (!zipEntriesFilenames.contains(entryFilename)) {
+					LOGGER.info("Adding new zip entry {}", entryFilename);
+					zipOutputStream.putNextEntry(new ZipEntry(entryFilename));
+					StreamUtils.copy(new FileInputStream(new File(directoryOfFiles, entryPath)), zipOutputStream);
+					zipOutputStream.closeEntry();
+				}
+			}
+		}
+
+		Files.move(tempFile.toPath(), existingZipFile.toPath(), StandardCopyOption.REPLACE_EXISTING);
+	}
 }
diff --git a/src/test/resources/SnomedCT_MiniRF2_Add_Laterality_delta/Delta/Terminology/sct2_Concept_Delta_INT_20180931.txt b/src/test/resources/SnomedCT_MiniRF2_Add_Laterality_delta/Delta/Terminology/sct2_Concept_Delta_INT_20180931.txt
new file mode 100644
index 0000000..b1fd434
--- /dev/null
+++ b/src/test/resources/SnomedCT_MiniRF2_Add_Laterality_delta/Delta/Terminology/sct2_Concept_Delta_INT_20180931.txt
@@ -0,0 +1,10 @@
+#
+# Comments are removed by unit test
+#
+id	effectiveTime	active	moduleId	definitionStatusId
+
+# Laterality attribute
+272741003	20180931	1	900000000000012004	900000000000074008
+
+# Left
+7771000	20180931	1	900000000000012004	900000000000074008
diff --git a/src/test/resources/SnomedCT_MiniRF2_Add_Laterality_delta/Delta/Terminology/sct2_Description_Delta-en_INT_20180931.txt b/src/test/resources/SnomedCT_MiniRF2_Add_Laterality_delta/Delta/Terminology/sct2_Description_Delta-en_INT_20180931.txt
new file mode 100644
index 0000000..ddcdf85
--- /dev/null
+++ b/src/test/resources/SnomedCT_MiniRF2_Add_Laterality_delta/Delta/Terminology/sct2_Description_Delta-en_INT_20180931.txt
@@ -0,0 +1,3 @@
+id	effectiveTime	active	moduleId	conceptId	languageCode	typeId	term	caseSignificanceId
+665309010	20170731	1	900000000000012004	272741003	en	900000000000003001	Laterality (attribute)	900000000000448009
+818570012	20170731	1	900000000000012004	7771000	en	900000000000003001	Left (qualifier value)	900000000000448009
diff --git a/src/test/resources/SnomedCT_MiniRF2_Add_Laterality_delta/Delta/Terminology/sct2_Relationship_Delta_INT_20180931.txt b/src/test/resources/SnomedCT_MiniRF2_Add_Laterality_delta/Delta/Terminology/sct2_Relationship_Delta_INT_20180931.txt
new file mode 100644
index 0000000..d9c3e60
--- /dev/null
+++ b/src/test/resources/SnomedCT_MiniRF2_Add_Laterality_delta/Delta/Terminology/sct2_Relationship_Delta_INT_20180931.txt
@@ -0,0 +1,9 @@
+id	effectiveTime	active	moduleId	sourceId	destinationId	relationshipGroup	typeId	characteristicTypeId	modifierId
+# Laterality - is a - Concept model object attribute
+200031001	20180931	1	900000000000012004	272741003	762705008	0	116680003	900000000000011006	900000000000451002
+
+# Left - is a - Model Component
+200032001	20180931	1	900000000000012004	7771000	900000000000441003	0	116680003	900000000000011006	900000000000451002
+
+# Disorder of endocrine system - Laterality - Left ...this is nonsense but supports testing
+200033001	20180931	1	900000000000207008	362969004	7771000	0	272741003	900000000000011006	900000000000451002
diff --git a/src/test/resources/SnomedCT_MiniRF2_Add_Laterality_delta/Delta/Terminology/sct2_StatedRelationship_Delta_INT_20180931.txt b/src/test/resources/SnomedCT_MiniRF2_Add_Laterality_delta/Delta/Terminology/sct2_StatedRelationship_Delta_INT_20180931.txt
new file mode 100644
index 0000000..8b8781c
--- /dev/null
+++ b/src/test/resources/SnomedCT_MiniRF2_Add_Laterality_delta/Delta/Terminology/sct2_StatedRelationship_Delta_INT_20180931.txt
@@ -0,0 +1,13 @@
+#
+# Comments are removed by unit test
+#
+id	effectiveTime	active	moduleId	sourceId	destinationId	relationshipGroup	typeId	characteristicTypeId	modifierId
+
+# Laterality - is a - Concept model object attribute
+100011001	20180931	1	900000000000012004	272741003	762705008	0	116680003	900000000000010007	900000000000451002
+
+# Left - is a - Model Component
+100012001	20180931	1	900000000000012004	7771000	900000000000441003	0	116680003	900000000000010007	900000000000451002
+
+# Disorder of endocrine system - Laterality - Left ...this is nonsense but supports testing
+100013001	20180931	1	900000000000207008	362969004	7771000	0	272741003	900000000000010007	900000000000451002
