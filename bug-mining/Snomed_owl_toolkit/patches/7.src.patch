diff --git a/src/main/java/org/snomed/otf/owltoolkit/normalform/RelationshipChangeProcessor.java b/src/main/java/org/snomed/otf/owltoolkit/normalform/RelationshipChangeProcessor.java
index 9c3ac7b..2ca5218 100644
--- a/src/main/java/org/snomed/otf/owltoolkit/normalform/RelationshipChangeProcessor.java
+++ b/src/main/java/org/snomed/otf/owltoolkit/normalform/RelationshipChangeProcessor.java
@@ -15,9 +15,6 @@
  */
 package org.snomed.otf.owltoolkit.normalform;
 
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Ordering;
-import com.google.common.collect.Sets;
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
 import org.snomed.otf.owltoolkit.constants.Concepts;
 import org.snomed.otf.owltoolkit.domain.Relationship;
@@ -30,6 +27,14 @@ import java.util.*;
  */
 public class RelationshipChangeProcessor {
 
+	private static final Comparator<Relationship> RELATIONSHIP_COMPARATOR_ALL_FIELDS = Comparator
+			.comparing(Relationship::getTypeId)
+			.thenComparing(Relationship::getDestinationId)
+			.thenComparing(Relationship::getGroup)
+			.thenComparing(Relationship::getUnionGroup)
+			.thenComparing(Relationship::isUniversal)
+			.thenComparing(Relationship::isDestinationNegated);
+
 	private final Map<Long, Set<Relationship>> addedStatements;
 	private final Map<Long, Set<Relationship>> removedStatements;
 	private Long addedCount;
@@ -44,32 +49,39 @@ public class RelationshipChangeProcessor {
 		skipAdditionalPartOf = skipAdditionalRelationship;
 	}
 
-	public void apply(final long conceptId, final Collection<Relationship> oldCollection, final Collection<Relationship> newCollection, final Ordering<Relationship> ordering) {
+	public void apply(final long conceptId, final Collection<Relationship> existingRelationships, final Collection<Relationship> newRelationships) {
 
-		final TreeSet<Relationship> uniqueOlds = Sets.newTreeSet(ordering);
-		final ImmutableList<Relationship> sortedOld = ordering.immutableSortedCopy(oldCollection);
-		final ImmutableList<Relationship> sortedNew = ordering.immutableSortedCopy(newCollection);
+		final TreeSet<Relationship> uniqueOlds = new TreeSet<>(RELATIONSHIP_COMPARATOR_ALL_FIELDS);
+		final List<Relationship> sortedOld = newSortedList(existingRelationships, RELATIONSHIP_COMPARATOR_ALL_FIELDS);
+		final List<Relationship> sortedNew = newSortedList(newRelationships, RELATIONSHIP_COMPARATOR_ALL_FIELDS);
 
 
 		// Collect removed subjects and added subjects
 		// Use secondary compare to find matching groups with a new number.. we should mark this during groups.adjustOrder(inferredGroups) to be sure they are from the same group!
 
-
+		// For each existing relationship if it can not be found in the new set mark it as removed
 		for (final Relationship oldSubject : sortedOld) {
-			final int idx = ordering.binarySearch(sortedNew, oldSubject);
+			final int i = Collections.binarySearch(sortedNew, oldSubject, RELATIONSHIP_COMPARATOR_ALL_FIELDS);
+			if (i < 0 || !uniqueOlds.add(oldSubject)) {
 
-			if (idx < 0 || !uniqueOlds.add(oldSubject)) {
 				handleRemovedSubject(conceptId, oldSubject);
 			}
 		}
 
+		// For each relationship in the new set if it does not match one in the old set mark is as added
 		for (final Relationship newMini : sortedNew) {
-			if (ordering.binarySearch(sortedOld, newMini) < 0) {
+			if (Collections.binarySearch(sortedOld, newMini, RELATIONSHIP_COMPARATOR_ALL_FIELDS) < 0) {
 				handleAddedSubject(conceptId, newMini);
 			}
 		}
 	}
 
+	private List<Relationship> newSortedList(Collection<Relationship> relationships, Comparator<Relationship> comparator) {
+		final List<Relationship> sortedOld = new ArrayList<>(relationships);
+		sortedOld.sort(comparator);
+		return sortedOld;
+	}
+
 	protected void handleAddedSubject(long conceptId, Relationship addedSubject) {
 		addedStatements.computeIfAbsent(conceptId, k -> new HashSet<>()).add(addedSubject);
 		addedCount++;
diff --git a/src/main/java/org/snomed/otf/owltoolkit/normalform/RelationshipNormalFormGenerator.java b/src/main/java/org/snomed/otf/owltoolkit/normalform/RelationshipNormalFormGenerator.java
index 0a96cd3..e9900f6 100644
--- a/src/main/java/org/snomed/otf/owltoolkit/normalform/RelationshipNormalFormGenerator.java
+++ b/src/main/java/org/snomed/otf/owltoolkit/normalform/RelationshipNormalFormGenerator.java
@@ -117,7 +117,7 @@ public final class RelationshipNormalFormGenerator {
 		for (Long conceptId : entries) {
 			final Collection<Relationship> existingComponents = snomedTaxonomy.getInferredRelationships((long) conceptId);
 			final Collection<Relationship> generatedComponents = secondNormalisationPass(conceptId);
-			processor.apply(conceptId, existingComponents, generatedComponents, StatementFragmentOrdering.INSTANCE);
+			processor.apply(conceptId, existingComponents, generatedComponents);
 		}
 
 		LOGGER.info(MessageFormat.format("<<< Relationship normal form generation [{0}]", stopwatch.toString()));
diff --git a/src/main/java/org/snomed/otf/owltoolkit/normalform/StatementFragmentOrdering.java b/src/main/java/org/snomed/otf/owltoolkit/normalform/StatementFragmentOrdering.java
deleted file mode 100644
index 708f56a..0000000
--- a/src/main/java/org/snomed/otf/owltoolkit/normalform/StatementFragmentOrdering.java
+++ /dev/null
@@ -1,66 +0,0 @@
-/*
- * Copyright 2017 SNOMED International, http://snomed.org
- * Copyright 2011-2015 B2i Healthcare Pte Ltd, http://b2i.sg
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.snomed.otf.owltoolkit.normalform;
-
-import com.google.common.collect.Ordering;
-import com.google.common.primitives.Booleans;
-import com.google.common.primitives.Longs;
-import org.snomed.otf.owltoolkit.domain.Relationship;
-
-/**
- * Compares {@link Relationship} instances for change processing.
- *
- */
-public final class StatementFragmentOrdering extends Ordering<Relationship> {
-	
-	public static final Ordering<Relationship> INSTANCE = new StatementFragmentOrdering();
-	
-	private StatementFragmentOrdering() {
-		// Prevents instantiation
-	}
-	
-	/*
-	 * (non-Javadoc)
-	 * @see com.google.common.collect.Ordering#compare(java.lang.Object, java.lang.Object)
-	 */
-	@Override
-	public int compare(final Relationship o1, final Relationship o2) {
-
-		final int attributeDelta = Longs.compare(o1.getTypeId(), o2.getTypeId());
-		if (attributeDelta != 0)
-			return attributeDelta;
-
-		final int valueDelta = Longs.compare(o1.getDestinationId(), o2.getDestinationId());
-		if (valueDelta != 0)
-			return valueDelta;
-
-		final int groupDelta = o1.getGroup() - o2.getGroup();
-		if (groupDelta != 0)
-			return groupDelta;
-		
-		final int unionGroupDelta = o1.getUnionGroup() - o2.getUnionGroup();
-		if (unionGroupDelta != 0)
-			return unionGroupDelta;
-
-		final int isUniversalDelta = Booleans.compare(o1.isUniversal(), o2.isUniversal());
-		if (isUniversalDelta != 0)
-			return isUniversalDelta;
-
-		final int isDestinationNegatedDelta = Booleans.compare(o1.isDestinationNegated(), o2.isDestinationNegated());
-		return isDestinationNegatedDelta;
-	}
-}
\ No newline at end of file
