diff --git a/src/main/java/org/snomed/otf/owltoolkit/normalform/NormalFormGenerator.java b/src/main/java/org/snomed/otf/owltoolkit/normalform/NormalFormGenerator.java
deleted file mode 100644
index a5a07f8..0000000
--- a/src/main/java/org/snomed/otf/owltoolkit/normalform/NormalFormGenerator.java
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- * Copyright 2018 SNOMED International, http://snomed.org
- * Copyright 2011-2016 B2i Healthcare Pte Ltd, http://b2i.sg
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.snomed.otf.owltoolkit.normalform;
-
-import com.google.common.collect.Ordering;
-import org.snomed.otf.owltoolkit.classification.ReasonerTaxonomy;
-import org.snomed.otf.owltoolkit.ontology.PropertyChain;
-import org.snomed.otf.owltoolkit.taxonomy.SnomedTaxonomy;
-
-import java.util.Collection;
-import java.util.List;
-import java.util.Set;
-
-/**
- * Base class for different implementations, which generate a set of components in normal form, based on a subsumption
- * hierarchy encapsulated in a reasoner.
- * 
- * @param <T> the generated component type
- * 
- */
-public abstract class NormalFormGenerator<T> {
-
-	protected final ReasonerTaxonomy reasonerTaxonomy;
-	
-	protected final SnomedTaxonomy snomedTaxonomy;
-
-	protected final Set<PropertyChain> propertyChains;
-
-	protected boolean preprocessingComplete = false;// TODO Remove this if not needed
-
-	public NormalFormGenerator(final ReasonerTaxonomy reasonerTaxonomy, SnomedTaxonomy snomedTaxonomy, Set<PropertyChain> propertyChains) {
-
-		this.reasonerTaxonomy = reasonerTaxonomy;
-		this.snomedTaxonomy = snomedTaxonomy;
-		this.propertyChains = propertyChains;
-	}
-	
-	/**
-	 * Computes and returns all changes as a result of normal form computation.
-	 * 
-	 * @param processor the change processor to route changes to
-	 * @param ordering an ordering defined over existing and generated components, used for detecting changes
-	 * @return the total number of generated components
-	 */
-	public final int collectNormalFormChanges(final OntologyChangeProcessor<T> processor, final Ordering<T> ordering) {
-		final List<Long> entries = reasonerTaxonomy.getConceptIds();
-		int generatedComponentCount = 0;
-
-		for (Long conceptId : entries) {
-			firstNormalisationPass(conceptId);
-		}
-
-		preprocessingComplete = true;
-
-		for (Long conceptId : entries) {
-			final Collection<T> existingComponents = getExistingComponents(conceptId);
-			final Collection<T> generatedComponents = secondNormalisationPass(conceptId);
-			processor.apply(conceptId, existingComponents, generatedComponents, ordering);
-			generatedComponentCount += generatedComponents.size();
-		}
-
-		return generatedComponentCount;
-	}
-
-	protected abstract Collection<T> getExistingComponents(final long conceptId);
-
-	/**
-	 * Computes and caches a set of components in normal form for the specified concept.
-	 * The first pass uses the is-a hierarchy for normalisation.
-	 * This hierarchy is available during the first pass because of the breath first order of processing concepts.
-	 *
-	 * @param conceptId the concept for which components should be generated
-	 */
-	protected abstract void firstNormalisationPass(final long conceptId);
-
-	/**
-	 * Performs additional normalisation as required before returning components in normal form for the specified concept.
-	 * The second pass uses property chains and transitive properties in order to further normalise components.
-	 * Other transitive hierarchies can not be guaranteed to be complete during the first pass because the super-type of a
-	 * concept in a transitive property hierarchy may be at a lower level in the is-a hierarchy meaning that it's processed later during the first pass.
-	 *
-	 * @param conceptId the concept for which components should be generated
-	 * @return the generated components of the specified concept in normal form
-	 */
-	protected abstract Collection<T> secondNormalisationPass(final long conceptId);
-
-}
diff --git a/src/main/java/org/snomed/otf/owltoolkit/normalform/OntologyChangeProcessor.java b/src/main/java/org/snomed/otf/owltoolkit/normalform/OntologyChangeProcessor.java
deleted file mode 100644
index f2a9c9b..0000000
--- a/src/main/java/org/snomed/otf/owltoolkit/normalform/OntologyChangeProcessor.java
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
- * Copyright 2017 SNOMED International, http://snomed.org
- * Copyright 2011-2016 B2i Healthcare Pte Ltd, http://b2i.sg
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.snomed.otf.owltoolkit.normalform;
-
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Ordering;
-import com.google.common.collect.Sets;
-
-import java.text.MessageFormat;
-import java.util.Collection;
-import java.util.TreeSet;
-
-/**
- * Compares two collections of change subjects and calls template methods whenever a removed, added or unmodified
- * element is encountered.
- * 
- * @param <T> the change subject's type
- * 
- */
-public abstract class OntologyChangeProcessor<T> {
-
-	public void apply(final long conceptId, final Collection<T> oldCollection, final Collection<T> newCollection, final Ordering<T> ordering) {
-		
-		final TreeSet<T> uniqueOlds = Sets.newTreeSet(ordering);
-		final ImmutableList<T> sortedOld = ordering.immutableSortedCopy(oldCollection);
-		final ImmutableList<T> sortedNew = ordering.immutableSortedCopy(newCollection);
-		
-		for (final T oldSubject : sortedOld) {
-			final int idx = ordering.binarySearch(sortedNew, oldSubject);
-			
-			if (idx < 0 || !uniqueOlds.add(oldSubject)) {
-				handleRemovedSubject(conceptId, oldSubject);
-			}
-		}
-		
-		for (final T newMini : sortedNew) {
-			if (ordering.binarySearch(sortedOld, newMini) < 0) {
-				handleAddedSubject(conceptId, newMini);
-			}
-		}
-	}
-	
-	public void apply(final Collection<OntologyChange<T>> changes) {
-		
-		if (changes == null || changes.isEmpty()) {
-			return;
-		}
-		
-		for (final OntologyChange<T> change : changes) {
-			final long conceptId = change.getConceptId();
-			switch (change.getNature()) {
-				case ADD:
-					handleAddedSubject(conceptId, change.getSubject());
-					break;
-				case REMOVE:
-					handleRemovedSubject(conceptId, change.getSubject());
-					break;
-				default:
-					throw new IllegalStateException(MessageFormat.format("Unexpected change nature {0}.", change.getNature()));
-			}
-		}
-	}
-
-	protected void handleRemovedSubject(final long conceptId, final T removedSubject) {
-		// Subclasses should override		
-	}
-
-	protected void handleAddedSubject(final long conceptId, final T addedSubject) {
-		// Subclasses should override
-	}
-}
diff --git a/src/main/java/org/snomed/otf/owltoolkit/normalform/RelationshipChangeCollector.java b/src/main/java/org/snomed/otf/owltoolkit/normalform/RelationshipChangeProcessor.java
similarity index 61%
rename from src/main/java/org/snomed/otf/owltoolkit/normalform/RelationshipChangeCollector.java
rename to src/main/java/org/snomed/otf/owltoolkit/normalform/RelationshipChangeProcessor.java
index 2d2970b..9c3ac7b 100644
--- a/src/main/java/org/snomed/otf/owltoolkit/normalform/RelationshipChangeCollector.java
+++ b/src/main/java/org/snomed/otf/owltoolkit/normalform/RelationshipChangeProcessor.java
@@ -15,15 +15,20 @@
  */
 package org.snomed.otf.owltoolkit.normalform;
 
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Ordering;
+import com.google.common.collect.Sets;
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
 import org.snomed.otf.owltoolkit.constants.Concepts;
 import org.snomed.otf.owltoolkit.domain.Relationship;
 
-import java.util.HashSet;
-import java.util.Map;
-import java.util.Set;
+import java.util.*;
 
-public class RelationshipChangeCollector extends OntologyChangeProcessor<Relationship> {
+/**
+ * Compares two collections of change subjects and calls template methods whenever a removed, added or unmodified
+ * element is encountered.
+ */
+public class RelationshipChangeProcessor {
 
 	private final Map<Long, Set<Relationship>> addedStatements;
 	private final Map<Long, Set<Relationship>> removedStatements;
@@ -31,7 +36,7 @@ public class RelationshipChangeCollector extends OntologyChangeProcessor<Relatio
 	private Long removedCount;
 	private boolean skipAdditionalPartOf;
 
-	public RelationshipChangeCollector(boolean skipAdditionalRelationship) {
+	public RelationshipChangeProcessor(boolean skipAdditionalRelationship) {
 		addedCount = 0L;
 		removedCount = 0L;
 		addedStatements = new Long2ObjectOpenHashMap<>();
@@ -39,13 +44,37 @@ public class RelationshipChangeCollector extends OntologyChangeProcessor<Relatio
 		skipAdditionalPartOf = skipAdditionalRelationship;
 	}
 
-	@Override
+	public void apply(final long conceptId, final Collection<Relationship> oldCollection, final Collection<Relationship> newCollection, final Ordering<Relationship> ordering) {
+
+		final TreeSet<Relationship> uniqueOlds = Sets.newTreeSet(ordering);
+		final ImmutableList<Relationship> sortedOld = ordering.immutableSortedCopy(oldCollection);
+		final ImmutableList<Relationship> sortedNew = ordering.immutableSortedCopy(newCollection);
+
+
+		// Collect removed subjects and added subjects
+		// Use secondary compare to find matching groups with a new number.. we should mark this during groups.adjustOrder(inferredGroups) to be sure they are from the same group!
+
+
+		for (final Relationship oldSubject : sortedOld) {
+			final int idx = ordering.binarySearch(sortedNew, oldSubject);
+
+			if (idx < 0 || !uniqueOlds.add(oldSubject)) {
+				handleRemovedSubject(conceptId, oldSubject);
+			}
+		}
+
+		for (final Relationship newMini : sortedNew) {
+			if (ordering.binarySearch(sortedOld, newMini) < 0) {
+				handleAddedSubject(conceptId, newMini);
+			}
+		}
+	}
+
 	protected void handleAddedSubject(long conceptId, Relationship addedSubject) {
 		addedStatements.computeIfAbsent(conceptId, k -> new HashSet<>()).add(addedSubject);
 		addedCount++;
 	}
 
-	@Override
 	protected void handleRemovedSubject(long conceptId, Relationship removedSubject) {
 		if (skipAdditionalPartOf) {
 			//We will preserve any "Additional" characteristic types eg PartOf relationships
diff --git a/src/main/java/org/snomed/otf/owltoolkit/normalform/RelationshipInactivationProcessor.java b/src/main/java/org/snomed/otf/owltoolkit/normalform/RelationshipInactivationProcessor.java
index c084b88..cc3cb49 100644
--- a/src/main/java/org/snomed/otf/owltoolkit/normalform/RelationshipInactivationProcessor.java
+++ b/src/main/java/org/snomed/otf/owltoolkit/normalform/RelationshipInactivationProcessor.java
@@ -13,7 +13,7 @@ public class RelationshipInactivationProcessor {
 		this.snomedTaxonomy = snomedTaxonomy;
 	}
 	
-	public void processInactivationChanges(RelationshipChangeCollector changeCollector) {
+	public void processInactivationChanges(RelationshipChangeProcessor changeCollector) {
 		Set<Long> inactiveConcepts = snomedTaxonomy.getInactivatedConcepts();
 		for (Long inactive : inactiveConcepts) {
 			for (Relationship rel : snomedTaxonomy.getInferredRelationships(inactive)) {
diff --git a/src/main/java/org/snomed/otf/owltoolkit/normalform/RelationshipNormalFormGenerator.java b/src/main/java/org/snomed/otf/owltoolkit/normalform/RelationshipNormalFormGenerator.java
index e06ef58..0a96cd3 100644
--- a/src/main/java/org/snomed/otf/owltoolkit/normalform/RelationshipNormalFormGenerator.java
+++ b/src/main/java/org/snomed/otf/owltoolkit/normalform/RelationshipNormalFormGenerator.java
@@ -45,7 +45,7 @@ import static org.snomed.otf.owltoolkit.constants.Concepts.IS_A_LONG;
  * Transforms a subsumption hierarchy and a set of non-ISA relationships into
  * distribution normal form.
  */
-public final class RelationshipNormalFormGenerator extends NormalFormGenerator<Relationship> {
+public final class RelationshipNormalFormGenerator {
 
 	/**
 	 * Special group number indicating that the next free group/union group number
@@ -54,18 +54,8 @@ public final class RelationshipNormalFormGenerator extends NormalFormGenerator<R
 	 */
 	public static final int NUMBER_NOT_PRESERVED = -1;
 
-	private final Map<Long, Set<AxiomRepresentation>> conceptAxiomStatementMap;
-
-	private static final int ZERO_GROUP = 0;
-
-	private final Map<Long, NodeGraph> transitiveNodeGraphs = new HashMap<>();
-
-	private final Set<Long> traversableProperties;
-
-	private final Map<Long, Collection<Relationship>> generatedNonIsACache = new Long2ObjectOpenHashMap<>();
-
 	private static final long INTERNATIONAL_CORE_MODULE_ID = Long.parseLong(Concepts.SNOMED_CT_CORE_MODULE);
-
+	private static final int ZERO_GROUP = 0;
 	private static final Comparator<Group> CORE_MODULE_GROUP_COMPARATOR = (o1, o2) -> {
 		long moduleId1 = o1.getUnionGroups().iterator().next().getRelationshipFragments().iterator().next().getModuleId();
 		long moduleId2 = o2.getUnionGroups().iterator().next().getRelationshipFragments().iterator().next().getModuleId();
@@ -76,9 +66,17 @@ public final class RelationshipNormalFormGenerator extends NormalFormGenerator<R
 		}
 		return 0;
 	};
-
 	private static final Logger LOGGER = LoggerFactory.getLogger(RelationshipNormalFormGenerator.class);
 
+	private final ReasonerTaxonomy reasonerTaxonomy;
+	private final SnomedTaxonomy snomedTaxonomy;
+	private final Set<PropertyChain> propertyChains;
+
+	private final Map<Long, Collection<Relationship>> generatedNonIsACache = new Long2ObjectOpenHashMap<>();
+	private final Set<Long> traversableProperties;
+	private final Map<Long, NodeGraph> transitiveNodeGraphs = new HashMap<>();
+	private final Map<Long, Set<AxiomRepresentation>> conceptAxiomStatementMap;
+
 	/**
 	 * Creates a new distribution normal form generator instance.
 	 * @param reasonerTaxonomy the reasoner to extract results from (may not be {@code null})
@@ -88,8 +86,10 @@ public final class RelationshipNormalFormGenerator extends NormalFormGenerator<R
 	 */
 	public RelationshipNormalFormGenerator(final ReasonerTaxonomy reasonerTaxonomy, final SnomedTaxonomy snomedTaxonomy,
 			final Map<Long, Set<AxiomRepresentation>> conceptAxiomStatementMap, final Set<PropertyChain> propertyChains) {
-		super(reasonerTaxonomy, snomedTaxonomy, propertyChains);
-		
+
+		this.reasonerTaxonomy = reasonerTaxonomy;
+		this.snomedTaxonomy = snomedTaxonomy;
+		this.propertyChains = propertyChains;
 		this.conceptAxiomStatementMap = conceptAxiomStatementMap;
 
 		traversableProperties = propertyChains.stream().map(PropertyChain::getDestinationType).collect(Collectors.toSet());
@@ -99,13 +99,38 @@ public final class RelationshipNormalFormGenerator extends NormalFormGenerator<R
 		traversableProperties.forEach(id -> transitiveNodeGraphs.put(id, new NodeGraph()));
 	}
 
-	@Override
-	public Collection<Relationship> getExistingComponents(final long conceptId) {
-		return snomedTaxonomy.getInferredRelationships(conceptId);
+	/**
+	 * Computes and returns all changes as a result of normal form computation.
+	 *
+	 * @param processor the change processor to route changes to
+	 * @return the total number of generated components
+	 */
+	public final void collectNormalFormChanges(final RelationshipChangeProcessor processor) {
+		LOGGER.info(">>> Relationship normal form generation");
+		final Stopwatch stopwatch = Stopwatch.createStarted();
+		final List<Long> entries = reasonerTaxonomy.getConceptIds();
+
+		for (Long conceptId : entries) {
+			firstNormalisationPass(conceptId);
+		}
+
+		for (Long conceptId : entries) {
+			final Collection<Relationship> existingComponents = snomedTaxonomy.getInferredRelationships((long) conceptId);
+			final Collection<Relationship> generatedComponents = secondNormalisationPass(conceptId);
+			processor.apply(conceptId, existingComponents, generatedComponents, StatementFragmentOrdering.INSTANCE);
+		}
+
+		LOGGER.info(MessageFormat.format("<<< Relationship normal form generation [{0}]", stopwatch.toString()));
 	}
 
-	@Override
-	public void firstNormalisationPass(long conceptId) {
+	/**
+	 * Computes and caches a set of components in normal form for the specified concept.
+	 * The first pass uses the is-a hierarchy for normalisation.
+	 * This hierarchy is available during the first pass because of the breath first order of processing concepts.
+	 *
+	 * @param conceptId the concept for which components should be generated
+	 */
+	private void firstNormalisationPass(long conceptId) {
 		final Set<Relationship> inferredNonIsAFragments = getInferredNonIsAFragmentsInNormalForm(conceptId);
 
 		// Place results in the cache, so children can re-use it
@@ -116,8 +141,16 @@ public final class RelationshipNormalFormGenerator extends NormalFormGenerator<R
 				transitiveNodeGraphs.get(r.getTypeId()).addParent(conceptId, r.getDestinationId()));
 	}
 
-	@Override
-	public Collection<Relationship> secondNormalisationPass(final long conceptId) {
+	/**
+	 * Performs additional normalisation as required before returning components in normal form for the specified concept.
+	 * The second pass uses property chains and transitive properties in order to further normalise components.
+	 * Other transitive hierarchies can not be guaranteed to be complete during the first pass because the super-type of a
+	 * concept in a transitive property hierarchy may be at a lower level in the is-a hierarchy meaning that it's processed later during the first pass.
+	 *
+	 * @param conceptId the concept for which components should be generated
+	 * @return the generated components of the specified concept in normal form
+	 */
+	private Collection<Relationship> secondNormalisationPass(final long conceptId) {
 		final Set<Long> directSuperTypes = reasonerTaxonomy.getParents(conceptId);
 
 		// Step 1: collect IS-A relationships
@@ -234,6 +267,7 @@ public final class RelationshipNormalFormGenerator extends NormalFormGenerator<R
 
 		// Sort groups to favour the core module
 		inferredGroups.sort(CORE_MODULE_GROUP_COMPARATOR);
+
 		// Shuffle around the numbers to match existing inferred group numbers as much as possible
 		groups.adjustOrder(inferredGroups);
 
@@ -405,13 +439,6 @@ public final class RelationshipNormalFormGenerator extends NormalFormGenerator<R
 				.collect(Collectors.toSet());
 	}
 
-	public final void collectNormalFormChanges(final OntologyChangeProcessor<Relationship> processor) {
-		LOGGER.info(">>> Relationship normal form generation");
-		final Stopwatch stopwatch = Stopwatch.createStarted();
-		collectNormalFormChanges(processor, StatementFragmentOrdering.INSTANCE);
-		LOGGER.info(MessageFormat.format("<<< Relationship normal form generation [{0}]", stopwatch.toString()));
-	}
-
 	public ReasonerTaxonomy getReasonerTaxonomy() {
 		return reasonerTaxonomy;
 	}
diff --git a/src/main/java/org/snomed/otf/owltoolkit/service/ClassificationResultsWriter.java b/src/main/java/org/snomed/otf/owltoolkit/service/ClassificationResultsWriter.java
index 87333d3..6df5050 100644
--- a/src/main/java/org/snomed/otf/owltoolkit/service/ClassificationResultsWriter.java
+++ b/src/main/java/org/snomed/otf/owltoolkit/service/ClassificationResultsWriter.java
@@ -17,8 +17,7 @@ package org.snomed.otf.owltoolkit.service;
 
 import org.snomed.otf.owltoolkit.constants.Concepts;
 import org.snomed.otf.owltoolkit.domain.Relationship;
-import org.snomed.otf.owltoolkit.normalform.RelationshipChangeCollector;
-import org.snomed.otf.owltoolkit.service.ReasonerServiceException;
+import org.snomed.otf.owltoolkit.normalform.RelationshipChangeProcessor;
 
 import java.io.BufferedWriter;
 import java.io.IOException;
@@ -39,7 +38,7 @@ public class ClassificationResultsWriter {
 	private static final String TAB = "\t";
 
 	public void writeResultsRf2Archive(
-			RelationshipChangeCollector changeCollector,
+			RelationshipChangeProcessor changeCollector,
 			List<Set<Long>> equivalentConceptIdSets,
 			OutputStream resultsOutputStream,
 			Date startDate) throws ReasonerServiceException {
diff --git a/src/main/java/org/snomed/otf/owltoolkit/service/SnomedReasonerService.java b/src/main/java/org/snomed/otf/owltoolkit/service/SnomedReasonerService.java
index 9fa299d..0e11190 100644
--- a/src/main/java/org/snomed/otf/owltoolkit/service/SnomedReasonerService.java
+++ b/src/main/java/org/snomed/otf/owltoolkit/service/SnomedReasonerService.java
@@ -27,7 +27,7 @@ import org.snomed.otf.owltoolkit.constants.Concepts;
 import org.snomed.otf.owltoolkit.conversion.AxiomRelationshipConversionService;
 import org.snomed.otf.owltoolkit.conversion.ConversionException;
 import org.snomed.otf.owltoolkit.domain.AxiomRepresentation;
-import org.snomed.otf.owltoolkit.normalform.RelationshipChangeCollector;
+import org.snomed.otf.owltoolkit.normalform.RelationshipChangeProcessor;
 import org.snomed.otf.owltoolkit.normalform.RelationshipInactivationProcessor;
 import org.snomed.otf.owltoolkit.normalform.RelationshipNormalFormGenerator;
 import org.snomed.otf.owltoolkit.ontology.OntologyDebugUtil;
@@ -161,7 +161,7 @@ public class SnomedReasonerService {
 		}
 		RelationshipNormalFormGenerator normalFormGenerator = new RelationshipNormalFormGenerator(reasonerTaxonomy, snomedTaxonomy, conceptAxiomStatementMap, propertyChains);
 
-		RelationshipChangeCollector changeCollector = new RelationshipChangeCollector(true);
+		RelationshipChangeProcessor changeCollector = new RelationshipChangeProcessor(true);
 		normalFormGenerator.collectNormalFormChanges(changeCollector);
 		timer.checkpoint("Generate normal form");
 
@@ -169,7 +169,7 @@ public class SnomedReasonerService {
 
 		logger.info("Inactivating inferred relationships for new inactive concepts");
 		RelationshipInactivationProcessor processor = new RelationshipInactivationProcessor(snomedTaxonomy);
-		RelationshipChangeCollector inactivationCollector = new RelationshipChangeCollector(false);
+		RelationshipChangeProcessor inactivationCollector = new RelationshipChangeProcessor(false);
 		processor.processInactivationChanges(inactivationCollector);
 		changeCollector.getRemovedStatements().putAll(inactivationCollector.getRemovedStatements());
 
