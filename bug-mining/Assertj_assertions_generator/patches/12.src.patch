diff --git a/src/main/java/org/assertj/assertions/generator/BaseAssertionGenerator.java b/src/main/java/org/assertj/assertions/generator/BaseAssertionGenerator.java
index 91f3794..6eec201 100644
--- a/src/main/java/org/assertj/assertions/generator/BaseAssertionGenerator.java
+++ b/src/main/java/org/assertj/assertions/generator/BaseAssertionGenerator.java
@@ -16,6 +16,7 @@ import static java.lang.String.format;
 import static org.apache.commons.io.IOUtils.closeQuietly;
 import static org.apache.commons.lang3.StringUtils.capitalize;
 import static org.apache.commons.lang3.StringUtils.isEmpty;
+import static org.apache.commons.lang3.StringUtils.remove;
 
 import java.io.File;
 import java.io.FileWriter;
@@ -27,6 +28,7 @@ import java.util.TreeSet;
 
 import org.assertj.assertions.generator.Template.Type;
 import org.assertj.assertions.generator.description.ClassDescription;
+import org.assertj.assertions.generator.description.FieldDescription;
 import org.assertj.assertions.generator.description.GetterDescription;
 import org.assertj.assertions.generator.description.TypeName;
 
@@ -237,6 +239,7 @@ public class BaseAssertionGenerator implements AssertionGenerator, AssertionsEnt
 
     // generate assertion method for each property with a public getter
     assertionFileContentBuilder.append(generateAssertionsForGettersOf(classDescription));
+    assertionFileContentBuilder.append(generateAssertionsForPublicFieldsOf(classDescription));
 
     // close class with }
     assertionFileContentBuilder.append(LINE_SEPARATOR).append("}").append(LINE_SEPARATOR);
@@ -418,7 +421,7 @@ public class BaseAssertionGenerator implements AssertionGenerator, AssertionsEnt
 
   protected String generateAssertionsForGettersOf(ClassDescription classDescription) {
     StringBuilder assertionsForGetters = new StringBuilder();
-    Set<GetterDescription> getters = classDescription.getGetters();
+    Set<GetterDescription> getters = classDescription.getGettersDescriptions();
     for (GetterDescription getter : getters) {
       String assertionContent = assertionContentFor(getter);
       assertionsForGetters.append(assertionContent).append(LINE_SEPARATOR);
@@ -426,6 +429,48 @@ public class BaseAssertionGenerator implements AssertionGenerator, AssertionsEnt
     return assertionsForGetters.toString();
   }
 
+  protected String generateAssertionsForPublicFieldsOf(ClassDescription classDescription) {
+    StringBuilder assertionsForPublicFields = new StringBuilder();
+    Set<FieldDescription> fields = classDescription.getFieldsDescriptions();
+    for (FieldDescription field : fields) {
+      String assertionContent = assertionContentFor(field);
+      assertionsForPublicFields.append(assertionContent).append(LINE_SEPARATOR);
+    }
+    return assertionsForPublicFields.toString();
+  }
+  
+  private String assertionContentFor(FieldDescription field) {
+    String assertionContent = hasAssertionTemplate.getContent();
+    if (field.isBooleanPropertyType()) {
+      assertionContent = isAssertionTemplate.getContent();
+    } else if (field.isIterablePropertyType()) {
+      StringBuilder sb = new StringBuilder(field.getElementTypeName());
+      if (field.isArrayPropertyType()) {
+        sb.append("[]");
+      }
+      assertionContent = hasIterableElementsAssertionTemplate.getContent().replaceAll(ELEMENT_TYPE_REGEXP,
+                                                                                      sb.toString());
+    } else if (field.isArrayPropertyType()) {
+      assertionContent = hasArrayElementsAssertionTemplate.getContent().replaceAll(ELEMENT_TYPE_REGEXP,
+                                                                                   field.getElementTypeName());
+    } else if (field.isPrimitivePropertyType()) {
+      assertionContent = hasAssertionTemplateForPrimitive.getContent();
+    }
+
+    // we reuse template for properties to have consistent assertins for property and field but 
+    // - change the way we get the value since it's a field and not a property:
+    assertionContent = assertionContent.replace("get${Property}()", "${property}")
+                                       .replace("is${Property}()", "${property}");
+    // - remove also ${throws} and ${throws_javadoc} since it make no sense for a field
+    assertionContent = remove(assertionContent, "${throws}");
+    assertionContent = remove(assertionContent, "${throws_javadoc}");
+    
+    // replace ${Property} and ${property} by field name (starting with uppercase/lowercase)
+    return assertionContent.replaceAll(PROPERTY_WITH_UPPERCASE_FIRST_CHAR_REGEXP, capitalize(field.getName()))
+                           .replaceAll(PROPERTY_TYPE_REGEXP, field.getPropertyTypeName())
+                           .replaceAll(PROPERTY_WITH_LOWERCASE_FIRST_CHAR_REGEXP, field.getName());
+  }
+  
   private String assertionContentFor(GetterDescription getter) {
     // sets default content (most likely case)
     String assertionContent = hasAssertionTemplate.getContent();
@@ -444,9 +489,9 @@ public class BaseAssertionGenerator implements AssertionGenerator, AssertionsEnt
     } else if (getter.isPrimitivePropertyType()) {
       assertionContent = hasAssertionTemplateForPrimitive.getContent();
     }
-
+    
     assertionContent = declareExceptions(getter, assertionContent);
-
+    
     String propertyName = getter.getPropertyName();
     assertionContent = assertionContent.replaceAll(PROPERTY_WITH_UPPERCASE_FIRST_CHAR_REGEXP, capitalize(propertyName));
     assertionContent = assertionContent.replaceAll(PROPERTY_TYPE_REGEXP, getter.getPropertyTypeName());
diff --git a/src/main/java/org/assertj/assertions/generator/description/ClassDescription.java b/src/main/java/org/assertj/assertions/generator/description/ClassDescription.java
index 39472c5..46c040e 100644
--- a/src/main/java/org/assertj/assertions/generator/description/ClassDescription.java
+++ b/src/main/java/org/assertj/assertions/generator/description/ClassDescription.java
@@ -27,6 +27,7 @@ public class ClassDescription {
 
   private Set<TypeName> typesToImports;
   private Set<GetterDescription> gettersDescriptions;
+  private Set<FieldDescription> fieldsDescriptions;
   private TypeName classTypeName;
 
   public ClassDescription(TypeName typeName) {
@@ -34,6 +35,7 @@ public class ClassDescription {
     this.classTypeName = typeName;
     this.typesToImports = new TreeSet<TypeName>();
     this.gettersDescriptions = new TreeSet<GetterDescription>();
+    this.fieldsDescriptions = new TreeSet<FieldDescription>();
   }
 
   public String getClassName() {
@@ -64,12 +66,20 @@ public class ClassDescription {
     this.typesToImports.addAll(typesToImport);
   }
 
-  public Set<GetterDescription> getGetters() {
+  public Set<GetterDescription> getGettersDescriptions() {
     return gettersDescriptions;
   }
 
   public void addGetterDescriptions(Collection<GetterDescription> getterDescriptions) {
-    gettersDescriptions.addAll(getterDescriptions);
+    this.gettersDescriptions.addAll(getterDescriptions);
+  }
+  
+  public void addFieldDescriptions(Set<FieldDescription> fieldDescriptions) {
+    this.fieldsDescriptions.addAll(fieldDescriptions);
+  }
+  
+  public Set<FieldDescription> getFieldsDescriptions() {
+    return fieldsDescriptions;
   }
 
   @Override
diff --git a/src/main/java/org/assertj/assertions/generator/description/FieldDescription.java b/src/main/java/org/assertj/assertions/generator/description/FieldDescription.java
new file mode 100644
index 0000000..64a881e
--- /dev/null
+++ b/src/main/java/org/assertj/assertions/generator/description/FieldDescription.java
@@ -0,0 +1,82 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ * 
+ * Copyright @2010-2011 the original author or authors.
+ */
+package org.assertj.assertions.generator.description;
+
+
+/**
+ * Stores the information needed to generate an assertion for a public field.
+ * <p>
+ * Let's say we have the following method in class <code>Person</code> :
+ * 
+ * <pre>
+ * <code>public int age</code>
+ * </pre>
+ * <p>
+ * To generate <code>PersonAssert</code> <code>hasAge(int expectedAge)</code> assertion in <code>PersonAssert</code>, we
+ * need to know :
+ * <ul>
+ * <li>the property name, here "age"</li>
+ * <li>property type</li>
+ * </ul>
+ * This class is immutable.
+ * 
+ * @author Joel Costigliola
+ */
+public class FieldDescription implements Comparable<FieldDescription> {
+
+  private String name;
+  private TypeDescription typeDescription;
+  
+  public FieldDescription(String name, TypeDescription typeDescription) {
+    super();
+    this.name = name;
+    this.typeDescription = typeDescription;
+  }
+
+  public String getName() {
+    return name;
+  }
+
+  public String getPropertyTypeName() {
+    return typeDescription.getSimpleNameWithOuterClass();
+  }
+
+  public boolean isIterablePropertyType() {
+    return typeDescription.isIterable();
+  }
+
+  public boolean isArrayPropertyType() {
+    return typeDescription.isArray();
+  }
+
+  public boolean isPrimitivePropertyType() {
+    return typeDescription.isPrimitive();
+  }
+
+  public boolean isBooleanPropertyType() {
+    return typeDescription.isBoolean();
+  }
+
+  public int compareTo(FieldDescription other) {
+    return name.compareTo(other.name);
+  }
+
+  public String getElementTypeName() {
+    return typeDescription.getElementTypeName() == null ? null : typeDescription.getElementTypeName().getSimpleNameWithOuterClass();
+  }
+
+  @Override
+  public String toString() {
+    return "FieldDescription[name=" + name + ", typeDescription=" + typeDescription + "]";
+  }
+}
diff --git a/src/main/java/org/assertj/assertions/generator/description/converter/ClassToClassDescriptionConverter.java b/src/main/java/org/assertj/assertions/generator/description/converter/ClassToClassDescriptionConverter.java
index 28a7d2f..ed91f0d 100644
--- a/src/main/java/org/assertj/assertions/generator/description/converter/ClassToClassDescriptionConverter.java
+++ b/src/main/java/org/assertj/assertions/generator/description/converter/ClassToClassDescriptionConverter.java
@@ -13,26 +13,39 @@
 package org.assertj.assertions.generator.description.converter;
 
 import static org.assertj.assertions.generator.description.TypeName.JAVA_LANG_PACKAGE;
-import static org.assertj.assertions.generator.util.ClassUtil.*;
-
-import com.google.common.annotations.VisibleForTesting;
+import static org.assertj.assertions.generator.util.ClassUtil.getClassesRelatedTo;
+import static org.assertj.assertions.generator.util.ClassUtil.getterMethodsOf;
+import static org.assertj.assertions.generator.util.ClassUtil.isArray;
+import static org.assertj.assertions.generator.util.ClassUtil.isIterable;
+import static org.assertj.assertions.generator.util.ClassUtil.propertyNameOf;
+import static org.assertj.assertions.generator.util.ClassUtil.publicFieldsOf;
 
+import java.lang.reflect.Field;
 import java.lang.reflect.GenericArrayType;
 import java.lang.reflect.Method;
 import java.lang.reflect.ParameterizedType;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.TreeSet;
 
 import org.assertj.assertions.generator.description.ClassDescription;
+import org.assertj.assertions.generator.description.FieldDescription;
 import org.assertj.assertions.generator.description.GetterDescription;
 import org.assertj.assertions.generator.description.TypeDescription;
 import org.assertj.assertions.generator.description.TypeName;
 import org.assertj.assertions.generator.util.ClassUtil;
 
+import com.google.common.annotations.VisibleForTesting;
+
 public class ClassToClassDescriptionConverter implements ClassDescriptionConverter<Class<?>> {
 
   public ClassDescription convertToClassDescription(Class<?> clazz) {
     ClassDescription classDescription = new ClassDescription(new TypeName(clazz));
     classDescription.addGetterDescriptions(getterDescriptionsOf(clazz));
+    classDescription.addFieldDescriptions(fieldDescriptionsOf(clazz));
     classDescription.addTypeToImport(getNeededImportsFor(clazz));
     return classDescription;
   }
@@ -50,6 +63,16 @@ public class ClassToClassDescriptionConverter implements ClassDescriptionConvert
     }
     return getterDescriptions;
   }
+  
+  @VisibleForTesting
+  protected Set<FieldDescription> fieldDescriptionsOf(Class<?> clazz) {
+    Set<FieldDescription> fieldDescriptions = new TreeSet<FieldDescription>();
+    List<Field> fields = publicFieldsOf(clazz);
+    for (Field field : fields) {
+      fieldDescriptions.add(new FieldDescription(field.getName(), getTypeDescription(field)));
+    }
+    return fieldDescriptions;
+  }
 
   private boolean isGetDeclaringClassEnumGetter(final Method getter, final Class<?> clazz) {
     return clazz.isEnum() && getter.getName().equals("getDeclaringClass");
@@ -92,6 +115,36 @@ public class ClassToClassDescriptionConverter implements ClassDescriptionConvert
     }
     return typeDescription;
   }
+  
+  protected TypeDescription getTypeDescription(Field field) { // TODO refactor
+    final Class<?> propertyType = field.getType();
+    final TypeDescription typeDescription = new TypeDescription(new TypeName(propertyType));
+    if (isArray(propertyType)) {
+      typeDescription.setElementTypeName(new TypeName(propertyType.getComponentType()));
+      typeDescription.setArray(true);
+    } else if (isIterable(propertyType)) {
+      ParameterizedType parameterizedType = (ParameterizedType) field.getGenericType();
+      if (parameterizedType.getActualTypeArguments()[0] instanceof GenericArrayType) {
+        GenericArrayType genericArrayType = (GenericArrayType) parameterizedType.getActualTypeArguments()[0];
+        Class<?> parameterClass = ClassUtil.getClass(genericArrayType.getGenericComponentType());
+        typeDescription.setElementTypeName(new TypeName(parameterClass));
+        typeDescription.setIterable(true);
+        typeDescription.setArray(true);
+      } else {
+        // Due to http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=7151486, try to change if java 7 and
+        // a real array
+        Class<?> internalClass = ClassUtil.getClass(parameterizedType.getActualTypeArguments()[0]);
+        if (internalClass.isArray()) {
+          typeDescription.setElementTypeName(new TypeName(internalClass.getComponentType()));
+          typeDescription.setArray(true);
+        } else {
+          typeDescription.setElementTypeName(new TypeName(internalClass));
+        }
+      }
+      typeDescription.setIterable(true);
+    }
+    return typeDescription;
+  }
 
   protected Set<TypeName> getNeededImportsFor(Class<?> clazz) {
     // collect property types
diff --git a/src/main/java/org/assertj/assertions/generator/util/ClassUtil.java b/src/main/java/org/assertj/assertions/generator/util/ClassUtil.java
index 4531ed5..b47c078 100644
--- a/src/main/java/org/assertj/assertions/generator/util/ClassUtil.java
+++ b/src/main/java/org/assertj/assertions/generator/util/ClassUtil.java
@@ -15,8 +15,10 @@ import org.reflections.util.FilterBuilder;
 import java.io.File;
 import java.io.IOException;
 import java.io.UnsupportedEncodingException;
+import java.lang.reflect.Field;
 import java.lang.reflect.GenericArrayType;
 import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.net.URL;
@@ -269,8 +271,7 @@ public class ClassUtil {
   public static List<Method> getterMethodsOf(Class<?> clazz) {
     Method[] methods = clazz.getMethods();
     List<Method> getters = new ArrayList<Method>();
-    for (int i = 0; i < methods.length; i++) {
-      Method method = methods[i];
+    for (Method method : methods) {
       if (isNotDefinedInObjectClass(method) && (isStandardGetter(method) || isBooleanGetter(method))) {
         getters.add(method);
       }
@@ -278,6 +279,21 @@ public class ClassUtil {
     return getters;
   }
 
+  public static List<Field> publicFieldsOf(Class<?> clazz) {
+    Field[] fields = clazz.getFields();
+    List<Field> nonStaticPublicFields = new ArrayList<Field>();
+    for (Field field : fields) {
+      if (isNotStaticPublicField(field)) {
+        nonStaticPublicFields.add(field);
+      }
+    }
+    return nonStaticPublicFields;
+  }
+  
+  private static boolean isNotStaticPublicField(Field field) {
+    return !Modifier.isStatic(field.getModifiers());
+  }
+
   private static boolean isNotDefinedInObjectClass(Method method) {
     return !method.getDeclaringClass().equals(Object.class);
   }
@@ -302,8 +318,6 @@ public class ClassUtil {
         } else if (actualTypeArgument instanceof GenericArrayType) {
           classes.addAll(getClassesRelatedTo(actualTypeArgument));
         }
-        // throw new IllegalArgumentException("cannot find type " + actualTypeArgument);
-        // I'm almost sure we should not arrive here !
       }
       Type rawType = parameterizedType.getRawType();
       if (rawType instanceof Class) {
diff --git a/src/test/java/org/assertj/assertions/generator/AssertionGeneratorTest.java b/src/test/java/org/assertj/assertions/generator/AssertionGeneratorTest.java
index e493114..eefde82 100644
--- a/src/test/java/org/assertj/assertions/generator/AssertionGeneratorTest.java
+++ b/src/test/java/org/assertj/assertions/generator/AssertionGeneratorTest.java
@@ -14,6 +14,10 @@ import java.io.IOException;
 import java.sql.SQLException;
 import java.util.List;
 
+import org.assertj.assertions.generator.data.Player;
+import org.assertj.assertions.generator.data.Team;
+import org.assertj.assertions.generator.description.ClassDescription;
+import org.assertj.assertions.generator.description.converter.ClassToClassDescriptionConverter;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.experimental.theories.Theories;
@@ -21,9 +25,6 @@ import org.junit.experimental.theories.Theory;
 import org.junit.runner.RunWith;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
-import org.assertj.assertions.generator.data.Player;
-import org.assertj.assertions.generator.description.ClassDescription;
-import org.assertj.assertions.generator.description.converter.ClassToClassDescriptionConverter;
 
 @RunWith(Theories.class)
 public class AssertionGeneratorTest implements NestedClassesTest, BeanWithExceptionsTest {
@@ -49,7 +50,13 @@ public class AssertionGeneratorTest implements NestedClassesTest, BeanWithExcept
   public void should_generate_assertion_for_player_class() throws Exception {
     assertionGenerator.generateCustomAssertionFor(converter.convertToClassDescription(Player.class));
     assertThat(fileGeneratedFor(Player.class)).hasContentEqualTo(
-        new File("src/test/resources/PlayerAssert.expected" + ".txt").getAbsoluteFile());
+        new File("src/test/resources/PlayerAssert.expected.txt").getAbsoluteFile());
+  }
+  
+  @Test
+  public void should_generate_assertion_for_class_with_public_fields() throws Exception {
+    assertionGenerator.generateCustomAssertionFor(converter.convertToClassDescription(Team.class));
+    assertThat(fileGeneratedFor(Team.class)).hasContentEqualTo(new File("src/test/resources/TeamAssert.expected.txt").getAbsoluteFile());
   }
 
   @Theory
diff --git a/src/test/java/org/assertj/assertions/generator/data/Team.java b/src/test/java/org/assertj/assertions/generator/data/Team.java
new file mode 100644
index 0000000..6556e97
--- /dev/null
+++ b/src/test/java/org/assertj/assertions/generator/data/Team.java
@@ -0,0 +1,37 @@
+package org.assertj.assertions.generator.data;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class Team {
+
+  // to check that no assertion is created for public static field
+  public static String staticField;
+  
+  // public field to test that we generate assertions for public fields
+  public String name;
+  
+  public boolean westCoast;
+  public int rank;
+  public List<Player> players = new ArrayList<Player>();
+  public List<int[]> points = new ArrayList<int[]>();
+  public String[] oldNames = {};
+  
+  // private field : no assertion should be generated
+  @SuppressWarnings("unused")
+  private String privateField;
+  
+  // property : assertion should be generated
+  private String division;
+
+  public String getDivision() {
+    return division;
+  }
+
+  public Team(String name, String division) {
+    super();
+    this.name = name;
+    this.division = division;
+  }
+
+}
diff --git a/src/test/java/org/assertj/assertions/generator/description/FieldDescriptionTest.java b/src/test/java/org/assertj/assertions/generator/description/FieldDescriptionTest.java
new file mode 100644
index 0000000..f0e0226
--- /dev/null
+++ b/src/test/java/org/assertj/assertions/generator/description/FieldDescriptionTest.java
@@ -0,0 +1,25 @@
+package org.assertj.assertions.generator.description;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+import org.assertj.assertions.generator.data.Player;
+import org.junit.Test;
+
+public class FieldDescriptionTest {
+
+  private FieldDescription fieldDescription;
+
+  @Test
+  public void should_create_valid_typename_from_class() {
+    fieldDescription = new FieldDescription("bestPlayer", new TypeDescription(new TypeName(Player.class)));
+    assertThat(fieldDescription.getName()).isEqualTo("bestPlayer");
+    assertThat(fieldDescription.getPropertyTypeName()).isEqualTo("Player");
+    assertThat(fieldDescription.getElementTypeName()).isNull();
+  }
+
+  @Test
+  public void should_show_information_in_toString() {
+    fieldDescription = new FieldDescription("bestPlayer", new TypeDescription(new TypeName(Player.class)));
+    assertThat(fieldDescription.toString()).contains("bestPlayer").contains(Player.class.getName());
+  }
+}
diff --git a/src/test/java/org/assertj/assertions/generator/description/TypeNameTest.java b/src/test/java/org/assertj/assertions/generator/description/TypeNameTest.java
index b9672fb..1369cf5 100644
--- a/src/test/java/org/assertj/assertions/generator/description/TypeNameTest.java
+++ b/src/test/java/org/assertj/assertions/generator/description/TypeNameTest.java
@@ -2,7 +2,6 @@ package org.assertj.assertions.generator.description;
 
 import org.assertj.assertions.generator.NestedClassesTest;
 import org.assertj.assertions.generator.data.Player;
-
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.experimental.theories.Theories;
@@ -152,4 +151,10 @@ public class TypeNameTest implements NestedClassesTest {
     assertThat(typeNameB.compareTo(typeNameA)).isPositive();
   }
 
+  @Test
+  public void should_show_information_in_toString() {
+    assertThat(new TypeName("A", "org.mypackage").toString()).isEqualTo("org.mypackage.A");
+    assertThat(new TypeName(int.class).toString()).isEqualTo("int");
+  }
+
 }
diff --git a/src/test/java/org/assertj/assertions/generator/description/converter/ClassToClassDescriptionConverterTest.java b/src/test/java/org/assertj/assertions/generator/description/converter/ClassToClassDescriptionConverterTest.java
index 74f0f51..0d92698 100644
--- a/src/test/java/org/assertj/assertions/generator/description/converter/ClassToClassDescriptionConverterTest.java
+++ b/src/test/java/org/assertj/assertions/generator/description/converter/ClassToClassDescriptionConverterTest.java
@@ -9,6 +9,7 @@ import org.assertj.assertions.generator.BeanWithExceptionsTest;
 import org.assertj.assertions.generator.NestedClassesTest;
 import org.assertj.assertions.generator.data.Name;
 import org.assertj.assertions.generator.data.Player;
+import org.assertj.assertions.generator.data.Team;
 import org.assertj.assertions.generator.data.TreeEnum;
 import org.assertj.assertions.generator.data.lotr.FellowshipOfTheRing;
 import org.assertj.assertions.generator.data.lotr.Race;
@@ -37,7 +38,7 @@ public class ClassToClassDescriptionConverterTest implements NestedClassesTest,
     assertThat(classDescription.getClassName()).isEqualTo("Player");
     assertThat(classDescription.getClassNameWithOuterClass()).isEqualTo("Player");
     assertThat(classDescription.getPackageName()).isEqualTo("org.assertj.assertions.generator.data");
-    assertThat(classDescription.getGetters()).hasSize(9);
+    assertThat(classDescription.getGettersDescriptions()).hasSize(9);
     assertThat(classDescription.getImports()).containsOnly(new TypeName(Player.class), new TypeName(Name.class));
   }
 
@@ -48,7 +49,7 @@ public class ClassToClassDescriptionConverterTest implements NestedClassesTest,
     assertThat(classDescription.getClassName()).isEqualTo(clazz.getSimpleName());
     assertThat(classDescription.getClassNameWithOuterClass()).isEqualTo(nestedClass.getClassNameWithOuterClass());
     assertThat(classDescription.getPackageName()).isEqualTo(clazz.getPackage().getName());
-    assertThat(classDescription.getGetters()).hasSize(1);
+    assertThat(classDescription.getGettersDescriptions()).hasSize(1);
     assertThat(classDescription.getImports()).isEmpty();
   }
 
@@ -59,10 +60,10 @@ public class ClassToClassDescriptionConverterTest implements NestedClassesTest,
     assertThat(classDescription.getClassName()).isEqualTo(clazz.getSimpleName());
     assertThat(classDescription.getClassNameWithOuterClass()).isEqualTo(clazz.getSimpleName());
     assertThat(classDescription.getPackageName()).isEqualTo(clazz.getPackage().getName());
-    assertThat(classDescription.getGetters()).hasSize(4);
+    assertThat(classDescription.getGettersDescriptions()).hasSize(4);
     assertThat(classDescription.getImports()).containsOnly(getter.getExceptions());
 
-    for (GetterDescription desc : classDescription.getGetters()) {
+    for (GetterDescription desc : classDescription.getGettersDescriptions()) {
       if (desc.getPropertyName().equals(getter.getPropertyName())) {
         assertThat(desc.getExceptions()).containsOnly(getter.getExceptions());
         break;
@@ -82,8 +83,8 @@ public class ClassToClassDescriptionConverterTest implements NestedClassesTest,
     }
     ClassDescription classDescription = converter.convertToClassDescription(Type.class);
     assertThat(classDescription.getClassName()).isEqualTo("Type");
-    assertThat(classDescription.getGetters()).hasSize(1);
-    GetterDescription getterDescription = classDescription.getGetters().iterator().next();
+    assertThat(classDescription.getGettersDescriptions()).hasSize(1);
+    GetterDescription getterDescription = classDescription.getGettersDescriptions().iterator().next();
     assertThat(getterDescription.isIterablePropertyType()).as("getterDescription must be iterable").isTrue();
     assertThat(getterDescription.getElementTypeName()).isEqualTo("int");
     assertThat(getterDescription.isArrayPropertyType()).as("getterDescription must be an array").isTrue();
@@ -94,8 +95,8 @@ public class ClassToClassDescriptionConverterTest implements NestedClassesTest,
     ClassDescription classDescription = converter.convertToClassDescription(TreeEnum.class);
     assertThat(classDescription.getClassName()).isEqualTo("TreeEnum");
     // should not contain getDeclaringClassGetter as we don't want to have hasDeclaringClass assertion
-    assertThat(classDescription.getGetters()).hasSize(1);
-    GetterDescription getterDescription = classDescription.getGetters().iterator().next();
+    assertThat(classDescription.getGettersDescriptions()).hasSize(1);
+    GetterDescription getterDescription = classDescription.getGettersDescriptions().iterator().next();
     assertThat(getterDescription.isIterablePropertyType()).as("getterDescription must be iterable").isTrue();
     assertThat(getterDescription.getElementTypeName()).isEqualTo("TreeEnum");
     assertThat(getterDescription.isArrayPropertyType()).as("getterDescription must be an array").isFalse();
@@ -117,8 +118,8 @@ public class ClassToClassDescriptionConverterTest implements NestedClassesTest,
 
     // Then
     assertThat(classDescription.getClassName()).isEqualTo("Type");
-    assertThat(classDescription.getGetters()).hasSize(1);
-    GetterDescription getterDescription = classDescription.getGetters().iterator().next();
+    assertThat(classDescription.getGettersDescriptions()).hasSize(1);
+    GetterDescription getterDescription = classDescription.getGettersDescriptions().iterator().next();
     assertThat(getterDescription.isIterablePropertyType()).as("getterDescription must be iterable").isTrue();
     assertThat(getterDescription.getElementTypeName()).isEqualTo("Player");
     assertThat(getterDescription.isArrayPropertyType()).as("getterDescription must be an array").isTrue();
@@ -130,8 +131,9 @@ public class ClassToClassDescriptionConverterTest implements NestedClassesTest,
     ClassDescription classDescription = converter.convertToClassDescription(FellowshipOfTheRing.class);
     assertThat(classDescription.getClassName()).isEqualTo("FellowshipOfTheRing");
     assertThat(classDescription.getClassNameWithOuterClass()).isEqualTo("FellowshipOfTheRing");
+    assertThat(classDescription.getClassNameWithOuterClassNotSeparatedByDots()).isEqualTo("FellowshipOfTheRing");
     assertThat(classDescription.getPackageName()).isEqualTo("org.assertj.assertions.generator.data.lotr");
-    assertThat(classDescription.getGetters()).hasSize(1);
+    assertThat(classDescription.getGettersDescriptions()).hasSize(1);
     assertThat(classDescription.getImports()).containsOnly(new TypeName(Map.class), new TypeName(List.class),
                                                            new TypeName(Race.class),
                                                            new TypeName(TolkienCharacter.class));
@@ -147,4 +149,16 @@ public class ClassToClassDescriptionConverterTest implements NestedClassesTest,
                                                      "org.assertj.assertions.generator.data.lotr.TolkienCharacter");
   }
 
+  @Test
+  public void should_build_class_description_for_class_with_public_fields() throws Exception {
+    ClassDescription classDescription = converter.convertToClassDescription(Team.class);
+    assertThat(classDescription.getClassName()).isEqualTo("Team");
+    assertThat(classDescription.getClassNameWithOuterClass()).isEqualTo("Team");
+    assertThat(classDescription.getClassNameWithOuterClassNotSeparatedByDots()).isEqualTo("Team");
+    assertThat(classDescription.getPackageName()).isEqualTo("org.assertj.assertions.generator.data");
+    assertThat(classDescription.getGettersDescriptions()).extracting("propertyName").containsExactly("division");
+    assertThat(classDescription.getFieldsDescriptions()).extracting("name").containsOnly("name", "oldNames", "westCoast", "rank", "players", "points");
+    assertThat(classDescription.getImports()).isEmpty();
+  }
+
 }
diff --git a/src/test/java/org/assertj/assertions/generator/util/ClassUtilTest.java b/src/test/java/org/assertj/assertions/generator/util/ClassUtilTest.java
index 5752125..655902d 100644
--- a/src/test/java/org/assertj/assertions/generator/util/ClassUtilTest.java
+++ b/src/test/java/org/assertj/assertions/generator/util/ClassUtilTest.java
@@ -43,6 +43,7 @@ public class ClassUtilTest implements NestedClassesTest {
     assertThat(classesInPackage).containsOnly(Player.class, ArtWork.class, Name.class, Movie.class,
                                               Movie.PublicCategory.class, Ring.class, Race.class,
                                               FellowshipOfTheRing.class, TolkienCharacter.class,
+                                              Team.class,
                                               TreeEnum.class,
                                               OuterClass.InnerPerson.IP_InnerPerson.class,
                                               OuterClass.InnerPerson.class,
@@ -173,16 +174,14 @@ public class ClassUtilTest implements NestedClassesTest {
   @Test
   public void getClass_on_parameterized_List_should_return_Integer_class() throws Exception {
     Method method = Generic.class.getMethod("getListOfInteger");
-    Class<?> clazz = ClassUtil.getClass(((ParameterizedType) method.getGenericReturnType()).getActualTypeArguments()
-                                          [0]);
+    Class<?> clazz = ClassUtil.getClass(((ParameterizedType) method.getGenericReturnType()).getActualTypeArguments()[0]);
     assertThat(clazz).isEqualTo(Integer.class);
   }
 
   @Test
   public void getClass_on_wildcard_List_should_return_Integer_class() throws Exception {
     Method method = Generic.class.getMethod("getListOfWildcardInteger");
-    Class<?> clazz = ClassUtil.getClass(((ParameterizedType) method.getGenericReturnType()).getActualTypeArguments()
-                                          [0]);
+    Class<?> clazz = ClassUtil.getClass(((ParameterizedType) method.getGenericReturnType()).getActualTypeArguments()[0]);
     assertThat(clazz).isEqualTo(Integer.class);
   }
 
@@ -195,14 +194,14 @@ public class ClassUtilTest implements NestedClassesTest {
 
   @Test
   public void getClassRelatedTo_on_non_generic_type_should_return_given_type() throws Exception {
-    Set<Class<?>> classes = ClassUtil.getClassesRelatedTo(String.class.getMethod("toString").getReturnType());
+    Set<Class<?>> classes = getClassesRelatedTo(String.class.getMethod("toString").getReturnType());
     assertThat(classes).containsOnly(String.class);
   }
 
   @Test
   public void getClassRelatedTo_on_generic_list_should_return_list_and_component_type() throws Exception {
     Method method = Generic.class.getMethod("getListOfInteger");
-    Set<Class<?>> classes = ClassUtil.getClassesRelatedTo(method.getGenericReturnType());
+    Set<Class<?>> classes = getClassesRelatedTo(method.getGenericReturnType());
     assertThat(classes).containsOnly(Integer.class, List.class);
   }
 
diff --git a/src/test/resources/TeamAssert.expected.txt b/src/test/resources/TeamAssert.expected.txt
new file mode 100644
index 0000000..53a6d76
--- /dev/null
+++ b/src/test/resources/TeamAssert.expected.txt
@@ -0,0 +1,276 @@
+package org.assertj.assertions.generator.data;
+
+import org.assertj.core.api.AbstractAssert;
+import org.assertj.core.api.Assertions;
+
+
+/**
+ * {@link Team} specific assertions - Generated by CustomAssertionGenerator.
+ */
+public class TeamAssert extends AbstractAssert<TeamAssert, Team> {
+
+  /**
+   * Creates a new <code>{@link TeamAssert}</code> to make assertions on actual Team.
+   * @param actual the Team we want to make assertions on.
+   */
+  public TeamAssert(Team actual) {
+    super(actual, TeamAssert.class);
+  }
+
+  /**
+   * An entry point for TeamAssert to follow AssertJ standard <code>assertThat()</code> statements.<br>
+   * With a static import, one can write directly: <code>assertThat(myTeam)</code> and get specific assertion with code completion.
+   * @param actual the Team we want to make assertions on.
+   * @return a new <code>{@link TeamAssert}</code>
+   */
+  public static TeamAssert assertThat(Team actual) {
+    return new TeamAssert(actual);
+  }
+
+  /**
+   * Verifies that the actual Team's division is equal to the given one.
+   * @param division the given division to compare the actual Team's division to.
+   * @return this assertion object.
+   * @throws AssertionError - if the actual Team's division is not equal to the given one.
+   */
+  public TeamAssert hasDivision(String division) {
+    // check that actual Team we want to make assertions on is not null.
+    isNotNull();
+
+    // overrides the default error message with a more explicit one
+    String assertjErrorMessage = "\nExpected division of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";
+    
+    // null safe check
+    String actualDivision = actual.getDivision();
+    if (!org.assertj.core.util.Objects.areEqual(actualDivision, division)) {
+      failWithMessage(assertjErrorMessage, actual, division, actualDivision);
+    }
+
+    // return the current assertion for method chaining
+    return this;
+  }
+
+  /**
+   * Verifies that the actual Team's name is equal to the given one.
+   * @param name the given name to compare the actual Team's name to.
+   * @return this assertion object.
+   * @throws AssertionError - if the actual Team's name is not equal to the given one.
+   */
+  public TeamAssert hasName(String name) {
+    // check that actual Team we want to make assertions on is not null.
+    isNotNull();
+
+    // overrides the default error message with a more explicit one
+    String assertjErrorMessage = "\nExpected name of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";
+    
+    // null safe check
+    String actualName = actual.name;
+    if (!org.assertj.core.util.Objects.areEqual(actualName, name)) {
+      failWithMessage(assertjErrorMessage, actual, name, actualName);
+    }
+
+    // return the current assertion for method chaining
+    return this;
+  }
+
+  /**
+   * Verifies that the actual Team's oldNames contains the given String elements.
+   * @param oldNames the given elements that should be contained in actual Team's oldNames.
+   * @return this assertion object.
+   * @throws AssertionError if the actual Team's oldNames does not contain all given String elements.
+   */
+  public TeamAssert hasOldNames(String... oldNames) {
+    // check that actual Team we want to make assertions on is not null.
+    isNotNull();
+
+    // check that given String varargs is not null.
+    if (oldNames == null) throw new AssertionError("Expecting oldNames parameter not to be null.");
+    
+    // check with standard error message (see commented below to set your own message).
+    Assertions.assertThat(actual.oldNames).contains(oldNames);
+
+    // To override the standard error message :
+    // - remove the previous call to Assertions.assertThat(actual.oldNames.contains(oldNames)
+    // - uncomment the line below and set your error message:
+    // Assertions.assertThat(actual.oldNames).overridingErrorMessage("\nmy error message %s", "arg1").contains(oldNames);
+    
+    // return the current assertion for method chaining
+    return this;
+  }
+
+  /**
+   * Verifies that the actual Team has no oldNames.
+   * @return this assertion object.
+   * @throws AssertionError if the actual Team's oldNames is not empty.
+   */
+  public TeamAssert hasNoOldNames() {
+    // check that actual Team we want to make assertions on is not null.
+    isNotNull();
+
+    // we override the default error message with a more explicit one
+    String assertjErrorMessage = "\nExpected :\n  <%s>\nnot to have oldNames but had :\n  <%s>";
+    
+    // check
+    if (actual.oldNames.length > 0)  {
+      failWithMessage(assertjErrorMessage, actual, java.util.Arrays.toString(actual.oldNames));
+    }
+    
+    // return the current assertion for method chaining
+    return this;
+  }
+  
+
+  /**
+   * Verifies that the actual Team's players contains the given Player elements.
+   * @param players the given elements that should be contained in actual Team's players.
+   * @return this assertion object.
+   * @throws AssertionError if the actual Team's players does not contain all given Player elements.
+   */
+  public TeamAssert hasPlayers(Player... players) {
+    // check that actual Team we want to make assertions on is not null.
+    isNotNull();
+
+    // check that given Player varargs is not null.
+    if (players == null) throw new AssertionError("Expecting players parameter not to be null.");
+    
+    // check with standard error message (see commented below to set your own message).
+    Assertions.assertThat(actual.players).contains(players);
+
+    // To override the standard error message :
+    // - remove the previous call to Assertions.assertThat(actual.players.contains(players)
+    // - uncomment the line below and set your error message:
+    // Assertions.assertThat(actual.players).overridingErrorMessage("\nmy error message %s", "arg1").contains(players);
+
+    // return the current assertion for method chaining
+    return this;
+  }
+
+  /**
+   * Verifies that the actual Team has no players.
+   * @return this assertion object.
+   * @throws AssertionError if the actual Team's players is not empty.
+   */
+  public TeamAssert hasNoPlayers() {
+    // check that actual Team we want to make assertions on is not null.
+    isNotNull();
+
+    // we override the default error message with a more explicit one
+    String assertjErrorMessage = "\nExpected :\n  <%s>\nnot to have players but had :\n  <%s>";
+    
+    // check
+    if (!actual.players.isEmpty()) {
+      failWithMessage(assertjErrorMessage, actual, actual.players);
+    }
+    
+    // return the current assertion for method chaining
+    return this;
+  }
+  
+
+  /**
+   * Verifies that the actual Team's points contains the given int[] elements.
+   * @param points the given elements that should be contained in actual Team's points.
+   * @return this assertion object.
+   * @throws AssertionError if the actual Team's points does not contain all given int[] elements.
+   */
+  public TeamAssert hasPoints(int[]... points) {
+    // check that actual Team we want to make assertions on is not null.
+    isNotNull();
+
+    // check that given int[] varargs is not null.
+    if (points == null) throw new AssertionError("Expecting points parameter not to be null.");
+    
+    // check with standard error message (see commented below to set your own message).
+    Assertions.assertThat(actual.points).contains(points);
+
+    // To override the standard error message :
+    // - remove the previous call to Assertions.assertThat(actual.points.contains(points)
+    // - uncomment the line below and set your error message:
+    // Assertions.assertThat(actual.points).overridingErrorMessage("\nmy error message %s", "arg1").contains(points);
+
+    // return the current assertion for method chaining
+    return this;
+  }
+
+  /**
+   * Verifies that the actual Team has no points.
+   * @return this assertion object.
+   * @throws AssertionError if the actual Team's points is not empty.
+   */
+  public TeamAssert hasNoPoints() {
+    // check that actual Team we want to make assertions on is not null.
+    isNotNull();
+
+    // we override the default error message with a more explicit one
+    String assertjErrorMessage = "\nExpected :\n  <%s>\nnot to have points but had :\n  <%s>";
+    
+    // check
+    if (!actual.points.isEmpty()) {
+      failWithMessage(assertjErrorMessage, actual, actual.points);
+    }
+    
+    // return the current assertion for method chaining
+    return this;
+  }
+  
+
+  /**
+   * Verifies that the actual Team's rank is equal to the given one.
+   * @param rank the given rank to compare the actual Team's rank to.
+   * @return this assertion object.
+   * @throws AssertionError - if the actual Team's rank is not equal to the given one.
+   */
+  public TeamAssert hasRank(int rank) {
+    // check that actual Team we want to make assertions on is not null.
+    isNotNull();
+
+    // overrides the default error message with a more explicit one
+    String assertjErrorMessage = "\nExpected rank of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";
+    
+    // check
+    int actualRank = actual.rank;
+    if (actualRank != rank) {
+      failWithMessage(assertjErrorMessage, actual, rank, actualRank);
+    }
+
+    // return the current assertion for method chaining
+    return this;
+  }
+
+  /**
+   * Verifies that the actual Team is westCoast.
+   * @return this assertion object.
+   * @throws AssertionError - if the actual Team is not westCoast.
+   */
+  public TeamAssert westCoast {
+    // check that actual Team we want to make assertions on is not null.
+    isNotNull();
+
+    // check
+    if (!actual.westCoast) {
+      failWithMessage("\nExpected actual Team to be westCoast but was not.");
+    }
+    
+    // return the current assertion for method chaining
+    return this;
+  }
+
+  /**
+   * Verifies that the actual Team is not westCoast.
+   * @return this assertion object.
+   * @throws AssertionError - if the actual Team is westCoast.
+   */
+  public TeamAssert isNotWestCoast() {
+    // check that actual Team we want to make assertions on is not null.
+    isNotNull();
+
+    // check
+    if (actual.westCoast) {
+      failWithMessage("\nExpected actual Team not to be westCoast but was.");
+    }
+    
+    // return the current assertion for method chaining
+    return this;
+  }
+
+}
