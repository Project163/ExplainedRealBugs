diff --git a/src/main/java/org/assertj/assertions/generator/description/converter/ClassToClassDescriptionConverter.java b/src/main/java/org/assertj/assertions/generator/description/converter/ClassToClassDescriptionConverter.java
index 0969ca8..cad7079 100644
--- a/src/main/java/org/assertj/assertions/generator/description/converter/ClassToClassDescriptionConverter.java
+++ b/src/main/java/org/assertj/assertions/generator/description/converter/ClassToClassDescriptionConverter.java
@@ -13,15 +13,15 @@
 package org.assertj.assertions.generator.description.converter;
 
 import static org.assertj.assertions.generator.description.TypeName.JAVA_LANG_PACKAGE;
+import static org.assertj.assertions.generator.util.ClassUtil.declaredGetterMethodsOf;
+import static org.assertj.assertions.generator.util.ClassUtil.declaredPublicFieldsOf;
 import static org.assertj.assertions.generator.util.ClassUtil.getClassesRelatedTo;
 import static org.assertj.assertions.generator.util.ClassUtil.getterMethodsAndNonStaticPublicFieldsOf;
 import static org.assertj.assertions.generator.util.ClassUtil.getterMethodsOf;
-import static org.assertj.assertions.generator.util.ClassUtil.declaredGetterMethodsOf;
+import static org.assertj.assertions.generator.util.ClassUtil.inheritsCollectionOrIsIterable;
 import static org.assertj.assertions.generator.util.ClassUtil.isArray;
-import static org.assertj.assertions.generator.util.ClassUtil.isIterable;
-import static org.assertj.assertions.generator.util.ClassUtil.propertyNameOf;
 import static org.assertj.assertions.generator.util.ClassUtil.nonStaticPublicFieldsOf;
-import static org.assertj.assertions.generator.util.ClassUtil.declaredPublicFieldsOf;
+import static org.assertj.assertions.generator.util.ClassUtil.propertyNameOf;
 
 import java.lang.reflect.Field;
 import java.lang.reflect.GenericArrayType;
@@ -47,199 +47,216 @@ import com.google.common.annotations.VisibleForTesting;
 public class ClassToClassDescriptionConverter implements ClassDescriptionConverter<Class<?>> {
 
   public ClassDescription convertToClassDescription(Class<?> clazz) {
-    ClassDescription classDescription = new ClassDescription(new TypeName(clazz));
-    classDescription.addGetterDescriptions(getterDescriptionsOf(clazz));
-    classDescription.addFieldDescriptions(fieldDescriptionsOf(clazz));
-    classDescription.addDeclaredGetterDescriptions(declaredGetterDescriptionsOf(clazz));
-    classDescription.addDeclaredFieldDescriptions(declaredFieldDescriptionsOf(clazz));
-    classDescription.addTypeToImport(getNeededImportsFor(clazz));
-    classDescription.setSuperType(clazz.getSuperclass());
-    return classDescription;
+	ClassDescription classDescription = new ClassDescription(new TypeName(clazz));
+	classDescription.addGetterDescriptions(getterDescriptionsOf(clazz));
+	classDescription.addFieldDescriptions(fieldDescriptionsOf(clazz));
+	classDescription.addDeclaredGetterDescriptions(declaredGetterDescriptionsOf(clazz));
+	classDescription.addDeclaredFieldDescriptions(declaredFieldDescriptionsOf(clazz));
+	classDescription.addTypeToImport(getNeededImportsFor(clazz));
+	classDescription.setSuperType(clazz.getSuperclass());
+	return classDescription;
   }
 
   @VisibleForTesting
   protected Set<GetterDescription> getterDescriptionsOf(Class<?> clazz) {
-    return doGetterDescriptionsOf(getterMethodsOf(clazz), clazz);
+	return doGetterDescriptionsOf(getterMethodsOf(clazz), clazz);
   }
-  
+
   @VisibleForTesting
   protected Set<GetterDescription> declaredGetterDescriptionsOf(Class<?> clazz) {
-    return doGetterDescriptionsOf(declaredGetterMethodsOf(clazz), clazz);
-  }
-
-  private Set<GetterDescription> doGetterDescriptionsOf(List<Method> getters, Class<?> clazz) {
-    Set<GetterDescription> getterDescriptions = new TreeSet<GetterDescription>();
-    for (Method getter : getters) {
-      // ignore getDeclaringClass if Enum
-      if (isGetDeclaringClassEnumGetter(getter, clazz)) continue;
-      final TypeDescription typeDescription = getTypeDescription(getter);
-      final List<TypeName> exceptionTypeNames = getExceptionTypeNames(getter);
-      String propertyName = propertyNameOf(getter);
-      getterDescriptions.add(new GetterDescription(propertyName, typeDescription, exceptionTypeNames));
-    }
-    return getterDescriptions;
-  }
-  
+	return doGetterDescriptionsOf(declaredGetterMethodsOf(clazz), clazz);
+  }
+
+  private Set<GetterDescription> doGetterDescriptionsOf(Set<Method> getters, Class<?> clazz) {
+	Set<GetterDescription> getterDescriptions = new TreeSet<GetterDescription>();
+	for (Method getter : getters) {
+	  // ignore getDeclaringClass if Enum
+	  if (isGetDeclaringClassEnumGetter(getter, clazz)) continue;
+	  final TypeDescription typeDescription = getTypeDescription(getter);
+	  final List<TypeName> exceptionTypeNames = getExceptionTypeNames(getter);
+	  String propertyName = propertyNameOf(getter);
+	  getterDescriptions.add(new GetterDescription(propertyName, typeDescription, exceptionTypeNames));
+	}
+	return getterDescriptions;
+  }
+
   @VisibleForTesting
   protected Set<FieldDescription> declaredFieldDescriptionsOf(Class<?> clazz) {
-    return doFieldDescriptionsOf(declaredPublicFieldsOf(clazz));
+	return doFieldDescriptionsOf(declaredPublicFieldsOf(clazz));
   }
 
   @VisibleForTesting
   protected Set<FieldDescription> fieldDescriptionsOf(Class<?> clazz) {
-    return doFieldDescriptionsOf(nonStaticPublicFieldsOf(clazz));
+	return doFieldDescriptionsOf(nonStaticPublicFieldsOf(clazz));
   }
 
   private Set<FieldDescription> doFieldDescriptionsOf(List<Field> fields) {
-    Set<FieldDescription> fieldDescriptions = new TreeSet<FieldDescription>();
-    for (Field field : fields) {
-      fieldDescriptions.add(new FieldDescription(field.getName(), getTypeDescription(field)));
-    }
-    return fieldDescriptions;
+	Set<FieldDescription> fieldDescriptions = new TreeSet<FieldDescription>();
+	for (Field field : fields) {
+	  fieldDescriptions.add(new FieldDescription(field.getName(), getTypeDescription(field)));
+	}
+	return fieldDescriptions;
   }
-  
+
   private boolean isGetDeclaringClassEnumGetter(final Method getter, final Class<?> clazz) {
-    return clazz.isEnum() && getter.getName().equals("getDeclaringClass");
+	return clazz.isEnum() && getter.getName().equals("getDeclaringClass");
   }
 
   private List<TypeName> getExceptionTypeNames(final Method getter) {
-    List<TypeName> exceptions = new ArrayList<TypeName>();
-    for (Class<?> exception : getter.getExceptionTypes()) {
-      exceptions.add(new TypeName(exception));
-    }
-    return exceptions;
+	List<TypeName> exceptions = new ArrayList<TypeName>();
+	for (Class<?> exception : getter.getExceptionTypes()) {
+	  exceptions.add(new TypeName(exception));
+	}
+	return exceptions;
   }
 
   private TypeDescription getTypeDescription(Member member) {
-    final Class<?> type = getTypeOf(member);
-    if (isArray(type)) return buildArrayTypeDescription(type);    
-
-    if (isIterable(type)) {
-      final TypeDescription typeDescription = new TypeDescription(new TypeName(type));
-      typeDescription.setIterable(true);
-      ParameterizedType parameterizedType = getParameterizedTypeOf(member);
-      if (parameterizedType.getActualTypeArguments()[0] instanceof GenericArrayType) {
-        GenericArrayType genericArrayType = (GenericArrayType) parameterizedType.getActualTypeArguments()[0];
-        typeDescription.setElementTypeName(new TypeName(genericArrayType.toString()));
-      } else {
-        // Due to http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=7151486, 
-        // java 7 is not able to detect GenericArrayType correctly => let's use a different way to detect array
-        Class<?> internalClass = ClassUtil.getClass(parameterizedType.getActualTypeArguments()[0]);
-        if (internalClass.isArray()) {
-          typeDescription.setElementTypeName(new TypeName(internalClass.getComponentType() + "[]"));
-        } else {
-          typeDescription.setElementTypeName(new TypeName(internalClass));
-        }
-      }
-      return typeDescription;
-    }
-    // "simple" type
-    return new TypeDescription(new TypeName(type));
-  }
-  
+	final Class<?> type = getTypeOf(member);
+	if (isArray(type)) return buildArrayTypeDescription(type);
+	// we are interested in collections and iterable but not subtype of Iterable that are not collection.
+	// e.g. java.file.nio.Path that implements Iterable but has no ParameterizedType (ex : Path.getParent() -> Path)
+	if (inheritsCollectionOrIsIterable(type)) return buildIterableTypeDescription(member, type);
+	// "simple" type
+	return new TypeDescription(new TypeName(type));
+  }
+
+  private TypeDescription buildIterableTypeDescription(Member member, final Class<?> type) {
+	final TypeDescription typeDescription = new TypeDescription(new TypeName(type));
+	typeDescription.setIterable(true);
+	if (methodReturnTypeHasNoParameterInfo(member)) {
+	  // not a ParameterizedType, i.e. no parameter information => use Object as element type.
+	  typeDescription.setElementTypeName(new TypeName(Object.class));
+	  return typeDescription;
+	}
+	ParameterizedType parameterizedType = getParameterizedTypeOf(member);
+	if (parameterizedType.getActualTypeArguments()[0] instanceof GenericArrayType) {
+	  GenericArrayType genericArrayType = (GenericArrayType) parameterizedType.getActualTypeArguments()[0];
+	  typeDescription.setElementTypeName(new TypeName(genericArrayType.toString()));
+	  return typeDescription;
+	}
+	// Due to http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=7151486,
+	// java 7 is not able to detect GenericArrayType correctly => let's use a different way to detect array
+	Class<?> internalClass = ClassUtil.getClass(parameterizedType.getActualTypeArguments()[0]);
+	if (internalClass.isArray()) {
+	  typeDescription.setElementTypeName(new TypeName(internalClass.getComponentType() + "[]"));
+	} else {
+	  typeDescription.setElementTypeName(new TypeName(internalClass));
+	}
+	return typeDescription;
+  }
+
+  private static boolean methodReturnTypeHasNoParameterInfo(Member member) {
+	// java loose generic info if getter is overriden :(
+	return member instanceof Method && ((Method) member).getGenericReturnType() instanceof Class;
+  }
+
   private static Class<?> getTypeOf(Member member) {
-    if (member instanceof Method) return ((Method)member).getReturnType();
-    if (member instanceof Field) return ((Field)member).getType();
-    throw new IllegalArgumentException("argument should be a Method or Field but was " + member.getClass());
+	if (member instanceof Method) return ((Method) member).getReturnType();
+	if (member instanceof Field) return ((Field) member).getType();
+	throw new IllegalArgumentException("argument should be a Method or Field but was " + member.getClass());
   }
 
   private static ParameterizedType getParameterizedTypeOf(Member member) {
-    if (member instanceof Method) return (ParameterizedType) ((Method)member).getGenericReturnType();
-    if (member instanceof Field) return (ParameterizedType) ((Field)member).getGenericType();
-    throw new IllegalArgumentException("argument should be a Method or Field but was " + member.getClass());
+	if (member instanceof Method) return (ParameterizedType) ((Method) member).getGenericReturnType();
+	if (member instanceof Field) return (ParameterizedType) ((Field) member).getGenericType();
+	throw new IllegalArgumentException("argument should be a Method or Field but was " + member.getClass());
   }
-  
+
   private static boolean hasParameterizedType(Member member) {
-    if (member instanceof Method) return ((Method)member).getGenericReturnType() instanceof ParameterizedType;
-    if (member instanceof Field) return ((Field)member).getGenericType() instanceof ParameterizedType ;
-    throw new IllegalArgumentException("argument should be a Method or Field but was " + member.getClass());
+	if (member instanceof Method) return ((Method) member).getGenericReturnType() instanceof ParameterizedType;
+	if (member instanceof Field) return ((Field) member).getGenericType() instanceof ParameterizedType;
+	throw new IllegalArgumentException("argument should be a Method or Field but was " + member.getClass());
   }
-  
+
   private static Class<?>[] getExceptionTypesOf(Member member) {
-    if (member instanceof Method) return ((Method)member).getExceptionTypes();
-    return new Class<?>[0];
+	if (member instanceof Method) return ((Method) member).getExceptionTypes();
+	return new Class<?>[0];
   }
-  
+
   private static TypeDescription buildArrayTypeDescription(final Class<?> arrayType) {
-    final TypeDescription typeDescription = new TypeDescription(new TypeName(arrayType));
-    typeDescription.setElementTypeName(new TypeName(arrayType.getComponentType()));
-    typeDescription.setArray(true);
-    return typeDescription;
+	final TypeDescription typeDescription = new TypeDescription(new TypeName(arrayType));
+	typeDescription.setElementTypeName(new TypeName(arrayType.getComponentType()));
+	typeDescription.setArray(true);
+	return typeDescription;
   }
-  
-  /**return the import needed for the assertion class corresponding to given class
+
+  /**
+   * return the import needed for the assertion class corresponding to given class
    * 
    * @param clazz
    * @return
    */
   private Set<TypeName> getNeededImportsFor(Class<?> clazz) {
-    // collect property types
-    Set<Class<?>> classesToImport = new HashSet<Class<?>>();
-    for (Member getter : getterMethodsAndNonStaticPublicFieldsOf(clazz)) {
-      Class<?> propertyType = getTypeOf(getter);
-      if (isArray(propertyType)) {
-        // we only need the component type, that is T in T[] array
-        classesToImport.add(propertyType.getComponentType());
-      } else if (isIterable(propertyType)) {
-        // we need the Iterable parameter type, that is T in Iterable<T>
-        // we don't need to import the Iterable since it does not appear directly in generated code, ex :
-        // assertThat(actual.getTeamMates()).contains(teamMates); // teamMates -> List
-        ParameterizedType parameterizedType = getParameterizedTypeOf(getter);
-        if (parameterizedType.getActualTypeArguments()[0] instanceof GenericArrayType) {
-          //
-          GenericArrayType genericArrayType = (GenericArrayType) parameterizedType.getActualTypeArguments()[0];
-          Class<?> parameterClass = ClassUtil.getClass(genericArrayType.getGenericComponentType());
-          classesToImport.add(parameterClass);
-        } else {
-          // Due to http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=7151486, try to change if java 7 and a real array
-          Class<?> internalClass = ClassUtil.getClass(parameterizedType.getActualTypeArguments()[0]);
-          if (internalClass.isArray()) {
-            classesToImport.add(internalClass.getComponentType());
-          } else {
-            classesToImport.add(internalClass);
-          }
-        }
-      } else if (hasParameterizedType(getter)) {
-        // return type is generic type, add it and all its parameters type.
-        classesToImport.addAll(getClassesRelatedTo(getParameterizedTypeOf(getter)));
-      } else {
-        // return type is not generic type, simply add it.
-        classesToImport.add(propertyType);
-      }
-      Collections.addAll(classesToImport, getExceptionTypesOf(getter));
-    }
-    // convert to TypeName, excluding primitive or types in java.lang that don't need to be imported.
-    Set<TypeName> typeNamesToImport = resolveTypesToImport(classesToImport);
-    // remove typenames belonging to the given class package, they don't need to be imported since assertion class will be in that package
-    return removeTypeNamesInPackage(typeNamesToImport, clazz.getPackage().getName());
+	// collect property types
+	Set<Class<?>> classesToImport = new HashSet<Class<?>>();
+	for (Member member : getterMethodsAndNonStaticPublicFieldsOf(clazz)) {
+	  Class<?> propertyType = getTypeOf(member);
+	  if (isArray(propertyType)) {
+		// we only need the component type, that is T in T[] array
+		classesToImport.add(propertyType.getComponentType());
+	  } else if (inheritsCollectionOrIsIterable(propertyType)) {
+		// no generic parameter info = nothing to import
+		if (methodReturnTypeHasNoParameterInfo(member)) continue; 
+		// we need the Iterable parameter type, that is T in Iterable<T>
+		// we don't need to import the Iterable since it does not appear directly in generated code, ex :
+		// assertThat(actual.getTeamMates()).contains(teamMates); // teamMates -> List
+		ParameterizedType parameterizedType = getParameterizedTypeOf(member);
+		if (parameterizedType.getActualTypeArguments()[0] instanceof GenericArrayType) {
+		  //
+		  GenericArrayType genericArrayType = (GenericArrayType) parameterizedType.getActualTypeArguments()[0];
+		  Class<?> parameterClass = ClassUtil.getClass(genericArrayType.getGenericComponentType());
+		  classesToImport.add(parameterClass);
+		} else {
+		  // Due to http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=7151486, try to change if java 7 and a real array
+		  Class<?> internalClass = ClassUtil.getClass(parameterizedType.getActualTypeArguments()[0]);
+		  if (internalClass.isArray()) {
+			classesToImport.add(internalClass.getComponentType());
+		  } else {
+			classesToImport.add(internalClass);
+		  }
+		}
+	  } else if (hasParameterizedType(member)) {
+		// return type is generic type, add it and all its parameters type.
+		classesToImport.addAll(getClassesRelatedTo(getParameterizedTypeOf(member)));
+	  } else {
+		// return type is not generic type, simply add it.
+		classesToImport.add(propertyType);
+	  }
+	  Collections.addAll(classesToImport, getExceptionTypesOf(member));
+	}
+	// convert to TypeName, excluding primitive or types in java.lang that don't need to be imported.
+	Set<TypeName> typeNamesToImport = resolveTypesToImport(classesToImport);
+	// remove typenames belonging to the given class package, they don't need to be imported since assertion class will
+	// be in that package
+	return removeTypeNamesInPackage(typeNamesToImport, clazz.getPackage().getName());
   }
 
   private Set<TypeName> removeTypeNamesInPackage(Set<TypeName> typeNamesToImport, String packageName) {
-    Set<TypeName> filteredTypeNames = new TreeSet<TypeName>();
-    for (TypeName typeName : typeNamesToImport) {
-      if (!typeName.getPackageName().equals(packageName)) filteredTypeNames.add(typeName);
-    }
-    return filteredTypeNames;
+	Set<TypeName> filteredTypeNames = new TreeSet<TypeName>();
+	for (TypeName typeName : typeNamesToImport) {
+	  if (!typeName.getPackageName().equals(packageName)) filteredTypeNames.add(typeName);
+	}
+	return filteredTypeNames;
   }
 
   private Set<TypeName> resolveTypesToImport(Set<Class<?>> classesToImport) {
-    Set<TypeName> typeToImports = new TreeSet<TypeName>();
-    for (Class<?> propertyType : classesToImport) {
-      TypeName typeName = resolveType(propertyType);
-      if (typeName != null) typeToImports.add(typeName);
-    }
-    return typeToImports;
+	Set<TypeName> typeToImports = new TreeSet<TypeName>();
+	for (Class<?> propertyType : classesToImport) {
+	  TypeName typeName = resolveType(propertyType);
+	  if (typeName != null) typeToImports.add(typeName);
+	}
+	return typeToImports;
   }
 
   private TypeName resolveType(Class<?> propertyType) {
-    // recursive call for array of arrays
-    if (propertyType.isArray()) return resolveType(propertyType.getComponentType());
-    return shouldBeImported(propertyType) ? new TypeName(propertyType) : null;
+	// recursive call for array of arrays
+	if (propertyType.isArray()) return resolveType(propertyType.getComponentType());
+	return shouldBeImported(propertyType) ? new TypeName(propertyType) : null;
   }
 
   private boolean shouldBeImported(Class<?> type) {
-    // Package can be null in case of array of primitive.
-    return !(type.isPrimitive() || type.getPackage() == null || JAVA_LANG_PACKAGE.equals(type.getPackage().getName()));
+	// Package can be null in case of array of primitive.
+	return !(type.isPrimitive() || type.getPackage() == null || JAVA_LANG_PACKAGE.equals(type.getPackage().getName()));
   }
 
 }
diff --git a/src/main/java/org/assertj/assertions/generator/util/ClassUtil.java b/src/main/java/org/assertj/assertions/generator/util/ClassUtil.java
index 54931df..a4c65b6 100644
--- a/src/main/java/org/assertj/assertions/generator/util/ClassUtil.java
+++ b/src/main/java/org/assertj/assertions/generator/util/ClassUtil.java
@@ -34,10 +34,13 @@ import java.lang.reflect.WildcardType;
 import java.net.URL;
 import java.net.URLDecoder;
 import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Comparator;
 import java.util.Enumeration;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
+import java.util.TreeSet;
 
 import org.apache.commons.lang3.ClassUtils;
 import org.apache.commons.lang3.StringUtils;
@@ -56,6 +59,12 @@ public class ClassUtil {
   public static final String IS_PREFIX = "is";
   public static final String GET_PREFIX = "get";
   private static final String CLASS_SUFFIX = ".class";
+  private static final Comparator<Method> GETTER_COMPARATOR = new Comparator<Method>() {
+	@Override
+    public int compare(Method m1, Method m2) {
+	  return m1.getName().compareTo(m2.getName());
+    }
+  };
 
   /**
    * Call {@link #collectClasses(ClassLoader, String...)} with <code>Thread.currentThread().getContextClassLoader()
@@ -241,8 +250,8 @@ public class ClassUtil {
     return uncapitalize(propertyWithCapitalLetter);
   }
 
-  public static boolean isIterable(Class<?> returnType) {
-    return Iterable.class.isAssignableFrom(returnType);
+  public static boolean inheritsCollectionOrIsIterable(Class<?> returnType) {
+    return Collection.class.isAssignableFrom(returnType) || Iterable.class.equals(returnType);
   }
 
   public static boolean isArray(Class<?> returnType) {
@@ -277,25 +286,31 @@ public class ClassUtil {
            && name.startsWith(IS_PREFIX);
   }
 
-  public static List<Method> declaredGetterMethodsOf(Class<?> clazz) {
+  public static Set<Method> declaredGetterMethodsOf(Class<?> clazz) {
     return filterGetterMethods(clazz.getDeclaredMethods());
   }
 
-  public static List<Method> getterMethodsOf(Class<?> clazz) {
+  public static Set<Method> getterMethodsOf(Class<?> clazz) {
     return filterGetterMethods(clazz.getMethods());
   }
 
-  private static List<Method> filterGetterMethods(Method[] methods) {
-    List<Method> getters = new ArrayList<Method>(methods.length);
+  private static Set<Method> filterGetterMethods(Method[] methods) {
+    Set<Method> getters = new TreeSet<Method>(GETTER_COMPARATOR);
     for (int i = 0; i < methods.length; i++) {
       Method method = methods[i];
-      if (isPublic(method.getModifiers()) && isNotDefinedInObjectClass(method) && (isStandardGetter(method) || isBooleanGetter(method))) {
+      if (isPublic(method.getModifiers()) 
+    	  && isNotDefinedInObjectClass(method) 
+    	  && isGetter(method)) {
         getters.add(method);
       }
     }
     return getters;
   }
 
+  private static boolean isGetter(Method method) {
+	return isStandardGetter(method) || isBooleanGetter(method);
+  }
+
   public static List<Field> nonStaticPublicFieldsOf(Class<?> clazz) {
     Field[] fields = clazz.getFields();
     List<Field> nonStaticPublicFields = new ArrayList<Field>();
diff --git a/src/test/java/org/assertj/assertions/generator/description/converter/ClassToClassDescriptionConverterTest.java b/src/test/java/org/assertj/assertions/generator/description/converter/ClassToClassDescriptionConverterTest.java
index d923e8b..04fd598 100644
--- a/src/test/java/org/assertj/assertions/generator/description/converter/ClassToClassDescriptionConverterTest.java
+++ b/src/test/java/org/assertj/assertions/generator/description/converter/ClassToClassDescriptionConverterTest.java
@@ -14,6 +14,8 @@ package org.assertj.assertions.generator.description.converter;
 
 import static org.assertj.core.api.Assertions.assertThat;
 
+import java.nio.file.Path;
+import java.util.ArrayList;
 import java.util.Date;
 import java.util.List;
 import java.util.Map;
@@ -43,187 +45,211 @@ public class ClassToClassDescriptionConverterTest implements NestedClassesTest,
 
   @BeforeClass
   public static void beforeAllTests() {
-    converter = new ClassToClassDescriptionConverter();
+	converter = new ClassToClassDescriptionConverter();
   }
 
   @Test
   public void should_build_player_class_description() throws Exception {
-    ClassDescription classDescription = converter.convertToClassDescription(Player.class);
-    assertThat(classDescription.getClassName()).isEqualTo("Player");
-    assertThat(classDescription.getClassNameWithOuterClass()).isEqualTo("Player");
-    assertThat(classDescription.getPackageName()).isEqualTo("org.assertj.assertions.generator.data.nba");
-    assertThat(classDescription.getGettersDescriptions()).hasSize(10);
-    assertThat(classDescription.getImports()).containsOnly(new TypeName(Name.class));
+	ClassDescription classDescription = converter.convertToClassDescription(Player.class);
+	assertThat(classDescription.getClassName()).isEqualTo("Player");
+	assertThat(classDescription.getClassNameWithOuterClass()).isEqualTo("Player");
+	assertThat(classDescription.getPackageName()).isEqualTo("org.assertj.assertions.generator.data.nba");
+	assertThat(classDescription.getGettersDescriptions()).hasSize(10);
+	assertThat(classDescription.getImports()).containsOnly(new TypeName(Name.class));
   }
 
   @Test
   public void should_build_movie_class_description() throws Exception {
-    ClassDescription classDescription = converter.convertToClassDescription(Movie.class);
-    assertThat(classDescription.getClassName()).isEqualTo("Movie");
-    assertThat(classDescription.getClassNameWithOuterClass()).isEqualTo("Movie");
-    assertThat(classDescription.getPackageName()).isEqualTo("org.assertj.assertions.generator.data");
-    assertThat(classDescription.getGettersDescriptions()).hasSize(3);
-    assertThat(classDescription.getFieldsDescriptions()).hasSize(4);
-    assertThat(classDescription.getDeclaredGettersDescriptions()).hasSize(2);
-    assertThat(classDescription.getDeclaredFieldsDescriptions()).hasSize(3);
-    assertThat(classDescription.getSuperType()).isEqualTo(ArtWork.class);
-    assertThat(classDescription.getImports()).containsOnly(new TypeName(Date.class));
+	ClassDescription classDescription = converter.convertToClassDescription(Movie.class);
+	assertThat(classDescription.getClassName()).isEqualTo("Movie");
+	assertThat(classDescription.getClassNameWithOuterClass()).isEqualTo("Movie");
+	assertThat(classDescription.getPackageName()).isEqualTo("org.assertj.assertions.generator.data");
+	assertThat(classDescription.getGettersDescriptions()).hasSize(3);
+	assertThat(classDescription.getFieldsDescriptions()).hasSize(4);
+	assertThat(classDescription.getDeclaredGettersDescriptions()).hasSize(2);
+	assertThat(classDescription.getDeclaredFieldsDescriptions()).hasSize(3);
+	assertThat(classDescription.getSuperType()).isEqualTo(ArtWork.class);
+	assertThat(classDescription.getImports()).containsOnly(new TypeName(Date.class));
   }
 
   @Theory
   public void should_build_nestedclass_description(NestedClass nestedClass) throws Exception {
-    Class<?> clazz = nestedClass.getNestedClass();
-    ClassDescription classDescription = converter.convertToClassDescription(clazz);
-    assertThat(classDescription.getClassName()).isEqualTo(clazz.getSimpleName());
-    assertThat(classDescription.getClassNameWithOuterClass()).isEqualTo(nestedClass.getClassNameWithOuterClass());
-    assertThat(classDescription.getPackageName()).isEqualTo(clazz.getPackage().getName());
-    assertThat(classDescription.getGettersDescriptions()).hasSize(1);
-    assertThat(classDescription.getImports()).isEmpty();
+	Class<?> clazz = nestedClass.getNestedClass();
+	ClassDescription classDescription = converter.convertToClassDescription(clazz);
+	assertThat(classDescription.getClassName()).isEqualTo(clazz.getSimpleName());
+	assertThat(classDescription.getClassNameWithOuterClass()).isEqualTo(nestedClass.getClassNameWithOuterClass());
+	assertThat(classDescription.getPackageName()).isEqualTo(clazz.getPackage().getName());
+	assertThat(classDescription.getGettersDescriptions()).hasSize(1);
+	assertThat(classDescription.getImports()).isEmpty();
   }
 
   @Theory
   public void should_build_getter_with_exception_description(GetterWithException getter) throws Exception {
-    Class<?> clazz = getter.getBeanClass();
-    ClassDescription classDescription = converter.convertToClassDescription(clazz);
-    assertThat(classDescription.getClassName()).isEqualTo(clazz.getSimpleName());
-    assertThat(classDescription.getClassNameWithOuterClass()).isEqualTo(clazz.getSimpleName());
-    assertThat(classDescription.getPackageName()).isEqualTo(clazz.getPackage().getName());
-    assertThat(classDescription.getGettersDescriptions()).hasSize(4);
-    assertThat(classDescription.getImports()).containsOnly(getter.getExceptions());
-
-    for (GetterDescription desc : classDescription.getGettersDescriptions()) {
-      if (desc.getPropertyName().equals(getter.getPropertyName())) {
-        assertThat(desc.getExceptions()).containsOnly(getter.getExceptions());
-        break;
-      }
-    }
+	Class<?> clazz = getter.getBeanClass();
+	ClassDescription classDescription = converter.convertToClassDescription(clazz);
+	assertThat(classDescription.getClassName()).isEqualTo(clazz.getSimpleName());
+	assertThat(classDescription.getClassNameWithOuterClass()).isEqualTo(clazz.getSimpleName());
+	assertThat(classDescription.getPackageName()).isEqualTo(clazz.getPackage().getName());
+	assertThat(classDescription.getGettersDescriptions()).hasSize(4);
+	assertThat(classDescription.getImports()).containsOnly(getter.getExceptions());
+
+	for (GetterDescription desc : classDescription.getGettersDescriptions()) {
+	  if (desc.getPropertyName().equals(getter.getPropertyName())) {
+		assertThat(desc.getExceptions()).containsOnly(getter.getExceptions());
+		break;
+	  }
+	}
   }
 
   @Test
   public void should_build_class_description_for_iterable_of_primitive_type_array() throws Exception {
-    class Type {
-      List<int[]> scores;
-
-      @SuppressWarnings("unused")
-      public List<int[]> getScores() {
-        return scores;
-      }
-    }
-    ClassDescription classDescription = converter.convertToClassDescription(Type.class);
-    assertThat(classDescription.getClassName()).isEqualTo("Type");
-    assertThat(classDescription.getGettersDescriptions()).hasSize(1);
-    GetterDescription getterDescription = classDescription.getGettersDescriptions().iterator().next();
-    assertThat(getterDescription.isIterableType()).as("getterDescription must be iterable").isTrue();
-    assertThat(getterDescription.getElementTypeName()).isEqualTo("int[]");
-    assertThat(getterDescription.isArrayType()).as("getterDescription must not be an array").isFalse();
+	class Type {
+	  List<int[]> scores;
+
+	  @SuppressWarnings("unused")
+	  public List<int[]> getScores() {
+		return scores;
+	  }
+	}
+	ClassDescription classDescription = converter.convertToClassDescription(Type.class);
+	assertThat(classDescription.getClassName()).isEqualTo("Type");
+	assertThat(classDescription.getGettersDescriptions()).hasSize(1);
+	GetterDescription getterDescription = classDescription.getGettersDescriptions().iterator().next();
+	assertThat(getterDescription.isIterableType()).as("getterDescription must be iterable").isTrue();
+	assertThat(getterDescription.getElementTypeName()).isEqualTo("int[]");
+	assertThat(getterDescription.isArrayType()).as("getterDescription must not be an array").isFalse();
   }
 
   @Test
   public void should_build_class_description_for_array_of_primitive_type_array() throws Exception {
-    class Type {
-      int[][] scores;
-      
-      @SuppressWarnings("unused")
-      public int[][] getScores() {
-        return scores;
-      }
-    }
-    ClassDescription classDescription = converter.convertToClassDescription(Type.class);
-    assertThat(classDescription.getClassName()).isEqualTo("Type");
-    assertThat(classDescription.getGettersDescriptions()).hasSize(1);
-    GetterDescription getterDescription = classDescription.getGettersDescriptions().iterator().next();
-    assertThat(getterDescription.isIterableType()).as("getterDescription is an iterable ?").isFalse();
-    assertThat(getterDescription.isArrayType()).as("getterDescription is an array ?").isTrue();
-    assertThat(getterDescription.getElementTypeName()).isEqualTo("int[]");
+	class Type {
+	  int[][] scores;
+
+	  @SuppressWarnings("unused")
+	  public int[][] getScores() {
+		return scores;
+	  }
+	}
+	ClassDescription classDescription = converter.convertToClassDescription(Type.class);
+	assertThat(classDescription.getClassName()).isEqualTo("Type");
+	assertThat(classDescription.getGettersDescriptions()).hasSize(1);
+	GetterDescription getterDescription = classDescription.getGettersDescriptions().iterator().next();
+	assertThat(getterDescription.isIterableType()).as("getterDescription is an iterable ?").isFalse();
+	assertThat(getterDescription.isArrayType()).as("getterDescription is an array ?").isTrue();
+	assertThat(getterDescription.getElementTypeName()).isEqualTo("int[]");
   }
-  
+
   @Test
   public void should_build_class_description_for_enum_type() throws Exception {
-    ClassDescription classDescription = converter.convertToClassDescription(TreeEnum.class);
-    assertThat(classDescription.getClassName()).isEqualTo("TreeEnum");
-    // should not contain getDeclaringClassGetter as we don't want to have hasDeclaringClass assertion
-    assertThat(classDescription.getGettersDescriptions()).hasSize(1);
-    GetterDescription getterDescription = classDescription.getGettersDescriptions().iterator().next();
-    assertThat(getterDescription.isIterableType()).as("getterDescription must be iterable").isTrue();
-    assertThat(getterDescription.getElementTypeName()).isEqualTo("TreeEnum");
-    assertThat(getterDescription.isArrayType()).as("getterDescription must be an array").isFalse();
+	ClassDescription classDescription = converter.convertToClassDescription(TreeEnum.class);
+	assertThat(classDescription.getClassName()).isEqualTo("TreeEnum");
+	// should not contain getDeclaringClassGetter as we don't want to have hasDeclaringClass assertion
+	assertThat(classDescription.getGettersDescriptions()).hasSize(1);
+	GetterDescription getterDescription = classDescription.getGettersDescriptions().iterator().next();
+	assertThat(getterDescription.isIterableType()).as("getterDescription must be iterable").isTrue();
+	assertThat(getterDescription.getElementTypeName()).isEqualTo("TreeEnum");
+	assertThat(getterDescription.isArrayType()).as("getterDescription must be an array").isFalse();
   }
 
   @Test
   public void should_build_class_description_for_iterable_of_Object_type() throws Exception {
-    // Given
-    class Type {
-      List<Player[]> players;
-      @SuppressWarnings("unused")
-      public List<Player[]> getPlayers() {
-        return players;
-      }
-    }
-
-    // When
-    ClassDescription classDescription = converter.convertToClassDescription(Type.class);
-
-    // Then
-    assertThat(classDescription.getClassName()).isEqualTo("Type");
-    assertThat(classDescription.getGettersDescriptions()).hasSize(1);
-    GetterDescription getterDescription = classDescription.getGettersDescriptions().iterator().next();
-    assertThat(getterDescription.isIterableType()).as("getterDescription must be iterable").isTrue();
-    assertThat(getterDescription.getElementTypeName()).isEqualTo("Player[]");
-    assertThat(getterDescription.isArrayType()).as("getterDescription is not an array").isFalse();
-    assertThat(classDescription.getImports()).extracting("simpleName").contains(Player.class.getSimpleName());
+	// Given
+	class Type {
+	  List<Player[]> players;
+
+	  @SuppressWarnings("unused")
+	  public List<Player[]> getPlayers() {
+		return players;
+	  }
+	}
+
+	// When
+	ClassDescription classDescription = converter.convertToClassDescription(Type.class);
+
+	// Then
+	assertThat(classDescription.getClassName()).isEqualTo("Type");
+	assertThat(classDescription.getGettersDescriptions()).hasSize(1);
+	GetterDescription getterDescription = classDescription.getGettersDescriptions().iterator().next();
+	assertThat(getterDescription.isIterableType()).as("getterDescription must be iterable").isTrue();
+	assertThat(getterDescription.getElementTypeName()).isEqualTo("Player[]");
+	assertThat(getterDescription.isArrayType()).as("getterDescription is not an array").isFalse();
+	assertThat(classDescription.getImports()).extracting("simpleName").contains(Player.class.getSimpleName());
   }
 
   @Test
   public void should_build_class_description_for_interface() throws Exception {
-    // Given an interface     
-    // When
-    ClassDescription classDescription = converter.convertToClassDescription(PlayerAgent.class);
-    
-    // Then
-    assertThat(classDescription.getClassName()).isEqualTo("PlayerAgent");
-    assertThat(classDescription.getSuperType()).isNull();
-    assertThat(classDescription.getGettersDescriptions()).hasSize(1);
-    GetterDescription getterDescription = classDescription.getGettersDescriptions().iterator().next();
-    assertThat(getterDescription.isIterableType()).as("getterDescription is not iterable").isFalse();
-    assertThat(getterDescription.getPropertyName()).isEqualTo("managedPlayer");
-    assertThat(getterDescription.getTypeName()).isEqualTo("Player");
-    assertThat(classDescription.getImports()).isEmpty();
+	// Given an interface
+	// When
+	ClassDescription classDescription = converter.convertToClassDescription(PlayerAgent.class);
+
+	// Then
+	assertThat(classDescription.getClassName()).isEqualTo("PlayerAgent");
+	assertThat(classDescription.getSuperType()).isNull();
+	assertThat(classDescription.getGettersDescriptions()).hasSize(1);
+	GetterDescription getterDescription = classDescription.getGettersDescriptions().iterator().next();
+	assertThat(getterDescription.isIterableType()).as("getterDescription is not iterable").isFalse();
+	assertThat(getterDescription.getPropertyName()).isEqualTo("managedPlayer");
+	assertThat(getterDescription.getTypeName()).isEqualTo("Player");
+	assertThat(classDescription.getImports()).isEmpty();
   }
-  
+
   @Test
   public void should_build_fellowshipOfTheRing_class_description() throws Exception {
-    ClassDescription classDescription = converter.convertToClassDescription(FellowshipOfTheRing.class);
-    assertThat(classDescription.getClassName()).isEqualTo("FellowshipOfTheRing");
-    assertThat(classDescription.getClassNameWithOuterClass()).isEqualTo("FellowshipOfTheRing");
-    assertThat(classDescription.getClassNameWithOuterClassNotSeparatedByDots()).isEqualTo("FellowshipOfTheRing");
-    assertThat(classDescription.getPackageName()).isEqualTo("org.assertj.assertions.generator.data.lotr");
-    assertThat(classDescription.getGettersDescriptions()).hasSize(1);
-    assertThat(classDescription.getImports()).containsOnly(new TypeName(Map.class), new TypeName(List.class));
+	ClassDescription classDescription = converter.convertToClassDescription(FellowshipOfTheRing.class);
+	assertThat(classDescription.getClassName()).isEqualTo("FellowshipOfTheRing");
+	assertThat(classDescription.getClassNameWithOuterClass()).isEqualTo("FellowshipOfTheRing");
+	assertThat(classDescription.getClassNameWithOuterClassNotSeparatedByDots()).isEqualTo("FellowshipOfTheRing");
+	assertThat(classDescription.getPackageName()).isEqualTo("org.assertj.assertions.generator.data.lotr");
+	assertThat(classDescription.getGettersDescriptions()).hasSize(1);
+	assertThat(classDescription.getImports()).containsOnly(new TypeName(Map.class), new TypeName(List.class));
   }
 
   @Test
   public void should_handle_toString() {
-    ClassDescription classDescription = converter.convertToClassDescription(FellowshipOfTheRing.class);
-    assertThat(classDescription.toString()).contains(FellowshipOfTheRing.class.getSimpleName(), "java.util.Map", "java.util.List");
+	ClassDescription classDescription = converter.convertToClassDescription(FellowshipOfTheRing.class);
+	assertThat(classDescription.toString()).contains(FellowshipOfTheRing.class.getSimpleName(), "java.util.Map",
+	                                                 "java.util.List");
   }
 
   @Test
   public void should_build_class_description_for_class_with_public_fields() throws Exception {
-    ClassDescription classDescription = converter.convertToClassDescription(Team.class);
-    assertThat(classDescription.getClassName()).isEqualTo("Team");
-    assertThat(classDescription.getClassNameWithOuterClass()).isEqualTo("Team");
-    assertThat(classDescription.getClassNameWithOuterClassNotSeparatedByDots()).isEqualTo("Team");
-    assertThat(classDescription.getPackageName()).isEqualTo("org.assertj.assertions.generator.data");
-    assertThat(classDescription.getGettersDescriptions()).extracting("propertyName").containsExactly("division");
-    assertThat(classDescription.getFieldsDescriptions()).extracting("name").containsOnly("name", 
-                                                                                         "oldNames", 
-                                                                                         "westCoast", 
-                                                                                         "rank", 
-                                                                                         "players", 
-                                                                                         "points", 
-                                                                                         "victoryRatio");
-    // no List.class as it won't be needed in TeamAssert
-    assertThat(classDescription.getImports()).containsOnly(new TypeName(Player.class));
+	ClassDescription classDescription = converter.convertToClassDescription(Team.class);
+	assertThat(classDescription.getClassName()).isEqualTo("Team");
+	assertThat(classDescription.getClassNameWithOuterClass()).isEqualTo("Team");
+	assertThat(classDescription.getClassNameWithOuterClassNotSeparatedByDots()).isEqualTo("Team");
+	assertThat(classDescription.getPackageName()).isEqualTo("org.assertj.assertions.generator.data");
+	assertThat(classDescription.getGettersDescriptions()).extracting("propertyName").containsExactly("division");
+	assertThat(classDescription.getFieldsDescriptions()).extracting("name").containsOnly("name",
+	                                                                                     "oldNames",
+	                                                                                     "westCoast",
+	                                                                                     "rank",
+	                                                                                     "players",
+	                                                                                     "points",
+	                                                                                     "victoryRatio");
+	// no List.class as it won't be needed in TeamAssert
+	assertThat(classDescription.getImports()).containsOnly(new TypeName(Player.class));
+  }
+
+  @Test
+  public void bug21_reflection_error_on_iterable_ParameterizedType() {
+	ClassDescription classDescription = converter.convertToClassDescription(Path.class);
+	assertThat(classDescription.getGettersDescriptions()).extracting("propertyName").contains("parent");
+  }
+
+  @Test
+  public void should_only_describe_overriden_getter_once() {
+	ClassDescription myClassDescription = converter.convertToClassDescription(ClassOverridingGetter.class);
+	assertThat(myClassDescription.getGettersDescriptions()).extracting("propertyName").containsOnlyOnce("myList");
+  }
+  
+  public interface InterfaceWithGetter {
+	public abstract List<String> getMyList();
+  }
+
+  class ClassOverridingGetter implements InterfaceWithGetter {
+	public ArrayList<String> getMyList() {
+	  return null;
+	}
   }
   
 }
diff --git a/src/test/java/org/assertj/assertions/generator/util/ClassUtilTest.java b/src/test/java/org/assertj/assertions/generator/util/ClassUtilTest.java
index 1ef8b89..b817adb 100644
--- a/src/test/java/org/assertj/assertions/generator/util/ClassUtilTest.java
+++ b/src/test/java/org/assertj/assertions/generator/util/ClassUtilTest.java
@@ -12,10 +12,36 @@
  */
 package org.assertj.assertions.generator.util;
 
+import static org.assertj.assertions.generator.util.ClassUtil.collectClasses;
+import static org.assertj.assertions.generator.util.ClassUtil.declaredGetterMethodsOf;
+import static org.assertj.assertions.generator.util.ClassUtil.getClassesRelatedTo;
+import static org.assertj.assertions.generator.util.ClassUtil.getSimpleNameWithOuterClass;
+import static org.assertj.assertions.generator.util.ClassUtil.getSimpleNameWithOuterClassNotSeparatedByDots;
+import static org.assertj.assertions.generator.util.ClassUtil.getterMethodsOf;
+import static org.assertj.assertions.generator.util.ClassUtil.inheritsCollectionOrIsIterable;
+import static org.assertj.assertions.generator.util.ClassUtil.isBooleanGetter;
+import static org.assertj.assertions.generator.util.ClassUtil.isStandardGetter;
+import static org.assertj.assertions.generator.util.ClassUtil.isValidGetterName;
+import static org.assertj.assertions.generator.util.ClassUtil.propertyNameOf;
+import static org.assertj.core.api.Assertions.assertThat;
+
+import java.lang.reflect.Method;
 import java.lang.reflect.ParameterizedType;
+import java.util.Collection;
+import java.util.List;
+import java.util.Set;
 
 import org.assertj.assertions.generator.NestedClassesTest;
-import org.assertj.assertions.generator.data.*;
+import org.assertj.assertions.generator.data.ArtWork;
+import org.assertj.assertions.generator.data.BeanWithOneException;
+import org.assertj.assertions.generator.data.BeanWithTwoExceptions;
+import org.assertj.assertions.generator.data.Dollar$;
+import org.assertj.assertions.generator.data.Movie;
+import org.assertj.assertions.generator.data.Name;
+import org.assertj.assertions.generator.data.OuterClass;
+import org.assertj.assertions.generator.data.OuterClass.StaticNestedPerson;
+import org.assertj.assertions.generator.data.Team;
+import org.assertj.assertions.generator.data.TreeEnum;
 import org.assertj.assertions.generator.data.lotr.FellowshipOfTheRing;
 import org.assertj.assertions.generator.data.lotr.Race;
 import org.assertj.assertions.generator.data.lotr.Ring;
@@ -27,15 +53,6 @@ import org.junit.experimental.theories.Theories;
 import org.junit.experimental.theories.Theory;
 import org.junit.runner.RunWith;
 
-import java.lang.reflect.Method;
-import java.util.Collection;
-import java.util.List;
-import java.util.Set;
-
-import static org.assertj.assertions.generator.data.OuterClass.StaticNestedPerson;
-import static org.assertj.assertions.generator.util.ClassUtil.*;
-import static org.assertj.core.api.Assertions.assertThat;
-
 @RunWith(Theories.class)
 public class ClassUtilTest implements NestedClassesTest {
 
@@ -92,10 +109,10 @@ public class ClassUtilTest implements NestedClassesTest {
 
   @Test
   public void should_return_true_if_class_implements_iterable_interface() {
-    assertThat(isIterable(Iterable.class)).isTrue();
-    assertThat(isIterable(Collection.class)).isTrue();
-    assertThat(isIterable(List.class)).isTrue();
-    assertThat(isIterable(String.class)).isFalse();
+    assertThat(inheritsCollectionOrIsIterable(Iterable.class)).isTrue();
+    assertThat(inheritsCollectionOrIsIterable(Collection.class)).isTrue();
+    assertThat(inheritsCollectionOrIsIterable(List.class)).isTrue();
+    assertThat(inheritsCollectionOrIsIterable(String.class)).isFalse();
   }
 
   @Test
@@ -145,21 +162,21 @@ public class ClassUtilTest implements NestedClassesTest {
 
   @Test
   public void should_return_getters_methods_only() throws Exception {
-    List<Method> playerGetterMethods = getterMethodsOf(Player.class);
+	Set<Method> playerGetterMethods = getterMethodsOf(Player.class);
     assertThat(playerGetterMethods).contains(Player.class.getMethod("getTeam", NO_PARAMS))
                                    .doesNotContain(Player.class.getMethod("isInTeam", String.class));
   }
 
   @Test
   public void should_also_return_inherited_getters_methods() throws Exception {
-    List<Method> playerGetterMethods = getterMethodsOf(Movie.class);
+    Set<Method> playerGetterMethods = getterMethodsOf(Movie.class);
     assertThat(playerGetterMethods).contains(Movie.class.getMethod("getReleaseDate", NO_PARAMS),
                                              ArtWork.class.getMethod("getTitle", NO_PARAMS));
   }
 
   @Test
   public void should_not_return_inherited_getters_methods() throws Exception {
-    List<Method> playerGetterMethods = declaredGetterMethodsOf(Movie.class);
+	Set<Method> playerGetterMethods = declaredGetterMethodsOf(Movie.class);
     assertThat(playerGetterMethods).contains(Movie.class.getMethod("getReleaseDate", NO_PARAMS))
                                    .doesNotContain(ArtWork.class.getMethod("getTitle", NO_PARAMS));
   }
