diff --git a/pom.xml b/pom.xml
index 3d27587..53d60b8 100644
--- a/pom.xml
+++ b/pom.xml
@@ -53,6 +53,21 @@
       <version>4.11</version><!--$NO-MVN-MAN-VER$-->
       <scope>test</scope>
     </dependency>
+
+    <dependency>
+      <groupId>commons-io</groupId>
+      <artifactId>commons-io</artifactId>
+      <version>2.5</version>
+      <scope>test</scope>
+    </dependency>
+
+    <!-- https://mvnrepository.com/artifact/com.google.testing.compile/compile-testing -->
+    <dependency>
+      <groupId>com.google.testing.compile</groupId>
+      <artifactId>compile-testing</artifactId>
+      <version>0.11</version>
+      <scope>test</scope>
+    </dependency>
   </dependencies>
 
   <build>
@@ -106,7 +121,7 @@
           </archive>
         </configuration>
       </plugin>
-      <!-- generate jacoco report -->
+       <!-- generate jacoco report -->
       <plugin>
         <groupId>org.jacoco</groupId>
         <artifactId>jacoco-maven-plugin</artifactId>
@@ -122,6 +137,9 @@
         <artifactId>maven-surefire-plugin</artifactId>
         <configuration>
           <argLine>${argLine}</argLine>
+          <!-- Needed because otherwise the classloader does not properly bring in the dependencies from
+               maven. Source: http://maven.apache.org/surefire/maven-surefire-plugin/examples/class-loading.html -->
+          <useSystemClassLoader>false</useSystemClassLoader>
         </configuration>
       </plugin>
     </plugins>
diff --git a/src/main/java/org/assertj/assertions/generator/BaseAssertionGenerator.java b/src/main/java/org/assertj/assertions/generator/BaseAssertionGenerator.java
index db0bd4e..2bf76d7 100644
--- a/src/main/java/org/assertj/assertions/generator/BaseAssertionGenerator.java
+++ b/src/main/java/org/assertj/assertions/generator/BaseAssertionGenerator.java
@@ -1,4 +1,4 @@
-/*
+/**
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
  * the License. You may obtain a copy of the License at
  *
@@ -24,6 +24,7 @@ import java.io.File;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.lang.reflect.Method;
+import java.nio.file.Paths;
 import java.util.*;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
@@ -71,7 +72,7 @@ public class BaseAssertionGenerator implements AssertionGenerator, AssertionsEnt
   private static final String LINE_SEPARATOR = "\n";
   // assertions classes are generated in their package directory starting from targetBaseDirectory.
   // ex : com.nba.Player -> targetBaseDirectory/com/nba/PlayerAssert.java
-  private String targetBaseDirectory = ".";
+  private File targetBaseDirectory = Paths.get(".").toFile();
   private TemplateRegistry templateRegistry;// the pattern to search for
 
   /**
@@ -113,7 +114,7 @@ public class BaseAssertionGenerator implements AssertionGenerator, AssertionsEnt
     templateRegistry = DefaultTemplateRegistryProducer.create(templatesDirectory);
   }
 
-  public void setDirectoryWhereAssertionFilesAreGenerated(String targetBaseDirectory) {
+  public void setDirectoryWhereAssertionFilesAreGenerated(File targetBaseDirectory) {
     this.targetBaseDirectory = targetBaseDirectory;
   }
 
@@ -483,7 +484,7 @@ public class BaseAssertionGenerator implements AssertionGenerator, AssertionsEnt
 
     // replace ${Property} and ${property} by field name (starting with uppercase/lowercase)
     if (field.isPredicate()) {
-      assertionContent = assertionContent.replace("actual." + PREDICATE + "()", "actual." + field.getName());
+      assertionContent = assertionContent.replace("actual." + PREDICATE + "()", "actual." + field.getOriginalMember().getName());
       assertionContent = assertionContent.replace(PREDICATE_FOR_JAVADOC,
                                                   field.getPredicateForJavadoc());
       assertionContent = assertionContent.replace(NEGATIVE_PREDICATE_FOR_JAVADOC,
diff --git a/src/main/java/org/assertj/assertions/generator/description/ClassDescription.java b/src/main/java/org/assertj/assertions/generator/description/ClassDescription.java
index 3404d2a..ec3b5be 100644
--- a/src/main/java/org/assertj/assertions/generator/description/ClassDescription.java
+++ b/src/main/java/org/assertj/assertions/generator/description/ClassDescription.java
@@ -1,4 +1,4 @@
-/*
+/**
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
  * the License. You may obtain a copy of the License at
  *
diff --git a/src/main/java/org/assertj/assertions/generator/description/DataDescription.java b/src/main/java/org/assertj/assertions/generator/description/DataDescription.java
index 999b5b8..80cfa08 100644
--- a/src/main/java/org/assertj/assertions/generator/description/DataDescription.java
+++ b/src/main/java/org/assertj/assertions/generator/description/DataDescription.java
@@ -1,4 +1,4 @@
-/*
+/**
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
  * the License. You may obtain a copy of the License at
  *
diff --git a/src/main/java/org/assertj/assertions/generator/description/FieldDescription.java b/src/main/java/org/assertj/assertions/generator/description/FieldDescription.java
index ab0aa93..bd09b8c 100644
--- a/src/main/java/org/assertj/assertions/generator/description/FieldDescription.java
+++ b/src/main/java/org/assertj/assertions/generator/description/FieldDescription.java
@@ -1,4 +1,4 @@
-/*
+/**
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
  * the License. You may obtain a copy of the License at
  *
diff --git a/src/main/java/org/assertj/assertions/generator/description/GetterDescription.java b/src/main/java/org/assertj/assertions/generator/description/GetterDescription.java
index 46b60b6..764d0be 100644
--- a/src/main/java/org/assertj/assertions/generator/description/GetterDescription.java
+++ b/src/main/java/org/assertj/assertions/generator/description/GetterDescription.java
@@ -1,4 +1,4 @@
-/*
+/**
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
  * the License. You may obtain a copy of the License at
  *
diff --git a/src/main/java/org/assertj/assertions/generator/util/ClassUtil.java b/src/main/java/org/assertj/assertions/generator/util/ClassUtil.java
index f601541..f1f4562 100644
--- a/src/main/java/org/assertj/assertions/generator/util/ClassUtil.java
+++ b/src/main/java/org/assertj/assertions/generator/util/ClassUtil.java
@@ -1,4 +1,4 @@
-/*
+/**
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
  * the License. You may obtain a copy of the License at
  *
diff --git a/src/test/java/org/assertj/assertions/generator/AssertionGeneratorOverrideTemplateTest.java b/src/test/java/org/assertj/assertions/generator/AssertionGeneratorOverrideTemplateTest.java
index a61318d..c19a4e7 100644
--- a/src/test/java/org/assertj/assertions/generator/AssertionGeneratorOverrideTemplateTest.java
+++ b/src/test/java/org/assertj/assertions/generator/AssertionGeneratorOverrideTemplateTest.java
@@ -12,24 +12,27 @@
  */
 package org.assertj.assertions.generator;
 
-import static org.assertj.assertions.generator.AssertionGeneratorTest.assertGeneratedAssertClass;
-
-import java.io.File;
-import java.io.IOException;
-
 import org.assertj.assertions.generator.data.cars.Car;
 import org.assertj.assertions.generator.description.converter.ClassToClassDescriptionConverter;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 
+import java.io.File;
+import java.io.IOException;
+import java.nio.file.Paths;
+
 public class AssertionGeneratorOverrideTemplateTest {
   private BaseAssertionGenerator assertionGenerator;
   private ClassToClassDescriptionConverter converter;
 
+  @Rule
+  public final GenerationPathHandler genHandle = new GenerationPathHandler(AssertionGeneratorOverrideTemplateTest.class,
+      Paths.get("src/test/resources"));
+
   @Before
   public void before() throws IOException {
-    assertionGenerator = new BaseAssertionGenerator();
-    assertionGenerator.setDirectoryWhereAssertionFilesAreGenerated("target");
+    assertionGenerator = genHandle.buildAssertionGenerator();
     converter = new ClassToClassDescriptionConverter();
   }
 
@@ -55,6 +58,6 @@ public class AssertionGeneratorOverrideTemplateTest {
                                                       "custom_has_assertion_template_for_whole_number.txt")));
 
     assertionGenerator.generateCustomAssertionFor(converter.convertToClassDescription(Car.class));
-    assertGeneratedAssertClass(Car.class, "CarAssert.expected.txt");
+    genHandle.assertGeneratedAssertClass(Car.class, "CarAssert.expected.txt", true);
   }
 }
diff --git a/src/test/java/org/assertj/assertions/generator/AssertionGeneratorTest.java b/src/test/java/org/assertj/assertions/generator/AssertionGeneratorTest.java
index 52c43a5..6555a42 100644
--- a/src/test/java/org/assertj/assertions/generator/AssertionGeneratorTest.java
+++ b/src/test/java/org/assertj/assertions/generator/AssertionGeneratorTest.java
@@ -20,6 +20,7 @@ import org.assertj.assertions.generator.description.ClassDescription;
 import org.assertj.assertions.generator.description.converter.AnnotationConfiguration;
 import org.assertj.assertions.generator.description.converter.ClassToClassDescriptionConverter;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 import org.junit.experimental.theories.Theories;
 import org.junit.experimental.theories.Theory;
@@ -29,18 +30,13 @@ import org.slf4j.LoggerFactory;
 
 import java.io.File;
 import java.io.IOException;
+import java.nio.file.Paths;
 import java.sql.SQLException;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-import java.util.Set;
+import java.util.*;
 
-import static com.google.common.collect.Sets.newHashSet;
 import static java.lang.reflect.Modifier.isPublic;
 import static java.nio.charset.Charset.defaultCharset;
 import static org.apache.commons.lang3.StringUtils.replace;
-import static org.assertj.assertions.generator.BaseAssertionGenerator.ABSTRACT_ASSERT_CLASS_PREFIX;
-import static org.assertj.assertions.generator.BaseAssertionGenerator.ASSERT_CLASS_FILE_SUFFIX;
 import static org.assertj.assertions.generator.util.ClassUtil.*;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.contentOf;
@@ -48,104 +44,113 @@ import static org.assertj.core.api.Assertions.contentOf;
 @RunWith(Theories.class)
 public class AssertionGeneratorTest implements NestedClassesTest, BeanWithExceptionsTest {
   private static final String LINE_SEPARATOR = "\n";
-  private static final String TARGET_DIRECTORY = "target";
-  private static final File RESOURCES_DIRECTORY = new File("src/test/resources");
   private static final Logger logger = LoggerFactory.getLogger(AssertionGeneratorTest.class);
   private ClassToClassDescriptionConverter converter;
   private AssertionGenerator assertionGenerator;
   private static final Set<TypeToken<?>> allClasses =
-      newHashSet(Arrays.<TypeToken<?>>asList(TypeToken.of(Movie.class), TypeToken.of(ArtWork.class)));
+      new HashSet<>(Arrays.<TypeToken<?>>asList(TypeToken.of(Movie.class), TypeToken.of(ArtWork.class)));
+
+  @Rule
+  public final GenerationPathHandler genHandle = new GenerationPathHandler(AssertionGeneratorTest.class, Paths.get("src/test/resources"));
 
   @Before
   public void beforeEachTest() throws IOException {
     converter = new ClassToClassDescriptionConverter();
-    assertionGenerator = buildAssertionGenerator();
-  }
-
-  public AssertionGenerator buildAssertionGenerator() throws IOException {
-    BaseAssertionGenerator assertionGenerator = new BaseAssertionGenerator();
-    assertionGenerator.setDirectoryWhereAssertionFilesAreGenerated(TARGET_DIRECTORY);
-    return assertionGenerator;
+    assertionGenerator = genHandle.buildAssertionGenerator();
   }
 
   @Test
   public void should_generate_assertion_for_player_class() throws Exception {
     assertionGenerator.generateCustomAssertionFor(converter.convertToClassDescription(Player.class));
-    assertGeneratedAssertClass(Player.class, "PlayerAssert.expected.txt");
+    genHandle.assertGeneratedAssertClass(Player.class, "PlayerAssert.expected.txt", true);
   }
 
   @Test
   public void should_generate_assertion_for_interface() throws Exception {
     assertionGenerator.generateCustomAssertionFor(converter.convertToClassDescription(PlayerAgent.class));
-    assertGeneratedAssertClass(PlayerAgent.class, "PlayerAgentAssert.expected.txt");
+    genHandle.assertGeneratedAssertClass(PlayerAgent.class, "PlayerAgentAssert.expected.txt", true);
   }
 
   @Test
   public void should_generate_assertion_for_class_with_public_fields() throws Exception {
     assertionGenerator.generateCustomAssertionFor(converter.convertToClassDescription(Team.class));
-    assertGeneratedAssertClass(Team.class, "TeamAssert.expected.txt");
+    genHandle.assertGeneratedAssertClass(Team.class, "TeamAssert.expected.txt", true);
   }
 
   @Test
   public void should_generate_assertion_for_class_with_properties_that_clash_with_fields() throws Exception {
     assertionGenerator.generateCustomAssertionFor(converter.convertToClassDescription(FieldPropertyClash.class));
-    assertGeneratedAssertClass(FieldPropertyClash.class, "FieldPropertyClash.expected.txt");
+    genHandle.assertGeneratedAssertClass(FieldPropertyClash.class, "FieldPropertyClash.expected.txt", true);
   }
 
   @Test
   public void should_generate_assertion_for_class_with_properties_that_clash_with_keywords() throws Exception {
     assertionGenerator.generateCustomAssertionFor(converter.convertToClassDescription(Keywords.class));
-    assertGeneratedAssertClass(Keywords.class, "Keywords.expected.txt");
+    genHandle.assertGeneratedAssertClass(Keywords.class, "Keywords.expected.txt", true);
   }
 
   @Test
   public void should_generate_assertion_for_class_with_predicates() throws Exception {
     ClassDescription classDescription = converter.convertToClassDescription(BooleanPredicates.class);
     assertionGenerator.generateCustomAssertionFor(classDescription);
-    assertGeneratedAssertClass(BooleanPredicates.class, "BooleanPredicates.expected.txt");
+    genHandle.assertGeneratedAssertClass(BooleanPredicates.class, "BooleanPredicates.expected.txt", true);
   }
 
   @Test
   public void should_generate_assertion_for_class_with_primitives() throws Exception {
     assertionGenerator.generateCustomAssertionFor(converter.convertToClassDescription(Primitives.class));
-    assertGeneratedAssertClass(Primitives.class, "PrimitivesAssert.expected.txt");
+    genHandle.assertGeneratedAssertClass(Primitives.class, "PrimitivesAssert.expected.txt", true);
   }
 
   @Test
   public void should_generate_assertion_for_class_with_interference_primitives() throws Exception {
     assertionGenerator.generateCustomAssertionFor(converter.convertToClassDescription(InterferencePrimitives.class));
-    assertGeneratedAssertClass(InterferencePrimitives.class, "InterferencePrimitivesAssert.expected.txt");
+    genHandle.assertGeneratedAssertClass(InterferencePrimitives.class, "InterferencePrimitivesAssert.expected.txt", true);
   }
 
   @Test
   public void should_generate_flat_assertion_for_movie_class() throws Exception {
-    assertThat(abstractFileGeneratedFor(Movie.class).delete()).isTrue();
     assertionGenerator.generateCustomAssertionFor(converter.convertToClassDescription(Movie.class));
-    assertGeneratedAssertClass(Movie.class, "MovieAssert.flat.expected.txt");
-    assertThat(abstractFileGeneratedFor(Movie.class)).doesNotExist();
+    genHandle.assertGeneratedAssertClass(Movie.class, "MovieAssert.flat.expected.txt", true);
+    assertThat(genHandle.abstractFileGeneratedFor(Movie.class)).doesNotExist();
   }
 
   @Test
   public void should_generate_hierarchical_assertion_for_movie_class() throws Exception {
-    assertionGenerator.generateHierarchicalCustomAssertionFor(converter.convertToClassDescription(Movie.class),
-                                                              allClasses);
-    assertGeneratedAssertClass(Movie.class, "MovieAssert.expected.txt");
-    assertAbstractGeneratedAssertClass(Movie.class, "AbstractMovieAssert.expected.txt");
+    List<File> generated = new ArrayList<>(4);
+
+    File[] movieFiles = assertionGenerator.generateHierarchicalCustomAssertionFor(converter.convertToClassDescription(Movie.class),
+                                                                             allClasses);
+    generated.addAll(Arrays.asList(movieFiles));
+
+    genHandle.assertGeneratedAssertClass(Movie.class, "MovieAssert.expected.txt", false);
+    genHandle.assertAbstractGeneratedAssertClass(Movie.class, "AbstractMovieAssert.expected.txt");
+
+    // These should also be generated!
+    File[] artWorkFiles = assertionGenerator.generateHierarchicalCustomAssertionFor(converter.convertToClassDescription(ArtWork.class),
+        allClasses);
+    generated.addAll(Arrays.asList(artWorkFiles));
+    genHandle.assertGeneratedAssertClass(ArtWork.class, "ArtWorkAssert.expected.txt", false);
+    genHandle.assertAbstractGeneratedAssertClass(ArtWork.class, "AbstractArtWorkAssert.expected.txt");
+
+    // compile them
+    genHandle.compileGeneratedFiles(generated);
   }
 
   @Test
   public void should_generate_hierarchical_assertion_for_artwork_class() throws Exception {
     assertionGenerator.generateHierarchicalCustomAssertionFor(converter.convertToClassDescription(ArtWork.class),
-                                                              allClasses);
-    assertGeneratedAssertClass(ArtWork.class, "ArtWorkAssert.expected.txt");
-    assertAbstractGeneratedAssertClass(ArtWork.class, "AbstractArtWorkAssert.expected.txt");
+                                                                                allClasses);
+
+    genHandle.assertAbstractGeneratedAssertClass(ArtWork.class, "AbstractArtWorkAssert.expected.txt");
+    genHandle.assertGeneratedAssertClass(ArtWork.class, "ArtWorkAssert.expected.txt", true);
   }
 
   @Theory
   public void should_generate_assertion_for_nested_class(NestedClass nestedClass) throws Exception {
     Class<?> clazz = nestedClass.getNestedClass();
     assertionGenerator.generateCustomAssertionFor(converter.convertToClassDescription(clazz));
-    assertThat(fileGeneratedFor(clazz)).hasContent(expectedContentFromTemplate(clazz,
+    assertThat(genHandle.fileGeneratedFor(clazz)).hasContent(expectedContentFromTemplate(clazz,
                                                                                "NestedClassAssert.template.expected.txt"));
   }
 
@@ -153,7 +158,7 @@ public class AssertionGeneratorTest implements NestedClassesTest, BeanWithExcept
   public void should_generate_hierarchical_assertion_for_nested_class(NestedClass nestedClass) throws Exception {
     Class<?> clazz = nestedClass.getNestedClass();
     assertionGenerator.generateHierarchicalCustomAssertionFor(converter.convertToClassDescription(clazz), null);
-    assertThat(fileGeneratedFor(clazz)).hasContent(expectedContentFromTemplate(clazz,
+    assertThat(genHandle.fileGeneratedFor(clazz)).hasContent(expectedContentFromTemplate(clazz,
                                                                                "NestedClassAssert.hierarchical.template.expected.txt"));
   }
 
@@ -161,7 +166,7 @@ public class AssertionGeneratorTest implements NestedClassesTest, BeanWithExcept
   public void should_generate_assertion_for_property_with_exception(TypeToken<?> beanType) throws Exception {
     assertionGenerator.generateCustomAssertionFor(converter.convertToClassDescription(beanType));
     Class<?> clazz = beanType.getRawType();
-    String expectedContent = contentOf(new File(RESOURCES_DIRECTORY, "BeanWithOneException.expected.txt"), defaultCharset());
+    String expectedContent = contentOf(genHandle.getResourcesDir().resolve("BeanWithOneException.expected.txt").toFile(), defaultCharset());
     if (!BEAN_WITH_ONE_EXCEPTION.equals(beanType)) {
       expectedContent = expectedContent.replace(BEAN_WITH_ONE_EXCEPTION.getRawType().getSimpleName(), clazz.getSimpleName());
       expectedContent = expectedContent.replace(" throws java.io.IOException ",
@@ -178,7 +183,7 @@ public class AssertionGeneratorTest implements NestedClassesTest, BeanWithExcept
         expectedContent = expectedContent.replace(throwsClause, replacement);
       }
     }
-    assertThat(fileGeneratedFor(clazz)).hasContent(expectedContent);
+    assertThat(genHandle.fileGeneratedFor(clazz)).hasContent(expectedContent);
   }
 
   @Test
@@ -216,63 +221,42 @@ public class AssertionGeneratorTest implements NestedClassesTest, BeanWithExcept
   public void should_generate_assertion_for_classes_using_type_with_same_name() throws IOException {
     Class<?> clazz = ClassUsingDifferentClassesWithSameName.class;
     assertionGenerator.generateCustomAssertionFor(converter.convertToClassDescription(clazz));
-    assertGeneratedAssertClass(ClassUsingDifferentClassesWithSameName.class,
-                               "ClassUsingDifferentClassesWithSameName.expected.txt");
+    genHandle.assertGeneratedAssertClass(ClassUsingDifferentClassesWithSameName.class,
+                               "ClassUsingDifferentClassesWithSameName.expected.txt", true);
   }
 
   @Test
   public void should_generate_assertion_for_annotated_methods() throws IOException {
     converter = new ClassToClassDescriptionConverter(new AnnotationConfiguration(GenerateAssertion.class));
     assertionGenerator.generateCustomAssertionFor(converter.convertToClassDescription(AnnotatedClass.class));
-    assertGeneratedAssertClass(AnnotatedClass.class, "AnnotatedClassAssert.expected.txt");
+    genHandle.assertGeneratedAssertClass(AnnotatedClass.class, "AnnotatedClassAssert.expected.txt", true);
   }
 
   @Test
   public void should_generate_assertion_for_methods_annotated_with_GenerateAssertion_by_default() throws IOException {
     assertionGenerator.generateCustomAssertionFor(converter.convertToClassDescription(AnnotatedClass.class));
-    assertGeneratedAssertClass(AnnotatedClass.class, "AnnotatedClassAssert.expected.txt");
+    genHandle.assertGeneratedAssertClass(AnnotatedClass.class, "AnnotatedClassAssert.expected.txt", true);
   }
 
   @Test
   public void should_generate_assertion_for_annotated_class() throws IOException {
     converter = new ClassToClassDescriptionConverter(new AnnotationConfiguration(AutoValue.class));
     assertionGenerator.generateCustomAssertionFor(converter.convertToClassDescription(AutoValueAnnotatedClass.class));
-    assertGeneratedAssertClass(AutoValueAnnotatedClass.class, "AutoValueAnnotatedClassAssert.expected.txt");
-  }
-
-  static void assertGeneratedAssertClass(Class<?> clazz, String expectedAssertFile) {
-    File expectedFile = new File(RESOURCES_DIRECTORY, expectedAssertFile).getAbsoluteFile();
-    assertThat(fileGeneratedFor(clazz)).hasSameContentAs(expectedFile);
+    genHandle.assertGeneratedAssertClass(AutoValueAnnotatedClass.class, "AutoValueAnnotatedClassAssert.expected.txt", true);
   }
 
-  private static void assertAbstractGeneratedAssertClass(Class<?> clazz, String expectedAssertFile) {
-    File expectedFile = new File(RESOURCES_DIRECTORY, expectedAssertFile).getAbsoluteFile();
-    assertThat(abstractFileGeneratedFor(clazz)).hasSameContentAs(expectedFile);
-  }
 
-  private static String expectedContentFromTemplate(Class<?> clazz, String fileTemplate) throws IOException {
-    String template = contentOf(new File(RESOURCES_DIRECTORY, fileTemplate), defaultCharset());
+  private String expectedContentFromTemplate(Class<?> clazz, String fileTemplate) throws IOException {
+    String template = contentOf(genHandle.getResourcesDir().resolve(fileTemplate).toFile(), defaultCharset());
     String content = replace(template, "${nestedClass}Assert", getSimpleNameWithOuterClassNotSeparatedByDots(clazz)
                                                                + "Assert");
     content = replace(content, "${nestedClass}", getSimpleNameWithOuterClass(clazz));
     return content;
   }
 
-  private static File fileGeneratedFor(Class<?> clazz) {
-    String dirName = TARGET_DIRECTORY + File.separatorChar
-                     + clazz.getPackage().getName().replace('.', File.separatorChar);
-    String generatedFileName = getSimpleNameWithOuterClassNotSeparatedByDots(clazz) + ASSERT_CLASS_FILE_SUFFIX;
-    return new File(dirName, generatedFileName);
-  }
 
-  private static File abstractFileGeneratedFor(Class<?> clazz) {
-    String dirName = TARGET_DIRECTORY + File.separatorChar
-                     + clazz.getPackage().getName().replace('.', File.separatorChar);
-    String generatedFileName = ABSTRACT_ASSERT_CLASS_PREFIX + getSimpleNameWithOuterClassNotSeparatedByDots(clazz)
-                               + ASSERT_CLASS_FILE_SUFFIX;
-    return new File(dirName, generatedFileName);
-  }
 
+  @SuppressWarnings("WeakerAccess")
   class MyClassLoader extends ClassLoader {
     public MyClassLoader(ClassLoader parent) {
       super(parent);
diff --git a/src/test/java/org/assertj/assertions/generator/AssertionsEntryPointGeneratorTest.java b/src/test/java/org/assertj/assertions/generator/AssertionsEntryPointGeneratorTest.java
index 96d8a89..767fd88 100644
--- a/src/test/java/org/assertj/assertions/generator/AssertionsEntryPointGeneratorTest.java
+++ b/src/test/java/org/assertj/assertions/generator/AssertionsEntryPointGeneratorTest.java
@@ -25,10 +25,12 @@ import org.assertj.assertions.generator.data.nba.Team;
 import org.assertj.assertions.generator.description.ClassDescription;
 import org.assertj.assertions.generator.description.converter.ClassToClassDescriptionConverter;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 
 import java.io.File;
 import java.io.IOException;
+import java.nio.file.Paths;
 import java.util.LinkedHashSet;
 import java.util.Set;
 
@@ -38,12 +40,15 @@ import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.contentOf;
 
 public class AssertionsEntryPointGeneratorTest {
-  private static final String TARGET_DIRECTORY = "target";
   private BaseAssertionGenerator generator;
 
+  @Rule
+  public final GenerationPathHandler genHandle = new GenerationPathHandler(AssertionsEntryPointGeneratorTest.class,
+                                                                           Paths.get("src/test/resources"));
+
   @Before
   public void beforeEachTest() throws IOException {
-    generator = buildAssertionGenerator();
+    generator = genHandle.buildAssertionGenerator();
   }
 
   @Test
@@ -87,7 +92,7 @@ public class AssertionsEntryPointGeneratorTest {
     String expectedContent = readExpectedContentFromFile("AssertionsWithCustomPackage.expected.txt");
     assertThat(assertionsEntryPointFile).as("check entry point class content")
                                         .hasContent(expectedContent)
-                                        .hasParent("target/my/custom/package");
+                                        .hasParent(genHandle.getRoot().toPath().resolve("my/custom/package").toFile());
   }
 
   @Test
@@ -267,12 +272,6 @@ public class AssertionsEntryPointGeneratorTest {
     return classDescriptionSet;
   }
 
-  private BaseAssertionGenerator buildAssertionGenerator() throws IOException {
-    BaseAssertionGenerator assertionGenerator = new BaseAssertionGenerator();
-    assertionGenerator.setDirectoryWhereAssertionFilesAreGenerated(TARGET_DIRECTORY);
-    return assertionGenerator;
-  }
-
   private String readExpectedContentFromFile(String fileWithExpectedContent) {
     return contentOf(new File("src/test/resources", fileWithExpectedContent));
   }
diff --git a/src/test/java/org/assertj/assertions/generator/GenerationPathHandler.java b/src/test/java/org/assertj/assertions/generator/GenerationPathHandler.java
new file mode 100644
index 0000000..1291ae3
--- /dev/null
+++ b/src/test/java/org/assertj/assertions/generator/GenerationPathHandler.java
@@ -0,0 +1,211 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+package org.assertj.assertions.generator;
+
+import com.google.common.base.Joiner;
+import com.google.testing.compile.Compilation;
+import com.google.testing.compile.CompilationSubject;
+import com.google.testing.compile.Compiler;
+import com.google.testing.compile.JavaFileObjects;
+import org.assertj.core.api.Assertions;
+import org.junit.rules.TemporaryFolder;
+import org.junit.runner.Description;
+import org.junit.runners.model.Statement;
+
+import javax.tools.JavaFileObject;
+import java.io.File;
+import java.io.IOException;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.net.URLClassLoader;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.util.*;
+
+import static org.assertj.assertions.generator.BaseAssertionGenerator.ABSTRACT_ASSERT_CLASS_PREFIX;
+import static org.assertj.assertions.generator.BaseAssertionGenerator.ASSERT_CLASS_FILE_SUFFIX;
+import static org.assertj.assertions.generator.util.ClassUtil.getSimpleNameWithOuterClassNotSeparatedByDots;
+import static org.assertj.core.api.Assertions.assertThat;
+
+/**
+ * Test {@link org.junit.Rule} used to generate temporary folders per test case so there is no concern of
+ * tests interacting with each other. This utilizes the built-in {@link TemporaryFolder} to accomplish this and
+ * contains generator specific methods.
+ */
+public class GenerationPathHandler extends TemporaryFolder {
+
+
+  public static final Path DEFAULT_GENERATION_ROOT = Paths.get("target/generated-test-output");
+
+  private final Compiler compiler;
+  private Path resourcesDir;
+
+  public GenerationPathHandler(final Class<?> owningClass, Path resourcesDir) {
+    super(DEFAULT_GENERATION_ROOT.toFile());
+
+    //noinspection ResultOfMethodCallIgnored
+    DEFAULT_GENERATION_ROOT.toFile().mkdirs();
+
+    this.resourcesDir = resourcesDir;
+
+    final String currentClasspath = getClasspathFromClassloader(ClassLoader.getSystemClassLoader());
+    compiler = Compiler.javac()
+        .withOptions("-classpath", currentClasspath);
+  }
+
+  public Path getResourcesDir() {
+    return resourcesDir;
+  }
+
+  @Override
+  public Statement apply(final Statement base, final Description description) {
+
+    return new Statement() {
+      @Override
+      public void evaluate() throws Throwable {
+        before();
+
+        try {
+          base.evaluate();
+          after();
+        } catch (Exception e) {
+          System.err.println("Failed working with folder: " + getRoot());
+          throw new AssertionError(e);
+        }
+      }
+    };
+  }
+
+  public BaseAssertionGenerator buildAssertionGenerator() throws IOException {
+    BaseAssertionGenerator assertionGenerator = new BaseAssertionGenerator();
+    assertionGenerator.setDirectoryWhereAssertionFilesAreGenerated(getRoot());
+    return assertionGenerator;
+  }
+
+  public Path packagePathFor(Class<?> clazz) {
+    return getRoot().toPath()
+        .resolve(clazz.getPackage().getName().replace('.', File.separatorChar));
+  }
+
+  public File fileGeneratedFor(Class<?> clazz) {
+    String generatedFileName = getSimpleNameWithOuterClassNotSeparatedByDots(clazz) + ASSERT_CLASS_FILE_SUFFIX;
+    return packagePathFor(clazz)
+        .resolve(generatedFileName)
+        .toFile();
+  }
+
+  public File abstractFileGeneratedFor(Class<?> clazz) {
+    String generatedFileName = ABSTRACT_ASSERT_CLASS_PREFIX
+        + getSimpleNameWithOuterClassNotSeparatedByDots(clazz)
+        + ASSERT_CLASS_FILE_SUFFIX;
+    return packagePathFor(clazz)
+        .resolve(generatedFileName)
+        .toFile();
+  }
+
+  public void compileGeneratedFiles(Iterable<? extends File> files) {
+    List<JavaFileObject> jfiles = new ArrayList<>();
+    for (File file: files) {
+      try {
+        final URL url = file.toURI().toURL();
+        jfiles.add(JavaFileObjects.forResource(url));
+      } catch (MalformedURLException mfue) {
+        Assertions.failBecauseExceptionWasNotThrown(MalformedURLException.class);
+      }
+    }
+
+    Compilation compilation = compiler.compile(jfiles);
+
+    try {
+
+      CompilationSubject.assertThat(compilation).succeeded();
+    } catch (AssertionError ex) {
+      throw new AssertionError("Error with compilation. JAVAC options:\n" + compiler.options(), ex);
+    }
+  }
+
+  public void compileGeneratedFiles(File... files) {
+    compileGeneratedFiles(Arrays.asList(files));
+  }
+
+  public void compileGeneratedFiles(Class<?>... classes) {
+    List<File> files = new ArrayList<>(classes.length);
+    for (Class<?> clazz: classes) {
+      files.add(fileGeneratedFor(clazz));
+
+      // Handle abstract files, too!
+      File abstractFile = abstractFileGeneratedFor(clazz);
+      if (abstractFile.exists()) {
+        files.add(abstractFile);
+      }
+    }
+
+    compileGeneratedFiles(files);
+  }
+
+  public void assertGeneratedAssertClass(Class<?> clazz, String expectedAssertFile, final boolean compileGenerated) throws IOException {
+    File expectedFile = resourcesDir.resolve(expectedAssertFile).toAbsolutePath().toFile();
+    File actualFile = fileGeneratedFor(clazz);
+    assertThat(actualFile).hasSameContentAs(expectedFile);
+
+    // compile it!
+    if (compileGenerated) {
+      compileGeneratedFiles(clazz);
+    }
+  }
+
+  public void assertAbstractGeneratedAssertClass(Class<?> clazz, String expectedAssertFile) {
+    File expectedFile = getResourcesDir().resolve(expectedAssertFile).toAbsolutePath().toFile();
+    assertThat(abstractFileGeneratedFor(clazz)).hasSameContentAs(expectedFile);
+  }
+
+  /**
+   * Returns the current classpaths of the given classloader including its parents.
+   *
+   * @throws IllegalArgumentException if the given classloader had classpaths which we could not
+   *     determine or use for compilation.
+   */
+  private static String getClasspathFromClassloader(ClassLoader currentClassloader) {
+    ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
+
+    // Add all URLClassloaders in the hirearchy till the system classloader.
+    List<URLClassLoader> classloaders = new ArrayList<>();
+    while(true) {
+      if (currentClassloader instanceof URLClassLoader) {
+        // We only know how to extract classpaths from URLClassloaders.
+        classloaders.add((URLClassLoader) currentClassloader);
+      } else {
+        throw new IllegalArgumentException("Classpath for compilation could not be extracted "
+            + "since given classloader is not an instance of URLClassloader");
+      }
+      if (currentClassloader == systemClassLoader) {
+        break;
+      }
+      currentClassloader = currentClassloader.getParent();
+    }
+
+    Set<String> classpaths = new LinkedHashSet<>();
+    for (URLClassLoader classLoader : classloaders) {
+      for (URL url : classLoader.getURLs()) {
+        if (url.getProtocol().equals("file")) {
+          classpaths.add(url.getPath());
+        } else {
+          throw new IllegalArgumentException("Given classloader consists of classpaths which are "
+              + "unsupported for compilation.");
+        }
+      }
+    }
+
+    return Joiner.on(File.pathSeparatorChar).join(classpaths);
+  }
+}
diff --git a/src/test/java/org/assertj/assertions/generator/description/converter/ClassToClassDescriptionConverterTest.java b/src/test/java/org/assertj/assertions/generator/description/converter/ClassToClassDescriptionConverterTest.java
index 74c0a3c..aaa8405 100644
--- a/src/test/java/org/assertj/assertions/generator/description/converter/ClassToClassDescriptionConverterTest.java
+++ b/src/test/java/org/assertj/assertions/generator/description/converter/ClassToClassDescriptionConverterTest.java
@@ -1,4 +1,4 @@
-/*
+/**
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
  * the License. You may obtain a copy of the License at
  *
diff --git a/src/test/java/org/assertj/assertions/generator/util/ClassUtilTest.java b/src/test/java/org/assertj/assertions/generator/util/ClassUtilTest.java
index 7c8b7f9..f542681 100644
--- a/src/test/java/org/assertj/assertions/generator/util/ClassUtilTest.java
+++ b/src/test/java/org/assertj/assertions/generator/util/ClassUtilTest.java
@@ -1,4 +1,4 @@
-/*
+/**
  * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
  * the License. You may obtain a copy of the License at
  *
diff --git a/src/test/resources/BooleanPredicates.expected.txt b/src/test/resources/BooleanPredicates.expected.txt
index feaf455..5769a28 100644
--- a/src/test/resources/BooleanPredicates.expected.txt
+++ b/src/test/resources/BooleanPredicates.expected.txt
@@ -312,7 +312,7 @@ public class BooleanPredicatesAssert extends AbstractObjectAssert<BooleanPredica
     isNotNull();
 
     // check that property call/field access is true
-    if (!actual.goodField) {
+    if (!actual.canBeGoodField) {
       failWithMessage("\nExpecting that actual BooleanPredicates can be good field but is not.");
     }
 
@@ -330,7 +330,7 @@ public class BooleanPredicatesAssert extends AbstractObjectAssert<BooleanPredica
     isNotNull();
 
     // check that property call/field access is false
-    if (actual.goodField) {
+    if (actual.canBeGoodField) {
       failWithMessage("\nExpecting that actual BooleanPredicates cannot be good field but is not.");
     }
 
@@ -348,7 +348,7 @@ public class BooleanPredicatesAssert extends AbstractObjectAssert<BooleanPredica
     isNotNull();
 
     // check that property call/field access is true
-    if (!actual.goodField) {
+    if (!actual.hasGoodField) {
       failWithMessage("\nExpecting that actual BooleanPredicates has good field but does not have.");
     }
 
@@ -366,7 +366,7 @@ public class BooleanPredicatesAssert extends AbstractObjectAssert<BooleanPredica
     isNotNull();
 
     // check that property call/field access is false
-    if (actual.goodField) {
+    if (actual.hasGoodField) {
       failWithMessage("\nExpecting that actual BooleanPredicates does not have good field but has.");
     }
 
@@ -384,7 +384,7 @@ public class BooleanPredicatesAssert extends AbstractObjectAssert<BooleanPredica
     isNotNull();
 
     // check that property call/field access is true
-    if (!actual.goodField) {
+    if (!actual.isGoodField) {
       failWithMessage("\nExpecting that actual BooleanPredicates is good field but is not.");
     }
 
@@ -402,7 +402,7 @@ public class BooleanPredicatesAssert extends AbstractObjectAssert<BooleanPredica
     isNotNull();
 
     // check that property call/field access is false
-    if (actual.goodField) {
+    if (actual.isGoodField) {
       failWithMessage("\nExpecting that actual BooleanPredicates is not good field but is.");
     }
 
@@ -420,7 +420,7 @@ public class BooleanPredicatesAssert extends AbstractObjectAssert<BooleanPredica
     isNotNull();
 
     // check that property call/field access is true
-    if (!actual.goodField) {
+    if (!actual.shouldBeGoodField) {
       failWithMessage("\nExpecting that actual BooleanPredicates should be good field but is not.");
     }
 
@@ -438,7 +438,7 @@ public class BooleanPredicatesAssert extends AbstractObjectAssert<BooleanPredica
     isNotNull();
 
     // check that property call/field access is false
-    if (actual.goodField) {
+    if (actual.shouldBeGoodField) {
       failWithMessage("\nExpecting that actual BooleanPredicates should not be good field but should be.");
     }
 
@@ -456,7 +456,7 @@ public class BooleanPredicatesAssert extends AbstractObjectAssert<BooleanPredica
     isNotNull();
 
     // check that property call/field access is true
-    if (!actual.goodField) {
+    if (!actual.wasGoodField) {
       failWithMessage("\nExpecting that actual BooleanPredicates was good field but was not.");
     }
 
@@ -474,7 +474,7 @@ public class BooleanPredicatesAssert extends AbstractObjectAssert<BooleanPredica
     isNotNull();
 
     // check that property call/field access is false
-    if (actual.goodField) {
+    if (actual.wasGoodField) {
       failWithMessage("\nExpecting that actual BooleanPredicates was not good field but was.");
     }
 
@@ -492,7 +492,7 @@ public class BooleanPredicatesAssert extends AbstractObjectAssert<BooleanPredica
     isNotNull();
 
     // check that property call/field access is true
-    if (!actual.goodField) {
+    if (!actual.willBeGoodField) {
       failWithMessage("\nExpecting that actual BooleanPredicates will be good field but will not be.");
     }
 
@@ -510,7 +510,7 @@ public class BooleanPredicatesAssert extends AbstractObjectAssert<BooleanPredica
     isNotNull();
 
     // check that property call/field access is false
-    if (actual.goodField) {
+    if (actual.willBeGoodField) {
       failWithMessage("\nExpecting that actual BooleanPredicates will not be good field but will be.");
     }
 
