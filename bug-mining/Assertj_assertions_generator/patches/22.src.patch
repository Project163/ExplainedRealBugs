diff --git a/licence-header.txt b/licence-header.txt
new file mode 100644
index 0000000..b96e314
--- /dev/null
+++ b/licence-header.txt
@@ -0,0 +1,10 @@
+Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+the License. You may obtain a copy of the License at                                                               
+                                                                                                                   
+http://www.apache.org/licenses/LICENSE-2.0                                                                         
+                                                                                                                   
+Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the 
+specific language governing permissions and limitations under the License.                                         
+                                                                                                                   
+Copyright ${inceptionYear}-${currentYear} the original author or authors.
\ No newline at end of file
diff --git a/pom.xml b/pom.xml
index 87d6070..3b765cc 100644
--- a/pom.xml
+++ b/pom.xml
@@ -5,7 +5,7 @@
   <parent>
     <groupId>org.assertj</groupId>
     <artifactId>assertj-parent-pom</artifactId>
-    <version>1.2.5</version>
+    <version>1.3.1</version>
   </parent>
   <artifactId>assertj-assertions-generator</artifactId>
   <version>1.4.1-SNAPSHOT</version>
@@ -48,7 +48,7 @@
     <dependency>
       <groupId>org.assertj</groupId>
       <artifactId>assertj-core</artifactId>
-      <version>1.6.1</version>
+      <version>1.7.0</version>
       <scope>test</scope>
     </dependency>
     <dependency>
@@ -61,10 +61,38 @@
   <build>
     <finalName>assertion-generator</finalName>
     <plugins>
+      <plugin>
+        <groupId>org.apache.maven.plugins</groupId>
+        <artifactId>maven-compiler-plugin</artifactId>
+        <configuration>
+          <source>1.6</source>
+          <target>1.6</target>
+        </configuration>
+      </plugin>
+      <plugin>
+        <groupId>org.codehaus.mojo</groupId>
+        <artifactId>animal-sniffer-maven-plugin</artifactId>
+        <configuration>
+          <signature>
+            <groupId>org.codehaus.mojo.signature</groupId>
+            <artifactId>java16</artifactId>
+            <version>1.0</version>
+          </signature>
+        </configuration>
+        <executions>
+          <execution>
+            <id>Check JRE 1.6 API compatibility</id>
+            <phase>test</phase>
+            <goals>
+              <goal>check</goal>
+            </goals>
+          </execution>
+        </executions>
+      </plugin>
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-assembly-plugin</artifactId>
-        <version>2.4</version>
+        <version>2.4.1</version>
         <executions>
           <execution>
             <id>unix-assembly</id>
@@ -96,7 +124,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-jar-plugin</artifactId>
-        <version>2.4</version>
+        <version>2.5</version>
         <configuration>
           <archive>
             <manifest>
@@ -127,34 +155,5 @@
         </configuration>
       </plugin>
     </plugins>
-    <pluginManagement>
-      <plugins>
-        <!--This plugin's configuration is used to store Eclipse m2e settings only. It has no influence on the Maven build itself.-->
-        <plugin>
-          <groupId>org.eclipse.m2e</groupId>
-          <artifactId>lifecycle-mapping</artifactId>
-          <version>1.0.0</version>
-          <configuration>
-            <lifecycleMappingMetadata>
-              <pluginExecutions>
-                <pluginExecution>
-                  <pluginExecutionFilter>
-                    <groupId>org.jacoco</groupId>
-                    <artifactId>jacoco-maven-plugin</artifactId>
-                    <versionRange>[0.6.2.201302030002,)</versionRange>
-                    <goals>
-                      <goal>prepare-agent</goal>
-                    </goals>
-                  </pluginExecutionFilter>
-                  <action>
-                    <ignore />
-                  </action>
-                </pluginExecution>
-              </pluginExecutions>
-            </lifecycleMappingMetadata>
-          </configuration>
-        </plugin>
-      </plugins>
-    </pluginManagement>
   </build>
 </project>
diff --git a/src/main/java/org/assertj/assertions/generator/BaseAssertionGenerator.java b/src/main/java/org/assertj/assertions/generator/BaseAssertionGenerator.java
index 77d2ada..edee620 100644
--- a/src/main/java/org/assertj/assertions/generator/BaseAssertionGenerator.java
+++ b/src/main/java/org/assertj/assertions/generator/BaseAssertionGenerator.java
@@ -39,9 +39,9 @@ public class BaseAssertionGenerator implements AssertionGenerator, AssertionsEnt
   // default file for templates
   static final String DEFAULT_IS_ASSERTION_TEMPLATE = "is_assertion_template.txt";
   static final String DEFAULT_HAS_ELEMENTS_ASSERTION_TEMPLATE_FOR_ARRAY =
-      "has_elements_assertion_template_for_array.txt";
+	  "has_elements_assertion_template_for_array.txt";
   static final String DEFAULT_HAS_ELEMENTS_ASSERTION_TEMPLATE_FOR_ITERABLE =
-      "has_elements_assertion_template_for_iterable.txt";
+	  "has_elements_assertion_template_for_iterable.txt";
   static final String DEFAULT_HAS_ASSERTION_TEMPLATE = "has_assertion_template.txt";
   static final String DEFAULT_HAS_ASSERTION_TEMPLATE_FOR_PRIMITIVE = "has_assertion_template_for_primitive.txt";
   static final String DEFAULT_HAS_ASSERTION_TEMPLATE_FOR_REAL_NUMBER = "has_assertion_template_for_real_number.txt";
@@ -51,7 +51,7 @@ public class BaseAssertionGenerator implements AssertionGenerator, AssertionsEnt
   static final String DEFAULT_ASSERTIONS_ENTRY_POINT_CLASS_TEMPLATE = "standard_assertions_entry_point_class_template.txt";
   static final String DEFAULT_ASSERTION_ENTRY_POINT_METHOD_TEMPLATE = "standard_assertion_entry_point_method_template.txt";
   static final String DEFAULT_SOFT_ENTRY_POINT_ASSERTIONS_CLASS_TEMPLATE =
-      "soft_assertions_entry_point_class_template.txt";
+	  "soft_assertions_entry_point_class_template.txt";
   static final String DEFAULT_SOFT_ENTRY_POINT_ASSERTION_METHOD_TEMPLATE = "soft_assertion_entry_point_method_template.txt";
   static final String DEFAULT_BDD_ENTRY_POINT_ASSERTIONS_CLASS_TEMPLATE = "bdd_assertions_entry_point_class_template.txt";
   static final String DEFAULT_BDD_ENTRY_POINT_ASSERTION_METHOD_TEMPLATE = "bdd_assertion_entry_point_method_template.txt";
@@ -100,7 +100,7 @@ public class BaseAssertionGenerator implements AssertionGenerator, AssertionsEnt
    * @throws IOException if some template file could not be found or read
    */
   public BaseAssertionGenerator() throws IOException {
-    this(TEMPLATES_DIR);
+	this(TEMPLATES_DIR);
   }
 
   /**
@@ -110,70 +110,70 @@ public class BaseAssertionGenerator implements AssertionGenerator, AssertionsEnt
    * @throws IOException if some template file could not be found or read
    */
   public BaseAssertionGenerator(String templatesDirectory) throws IOException {
-    this(
-         new Template(Template.Type.ASSERT_CLASS,
-                      new File(templatesDirectory, DEFAULT_CUSTOM_ASSERTION_CLASS_TEMPLATE)),
-         new Template(Template.Type.HIERARCHICAL_ASSERT_CLASS,
-                      new File(templatesDirectory, DEFAULT_CUSTOM_HIERARCHICAL_ASSERTION_CLASS_TEMPLATE)),
-         new Template(Template.Type.ABSTRACT_ASSERT_CLASS,
-                      new File(templatesDirectory, DEFAULT_CUSTOM_ABSTRACT_ASSERTION_CLASS_TEMPLATE)),
-         new Template(Template.Type.HAS,
-                      new File(templatesDirectory, DEFAULT_HAS_ASSERTION_TEMPLATE)),
-         new Template(Template.Type.HAS_FOR_PRIMITIVE,
-                      new File(templatesDirectory, DEFAULT_HAS_ASSERTION_TEMPLATE_FOR_PRIMITIVE)),
-         new Template(Template.Type.HAS_FOR_ITERABLE,
-                      new File(templatesDirectory, DEFAULT_HAS_ELEMENTS_ASSERTION_TEMPLATE_FOR_ITERABLE)),
-         new Template(Template.Type.HAS_FOR_ARRAY,
-                      new File(templatesDirectory, DEFAULT_HAS_ELEMENTS_ASSERTION_TEMPLATE_FOR_ARRAY)),
-         new Template(Template.Type.IS,
-                      new File(templatesDirectory, DEFAULT_IS_ASSERTION_TEMPLATE)),
-         new Template(Type.ASSERTIONS_ENTRY_POINT_CLASS,
-                      new File(templatesDirectory, DEFAULT_ASSERTIONS_ENTRY_POINT_CLASS_TEMPLATE)),
-         new Template(Type.ASSERTION_ENTRY_POINT,
-                      new File(templatesDirectory, DEFAULT_ASSERTION_ENTRY_POINT_METHOD_TEMPLATE)),
-         new Template(Type.SOFT_ASSERTIONS_ENTRY_POINT_CLASS,
-                      new File(templatesDirectory, DEFAULT_SOFT_ENTRY_POINT_ASSERTIONS_CLASS_TEMPLATE)),
-         new Template(Type.SOFT_ENTRY_POINT_METHOD_ASSERTION,
-                      new File(templatesDirectory, DEFAULT_SOFT_ENTRY_POINT_ASSERTION_METHOD_TEMPLATE)),
-         new Template(Type.BDD_ASSERTIONS_ENTRY_POINT_CLASS,
-                      new File(templatesDirectory, DEFAULT_BDD_ENTRY_POINT_ASSERTIONS_CLASS_TEMPLATE)),
-         new Template(Type.BDD_ENTRY_POINT_METHOD_ASSERTION,
-                      new File(templatesDirectory, DEFAULT_BDD_ENTRY_POINT_ASSERTION_METHOD_TEMPLATE)),
-         new Template(Type.HAS_FOR_REAL_NUMBER,
-                      new File(templatesDirectory, DEFAULT_HAS_ASSERTION_TEMPLATE_FOR_REAL_NUMBER)));
+	this(
+	     new Template(Template.Type.ASSERT_CLASS,
+	                  new File(templatesDirectory, DEFAULT_CUSTOM_ASSERTION_CLASS_TEMPLATE)),
+	     new Template(Template.Type.HIERARCHICAL_ASSERT_CLASS,
+	                  new File(templatesDirectory, DEFAULT_CUSTOM_HIERARCHICAL_ASSERTION_CLASS_TEMPLATE)),
+	     new Template(Template.Type.ABSTRACT_ASSERT_CLASS,
+	                  new File(templatesDirectory, DEFAULT_CUSTOM_ABSTRACT_ASSERTION_CLASS_TEMPLATE)),
+	     new Template(Template.Type.HAS,
+	                  new File(templatesDirectory, DEFAULT_HAS_ASSERTION_TEMPLATE)),
+	     new Template(Template.Type.HAS_FOR_PRIMITIVE,
+	                  new File(templatesDirectory, DEFAULT_HAS_ASSERTION_TEMPLATE_FOR_PRIMITIVE)),
+	     new Template(Template.Type.HAS_FOR_ITERABLE,
+	                  new File(templatesDirectory, DEFAULT_HAS_ELEMENTS_ASSERTION_TEMPLATE_FOR_ITERABLE)),
+	     new Template(Template.Type.HAS_FOR_ARRAY,
+	                  new File(templatesDirectory, DEFAULT_HAS_ELEMENTS_ASSERTION_TEMPLATE_FOR_ARRAY)),
+	     new Template(Template.Type.IS,
+	                  new File(templatesDirectory, DEFAULT_IS_ASSERTION_TEMPLATE)),
+	     new Template(Type.ASSERTIONS_ENTRY_POINT_CLASS,
+	                  new File(templatesDirectory, DEFAULT_ASSERTIONS_ENTRY_POINT_CLASS_TEMPLATE)),
+	     new Template(Type.ASSERTION_ENTRY_POINT,
+	                  new File(templatesDirectory, DEFAULT_ASSERTION_ENTRY_POINT_METHOD_TEMPLATE)),
+	     new Template(Type.SOFT_ASSERTIONS_ENTRY_POINT_CLASS,
+	                  new File(templatesDirectory, DEFAULT_SOFT_ENTRY_POINT_ASSERTIONS_CLASS_TEMPLATE)),
+	     new Template(Type.SOFT_ENTRY_POINT_METHOD_ASSERTION,
+	                  new File(templatesDirectory, DEFAULT_SOFT_ENTRY_POINT_ASSERTION_METHOD_TEMPLATE)),
+	     new Template(Type.BDD_ASSERTIONS_ENTRY_POINT_CLASS,
+	                  new File(templatesDirectory, DEFAULT_BDD_ENTRY_POINT_ASSERTIONS_CLASS_TEMPLATE)),
+	     new Template(Type.BDD_ENTRY_POINT_METHOD_ASSERTION,
+	                  new File(templatesDirectory, DEFAULT_BDD_ENTRY_POINT_ASSERTION_METHOD_TEMPLATE)),
+	     new Template(Type.HAS_FOR_REAL_NUMBER,
+	                  new File(templatesDirectory, DEFAULT_HAS_ASSERTION_TEMPLATE_FOR_REAL_NUMBER)));
   }
 
   public BaseAssertionGenerator(Template classAssertionTemplate,
-                                Template hierarchicalClassAssertionTemplate,
-                                Template abstractClassAssertionTemplate,
-                                Template hasAssertionTemplate,
-                                Template hasAssertionTemplateForPrimitive,
-                                Template hasIterableElementsAssertionTemplate,
-                                Template hasArrayElementsAssertionTemplate,
-                                Template isAssertionTemplate,
-                                Template entryPointAssertionsClassTemplate,
-                                Template entryPointAssertionTemplate,
-                                Template entryPointSoftAssertionsClassTemplate,
-                                Template entryPointSoftAssertionTemplate,
-                                Template bddAssertionsEntryPointClassTemplate,
-                                Template bddAssertionEntryPointMethodTemplate,
-                                Template hasAssertionTemplateForRealNumber) {
-
-    this.setAssertionClassTemplate(classAssertionTemplate);
-    this.setHierarchicalAssertionClassTemplate(hierarchicalClassAssertionTemplate);
-    this.setAbstractAssertionClassTemplate(abstractClassAssertionTemplate);
-    this.setHasAssertionTemplate(hasAssertionTemplate);
-    this.setHasAssertionTemplateForPrimitive(hasAssertionTemplateForPrimitive);
-    this.setHasAssertionTemplateForRealNumber(hasAssertionTemplateForRealNumber);
-    this.setHasElementsAssertionForIterableTemplate(hasIterableElementsAssertionTemplate);
-    this.setHasElementsAssertionForArrayTemplate(hasArrayElementsAssertionTemplate);
-    this.setIsAssertionTemplate(isAssertionTemplate);
-    this.setStandardAssertionsEntryPointClassTemplate(entryPointAssertionsClassTemplate);
-    this.setStandardAssertionEntryPointMethodTemplate(entryPointAssertionTemplate);
-    this.setSoftAssertionsEntryPointClassTemplate(entryPointSoftAssertionsClassTemplate);
-    this.setSoftAssertionEntryPointMethodTemplate(entryPointSoftAssertionTemplate);
-    this.setBddAssertionsEntryPointClassTemplate(bddAssertionsEntryPointClassTemplate);
-    this.setBddAssertionEntryPointMethodTemplate(bddAssertionEntryPointMethodTemplate);
+	                            Template hierarchicalClassAssertionTemplate,
+	                            Template abstractClassAssertionTemplate,
+	                            Template hasAssertionTemplate,
+	                            Template hasAssertionTemplateForPrimitive,
+	                            Template hasIterableElementsAssertionTemplate,
+	                            Template hasArrayElementsAssertionTemplate,
+	                            Template isAssertionTemplate,
+	                            Template entryPointAssertionsClassTemplate,
+	                            Template entryPointAssertionTemplate,
+	                            Template entryPointSoftAssertionsClassTemplate,
+	                            Template entryPointSoftAssertionTemplate,
+	                            Template bddAssertionsEntryPointClassTemplate,
+	                            Template bddAssertionEntryPointMethodTemplate,
+	                            Template hasAssertionTemplateForRealNumber) {
+
+	this.setAssertionClassTemplate(classAssertionTemplate);
+	this.setHierarchicalAssertionClassTemplate(hierarchicalClassAssertionTemplate);
+	this.setAbstractAssertionClassTemplate(abstractClassAssertionTemplate);
+	this.setHasAssertionTemplate(hasAssertionTemplate);
+	this.setHasAssertionTemplateForPrimitive(hasAssertionTemplateForPrimitive);
+	this.setHasAssertionTemplateForRealNumber(hasAssertionTemplateForRealNumber);
+	this.setHasElementsAssertionForIterableTemplate(hasIterableElementsAssertionTemplate);
+	this.setHasElementsAssertionForArrayTemplate(hasArrayElementsAssertionTemplate);
+	this.setIsAssertionTemplate(isAssertionTemplate);
+	this.setStandardAssertionsEntryPointClassTemplate(entryPointAssertionsClassTemplate);
+	this.setStandardAssertionEntryPointMethodTemplate(entryPointAssertionTemplate);
+	this.setSoftAssertionsEntryPointClassTemplate(entryPointSoftAssertionsClassTemplate);
+	this.setSoftAssertionEntryPointMethodTemplate(entryPointSoftAssertionTemplate);
+	this.setBddAssertionsEntryPointClassTemplate(bddAssertionsEntryPointClassTemplate);
+	this.setBddAssertionEntryPointMethodTemplate(bddAssertionEntryPointMethodTemplate);
   }
 
   /**
@@ -183,251 +183,250 @@ public class BaseAssertionGenerator implements AssertionGenerator, AssertionsEnt
    * @param assertionClassTemplate the {@link Template} to use for assertion class general skeleton.
    */
   public final void setAssertionClassTemplate(Template assertionClassTemplate) {
-    checkTemplateParameter(assertionClassTemplate, Template.Type.ASSERT_CLASS);
-    this.classAssertionTemplate = assertionClassTemplate;
+	checkTemplateParameter(assertionClassTemplate, Template.Type.ASSERT_CLASS);
+	this.classAssertionTemplate = assertionClassTemplate;
   }
 
   public final void setHierarchicalAssertionClassTemplate(Template hierarchicalAssertionClassTemplate) {
-    checkTemplateParameter(hierarchicalAssertionClassTemplate, Template.Type.HIERARCHICAL_ASSERT_CLASS);
-    this.hierarchicalClassAssertionTemplate = hierarchicalAssertionClassTemplate;
+	checkTemplateParameter(hierarchicalAssertionClassTemplate, Template.Type.HIERARCHICAL_ASSERT_CLASS);
+	this.hierarchicalClassAssertionTemplate = hierarchicalAssertionClassTemplate;
   }
 
   public final void setAbstractAssertionClassTemplate(Template abstractAssertionClassTemplate) {
-    checkTemplateParameter(abstractAssertionClassTemplate, Template.Type.ABSTRACT_ASSERT_CLASS);
-    this.abstractClassAssertionTemplate = abstractAssertionClassTemplate;
+	checkTemplateParameter(abstractAssertionClassTemplate, Template.Type.ABSTRACT_ASSERT_CLASS);
+	this.abstractClassAssertionTemplate = abstractAssertionClassTemplate;
   }
 
   public final void setHasAssertionTemplate(Template hasAssertionTemplate) {
-    checkTemplateParameter(hasAssertionTemplate, Template.Type.HAS);
-    this.hasAssertionTemplate = hasAssertionTemplate;
+	checkTemplateParameter(hasAssertionTemplate, Template.Type.HAS);
+	this.hasAssertionTemplate = hasAssertionTemplate;
   }
 
   public final void setHasAssertionTemplateForPrimitive(Template hasAssertionTemplateForPrimitive) {
-    checkTemplateParameter(hasAssertionTemplateForPrimitive, Template.Type.HAS_FOR_PRIMITIVE);
-    this.hasAssertionTemplateForPrimitive = hasAssertionTemplateForPrimitive;
+	checkTemplateParameter(hasAssertionTemplateForPrimitive, Template.Type.HAS_FOR_PRIMITIVE);
+	this.hasAssertionTemplateForPrimitive = hasAssertionTemplateForPrimitive;
   }
 
   public final void setHasAssertionTemplateForRealNumber(Template hasAssertionTemplateForRealNumber) {
-    checkTemplateParameter(hasAssertionTemplateForRealNumber, Template.Type.HAS_FOR_REAL_NUMBER);
-    this.hasAssertionTemplateForRealNumber = hasAssertionTemplateForRealNumber;
+	checkTemplateParameter(hasAssertionTemplateForRealNumber, Template.Type.HAS_FOR_REAL_NUMBER);
+	this.hasAssertionTemplateForRealNumber = hasAssertionTemplateForRealNumber;
   }
 
   public final void setHasElementsAssertionForIterableTemplate(Template hasIterableElementsAssertionTemplate) {
-    checkTemplateParameter(hasIterableElementsAssertionTemplate, Template.Type.HAS_FOR_ITERABLE);
-    this.hasIterableElementsAssertionTemplate = hasIterableElementsAssertionTemplate;
+	checkTemplateParameter(hasIterableElementsAssertionTemplate, Template.Type.HAS_FOR_ITERABLE);
+	this.hasIterableElementsAssertionTemplate = hasIterableElementsAssertionTemplate;
   }
 
   public final void setHasElementsAssertionForArrayTemplate(Template hasArrayElementsAssertionTemplate) {
-    checkTemplateParameter(hasArrayElementsAssertionTemplate, Template.Type.HAS_FOR_ARRAY);
-    this.hasArrayElementsAssertionTemplate = hasArrayElementsAssertionTemplate;
+	checkTemplateParameter(hasArrayElementsAssertionTemplate, Template.Type.HAS_FOR_ARRAY);
+	this.hasArrayElementsAssertionTemplate = hasArrayElementsAssertionTemplate;
   }
 
   public final void setIsAssertionTemplate(Template isAssertionTemplate) {
-    checkTemplateParameter(isAssertionTemplate, Template.Type.IS);
-    this.isAssertionTemplate = isAssertionTemplate;
+	checkTemplateParameter(isAssertionTemplate, Template.Type.IS);
+	this.isAssertionTemplate = isAssertionTemplate;
   }
 
   public void setStandardAssertionsEntryPointClassTemplate(final Template standardAssertionsEntryPointClassTemplate) {
-    checkTemplateParameter(standardAssertionsEntryPointClassTemplate, Type.ASSERTIONS_ENTRY_POINT_CLASS);
-    this.standardAssertionsEntryPointClassTemplate = standardAssertionsEntryPointClassTemplate;
+	checkTemplateParameter(standardAssertionsEntryPointClassTemplate, Type.ASSERTIONS_ENTRY_POINT_CLASS);
+	this.standardAssertionsEntryPointClassTemplate = standardAssertionsEntryPointClassTemplate;
   }
 
   public void setStandardAssertionEntryPointMethodTemplate(final Template standardAssertionEntryPointMethodTemplate) {
-    checkTemplateParameter(standardAssertionEntryPointMethodTemplate, Type.ASSERTION_ENTRY_POINT);
-    this.standardAssertionEntryPointMethodTemplate = standardAssertionEntryPointMethodTemplate;
+	checkTemplateParameter(standardAssertionEntryPointMethodTemplate, Type.ASSERTION_ENTRY_POINT);
+	this.standardAssertionEntryPointMethodTemplate = standardAssertionEntryPointMethodTemplate;
   }
 
   public void setDirectoryWhereAssertionFilesAreGenerated(String targetBaseDirectory) {
-    this.targetBaseDirectory = targetBaseDirectory;
+	this.targetBaseDirectory = targetBaseDirectory;
   }
 
   public void setSoftAssertionsEntryPointClassTemplate(final Template softAssertionsEntryPointClassTemplate) {
-    this.softAssertionsEntryPointClassTemplate = softAssertionsEntryPointClassTemplate;
+	this.softAssertionsEntryPointClassTemplate = softAssertionsEntryPointClassTemplate;
   }
 
   public void setSoftAssertionEntryPointMethodTemplate(final Template softAssertionEntryPointMethodTemplate) {
-    this.softAssertionEntryPointMethodTemplate = softAssertionEntryPointMethodTemplate;
+	this.softAssertionEntryPointMethodTemplate = softAssertionEntryPointMethodTemplate;
   }
 
   public void setBddAssertionsEntryPointClassTemplate(final Template bddAssertionsEntryPointClassTemplate) {
-    this.bddAssertionsEntryPointClassTemplate = bddAssertionsEntryPointClassTemplate;
+	this.bddAssertionsEntryPointClassTemplate = bddAssertionsEntryPointClassTemplate;
   }
 
   public void setBddAssertionEntryPointMethodTemplate(final Template bddAssertionEntryPointMethodTemplate) {
-    this.bddAssertionEntryPointMethodTemplate = bddAssertionEntryPointMethodTemplate;
+	this.bddAssertionEntryPointMethodTemplate = bddAssertionEntryPointMethodTemplate;
   }
 
   @Override
   public File generateCustomAssertionFor(ClassDescription classDescription) throws IOException {
 
-    // Assertion content
-    String assertionFileContent = generateCustomAssertionContentFor(classDescription);
-    // finally create the assertion file, located in its package directory starting from targetBaseDirectory
-    String targetDirectory = getDirectoryPathCorrespondingToPackage(classDescription.getPackageName());
-    // build any needed directories
-    new File(targetDirectory).mkdirs();
-    return createFile(assertionFileContent, assertClassNameOf(classDescription) + ".java", targetDirectory);
+	// Assertion content
+	String assertionFileContent = generateCustomAssertionContentFor(classDescription);
+	// finally create the assertion file, located in its package directory starting from targetBaseDirectory
+	String targetDirectory = getDirectoryPathCorrespondingToPackage(classDescription.getPackageName());
+	// build any needed directories
+	new File(targetDirectory).mkdirs();
+	return createFile(assertionFileContent, assertClassNameOf(classDescription) + ".java", targetDirectory);
   }
 
   @Override
   public File[] generateHierarchicalCustomAssertionFor(ClassDescription classDescription, Set<Class<?>> allClasses)
-      throws IOException {
-
-    // Assertion content
-    String[] assertionFileContent = generateHierarchicalCustomAssertionContentFor(classDescription, allClasses);
-    // finally create the assertion file, located in its package directory starting from targetBaseDirectory
-    String targetDirectory = getDirectoryPathCorrespondingToPackage(classDescription.getPackageName());
-    // build any needed directories
-    new File(targetDirectory).mkdirs();
-    File[] assertionClassesFile = new File[2];
-    final String concreteAsserClassFileName = assertClassNameOf(classDescription) + ".java";
-    final String abstractAsserClassFileName = abstractAssertClassNameOf(classDescription) + ".java";
-    assertionClassesFile[0] = createFile(assertionFileContent[0], abstractAsserClassFileName, targetDirectory);
-    assertionClassesFile[1] = createFile(assertionFileContent[1], concreteAsserClassFileName, targetDirectory);
-    return assertionClassesFile;
+	  throws IOException {
+
+	// Assertion content
+	String[] assertionFileContent = generateHierarchicalCustomAssertionContentFor(classDescription, allClasses);
+	// finally create the assertion file, located in its package directory starting from targetBaseDirectory
+	String targetDirectory = getDirectoryPathCorrespondingToPackage(classDescription.getPackageName());
+	// build any needed directories
+	new File(targetDirectory).mkdirs();
+	File[] assertionClassesFile = new File[2];
+	final String concreteAsserClassFileName = assertClassNameOf(classDescription) + ".java";
+	final String abstractAsserClassFileName = abstractAssertClassNameOf(classDescription) + ".java";
+	assertionClassesFile[0] = createFile(assertionFileContent[0], abstractAsserClassFileName, targetDirectory);
+	assertionClassesFile[1] = createFile(assertionFileContent[1], concreteAsserClassFileName, targetDirectory);
+	return assertionClassesFile;
   }
 
   @Override
   public String[] generateHierarchicalCustomAssertionContentFor(ClassDescription classDescription,
-                                                                Set<Class<?>> allClasses) {
-    // use class template first
-    StringBuilder abstractAssertClassContentBuilder = new StringBuilder(abstractClassAssertionTemplate.getContent());
+	                                                            Set<Class<?>> allClasses) {
+	// use class template first
+	StringBuilder abstractAssertClassContentBuilder = new StringBuilder(abstractClassAssertionTemplate.getContent());
 
-    // generate assertion method for each property with a public getter
-    abstractAssertClassContentBuilder.append(generateAssertionsForGetters(classDescription.getDeclaredGettersDescriptions()));
-    abstractAssertClassContentBuilder.append(generateAssertionsForPublicFields(classDescription.getDeclaredFieldsDescriptions()));
+	// generate assertion method for each property with a public getter
+	abstractAssertClassContentBuilder.append(generateAssertionsForDeclaredGettersOf(classDescription));
+	abstractAssertClassContentBuilder.append(generateAssertionsForDeclaredPublicFieldsOf(classDescription));
 
-    // close class with }
-    abstractAssertClassContentBuilder.append(LINE_SEPARATOR).append("}").append(LINE_SEPARATOR);
+	// close class with }
+	abstractAssertClassContentBuilder.append(LINE_SEPARATOR).append("}").append(LINE_SEPARATOR);
 
-    // use class template first
-    StringBuilder concreteAssertClassContentBuilder = new StringBuilder(hierarchicalClassAssertionTemplate.getContent());
+	// use class template first
+	StringBuilder concreteAssertClassContentBuilder = new StringBuilder(hierarchicalClassAssertionTemplate.getContent());
 
-    String[] assertionClassesContent = new String[2];
-    assertionClassesContent[0] = fillAssertClassTemplate(abstractAssertClassContentBuilder.toString(),
-                                                         classDescription, allClasses, false);
-    assertionClassesContent[1] = fillAssertClassTemplate(concreteAssertClassContentBuilder.toString(),
-                                                         classDescription, null, true);
-    return assertionClassesContent;
+	String[] assertionClassesContent = new String[2];
+	assertionClassesContent[0] = fillAssertClassTemplate(abstractAssertClassContentBuilder.toString(),
+	                                                     classDescription, allClasses, false);
+	assertionClassesContent[1] = fillAssertClassTemplate(concreteAssertClassContentBuilder.toString(),
+	                                                     classDescription, null, true);
+	return assertionClassesContent;
   }
 
   private String fillAssertClassTemplate(String template, ClassDescription classDescription,
-                                         Set<Class<?>> classesHierarchy, boolean concrete) {
-    // Add o.a.c.a.Assertions if needed
-    TreeSet<TypeName> imports = new TreeSet<TypeName>(classDescription.getImports());
-    if (template.contains("Assertions")) {
-      imports.add(new TypeName("org.assertj.core.api.Assertions"));
-    }
-
-    final TypeName superAssertionClass;
-    // Add assertion supertype to imports if needed
-    if (classesHierarchy == null || !classesHierarchy.contains(classDescription.getSuperType())) {
-      superAssertionClass = new TypeName("org.assertj.core.api.AbstractAssert");
-    } else {
-      final TypeName superTypeName = new TypeName(classDescription.getSuperType());
-      superAssertionClass = new TypeName(abstractAssertClassNameOf(superTypeName), superTypeName.getPackageName());
-    }
-    imports.add(superAssertionClass);
-
-    final String customAssertionClass = concrete ? assertClassNameOf(classDescription) :
-        abstractAssertClassNameOf(classDescription);
-    final String selfType = concrete ? customAssertionClass : "S";
-    final String myself = concrete ? "this" : "myself";
-
-    template = replace(template, PACKAGE, classDescription.getPackageName());
-    template = replace(template, CUSTOM_ASSERTION_CLASS, customAssertionClass);
-    // className could be a nested class like "OuterClass.NestedClass", in that case assert class will be
-    // OuterClassNestedClass
-    template = replace(template, SUPER_ASSERTION_CLASS,
-                       superAssertionClass.getSimpleNameWithOuterClassNotSeparatedByDots());
-    template = replace(template, CLASS_TO_ASSERT, classDescription.getClassNameWithOuterClass());
-    template = replace(template, SELF_TYPE, selfType);
-    template = replace(template, MYSELF, myself);
-    template = replace(template, IMPORTS, listImports(imports, classDescription.getPackageName()));
-
-    return template;
+	                                     Set<Class<?>> classesHierarchy, boolean concrete) {
+	// Add any AssertJ needed imports only, other types are used with their fully qualifed names to avoid a compilation
+	// error when two types have the same
+	TreeSet<TypeName> assertjImports = new TreeSet<TypeName>();
+	if (template.contains("Assertions")) assertjImports.add(new TypeName("org.assertj.core.api.Assertions"));
+
+	final TypeName superAssertionClass;
+	// Add assertion supertype to imports if needed
+	if (classesHierarchy == null || !classesHierarchy.contains(classDescription.getSuperType())) {
+	  superAssertionClass = new TypeName("org.assertj.core.api.AbstractAssert");
+	} else {
+	  final TypeName superTypeName = new TypeName(classDescription.getSuperType());
+	  superAssertionClass = new TypeName(abstractAssertClassNameOf(superTypeName), superTypeName.getPackageName());
+	}
+	assertjImports.add(superAssertionClass);
+
+	final String customAssertionClass = concrete ? assertClassNameOf(classDescription) :
+	    abstractAssertClassNameOf(classDescription);
+	final String selfType = concrete ? customAssertionClass : "S";
+	final String myself = concrete ? "this" : "myself";
+
+	template = replace(template, PACKAGE, classDescription.getPackageName());
+	template = replace(template, CUSTOM_ASSERTION_CLASS, customAssertionClass);
+	// className could be a nested class like "OuterClass.NestedClass", in that case assert class will be
+	// OuterClassNestedClass
+	template = replace(template, SUPER_ASSERTION_CLASS,
+	                   superAssertionClass.getSimpleNameWithOuterClassNotSeparatedByDots());
+	template = replace(template, CLASS_TO_ASSERT, classDescription.getClassNameWithOuterClass());
+	template = replace(template, SELF_TYPE, selfType);
+	template = replace(template, MYSELF, myself);
+	template = replace(template, IMPORTS, listNeededImports(assertjImports, classDescription.getPackageName()));
+
+	return template;
   }
 
   private String fillAssertClassTemplate(String template, ClassDescription classDescription) {
-    return fillAssertClassTemplate(template, classDescription, null, true);
+	return fillAssertClassTemplate(template, classDescription, null, true);
   }
 
   @Override
   public String generateCustomAssertionContentFor(ClassDescription classDescription) {
 
-    // use class template first
-    StringBuilder assertionFileContentBuilder = new StringBuilder(classAssertionTemplate.getContent());
+	// use class template first
+	StringBuilder assertionFileContentBuilder = new StringBuilder(classAssertionTemplate.getContent());
 
-    // generate assertion method for each property with a public getter
-    assertionFileContentBuilder.append(generateAssertionsForGetters(classDescription.getGettersDescriptions()));
-    assertionFileContentBuilder.append(generateAssertionsForPublicFields(classDescription.getFieldsDescriptions()));
+	// generate assertion method for each property with a public getter
+	assertionFileContentBuilder.append(generateAssertionsForGettersOf(classDescription));
+	assertionFileContentBuilder.append(generateAssertionsForPublicFieldsOf(classDescription));
 
-    // close class with }
-    assertionFileContentBuilder.append(LINE_SEPARATOR).append("}").append(LINE_SEPARATOR);
+	// close class with }
+	assertionFileContentBuilder.append(LINE_SEPARATOR).append("}").append(LINE_SEPARATOR);
 
-    return fillAssertClassTemplate(assertionFileContentBuilder.toString(), classDescription);
+	return fillAssertClassTemplate(assertionFileContentBuilder.toString(), classDescription);
   }
 
   @Override
   public String generateAssertionsEntryPointClassContentFor(final Set<ClassDescription> classDescriptionSet,
-                                                            AssertionsEntryPointType assertionsEntryPointType,
-                                                            String entryPointClassPackage) {
-    if (noClassDescriptionsGiven(classDescriptionSet)) return "";
-    Template assertionEntryPointMethodTemplate = chooseAssertionEntryPointMethodTemplate(assertionsEntryPointType);
-    Template assertionsEntryPointClassTemplate = chooseAssertionEntryPointClassTemplate(assertionsEntryPointType);
-    return generateAssertionsEntryPointClassContent(classDescriptionSet, assertionsEntryPointClassTemplate,
-                                                    assertionEntryPointMethodTemplate, entryPointClassPackage);
+	                                                        AssertionsEntryPointType assertionsEntryPointType,
+	                                                        String entryPointClassPackage) {
+	if (noClassDescriptionsGiven(classDescriptionSet)) return "";
+	Template assertionEntryPointMethodTemplate = chooseAssertionEntryPointMethodTemplate(assertionsEntryPointType);
+	Template assertionsEntryPointClassTemplate = chooseAssertionEntryPointClassTemplate(assertionsEntryPointType);
+	return generateAssertionsEntryPointClassContent(classDescriptionSet, assertionsEntryPointClassTemplate,
+	                                                assertionEntryPointMethodTemplate, entryPointClassPackage);
   }
 
   private Template chooseAssertionEntryPointMethodTemplate(final AssertionsEntryPointType assertionsEntryPointType) {
-    switch (assertionsEntryPointType) {
-    case SOFT:
-      return softAssertionEntryPointMethodTemplate;
-    case BDD:
-      return bddAssertionEntryPointMethodTemplate;
-    default:
-      return standardAssertionEntryPointMethodTemplate;
-    }
+	switch (assertionsEntryPointType) {
+	case SOFT:
+	  return softAssertionEntryPointMethodTemplate;
+	case BDD:
+	  return bddAssertionEntryPointMethodTemplate;
+	default:
+	  return standardAssertionEntryPointMethodTemplate;
+	}
   }
 
   private Template chooseAssertionEntryPointClassTemplate(final AssertionsEntryPointType assertionsEntryPointType) {
-    switch (assertionsEntryPointType) {
-    case SOFT:
-      return softAssertionsEntryPointClassTemplate;
-    case BDD:
-      return bddAssertionsEntryPointClassTemplate;
-    default:
-      return standardAssertionsEntryPointClassTemplate;
-    }
+	switch (assertionsEntryPointType) {
+	case SOFT:
+	  return softAssertionsEntryPointClassTemplate;
+	case BDD:
+	  return bddAssertionsEntryPointClassTemplate;
+	default:
+	  return standardAssertionsEntryPointClassTemplate;
+	}
   }
 
   @Override
   public File generateAssertionsEntryPointClassFor(final Set<ClassDescription> classDescriptionSet,
-                                                   AssertionsEntryPointType assertionsEntryPointType,
-                                                   String entryPointClassPackage) throws IOException {
-    if (noClassDescriptionsGiven(classDescriptionSet)) return null;
-    String assertionsEntryPointFileContent = generateAssertionsEntryPointClassContentFor(classDescriptionSet,
-                                                                                         assertionsEntryPointType,
-                                                                                         entryPointClassPackage);
-    return createAssertionsFileFor(classDescriptionSet, assertionsEntryPointFileContent,
-                                   assertionsEntryPointType.getFileName(), entryPointClassPackage);
+	                                               AssertionsEntryPointType assertionsEntryPointType,
+	                                               String entryPointClassPackage) throws IOException {
+	if (noClassDescriptionsGiven(classDescriptionSet)) return null;
+	String assertionsEntryPointFileContent = generateAssertionsEntryPointClassContentFor(classDescriptionSet,
+	                                                                                     assertionsEntryPointType,
+	                                                                                     entryPointClassPackage);
+	return createAssertionsFileFor(classDescriptionSet, assertionsEntryPointFileContent,
+	                               assertionsEntryPointType.getFileName(), entryPointClassPackage);
   }
 
   private String generateAssertionsEntryPointClassContent(final Set<ClassDescription> classDescriptionSet,
-                                                          final Template entryPointAssertionsClassTemplate,
-                                                          final Template entryPointAssertionMethodTemplate,
-                                                          String entryPointClassPackage) {
-    String entryPointAssertionsClassContent = entryPointAssertionsClassTemplate.getContent();
-    // resolve template markers
-    String classPackage = isEmpty(entryPointClassPackage) ? determineBestEntryPointsAssertionsClassPackage(classDescriptionSet)
-        : entryPointClassPackage;
-    entryPointAssertionsClassContent = replace(entryPointAssertionsClassContent, PACKAGE, classPackage);
-
-    String allEntryPointsAssertionContent = generateAssertionEntryPointMethodsFor(classDescriptionSet,
-                                                                                  entryPointAssertionMethodTemplate);
-    entryPointAssertionsClassContent = replace(entryPointAssertionsClassContent, ALL_ASSERTIONS_ENTRY_POINTS,
-                                               allEntryPointsAssertionContent);
-    return entryPointAssertionsClassContent;
+	                                                      final Template entryPointAssertionsClassTemplate,
+	                                                      final Template entryPointAssertionMethodTemplate,
+	                                                      String entryPointClassPackage) {
+	String entryPointAssertionsClassContent = entryPointAssertionsClassTemplate.getContent();
+	// resolve template markers
+	String classPackage = isEmpty(entryPointClassPackage) ? determineBestEntryPointsAssertionsClassPackage(classDescriptionSet)
+	    : entryPointClassPackage;
+	entryPointAssertionsClassContent = replace(entryPointAssertionsClassContent, PACKAGE, classPackage);
+
+	String allEntryPointsAssertionContent = generateAssertionEntryPointMethodsFor(classDescriptionSet,
+	                                                                              entryPointAssertionMethodTemplate);
+	entryPointAssertionsClassContent = replace(entryPointAssertionsClassContent, ALL_ASSERTIONS_ENTRY_POINTS,
+	                                           allEntryPointsAssertionContent);
+	return entryPointAssertionsClassContent;
   }
 
   /**
@@ -445,71 +444,71 @@ public class BaseAssertionGenerator implements AssertionGenerator, AssertionsEnt
    * @throws IOException if file can't be created.
    */
   private File createAssertionsFileFor(final Set<ClassDescription> classDescriptionSet, final String fileContent,
-                                       final String fileName, final String assertionsClassPackage) throws IOException {
-    String classPackage = isEmpty(assertionsClassPackage) ? determineBestEntryPointsAssertionsClassPackage(classDescriptionSet)
-        : assertionsClassPackage;
-    String assertionsDirectory = getDirectoryPathCorrespondingToPackage(classPackage);
-    // build any needed directories
-    new File(assertionsDirectory).mkdirs();
-    return createFile(fileContent, fileName, assertionsDirectory);
+	                                   final String fileName, final String assertionsClassPackage) throws IOException {
+	String classPackage = isEmpty(assertionsClassPackage) ? determineBestEntryPointsAssertionsClassPackage(classDescriptionSet)
+	    : assertionsClassPackage;
+	String assertionsDirectory = getDirectoryPathCorrespondingToPackage(classPackage);
+	// build any needed directories
+	new File(assertionsDirectory).mkdirs();
+	return createFile(fileContent, fileName, assertionsDirectory);
   }
 
   private String generateAssertionEntryPointMethodsFor(final Set<ClassDescription> classDescriptionSet,
-                                                       Template assertionEntryPointMethodTemplate) {
-    // sort ClassDescription according to their class name.
-    SortedSet<ClassDescription> sortedClassDescriptionSet = new TreeSet<ClassDescription>(classDescriptionSet);
-    // generate for each classDescription the entry point method, e.g. assertThat(MyClass) or then(MyClass)
-    StringBuilder allAssertThatsContentBuilder = new StringBuilder();
-    final String lineSeparator = System.getProperty("line.separator");
-    for (ClassDescription classDescription : sortedClassDescriptionSet) {
-      String assertionEntryPointMethodContent = assertionEntryPointMethodTemplate.getContent();
-      // resolve class assert (ex: PlayerAssert)
-      // in case of inner classes like Movie.PublicCategory, class assert will be MoviePublicCategoryAssert
-      assertionEntryPointMethodContent = replace(assertionEntryPointMethodContent, CUSTOM_ASSERTION_CLASS,
-                                                 fullyQualifiedAssertClassName(classDescription));
-      // resolve class (ex: Player)
-      // in case of inner classes like Movie.PublicCategory use class name with outer class i.e. Movie.PublicCategory.
-      assertionEntryPointMethodContent = replace(assertionEntryPointMethodContent, CLASS_TO_ASSERT,
-                                                 classDescription.getFullyQualifiedClassName());
-      allAssertThatsContentBuilder.append(lineSeparator).append(assertionEntryPointMethodContent);
-    }
-    return allAssertThatsContentBuilder.toString();
+	                                                   Template assertionEntryPointMethodTemplate) {
+	// sort ClassDescription according to their class name.
+	SortedSet<ClassDescription> sortedClassDescriptionSet = new TreeSet<ClassDescription>(classDescriptionSet);
+	// generate for each classDescription the entry point method, e.g. assertThat(MyClass) or then(MyClass)
+	StringBuilder allAssertThatsContentBuilder = new StringBuilder();
+	final String lineSeparator = System.getProperty("line.separator");
+	for (ClassDescription classDescription : sortedClassDescriptionSet) {
+	  String assertionEntryPointMethodContent = assertionEntryPointMethodTemplate.getContent();
+	  // resolve class assert (ex: PlayerAssert)
+	  // in case of inner classes like Movie.PublicCategory, class assert will be MoviePublicCategoryAssert
+	  assertionEntryPointMethodContent = replace(assertionEntryPointMethodContent, CUSTOM_ASSERTION_CLASS,
+		                                         fullyQualifiedAssertClassName(classDescription));
+	  // resolve class (ex: Player)
+	  // in case of inner classes like Movie.PublicCategory use class name with outer class i.e. Movie.PublicCategory.
+	  assertionEntryPointMethodContent = replace(assertionEntryPointMethodContent, CLASS_TO_ASSERT,
+		                                         classDescription.getFullyQualifiedClassName());
+	  allAssertThatsContentBuilder.append(lineSeparator).append(assertionEntryPointMethodContent);
+	}
+	return allAssertThatsContentBuilder.toString();
   }
 
   private String determineBestEntryPointsAssertionsClassPackage(final Set<ClassDescription> classDescriptionSet) {
-    SortedSet<String> packages = new TreeSet<String>(new Comparator<String>() {
-      @Override
-      public int compare(final String o1, final String o2) {
-        return o1.length() - o2.length();
-      }
-    });
-    for (ClassDescription classDescription : classDescriptionSet) {
-      packages.add(classDescription.getPackageName());
-    }
-    // takes the base package of all given classes assuming they all belong to a common package, i.e a.b.c. over a.b.c.d
-    // this can certainly be improved ...
-    return packages.first();
+	SortedSet<String> packages = new TreeSet<String>(new Comparator<String>() {
+	  @Override
+	  public int compare(final String o1, final String o2) {
+		return o1.length() - o2.length();
+	  }
+	});
+	for (ClassDescription classDescription : classDescriptionSet) {
+	  packages.add(classDescription.getPackageName());
+	}
+	// takes the base package of all given classes assuming they all belong to a common package, i.e a.b.c. over a.b.c.d
+	// this can certainly be improved ...
+	return packages.first();
   }
 
   private static String assertClassNameOf(ClassDescription classDescription) {
-    return assertClassNameOf(classDescription.getTypeName());
+	return assertClassNameOf(classDescription.getTypeName());
   }
 
   private static String assertClassNameOf(TypeName type) {
-    return type.getSimpleNameWithOuterClassNotSeparatedByDots() + ASSERT_CLASS_SUFFIX;
+	return type.getSimpleNameWithOuterClassNotSeparatedByDots() + ASSERT_CLASS_SUFFIX;
   }
 
   private static String abstractAssertClassNameOf(ClassDescription classDescription) {
-    return abstractAssertClassNameOf(classDescription.getTypeName());
+	return abstractAssertClassNameOf(classDescription.getTypeName());
   }
 
   private static String abstractAssertClassNameOf(TypeName type) {
-    return ABSTRACT_ASSERT_CLASS_PREFIX + assertClassNameOf(type);
+	return ABSTRACT_ASSERT_CLASS_PREFIX + assertClassNameOf(type);
   }
 
   private static String fullyQualifiedAssertClassName(ClassDescription classDescription) {
-    return classDescription.getPackageName() + "." + classDescription.getClassNameWithOuterClassNotSeparatedByDots()
-           + ASSERT_CLASS_SUFFIX;
+	return classDescription.getPackageName() + "." + classDescription.getClassNameWithOuterClassNotSeparatedByDots()
+	       + ASSERT_CLASS_SUFFIX;
   }
 
   /**
@@ -519,73 +518,83 @@ public class BaseAssertionGenerator implements AssertionGenerator, AssertionsEnt
    * @return the target directory path corresponding to the given package.
    */
   private String getDirectoryPathCorrespondingToPackage(final String packageName) {
-    return targetBaseDirectory + File.separator + packageName.replace('.', File.separatorChar);
+	return targetBaseDirectory + File.separator + packageName.replace('.', File.separatorChar);
   }
 
-  private static String listImports(Set<TypeName> typesToImport, String classPackage) {
-    StringBuilder importsBuilder = new StringBuilder();
-    for (TypeName type : typesToImport) {
-      if (!type.isPrimitive() && !type.belongsToJavaLangPackage() && !type.getPackageName().equals(classPackage)) {
-        importsBuilder.append(format(IMPORT_LINE, type, LINE_SEPARATOR));
-      }
-    }
-    return importsBuilder.toString();
+  private static String listNeededImports(Set<TypeName> typesToImport, String classPackage) {
+	StringBuilder importsBuilder = new StringBuilder();
+	for (TypeName type : typesToImport) {
+	  if (!type.isPrimitive() && !type.belongsToJavaLangPackage() && !type.getPackageName().equals(classPackage)) {
+		importsBuilder.append(format(IMPORT_LINE, type, LINE_SEPARATOR));
+	  }
+	}
+	return importsBuilder.toString();
   }
 
   protected String generateAssertionsForGettersOf(ClassDescription classDescription) {
-    return generateAssertionsForGetters(classDescription.getGettersDescriptions());
+	return generateAssertionsForGetters(classDescription.getGettersDescriptions(), classDescription);
   }
 
-  protected String generateAssertionsForGetters(Set<GetterDescription> getters) {
-    StringBuilder assertionsForGetters = new StringBuilder();
-    for (GetterDescription getter : getters) {
-      String assertionContent = assertionContentForProperty(getter);
-      assertionsForGetters.append(assertionContent).append(LINE_SEPARATOR);
-    }
-    return assertionsForGetters.toString();
+  protected String generateAssertionsForDeclaredGettersOf(ClassDescription classDescription) {
+	return generateAssertionsForGetters(classDescription.getDeclaredGettersDescriptions(), classDescription);
+  }
+
+  protected String generateAssertionsForGetters(Set<GetterDescription> getters, ClassDescription classDescription) {
+	StringBuilder assertionsForGetters = new StringBuilder();
+	for (GetterDescription getter : getters) {
+	  String assertionContent = assertionContentForProperty(getter, classDescription);
+	  assertionsForGetters.append(assertionContent).append(LINE_SEPARATOR);
+	}
+	return assertionsForGetters.toString();
   }
 
   protected String generateAssertionsForPublicFieldsOf(ClassDescription classDescription) {
-    return generateAssertionsForPublicFields(classDescription.getFieldsDescriptions());
+	return generateAssertionsForPublicFields(classDescription.getFieldsDescriptions(), classDescription);
+  }
+
+  protected String generateAssertionsForDeclaredPublicFieldsOf(ClassDescription classDescription) {
+	return generateAssertionsForPublicFields(classDescription.getDeclaredFieldsDescriptions(), classDescription);
   }
 
-  protected String generateAssertionsForPublicFields(Set<FieldDescription> fields) {
-    StringBuilder assertionsForPublicFields = new StringBuilder();
-    for (FieldDescription field : fields) {
-      String assertionContent = assertionContentForField(field);
-      assertionsForPublicFields.append(assertionContent).append(LINE_SEPARATOR);
-    }
-    return assertionsForPublicFields.toString();
+  protected String generateAssertionsForPublicFields(Set<FieldDescription> fields, ClassDescription classDescription) {
+	StringBuilder assertionsForPublicFields = new StringBuilder();
+	for (FieldDescription field : fields) {
+	  String assertionContent = assertionContentForField(field, classDescription);
+	  assertionsForPublicFields.append(assertionContent).append(LINE_SEPARATOR);
+	}
+	return assertionsForPublicFields.toString();
   }
 
-  private String assertionContentForField(FieldDescription field) {
-    String assertionContent = baseAssertionContentFor(field);
+  private String assertionContentForField(FieldDescription field, ClassDescription classDescription) {
+	String assertionContent = baseAssertionContentFor(field, classDescription);
 
-    // we reuse template for properties to have consistent assertions for property and field but change the way we get
-    // the value since it's a field and not a property:
-    assertionContent = assertionContent.replace("get${Property}()", "${property}")
-                                       .replace("is${Property}())", "${property})");
-    // - remove also ${throws} and ${throws_javadoc} since it does not make any sense for a field
-    assertionContent = remove(assertionContent, "${throws}");
-    assertionContent = remove(assertionContent, "${throws_javadoc}");
+	// we reuse template for properties to have consistent assertions for property and field but change the way we get
+	// the value since it's a field and not a property:
+	assertionContent = assertionContent.replace("get${Property}()", "${property}")
+	                                   .replace("is${Property}())", "${property})");
+	// - remove also ${throws} and ${throws_javadoc} since it does not make any sense for a field
+	assertionContent = remove(assertionContent, "${throws}");
+	assertionContent = remove(assertionContent, "${throws_javadoc}");
 
-    // replace ${Property} and ${property} by field name (starting with uppercase/lowercase)
-    assertionContent = replace(assertionContent, PROPERTY_WITH_UPPERCASE_FIRST_CHAR, capitalize(field.getName()));
-    assertionContent = replace(assertionContent, PROPERTY_TYPE, field.getTypeName());
-    assertionContent = replace(assertionContent, PROPERTY_WITH_LOWERCASE_FIRST_CHAR, field.getName());
-    return assertionContent;
+	// replace ${Property} and ${property} by field name (starting with uppercase/lowercase)
+	assertionContent = replace(assertionContent, PROPERTY_WITH_UPPERCASE_FIRST_CHAR, capitalize(field.getName()));
+	assertionContent = replace(assertionContent, PROPERTY_TYPE,
+	                           field.getFullyQualifiedTypeNameIfNeeded(classDescription.getPackageName()));
+	assertionContent = replace(assertionContent, PROPERTY_WITH_LOWERCASE_FIRST_CHAR, field.getName());
+	return assertionContent;
   }
 
-  private String assertionContentForProperty(GetterDescription getter) {
-    String assertionContent = baseAssertionContentFor(getter);
+  private String assertionContentForProperty(GetterDescription getter, ClassDescription classDescription) {
+	String assertionContent = baseAssertionContentFor(getter, classDescription);
 
-    assertionContent = declareExceptions(getter, assertionContent);
+	assertionContent = declareExceptions(getter, assertionContent, classDescription);
 
-    String propertyName = getter.getPropertyName();
-    assertionContent = replace(assertionContent, PROPERTY_WITH_UPPERCASE_FIRST_CHAR, capitalize(propertyName));
-    assertionContent = replace(assertionContent, PROPERTY_TYPE, getter.getTypeName());
-    assertionContent = replace(assertionContent, PROPERTY_WITH_LOWERCASE_FIRST_CHAR, propertyName);
-    return assertionContent;
+	String propertyName = getter.getPropertyName();
+	assertionContent = replace(assertionContent, PROPERTY_WITH_UPPERCASE_FIRST_CHAR, capitalize(propertyName));
+	assertionContent = replace(assertionContent, PROPERTY_TYPE,
+	                           getter.getFullyQualifiedTypeNameIfNeeded(classDescription.getPackageName()));
+	assertionContent = replace(assertionContent, PROPERTY_WITH_LOWERCASE_FIRST_CHAR, propertyName);
+	return assertionContent;
   }
 
   /**
@@ -595,22 +604,22 @@ public class BaseAssertionGenerator implements AssertionGenerator, AssertionsEnt
    * @param fieldOrProperty
    * @return the base assertion content
    */
-  private String baseAssertionContentFor(DataDescription fieldOrProperty) {
-    String assertionContent = hasAssertionTemplate.getContent();
-    if (fieldOrProperty.isBooleanType()) {
-      assertionContent = isAssertionTemplate.getContent();
-    } else if (fieldOrProperty.isIterableType()) {
-      assertionContent = replace(hasIterableElementsAssertionTemplate.getContent(), ELEMENT_TYPE,
-                                 fieldOrProperty.getElementTypeName());
-    } else if (fieldOrProperty.isArrayType()) {
-      assertionContent = replace(hasArrayElementsAssertionTemplate.getContent(), ELEMENT_TYPE,
-                                 fieldOrProperty.getElementTypeName());
-    } else if (fieldOrProperty.isRealNumberType()) {
-      assertionContent = hasAssertionTemplateForRealNumber.getContent();
-    } else if (fieldOrProperty.isPrimitiveType()) {
-      assertionContent = hasAssertionTemplateForPrimitive.getContent();
-    }
-    return assertionContent;
+  private String baseAssertionContentFor(DataDescription fieldOrProperty, ClassDescription classDescription) {
+	String assertionContent = hasAssertionTemplate.getContent();
+	if (fieldOrProperty.isBooleanType()) {
+	  assertionContent = isAssertionTemplate.getContent();
+	} else if (fieldOrProperty.isIterableType()) {
+	  assertionContent = replace(hasIterableElementsAssertionTemplate.getContent(), ELEMENT_TYPE,
+		                         fieldOrProperty.getElementTypeName(classDescription.getPackageName()));
+	} else if (fieldOrProperty.isArrayType()) {
+	  assertionContent = replace(hasArrayElementsAssertionTemplate.getContent(), ELEMENT_TYPE,
+		                         fieldOrProperty.getElementTypeName(classDescription.getPackageName()));
+	} else if (fieldOrProperty.isRealNumberType()) {
+	  assertionContent = hasAssertionTemplateForRealNumber.getContent();
+	} else if (fieldOrProperty.isPrimitiveType()) {
+	  assertionContent = hasAssertionTemplateForPrimitive.getContent();
+	}
+	return assertionContent;
   }
 
   /**
@@ -618,66 +627,62 @@ public class BaseAssertionGenerator implements AssertionGenerator, AssertionsEnt
    *
    * @param getter
    * @param assertionContent
+   * @param classDescription
    * @return
    */
-  private String declareExceptions(GetterDescription getter, String assertionContent) {
-    StringBuilder throwsClause = new StringBuilder();
-    StringBuilder throwsJavaDoc = new StringBuilder();
-    boolean first = true;
-    for (TypeName exception : getter.getExceptions()) {
-      if (first) {
-        throwsClause.append("throws ");
-      } else {
-        throwsClause.append(", ");
-      }
-      first = false;
-      String exceptionName = exception.getSimpleNameWithOuterClass();
-      throwsClause.append(exceptionName);
-      throwsJavaDoc.append(LINE_SEPARATOR).append("   * @throws ").append(exceptionName);
-      throwsJavaDoc.append(" if actual.").append(getter.isBooleanType() ? "is" : "get")
-                   .append("${Property}() throws one.");
-    }
-    if (!getter.getExceptions().isEmpty()) {
-      throwsClause.append(' ');
-    }
-
-    assertionContent = assertionContent.replace(THROWS_JAVADOC, throwsJavaDoc.toString());
-    assertionContent = assertionContent.replace(THROWS, throwsClause.toString());
-    return assertionContent;
+  private String declareExceptions(GetterDescription getter, String assertionContent, ClassDescription classDescription) {
+	StringBuilder throwsClause = new StringBuilder();
+	StringBuilder throwsJavaDoc = new StringBuilder();
+	boolean first = true;
+	for (TypeName exception : getter.getExceptions()) {
+	  if (first) throwsClause.append("throws ");
+	  else throwsClause.append(", ");
+	  first = false;
+	  String exceptionName = exception.getFullyQualifiedTypeNameIfNeeded(classDescription.getPackageName());
+	  throwsClause.append(exceptionName);
+	  throwsJavaDoc.append(LINE_SEPARATOR).append("   * @throws ").append(exceptionName);
+	  throwsJavaDoc.append(" if actual.").append(getter.isBooleanType() ? "is" : "get")
+		           .append("${Property}() throws one.");
+	}
+	if (!getter.getExceptions().isEmpty()) throwsClause.append(' ');
+
+	assertionContent = assertionContent.replace(THROWS_JAVADOC, throwsJavaDoc.toString());
+	assertionContent = assertionContent.replace(THROWS, throwsClause.toString());
+	return assertionContent;
   }
 
   private void fillFile(String customAssertionContent, File assertionJavaFile) throws IOException {
-    FileWriter fileWriter = null;
-    try {
-      fileWriter = new FileWriter(assertionJavaFile);
-      fileWriter.write(customAssertionContent);
-    } finally {
-      closeQuietly(fileWriter);
-    }
+	FileWriter fileWriter = null;
+	try {
+	  fileWriter = new FileWriter(assertionJavaFile);
+	  fileWriter.write(customAssertionContent);
+	} finally {
+	  closeQuietly(fileWriter);
+	}
   }
 
   private File createFile(String fileContent, String fileName, String targetDirectory) throws IOException {
-    File file = new File(targetDirectory, fileName);
-    file.createNewFile();
-    fillFile(fileContent, file);
-    return file;
+	File file = new File(targetDirectory, fileName);
+	file.createNewFile();
+	fillFile(fileContent, file);
+	return file;
   }
 
   private static void checkTemplateParameter(Template assertionClassTemplate, Type templateType) {
-    if (assertionClassTemplate == null) {
-      throw new NullPointerException("Expecting a non null Template");
-    }
-    if (templateType != assertionClassTemplate.getType()) {
-      throw new IllegalArgumentException("Expecting a Template type to be '" + templateType + "' but was '"
-                                         + assertionClassTemplate.getType() + "'");
-    }
-    if (assertionClassTemplate.getContent() == null) {
-      throw new NullPointerException("Expecting a non null content in the Template");
-    }
+	if (assertionClassTemplate == null) {
+	  throw new NullPointerException("Expecting a non null Template");
+	}
+	if (templateType != assertionClassTemplate.getType()) {
+	  throw new IllegalArgumentException("Expecting a Template type to be '" + templateType + "' but was '"
+		                                 + assertionClassTemplate.getType() + "'");
+	}
+	if (assertionClassTemplate.getContent() == null) {
+	  throw new NullPointerException("Expecting a non null content in the Template");
+	}
   }
 
   private static boolean noClassDescriptionsGiven(final Set<ClassDescription> classDescriptionSet) {
-    return classDescriptionSet == null || classDescriptionSet.isEmpty();
+	return classDescriptionSet == null || classDescriptionSet.isEmpty();
   }
 
 }
diff --git a/src/main/java/org/assertj/assertions/generator/description/ClassDescription.java b/src/main/java/org/assertj/assertions/generator/description/ClassDescription.java
index d701673..98a64dc 100644
--- a/src/main/java/org/assertj/assertions/generator/description/ClassDescription.java
+++ b/src/main/java/org/assertj/assertions/generator/description/ClassDescription.java
@@ -25,7 +25,6 @@ import java.util.TreeSet;
  */
 public class ClassDescription implements Comparable<ClassDescription> {
 
-  private Set<TypeName> typesToImports;
   private Set<GetterDescription> gettersDescriptions;
   private Set<FieldDescription> fieldsDescriptions;
   private Set<GetterDescription> declaredGettersDescriptions;
@@ -36,7 +35,6 @@ public class ClassDescription implements Comparable<ClassDescription> {
   public ClassDescription(TypeName typeName) {
     super();
     this.classTypeName = typeName;
-    this.typesToImports = new TreeSet<TypeName>();
     this.gettersDescriptions = new TreeSet<GetterDescription>();
     this.fieldsDescriptions = new TreeSet<FieldDescription>();
     this.declaredGettersDescriptions = new TreeSet<GetterDescription>();
@@ -67,18 +65,6 @@ public class ClassDescription implements Comparable<ClassDescription> {
     return classTypeName.getPackageName();
   }
 
-  /**
-   * Return the type to import for the corresponding assertions class
-   * @return
-   */
-  public Set<TypeName> getImports() {
-    return typesToImports;
-  }
-
-  public void addTypeToImport(Collection<TypeName> typesToImport) {
-    this.typesToImports.addAll(typesToImport);
-  }
-
   public Set<GetterDescription> getGettersDescriptions() {
     return gettersDescriptions;
   }
@@ -113,7 +99,7 @@ public class ClassDescription implements Comparable<ClassDescription> {
   
   @Override
   public String toString() {
-    return "ClassDescription [classTypeName=" + classTypeName + ", typesToImports=" + typesToImports + "]";
+    return "ClassDescription [classTypeName=" + classTypeName + "]";
   }
 
   @Override
diff --git a/src/main/java/org/assertj/assertions/generator/description/DataDescription.java b/src/main/java/org/assertj/assertions/generator/description/DataDescription.java
index 09c902b..d612c0d 100644
--- a/src/main/java/org/assertj/assertions/generator/description/DataDescription.java
+++ b/src/main/java/org/assertj/assertions/generator/description/DataDescription.java
@@ -21,41 +21,54 @@ public abstract class DataDescription {
   protected final TypeDescription typeDescription;
 
   public DataDescription(String name, TypeDescription typeDescription) {
-    super();
-    this.name = name;
-    this.typeDescription = typeDescription;
+	super();
+	this.name = name;
+	this.typeDescription = typeDescription;
   }
 
   public String getName() {
-    return name;
+	return name;
   }
 
   public String getTypeName() {
-    return typeDescription.getSimpleNameWithOuterClass();
+	return typeDescription.getSimpleNameWithOuterClass();
   }
 
   public boolean isIterableType() {
-    return typeDescription.isIterable();
+	return typeDescription.isIterable();
   }
 
   public boolean isArrayType() {
-    return typeDescription.isArray();
+	return typeDescription.isArray();
   }
 
   public boolean isPrimitiveType() {
-    return typeDescription.isPrimitive();
+	return typeDescription.isPrimitive();
   }
 
   public boolean isRealNumberType() {
-    return typeDescription.isRealNumber();
+	return typeDescription.isRealNumber();
   }
 
   public boolean isBooleanType() {
-    return typeDescription.isBoolean();
+	return typeDescription.isBoolean();
   }
 
-  public String getElementTypeName() {
-    return typeDescription.getElementTypeName() == null ? null : typeDescription.getElementTypeName().getSimpleNameWithOuterClass();
+  /**
+   * return the simple element type name if etement type belongs to given the package and the fully qualified element
+   * type name ortherwise.
+   * 
+   * @param packageName typically the package of the enclosing Class
+   * @return the simple element type name if etement type belongs to given the package and the fully qualified element
+   * type name ortherwise.
+   */
+  public String getElementTypeName(String packageName) {
+	return typeDescription.getElementTypeName() == null ? null
+	    : typeDescription.getElementTypeName().getFullyQualifiedTypeNameIfNeeded(packageName);
+  }
+
+  public String getFullyQualifiedTypeNameIfNeeded(String packageName) {
+	return typeDescription.getFullyQualifiedTypeNameIfNeeded(packageName);
   }
 
 }
\ No newline at end of file
diff --git a/src/main/java/org/assertj/assertions/generator/description/FieldDescription.java b/src/main/java/org/assertj/assertions/generator/description/FieldDescription.java
index a8e196a..4f4630c 100644
--- a/src/main/java/org/assertj/assertions/generator/description/FieldDescription.java
+++ b/src/main/java/org/assertj/assertions/generator/description/FieldDescription.java
@@ -46,4 +46,5 @@ public class FieldDescription extends DataDescription implements Comparable<Fiel
   public String toString() {
     return "FieldDescription[name=" + getName() + ", typeDescription=" + typeDescription + "]";
   }
+
 }
diff --git a/src/main/java/org/assertj/assertions/generator/description/TypeDescription.java b/src/main/java/org/assertj/assertions/generator/description/TypeDescription.java
index 6aefbd4..1a82e0e 100644
--- a/src/main/java/org/assertj/assertions/generator/description/TypeDescription.java
+++ b/src/main/java/org/assertj/assertions/generator/description/TypeDescription.java
@@ -50,58 +50,62 @@ public class TypeDescription {
   private TypeName elementTypeName;
 
   public TypeDescription(TypeName typeName) {
-    super();
-    if (typeName == null) throw new IllegalArgumentException("typeName must not be null.");
-    this.typeName = typeName;
-    this.isArray = false;
-    this.isIterable = false;
-    this.elementTypeName = null;
+	super();
+	if (typeName == null) throw new IllegalArgumentException("typeName must not be null.");
+	this.typeName = typeName;
+	this.isArray = false;
+	this.isIterable = false;
+	this.elementTypeName = null;
   }
 
   public String getSimpleNameWithOuterClass() {
-    return typeName.getSimpleNameWithOuterClass();
+	return typeName.getSimpleNameWithOuterClass();
   }
 
   public boolean isArray() {
-    return isArray;
+	return isArray;
   }
 
   public void setArray(boolean isArray) {
-    this.isArray = isArray;
+	this.isArray = isArray;
   }
 
   public boolean isPrimitive() {
-    return typeName.isPrimitive();
+	return typeName.isPrimitive();
   }
 
   public boolean isRealNumber() {
-    return typeName.isRealNumber();
+	return typeName.isRealNumber();
   }
 
   public boolean isBoolean() {
-    return typeName.isBoolean();
+	return typeName.isBoolean();
   }
 
   public TypeName getElementTypeName() {
-    return elementTypeName;
+	return elementTypeName;
   }
 
   public void setElementTypeName(TypeName elementTypeName) {
-    this.elementTypeName = elementTypeName;
+	this.elementTypeName = elementTypeName;
   }
 
   public boolean isIterable() {
-    return isIterable;
+	return isIterable;
   }
 
   public void setIterable(boolean isIterable) {
-    this.isIterable = isIterable;
+	this.isIterable = isIterable;
   }
 
   @Override
   public String toString() {
-    return "TypeDescription[typeName=" + typeName + ", array=" + isArray + ", iterable=" + isIterable + ", primitive="
-           + isPrimitive() + ", boolean=" + isBoolean() + ", elementTypeName=" + elementTypeName + "]";
+	return "TypeDescription[typeName=" + typeName + ", array=" + isArray + ", iterable=" + isIterable + ", primitive="
+	       + isPrimitive() + ", boolean=" + isBoolean() + ", elementTypeName=" + elementTypeName + "]";
+  }
+
+  public String getFullyQualifiedTypeNameIfNeeded(String packageName) {
+	return typeName.getFullyQualifiedTypeNameIfNeeded(packageName);
   }
 
 }
diff --git a/src/main/java/org/assertj/assertions/generator/description/TypeName.java b/src/main/java/org/assertj/assertions/generator/description/TypeName.java
index 56183c1..bafc261 100644
--- a/src/main/java/org/assertj/assertions/generator/description/TypeName.java
+++ b/src/main/java/org/assertj/assertions/generator/description/TypeName.java
@@ -12,6 +12,7 @@
  */
 package org.assertj.assertions.generator.description;
 
+import static com.google.common.base.Objects.equal;
 import static org.apache.commons.lang3.ArrayUtils.contains;
 import static org.apache.commons.lang3.StringUtils.indexOfAny;
 import static org.apache.commons.lang3.StringUtils.isBlank;
@@ -176,4 +177,9 @@ public class TypeName implements Comparable<TypeName> {
   public String getFullyQualifiedClassName() {
     return isEmpty(packageName) ? typeSimpleNameWithOuterClass : packageName + "." + typeSimpleNameWithOuterClass;
   }
+  
+  public String getFullyQualifiedTypeNameIfNeeded(String targetPackage) {
+	return belongsToJavaLangPackage() || equal(targetPackage, packageName) ? getSimpleNameWithOuterClass() : getFullyQualifiedClassName();
+  }
+  
 }
diff --git a/src/main/java/org/assertj/assertions/generator/description/converter/ClassToClassDescriptionConverter.java b/src/main/java/org/assertj/assertions/generator/description/converter/ClassToClassDescriptionConverter.java
index cad7079..abd57c4 100644
--- a/src/main/java/org/assertj/assertions/generator/description/converter/ClassToClassDescriptionConverter.java
+++ b/src/main/java/org/assertj/assertions/generator/description/converter/ClassToClassDescriptionConverter.java
@@ -12,11 +12,9 @@
  */
 package org.assertj.assertions.generator.description.converter;
 
-import static org.assertj.assertions.generator.description.TypeName.JAVA_LANG_PACKAGE;
+import static org.apache.commons.lang3.StringUtils.remove;
 import static org.assertj.assertions.generator.util.ClassUtil.declaredGetterMethodsOf;
 import static org.assertj.assertions.generator.util.ClassUtil.declaredPublicFieldsOf;
-import static org.assertj.assertions.generator.util.ClassUtil.getClassesRelatedTo;
-import static org.assertj.assertions.generator.util.ClassUtil.getterMethodsAndNonStaticPublicFieldsOf;
 import static org.assertj.assertions.generator.util.ClassUtil.getterMethodsOf;
 import static org.assertj.assertions.generator.util.ClassUtil.inheritsCollectionOrIsIterable;
 import static org.assertj.assertions.generator.util.ClassUtil.isArray;
@@ -29,8 +27,6 @@ import java.lang.reflect.Member;
 import java.lang.reflect.Method;
 import java.lang.reflect.ParameterizedType;
 import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 import java.util.TreeSet;
@@ -52,7 +48,6 @@ public class ClassToClassDescriptionConverter implements ClassDescriptionConvert
 	classDescription.addFieldDescriptions(fieldDescriptionsOf(clazz));
 	classDescription.addDeclaredGetterDescriptions(declaredGetterDescriptionsOf(clazz));
 	classDescription.addDeclaredFieldDescriptions(declaredFieldDescriptionsOf(clazz));
-	classDescription.addTypeToImport(getNeededImportsFor(clazz));
 	classDescription.setSuperType(clazz.getSuperclass());
 	return classDescription;
   }
@@ -138,7 +133,8 @@ public class ClassToClassDescriptionConverter implements ClassDescriptionConvert
 	// java 7 is not able to detect GenericArrayType correctly => let's use a different way to detect array
 	Class<?> internalClass = ClassUtil.getClass(parameterizedType.getActualTypeArguments()[0]);
 	if (internalClass.isArray()) {
-	  typeDescription.setElementTypeName(new TypeName(internalClass.getComponentType() + "[]"));
+	  String componentTypeWithoutClassPrefix =  remove(internalClass.getComponentType().toString(), "class ");
+	  typeDescription.setElementTypeName(new TypeName(componentTypeWithoutClassPrefix + "[]"));
 	} else {
 	  typeDescription.setElementTypeName(new TypeName(internalClass));
 	}
@@ -147,7 +143,7 @@ public class ClassToClassDescriptionConverter implements ClassDescriptionConvert
 
   private static boolean methodReturnTypeHasNoParameterInfo(Member member) {
 	// java loose generic info if getter is overriden :(
-	return member instanceof Method && ((Method) member).getGenericReturnType() instanceof Class;
+	return member instanceof Method && !(((Method) member).getGenericReturnType() instanceof ParameterizedType);
   }
 
   private static Class<?> getTypeOf(Member member) {
@@ -162,17 +158,6 @@ public class ClassToClassDescriptionConverter implements ClassDescriptionConvert
 	throw new IllegalArgumentException("argument should be a Method or Field but was " + member.getClass());
   }
 
-  private static boolean hasParameterizedType(Member member) {
-	if (member instanceof Method) return ((Method) member).getGenericReturnType() instanceof ParameterizedType;
-	if (member instanceof Field) return ((Field) member).getGenericType() instanceof ParameterizedType;
-	throw new IllegalArgumentException("argument should be a Method or Field but was " + member.getClass());
-  }
-
-  private static Class<?>[] getExceptionTypesOf(Member member) {
-	if (member instanceof Method) return ((Method) member).getExceptionTypes();
-	return new Class<?>[0];
-  }
-
   private static TypeDescription buildArrayTypeDescription(final Class<?> arrayType) {
 	final TypeDescription typeDescription = new TypeDescription(new TypeName(arrayType));
 	typeDescription.setElementTypeName(new TypeName(arrayType.getComponentType()));
@@ -180,83 +165,4 @@ public class ClassToClassDescriptionConverter implements ClassDescriptionConvert
 	return typeDescription;
   }
 
-  /**
-   * return the import needed for the assertion class corresponding to given class
-   * 
-   * @param clazz
-   * @return
-   */
-  private Set<TypeName> getNeededImportsFor(Class<?> clazz) {
-	// collect property types
-	Set<Class<?>> classesToImport = new HashSet<Class<?>>();
-	for (Member member : getterMethodsAndNonStaticPublicFieldsOf(clazz)) {
-	  Class<?> propertyType = getTypeOf(member);
-	  if (isArray(propertyType)) {
-		// we only need the component type, that is T in T[] array
-		classesToImport.add(propertyType.getComponentType());
-	  } else if (inheritsCollectionOrIsIterable(propertyType)) {
-		// no generic parameter info = nothing to import
-		if (methodReturnTypeHasNoParameterInfo(member)) continue; 
-		// we need the Iterable parameter type, that is T in Iterable<T>
-		// we don't need to import the Iterable since it does not appear directly in generated code, ex :
-		// assertThat(actual.getTeamMates()).contains(teamMates); // teamMates -> List
-		ParameterizedType parameterizedType = getParameterizedTypeOf(member);
-		if (parameterizedType.getActualTypeArguments()[0] instanceof GenericArrayType) {
-		  //
-		  GenericArrayType genericArrayType = (GenericArrayType) parameterizedType.getActualTypeArguments()[0];
-		  Class<?> parameterClass = ClassUtil.getClass(genericArrayType.getGenericComponentType());
-		  classesToImport.add(parameterClass);
-		} else {
-		  // Due to http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=7151486, try to change if java 7 and a real array
-		  Class<?> internalClass = ClassUtil.getClass(parameterizedType.getActualTypeArguments()[0]);
-		  if (internalClass.isArray()) {
-			classesToImport.add(internalClass.getComponentType());
-		  } else {
-			classesToImport.add(internalClass);
-		  }
-		}
-	  } else if (hasParameterizedType(member)) {
-		// return type is generic type, add it and all its parameters type.
-		classesToImport.addAll(getClassesRelatedTo(getParameterizedTypeOf(member)));
-	  } else {
-		// return type is not generic type, simply add it.
-		classesToImport.add(propertyType);
-	  }
-	  Collections.addAll(classesToImport, getExceptionTypesOf(member));
-	}
-	// convert to TypeName, excluding primitive or types in java.lang that don't need to be imported.
-	Set<TypeName> typeNamesToImport = resolveTypesToImport(classesToImport);
-	// remove typenames belonging to the given class package, they don't need to be imported since assertion class will
-	// be in that package
-	return removeTypeNamesInPackage(typeNamesToImport, clazz.getPackage().getName());
-  }
-
-  private Set<TypeName> removeTypeNamesInPackage(Set<TypeName> typeNamesToImport, String packageName) {
-	Set<TypeName> filteredTypeNames = new TreeSet<TypeName>();
-	for (TypeName typeName : typeNamesToImport) {
-	  if (!typeName.getPackageName().equals(packageName)) filteredTypeNames.add(typeName);
-	}
-	return filteredTypeNames;
-  }
-
-  private Set<TypeName> resolveTypesToImport(Set<Class<?>> classesToImport) {
-	Set<TypeName> typeToImports = new TreeSet<TypeName>();
-	for (Class<?> propertyType : classesToImport) {
-	  TypeName typeName = resolveType(propertyType);
-	  if (typeName != null) typeToImports.add(typeName);
-	}
-	return typeToImports;
-  }
-
-  private TypeName resolveType(Class<?> propertyType) {
-	// recursive call for array of arrays
-	if (propertyType.isArray()) return resolveType(propertyType.getComponentType());
-	return shouldBeImported(propertyType) ? new TypeName(propertyType) : null;
-  }
-
-  private boolean shouldBeImported(Class<?> type) {
-	// Package can be null in case of array of primitive.
-	return !(type.isPrimitive() || type.getPackage() == null || JAVA_LANG_PACKAGE.equals(type.getPackage().getName()));
-  }
-
 }
diff --git a/src/main/java/org/assertj/assertions/generator/util/ClassUtil.java b/src/main/java/org/assertj/assertions/generator/util/ClassUtil.java
index a4c65b6..b3b813b 100644
--- a/src/main/java/org/assertj/assertions/generator/util/ClassUtil.java
+++ b/src/main/java/org/assertj/assertions/generator/util/ClassUtil.java
@@ -24,7 +24,6 @@ import java.io.UnsupportedEncodingException;
 import java.lang.reflect.Array;
 import java.lang.reflect.Field;
 import java.lang.reflect.GenericArrayType;
-import java.lang.reflect.Member;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.lang.reflect.ParameterizedType;
@@ -322,15 +321,6 @@ public class ClassUtil {
     return nonStaticPublicFields;
   }
 
-
-  public static List<Member> getterMethodsAndNonStaticPublicFieldsOf(Class<?> clazz) {
-    List<Member> methodsAndNonStaticPublicFields = new ArrayList<Member>();
-    methodsAndNonStaticPublicFields.addAll(getterMethodsOf(clazz));
-    methodsAndNonStaticPublicFields.addAll(nonStaticPublicFieldsOf(clazz));
-    return methodsAndNonStaticPublicFields;
-  }
-  
-  
   public static List<Field> declaredPublicFieldsOf(Class<?> clazz) {
     Field[] fields = clazz.getDeclaredFields();
     List<Field> nonStaticPublicFields = new ArrayList<Field>();
diff --git a/src/test/java/org/assertj/assertions/generator/AssertionGeneratorTest.java b/src/test/java/org/assertj/assertions/generator/AssertionGeneratorTest.java
index 0a0e6c9..396ad7f 100644
--- a/src/test/java/org/assertj/assertions/generator/AssertionGeneratorTest.java
+++ b/src/test/java/org/assertj/assertions/generator/AssertionGeneratorTest.java
@@ -51,174 +51,189 @@ public class AssertionGeneratorTest implements NestedClassesTest, BeanWithExcept
   private static final Logger logger = LoggerFactory.getLogger(AssertionGeneratorTest.class);
   private ClassToClassDescriptionConverter converter;
   private AssertionGenerator assertionGenerator;
-  private static final Set<Class<?>> allClasses = newHashSet(new Class<?>[] {Movie.class, ArtWork.class});
-  
+  private static final Set<Class<?>> allClasses = newHashSet(new Class<?>[] { Movie.class, ArtWork.class });
+
   @Before
   public void beforeEachTest() throws IOException {
-    converter = new ClassToClassDescriptionConverter();
-    assertionGenerator = buildAssertionGenerator();
+	converter = new ClassToClassDescriptionConverter();
+	assertionGenerator = buildAssertionGenerator();
   }
 
   public AssertionGenerator buildAssertionGenerator() throws IOException {
-    BaseAssertionGenerator assertionGenerator = new BaseAssertionGenerator();
-    assertionGenerator.setDirectoryWhereAssertionFilesAreGenerated(TARGET_DIRECTORY);
-    return assertionGenerator;
+	BaseAssertionGenerator assertionGenerator = new BaseAssertionGenerator();
+	assertionGenerator.setDirectoryWhereAssertionFilesAreGenerated(TARGET_DIRECTORY);
+	return assertionGenerator;
   }
 
   @Test
   public void should_generate_assertion_for_player_class() throws Exception {
-    assertionGenerator.generateCustomAssertionFor(converter.convertToClassDescription(Player.class));
-    assertThat(fileGeneratedFor(Player.class)).hasContentEqualTo(
-        new File("src/test/resources/PlayerAssert.expected.txt").getAbsoluteFile());
+	assertionGenerator.generateCustomAssertionFor(converter.convertToClassDescription(Player.class));
+	assertGeneratedAssertClass(Player.class, "PlayerAssert.expected.txt");
   }
-  
+
   @Test
   public void should_generate_assertion_for_interface() throws Exception {
-    assertionGenerator.generateCustomAssertionFor(converter.convertToClassDescription(PlayerAgent.class));
-    assertThat(fileGeneratedFor(PlayerAgent.class)).hasContentEqualTo(
-               new File("src/test/resources/PlayerAgentAssert.expected.txt").getAbsoluteFile());
+	assertionGenerator.generateCustomAssertionFor(converter.convertToClassDescription(PlayerAgent.class));
+	assertGeneratedAssertClass(PlayerAgent.class, "PlayerAgentAssert.expected.txt");
   }
-  
+
   @Test
   public void should_generate_assertion_for_class_with_public_fields() throws Exception {
-    assertionGenerator.generateCustomAssertionFor(converter.convertToClassDescription(Team.class));
-    assertThat(fileGeneratedFor(Team.class)).hasContentEqualTo(new File("src/test/resources/TeamAssert.expected.txt").getAbsoluteFile());
+	assertionGenerator.generateCustomAssertionFor(converter.convertToClassDescription(Team.class));
+	assertGeneratedAssertClass(Team.class, "TeamAssert.expected.txt");
   }
 
   @Test
   public void should_generate_flat_assertion_for_movie_class() throws Exception {
-    abstractFileGeneratedFor(Movie.class).delete();
-    assertionGenerator.generateCustomAssertionFor(converter.convertToClassDescription(Movie.class));
-    assertThat(fileGeneratedFor(Movie.class)).hasContentEqualTo(
-        new File("src/test/resources/MovieAssert.flat.expected.txt").getAbsoluteFile());
-    assertThat(abstractFileGeneratedFor(Movie.class)).doesNotExist();
+	abstractFileGeneratedFor(Movie.class).delete();
+	assertionGenerator.generateCustomAssertionFor(converter.convertToClassDescription(Movie.class));
+	assertGeneratedAssertClass(Movie.class, "MovieAssert.flat.expected.txt");
+	assertThat(abstractFileGeneratedFor(Movie.class)).doesNotExist();
   }
 
   @Test
   public void should_generate_hierarchical_assertion_for_movie_class() throws Exception {
-    assertionGenerator.generateHierarchicalCustomAssertionFor(converter.convertToClassDescription(Movie.class), allClasses);
-    assertThat(fileGeneratedFor(Movie.class)).hasContentEqualTo(
-        new File("src/test/resources/MovieAssert.expected.txt").getAbsoluteFile());
-    assertThat(abstractFileGeneratedFor(Movie.class)).hasContentEqualTo(
-        new File("src/test/resources/AbstractMovieAssert.expected.txt").getAbsoluteFile());
+	assertionGenerator.generateHierarchicalCustomAssertionFor(converter.convertToClassDescription(Movie.class),
+	                                                          allClasses);
+	assertGeneratedAssertClass(Movie.class, "MovieAssert.expected.txt");
+	assertAbstractGeneratedAssertClass(Movie.class, "AbstractMovieAssert.expected.txt");
   }
 
   @Test
   public void should_generate_hierarchical_assertion_for_artwork_class() throws Exception {
-    assertionGenerator.generateHierarchicalCustomAssertionFor(converter.convertToClassDescription(ArtWork.class), allClasses);
-    assertThat(fileGeneratedFor(ArtWork.class)).hasContentEqualTo(
-        new File("src/test/resources/ArtWorkAssert.expected.txt").getAbsoluteFile());
-    assertThat(abstractFileGeneratedFor(ArtWork.class)).hasContentEqualTo(
-        new File("src/test/resources/AbstractArtWorkAssert.expected.txt").getAbsoluteFile());
+	assertionGenerator.generateHierarchicalCustomAssertionFor(converter.convertToClassDescription(ArtWork.class),
+	                                                          allClasses);
+	assertGeneratedAssertClass(ArtWork.class, "ArtWorkAssert.expected.txt");
+	assertAbstractGeneratedAssertClass(ArtWork.class, "AbstractArtWorkAssert.expected.txt");
   }
 
   @Theory
   public void should_generate_assertion_for_nested_class(NestedClass nestedClass) throws Exception {
-    Class<?> clazz = nestedClass.getNestedClass();
-    assertionGenerator.generateCustomAssertionFor(converter.convertToClassDescription(clazz));
-    assertThat(fileGeneratedFor(clazz)).hasContent(expectedContentFromTemplate(clazz, "NestedClassAssert.template.expected.txt"));
+	Class<?> clazz = nestedClass.getNestedClass();
+	assertionGenerator.generateCustomAssertionFor(converter.convertToClassDescription(clazz));
+	assertThat(fileGeneratedFor(clazz)).hasContent(expectedContentFromTemplate(clazz,
+	                                                                           "NestedClassAssert.template.expected.txt"));
   }
 
   @Theory
   public void should_generate_hierarchical_assertion_for_nested_class(NestedClass nestedClass) throws Exception {
-    Class<?> clazz = nestedClass.getNestedClass();
-    assertionGenerator.generateHierarchicalCustomAssertionFor(converter.convertToClassDescription(clazz), null);
-    assertThat(fileGeneratedFor(clazz)).hasContent(expectedContentFromTemplate(clazz, "NestedClassAssert.hierarchical.template.expected.txt"));
+	Class<?> clazz = nestedClass.getNestedClass();
+	assertionGenerator.generateHierarchicalCustomAssertionFor(converter.convertToClassDescription(clazz), null);
+	assertThat(fileGeneratedFor(clazz)).hasContent(expectedContentFromTemplate(clazz,
+	                                                                           "NestedClassAssert.hierarchical.template.expected.txt"));
   }
-  
+
   @Theory
   public void should_generate_assertion_for_property_with_exception(Class<?> beanClass) throws Exception {
-    assertionGenerator.generateCustomAssertionFor(converter.convertToClassDescription(beanClass));
-    String expectedContent = readFileToString(new File("src/test/resources/BeanWithOneException.expected.txt"));
-    if (!BEAN_WITH_ONE_EXCEPTION.equals(beanClass)) {
-      String importException = "import java.io.IOException;" + LINE_SEPARATOR;
-      expectedContent = expectedContent.replace(importException, importException + "import java.sql.SQLException;"
-          + LINE_SEPARATOR);
-
-      expectedContent = expectedContent.replace(BEAN_WITH_ONE_EXCEPTION.getSimpleName(), beanClass.getSimpleName());
-      expectedContent = expectedContent.replace(" throws IOException ", " throws IOException, SQLException ");
-
-      GetterWithException[] getters = { STRING_1_EXCEPTION, BOOLEAN_1_EXCEPTION, ARRAY_1_EXCEPTION,
-          ITERABLE_1_EXCEPTION };
-      for (GetterWithException getter : getters) {
-        String throwsClause = generateThrowsClause(IOException.class, getter.getPropertyName(), getter.isBooleanType());
-        String replacement = throwsClause
-            + generateThrowsClause(SQLException.class, getter.getPropertyName(), getter.isBooleanType());
-        expectedContent = expectedContent.replace(throwsClause, replacement);
-      }
-    }
-    assertThat(fileGeneratedFor(beanClass)).hasContent(expectedContent);
+	assertionGenerator.generateCustomAssertionFor(converter.convertToClassDescription(beanClass));
+	String expectedContent = readFileToString(new File("src/test/resources/BeanWithOneException.expected.txt"));
+	if (!BEAN_WITH_ONE_EXCEPTION.equals(beanClass)) {
+	  expectedContent = expectedContent.replace(BEAN_WITH_ONE_EXCEPTION.getSimpleName(), beanClass.getSimpleName());
+	  expectedContent = expectedContent.replace(" throws java.io.IOException ",
+		                                        " throws java.io.IOException, java.sql.SQLException ");
+
+	  GetterWithException[] getters = { STRING_1_EXCEPTION, BOOLEAN_1_EXCEPTION, ARRAY_1_EXCEPTION,
+		  ITERABLE_1_EXCEPTION };
+	  for (GetterWithException getter : getters) {
+		String throwsClause = generateThrowsClause(IOException.class, getter.getPropertyName(), getter.isBooleanType());
+		String replacement = throwsClause
+		                     + generateThrowsClause(SQLException.class, getter.getPropertyName(),
+		                                            getter.isBooleanType());
+		expectedContent = expectedContent.replace(throwsClause, replacement);
+	  }
+	}
+	assertThat(fileGeneratedFor(beanClass)).hasContent(expectedContent);
   }
 
   private String generateThrowsClause(Class<?> exception, String property, boolean booleanType) {
-    String getter = (booleanType ? "is" : "get") + Character.toUpperCase(property.charAt(0)) + property.substring(1);
-    return "   * @throws " + exception.getSimpleName() + " if actual." + getter + "() throws one." + LINE_SEPARATOR;
+	String getter = (booleanType ? "is" : "get") + Character.toUpperCase(property.charAt(0)) + property.substring(1);
+	return "   * @throws " + exception.getName() + " if actual." + getter + "() throws one." + LINE_SEPARATOR;
   }
 
   @Test
   public void should_generate_assertion_for_classes_in_package() throws Exception {
-    Set<Class<?>> classes = collectClasses("org.assertj.assertions.generator.data");
-    for (Class<?> clazz : classes) {
-      assertThat(clazz.isAnonymousClass()).as("check that <" + clazz.getSimpleName() + "> is not anonymous").isFalse();
-      assertThat(clazz.isLocalClass()).as("check that " + clazz.getSimpleName() + " is not local").isFalse();
-      assertThat(isPublic(clazz.getModifiers())).as("check that " + clazz.getSimpleName() + " is public").isTrue();
-      logger.info("Generating assertions for {}", clazz.getName());
-      final ClassDescription classDescription = converter.convertToClassDescription(clazz);
-      File customAssertionFile = assertionGenerator.generateCustomAssertionFor(classDescription);
-      logger.info("Generated {} assertions file -> {}", clazz.getSimpleName(), customAssertionFile.getAbsolutePath());
-    }
+	Set<Class<?>> classes = collectClasses("org.assertj.assertions.generator.data");
+	for (Class<?> clazz : classes) {
+	  assertThat(clazz.isAnonymousClass()).as("check that <" + clazz.getSimpleName() + "> is not anonymous").isFalse();
+	  assertThat(clazz.isLocalClass()).as("check that " + clazz.getSimpleName() + " is not local").isFalse();
+	  assertThat(isPublic(clazz.getModifiers())).as("check that " + clazz.getSimpleName() + " is public").isTrue();
+	  logger.info("Generating assertions for {}", clazz.getName());
+	  final ClassDescription classDescription = converter.convertToClassDescription(clazz);
+	  File customAssertionFile = assertionGenerator.generateCustomAssertionFor(classDescription);
+	  logger.info("Generated {} assertions file -> {}", clazz.getSimpleName(), customAssertionFile.getAbsolutePath());
+	}
   }
 
   @Test
   public void should_generate_assertion_for_classes_in_package_using_provided_class_loader() throws Exception {
-    ClassLoader customClassLoader = new MyClassLoader(Thread.currentThread().getContextClassLoader());
-    Set<Class<?>> classes = collectClasses(customClassLoader, "org.assertj.assertions.generator.data");
-    for (Class<?> clazz : classes) {
-      assertThat(clazz.isAnonymousClass()).as("check that " + clazz.getSimpleName() + " is not anonymous").isFalse();
-      assertThat(clazz.isLocalClass()).as("check that " + clazz.getSimpleName() + " is not local").isFalse();
-      assertThat(isPublic(clazz.getModifiers())).as("check that " + clazz.getSimpleName() + " is public").isTrue();
-      logger.info("Generating assertions for {}", clazz.getName());
-      final ClassDescription classDescription = converter.convertToClassDescription(clazz);
-      File customAssertionFile = assertionGenerator.generateCustomAssertionFor(classDescription);
-      logger.info("Generated {} assertions file -> {}", clazz.getSimpleName(), customAssertionFile.getAbsolutePath());
-    }
+	ClassLoader customClassLoader = new MyClassLoader(Thread.currentThread().getContextClassLoader());
+	Set<Class<?>> classes = collectClasses(customClassLoader, "org.assertj.assertions.generator.data");
+	for (Class<?> clazz : classes) {
+	  assertThat(clazz.isAnonymousClass()).as("check that " + clazz.getSimpleName() + " is not anonymous").isFalse();
+	  assertThat(clazz.isLocalClass()).as("check that " + clazz.getSimpleName() + " is not local").isFalse();
+	  assertThat(isPublic(clazz.getModifiers())).as("check that " + clazz.getSimpleName() + " is public").isTrue();
+	  logger.info("Generating assertions for {}", clazz.getName());
+	  final ClassDescription classDescription = converter.convertToClassDescription(clazz);
+	  File customAssertionFile = assertionGenerator.generateCustomAssertionFor(classDescription);
+	  logger.info("Generated {} assertions file -> {}", clazz.getSimpleName(), customAssertionFile.getAbsolutePath());
+	}
   }
 
   @Test
   public void should_check_template_type() throws Exception {
-    BaseAssertionGenerator assertionGenerator = new BaseAssertionGenerator();
-    assertionGenerator.setHasAssertionTemplate(new Template(Template.Type.HAS, "template content"));
-    try {
-      assertionGenerator.setHasAssertionTemplate(new Template(Template.Type.IS, "template content"));
-      failBecauseExceptionWasNotThrown(IllegalArgumentException.class);
-    } catch (IllegalArgumentException e) {
-      assertThat(e).hasMessage("Expecting a Template type to be 'HAS' but was 'IS'");
-    }
+	BaseAssertionGenerator assertionGenerator = new BaseAssertionGenerator();
+	assertionGenerator.setHasAssertionTemplate(new Template(Template.Type.HAS, "template content"));
+	try {
+	  assertionGenerator.setHasAssertionTemplate(new Template(Template.Type.IS, "template content"));
+	  failBecauseExceptionWasNotThrown(IllegalArgumentException.class);
+	} catch (IllegalArgumentException e) {
+	  assertThat(e).hasMessage("Expecting a Template type to be 'HAS' but was 'IS'");
+	}
+  }
+
+  @Test
+  public void should_generate_assertion_for_classes_using_type_with_same_name() throws IOException {
+	Class<?> clazz = ClassUsingDifferentClassesWithSameName.class;
+	assertionGenerator.generateCustomAssertionFor(converter.convertToClassDescription(clazz));
+	assertGeneratedAssertClass(ClassUsingDifferentClassesWithSameName.class,
+	                           "ClassUsingDifferentClassesWithSameName.expected.txt");
+  }
+
+  private static void assertGeneratedAssertClass(Class<?> clazz, String expectedAssertFile) {
+	assertThat(fileGeneratedFor(clazz)).hasContentEqualTo(new File("src/test/resources/" + expectedAssertFile).getAbsoluteFile());
+  }
+
+  private static void assertAbstractGeneratedAssertClass(Class<?> clazz, String expectedAssertFile) {
+	assertThat(abstractFileGeneratedFor(clazz)).hasContentEqualTo(new File("src/test/resources/" + expectedAssertFile).getAbsoluteFile());
   }
 
   private static String expectedContentFromTemplate(Class<?> clazz, String fileTemplate) throws IOException {
-    String template = readFileToString(new File("src/test/resources/" + fileTemplate));
-    String content = replace(template, "${nestedClass}Assert", getSimpleNameWithOuterClassNotSeparatedByDots(clazz) + "Assert");
-    content = replace(content, "${nestedClass}", getSimpleNameWithOuterClass(clazz));
-    return content;
+	String template = readFileToString(new File("src/test/resources/" + fileTemplate));
+	String content = replace(template, "${nestedClass}Assert", getSimpleNameWithOuterClassNotSeparatedByDots(clazz)
+	                                                           + "Assert");
+	content = replace(content, "${nestedClass}", getSimpleNameWithOuterClass(clazz));
+	return content;
   }
 
   private static File fileGeneratedFor(Class<?> clazz) {
-    String dirName = TARGET_DIRECTORY + File.separatorChar + clazz.getPackage().getName().replace('.', File.separatorChar);
-    String generatedFileName = getSimpleNameWithOuterClassNotSeparatedByDots(clazz) + ASSERT_CLASS_FILE_SUFFIX;
-    return new File(dirName, generatedFileName);
+	String dirName = TARGET_DIRECTORY + File.separatorChar
+	                 + clazz.getPackage().getName().replace('.', File.separatorChar);
+	String generatedFileName = getSimpleNameWithOuterClassNotSeparatedByDots(clazz) + ASSERT_CLASS_FILE_SUFFIX;
+	return new File(dirName, generatedFileName);
   }
-  
+
   private static File abstractFileGeneratedFor(Class<?> clazz) {
-    String dirName = TARGET_DIRECTORY + File.separatorChar + clazz.getPackage().getName().replace('.', File.separatorChar);
-    String generatedFileName = ABSTRACT_ASSERT_CLASS_PREFIX + getSimpleNameWithOuterClassNotSeparatedByDots(clazz) + ASSERT_CLASS_FILE_SUFFIX;
-    return new File(dirName, generatedFileName);    
+	String dirName = TARGET_DIRECTORY + File.separatorChar
+	                 + clazz.getPackage().getName().replace('.', File.separatorChar);
+	String generatedFileName = ABSTRACT_ASSERT_CLASS_PREFIX + getSimpleNameWithOuterClassNotSeparatedByDots(clazz)
+	                           + ASSERT_CLASS_FILE_SUFFIX;
+	return new File(dirName, generatedFileName);
   }
 
   class MyClassLoader extends ClassLoader {
-    public MyClassLoader(ClassLoader parent) {
-      super(parent);
-    }
+	public MyClassLoader(ClassLoader parent) {
+	  super(parent);
+	}
   }
 
 }
diff --git a/src/test/java/org/assertj/assertions/generator/ClassUsingDifferentClassesWithSameName.java b/src/test/java/org/assertj/assertions/generator/ClassUsingDifferentClassesWithSameName.java
new file mode 100644
index 0000000..a0730e8
--- /dev/null
+++ b/src/test/java/org/assertj/assertions/generator/ClassUsingDifferentClassesWithSameName.java
@@ -0,0 +1,24 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.assertions.generator;
+
+// used in test - getters implemntation don't matter
+public class ClassUsingDifferentClassesWithSameName {
+  public org.assertj.assertions.generator.data.nba.Team getNbaTeam() {
+	return null;
+  }
+
+  public org.assertj.assertions.generator.data.Team getTeam() {
+	return null;
+  }
+}
\ No newline at end of file
diff --git a/src/test/java/org/assertj/assertions/generator/description/FieldDescriptionTest.java b/src/test/java/org/assertj/assertions/generator/description/FieldDescriptionTest.java
index 6193992..ce03ebf 100644
--- a/src/test/java/org/assertj/assertions/generator/description/FieldDescriptionTest.java
+++ b/src/test/java/org/assertj/assertions/generator/description/FieldDescriptionTest.java
@@ -26,7 +26,7 @@ public class FieldDescriptionTest {
     fieldDescription = new FieldDescription("bestPlayer", new TypeDescription(new TypeName(Player.class)));
     assertThat(fieldDescription.getName()).isEqualTo("bestPlayer");
     assertThat(fieldDescription.getTypeName()).isEqualTo("Player");
-    assertThat(fieldDescription.getElementTypeName()).isNull();
+    assertThat(fieldDescription.getElementTypeName(Player.class.getPackage().getName())).isNull();
   }
 
   @Test
diff --git a/src/test/java/org/assertj/assertions/generator/description/GetterDescriptionTest.java b/src/test/java/org/assertj/assertions/generator/description/GetterDescriptionTest.java
index a822e97..98be46e 100644
--- a/src/test/java/org/assertj/assertions/generator/description/GetterDescriptionTest.java
+++ b/src/test/java/org/assertj/assertions/generator/description/GetterDescriptionTest.java
@@ -31,7 +31,7 @@ public class GetterDescriptionTest {
     getterDescription = new GetterDescription("bestPlayer", new TypeDescription(new TypeName(Player.class)), Collections.<TypeName>emptyList());
     assertThat(getterDescription.getPropertyName()).isEqualTo("bestPlayer");
     assertThat(getterDescription.getTypeName()).isEqualTo("Player");
-    assertThat(getterDescription.getElementTypeName()).isNull();
+    assertThat(getterDescription.getElementTypeName(Player.class.getPackage().getName())).isNull();
   }
 
   @Test
diff --git a/src/test/java/org/assertj/assertions/generator/description/converter/ClassToClassDescriptionConverterTest.java b/src/test/java/org/assertj/assertions/generator/description/converter/ClassToClassDescriptionConverterTest.java
index 04fd598..755ad46 100644
--- a/src/test/java/org/assertj/assertions/generator/description/converter/ClassToClassDescriptionConverterTest.java
+++ b/src/test/java/org/assertj/assertions/generator/description/converter/ClassToClassDescriptionConverterTest.java
@@ -14,17 +14,14 @@ package org.assertj.assertions.generator.description.converter;
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import java.nio.file.Path;
+import java.sql.SQLException;
 import java.util.ArrayList;
-import java.util.Date;
 import java.util.List;
-import java.util.Map;
 
 import org.assertj.assertions.generator.BeanWithExceptionsTest;
 import org.assertj.assertions.generator.NestedClassesTest;
 import org.assertj.assertions.generator.data.ArtWork;
 import org.assertj.assertions.generator.data.Movie;
-import org.assertj.assertions.generator.data.Name;
 import org.assertj.assertions.generator.data.Team;
 import org.assertj.assertions.generator.data.TreeEnum;
 import org.assertj.assertions.generator.data.lotr.FellowshipOfTheRing;
@@ -32,7 +29,6 @@ import org.assertj.assertions.generator.data.nba.Player;
 import org.assertj.assertions.generator.data.nba.PlayerAgent;
 import org.assertj.assertions.generator.description.ClassDescription;
 import org.assertj.assertions.generator.description.GetterDescription;
-import org.assertj.assertions.generator.description.TypeName;
 import org.junit.BeforeClass;
 import org.junit.Test;
 import org.junit.experimental.theories.Theories;
@@ -55,7 +51,6 @@ public class ClassToClassDescriptionConverterTest implements NestedClassesTest,
 	assertThat(classDescription.getClassNameWithOuterClass()).isEqualTo("Player");
 	assertThat(classDescription.getPackageName()).isEqualTo("org.assertj.assertions.generator.data.nba");
 	assertThat(classDescription.getGettersDescriptions()).hasSize(10);
-	assertThat(classDescription.getImports()).containsOnly(new TypeName(Name.class));
   }
 
   @Test
@@ -69,7 +64,6 @@ public class ClassToClassDescriptionConverterTest implements NestedClassesTest,
 	assertThat(classDescription.getDeclaredGettersDescriptions()).hasSize(2);
 	assertThat(classDescription.getDeclaredFieldsDescriptions()).hasSize(3);
 	assertThat(classDescription.getSuperType()).isEqualTo(ArtWork.class);
-	assertThat(classDescription.getImports()).containsOnly(new TypeName(Date.class));
   }
 
   @Theory
@@ -80,7 +74,6 @@ public class ClassToClassDescriptionConverterTest implements NestedClassesTest,
 	assertThat(classDescription.getClassNameWithOuterClass()).isEqualTo(nestedClass.getClassNameWithOuterClass());
 	assertThat(classDescription.getPackageName()).isEqualTo(clazz.getPackage().getName());
 	assertThat(classDescription.getGettersDescriptions()).hasSize(1);
-	assertThat(classDescription.getImports()).isEmpty();
   }
 
   @Theory
@@ -91,7 +84,6 @@ public class ClassToClassDescriptionConverterTest implements NestedClassesTest,
 	assertThat(classDescription.getClassNameWithOuterClass()).isEqualTo(clazz.getSimpleName());
 	assertThat(classDescription.getPackageName()).isEqualTo(clazz.getPackage().getName());
 	assertThat(classDescription.getGettersDescriptions()).hasSize(4);
-	assertThat(classDescription.getImports()).containsOnly(getter.getExceptions());
 
 	for (GetterDescription desc : classDescription.getGettersDescriptions()) {
 	  if (desc.getPropertyName().equals(getter.getPropertyName())) {
@@ -116,7 +108,7 @@ public class ClassToClassDescriptionConverterTest implements NestedClassesTest,
 	assertThat(classDescription.getGettersDescriptions()).hasSize(1);
 	GetterDescription getterDescription = classDescription.getGettersDescriptions().iterator().next();
 	assertThat(getterDescription.isIterableType()).as("getterDescription must be iterable").isTrue();
-	assertThat(getterDescription.getElementTypeName()).isEqualTo("int[]");
+	assertThat(getterDescription.getElementTypeName(Type.class.getPackage().getName())).isEqualTo("int[]");
 	assertThat(getterDescription.isArrayType()).as("getterDescription must not be an array").isFalse();
   }
 
@@ -136,7 +128,7 @@ public class ClassToClassDescriptionConverterTest implements NestedClassesTest,
 	GetterDescription getterDescription = classDescription.getGettersDescriptions().iterator().next();
 	assertThat(getterDescription.isIterableType()).as("getterDescription is an iterable ?").isFalse();
 	assertThat(getterDescription.isArrayType()).as("getterDescription is an array ?").isTrue();
-	assertThat(getterDescription.getElementTypeName()).isEqualTo("int[]");
+	assertThat(getterDescription.getElementTypeName(Type.class.getPackage().getName())).isEqualTo("int[]");
   }
 
   @Test
@@ -147,7 +139,7 @@ public class ClassToClassDescriptionConverterTest implements NestedClassesTest,
 	assertThat(classDescription.getGettersDescriptions()).hasSize(1);
 	GetterDescription getterDescription = classDescription.getGettersDescriptions().iterator().next();
 	assertThat(getterDescription.isIterableType()).as("getterDescription must be iterable").isTrue();
-	assertThat(getterDescription.getElementTypeName()).isEqualTo("TreeEnum");
+	assertThat(getterDescription.getElementTypeName(TreeEnum.class.getPackage().getName())).isEqualTo("TreeEnum");
 	assertThat(getterDescription.isArrayType()).as("getterDescription must be an array").isFalse();
   }
 
@@ -171,9 +163,8 @@ public class ClassToClassDescriptionConverterTest implements NestedClassesTest,
 	assertThat(classDescription.getGettersDescriptions()).hasSize(1);
 	GetterDescription getterDescription = classDescription.getGettersDescriptions().iterator().next();
 	assertThat(getterDescription.isIterableType()).as("getterDescription must be iterable").isTrue();
-	assertThat(getterDescription.getElementTypeName()).isEqualTo("Player[]");
+	assertThat(getterDescription.getElementTypeName(Type.class.getPackage().getName())).isEqualTo("org.assertj.assertions.generator.data.nba.Player[]");
 	assertThat(getterDescription.isArrayType()).as("getterDescription is not an array").isFalse();
-	assertThat(classDescription.getImports()).extracting("simpleName").contains(Player.class.getSimpleName());
   }
 
   @Test
@@ -190,7 +181,6 @@ public class ClassToClassDescriptionConverterTest implements NestedClassesTest,
 	assertThat(getterDescription.isIterableType()).as("getterDescription is not iterable").isFalse();
 	assertThat(getterDescription.getPropertyName()).isEqualTo("managedPlayer");
 	assertThat(getterDescription.getTypeName()).isEqualTo("Player");
-	assertThat(classDescription.getImports()).isEmpty();
   }
 
   @Test
@@ -201,14 +191,12 @@ public class ClassToClassDescriptionConverterTest implements NestedClassesTest,
 	assertThat(classDescription.getClassNameWithOuterClassNotSeparatedByDots()).isEqualTo("FellowshipOfTheRing");
 	assertThat(classDescription.getPackageName()).isEqualTo("org.assertj.assertions.generator.data.lotr");
 	assertThat(classDescription.getGettersDescriptions()).hasSize(1);
-	assertThat(classDescription.getImports()).containsOnly(new TypeName(Map.class), new TypeName(List.class));
   }
 
   @Test
   public void should_handle_toString() {
 	ClassDescription classDescription = converter.convertToClassDescription(FellowshipOfTheRing.class);
-	assertThat(classDescription.toString()).contains(FellowshipOfTheRing.class.getSimpleName(), "java.util.Map",
-	                                                 "java.util.List");
+	assertThat(classDescription.toString()).contains(FellowshipOfTheRing.class.getName());
   }
 
   @Test
@@ -226,14 +214,22 @@ public class ClassToClassDescriptionConverterTest implements NestedClassesTest,
 	                                                                                     "players",
 	                                                                                     "points",
 	                                                                                     "victoryRatio");
-	// no List.class as it won't be needed in TeamAssert
-	assertThat(classDescription.getImports()).containsOnly(new TypeName(Player.class));
   }
 
   @Test
   public void bug21_reflection_error_on_iterable_ParameterizedType() {
-	ClassDescription classDescription = converter.convertToClassDescription(Path.class);
-	assertThat(classDescription.getGettersDescriptions()).extracting("propertyName").contains("parent");
+	class MySQLException extends SQLException {
+	  private static final long serialVersionUID = 1L;
+
+	  @SuppressWarnings("unused")
+	  public SQLException getExceptionChain() {
+		return null;
+	  }
+	}
+	ClassDescription classDescription = converter.convertToClassDescription(MySQLException.class);
+	// exceptionChain is a SQLException which is an Iterable<Throwable> but looking only at SQLException we can't deduce
+	// iterable type
+	assertThat(classDescription.getGettersDescriptions()).extracting("propertyName").contains("exceptionChain");
   }
 
   @Test
@@ -241,7 +237,7 @@ public class ClassToClassDescriptionConverterTest implements NestedClassesTest,
 	ClassDescription myClassDescription = converter.convertToClassDescription(ClassOverridingGetter.class);
 	assertThat(myClassDescription.getGettersDescriptions()).extracting("propertyName").containsOnlyOnce("myList");
   }
-  
+
   public interface InterfaceWithGetter {
 	public abstract List<String> getMyList();
   }
@@ -251,5 +247,5 @@ public class ClassToClassDescriptionConverterTest implements NestedClassesTest,
 	  return null;
 	}
   }
-  
+
 }
diff --git a/src/test/resources/AbstractMovieAssert.expected.txt b/src/test/resources/AbstractMovieAssert.expected.txt
index 0081819..5599906 100644
--- a/src/test/resources/AbstractMovieAssert.expected.txt
+++ b/src/test/resources/AbstractMovieAssert.expected.txt
@@ -1,6 +1,5 @@
 package org.assertj.assertions.generator.data;
 
-import java.util.Date;
 import org.assertj.core.api.Assertions;
 
 
@@ -46,7 +45,7 @@ public abstract class AbstractMovieAssert<S extends AbstractMovieAssert<S, A>, A
    * @return this assertion object.
    * @throws AssertionError - if the actual Movie's releaseDate is not equal to the given one.
    */
-  public S hasReleaseDate(Date releaseDate) {
+  public S hasReleaseDate(java.util.Date releaseDate) {
     // check that actual Movie we want to make assertions on is not null.
     isNotNull();
 
@@ -54,7 +53,7 @@ public abstract class AbstractMovieAssert<S extends AbstractMovieAssert<S, A>, A
     String assertjErrorMessage = "\nExpected releaseDate of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";
     
     // null safe check
-    Date actualReleaseDate = actual.getReleaseDate();
+    java.util.Date actualReleaseDate = actual.getReleaseDate();
     if (!org.assertj.core.util.Objects.areEqual(actualReleaseDate, releaseDate)) {
       failWithMessage(assertjErrorMessage, actual, releaseDate, actualReleaseDate);
     }
diff --git a/src/test/resources/BeanWithOneException.expected.txt b/src/test/resources/BeanWithOneException.expected.txt
index 26966b9..480235d 100644
--- a/src/test/resources/BeanWithOneException.expected.txt
+++ b/src/test/resources/BeanWithOneException.expected.txt
@@ -1,6 +1,5 @@
 package org.assertj.assertions.generator.data;
 
-import java.io.IOException;
 import org.assertj.core.api.AbstractAssert;
 import org.assertj.core.api.Assertions;
 
@@ -33,9 +32,9 @@ public class BeanWithOneExceptionAssert extends AbstractAssert<BeanWithOneExcept
    * @param arrayPropertyThrowsException the given elements that should be contained in actual BeanWithOneException's arrayPropertyThrowsException.
    * @return this assertion object.
    * @throws AssertionError if the actual BeanWithOneException's arrayPropertyThrowsException does not contain all given String elements.
-   * @throws IOException if actual.getArrayPropertyThrowsException() throws one.
+   * @throws java.io.IOException if actual.getArrayPropertyThrowsException() throws one.
    */
-  public BeanWithOneExceptionAssert hasArrayPropertyThrowsException(String... arrayPropertyThrowsException) throws IOException {
+  public BeanWithOneExceptionAssert hasArrayPropertyThrowsException(String... arrayPropertyThrowsException) throws java.io.IOException {
     // check that actual BeanWithOneException we want to make assertions on is not null.
     isNotNull();
 
@@ -58,9 +57,9 @@ public class BeanWithOneExceptionAssert extends AbstractAssert<BeanWithOneExcept
    * Verifies that the actual BeanWithOneException has no arrayPropertyThrowsException.
    * @return this assertion object.
    * @throws AssertionError if the actual BeanWithOneException's arrayPropertyThrowsException is not empty.
-   * @throws IOException if actual.getArrayPropertyThrowsException() throws one.
+   * @throws java.io.IOException if actual.getArrayPropertyThrowsException() throws one.
    */
-  public BeanWithOneExceptionAssert hasNoArrayPropertyThrowsException() throws IOException {
+  public BeanWithOneExceptionAssert hasNoArrayPropertyThrowsException() throws java.io.IOException {
     // check that actual BeanWithOneException we want to make assertions on is not null.
     isNotNull();
 
@@ -81,9 +80,9 @@ public class BeanWithOneExceptionAssert extends AbstractAssert<BeanWithOneExcept
    * Verifies that the actual BeanWithOneException is booleanPropertyThrowsException.
    * @return this assertion object.
    * @throws AssertionError - if the actual BeanWithOneException is not booleanPropertyThrowsException.
-   * @throws IOException if actual.isBooleanPropertyThrowsException() throws one.
+   * @throws java.io.IOException if actual.isBooleanPropertyThrowsException() throws one.
    */
-  public BeanWithOneExceptionAssert isBooleanPropertyThrowsException() throws IOException {
+  public BeanWithOneExceptionAssert isBooleanPropertyThrowsException() throws java.io.IOException {
     // check that actual BeanWithOneException we want to make assertions on is not null.
     isNotNull();
 
@@ -100,9 +99,9 @@ public class BeanWithOneExceptionAssert extends AbstractAssert<BeanWithOneExcept
    * Verifies that the actual BeanWithOneException is not booleanPropertyThrowsException.
    * @return this assertion object.
    * @throws AssertionError - if the actual BeanWithOneException is booleanPropertyThrowsException.
-   * @throws IOException if actual.isBooleanPropertyThrowsException() throws one.
+   * @throws java.io.IOException if actual.isBooleanPropertyThrowsException() throws one.
    */
-  public BeanWithOneExceptionAssert isNotBooleanPropertyThrowsException() throws IOException {
+  public BeanWithOneExceptionAssert isNotBooleanPropertyThrowsException() throws java.io.IOException {
     // check that actual BeanWithOneException we want to make assertions on is not null.
     isNotNull();
 
@@ -120,9 +119,9 @@ public class BeanWithOneExceptionAssert extends AbstractAssert<BeanWithOneExcept
    * @param iterablePropertyThrowsException the given elements that should be contained in actual BeanWithOneException's iterablePropertyThrowsException.
    * @return this assertion object.
    * @throws AssertionError if the actual BeanWithOneException's iterablePropertyThrowsException does not contain all given String elements.
-   * @throws IOException if actual.getIterablePropertyThrowsException() throws one.
+   * @throws java.io.IOException if actual.getIterablePropertyThrowsException() throws one.
    */
-  public BeanWithOneExceptionAssert hasIterablePropertyThrowsException(String... iterablePropertyThrowsException) throws IOException {
+  public BeanWithOneExceptionAssert hasIterablePropertyThrowsException(String... iterablePropertyThrowsException) throws java.io.IOException {
     // check that actual BeanWithOneException we want to make assertions on is not null.
     isNotNull();
 
@@ -140,9 +139,9 @@ public class BeanWithOneExceptionAssert extends AbstractAssert<BeanWithOneExcept
    * Verifies that the actual BeanWithOneException has no iterablePropertyThrowsException.
    * @return this assertion object.
    * @throws AssertionError if the actual BeanWithOneException's iterablePropertyThrowsException is not empty.
-   * @throws IOException if actual.getIterablePropertyThrowsException() throws one.
+   * @throws java.io.IOException if actual.getIterablePropertyThrowsException() throws one.
    */
-  public BeanWithOneExceptionAssert hasNoIterablePropertyThrowsException() throws IOException {
+  public BeanWithOneExceptionAssert hasNoIterablePropertyThrowsException() throws java.io.IOException {
     // check that actual BeanWithOneException we want to make assertions on is not null.
     isNotNull();
 
@@ -164,9 +163,9 @@ public class BeanWithOneExceptionAssert extends AbstractAssert<BeanWithOneExcept
    * @param stringPropertyThrowsException the given stringPropertyThrowsException to compare the actual BeanWithOneException's stringPropertyThrowsException to.
    * @return this assertion object.
    * @throws AssertionError - if the actual BeanWithOneException's stringPropertyThrowsException is not equal to the given one.
-   * @throws IOException if actual.getStringPropertyThrowsException() throws one.
+   * @throws java.io.IOException if actual.getStringPropertyThrowsException() throws one.
    */
-  public BeanWithOneExceptionAssert hasStringPropertyThrowsException(String stringPropertyThrowsException) throws IOException {
+  public BeanWithOneExceptionAssert hasStringPropertyThrowsException(String stringPropertyThrowsException) throws java.io.IOException {
     // check that actual BeanWithOneException we want to make assertions on is not null.
     isNotNull();
 
diff --git a/src/test/resources/ClassUsingDifferentClassesWithSameName.expected.txt b/src/test/resources/ClassUsingDifferentClassesWithSameName.expected.txt
new file mode 100644
index 0000000..018da75
--- /dev/null
+++ b/src/test/resources/ClassUsingDifferentClassesWithSameName.expected.txt
@@ -0,0 +1,75 @@
+package org.assertj.assertions.generator;
+
+import org.assertj.core.api.AbstractAssert;
+
+
+/**
+ * {@link ClassUsingDifferentClassesWithSameName} specific assertions - Generated by CustomAssertionGenerator.
+ */
+public class ClassUsingDifferentClassesWithSameNameAssert extends AbstractAssert<ClassUsingDifferentClassesWithSameNameAssert, ClassUsingDifferentClassesWithSameName> {
+
+  /**
+   * Creates a new <code>{@link ClassUsingDifferentClassesWithSameNameAssert}</code> to make assertions on actual ClassUsingDifferentClassesWithSameName.
+   * @param actual the ClassUsingDifferentClassesWithSameName we want to make assertions on.
+   */
+  public ClassUsingDifferentClassesWithSameNameAssert(ClassUsingDifferentClassesWithSameName actual) {
+    super(actual, ClassUsingDifferentClassesWithSameNameAssert.class);
+  }
+
+  /**
+   * An entry point for ClassUsingDifferentClassesWithSameNameAssert to follow AssertJ standard <code>assertThat()</code> statements.<br>
+   * With a static import, one can write directly: <code>assertThat(myClassUsingDifferentClassesWithSameName)</code> and get specific assertion with code completion.
+   * @param actual the ClassUsingDifferentClassesWithSameName we want to make assertions on.
+   * @return a new <code>{@link ClassUsingDifferentClassesWithSameNameAssert}</code>
+   */
+  public static ClassUsingDifferentClassesWithSameNameAssert assertThat(ClassUsingDifferentClassesWithSameName actual) {
+    return new ClassUsingDifferentClassesWithSameNameAssert(actual);
+  }
+
+  /**
+   * Verifies that the actual ClassUsingDifferentClassesWithSameName's nbaTeam is equal to the given one.
+   * @param nbaTeam the given nbaTeam to compare the actual ClassUsingDifferentClassesWithSameName's nbaTeam to.
+   * @return this assertion object.
+   * @throws AssertionError - if the actual ClassUsingDifferentClassesWithSameName's nbaTeam is not equal to the given one.
+   */
+  public ClassUsingDifferentClassesWithSameNameAssert hasNbaTeam(org.assertj.assertions.generator.data.nba.Team nbaTeam) {
+    // check that actual ClassUsingDifferentClassesWithSameName we want to make assertions on is not null.
+    isNotNull();
+
+    // overrides the default error message with a more explicit one
+    String assertjErrorMessage = "\nExpected nbaTeam of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";
+    
+    // null safe check
+    org.assertj.assertions.generator.data.nba.Team actualNbaTeam = actual.getNbaTeam();
+    if (!org.assertj.core.util.Objects.areEqual(actualNbaTeam, nbaTeam)) {
+      failWithMessage(assertjErrorMessage, actual, nbaTeam, actualNbaTeam);
+    }
+
+    // return the current assertion for method chaining
+    return this;
+  }
+
+  /**
+   * Verifies that the actual ClassUsingDifferentClassesWithSameName's team is equal to the given one.
+   * @param team the given team to compare the actual ClassUsingDifferentClassesWithSameName's team to.
+   * @return this assertion object.
+   * @throws AssertionError - if the actual ClassUsingDifferentClassesWithSameName's team is not equal to the given one.
+   */
+  public ClassUsingDifferentClassesWithSameNameAssert hasTeam(org.assertj.assertions.generator.data.Team team) {
+    // check that actual ClassUsingDifferentClassesWithSameName we want to make assertions on is not null.
+    isNotNull();
+
+    // overrides the default error message with a more explicit one
+    String assertjErrorMessage = "\nExpected team of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";
+    
+    // null safe check
+    org.assertj.assertions.generator.data.Team actualTeam = actual.getTeam();
+    if (!org.assertj.core.util.Objects.areEqual(actualTeam, team)) {
+      failWithMessage(assertjErrorMessage, actual, team, actualTeam);
+    }
+
+    // return the current assertion for method chaining
+    return this;
+  }
+
+}
diff --git a/src/test/resources/MovieAssert.flat.expected.txt b/src/test/resources/MovieAssert.flat.expected.txt
index 2c1f0e8..2d49271 100644
--- a/src/test/resources/MovieAssert.flat.expected.txt
+++ b/src/test/resources/MovieAssert.flat.expected.txt
@@ -1,6 +1,5 @@
 package org.assertj.assertions.generator.data;
 
-import java.util.Date;
 import org.assertj.core.api.AbstractAssert;
 import org.assertj.core.api.Assertions;
 
@@ -57,7 +56,7 @@ public class MovieAssert extends AbstractAssert<MovieAssert, Movie> {
    * @return this assertion object.
    * @throws AssertionError - if the actual Movie's releaseDate is not equal to the given one.
    */
-  public MovieAssert hasReleaseDate(Date releaseDate) {
+  public MovieAssert hasReleaseDate(java.util.Date releaseDate) {
     // check that actual Movie we want to make assertions on is not null.
     isNotNull();
 
@@ -65,7 +64,7 @@ public class MovieAssert extends AbstractAssert<MovieAssert, Movie> {
     String assertjErrorMessage = "\nExpected releaseDate of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";
     
     // null safe check
-    Date actualReleaseDate = actual.getReleaseDate();
+    java.util.Date actualReleaseDate = actual.getReleaseDate();
     if (!org.assertj.core.util.Objects.areEqual(actualReleaseDate, releaseDate)) {
       failWithMessage(assertjErrorMessage, actual, releaseDate, actualReleaseDate);
     }
diff --git a/src/test/resources/PlayerAssert.expected.txt b/src/test/resources/PlayerAssert.expected.txt
index 8ed5b9a..38bc0b4 100644
--- a/src/test/resources/PlayerAssert.expected.txt
+++ b/src/test/resources/PlayerAssert.expected.txt
@@ -1,6 +1,5 @@
 package org.assertj.assertions.generator.data.nba;
 
-import org.assertj.assertions.generator.data.Name;
 import org.assertj.core.api.AbstractAssert;
 import org.assertj.core.api.Assertions;
 
@@ -57,7 +56,7 @@ public class PlayerAssert extends AbstractAssert<PlayerAssert, Player> {
    * @return this assertion object.
    * @throws AssertionError - if the actual Player's name is not equal to the given one.
    */
-  public PlayerAssert hasName(Name name) {
+  public PlayerAssert hasName(org.assertj.assertions.generator.data.Name name) {
     // check that actual Player we want to make assertions on is not null.
     isNotNull();
 
@@ -65,7 +64,7 @@ public class PlayerAssert extends AbstractAssert<PlayerAssert, Player> {
     String assertjErrorMessage = "\nExpected name of:\n  <%s>\nto be:\n  <%s>\nbut was:\n  <%s>";
     
     // null safe check
-    Name actualName = actual.getName();
+    org.assertj.assertions.generator.data.Name actualName = actual.getName();
     if (!org.assertj.core.util.Objects.areEqual(actualName, name)) {
       failWithMessage(assertjErrorMessage, actual, name, actualName);
     }
diff --git a/src/test/resources/TeamAssert.expected.txt b/src/test/resources/TeamAssert.expected.txt
index 3f9a221..c976c58 100644
--- a/src/test/resources/TeamAssert.expected.txt
+++ b/src/test/resources/TeamAssert.expected.txt
@@ -1,6 +1,5 @@
 package org.assertj.assertions.generator.data;
 
-import org.assertj.assertions.generator.data.nba.Player;
 import org.assertj.core.api.AbstractAssert;
 import org.assertj.core.api.Assertions;
 
@@ -122,16 +121,16 @@ public class TeamAssert extends AbstractAssert<TeamAssert, Team> {
   
 
   /**
-   * Verifies that the actual Team's players contains the given Player elements.
+   * Verifies that the actual Team's players contains the given org.assertj.assertions.generator.data.nba.Player elements.
    * @param players the given elements that should be contained in actual Team's players.
    * @return this assertion object.
-   * @throws AssertionError if the actual Team's players does not contain all given Player elements.
+   * @throws AssertionError if the actual Team's players does not contain all given org.assertj.assertions.generator.data.nba.Player elements.
    */
-  public TeamAssert hasPlayers(Player... players) {
+  public TeamAssert hasPlayers(org.assertj.assertions.generator.data.nba.Player... players) {
     // check that actual Team we want to make assertions on is not null.
     isNotNull();
 
-    // check that given Player varargs is not null.
+    // check that given org.assertj.assertions.generator.data.nba.Player varargs is not null.
     if (players == null) throw new AssertionError("Expecting players parameter not to be null.");
     
     // check with standard error message, to set another message call: info.overridingErrorMessage("my error message");
