diff --git a/.gitignore b/.gitignore
index b270863..74f1fd6 100644
--- a/.gitignore
+++ b/.gitignore
@@ -11,3 +11,5 @@
 *.jar
 *.war
 *.ear
+/Vagrantfile
+/.vagrant/
diff --git a/src/main/java/org/assertj/assertions/generator/BaseAssertionGenerator.java b/src/main/java/org/assertj/assertions/generator/BaseAssertionGenerator.java
index 81ef983..cfee04a 100644
--- a/src/main/java/org/assertj/assertions/generator/BaseAssertionGenerator.java
+++ b/src/main/java/org/assertj/assertions/generator/BaseAssertionGenerator.java
@@ -12,29 +12,27 @@
  */
 package org.assertj.assertions.generator;
 
-import com.google.common.collect.Sets;
-import com.google.common.reflect.TypeToken;
-import org.assertj.assertions.generator.Template.Type;
-import org.assertj.assertions.generator.description.ClassDescription;
-import org.assertj.assertions.generator.description.DataDescription;
-import org.assertj.assertions.generator.description.FieldDescription;
-import org.assertj.assertions.generator.description.GetterDescription;
-import org.assertj.assertions.generator.util.ClassUtil;
+import static com.google.common.collect.Sets.newHashSet;
+import static java.lang.String.format;
+import static org.apache.commons.lang3.StringUtils.*;
+import static org.assertj.assertions.generator.Template.Type.ASSERT_CLASS;
+import static org.assertj.assertions.generator.util.ClassUtil.getTypeDeclarationWithinPackage;
 
 import java.io.File;
 import java.io.FileWriter;
 import java.io.IOException;
-import java.lang.reflect.Method;
 import java.nio.file.Paths;
 import java.util.*;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
-import static com.google.common.collect.Sets.newHashSet;
-import static java.lang.String.format;
-import static org.apache.commons.lang3.StringUtils.*;
-import static org.assertj.assertions.generator.Template.Type.ASSERT_CLASS;
-import static org.assertj.assertions.generator.util.ClassUtil.getTypeDeclarationWithinPackage;
+import com.google.common.reflect.TypeToken;
+import org.assertj.assertions.generator.Template.Type;
+import org.assertj.assertions.generator.description.ClassDescription;
+import org.assertj.assertions.generator.description.DataDescription;
+import org.assertj.assertions.generator.description.FieldDescription;
+import org.assertj.assertions.generator.description.GetterDescription;
+import org.assertj.assertions.generator.util.ClassUtil;
 
 @SuppressWarnings("WeakerAccess")
 public class BaseAssertionGenerator implements AssertionGenerator, AssertionsEntryPointGenerator {
@@ -73,6 +71,14 @@ public class BaseAssertionGenerator implements AssertionGenerator, AssertionsEnt
   private static final String THROWS = "${throws}";
   private static final String THROWS_JAVADOC = "${throws_javadoc}";
   private static final String LINE_SEPARATOR = "\n";
+
+  private static final Comparator<String> ORDER_BY_INCREASING_LENGTH = new Comparator<String>() {
+    @Override
+    public int compare(final String o1, final String o2) {
+      return o1.length() - o2.length();
+    }
+  };
+
   // assertions classes are generated in their package directory starting from targetBaseDirectory.
   // ex : com.nba.Player -> targetBaseDirectory/com/nba/PlayerAssert.java
   private File targetBaseDirectory = Paths.get(".").toFile();
@@ -372,12 +378,7 @@ public class BaseAssertionGenerator implements AssertionGenerator, AssertionsEnt
   }
 
   private String determineBestEntryPointsAssertionsClassPackage(final Set<ClassDescription> classDescriptionSet) {
-    SortedSet<String> packages = new TreeSet<>(new Comparator<String>() {
-      @Override
-      public int compare(final String o1, final String o2) {
-        return o1.length() - o2.length();
-      }
-    });
+    SortedSet<String> packages = new TreeSet<>(ORDER_BY_INCREASING_LENGTH);
     for (ClassDescription classDescription : classDescriptionSet) {
       packages.add(classDescription.getPackageName());
     }
@@ -469,19 +470,13 @@ public class BaseAssertionGenerator implements AssertionGenerator, AssertionsEnt
   }
 
   private String assertionContentForField(FieldDescription field, ClassDescription classDescription) {
-    final TypeToken<?> owningType = field.getOwningType();
 
-    final String fieldName = field.getName();
-    final String fieldNameCap = capitalize(field.getName());
-    try {
-      Method m = owningType.getRawType().getMethod("get" + fieldNameCap);
-      if (classDescription.getGettersDescriptions().contains(new GetterDescription(fieldName, owningType, m))) {
-        return "";
-      }
-    } catch (NoSuchMethodException nsme) {
-      // ignore it, let flow keep going
+    if (classDescription.hasGetterForField(field)) {
+      // the assertion has already been generated using the getter to read the field
+      return "";
     }
 
+    final String fieldName = field.getName();
     String assertionContent = baseAssertionContentFor(field, classDescription);
 
     // we reuse template for properties to have consistent assertions for property and field but change the way we get
@@ -510,7 +505,7 @@ public class BaseAssertionGenerator implements AssertionGenerator, AssertionsEnt
       assertionContent = replace(assertionContent, PREDICATE, field.getPredicate());
       assertionContent = replace(assertionContent, PREDICATE_NEG, field.getNegativePredicate());
     }
-    assertionContent = replace(assertionContent, PROPERTY_WITH_UPPERCASE_FIRST_CHAR, fieldNameCap);
+    assertionContent = replace(assertionContent, PROPERTY_WITH_UPPERCASE_FIRST_CHAR, capitalize(field.getName()));
     assertionContent = replace(assertionContent, PROPERTY_SIMPLE_TYPE,
                                field.getTypeName(false, false));
     assertionContent = replace(assertionContent, PROPERTY_ASSERT_TYPE,
diff --git a/src/main/java/org/assertj/assertions/generator/description/ClassDescription.java b/src/main/java/org/assertj/assertions/generator/description/ClassDescription.java
index 15b6365..886b241 100644
--- a/src/main/java/org/assertj/assertions/generator/description/ClassDescription.java
+++ b/src/main/java/org/assertj/assertions/generator/description/ClassDescription.java
@@ -13,19 +13,24 @@
 package org.assertj.assertions.generator.description;
 
 import com.google.common.reflect.TypeToken;
+import org.apache.commons.lang3.StringUtils;
 import org.assertj.assertions.generator.util.ClassUtil;
 
 import java.util.Collection;
+import java.util.HashSet;
 import java.util.Objects;
 import java.util.Set;
 import java.util.TreeSet;
 
+import static com.google.common.collect.Sets.union;
+import static org.assertj.assertions.generator.util.ClassUtil.isBoolean;
+
 /**
- * 
+ *
  * Stores the information needed to generate assertions for a given class.
- * 
+ *
  * @author Joel Costigliola
- * 
+ *
  */
 public class ClassDescription implements Comparable<ClassDescription> {
 
@@ -49,7 +54,7 @@ public class ClassDescription implements Comparable<ClassDescription> {
   public String getClassName() {
     return type.getRawType().getName();
   }
-  
+
   public String getFullyQualifiedClassName() {
     return ClassUtil.getTypeDeclaration(type, false, true);
   }
@@ -65,7 +70,7 @@ public class ClassDescription implements Comparable<ClassDescription> {
   public String getClassNameWithOuterClassNotSeparatedByDots() {
     return ClassUtil.getTypeNameWithoutDots(getClassNameWithOuterClass()); //classTypeName.getSimpleNameWithOuterClassNotSeparatedByDots();
   }
-  
+
   public String getPackageName() {
     return type.getRawType().getPackage().getName();
   }
@@ -77,11 +82,11 @@ public class ClassDescription implements Comparable<ClassDescription> {
   public void addGetterDescriptions(Collection<GetterDescription> getterDescriptions) {
     this.gettersDescriptions.addAll(getterDescriptions);
   }
-  
+
   public void addFieldDescriptions(Set<FieldDescription> fieldDescriptions) {
     this.fieldsDescriptions.addAll(fieldDescriptions);
   }
-  
+
   public Set<FieldDescription> getFieldsDescriptions() {
     return fieldsDescriptions;
   }
@@ -101,7 +106,26 @@ public class ClassDescription implements Comparable<ClassDescription> {
   public void addDeclaredFieldDescriptions(Set<FieldDescription> declaredFieldDescriptions) {
     this.declaredFieldsDescriptions.addAll(declaredFieldDescriptions);
   }
-  
+
+  public boolean hasGetterForField(FieldDescription field) {
+    // get all getters with a return type == field type
+    Set<String> gettersCompatibleWithFieldType = new HashSet<>();
+    for (GetterDescription getter : union(this.gettersDescriptions, this.declaredGettersDescriptions)) {
+      if (Objects.equals(field.getValueType(), getter.getValueType())) {
+        gettersCompatibleWithFieldType.add(getter.getOriginalMember().getName());
+      }
+    }
+    // check boolean getters
+    final String capName = StringUtils.capitalize(field.getName());
+    if (field.isPredicate()) {
+      for (String prefix : ClassUtil.PREDICATE_PREFIXES.keySet()) {
+        if (gettersCompatibleWithFieldType.contains(prefix + capName)) return true;
+      }
+    }
+    // standard getter
+    return gettersCompatibleWithFieldType.contains("get" + capName);
+  }
+
   @Override
   public String toString() {
     return "ClassDescription [valueType=" + type + "]";
@@ -120,7 +144,7 @@ public class ClassDescription implements Comparable<ClassDescription> {
   public int hashCode() {
     return Objects.hash(type);
   }
-  
+
   @Override
   public int compareTo(ClassDescription o) {
     return type.getRawType().getName().compareTo(o.type.getRawType().getName());
@@ -134,7 +158,7 @@ public class ClassDescription implements Comparable<ClassDescription> {
   public void setSuperType(Class<?> superType) {
     // TypeToken#getSupertype(..) checks to make sure it is a super type
     if (superType != null) {
-      this.superType = type.getSupertype((Class)superType);
+      this.superType = type.getSupertype((Class) superType);
     }
   }
 }
diff --git a/src/main/java/org/assertj/assertions/generator/util/ClassUtil.java b/src/main/java/org/assertj/assertions/generator/util/ClassUtil.java
index 4ed3bef..3ffb55e 100644
--- a/src/main/java/org/assertj/assertions/generator/util/ClassUtil.java
+++ b/src/main/java/org/assertj/assertions/generator/util/ClassUtil.java
@@ -41,8 +41,6 @@ import static org.apache.commons.lang3.StringUtils.uncapitalize;
 
 /**
  * Some utilities methods related to classes and packages.
- *
- * @author Joel Costigliola
  */
 @SuppressWarnings("WeakerAccess")
 public class ClassUtil {
@@ -202,17 +200,12 @@ public class ClassUtil {
     return classes;
   }
 
-  /**
-   * @param loadedClass
-   * @return
-   */
-  private static boolean isClassCandidateToAssertionsGeneration(TypeToken<?> loadedClass) {
-    if (loadedClass == null) {
-      return false;
-    }
-
-    Class<?> raw = loadedClass.getRawType();
-    return isPublic(raw.getModifiers()) && !raw.isAnonymousClass() && !raw.isLocalClass();
+  private static boolean isClassCandidateToAssertionsGeneration(TypeToken<?> typeToken) {
+    if (typeToken == null) return false;
+    Class<?> raw = typeToken.getRawType();
+    return isPublic(raw.getModifiers())
+           && !raw.isAnonymousClass()
+           && !raw.isLocalClass();
   }
 
   private static boolean isClass(String fileName) {
@@ -234,12 +227,12 @@ public class ClassUtil {
   /**
    * Returns the property name of given getter method, examples :
    * <p/>
-   * 
+   *
    * <pre>
    * getName -> name
    * </pre>
    * <p/>
-   * 
+   *
    * <pre>
    * isMostValuablePlayer -> mostValuablePlayer
    * </pre>
@@ -279,8 +272,8 @@ public class ClassUtil {
 
   private static boolean isAnnotated(Method method, Set<Class<?>> includeAnnotations, boolean isClassAnnotated) {
     if (!Void.TYPE.equals(method.getReturnType())
-            && method.getParameterTypes().length == 0
-            && !isStatic(method.getModifiers())) {
+        && method.getParameterTypes().length == 0
+        && !isStatic(method.getModifiers())) {
       Annotation[] methodAnnotations = method.getAnnotations();
       return isClassAnnotated || containsAny(methodAnnotations, includeAnnotations);
     }
@@ -302,7 +295,7 @@ public class ClassUtil {
 
   static private final Pattern PREFIX_PATTERN;
 
-  static private final Map<String, String> PREDICATE_PREFIXES;
+  static public final Map<String, String> PREDICATE_PREFIXES;
 
   static private final Comparator<String> LONGEST_TO_SHORTEST = new Comparator<String>() {
     @Override
@@ -313,7 +306,7 @@ public class ClassUtil {
   };
 
   static {
-    String[][] predicates = new String[][] {
+    String[][] predicates = {
         { "is", "isNot" },
         { "was", "wasNot" },
         { "can", "cannot" },
@@ -459,16 +452,16 @@ public class ClassUtil {
    * Gets the simple name of the class but, unlike {@link Class#getSimpleName()}, it includes the name of the outer
    * class when <code>clazz</code> is an inner class.
    *
-   * @param clazz
-   * @return
+   * @param clazz the class
+   * @return the simple name of the class prefixed by the outer class if any (separated by dot)
    */
   public static String getSimpleNameWithOuterClass(Class<?> clazz) {
     if (isNotNestedClass(clazz)) {
       return clazz.getSimpleName();
     }
     String nestedClassName = clazz.getName();
-    nestedClassName = nestedClassName.substring(clazz.getPackage().getName().length() + 1);
-    nestedClassName = nestedClassName.replace('$', '.');
+        nestedClassName = nestedClassName.substring(clazz.getPackage().getName().length() + 1);
+        nestedClassName = nestedClassName.replace('$', '.');
     return nestedClassName;
   }
 
@@ -477,13 +470,13 @@ public class ClassUtil {
    * class when <code>clazz</code> is an inner class, both class names are concatenated.
    * <p>
    * Example:
-   * 
+   *
    * <pre>
-   * Outer.Inner -> OuterInner 
+   * Outer.Inner -> OuterInner
    * </pre>
    *
-   * @param clazz
-   * @return
+   * @param clazz the class
+   * @return the simple name of the class prefixed by the outer class if any
    */
   public static String getSimpleNameWithOuterClassNotSeparatedByDots(Class<?> clazz) {
     if (isNotNestedClass(clazz)) {
@@ -535,18 +528,7 @@ public class ClassUtil {
    */
   public static boolean isInnerPackageOf(Package child, Package parent) {
     return child != null && parent != null
-        && child.getName().startsWith(parent.getName());
-  }
-
-  /**
-   * Utility version that allows to pass a string and {@link Package}.
-   * <br/>
-   * Delegates to {@link #isInnerPackageOf(String, String)}.
-   *
-   * @see #isInnerPackageOf(String, String)
-   */
-  public static boolean isInnerPackageOf(Package child, String parent) {
-    return child != null && isInnerPackageOf(child.getName(), parent);
+           && child.getName().startsWith(parent.getName());
   }
 
   /**
@@ -612,7 +594,7 @@ public class ClassUtil {
   public static String getTypeDeclarationWithinPackage(TypeToken<?> type, String packageName, final boolean asParameter) {
 
     boolean reqFQN = !Objects.equals(packageName, JAVA_LANG_PACKAGE.getName())
-        && (!type.isPrimitive() && !type.isArray() && !Objects.equals(packageName, type.getRawType().getPackage().getName()));
+                     && (!type.isPrimitive() && !type.isArray() && !Objects.equals(packageName, type.getRawType().getPackage().getName()));
     StringBuilder bld = new StringBuilder();
     getTypeDeclaration(bld, packageName, type, asParameter, reqFQN);
     return bld.toString();
@@ -623,7 +605,8 @@ public class ClassUtil {
    * @see #getTypeDeclaration(TypeToken, boolean, boolean)
    * @see #getTypeDeclarationWithinPackage(TypeToken, String, boolean)
    */
-  private static void getTypeDeclaration(StringBuilder bld, String basePackage, TypeToken<?> type, boolean asParameter, boolean fullyQualified) {
+  private static void getTypeDeclaration(StringBuilder bld, String basePackage, TypeToken<?> type, boolean asParameter,
+                                         boolean fullyQualified) {
 
     Class<?> raw = type.getRawType();
 
@@ -690,9 +673,9 @@ public class ClassUtil {
           Package paramPackage = paramType.getRawType().getPackage();
 
           getTypeDeclaration(bld, basePackage, paramType, false,
-              fullyQualified
-                  || ((paramPackage != null && !Objects.equals(basePackage, paramPackage.getName()))
-                  && Objects.equals(paramPackage, raw.getPackage())));
+                             fullyQualified
+                             || ((paramPackage != null && !Objects.equals(basePackage, paramPackage.getName()))
+                                 && Objects.equals(paramPackage, raw.getPackage())));
         }
 
         bld.append(">");
diff --git a/src/test/java/org/assertj/assertions/generator/data/FieldPropertyClash.java b/src/test/java/org/assertj/assertions/generator/data/FieldPropertyClash.java
index 3bb6238..a0b5d24 100644
--- a/src/test/java/org/assertj/assertions/generator/data/FieldPropertyClash.java
+++ b/src/test/java/org/assertj/assertions/generator/data/FieldPropertyClash.java
@@ -20,4 +20,24 @@ public class FieldPropertyClash {
   public String getString() {
 	return "";
   }
+
+  // joel-costigliola/assertj-assertions-generator#105
+  // Predicate properties were not properly discerned vs non-predicate
+  public boolean isBoolean;
+  public boolean isBoolean() { return false; }
+
+  public boolean isNotBoolean() { return false; }
+
+
+  public boolean shouldNotBeSomewhere;
+  public boolean shouldNotBeSomewhere() { return shouldNotBeSomewhere; }
+
+  // different "tenses"
+  public boolean willBeOutside;
+  public boolean willNotBeOutside() { return willBeOutside; }
+
+  //
+  public boolean willNotBeUpsideDown;
+  public boolean willBeUpsideDown() { return !willNotBeUpsideDown; }
+
 }
diff --git a/src/test/java/org/assertj/assertions/generator/description/FieldDescriptionTest.java b/src/test/java/org/assertj/assertions/generator/description/FieldDescriptionTest.java
index fe0ccb0..58a7e0f 100644
--- a/src/test/java/org/assertj/assertions/generator/description/FieldDescriptionTest.java
+++ b/src/test/java/org/assertj/assertions/generator/description/FieldDescriptionTest.java
@@ -12,13 +12,16 @@
  */
 package org.assertj.assertions.generator.description;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
+import java.util.Arrays;
+import java.util.Collections;
+
 import com.google.common.reflect.TypeToken;
 import org.assertj.assertions.generator.data.Name;
 import org.assertj.assertions.generator.data.nba.Player;
 import org.junit.Test;
 
-import static org.assertj.core.api.Assertions.assertThat;
-
 public class FieldDescriptionTest {
 
   private static final TypeToken<Player> PLAYER_TYPE = TypeToken.of(Player.class);
@@ -82,4 +85,117 @@ public class FieldDescriptionTest {
     assertThat(fieldDescription.getPredicateForErrorMessagePart1()).isEqualTo("is disabled");
     assertThat(fieldDescription.getPredicateForErrorMessagePart2()).isEqualTo("is not");
   }
+
+  private static final TypeToken<FieldPropertyNames> FIELD_PROP_TYPE = TypeToken.of(FieldPropertyNames.class);
+  
+  private static class FieldPropertyNames {
+    public boolean isBoolean = true;
+    public boolean isBoolean() {
+      return isBoolean;
+    }
+    
+    public boolean isNotBoolean() {
+      return !isBoolean;
+    }
+
+    public String stringProp;
+    
+    public String getStringProp() {
+      return stringProp;
+    }
+
+    public int onlyField;
+    
+    public String badGetter;
+    public int getBadGetter() {
+      return -1;
+    }
+  }
+
+  @Test
+  public void should_find_getter_method_for_predicate_field() throws Exception {
+
+    fieldDescription = new FieldDescription(FieldPropertyNames.class.getDeclaredField("isBoolean"), FIELD_PROP_TYPE);
+
+    GetterDescription posGetter = new GetterDescription("boolean", FIELD_PROP_TYPE,
+            FieldPropertyNames.class.getMethod("isBoolean"));
+    GetterDescription negGetter = new GetterDescription("boolean", FIELD_PROP_TYPE,
+            FieldPropertyNames.class.getMethod("isNotBoolean"));
+
+    ClassDescription classDesc = new ClassDescription(FIELD_PROP_TYPE);
+    classDesc.addGetterDescriptions(Arrays.asList(posGetter, negGetter));
+
+    assertThat(classDesc.hasGetterForField(fieldDescription))
+            .as("Correctly identifies there is a getter")
+            .isTrue();
+  }
+
+  @Test
+  public void should_find_getter_method_for_field() throws Exception {
+
+    fieldDescription = new FieldDescription(FieldPropertyNames.class.getDeclaredField("stringProp"), FIELD_PROP_TYPE);
+
+    GetterDescription getter = new GetterDescription("stringProp", FIELD_PROP_TYPE,
+            FieldPropertyNames.class.getMethod("getStringProp"));
+
+    ClassDescription classDesc = new ClassDescription(FIELD_PROP_TYPE);
+    classDesc.addGetterDescriptions(Collections.singletonList(getter));
+
+    assertThat(classDesc.hasGetterForField(fieldDescription))
+            .as("Correctly identifies there is a getter")
+            .isTrue();
+  }
+
+  @Test
+  public void should_not_find_getter_method_for_mismatched_return_type() throws Exception {
+
+    fieldDescription = new FieldDescription(FieldPropertyNames.class.getDeclaredField("badGetter"), FIELD_PROP_TYPE);
+
+    GetterDescription getter = new GetterDescription("badGetter", FIELD_PROP_TYPE,
+            FieldPropertyNames.class.getMethod("getBadGetter"));
+    
+    ClassDescription classDesc = new ClassDescription(FIELD_PROP_TYPE);
+    classDesc.addGetterDescriptions(Collections.singletonList(getter));
+
+    assertThat(classDesc.hasGetterForField(fieldDescription))
+            .as("Correctly identifies there is no getter")
+            .isFalse();
+  }
+
+
+  @Test
+  public void should_not_find_getter_method_for_missing_getter() throws Exception {
+
+    fieldDescription = new FieldDescription(FieldPropertyNames.class.getDeclaredField("onlyField"), FIELD_PROP_TYPE);
+
+    ClassDescription classDesc = new ClassDescription(FIELD_PROP_TYPE);
+
+    assertThat(classDesc.hasGetterForField(fieldDescription))
+            .as("Correctly identifies there is no getter")
+            .isFalse();
+  }
+  
+  // Given that everything is written via reflection, we can not actually get access to a 
+  // non-existant field anymore. Thus, there is no need to test it!
+//  @Test
+//  public void should_not_find_getter_method_for_non_existant_field() throws Exception {
+//    
+//  }
+
+  @Test(expected = NullPointerException.class)
+  public void should_fail_find_with_npe_for_null_field_desc() throws Exception {
+
+    ClassDescription classDesc = new ClassDescription(FIELD_PROP_TYPE);
+
+    classDesc.hasGetterForField(null);
+  }
+
+  @Test(expected = NullPointerException.class)
+  public void should_fail_has_with_npe_for_null_field_desc() throws Exception {
+
+    ClassDescription classDesc = new ClassDescription(FIELD_PROP_TYPE);
+
+    classDesc.hasGetterForField(null);
+  }
+  
 }
diff --git a/src/test/resources/FieldPropertyClash.expected.txt b/src/test/resources/FieldPropertyClash.expected.txt
index 1a2be51..da79bf4 100644
--- a/src/test/resources/FieldPropertyClash.expected.txt
+++ b/src/test/resources/FieldPropertyClash.expected.txt
@@ -28,6 +28,114 @@ public class FieldPropertyClashAssert extends AbstractObjectAssert<FieldProperty
     return new FieldPropertyClashAssert(actual);
   }
 
+  /**
+   * Verifies that the actual FieldPropertyClash is boolean.
+   * @return this assertion object.
+   * @throws AssertionError - if the actual FieldPropertyClash is not boolean.
+   */
+  public FieldPropertyClashAssert isBoolean() {
+    // check that actual FieldPropertyClash we want to make assertions on is not null.
+    isNotNull();
+
+    // check
+    if (!actual.isBoolean()) {
+      failWithMessage("\nExpecting that actual FieldPropertyClash is boolean but is not.");
+    }
+
+    // return the current assertion for method chaining
+    return this;
+  }
+
+  /**
+   * Verifies that the actual FieldPropertyClash is not boolean.
+   * @return this assertion object.
+   * @throws AssertionError - if the actual FieldPropertyClash is boolean.
+   */
+  public FieldPropertyClashAssert isNotBoolean() {
+    // check that actual FieldPropertyClash we want to make assertions on is not null.
+    isNotNull();
+
+    // check
+    if (!actual.isNotBoolean()) {
+      failWithMessage("\nExpecting that actual FieldPropertyClash is not boolean but is.");
+    }
+
+    // return the current assertion for method chaining
+    return this;
+  }
+
+  /**
+   * Verifies that the actual FieldPropertyClash will not be outside.
+   * @return this assertion object.
+   * @throws AssertionError - if the actual FieldPropertyClash will be outside.
+   */
+  public FieldPropertyClashAssert willNotBeOutside() {
+    // check that actual FieldPropertyClash we want to make assertions on is not null.
+    isNotNull();
+
+    // check that property call/field access is true
+    if (!actual.willNotBeOutside()) {
+      failWithMessage("\nExpecting that actual FieldPropertyClash will not be outside but will be.");
+    }
+
+    // return the current assertion for method chaining
+    return this;
+  }
+
+  /**
+   * Verifies that the actual FieldPropertyClash will be outside.
+   * @return this assertion object.
+   * @throws AssertionError - if the actual FieldPropertyClash will not be outside.
+   */
+  public FieldPropertyClashAssert willBeOutside() {
+    // check that actual FieldPropertyClash we want to make assertions on is not null.
+    isNotNull();
+
+    // check that property call/field access is false
+    if (actual.willNotBeOutside()) {
+      failWithMessage("\nExpecting that actual FieldPropertyClash will be outside but will not be.");
+    }
+
+    // return the current assertion for method chaining
+    return this;
+  }
+
+  /**
+   * Verifies that the actual FieldPropertyClash should not be somewhere.
+   * @return this assertion object.
+   * @throws AssertionError - if the actual FieldPropertyClash should be somewhere.
+   */
+  public FieldPropertyClashAssert shouldNotBeSomewhere() {
+    // check that actual FieldPropertyClash we want to make assertions on is not null.
+    isNotNull();
+
+    // check that property call/field access is true
+    if (!actual.shouldNotBeSomewhere()) {
+      failWithMessage("\nExpecting that actual FieldPropertyClash should not be somewhere but should be.");
+    }
+
+    // return the current assertion for method chaining
+    return this;
+  }
+
+  /**
+   * Verifies that the actual FieldPropertyClash should be somewhere.
+   * @return this assertion object.
+   * @throws AssertionError - if the actual FieldPropertyClash should not be somewhere.
+   */
+  public FieldPropertyClashAssert shouldBeSomewhere() {
+    // check that actual FieldPropertyClash we want to make assertions on is not null.
+    isNotNull();
+
+    // check that property call/field access is false
+    if (actual.shouldNotBeSomewhere()) {
+      failWithMessage("\nExpecting that actual FieldPropertyClash should be somewhere but is not.");
+    }
+
+    // return the current assertion for method chaining
+    return this;
+  }
+
   /**
    * Verifies that the actual FieldPropertyClash's string is equal to the given one.
    * @param string the given string to compare the actual FieldPropertyClash's string to.
@@ -51,5 +159,45 @@ public class FieldPropertyClashAssert extends AbstractObjectAssert<FieldProperty
     return this;
   }
 
+  /**
+   * Verifies that the actual FieldPropertyClash will be upside down.
+   * @return this assertion object.
+   * @throws AssertionError - if the actual FieldPropertyClash will not be upside down.
+   */
+  public FieldPropertyClashAssert willBeUpsideDown() {
+    // check that actual FieldPropertyClash we want to make assertions on is not null.
+    isNotNull();
+
+    // check that property call/field access is true
+    if (!actual.willBeUpsideDown()) {
+      failWithMessage("\nExpecting that actual FieldPropertyClash will be upside down but will not be.");
+    }
+
+    // return the current assertion for method chaining
+    return this;
+  }
+
+  /**
+   * Verifies that the actual FieldPropertyClash will not be upside down.
+   * @return this assertion object.
+   * @throws AssertionError - if the actual FieldPropertyClash will be upside down.
+   */
+  public FieldPropertyClashAssert willNotBeUpsideDown() {
+    // check that actual FieldPropertyClash we want to make assertions on is not null.
+    isNotNull();
+
+    // check that property call/field access is false
+    if (actual.willBeUpsideDown()) {
+      failWithMessage("\nExpecting that actual FieldPropertyClash will not be upside down but will be.");
+    }
+
+    // return the current assertion for method chaining
+    return this;
+  }
+
+
+
+
+
 
 }
