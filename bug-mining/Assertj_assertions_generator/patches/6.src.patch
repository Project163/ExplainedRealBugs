diff --git a/pom.xml b/pom.xml
index d005190..7c22271 100644
--- a/pom.xml
+++ b/pom.xml
@@ -37,13 +37,13 @@
     <dependency>
       <groupId>ch.qos.logback</groupId>
       <artifactId>logback-classic</artifactId>
-      <version>1.0.12</version>
+      <version>1.0.13</version>
     </dependency>
     <!-- test dependencies -->
     <dependency>
       <groupId>org.assertj</groupId>
       <artifactId>assertj-core</artifactId>
-      <version>1.4.0</version>
+      <version>1.5.0</version>
       <scope>test</scope>
     </dependency>
     <dependency>
diff --git a/src/main/java/org/assertj/assertions/generator/AssertionGenerator.java b/src/main/java/org/assertj/assertions/generator/AssertionGenerator.java
index 99db450..5c2c690 100644
--- a/src/main/java/org/assertj/assertions/generator/AssertionGenerator.java
+++ b/src/main/java/org/assertj/assertions/generator/AssertionGenerator.java
@@ -2,6 +2,7 @@ package org.assertj.assertions.generator;
 
 import java.io.File;
 import java.io.IOException;
+import java.util.Set;
 
 import org.assertj.assertions.generator.description.ClassDescription;
 
@@ -9,49 +10,49 @@ import org.assertj.assertions.generator.description.ClassDescription;
 public interface AssertionGenerator {
 
   /**
-   * Builds and returns the the custom assertion java file for the given {@link ClassDescription}.
+   * Builds and returns the custom assertion java file for the given {@link ClassDescription}.
    * <p>
    * Let's say we have the {@link ClassDescription} corresponding to :
-   * 
+   *
    * <pre>
    * public class Race {
-   * 
+   *
    *   private final String name;
    *   private final boolean immortal;
-   * 
+   *
    *   public Race(String name, boolean immortal) {
    *     this.name = name;
    *     this.immortal = immortal;
    *   }
-   * 
+   *
    *   public String getName() {
    *     return name;
    *   }
-   * 
+   *
    *   public boolean isImmortal() {
    *     return immortal;
    *   }
    * }
    * </pre>
-   * 
+   *
    * We will generate assertions specific to <code>Race</code> in <code>RaceAssert</code> class, like :
-   * 
+   *
    * <pre>
    * import static java.lang.String.format;
-   * 
+   *
    * import org.assertj.core.api.AbstractAssert;
    * import org.assertj.core.api.Assertions;
-   * 
+   *
    * public class RaceAssert extends AbstractAssert<RaceAssert, Race> {
-   * 
+   *
    *   public RaceAssert(Race actual) {
    *     super(actual, RaceAssert.class);
    *   }
-   * 
+   *
    *   public static RaceAssert assertThat(Race actual) {
    *     return new RaceAssert(actual);
    *   }
-   * 
+   *
    *   public RaceAssert hasName(String name) {
    *     // check that actual Race we want to make assertions on is not null.
    *     isNotNull();
@@ -59,11 +60,11 @@ public interface AssertionGenerator {
    *     String errorMessage = format("Expected Race's name to be <%s> but was <%s>", name, actual.getName());
    *     // check
    *     if (!actual.getName().equals(name)) { throw new AssertionError(errorMessage); }
-   * 
+   *
    *     // return the current assertion for method chaining
    *     return this;
    *   }
-   * 
+   *
    *   public RaceAssert isImmortal() {
    *     // check that actual Race we want to make assertions on is not null.
    *     isNotNull();
@@ -75,15 +76,16 @@ public interface AssertionGenerator {
    *     return this;
    *   }
    * </pre>
-   * 
+   *
    * @param classDescription the {@link ClassDescription} used to generate tha assertions class.
    * @return the custom assertion java file for the given class
    * @throws IOException if something went wrong when creating the assertion file.
    */
 
   File generateCustomAssertionFor(ClassDescription classDescription) throws IOException;
+
   /**
-   * Builds and returns the the custom assertion java file for the given {@link ClassDescription}.
+   * Builds and returns the custom assertion java file content for the given {@link ClassDescription}.
    * <p>
    * Let's say we have the {@link ClassDescription} corresponding to :
    *
@@ -156,4 +158,29 @@ public interface AssertionGenerator {
    */
   String generateCustomAssertionContentFor(ClassDescription classDescription) throws IOException;
 
+  /**
+   * Returns the content of the assertions entry point class for the given {@link ClassDescription} set.
+   * <p>
+   * The idea is to generate an equivalent of assertj-core Assertions class that gives easy access to all AssertJ Core
+   * assertions.
+   *
+   * @param classDescriptionSet the set of ClassDescription whose assertion calls will be in the generated entry point
+   *                            class content.
+   * @return the assertions entry point class content
+   */
+  String generateAssertionsEntryPointContentFor(Set<ClassDescription> classDescriptionSet);
+
+  /**
+   * Returns the assertions entry point class file for the given {@link ClassDescription} set.
+   * <p>
+   * The idea is to generate an equivalent of assertj-core Assertions class that gives easy access to all AssertJ Core
+   * assertions.
+   *
+   * @param classDescriptionSet the set of ClassDescription whose assertion calls will be in the generated entry point
+   *                            class.
+   * @return the assertions entry point class file.
+   * @throws IOException if assertions entry point class file can't be created.
+   */
+  File generateAssertionsEntryPointFor(Set<ClassDescription> classDescriptionSet) throws IOException;
+
 }
\ No newline at end of file
diff --git a/src/main/java/org/assertj/assertions/generator/BaseAssertionGenerator.java b/src/main/java/org/assertj/assertions/generator/BaseAssertionGenerator.java
index 2a4eb22..22d436b 100644
--- a/src/main/java/org/assertj/assertions/generator/BaseAssertionGenerator.java
+++ b/src/main/java/org/assertj/assertions/generator/BaseAssertionGenerator.java
@@ -18,10 +18,12 @@ import static org.apache.commons.lang3.StringUtils.capitalize;
 import static org.apache.commons.lang3.StringUtils.isEmpty;
 
 import java.io.File;
-import java.io.FileNotFoundException;
 import java.io.FileWriter;
 import java.io.IOException;
+import java.util.Comparator;
 import java.util.Set;
+import java.util.SortedSet;
+import java.util.TreeSet;
 
 import org.assertj.assertions.generator.Template.Type;
 import org.assertj.assertions.generator.description.ClassDescription;
@@ -32,26 +34,32 @@ public class BaseAssertionGenerator implements AssertionGenerator {
 
   // default file for templates
   static final String DEFAULT_IS_ASSERTION_TEMPLATE = "is_assertion_template.txt";
-  static final String DEFAULT_HAS_ELEMENTS_ASSERTION_TEMPLATE_FOR_ARRAY = "has_elements_assertion_template_for_array.txt";
-  static final String DEFAULT_HAS_ELEMENTS_ASSERTION_TEMPLATE_FOR_ITERABLE = "has_elements_assertion_template_for_iterable.txt";
+  static final String DEFAULT_HAS_ELEMENTS_ASSERTION_TEMPLATE_FOR_ARRAY =
+    "has_elements_assertion_template_for_array.txt";
+  static final String DEFAULT_HAS_ELEMENTS_ASSERTION_TEMPLATE_FOR_ITERABLE =
+    "has_elements_assertion_template_for_iterable.txt";
   static final String DEFAULT_HAS_ASSERTION_TEMPLATE = "has_assertion_template.txt";
   static final String DEFAULT_HAS_ASSERTION_TEMPLATE_FOR_PRIMITIVE = "has_assertion_template_for_primitive.txt";
   static final String DEFAULT_CUSTOM_ASSERTION_CLASS_TEMPLATE = "custom_assertion_class_template.txt";
+  static final String DEFAULT_ENTRY_POINT_ASSERTIONS_CLASS_TEMPLATE = "entry_point_assertions_class_template.txt";
+  static final String DEFAULT_ENTRY_POINT_ASSERTION_TEMPLATE = "entry_point_assertion_template.txt";
   static final String ASSERT_CLASS_SUFFIX = "Assert";
   static final String ASSERT_CLASS_FILE_SUFFIX = ASSERT_CLASS_SUFFIX + ".java";
   static final String TEMPLATES_DIR = "templates" + File.separator;
   private static final String IMPORT_LINE = "import %s;%s";
   private static final String PROPERTY_WITH_UPPERCASE_FIRST_CHAR_REGEXP = "\\$\\{Property\\}";
   private static final String PROPERTY_WITH_LOWERCASE_FIRST_CHAR_REGEXP = "\\$\\{property\\}";
-  private static final String PACKAGE__REGEXP = "\\$\\{package\\}";
-  private static final String PACKAGE_FULL__REGEXP = "\\$\\{package_full\\}";
+  private static final String PACKAGE_REGEXP = "\\$\\{package\\}";
+  private static final String PACKAGE_FULL_REGEXP = "\\$\\{package_full\\}";
   private static final String PROPERTY_TYPE_REGEXP = "\\$\\{propertyType\\}";
   private static final String CLASS_TO_ASSERT_REGEXP = "\\$\\{class_to_assert\\}";
   private static final String ELEMENT_TYPE_REGEXP = "\\$\\{elementType\\}";
+  private static final String ALL_ASSERTIONS_ENTRY_POINTS = "\\$\\{all_assertions_entry_points\\}";
   private static final String IMPORTS = "${imports}";
   private static final String THROWS = "${throws}";
   private static final String THROWS_JAVADOC = "${throws_javadoc}";
   private static final String LINE_SEPARATOR = System.getProperty("line.separator");
+  private static final String ASSERTIONS_ENTRY_POINT_FILE = "Assertions.java";
   // assertions classes are generated in their package directory starting from targetBaseDirectory.
   // ex : com.nba.Player -> targetBaseDirectory/com/nba/PlayerAssert.java
   private String targetBaseDirectory = ".";
@@ -61,12 +69,13 @@ public class BaseAssertionGenerator implements AssertionGenerator {
   private Template hasIterableElementsAssertionTemplate;
   private Template hasArrayElementsAssertionTemplate;
   private Template isAssertionTemplate;
+  private Template entryPointAssertionsClassTemplate;
+  private Template entryPointAssertionTemplate;
 
   /**
    * Creates a new </code>{@link BaseAssertionGenerator}</code> with default templates directory.
    *
-   * @throws FileNotFoundException if some template file could not be found
-   * @throws IOException           if some template file could not be read
+   * @throws IOException if some template file could not be found or read
    */
   public BaseAssertionGenerator() throws IOException {
     this(TEMPLATES_DIR);
@@ -76,19 +85,27 @@ public class BaseAssertionGenerator implements AssertionGenerator {
    * Creates a new </code>{@link BaseAssertionGenerator}</code> with in the specified directory.
    *
    * @param templatesDirectory path where to find templates
-   * @throws FileNotFoundException if some template file could not be found
-   * @throws IOException           if some template file could not be read
+   * @throws IOException if some template file could not be found or read
    */
-  public BaseAssertionGenerator(String templatesDirectory) throws FileNotFoundException, IOException {
+  public BaseAssertionGenerator(String templatesDirectory) throws IOException {
     this(
-        new Template(Template.Type.ASSERT_CLASS, new File(templatesDirectory, DEFAULT_CUSTOM_ASSERTION_CLASS_TEMPLATE)), //
-        new Template(Template.Type.HAS, new File(templatesDirectory, DEFAULT_HAS_ASSERTION_TEMPLATE)), //
-        new Template(Template.Type.HAS_FOR_PRIMITIVE, new File(templatesDirectory, DEFAULT_HAS_ASSERTION_TEMPLATE_FOR_PRIMITIVE)), //
-        new Template(Template.Type.HAS_FOR_ITERABLE, new File(templatesDirectory,
-            DEFAULT_HAS_ELEMENTS_ASSERTION_TEMPLATE_FOR_ITERABLE)), //
-        new Template(Template.Type.HAS_FOR_ARRAY, new File(templatesDirectory,
-            DEFAULT_HAS_ELEMENTS_ASSERTION_TEMPLATE_FOR_ARRAY)), //
-        new Template(Template.Type.IS, new File(templatesDirectory, DEFAULT_IS_ASSERTION_TEMPLATE)));
+          new Template(Template.Type.ASSERT_CLASS,
+                       new File(templatesDirectory, DEFAULT_CUSTOM_ASSERTION_CLASS_TEMPLATE)),
+          new Template(Template.Type.HAS,
+                       new File(templatesDirectory, DEFAULT_HAS_ASSERTION_TEMPLATE)),
+          new Template(Template.Type.HAS_FOR_PRIMITIVE,
+                       new File(templatesDirectory, DEFAULT_HAS_ASSERTION_TEMPLATE_FOR_PRIMITIVE)),
+          new Template(Template.Type.HAS_FOR_ITERABLE,
+                       new File(templatesDirectory, DEFAULT_HAS_ELEMENTS_ASSERTION_TEMPLATE_FOR_ITERABLE)),
+          new Template(Template.Type.HAS_FOR_ARRAY,
+                       new File(templatesDirectory, DEFAULT_HAS_ELEMENTS_ASSERTION_TEMPLATE_FOR_ARRAY)),
+          new Template(Template.Type.IS,
+                       new File(templatesDirectory, DEFAULT_IS_ASSERTION_TEMPLATE)),
+          new Template(Type.ENTRY_POINT_ASSERTIONS_CLASS,
+                       new File(templatesDirectory, DEFAULT_ENTRY_POINT_ASSERTIONS_CLASS_TEMPLATE)),
+          new Template(Type.ENTRY_POINT_ASSERTION,
+                       new File(templatesDirectory, DEFAULT_ENTRY_POINT_ASSERTION_TEMPLATE))
+    );
   }
 
   /**
@@ -101,17 +118,25 @@ public class BaseAssertionGenerator implements AssertionGenerator {
    * @param hasArrayElementsAssertionTemplate
    *
    * @param isAssertionTemplate
+   * @param entryPointAssertionsClassTemplate
+   *
+   * @param entryPointAssertionTemplate
    */
   public BaseAssertionGenerator(Template classAssertionTemplate, Template hasAssertionTemplate,
                                 Template hasAssertionTemplateForPrimitive,
-                                Template hasIterableElementsAssertionTemplate, Template hasArrayElementsAssertionTemplate,
-                                Template isAssertionTemplate) {
+                                Template hasIterableElementsAssertionTemplate,
+                                Template hasArrayElementsAssertionTemplate,
+                                Template isAssertionTemplate,
+                                Template entryPointAssertionsClassTemplate,
+                                Template entryPointAssertionTemplate) {
     this.setAssertionClassTemplate(classAssertionTemplate);
     this.setHasAssertionTemplate(hasAssertionTemplate);
     this.setHasAssertionTemplateForPrimitive(hasAssertionTemplateForPrimitive);
     this.setHasElementsAssertionForIterableTemplate(hasIterableElementsAssertionTemplate);
     this.setHasElementsAssertionForArrayTemplate(hasArrayElementsAssertionTemplate);
     this.setIsAssertionTemplate(isAssertionTemplate);
+    this.setEntryPointAssertionsClassTemplate(entryPointAssertionsClassTemplate);
+    this.setEntryPointAssertionTemplate(entryPointAssertionTemplate);
   }
 
   /**
@@ -150,6 +175,16 @@ public class BaseAssertionGenerator implements AssertionGenerator {
     this.isAssertionTemplate = isAssertionTemplate;
   }
 
+  public void setEntryPointAssertionsClassTemplate(final Template entryPointAssertionsClassTemplate) {
+    checkTemplateParameter(entryPointAssertionsClassTemplate, Type.ENTRY_POINT_ASSERTIONS_CLASS);
+    this.entryPointAssertionsClassTemplate = entryPointAssertionsClassTemplate;
+  }
+
+  public void setEntryPointAssertionTemplate(final Template entryPointAssertionTemplate) {
+    checkTemplateParameter(entryPointAssertionTemplate, Type.ENTRY_POINT_ASSERTION);
+    this.entryPointAssertionTemplate = entryPointAssertionTemplate;
+  }
+
   public void setDirectoryWhereAssertionFilesAreGenerated(String targetBaseDirectory) {
     this.targetBaseDirectory = targetBaseDirectory;
   }
@@ -162,11 +197,11 @@ public class BaseAssertionGenerator implements AssertionGenerator {
     // Assertion content
     String assertionFileContent = generateCustomAssertionContentFor(classDescription);
     // finally create the assertion file, located in its package directory starting from targetBaseDirectory
-    String targetDirectory = getTargetDirectoryPathFor(classDescription);
+    String targetDirectory = getDirectoryPathCorrespondingToPackage(classDescription.getPackageName());
     // build any needed directories
     new File(targetDirectory).mkdirs();
     return createCustomAssertionFile(assertionFileContent, classDescription.getClassName() + ASSERT_CLASS_FILE_SUFFIX,
-        targetDirectory);
+                                     targetDirectory);
   }
 
   public String generateCustomAssertionContentFor(ClassDescription classDescription) throws IOException {
@@ -178,40 +213,124 @@ public class BaseAssertionGenerator implements AssertionGenerator {
     assertionFileContentBuilder.append(generateAssertionsForGettersOf(classDescription));
 
     // close class with }
-    assertionFileContentBuilder.append(LINE_SEPARATOR).append("}").append(LINE_SEPARATOR);
 
-    String className = classDescription.getClassName(); // className could be a nested class like
-                                                        // "OuterClass.NestedClass"
+    assertionFileContentBuilder.append(LINE_SEPARATOR).append("}").append(LINE_SEPARATOR);
+    // className could be a nested class like "OuterClass.NestedClass"
+    String className = classDescription.getClassName();
 
     // resolve template markers
     String assertionFileContent = assertionFileContentBuilder.toString();
-    assertionFileContent = assertionFileContent.replaceAll(PACKAGE__REGEXP, classDescription.getPackageName());
-    assertionFileContent = assertionFileContent.replaceAll(CLASS_TO_ASSERT_REGEXP + ASSERT_CLASS_SUFFIX, className
-        + ASSERT_CLASS_SUFFIX);
+    assertionFileContent = assertionFileContent.replaceAll(PACKAGE_REGEXP, classDescription.getPackageName());
+    assertionFileContent = assertionFileContent.replaceAll(CLASS_TO_ASSERT_REGEXP + ASSERT_CLASS_SUFFIX,
+                                                           className + ASSERT_CLASS_SUFFIX);
     // used for no package class.
-    assertionFileContent = assertionFileContent.replaceAll(PACKAGE_FULL__REGEXP,
-        isEmpty(classDescription.getPackageName()) ? "" : "package " + classDescription.getPackageName() + ";");
-    assertionFileContent = assertionFileContent.replaceAll(CLASS_TO_ASSERT_REGEXP, classDescription.getClassNameWithOuterClass());
-    assertionFileContent = assertionFileContent.replace(IMPORTS,
-        listImports(classDescription.getImports(), classDescription.getPackageName()));
-
+    assertionFileContent = assertionFileContent.replaceAll(PACKAGE_FULL_REGEXP,
+                                                           isEmpty(classDescription.getPackageName()) ? "" :
+                                                             "package " + classDescription.getPackageName() + ";");
+    assertionFileContent = assertionFileContent.replaceAll(CLASS_TO_ASSERT_REGEXP,
+                                                           classDescription.getClassNameWithOuterClass());
+    assertionFileContent = assertionFileContent.replace(IMPORTS, listImports(classDescription.getImports(),
+                                                                             classDescription.getPackageName()));
     return assertionFileContent;
   }
 
+  @Override
+  public String generateAssertionsEntryPointContentFor(final Set<ClassDescription> classDescriptionSet) {
+    final String entryPointAssertionsClassTemplateContent = entryPointAssertionsClassTemplate.getContent();
+    String entryPointAssertionsClassContent = new StringBuilder(entryPointAssertionsClassTemplateContent).toString();
+    // resolve template markers
+    String entryPointAssertionsClassPackage = determineEntryPointsAssertionsClassPackage(classDescriptionSet);
+    entryPointAssertionsClassContent = entryPointAssertionsClassContent.replaceAll(PACKAGE_REGEXP,
+                                                                                   entryPointAssertionsClassPackage);
+    String entryPointAssertionsImportsContent = generateEntryPointsAssertionsImportFor(classDescriptionSet,
+                                                                                       entryPointAssertionsClassPackage);
+    entryPointAssertionsClassContent = entryPointAssertionsClassContent.replace(IMPORTS,
+                                                                                entryPointAssertionsImportsContent);
+    String allEntryPointsAssertionContent = generateAssertThatEntryPointsAssertionsFor(classDescriptionSet);
+    entryPointAssertionsClassContent = entryPointAssertionsClassContent.replaceAll(ALL_ASSERTIONS_ENTRY_POINTS,
+                                                                                   allEntryPointsAssertionContent);
+    return entryPointAssertionsClassContent;
+  }
+
+  @Override
+  public File generateAssertionsEntryPointFor(final Set<ClassDescription> classDescriptionSet) throws IOException {
+    String assertionsEntryPointFileContent = generateAssertionsEntryPointContentFor(classDescriptionSet);
+    // create the assertion entry point file, located in its package directory starting from targetBaseDirectory
+    String entryPointAssertionsClassPackage = determineEntryPointsAssertionsClassPackage(classDescriptionSet);
+    String targetDirectory = getDirectoryPathCorrespondingToPackage(entryPointAssertionsClassPackage);
+    // build any needed directories
+    new File(targetDirectory).mkdirs();
+    return createCustomAssertionFile(assertionsEntryPointFileContent, ASSERTIONS_ENTRY_POINT_FILE, targetDirectory);
+  }
+
+  private String generateAssertThatEntryPointsAssertionsFor(final Set<ClassDescription> classDescriptionSet) {
+    // sort ClassDescription according to their class name.
+    SortedSet<ClassDescription> sortedClassDescriptionSet =
+      new TreeSet<ClassDescription>(new Comparator<ClassDescription>() {
+        @Override
+        public int compare(final ClassDescription cd1, final ClassDescription cd2) {
+          return cd1.getClassName().compareTo(cd2.getClassName());
+        }
+      });
+    sortedClassDescriptionSet.addAll(classDescriptionSet);
+    // generate assertThat(MyClass) for each classDescription
+    StringBuilder allAssertThatsContentBuilder = new StringBuilder();
+    final String lineSeparator = System.getProperty("line.separator");
+    for (ClassDescription classDescription : sortedClassDescriptionSet) {
+      String assertThatContent = new StringBuilder(entryPointAssertionTemplate.getContent()).toString();
+      // resolve template markers, use class name with outer class in case of inner classes like Movie.PublicCategory.
+      assertThatContent = assertThatContent.replaceAll(CLASS_TO_ASSERT_REGEXP + ASSERT_CLASS_SUFFIX,
+                                                       classDescription.getClassName() + ASSERT_CLASS_SUFFIX);
+      // resolve template markers, use class name with outer class in case of inner classes like Movie.PublicCategory.
+      assertThatContent = assertThatContent.replaceAll(CLASS_TO_ASSERT_REGEXP,
+                                                       classDescription.getClassNameWithOuterClass());
+      allAssertThatsContentBuilder.append(lineSeparator).append(assertThatContent);
+    }
+    return allAssertThatsContentBuilder.toString();
+  }
+
+  private String generateEntryPointsAssertionsImportFor(final Set<ClassDescription> classDescriptionSet,
+                                                        final String entryPointAssertionsClassPackage) {
+    final Set<TypeName> typeNameSet = new TreeSet<TypeName>();
+    for (ClassDescription classDescription : classDescriptionSet) {
+      typeNameSet.add(classDescription.getTypeName());
+      // add also corresponding Assert class (NameAssert for class Name)
+      // this is needed to generate both imports (Name and NameAssert imports)
+      typeNameSet.add(new TypeName(classDescription.getClassName() + ASSERT_CLASS_SUFFIX,
+                                   classDescription.getPackageName()));
+    }
+    return listImports(typeNameSet, entryPointAssertionsClassPackage);
+  }
+
+  private String determineEntryPointsAssertionsClassPackage(final Set<ClassDescription> classDescriptionSet) {
+    SortedSet<String> packages = new TreeSet<String>(new Comparator<String>() {
+      @Override
+      public int compare(final String o1, final String o2) {
+        return o1.length() - o2.length();
+      }
+    });
+    for (ClassDescription classDescription : classDescriptionSet) {
+      packages.add(classDescription.getPackageName());
+    }
+    // takes the base package of all given classes assuming they all belong to a common package, i.e a.b.c. over a.b.c.d
+    // this can certainly be improved ...
+    return packages.first();
+  }
+
   /**
    * Returns the target directory path where the assertions file for given classDescription will be created.
    *
-   * @param classDescription the {@link ClassDescription} we want to generate an assertion file for.
-   * @return the target directory path where the assertions file for given classDescription will be created.
+   * @param packageName
+   * @return the target directory path corresponding to the given package.
    */
-  private String getTargetDirectoryPathFor(ClassDescription classDescription) {
-    return targetBaseDirectory + File.separator + classDescription.getPackageName().replace('.', File.separatorChar);
+  private String getDirectoryPathCorrespondingToPackage(final String packageName) {
+    return targetBaseDirectory + File.separator + packageName.replace('.', File.separatorChar);
   }
 
-  private static String listImports(Set<TypeName> typesToImport, String assertClassPackage) {
+  private static String listImports(Set<TypeName> typesToImport, String classPackage) {
     StringBuilder importsBuilder = new StringBuilder();
     for (TypeName type : typesToImport) {
-      if (!type.isPrimitive() && !type.belongsToJavaLangPackage() && !type.getPackageName().equals(assertClassPackage)) {
+      if (!type.isPrimitive() && !type.belongsToJavaLangPackage() && !type.getPackageName().equals(classPackage)) {
         importsBuilder.append(format(IMPORT_LINE, type, LINE_SEPARATOR));
       }
     }
@@ -239,10 +358,10 @@ public class BaseAssertionGenerator implements AssertionGenerator {
         sb.append("[]");
       }
       assertionContent = hasIterableElementsAssertionTemplate.getContent().replaceAll(ELEMENT_TYPE_REGEXP,
-          sb.toString());
+                                                                                      sb.toString());
     } else if (getter.isArrayPropertyType()) {
       assertionContent = hasArrayElementsAssertionTemplate.getContent().replaceAll(ELEMENT_TYPE_REGEXP,
-          getter.getElementTypeName());
+                                                                                   getter.getElementTypeName());
     } else if (getter.isPrimitivePropertyType()) {
       assertionContent = hasAssertionTemplateForPrimitive.getContent();
     }
@@ -277,7 +396,7 @@ public class BaseAssertionGenerator implements AssertionGenerator {
       throwsClause.append(exceptionName);
       throwsJavaDoc.append(LINE_SEPARATOR).append("   * @throws ").append(exceptionName);
       throwsJavaDoc.append(" if actual.").append(getter.isBooleanPropertyType() ? "is" : "get")
-          .append("${Property}() throws one.");
+                   .append("${Property}() throws one.");
     }
     if (!getter.getExceptions().isEmpty()) {
       throwsClause.append(' ');
@@ -298,7 +417,7 @@ public class BaseAssertionGenerator implements AssertionGenerator {
   }
 
   private File createCustomAssertionFile(String assertionFileContent, String assertionFileName, String targetDirectory)
-      throws IOException {
+    throws IOException {
     File assertionJavaFile = new File(targetDirectory, assertionFileName);
     assertionJavaFile.createNewFile();
     fillAssertionJavaFile(assertionFileContent, assertionJavaFile);
@@ -311,7 +430,7 @@ public class BaseAssertionGenerator implements AssertionGenerator {
     }
     if (templateType != assertionClassTemplate.getType()) {
       throw new IllegalArgumentException("Expecting a Template type to be '" + templateType + "' but was '"
-          + assertionClassTemplate.getType() + "'");
+                                         + assertionClassTemplate.getType() + "'");
     }
     if (assertionClassTemplate.getContent() == null) {
       throw new NullPointerException("Expecting a non null content in the Template");
diff --git a/src/main/java/org/assertj/assertions/generator/Template.java b/src/main/java/org/assertj/assertions/generator/Template.java
index 6093a1b..74be951 100644
--- a/src/main/java/org/assertj/assertions/generator/Template.java
+++ b/src/main/java/org/assertj/assertions/generator/Template.java
@@ -134,7 +134,7 @@ public class Template {
   }
 
   public enum Type {
-    IS, HAS_FOR_ARRAY, HAS_FOR_ITERABLE, HAS, HAS_FOR_PRIMITIVE, ASSERT_CLASS;
+    IS, HAS_FOR_ARRAY, HAS_FOR_ITERABLE, HAS, HAS_FOR_PRIMITIVE, ASSERT_CLASS, ENTRY_POINT_ASSERTIONS_CLASS, ENTRY_POINT_ASSERTION;
   }
 
 }
diff --git a/src/main/java/org/assertj/assertions/generator/cli/AssertionGeneratorLauncher.java b/src/main/java/org/assertj/assertions/generator/cli/AssertionGeneratorLauncher.java
index 9a5dc7d..c04ee0f 100644
--- a/src/main/java/org/assertj/assertions/generator/cli/AssertionGeneratorLauncher.java
+++ b/src/main/java/org/assertj/assertions/generator/cli/AssertionGeneratorLauncher.java
@@ -31,7 +31,7 @@ public class AssertionGeneratorLauncher {
   private static final Logger logger = LoggerFactory.getLogger(AssertionGeneratorLauncher.class);
   private static ClassToClassDescriptionConverter classDescriptionConverter = new ClassToClassDescriptionConverter();
 
-  public static void main(String[] classesOrPackagesNames) throws FileNotFoundException, IOException, ClassNotFoundException {
+  public static void main(String[] classesOrPackagesNames) throws IOException, ClassNotFoundException {
     List<Class<?>> classes = collectClasses(classesOrPackagesNames);
     logger.info("Generating assertions for classes {}", classes);
     BaseAssertionGenerator customAssertionGenerator = new BaseAssertionGenerator();
diff --git a/src/main/java/org/assertj/assertions/generator/description/ClassDescription.java b/src/main/java/org/assertj/assertions/generator/description/ClassDescription.java
index b1fd587..916dc4b 100644
--- a/src/main/java/org/assertj/assertions/generator/description/ClassDescription.java
+++ b/src/main/java/org/assertj/assertions/generator/description/ClassDescription.java
@@ -40,6 +40,10 @@ public class ClassDescription {
     return classTypeName.getSimpleName();
   }
 
+  public TypeName getTypeName() {
+    return classTypeName;
+  }
+
   public String getClassNameWithOuterClass() {
     return classTypeName.getSimpleNameWithOuterClass();
   }
@@ -68,4 +72,21 @@ public class ClassDescription {
   public String toString() {
     return "ClassDescription [classTypeName=" + classTypeName + ", typesToImports=" + typesToImports + "]";
   }
+
+  @Override
+  public boolean equals(final Object o) {
+    if (this == o) return true;
+    if (!(o instanceof ClassDescription)) return false;
+
+    final ClassDescription that = (ClassDescription) o;
+
+    if (classTypeName != null ? !classTypeName.equals(that.classTypeName) : that.classTypeName != null) return false;
+
+    return true;
+  }
+
+  @Override
+  public int hashCode() {
+    return classTypeName != null ? classTypeName.hashCode() : 0;
+  }
 }
diff --git a/src/main/java/org/assertj/assertions/generator/util/ClassUtil.java b/src/main/java/org/assertj/assertions/generator/util/ClassUtil.java
index da90c86..dddd7e7 100644
--- a/src/main/java/org/assertj/assertions/generator/util/ClassUtil.java
+++ b/src/main/java/org/assertj/assertions/generator/util/ClassUtil.java
@@ -301,7 +301,7 @@ public class ClassUtil {
         } else if (actualTypeArgument instanceof GenericArrayType) {
           classes.addAll(getClassesRelatedTo(actualTypeArgument));
         }
-//          throw new IllegalArgumentException("cannot find type " + actualTypeArgument);
+        // throw new IllegalArgumentException("cannot find type " + actualTypeArgument);
         // I'm almost sure we should not arrive here !
       }
       Type rawType = parameterizedType.getRawType();
diff --git a/src/main/resources/templates/entry_point_assertion_template.txt b/src/main/resources/templates/entry_point_assertion_template.txt
new file mode 100644
index 0000000..ec3c2fe
--- /dev/null
+++ b/src/main/resources/templates/entry_point_assertion_template.txt
@@ -0,0 +1,9 @@
+  /**
+   * Creates a new instance of <code>{@link ${class_to_assert}Assert}</code>.
+   *
+   * @param actual the actual value.
+   * @return the created assertion object.
+   */
+  public static ${class_to_assert}Assert assertThat(${class_to_assert} actual) {
+    return new ${class_to_assert}Assert(actual);
+  }
diff --git a/src/main/resources/templates/entry_point_assertions_class_template.txt b/src/main/resources/templates/entry_point_assertions_class_template.txt
new file mode 100644
index 0000000..149eebe
--- /dev/null
+++ b/src/main/resources/templates/entry_point_assertions_class_template.txt
@@ -0,0 +1,16 @@
+package ${package};
+
+${imports}
+/**
+ * Entry point for assertion of different data types. Each method in this class is a static factory for the
+ * type-specific assertion objects.
+ */
+public class Assertions {
+${all_assertions_entry_points}
+  /**
+   * Creates a new </code>{@link Assertions}</code>.
+   */
+  protected Assertions() {
+    // empty
+  }
+}
diff --git a/src/test/java/org/assertj/assertions/generator/AssertionGeneratorTest.java b/src/test/java/org/assertj/assertions/generator/AssertionGeneratorTest.java
index b9be616..11ebe2d 100644
--- a/src/test/java/org/assertj/assertions/generator/AssertionGeneratorTest.java
+++ b/src/test/java/org/assertj/assertions/generator/AssertionGeneratorTest.java
@@ -1,9 +1,19 @@
 package org.assertj.assertions.generator;
 
-import org.apache.commons.io.FileUtils;
-import org.assertj.assertions.generator.data.Player;
-import org.assertj.assertions.generator.description.converter.ClassToClassDescriptionConverter;
-import org.assertj.assertions.generator.util.ClassUtil;
+import static com.google.common.collect.Lists.*;
+import static org.apache.commons.io.FileUtils.readFileToString;
+import static org.assertj.assertions.generator.BaseAssertionGenerator.ASSERT_CLASS_FILE_SUFFIX;
+import static org.assertj.assertions.generator.util.ClassUtil.collectClasses;
+import static org.assertj.core.api.Assertions.*;
+
+import java.io.File;
+import java.io.IOException;
+import java.lang.reflect.Modifier;
+import java.sql.SQLException;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Set;
+
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.experimental.theories.Theories;
@@ -12,23 +22,22 @@ import org.junit.runner.RunWith;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.lang.reflect.Modifier;
-import java.sql.SQLException;
-import java.util.List;
-
-import static org.assertj.assertions.generator.BaseAssertionGenerator.ASSERT_CLASS_FILE_SUFFIX;
-import static org.assertj.assertions.generator.util.ClassUtil.collectClasses;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;
+import org.assertj.assertions.generator.data.ArtWork;
+import org.assertj.assertions.generator.data.Movie;
+import org.assertj.assertions.generator.data.Name;
+import org.assertj.assertions.generator.data.Player;
+import org.assertj.assertions.generator.data.TreeEnum;
+import org.assertj.assertions.generator.data.lotr.Race;
+import org.assertj.assertions.generator.data.lotr.Ring;
+import org.assertj.assertions.generator.data.lotr.TolkienCharacter;
+import org.assertj.assertions.generator.description.ClassDescription;
+import org.assertj.assertions.generator.description.converter.ClassToClassDescriptionConverter;
+import org.assertj.assertions.generator.util.ClassUtil;
 
 
 @RunWith(Theories.class)
 public class AssertionGeneratorTest implements NestedClassesTest, BeanWithExceptionsTest {
   private static final String LINE_SEPARATOR = System.getProperty("line.separator");
-    
   private static final String TARGET_DIRECTORY = "target";
   private static final Logger logger = LoggerFactory.getLogger(AssertionGeneratorTest.class);
   private ClassToClassDescriptionConverter converter;
@@ -45,7 +54,8 @@ public class AssertionGeneratorTest implements NestedClassesTest, BeanWithExcept
   public void should_generate_assertion_for_player_class() throws Exception {
     customAssertionGenerator.generateCustomAssertionFor(converter.convertToClassDescription(Player.class));
     assertThat(fileGeneratedFor(Player.class)).hasContentEqualTo(
-            new File("src/test/resources/PlayerAssert.expected.txt").getAbsoluteFile());
+                                                                  new File("src/test/resources/PlayerAssert.expected" +
+                                                                           ".txt").getAbsoluteFile());
   }
 
   @Theory
@@ -58,18 +68,21 @@ public class AssertionGeneratorTest implements NestedClassesTest, BeanWithExcept
   @Theory
   public void should_generate_assertion_for_property_with_exception(Class<?> beanClass) throws Exception {
     customAssertionGenerator.generateCustomAssertionFor(converter.convertToClassDescription(beanClass));
-    String expectedContent = FileUtils.readFileToString(new File("src/test/resources/BeanWithOneException.expected.txt"));
+    String expectedContent = readFileToString(new File("src/test/resources/BeanWithOneException.expected.txt"));
     if (!BEAN_WITH_ONE_EXCEPTION.equals(beanClass)) {
       String importException = "import java.io.IOException;" + LINE_SEPARATOR;
-      expectedContent = expectedContent.replace(importException, importException + "import java.sql.SQLException;" + LINE_SEPARATOR);
+      expectedContent = expectedContent.replace(importException, importException + "import java.sql.SQLException;" +
+                                                                 LINE_SEPARATOR);
 
       expectedContent = expectedContent.replace(BEAN_WITH_ONE_EXCEPTION.getSimpleName(), beanClass.getSimpleName());
       expectedContent = expectedContent.replace(" throws IOException ", " throws IOException, SQLException ");
 
-      GetterWithException[] getters = {STRING_1_EXCEPTION, BOOLEAN_1_EXCEPTION, ARRAY_1_EXCEPTION, ITERABLE_1_EXCEPTION};
+      GetterWithException[] getters = {STRING_1_EXCEPTION, BOOLEAN_1_EXCEPTION, ARRAY_1_EXCEPTION,
+                                        ITERABLE_1_EXCEPTION};
       for (GetterWithException getter : getters) {
         String throwsClause = generateThrowsClause(IOException.class, getter.getPropertyName(), getter.isBooleanType());
-        String replacement = throwsClause + generateThrowsClause(SQLException.class, getter.getPropertyName(), getter.isBooleanType()); 
+        String replacement = throwsClause + generateThrowsClause(SQLException.class, getter.getPropertyName(),
+                                                                 getter.isBooleanType());
         expectedContent = expectedContent.replace(throwsClause, replacement);
       }
     }
@@ -77,20 +90,21 @@ public class AssertionGeneratorTest implements NestedClassesTest, BeanWithExcept
   }
 
   private String generateThrowsClause(Class<?> exception, String property, boolean booleanType) {
-      String getter = (booleanType ? "is" : "get") + Character.toUpperCase(property.charAt(0)) + property.substring(1); 
-      return "   * @throws " + exception.getSimpleName() + " if actual." + getter + "() throws one." + LINE_SEPARATOR;
+    String getter = (booleanType ? "is" : "get") + Character.toUpperCase(property.charAt(0)) + property.substring(1);
+    return "   * @throws " + exception.getSimpleName() + " if actual." + getter + "() throws one." + LINE_SEPARATOR;
   }
-    
+
   @Test
   public void should_generate_assertion_for_classes_in_package() throws Exception {
     List<Class<?>> classes = collectClasses("org.assertj.assertions.generator.data");
     for (Class<?> clazz : classes) {
-      assertThat(clazz.isAnonymousClass()).as("check that <" + clazz.getSimpleName() +"> is not anonymous").isFalse();
-      assertThat(clazz.isLocalClass()).as("check that " + clazz.getSimpleName() +" is not local").isFalse();
-      assertThat(Modifier.isPublic(clazz.getModifiers())).as("check that " + clazz.getSimpleName() +" is public").isTrue();
+      assertThat(clazz.isAnonymousClass()).as("check that <" + clazz.getSimpleName() + "> is not anonymous").isFalse();
+      assertThat(clazz.isLocalClass()).as("check that " + clazz.getSimpleName() + " is not local").isFalse();
+      assertThat(Modifier.isPublic(clazz.getModifiers())).as("check that " + clazz.getSimpleName() + " is public")
+        .isTrue();
       logger.info("Generating assertions for {}", clazz.getName());
-      File customAssertionFile = customAssertionGenerator.generateCustomAssertionFor(converter
-          .convertToClassDescription(clazz));
+      final ClassDescription classDescription = converter.convertToClassDescription(clazz);
+      File customAssertionFile = customAssertionGenerator.generateCustomAssertionFor(classDescription);
       logger.info("Generated {} assertions file -> {}", clazz.getSimpleName(), customAssertionFile.getAbsolutePath());
     }
   }
@@ -100,16 +114,33 @@ public class AssertionGeneratorTest implements NestedClassesTest, BeanWithExcept
     ClassLoader customClassLoader = new MyClassLoader(Thread.currentThread().getContextClassLoader());
     List<Class<?>> classes = collectClasses(customClassLoader, "org.assertj.assertions.generator.data");
     for (Class<?> clazz : classes) {
-      assertThat(clazz.isAnonymousClass()).as("check that " + clazz.getSimpleName() +" is not anonymous").isFalse();
-      assertThat(clazz.isLocalClass()).as("check that " + clazz.getSimpleName() +" is not local").isFalse();
-      assertThat(Modifier.isPublic(clazz.getModifiers())).as("check that " + clazz.getSimpleName() +" is public").isTrue();
+      assertThat(clazz.isAnonymousClass()).as("check that " + clazz.getSimpleName() + " is not anonymous").isFalse();
+      assertThat(clazz.isLocalClass()).as("check that " + clazz.getSimpleName() + " is not local").isFalse();
+      assertThat(Modifier.isPublic(clazz.getModifiers())).as("check that " + clazz.getSimpleName() + " is public")
+        .isTrue();
       logger.info("Generating assertions for {}", clazz.getName());
-      File customAssertionFile = customAssertionGenerator.generateCustomAssertionFor(converter
-          .convertToClassDescription(clazz));
+      final ClassDescription classDescription = converter.convertToClassDescription(clazz);
+      File customAssertionFile = customAssertionGenerator.generateCustomAssertionFor(classDescription);
       logger.info("Generated {} assertions file -> {}", clazz.getSimpleName(), customAssertionFile.getAbsolutePath());
     }
   }
 
+  @Test
+  public void should_generate_assertion_entry_point_class_file() throws Exception {
+    // GIVEN : classes we want to have entry point assertions for
+    List<Class<?>> classes = newArrayList(Ring.class, Race.class, ArtWork.class, Name.class, Player.class, Movie.class,
+                                          TolkienCharacter.class, TreeEnum.class, Movie.PublicCategory.class);
+    Set<ClassDescription> classClassDescriptionSet = new LinkedHashSet<ClassDescription>(classes.size());
+    for (Class<?> clazz : classes) {
+      classClassDescriptionSet.add(converter.convertToClassDescription(clazz));
+    }
+    // WHEN
+    final File assertionsEntryPointFile = customAssertionGenerator.generateAssertionsEntryPointFor(classClassDescriptionSet);
+    // THEN
+    String expectedContent = readFileToString(new File("src/test/resources/Assertions.expected.txt"));
+    assertThat(assertionsEntryPointFile).as("check entry point class content").hasContent(expectedContent);
+  }
+
   @Test
   public void should_check_template_type() throws Exception {
     customAssertionGenerator.setHasAssertionTemplate(new Template(Template.Type.HAS, "template content"));
@@ -119,11 +150,10 @@ public class AssertionGeneratorTest implements NestedClassesTest, BeanWithExcept
     } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("Expecting a Template type to be 'HAS' but was 'IS'");
     }
-
   }
 
   private static String expectedContentFromTemplate(Class<?> clazz) throws IOException {
-    String template = FileUtils.readFileToString(new File("src/test/resources/NestedClassAssert.template.expected.txt"));
+    String template = readFileToString(new File("src/test/resources/NestedClassAssert.template.expected.txt"));
     String content = template.replace("${nestedClass}Assert", clazz.getSimpleName() + "Assert");
     content = content.replace("${nestedClass}", ClassUtil.getSimpleNameWithOuterClass(clazz));
     return content;
@@ -131,7 +161,7 @@ public class AssertionGeneratorTest implements NestedClassesTest, BeanWithExcept
 
   private static File fileGeneratedFor(Class<?> clazz) {
     String dirName = TARGET_DIRECTORY + File.separatorChar
-        + clazz.getPackage().getName().replace('.', File.separatorChar);
+                     + clazz.getPackage().getName().replace('.', File.separatorChar);
     String generatedFileName = clazz.getSimpleName() + ASSERT_CLASS_FILE_SUFFIX;
     return new File(dirName, generatedFileName);
   }
diff --git a/src/test/java/org/assertj/assertions/generator/description/TypeNameTest.java b/src/test/java/org/assertj/assertions/generator/description/TypeNameTest.java
index 4d8fc23..283a16e 100644
--- a/src/test/java/org/assertj/assertions/generator/description/TypeNameTest.java
+++ b/src/test/java/org/assertj/assertions/generator/description/TypeNameTest.java
@@ -2,6 +2,7 @@ package org.assertj.assertions.generator.description;
 
 import org.assertj.assertions.generator.NestedClassesTest;
 import org.assertj.assertions.generator.data.Player;
+
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.experimental.theories.Theories;
@@ -15,9 +16,9 @@ import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;
 @RunWith(Theories.class)
 public class TypeNameTest implements NestedClassesTest {
 
-  private TypeName typeName;
   @Rule
   public ExpectedException thrown = ExpectedException.none();
+  private TypeName typeName;
 
   @Test
   public void should_create_valid_typename_from_class() {
@@ -77,6 +78,13 @@ public class TypeNameTest implements NestedClassesTest {
     assertThat(typeName.getPackageName()).isEmpty();
     assertThat(typeName.belongsToJavaLangPackage()).isFalse();
     assertThat(typeName.isPrimitive()).isTrue();
+    // same
+    typeName = new TypeName("int", null);
+    assertThat(typeName.getSimpleName()).isEqualTo("int");
+    assertThat(typeName.getSimpleNameWithOuterClass()).isEqualTo("int");
+    assertThat(typeName.getPackageName()).isEmpty();
+    assertThat(typeName.belongsToJavaLangPackage()).isFalse();
+    assertThat(typeName.isPrimitive()).isTrue();
   }
 
   @Test
@@ -85,7 +93,7 @@ public class TypeNameTest implements NestedClassesTest {
     thrown.expectMessage("type name should not be blank or null");
     typeName = new TypeName("");
   }
-  
+
   @Test
   public void should_detect_primitives_typename() {
     assertThat(new TypeName(int.class).isPrimitive()).isTrue();
@@ -110,7 +118,7 @@ public class TypeNameTest implements NestedClassesTest {
     assertThat(new TypeName("Boolean").isBoolean()).isFalse();
     assertThat(new TypeName("test.boolean").isBoolean()).isFalse();
   }
-  
+
   @Test
   public void should_fail_if_type_simple_name_is_null() {
     try {
diff --git a/src/test/java/org/assertj/assertions/generator/util/ClassUtilTest.java b/src/test/java/org/assertj/assertions/generator/util/ClassUtilTest.java
index cc0ec5d..b27677a 100644
--- a/src/test/java/org/assertj/assertions/generator/util/ClassUtilTest.java
+++ b/src/test/java/org/assertj/assertions/generator/util/ClassUtilTest.java
@@ -17,6 +17,7 @@ import org.junit.runner.RunWith;
 import java.lang.reflect.Method;
 import java.util.Collection;
 import java.util.List;
+import java.util.Set;
 
 import static org.assertj.assertions.generator.data.OuterClass.StaticNestedPerson;
 import static org.assertj.assertions.generator.util.ClassUtil.*;
@@ -154,7 +155,6 @@ public class ClassUtilTest implements NestedClassesTest {
   @Test
   public void getClass_on_parameterized_List_should_return_Integer_class() throws Exception {
     Method method = Generic.class.getMethod("getListOfInteger");
-
     Class<?> clazz = ClassUtil.getClass(((ParameterizedType) method.getGenericReturnType()).getActualTypeArguments()
                                           [0]);
     assertThat(clazz).isEqualTo(Integer.class);
@@ -163,17 +163,40 @@ public class ClassUtilTest implements NestedClassesTest {
   @Test
   public void getClass_on_wildcard_List_should_return_Integer_class() throws Exception {
     Method method = Generic.class.getMethod("getListOfWildcardInteger");
-
     Class<?> clazz = ClassUtil.getClass(((ParameterizedType) method.getGenericReturnType()).getActualTypeArguments()
                                           [0]);
     assertThat(clazz).isEqualTo(Integer.class);
   }
 
+  @Test
+  public void getClass_on_variable_type_should_return_null() throws Exception {
+    Method method = Generic.class.getMethod("getGenericArray");
+    Class<?> clazz = ClassUtil.getClass((method.getGenericReturnType()));
+    assertThat(clazz).isNull();
+  }
+
+  @Test
+  public void getClassRelatedTo_on_non_generic_type_should_return_given_type() throws Exception {
+    Set<Class<?>> classes = ClassUtil.getClassesRelatedTo(String.class.getMethod("toString").getReturnType());
+    assertThat(classes).containsOnly(String.class);
+  }
+
+  @Test
+  public void getClassRelatedTo_on_generic_list_should_return_list_and_component_type() throws Exception {
+    Method method = Generic.class.getMethod("getListOfInteger");
+    Set<Class<?>> classes = ClassUtil.getClassesRelatedTo(method.getGenericReturnType());
+    assertThat(classes).containsOnly(Integer.class, List.class);
+  }
+
   private static class Generic {
     public List<Integer> getListOfInteger() {
       return null;
     }
 
+    public <T> T[] getGenericArray() {
+      return null;
+    }
+
     public List<? extends Integer> getListOfWildcardInteger() {
       return null;
     }
diff --git a/src/test/resources/Assertions.expected.txt b/src/test/resources/Assertions.expected.txt
new file mode 100644
index 0000000..6937952
--- /dev/null
+++ b/src/test/resources/Assertions.expected.txt
@@ -0,0 +1,112 @@
+package org.assertj.assertions.generator.data;
+
+import org.assertj.assertions.generator.data.lotr.Race;
+import org.assertj.assertions.generator.data.lotr.RaceAssert;
+import org.assertj.assertions.generator.data.lotr.Ring;
+import org.assertj.assertions.generator.data.lotr.RingAssert;
+import org.assertj.assertions.generator.data.lotr.TolkienCharacter;
+import org.assertj.assertions.generator.data.lotr.TolkienCharacterAssert;
+
+/**
+ * Entry point for assertion of different data types. Each method in this class is a static factory for the
+ * type-specific assertion objects.
+ */
+public class Assertions {
+
+  /**
+   * Creates a new instance of <code>{@link ArtWorkAssert}</code>.
+   *
+   * @param actual the actual value.
+   * @return the created assertion object.
+   */
+  public static ArtWorkAssert assertThat(ArtWork actual) {
+    return new ArtWorkAssert(actual);
+  }
+
+  /**
+   * Creates a new instance of <code>{@link MovieAssert}</code>.
+   *
+   * @param actual the actual value.
+   * @return the created assertion object.
+   */
+  public static MovieAssert assertThat(Movie actual) {
+    return new MovieAssert(actual);
+  }
+
+  /**
+   * Creates a new instance of <code>{@link NameAssert}</code>.
+   *
+   * @param actual the actual value.
+   * @return the created assertion object.
+   */
+  public static NameAssert assertThat(Name actual) {
+    return new NameAssert(actual);
+  }
+
+  /**
+   * Creates a new instance of <code>{@link PlayerAssert}</code>.
+   *
+   * @param actual the actual value.
+   * @return the created assertion object.
+   */
+  public static PlayerAssert assertThat(Player actual) {
+    return new PlayerAssert(actual);
+  }
+
+  /**
+   * Creates a new instance of <code>{@link PublicCategoryAssert}</code>.
+   *
+   * @param actual the actual value.
+   * @return the created assertion object.
+   */
+  public static PublicCategoryAssert assertThat(Movie.PublicCategory actual) {
+    return new PublicCategoryAssert(actual);
+  }
+
+  /**
+   * Creates a new instance of <code>{@link RaceAssert}</code>.
+   *
+   * @param actual the actual value.
+   * @return the created assertion object.
+   */
+  public static RaceAssert assertThat(Race actual) {
+    return new RaceAssert(actual);
+  }
+
+  /**
+   * Creates a new instance of <code>{@link RingAssert}</code>.
+   *
+   * @param actual the actual value.
+   * @return the created assertion object.
+   */
+  public static RingAssert assertThat(Ring actual) {
+    return new RingAssert(actual);
+  }
+
+  /**
+   * Creates a new instance of <code>{@link TolkienCharacterAssert}</code>.
+   *
+   * @param actual the actual value.
+   * @return the created assertion object.
+   */
+  public static TolkienCharacterAssert assertThat(TolkienCharacter actual) {
+    return new TolkienCharacterAssert(actual);
+  }
+
+  /**
+   * Creates a new instance of <code>{@link TreeEnumAssert}</code>.
+   *
+   * @param actual the actual value.
+   * @return the created assertion object.
+   */
+  public static TreeEnumAssert assertThat(TreeEnum actual) {
+    return new TreeEnumAssert(actual);
+  }
+
+  /**
+   * Creates a new </code>{@link Assertions}</code>.
+   */
+  protected Assertions() {
+    // empty
+  }
+}
