diff --git a/src/redirect.rs b/src/redirect.rs
index 50a096f..6e3ce55 100644
--- a/src/redirect.rs
+++ b/src/redirect.rs
@@ -128,7 +128,8 @@ impl Policy {
         match self.inner {
             PolicyKind::Custom(ref custom) => custom(attempt),
             PolicyKind::Limit(max) => {
-                if attempt.previous.len() >= max {
+                // The first URL in the previous is the initial URL and not a redirection. It needs to be excluded.
+                if attempt.previous.len() > max {
                     attempt.error(TooManyRedirects)
                 } else {
                     attempt.follow()
@@ -260,7 +261,7 @@ impl StdError for TooManyRedirects {}
 fn test_redirect_policy_limit() {
     let policy = Policy::default();
     let next = Url::parse("http://x.y/z").unwrap();
-    let mut previous = (0..9)
+    let mut previous = (0..=9)
         .map(|i| Url::parse(&format!("http://a.b/c/{i}")).unwrap())
         .collect::<Vec<_>>();
 
diff --git a/tests/redirect.rs b/tests/redirect.rs
index c496d90..9634dc3 100644
--- a/tests/redirect.rs
+++ b/tests/redirect.rs
@@ -376,3 +376,37 @@ async fn test_redirect_https_only_enforced_gh1312() {
     let err = res.unwrap_err();
     assert!(err.is_redirect());
 }
+
+#[tokio::test]
+async fn test_redirect_limit_to_1() {
+    let server = server::http(move |req| async move {
+        let i: i32 = req
+            .uri()
+            .path()
+            .rsplit('/')
+            .next()
+            .unwrap()
+            .parse::<i32>()
+            .unwrap();
+        assert!(req.uri().path().ends_with(&format!("/redirect/{i}")));
+        http::Response::builder()
+            .status(302)
+            .header("location", format!("/redirect/{}", i + 1))
+            .body(Body::default())
+            .unwrap()
+    });
+    // The number at the end of the uri indicates the total number of redirections
+    let url = format!("http://{}/redirect/0", server.addr());
+
+    let client = reqwest::Client::builder()
+        .redirect(reqwest::redirect::Policy::limited(1))
+        .build()
+        .unwrap();
+    let res = client.get(&url).send().await.unwrap_err();
+    // If the maxmium limit is 1, then the final uri should be /redirect/1
+    assert_eq!(
+        res.url().unwrap().as_str(),
+        format!("http://{}/redirect/1", server.addr()).as_str()
+    );
+    assert!(res.is_redirect());
+}
