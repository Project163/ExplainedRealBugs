diff --git a/Cargo.toml b/Cargo.toml
index 29f92b3..eec3c3b 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -134,7 +134,7 @@ h2 = { version = "0.4", optional = true }
 log = "0.4.17"
 percent-encoding = "2.3"
 tokio = { version = "1.0", default-features = false, features = ["net", "time"] }
-tower = { version = "0.5.2", default-features = false, features = ["timeout", "util"] }
+tower = { version = "0.5.2", default-features = false, features = ["retry", "timeout", "util"] }
 tower-http = { version = "0.6.5", default-features = false, features = ["follow-redirect"] }
 pin-project-lite = "0.2.11"
 
diff --git a/src/async_impl/body.rs b/src/async_impl/body.rs
index cabce24..2a7d8f8 100644
--- a/src/async_impl/body.rs
+++ b/src/async_impl/body.rs
@@ -154,15 +154,6 @@ impl Body {
         }
     }
 
-    pub(crate) fn try_reuse(self) -> (Option<Bytes>, Self) {
-        let reuse = match self.inner {
-            Inner::Reusable(ref chunk) => Some(chunk.clone()),
-            Inner::Streaming { .. } => None,
-        };
-
-        (reuse, self)
-    }
-
     pub(crate) fn try_clone(&self) -> Option<Body> {
         match self.inner {
             Inner::Reusable(ref chunk) => Some(Body::reusable(chunk.clone())),
diff --git a/src/async_impl/client.rs b/src/async_impl/client.rs
index f1f83db..45befa5 100644
--- a/src/async_impl/client.rs
+++ b/src/async_impl/client.rs
@@ -1,7 +1,5 @@
 #[cfg(any(feature = "native-tls", feature = "__rustls",))]
 use std::any::Any;
-#[cfg(feature = "http2")]
-use std::error::Error;
 use std::future::Future;
 use std::net::IpAddr;
 use std::pin::Pin;
@@ -45,7 +43,6 @@ use crate::Certificate;
 use crate::Identity;
 use crate::{IntoUrl, Method, Proxy, Url};
 
-use bytes::Bytes;
 use http::header::{
     Entry, HeaderMap, HeaderValue, ACCEPT, ACCEPT_ENCODING, PROXY_AUTHORIZATION, RANGE, USER_AGENT,
 };
@@ -176,6 +173,7 @@ struct Config {
     proxies: Vec<ProxyMatcher>,
     auto_sys_proxy: bool,
     redirect_policy: redirect::Policy,
+    retry_policy: crate::retry::Builder,
     referer: bool,
     read_timeout: Option<Duration>,
     timeout: Option<Duration>,
@@ -300,6 +298,7 @@ impl ClientBuilder {
                 proxies: Vec::new(),
                 auto_sys_proxy: true,
                 redirect_policy: redirect::Policy::default(),
+                retry_policy: crate::retry::Builder::default(),
                 referer: true,
                 read_timeout: None,
                 timeout: None,
@@ -999,14 +998,18 @@ impl ClientBuilder {
             hyper: hyper_client,
         };
 
-        let policy = {
+        let redirect_policy = {
             let mut p = TowerRedirectPolicy::new(config.redirect_policy);
             p.with_referer(config.referer)
                 .with_https_only(config.https_only);
             p
         };
 
-        let hyper = FollowRedirect::with_policy(hyper_service, policy.clone());
+        let retry_policy = config.retry_policy.into_policy();
+
+        let retries = tower::retry::Retry::new(retry_policy.clone(), hyper_service);
+
+        let hyper = FollowRedirect::with_policy(retries, redirect_policy.clone());
 
         Ok(Client {
             inner: Arc::new(ClientRef {
@@ -1026,7 +1029,8 @@ impl ClientBuilder {
                             config.pool_idle_timeout,
                             config.cookie_store,
                         );
-                        Some(FollowRedirect::with_policy(h3_service, policy))
+                        let retries = tower::retry::Retry::new(retry_policy, h3_service);
+                        Some(FollowRedirect::with_policy(retries, redirect_policy))
                     }
                     None => None,
                 },
@@ -1337,6 +1341,17 @@ impl ClientBuilder {
         self
     }
 
+    // Retry options
+
+    /// Set a request retry policy.
+    ///
+    /// Default behavior is to retry protocol NACKs.
+    // XXX: accept an `impl retry::IntoPolicy` instead?
+    pub fn retry(mut self, policy: crate::retry::Builder) -> ClientBuilder {
+        self.config.retry_policy = policy;
+        self
+    }
+
     // Proxy options
 
     /// Add a `Proxy` to the list of proxies the `Client` will use.
@@ -2505,13 +2520,7 @@ impl Client {
             _ => return Pending::new_err(error::url_invalid_uri(url)),
         };
 
-        let (reusable, body) = match body {
-            Some(body) => {
-                let (reusable, body) = body.try_reuse();
-                (Some(reusable), body)
-            }
-            None => (None, Body::empty()),
-        };
+        let body = body.unwrap_or_else(Body::empty);
 
         self.proxy_auth(&uri, &mut headers);
         self.proxy_custom_headers(&uri, &mut headers);
@@ -2556,9 +2565,6 @@ impl Client {
                 method,
                 url,
                 headers,
-                body: reusable,
-
-                retry_count: 0,
 
                 client: self.inner.clone(),
 
@@ -2792,14 +2798,18 @@ impl Config {
     }
 }
 
+type LayeredService<T> =
+    FollowRedirect<tower::retry::Retry<crate::retry::Policy, T>, TowerRedirectPolicy>;
+type LayeredFuture<T> = <LayeredService<T> as Service<http::Request<Body>>>::Future;
+
 struct ClientRef {
     accepts: Accepts,
     #[cfg(feature = "cookies")]
     cookie_store: Option<Arc<dyn cookie::CookieStore>>,
     headers: HeaderMap,
-    hyper: FollowRedirect<HyperService, TowerRedirectPolicy>,
+    hyper: LayeredService<HyperService>,
     #[cfg(feature = "http3")]
-    h3_client: Option<FollowRedirect<H3Client, TowerRedirectPolicy>>,
+    h3_client: Option<LayeredService<H3Client>>,
     referer: bool,
     request_timeout: RequestConfig<RequestTimeout>,
     read_timeout: Option<Duration>,
@@ -2863,9 +2873,6 @@ pin_project! {
         method: Method,
         url: Url,
         headers: HeaderMap,
-        body: Option<Option<Bytes>>,
-
-        retry_count: usize,
 
         client: Arc<ClientRef>,
 
@@ -2880,9 +2887,9 @@ pin_project! {
 }
 
 enum ResponseFuture {
-    Default(tower_http::follow_redirect::ResponseFuture<HyperService, Body, TowerRedirectPolicy>),
+    Default(LayeredFuture<HyperService>),
     #[cfg(feature = "http3")]
-    H3(tower_http::follow_redirect::ResponseFuture<H3Client, Body, TowerRedirectPolicy>),
+    H3(LayeredFuture<H3Client>),
 }
 
 impl PendingRequest {
@@ -2897,103 +2904,6 @@ impl PendingRequest {
     fn read_timeout(self: Pin<&mut Self>) -> Pin<&mut Option<Pin<Box<Sleep>>>> {
         self.project().read_timeout_fut
     }
-
-    #[cfg(any(feature = "http2", feature = "http3"))]
-    fn retry_error(mut self: Pin<&mut Self>, err: &(dyn std::error::Error + 'static)) -> bool {
-        use log::trace;
-
-        if !is_retryable_error(err) {
-            return false;
-        }
-
-        trace!("can retry {err:?}");
-
-        let body = match self.body {
-            Some(Some(ref body)) => Body::reusable(body.clone()),
-            Some(None) => {
-                log::debug!("error was retryable, but body not reusable");
-                return false;
-            }
-            None => Body::empty(),
-        };
-
-        if self.retry_count >= 2 {
-            trace!("retry count too high");
-            return false;
-        }
-        self.retry_count += 1;
-
-        // If it parsed once, it should parse again
-        let uri = try_uri(&self.url).expect("URL was already validated as URI");
-
-        *self.as_mut().in_flight().get_mut() = match *self.as_mut().in_flight().as_ref() {
-            #[cfg(feature = "http3")]
-            ResponseFuture::H3(_) => {
-                let mut req = hyper::Request::builder()
-                    .method(self.method.clone())
-                    .uri(uri)
-                    .body(body)
-                    .expect("valid request parts");
-                *req.headers_mut() = self.headers.clone();
-                let mut h3 = self
-                    .client
-                    .h3_client
-                    .as_ref()
-                    .expect("H3 client must exists, otherwise we can't have a h3 request here")
-                    .clone();
-                ResponseFuture::H3(h3.call(req))
-            }
-            _ => {
-                let mut req = hyper::Request::builder()
-                    .method(self.method.clone())
-                    .uri(uri)
-                    .body(body)
-                    .expect("valid request parts");
-                *req.headers_mut() = self.headers.clone();
-                let mut hyper = self.client.hyper.clone();
-                ResponseFuture::Default(hyper.call(req))
-            }
-        };
-
-        true
-    }
-}
-
-#[cfg(any(feature = "http2", feature = "http3"))]
-fn is_retryable_error(err: &(dyn std::error::Error + 'static)) -> bool {
-    // pop the legacy::Error
-    let err = if let Some(err) = err.source() {
-        err
-    } else {
-        return false;
-    };
-
-    #[cfg(feature = "http3")]
-    if let Some(cause) = err.source() {
-        if let Some(err) = cause.downcast_ref::<h3::error::ConnectionError>() {
-            log::debug!("determining if HTTP/3 error {err} can be retried");
-            // TODO: Does h3 provide an API for checking the error?
-            return err.to_string().as_str() == "timeout";
-        }
-    }
-
-    #[cfg(feature = "http2")]
-    if let Some(cause) = err.source() {
-        if let Some(err) = cause.downcast_ref::<h2::Error>() {
-            // They sent us a graceful shutdown, try with a new connection!
-            if err.is_go_away() && err.is_remote() && err.reason() == Some(h2::Reason::NO_ERROR) {
-                return true;
-            }
-
-            // REFUSED_STREAM was sent from the server, which is safe to retry.
-            // https://www.rfc-editor.org/rfc/rfc9113.html#section-8.7-3.2
-            if err.is_reset() && err.is_remote() && err.reason() == Some(h2::Reason::REFUSED_STREAM)
-            {
-                return true;
-            }
-        }
-    }
-    false
 }
 
 impl Pending {
@@ -3042,66 +2952,49 @@ impl Future for PendingRequest {
             }
         }
 
-        loop {
-            let res = match self.as_mut().in_flight().get_mut() {
-                ResponseFuture::Default(r) => match ready!(Pin::new(r).poll(cx)) {
-                    Err(e) => {
-                        #[cfg(feature = "http2")]
-                        if e.is_request() {
-                            if let Some(e) = e.source() {
-                                if self.as_mut().retry_error(e) {
-                                    continue;
-                                }
-                            }
-                        }
-
-                        return Poll::Ready(Err(e.if_no_url(|| self.url.clone())));
-                    }
-                    Ok(res) => res.map(super::body::boxed),
-                },
-                #[cfg(feature = "http3")]
-                ResponseFuture::H3(r) => match ready!(Pin::new(r).poll(cx)) {
-                    Err(e) => {
-                        if self.as_mut().retry_error(&e) {
-                            continue;
-                        }
-                        return Poll::Ready(Err(
-                            crate::error::request(e).with_url(self.url.clone())
-                        ));
-                    }
-                    Ok(res) => res,
-                },
-            };
-
-            #[cfg(feature = "cookies")]
-            {
-                if let Some(ref cookie_store) = self.client.cookie_store {
-                    let mut cookies =
-                        cookie::extract_response_cookie_headers(res.headers()).peekable();
-                    if cookies.peek().is_some() {
-                        cookie_store.set_cookies(&mut cookies, &self.url);
-                    }
+        let res = match self.as_mut().in_flight().get_mut() {
+            ResponseFuture::Default(r) => match ready!(Pin::new(r).poll(cx)) {
+                Err(e) => {
+                    return Poll::Ready(Err(e.if_no_url(|| self.url.clone())));
                 }
-            }
-            if let Some(url) = &res
-                .extensions()
-                .get::<tower_http::follow_redirect::RequestUri>()
-            {
-                self.url = match Url::parse(&url.0.to_string()) {
-                    Ok(url) => url,
-                    Err(e) => return Poll::Ready(Err(crate::error::decode(e))),
+                Ok(res) => res.map(super::body::boxed),
+            },
+            #[cfg(feature = "http3")]
+            ResponseFuture::H3(r) => match ready!(Pin::new(r).poll(cx)) {
+                Err(e) => {
+                    return Poll::Ready(Err(crate::error::request(e).with_url(self.url.clone())));
                 }
-            };
+                Ok(res) => res,
+            },
+        };
 
-            let res = Response::new(
-                res,
-                self.url.clone(),
-                self.client.accepts,
-                self.total_timeout.take(),
-                self.read_timeout,
-            );
-            return Poll::Ready(Ok(res));
+        #[cfg(feature = "cookies")]
+        {
+            if let Some(ref cookie_store) = self.client.cookie_store {
+                let mut cookies = cookie::extract_response_cookie_headers(res.headers()).peekable();
+                if cookies.peek().is_some() {
+                    cookie_store.set_cookies(&mut cookies, &self.url);
+                }
+            }
         }
+        if let Some(url) = &res
+            .extensions()
+            .get::<tower_http::follow_redirect::RequestUri>()
+        {
+            self.url = match Url::parse(&url.0.to_string()) {
+                Ok(url) => url,
+                Err(e) => return Poll::Ready(Err(crate::error::decode(e))),
+            }
+        };
+
+        let res = Response::new(
+            res,
+            self.url.clone(),
+            self.client.accepts,
+            self.total_timeout.take(),
+            self.read_timeout,
+        );
+        Poll::Ready(Ok(res))
     }
 }
 
diff --git a/src/blocking/client.rs b/src/blocking/client.rs
index 77619f3..255d9d8 100644
--- a/src/blocking/client.rs
+++ b/src/blocking/client.rs
@@ -342,6 +342,13 @@ impl ClientBuilder {
         self.with_inner(move |inner| inner.redirect(policy))
     }
 
+    /// Set a request retry policy.
+    ///
+    /// Default behavior is to retry protocol NACKs.
+    pub fn retry(self, policy: crate::retry::Builder) -> ClientBuilder {
+        self.with_inner(move |inner| inner.retry(policy))
+    }
+
     /// Enable or disable automatic setting of the `Referer` header.
     ///
     /// Default is `true`.
diff --git a/src/lib.rs b/src/lib.rs
index fbf99cb..99a7efc 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -376,6 +376,7 @@ if_hyper! {
     pub mod dns;
     mod proxy;
     pub mod redirect;
+    pub mod retry;
     #[cfg(feature = "__tls")]
     pub mod tls;
     mod util;
diff --git a/src/retry.rs b/src/retry.rs
new file mode 100644
index 0000000..c3ffd23
--- /dev/null
+++ b/src/retry.rs
@@ -0,0 +1,477 @@
+//! Retry requests
+//!
+//! A `Client` has the ability to retry requests, by sending additional copies
+//! to the server if a response is considered retryable.
+//!
+//! The [`Builder`] makes it easier to configure what requests to retry, along
+//! with including best practices by default, such as a retry budget.
+//!
+//! # Defaults
+//!
+//! The default retry behavior of a `Client` is to only retry requests where an
+//! error or low-level protocol NACK is encountered that is known to be safe to
+//! retry. Note however that providing a specific retry policy will override
+//! the default, and you will need to explicitly include that behavior.
+//!
+//! All policies default to including a retry budget that permits 20% extra
+//! requests to be sent.
+//!
+//! # Scoped
+//!
+//! A client's retry policy is scoped. That means that the policy doesn't
+//! apply to all requests, but only those within a user-defined scope.
+//!
+//! Since all policies include a budget by default, it doesn't make sense to
+//! apply it on _all_ requests. Rather, the retry history applied by a budget
+//! should likely only be applied to the same host.
+//!
+//! # Classifiers
+//!
+//! A retry policy needs to be configured with a classifier that determines
+//! if a request should be retried. Knowledge of the destination server's
+//! behavior is required to make a safe classifier. **Requests should not be
+//! retried** if the server cannot safely handle the same request twice, or if
+//! it causes side effects.
+//!
+//! Some common properties to check include if the request method is
+//! idempotent, or if the response status code indicates a transient error.
+
+use std::sync::Arc;
+use std::time::Duration;
+
+use tower::retry::budget::{Budget as _, TpsBudget as Budget};
+
+/// Builder to configure retries
+///
+/// Construct with [`for_host()`].
+#[derive(Debug)]
+pub struct Builder {
+    //backoff: Backoff,
+    budget: Option<f32>,
+    classifier: classify::Classifier,
+    max_retries_per_request: u32,
+    scope: scope::Scoped,
+}
+
+/// The internal type that we convert the builder into, that implements
+/// tower::retry::Policy privately.
+#[derive(Clone, Debug)]
+pub(crate) struct Policy {
+    budget: Option<Arc<Budget>>,
+    classifier: classify::Classifier,
+    max_retries_per_request: u32,
+    retry_cnt: u32,
+    scope: scope::Scoped,
+}
+
+//#[derive(Debug)]
+//struct Backoff;
+
+/// Create a retry builder with a request scope.
+///
+/// To provide a scope that isn't a closure, use the more general
+/// [`Builder::scoped()`].
+pub fn for_host<S>(host: S) -> Builder
+where
+    S: PartialEq<str> + Send + Sync + 'static,
+{
+    scoped(move |req| &host == req.uri().host().unwrap_or(""))
+}
+
+/// Create a retry policy that will never retry any request.
+///
+/// This is useful for disabling the `Client`s default behavior of retrying
+/// protocol nacks.
+pub fn never() -> Builder {
+    scoped(|_| false).no_budget()
+}
+
+fn scoped<F>(func: F) -> Builder
+where
+    F: Fn(&Req) -> bool + Send + Sync + 'static,
+{
+    Builder::scoped(scope::ScopeFn(func))
+}
+
+// ===== impl Builder =====
+
+impl Builder {
+    /// Create a scoped retry policy.
+    ///
+    /// For a more convenient constructor, see [`for_host()`].
+    pub fn scoped(scope: impl scope::Scope) -> Self {
+        Self {
+            budget: Some(0.2),
+            classifier: classify::Classifier::Never,
+            max_retries_per_request: 2, // on top of the original
+            scope: scope::Scoped::Dyn(Arc::new(scope)),
+        }
+    }
+
+    /// Set no retry budget.
+    ///
+    /// Sets that no budget will be enforced. This could also be considered
+    /// to be an infinite budget.
+    ///
+    /// This is NOT recommended. Disabling the budget can make your system more
+    /// susceptible to retry storms.
+    pub fn no_budget(mut self) -> Self {
+        self.budget = None;
+        self
+    }
+
+    /// Sets the max extra load the budget will allow.
+    ///
+    /// Think of the amount of requests your client generates, and how much
+    /// load that puts on the server. This option configures as a percentage
+    /// how much extra load is allowed via retries.
+    ///
+    /// For example, if you send 1,000 requests per second, setting a maximum
+    /// extra load value of `0.3` would allow 300 more requests per second
+    /// in retries. A value of `2.5` would allow 2,500 more requests.
+    ///
+    /// # Panics
+    ///
+    /// The `extra_percent` value must be within reasonable values for a
+    /// percentage. This method will panic if it is less than `0.0`, or greater
+    /// than `1000.0`.
+    pub fn max_extra_load(mut self, extra_percent: f32) -> Self {
+        assert!(extra_percent >= 0.0);
+        assert!(extra_percent <= 1000.0);
+        self.budget = Some(extra_percent);
+        self
+    }
+
+    // pub fn max_replay_body
+
+    /// Set the max retries allowed per request.
+    ///
+    /// For each logical (initial) request, only retry up to `max` times.
+    ///
+    /// This value is used in combination with a token budget that is applied
+    /// to all requests. Even if the budget would allow more requests, this
+    /// limit will prevent. Likewise, the budget may prevent retying up to
+    /// `max` times. This setting prevents a single request from consuming
+    /// the entire budget.
+    ///
+    /// Default is currently 2 retries.
+    pub fn max_retries_per_request(mut self, max: u32) -> Self {
+        self.max_retries_per_request = max;
+        self
+    }
+
+    /// Provide a classifier to determine if a request should be retried.
+    ///
+    /// # Example
+    ///
+    /// ```rust
+    /// # fn with_builder(builder: reqwest::retry::Builder) -> reqwest::retry::Builder {
+    /// builder.classify_fn(|req_rep| {
+    ///     match (req_rep.method(), req_rep.status()) {
+    ///         (&http::Method::GET, Some(http::StatusCode::SERVICE_UNAVAILABLE)) => {
+    ///             req_rep.retryable()
+    ///         },
+    ///         _ => req_rep.success()
+    ///     }
+    /// })
+    /// # }
+    /// ```
+    pub fn classify_fn<F>(self, func: F) -> Self
+    where
+        F: Fn(classify::ReqRep<'_>) -> classify::Action + Send + Sync + 'static,
+    {
+        self.classify(classify::ClassifyFn(func))
+    }
+
+    /// Provide a classifier to determine if a request should be retried.
+    pub fn classify(mut self, classifier: impl classify::Classify) -> Self {
+        self.classifier = classify::Classifier::Dyn(Arc::new(classifier));
+        self
+    }
+
+    pub(crate) fn default() -> Builder {
+        Self {
+            // unscoped protocols nacks doesn't need a budget
+            budget: None,
+            classifier: classify::Classifier::ProtocolNacks,
+            max_retries_per_request: 2, // on top of the original
+            scope: scope::Scoped::Unscoped,
+        }
+    }
+
+    pub(crate) fn into_policy(self) -> Policy {
+        let budget = self
+            .budget
+            .map(|p| Arc::new(Budget::new(Duration::from_secs(10), 10, p)));
+        Policy {
+            budget,
+            classifier: self.classifier,
+            max_retries_per_request: self.max_retries_per_request,
+            retry_cnt: 0,
+            scope: self.scope,
+        }
+    }
+}
+
+// ===== internal ======
+
+type Req = http::Request<crate::async_impl::body::Body>;
+
+impl<B> tower::retry::Policy<Req, http::Response<B>, crate::Error> for Policy {
+    // TODO? backoff futures...
+    type Future = std::future::Ready<()>;
+
+    fn retry(
+        &mut self,
+        req: &mut Req,
+        result: &mut crate::Result<http::Response<B>>,
+    ) -> Option<Self::Future> {
+        match self.classifier.classify(req, result) {
+            classify::Action::Success => {
+                log::trace!("shouldn't retry!");
+                if let Some(ref budget) = self.budget {
+                    budget.deposit();
+                }
+                None
+            }
+            classify::Action::Retryable => {
+                log::trace!("could retry!");
+                if self.budget.as_ref().map(|b| b.withdraw()).unwrap_or(true) {
+                    self.retry_cnt += 1;
+                    Some(std::future::ready(()))
+                } else {
+                    log::debug!("retryable but could not withdraw from budget");
+                    None
+                }
+            }
+        }
+    }
+
+    fn clone_request(&mut self, req: &Req) -> Option<Req> {
+        if self.retry_cnt > 0 && !self.scope.applies_to(req) {
+            return None;
+        }
+        if self.retry_cnt >= self.max_retries_per_request {
+            log::trace!("max_retries_per_request hit");
+            return None;
+        }
+        let body = req.body().try_clone()?;
+        let mut new = http::Request::new(body);
+        *new.method_mut() = req.method().clone();
+        *new.uri_mut() = req.uri().clone();
+        *new.version_mut() = req.version();
+        *new.headers_mut() = req.headers().clone();
+        *new.extensions_mut() = req.extensions().clone();
+
+        Some(new)
+    }
+}
+
+fn is_retryable_error(err: &crate::Error) -> bool {
+    use std::error::Error as _;
+
+    // pop the reqwest::Error
+    let err = if let Some(err) = err.source() {
+        err
+    } else {
+        return false;
+    };
+    // pop the legacy::Error
+    let err = if let Some(err) = err.source() {
+        err
+    } else {
+        return false;
+    };
+
+    #[cfg(not(any(feature = "http3", feature = "http2")))]
+    let _err = err;
+
+    #[cfg(feature = "http3")]
+    if let Some(cause) = err.source() {
+        if let Some(err) = cause.downcast_ref::<h3::error::ConnectionError>() {
+            log::trace!("determining if HTTP/3 error {err} can be retried");
+            // TODO: Does h3 provide an API for checking the error?
+            return err.to_string().as_str() == "timeout";
+        }
+    }
+
+    #[cfg(feature = "http2")]
+    if let Some(cause) = err.source() {
+        if let Some(err) = cause.downcast_ref::<h2::Error>() {
+            // They sent us a graceful shutdown, try with a new connection!
+            if err.is_go_away() && err.is_remote() && err.reason() == Some(h2::Reason::NO_ERROR) {
+                return true;
+            }
+
+            // REFUSED_STREAM was sent from the server, which is safe to retry.
+            // https://www.rfc-editor.org/rfc/rfc9113.html#section-8.7-3.2
+            if err.is_reset() && err.is_remote() && err.reason() == Some(h2::Reason::REFUSED_STREAM)
+            {
+                return true;
+            }
+        }
+    }
+    false
+}
+
+// sealed types and traits on purpose while exploring design space
+mod scope {
+    pub trait Scope: Send + Sync + 'static {
+        fn applies_to(&self, req: &super::Req) -> bool;
+    }
+
+    // I think scopes likely make the most sense being to hosts.
+    // If that's the case, then it should probably be easiest to check for
+    // the host. Perhaps also considering the ability to add more things
+    // to scope off in the future...
+
+    // For Future Whoever: making a blanket impl for any closure sounds nice,
+    // but it causes inference issues at the call site. Every closure would
+    // need to include `: ReqRep` in the arguments.
+    //
+    // An alternative is to make things like `ScopeFn`. Slightly more annoying,
+    // but also more forwards-compatible. :shrug:
+
+    pub struct ScopeFn<F>(pub(super) F);
+
+    impl<F> Scope for ScopeFn<F>
+    where
+        F: Fn(&super::Req) -> bool + Send + Sync + 'static,
+    {
+        fn applies_to(&self, req: &super::Req) -> bool {
+            (self.0)(req)
+        }
+    }
+
+    #[derive(Clone)]
+    pub(super) enum Scoped {
+        Unscoped,
+        Dyn(std::sync::Arc<dyn Scope>),
+    }
+
+    impl Scoped {
+        pub(super) fn applies_to(&self, req: &super::Req) -> bool {
+            let ret = match self {
+                Self::Unscoped => true,
+                Self::Dyn(s) => s.applies_to(req),
+            };
+            log::trace!("retry in scope: {ret}");
+            ret
+        }
+    }
+
+    impl std::fmt::Debug for Scoped {
+        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+            match self {
+                Self::Unscoped => f.write_str("Unscoped"),
+                Self::Dyn(_) => f.write_str("Scoped"),
+            }
+        }
+    }
+}
+
+// sealed types and traits on purpose while exploring design space
+mod classify {
+    pub trait Classify: Send + Sync + 'static {
+        fn classify(&self, req_rep: ReqRep<'_>) -> Action;
+    }
+
+    // For Future Whoever: making a blanket impl for any closure sounds nice,
+    // but it causes inference issues at the call site. Every closure would
+    // need to include `: ReqRep` in the arguments.
+    //
+    // An alternative is to make things like `ClassifyFn`. Slightly more
+    // annoying, but also more forwards-compatible. :shrug:
+    pub struct ClassifyFn<F>(pub(super) F);
+
+    impl<F> Classify for ClassifyFn<F>
+    where
+        F: Fn(ReqRep<'_>) -> Action + Send + Sync + 'static,
+    {
+        fn classify(&self, req_rep: ReqRep<'_>) -> Action {
+            (self.0)(req_rep)
+        }
+    }
+
+    #[derive(Debug)]
+    pub struct ReqRep<'a>(&'a super::Req, Result<http::StatusCode, &'a crate::Error>);
+
+    impl ReqRep<'_> {
+        pub fn method(&self) -> &http::Method {
+            self.0.method()
+        }
+
+        pub fn uri(&self) -> &http::Uri {
+            self.0.uri()
+        }
+
+        pub fn status(&self) -> Option<http::StatusCode> {
+            self.1.ok()
+        }
+
+        pub fn error(&self) -> Option<&(dyn std::error::Error + 'static)> {
+            self.1.as_ref().err().map(|e| &**e as _)
+        }
+
+        pub fn retryable(self) -> Action {
+            Action::Retryable
+        }
+
+        pub fn success(self) -> Action {
+            Action::Success
+        }
+
+        fn is_protocol_nack(&self) -> bool {
+            self.1
+                .as_ref()
+                .err()
+                .map(|&e| super::is_retryable_error(e))
+                .unwrap_or(false)
+        }
+    }
+
+    #[must_use]
+    #[derive(Debug)]
+    pub enum Action {
+        Success,
+        Retryable,
+    }
+
+    #[derive(Clone)]
+    pub(super) enum Classifier {
+        Never,
+        ProtocolNacks,
+        Dyn(std::sync::Arc<dyn Classify>),
+    }
+
+    impl Classifier {
+        pub(super) fn classify<B>(
+            &self,
+            req: &super::Req,
+            res: &Result<http::Response<B>, crate::Error>,
+        ) -> Action {
+            let req_rep = ReqRep(req, res.as_ref().map(|r| r.status()));
+            match self {
+                Self::Never => Action::Success,
+                Self::ProtocolNacks => {
+                    if req_rep.is_protocol_nack() {
+                        Action::Retryable
+                    } else {
+                        Action::Success
+                    }
+                }
+                Self::Dyn(c) => c.classify(req_rep),
+            }
+        }
+    }
+
+    impl std::fmt::Debug for Classifier {
+        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
+            match self {
+                Self::Never => f.write_str("Never"),
+                Self::ProtocolNacks => f.write_str("ProtocolNacks"),
+                Self::Dyn(_) => f.write_str("Classifier"),
+            }
+        }
+    }
+}
diff --git a/tests/client.rs b/tests/client.rs
index 307892c..fce977f 100644
--- a/tests/client.rs
+++ b/tests/client.rs
@@ -473,78 +473,6 @@ async fn test_tls_info() {
     assert!(tls_info.is_none());
 }
 
-// NOTE: using the default "current_thread" runtime here would cause the test to
-// fail, because the only thread would block until `panic_rx` receives a
-// notification while the client needs to be driven to get the graceful shutdown
-// done.
-#[cfg(feature = "http2")]
-#[tokio::test(flavor = "multi_thread", worker_threads = 2)]
-async fn highly_concurrent_requests_to_http2_server_with_low_max_concurrent_streams() {
-    let client = reqwest::Client::builder()
-        .http2_prior_knowledge()
-        .build()
-        .unwrap();
-
-    let server = server::http_with_config(
-        move |req| async move {
-            assert_eq!(req.version(), http::Version::HTTP_2);
-            http::Response::default()
-        },
-        |builder| {
-            builder.http2().max_concurrent_streams(1);
-        },
-    );
-
-    let url = format!("http://{}", server.addr());
-
-    let futs = (0..100).map(|_| {
-        let client = client.clone();
-        let url = url.clone();
-        async move {
-            let res = client.get(&url).send().await.unwrap();
-            assert_eq!(res.status(), reqwest::StatusCode::OK);
-        }
-    });
-    futures_util::future::join_all(futs).await;
-}
-
-#[cfg(feature = "http2")]
-#[tokio::test]
-async fn highly_concurrent_requests_to_slow_http2_server_with_low_max_concurrent_streams() {
-    use support::delay_server;
-
-    let client = reqwest::Client::builder()
-        .http2_prior_knowledge()
-        .build()
-        .unwrap();
-
-    let server = delay_server::Server::new(
-        move |req| async move {
-            assert_eq!(req.version(), http::Version::HTTP_2);
-            http::Response::default()
-        },
-        |http| {
-            http.http2().max_concurrent_streams(1);
-        },
-        std::time::Duration::from_secs(2),
-    )
-    .await;
-
-    let url = format!("http://{}", server.addr());
-
-    let futs = (0..100).map(|_| {
-        let client = client.clone();
-        let url = url.clone();
-        async move {
-            let res = client.get(&url).send().await.unwrap();
-            assert_eq!(res.status(), reqwest::StatusCode::OK);
-        }
-    });
-    futures_util::future::join_all(futs).await;
-
-    server.shutdown().await;
-}
-
 #[tokio::test]
 async fn close_connection_after_idle_timeout() {
     let mut server = server::http(move |_| async move { http::Response::default() });
diff --git a/tests/retry.rs b/tests/retry.rs
new file mode 100644
index 0000000..15d264e
--- /dev/null
+++ b/tests/retry.rs
@@ -0,0 +1,144 @@
+#![cfg(not(target_arch = "wasm32"))]
+#![cfg(not(feature = "rustls-tls-manual-roots-no-provider"))]
+mod support;
+use support::server;
+
+use std::sync::atomic::{AtomicUsize, Ordering};
+use std::sync::Arc;
+
+#[tokio::test]
+async fn retries_apply_in_scope() {
+    let _ = env_logger::try_init();
+    let cnt = Arc::new(AtomicUsize::new(0));
+    let server = server::http(move |_req| {
+        let cnt = cnt.clone();
+        async move {
+            if cnt.fetch_add(1, Ordering::Relaxed) == 0 {
+                // first req is bad
+                http::Response::builder()
+                    .status(http::StatusCode::SERVICE_UNAVAILABLE)
+                    .body(Default::default())
+                    .unwrap()
+            } else {
+                http::Response::default()
+            }
+        }
+    });
+
+    let scope = server.addr().ip().to_string();
+    let retries = reqwest::retry::for_host(scope).classify_fn(|req_rep| {
+        if req_rep.status() == Some(http::StatusCode::SERVICE_UNAVAILABLE) {
+            req_rep.retryable()
+        } else {
+            req_rep.success()
+        }
+    });
+
+    let url = format!("http://{}", server.addr());
+    let resp = reqwest::Client::builder()
+        .retry(retries)
+        .build()
+        .unwrap()
+        .get(url)
+        .send()
+        .await
+        .unwrap();
+
+    assert_eq!(resp.status(), 200);
+}
+
+#[cfg(feature = "http2")]
+#[tokio::test(flavor = "multi_thread", worker_threads = 2)]
+async fn default_retries_have_a_limit() {
+    let _ = env_logger::try_init();
+
+    let server = server::http_with_config(
+        move |req| async move {
+            assert_eq!(req.version(), http::Version::HTTP_2);
+            // refused forever
+            Err(h2::Error::from(h2::Reason::REFUSED_STREAM))
+        },
+        |_| {},
+    );
+
+    let client = reqwest::Client::builder()
+        .http2_prior_knowledge()
+        .build()
+        .unwrap();
+
+    let url = format!("http://{}", server.addr());
+
+    let _err = client.get(url).send().await.unwrap_err();
+}
+
+// NOTE: using the default "current_thread" runtime here would cause the test to
+// fail, because the only thread would block until `panic_rx` receives a
+// notification while the client needs to be driven to get the graceful shutdown
+// done.
+#[cfg(feature = "http2")]
+#[tokio::test(flavor = "multi_thread", worker_threads = 2)]
+async fn highly_concurrent_requests_to_http2_server_with_low_max_concurrent_streams() {
+    let client = reqwest::Client::builder()
+        .http2_prior_knowledge()
+        .build()
+        .unwrap();
+
+    let server = server::http_with_config(
+        move |req| async move {
+            assert_eq!(req.version(), http::Version::HTTP_2);
+            Ok::<_, std::convert::Infallible>(http::Response::default())
+        },
+        |builder| {
+            builder.http2().max_concurrent_streams(1);
+        },
+    );
+
+    let url = format!("http://{}", server.addr());
+
+    let futs = (0..100).map(|_| {
+        let client = client.clone();
+        let url = url.clone();
+        async move {
+            let res = client.get(&url).send().await.unwrap();
+            assert_eq!(res.status(), reqwest::StatusCode::OK);
+        }
+    });
+    futures_util::future::join_all(futs).await;
+}
+
+#[cfg(feature = "http2")]
+#[tokio::test]
+async fn highly_concurrent_requests_to_slow_http2_server_with_low_max_concurrent_streams() {
+    use support::delay_server;
+
+    let client = reqwest::Client::builder()
+        .http2_prior_knowledge()
+        .build()
+        .unwrap();
+
+    let server = delay_server::Server::new(
+        move |req| async move {
+            assert_eq!(req.version(), http::Version::HTTP_2);
+            http::Response::default()
+        },
+        |http| {
+            http.http2().max_concurrent_streams(1);
+        },
+        std::time::Duration::from_secs(2),
+    )
+    .await;
+
+    let url = format!("http://{}", server.addr());
+
+    let futs = (0..100).map(|_| {
+        let client = client.clone();
+        let url = url.clone();
+        async move {
+            let res = client.get(&url).send().await.unwrap();
+            assert_eq!(res.status(), reqwest::StatusCode::OK);
+        }
+    });
+    futures_util::future::join_all(futs).await;
+
+    server.shutdown().await;
+}
diff --git a/tests/support/server.rs b/tests/support/server.rs
index 9d79d5a..e9b653d 100644
--- a/tests/support/server.rs
+++ b/tests/support/server.rs
@@ -56,15 +56,20 @@ where
     F: Fn(http::Request<hyper::body::Incoming>) -> Fut + Clone + Send + 'static,
     Fut: Future<Output = http::Response<reqwest::Body>> + Send + 'static,
 {
-    http_with_config(func, |_builder| {})
+    let infall = move |req| {
+        let fut = func(req);
+        async move { Ok::<_, Infallible>(fut.await) }
+    };
+    http_with_config(infall, |_builder| {})
 }
 
 type Builder = hyper_util::server::conn::auto::Builder<hyper_util::rt::TokioExecutor>;
 
-pub fn http_with_config<F1, Fut, F2, Bu>(func: F1, apply_config: F2) -> Server
+pub fn http_with_config<F1, Fut, E, F2, Bu>(func: F1, apply_config: F2) -> Server
 where
     F1: Fn(http::Request<hyper::body::Incoming>) -> Fut + Clone + Send + 'static,
-    Fut: Future<Output = http::Response<reqwest::Body>> + Send + 'static,
+    Fut: Future<Output = Result<http::Response<reqwest::Body>, E>> + Send + 'static,
+    E: Into<Box<dyn std::error::Error + Send + Sync>>,
     F2: FnOnce(&mut Builder) -> Bu + Send + 'static,
 {
     // Spawn new runtime in thread to prevent reactor execution context conflict
@@ -107,10 +112,7 @@ where
                             accepted = listener.accept() => {
                                 let (io, _) = accepted.expect("accepted");
                                 let func = func.clone();
-                                let svc = hyper::service::service_fn(move |req| {
-                                    let fut = func(req);
-                                    async move { Ok::<_, Infallible>(fut.await) }
-                                });
+                                let svc = hyper::service::service_fn(func);
                                 let builder = builder.clone();
                                 let events_tx = events_tx.clone();
                                 let watcher = graceful.watcher();
