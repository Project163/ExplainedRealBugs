diff --git a/src/async_impl/client.rs b/src/async_impl/client.rs
index c916d6f..f1f83db 100644
--- a/src/async_impl/client.rs
+++ b/src/async_impl/client.rs
@@ -20,6 +20,8 @@ use crate::async_impl::h3_client::connect::{H3ClientConfig, H3Connector};
 #[cfg(feature = "http3")]
 use crate::async_impl::h3_client::H3Client;
 use crate::config::{RequestConfig, RequestTimeout};
+#[cfg(unix)]
+use crate::connect::uds::UnixSocketProvider;
 use crate::connect::{
     sealed::{Conn, Unnameable},
     BoxedConnectorLayer, BoxedConnectorService, Connector, ConnectorBuilder,
@@ -256,6 +258,9 @@ struct Config {
     h3_send_grease: Option<bool>,
     dns_overrides: HashMap<String, Vec<SocketAddr>>,
     dns_resolver: Option<Arc<dyn Resolve>>,
+
+    #[cfg(unix)]
+    unix_socket: Option<Arc<std::path::Path>>,
 }
 
 impl Default for ClientBuilder {
@@ -378,6 +383,8 @@ impl ClientBuilder {
                 #[cfg(feature = "http3")]
                 h3_send_grease: None,
                 dns_resolver: None,
+                #[cfg(unix)]
+                unix_socket: None,
             },
         }
     }
@@ -907,6 +914,12 @@ impl ClientBuilder {
         #[cfg(feature = "socks")]
         connector_builder.set_socks_resolver(resolver);
 
+        // TODO: It'd be best to refactor this so the HttpConnector is never
+        // constructed at all. But there's a lot of code for all the different
+        // ways TLS can be configured...
+        #[cfg(unix)]
+        connector_builder.set_unix_socket(config.unix_socket);
+
         let mut builder =
             hyper_util::client::legacy::Client::builder(hyper_util::rt::TokioExecutor::new());
         #[cfg(feature = "http2")]
@@ -1710,6 +1723,25 @@ impl ClientBuilder {
         self
     }
 
+    // Alt Transports
+
+    /// Set that all connections will use this Unix socket.
+    ///
+    /// If a request URI uses the `https` scheme, TLS will still be used over
+    /// the Unix socket.
+    ///
+    /// # Note
+    ///
+    /// This option is not compatible with any of the TCP or Proxy options.
+    /// Setting this will ignore all those options previously set.
+    ///
+    /// Likewise, DNS resolution will not be done on the domain name.
+    #[cfg(unix)]
+    pub fn unix_socket(mut self, path: impl UnixSocketProvider) -> ClientBuilder {
+        self.config.unix_socket = Some(path.reqwest_uds_path(crate::connect::uds::Internal).into());
+        self
+    }
+
     // TLS options
 
     /// Add a custom root certificate.
@@ -2752,6 +2784,11 @@ impl Config {
                 f.field("tls_enable_early_data", &true);
             }
         }
+
+        #[cfg(unix)]
+        if let Some(ref p) = self.unix_socket {
+            f.field("unix_socket", p);
+        }
     }
 }
 
diff --git a/src/blocking/client.rs b/src/blocking/client.rs
index 338ef63..77619f3 100644
--- a/src/blocking/client.rs
+++ b/src/blocking/client.rs
@@ -20,6 +20,8 @@ use super::request::{Request, RequestBuilder};
 use super::response::Response;
 use super::wait;
 use crate::connect::sealed::{Conn, Unnameable};
+#[cfg(unix)]
+use crate::connect::uds::UnixSocketProvider;
 use crate::connect::BoxedConnectorService;
 use crate::dns::Resolve;
 use crate::error::BoxError;
@@ -723,6 +725,24 @@ impl ClientBuilder {
         self.with_inner(move |inner| inner.tcp_user_timeout(val))
     }
 
+    // Alt Transports
+
+    /// Set that all connections will use this Unix socket.
+    ///
+    /// If a request URI uses the `https` scheme, TLS will still be used over
+    /// the Unix socket.
+    ///
+    /// # Note
+    ///
+    /// This option is not compatible with any of the TCP or Proxy options.
+    /// Setting this will ignore all those options previously set.
+    ///
+    /// Likewise, DNS resolution will not be done on the domain name.
+    #[cfg(unix)]
+    pub fn unix_socket(self, path: impl UnixSocketProvider) -> ClientBuilder {
+        self.with_inner(move |inner| inner.unix_socket(path))
+    }
+
     // TLS options
 
     /// Add a custom root certificate.
diff --git a/src/connect.rs b/src/connect.rs
index 3810c3d..ca52dd5 100644
--- a/src/connect.rs
+++ b/src/connect.rs
@@ -5,7 +5,7 @@ use http::uri::Scheme;
 use http::Uri;
 use hyper::rt::{Read, ReadBufCursor, Write};
 use hyper_util::client::legacy::connect::{Connected, Connection};
-#[cfg(any(feature = "socks", feature = "__tls"))]
+#[cfg(any(feature = "socks", feature = "__tls", unix))]
 use hyper_util::rt::TokioIo;
 #[cfg(feature = "default-tls")]
 use native_tls_crate::{TlsConnector, TlsConnectorBuilder};
@@ -80,6 +80,8 @@ pub(crate) struct ConnectorBuilder {
     user_agent: Option<HeaderValue>,
     #[cfg(feature = "socks")]
     resolver: Option<DynResolver>,
+    #[cfg(unix)]
+    unix_socket: Option<Arc<std::path::Path>>,
 }
 
 impl ConnectorBuilder {
@@ -99,8 +101,16 @@ where {
             simple_timeout: None,
             #[cfg(feature = "socks")]
             resolver: self.resolver.unwrap_or_else(DynResolver::gai),
+            #[cfg(unix)]
+            unix_socket: self.unix_socket,
         };
 
+        #[cfg(unix)]
+        if base_service.unix_socket.is_some() && !base_service.proxies.is_empty() {
+            base_service.proxies = Default::default();
+            log::trace!("unix_socket() set, proxies are ignored");
+        }
+
         if layers.is_empty() {
             // we have no user-provided layers, only use concrete types
             base_service.simple_timeout = self.timeout;
@@ -196,6 +206,8 @@ where {
             timeout: None,
             #[cfg(feature = "socks")]
             resolver: None,
+            #[cfg(unix)]
+            unix_socket: None,
         }
     }
 
@@ -305,6 +317,8 @@ where {
             timeout: None,
             #[cfg(feature = "socks")]
             resolver: None,
+            #[cfg(unix)]
+            unix_socket: None,
         }
     }
 
@@ -376,6 +390,8 @@ where {
             timeout: None,
             #[cfg(feature = "socks")]
             resolver: None,
+            #[cfg(unix)]
+            unix_socket: None,
         }
     }
 
@@ -436,6 +452,11 @@ where {
             Inner::Http(http) => http.set_tcp_user_timeout(dur),
         }
     }
+
+    #[cfg(unix)]
+    pub(crate) fn set_unix_socket(&mut self, path: Option<Arc<std::path::Path>>) {
+        self.unix_socket = path;
+    }
 }
 
 #[allow(missing_debug_implementations)]
@@ -457,6 +478,9 @@ pub(crate) struct ConnectorService {
     user_agent: Option<HeaderValue>,
     #[cfg(feature = "socks")]
     resolver: DynResolver,
+    /// If set, this always takes priority over TCP.
+    #[cfg(unix)]
+    unix_socket: Option<Arc<std::path::Path>>,
 }
 
 #[derive(Clone)]
@@ -649,6 +673,75 @@ impl ConnectorService {
         }
     }
 
+    /// Connect over Unix Domain Socket (or Windows?).
+    #[cfg(unix)]
+    async fn connect_local_transport(self, dst: Uri) -> Result<Conn, BoxError> {
+        let path = self
+            .unix_socket
+            .as_ref()
+            .expect("connect local must have socket path")
+            .clone();
+        let svc = tower::service_fn(move |_| {
+            let fut = tokio::net::UnixStream::connect(path.clone());
+            async move {
+                let io = fut.await?;
+                Ok::<_, std::io::Error>(TokioIo::new(io))
+            }
+        });
+        let is_proxy = false;
+        match self.inner {
+            #[cfg(not(feature = "__tls"))]
+            Inner::Http(..) => {
+                let mut svc = svc;
+                let io = svc.call(dst).await?;
+                Ok(Conn {
+                    inner: self.verbose.wrap(io),
+                    is_proxy,
+                    tls_info: false,
+                })
+            }
+            #[cfg(feature = "default-tls")]
+            Inner::DefaultTls(_, tls) => {
+                let tls_connector = tokio_native_tls::TlsConnector::from(tls.clone());
+                let mut http = hyper_tls::HttpsConnector::from((svc, tls_connector));
+                let io = http.call(dst).await?;
+
+                if let hyper_tls::MaybeHttpsStream::Https(stream) = io {
+                    Ok(Conn {
+                        inner: self.verbose.wrap(NativeTlsConn { inner: stream }),
+                        is_proxy,
+                        tls_info: self.tls_info,
+                    })
+                } else {
+                    Ok(Conn {
+                        inner: self.verbose.wrap(io),
+                        is_proxy,
+                        tls_info: false,
+                    })
+                }
+            }
+            #[cfg(feature = "__rustls")]
+            Inner::RustlsTls { tls, .. } => {
+                let mut http = hyper_rustls::HttpsConnector::from((svc, tls.clone()));
+                let io = http.call(dst).await?;
+
+                if let hyper_rustls::MaybeHttpsStream::Https(stream) = io {
+                    Ok(Conn {
+                        inner: self.verbose.wrap(RustlsTlsConn { inner: stream }),
+                        is_proxy,
+                        tls_info: self.tls_info,
+                    })
+                } else {
+                    Ok(Conn {
+                        inner: self.verbose.wrap(io),
+                        is_proxy,
+                        tls_info: false,
+                    })
+                }
+            }
+        }
+    }
+
     async fn connect_via_proxy(self, dst: Uri, proxy: Intercepted) -> Result<Conn, BoxError> {
         log::debug!("proxy({proxy:?}) intercepts '{dst:?}'");
 
@@ -788,6 +881,16 @@ impl Service<Uri> for ConnectorService {
     fn call(&mut self, dst: Uri) -> Self::Future {
         log::debug!("starting new connection: {dst:?}");
         let timeout = self.simple_timeout;
+
+        // Local transports (UDS) skip proxies
+        #[cfg(unix)]
+        if self.unix_socket.is_some() {
+            return Box::pin(with_timeout(
+                self.clone().connect_local_transport(dst),
+                timeout,
+            ));
+        }
+
         for prox in self.proxies.iter() {
             if let Some(intercepted) = prox.intercept(&dst) {
                 return Box::pin(with_timeout(
@@ -810,16 +913,18 @@ trait TlsInfoFactory {
 }
 
 #[cfg(feature = "__tls")]
-impl TlsInfoFactory for tokio::net::TcpStream {
+impl<T: TlsInfoFactory> TlsInfoFactory for TokioIo<T> {
     fn tls_info(&self) -> Option<crate::tls::TlsInfo> {
-        None
+        self.inner().tls_info()
     }
 }
 
+// ===== TcpStream =====
+
 #[cfg(feature = "__tls")]
-impl<T: TlsInfoFactory> TlsInfoFactory for TokioIo<T> {
+impl TlsInfoFactory for tokio::net::TcpStream {
     fn tls_info(&self) -> Option<crate::tls::TlsInfo> {
-        self.inner().tls_info()
+        None
     }
 }
 
@@ -903,6 +1008,102 @@ impl TlsInfoFactory for hyper_rustls::MaybeHttpsStream<TokioIo<tokio::net::TcpSt
     }
 }
 
+// ===== UnixStream =====
+
+#[cfg(feature = "__tls")]
+#[cfg(unix)]
+impl TlsInfoFactory for tokio::net::UnixStream {
+    fn tls_info(&self) -> Option<crate::tls::TlsInfo> {
+        None
+    }
+}
+
+#[cfg(feature = "default-tls")]
+#[cfg(unix)]
+impl TlsInfoFactory for tokio_native_tls::TlsStream<TokioIo<TokioIo<tokio::net::UnixStream>>> {
+    fn tls_info(&self) -> Option<crate::tls::TlsInfo> {
+        let peer_certificate = self
+            .get_ref()
+            .peer_certificate()
+            .ok()
+            .flatten()
+            .and_then(|c| c.to_der().ok());
+        Some(crate::tls::TlsInfo { peer_certificate })
+    }
+}
+
+#[cfg(feature = "default-tls")]
+#[cfg(unix)]
+impl TlsInfoFactory
+    for tokio_native_tls::TlsStream<
+        TokioIo<hyper_tls::MaybeHttpsStream<TokioIo<tokio::net::UnixStream>>>,
+    >
+{
+    fn tls_info(&self) -> Option<crate::tls::TlsInfo> {
+        let peer_certificate = self
+            .get_ref()
+            .peer_certificate()
+            .ok()
+            .flatten()
+            .and_then(|c| c.to_der().ok());
+        Some(crate::tls::TlsInfo { peer_certificate })
+    }
+}
+
+#[cfg(feature = "default-tls")]
+#[cfg(unix)]
+impl TlsInfoFactory for hyper_tls::MaybeHttpsStream<TokioIo<tokio::net::UnixStream>> {
+    fn tls_info(&self) -> Option<crate::tls::TlsInfo> {
+        match self {
+            hyper_tls::MaybeHttpsStream::Https(tls) => tls.tls_info(),
+            hyper_tls::MaybeHttpsStream::Http(_) => None,
+        }
+    }
+}
+
+#[cfg(feature = "__rustls")]
+#[cfg(unix)]
+impl TlsInfoFactory for tokio_rustls::client::TlsStream<TokioIo<TokioIo<tokio::net::UnixStream>>> {
+    fn tls_info(&self) -> Option<crate::tls::TlsInfo> {
+        let peer_certificate = self
+            .get_ref()
+            .1
+            .peer_certificates()
+            .and_then(|certs| certs.first())
+            .map(|c| c.to_vec());
+        Some(crate::tls::TlsInfo { peer_certificate })
+    }
+}
+
+#[cfg(feature = "__rustls")]
+#[cfg(unix)]
+impl TlsInfoFactory
+    for tokio_rustls::client::TlsStream<
+        TokioIo<hyper_rustls::MaybeHttpsStream<TokioIo<tokio::net::UnixStream>>>,
+    >
+{
+    fn tls_info(&self) -> Option<crate::tls::TlsInfo> {
+        let peer_certificate = self
+            .get_ref()
+            .1
+            .peer_certificates()
+            .and_then(|certs| certs.first())
+            .map(|c| c.to_vec());
+        Some(crate::tls::TlsInfo { peer_certificate })
+    }
+}
+
+#[cfg(feature = "__rustls")]
+#[cfg(unix)]
+impl TlsInfoFactory for hyper_rustls::MaybeHttpsStream<TokioIo<tokio::net::UnixStream>> {
+    fn tls_info(&self) -> Option<crate::tls::TlsInfo> {
+        match self {
+            hyper_rustls::MaybeHttpsStream::Https(tls) => tls.tls_info(),
+            hyper_rustls::MaybeHttpsStream::Http(_) => None,
+        }
+    }
+}
+
 pub(crate) trait AsyncConn:
     Read + Write + Connection + Send + Sync + Unpin + 'static
 {
@@ -1006,6 +1207,48 @@ pub(crate) mod sealed {
     }
 }
 
+// Some sealed things for UDS
+#[cfg(unix)]
+pub(crate) mod uds {
+    use std::path::Path;
+
+    /// A provider for Unix Domain Socket paths.
+    ///
+    /// This trait is sealed. This allows us expand the support in the future
+    /// by controlling who can implement the trait.
+    ///
+    /// It's available in the docs to see what type may be passed in.
+    #[cfg(unix)]
+    pub trait UnixSocketProvider {
+        #[doc(hidden)]
+        fn reqwest_uds_path(&self, _: Internal) -> &Path;
+    }
+
+    #[allow(missing_debug_implementations)]
+    pub struct Internal;
+
+    macro_rules! as_path {
+        ($($t:ty,)+) => {
+            $(
+                impl UnixSocketProvider for $t {
+                    #[doc(hidden)]
+                    fn reqwest_uds_path(&self, _: Internal) -> &Path {
+                        self.as_ref()
+                    }
+                }
+            )+
+        }
+    }
+
+    as_path![
+        String,
+        &'_ str,
+        &'_ Path,
+        std::path::PathBuf,
+        std::sync::Arc<Path>,
+    ];
+}
+
 pub(crate) type Connecting = Pin<Box<dyn Future<Output = Result<Conn, BoxError>> + Send>>;
 
 #[cfg(feature = "default-tls")]
@@ -1071,6 +1314,34 @@ mod native_tls_conn {
         }
     }
 
+    #[cfg(unix)]
+    impl Connection for NativeTlsConn<TokioIo<TokioIo<tokio::net::UnixStream>>> {
+        fn connected(&self) -> Connected {
+            let connected = Connected::new();
+            #[cfg(feature = "native-tls-alpn")]
+            match self.inner.inner().get_ref().negotiated_alpn().ok() {
+                Some(Some(alpn_protocol)) if alpn_protocol == b"h2" => connected.negotiated_h2(),
+                _ => connected,
+            }
+            #[cfg(not(feature = "native-tls-alpn"))]
+            connected
+        }
+    }
+
+    #[cfg(unix)]
+    impl Connection for NativeTlsConn<TokioIo<MaybeHttpsStream<TokioIo<tokio::net::UnixStream>>>> {
+        fn connected(&self) -> Connected {
+            let connected = Connected::new();
+            #[cfg(feature = "native-tls-alpn")]
+            match self.inner.inner().get_ref().negotiated_alpn().ok() {
+                Some(Some(alpn_protocol)) if alpn_protocol == b"h2" => connected.negotiated_h2(),
+                _ => connected,
+            }
+            #[cfg(not(feature = "native-tls-alpn"))]
+            connected
+        }
+    }
+
     impl<T: AsyncRead + AsyncWrite + Unpin> Read for NativeTlsConn<T> {
         fn poll_read(
             self: Pin<&mut Self>,
@@ -1186,6 +1457,40 @@ mod rustls_tls_conn {
         }
     }
 
+    #[cfg(unix)]
+    impl Connection for RustlsTlsConn<TokioIo<TokioIo<tokio::net::UnixStream>>> {
+        fn connected(&self) -> Connected {
+            if self.inner.inner().get_ref().1.alpn_protocol() == Some(b"h2") {
+                self.inner
+                    .inner()
+                    .get_ref()
+                    .0
+                    .inner()
+                    .connected()
+                    .negotiated_h2()
+            } else {
+                self.inner.inner().get_ref().0.inner().connected()
+            }
+        }
+    }
+
+    #[cfg(unix)]
+    impl Connection for RustlsTlsConn<TokioIo<MaybeHttpsStream<TokioIo<tokio::net::UnixStream>>>> {
+        fn connected(&self) -> Connected {
+            if self.inner.inner().get_ref().1.alpn_protocol() == Some(b"h2") {
+                self.inner
+                    .inner()
+                    .get_ref()
+                    .0
+                    .inner()
+                    .connected()
+                    .negotiated_h2()
+            } else {
+                self.inner.inner().get_ref().0.inner().connected()
+            }
+        }
+    }
+
     impl<T: AsyncRead + AsyncWrite + Unpin> Read for RustlsTlsConn<T> {
         fn poll_read(
             self: Pin<&mut Self>,
diff --git a/src/lib.rs b/src/lib.rs
index 66e286a..fbf99cb 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -379,6 +379,9 @@ if_hyper! {
     #[cfg(feature = "__tls")]
     pub mod tls;
     mod util;
+
+    #[cfg(docsrs)]
+    pub use connect::uds::UnixSocketProvider;
 }
 
 if_wasm! {
diff --git a/tests/not_tcp.rs b/tests/not_tcp.rs
new file mode 100644
index 0000000..6023b6b
--- /dev/null
+++ b/tests/not_tcp.rs
@@ -0,0 +1,56 @@
+#![cfg(not(target_arch = "wasm32"))]
+#![cfg(not(feature = "rustls-tls-manual-roots-no-provider"))]
+#![cfg(unix)]
+
+mod support;
+
+#[tokio::test]
+async fn unix_socket_works() {
+    let server = support::not_tcp::uds(move |_| async move { http::Response::default() });
+
+    let res = reqwest::Client::builder()
+        .unix_socket(server.path())
+        .build()
+        .unwrap()
+        .get("http://yolo.local/foo")
+        .send()
+        .await
+        .expect("send request");
+
+    assert_eq!(res.status(), 200);
+}
+
+#[tokio::test]
+async fn unix_socket_ignores_proxies() {
+    let server = support::not_tcp::uds(move |_| async move { http::Response::default() });
+
+    let res = reqwest::Client::builder()
+        .unix_socket(server.path())
+        .proxy(reqwest::Proxy::http("http://dont.use.me.local").unwrap())
+        .build()
+        .unwrap()
+        .get("http://yolo.local/foo")
+        .send()
+        .await
+        .expect("send request");
+
+    assert_eq!(res.status(), 200);
+}
+
+// TODO: enable when test server supports TLS
+#[ignore]
+#[tokio::test]
+async fn unix_socket_uses_tls() {
+    let server = support::not_tcp::uds(move |_| async move { http::Response::default() });
+
+    let res = reqwest::Client::builder()
+        .unix_socket(server.path())
+        .build()
+        .unwrap()
+        .get("https://yolo.local/foo")
+        .send()
+        .await
+        .expect("send request");
+
+    assert_eq!(res.status(), 200);
+}
diff --git a/tests/support/mod.rs b/tests/support/mod.rs
index a37fc78..1d14efd 100644
--- a/tests/support/mod.rs
+++ b/tests/support/mod.rs
@@ -3,6 +3,7 @@
 pub mod delay_layer;
 pub mod delay_server;
 pub mod error;
+pub mod not_tcp;
 pub mod server;
 
 // TODO: remove once done converting to new support server?
diff --git a/tests/support/not_tcp.rs b/tests/support/not_tcp.rs
new file mode 100644
index 0000000..126d458
--- /dev/null
+++ b/tests/support/not_tcp.rs
@@ -0,0 +1,149 @@
+#![cfg(not(target_arch = "wasm32"))]
+#![cfg(unix)]
+
+use std::convert::Infallible;
+use std::future::Future;
+use std::sync::mpsc as std_mpsc;
+use std::thread;
+use std::time::Duration;
+
+use tokio::runtime;
+use tokio::sync::oneshot;
+
+pub struct Server {
+    path: std::path::PathBuf,
+    panic_rx: std_mpsc::Receiver<()>,
+    events_rx: std_mpsc::Receiver<Event>,
+    shutdown_tx: Option<oneshot::Sender<()>>,
+}
+
+#[non_exhaustive]
+pub enum Event {
+    ConnectionClosed,
+}
+
+impl Server {
+    pub fn path(&self) -> &std::path::Path {
+        &self.path
+    }
+
+    pub fn events(&mut self) -> Vec<Event> {
+        let mut events = Vec::new();
+        while let Ok(event) = self.events_rx.try_recv() {
+            events.push(event);
+        }
+        events
+    }
+}
+
+impl Drop for Server {
+    fn drop(&mut self) {
+        if let Some(tx) = self.shutdown_tx.take() {
+            let _ = tx.send(());
+        }
+
+        if !::std::thread::panicking() {
+            self.panic_rx
+                .recv_timeout(Duration::from_secs(3))
+                .expect("test server should not panic");
+        }
+    }
+}
+
+pub fn uds<F, Fut>(func: F) -> Server
+where
+    F: Fn(http::Request<hyper::body::Incoming>) -> Fut + Clone + Send + 'static,
+    Fut: Future<Output = http::Response<reqwest::Body>> + Send + 'static,
+{
+    uds_with_config(func, |_builder| {})
+}
+
+type Builder = hyper_util::server::conn::auto::Builder<hyper_util::rt::TokioExecutor>;
+
+pub fn uds_with_config<F1, Fut, F2, Bu>(func: F1, apply_config: F2) -> Server
+where
+    F1: Fn(http::Request<hyper::body::Incoming>) -> Fut + Clone + Send + 'static,
+    Fut: Future<Output = http::Response<reqwest::Body>> + Send + 'static,
+    F2: FnOnce(&mut Builder) -> Bu + Send + 'static,
+{
+    // Spawn new runtime in thread to prevent reactor execution context conflict
+    let test_name = thread::current().name().unwrap_or("<unknown>").to_string();
+    thread::spawn(move || {
+        let rt = runtime::Builder::new_current_thread()
+            .enable_all()
+            .build()
+            .expect("new rt");
+        let path = random_tmp_path();
+        let listener = rt.block_on(async {
+            tokio::net::UnixListener::bind(&path)
+                .unwrap()
+        });
+
+        let (shutdown_tx, mut shutdown_rx) = oneshot::channel();
+        let (panic_tx, panic_rx) = std_mpsc::channel();
+        let (events_tx, events_rx) = std_mpsc::channel();
+        let tname = format!(
+            "test({})-support-server",
+            test_name,
+        );
+
+        let close_path = path.clone();
+
+        thread::Builder::new()
+            .name(tname)
+            .spawn(move || {
+                rt.block_on(async move {
+                    let mut builder =
+                        hyper_util::server::conn::auto::Builder::new(hyper_util::rt::TokioExecutor::new());
+                    apply_config(&mut builder);
+
+                    loop {
+                        tokio::select! {
+                            _ = &mut shutdown_rx => {
+                                break;
+                            }
+                            accepted = listener.accept() => {
+                                let (io, _) = accepted.expect("accepted");
+                                let func = func.clone();
+                                let svc = hyper::service::service_fn(move |req| {
+                                    let fut = func(req);
+                                    async move { Ok::<_, Infallible>(fut.await) }
+                                });
+                                let builder = builder.clone();
+                                let events_tx = events_tx.clone();
+                                tokio::spawn(async move {
+                                    let _ = builder.serve_connection_with_upgrades(hyper_util::rt::TokioIo::new(io), svc).await;
+                                    let _ = events_tx.send(Event::ConnectionClosed);
+                                });
+                            }
+                        }
+                    }
+                    let _ = std::fs::remove_file(close_path);
+                    let _ = panic_tx.send(());
+                });
+            })
+            .expect("thread spawn");
+        Server {
+            path,
+            panic_rx,
+            events_rx,
+            shutdown_tx: Some(shutdown_tx),
+        }
+    })
+    .join()
+    .unwrap()
+}
+
+fn random_tmp_path() -> std::path::PathBuf {
+    use std::hash::BuildHasher;
+
+    let mut buf = std::env::temp_dir();
+
+    // libstd uses system random to create each one
+    let rng = std::collections::hash_map::RandomState::new();
+    let n = rng.hash_one("reqwest-uds-sock");
+
+    buf.push(format!("reqwest-test-uds-sock-{}", n));
+
+    buf
+}
