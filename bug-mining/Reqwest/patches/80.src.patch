diff --git a/Cargo.toml b/Cargo.toml
index a9e1882..38b698d 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -51,7 +51,7 @@ gzip = ["async-compression", "async-compression/gzip", "tokio-util"]
 
 brotli = ["async-compression", "async-compression/brotli", "tokio-util"]
 
-deflate = ["async-compression", "async-compression/zlib", "tokio-util"]
+deflate = ["async-compression", "async-compression/deflate", "tokio-util"]
 
 json = ["serde_json"]
 
diff --git a/src/async_impl/decoder.rs b/src/async_impl/decoder.rs
index c0542cf..2babbb6 100644
--- a/src/async_impl/decoder.rs
+++ b/src/async_impl/decoder.rs
@@ -10,7 +10,7 @@ use async_compression::tokio::bufread::GzipDecoder;
 use async_compression::tokio::bufread::BrotliDecoder;
 
 #[cfg(feature = "deflate")]
-use async_compression::tokio::bufread::ZlibDecoder;
+use async_compression::tokio::bufread::DeflateDecoder;
 
 use bytes::Bytes;
 use futures_core::Stream;
@@ -62,7 +62,7 @@ enum Inner {
 
     /// A `Deflate` decoder will uncompress the deflated response content before returning it.
     #[cfg(feature = "deflate")]
-    Deflate(Pin<Box<FramedRead<ZlibDecoder<PeekableIoStreamReader>, BytesCodec>>>),
+    Deflate(Pin<Box<FramedRead<DeflateDecoder<PeekableIoStreamReader>, BytesCodec>>>),
 
     /// A decoder that doesn't have a value yet.
     #[cfg(any(feature = "brotli", feature = "gzip", feature = "deflate"))]
@@ -324,7 +324,7 @@ impl Future for Pending {
             ))))),
             #[cfg(feature = "deflate")]
             DecoderType::Deflate => Poll::Ready(Ok(Inner::Deflate(Box::pin(FramedRead::new(
-                ZlibDecoder::new(StreamReader::new(_body)),
+                DeflateDecoder::new(StreamReader::new(_body)),
                 BytesCodec::new(),
             ))))),
         }
diff --git a/tests/deflate.rs b/tests/deflate.rs
index d5e17c2..11ed61d 100644
--- a/tests/deflate.rs
+++ b/tests/deflate.rs
@@ -92,7 +92,7 @@ async fn deflate_case(response_size: usize, chunk_size: usize) {
         .into_iter()
         .map(|i| format!("test {}", i))
         .collect();
-    let mut encoder = libflate::zlib::Encoder::new(Vec::new()).unwrap();
+    let mut encoder = libflate::deflate::Encoder::new(Vec::new());
     match encoder.write(content.as_bytes()) {
         Ok(n) => assert!(n > 0, "Failed to write to encoder."),
         _ => panic!("Failed to deflate encode string."),
