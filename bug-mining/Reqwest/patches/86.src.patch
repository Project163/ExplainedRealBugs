diff --git a/src/async_impl/body.rs b/src/async_impl/body.rs
index ff5446e..3ba9350 100644
--- a/src/async_impl/body.rs
+++ b/src/async_impl/body.rs
@@ -267,14 +267,17 @@ impl HttpBody for Body {
 
     fn size_hint(&self) -> http_body::SizeHint {
         match self.inner {
-            Inner::Reusable(ref bytes) => {
-                let mut hint = http_body::SizeHint::default();
-                hint.set_exact(bytes.len() as u64);
-                hint
-            }
+            Inner::Reusable(ref bytes) => http_body::SizeHint::with_exact(bytes.len() as u64),
             Inner::Streaming(ref body) => body.size_hint(),
         }
     }
+
+    fn is_end_stream(&self) -> bool {
+        match self.inner {
+            Inner::Reusable(ref bytes) => bytes.is_empty(),
+            Inner::Streaming(ref body) => body.is_end_stream(),
+        }
+    }
 }
 
 // ===== impl TotalTimeoutBody =====
@@ -352,6 +355,8 @@ where
 
 #[cfg(test)]
 mod tests {
+    use http_body::Body as _;
+
     use super::Body;
 
     #[test]
@@ -360,4 +365,19 @@ mod tests {
         let body = Body::from(&test_data[..]);
         assert_eq!(body.as_bytes(), Some(&test_data[..]));
     }
+
+    #[test]
+    fn body_exact_length() {
+        let empty_body = Body::empty();
+        assert!(empty_body.is_end_stream());
+        assert_eq!(empty_body.size_hint().exact(), Some(0));
+
+        let bytes_body = Body::reusable("abc".into());
+        assert!(!bytes_body.is_end_stream());
+        assert_eq!(bytes_body.size_hint().exact(), Some(3));
+
+        let stream_body = Body::streaming(bytes_body);
+        assert!(!stream_body.is_end_stream());
+        assert_eq!(stream_body.size_hint().exact(), None);
+    }
 }
diff --git a/tests/blocking.rs b/tests/blocking.rs
index c4ea04b..7d57db7 100644
--- a/tests/blocking.rs
+++ b/tests/blocking.rs
@@ -1,7 +1,6 @@
 mod support;
 
-#[cfg(feature = "json")]
-use http::header::CONTENT_TYPE;
+use http::header::{CONTENT_LENGTH, CONTENT_TYPE, TRANSFER_ENCODING};
 use http_body_util::BodyExt;
 #[cfg(feature = "json")]
 use std::collections::HashMap;
@@ -21,6 +20,29 @@ fn test_response_text() {
     assert_eq!(b"Hello", body.as_bytes());
 }
 
+#[test]
+fn donot_set_conent_length_0_if_have_no_body() {
+    let server = server::http(move |req| async move {
+        let headers = req.headers();
+        assert_eq!(headers.get(CONTENT_LENGTH), None);
+        assert!(headers.get(CONTENT_TYPE).is_none());
+        assert!(headers.get(TRANSFER_ENCODING).is_none());
+        dbg!(&headers);
+        http::Response::default()
+    });
+
+    let url = format!("http://{}/conent-length", server.addr());
+    let res = reqwest::blocking::Client::builder()
+        .no_proxy()
+        .build()
+        .expect("client builder")
+        .post(&url)
+        .send()
+        .expect("request");
+
+    assert_eq!(res.status(), reqwest::StatusCode::OK);
+}
+
 #[test]
 #[cfg(feature = "charset")]
 fn test_response_non_utf_8_text() {
diff --git a/tests/client.rs b/tests/client.rs
index 02f32fc..bc6002f 100644
--- a/tests/client.rs
+++ b/tests/client.rs
@@ -3,8 +3,7 @@ mod support;
 
 use support::server;
 
-#[cfg(feature = "json")]
-use http::header::CONTENT_TYPE;
+use http::header::{CONTENT_LENGTH, CONTENT_TYPE, TRANSFER_ENCODING};
 #[cfg(feature = "json")]
 use std::collections::HashMap;
 
@@ -54,6 +53,30 @@ async fn auto_headers() {
     assert_eq!(res.remote_addr(), Some(server.addr()));
 }
 
+#[tokio::test]
+async fn donot_set_conent_length_0_if_have_no_body() {
+    let server = server::http(move |req| async move {
+        let headers = req.headers();
+        assert_eq!(headers.get(CONTENT_LENGTH), None);
+        assert!(headers.get(CONTENT_TYPE).is_none());
+        assert!(headers.get(TRANSFER_ENCODING).is_none());
+        dbg!(&headers);
+        http::Response::default()
+    });
+
+    let url = format!("http://{}/conent-length", server.addr());
+    let res = reqwest::Client::builder()
+        .no_proxy()
+        .build()
+        .expect("client builder")
+        .get(&url)
+        .send()
+        .await
+        .expect("request");
+
+    assert_eq!(res.status(), reqwest::StatusCode::OK);
+}
+
 #[tokio::test]
 async fn user_agent() {
     let server = server::http(move |req| async move {
