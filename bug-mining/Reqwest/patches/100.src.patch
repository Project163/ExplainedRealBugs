diff --git a/Cargo.toml b/Cargo.toml
index c61a072..468657d 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -130,6 +130,7 @@ mime = "0.3.16"
 percent-encoding = "2.3"
 tokio = { version = "1.0", default-features = false, features = ["net", "time"] }
 tower = { version = "0.5.2", default-features = false, features = ["timeout", "util"] }
+tower-http = { version = "0.6.4", default-features = false, features = ["follow-redirect"] }
 pin-project-lite = "0.2.11"
 ipnet = "2.3"
 
diff --git a/src/async_impl/client.rs b/src/async_impl/client.rs
index e00cdbb..f631bf2 100644
--- a/src/async_impl/client.rs
+++ b/src/async_impl/client.rs
@@ -1,5 +1,7 @@
 #[cfg(any(feature = "native-tls", feature = "__rustls",))]
 use std::any::Any;
+#[cfg(feature = "http2")]
+use std::error::Error;
 use std::future::Future;
 use std::net::IpAddr;
 use std::pin::Pin;
@@ -16,7 +18,7 @@ use super::Body;
 #[cfg(feature = "http3")]
 use crate::async_impl::h3_client::connect::{H3ClientConfig, H3Connector};
 #[cfg(feature = "http3")]
-use crate::async_impl::h3_client::{H3Client, H3ResponseFuture};
+use crate::async_impl::h3_client::H3Client;
 use crate::config::{RequestConfig, RequestTimeout};
 use crate::connect::{
     sealed::{Conn, Unnameable},
@@ -30,7 +32,7 @@ use crate::dns::{gai::GaiResolver, DnsResolverWithOverrides, DynResolver, Resolv
 use crate::error::{self, BoxError};
 use crate::into_url::try_uri;
 use crate::proxy::Matcher as ProxyMatcher;
-use crate::redirect::{self, remove_sensitive_headers};
+use crate::redirect::{self, TowerRedirectPolicy};
 #[cfg(feature = "__rustls")]
 use crate::tls::CertificateRevocationList;
 #[cfg(feature = "__tls")]
@@ -39,17 +41,15 @@ use crate::tls::{self, TlsBackend};
 use crate::Certificate;
 #[cfg(any(feature = "native-tls", feature = "__rustls"))]
 use crate::Identity;
-use crate::{IntoUrl, Method, Proxy, StatusCode, Url};
+use crate::{IntoUrl, Method, Proxy, Url};
 
 use bytes::Bytes;
 use http::header::{
-    Entry, HeaderMap, HeaderValue, ACCEPT, ACCEPT_ENCODING, CONTENT_ENCODING, CONTENT_LENGTH,
-    CONTENT_TYPE, LOCATION, PROXY_AUTHORIZATION, RANGE, REFERER, TRANSFER_ENCODING, USER_AGENT,
+    Entry, HeaderMap, HeaderValue, ACCEPT, ACCEPT_ENCODING, PROXY_AUTHORIZATION, RANGE, USER_AGENT,
 };
 use http::uri::Scheme;
 use http::Uri;
 use hyper_util::client::legacy::connect::HttpConnector;
-use log::debug;
 #[cfg(feature = "default-tls")]
 use native_tls_crate::TlsConnector;
 use pin_project_lite::pin_project;
@@ -60,8 +60,7 @@ use quinn::VarInt;
 use tokio::time::Sleep;
 use tower::util::BoxCloneSyncServiceLayer;
 use tower::{Layer, Service};
-
-type HyperResponseFuture = hyper_util::client::legacy::ResponseFuture;
+use tower_http::follow_redirect::FollowRedirect;
 
 /// An asynchronous `Client` to make Requests with.
 ///
@@ -96,6 +95,61 @@ enum HttpVersionPref {
     All,
 }
 
+#[derive(Clone)]
+struct HyperService {
+    #[cfg(feature = "cookies")]
+    cookie_store: Option<Arc<dyn cookie::CookieStore>>,
+    hyper: HyperClient,
+}
+
+impl Service<hyper::Request<crate::async_impl::body::Body>> for HyperService {
+    type Error = crate::Error;
+    type Response = http::Response<hyper::body::Incoming>;
+    type Future = Pin<Box<dyn Future<Output = Result<Self::Response, Self::Error>> + Send + Sync>>;
+
+    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
+        self.hyper.poll_ready(cx).map_err(crate::error::request)
+    }
+
+    #[cfg(not(feature = "cookies"))]
+    fn call(&mut self, req: hyper::Request<crate::async_impl::body::Body>) -> Self::Future {
+        let clone = self.hyper.clone();
+        let mut inner = std::mem::replace(&mut self.hyper, clone);
+        Box::pin(async move { inner.call(req).await.map_err(crate::error::request) })
+    }
+
+    #[cfg(feature = "cookies")]
+    fn call(&mut self, mut req: hyper::Request<crate::async_impl::body::Body>) -> Self::Future {
+        let clone = self.hyper.clone();
+        let mut inner = std::mem::replace(&mut self.hyper, clone);
+        let url = Url::parse(req.uri().to_string().as_str()).expect("invalid URL");
+
+        if let Some(cookie_store) = self.cookie_store.as_ref() {
+            if req.headers().get(crate::header::COOKIE).is_none() {
+                let headers = req.headers_mut();
+                crate::util::add_cookie_header(headers, &**cookie_store, &url);
+            }
+        }
+
+        let cookie_store = self.cookie_store.clone();
+        Box::pin(async move {
+            let res = inner.call(req).await.map_err(crate::error::request);
+
+            if let Some(ref cookie_store) = cookie_store {
+                if let Ok(res) = &res {
+                    let mut cookies =
+                        cookie::extract_response_cookie_headers(res.headers()).peekable();
+                    if cookies.peek().is_some() {
+                        cookie_store.set_cookies(&mut cookies, &url);
+                    }
+                }
+            }
+
+            res
+        })
+    }
+}
+
 struct Config {
     // NOTE: When adding a new field, update `fmt::Debug for ClientBuilder`
     accepts: Accepts,
@@ -902,29 +956,59 @@ impl ClientBuilder {
 
         let proxies_maybe_http_auth = proxies.iter().any(|p| p.maybe_has_http_auth());
 
+        let redirect_policy_desc = if config.redirect_policy.is_default() {
+            None
+        } else {
+            Some(format!("{:?}", &config.redirect_policy))
+        };
+
+        let hyper_client = builder.build(connector_builder.build(config.connector_layers));
+        let hyper_service = HyperService {
+            #[cfg(feature = "cookies")]
+            cookie_store: config.cookie_store.clone(),
+            hyper: hyper_client,
+        };
+
+        let policy = {
+            let mut p = TowerRedirectPolicy::new(config.redirect_policy);
+            p.with_referer(config.referer)
+                .with_https_only(config.https_only);
+            p
+        };
+
+        let hyper = FollowRedirect::with_policy(hyper_service, policy.clone());
+
         Ok(Client {
             inner: Arc::new(ClientRef {
                 accepts: config.accepts,
                 #[cfg(feature = "cookies")]
-                cookie_store: config.cookie_store,
+                cookie_store: config.cookie_store.clone(),
                 // Use match instead of map since config is partially moved,
                 // and it cannot be used in closure
                 #[cfg(feature = "http3")]
                 h3_client: match h3_connector {
                     Some(h3_connector) => {
-                        Some(H3Client::new(h3_connector, config.pool_idle_timeout))
+                        #[cfg(not(feature = "cookies"))]
+                        let h3_service = H3Client::new(h3_connector, config.pool_idle_timeout);
+                        #[cfg(feature = "cookies")]
+                        let h3_service = H3Client::new(
+                            h3_connector,
+                            config.pool_idle_timeout,
+                            config.cookie_store,
+                        );
+                        Some(FollowRedirect::with_policy(h3_service, policy))
                     }
                     None => None,
                 },
-                hyper: builder.build(connector_builder.build(config.connector_layers)),
                 headers: config.headers,
-                redirect_policy: config.redirect_policy,
                 referer: config.referer,
                 read_timeout: config.read_timeout,
                 request_timeout: RequestConfig::new(config.timeout),
+                hyper,
                 proxies,
                 proxies_maybe_http_auth,
                 https_only: config.https_only,
+                redirect_policy_desc,
             }),
         })
     }
@@ -2343,16 +2427,6 @@ impl Client {
             }
         }
 
-        // Add cookies from the cookie store.
-        #[cfg(feature = "cookies")]
-        {
-            if let Some(cookie_store) = self.inner.cookie_store.as_ref() {
-                if headers.get(crate::header::COOKIE).is_none() {
-                    add_cookie_header(&mut headers, &**cookie_store, &url);
-                }
-            }
-        }
-
         let accept_encoding = self.inner.accepts.as_str();
 
         if let Some(accept_encoding) = accept_encoding {
@@ -2386,12 +2460,14 @@ impl Client {
             http::Version::HTTP_3 if self.inner.h3_client.is_some() => {
                 let mut req = builder.body(body).expect("valid request parts");
                 *req.headers_mut() = headers.clone();
-                ResponseFuture::H3(self.inner.h3_client.as_ref().unwrap().request(req))
+                let mut h3 = self.inner.h3_client.as_ref().unwrap().clone();
+                ResponseFuture::H3(h3.call(req))
             }
             _ => {
                 let mut req = builder.body(body).expect("valid request parts");
                 *req.headers_mut() = headers.clone();
-                ResponseFuture::Default(self.inner.hyper.request(req))
+                let mut hyper = self.inner.hyper.clone();
+                ResponseFuture::Default(hyper.call(req))
             }
         };
 
@@ -2416,8 +2492,6 @@ impl Client {
                 headers,
                 body: reusable,
 
-                urls: Vec::new(),
-
                 retry_count: 0,
 
                 client: self.inner.clone(),
@@ -2634,16 +2708,16 @@ struct ClientRef {
     #[cfg(feature = "cookies")]
     cookie_store: Option<Arc<dyn cookie::CookieStore>>,
     headers: HeaderMap,
-    hyper: HyperClient,
+    hyper: FollowRedirect<HyperService, TowerRedirectPolicy>,
     #[cfg(feature = "http3")]
-    h3_client: Option<H3Client>,
-    redirect_policy: redirect::Policy,
+    h3_client: Option<FollowRedirect<H3Client, TowerRedirectPolicy>>,
     referer: bool,
     request_timeout: RequestConfig<RequestTimeout>,
     read_timeout: Option<Duration>,
     proxies: Arc<Vec<ProxyMatcher>>,
     proxies_maybe_http_auth: bool,
     https_only: bool,
+    redirect_policy_desc: Option<String>,
 }
 
 impl ClientRef {
@@ -2664,8 +2738,8 @@ impl ClientRef {
             f.field("proxies", &self.proxies);
         }
 
-        if !self.redirect_policy.is_default() {
-            f.field("redirect_policy", &self.redirect_policy);
+        if let Some(s) = &self.redirect_policy_desc {
+            f.field("redirect_policy", s);
         }
 
         if self.referer {
@@ -2701,8 +2775,6 @@ pin_project! {
         headers: HeaderMap,
         body: Option<Option<Bytes>>,
 
-        urls: Vec<Url>,
-
         retry_count: usize,
 
         client: Arc<ClientRef>,
@@ -2718,9 +2790,9 @@ pin_project! {
 }
 
 enum ResponseFuture {
-    Default(HyperResponseFuture),
+    Default(tower_http::follow_redirect::ResponseFuture<HyperService, Body, TowerRedirectPolicy>),
     #[cfg(feature = "http3")]
-    H3(H3ResponseFuture),
+    H3(tower_http::follow_redirect::ResponseFuture<H3Client, Body, TowerRedirectPolicy>),
 }
 
 impl PendingRequest {
@@ -2736,14 +2808,6 @@ impl PendingRequest {
         self.project().read_timeout_fut
     }
 
-    fn urls(self: Pin<&mut Self>) -> &mut Vec<Url> {
-        self.project().urls
-    }
-
-    fn headers(self: Pin<&mut Self>) -> &mut HeaderMap {
-        self.project().headers
-    }
-
     #[cfg(any(feature = "http2", feature = "http3"))]
     fn retry_error(mut self: Pin<&mut Self>, err: &(dyn std::error::Error + 'static)) -> bool {
         use log::trace;
@@ -2757,7 +2821,7 @@ impl PendingRequest {
         let body = match self.body {
             Some(Some(ref body)) => Body::reusable(body.clone()),
             Some(None) => {
-                debug!("error was retryable, but body not reusable");
+                log::debug!("error was retryable, but body not reusable");
                 return false;
             }
             None => Body::empty(),
@@ -2781,13 +2845,13 @@ impl PendingRequest {
                     .body(body)
                     .expect("valid request parts");
                 *req.headers_mut() = self.headers.clone();
-                ResponseFuture::H3(
-                    self.client
-                        .h3_client
-                        .as_ref()
-                        .expect("H3 client must exists, otherwise we can't have a h3 request here")
-                        .request(req),
-                )
+                let mut h3 = self
+                    .client
+                    .h3_client
+                    .as_ref()
+                    .expect("H3 client must exists, otherwise we can't have a h3 request here")
+                    .clone();
+                ResponseFuture::H3(h3.call(req))
             }
             _ => {
                 let mut req = hyper::Request::builder()
@@ -2796,7 +2860,8 @@ impl PendingRequest {
                     .body(body)
                     .expect("valid request parts");
                 *req.headers_mut() = self.headers.clone();
-                ResponseFuture::Default(self.client.hyper.request(req))
+                let mut hyper = self.client.hyper.clone();
+                ResponseFuture::Default(hyper.call(req))
             }
         };
 
@@ -2816,7 +2881,7 @@ fn is_retryable_error(err: &(dyn std::error::Error + 'static)) -> bool {
     #[cfg(feature = "http3")]
     if let Some(cause) = err.source() {
         if let Some(err) = cause.downcast_ref::<h3::error::ConnectionError>() {
-            debug!("determining if HTTP/3 error {err} can be retried");
+            log::debug!("determining if HTTP/3 error {err} can be retried");
             // TODO: Does h3 provide an API for checking the error?
             return err.to_string().as_str() == "timeout";
         }
@@ -2892,12 +2957,15 @@ impl Future for PendingRequest {
                 ResponseFuture::Default(r) => match Pin::new(r).poll(cx) {
                     Poll::Ready(Err(e)) => {
                         #[cfg(feature = "http2")]
-                        if self.as_mut().retry_error(&e) {
-                            continue;
+                        if e.is_request() {
+                            if let Some(e) = e.source() {
+                                if self.as_mut().retry_error(e) {
+                                    continue;
+                                }
+                            }
                         }
-                        return Poll::Ready(Err(
-                            crate::error::request(e).with_url(self.url.clone())
-                        ));
+
+                        return Poll::Ready(Err(e));
                     }
                     Poll::Ready(Ok(res)) => res.map(super::body::boxed),
                     Poll::Pending => return Poll::Pending,
@@ -2921,151 +2989,21 @@ impl Future for PendingRequest {
             {
                 if let Some(ref cookie_store) = self.client.cookie_store {
                     let mut cookies =
-                        cookie::extract_response_cookie_headers(&res.headers()).peekable();
+                        cookie::extract_response_cookie_headers(res.headers()).peekable();
                     if cookies.peek().is_some() {
                         cookie_store.set_cookies(&mut cookies, &self.url);
                     }
                 }
             }
-            let should_redirect = match res.status() {
-                StatusCode::MOVED_PERMANENTLY | StatusCode::FOUND | StatusCode::SEE_OTHER => {
-                    self.body = None;
-                    for header in &[
-                        TRANSFER_ENCODING,
-                        CONTENT_ENCODING,
-                        CONTENT_TYPE,
-                        CONTENT_LENGTH,
-                    ] {
-                        self.headers.remove(header);
-                    }
-
-                    match self.method {
-                        Method::GET | Method::HEAD => {}
-                        _ => {
-                            self.method = Method::GET;
-                        }
-                    }
-                    true
-                }
-                StatusCode::TEMPORARY_REDIRECT | StatusCode::PERMANENT_REDIRECT => {
-                    match self.body {
-                        Some(Some(_)) | None => true,
-                        Some(None) => false,
-                    }
+            if let Some(url) = &res
+                .extensions()
+                .get::<tower_http::follow_redirect::RequestUri>()
+            {
+                self.url = match Url::parse(&url.0.to_string()) {
+                    Ok(url) => url,
+                    Err(e) => return Poll::Ready(Err(crate::error::decode(e))),
                 }
-                _ => false,
             };
-            if should_redirect {
-                let loc = res.headers().get(LOCATION).and_then(|val| {
-                    let loc = (|| -> Option<Url> {
-                        // Some sites may send a UTF-8 Location header,
-                        // even though we're supposed to treat those bytes
-                        // as opaque, we'll check specifically for utf8.
-                        self.url.join(str::from_utf8(val.as_bytes()).ok()?).ok()
-                    })();
-
-                    // Check that the `url` is also a valid `http::Uri`.
-                    //
-                    // If not, just log it and skip the redirect.
-                    let loc = loc.and_then(|url| {
-                        if try_uri(&url).is_ok() {
-                            Some(url)
-                        } else {
-                            None
-                        }
-                    });
-
-                    if loc.is_none() {
-                        debug!("Location header had invalid URI: {val:?}");
-                    }
-                    loc
-                });
-                if let Some(loc) = loc {
-                    if self.client.referer {
-                        if let Some(referer) = make_referer(&loc, &self.url) {
-                            self.headers.insert(REFERER, referer);
-                        }
-                    }
-                    let url = self.url.clone();
-                    self.as_mut().urls().push(url);
-                    let action = self
-                        .client
-                        .redirect_policy
-                        .check(res.status(), &loc, &self.urls);
-
-                    match action {
-                        redirect::ActionKind::Follow => {
-                            debug!("redirecting '{}' to '{}'", self.url, loc);
-
-                            if loc.scheme() != "http" && loc.scheme() != "https" {
-                                return Poll::Ready(Err(error::url_bad_scheme(loc)));
-                            }
-
-                            if self.client.https_only && loc.scheme() != "https" {
-                                return Poll::Ready(Err(error::redirect(
-                                    error::url_bad_scheme(loc.clone()),
-                                    loc,
-                                )));
-                            }
-
-                            self.url = loc;
-                            let mut headers =
-                                std::mem::replace(self.as_mut().headers(), HeaderMap::new());
-
-                            remove_sensitive_headers(&mut headers, &self.url, &self.urls);
-                            let uri = try_uri(&self.url)?;
-                            let body = match self.body {
-                                Some(Some(ref body)) => Body::reusable(body.clone()),
-                                _ => Body::empty(),
-                            };
-
-                            // Add cookies from the cookie store.
-                            #[cfg(feature = "cookies")]
-                            {
-                                if let Some(ref cookie_store) = self.client.cookie_store {
-                                    add_cookie_header(&mut headers, &**cookie_store, &self.url);
-                                }
-                            }
-
-                            *self.as_mut().in_flight().get_mut() =
-                                match *self.as_mut().in_flight().as_ref() {
-                                    #[cfg(feature = "http3")]
-                                    ResponseFuture::H3(_) => {
-                                        let mut req = hyper::Request::builder()
-                                            .method(self.method.clone())
-                                            .uri(uri.clone())
-                                            .body(body)
-                                            .expect("valid request parts");
-                                        *req.headers_mut() = headers.clone();
-                                        std::mem::swap(self.as_mut().headers(), &mut headers);
-                                        ResponseFuture::H3(self.client.h3_client
-                        .as_ref()
-                        .expect("H3 client must exists, otherwise we can't have a h3 request here")
-                                            .request(req))
-                                    }
-                                    _ => {
-                                        let mut req = hyper::Request::builder()
-                                            .method(self.method.clone())
-                                            .uri(uri.clone())
-                                            .body(body)
-                                            .expect("valid request parts");
-                                        *req.headers_mut() = headers.clone();
-                                        std::mem::swap(self.as_mut().headers(), &mut headers);
-                                        ResponseFuture::Default(self.client.hyper.request(req))
-                                    }
-                                };
-
-                            continue;
-                        }
-                        redirect::ActionKind::Stop => {
-                            debug!("redirect policy disallowed redirection to '{loc}'");
-                        }
-                        redirect::ActionKind::Error(err) => {
-                            return Poll::Ready(Err(crate::error::redirect(err, self.url.clone())));
-                        }
-                    }
-                }
-            }
 
             let res = Response::new(
                 res,
@@ -3092,25 +3030,6 @@ impl fmt::Debug for Pending {
     }
 }
 
-fn make_referer(next: &Url, previous: &Url) -> Option<HeaderValue> {
-    if next.scheme() == "http" && previous.scheme() == "https" {
-        return None;
-    }
-
-    let mut referer = previous.clone();
-    let _ = referer.set_username("");
-    let _ = referer.set_password(None);
-    referer.set_fragment(None);
-    referer.as_str().parse().ok()
-}
-
-#[cfg(feature = "cookies")]
-fn add_cookie_header(headers: &mut HeaderMap, cookie_store: &dyn cookie::CookieStore, url: &Url) {
-    if let Some(header) = cookie_store.cookies(url) {
-        headers.insert(crate::header::COOKIE, header);
-    }
-}
-
 #[cfg(test)]
 mod tests {
     #![cfg(not(feature = "rustls-tls-manual-roots-no-provider"))]
diff --git a/src/async_impl/h3_client/mod.rs b/src/async_impl/h3_client/mod.rs
index a4040f1..77367f1 100644
--- a/src/async_impl/h3_client/mod.rs
+++ b/src/async_impl/h3_client/mod.rs
@@ -6,6 +6,8 @@ mod pool;
 
 use crate::async_impl::body::ResponseBody;
 use crate::async_impl::h3_client::pool::{Key, Pool, PoolClient};
+#[cfg(feature = "cookies")]
+use crate::cookie;
 use crate::error::{BoxError, Error, Kind};
 use crate::{error, Body};
 use connect::H3Connector;
@@ -13,17 +15,23 @@ use http::{Request, Response};
 use log::trace;
 use std::future::{self, Future};
 use std::pin::Pin;
+#[cfg(feature = "cookies")]
+use std::sync::Arc;
 use std::task::{Context, Poll};
 use std::time::Duration;
 use sync_wrapper::SyncWrapper;
+use tower::Service;
 
 #[derive(Clone)]
 pub(crate) struct H3Client {
     pool: Pool,
     connector: H3Connector,
+    #[cfg(feature = "cookies")]
+    cookie_store: Option<Arc<dyn cookie::CookieStore>>,
 }
 
 impl H3Client {
+    #[cfg(not(feature = "cookies"))]
     pub fn new(connector: H3Connector, pool_timeout: Option<Duration>) -> Self {
         H3Client {
             pool: Pool::new(pool_timeout),
@@ -31,6 +39,19 @@ impl H3Client {
         }
     }
 
+    #[cfg(feature = "cookies")]
+    pub fn new(
+        connector: H3Connector,
+        pool_timeout: Option<Duration>,
+        cookie_store: Option<Arc<dyn cookie::CookieStore>>,
+    ) -> Self {
+        H3Client {
+            pool: Pool::new(pool_timeout),
+            connector,
+            cookie_store,
+        }
+    }
+
     async fn get_pooled_client(&mut self, key: Key) -> Result<PoolClient, BoxError> {
         if let Some(client) = self.pool.try_pool(&key) {
             trace!("getting client from pool with key {key:?}");
@@ -58,6 +79,7 @@ impl H3Client {
         Ok(self.pool.new_connection(lock, driver, tx))
     }
 
+    #[cfg(not(feature = "cookies"))]
     async fn send_request(
         mut self,
         key: Key,
@@ -73,6 +95,42 @@ impl H3Client {
             .map_err(|e| Error::new(Kind::Request, Some(e)))
     }
 
+    #[cfg(feature = "cookies")]
+    async fn send_request(
+        mut self,
+        key: Key,
+        mut req: Request<Body>,
+    ) -> Result<Response<ResponseBody>, Error> {
+        let mut pooled = match self.get_pooled_client(key).await {
+            Ok(client) => client,
+            Err(e) => return Err(error::request(e)),
+        };
+
+        let url = url::Url::parse(req.uri().to_string().as_str()).unwrap();
+        if let Some(cookie_store) = self.cookie_store.as_ref() {
+            if req.headers().get(crate::header::COOKIE).is_none() {
+                let headers = req.headers_mut();
+                crate::util::add_cookie_header(headers, &**cookie_store, &url);
+            }
+        }
+
+        let res = pooled
+            .send_request(req)
+            .await
+            .map_err(|e| Error::new(Kind::Request, Some(e)));
+
+        if let Some(ref cookie_store) = self.cookie_store {
+            if let Ok(res) = &res {
+                let mut cookies = cookie::extract_response_cookie_headers(res.headers()).peekable();
+                if cookies.peek().is_some() {
+                    cookie_store.set_cookies(&mut cookies, &url);
+                }
+            }
+        }
+
+        res
+    }
+
     pub fn request(&self, mut req: Request<Body>) -> H3ResponseFuture {
         let pool_key = match pool::extract_domain(req.uri_mut()) {
             Ok(s) => s,
@@ -88,6 +146,20 @@ impl H3Client {
     }
 }
 
+impl Service<Request<Body>> for H3Client {
+    type Response = Response<ResponseBody>;
+    type Error = Error;
+    type Future = H3ResponseFuture;
+
+    fn poll_ready(&mut self, _cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
+        Poll::Ready(Ok(()))
+    }
+
+    fn call(&mut self, req: Request<Body>) -> Self::Future {
+        self.request(req)
+    }
+}
+
 pub(crate) struct H3ResponseFuture {
     inner: SyncWrapper<Pin<Box<dyn Future<Output = Result<Response<ResponseBody>, Error>> + Send>>>,
 }
diff --git a/src/redirect.rs b/src/redirect.rs
index 6e3ce55..f22ab8b 100644
--- a/src/redirect.rs
+++ b/src/redirect.rs
@@ -4,13 +4,17 @@
 //! maximum redirect chain of 10 hops. To customize this behavior, a
 //! `redirect::Policy` can be used with a `ClientBuilder`.
 
-use std::error::Error as StdError;
 use std::fmt;
+use std::{error::Error as StdError, sync::Arc};
 
-use crate::header::{HeaderMap, AUTHORIZATION, COOKIE, PROXY_AUTHORIZATION, WWW_AUTHENTICATE};
+use crate::header::{AUTHORIZATION, COOKIE, PROXY_AUTHORIZATION, REFERER, WWW_AUTHENTICATE};
+use http::{HeaderMap, HeaderValue};
 use hyper::StatusCode;
 
-use crate::Url;
+use crate::{async_impl, Url};
+use tower_http::follow_redirect::policy::{
+    Action as TowerAction, Attempt as TowerAttempt, Policy as TowerPolicy,
+};
 
 /// A type that controls the policy on how to handle the following of redirects.
 ///
@@ -257,6 +261,96 @@ impl fmt::Display for TooManyRedirects {
 
 impl StdError for TooManyRedirects {}
 
+#[derive(Clone)]
+pub(crate) struct TowerRedirectPolicy {
+    policy: Arc<Policy>,
+    referer: bool,
+    urls: Vec<Url>,
+    https_only: bool,
+}
+
+impl TowerRedirectPolicy {
+    pub(crate) fn new(policy: Policy) -> Self {
+        Self {
+            policy: Arc::new(policy),
+            referer: false,
+            urls: Vec::new(),
+            https_only: false,
+        }
+    }
+
+    pub(crate) fn with_referer(&mut self, referer: bool) -> &mut Self {
+        self.referer = referer;
+        self
+    }
+
+    pub(crate) fn with_https_only(&mut self, https_only: bool) -> &mut Self {
+        self.https_only = https_only;
+        self
+    }
+}
+
+fn make_referer(next: &Url, previous: &Url) -> Option<HeaderValue> {
+    if next.scheme() == "http" && previous.scheme() == "https" {
+        return None;
+    }
+
+    let mut referer = previous.clone();
+    let _ = referer.set_username("");
+    let _ = referer.set_password(None);
+    referer.set_fragment(None);
+    referer.as_str().parse().ok()
+}
+
+impl TowerPolicy<async_impl::body::Body, crate::Error> for TowerRedirectPolicy {
+    fn redirect(&mut self, attempt: &TowerAttempt<'_>) -> Result<TowerAction, crate::Error> {
+        let previous_url =
+            Url::parse(&attempt.previous().to_string()).expect("Previous URL must be valid");
+
+        let next_url = match Url::parse(&attempt.location().to_string()) {
+            Ok(url) => url,
+            Err(e) => return Err(crate::error::builder(e)),
+        };
+
+        if next_url.scheme() != "http" && next_url.scheme() != "https" {
+            return Err(crate::error::url_bad_scheme(next_url));
+        }
+
+        if self.https_only && next_url.scheme() != "https" {
+            return Err(crate::error::redirect(
+                crate::error::url_bad_scheme(next_url.clone()),
+                next_url,
+            ));
+        }
+
+        self.urls.push(previous_url.clone());
+
+        match self.policy.check(attempt.status(), &next_url, &self.urls) {
+            ActionKind::Follow => Ok(TowerAction::Follow),
+            ActionKind::Stop => Ok(TowerAction::Stop),
+            ActionKind::Error(e) => Err(crate::error::redirect(e, previous_url)),
+        }
+    }
+
+    fn on_request(&mut self, req: &mut http::Request<async_impl::body::Body>) {
+        if let Ok(next_url) = Url::parse(&req.uri().to_string()) {
+            remove_sensitive_headers(req.headers_mut(), &next_url, &self.urls);
+            if self.referer {
+                if let Some(previous_url) = self.urls.last() {
+                    if let Some(v) = make_referer(&next_url, previous_url) {
+                        req.headers_mut().insert(REFERER, v);
+                    }
+                }
+            }
+        };
+    }
+
+    // This is must implemented to make 307 and 308 redirects work
+    fn clone_body(&self, body: &async_impl::body::Body) -> Option<async_impl::body::Body> {
+        body.try_clone()
+    }
+}
+
 #[test]
 fn test_redirect_policy_limit() {
     let policy = Policy::default();
diff --git a/src/util.rs b/src/util.rs
index 88a5200..982d3a2 100644
--- a/src/util.rs
+++ b/src/util.rs
@@ -87,3 +87,14 @@ pub(crate) fn replace_headers(dst: &mut HeaderMap, src: HeaderMap) {
         }
     }
 }
+
+#[cfg(feature = "cookies")]
+pub(crate) fn add_cookie_header(
+    headers: &mut HeaderMap,
+    cookie_store: &dyn crate::cookie::CookieStore,
+    url: &url::Url,
+) {
+    if let Some(header) = cookie_store.cookies(url) {
+        headers.insert(crate::header::COOKIE, header);
+    }
+}
diff --git a/tests/redirect.rs b/tests/redirect.rs
index 9634dc3..a6a529b 100644
--- a/tests/redirect.rs
+++ b/tests/redirect.rs
@@ -410,3 +410,35 @@ async fn test_redirect_limit_to_1() {
     );
     assert!(res.is_redirect());
 }
+
+#[tokio::test]
+async fn test_redirect_custom() {
+    let server = server::http(move |req| async move {
+        assert!(req.uri().path().ends_with("/foo"));
+        http::Response::builder()
+            .status(302)
+            .header("location", "/should_not_be_called")
+            .body(Body::default())
+            .unwrap()
+    });
+
+    let url = format!("http://{}/foo", server.addr());
+
+    let res = reqwest::Client::builder()
+        .redirect(reqwest::redirect::Policy::custom(|attempt| {
+            if attempt.url().path().ends_with("/should_not_be_called") {
+                attempt.stop()
+            } else {
+                attempt.follow()
+            }
+        }))
+        .build()
+        .unwrap()
+        .get(&url)
+        .send()
+        .await
+        .unwrap();
+
+    assert_eq!(res.url().as_str(), url);
+    assert_eq!(res.status(), reqwest::StatusCode::FOUND);
+}
