diff --git a/docs/src/main/asciidoc/qute-reference.adoc b/docs/src/main/asciidoc/qute-reference.adoc
index f9a9049afea..65a794f5f5f 100644
--- a/docs/src/main/asciidoc/qute-reference.adoc
+++ b/docs/src/main/asciidoc/qute-reference.adoc
@@ -1127,6 +1127,15 @@ This section can be used to include another template and possibly override some
 <1> Include a template with id `foo`. The included template can reference data from the current context.
 <2> It's also possible to define optional parameters that can be used in the included template.
 
+By default, the first unnamed parameter represents the id of a template that should be included.
+And it is taken as is.
+For example, `{#include bar/foo /}` includes a template with id `bar/foo`; i.e. `src/main/resources/templates/bar/foo.html` could be matched.
+However, it is also possible to supply the template id dynamically.
+Just add the `_id` parameter to the tag.
+In this case, the argument value of the `_id` parameter represents an expression that is resolved and the result represents the template id.
+For example, `{#include _id=bar.foo /}` means that `bar.foo` is first resolved and then the resulting template id is used.
+
+
 _Template inheritance_ makes it possible to reuse template layouts.
 
 .Template "base"
diff --git a/independent-projects/qute/core/src/main/java/io/quarkus/qute/IncludeSectionHelper.java b/independent-projects/qute/core/src/main/java/io/quarkus/qute/IncludeSectionHelper.java
index 67e47dfd254..8619e06d941 100644
--- a/independent-projects/qute/core/src/main/java/io/quarkus/qute/IncludeSectionHelper.java
+++ b/independent-projects/qute/core/src/main/java/io/quarkus/qute/IncludeSectionHelper.java
@@ -1,6 +1,5 @@
 package io.quarkus.qute;
 
-import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -11,7 +10,9 @@
 import java.util.function.Supplier;
 import java.util.regex.Pattern;
 
+import io.quarkus.qute.SectionHelperFactory.SectionInitContext;
 import io.quarkus.qute.Template.Fragment;
+import io.quarkus.qute.TemplateNode.Origin;
 
 public class IncludeSectionHelper implements SectionHelper {
 
@@ -19,14 +20,14 @@ public class IncludeSectionHelper implements SectionHelper {
     private static final String TEMPLATE = "template";
     private static final Map<String, Object> FRAGMENT_PARAMS = Map.of(Template.Fragment.ATTRIBUTE, true);
 
-    protected final Supplier<Template> template;
+    protected final TemplateSupplier templateSupplier;
     protected final Map<String, SectionBlock> extendingBlocks;
     protected final Map<String, Expression> parameters;
     protected final boolean isIsolated;
 
-    public IncludeSectionHelper(Supplier<Template> templateSupplier, Map<String, SectionBlock> extendingBlocks,
+    IncludeSectionHelper(TemplateSupplier templateSupplier, Map<String, SectionBlock> extendingBlocks,
             Map<String, Expression> parameters, boolean isIsolated) {
-        this.template = templateSupplier;
+        this.templateSupplier = templateSupplier;
         this.extendingBlocks = extendingBlocks;
         this.parameters = parameters;
         this.isIsolated = isIsolated;
@@ -36,8 +37,8 @@ public IncludeSectionHelper(Supplier<Template> templateSupplier, Map<String, Sec
     public CompletionStage<ResultNode> resolve(SectionResolutionContext context) {
         if (parameters.isEmpty() && optimizeIfNoParams()) {
             // No params
-            Template t = template.get();
-            SectionNode root = t.getRootNode();
+            Template template = templateSupplier.get(Map.of());
+            SectionNode root = template.getRootNode();
             ResolutionContext resolutionContext;
             if (isIsolated) {
                 resolutionContext = context.newResolutionContext(null, extendingBlocks);
@@ -47,7 +48,7 @@ public CompletionStage<ResultNode> resolve(SectionResolutionContext context) {
             } else {
                 resolutionContext = context.resolutionContext().createChild(null, extendingBlocks);
             }
-            return root.resolve(resolutionContext, t.isFragment() ? FRAGMENT_PARAMS : null);
+            return root.resolve(resolutionContext, template.isFragment() ? FRAGMENT_PARAMS : null);
         } else {
             CompletableFuture<ResultNode> result = new CompletableFuture<>();
             context.evaluate(parameters).whenComplete((evaluatedParams, t1) -> {
@@ -57,17 +58,18 @@ public CompletionStage<ResultNode> resolve(SectionResolutionContext context) {
                     addAdditionalEvaluatedParams(context, evaluatedParams);
                     try {
                         ResolutionContext resolutionContext;
-                        // Execute the template with the params as the root context object
                         Object data = Mapper.wrap(evaluatedParams);
                         if (isIsolated) {
                             resolutionContext = context.newResolutionContext(data, extendingBlocks);
                         } else {
                             resolutionContext = context.resolutionContext().createChild(data, extendingBlocks);
                         }
-                        Template t = template.get();
-                        SectionNode root = ((TemplateImpl) t).root;
+
+                        Template template = templateSupplier.get(evaluatedParams);
+                        SectionNode root = template.getRootNode();
+
                         // Execute the template with the params as the root context object
-                        root.resolve(resolutionContext, t.isFragment() ? FRAGMENT_PARAMS : null)
+                        root.resolve(resolutionContext, template.isFragment() ? FRAGMENT_PARAMS : null)
                                 .whenComplete((resultNode, t2) -> {
                                     if (t2 != null) {
                                         result.completeExceptionally(t2);
@@ -102,6 +104,8 @@ protected void addAdditionalEvaluatedParams(SectionResolutionContext context, Ma
 
     public static class Factory extends AbstractIncludeFactory<IncludeSectionHelper> {
 
+        static final String DYNAMIC_ID = "_id";
+
         @Override
         public List<String> getDefaultAliases() {
             return ImmutableList.of("include");
@@ -109,7 +113,15 @@ public List<String> getDefaultAliases() {
 
         @Override
         public ParametersInfo getParameters() {
-            ParametersInfo.Builder builder = ParametersInfo.builder().addParameter(TEMPLATE);
+            ParametersInfo.Builder builder = ParametersInfo.builder()
+                    .addParameter(Parameter.builder(TEMPLATE)
+                            .optional()
+                            .valuePredicate(this::skipBuiltInParam)
+                            .build())
+                    .addParameter(Parameter.builder(DYNAMIC_ID)
+                            .optional()
+                            .valuePredicate(this::skipBuiltInParam)
+                            .build());
             addDefaultParams(builder);
             return builder.build();
         }
@@ -120,7 +132,8 @@ public MissingEndTagStrategy missingEndTagStrategy() {
         }
 
         @Override
-        protected boolean ignoreParameterInit(Supplier<String> firstParamSupplier, String key, String value) {
+        protected boolean ignoreParameterInit(Map<String, String> params, Supplier<String> firstParamValue, String key,
+                String value) {
             return key.equals(TEMPLATE)
                     // {#include foo _isolated=true /}
                     || key.equals(ISOLATED)
@@ -136,7 +149,13 @@ protected boolean ignoreParameterInit(Supplier<String> firstParamSupplier, Strin
 
         @Override
         protected String getTemplateId(SectionInitContext context) {
+            if (context.getParameters().containsKey(DYNAMIC_ID)) {
+                return null;
+            }
             String templateParam = context.getParameter(TEMPLATE);
+            if (templateParam == null) {
+                throw context.error("Neither the template id nor the template name was specified").build();
+            }
             if (LiteralSupport.isStringLiteralSeparator(templateParam.charAt(0))) {
                 templateParam = templateParam.substring(1, templateParam.length() - 1);
             }
@@ -144,9 +163,9 @@ protected String getTemplateId(SectionInitContext context) {
         }
 
         @Override
-        protected IncludeSectionHelper newHelper(Supplier<Template> template, Map<String, Expression> params,
+        protected IncludeSectionHelper newHelper(TemplateSupplier templateSupplier, Map<String, Expression> params,
                 Map<String, SectionBlock> extendingBlocks, Boolean isolatedValue, SectionInitContext context) {
-            return new IncludeSectionHelper(template, extendingBlocks, params, isolatedValue != null ? isolatedValue
+            return new IncludeSectionHelper(templateSupplier, extendingBlocks, params, isolatedValue != null ? isolatedValue
                     : Boolean.parseBoolean(context.getParameterOrDefault(ISOLATED, Boolean.FALSE.toString())));
         }
 
@@ -170,21 +189,35 @@ String isolatedDefaultValue() {
 
         void addDefaultParams(ParametersInfo.Builder builder) {
             builder
-                    .addParameter(Parameter.builder(ISOLATED).defaultValue(isolatedDefaultValue()).optional()
-                            .valuePredicate(ISOLATED::equals).build())
-                    .addParameter(Parameter.builder(UNISOLATED).optional().valuePredicate(UNISOLATED::equals).build())
-                    .addParameter(Parameter.builder(IGNORE_FRAGMENTS).defaultValue(Boolean.FALSE.toString()).optional()
-                            .valuePredicate(IGNORE_FRAGMENTS::equals).build())
+                    .addParameter(Parameter.builder(ISOLATED)
+                            .defaultValue(isolatedDefaultValue())
+                            .optional()
+                            .valuePredicate(ISOLATED::equals)
+                            .build())
+                    .addParameter(Parameter.builder(UNISOLATED)
+                            .optional()
+                            .valuePredicate(UNISOLATED::equals)
+                            .build())
+                    .addParameter(Parameter.builder(IGNORE_FRAGMENTS)
+                            .defaultValue(Boolean.FALSE.toString())
+                            .optional()
+                            .valuePredicate(IGNORE_FRAGMENTS::equals)
+                            .build())
                     .build();
         }
 
+        protected boolean skipBuiltInParam(String value) {
+            return value != null && !value.startsWith("_");
+        }
+
         @Override
         public Scope initializeBlock(Scope outerScope, BlockInfo block) {
             if (block.getLabel().equals(MAIN_BLOCK_NAME)) {
-                for (Entry<String, String> entry : block.getParameters().entrySet()) {
+                Map<String, String> params = block.getParameters();
+                for (Entry<String, String> entry : params.entrySet()) {
                     String key = entry.getKey();
                     String value = entry.getValue();
-                    handleParam(key, value, () -> block.getParameter(0), (k, v) -> block.addExpression(k, v));
+                    processParam(params, key, value, () -> block.getParameter(0), (k, v) -> block.addExpression(k, v));
                 }
                 return outerScope;
             } else {
@@ -200,7 +233,7 @@ public T initialize(SectionInitContext context) {
             Map<String, SectionBlock> extendingBlocks;
 
             if (isEmpty) {
-                extendingBlocks = Collections.emptyMap();
+                extendingBlocks = Map.of();
             } else {
                 extendingBlocks = new HashMap<>();
                 for (SectionBlock block : context.getBlocks()) {
@@ -215,112 +248,51 @@ public T initialize(SectionInitContext context) {
                 }
             }
 
-            Map<String, Expression> params;
-            if (context.getParameters().size() == 1) {
-                params = Collections.emptyMap();
-            } else {
-                params = new HashMap<>();
-                for (Entry<String, String> entry : context.getParameters().entrySet()) {
-                    String key = entry.getKey();
-                    String value = entry.getValue();
-                    if (value.equals(ISOLATED)) {
-                        isolatedValue = true;
-                        continue;
-                    } else if (value.equals(UNISOLATED)) {
-                        isolatedValue = false;
-                        continue;
-                    }
-                    if (value.equals(IGNORE_FRAGMENTS)) {
-                        ignoreFragments = true;
-                        continue;
-                    }
-                    handleParam(key, value, () -> context.getParameter(0), (k, v) -> params.put(k, context.getExpression(k)));
+            Map<String, Expression> params = new HashMap<>();
+            Map<String, String> contextParams = context.getParameters();
+            for (Entry<String, String> entry : contextParams.entrySet()) {
+                String key = entry.getKey();
+                String value = entry.getValue();
+                if (value.equals(ISOLATED)) {
+                    // {#include foo _isolated /}
+                    isolatedValue = true;
+                    continue;
+                } else if (value.equals(UNISOLATED)) {
+                    // {#include foo _unisolated /}
+                    isolatedValue = false;
+                    continue;
+                }
+                if (value.equals(IGNORE_FRAGMENTS)) {
+                    // {#include foo _ignoreFragments /}
+                    ignoreFragments = true;
+                    continue;
                 }
+                processParam(contextParams, key, value, () -> context.getParameter(0),
+                        (k, v) -> params.put(k, context.getExpression(k)));
             }
 
-            // foo - no fragment
-            // foo$bar - template "foo" and fragment "bar"
-            // $fragment_01 - current template and fragment "fragment_01"
+            // null - dynamic lookup is needed
+            // "foo" - no fragment
+            // "foo$bar" - template "foo" and fragment "bar"
+            // "$fragment_01" - current template and fragment "fragment_01"
             String templateId = getTemplateId(context);
-
-            //
-            if (!ignoreFragments) {
-                ignoreFragments = Boolean.parseBoolean(context.getParameterOrDefault(IGNORE_FRAGMENTS, "false"));
-            }
-            final String fragmentId = ignoreFragments ? null : getFragmentId(templateId, context);
-            Supplier<Template> currentTemplate;
-            if (fragmentId != null) {
-                // remove the trailing fragment part
-                templateId = templateId.substring(0, templateId.lastIndexOf('$'));
-                if (templateId.isEmpty()) {
-                    // use the current template
-                    currentTemplate = context.getCurrentTemplate();
-                } else {
-                    currentTemplate = null;
-                }
-            } else {
-                currentTemplate = null;
-            }
-            final String finalTemplateId = templateId;
-
-            final Engine engine = context.getEngine();
-            Supplier<Template> template = new Supplier<Template>() {
-                @Override
-                public Template get() {
-                    Template template;
-                    if (currentTemplate != null) {
-                        template = currentTemplate.get();
-                    } else {
-                        template = engine.getTemplate(finalTemplateId);
-                    }
-                    if (template == null) {
-                        throw engine.error("included template [{templateId}] not found")
-                                .code(Code.TEMPLATE_NOT_FOUND)
-                                .argument("templateId", finalTemplateId)
-                                .origin(context.getOrigin())
-                                .build();
-                    }
-                    if (fragmentId != null) {
-                        Fragment fragment = template.getFragment(fragmentId);
-                        if (fragment == null) {
-                            throw engine.error("fragment [{fragmentId}] not found in the included template [{templateId}]")
-                                    .code(Code.FRAGMENT_NOT_FOUND)
-                                    .argument("templateId", finalTemplateId)
-                                    .argument("fragmentId", fragmentId)
-                                    .origin(context.getOrigin())
-                                    .build();
-                        }
-                        template = fragment;
-                    }
-                    return template;
-                }
-            };
-            return newHelper(template, params, extendingBlocks, isolatedValue, context);
+            TemplateSupplier templateSupplier = templateId != null
+                    ? new FixedTemplateSupplier(context, ignoreFragments, templateId)
+                    : new DynamicTemplateSupplier(context, ignoreFragments);
+            return newHelper(templateSupplier, params, extendingBlocks, isolatedValue,
+                    context);
         }
 
+        /**
+         *
+         * @param context
+         * @return {@code null} if dynamic lookup is needed
+         */
         protected abstract String getTemplateId(SectionInitContext context);
 
-        protected String getFragmentId(String templateId, SectionInitContext context) {
-            int idx = templateId.lastIndexOf('$');
-            if (idx != -1) {
-                // the part after the last occurence of a dollar sign is the fragment identifier
-                String fragmentId = templateId.substring(idx + 1, templateId.length());
-                if (FragmentSectionHelper.Factory.FRAGMENT_PATTERN.matcher(fragmentId).matches()) {
-                    return fragmentId;
-                } else {
-                    throw context.getEngine().error("invalid fragment identifier [{fragmentId}]")
-                            .code(Code.INVALID_FRAGMENT_ID)
-                            .argument("fragmentId", fragmentId)
-                            .origin(context.getOrigin())
-                            .build();
-                }
-            }
-            return null;
-        }
-
-        protected void handleParam(String key, String value, Supplier<String> firstParamSupplier,
+        protected void processParam(Map<String, String> params, String key, String value, Supplier<String> firstParamValue,
                 BiConsumer<String, String> paramConsumer) {
-            if (ignoreParameterInit(firstParamSupplier, key, value)) {
+            if (ignoreParameterInit(params, firstParamValue, key, value)) {
                 return;
             } else if (useDefaultedKey(key, value)) {
                 if (LiteralSupport.isStringLiteral(value)) {
@@ -346,11 +318,20 @@ protected boolean isSinglePart(String value) {
             return Expressions.splitParts(value).size() == 1 && !WHITESPACE.matcher(value).find();
         }
 
-        protected boolean ignoreParameterInit(Supplier<String> firstParamSupplier, String key, String value) {
+        /**
+         *
+         * @param params
+         * @param firstParamSupplier
+         * @param key
+         * @param value
+         * @return {@code true} if the parameter should not be processed, i.e. registered as an expression
+         */
+        protected boolean ignoreParameterInit(Map<String, String> params, Supplier<String> firstParamSupplier, String key,
+                String value) {
             return key.equals(IGNORE_FRAGMENTS);
         }
 
-        protected abstract T newHelper(Supplier<Template> template, Map<String, Expression> params,
+        protected abstract T newHelper(TemplateSupplier templateSupplier, Map<String, Expression> params,
                 Map<String, SectionBlock> extendingBlocks, Boolean isolatedValue, SectionInitContext context);
     }
 
@@ -373,4 +354,143 @@ public String getName() {
 
     }
 
+    static class FixedTemplateSupplier extends TemplateSupplier {
+
+        private final String templateId;
+        private final String fragmentId;
+        private final Supplier<Template> currentTemplate;
+
+        FixedTemplateSupplier(SectionInitContext context, boolean ignoreFragments, String templateId) {
+            super(context, ignoreFragments);
+            final String fragmentId = getFragmentId(templateId);
+            Supplier<Template> currentTemplate;
+            if (fragmentId != null) {
+                // remove the trailing fragment part
+                templateId = templateId.substring(0, templateId.lastIndexOf('$'));
+                if (templateId.isEmpty()) {
+                    // use the current template
+                    currentTemplate = context.getCurrentTemplate();
+                } else {
+                    currentTemplate = null;
+                }
+            } else {
+                currentTemplate = null;
+            }
+            this.templateId = templateId;
+            this.fragmentId = fragmentId;
+            this.currentTemplate = currentTemplate;
+        }
+
+        @Override
+        Template get(Map<String, Object> params) {
+            return doGet(templateId, fragmentId, currentTemplate);
+        }
+
+    }
+
+    static class DynamicTemplateSupplier extends TemplateSupplier {
+
+        private final Supplier<Template> currentTemplate;
+
+        DynamicTemplateSupplier(SectionInitContext context, boolean ignoreFragments) {
+            super(context, ignoreFragments);
+            this.currentTemplate = context.getCurrentTemplate();
+        }
+
+        @Override
+        Template get(Map<String, Object> params) {
+            Object templateIdVal = params.get(Factory.DYNAMIC_ID);
+            if (templateIdVal == null) {
+                throw engine.error("dynamically included template not found")
+                        .code(Code.TEMPLATE_NOT_FOUND)
+                        .origin(origin)
+                        .build();
+            }
+            String templateId = templateIdVal.toString();
+            final String fragmentId = getFragmentId(templateId);
+            Supplier<Template> currentTemplate;
+            if (fragmentId != null) {
+                // remove the trailing fragment part
+                templateId = templateId.substring(0, templateId.lastIndexOf('$'));
+                if (templateId.isEmpty()) {
+                    // use the current template
+                    currentTemplate = this.currentTemplate;
+                } else {
+                    currentTemplate = null;
+                }
+            } else {
+                currentTemplate = null;
+            }
+            return doGet(templateId, fragmentId, currentTemplate);
+        }
+
+    }
+
+    static abstract class TemplateSupplier {
+
+        protected final Engine engine;
+        protected final Origin origin;
+        protected final boolean ignoreFragments;
+
+        TemplateSupplier(SectionInitContext context, boolean ignoreFragments) {
+            this.engine = context.getEngine();
+            this.origin = context.getOrigin();
+            this.ignoreFragments = ignoreFragments ? true
+                    : Boolean.parseBoolean(context.getParameterOrDefault(AbstractIncludeFactory.IGNORE_FRAGMENTS, "false"));
+        }
+
+        abstract Template get(Map<String, Object> params);
+
+        protected Template doGet(String templateId, String fragmentId, Supplier<Template> currentTemplate) {
+            Template ret;
+            if (currentTemplate != null) {
+                ret = currentTemplate.get();
+            } else {
+                ret = engine.getTemplate(templateId);
+            }
+            if (ret == null) {
+                throw engine.error("included template [{templateId}] not found")
+                        .code(Code.TEMPLATE_NOT_FOUND)
+                        .argument("templateId", templateId)
+                        .origin(origin)
+                        .build();
+            }
+            if (fragmentId != null) {
+                Fragment fragment = ret.getFragment(fragmentId);
+                if (fragment == null) {
+                    throw engine.error("fragment [{fragmentId}] not found in the included template [{templateId}]")
+                            .code(Code.FRAGMENT_NOT_FOUND)
+                            .argument("templateId", templateId)
+                            .argument("fragmentId", fragmentId)
+                            .origin(origin)
+                            .build();
+                }
+                ret = fragment;
+            }
+            return ret;
+        }
+
+        protected String getFragmentId(String templateId) {
+            if (ignoreFragments) {
+                return null;
+            }
+            int idx = templateId.lastIndexOf('$');
+            if (idx != -1) {
+                // the part after the last occurence of a dollar sign is the fragment identifier
+                String fragmentId = templateId.substring(idx + 1, templateId.length());
+                if (FragmentSectionHelper.Factory.FRAGMENT_PATTERN.matcher(fragmentId).matches()) {
+                    return fragmentId;
+                } else {
+                    throw engine.error("invalid fragment identifier [{fragmentId}]")
+                            .code(Code.INVALID_FRAGMENT_ID)
+                            .argument("fragmentId", fragmentId)
+                            .origin(origin)
+                            .build();
+                }
+            }
+            return null;
+        }
+
+    }
+
 }
diff --git a/independent-projects/qute/core/src/main/java/io/quarkus/qute/UserTagSectionHelper.java b/independent-projects/qute/core/src/main/java/io/quarkus/qute/UserTagSectionHelper.java
index 7d0cc604490..56f374ca4d3 100644
--- a/independent-projects/qute/core/src/main/java/io/quarkus/qute/UserTagSectionHelper.java
+++ b/independent-projects/qute/core/src/main/java/io/quarkus/qute/UserTagSectionHelper.java
@@ -20,7 +20,7 @@ public class UserTagSectionHelper extends IncludeSectionHelper implements Sectio
     private final HtmlEscaper htmlEscaper;
     private final String itKey;
 
-    UserTagSectionHelper(Supplier<Template> templateSupplier, Map<String, SectionBlock> extendingBlocks,
+    UserTagSectionHelper(TemplateSupplier templateSupplier, Map<String, SectionBlock> extendingBlocks,
             Map<String, Expression> parameters, boolean isIsolated, boolean isNestedContentNeeded, HtmlEscaper htmlEscaper,
             String itKey) {
         super(templateSupplier, extendingBlocks, parameters, isIsolated);
@@ -39,7 +39,8 @@ protected void addAdditionalEvaluatedParams(SectionResolutionContext context, Ma
         evaluatedParams.put(Factory.ARGS, new Arguments(evaluatedParams));
         if (isNestedContentNeeded) {
             // If needed then add the {nested-content} to the evaluated params
-            Expression nestedContent = ((TemplateImpl) template.get()).findExpression(this::isNestedContent);
+            Expression nestedContent = ((TemplateImpl) templateSupplier.get(evaluatedParams))
+                    .findExpression(this::isNestedContent);
             if (nestedContent != null) {
                 // Execute the nested content first and make it accessible via the "nested-content" key
                 evaluatedParams.put(NESTED_CONTENT,
@@ -106,9 +107,10 @@ public ParametersInfo getParameters() {
         }
 
         @Override
-        protected boolean ignoreParameterInit(Supplier<String> firstParamSupplier, String key, String value) {
-            // {#myTag _isolated=true /}
-            return super.ignoreParameterInit(firstParamSupplier, key, value)
+        protected boolean ignoreParameterInit(Map<String, String> params, Supplier<String> firstParamValue, String key,
+                String value) {
+            return super.ignoreParameterInit(params, firstParamValue, key, value)
+                    // {#myTag _isolated=true /}
                     || (key.equals(ISOLATED)
                             // {#myTag _isolated /}
                             || value.equals(ISOLATED)
@@ -116,7 +118,7 @@ protected boolean ignoreParameterInit(Supplier<String> firstParamSupplier, Strin
                             || value.equals(UNISOLATED)
                             // IT with default value or not the first agrument
                             // e.g. it=it in {#myTag foo=bar /} or baz in {#myTag foo=bar baz /}
-                            || (key.equals(IT) && (!firstParamSupplier.get().equals(value) || value.equals(IT))));
+                            || (key.equals(IT) && (!firstParamValue.get().equals(value) || value.equals(IT))));
         }
 
         @Override
@@ -125,13 +127,13 @@ protected String getTemplateId(SectionInitContext context) {
         }
 
         @Override
-        protected UserTagSectionHelper newHelper(Supplier<Template> template, Map<String, Expression> params,
+        protected UserTagSectionHelper newHelper(TemplateSupplier templateSupplier, Map<String, Expression> params,
                 Map<String, SectionBlock> extendingBlocks, Boolean isolatedValue, SectionInitContext context) {
             boolean isNestedContentNeeded = !context.getBlock(SectionHelperFactory.MAIN_BLOCK_NAME).isEmpty();
             // Use the filtered map of paramas and not the original map from the SectionInitContext
             Expression itKeyExpr = params.getOrDefault(IT, null);
 
-            return new UserTagSectionHelper(template, extendingBlocks, params,
+            return new UserTagSectionHelper(templateSupplier, extendingBlocks, params,
                     isolatedValue != null ? isolatedValue
                             : Boolean.parseBoolean(context.getParameterOrDefault(ISOLATED, ISOLATED_DEFAULT_VALUE)),
                     isNestedContentNeeded, htmlEscaper,
@@ -139,7 +141,7 @@ protected UserTagSectionHelper newHelper(Supplier<Template> template, Map<String
         }
 
         @Override
-        protected void handleParam(String key, String value, Supplier<String> firstParamSupplier,
+        protected void processParam(Map<String, String> params, String key, String value, Supplier<String> firstParamValue,
                 BiConsumer<String, String> paramConsumer) {
             if (key.equals(IT)) {
                 if (value.equals(IT)) {
@@ -151,7 +153,7 @@ protected void handleParam(String key, String value, Supplier<String> firstParam
                     paramConsumer.accept(defaultedKey, value);
                 }
             }
-            super.handleParam(key, value, firstParamSupplier, paramConsumer);
+            super.processParam(params, key, value, firstParamValue, paramConsumer);
         }
 
     }
diff --git a/independent-projects/qute/core/src/test/java/io/quarkus/qute/IncludeTest.java b/independent-projects/qute/core/src/test/java/io/quarkus/qute/IncludeTest.java
index 0482275186a..c01d3ccb8de 100644
--- a/independent-projects/qute/core/src/test/java/io/quarkus/qute/IncludeTest.java
+++ b/independent-projects/qute/core/src/test/java/io/quarkus/qute/IncludeTest.java
@@ -347,4 +347,27 @@ public void testNestedBlocksWithSameName() {
                                     """).render().replaceAll("\\s+", ""));
     }
 
+    @Test
+    public void testDynamicTemplate() {
+        Engine engine = Engine.builder().addDefaults().build();
+        engine.putTemplate("root", engine.parse("<html><body>{#insert foo /}</body></html>"));
+        assertEquals("<html><body>Something</body></html>",
+                engine.parse("{#include _id=foo}{#foo}Something{/include}").data("foo", "root").render());
+        assertEquals("<html><body>1</body></html>",
+                engine.parse("{#include bar=1 _id=foo}{#foo}{bar}{/include}").data("foo", "root").render());
+    }
+
+    @Test
+    public void testDynamicTemplateNotFound() {
+        Engine engine = Engine.builder().addDefaults().build();
+        assertThatExceptionOfType(TemplateException.class)
+                .isThrownBy(() -> engine.parse("{#include _id=foo /}", null, "foo.html")
+                        .data("foo", "nonexistent")
+                        .render())
+                .withMessage(
+                        "Rendering error in template [foo.html] line 1: included template [nonexistent] not found")
+                .hasFieldOrProperty("origin")
+                .hasFieldOrProperty("code");
+    }
+
 }
diff --git a/independent-projects/qute/core/src/test/java/io/quarkus/qute/ParserTest.java b/independent-projects/qute/core/src/test/java/io/quarkus/qute/ParserTest.java
index 9fa33d1e2bd..6c3310e3916 100644
--- a/independent-projects/qute/core/src/test/java/io/quarkus/qute/ParserTest.java
+++ b/independent-projects/qute/core/src/test/java/io/quarkus/qute/ParserTest.java
@@ -449,9 +449,9 @@ public void testInvalidIdentifier() {
     }
 
     @Test
-    public void testMandatorySectionParas() {
-        assertParserError("{#include /}", ParserError.MANDATORY_SECTION_PARAMS_MISSING,
-                "Parser error: mandatory section parameters not declared for {#include /}: [template]", 1);
+    public void testMandatorySectionParams() {
+        assertParserError("{#eval /}", ParserError.MANDATORY_SECTION_PARAMS_MISSING,
+                "Parser error: mandatory section parameters not declared for {#eval /}: [template]", 1);
     }
 
     @Test
