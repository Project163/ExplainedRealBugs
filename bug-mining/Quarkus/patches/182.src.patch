diff --git a/extensions/tls-registry/deployment/src/test/java/io/quarkus/tls/JavaNetSslTlsBucketConfigTest.java b/extensions/tls-registry/deployment/src/test/java/io/quarkus/tls/JavaxNetSslTrustStoreProviderTest.java
similarity index 78%
rename from extensions/tls-registry/deployment/src/test/java/io/quarkus/tls/JavaNetSslTlsBucketConfigTest.java
rename to extensions/tls-registry/deployment/src/test/java/io/quarkus/tls/JavaxNetSslTrustStoreProviderTest.java
index 5423820066f..0f93083ef3c 100644
--- a/extensions/tls-registry/deployment/src/test/java/io/quarkus/tls/JavaNetSslTlsBucketConfigTest.java
+++ b/extensions/tls-registry/deployment/src/test/java/io/quarkus/tls/JavaxNetSslTrustStoreProviderTest.java
@@ -16,6 +16,7 @@
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
+import javax.net.ssl.TrustManager;
 import javax.net.ssl.TrustManagerFactory;
 import javax.net.ssl.X509TrustManager;
 
@@ -27,8 +28,9 @@
 import org.junit.jupiter.api.extension.RegisterExtension;
 
 import io.quarkus.test.QuarkusUnitTest;
+import io.vertx.core.Vertx;
 
-public class JavaNetSslTlsBucketConfigTest {
+public class JavaxNetSslTrustStoreProviderTest {
     @RegisterExtension
     static final QuarkusUnitTest config = createConfig();
 
@@ -45,7 +47,6 @@ static QuarkusUnitTest createConfig() {
                 .setArchiveProducer(() -> ShrinkWrap.create(JavaArchive.class))
                 .overrideConfigKey("quarkus.tls.javaNetSslLike.trust-store." + tsType + ".path", tsPath.toString())
                 .overrideConfigKey("quarkus.tls.javaNetSslLike.trust-store." + tsType + ".password", password);
-
     }
 
     static Path defaultTrustStorePath() {
@@ -79,6 +80,9 @@ static Path defaultTrustStorePath() {
     @Inject
     TlsConfigurationRegistry certificates;
 
+    @Inject
+    Vertx vertx;
+
     @Test
     void test() throws KeyStoreException, IOException, NoSuchAlgorithmException, CertificateException {
         TlsConfiguration def = certificates.get("javax.net.ssl").orElseThrow();
@@ -126,18 +130,31 @@ void test() throws KeyStoreException, IOException, NoSuchAlgorithmException, Cer
                 throw lastException;
             }
         }
+
     }
 
     @Test
-    void checkDefaults() {
+    void certs() throws Exception {
         /*
-         * The javaNetSslLike named TLS bucket mimics what JavaNetSslTlsBucketConfig does programmatically.
-         * By asserting that their SSLOptions are equal, we make sure that all defaults set programmatically
-         * in JavaNetSslTlsBucketConfig are in sync with @WithDefault values defined in TlsBucketConfig
+         * The javaNetSslLike named TLS bucket mimics what JavaNetSslTrustStoreProvider does programmatically.
+         * By asserting that the set of certs they contain are equal, we make sure that JavaNetSslTrustStoreProvider
+         * behaves correctly.
          */
-        final TlsConfiguration javaNetSsl = certificates.get("javax.net.ssl").orElseThrow();
-        final TlsConfiguration javaNetSslLike = certificates.get("javaNetSslLike").orElseThrow();
-        assertThat(javaNetSsl.getSSLOptions()).isEqualTo(javaNetSslLike.getSSLOptions());
+        final TrustManager[] javaNetSslTrustManagers = trustManagers("javax.net.ssl");
+        final TrustManager[] javaNetSslLikeTrustManagers = trustManagers("javaNetSslLike");
+        assertThat(javaNetSslTrustManagers.length).isEqualTo(javaNetSslLikeTrustManagers.length);
+        for (int i = 0; i < javaNetSslTrustManagers.length; i++) {
+            X509TrustManager javaNetSslTm = (X509TrustManager) javaNetSslTrustManagers[i];
+            X509TrustManager javaNetSslLikeTm = (X509TrustManager) javaNetSslLikeTrustManagers[i];
+            assertThat(javaNetSslTm.getAcceptedIssuers().length).isGreaterThan(0);
+            assertThat(javaNetSslTm.getAcceptedIssuers()).containsExactlyInAnyOrder(javaNetSslLikeTm.getAcceptedIssuers());
+        }
+    }
 
+    TrustManager[] trustManagers(String key) throws Exception {
+        final TlsConfiguration javaNetSsl = certificates.get(key).orElseThrow();
+        final TrustManagerFactory javaNetSslTrustManagerFactory = javaNetSsl.getSSLOptions().getTrustOptions()
+                .getTrustManagerFactory(vertx);
+        return javaNetSslTrustManagerFactory.getTrustManagers();
     }
 }
diff --git a/extensions/tls-registry/runtime/src/main/java/io/quarkus/tls/runtime/CertificateRecorder.java b/extensions/tls-registry/runtime/src/main/java/io/quarkus/tls/runtime/CertificateRecorder.java
index 270cc5e67dd..01beadd681f 100644
--- a/extensions/tls-registry/runtime/src/main/java/io/quarkus/tls/runtime/CertificateRecorder.java
+++ b/extensions/tls-registry/runtime/src/main/java/io/quarkus/tls/runtime/CertificateRecorder.java
@@ -34,6 +34,7 @@ public class CertificateRecorder implements TlsConfigurationRegistry {
     private final Map<String, TlsConfiguration> certificates = new ConcurrentHashMap<>();
     private volatile TlsCertificateUpdater reloader;
     private volatile Vertx vertx;
+    private volatile TlsConfig config;
 
     /**
      * Validate the certificate configuration.
@@ -51,6 +52,7 @@ public void validateCertificates(Set<String> providerBucketNames,
             RuntimeValue<Vertx> vertx,
             ShutdownContext shutdownContext) {
         this.vertx = vertx.getValue();
+        this.config = config;
         // Verify the default config
         if (config.defaultCertificateConfig().isPresent()) {
             verifyCertificateConfig(config.defaultCertificateConfig().get(), vertx.getValue(), TlsConfig.DEFAULT_NAME);
@@ -176,8 +178,8 @@ public static TrustStoreAndTrustOptions getTrustStore(TlsBucketConfig bucketConf
     public Optional<TlsConfiguration> get(String name) {
         if (TlsConfig.JAVA_NET_SSL_TLS_CONFIGURATION_NAME.equals(name)) {
             final TlsConfiguration result = certificates.computeIfAbsent(TlsConfig.JAVA_NET_SSL_TLS_CONFIGURATION_NAME, k -> {
-                return verifyCertificateConfigInternal(new JavaNetSslTlsBucketConfig(), vertx,
-                        TlsConfig.JAVA_NET_SSL_TLS_CONFIGURATION_NAME);
+                final TrustStoreAndTrustOptions ts = JavaxNetSslTrustStoreProvider.getTrustStore(vertx);
+                return new VertxCertificateHolder(vertx, k, config.namedCertificateConfig().get(k), null, ts);
             });
             return Optional.ofNullable(result);
         }
diff --git a/extensions/tls-registry/runtime/src/main/java/io/quarkus/tls/runtime/JavaNetSslTlsBucketConfig.java b/extensions/tls-registry/runtime/src/main/java/io/quarkus/tls/runtime/JavaNetSslTlsBucketConfig.java
deleted file mode 100644
index 518a19a08bf..00000000000
--- a/extensions/tls-registry/runtime/src/main/java/io/quarkus/tls/runtime/JavaNetSslTlsBucketConfig.java
+++ /dev/null
@@ -1,170 +0,0 @@
-package io.quarkus.tls.runtime;
-
-import java.nio.file.Files;
-import java.nio.file.Path;
-import java.security.KeyStore;
-import java.time.Duration;
-import java.util.List;
-import java.util.Locale;
-import java.util.Optional;
-import java.util.Set;
-
-import org.jboss.logging.Logger;
-
-import io.quarkus.tls.runtime.config.JKSTrustStoreConfig;
-import io.quarkus.tls.runtime.config.KeyStoreConfig;
-import io.quarkus.tls.runtime.config.P12TrustStoreConfig;
-import io.quarkus.tls.runtime.config.PemCertsConfig;
-import io.quarkus.tls.runtime.config.TlsBucketConfig;
-import io.quarkus.tls.runtime.config.TrustStoreConfig;
-import io.quarkus.tls.runtime.config.TrustStoreConfig.CertificateExpiryPolicy;
-import io.quarkus.tls.runtime.config.TrustStoreCredentialProviderConfig;
-
-/**
- * A {@link TlsBucketConfig} mimicking the way how SunJSSE locates the default truststore:
- * <ol>
- * <li>If the {@code javax.net.ssl.trustStore} property is defined, then it is honored
- * <li>If the {@code $JAVA_HOME/lib/security/jssecacerts} is a regular file, then it is used
- * <li>If the {@code $JAVA_HOME/lib/security/cacerts} is a regular file, then it is used
- * <li>Otherwise an {@link IllegalStateException} is thrown.
- * </ol>
- *
- * @since 3.18.0
- */
-class JavaNetSslTlsBucketConfig implements TlsBucketConfig {
-
-    private static final Logger log = Logger.getLogger(JavaNetSslTlsBucketConfig.class);
-
-    JavaNetSslTlsBucketConfig() {
-    }
-
-    @Override
-    public Optional<KeyStoreConfig> keyStore() {
-        return Optional.empty();
-    }
-
-    @Override
-    public Optional<TrustStoreConfig> trustStore() {
-        final Path tsPath = defaultTrustStorePath();
-        final Optional<JKSTrustStoreConfig> jksConfig;
-        final Optional<P12TrustStoreConfig> p12Config;
-        final String tsType = System.getProperty("javax.net.ssl.trustStoreType", KeyStore.getDefaultType())
-                .toLowerCase(Locale.US);
-        final Optional<String> password = Optional
-                .ofNullable(System.getProperty("javax.net.ssl.trustStorePassword", "changeit"));
-        switch (tsType) {
-            case "pkcs12": {
-                p12Config = Optional.of(new JavaNetSslStoreConfig(
-                        tsPath,
-                        password,
-                        Optional.empty(),
-                        null));
-                jksConfig = Optional.empty();
-                break;
-            }
-            case "jks": {
-                p12Config = Optional.empty();
-                jksConfig = Optional.of(new JavaNetSslStoreConfig(
-                        tsPath,
-                        password,
-                        Optional.empty(),
-                        null));
-                break;
-            }
-            default:
-                throw new IllegalArgumentException("Unexpected javax.net.ssl.trustStoreType: " + tsType);
-        }
-        final TrustStoreConfig tsCfg = new JavaNetSslTrustStoreConfig(p12Config, jksConfig, CertificateExpiryPolicy.WARN);
-        return Optional.of(tsCfg);
-    }
-
-    static Path defaultTrustStorePath() {
-        final String rawTsPath = System.getProperty("javax.net.ssl.trustStore");
-        if (rawTsPath != null && !rawTsPath.isEmpty()) {
-            log.debugf("Honoring javax.net.ssl.trustStore property value: %s", rawTsPath);
-            return Path.of(rawTsPath);
-        }
-        final String javaHome = System.getProperty("java.home");
-        if (javaHome == null || javaHome.isEmpty()) {
-            throw new IllegalStateException(
-                    "Could not locate the default Java truststore because the 'java.home' property is not set");
-        }
-        final Path javaHomePath = Path.of(javaHome);
-        if (!Files.isDirectory(javaHomePath)) {
-            throw new IllegalStateException("Could not locate the default Java truststore because the 'java.home' path '"
-                    + javaHome + "' is not a directory");
-        }
-        final Path jssecacerts = javaHomePath.resolve("lib/security/jssecacerts");
-        if (Files.isRegularFile(jssecacerts)) {
-            log.debugf("Using %s as a truststore", jssecacerts);
-            return jssecacerts;
-        }
-        final Path cacerts = javaHomePath.resolve("lib/security/cacerts");
-        if (Files.isRegularFile(cacerts)) {
-            log.debugf("Using %s as a truststore", cacerts);
-            return cacerts;
-        }
-        throw new IllegalStateException(
-                "Could not locate the default Java truststore. Tried javax.net.ssl.trustStore system property, " + jssecacerts
-                        + " and " + cacerts);
-    }
-
-    @Override
-    public Optional<List<String>> cipherSuites() {
-        return Optional.empty();
-    }
-
-    @Override
-    public Set<String> protocols() {
-        return Set.of("TLSv1.3", "TLSv1.2");
-    }
-
-    @Override
-    public Duration handshakeTimeout() {
-        return Duration.ofSeconds(10L);
-    }
-
-    @Override
-    public boolean alpn() {
-        return true;
-    }
-
-    @Override
-    public Optional<List<Path>> certificateRevocationList() {
-        return Optional.empty();
-    }
-
-    @Override
-    public boolean trustAll() {
-        return false;
-    }
-
-    @Override
-    public Optional<String> hostnameVerificationAlgorithm() {
-        return Optional.empty();
-    }
-
-    @Override
-    public Optional<Duration> reloadPeriod() {
-        return Optional.empty();
-    }
-
-    static record JavaNetSslStoreConfig(Path path, Optional<String> password, Optional<String> alias,
-            Optional<String> provider) implements P12TrustStoreConfig, JKSTrustStoreConfig {
-    }
-
-    static record JavaNetSslTrustStoreConfig(Optional<P12TrustStoreConfig> p12, Optional<JKSTrustStoreConfig> jks,
-            CertificateExpiryPolicy certificateExpirationPolicy) implements TrustStoreConfig {
-
-        @Override
-        public Optional<PemCertsConfig> pem() {
-            return Optional.empty();
-        }
-
-        @Override
-        public TrustStoreCredentialProviderConfig credentialsProvider() {
-            return null;
-        }
-
-    }
-}
\ No newline at end of file
diff --git a/extensions/tls-registry/runtime/src/main/java/io/quarkus/tls/runtime/JavaxNetSslTrustStoreProvider.java b/extensions/tls-registry/runtime/src/main/java/io/quarkus/tls/runtime/JavaxNetSslTrustStoreProvider.java
new file mode 100644
index 00000000000..340d205155f
--- /dev/null
+++ b/extensions/tls-registry/runtime/src/main/java/io/quarkus/tls/runtime/JavaxNetSslTrustStoreProvider.java
@@ -0,0 +1,117 @@
+package io.quarkus.tls.runtime;
+
+import java.io.IOException;
+import java.security.KeyStore;
+import java.security.KeyStoreException;
+import java.security.NoSuchAlgorithmException;
+import java.security.cert.CertificateException;
+import java.security.cert.X509Certificate;
+import java.util.List;
+import java.util.Locale;
+import java.util.function.Function;
+
+import javax.naming.InvalidNameException;
+import javax.naming.ldap.LdapName;
+import javax.naming.ldap.Rdn;
+import javax.net.ssl.TrustManager;
+import javax.net.ssl.TrustManagerFactory;
+import javax.net.ssl.X509TrustManager;
+
+import io.quarkus.tls.runtime.config.TrustStoreConfig.CertificateExpiryPolicy;
+import io.quarkus.tls.runtime.keystores.ExpiryTrustOptions;
+import io.vertx.core.Vertx;
+import io.vertx.core.net.TrustOptions;
+import io.vertx.core.net.impl.KeyStoreHelper;
+
+/**
+ * Provides {@link TrustStoreAndTrustOptions} wrapping the default Java trust store specified as follows:
+ * <ol>
+ * <li>If the {@code javax.net.ssl.trustStore} property is defined, then it is honored
+ * <li>If the {@code $JAVA_HOME/lib/security/jssecacerts} is a regular file, then it is used
+ * <li>If the {@code $JAVA_HOME/lib/security/cacerts} is a regular file, then it is used
+ * </ol>
+ * <p>
+ * For native image, be aware that the default trust material is stored inside the native image.
+ * Therefore it is not loaded anew at application start unless the application is started with
+ * {@code -Djavax.net.ssl.trustStore=path/to/trust-store} - see
+ * <a href="https://www.graalvm.org/latest/reference-manual/native-image/dynamic-features/CertificateManagement/">Certificate
+ * Management</a> in GraalVM reference manual.
+ *
+ * @since 3.18.0
+ */
+public class JavaxNetSslTrustStoreProvider {
+
+    public static TrustStoreAndTrustOptions getTrustStore(Vertx vertx) {
+        JavaNetSslTrustOptions options = new JavaNetSslTrustOptions();
+        return new TrustStoreAndTrustOptions(options.keystore, new ExpiryTrustOptions(options, CertificateExpiryPolicy.WARN));
+    }
+
+    static class JavaNetSslTrustOptions implements TrustOptions {
+        private final TrustManagerFactory trustManagerFactory;
+        private final KeyStore keystore;
+        private KeyStoreHelper helper;
+
+        JavaNetSslTrustOptions() {
+            try {
+                final TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
+                tmf.init((KeyStore) null);
+
+                final String tsType = System.getProperty("javax.net.ssl.trustStoreType", KeyStore.getDefaultType());
+                final KeyStore cacerts = KeyStore.getInstance(tsType);
+                cacerts.load(null, null);
+                for (TrustManager tm : tmf.getTrustManagers()) {
+                    for (X509Certificate c : ((X509TrustManager) tm).getAcceptedIssuers()) {
+                        final String dn = c.getSubjectX500Principal().getName();
+                        final List<Rdn> rdns = new LdapName(dn).getRdns();
+                        String alias = rdns.stream()
+                                .filter(rdn -> rdn.getType().equalsIgnoreCase("cn"))
+                                .map(rdn -> rdn.getValue().toString())
+                                .findFirst()
+                                .orElseGet(() -> rdns.stream()
+                                        .filter(rdn -> rdn.getType().equalsIgnoreCase("ou"))
+                                        .map(rdn -> rdn.getValue().toString())
+                                        .findFirst()
+                                        .orElseThrow(() -> new IllegalStateException("No CN or OU in " + dn)));
+                        alias = alias.replace(" ", "");
+                        alias = alias.toLowerCase(Locale.ROOT);
+                        cacerts.setCertificateEntry(alias, c);
+                    }
+                }
+                trustManagerFactory = tmf;
+                keystore = cacerts;
+            } catch (NoSuchAlgorithmException | KeyStoreException | InvalidNameException | CertificateException
+                    | IOException e) {
+                throw new RuntimeException(e);
+            }
+        }
+
+        @Override
+        public Function<String, TrustManager[]> trustManagerMapper(Vertx vertx) throws Exception {
+            if (helper == null) {
+                final String cacertsPassword = System.getProperty("javax.net.ssl.trustStorePassword", "changeit");
+                helper = new KeyStoreHelper(keystore, cacertsPassword, null);
+            }
+            return helper::getTrustMgr;
+        }
+
+        @Override
+        public TrustManagerFactory getTrustManagerFactory(Vertx vertx) {
+            return trustManagerFactory;
+        }
+
+        @Override
+        public TrustOptions copy() {
+            return this;
+        }
+
+        @Override
+        public int hashCode() {
+            final int prime = 31;
+            int result = 1;
+            result = prime * result + ((keystore == null) ? 0 : keystore.hashCode());
+            return result;
+        }
+
+    }
+
+}
diff --git a/integration-tests/rest-client/pom.xml b/integration-tests/rest-client/pom.xml
index 7e2bc53e486..20aaf2d16f8 100644
--- a/integration-tests/rest-client/pom.xml
+++ b/integration-tests/rest-client/pom.xml
@@ -152,9 +152,6 @@
                     <systemPropertyVariables>
                         <!-- force the locale as we want to explicitly test message interpolation -->
                         <user.language>en</user.language>
-                        <javax.net.ssl.trustStore>${self-signed.trust-store}</javax.net.ssl.trustStore>
-                        <javax.net.ssl.trustStorePassword>${self-signed.trust-store-password}
-                        </javax.net.ssl.trustStorePassword>
                     </systemPropertyVariables>
                 </configuration>
             </plugin>
diff --git a/integration-tests/rest-client/src/main/java/io/quarkus/it/rest/client/selfsigned/ExternalSelfSignedResource.java b/integration-tests/rest-client/src/main/java/io/quarkus/it/rest/client/selfsigned/ExternalSelfSignedResource.java
index 97b8847e67b..05d41dcbadd 100644
--- a/integration-tests/rest-client/src/main/java/io/quarkus/it/rest/client/selfsigned/ExternalSelfSignedResource.java
+++ b/integration-tests/rest-client/src/main/java/io/quarkus/it/rest/client/selfsigned/ExternalSelfSignedResource.java
@@ -1,15 +1,32 @@
 package io.quarkus.it.rest.client.selfsigned;
 
 import java.io.IOException;
+import java.io.PrintWriter;
+import java.io.StringWriter;
+import java.io.Writer;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
 
 import jakarta.inject.Inject;
 import jakarta.ws.rs.GET;
 import jakarta.ws.rs.Path;
+import jakarta.ws.rs.PathParam;
 import jakarta.ws.rs.Produces;
 import jakarta.ws.rs.core.MediaType;
+import jakarta.ws.rs.core.Response;
 
+import org.eclipse.microprofile.config.inject.ConfigProperty;
 import org.eclipse.microprofile.rest.client.inject.RestClient;
 
+import io.quarkus.tls.TlsConfigurationRegistry;
+import io.vertx.core.Future;
+import io.vertx.core.Vertx;
+import io.vertx.core.buffer.Buffer;
+import io.vertx.core.http.HttpClientOptions;
+import io.vertx.core.http.HttpMethod;
+import io.vertx.core.http.RequestOptions;
+
 /**
  * This has nothing to do with rest-client, but we add it here in order to avoid creating
  * a new integration test that would slow down our CI
@@ -19,12 +36,52 @@ public class ExternalSelfSignedResource {
 
     @Inject
     @RestClient
-    ExternalSelfSignedClient client;
+    ExternalSelfSignedClient externalSelfSignedClient;
 
     @GET
+    @Path("/ExternalSelfSignedClient")
     @Produces(MediaType.TEXT_PLAIN)
-    public String perform() throws IOException {
-        return String.valueOf(client.invoke().getStatus());
+    public Response perform(@PathParam("client") String client) throws IOException {
+        return externalSelfSignedClient.invoke();
     }
 
+    @Inject
+    TlsConfigurationRegistry tlsConfigurationRegistry;
+
+    @Inject
+    Vertx vertx;
+
+    @ConfigProperty(name = "self-signed.port", defaultValue = "-1")
+    int serverPort;
+
+    @GET
+    @Path("/HttpClient/{tlsConfigName}")
+    @Produces(MediaType.TEXT_PLAIN)
+    public Response client(@PathParam("tlsConfigName") String tlsConfigName)
+            throws InterruptedException, ExecutionException, TimeoutException {
+        final HttpClientOptions opts = new HttpClientOptions();
+        tlsConfigurationRegistry.get(tlsConfigName)
+                .ifPresent(tlsConfig -> opts.setTrustOptions(tlsConfig.getTrustStoreOptions()));
+        final Future<Response> response = vertx.createHttpClient(opts).request(
+                new RequestOptions()
+                        .setMethod(HttpMethod.GET)
+                        .setHost("localhost")
+                        .setPort(serverPort)
+                        .setURI("/")
+                        .setSsl(true))
+                .compose(request -> request.end().compose(x -> request.response())
+                        .compose(resp -> resp
+                                .body()
+                                .map(Buffer::toString)
+                                .compose(respBody -> Future.succeededFuture(Response.ok(respBody).build()))))
+                .recover(e -> Future.succeededFuture(Response.status(500).entity(stackTrace(e)).build()));
+        return response.toCompletionStage().toCompletableFuture().get(10, TimeUnit.SECONDS);
+    }
+
+    static Object stackTrace(Throwable e) {
+        final Writer sw = new StringWriter();
+        final PrintWriter pw = new PrintWriter(sw);
+        e.printStackTrace(pw);
+        return sw.toString();
+    }
 }
diff --git a/integration-tests/rest-client/src/test/java/io/quarkus/it/rest/client/selfsigned/ExternalSelfSignedTestCase.java b/integration-tests/rest-client/src/test/java/io/quarkus/it/rest/client/selfsigned/ExternalSelfSignedTestCase.java
index 3baf8b90330..236ea4e8d3b 100644
--- a/integration-tests/rest-client/src/test/java/io/quarkus/it/rest/client/selfsigned/ExternalSelfSignedTestCase.java
+++ b/integration-tests/rest-client/src/test/java/io/quarkus/it/rest/client/selfsigned/ExternalSelfSignedTestCase.java
@@ -1,6 +1,8 @@
 package io.quarkus.it.rest.client.selfsigned;
 
+import static io.restassured.RestAssured.given;
 import static io.restassured.RestAssured.when;
+import static org.hamcrest.Matchers.containsStringIgnoringCase;
 import static org.hamcrest.Matchers.is;
 
 import org.junit.jupiter.api.Test;
@@ -15,10 +17,28 @@ public class ExternalSelfSignedTestCase {
     @Test
     public void should_accept_self_signed_certs() {
         when()
-                .get("/self-signed")
+                .get("/self-signed/ExternalSelfSignedClient")
                 .then()
                 .statusCode(200)
-                .body(is("200"));
+                .body(is("Hello self-signed!"));
+    }
+
+    @Test
+    public void javaxNetSsl() {
+        given()
+                .get("/self-signed/HttpClient/javax.net.ssl")
+                .then()
+                .statusCode(200)
+                .body(is("Hello self-signed!"));
+    }
+
+    @Test
+    public void fakeHost() {
+        given()
+                .get("/self-signed/HttpClient/fake-host")
+                .then()
+                .statusCode(500)
+                .body(containsStringIgnoringCase("unable to find valid certification path"));
     }
 
 }
diff --git a/integration-tests/rest-client/src/test/java/io/quarkus/it/rest/client/selfsigned/SelfSignedServiceTestResource.java b/integration-tests/rest-client/src/test/java/io/quarkus/it/rest/client/selfsigned/SelfSignedServiceTestResource.java
index 2e2a23ba5eb..13011706a26 100644
--- a/integration-tests/rest-client/src/test/java/io/quarkus/it/rest/client/selfsigned/SelfSignedServiceTestResource.java
+++ b/integration-tests/rest-client/src/test/java/io/quarkus/it/rest/client/selfsigned/SelfSignedServiceTestResource.java
@@ -2,6 +2,10 @@
 
 import java.io.File;
 import java.time.Duration;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.List;
 import java.util.Map;
 
 import io.quarkus.test.common.QuarkusTestResourceLifecycleManager;
@@ -14,7 +18,8 @@
 
 public class SelfSignedServiceTestResource implements QuarkusTestResourceLifecycleManager {
 
-    Vertx vertx = Vertx.vertx();
+    private Vertx vertx = Vertx.vertx();
+    private Map<String, String> originalProps = new HashMap<>();
 
     @Override
     public Map<String, String> start() {
@@ -24,14 +29,20 @@ public Map<String, String> start() {
         // We do not use the junit 5 plugin to avoid having to annotate all the tests to make sure the certs are
         // generated before the tests are run
         CertificateGenerator generator = new CertificateGenerator(file.toPath(), false);
-        CertificateRequest cr = new CertificateRequest()
-                .withName("self-signed")
-                .withFormat(Format.PKCS12)
-                .withPassword("changeit")
-                .withDuration(Duration.ofDays(2))
-                .withCN("localhost");
         try {
-            generator.generate(cr);
+            generator.generate(new CertificateRequest()
+                    .withName("self-signed")
+                    .withFormat(Format.PKCS12)
+                    .withPassword("changeit")
+                    .withDuration(Duration.ofDays(2))
+                    .withCN("localhost"));
+
+            generator.generate(new CertificateRequest()
+                    .withName("fake-host")
+                    .withFormat(Format.PKCS12)
+                    .withPassword("changeit")
+                    .withDuration(Duration.ofDays(2))
+                    .withCN("fake-host.com"));
         } catch (Exception e) {
             throw new RuntimeException(e);
         }
@@ -42,17 +53,52 @@ public Map<String, String> start() {
                         .setPath("target/certs/self-signed-keystore.p12")
                         .setPassword("changeit"));
         var server = vertx.createHttpServer(options)
-                .requestHandler(req -> req.response().end("OK"))
+                .requestHandler(req -> req.response().end("Hello self-signed!"))
                 .listen(-2).toCompletionStage().toCompletableFuture().join();
 
-        return Map.of(
+        setProperty("javax.net.ssl.trustStore", "target/certs/self-signed-truststore.p12");
+        setProperty("javax.net.ssl.trustStoreType", "PKCS12");
+        setProperty("javax.net.ssl.trustStorePassword", "changeit");
+
+        List<String> list = Arrays.asList(
+                "javax.net.ssl.trustStore", "target/certs/self-signed-truststore.p12",
+                "javax.net.ssl.trustStoreType", "PKCS12",
+                "javax.net.ssl.trustStorePassword", "changeit",
+
                 "quarkus.rest-client.self-signed.url", "https://localhost:" + server.actualPort() + "/",
                 "quarkus.rest-client.self-signed.trust-store", "target/certs/self-signed-truststore.p12",
-                "quarkus.rest-client.self-signed.trust-store-password", "changeit");
+                "quarkus.rest-client.self-signed.trust-store-password", "changeit",
+
+                "self-signed.port", String.valueOf(server.actualPort()),
+
+                "quarkus.tls.fake-host.trust-store.p12.path", "target/certs/fake-host-truststore.p12",
+                "quarkus.tls.fake-host.trust-store.p12.password", "changeit"
+
+        );
+        Map<String, String> result = new LinkedHashMap<>();
+        for (int i = 0; i < list.size(); i++) {
+            result.put(list.get(i++), list.get(i));
+        }
+        return result;
+    }
+
+    void setProperty(String k, String v) {
+        originalProps.put(k, System.getProperty(k));
+        System.setProperty(k, v);
+    }
+
+    void restoreProperty(String k) {
+        String v = originalProps.get(k);
+        if (v == null) {
+            System.getProperties().remove(k);
+        } else {
+            System.setProperty(k, v);
+        }
     }
 
     @Override
     public void stop() {
         vertx.close().toCompletionStage().toCompletableFuture().join();
+        originalProps.keySet().forEach(this::restoreProperty);
     }
 }
