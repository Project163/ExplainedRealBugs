diff --git a/extensions/panache/hibernate-orm-panache-kotlin/deployment/src/test/kotlin/io/quarkus/hibernate/orm/panache/kotlin/deployment/test/Bug50144Test.kt b/extensions/panache/hibernate-orm-panache-kotlin/deployment/src/test/kotlin/io/quarkus/hibernate/orm/panache/kotlin/deployment/test/Bug50144Test.kt
new file mode 100644
index 00000000000..602a2cc7f28
--- /dev/null
+++ b/extensions/panache/hibernate-orm-panache-kotlin/deployment/src/test/kotlin/io/quarkus/hibernate/orm/panache/kotlin/deployment/test/Bug50144Test.kt
@@ -0,0 +1,100 @@
+package io.quarkus.hibernate.orm.panache.kotlin.deployment.test
+
+import io.quarkus.hibernate.orm.panache.kotlin.PanacheRepositoryBase
+import io.quarkus.test.QuarkusUnitTest
+import jakarta.enterprise.context.ApplicationScoped
+import jakarta.inject.Inject
+import jakarta.persistence.Entity
+import jakarta.persistence.GeneratedValue
+import jakarta.persistence.GenerationType
+import jakarta.persistence.Id
+import jakarta.transaction.Transactional
+import org.jboss.shrinkwrap.api.ShrinkWrap
+import org.jboss.shrinkwrap.api.spec.JavaArchive
+import org.junit.jupiter.api.extension.RegisterExtension
+import org.junit.jupiter.api.assertThrows
+import org.junit.jupiter.api.Test
+import java.util.UUID
+
+class Bug50144Test {
+    companion object {
+        @RegisterExtension
+        @JvmField
+        var runner = QuarkusUnitTest()
+            .setArchiveProducer {
+                ShrinkWrap.create(JavaArchive::class.java)
+                    .addClasses(WorkingAssignmentRepository::class.java, BrokenAssignmentRepository::class.java,
+                        WorkingBaseRepository::class.java, BrokenBaseRepository::class.java,
+                        Assignment::class.java, NotFoundException::class.java)
+            }
+    }
+
+    @Inject
+    private lateinit var workingAssignmentRepository: WorkingAssignmentRepository
+
+    @Inject
+    private lateinit var brokenAssignmentRepository: BrokenAssignmentRepository
+
+    @Transactional
+    @Test
+    fun `A working example`() {
+        val id: UUID = UUID.randomUUID()
+
+        assertThrows<NotFoundException> {
+            workingAssignmentRepository.findByIdOrThrow(id)
+        }
+    }
+
+    @Transactional
+    @Test
+    fun `This breaks for some reason`() {
+        val id: UUID = UUID.randomUUID()
+
+        assertThrows<NotFoundException> {
+            brokenAssignmentRepository.findByIdOrThrow(id)
+        }
+    }
+
+    class NotFoundException: Exception()
+
+    @Entity
+    class Assignment {
+        @Id
+        @GeneratedValue(strategy = GenerationType.UUID)
+        private lateinit var _id: UUID
+    }
+
+    abstract class WorkingBaseRepository<EntityT : Any, IdT: Any> : PanacheRepositoryBase<EntityT, IdT> {
+        fun findByIdOrThrow(
+            id: IdT,
+            exception: (IdT) -> Exception,
+        ): EntityT = findById(id) ?: throw exception(id)
+    }
+
+    @ApplicationScoped
+    class WorkingAssignmentRepository : WorkingBaseRepository<Assignment, UUID>() {
+        fun findByIdOrThrow(assignmentId: UUID): Assignment {
+            return findByIdOrThrow(assignmentId) {
+                NotFoundException()
+            }
+        }
+    }
+
+    abstract class BrokenBaseRepository<EntityT : Any, IdT: UUID> : PanacheRepositoryBase<EntityT, IdT> {
+        fun findByIdOrThrow(
+            id: IdT,
+            exception: (IdT) -> Exception,
+        ): EntityT = findById(id) ?: throw exception(id)
+    }
+
+    @ApplicationScoped
+    class BrokenAssignmentRepository : BrokenBaseRepository<Assignment, UUID>() {
+        fun findByIdOrThrow(assignmentId: UUID): Assignment {
+            return findByIdOrThrow(assignmentId) {
+                NotFoundException()
+            }
+        }
+    }
+
+
+}
diff --git a/extensions/panache/panache-common/deployment/src/main/java/io/quarkus/panache/common/deployment/visitors/KotlinPanacheClassOperationGenerationVisitor.java b/extensions/panache/panache-common/deployment/src/main/java/io/quarkus/panache/common/deployment/visitors/KotlinPanacheClassOperationGenerationVisitor.java
index 9cebfdac72b..2a9ac1da319 100644
--- a/extensions/panache/panache-common/deployment/src/main/java/io/quarkus/panache/common/deployment/visitors/KotlinPanacheClassOperationGenerationVisitor.java
+++ b/extensions/panache/panache-common/deployment/src/main/java/io/quarkus/panache/common/deployment/visitors/KotlinPanacheClassOperationGenerationVisitor.java
@@ -4,7 +4,6 @@
 import static io.quarkus.deployment.util.AsmUtil.unboxIfRequired;
 import static io.quarkus.gizmo.Gizmo.ASM_API_VERSION;
 import static io.quarkus.panache.common.deployment.PanacheConstants.DOTNAME_GENERATE_BRIDGE;
-import static java.lang.String.format;
 import static java.util.stream.Collectors.toList;
 import static org.objectweb.asm.Opcodes.ACC_BRIDGE;
 import static org.objectweb.asm.Opcodes.ARRAYLENGTH;
@@ -25,10 +24,11 @@
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import java.util.StringJoiner;
-import java.util.TreeMap;
 import java.util.function.Function;
 
 import org.jboss.jandex.AnnotationInstance;
@@ -68,10 +68,11 @@ public class KotlinPanacheClassOperationGenerationVisitor extends ClassVisitor {
     protected final Function<String, Type> argMapper;
     protected final ClassInfo classInfo;
     protected final ByteCodeType entityUpperBound;
+    // These are type arguments to the Panache base entity/repo, not to the current or intermediate type
     protected final Map<String, ByteCodeType> typeArguments = new HashMap<>();
     private final ByteCodeType baseType;
-    private final Map<String, MethodInfo> definedMethods = new TreeMap<>();
-
+    private final Set<String> userMethods = new HashSet<>();
+    private final Set<String> baseTypeMethods = new HashSet<>();
     private final Map<String, String> erasures = new HashMap<>();
     private final IndexView indexView;
     protected List<PanacheMethodCustomizer> methodCustomizers;
@@ -101,10 +102,20 @@ public KotlinPanacheClassOperationGenerationVisitor(ClassVisitor outputClassVisi
                     ? byteCodeType.get()
                     : null;
         };
+        loadBaseTypeMethods();
+    }
 
-        collectMethods(classInfo);
-        filterNonOverrides();
-
+    /**
+     * This loads the signatures of every base type method that requires a bridge
+     */
+    private void loadBaseTypeMethods() {
+        for (MethodInfo method : indexView.getClassByName(baseType.dotName()).methods()) {
+            String descriptor = method.descriptor(type -> typeArguments.getOrDefault(type, OBJECT).get());
+            AnnotationInstance bridge = method.annotation(DOTNAME_GENERATE_BRIDGE);
+            if (bridge != null) {
+                baseTypeMethods.add(method.name() + "/" + descriptor);
+            }
+        }
     }
 
     public static List<ByteCodeType> recursivelyFindEntityTypeArguments(IndexView indexView, DotName clazz,
@@ -217,27 +228,6 @@ private void checkCast(MethodVisitor mv, Type returnType, String operationReturn
         }
     }
 
-    private void collectMethods(ClassInfo classInfo) {
-        if (classInfo != null && !classInfo.name().equals(baseType.dotName())) {
-            classInfo.methods()
-                    .forEach(method -> {
-                        String descriptor = method.descriptor(m -> {
-                            ByteCodeType byteCodeType = typeArguments.get(m);
-                            return byteCodeType != null ? byteCodeType.get() : OBJECT.get();
-                        });
-                        MethodInfo prior = definedMethods.put(method.name() + descriptor, method);
-                        if (prior != null && !isBridgeMethod(method)) {
-                            throw new IllegalStateException(format("Should not run in to duplicate " +
-                                    "mappings: \n\t%s\n\t%s\n\t%s", method, descriptor, prior));
-                        }
-                    });
-            DotName superName = classInfo.superName();
-            if (superName != null) {
-                collectMethods(indexView.getClassByName(superName));
-            }
-        }
-    }
-
     private String desc(String name) {
         String s = name.replace(".", "/");
         return s.startsWith("[") ? s : "L" + s + ";";
@@ -313,16 +303,6 @@ private Label endLabel() {
         return labels.get(labels.size() - 1);
     }
 
-    private void filterNonOverrides() {
-        new ArrayList<>(definedMethods.values())
-                .forEach(method -> {
-                    AnnotationInstance generateBridge = method.annotation(DOTNAME_GENERATE_BRIDGE);
-                    if (generateBridge != null) {
-                        definedMethods.remove(method.name() + method.descriptor());
-                    }
-                });
-    }
-
     private void generate(MethodInfo method) {
         // Note: we can't use SYNTHETIC here because otherwise Mockito will never mock these methods
         MethodVisitor mv = cv.visitMethod(Opcodes.ACC_PUBLIC, method.name(),
@@ -460,10 +440,6 @@ private void invokeOperation(MethodVisitor mv, MethodInfo method) {
         mv.visitInsn(AsmUtil.getReturnInstruction(returnType));
     }
 
-    private boolean isBridgeMethod(MethodInfo method) {
-        return (method.flags() & ACC_BRIDGE) != ACC_BRIDGE;
-    }
-
     private org.objectweb.asm.Type asmType(Type methodParameter) {
         org.objectweb.asm.Type parameter;
         if (methodParameter.kind() == Type.Kind.TYPE_VARIABLE) {
@@ -531,23 +507,15 @@ public String toString() {
     @Override
     public MethodVisitor visitMethod(int access, String name, String descriptor, String signature,
             String[] exceptions) {
-
-        MethodInfo methodInfo = definedMethods.entrySet().stream()
-                .filter(e -> e.getKey().equals(name + descriptor))
-                .map(e -> e.getValue())
-                .findFirst()
-                .orElse(null);
-        if (methodInfo != null && !methodInfo.hasAnnotation(DOTNAME_GENERATE_BRIDGE)) {
-            return super.visitMethod(access, name, descriptor, signature, exceptions);
-        } else if (name.contains("$")) {
-            //some agents such as jacoco add new methods, they generally have $ in the name
-            return super.visitMethod(access, name, descriptor, signature, exceptions);
-        } else if (name.equals(CTOR_METHOD_NAME) || name.equals(CLINIT_METHOD_NAME)) {
-            //Arc can add no-args constructors to support intercepted beans
-            // Logging with Panache can add a class initializer
-            return super.visitMethod(access, name, descriptor, signature, exceptions);
+        // Kotlinc or something will add bridge methods for the base type methods, these are not user methods
+        // so we filter them out since we add them back in visitEnd()
+        String sig = name + "/" + descriptor;
+        if ((access & Opcodes.ACC_BRIDGE) != 0
+                && baseTypeMethods.contains(sig)) {
+            return null;
         }
-        return null;
+        userMethods.add(sig);
+        return super.visitMethod(access, name, descriptor, signature, exceptions);
     }
 
     @Override
@@ -555,14 +523,14 @@ public void visitEnd() {
         for (MethodInfo method : indexView.getClassByName(baseType.dotName()).methods()) {
             String descriptor = method.descriptor(type -> typeArguments.getOrDefault(type, OBJECT).get());
             AnnotationInstance bridge = method.annotation(DOTNAME_GENERATE_BRIDGE);
-            if (!definedMethods.containsKey(method.name() + descriptor) && bridge != null) {
+            if (!userMethods.contains(method.name() + "/" + descriptor) && bridge != null) {
                 generate(method);
                 if (needsJvmBridge(method)) {
                     String bridgeDescriptor = bridgeMethodDescriptor(method, type -> {
                         ByteCodeType mapped = typeArguments.get(type);
                         return mapped != null ? mapped.get() : null;
                     });
-                    if (!definedMethods.containsKey(method.name() + bridgeDescriptor)) {
+                    if (!userMethods.contains(method.name() + "/" + bridgeDescriptor)) {
                         generateBridge(method, bridgeDescriptor);
                     }
 
