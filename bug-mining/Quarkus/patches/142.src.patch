diff --git a/core/runtime/src/main/java/io/quarkus/runtime/logging/LogMetricsHandler.java b/core/runtime/src/main/java/io/quarkus/runtime/logging/LogMetricsHandler.java
index f2cec8f96c2..d9fd436f064 100644
--- a/core/runtime/src/main/java/io/quarkus/runtime/logging/LogMetricsHandler.java
+++ b/core/runtime/src/main/java/io/quarkus/runtime/logging/LogMetricsHandler.java
@@ -3,9 +3,9 @@
 import java.util.Map.Entry;
 import java.util.NavigableMap;
 import java.util.concurrent.atomic.LongAdder;
-import java.util.logging.Handler;
-import java.util.logging.LogRecord;
 
+import org.jboss.logmanager.ExtHandler;
+import org.jboss.logmanager.ExtLogRecord;
 import org.jboss.logmanager.Level;
 
 /**
@@ -16,7 +16,7 @@
  * <p>
  * Non-standard levels are counted with the lower standard level.
  */
-public class LogMetricsHandler extends Handler {
+public class LogMetricsHandler extends ExtHandler {
 
     final NavigableMap<Integer, LongAdder> logCounters;
 
@@ -25,15 +25,13 @@ public LogMetricsHandler(NavigableMap<Integer, LongAdder> logCounters) {
     }
 
     @Override
-    public void publish(LogRecord record) {
-        if (isLoggable(record)) {
-            Entry<Integer, LongAdder> counter = logCounters.floorEntry(record.getLevel().intValue());
-            if (counter != null) {
-                counter.getValue().increment();
-            } else {
-                // Default to TRACE for anything lower
-                logCounters.get(Level.TRACE.intValue()).increment();
-            }
+    protected void doPublish(ExtLogRecord record) {
+        Entry<Integer, LongAdder> counter = logCounters.floorEntry(record.getLevel().intValue());
+        if (counter != null) {
+            counter.getValue().increment();
+        } else {
+            // Default to TRACE for anything lower
+            logCounters.get(Level.TRACE.intValue()).increment();
         }
     }
 
diff --git a/core/runtime/src/main/java/io/quarkus/runtime/logging/LoggingSetupRecorder.java b/core/runtime/src/main/java/io/quarkus/runtime/logging/LoggingSetupRecorder.java
index 2d390ab877d..3d8fe47a079 100644
--- a/core/runtime/src/main/java/io/quarkus/runtime/logging/LoggingSetupRecorder.java
+++ b/core/runtime/src/main/java/io/quarkus/runtime/logging/LoggingSetupRecorder.java
@@ -33,6 +33,8 @@
 import org.eclipse.microprofile.config.ConfigProvider;
 import org.eclipse.microprofile.config.spi.ConfigSource;
 import org.jboss.logmanager.ExtFormatter;
+import org.jboss.logmanager.ExtHandler;
+import org.jboss.logmanager.ExtLogRecord;
 import org.jboss.logmanager.LogContext;
 import org.jboss.logmanager.LogContextInitializer;
 import org.jboss.logmanager.Logger;
@@ -183,9 +185,9 @@ public void accept(String loggerName, CleanupFilterConfig config) {
             handlers.add(consoleHandler);
         }
         if (launchMode.isDevOrTest()) {
-            handlers.add(new Handler() {
+            handlers.add(new ExtHandler() {
                 @Override
-                public void publish(LogRecord record) {
+                protected void doPublish(ExtLogRecord record) {
                     if (record.getThrown() != null) {
                         ExceptionReporting.notifyException(record.getThrown());
                     }
@@ -613,9 +615,9 @@ private static Handler configureConsoleHandler(
 
         if (color && launchMode.isDevOrTest() && !config.async().enable()) {
             final Handler delegate = handler;
-            handler = new Handler() {
+            handler = new ExtHandler() {
                 @Override
-                public void publish(LogRecord record) {
+                protected void doPublish(ExtLogRecord record) {
                     BiConsumer<LogRecord, Consumer<LogRecord>> formatter = CurrentAppExceptionHighlighter.THROWABLE_FORMATTER;
                     if (formatter != null) {
                         formatter.accept(record, delegate::publish);
diff --git a/extensions/opentelemetry/runtime/src/main/java/io/quarkus/opentelemetry/runtime/logs/OpenTelemetryLogHandler.java b/extensions/opentelemetry/runtime/src/main/java/io/quarkus/opentelemetry/runtime/logs/OpenTelemetryLogHandler.java
index 9c4606ea68e..65e2de1270e 100644
--- a/extensions/opentelemetry/runtime/src/main/java/io/quarkus/opentelemetry/runtime/logs/OpenTelemetryLogHandler.java
+++ b/extensions/opentelemetry/runtime/src/main/java/io/quarkus/opentelemetry/runtime/logs/OpenTelemetryLogHandler.java
@@ -13,12 +13,11 @@
 import java.time.Instant;
 import java.util.Map;
 import java.util.Optional;
-import java.util.logging.Handler;
 import java.util.logging.Level;
-import java.util.logging.LogRecord;
 
 import org.eclipse.microprofile.config.Config;
 import org.eclipse.microprofile.config.ConfigProvider;
+import org.jboss.logmanager.ExtHandler;
 import org.jboss.logmanager.ExtLogRecord;
 
 import io.opentelemetry.api.OpenTelemetry;
@@ -28,7 +27,7 @@
 import io.opentelemetry.api.logs.LogRecordBuilder;
 import io.opentelemetry.api.logs.Severity;
 
-public class OpenTelemetryLogHandler extends Handler {
+public class OpenTelemetryLogHandler extends ExtHandler {
 
     private final OpenTelemetry openTelemetry;
 
@@ -37,7 +36,7 @@ public OpenTelemetryLogHandler(final OpenTelemetry openTelemetry) {
     }
 
     @Override
-    public void publish(LogRecord record) {
+    protected void doPublish(ExtLogRecord record) {
         if (openTelemetry == null) {
             return; // might happen at shutdown
         }
@@ -60,24 +59,22 @@ public void publish(LogRecord record) {
         attributes.put(CODE_NAMESPACE, record.getSourceClassName());
         attributes.put(CODE_FUNCTION, record.getSourceMethodName());
 
-        if (record instanceof ExtLogRecord) {
-            attributes.put(CODE_LINENO, ((ExtLogRecord) record).getSourceLineNumber());
-            attributes.put(THREAD_NAME, ((ExtLogRecord) record).getThreadName());
-            attributes.put(THREAD_ID, ((ExtLogRecord) record).getLongThreadID());
-            attributes.put(AttributeKey.stringKey("log.logger.namespace"),
-                    ((ExtLogRecord) record).getLoggerClassName());
-
-            final Map<String, String> mdcCopy = ((ExtLogRecord) record).getMdcCopy();
-            if (mdcCopy != null) {
-                mdcCopy.forEach((k, v) -> {
-                    // ignore duplicated span data already in the MDC
-                    if (!k.toLowerCase().equals("spanid") &&
-                            !k.toLowerCase().equals("traceid") &&
-                            !k.toLowerCase().equals("sampled")) {
-                        attributes.put(AttributeKey.stringKey(k), v);
-                    }
-                });
-            }
+        attributes.put(CODE_LINENO, record.getSourceLineNumber());
+        attributes.put(THREAD_NAME, record.getThreadName());
+        attributes.put(THREAD_ID, record.getLongThreadID());
+        attributes.put(AttributeKey.stringKey("log.logger.namespace"),
+                record.getLoggerClassName());
+
+        final Map<String, String> mdcCopy = record.getMdcCopy();
+        if (mdcCopy != null) {
+            mdcCopy.forEach((k, v) -> {
+                // ignore duplicated span data already in the MDC
+                if (!k.equalsIgnoreCase("spanid") &&
+                        !k.equalsIgnoreCase("traceid") &&
+                        !k.equalsIgnoreCase("sampled")) {
+                    attributes.put(AttributeKey.stringKey(k), v);
+                }
+            });
         }
 
         if (record.getThrown() != null) {
