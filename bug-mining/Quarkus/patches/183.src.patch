diff --git a/docs/src/main/asciidoc/qute-reference.adoc b/docs/src/main/asciidoc/qute-reference.adoc
index 3b4bfc72a95..503a1cc511a 100644
--- a/docs/src/main/asciidoc/qute-reference.adoc
+++ b/docs/src/main/asciidoc/qute-reference.adoc
@@ -1258,8 +1258,8 @@ This is {#insert title}my title{/title}! <1>
 [[fragments]]
 ==== Fragments
 
-A fragment represents a part of the template that can be treated as a separate template, i.e. rendered separately.
-One of the main motivations to introduce this feature was to support use cases like https://htmx.org/essays/template-fragments/[htmx fragments].
+A fragment represents a part of a template that can be treated as a separate template, i.e. rendered separately.
+One of the main motivations to introduce this feature was the support of use cases like https://htmx.org/essays/template-fragments/[htmx fragments].
 
 Fragments can be defined with the `{#fragment}` section.
 Each fragment has an identifier that can only consist of alphanumeric characters and underscores.
@@ -1285,7 +1285,7 @@ NOTE: Note that a fragment identifier must be unique in a template.
 </ol>
 {/fragment}
 ----
-<1> Defines a fragment with identifier `item_aliases`. Note that only alphanumeric characters and underscores can be used in the identifier.
+<1> Defines a fragment with identifier `item_aliases`. Note that only alphanumeric characters and underscores can be used in the identifier. The name of the first parameter can be omitted - `{#fragment item_aliases}` is fine too. 
 
 You can obtain a fragment programmatically via the `io.quarkus.qute.Template.getFragment(String)` method.
 
@@ -1318,49 +1318,63 @@ The snippet above should render something like:
 TIP: In Quarkus, it is also possible to define a <<type_safe_fragments,type-safe fragment>>.
 
 You can also include a fragment with an `{#include}` section inside another template or the template that defines the fragment.
+A fragment can be also used in expressions with the `frg:`/`fragment:` namespaces.
 
 .Including a Fragment in `user.html`
 [source,html]
 ----
 <h1>User - {user.name}</h1>
 
+<p>
+{#fragment fullname}
+{name} <strong>{surname}</strong>
+{/fragment}
+</p>
+
 <p>This document contains a detailed info about a user.</p>
 
 {#include item$item_aliases aliases=user.aliases /} <1><2>
+
+{frg:fullname} is a happy user! <3>
 ----
 <1> A template identifier that contains a dollar sign `$` denotes a fragment. The `item$item_aliases` value is translated as: _Use the fragment `item_aliases` from the template `item`._
 <2> The `aliases` parameter is used to pass the relevant data. We need to make sure that the data are set correctly. In this particular case the fragment will use the expression `user.aliases` as the value of `aliases` in the `{#for alias in aliases}` section.
+<3> The `{frg:username}` expression outputs the fragment content. `frg:` can be replaced with `fragment:`.
 
 TIP: If you want to reference a fragment from the same template, skip the part before `$`, i.e. something like `{#include $item_aliases /}`.
 
 NOTE: You can specify `{#include item$item_aliases _ignoreFragments=true /}` in order to disable this feature, i.e. a dollar sign `$` in the template identifier does not result in a fragment lookup.
 
-===== Hidden Fragments
+
+===== Hidden Fragments (Capture)
 
 By default, a fragment is normally rendered as a part of the original template.
-However, sometimes it might be useful to mark a fragment as _hidden_ with `rendered=false`.
-An interesting use case would be a fragment that can be used multiple-times inside the template that defines it.
+However, sometimes it might be useful to mark a fragment as _hidden_.
+The regular fragment section has the `capture` alias that implies a hidden fragment.
+Alternatively, you can "hide" a fragment either with `rendered=false` or `_hidden` parameters.
+An interesting use case could be a fragment that can be used multiple-times inside the template that defines it.
 
-.Fragment Definition in `item.html`
+.Hidden Fragment Definition in `item.html`
 [source,html]
 ----
-{#fragment id=strong rendered=false} <1>
+{#capture strong} <1>
 <strong>{val}</strong>
-{/fragment}
+{/capture}
 
 <h1>My page</h1>
 <p>This document
 {#include $strong val='contains' /} <2>
 a lot of
-{#include $strong val='information' /} <3>
+{capture:strong(param:val = 'information')} <3> <4>
 !</p>
 ----
 <1> Defines a hidden fragment with identifier `strong`.
-In this particular case, we use the `false` boolean literal as the value of the `rendered` parameter.
-However, it's possible to use any expression there.
+`{#capture strong}` can be replaced with `{#fragment strong rendered=false}` or `{#fragment strong _hidden}`.
+The `rendered` parameter can use any expression, e.g. `{#fragment strong rendered=config.isRendered}`.
 <2> Include the fragment `strong` and pass the value.
 Note the syntax `$strong` which is translated to include the fragment `strong` from the current template.
-<3> Include the fragment `strong` and pass the value.
+<3> A namespace resolver can be used to access a hidden fragment too. `capture:` can be replaced with `cap:`.
+<4> `param:val = 'information'` is used to pass a named parameter to the fragment. 
 
 The snippet above renders something like:
 
@@ -1374,6 +1388,8 @@ a lot of
 !</p>
 ----
 
+TIP: In Quarkus, the namespace resolvers are automatically registered for namespaces `frg`, `fragment`, `cap` and `capture`.
+
 ==== Eval Section
 
 This section can be used to parse and evaluate a template dynamically.
diff --git a/extensions/qute/deployment/src/test/java/io/quarkus/qute/deployment/fragment/HiddenFragmentsTest.java b/extensions/qute/deployment/src/test/java/io/quarkus/qute/deployment/fragment/HiddenFragmentsTest.java
new file mode 100644
index 00000000000..d2d1bed11a8
--- /dev/null
+++ b/extensions/qute/deployment/src/test/java/io/quarkus/qute/deployment/fragment/HiddenFragmentsTest.java
@@ -0,0 +1,50 @@
+package io.quarkus.qute.deployment.fragment;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+
+import jakarta.inject.Inject;
+
+import org.jboss.shrinkwrap.api.asset.StringAsset;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.RegisterExtension;
+
+import io.quarkus.qute.Template;
+import io.quarkus.test.QuarkusUnitTest;
+
+public class HiddenFragmentsTest {
+
+    @RegisterExtension
+    static final QuarkusUnitTest config = new QuarkusUnitTest()
+            .withApplicationRoot(root -> root
+                    .addAsResource(new StringAsset("""
+                            {#capture faClass}
+                            {#when type}
+                              {#is "info"}
+                                fa fa-lightbulb
+                              {#is "warning"}
+                                fa fa-exclamation-triangle
+                              {#is "error"}
+                                fa fa-times-circle
+                              {#is "success"}
+                                fa fa-check-circle
+                              {#is "question"}
+                                fa fa-question-circle
+                              {#else}
+                                fa fa-info-circle
+                              {/when}
+                            {/}
+                            <i class="{capture:faClass(param:type = type.or(anotherType)).strip}"></i>::{capture:faClass.strip}
+                                                        """), "templates/hide.html"));
+
+    @Inject
+    Template hide;
+
+    @Test
+    public void testResolvers() {
+        assertEquals("<i class=\"fa fa-times-circle\"></i>::fa fa-times-circle",
+                hide.data("type", "error", "anotherType", "foo").render().strip());
+        assertEquals("<i class=\"fa fa-question-circle\"></i>::fa fa-info-circle",
+                hide.data("type", null, "anotherType", "question").render().strip());
+    }
+
+}
diff --git a/extensions/qute/runtime/src/main/java/io/quarkus/qute/runtime/EngineProducer.java b/extensions/qute/runtime/src/main/java/io/quarkus/qute/runtime/EngineProducer.java
index 2f8e73f8529..a09d9e85d15 100644
--- a/extensions/qute/runtime/src/main/java/io/quarkus/qute/runtime/EngineProducer.java
+++ b/extensions/qute/runtime/src/main/java/io/quarkus/qute/runtime/EngineProducer.java
@@ -20,6 +20,14 @@
 import java.util.concurrent.ConcurrentMap;
 import java.util.regex.Pattern;
 
+import jakarta.enterprise.context.ApplicationScoped;
+import jakarta.enterprise.context.Dependent;
+import jakarta.enterprise.event.Event;
+import jakarta.enterprise.event.Observes;
+import jakarta.enterprise.inject.Produces;
+import jakarta.inject.Singleton;
+import jakarta.interceptor.Interceptor;
+
 import org.jboss.logging.Logger;
 
 import io.quarkus.arc.All;
@@ -35,6 +43,7 @@
 import io.quarkus.qute.HtmlEscaper;
 import io.quarkus.qute.ImmutableList;
 import io.quarkus.qute.JsonEscaper;
+import io.quarkus.qute.NamedArgument;
 import io.quarkus.qute.NamespaceResolver;
 import io.quarkus.qute.ParserHook;
 import io.quarkus.qute.Qute;
@@ -58,13 +67,6 @@
 import io.quarkus.runtime.LocalesBuildTimeConfig;
 import io.quarkus.runtime.ShutdownEvent;
 import io.quarkus.runtime.Startup;
-import jakarta.enterprise.context.ApplicationScoped;
-import jakarta.enterprise.context.Dependent;
-import jakarta.enterprise.event.Event;
-import jakarta.enterprise.event.Observes;
-import jakarta.enterprise.inject.Produces;
-import jakarta.inject.Singleton;
-import jakarta.interceptor.Interceptor;
 
 @Startup(Interceptor.Priority.PLATFORM_BEFORE)
 @Singleton
@@ -129,6 +131,8 @@ public EngineProducer(QuteContext context, QuteConfig config, QuteRuntimeConfig
         builder.addValueResolver(ValueResolvers.orEmpty());
         // Note that arrays are handled specifically during validation
         builder.addValueResolver(ValueResolvers.arrayResolver());
+        // Named arguments for fragment namespace resolver
+        builder.addValueResolver(new NamedArgument.SetValueResolver());
         // Additional value resolvers
         for (ValueResolver valueResolver : valueResolvers) {
             builder.addValueResolver(valueResolver);
@@ -197,6 +201,12 @@ public EngineProducer(QuteContext context, QuteConfig config, QuteRuntimeConfig
         }
         // str:eval
         builder.addNamespaceResolver(new StrEvalNamespaceResolver());
+        // Fragment namespace resolvers
+        builder.addNamespaceResolver(new NamedArgument.ParamNamespaceResolver());
+        builder.addNamespaceResolver(new FragmentNamespaceResolver(FragmentNamespaceResolver.FRAGMENT));
+        builder.addNamespaceResolver(new FragmentNamespaceResolver(FragmentNamespaceResolver.FRG));
+        builder.addNamespaceResolver(new FragmentNamespaceResolver(FragmentNamespaceResolver.CAPTURE));
+        builder.addNamespaceResolver(new FragmentNamespaceResolver(FragmentNamespaceResolver.CAP));
 
         // Add generated resolvers
         for (String resolverClass : context.getResolverClasses()) {
diff --git a/extensions/qute/runtime/src/main/java/io/quarkus/qute/runtime/TemplateProducer.java b/extensions/qute/runtime/src/main/java/io/quarkus/qute/runtime/TemplateProducer.java
index ae7d0519d5e..66c6b5644d2 100644
--- a/extensions/qute/runtime/src/main/java/io/quarkus/qute/runtime/TemplateProducer.java
+++ b/extensions/qute/runtime/src/main/java/io/quarkus/qute/runtime/TemplateProducer.java
@@ -34,6 +34,7 @@
 import io.quarkus.qute.ParameterDeclaration;
 import io.quarkus.qute.RenderedResults;
 import io.quarkus.qute.ResultsCollectingTemplateInstance;
+import io.quarkus.qute.SectionNode;
 import io.quarkus.qute.Template;
 import io.quarkus.qute.TemplateInstance;
 import io.quarkus.qute.TemplateInstanceBase;
@@ -172,6 +173,14 @@ public Template get() {
             this.renderedResults = renderedResults;
         }
 
+        @Override
+        public SectionNode getRootNode() {
+            if (unambiguousTemplate != null) {
+                return unambiguousTemplate.get().getRootNode();
+            }
+            throw ambiguousTemplates("getRootNode()");
+        }
+
         @Override
         public TemplateInstance instance() {
             TemplateInstance instance = new InjectableTemplateInstanceImpl();
@@ -322,6 +331,11 @@ public List<TemplateNode> getNodes() {
                 return InjectableTemplate.this.getNodes();
             }
 
+            @Override
+            public SectionNode getRootNode() {
+                return InjectableTemplate.this.getRootNode();
+            }
+
             @Override
             public Collection<TemplateNode> findNodes(Predicate<TemplateNode> predicate) {
                 return InjectableTemplate.this.findNodes(predicate);
diff --git a/independent-projects/qute/core/src/main/java/io/quarkus/qute/EvalSectionHelper.java b/independent-projects/qute/core/src/main/java/io/quarkus/qute/EvalSectionHelper.java
index fa23c592a8b..93b6217363d 100644
--- a/independent-projects/qute/core/src/main/java/io/quarkus/qute/EvalSectionHelper.java
+++ b/independent-projects/qute/core/src/main/java/io/quarkus/qute/EvalSectionHelper.java
@@ -55,10 +55,10 @@ public CompletionStage<ResultNode> resolve(SectionResolutionContext context) {
     }
 
     private void parseAndResolve(CompletableFuture<ResultNode> ret, String contents, ResolutionContext resolutionContext) {
-        TemplateImpl template;
+        Template template;
         try {
-            template = (TemplateImpl) engine.parse(contents);
-            template.root
+            template = engine.parse(contents);
+            template.getRootNode()
                     .resolve(resolutionContext)
                     .whenComplete((resultNode, t2) -> {
                         if (t2 != null) {
diff --git a/independent-projects/qute/core/src/main/java/io/quarkus/qute/FragmentNamespaceResolver.java b/independent-projects/qute/core/src/main/java/io/quarkus/qute/FragmentNamespaceResolver.java
new file mode 100644
index 00000000000..fcf27459ba4
--- /dev/null
+++ b/independent-projects/qute/core/src/main/java/io/quarkus/qute/FragmentNamespaceResolver.java
@@ -0,0 +1,133 @@
+package io.quarkus.qute;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionStage;
+import java.util.concurrent.ExecutionException;
+
+import io.quarkus.qute.EngineBuilder.EngineListener;
+import io.quarkus.qute.Template.Fragment;
+
+/**
+ * Renders a matching fragment from the current template.
+ *
+ * @see FragmentSectionHelper
+ */
+public class FragmentNamespaceResolver implements NamespaceResolver, EngineListener {
+
+    public static final String FRG = "frg";
+    public static final String FRAGMENT = "fragment";
+    public static final String CAP = "cap";
+    public static final String CAPTURE = "capture";
+
+    private final String namespace;
+
+    private final int priority;
+
+    private volatile Engine engine;
+
+    public FragmentNamespaceResolver() {
+        this(FRG, -1);
+    }
+
+    public FragmentNamespaceResolver(String namespace) {
+        this(namespace, -1);
+    }
+
+    public FragmentNamespaceResolver(String namespace, int priority) {
+        this.namespace = namespace;
+        this.priority = priority;
+    }
+
+    @Override
+    public void engineBuilt(Engine engine) {
+        this.engine = engine;
+    }
+
+    @Override
+    public CompletionStage<Object> resolve(EvalContext context) {
+        String id = context.getName();
+        Template template = null;
+        int idx = id.lastIndexOf('$');
+        if (idx != -1) {
+            // the part before the last occurence of a dollar sign is the template identifier
+            String templateId = id.substring(0, idx);
+            Engine e = engine;
+            if (e == null) {
+                throw new TemplateException("Engine not set");
+            }
+            template = e.getTemplate(templateId);
+            if (template == null) {
+                throw new TemplateException("Template not found: " + templateId);
+            }
+            // the part after the last occurence of a dollar sign is the fragment identifier
+            id = id.substring(idx + 1);
+        } else {
+            template = context.resolutionContext().getTemplate();
+        }
+        Fragment fragment = template.getFragment(id);
+        if (fragment != null) {
+            CompletableFuture<Object> ret = new CompletableFuture<>();
+            if (!context.getParams().isEmpty()) {
+                EvaluatedParams params = EvaluatedParams.evaluate(context);
+                params.stage.whenComplete((r, t) -> {
+                    if (t != null) {
+                        ret.completeExceptionally(t);
+                    } else {
+                        Map<String, Object> args = new HashMap<>();
+                        for (int i = 0; i < context.getParams().size(); i++) {
+                            try {
+                                Object result = params.getResult(i);
+                                if (result instanceof NamedArgument arg) {
+                                    args.put(arg.getName(), arg.getValue());
+                                } else {
+                                    ret.completeExceptionally(
+                                            new TemplateException("Named argument expected: " + result.getClass()));
+                                    break;
+                                }
+                            } catch (InterruptedException | ExecutionException e) {
+                                ret.completeExceptionally(e);
+                            }
+                        }
+                        ResolutionContext child = context.resolutionContext().createChild(Mapper.wrap(args), null);
+                        fragment.getRootNode().resolve(child, Map.of(Template.Fragment.ATTRIBUTE, true))
+                                .whenComplete((r2, t2) -> {
+                                    if (t2 != null) {
+                                        ret.completeExceptionally(t2);
+                                    } else {
+                                        StringBuilder sb = new StringBuilder();
+                                        r2.process(sb::append);
+                                        ret.complete(sb.toString());
+                                    }
+                                });
+                    }
+                });
+            } else {
+                fragment.getRootNode().resolve(context.resolutionContext(), Map.of(Template.Fragment.ATTRIBUTE, true))
+                        .whenComplete((r, t) -> {
+                            if (t != null) {
+                                ret.completeExceptionally(t);
+                            } else {
+                                StringBuilder sb = new StringBuilder();
+                                r.process(sb::append);
+                                ret.complete(sb.toString());
+                            }
+                        });
+            }
+            return ret;
+        }
+        return Results.notFound(context);
+    }
+
+    @Override
+    public int getPriority() {
+        return priority;
+    }
+
+    @Override
+    public String getNamespace() {
+        return namespace;
+    }
+
+}
diff --git a/independent-projects/qute/core/src/main/java/io/quarkus/qute/FragmentSectionHelper.java b/independent-projects/qute/core/src/main/java/io/quarkus/qute/FragmentSectionHelper.java
index dcb28af1054..001d7901d8c 100644
--- a/independent-projects/qute/core/src/main/java/io/quarkus/qute/FragmentSectionHelper.java
+++ b/independent-projects/qute/core/src/main/java/io/quarkus/qute/FragmentSectionHelper.java
@@ -39,9 +39,13 @@ public CompletionStage<ResultNode> resolve(SectionResolutionContext context) {
         if (isAlwaysExecuted(context)) {
             return context.execute();
         }
-        return context.resolutionContext().evaluate(rendered).thenCompose(r -> {
-            return Booleans.isFalsy(r) ? ResultNode.NOOP : context.execute();
-        });
+        if (rendered.isLiteral()) {
+            return Booleans.isFalsy(rendered.getLiteral()) ? ResultNode.NOOP : context.execute();
+        } else {
+            return context.resolutionContext().evaluate(rendered).thenCompose(r -> {
+                return Booleans.isFalsy(r) ? ResultNode.NOOP : context.execute();
+            });
+        }
     }
 
     private boolean isAlwaysExecuted(SectionResolutionContext context) {
@@ -60,12 +64,14 @@ public static class Factory implements SectionHelperFactory<FragmentSectionHelpe
         static final Pattern FRAGMENT_PATTERN = Pattern.compile("[a-zA-Z0-9_]+");
 
         static final String RENDERED = "rendered";
+        static final String HIDDEN = "_hidden";
+        static final String CAPTURE = "capture";
 
         private final Map<String, Map<String, Origin>> templateToFragments = new ConcurrentHashMap<>();
 
         @Override
         public List<String> getDefaultAliases() {
-            return ImmutableList.of("fragment");
+            return ImmutableList.of("fragment", CAPTURE);
         }
 
         @Override
@@ -73,6 +79,7 @@ public ParametersInfo getParameters() {
             return ParametersInfo.builder()
                     .addParameter(ID)
                     .addParameter(Parameter.builder(RENDERED).ignoreUnnamedValues().optional().build())
+                    .addParameter(Parameter.builder(HIDDEN).optional().valuePredicate(HIDDEN::equals).build())
                     .build();
         }
 
@@ -109,7 +116,15 @@ public FragmentSectionHelper initialize(SectionInitContext context) {
                             .build();
                 }
             }
-            return new FragmentSectionHelper(id, context.getExpression(RENDERED), generatedId);
+            Expression rendered = null;
+            if (context.getName().equals(CAPTURE)) {
+                rendered = ExpressionImpl.literalFrom(-1, "false");
+            } else if (context.hasParameter(RENDERED)) {
+                rendered = context.getExpression(RENDERED);
+            } else if (context.hasParameter(HIDDEN)) {
+                rendered = ExpressionImpl.literalFrom(-1, "false");
+            }
+            return new FragmentSectionHelper(id, rendered, generatedId);
         }
 
         @Override
diff --git a/independent-projects/qute/core/src/main/java/io/quarkus/qute/IncludeSectionHelper.java b/independent-projects/qute/core/src/main/java/io/quarkus/qute/IncludeSectionHelper.java
index e1726b774bd..67e47dfd254 100644
--- a/independent-projects/qute/core/src/main/java/io/quarkus/qute/IncludeSectionHelper.java
+++ b/independent-projects/qute/core/src/main/java/io/quarkus/qute/IncludeSectionHelper.java
@@ -37,7 +37,7 @@ public CompletionStage<ResultNode> resolve(SectionResolutionContext context) {
         if (parameters.isEmpty() && optimizeIfNoParams()) {
             // No params
             Template t = template.get();
-            SectionNode root = ((TemplateImpl) t).root;
+            SectionNode root = t.getRootNode();
             ResolutionContext resolutionContext;
             if (isIsolated) {
                 resolutionContext = context.newResolutionContext(null, extendingBlocks);
diff --git a/independent-projects/qute/core/src/main/java/io/quarkus/qute/NamedArgument.java b/independent-projects/qute/core/src/main/java/io/quarkus/qute/NamedArgument.java
new file mode 100644
index 00000000000..8c94b4abff0
--- /dev/null
+++ b/independent-projects/qute/core/src/main/java/io/quarkus/qute/NamedArgument.java
@@ -0,0 +1,81 @@
+package io.quarkus.qute;
+
+import java.util.concurrent.CompletionStage;
+
+/**
+ * Used to supply named arguments for {@link FragmentNamespaceResolver}.
+ */
+public final class NamedArgument {
+
+    private final String name;
+
+    private volatile Object value;
+
+    public NamedArgument(String name) {
+        this.name = name;
+    }
+
+    public Object getValue() {
+        return value;
+    }
+
+    public NamedArgument setValue(Object value) {
+        this.value = value;
+        return this;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public static final class ParamNamespaceResolver implements NamespaceResolver {
+
+        private final String name;
+
+        private final int priority;
+
+        public ParamNamespaceResolver() {
+            this("param", -1);
+        }
+
+        public ParamNamespaceResolver(String name, int priority) {
+            this.name = name;
+            this.priority = priority;
+        }
+
+        @Override
+        public CompletionStage<Object> resolve(EvalContext context) {
+            return CompletedStage.of(new NamedArgument(context.getName()));
+        }
+
+        @Override
+        public int getPriority() {
+            return priority;
+        }
+
+        @Override
+        public String getNamespace() {
+            return name;
+        }
+
+    }
+
+    public static final class SetValueResolver implements ValueResolver {
+
+        public boolean appliesTo(EvalContext context) {
+            if (context.getParams().size() != 1) {
+                return false;
+            }
+            String name = context.getName();
+            return (name.equals("=") || name.equals("set"))
+                    && ValueResolvers.matchClass(context, NamedArgument.class);
+        }
+
+        @Override
+        public CompletionStage<Object> resolve(EvalContext context) {
+            NamedArgument argument = (NamedArgument) context.getBase();
+            return context.evaluate(context.getParams().get(0)).thenApply(v -> argument.setValue(v));
+        }
+
+    }
+}
diff --git a/independent-projects/qute/core/src/main/java/io/quarkus/qute/SectionHelperFactory.java b/independent-projects/qute/core/src/main/java/io/quarkus/qute/SectionHelperFactory.java
index 7e81f7b583a..16da9883ff1 100644
--- a/independent-projects/qute/core/src/main/java/io/quarkus/qute/SectionHelperFactory.java
+++ b/independent-projects/qute/core/src/main/java/io/quarkus/qute/SectionHelperFactory.java
@@ -211,6 +211,12 @@ default boolean hasParameter(String name) {
      */
     public interface SectionInitContext extends ParserDelegate {
 
+        /**
+         *
+         * @return the section name
+         */
+        String getName();
+
         /**
          *
          * @return the parameters of the main block
diff --git a/independent-projects/qute/core/src/main/java/io/quarkus/qute/SectionInitContextImpl.java b/independent-projects/qute/core/src/main/java/io/quarkus/qute/SectionInitContextImpl.java
index f5f0a7b1617..f8b49708dec 100644
--- a/independent-projects/qute/core/src/main/java/io/quarkus/qute/SectionInitContextImpl.java
+++ b/independent-projects/qute/core/src/main/java/io/quarkus/qute/SectionInitContextImpl.java
@@ -13,13 +13,19 @@ final class SectionInitContextImpl implements SectionInitContext {
     private final List<SectionBlock> blocks;
     private final ErrorInitializer errorInitializer;
     private final Supplier<Template> currentTemplate;
+    private final String name;
 
     SectionInitContextImpl(EngineImpl engine, List<SectionBlock> blocks, ErrorInitializer errorInitializer,
-            Supplier<Template> currentTemplate) {
+            Supplier<Template> currentTemplate, String name) {
         this.engine = engine;
         this.blocks = blocks;
         this.errorInitializer = errorInitializer;
         this.currentTemplate = currentTemplate;
+        this.name = name;
+    }
+
+    public String getName() {
+        return name;
     }
 
     /**
diff --git a/independent-projects/qute/core/src/main/java/io/quarkus/qute/SectionNode.java b/independent-projects/qute/core/src/main/java/io/quarkus/qute/SectionNode.java
index a815dfe5b24..1a08eab0991 100644
--- a/independent-projects/qute/core/src/main/java/io/quarkus/qute/SectionNode.java
+++ b/independent-projects/qute/core/src/main/java/io/quarkus/qute/SectionNode.java
@@ -210,7 +210,9 @@ SectionNode build(Supplier<Template> currentTemlate) {
             }
             List<SectionBlock> blocks = builder.build();
             return new SectionNode(helperName, blocks,
-                    factory.initialize(new SectionInitContextImpl(engine, blocks, errorInitializer, currentTemlate)), origin);
+                    factory.initialize(
+                            new SectionInitContextImpl(engine, blocks, errorInitializer, currentTemlate, helperName)),
+                    origin);
         }
 
     }
diff --git a/independent-projects/qute/core/src/main/java/io/quarkus/qute/StrEvalNamespaceResolver.java b/independent-projects/qute/core/src/main/java/io/quarkus/qute/StrEvalNamespaceResolver.java
index 43033e3c241..2e46c4c875e 100644
--- a/independent-projects/qute/core/src/main/java/io/quarkus/qute/StrEvalNamespaceResolver.java
+++ b/independent-projects/qute/core/src/main/java/io/quarkus/qute/StrEvalNamespaceResolver.java
@@ -84,7 +84,7 @@ private Template parse(String contents, Variant variant) {
     }
 
     private void resolve(CompletableFuture<Object> ret, EvalContext context, Template template) {
-        ((TemplateImpl) template).root.resolve(context.resolutionContext()).whenComplete((r, t) -> {
+        template.getRootNode().resolve(context.resolutionContext()).whenComplete((r, t) -> {
             if (t != null) {
                 ret.completeExceptionally(t);
             } else {
diff --git a/independent-projects/qute/core/src/main/java/io/quarkus/qute/Template.java b/independent-projects/qute/core/src/main/java/io/quarkus/qute/Template.java
index 3783a043de3..75b6512c730 100644
--- a/independent-projects/qute/core/src/main/java/io/quarkus/qute/Template.java
+++ b/independent-projects/qute/core/src/main/java/io/quarkus/qute/Template.java
@@ -206,6 +206,12 @@ default boolean isFragment() {
      */
     Collection<TemplateNode> findNodes(Predicate<TemplateNode> predicate);
 
+    /**
+     *
+     * @return the root section node
+     */
+    SectionNode getRootNode();
+
     /**
      * A fragment represents a part of the template that can be treated as a separate template.
      */
diff --git a/independent-projects/qute/core/src/main/java/io/quarkus/qute/TemplateImpl.java b/independent-projects/qute/core/src/main/java/io/quarkus/qute/TemplateImpl.java
index 255b63abbff..23ba18292d1 100644
--- a/independent-projects/qute/core/src/main/java/io/quarkus/qute/TemplateImpl.java
+++ b/independent-projects/qute/core/src/main/java/io/quarkus/qute/TemplateImpl.java
@@ -119,6 +119,11 @@ public Collection<TemplateNode> findNodes(Predicate<TemplateNode> predicate) {
         return root.findNodes(predicate);
     }
 
+    @Override
+    public SectionNode getRootNode() {
+        return root;
+    }
+
     private LazyValue<Map<String, Fragment>> initFragments(SectionNode section) {
         if (section.name.equals(Parser.ROOT_HELPER_NAME)) {
             // Initialize the lazy map for root sections only
diff --git a/independent-projects/qute/core/src/test/java/io/quarkus/qute/FragmentTest.java b/independent-projects/qute/core/src/test/java/io/quarkus/qute/FragmentTest.java
index 2bf58e96053..9eba74b62db 100644
--- a/independent-projects/qute/core/src/test/java/io/quarkus/qute/FragmentTest.java
+++ b/independent-projects/qute/core/src/test/java/io/quarkus/qute/FragmentTest.java
@@ -61,11 +61,58 @@ public void testNonUniqueIds() {
     public void testInvisibleFragment() {
         Engine engine = Engine.builder().addDefaults().build();
         Template foo = engine.parse(
-                "PREFIX::{#fragment foo rendered=false}FOO{/fragment}::{#include $foo /}::{#include $foo /}", null, "foo");
+                "PREFIX::{#fragment foo _hidden}FOO{/fragment}::{#include $foo /}::{#include $foo /}", null, "foo");
         assertEquals("PREFIX::::FOO::FOO", foo.render());
         assertEquals("FOO", foo.getFragment("foo").render());
     }
 
+    @Test
+    public void testFrgNamespace() {
+        Engine engine = Engine.builder()
+                .addDefaults()
+                .addNamespaceResolver(new FragmentNamespaceResolver())
+                .addValueResolver(new ReflectionValueResolver())
+                .build();
+        Template foo = engine.parse(
+                "PREFIX::{#fragment foo rendered=false}FOO{/fragment}::{frg:foo.toLowerCase}::{#include $foo /}", null, "foo");
+        assertEquals("PREFIX::::foo::FOO", foo.render());
+        // Fragment from another template
+        engine.putTemplate("bar", engine.parse("""
+                {#fragment barbar _hidden}
+                Barbar is here!
+                {/}
+                """));
+        assertEquals("Barbar is here!", engine.parse("{frg:bar$barbar}").render().strip());
+        assertThrows(TemplateException.class, () -> engine.parse("{frg:nonexistent$barbar}").render());
+    }
+
+    @Test
+    public void testCapture() {
+        Engine engine = Engine.builder()
+                .addDefaults()
+                .addNamespaceResolver(new FragmentNamespaceResolver(FragmentNamespaceResolver.CAP))
+                .addValueResolver(new ReflectionValueResolver())
+                .build();
+        Template foo = engine.parse(
+                "PREFIX::{#capture foo}FOO{/capture}::{cap:foo.toLowerCase}::{#include $foo /}", null, "foo");
+        assertEquals("PREFIX::::foo::FOO", foo.render());
+    }
+
+    @Test
+    public void testCaptureArgs() {
+        Engine engine = Engine.builder()
+                .addDefaults()
+                .addNamespaceResolver(new FragmentNamespaceResolver(FragmentNamespaceResolver.CAPTURE))
+                .addNamespaceResolver(new NamedArgument.ParamNamespaceResolver())
+                .addValueResolver(new NamedArgument.SetValueResolver())
+                .addValueResolver(new ReflectionValueResolver())
+                .build();
+        Template foo = engine.parse(
+                "PREFIX::{#capture foo}{name} {surname}{/capture}::{capture:foo(param:name = 'Ondik',param:surname.set(mySurname)).toLowerCase}",
+                null, "foo");
+        assertEquals("PREFIX::::ondik kouba", foo.data("mySurname", "Kouba").render());
+    }
+
     @Test
     public void testInvalidId() {
         Engine engine = Engine.builder().addDefaults().build();
