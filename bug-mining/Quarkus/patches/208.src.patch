diff --git a/extensions/websockets-next/runtime/src/main/java/io/quarkus/websockets/next/runtime/Endpoints.java b/extensions/websockets-next/runtime/src/main/java/io/quarkus/websockets/next/runtime/Endpoints.java
index 60ef3877fc5..707b696f464 100644
--- a/extensions/websockets-next/runtime/src/main/java/io/quarkus/websockets/next/runtime/Endpoints.java
+++ b/extensions/websockets-next/runtime/src/main/java/io/quarkus/websockets/next/runtime/Endpoints.java
@@ -220,7 +220,12 @@ public void handle(Void event) {
             timerId = vertx.setPeriodic(autoPingInterval.get().toMillis(), new Handler<Long>() {
                 @Override
                 public void handle(Long timerId) {
-                    connection.sendAutoPing();
+                    if (connection.isOpen()) {
+                        connection.sendAutoPing();
+                    } else {
+                        LOG.debugf("Try to cancel the autoPing timer for a closed connection: %s", connection.id());
+                        vertx.cancelTimer(timerId);
+                    }
                 }
             });
         } else {
@@ -237,16 +242,20 @@ public void handle(Void event) {
                     @Override
                     public void handle(Void event) {
                         endpoint.onClose().onComplete(r -> {
-                            if (r.succeeded()) {
-                                LOG.debugf("@OnClose callback completed: %s", connection);
-                            } else {
-                                handleFailure(unhandledFailureStrategy, r.cause(), "Unable to complete @OnClose callback",
-                                        connection);
-                            }
-                            securitySupport.onClose();
-                            onClose.run();
-                            if (timerId != null) {
-                                vertx.cancelTimer(timerId);
+                            try {
+                                if (r.succeeded()) {
+                                    LOG.debugf("@OnClose callback completed: %s", connection);
+                                } else {
+                                    handleFailure(unhandledFailureStrategy, r.cause(), "Unable to complete @OnClose callback",
+                                            connection);
+                                }
+                                securitySupport.onClose();
+                                onClose.run();
+                            } finally {
+                                // Make sure we always try to cancel the timer
+                                if (timerId != null) {
+                                    vertx.cancelTimer(timerId);
+                                }
                             }
                         });
                     }
