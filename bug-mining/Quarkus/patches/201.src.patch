diff --git a/extensions/qute/deployment/src/main/java/io/quarkus/qute/deployment/TypeInfos.java b/extensions/qute/deployment/src/main/java/io/quarkus/qute/deployment/TypeInfos.java
index fbc0ec54a74..c37726dc6de 100644
--- a/extensions/qute/deployment/src/main/java/io/quarkus/qute/deployment/TypeInfos.java
+++ b/extensions/qute/deployment/src/main/java/io/quarkus/qute/deployment/TypeInfos.java
@@ -221,8 +221,13 @@ public boolean isInfixNotationSupported() {
         }
 
         @Override
-        public boolean isLiteralSeparator(char candidate) {
-            return candidate == '<' || candidate == '>';
+        public boolean isLiteralSeparatorStart(char candidate) {
+            return candidate == '<';
+        }
+
+        @Override
+        public boolean isLiteralSeparatorEnd(char startSeparator, char candidate) {
+            return candidate == '>';
         }
 
     };
diff --git a/extensions/qute/deployment/src/test/java/io/quarkus/qute/deployment/extensions/StringTemplateExtensionsTest.java b/extensions/qute/deployment/src/test/java/io/quarkus/qute/deployment/extensions/StringTemplateExtensionsTest.java
index 903dd0c04d7..024b44048d5 100644
--- a/extensions/qute/deployment/src/test/java/io/quarkus/qute/deployment/extensions/StringTemplateExtensionsTest.java
+++ b/extensions/qute/deployment/src/test/java/io/quarkus/qute/deployment/extensions/StringTemplateExtensionsTest.java
@@ -93,6 +93,21 @@ public void testTemplateExtensions() {
         assertEquals("Hello fool!",
                 hello.data("name", "fool")
                         .render());
+
+        // https://github.com/quarkusio/quarkus/issues/47092
+        assertEquals("Quteiscool!",
+                engine.parse("{str:builder('Qute').append(\"is\").append(\"cool!\")}")
+                        .render());
+        assertEquals("Qute's cool!",
+                engine.parse("{str:builder('Qute').append(\"'s\").append(\" cool!\")}")
+                        .render());
+        assertEquals("\"Qute\" is cool!",
+                engine.parse("{str:builder('\"Qute\" ').append('is').append(\" cool!\")}")
+                        .render());
+        assertEquals("Hello '!",
+                engine.parse("{str:concat(\"Hello '\",\"!\")}")
+                        .render());
+
     }
 
 }
diff --git a/independent-projects/qute/core/src/main/java/io/quarkus/qute/Expressions.java b/independent-projects/qute/core/src/main/java/io/quarkus/qute/Expressions.java
index 0c3d8bd9eb5..cb332d9f494 100644
--- a/independent-projects/qute/core/src/main/java/io/quarkus/qute/Expressions.java
+++ b/independent-projects/qute/core/src/main/java/io/quarkus/qute/Expressions.java
@@ -72,7 +72,7 @@ public static List<String> splitParts(String value, SplitConfig splitConfig) {
         if (value == null || value.isEmpty()) {
             return Collections.emptyList();
         }
-        boolean literal = false;
+        char literal = 0;
         char separator = 0;
         byte infix = 0;
         byte brackets = 0;
@@ -83,7 +83,7 @@ public static List<String> splitParts(String value, SplitConfig splitConfig) {
             if (splitConfig.isSeparator(c)) {
                 // Adjacent separators may be ignored
                 if (separator == 0 || separator != c) {
-                    if (!literal && brackets == 0 && infix == 0) {
+                    if (literal == 0 && brackets == 0 && infix == 0) {
                         if (splitConfig.shouldPrependSeparator(c)) {
                             buffer.append(c);
                         }
@@ -99,11 +99,15 @@ public static List<String> splitParts(String value, SplitConfig splitConfig) {
                     }
                 }
             } else {
-                if (splitConfig.isLiteralSeparator(c)) {
-                    literal = !literal;
+                if (literal == 0
+                        && splitConfig.isLiteralSeparatorStart(c)) {
+                    literal = c;
+                } else if (literal != 0
+                        && splitConfig.isLiteralSeparatorEnd(literal, c)) {
+                    literal = 0;
                 }
                 // Non-separator char
-                if (!literal) {
+                if (literal == 0) {
                     // Not inside a string/type literal
                     if (brackets == 0 && c == ' ' && splitConfig.isInfixNotationSupported()) {
                         // Infix supported, blank space and not inside a virtual method
@@ -212,8 +216,19 @@ public boolean isInfixNotationSupported() {
         }
 
         @Override
-        public boolean isLiteralSeparator(char candidate) {
-            return SplitConfig.super.isLiteralSeparator(candidate) || candidate == '<' || candidate == '>';
+        public boolean isLiteralSeparatorStart(char candidate) {
+            return SplitConfig.super.isLiteralSeparatorStart(candidate)
+                    // We need this in order to support things like {@com.foo.Bar<? extends org.acme.Baz, String> bar}
+                    // where a space should not be treated as a separator
+                    || candidate == '<';
+        }
+
+        @Override
+        public boolean isLiteralSeparatorEnd(char startSeparator, char candidate) {
+            if (startSeparator == '<') {
+                return candidate == '>';
+            }
+            return SplitConfig.super.isLiteralSeparatorEnd(startSeparator, candidate);
         }
 
     };
@@ -221,7 +236,7 @@ public boolean isLiteralSeparator(char candidate) {
     private static final SplitConfig TYPE_INFO_SPLIT_CONFIG = new DefaultSplitConfig() {
 
         @Override
-        public boolean isLiteralSeparator(char candidate) {
+        public boolean isLiteralSeparatorStart(char candidate) {
             return candidate == TYPE_INFO_SEPARATOR || LiteralSupport.isStringLiteralSeparator(candidate);
         }
     };
@@ -247,12 +262,36 @@ public boolean shouldAppendSeparator(char candidate) {
 
     public interface SplitConfig {
 
+        /**
+         *
+         * @param candidate
+         * @return {@code true} if the characted should be treated as a "part" separator
+         */
         boolean isSeparator(char candidate);
 
-        default boolean isLiteralSeparator(char candidate) {
+        /**
+         * A "part" separator used inside a literal must be ignored.
+         *
+         * @param candidate
+         * @return {@code true} if the characted should be treated as a "literal" start separator
+         */
+        default boolean isLiteralSeparatorStart(char candidate) {
             return LiteralSupport.isStringLiteralSeparator(candidate);
         }
 
+        /**
+         *
+         * @param startSeparator
+         * @param candidate
+         * @return {@code true} if the characted should be treated as a "literal" end separator
+         */
+        default boolean isLiteralSeparatorEnd(char startSeparator, char candidate) {
+            if (isLiteralSeparatorStart(startSeparator)) {
+                return startSeparator == candidate;
+            }
+            return false;
+        }
+
         default boolean shouldPrependSeparator(char candidate) {
             return false;
         }
diff --git a/independent-projects/qute/core/src/test/java/io/quarkus/qute/ParserTest.java b/independent-projects/qute/core/src/test/java/io/quarkus/qute/ParserTest.java
index deb8c6dfdee..9fa33d1e2bd 100644
--- a/independent-projects/qute/core/src/test/java/io/quarkus/qute/ParserTest.java
+++ b/independent-projects/qute/core/src/test/java/io/quarkus/qute/ParserTest.java
@@ -21,6 +21,7 @@
 
 import org.junit.jupiter.api.Test;
 
+import io.quarkus.qute.Expression.Part;
 import io.quarkus.qute.TemplateException.Builder;
 import io.quarkus.qute.TemplateLocator.TemplateLocation;
 import io.quarkus.qute.TemplateNode.Origin;
@@ -460,13 +461,38 @@ public void testSectionParameterWithNestedSingleQuotationMark() {
         assertSectionParams(engine, "{#let id=\"'Foo \"}", Map.of("id", "\"'Foo \""));
         assertSectionParams(engine, "{#let id=\"'Foo ' \"}", Map.of("id", "\"'Foo ' \""));
         assertSectionParams(engine, "{#let id=\"'Foo ' \" bar='baz'}", Map.of("id", "\"'Foo ' \"", "bar", "'baz'"));
-        assertSectionParams(engine, "{#let my=bad id=(\"'Foo ' \" + 1) bar='baz'}",
-                Map.of("my", "bad", "id", "(\"'Foo ' \" + 1)", "bar", "'baz'"));
+        assertSectionParams(engine, "{#let my=bad id=(foo + 1) bar='baz'}",
+                Map.of("my", "bad", "id", "(foo + 1)", "bar", "'baz'"));
         assertSectionParams(engine, "{#let id = 'Foo'}", Map.of("id", "'Foo'"));
         assertSectionParams(engine, "{#let id= 'Foo'}", Map.of("id", "'Foo'"));
         assertSectionParams(engine, "{#let my = (bad or not) id=1}", Map.of("my", "(bad or not)", "id", "1"));
         assertSectionParams(engine, "{#let my= (bad or not) id=1}", Map.of("my", "(bad or not)", "id", "1"));
+    }
+
+    @Test
+    public void testVirtualMethodWithNestedLiteralSeparator() {
+        Engine engine = Engine.builder().addDefaults().build();
+        List<Part> parts = engine.parse("{foo('Bar \"!')}").findExpression(e -> true).getParts();
+        assertVirtualMethodParam(parts.get(0), "foo", "Bar \"!");
+
+        parts = engine.parse("{foo(\"Bar '!\")}").findExpression(e -> true).getParts();
+        assertVirtualMethodParam(parts.get(0), "foo", "Bar '!");
+
+        parts = engine.parse("{foo(\"Bar '!\").baz(1)}").findExpression(e -> true).getParts();
+        assertVirtualMethodParam(parts.get(0), "foo", "Bar '!");
+        assertVirtualMethodParam(parts.get(1), "baz", "1");
+
+        parts = engine.parse("{str:builder('Qute').append(\"is '\").append(\"cool!\")}").findExpression(e -> true).getParts();
+        assertVirtualMethodParam(parts.get(0), "builder", "Qute");
+        assertVirtualMethodParam(parts.get(1), "append", "is '");
+        assertVirtualMethodParam(parts.get(2), "append", "cool!");
+    }
 
+    private void assertVirtualMethodParam(Part part, String name, String literal) {
+        assertTrue(part.isVirtualMethod());
+        assertEquals(name, part.getName());
+        assertTrue(part.asVirtualMethod().getParameters().get(0).isLiteral());
+        assertEquals(literal, part.asVirtualMethod().getParameters().get(0).getLiteral().toString());
     }
 
     @Test
