diff --git a/extensions/qute/deployment/src/main/java/io/quarkus/qute/deployment/QuteProcessor.java b/extensions/qute/deployment/src/main/java/io/quarkus/qute/deployment/QuteProcessor.java
index bf00da04054..1b7c1487ced 100644
--- a/extensions/qute/deployment/src/main/java/io/quarkus/qute/deployment/QuteProcessor.java
+++ b/extensions/qute/deployment/src/main/java/io/quarkus/qute/deployment/QuteProcessor.java
@@ -145,7 +145,7 @@
 import io.quarkus.qute.deployment.TypeInfos.TypeInfo;
 import io.quarkus.qute.deployment.Types.AssignabilityCheck;
 import io.quarkus.qute.generator.ExtensionMethodGenerator;
-import io.quarkus.qute.generator.ExtensionMethodGenerator.ExtensionMethodInfo;
+import io.quarkus.qute.generator.ExtensionMethodGenerator.NamespaceExtensionMethodInfo;
 import io.quarkus.qute.generator.ExtensionMethodGenerator.Param;
 import io.quarkus.qute.generator.TemplateGlobalGenerator;
 import io.quarkus.qute.generator.ValueResolverGenerator;
@@ -2107,12 +2107,13 @@ public Function<FieldInfo, String> apply(ClassInfo clazz) {
                         .collect(Collectors.groupingBy(TemplateExtensionMethodBuildItem::getPriority));
 
                 for (Entry<Integer, List<TemplateExtensionMethodBuildItem>> priorityEntry : priorityToMethods.entrySet()) {
-                    List<ExtensionMethodGenerator.ExtensionMethodInfo> extensionMethods = new ArrayList<>(
+                    List<ExtensionMethodGenerator.NamespaceExtensionMethodInfo> extensionMethods = new ArrayList<>(
                             priorityEntry.getValue().size());
                     for (TemplateExtensionMethodBuildItem method : priorityEntry.getValue()) {
                         extensionMethods
-                                .add(new ExtensionMethodInfo(method.getMethod(), method.getMatchName(), method.getMatchNames(),
-                                        method.getMatchRegex()));
+                                .add(new NamespaceExtensionMethodInfo(method.getMethod(), method.getMatchName(),
+                                        Set.copyOf(method.getMatchNames()),
+                                        method.getMatchRegex(), method.getParams()));
                     }
                     String generatedType = extensionMethodGenerator.generateNamespaceResolver(
                             priorityEntry.getValue().get(0).getMethod().declaringClass(), nsEntry.getKey(),
diff --git a/independent-projects/qute/core/src/main/java/io/quarkus/qute/EvaluatedParams.java b/independent-projects/qute/core/src/main/java/io/quarkus/qute/EvaluatedParams.java
index 24f8817122d..461b3ff83e9 100644
--- a/independent-projects/qute/core/src/main/java/io/quarkus/qute/EvaluatedParams.java
+++ b/independent-projects/qute/core/src/main/java/io/quarkus/qute/EvaluatedParams.java
@@ -141,9 +141,10 @@ public Object getResult(int index) throws InterruptedException, ExecutionExcepti
      */
     public boolean parameterTypesMatch(boolean varargs, Class<?>[] types) throws InterruptedException, ExecutionException {
         // Check the number of parameters and replace the last param type with component type if needed
+        Class<?> componentType = null;
         if (types.length == results.length) {
             if (varargs) {
-                types[types.length - 1] = types[types.length - 1].getComponentType();
+                componentType = boxType(types[types.length - 1].getComponentType());
             }
         } else {
             if (varargs) {
@@ -151,8 +152,7 @@ public boolean parameterTypesMatch(boolean varargs, Class<?>[] types) throws Int
                 if (diff > 1) {
                     return false;
                 } else if (diff < 1) {
-                    Class<?> varargsType = types[types.length - 1];
-                    types[types.length - 1] = varargsType.getComponentType();
+                    componentType = boxType(types[types.length - 1].getComponentType());
                 }
                 // if diff == 1 then vargs may be empty and we need to compare the result types
             } else {
@@ -165,7 +165,11 @@ public boolean parameterTypesMatch(boolean varargs, Class<?>[] types) throws Int
             Object result = getResult(i);
             if (result != null) {
                 Class<?> resultClass = boxType(result.getClass());
-                if (!paramType.isAssignableFrom(resultClass)) {
+                if (!paramType.isAssignableFrom(resultClass)
+                        // For varargs we also try to match the component type
+                        && (componentType == null
+                                || i < (types.length - 1)
+                                || !componentType.isAssignableFrom(resultClass))) {
                     return false;
                 }
             }
@@ -178,14 +182,30 @@ public boolean parameterTypesMatch(boolean varargs, Class<?>[] types) throws Int
 
     public Object getVarargsResults(int numberOfParameters, Class<?> componentType)
             throws InterruptedException, ExecutionException {
+        // For varargs we want to skip all previous args
         int skip = numberOfParameters - 1;
-        if (skip < 0) {
+        if (skip < 0 || skip >= results.length) {
             return Array.newInstance(componentType, 0);
         }
+        Object result = null;
+        int capacity = results.length - skip;
+        if (numberOfParameters == results.length) {
+            // If there is exactly one non-skipped argument
+            // test if it's not a matching array
+            result = getResult(skip);
+            Class<?> resultClass = result.getClass();
+            if (resultClass.isArray() && resultClass.getComponentType().equals(componentType)) {
+                return result;
+            }
+            skip++;
+        }
+        Object array = Array.newInstance(componentType, capacity);
         int idx = 0;
-        Object array = Array.newInstance(componentType, results.length - skip);
+        if (result != null) {
+            Array.set(array, idx++, result);
+        }
         for (int i = skip; i < results.length; i++) {
-            Object result = getResult(i);
+            result = getResult(i);
             Array.set(array, idx++, result);
         }
         return array;
diff --git a/independent-projects/qute/core/src/main/java/io/quarkus/qute/TemplateExtension.java b/independent-projects/qute/core/src/main/java/io/quarkus/qute/TemplateExtension.java
index b0580799175..727c9fdd6ee 100644
--- a/independent-projects/qute/core/src/main/java/io/quarkus/qute/TemplateExtension.java
+++ b/independent-projects/qute/core/src/main/java/io/quarkus/qute/TemplateExtension.java
@@ -138,11 +138,13 @@
     int priority() default DEFAULT_PRIORITY;
 
     /**
-     * If not empty a namespace resolver is generated instead.
+     * If not empty then a namespace resolver is generated.
      * <p>
-     * Template extension methods that share the same namespace and are declared on the same class are grouped in one resolver
-     * and ordered by {@link #priority()}. The first matching extension method is used to resolve an expression. Template
-     * extension methods declared on different classes cannot share the same namespace.
+     * Multiple extension methods declared on the same class can share the same namespace. However, extension methods declared
+     * on different classes cannot share the same namespace.
+     * <p>
+     * It's recommended to specify the {@link #priority()} if multiple extension methods that share the same namespace also
+     * match the same property/method name and parameters.
      *
      * @return the namespace
      * @see NamespaceResolver#getNamespace()
diff --git a/independent-projects/qute/generator/src/main/java/io/quarkus/qute/generator/ExtensionMethodGenerator.java b/independent-projects/qute/generator/src/main/java/io/quarkus/qute/generator/ExtensionMethodGenerator.java
index 134d1f8b6e7..db113ee11e9 100644
--- a/independent-projects/qute/generator/src/main/java/io/quarkus/qute/generator/ExtensionMethodGenerator.java
+++ b/independent-projects/qute/generator/src/main/java/io/quarkus/qute/generator/ExtensionMethodGenerator.java
@@ -31,6 +31,7 @@
 import org.jboss.jandex.PrimitiveType.Primitive;
 import org.jboss.jandex.Type;
 import org.jboss.jandex.Type.Kind;
+import org.jboss.logging.Logger;
 
 import io.quarkus.gizmo2.ClassOutput;
 import io.quarkus.gizmo2.Const;
@@ -55,6 +56,8 @@
  */
 public class ExtensionMethodGenerator extends AbstractGenerator {
 
+    private static final Logger LOG = Logger.getLogger(ExtensionMethodGenerator.class);
+
     public static final DotName TEMPLATE_EXTENSION = DotName.createSimple(TemplateExtension.class.getName());
     public static final DotName TEMPLATE_ATTRIBUTE = DotName.createSimple(TemplateExtension.TemplateAttribute.class.getName());
     public static final String SUFFIX = "_Extension" + ValueResolverGenerator.SUFFIX;
@@ -71,10 +74,6 @@ public ExtensionMethodGenerator(IndexView index, ClassOutput classOutput) {
         super(index, classOutput);
     }
 
-    public Set<String> getGeneratedTypes() {
-        return generatedTypes;
-    }
-
     public static void validate(MethodInfo method, String namespace) {
         if (!Modifier.isStatic(method.flags())) {
             throw new IllegalStateException(
@@ -101,6 +100,8 @@ public static void validate(MethodInfo method, String namespace) {
      */
     public String generate(MethodInfo method, String matchName, List<String> matchNames, String matchRegex, Integer priority) {
 
+        LOG.debugf("Generating resolver for extension method declared on %s: %s", method.declaringClass(), method);
+
         AnnotationInstance extensionAnnotation = method.annotation(TEMPLATE_EXTENSION);
         List<Type> parameters = method.parameterTypes();
 
@@ -206,7 +207,11 @@ public String generate(MethodInfo method, String matchName, List<String> matchNa
     }
 
     public String generateNamespaceResolver(ClassInfo declaringClass, String namespace, int priority,
-            List<ExtensionMethodInfo> extensionMethods) {
+            List<NamespaceExtensionMethodInfo> extensionMethods) {
+        // Generate namespace resolver for extension methods from a single class with the same priority
+        LOG.debugf("Generating namespace [%s] resolver for extension methods declared on %s with priority %s", namespace,
+                declaringClass, priority);
+
         String baseName;
         if (declaringClass.enclosingClass() != null) {
             baseName = simpleName(declaringClass.enclosingClass()) + ValueResolverGenerator.NESTED_SEPARATOR
@@ -223,7 +228,7 @@ public String generateNamespaceResolver(ClassInfo declaringClass, String namespa
 
         gizmo.class_(generatedClassName, cc -> {
             cc.implements_(NamespaceResolver.class);
-            for (ExtensionMethodInfo extensionMethod : extensionMethods) {
+            for (NamespaceExtensionMethodInfo extensionMethod : extensionMethods) {
                 String matchRegex = extensionMethod.matchRegex();
                 if (matchRegex != null && !matchRegex.isEmpty()) {
                     cc.field(PATTERN + "_" + sha1(extensionMethod.method().toString()), fc -> {
@@ -246,17 +251,213 @@ public String generateNamespaceResolver(ClassInfo declaringClass, String namespa
                 ParamVar evalContext = mc.parameter("ec", EvalContext.class);
 
                 mc.body(bc -> {
+                    // Note that we have to group all extension methods in one resolver because
+                    // it's not allowed to register multiple namespace resolvers for the same namespace with the same priority
+
                     LocalVar name = bc.localVar("name", bc.invokeInterface(Descriptors.GET_NAME, evalContext));
-                    LocalVar paramsCount = bc.localVar("count", bc.invokeInterface(Descriptors.COLLECTION_SIZE,
-                            bc.invokeInterface(Descriptors.GET_PARAMS, evalContext)));
-                    for (ExtensionMethodInfo extensionMethod : extensionMethods) {
-                        String matchRegex = extensionMethod.matchRegex();
-                        FieldDesc patternField = matchRegex != null ? FieldDesc.of(cc.type(),
-                                PATTERN + "_" + sha1(extensionMethod.method().toString()), Pattern.class) : null;
-                        addNamespaceExtensionMethod(cc, bc, evalContext, patternField, extensionMethod.method(),
-                                extensionMethod.matchName(),
-                                extensionMethod.matchNames(), matchRegex, name, paramsCount);
+                    LocalVar params = bc.localVar("params", bc.invokeInterface(Descriptors.GET_PARAMS, evalContext));
+                    LocalVar paramsCount = bc.localVar("paramsCount",
+                            bc.invokeInterface(Descriptors.COLLECTION_SIZE, params));
+
+                    // First group extension methods by number of _evaluated_ params, e.g.:
+                    // 0 -> [ping(), pong()]
+                    // 1 -> [ping(int a), ping(String name), pong(boolean val)]
+                    Map<Integer, List<NamespaceExtensionMethodInfo>> byNumberOfParams = new HashMap<>();
+                    Map<Integer, List<NamespaceExtensionMethodInfo>> varargsByMinParams = new HashMap<>();
+                    for (NamespaceExtensionMethodInfo em : extensionMethods) {
+                        int count = em.params().evaluated().size();
+                        List<NamespaceExtensionMethodInfo> matching = byNumberOfParams.get(count);
+                        if (matching == null) {
+                            matching = new ArrayList<>();
+                            byNumberOfParams.put(count, matching);
+                        }
+                        matching.add(em);
+                        if (ValueResolverGenerator.isVarArgs(em.method())) {
+                            int minCount = count - 1;
+                            matching = varargsByMinParams.get(minCount);
+                            if (matching == null) {
+                                matching = new ArrayList<>();
+                                varargsByMinParams.put(minCount, matching);
+                            }
+                            matching.add(em);
+                        }
+                    }
+                    for (Map.Entry<Integer, List<NamespaceExtensionMethodInfo>> e : byNumberOfParams.entrySet()) {
+                        // For example, ping(int... a) should be also included for entry with 2 params
+                        varargsByMinParams.entrySet().stream()
+                                .filter(ve -> e.getKey() >= ve.getKey())
+                                .forEach(ve -> e.getValue().addAll(ve.getValue()));
+                    }
+
+                    for (Map.Entry<Integer, List<NamespaceExtensionMethodInfo>> e : byNumberOfParams.entrySet()) {
+                        // Then group extension methods by matching names
+                        // "ping" -> [ping(int a), ping(String name)]
+                        // Keep in mind that extension methods may have a special name matching config,
+                        // e.g. TemplateExtension#matchNames()
+                        Map<String, List<NamespaceExtensionMethodInfo>> matchingName = new HashMap<>();
+                        Map<Set<String>, List<NamespaceExtensionMethodInfo>> matchingNames = new HashMap<>();
+                        int numberOfParams = e.getKey();
+                        List<NamespaceExtensionMethodInfo> extensionMethodForParams = e.getValue();
+
+                        for (NamespaceExtensionMethodInfo em : extensionMethodForParams) {
+                            if (em.matchesName()) {
+                                List<NamespaceExtensionMethodInfo> matching = matchingName.get(em.matchName());
+                                if (matching == null) {
+                                    matching = new ArrayList<>();
+                                    matchingName.put(em.matchName(), matching);
+                                }
+                                matching.add(em);
+                            } else if (em.matchesNames()) {
+                                List<NamespaceExtensionMethodInfo> matching = matchingNames.get(em.matchNames());
+                                if (matching == null) {
+                                    matching = new ArrayList<>();
+                                    matchingNames.put(em.matchNames(), matching);
+                                }
+                                matching.add(em);
+                            }
+                        }
+                        for (Map.Entry<String, List<NamespaceExtensionMethodInfo>> mne : matchingName.entrySet()) {
+                            // Add extension methods with TemplateExtension#matchNames() and TemplateExtension#matchRegex()
+                            // that also match the given name
+                            for (NamespaceExtensionMethodInfo em : extensionMethodForParams) {
+                                if (em.alsoMatches(mne.getKey())) {
+                                    mne.getValue().add(em);
+                                }
+                            }
+                        }
+                        for (Map.Entry<Set<String>, List<NamespaceExtensionMethodInfo>> mne : matchingNames.entrySet()) {
+                            // Add extension methods with TemplateExtension#matchRegex()
+                            // that also match the given names
+                            for (NamespaceExtensionMethodInfo em : extensionMethodForParams) {
+                                if (em.alsoMatches(mne.getKey())) {
+                                    mne.getValue().add(em);
+                                }
+                            }
+                        }
+
+                        // First handle all methods matching the same number of params and the _same name_
+                        // This includes extension methods with TemplateExtension#matchNames() and TemplateExtension#matchRegex()
+                        for (Map.Entry<String, List<NamespaceExtensionMethodInfo>> mne : matchingName.entrySet()) {
+                            String matchName = mne.getKey();
+                            boolean matchAny = matchName.equals(TemplateExtension.ANY);
+
+                            bc.block(nested -> {
+                                // Test name
+                                if (!matchAny) {
+                                    nested.ifNot(nested.objEquals(name, Const.of(matchName)),
+                                            notMatching -> notMatching.break_(nested));
+                                }
+                                // Test number of evaluated params
+                                nested.if_(nested.ne(paramsCount, Const.of(numberOfParams)),
+                                        notEqual -> notEqual.break_(nested));
+
+                                List<NamespaceExtensionMethodInfo> methods = mne.getValue();
+                                if (numberOfParams == 0) {
+                                    // No params -> there must be exactly one extension method
+                                    if (methods.size() > 1) {
+                                        throw new IllegalStateException(
+                                                "Multiple extension methods match 0 params and the name %s: %s. Specify priorities to avoid this problem."
+                                                        .formatted(matchName, methods));
+                                    }
+                                    nested.return_(doInvokeNoParams(nested, name, evalContext, methods.get(0)));
+                                } else {
+                                    evaluateAndInvoke(nested, evalContext, name, methods);
+                                }
+                            });
+                        }
+
+                        // Then handle all methods matching the same number of params and the _same names_
+                        for (Map.Entry<Set<String>, List<NamespaceExtensionMethodInfo>> mne : matchingNames.entrySet()) {
+                            Set<String> matchNames = mne.getKey();
+
+                            bc.block(nested -> {
+                                // Test that any of the names matches
+                                nested.block(nested2 -> {
+                                    for (String matchName : matchNames) {
+                                        nested2.if_(nested2.objEquals(name, Const.of(matchName)),
+                                                namesMatch -> namesMatch.break_(nested2));
+                                    }
+                                    nested2.break_(nested);
+                                });
+                                // Test number of evaluated params
+                                nested.if_(nested.ne(paramsCount, Const.of(numberOfParams)),
+                                        notEqual -> notEqual.break_(nested));
+
+                                List<NamespaceExtensionMethodInfo> methods = mne.getValue();
+                                if (numberOfParams == 0) {
+                                    // No params -> there must be exactly one extension method
+                                    if (methods.size() > 1) {
+                                        throw new IllegalStateException(
+                                                "Multiple extension methods match 0 params and the names %s: %s. Specify priorities to avoid this problem."
+                                                        .formatted(matchNames, methods));
+                                    }
+                                    nested.return_(doInvokeNoParams(nested, name, evalContext, methods.get(0)));
+                                } else {
+                                    evaluateAndInvoke(nested, evalContext, name, methods);
+                                }
+                            });
+                        }
+
+                        // Next handle all matchRegex methods
+                        for (NamespaceExtensionMethodInfo em : extensionMethodForParams) {
+                            if (em.matchesRegex()) {
+                                bc.block(nested -> {
+                                    // Test regexp
+                                    FieldDesc patternField = FieldDesc.of(cc.type(),
+                                            PATTERN + "_" + sha1(em.method().toString()), Pattern.class);
+                                    Expr pattern = cc.this_().field(patternField);
+                                    Expr matcher = nested.invokeVirtual(Descriptors.PATTERN_MATCHER, pattern, name);
+                                    nested.ifNot(nested.invokeVirtual(Descriptors.MATCHER_MATCHES, matcher),
+                                            notMatching -> notMatching.break_(nested));
+                                    // Test number of evaluated params
+                                    nested.if_(nested.ne(paramsCount, Const.of(e.getKey())),
+                                            notEqual -> notEqual.break_(nested));
+                                    evaluateAndInvoke(nested, evalContext, name, List.of(em));
+                                });
+                            }
+                        }
+
                     }
+
+                    // Finally handle varargs methods
+                    // For varargs methods we need to match name and any number of params
+                    for (Map.Entry<Integer, List<NamespaceExtensionMethodInfo>> e : varargsByMinParams.entrySet()) {
+                        for (NamespaceExtensionMethodInfo em : e.getValue()) {
+                            bc.block(nested -> {
+                                // Test number of evaluated params >= min params
+                                nested.if_(nested.lt(paramsCount, Const.of(e.getKey())), notGe -> notGe.break_(nested));
+                                if (em.matchesRegex()) {
+                                    // Test regexp
+                                    FieldDesc patternField = FieldDesc.of(cc.type(),
+                                            PATTERN + "_" + sha1(em.method().toString()), Pattern.class);
+                                    Expr pattern = cc.this_().field(patternField);
+                                    Expr matcher = nested.invokeVirtual(Descriptors.PATTERN_MATCHER, pattern, name);
+                                    nested.ifNot(nested.invokeVirtual(Descriptors.MATCHER_MATCHES, matcher),
+                                            notMatching -> notMatching.break_(nested));
+                                } else if (em.matchesNames()) {
+                                    // Test that any of the names matches
+                                    nested.block(nested2 -> {
+                                        for (String matchName : em.matchNames()) {
+                                            nested2.if_(nested2.objEquals(name, Const.of(matchName)),
+                                                    namesMatch -> namesMatch.break_(nested2));
+                                        }
+                                        nested2.break_(nested);
+                                    });
+                                } else {
+                                    String matchName = em.matchName();
+                                    boolean matchAny = matchName.equals(TemplateExtension.ANY);
+                                    // Test name
+                                    if (!matchAny) {
+                                        nested.ifNot(nested.objEquals(name, Const.of(matchName)),
+                                                notMatching -> notMatching.break_(nested));
+                                    }
+                                }
+                                evaluateAndInvoke(nested, evalContext, name, List.of(em));
+                            });
+                        }
+
+                    }
+
                     bc.return_(bc.invokeStatic(Descriptors.RESULTS_NOT_FOUND_EC, evalContext));
                 });
             });
@@ -264,157 +465,208 @@ public String generateNamespaceResolver(ClassInfo declaringClass, String namespa
         return generatedClassName;
     }
 
-    private void addNamespaceExtensionMethod(ClassCreator namespaceResolver, BlockCreator resolve, ParamVar evalContext,
-            FieldDesc patternField,
-            MethodInfo method, String matchName, List<String> matchNames, String matchRegex, Var name, Var paramsCount) {
-        boolean isNameParamRequired = patternField != null || !matchNames.isEmpty()
-                || matchName.equals(TemplateExtension.ANY);
-        Parameters params = new Parameters(method, isNameParamRequired, true);
-        boolean matchAny = patternField == null && matchNames.isEmpty() && matchName.equals(TemplateExtension.ANY);
-        boolean isVarArgs = ValueResolverGenerator.isVarArgs(method);
-
-        resolve.block(nested -> {
-            // Test property name
-            if (!matchAny) {
-                if (patternField != null) {
-                    Expr pattern = namespaceResolver.this_().field(patternField);
-                    Expr matcher = nested.invokeVirtual(Descriptors.PATTERN_MATCHER, pattern, name);
-                    nested.ifNot(nested.invokeVirtual(Descriptors.MATCHER_MATCHES, matcher),
-                            notMatching -> notMatching.break_(nested));
-
-                } else if (!matchNames.isEmpty()) {
-                    // Any of the name matches
-                    nested.block(namesMatch -> {
-                        for (String match : matchNames) {
-                            namesMatch.if_(namesMatch.objEquals(name, Const.of(match)),
-                                    matching -> matching.break_(namesMatch));
+    private void doInvoke(BlockCreator bc, Var capturedRet, Var capturedName, Var capturedEvalContext,
+            Var capturedEvaluatedParams, ParamVar result,
+            NamespaceExtensionMethodInfo em) {
+        LocalVar invokeRet = bc.localVar("ret", Const.ofNull(Object.class));
+        List<Type> parameterTypes = em.params().parameterTypes();
+        bc.try_(tc -> {
+            tc.body(tcb -> {
+                Expr[] args = new Expr[parameterTypes.size()];
+                // Collect the params
+                int evalIdx = 0;
+                int lastIdx = parameterTypes.size() - 1;
+                for (int i = 0; i < parameterTypes.size(); i++) {
+                    Param param = em.params().get(i);
+                    if (param.kind == ParamKind.NAME) {
+                        args[i] = capturedName;
+                    } else if (param.kind == ParamKind.ATTR) {
+                        args[i] = tcb.invokeInterface(Descriptors.GET_ATTRIBUTE, capturedEvalContext,
+                                Const.of(param.name));
+                    } else {
+                        if (ValueResolverGenerator.isVarArgs(em.method()) && i == lastIdx) {
+                            // Last param is varargs
+                            Type varargsParam = em.params().get(lastIdx).type;
+                            Expr componentType = Const
+                                    .of(classDescOf(varargsParam.asArrayType().constituent().name()));
+                            Expr varargsResults = tcb.invokeVirtual(
+                                    Descriptors.EVALUATED_PARAMS_GET_VARARGS_RESULTS,
+                                    capturedEvaluatedParams, Const.of(em.params().evaluated().size()), componentType);
+                            args[i] = varargsResults;
+                        } else {
+                            args[i] = tcb.invokeVirtual(Descriptors.EVALUATED_PARAMS_GET_RESULT,
+                                    capturedEvaluatedParams, Const.of(evalIdx++));
                         }
-                        namesMatch.break_(nested);
-                    });
+                    }
+                }
 
+                // Now call the method
+                tcb.set(invokeRet, tcb.invokeStatic(methodDescOf(em.method()), args));
+
+                if (hasCompletionStage(em.method().returnType())) {
+                    Expr fun2 = tcb.lambda(BiConsumer.class, lc2 -> {
+                        Var capturedRet2 = lc2.capture(capturedRet);
+                        ParamVar result2 = lc2.parameter("r", 0);
+                        ParamVar throwable2 = lc2.parameter("t", 1);
+                        lc2.body(whenComplete2 -> {
+                            whenComplete2.ifNull(throwable2, success2 -> {
+                                success2.invokeVirtual(Descriptors.COMPLETABLE_FUTURE_COMPLETE,
+                                        capturedRet2,
+                                        result2);
+                                success2.return_();
+                            });
+                            whenComplete2.invokeVirtual(
+                                    Descriptors.COMPLETABLE_FUTURE_COMPLETE_EXCEPTIONALLY,
+                                    capturedRet2,
+                                    throwable2);
+                            whenComplete2.return_();
+                        });
+                    });
+                    tcb.invokeInterface(Descriptors.CF_WHEN_COMPLETE, invokeRet, fun2);
                 } else {
-                    nested.ifNot(nested.objEquals(name, Const.of(matchName)), matching -> matching.break_(nested));
+                    tcb.invokeVirtual(Descriptors.COMPLETABLE_FUTURE_COMPLETE, capturedRet,
+                            invokeRet);
                 }
-            }
-            // Test number of parameters
-            int realParamSize = params.evaluated().size();
-            if (!isVarArgs || realParamSize > 1) {
-                if (isVarArgs) {
-                    // For varargs methods match the minimal number of params
-                    nested.if_(nested.le(paramsCount, Const.of(realParamSize - 1)), lessEqual -> lessEqual.break_(nested));
-                } else {
-                    // https://github.com/quarkusio/gizmo/issues/467
-                    // workaround: use the constant as the second argument
-                    nested.if_(nested.ne(paramsCount, Const.of(realParamSize)), notEqual -> notEqual.break_(nested));
+            });
+            tc.catch_(Throwable.class, "t", (cb, e) -> {
+                cb.invokeVirtual(Descriptors.COMPLETABLE_FUTURE_COMPLETE_EXCEPTIONALLY,
+                        capturedRet, e);
+            });
+        });
+    }
+
+    Expr doInvokeNoParams(BlockCreator bc, Var name, Var evalContext, NamespaceExtensionMethodInfo em) {
+        Parameters p = em.params();
+        // No parameter needs to be evaluated
+        Expr[] args = new Expr[p.size()];
+        for (int i = 0; i < p.size(); i++) {
+            Param param = p.get(i);
+            if (param.kind == ParamKind.NAME) {
+                args[i] = name;
+            } else if (param.kind == ParamKind.ATTR) {
+                args[i] = bc.invokeInterface(Descriptors.GET_ATTRIBUTE, evalContext,
+                        Const.of(param.name));
+            } else {
+                if (ValueResolverGenerator.isVarArgs(em.method())) {
+                    // Last param is varargs
+                    Type varargsParam = em.params().getFirst(ParamKind.EVAL).type;
+                    args[i] = bc.newArray(classDescOf(varargsParam.asArrayType().constituent().name()));
                 }
             }
+        }
+        MethodInfo method = em.method();
+        Expr result = bc.invokeStatic(methodDescOf(method), args);
+        if (hasCompletionStage(method.returnType())) {
+            return result;
+        } else {
+            return bc.invokeStatic(Descriptors.COMPLETED_STAGE_OF, result);
+        }
+    }
 
-            if (!params.needsEvaluation()) {
-                Expr[] args = new Expr[params.size()];
-                for (int i = 0; i < params.size(); i++) {
-                    Param param = params.get(i);
-                    if (param.kind == ParamKind.NAME) {
-                        args[i] = name;
-                    } else if (param.kind == ParamKind.ATTR) {
-                        args[i] = nested.invokeInterface(Descriptors.GET_ATTRIBUTE, evalContext,
-                                Const.of(param.name));
+    void evaluateAndInvoke(BlockCreator nested, Var evalContext, Var name, List<NamespaceExtensionMethodInfo> methods) {
+        LocalVar ret = nested.localVar("ret", nested.new_(CompletableFuture.class));
+        // We need to evaluate the params first
+        LocalVar evaluatedParams = nested.localVar("evaluatedParams",
+                nested.invokeStatic(Descriptors.EVALUATED_PARAMS_EVALUATE,
+                        evalContext));
+        Expr paramsReady = evaluatedParams.field(Descriptors.EVALUATED_PARAMS_STAGE);
+        // Function that is called when params are evaluated
+        Expr whenCompleteFun = nested.lambda(BiConsumer.class, lc -> {
+            Var capturedRet = lc.capture(ret);
+            Var capturedName = lc.capture(name);
+            Var capturedEvaluatedParams = lc.capture(evaluatedParams);
+            Var capturedEvalContext = lc.capture(evalContext);
+            ParamVar result = lc.parameter("r", 0);
+            ParamVar throwable = lc.parameter("t", 1);
+
+            lc.body(accept -> {
+                accept.ifElse(accept.isNull(throwable), success -> {
+
+                    for (NamespaceExtensionMethodInfo em : methods) {
+                        success.block(nested2 -> {
+                            // Try to match parameter types
+                            LocalVar paramTypesArray = nested2.localVar("pt",
+                                    nested2.newArray(Class.class, em.params()
+                                            .evaluated()
+                                            .stream()
+                                            .map(p -> Const.of(classDescOf(p.type)))
+                                            .toList()));
+                            nested2.ifNot(
+                                    nested2.invokeVirtual(
+                                            Descriptors.EVALUATED_PARAMS_PARAM_TYPES_MATCH,
+                                            capturedEvaluatedParams,
+                                            Const.of(ValueResolverGenerator.isVarArgs(em.method())),
+                                            paramTypesArray),
+                                    notMatched -> notMatched.break_(nested2));
+
+                            // Parameters matched
+                            doInvoke(nested2, capturedRet, capturedName, capturedEvalContext,
+                                    capturedEvaluatedParams, result,
+                                    em);
+                            nested2.return_();
+                        });
                     }
-                }
-                nested.return_(nested.invokeStatic(Descriptors.COMPLETED_STAGE_OF,
-                        nested.invokeStatic(methodDescOf(method), args)));
-            } else {
-                LocalVar ret = nested.localVar("ret", nested.new_(CompletableFuture.class));
-                // Evaluate params first
-                // The CompletionStage upon which we invoke whenComplete()
-                LocalVar evaluatedParams = nested.localVar("evaluatedParams",
-                        nested.invokeStatic(Descriptors.EVALUATED_PARAMS_EVALUATE,
-                                evalContext));
-                Expr paramsReady = evaluatedParams.field(Descriptors.EVALUATED_PARAMS_STAGE);
-
-                // Function that is called when params are evaluated
-                Expr whenCompleteFun = nested.lambda(BiConsumer.class, lc -> {
-                    Var capturedName = isNameParamRequired ? lc.capture(name) : null;
-                    Var capturedRet = lc.capture(ret);
-                    Var capturedEvaluatedParams = lc.capture(evaluatedParams);
-                    Var capturedEvalContext = lc.capture(evalContext);
-                    @SuppressWarnings("unused")
-                    ParamVar result = lc.parameter("r", 0);
-                    ParamVar throwable = lc.parameter("t", 1);
-
-                    lc.body(accept -> {
-                        accept.ifElse(accept.isNull(throwable), success -> {
-                            // Check type parameters and return NO_RESULT if failed
-                            List<Param> evaluated = params.evaluated();
-                            LocalVar paramTypes = success.localVar("pt", success.newArray(Class.class, evaluated.stream()
-                                    .map(p -> Const.of(classDescOf(p.type)))
-                                    .toList()));
-                            success.ifNot(success.invokeVirtual(Descriptors.EVALUATED_PARAMS_PARAM_TYPES_MATCH,
-                                    capturedEvaluatedParams, Const.of(isVarArgs), paramTypes),
-                                    typeMatchFailed -> {
-                                        typeMatchFailed.invokeVirtual(Descriptors.COMPLETABLE_FUTURE_COMPLETE, capturedRet,
-                                                typeMatchFailed.invokeStatic(Descriptors.NOT_FOUND_FROM_EC,
-                                                        capturedEvalContext));
-                                        typeMatchFailed.return_();
-                                    });
 
-                            // try-catch
-                            success.try_(tc -> {
-
-                                tc.body(tcb -> {
-
-                                    // Collect the params
-                                    Expr[] args = new Expr[params.size()];
-                                    int evalIdx = 0;
-                                    int lastIdx = params.size() - 1;
-                                    for (int i = 0; i < params.size(); i++) {
-                                        Param param = params.get(i);
-                                        if (param.kind == ParamKind.NAME) {
-                                            args[i] = capturedName;
-                                        } else if (param.kind == ParamKind.ATTR) {
-                                            args[i] = tcb.invokeInterface(Descriptors.GET_ATTRIBUTE, capturedEvalContext,
-                                                    Const.of(param.name));
-                                        } else {
-                                            if (isVarArgs && i == lastIdx) {
-                                                // Last param is varargs
-                                                Type varargsParam = params.get(lastIdx).type;
-                                                Expr componentType = Const
-                                                        .of(classDescOf(varargsParam.asArrayType().elementType()));
-                                                Expr varargsResults = tcb.invokeVirtual(
-                                                        Descriptors.EVALUATED_PARAMS_GET_VARARGS_RESULTS,
-                                                        capturedEvaluatedParams, Const.of(evaluated.size()), componentType);
-                                                args[i] = varargsResults;
-                                            } else {
-                                                args[i] = tcb.invokeVirtual(Descriptors.EVALUATED_PARAMS_GET_RESULT,
-                                                        capturedEvaluatedParams, Const.of(evalIdx++));
-                                            }
-                                        }
-                                    }
-                                    // Invoke the extension method
-                                    Expr invokeRet = tcb.invokeStatic(methodDescOf(method), args);
-                                    tcb.invokeVirtual(Descriptors.COMPLETABLE_FUTURE_COMPLETE, capturedRet, invokeRet);
-                                });
-
-                                tc.catch_(Throwable.class, "e", (cb, e) -> {
-                                    cb.invokeVirtual(Descriptors.COMPLETABLE_FUTURE_COMPLETE_EXCEPTIONALLY, capturedRet, e);
-                                });
-                            });
-                        },
-                                failure -> {
-                                    failure.invokeVirtual(Descriptors.COMPLETABLE_FUTURE_COMPLETE_EXCEPTIONALLY,
-                                            capturedRet,
-                                            throwable);
-                                });
-                        accept.return_();
-                    });
+                    // No method matches - result not found
+                    success.invokeVirtual(Descriptors.COMPLETABLE_FUTURE_COMPLETE, capturedRet,
+                            success.invokeStatic(Descriptors.NOT_FOUND_FROM_EC,
+                                    capturedEvalContext));
+                    success.return_();
 
+                }, failure -> {
+                    failure.invokeVirtual(Descriptors.COMPLETABLE_FUTURE_COMPLETE_EXCEPTIONALLY,
+                            capturedRet,
+                            throwable);
                 });
-                nested.invokeInterface(Descriptors.CF_WHEN_COMPLETE, paramsReady, whenCompleteFun);
-                nested.return_(ret);
-            }
+                accept.return_();
+            });
         });
+
+        nested.invokeInterface(Descriptors.CF_WHEN_COMPLETE, paramsReady, whenCompleteFun);
+        nested.return_(ret);
     }
 
-    public record ExtensionMethodInfo(MethodInfo method, String matchName, List<String> matchNames, String matchRegex) {
+    public record NamespaceExtensionMethodInfo(MethodInfo method, String matchName, Set<String> matchNames, String matchRegex,
+            Parameters params) {
+
+        boolean matchesName() {
+            return matchRegex == null && matchNames.isEmpty();
+        }
+
+        boolean matchesNames() {
+            return matchRegex == null && !matchNames.isEmpty();
+        }
+
+        boolean matchesRegex() {
+            return matchRegex != null;
+        }
+
+        boolean alsoMatches(String name) {
+            if (matchRegex != null) {
+                return Pattern.matches(matchRegex, name);
+            } else if (!matchNames.isEmpty()) {
+                return matchNames.contains(name);
+            }
+            return false;
+        }
+
+        boolean alsoMatches(Set<String> names) {
+            if (matchRegex != null) {
+                Pattern p = Pattern.compile(matchRegex);
+                for (String name : names) {
+                    if (!p.matcher(name).matches()) {
+                        return false;
+                    }
+                }
+                return true;
+            }
+            return false;
+        }
+
+        @Override
+        public String toString() {
+            return "NamespaceExtensionMethodInfo [declaringClass=" + method.declaringClass() + ", method=" + method + "]";
+        }
 
     }
 
@@ -679,9 +931,11 @@ static Type box(Primitive primitive) {
 
     public static final class Parameters implements Iterable<Param> {
 
+        final boolean isNameParameterRequired;
         final List<Param> params;
 
         public Parameters(MethodInfo method, boolean isNameParameterRequired, boolean hasNamespace) {
+            this.isNameParameterRequired = isNameParameterRequired;
             List<Type> parameters = method.parameterTypes();
             Map<Integer, String> attributeParamNames = new HashMap<>();
             for (AnnotationInstance annotation : method.annotations()) {
@@ -749,6 +1003,10 @@ public Parameters(MethodInfo method, boolean isNameParameterRequired, boolean ha
             }
         }
 
+        public List<Type> parameterTypes() {
+            return params.stream().map(p -> p.type).toList();
+        }
+
         public String[] parameterTypesAsStringArray() {
             String[] types = new String[params.size()];
             for (int i = 0; i < params.size(); i++) {
diff --git a/independent-projects/qute/generator/src/test/java/io/quarkus/qute/generator/NamespaceExtensionMethods.java b/independent-projects/qute/generator/src/test/java/io/quarkus/qute/generator/NamespaceExtensionMethods.java
new file mode 100644
index 00000000000..6a694d0cde3
--- /dev/null
+++ b/independent-projects/qute/generator/src/test/java/io/quarkus/qute/generator/NamespaceExtensionMethods.java
@@ -0,0 +1,31 @@
+package io.quarkus.qute.generator;
+
+import java.util.Arrays;
+
+public class NamespaceExtensionMethods {
+
+    static String ping(Number a, Number b) {
+        return "Number, Number";
+    }
+
+    static String ping(String a, String b) {
+        return "String, String";
+    }
+
+    static String ping(String name, String a, Number b) {
+        return "String, Number:" + name;
+    }
+
+    static String pong(String... values) {
+        return "String..." + Arrays.toString(values);
+    }
+
+    static String[] pongs() {
+        return new String[] { "foo", "bar" };
+    }
+
+    static String pingRegex(String name, String a) {
+        return "String:" + name + a;
+    }
+
+}
diff --git a/independent-projects/qute/generator/src/test/java/io/quarkus/qute/generator/SimpleGeneratorTest.java b/independent-projects/qute/generator/src/test/java/io/quarkus/qute/generator/SimpleGeneratorTest.java
index 22ad6efa156..65cf3054151 100644
--- a/independent-projects/qute/generator/src/test/java/io/quarkus/qute/generator/SimpleGeneratorTest.java
+++ b/independent-projects/qute/generator/src/test/java/io/quarkus/qute/generator/SimpleGeneratorTest.java
@@ -9,6 +9,7 @@
 import java.lang.reflect.InvocationTargetException;
 import java.util.HashSet;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CompletionStage;
@@ -34,6 +35,8 @@
 import io.quarkus.qute.Resolver;
 import io.quarkus.qute.TestEvalContext;
 import io.quarkus.qute.ValueResolver;
+import io.quarkus.qute.generator.ExtensionMethodGenerator.NamespaceExtensionMethodInfo;
+import io.quarkus.qute.generator.ExtensionMethodGenerator.Parameters;
 
 public class SimpleGeneratorTest {
 
@@ -43,7 +46,8 @@ public class SimpleGeneratorTest {
     public static void init() throws IOException {
         ClassOutput classOutput = ClassOutput.fileWriter(new File("target/test-classes/").toPath());
         Index index = index(MyService.class, PublicMyService.class, BaseService.class, MyItem.class, String.class,
-                CompletionStage.class, List.class, MyEnum.class, StringBuilder.class, SomeBean.class, SomeInterface.class);
+                CompletionStage.class, List.class, MyEnum.class, StringBuilder.class, SomeBean.class, SomeInterface.class,
+                NamespaceExtensionMethods.class);
         ClassInfo myServiceClazz = index.getClassByName(DotName.createSimple(MyService.class.getName()));
         ValueResolverGenerator generator = ValueResolverGenerator.builder().setIndex(index).setClassOutput(classOutput)
                 .addClass(myServiceClazz)
@@ -72,6 +76,24 @@ public static void init() throws IOException {
                 "getDummyVarargs", Type.create(myServiceClazz.name(), Kind.CLASS), PrimitiveType.INT,
                 Type.create(DotName.createSimple("[L" + String.class.getName() + ";"), Kind.ARRAY));
         extensionMethodGenerator.generate(extensionMethod, null, List.of(), null, null);
+        ClassInfo namespaceExtensionMethodsClazz = index.getClassByName(DotName.createSimple(NamespaceExtensionMethods.class));
+        List<MethodInfo> myExtensionMethods = namespaceExtensionMethodsClazz.methods().stream()
+                .filter(m -> m.name().equals("ping") || m.name().startsWith("pong") || m.name().equals("pingRegex")).toList();
+        extensionMethodGenerator.generateNamespaceResolver(namespaceExtensionMethodsClazz, "my", 0,
+                myExtensionMethods.stream().map(
+                        m -> {
+                            if (m.name().equals("pingRegex")) {
+                                return new NamespaceExtensionMethodInfo(m, null, Set.of(), "alpha",
+                                        new Parameters(m, true, true));
+                            }
+                            if (m.name().equals("ping")
+                                    && m.parametersCount() == 3) {
+                                return new NamespaceExtensionMethodInfo(m, null, Set.of("ping", "pingu"), null,
+                                        new Parameters(m, true, true));
+                            }
+                            return new NamespaceExtensionMethodInfo(m, m.name(), Set.of(), null,
+                                    new Parameters(m, false, true));
+                        }).toList());
         generatedTypes.addAll(extensionMethodGenerator.getGeneratedTypes());
     }
 
@@ -111,7 +133,8 @@ public void testWithEngine() throws Exception {
 
         EngineBuilder builder = Engine.builder().addDefaults();
         for (String generatedType : generatedTypes) {
-            if (generatedType.contains(ValueResolverGenerator.NAMESPACE_SUFFIX)) {
+            if (generatedType.contains(ValueResolverGenerator.NAMESPACE_SUFFIX)
+                    || generatedType.contains(ExtensionMethodGenerator.NAMESPACE_SUFFIX)) {
                 builder.addNamespaceResolver((NamespaceResolver) newResolver(generatedType));
             } else {
                 builder.addValueResolver((ValueResolver) newResolver(generatedType));
@@ -154,6 +177,18 @@ public void testWithEngine() throws Exception {
         assertEquals("10", engine.parse("{io_quarkus_qute_generator_MyService:getDummy(5)}").render());
         assertEquals("foo", engine.parse("{builder.append('foo')}").data("builder", new StringBuilder()).render());
 
+        assertEquals("NOT_FOUND", engine.parse("{my:ping(a,b,c)}").data(Map.of("a", 100, "b", 50)).render());
+        assertEquals("Number, Number", engine.parse("{my:ping(a,b)}").data(Map.of("a", 100, "b", 50)).render());
+        assertEquals("String, Number:ping", engine.parse("{my:ping(a,b)}").data(Map.of("a", "100", "b", 50)).render());
+        assertEquals("String, Number:pingu", engine.parse("{my:pingu(a,b)}").data(Map.of("a", "100", "b", 50)).render());
+        assertEquals("NOT_FOUND", engine.parse("{my:ping(b,a)}").data(Map.of("a", "100", "b", 50)).render());
+        assertEquals("String, String", engine.parse("{my:ping(a,b)}").data(Map.of("a", "100", "b", "50")).render());
+        assertEquals("String:alpha100", engine.parse("{my:alpha(a)}").data(Map.of("a", "100")).render());
+        assertEquals("String...[]", engine.parse("{my:pong()}").data(Map.of("a", "100", "b", "50")).render());
+        assertEquals("String...[100]", engine.parse("{my:pong(a)}").data(Map.of("a", "100", "b", "50")).render());
+        assertEquals("String...[50, 100]", engine.parse("{my:pong(b,a)}").data(Map.of("a", "100", "b", "50")).render());
+        assertEquals("String...[foo, bar]", engine.parse("{my:pong(my:pongs)}").render());
+
         // Exact match takes precedence over the getter
         assertEquals("bar::true::true::ping::false",
                 engine.parse("{some.image}::{some.hasImage}::{some.hasImage('bar')}::{some.png}::{some.hasPng('bar')}")
