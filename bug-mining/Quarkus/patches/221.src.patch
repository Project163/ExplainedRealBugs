diff --git a/extensions/scheduler/deployment/src/main/java/io/quarkus/scheduler/deployment/SchedulerProcessor.java b/extensions/scheduler/deployment/src/main/java/io/quarkus/scheduler/deployment/SchedulerProcessor.java
index 277a453e3a3..2a7454a5271 100644
--- a/extensions/scheduler/deployment/src/main/java/io/quarkus/scheduler/deployment/SchedulerProcessor.java
+++ b/extensions/scheduler/deployment/src/main/java/io/quarkus/scheduler/deployment/SchedulerProcessor.java
@@ -15,6 +15,7 @@
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Map.Entry;
 import java.util.Optional;
 import java.util.Set;
 import java.util.concurrent.CompletableFuture;
@@ -176,6 +177,7 @@ void collectScheduledMethods(BeanArchiveIndexBuildItem beanArchives, BeanDiscove
             BuildProducer<ScheduledBusinessMethodItem> scheduledBusinessMethods) {
 
         // First collect static scheduled methods
+        Map<MethodInfo, List<AnnotationInstance>> staticScheduledMethods = new HashMap<>();
         List<AnnotationInstance> schedules = new ArrayList<>(
                 beanArchives.getIndex().getAnnotations(SchedulerDotNames.SCHEDULED_NAME));
         for (AnnotationInstance annotationInstance : beanArchives.getIndex().getAnnotations(SchedulerDotNames.SCHEDULES_NAME)) {
@@ -198,13 +200,23 @@ void collectScheduledMethods(BeanArchiveIndexBuildItem beanArchives, BeanDiscove
                         method.name(), declaringClass.name()));
             }
             if (Modifier.isStatic(method.flags()) && !KotlinUtil.isSuspendMethod(method)) {
-                scheduledBusinessMethods.produce(new ScheduledBusinessMethodItem(null, method, schedules,
-                        transformedAnnotations.hasAnnotation(method, SchedulerDotNames.NON_BLOCKING),
-                        transformedAnnotations.hasAnnotation(method, SchedulerDotNames.RUN_ON_VIRTUAL_THREAD)));
-                LOGGER.debugf("Found scheduled static method %s declared on %s", method, declaringClass.name());
+                List<AnnotationInstance> methodSchedules = staticScheduledMethods.get(method);
+                if (methodSchedules == null) {
+                    methodSchedules = new ArrayList<>();
+                    staticScheduledMethods.put(method, methodSchedules);
+                }
+                methodSchedules.add(annotationInstance);
             }
         }
 
+        for (Entry<MethodInfo, List<AnnotationInstance>> e : staticScheduledMethods.entrySet()) {
+            MethodInfo method = e.getKey();
+            scheduledBusinessMethods.produce(new ScheduledBusinessMethodItem(null, method, e.getValue(),
+                    transformedAnnotations.hasAnnotation(method, SchedulerDotNames.NON_BLOCKING),
+                    transformedAnnotations.hasAnnotation(method, SchedulerDotNames.RUN_ON_VIRTUAL_THREAD)));
+            LOGGER.debugf("Found scheduled static method %s declared on %s", method, method.declaringClass().name());
+        }
+
         // Then collect all business methods annotated with @Scheduled
         for (BeanInfo bean : beanDiscovery.beanStream().classBeans()) {
             collectScheduledMethods(beanArchives.getIndex(), transformedAnnotations, bean,
diff --git a/extensions/scheduler/deployment/src/test/java/io/quarkus/scheduler/test/staticmethod/ScheduledStaticMethodTest.java b/extensions/scheduler/deployment/src/test/java/io/quarkus/scheduler/test/staticmethod/ScheduledStaticMethodTest.java
index 90355cd1597..8fecb1afa8c 100644
--- a/extensions/scheduler/deployment/src/test/java/io/quarkus/scheduler/test/staticmethod/ScheduledStaticMethodTest.java
+++ b/extensions/scheduler/deployment/src/test/java/io/quarkus/scheduler/test/staticmethod/ScheduledStaticMethodTest.java
@@ -1,14 +1,18 @@
 package io.quarkus.scheduler.test.staticmethod;
 
+import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 
+import jakarta.inject.Inject;
+
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.extension.RegisterExtension;
 
 import io.quarkus.scheduler.Scheduled;
+import io.quarkus.scheduler.Scheduler;
 import io.quarkus.test.QuarkusUnitTest;
 
 public class ScheduledStaticMethodTest {
@@ -18,8 +22,12 @@ public class ScheduledStaticMethodTest {
             .withApplicationRoot((jar) -> jar
                     .addClasses(Jobs.class, AbstractJobs.class, InterfaceJobs.class));
 
+    @Inject
+    Scheduler scheduler;
+
     @Test
     public void testSimpleScheduledJobs() throws InterruptedException {
+        assertEquals(3, scheduler.getScheduledJobs().size());
         assertTrue(Jobs.LATCH.await(5, TimeUnit.SECONDS));
         assertTrue(AbstractJobs.LATCH.await(5, TimeUnit.SECONDS));
         assertTrue(InterfaceJobs.LATCH.await(5, TimeUnit.SECONDS));
