diff --git a/docs/src/main/asciidoc/qute-reference.adoc b/docs/src/main/asciidoc/qute-reference.adoc
index 65a794f5f5f..7679f61e173 100644
--- a/docs/src/main/asciidoc/qute-reference.adoc
+++ b/docs/src/main/asciidoc/qute-reference.adoc
@@ -3042,7 +3042,14 @@ Message bundle files must be encoded in _UTF-8_.
 The file name consists of the relevant bundle name (e.g. `msg`) and underscore followed by a language tag (IETF; e.g. `en-US`).
 The language tag may be omitted, in which case the language tag of the default bundle locale is used.
 For example, if bundle `msg` has default locale `en`, then `msg.properties` is going to be treated as `msg_en.properties`.
-If both `msg.properties` and `msg_en.properties` are detected, an exception is thrown and build fails.
+
+If there are multiple files for a specific locale then Qute attempts to resolve the ambiguity.
+Localized files from the application root have higher priority and take precedence over localized files from dependencies.
+If multiple files of the same priority exist, then the build fails.
+For example, if the default bundle locale is `en` and the files `msg.properties` and `msg_en.properties` are found in the application root, then an exception is thrown and the build fails. 
+Or another example - if there are two dependencies and both contain the `msg_en.properties` file, then the build fails again.
+On the other hand, if there is the `msg_en.properties` file in the application root and also the `msg_en.properties` file in a dependency, then messages from the application root take precedence and override the values from the dependency.
+
 The file format is very simple: each line represents either a key/value pair with the equals sign used as a separator or a comment (line starts with `#`).
 Blank lines are ignored.
 Keys are _mapped to method names_ from the corresponding message bundle interface.
diff --git a/extensions/qute/deployment/src/main/java/io/quarkus/qute/deployment/MessageBundleBuildItem.java b/extensions/qute/deployment/src/main/java/io/quarkus/qute/deployment/MessageBundleBuildItem.java
index 805c2d2677a..22ab69918db 100644
--- a/extensions/qute/deployment/src/main/java/io/quarkus/qute/deployment/MessageBundleBuildItem.java
+++ b/extensions/qute/deployment/src/main/java/io/quarkus/qute/deployment/MessageBundleBuildItem.java
@@ -1,24 +1,25 @@
 package io.quarkus.qute.deployment;
 
-import java.nio.file.Path;
+import java.util.List;
 import java.util.Map;
 
 import org.jboss.jandex.ClassInfo;
 
 import io.quarkus.builder.item.MultiBuildItem;
+import io.quarkus.qute.deployment.MessageBundleProcessor.MessageFile;
 
 public final class MessageBundleBuildItem extends MultiBuildItem {
 
     private final String name;
     private final ClassInfo defaultBundleInterface;
     private final Map<String, ClassInfo> localizedInterfaces;
-    private final Map<String, Path> localizedFiles;
-    private final Map<String, Path> mergeCandidates;
+    private final Map<String, List<MessageFile>> localizedFiles;
+    private final Map<String, List<MessageFile>> mergeCandidates;
     private final String defaultLocale;
 
     public MessageBundleBuildItem(String name, ClassInfo defaultBundleInterface,
-            Map<String, ClassInfo> localizedInterfaces, Map<String, Path> localizedFiles,
-            Map<String, Path> mergeCandidates, String defaultLocale) {
+            Map<String, ClassInfo> localizedInterfaces, Map<String, List<MessageFile>> localizedFiles,
+            Map<String, List<MessageFile>> mergeCandidates, String defaultLocale) {
         this.name = name;
         this.defaultBundleInterface = defaultBundleInterface;
         this.localizedInterfaces = localizedInterfaces;
@@ -39,17 +40,15 @@ public Map<String, ClassInfo> getLocalizedInterfaces() {
         return localizedInterfaces;
     }
 
-    public Map<String, Path> getLocalizedFiles() {
+    public Map<String, List<MessageFile>> getLocalizedFiles() {
         return localizedFiles;
     }
 
     /**
      * Merge candidates are localized files used as a supplementary source of message templates
      * not specified by localized interfaces.
-     *
-     * @return locale -> localized file {@link Path}
      */
-    public Map<String, Path> getMergeCandidates() {
+    public Map<String, List<MessageFile>> getMergeCandidates() {
         return mergeCandidates;
     }
 
diff --git a/extensions/qute/deployment/src/main/java/io/quarkus/qute/deployment/MessageBundleProcessor.java b/extensions/qute/deployment/src/main/java/io/quarkus/qute/deployment/MessageBundleProcessor.java
index e4c0eb8434d..8dcb77565d8 100644
--- a/extensions/qute/deployment/src/main/java/io/quarkus/qute/deployment/MessageBundleProcessor.java
+++ b/extensions/qute/deployment/src/main/java/io/quarkus/qute/deployment/MessageBundleProcessor.java
@@ -139,7 +139,8 @@ List<MessageBundleBuildItem> processBundles(BeanArchiveIndexBuildItem beanArchiv
         Map<String, ClassInfo> found = new HashMap<>();
         List<MessageBundleBuildItem> bundles = new ArrayList<>();
         List<DotName> localizedInterfaces = new ArrayList<>();
-        List<Path> messageFiles = findMessageFiles(applicationArchivesBuildItem, watchedFiles);
+        // Message files sorted by priority
+        List<MessageFile> messageFiles = findMessageFiles(applicationArchivesBuildItem, watchedFiles);
 
         // First collect all interfaces annotated with @MessageBundle
         for (AnnotationInstance bundleAnnotation : index.getAnnotations(Names.BUNDLE)) {
@@ -209,48 +210,40 @@ List<MessageBundleBuildItem> processBundles(BeanArchiveIndexBuildItem beanArchiv
                     }
 
                     // Find localized files
-                    Map<String, Path> localeToFile = new HashMap<>();
+                    Map<String, List<MessageFile>> localeToFiles = new HashMap<>();
                     // Message templates not specified by a localized interface are looked up in a localized file (merge candidate)
-                    Map<String, Path> localeToMergeCandidate = new HashMap<>();
-                    for (Path messageFile : messageFiles) {
-                        String fileName = messageFile.getFileName().toString();
-                        if (bundleNameMatchesFileName(fileName, name)) {
-                            final String locale;
-                            int postfixIdx = fileName.indexOf('.');
-                            if (postfixIdx == name.length()) {
-
-                                // msg.txt -> use bundle default locale
+                    Map<String, List<MessageFile>> localeToMergeCandidates = new HashMap<>();
+                    for (MessageFile messageFile : messageFiles) {
+                        if (messageFile.matchesBundle(name)) {
+                            String locale = messageFile.getLocale(name);
+                            if (locale == null) {
                                 locale = defaultLocale;
-                            } else {
-
-                                locale = fileName
-                                        // msg_en.txt -> en
-                                        // msg_Views_Index_cs.properties -> cs
-                                        // msg_Views_Index_cs-CZ.properties -> cs-CZ
-                                        // msg_Views_Index_cs_CZ.properties -> cs_CZ
-                                        .substring(name.length() + 1, postfixIdx)
-                                        // Support resource bundle naming convention
-                                        .replace('_', '-');
                             }
-
                             ClassInfo localizedInterface = localeToInterface.get(locale);
+                            List<MessageFile> files;
                             if (defaultLocale.equals(locale) || localizedInterface != null) {
-                                // both file and interface exist for one locale, therefore we need to merge them
-                                Path previous = localeToMergeCandidate.put(locale, messageFile);
-                                if (previous != null) {
-                                    throw new MessageBundleException(
-                                            String.format(
-                                                    "Cannot register [%s] - a localized file already exists for locale [%s]: [%s]",
-                                                    fileName, locale, previous.getFileName().toString()));
+                                files = localeToMergeCandidates.get(locale);
+                                if (files == null) {
+                                    files = new ArrayList<>();
+                                    localeToMergeCandidates.put(locale, files);
                                 }
                             } else {
-                                localeToFile.put(locale, messageFile);
+                                files = localeToFiles.get(locale);
+                                if (files == null) {
+                                    files = new ArrayList<>();
+                                    localeToFiles.put(locale, files);
+                                }
                             }
+                            files.add(messageFile);
                         }
                     }
 
+                    // Check for duplicates again
+                    checkForDuplicates(localeToMergeCandidates);
+                    checkForDuplicates(localeToFiles);
+
                     bundles.add(new MessageBundleBuildItem(name, bundleClass, localeToInterface,
-                            localeToFile, localeToMergeCandidate, defaultLocale));
+                            localeToFiles, localeToMergeCandidates, defaultLocale));
                 } else {
                     throw new MessageBundleException("@MessageBundle must be declared on an interface: " + bundleClass);
                 }
@@ -289,7 +282,6 @@ List<MessageBundleBuildItem> processBundles(BeanArchiveIndexBuildItem beanArchiv
                     .scope(Singleton.class)
                     .creator(cg -> {
                         BlockCreator bc = cg.createMethod();
-
                         // Just create a new instance of the generated class
                         bc.return_(bc.new_(ConstructorDesc.of(
                                 generatedImplementations.get(bundleInterface.name().toString()))));
@@ -304,14 +296,13 @@ List<MessageBundleBuildItem> processBundles(BeanArchiveIndexBuildItem beanArchiv
                         .scope(Singleton.class)
                         .creator(cg -> {
                             BlockCreator bc = cg.createMethod();
-
                             // Just create a new instance of the generated class
                             bc.return_(bc.new_(ConstructorDesc.of(
                                     generatedImplementations.get(localizedInterface.name().toString()))));
                         }).done();
             }
             // Localized files
-            for (Entry<String, Path> entry : bundle.getLocalizedFiles().entrySet()) {
+            for (Entry<String, List<MessageFile>> entry : bundle.getLocalizedFiles().entrySet()) {
                 beanRegistration.getContext().configure(bundle.getDefaultBundleInterface().name())
                         .addType(bundle.getDefaultBundleInterface().name())
                         .addQualifier().annotation(Names.LOCALIZED)
@@ -319,10 +310,9 @@ List<MessageBundleBuildItem> processBundles(BeanArchiveIndexBuildItem beanArchiv
                         .unremovable()
                         .scope(Singleton.class).creator(cg -> {
                             BlockCreator bc = cg.createMethod();
-
                             // Just create a new instance of the generated class
                             bc.return_(bc.new_(ConstructorDesc.of(
-                                    generatedImplementations.get(entry.getValue().toString()))));
+                                    generatedImplementations.get(entry.getValue().get(0).fileName()))));
                         }).done();
             }
         }
@@ -330,30 +320,6 @@ List<MessageBundleBuildItem> processBundles(BeanArchiveIndexBuildItem beanArchiv
         return bundles;
     }
 
-    static boolean bundleNameMatchesFileName(String fileName, String name) {
-        int fileSeparatorIdx = fileName.indexOf('.');
-        // Remove file extension if exists
-        if (fileSeparatorIdx > -1) {
-            fileName = fileName.substring(0, fileSeparatorIdx);
-        }
-        // Split the filename and the bundle name by underscores
-        String[] fileNameParts = fileName.split("_");
-        String[] nameParts = name.split("_");
-
-        if (fileNameParts.length < nameParts.length) {
-            return false;
-        }
-
-        // Compare each part of the filename with the corresponding part of the bundle name
-        for (int i = 0; i < nameParts.length; i++) {
-            if (!fileNameParts[i].equals(nameParts[i])) {
-                return false;
-            }
-        }
-
-        return true;
-    }
-
     @Record(value = STATIC_INIT)
     @BuildStep
     void initBundleContext(MessageBundleRecorder recorder,
@@ -769,9 +735,12 @@ private Map<String, ClassDesc> generateImplementations(List<MessageBundleBuildIt
             }
 
             // Generate implementation for each localized file
-            for (Entry<String, Path> entry : bundle.getLocalizedFiles().entrySet()) {
-                Path localizedFile = entry.getValue();
-                var keyToTemplate = parseKeyToTemplateFromLocalizedFile(bundleInterface, localizedFile, index);
+            for (Entry<String, List<MessageFile>> entry : bundle.getLocalizedFiles().entrySet()) {
+                List<MessageFile> localizedFiles = entry.getValue();
+                if (localizedFiles.isEmpty()) {
+                    continue;
+                }
+                var keyToTemplate = parseKeyToTemplateFromLocalizedFiles(bundleInterface, localizedFiles, index);
 
                 String locale = entry.getKey();
                 ClassOutput localeAwareGizmoAdaptor = new GeneratedClassGizmo2Adaptor(generatedClasses, generatedResources,
@@ -785,7 +754,7 @@ public String apply(String className) {
                                 return className;
                             }
                         }));
-                generatedTypes.put(localizedFile.toString(),
+                generatedTypes.put(localizedFiles.get(0).fileName(),
                         ClassDesc.of(generateImplementation(bundle, bundleInterface, bundleImpl,
                                 new SimpleClassInfoWrapper(bundleInterface), localeAwareGizmoAdaptor, messageTemplateMethods,
                                 keyToTemplate, locale, index)));
@@ -798,9 +767,9 @@ private Map<String, String> getLocalizedFileKeyToTemplate(MessageBundleBuildItem
             ClassInfo bundleInterface, String locale, List<MethodInfo> methods, ClassInfo localizedInterface, IndexView index)
             throws IOException {
 
-        Path localizedFile = bundle.getMergeCandidates().get(locale);
-        if (localizedFile != null) {
-            Map<String, String> keyToTemplate = parseKeyToTemplateFromLocalizedFile(bundleInterface, localizedFile, index);
+        List<MessageFile> localizedFiles = bundle.getMergeCandidates().get(locale);
+        if (localizedFiles != null) {
+            Map<String, String> keyToTemplate = parseKeyToTemplateFromLocalizedFiles(bundleInterface, localizedFiles, index);
             if (!keyToTemplate.isEmpty()) {
 
                 // keep message templates if value wasn't provided by Message#value
@@ -830,42 +799,48 @@ private Map<String, String> getLocalizedFileKeyToTemplate(MessageBundleBuildItem
                 return keyToTemplate;
             }
         }
-        return Collections.emptyMap();
+        return Map.of();
     }
 
-    private Map<String, String> parseKeyToTemplateFromLocalizedFile(ClassInfo bundleInterface,
-            Path localizedFile, IndexView index) throws IOException {
+    private Map<String, String> parseKeyToTemplateFromLocalizedFiles(ClassInfo bundleInterface,
+            List<MessageFile> localizedFile, IndexView index) throws IOException {
         Map<String, String> keyToTemplate = new HashMap<>();
-        for (ListIterator<String> it = Files.readAllLines(localizedFile).listIterator(); it.hasNext();) {
-            String line = it.next();
-            if (line.isBlank()) {
-                // Blank lines are skipped
-                continue;
-            }
-            line = line.strip();
-            if (line.startsWith("#")) {
-                // Comments are skipped
-                continue;
-            }
-            int eqIdx = line.indexOf('=');
-            if (eqIdx == -1) {
-                throw new MessageBundleException(
-                        "Missing key/value separator\n\t- file: " + localizedFile + "\n\t- line " + it.previousIndex());
-            }
-            String key = line.substring(0, eqIdx).strip();
-            if (!hasMessageBundleMethod(bundleInterface, key) && !isEnumConstantMessageKey(key, index, bundleInterface)) {
-                throw new MessageBundleException(
-                        "Message bundle method " + key + "() not found on: " + bundleInterface + "\n\t- file: "
-                                + localizedFile + "\n\t- line " + it.previousIndex());
-            }
-            String value = adaptLine(line.substring(eqIdx + 1, line.length()));
-            if (value.endsWith("\\")) {
-                // The logical line is spread out across several normal lines
-                StringBuilder builder = new StringBuilder(value.substring(0, value.length() - 1));
-                constructLine(builder, it);
-                keyToTemplate.put(key, builder.toString());
-            } else {
-                keyToTemplate.put(key, value);
+        for (MessageFile messageFile : localizedFile) {
+            for (ListIterator<String> it = Files.readAllLines(messageFile.path()).listIterator(); it.hasNext();) {
+                String line = it.next();
+                if (line.isBlank()) {
+                    // Blank lines are skipped
+                    continue;
+                }
+                line = line.strip();
+                if (line.startsWith("#")) {
+                    // Comments are skipped
+                    continue;
+                }
+                int eqIdx = line.indexOf('=');
+                if (eqIdx == -1) {
+                    throw new MessageBundleException(
+                            "Missing key/value separator\n\t- file: " + localizedFile + "\n\t- line " + it.previousIndex());
+                }
+                String key = line.substring(0, eqIdx).strip();
+                if (keyToTemplate.containsKey(key)) {
+                    // Message template with higher priority takes precedence
+                    continue;
+                }
+                if (!hasMessageBundleMethod(bundleInterface, key) && !isEnumConstantMessageKey(key, index, bundleInterface)) {
+                    throw new MessageBundleException(
+                            "Message bundle method " + key + "() not found on: " + bundleInterface + "\n\t- file: "
+                                    + localizedFile + "\n\t- line " + it.previousIndex());
+                }
+                String value = adaptLine(line.substring(eqIdx + 1, line.length()));
+                if (value.endsWith("\\")) {
+                    // The logical line is spread out across several normal lines
+                    StringBuilder builder = new StringBuilder(value.substring(0, value.length() - 1));
+                    constructLine(builder, it);
+                    keyToTemplate.put(key, builder.toString());
+                } else {
+                    keyToTemplate.put(key, value);
+                }
             }
         }
         return keyToTemplate;
@@ -1534,68 +1509,138 @@ private String getDefaultLocale(AnnotationInstance bundleAnnotation, LocalesBuil
         return defaultLocale;
     }
 
-    private List<Path> findMessageFiles(ApplicationArchivesBuildItem applicationArchivesBuildItem,
-            BuildProducer<HotDeploymentWatchedFileBuildItem> watchedFiles) throws IOException {
+    record MessageFile(Path path, String fileName, int priority) implements Comparable<MessageFile> {
+
+        MessageFile(Path path, int priority) {
+            this(path, path.getFileName().toString(), priority);
+        }
+
+        boolean matchesBundle(String bundleName) {
+            String fileName = this.fileName;
+            int fileSeparatorIdx = fileName.indexOf('.');
+            // Remove file extension if exists
+            if (fileSeparatorIdx > -1) {
+                fileName = fileName.substring(0, fileSeparatorIdx);
+            }
+            // Split the filename and the bundle name by underscores
+            String[] fileNameParts = fileName.split("_");
+            String[] nameParts = bundleName.split("_");
 
-        Map<String, List<Path>> messageFileNameToPath = new HashMap<>();
+            if (fileNameParts.length < nameParts.length) {
+                return false;
+            }
 
-        for (ApplicationArchive archive : applicationArchivesBuildItem.getAllApplicationArchives()) {
-            archive.accept(tree -> {
-                final Path messagesPath = tree.getPath(MESSAGES);
-                if (messagesPath == null) {
-                    return;
+            // Compare each part of the filename with the corresponding part of the bundle name
+            for (int i = 0; i < nameParts.length; i++) {
+                if (!fileNameParts[i].equals(nameParts[i])) {
+                    return false;
                 }
-                try (Stream<Path> files = Files.list(messagesPath)) {
-                    Iterator<Path> iter = files.iterator();
-                    while (iter.hasNext()) {
-                        Path filePath = iter.next();
-                        if (Files.isRegularFile(filePath)) {
-                            String messageFileName = messagesPath.relativize(filePath).toString();
-                            if (File.separatorChar != '/') {
-                                messageFileName = messageFileName.replace(File.separatorChar, '/');
-                            }
-                            List<Path> paths = messageFileNameToPath.get(messageFileName);
-                            if (paths == null) {
-                                paths = new ArrayList<>();
-                                messageFileNameToPath.put(messageFileName, paths);
-                            }
-                            paths.add(filePath);
-                        }
+            }
+            return true;
+        }
+
+        String getLocale(String bundleName) {
+            String fileName = this.fileName;
+            int postfixIdx = fileName.indexOf('.');
+            if (postfixIdx == bundleName.length()) {
+                // msg.txt -> use bundle default locale
+                return null;
+            } else {
+                return fileName
+                        // msg_en.txt -> en
+                        // msg_Views_Index_cs.properties -> cs
+                        // msg_Views_Index_cs-CZ.properties -> cs-CZ
+                        // msg_Views_Index_cs_CZ.properties -> cs_CZ
+                        .substring(bundleName.length() + 1, postfixIdx)
+                        // Support resource bundle naming convention
+                        .replace('_', '-');
+            }
+        }
+
+        @Override
+        public int compareTo(MessageFile other) {
+            // Higher priority goes first
+            return Integer.compare(other.priority(), priority());
+        }
+    }
+
+    private void checkForDuplicates(Map<String, List<MessageFile>> groupByName) {
+        // Check for duplicates
+        // If there are multiple message files of the same priority then fail the build
+        for (var entry : groupByName.entrySet()) {
+            if (entry.getValue().size() > 1) {
+                Map<Integer, List<MessageFile>> groupByPriority = entry.getValue().stream()
+                        .collect(Collectors.groupingBy(MessageFile::priority));
+                for (var groupEntry : groupByPriority.entrySet()) {
+                    if (groupEntry.getValue().size() > 1) {
+                        StringBuilder builder = new StringBuilder("Duplicate localized files with priority ")
+                                .append(groupEntry.getValue().get(0).priority())
+                                .append(" found:\n\t- ")
+                                .append(entry.getKey())
+                                .append(": ")
+                                .append(groupEntry.getValue());
+                        throw new MessageBundleException(builder.toString());
                     }
-                } catch (IOException e) {
-                    throw new UncheckedIOException(e);
                 }
-            });
+            }
         }
+    }
+
+    private List<MessageFile> findMessageFiles(ApplicationArchivesBuildItem applicationArchives,
+            BuildProducer<HotDeploymentWatchedFileBuildItem> watchedFiles) throws IOException {
 
-        if (messageFileNameToPath.isEmpty()) {
-            return Collections.emptyList();
+        List<MessageFile> messageFiles = new ArrayList<>();
+
+        addMessageFiles(applicationArchives.getRootArchive(), 10, messageFiles);
+        for (ApplicationArchive archive : applicationArchives.getApplicationArchives()) {
+            addMessageFiles(archive, 1, messageFiles);
         }
 
-        // Check duplicates
-        List<Entry<String, List<Path>>> duplicates = messageFileNameToPath.entrySet().stream()
-                .filter(e -> e.getValue().size() > 1).collect(Collectors.toList());
-        if (!duplicates.isEmpty()) {
-            StringBuilder builder = new StringBuilder("Duplicate localized files found:");
-            for (Entry<String, List<Path>> e : duplicates) {
-                builder.append("\n\t- ")
-                        .append(e.getKey())
-                        .append(": ")
-                        .append(e.getValue());
-            }
-            throw new IllegalStateException(builder.toString());
+        if (messageFiles.isEmpty()) {
+            return List.of();
         }
 
+        // Check for duplicates
+        Map<String, List<MessageFile>> groupByName = messageFiles.stream()
+                .collect(Collectors.groupingBy(MessageFile::fileName));
+        checkForDuplicates(groupByName);
+
+        // Sort message files by priority
+        messageFiles.sort(null);
+
         // Hot deployment
-        for (String messageFileName : messageFileNameToPath.keySet()) {
-            watchedFiles.produce(new HotDeploymentWatchedFileBuildItem(MESSAGES + "/" + messageFileName));
+        for (MessageFile messageFile : messageFiles) {
+            watchedFiles.produce(new HotDeploymentWatchedFileBuildItem(MESSAGES + "/" + messageFile.fileName()));
         }
 
-        List<Path> messageFiles = new ArrayList<>();
-        messageFileNameToPath.values().forEach(messageFiles::addAll);
         return messageFiles;
     }
 
+    private void addMessageFiles(ApplicationArchive archive, int priority,
+            List<MessageFile> messageFiles) {
+        archive.accept(tree -> {
+            final Path messagesPath = tree.getPath(MESSAGES);
+            if (messagesPath == null) {
+                return;
+            }
+            try (Stream<Path> files = Files.list(messagesPath)) {
+                Iterator<Path> iter = files.iterator();
+                while (iter.hasNext()) {
+                    Path filePath = iter.next();
+                    if (Files.isRegularFile(filePath)) {
+                        String messageFileName = messagesPath.relativize(filePath).toString();
+                        if (File.separatorChar != '/') {
+                            messageFileName = messageFileName.replace(File.separatorChar, '/');
+                        }
+                        messageFiles.add(new MessageFile(filePath, priority));
+                    }
+                }
+            } catch (IOException e) {
+                throw new UncheckedIOException(e);
+            }
+        });
+    }
+
     private static class AppClassPredicate implements Predicate<String> {
 
         private final Function<String, String> additionalClassNameSanitizer;
diff --git a/extensions/qute/deployment/src/test/java/io/quarkus/qute/deployment/MessageBundleProcessorTest.java b/extensions/qute/deployment/src/test/java/io/quarkus/qute/deployment/MessageBundleProcessorTest.java
index 4850f984ef4..9feab012d26 100644
--- a/extensions/qute/deployment/src/test/java/io/quarkus/qute/deployment/MessageBundleProcessorTest.java
+++ b/extensions/qute/deployment/src/test/java/io/quarkus/qute/deployment/MessageBundleProcessorTest.java
@@ -3,24 +3,27 @@
 import static org.junit.jupiter.api.Assertions.assertFalse;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
+import java.nio.file.Path;
+
 import org.junit.jupiter.api.Test;
 
 class MessageBundleProcessorTest {
 
     @Test
     void bundleNameMatchesFileName() {
-        assertTrue(MessageBundleProcessor.bundleNameMatchesFileName("messages.properties", "messages"));
-        assertTrue(MessageBundleProcessor.bundleNameMatchesFileName("started.properties", "started"));
-        assertTrue(MessageBundleProcessor.bundleNameMatchesFileName("startedValidation.properties", "startedValidation"));
-        assertTrue(MessageBundleProcessor.bundleNameMatchesFileName("EmailBundles_startedValidation.properties",
-                "EmailBundles_startedValidation"));
-        assertTrue(MessageBundleProcessor.bundleNameMatchesFileName("EmailBundles_startedValidation_pt_BR.properties",
-                "EmailBundles_startedValidation"));
-
-        assertFalse(MessageBundleProcessor.bundleNameMatchesFileName("startedValidation.properties", "started"));
-        assertFalse(MessageBundleProcessor.bundleNameMatchesFileName("EmailBundles_startedValidation.properties",
-                "EmailBundles_started"));
-        assertFalse(MessageBundleProcessor.bundleNameMatchesFileName("EmailBundles_startedValidation_pt_BR.properties",
-                "EmailBundles_started"));
+        assertTrue(new MessageBundleProcessor.MessageFile(Path.of("messages.properties"), 0).matchesBundle("messages"));
+        assertTrue(new MessageBundleProcessor.MessageFile(Path.of("started.properties"), 0).matchesBundle("started"));
+        assertTrue(new MessageBundleProcessor.MessageFile(Path.of("startedValidation.properties"), 0)
+                .matchesBundle("startedValidation"));
+        assertTrue(new MessageBundleProcessor.MessageFile(Path.of("EmailBundles_startedValidation.properties"), 0)
+                .matchesBundle("EmailBundles_startedValidation"));
+        assertTrue(new MessageBundleProcessor.MessageFile(Path.of("EmailBundles_startedValidation_pt_BR.properties"), 0)
+                .matchesBundle("EmailBundles_startedValidation"));
+        assertFalse(
+                new MessageBundleProcessor.MessageFile(Path.of("startedValidation.properties"), 0).matchesBundle("started"));
+        assertFalse(new MessageBundleProcessor.MessageFile(Path.of("EmailBundles_startedValidation.properties"), 0)
+                .matchesBundle("EmailBundles_started"));
+        assertFalse(new MessageBundleProcessor.MessageFile(Path.of("EmailBundles_startedValidation_pt_BR.properties"), 0)
+                .matchesBundle("EmailBundles_started"));
     }
 }
diff --git a/extensions/qute/deployment/src/test/java/io/quarkus/qute/deployment/i18n/DefaultFileDuplicateFoundTest.java b/extensions/qute/deployment/src/test/java/io/quarkus/qute/deployment/i18n/DefaultFileDuplicateFoundTest.java
index 6a5509e8b2b..733674bcf30 100644
--- a/extensions/qute/deployment/src/test/java/io/quarkus/qute/deployment/i18n/DefaultFileDuplicateFoundTest.java
+++ b/extensions/qute/deployment/src/test/java/io/quarkus/qute/deployment/i18n/DefaultFileDuplicateFoundTest.java
@@ -33,7 +33,7 @@ public class DefaultFileDuplicateFoundTest {
                     e = e.getCause();
                 }
                 assertNotNull(mbe);
-                assertTrue(mbe.getMessage().contains("localized file already exists for locale [cs]"), mbe.getMessage());
+                assertTrue(mbe.getMessage().contains("Duplicate localized files with priority 10 found"), mbe.getMessage());
                 assertTrue(mbe.getMessage().contains("msg_cs.properties"), mbe.getMessage());
                 assertTrue(mbe.getMessage().contains("msg.properties"), mbe.getMessage());
             });
diff --git a/extensions/qute/deployment/src/test/java/io/quarkus/qute/deployment/i18n/LocalizedFileDuplicateFoundTest.java b/extensions/qute/deployment/src/test/java/io/quarkus/qute/deployment/i18n/LocalizedFileDuplicateFoundTest.java
index e97b0d3b6a2..339f93221ae 100644
--- a/extensions/qute/deployment/src/test/java/io/quarkus/qute/deployment/i18n/LocalizedFileDuplicateFoundTest.java
+++ b/extensions/qute/deployment/src/test/java/io/quarkus/qute/deployment/i18n/LocalizedFileDuplicateFoundTest.java
@@ -8,6 +8,7 @@
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.extension.RegisterExtension;
 
+import io.quarkus.qute.deployment.MessageBundleException;
 import io.quarkus.test.QuarkusUnitTest;
 
 public class LocalizedFileDuplicateFoundTest {
@@ -15,21 +16,24 @@ public class LocalizedFileDuplicateFoundTest {
     @RegisterExtension
     static final QuarkusUnitTest config = new QuarkusUnitTest()
             .withApplicationRoot(root -> root.addAsResource(new StringAsset("hello=Ahoj!"), "messages/messages_cs.properties"))
+            // there are multiple message files of the same priority
             .withAdditionalDependency(
                     d -> d.addAsResource(new StringAsset("hello=Cau!"), "messages/messages_cs.properties"))
+            .withAdditionalDependency(
+                    d -> d.addAsResource(new StringAsset("hello=Caucau!"), "messages/messages_cs.properties"))
             .assertException(t -> {
                 Throwable e = t;
-                IllegalStateException ise = null;
+                MessageBundleException mbe = null;
                 while (e != null) {
-                    if (e instanceof IllegalStateException) {
-                        ise = (IllegalStateException) e;
+                    if (e instanceof MessageBundleException) {
+                        mbe = (MessageBundleException) e;
                         break;
                     }
                     e = e.getCause();
                 }
-                assertNotNull(ise);
-                assertTrue(ise.getMessage().contains("Duplicate localized files found:"), ise.getMessage());
-                assertTrue(ise.getMessage().contains("messages_cs.properties"), ise.getMessage());
+                assertNotNull(mbe);
+                assertTrue(mbe.getMessage().contains("Duplicate localized files with priority 1 found:"), mbe.getMessage());
+                assertTrue(mbe.getMessage().contains("messages_cs.properties"), mbe.getMessage());
             });
 
     @Test
diff --git a/extensions/qute/deployment/src/test/java/io/quarkus/qute/deployment/i18n/PrioritizedLocalizedFilesMergeTest.java b/extensions/qute/deployment/src/test/java/io/quarkus/qute/deployment/i18n/PrioritizedLocalizedFilesMergeTest.java
new file mode 100644
index 00000000000..47bce39134d
--- /dev/null
+++ b/extensions/qute/deployment/src/test/java/io/quarkus/qute/deployment/i18n/PrioritizedLocalizedFilesMergeTest.java
@@ -0,0 +1,54 @@
+package io.quarkus.qute.deployment.i18n;
+
+import static io.quarkus.qute.i18n.MessageBundle.DEFAULT_NAME;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+
+import org.jboss.shrinkwrap.api.asset.StringAsset;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.RegisterExtension;
+
+import io.quarkus.qute.i18n.Localized;
+import io.quarkus.qute.i18n.Message;
+import io.quarkus.qute.i18n.MessageBundle;
+import io.quarkus.test.QuarkusUnitTest;
+
+public class PrioritizedLocalizedFilesMergeTest {
+
+    @RegisterExtension
+    static final QuarkusUnitTest config = new QuarkusUnitTest()
+            .withApplicationRoot((jar) -> jar
+                    .addClass(Messages.class)
+                    .addAsResource(new StringAsset("hello=Hi!\ngoodbye=Bye"), "messages/msg_en.properties"))
+            .withAdditionalDependency(
+                    d -> d.addAsResource(new StringAsset("""
+                            hello=Hey!
+                            goodbye=Byebye
+                            foo=Alpha
+                            """), "messages/msg.properties"))
+            .overrideConfigKey("quarkus.default-locale", "en");
+
+    @Localized("en")
+    Messages messages;
+
+    @Test
+    public void testMerge() {
+        assertEquals("Hello", messages.hello());
+        assertEquals("Bye", messages.goodbye());
+        assertEquals("Alpha", messages.foo());
+    }
+
+    @MessageBundle(DEFAULT_NAME)
+    public interface Messages {
+
+        @Message("Hello")
+        String hello();
+
+        @Message
+        String goodbye();
+
+        @Message
+        String foo();
+
+    }
+
+}
