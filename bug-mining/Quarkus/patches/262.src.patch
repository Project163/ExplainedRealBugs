diff --git a/extensions/resteasy-reactive/rest/deployment/src/main/java/io/quarkus/resteasy/reactive/server/deployment/QuarkusInvokerFactory.java b/extensions/resteasy-reactive/rest/deployment/src/main/java/io/quarkus/resteasy/reactive/server/deployment/QuarkusInvokerFactory.java
index 917a0026508..ff2872ce22d 100644
--- a/extensions/resteasy-reactive/rest/deployment/src/main/java/io/quarkus/resteasy/reactive/server/deployment/QuarkusInvokerFactory.java
+++ b/extensions/resteasy-reactive/rest/deployment/src/main/java/io/quarkus/resteasy/reactive/server/deployment/QuarkusInvokerFactory.java
@@ -5,7 +5,9 @@
 import java.lang.reflect.Modifier;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 import java.util.function.Predicate;
 import java.util.function.Supplier;
 
@@ -32,6 +34,8 @@ public class QuarkusInvokerFactory implements EndpointInvokerFactory {
     final BuildProducer<GeneratedClassBuildItem> generatedClassBuildItemBuildProducer;
     final ResteasyReactiveRecorder recorder;
 
+    private final Map<String, Supplier<EndpointInvoker>> generatedInvokers = new HashMap<>();
+
     public QuarkusInvokerFactory(Predicate<String> applicationClassPredicate,
             BuildProducer<GeneratedClassBuildItem> generatedClassBuildItemBuildProducer,
             ResteasyReactiveRecorder recorder) {
@@ -51,6 +55,9 @@ public Supplier<EndpointInvoker> create(ResourceMethod method, ClassInfo current
 
         String baseName = currentClassInfo.name() + "$quarkusrestinvoker$" + method.getName() + "_"
                 + HashUtil.sha1(endpointIdentifier);
+        if (generatedInvokers.containsKey(baseName)) {
+            return generatedInvokers.get(baseName);
+        }
         ClassOutput classOutput = new GeneratedClassGizmo2Adaptor(generatedClassBuildItemBuildProducer, null,
                 applicationClassPredicate.test(currentClassInfo.name().toString()));
         Gizmo g = Gizmo.create(classOutput);
@@ -80,7 +87,9 @@ public Supplier<EndpointInvoker> create(ResourceMethod method, ClassInfo current
                 });
             });
         });
-        return recorder.invoker(baseName);
+        var result = recorder.invoker(baseName);
+        generatedInvokers.put(baseName, result);
+        return result;
     }
 
 }
diff --git a/integration-tests/rest-client-reactive-http2/pom.xml b/integration-tests/rest-client-reactive-http2/pom.xml
index 74c256e26dc..22ad4c221a3 100644
--- a/integration-tests/rest-client-reactive-http2/pom.xml
+++ b/integration-tests/rest-client-reactive-http2/pom.xml
@@ -43,6 +43,11 @@
             <artifactId>vertx-web-client</artifactId>
             <scope>test</scope>
         </dependency>
+      <dependency>
+        <groupId>io.quarkus</groupId>
+        <artifactId>quarkus-junit5-internal</artifactId>
+        <scope>test</scope>
+      </dependency>
 
         <!-- Minimal test dependencies to *-deployment artifacts for consistent build order -->
         <dependency>
@@ -86,6 +91,30 @@
                     </execution>
                 </executions>
             </plugin>
+            <plugin>
+              <groupId>org.apache.maven.plugins</groupId>
+              <artifactId>maven-surefire-plugin</artifactId>
+              <configuration>
+                <runOrder>alphabetical</runOrder>
+              </configuration>
+              <executions>
+                <!--
+                The prod mode tests need to be part of a different execution to ensure that they don't mess with the standard tests.
+                By adding this configuration we ensure that the maven surefire plugin will execute twice, one for the regular **/*Test.java
+                tests (using the 'default-test' execution), and one for the prod mode tests (this 'prod-mode' execution)
+                -->
+                <execution>
+                  <id>prod-mode</id>
+                  <phase>test</phase>
+                  <goals>
+                    <goal>test</goal>
+                  </goals>
+                  <configuration>
+                    <includes>**/*PMT.java</includes>
+                  </configuration>
+                </execution>
+              </executions>
+            </plugin>
         </plugins>
     </build>
 
diff --git a/integration-tests/rest-client-reactive-http2/src/test/java/io/quarkus/it/rest/client/http2/RestMethodInAbstractPMT.java b/integration-tests/rest-client-reactive-http2/src/test/java/io/quarkus/it/rest/client/http2/RestMethodInAbstractPMT.java
new file mode 100644
index 00000000000..a7d9c35c092
--- /dev/null
+++ b/integration-tests/rest-client-reactive-http2/src/test/java/io/quarkus/it/rest/client/http2/RestMethodInAbstractPMT.java
@@ -0,0 +1,75 @@
+package io.quarkus.it.rest.client.http2;
+
+import static io.restassured.RestAssured.get;
+
+import jakarta.ws.rs.GET;
+import jakarta.ws.rs.Path;
+import jakarta.ws.rs.Produces;
+import jakarta.ws.rs.core.MediaType;
+
+import org.eclipse.microprofile.rest.client.inject.RestClient;
+import org.hamcrest.Matchers;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.RegisterExtension;
+
+import io.quarkus.test.QuarkusProdModeTest;
+
+/**
+ * This test does not really belong here, but the only way to create a test for
+ * <a href="https://github.com/quarkusio/quarkus/issues/50314">this issue</a>
+ * is to build a similar REST application in prod mode.
+ */
+public class RestMethodInAbstractPMT {
+
+    @RegisterExtension
+    static QuarkusProdModeTest runner = new QuarkusProdModeTest()
+            .withApplicationRoot((jar) -> jar
+                    .addClasses(BaseResource.class, Resource1.class, Resource2.class, Client.class))
+            .setRun(true);
+
+    @Test
+    public void test() {
+        get("/res1")
+                .then()
+                .statusCode(200)
+                .body(Matchers.equalTo("foo"));
+    }
+
+    public static abstract class BaseResource {
+
+        @GET
+        @Path("/base")
+        @Produces(MediaType.TEXT_PLAIN)
+        public String base() {
+            return "base";
+        }
+    }
+
+    @Path("res1")
+    public static class Resource1 extends BaseResource {
+
+        @GET
+        public String foo() {
+            return "foo";
+        }
+    }
+
+    @Path("res2")
+    public static class Resource2 extends BaseResource {
+
+        @RestClient
+        Client client;
+
+        @GET
+        public String foo() {
+            return "foo";
+        }
+
+        @GET
+        @Path("bar")
+        public String bar() {
+            return "bar";
+        }
+    }
+
+}
