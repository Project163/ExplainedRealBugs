diff --git a/extensions/qute/deployment/src/main/java/io/quarkus/qute/deployment/EffectiveTemplatePathsBuildItem.java b/extensions/qute/deployment/src/main/java/io/quarkus/qute/deployment/EffectiveTemplatePathsBuildItem.java
new file mode 100644
index 00000000000..7e194539e1f
--- /dev/null
+++ b/extensions/qute/deployment/src/main/java/io/quarkus/qute/deployment/EffectiveTemplatePathsBuildItem.java
@@ -0,0 +1,26 @@
+package io.quarkus.qute.deployment;
+
+import java.util.List;
+
+import io.quarkus.builder.item.SimpleBuildItem;
+import io.quarkus.qute.runtime.QuteConfig;
+
+/**
+ * This build item represents all template paths of an application.
+ * <p>
+ * If {@link QuteConfig.DuplicitTemplatesStrategy#PRIORITIZE} is used then duplicit template paths with lower priority are not
+ * included.
+ */
+public final class EffectiveTemplatePathsBuildItem extends SimpleBuildItem {
+
+    private final List<TemplatePathBuildItem> templatePaths;
+
+    EffectiveTemplatePathsBuildItem(List<TemplatePathBuildItem> templatePaths) {
+        this.templatePaths = templatePaths;
+    }
+
+    public List<TemplatePathBuildItem> getTemplatePaths() {
+        return templatePaths;
+    }
+
+}
diff --git a/extensions/qute/deployment/src/main/java/io/quarkus/qute/deployment/QuteDevModeProcessor.java b/extensions/qute/deployment/src/main/java/io/quarkus/qute/deployment/QuteDevModeProcessor.java
index 40cce54b351..8653d5695d5 100644
--- a/extensions/qute/deployment/src/main/java/io/quarkus/qute/deployment/QuteDevModeProcessor.java
+++ b/extensions/qute/deployment/src/main/java/io/quarkus/qute/deployment/QuteDevModeProcessor.java
@@ -2,7 +2,6 @@
 
 import java.lang.reflect.Modifier;
 import java.util.HashMap;
-import java.util.List;
 import java.util.Map;
 import java.util.function.Predicate;
 
@@ -27,10 +26,10 @@
 public class QuteDevModeProcessor {
 
     @BuildStep
-    void collectGeneratedContents(List<TemplatePathBuildItem> templatePaths,
+    void collectGeneratedContents(EffectiveTemplatePathsBuildItem effectiveTemplatePaths,
             BuildProducer<ValidationErrorBuildItem> errors) {
         Map<String, String> contents = new HashMap<>();
-        for (TemplatePathBuildItem template : templatePaths) {
+        for (TemplatePathBuildItem template : effectiveTemplatePaths.getTemplatePaths()) {
             if (!template.isFileBased()) {
                 contents.put(template.getPath(), template.getContent());
             }
diff --git a/extensions/qute/deployment/src/main/java/io/quarkus/qute/deployment/QuteProcessor.java b/extensions/qute/deployment/src/main/java/io/quarkus/qute/deployment/QuteProcessor.java
index 5626e7b972f..cbaea274d9b 100644
--- a/extensions/qute/deployment/src/main/java/io/quarkus/qute/deployment/QuteProcessor.java
+++ b/extensions/qute/deployment/src/main/java/io/quarkus/qute/deployment/QuteProcessor.java
@@ -98,6 +98,7 @@
 import io.quarkus.deployment.pkg.builditem.CurateOutcomeBuildItem;
 import io.quarkus.gizmo.ClassOutput;
 import io.quarkus.gizmo.MethodDescriptor;
+import io.quarkus.logging.Log;
 import io.quarkus.maven.dependency.ArtifactKey;
 import io.quarkus.maven.dependency.DependencyFlags;
 import io.quarkus.maven.dependency.ResolvedDependency;
@@ -291,7 +292,6 @@ AdditionalBeanBuildItem additionalBeans() {
     @BuildStep
     List<CheckedTemplateBuildItem> collectCheckedTemplates(BeanArchiveIndexBuildItem index,
             BuildProducer<BytecodeTransformerBuildItem> transformers,
-            List<TemplatePathBuildItem> templatePaths,
             List<CheckedTemplateAdapterBuildItem> templateAdaptorBuildItems,
             TemplateFilePathsBuildItem filePaths,
             CustomTemplateLocatorPatternsBuildItem locatorPatternsBuildItem) {
@@ -605,7 +605,18 @@ private boolean isNotLocatedByCustomTemplateLocator(
     }
 
     @BuildStep
-    TemplatesAnalysisBuildItem analyzeTemplates(List<TemplatePathBuildItem> templatePaths,
+    EffectiveTemplatePathsBuildItem collectEffectiveTemplatePaths(QuteConfig config,
+            List<TemplatePathBuildItem> templatePaths) {
+        List<TemplatePathBuildItem> effectiveTemplatePaths = switch (config.duplicitTemplatesStrategy()) {
+            case FAIL -> failOnDuplicatePaths(templatePaths);
+            case PRIORITIZE -> prioritizeOnDuplicatePaths(templatePaths);
+            default -> templatePaths;
+        };
+        return new EffectiveTemplatePathsBuildItem(List.copyOf(effectiveTemplatePaths));
+    }
+
+    @BuildStep
+    void analyzeTemplates(EffectiveTemplatePathsBuildItem effectiveTemplatePaths,
             TemplateFilePathsBuildItem filePaths,
             List<CheckedTemplateBuildItem> checkedTemplates,
             List<MessageBundleMethodBuildItem> messageBundleMethods,
@@ -613,11 +624,10 @@ TemplatesAnalysisBuildItem analyzeTemplates(List<TemplatePathBuildItem> template
             List<ValidationParserHookBuildItem> validationParserHooks,
             Optional<EngineConfigurationsBuildItem> engineConfigurations,
             BeanArchiveIndexBuildItem beanArchiveIndex,
-            BuildProducer<CheckedFragmentValidationBuildItem> checkedFragmentValidations) {
+            BuildProducer<CheckedFragmentValidationBuildItem> checkedFragmentValidations,
+            BuildProducer<TemplatesAnalysisBuildItem> templateAnalysis) {
         long start = System.nanoTime();
 
-        checkDuplicatePaths(templatePaths);
-
         List<TemplateAnalysis> analysis = new ArrayList<>();
 
         // A dummy engine instance is used to parse and validate all templates during the build
@@ -625,7 +635,7 @@ TemplatesAnalysisBuildItem analyzeTemplates(List<TemplatePathBuildItem> template
         EngineBuilder builder = Engine.builder().addDefaultSectionHelpers();
 
         // Register user tags
-        for (TemplatePathBuildItem path : templatePaths) {
+        for (TemplatePathBuildItem path : effectiveTemplatePaths.getTemplatePaths()) {
             if (path.isTag()) {
                 String tagPath = path.getPath();
                 String tagName = tagPath.substring(TemplatePathBuildItem.TAGS.length(), tagPath.length());
@@ -685,7 +695,9 @@ public CompletionStage<ResultNode> resolve(SectionResolutionContext context) {
 
             @Override
             public Optional<TemplateLocation> locate(String id) {
-                TemplatePathBuildItem found = templatePaths.stream().filter(p -> p.getPath().equals(id)).findAny().orElse(null);
+                TemplatePathBuildItem found = effectiveTemplatePaths.getTemplatePaths().stream()
+                        .filter(p -> p.getPath().equals(id)).findAny()
+                        .orElse(null);
                 if (found != null) {
                     return Optional.of(new TemplateLocation() {
                         @Override
@@ -767,7 +779,7 @@ public void beforeParsing(ParserHelper parserHelper) {
         List<CheckedTemplateBuildItem> checkedFragments = checkedTemplates.stream().filter(CheckedTemplateBuildItem::isFragment)
                 .collect(Collectors.toList());
 
-        for (TemplatePathBuildItem path : templatePaths) {
+        for (TemplatePathBuildItem path : effectiveTemplatePaths.getTemplatePaths()) {
             Template template = dummyEngine.getTemplate(path.getPath());
             if (template != null) {
                 String templateIdWithoutSuffix = templatePathWithoutSuffix(template.getId(), config);
@@ -802,7 +814,8 @@ public void beforeParsing(ParserHelper parserHelper) {
 
         LOGGER.debugf("Finished analysis of %s templates in %s ms", analysis.size(),
                 TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start));
-        return new TemplatesAnalysisBuildItem(analysis);
+
+        templateAnalysis.produce(new TemplatesAnalysisBuildItem(analysis));
     }
 
     private String templatePathWithoutSuffix(String path, QuteConfig config) {
@@ -1915,7 +1928,6 @@ static String findTemplatePath(TemplatesAnalysisBuildItem analysis, String id) {
     void generateValueResolvers(QuteConfig config, BuildProducer<GeneratedClassBuildItem> generatedClasses,
             BeanArchiveIndexBuildItem beanArchiveIndex,
             ApplicationArchivesBuildItem applicationArchivesBuildItem,
-            List<TemplatePathBuildItem> templatePaths,
             List<TemplateExtensionMethodBuildItem> templateExtensionMethods,
             List<ImplicitValueResolverBuildItem> implicitClasses,
             TemplatesAnalysisBuildItem templatesAnalysis,
@@ -2224,21 +2236,25 @@ public boolean test(String path) {
             // Skip extension archives that are also application archives
             if (!appArtifactKeys.contains(artifact.getKey())) {
                 scanPathTree(artifact.getContentTree(), templateRoots, watchedPaths, templatePaths, nativeImageResources,
-                        config, excludePatterns);
+                        config, excludePatterns, TemplatePathBuildItem.APP_ARCHIVE_PRIORITY);
             }
         }
-        for (ApplicationArchive archive : allApplicationArchives) {
+        for (ApplicationArchive archive : applicationArchives.getApplicationArchives()) {
             archive.accept(
                     tree -> scanPathTree(tree, templateRoots, watchedPaths, templatePaths, nativeImageResources, config,
-                            excludePatterns));
+                            excludePatterns, TemplatePathBuildItem.APP_ARCHIVE_PRIORITY));
         }
+        applicationArchives.getRootArchive().accept(
+                tree -> scanPathTree(tree, templateRoots, watchedPaths, templatePaths, nativeImageResources, config,
+                        excludePatterns, TemplatePathBuildItem.ROOT_ARCHIVE_PRIORITY));
     }
 
     private void scanPathTree(PathTree pathTree, TemplateRootsBuildItem templateRoots,
             BuildProducer<HotDeploymentWatchedFileBuildItem> watchedPaths,
             BuildProducer<TemplatePathBuildItem> templatePaths,
             BuildProducer<NativeImageResourceBuildItem> nativeImageResources,
-            QuteConfig config, List<Pattern> excludePatterns) {
+            QuteConfig config, List<Pattern> excludePatterns,
+            int templatePriority) {
         for (String templateRoot : templateRoots) {
             if (PathTreeUtils.containsCaseSensitivePath(pathTree, templateRoot)) {
                 pathTree.walkIfContains(templateRoot, visit -> {
@@ -2258,7 +2274,7 @@ private void scanPathTree(PathTree pathTree, TemplateRootsBuildItem templateRoot
                             }
                         }
                         produceTemplateBuildItems(templatePaths, watchedPaths, nativeImageResources,
-                                relativePath, templatePath, visit.getPath(), config);
+                                relativePath, templatePath, visit.getPath(), config, templatePriority);
                     }
                 });
             }
@@ -2266,9 +2282,10 @@ private void scanPathTree(PathTree pathTree, TemplateRootsBuildItem templateRoot
     }
 
     @BuildStep
-    TemplateFilePathsBuildItem collectTemplateFilePaths(QuteConfig config, List<TemplatePathBuildItem> templatePaths) {
+    TemplateFilePathsBuildItem collectTemplateFilePaths(QuteConfig config,
+            EffectiveTemplatePathsBuildItem effectiveTemplatePaths) {
         Set<String> filePaths = new HashSet<String>();
-        for (TemplatePathBuildItem templatePath : templatePaths) {
+        for (TemplatePathBuildItem templatePath : effectiveTemplatePaths.getTemplatePaths()) {
             String path = templatePath.getPath();
             filePaths.add(path);
             // Also add version without suffix from the path
@@ -2283,7 +2300,8 @@ TemplateFilePathsBuildItem collectTemplateFilePaths(QuteConfig config, List<Temp
     }
 
     @BuildStep
-    void validateTemplateInjectionPoints(TemplateFilePathsBuildItem filePaths, List<TemplatePathBuildItem> templatePaths,
+    void validateTemplateInjectionPoints(TemplateFilePathsBuildItem filePaths,
+            EffectiveTemplatePathsBuildItem effectiveTemplatePaths,
             ValidationPhaseBuildItem validationPhase, BuildProducer<ValidationErrorBuildItem> validationErrors,
             CustomTemplateLocatorPatternsBuildItem locatorPatternsBuildItem) {
 
@@ -2309,8 +2327,10 @@ && isNotLocatedByCustomTemplateLocator(locatorPatternsBuildItem.getLocationPatte
                                 new TemplateException(
                                         String.format(
                                                 "No template found for path [%s] defined at %s\n\t- available templates: %s",
-                                                name, injectionPoint.getTargetInfo(), templatePaths.stream()
-                                                        .map(TemplatePathBuildItem::getPath).collect(Collectors.toList())))));
+                                                name, injectionPoint.getTargetInfo(),
+                                                effectiveTemplatePaths.getTemplatePaths().stream()
+                                                        .map(TemplatePathBuildItem::getPath)
+                                                        .collect(Collectors.toList())))));
                     }
                 }
             }
@@ -2439,9 +2459,10 @@ private void reportFoundInvalidTarget(BuildProducer<ValidationErrorBuildItem> va
     }
 
     @BuildStep
-    TemplateVariantsBuildItem collectTemplateVariants(List<TemplatePathBuildItem> templatePaths, QuteConfig config)
+    TemplateVariantsBuildItem collectTemplateVariants(EffectiveTemplatePathsBuildItem effectiveTemplatePaths, QuteConfig config)
             throws IOException {
-        Set<String> allPaths = templatePaths.stream().map(TemplatePathBuildItem::getPath).collect(Collectors.toSet());
+        Set<String> allPaths = effectiveTemplatePaths.getTemplatePaths().stream().map(TemplatePathBuildItem::getPath)
+                .collect(Collectors.toSet());
         // Variants are usually used when injecting a template, e.g. @Inject Template foo
         // In this case, the suffix may not specified but the correct template may be selected based on a matching variant
         // For example, the HTTP Accept header may be used to find a matching variant
@@ -2579,13 +2600,13 @@ void collecTemplateContents(BeanArchiveIndexBuildItem index, List<CheckedTemplat
     @BuildStep
     @Record(value = STATIC_INIT)
     void initialize(BuildProducer<SyntheticBeanBuildItem> syntheticBeans, QuteRecorder recorder,
-            List<TemplatePathBuildItem> templatePaths, Optional<TemplateVariantsBuildItem> templateVariants,
+            EffectiveTemplatePathsBuildItem effectiveTemplatePaths, Optional<TemplateVariantsBuildItem> templateVariants,
             TemplateRootsBuildItem templateRoots, List<TemplatePathExcludeBuildItem> templatePathExcludes) {
 
         List<String> templates = new ArrayList<>();
         List<String> tags = new ArrayList<>();
         Map<String, String> templateContents = new HashMap<>();
-        for (TemplatePathBuildItem templatePath : templatePaths) {
+        for (TemplatePathBuildItem templatePath : effectiveTemplatePaths.getTemplatePaths()) {
             if (templatePath.isTag()) {
                 // tags/myTag.html -> myTag.html
                 String tagPath = templatePath.getPath();
@@ -3596,7 +3617,7 @@ public static String getName(InjectionPointInfo injectionPoint) {
     private static void produceTemplateBuildItems(BuildProducer<TemplatePathBuildItem> templatePaths,
             BuildProducer<HotDeploymentWatchedFileBuildItem> watchedPaths,
             BuildProducer<NativeImageResourceBuildItem> nativeImageResources, String resourcePath,
-            String templatePath, Path originalPath, QuteConfig config) {
+            String templatePath, Path originalPath, QuteConfig config, int templatePriority) {
         if (templatePath.isEmpty()) {
             return;
         }
@@ -3613,7 +3634,9 @@ private static void produceTemplateBuildItems(BuildProducer<TemplatePathBuildIte
         templatePaths.produce(TemplatePathBuildItem.builder()
                 .path(templatePath)
                 .fullPath(originalPath)
-                .content(readTemplateContent(originalPath, config.defaultCharset())).build());
+                .priority(templatePriority)
+                .content(readTemplateContent(originalPath, config.defaultCharset()))
+                .build());
     }
 
     private static boolean isExcluded(TypeCheck check, Iterable<Predicate<TypeCheck>> excludes) {
@@ -3625,7 +3648,7 @@ private static boolean isExcluded(TypeCheck check, Iterable<Predicate<TypeCheck>
         return false;
     }
 
-    private void checkDuplicatePaths(List<TemplatePathBuildItem> templatePaths) {
+    private List<TemplatePathBuildItem> failOnDuplicatePaths(List<TemplatePathBuildItem> templatePaths) {
         Map<String, List<TemplatePathBuildItem>> duplicates = templatePaths.stream()
                 .collect(Collectors.groupingBy(TemplatePathBuildItem::getPath));
         for (Iterator<List<TemplatePathBuildItem>> it = duplicates.values().iterator(); it.hasNext();) {
@@ -3635,15 +3658,63 @@ private void checkDuplicatePaths(List<TemplatePathBuildItem> templatePaths) {
             }
         }
         if (!duplicates.isEmpty()) {
-            StringBuilder builder = new StringBuilder("Duplicate templates found:");
-            for (Entry<String, List<TemplatePathBuildItem>> e : duplicates.entrySet()) {
-                builder.append("\n\t- ")
-                        .append(e.getKey())
-                        .append(": ")
-                        .append(e.getValue().stream().map(TemplatePathBuildItem::getSourceInfo).collect(Collectors.toList()));
+            throw newDuplicateError(duplicates);
+        }
+        return templatePaths;
+    }
+
+    private List<TemplatePathBuildItem> prioritizeOnDuplicatePaths(List<TemplatePathBuildItem> templatePaths) {
+        Map<String, List<TemplatePathBuildItem>> groupedByPath = templatePaths.stream()
+                .collect(Collectors.groupingBy(TemplatePathBuildItem::getPath));
+        List<TemplatePathBuildItem> toRemove = new ArrayList<>();
+        for (Iterator<List<TemplatePathBuildItem>> it = groupedByPath.values().iterator(); it.hasNext();) {
+            List<TemplatePathBuildItem> paths = it.next();
+            if (paths.isEmpty() || paths.size() == 1) {
+                it.remove();
+            } else {
+                // Try to resolve the ambiguity...
+                // First sort the templates, higher priority goes first
+                List<TemplatePathBuildItem> sorted = new ArrayList<>(paths);
+                sorted.sort(Comparator.comparingInt(TemplatePathBuildItem::getPriority).reversed());
+                if (sorted.get(0).getPriority() > sorted.get(1).getPriority()) {
+                    // Ambiguity resolved - templates with lower priority must be removed
+                    List<TemplatePathBuildItem> ignored = sorted.subList(1, sorted.size());
+                    Log.debugf("Duplicity resolved: %s is used, templates ignored:\n\t- %s", sorted.get(0).getSourceInfo(),
+                            ignored.stream().map(TemplatePathBuildItem::getSourceInfo).collect(Collectors.joining("\n\t- ")));
+                    it.remove();
+                    ignored.forEach(toRemove::add);
+                }
+            }
+        }
+        if (!groupedByPath.isEmpty()) {
+            // Unresolvable duplicates found
+            throw newDuplicateError(groupedByPath);
+        }
+        if (!toRemove.isEmpty()) {
+            // Some ambiguities were resolved
+            List<TemplatePathBuildItem> effective = new ArrayList<>(templatePaths);
+            for (Iterator<TemplatePathBuildItem> it = effective.iterator(); it.hasNext();) {
+                TemplatePathBuildItem template = it.next();
+                for (TemplatePathBuildItem remove : toRemove) {
+                    if (template == remove) {
+                        it.remove();
+                    }
+                }
             }
-            throw new IllegalStateException(builder.toString());
+            return effective;
+        }
+        return templatePaths;
+    }
+
+    private IllegalStateException newDuplicateError(Map<String, List<TemplatePathBuildItem>> groupedByPath) {
+        StringBuilder builder = new StringBuilder("Duplicate templates found:");
+        for (Entry<String, List<TemplatePathBuildItem>> e : groupedByPath.entrySet()) {
+            builder.append("\n\t- ")
+                    .append(e.getKey())
+                    .append(": ")
+                    .append(e.getValue().stream().map(TemplatePathBuildItem::getSourceInfo).collect(Collectors.toList()));
         }
+        return new IllegalStateException(builder.toString());
     }
 
     static String readTemplateContent(Path path, Charset defaultCharset) {
diff --git a/extensions/qute/deployment/src/main/java/io/quarkus/qute/deployment/TemplatePathBuildItem.java b/extensions/qute/deployment/src/main/java/io/quarkus/qute/deployment/TemplatePathBuildItem.java
index eaa11394115..7704a19aac7 100644
--- a/extensions/qute/deployment/src/main/java/io/quarkus/qute/deployment/TemplatePathBuildItem.java
+++ b/extensions/qute/deployment/src/main/java/io/quarkus/qute/deployment/TemplatePathBuildItem.java
@@ -4,6 +4,7 @@
 import java.util.Objects;
 
 import io.quarkus.builder.item.MultiBuildItem;
+import io.quarkus.qute.runtime.QuteConfig;
 
 /**
  * Discovered template.
@@ -11,10 +12,30 @@
  * Templates backed by files located in a template root are discovered automatically. Furthermore, extensions can produce this
  * build item in order to provide a template that is not backed by a file.
  *
+ * <h2>Warning</h2>
+ *
+ * Extensions should never <i>consume</i> this build item directly. However, they may consume the
+ * {@link EffectiveTemplatePathsBuildItem} instead.
+ *
  * @see TemplateRootBuildItem
  */
 public final class TemplatePathBuildItem extends MultiBuildItem {
 
+    /**
+     * The priority used for templates from the root application archive.
+     */
+    public static final int ROOT_ARCHIVE_PRIORITY = 30;
+
+    /**
+     * The default priority used for templates that are not backed by a file.
+     */
+    public static final int BUILD_ITEM_PRIORITY = 20;
+
+    /**
+     * The priority used for templates from non-root application archives.
+     */
+    public static final int APP_ARCHIVE_PRIORITY = 10;
+
     /**
      *
      * @return a new builder instance
@@ -30,6 +51,8 @@ public static Builder builder() {
     private final Path fullPath;
     private final String extensionInfo;
 
+    private final int priority;
+
     /**
      *
      * @param path
@@ -37,16 +60,18 @@ public static Builder builder() {
      * @param content
      * @deprecated Use the {@link #builder()} instead
      */
-    @Deprecated
+    @Deprecated(forRemoval = true, since = "3.13")
     public TemplatePathBuildItem(String path, Path fullPath, String content) {
-        this(Objects.requireNonNull(path), Objects.requireNonNull(content), Objects.requireNonNull(fullPath), null);
+        this(Objects.requireNonNull(path), Objects.requireNonNull(content), Objects.requireNonNull(fullPath), null,
+                BUILD_ITEM_PRIORITY);
     }
 
-    private TemplatePathBuildItem(String path, String content, Path fullPath, String extensionInfo) {
+    private TemplatePathBuildItem(String path, String content, Path fullPath, String extensionInfo, int priority) {
         this.path = path;
         this.content = content;
         this.fullPath = fullPath;
         this.extensionInfo = extensionInfo;
+        this.priority = priority;
     }
 
     /**
@@ -86,6 +111,15 @@ public String getExtensionInfo() {
         return extensionInfo;
     }
 
+    /**
+     * Templates with higher priority take precedence when duplicates are found.
+     *
+     * @return the priority
+     */
+    public int getPriority() {
+        return priority;
+    }
+
     /**
      *
      * @return {@code true} if it represents a user tag, {@code false} otherwise
@@ -111,7 +145,7 @@ public boolean isFileBased() {
     }
 
     public String getSourceInfo() {
-        return isFileBased() ? getFullPath().toString() : extensionInfo;
+        return (isFileBased() ? getFullPath().toString() : extensionInfo) + " [" + getPriority() + "]";
     }
 
     public static class Builder {
@@ -120,6 +154,7 @@ public static class Builder {
         private String content;
         private Path fullPath;
         private String extensionInfo;
+        private int priority = BUILD_ITEM_PRIORITY;
 
         /**
          * Set the path relative to the template root. The {@code /} is used as a path separator.
@@ -168,11 +203,23 @@ public Builder extensionInfo(String info) {
             return this;
         }
 
+        /**
+         * Set the priority of the template.
+         *
+         * @param priority
+         * @return self
+         * @see QuteConfig#duplicitTemplatesStrategy()
+         */
+        public Builder priority(int priority) {
+            this.priority = priority;
+            return this;
+        }
+
         public TemplatePathBuildItem build() {
             if (fullPath == null && extensionInfo == null) {
                 throw new IllegalStateException("Templates that are not backed by a file must provide extension info");
             }
-            return new TemplatePathBuildItem(path, content, fullPath, extensionInfo);
+            return new TemplatePathBuildItem(path, content, fullPath, extensionInfo, priority);
         }
 
     }
diff --git a/extensions/qute/deployment/src/main/java/io/quarkus/qute/deployment/devui/QuteDevUIProcessor.java b/extensions/qute/deployment/src/main/java/io/quarkus/qute/deployment/devui/QuteDevUIProcessor.java
index 0ab61fe4479..6c01d8efafb 100644
--- a/extensions/qute/deployment/src/main/java/io/quarkus/qute/deployment/devui/QuteDevUIProcessor.java
+++ b/extensions/qute/deployment/src/main/java/io/quarkus/qute/deployment/devui/QuteDevUIProcessor.java
@@ -20,6 +20,7 @@
 import io.quarkus.devui.spi.page.Page;
 import io.quarkus.qute.ParameterDeclaration;
 import io.quarkus.qute.deployment.CheckedTemplateBuildItem;
+import io.quarkus.qute.deployment.EffectiveTemplatePathsBuildItem;
 import io.quarkus.qute.deployment.ImplicitValueResolverBuildItem;
 import io.quarkus.qute.deployment.TemplateDataBuildItem;
 import io.quarkus.qute.deployment.TemplateExtensionMethodBuildItem;
@@ -33,7 +34,7 @@ public class QuteDevUIProcessor {
 
     @BuildStep(onlyIf = IsDevelopment.class)
     public void pages(
-            List<TemplatePathBuildItem> templatePaths,
+            EffectiveTemplatePathsBuildItem effectiveTemplatePaths,
             List<CheckedTemplateBuildItem> checkedTemplates,
             TemplateVariantsBuildItem variants,
             TemplatesAnalysisBuildItem templatesAnalysis,
@@ -45,7 +46,7 @@ public void pages(
 
         CardPageBuildItem pageBuildItem = new CardPageBuildItem();
 
-        List<TemplatePathBuildItem> sortedTemplatePaths = templatePaths.stream()
+        List<TemplatePathBuildItem> sortedTemplatePaths = effectiveTemplatePaths.getTemplatePaths().stream()
                 .sorted(Comparator.comparing(tp -> tp.getPath().toLowerCase())).collect(Collectors.toList());
         pageBuildItem.addBuildTimeData("templates",
                 createTemplatesJson(sortedTemplatePaths, checkedTemplates, templatesAnalysis, variants));
diff --git a/extensions/qute/deployment/src/test/java/io/quarkus/qute/deployment/builditemtemplate/AdditionalTemplatePathDuplicatesResolvedTest.java b/extensions/qute/deployment/src/test/java/io/quarkus/qute/deployment/builditemtemplate/AdditionalTemplatePathDuplicatesResolvedTest.java
new file mode 100644
index 00000000000..763e29ec722
--- /dev/null
+++ b/extensions/qute/deployment/src/test/java/io/quarkus/qute/deployment/builditemtemplate/AdditionalTemplatePathDuplicatesResolvedTest.java
@@ -0,0 +1,58 @@
+package io.quarkus.qute.deployment.builditemtemplate;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+
+import java.util.function.Consumer;
+
+import jakarta.inject.Inject;
+
+import org.jboss.shrinkwrap.api.asset.StringAsset;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.RegisterExtension;
+
+import io.quarkus.builder.BuildChainBuilder;
+import io.quarkus.builder.BuildContext;
+import io.quarkus.builder.BuildStep;
+import io.quarkus.qute.Template;
+import io.quarkus.qute.deployment.TemplatePathBuildItem;
+import io.quarkus.test.QuarkusUnitTest;
+
+public class AdditionalTemplatePathDuplicatesResolvedTest {
+
+    @RegisterExtension
+    static final QuarkusUnitTest config = new QuarkusUnitTest()
+            .withApplicationRoot(root -> root
+                    .addAsResource(new StringAsset("Hi {name}!"), "templates/hi.txt"))
+            .addBuildChainCustomizer(buildCustomizer());
+
+    static Consumer<BuildChainBuilder> buildCustomizer() {
+        return new Consumer<BuildChainBuilder>() {
+            @Override
+            public void accept(BuildChainBuilder builder) {
+                builder.addBuildStep(new BuildStep() {
+                    @Override
+                    public void execute(BuildContext context) {
+                        context.produce(TemplatePathBuildItem.builder()
+                                .path("hi.txt")
+                                .extensionInfo("test-ext")
+                                .content("Hello {name}!")
+                                .priority(100)
+                                .build());
+                    }
+                }).produces(TemplatePathBuildItem.class)
+                        .build();
+
+            }
+        };
+    }
+
+    @Inject
+    Template hi;
+
+    @Test
+    public void testHi() {
+        // Build item with higher priority takes precedence
+        assertEquals("Hello Lu!", hi.data("name", "Lu").render());
+    }
+
+}
diff --git a/extensions/qute/deployment/src/test/java/io/quarkus/qute/deployment/builditemtemplate/AdditionalTemplatePathDuplicatesTest.java b/extensions/qute/deployment/src/test/java/io/quarkus/qute/deployment/builditemtemplate/AdditionalTemplatePathDuplicatesTest.java
index 4f2ac577bfa..0a8781bda57 100644
--- a/extensions/qute/deployment/src/test/java/io/quarkus/qute/deployment/builditemtemplate/AdditionalTemplatePathDuplicatesTest.java
+++ b/extensions/qute/deployment/src/test/java/io/quarkus/qute/deployment/builditemtemplate/AdditionalTemplatePathDuplicatesTest.java
@@ -20,6 +20,7 @@ public class AdditionalTemplatePathDuplicatesTest {
     static final QuarkusUnitTest config = new QuarkusUnitTest()
             .withApplicationRoot(root -> root
                     .addAsResource(new StringAsset("Hi {name}!"), "templates/hi.txt"))
+            .overrideConfigKey("quarkus.qute.duplicit-templates-strategy", "fail")
             .addBuildChainCustomizer(buildCustomizer())
             .setExpectedException(IllegalStateException.class, true);
 
diff --git a/extensions/qute/deployment/src/test/java/io/quarkus/qute/deployment/scanning/DuplicateTemplatesResolvedTest.java b/extensions/qute/deployment/src/test/java/io/quarkus/qute/deployment/scanning/DuplicateTemplatesResolvedTest.java
new file mode 100644
index 00000000000..b276934547b
--- /dev/null
+++ b/extensions/qute/deployment/src/test/java/io/quarkus/qute/deployment/scanning/DuplicateTemplatesResolvedTest.java
@@ -0,0 +1,31 @@
+package io.quarkus.qute.deployment.scanning;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+
+import jakarta.inject.Inject;
+
+import org.jboss.shrinkwrap.api.asset.StringAsset;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.RegisterExtension;
+
+import io.quarkus.qute.Template;
+import io.quarkus.test.QuarkusUnitTest;
+
+public class DuplicateTemplatesResolvedTest {
+
+    @RegisterExtension
+    static final QuarkusUnitTest config = new QuarkusUnitTest()
+            .withApplicationRoot(root -> root.addAsResource(new StringAsset("Hello!"), "templates/hello.html"))
+            .withAdditionalDependency(
+                    d -> d.addAsResource(new StringAsset("Hi!"), "templates/hello.html"));
+
+    @Inject
+    Template hello;
+
+    @Test
+    public void testHello() {
+        // Root archive takes precedence
+        assertEquals("Hello!", hello.render());
+    }
+
+}
diff --git a/extensions/qute/deployment/src/test/java/io/quarkus/qute/deployment/scanning/MultipleTemplatesDirectoryDuplicateFoundTest.java b/extensions/qute/deployment/src/test/java/io/quarkus/qute/deployment/scanning/MultipleTemplatesDirectoryDuplicateFoundTest.java
index 9e1c13a1128..f269cddc596 100644
--- a/extensions/qute/deployment/src/test/java/io/quarkus/qute/deployment/scanning/MultipleTemplatesDirectoryDuplicateFoundTest.java
+++ b/extensions/qute/deployment/src/test/java/io/quarkus/qute/deployment/scanning/MultipleTemplatesDirectoryDuplicateFoundTest.java
@@ -17,6 +17,7 @@ public class MultipleTemplatesDirectoryDuplicateFoundTest {
             .withApplicationRoot(root -> root.addAsResource(new StringAsset("Hello!"), "templates/hello.html"))
             .withAdditionalDependency(
                     d -> d.addAsResource(new StringAsset("Hi!"), "templates/hello.html"))
+            .overrideConfigKey("quarkus.qute.duplicit-templates-strategy", "fail")
             .assertException(t -> {
                 Throwable e = t;
                 IllegalStateException ise = null;
diff --git a/extensions/qute/runtime/src/main/java/io/quarkus/qute/runtime/EngineProducer.java b/extensions/qute/runtime/src/main/java/io/quarkus/qute/runtime/EngineProducer.java
index a09d9e85d15..c730bf2ec19 100644
--- a/extensions/qute/runtime/src/main/java/io/quarkus/qute/runtime/EngineProducer.java
+++ b/extensions/qute/runtime/src/main/java/io/quarkus/qute/runtime/EngineProducer.java
@@ -82,7 +82,6 @@ public class EngineProducer {
 
     private final Engine engine;
     private final ContentTypes contentTypes;
-    private final List<String> tags;
     private final List<String> suffixes;
     private final Set<String> templateRoots;
     private final Map<String, String> templateContents;
@@ -100,7 +99,6 @@ public EngineProducer(QuteContext context, QuteConfig config, QuteRuntimeConfig
         this.suffixes = config.suffixes();
         this.templateRoots = context.getTemplateRoots();
         this.templateContents = Map.copyOf(context.getTemplateContents());
-        this.tags = context.getTags();
         this.defaultLocale = locales.defaultLocale().orElse(Locale.getDefault());
         this.defaultCharset = config.defaultCharset();
         this.container = Arc.container();
@@ -112,7 +110,8 @@ public EngineProducer(QuteContext context, QuteConfig config, QuteRuntimeConfig
         }
         this.templatePathExcludes = excludesBuilder.build();
 
-        LOGGER.debugf("Initializing Qute [templates: %s, tags: %s, resolvers: %s", context.getTemplatePaths(), tags,
+        LOGGER.debugf("Initializing Qute [templates: %s, tags: %s, resolvers: %s", context.getTemplatePaths(),
+                context.getTags(),
                 context.getResolverClasses());
 
         EngineBuilder builder = Engine.builder();
@@ -219,7 +218,7 @@ public EngineProducer(QuteContext context, QuteConfig config, QuteRuntimeConfig
             LOGGER.debugf("Added generated value resolver: %s", resolverClass);
         }
         // Add tags
-        for (String tag : tags) {
+        for (String tag : context.getTags()) {
             // Strip suffix, item.html -> item
             String tagName = tag.contains(".") ? tag.substring(0, tag.indexOf('.')) : tag;
             String tagTemplateId = TAGS + tagName;
@@ -375,7 +374,27 @@ private Optional<TemplateLocation> locate(String path) {
         if (isExcluded(path)) {
             return Optional.empty();
         }
-        // First try to locate file-based templates
+        // First try the template contents, i.e. templates not backed by files
+        LOGGER.debugf("Locate template contents for %s", path);
+        String content = templateContents.get(path);
+        if (content == null) {
+            // Try path with suffixes
+            for (String suffix : suffixes) {
+                String pathWithSuffix = path + "." + suffix;
+                if (isExcluded(pathWithSuffix)) {
+                    continue;
+                }
+                content = templateContents.get(pathWithSuffix);
+                if (content != null) {
+                    break;
+                }
+            }
+        }
+        if (content != null) {
+            return Optional.of(new ContentTemplateLocation(content, createVariant(path)));
+        }
+
+        // Then try to locate file-based templates
         for (String templateRoot : templateRoots) {
             URL resource = null;
             String templatePath = templateRoot + path;
@@ -399,25 +418,7 @@ private Optional<TemplateLocation> locate(String path) {
                 return Optional.of(new ResourceTemplateLocation(resource, createVariant(templatePath)));
             }
         }
-        // Then try the template contents
-        LOGGER.debugf("Locate template contents for %s", path);
-        String content = templateContents.get(path);
-        if (content == null) {
-            // Try path with suffixes
-            for (String suffix : suffixes) {
-                String pathWithSuffix = path + "." + suffix;
-                if (isExcluded(pathWithSuffix)) {
-                    continue;
-                }
-                content = templateContents.get(pathWithSuffix);
-                if (content != null) {
-                    break;
-                }
-            }
-        }
-        if (content != null) {
-            return Optional.of(new ContentTemplateLocation(content, createVariant(path)));
-        }
+
         return Optional.empty();
     }
 
diff --git a/extensions/qute/runtime/src/main/java/io/quarkus/qute/runtime/QuteConfig.java b/extensions/qute/runtime/src/main/java/io/quarkus/qute/runtime/QuteConfig.java
index 63049f991e8..c37d7476df9 100644
--- a/extensions/qute/runtime/src/main/java/io/quarkus/qute/runtime/QuteConfig.java
+++ b/extensions/qute/runtime/src/main/java/io/quarkus/qute/runtime/QuteConfig.java
@@ -89,6 +89,12 @@ public interface QuteConfig {
     @WithDefault("UTF-8")
     Charset defaultCharset();
 
+    /**
+     * The strategy used when multiple templates with the same path are found in the application.
+     */
+    @WithDefault("PRIORITIZE")
+    DuplicitTemplatesStrategy duplicitTemplatesStrategy();
+
     /**
      * Development mode configuration.
      */
@@ -99,4 +105,23 @@ public interface QuteConfig {
      */
     QuteTestModeConfig testMode();
 
+    public enum DuplicitTemplatesStrategy {
+
+        /**
+         * If multiple templates with the same path are found then determine the highest priority value and eliminate all
+         * templates with lowest priority. If there is exactly one template remaining then use this template. Otherwise, fail
+         * the build.
+         * <p>
+         * Templates from the root application archive have the priority {@code 30}. Templates from other application archives
+         * have the priority {@code 10}. Templates from build items can define any priority.
+         */
+        PRIORITIZE,
+
+        /**
+         * Fail the build if multiple templates with the same path are found.
+         */
+        FAIL,
+
+    }
+
 }
