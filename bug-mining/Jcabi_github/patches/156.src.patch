diff --git a/src/main/java/com/jcabi/github/wire/CarefulWire.java b/src/main/java/com/jcabi/github/wire/CarefulWire.java
index 324f539c2..1a9390e1b 100644
--- a/src/main/java/com/jcabi/github/wire/CarefulWire.java
+++ b/src/main/java/com/jcabi/github/wire/CarefulWire.java
@@ -29,6 +29,7 @@
  */
 package com.jcabi.github.wire;
 
+import com.jcabi.aspects.Immutable;
 import com.jcabi.log.Logger;
 import com.rexsl.test.Request;
 import com.rexsl.test.Response;
@@ -66,8 +67,9 @@ import lombok.ToString;
  * @author Alexander Sinyagin (sinyagin.alexander@gmail.com)
  * @version $Id$
  */
+@Immutable
 @ToString
-@EqualsAndHashCode(of = "origin")
+@EqualsAndHashCode(of = { "origin", "threshold" })
 public final class CarefulWire implements Wire {
 
     /**
@@ -77,32 +79,21 @@ public final class CarefulWire implements Wire {
 
     /**
      * Threshold of number of remaining requests, below which requests are
-     * blocked before reset.
+     * blocked until reset.
      */
     private final transient int threshold;
 
-    /**
-     * Time of limit resetting. If it's 0, there is no need to block requests.
-     */
-    private transient long resetTime;
-
-    /**
-     * Monitor for the resetTime.
-     */
-    private final transient Object resetTimeMonitor = new Object();
-
     /**
      * Public ctor.
      *
      * @param wire Original wire
-     * @param threshold Threshold of number of remaining requests, below which
-     *  requests are blocked before reset
-     * @checkstyle HiddenField (3 lines)
+     * @param thrshld Threshold of number of remaining requests, below which
+     *  requests are blocked util reset
      */
     public CarefulWire(@NotNull(message = "wire can't be NULL")
-        final Wire wire, final int threshold) {
+        final Wire wire, final int thrshld) {
         this.origin = wire;
-        this.threshold = threshold;
+        this.threshold = thrshld;
     }
 
     /**
@@ -114,40 +105,30 @@ public final class CarefulWire implements Wire {
         final String method,
         final Collection<Map.Entry<String, String>> headers,
         final byte[] content) throws IOException {
-        synchronized (this.resetTimeMonitor) {
-            if (this.resetTime != 0) {
-                // @checkstyle MagicNumber (1 line)
-                final long now = System.currentTimeMillis() / 1000L;
-                if (this.resetTime > now) {
-                    final long length = this.resetTime - now;
-                    Logger.info(
-                        this,
-                        // @checkstyle LineLength (1 line)
-                        "Remaining number of requests per hour is less than %d. Waiting for %d seconds.",
-                        this.threshold, length
-                    );
-                    try {
-                        // @checkstyle MagicNumber (1 line)
-                        Thread.sleep(length * 1000L);
-                    } catch (final InterruptedException ex) {
-                        throw new IOException(ex);
-                    }
-                }
-                this.resetTime = 0L;
-            }
-        }
         final Response resp = this.origin
             .send(req, home, method, headers, content);
-        final String remainingHeader = "X-RateLimit-Remaining";
-        if (resp.headers().containsKey(remainingHeader)) {
-            final int remaining = Integer.parseInt(
-                resp.headers().get(remainingHeader).get(0)
+        final int remaining = Integer.parseInt(
+            resp.headers().get("X-RateLimit-Remaining").get(0)
+        );
+        if (remaining < this.threshold) {
+            final long reset = Long.parseLong(
+                resp.headers().get("X-RateLimit-Reset").get(0)
             );
-            if (remaining < this.threshold) {
-                synchronized (this.resetTimeMonitor) {
-                    this.resetTime = Long.parseLong(
-                        resp.headers().get("X-RateLimit-Reset").get(0)
-                    );
+            // @checkstyle MagicNumber (1 line)
+            final long now = System.currentTimeMillis() / 1000L;
+            if (reset > now) {
+                final long length = reset - now;
+                Logger.info(
+                    this,
+                    // @checkstyle LineLength (1 line)
+                    "Remaining number of requests per hour is less than %d. Waiting for %d seconds.",
+                    this.threshold, length
+                );
+                try {
+                    // @checkstyle MagicNumber (1 line)
+                    Thread.sleep(length * 1000L);
+                } catch (final InterruptedException ex) {
+                    throw new IOException(ex);
                 }
             }
         }
diff --git a/src/site/markdown/respect-limits.apt.vm b/src/site/apt/respect-limits.apt.vm
similarity index 75%
rename from src/site/markdown/respect-limits.apt.vm
rename to src/site/apt/respect-limits.apt.vm
index f61b191bc..38ab2f808 100644
--- a/src/site/markdown/respect-limits.apt.vm
+++ b/src/site/apt/respect-limits.apt.vm
@@ -1,10 +1,10 @@
-------
-Respect Limits
-------
-Alexander Sinyagin
-------
-2014-01-08
-------
+ ------
+ Respect Limits
+ ------
+ Alexander Sinyagin
+ ------
+ 2014-01-08
+ ------
 
 ~~
 ~~ Copyright (c) 2014, jcabi.com
@@ -41,14 +41,20 @@ Respect Limits
   Github has limits for number of request per hour. It
   sets following headers describing current state of rate limit in each
   response: <<<X-RateLimit-Limit>>>, <<<X-RateLimit-Remaining>>>, and
-  <<<X-RateLimit-Reset>>>. For further information see {{{http://developer.github.com/v3/#rate-limiting}} API Documentation}).
+  <<<X-RateLimit-Reset>>>. For further information see
+  {{{http://developer.github.com/v3/#rate-limiting} API Documentation}}.
 
-  If you want to control limits, you can use {{{./apidocs-${project.version}/com/github/jcabi/wire/CarefulWare.html}}<<<CarefulWare>>>} class for it.
-  If <<<X-RateLimit-Remaining>>> is less than a given threshold, on next request
-  {{{./apidocs-${project.version}/com/github/jcabi/wire/CarefulWare.html}}<<<CarefulWare>>>}
+  If you want to control limits, you can use
+  {{{./apidocs-${project.version}/com/github/jcabi/wire/CarefulWare.html}<<<CarefulWare>>>}}
+  class for it. If <<<X-RateLimit-Remaining>>> of received response is less than
+  a given threshold,
+  {{{./apidocs-${project.version}/com/github/jcabi/wire/CarefulWare.html}<<<CarefulWare>>>}}
   will sleep until a time specified in the <<<X-RateLimit-Reset>>> header.
 
-  You can use {{{./apidocs-${project.version}/com/github/jcabi/wire/CarefulWare.html}}<<<CarefulWare>>>} with {{{./apidocs-${project.version}/com/github/jcabi/Github.html}}Github}:
+  You can use
+  {{{./apidocs-${project.version}/com/github/jcabi/wire/CarefulWare.html}<<<CarefulWare>>>}}
+  with
+  {{{./apidocs-${project.version}/com/github/jcabi/Github.html}<<<Github>>>}}:
 
 +--
 Github github = new RtGithub(
diff --git a/src/test/java/com/jcabi/github/wire/CarefulWireTest.java b/src/test/java/com/jcabi/github/wire/CarefulWireTest.java
index a9bc17a52..943ed5f09 100644
--- a/src/test/java/com/jcabi/github/wire/CarefulWireTest.java
+++ b/src/test/java/com/jcabi/github/wire/CarefulWireTest.java
@@ -29,20 +29,12 @@
  */
 package com.jcabi.github.wire;
 
-import com.rexsl.test.Request;
-import com.rexsl.test.Response;
-import com.rexsl.test.Wire;
-import com.rexsl.test.request.ApacheRequest;
+import com.rexsl.test.request.FakeRequest;
 import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
+import java.net.HttpURLConnection;
 import org.hamcrest.MatcherAssert;
 import org.hamcrest.Matchers;
 import org.junit.Test;
-import org.mockito.Mockito;
 
 /**
  * Test case for {@link CarefulWire}.
@@ -53,45 +45,23 @@ import org.mockito.Mockito;
 public final class CarefulWireTest {
 
     /**
-     * CarefulWire can wait before the limit reset.
+     * CarefulWire can wait until the limit reset.
      * @throws IOException If some problem inside
      */
     @Test
     public void waitBeforeReset() throws IOException {
-        final Response resp = Mockito.mock(Response.class);
+        final int threshold = 10;
         // @checkstyle MagicNumber (1 line)
-        final long resetTime = System.currentTimeMillis() / 1000L + 5L;
-        final ConcurrentHashMap<String, List<String>> headers =
-            new ConcurrentHashMap<String, List<String>>(1);
-        final List<String> remainingval = new ArrayList<String>(1);
-        remainingval.add("9");
-        headers.put("X-RateLimit-Remaining", remainingval);
-        final List<String> resetval = new ArrayList<String>(1);
-        resetval.add(String.valueOf(resetTime));
-        headers.put("X-RateLimit-Reset", resetval);
-        Mockito.when(resp.headers()).thenReturn(headers);
-        final long[] requestTime = new long[1];
-        final Wire origin = new Wire() {
-            // @checkstyle ParameterNumber (5 lines)
-            @Override
-            public Response send(final Request req, final String home,
-                final String method,
-                final Collection<Map.Entry<String, String>> headers,
-                final byte[] content) {
-                // @checkstyle MagicNumber (1 line)
-                requestTime[0] = System.currentTimeMillis() / 1000L;
-                return resp;
-            }
-        };
-        final Wire wire = new CarefulWire(origin, 10);
-        final Request req = new ApacheRequest("");
-        final Collection<Map.Entry<String, String>> reqHeaders =
-            new ArrayList<Map.Entry<String, String>>(0);
-        final byte[] content = new byte[1];
-        wire.send(req, "", "", reqHeaders, content);
-        wire.send(req, "", "", reqHeaders, content);
-        MatcherAssert.assertThat(
-            requestTime[0], Matchers.greaterThanOrEqualTo(resetTime)
-        );
+        final long reset = System.currentTimeMillis() / 1000L + 5L;
+        new FakeRequest()
+            .withStatus(HttpURLConnection.HTTP_OK)
+            .withReason("OK")
+            .withHeader("X-RateLimit-Remaining", "9")
+            .withHeader("X-RateLimit-Reset", String.valueOf(reset))
+            .through(CarefulWire.class, threshold)
+            .fetch();
+        // @checkstyle MagicNumber (1 line)
+        final long now = System.currentTimeMillis() / 1000L;
+        MatcherAssert.assertThat(now, Matchers.greaterThanOrEqualTo(reset));
     }
 }
