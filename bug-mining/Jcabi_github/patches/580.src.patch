diff --git a/src/main/java/com/jcabi/github/Contents.java b/src/main/java/com/jcabi/github/Contents.java
index 585bd2097..fe44593ec 100644
--- a/src/main/java/com/jcabi/github/Contents.java
+++ b/src/main/java/com/jcabi/github/Contents.java
@@ -89,7 +89,7 @@ public interface Contents {
         throws IOException;
 
     /**
-     * Get the contents of a file or directory in a repository.
+     * Get the contents of a file or symbolic link in a repository.
      * @param path The content path
      * @param ref The name of the commit/branch/tag. Default: the repository's default branch (usually master)
      * @return Content fetched
@@ -101,6 +101,19 @@ public interface Contents {
         @NotNull(message = "ref is never NULL") String ref)
         throws IOException;
 
+    /**
+     * Get the contents of a directory in a repository.
+     * @param path The content path
+     * @param ref The name of the commit/branch/tag. Default: the repository's default branch (usually master)
+     * @return Contents fetched
+     * @throws IOException If there is any I/O problem
+     * @see <a href="http://developer.github.com/v3/repos/contents/#get-contents">Get contents</a>
+     */
+    Iterable<Content> iterate(
+        @NotNull(message = "path  is never NULL") String path,
+        @NotNull(message = "ref is never NULL") String ref)
+        throws IOException;
+
     /**
      * Removes a file.
      * @param content Parameters to remove a file
diff --git a/src/main/java/com/jcabi/github/RtContents.java b/src/main/java/com/jcabi/github/RtContents.java
index c8a88c591..fd475e647 100644
--- a/src/main/java/com/jcabi/github/RtContents.java
+++ b/src/main/java/com/jcabi/github/RtContents.java
@@ -188,6 +188,32 @@ final class RtContents implements Contents {
         );
     }
 
+    @Override
+    @NotNull(message = "Iterable of Content can't be NULL")
+    public Iterable<Content> iterate(
+        @NotNull(message = "path can't be NULL") final String path,
+        @NotNull(message = "ref can't be NULL") final String ref
+    ) throws IOException {
+        final JsonStructure json = Json.createObjectBuilder()
+            .add("path", path)
+            .add("ref", ref)
+            .build();
+        return new RtPagination<Content>(
+            this.request.method(Request.GET)
+                .uri().path(path).back()
+                .body().set(json).back(),
+            new RtPagination.Mapping<Content, JsonObject>() {
+                @Override
+                public Content map(final JsonObject object) {
+                    return new RtContent(
+                        RtContents.this.entry, RtContents.this.owner,
+                        object.getString("path")
+                    );
+                };
+            }
+        );
+    }
+
     @Override
     @NotNull(message = "Repo commit is never NULL")
     public RepoCommit remove(@NotNull(message = "content can't be NULL")
diff --git a/src/main/java/com/jcabi/github/mock/MkContents.java b/src/main/java/com/jcabi/github/mock/MkContents.java
index 79b31b430..624b07f12 100644
--- a/src/main/java/com/jcabi/github/mock/MkContents.java
+++ b/src/main/java/com/jcabi/github/mock/MkContents.java
@@ -163,6 +163,23 @@ final class MkContents implements Contents {
         return new MkContent(this.storage, this.self, this.coords, path, ref);
     }
 
+    /**
+     * {@inheritDoc}
+     * @todo #684 Let's implement MkContents.iterate() for returning directory
+     *  contents. Since we are using XML in MkStorage, we don't actually have
+     *  directories. What we can do instead, is use the given path as a prefix,
+     *  with the '/' character as separators. For example, if we have two
+     *  different content objects with paths "foo/bar", "foo/baz, and "baa/boo"
+     *  iterate should return the first two when the path "foo" or "foo/" is
+     *  specified.
+     */
+    @Override
+    @NotNull(message = "Iterable of contents is never NULL")
+    public Iterable<Content> iterate(final String path, final String ref)
+        throws IOException {
+        throw new UnsupportedOperationException("Not yet implemented.");
+    }
+
     @Override
     @NotNull(message = "commit is never NULL")
     public RepoCommit remove(
diff --git a/src/test/java/com/jcabi/github/RtContentsTest.java b/src/test/java/com/jcabi/github/RtContentsTest.java
index 9d6487892..30461b1af 100644
--- a/src/test/java/com/jcabi/github/RtContentsTest.java
+++ b/src/test/java/com/jcabi/github/RtContentsTest.java
@@ -38,6 +38,7 @@ import com.jcabi.http.mock.MkQuery;
 import com.jcabi.http.request.ApacheRequest;
 import java.net.HttpURLConnection;
 import javax.json.Json;
+import javax.json.JsonArray;
 import javax.json.JsonObject;
 import org.hamcrest.MatcherAssert;
 import org.hamcrest.Matchers;
@@ -49,7 +50,7 @@ import org.mockito.Mockito;
  * @author Andres Candal (andres.candal@rollasolution.com)
  * @version $Id$
  * @since 0.8
- * @checkstyle MultipleStringLiteralsCheck (350 lines)
+ * @checkstyle MultipleStringLiteralsCheck (500 lines)
  */
 @Immutable
 @SuppressWarnings("PMD.AvoidDuplicateLiterals")
@@ -348,6 +349,40 @@ public final class RtContentsTest {
         }
     }
 
+    /**
+     * RtContents can iterate through a directory's contents.
+     * @throws Exception If something goes wrong.
+     */
+    @Test
+    public void canIterateDirectoryContents() throws Exception {
+        final JsonArray body = Json.createArrayBuilder().add(
+            Json.createObjectBuilder()
+                .add("path", "README.md")
+                .build()
+        ).add(
+            Json.createObjectBuilder()
+                .add("path", ".gitignore")
+                .build()
+        ).build();
+        final MkContainer container = new MkGrizzlyContainer().next(
+            new MkAnswer.Simple(HttpURLConnection.HTTP_OK, body.toString())
+        ).next(new MkAnswer.Simple("{\"path\":\"README.md\"}"))
+            .next(new MkAnswer.Simple("{\"path\":\".gitignore\"}"))
+            .start();
+        final RtContents contents = new RtContents(
+            new ApacheRequest(container.home()),
+            repo()
+        );
+        try {
+            MatcherAssert.assertThat(
+                contents.iterate("dir", "branch2"),
+                Matchers.<Content>iterableWithSize(2)
+            );
+        } finally {
+            container.stop();
+        }
+    }
+
     /**
      * Create and return repo for testing.
      * @return Repo
