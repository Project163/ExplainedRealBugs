diff --git a/.travis.yml b/.travis.yml
index 5168c49..e4b9a58 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -27,10 +27,10 @@ install:
         choco install python3;
         export PATH=/c/Python37:/c/Python37/Scripts:/c/Python38:/c/Python38/Scripts:$PATH;
         python -m pip install -U click h11 wsproto==0.13.* websockets==8.*;
-        python -m pip install -U autoflake black codecov isort pytest pytest-cov requests;
+        python -m pip install -U autoflake black codecov isort pytest pytest-cov requests watchdog;
       elif [ "$TRAVIS_PYTHON_VERSION" = "pypy3" ]; then
         pip install -U click h11 wsproto==0.13.*;
-        pip install -U autoflake codecov isort pytest pytest-cov requests;
+        pip install -U autoflake codecov isort pytest pytest-cov requests watchdog;
       else
         pip install -U -r requirements.txt;
       fi;
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 4126be9..0d1c297 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -1,5 +1,9 @@
 # Change Log
 
+## Unreleased
+
+* Use `watchdog`, if installed, for watching code changes.
+
 ## 0.11.3
 
 * Update dependencies.
diff --git a/docs/settings.md b/docs/settings.md
index c581055..b8b29b6 100644
--- a/docs/settings.md
+++ b/docs/settings.md
@@ -21,6 +21,12 @@ equivalent keyword arguments, eg. `uvicorn.run("example:app", port=5000, reload=
 * `--reload` - Enable auto-reload.
 * `--reload-dir <path>` - Specify which directories to watch for python file changes. May be used multiple times. If unused, then by default all directories in `sys.path` will be watched.
 
+By default Uvicorn uses simple changes detection strategy that compares python files modification times few times a second. If this approach doesn't work for your project (eg. because of its complexity), you can install Uvicorn with optional `watchdog` dependency to use filesystem events instead:
+
+```
+$ pip install uvicorn[watchdogreload]
+```
+
 ## Production
 
 * `--workers <int>` - Use multiple worker processes. Defaults to the value of the `$WEB_CONCURRENCY` environment variable.
diff --git a/requirements.txt b/requirements.txt
index 7c5a3a5..9b28bab 100644
--- a/requirements.txt
+++ b/requirements.txt
@@ -19,3 +19,6 @@ requests
 # Documentation
 mkdocs
 mkdocs-material
+
+# Efficient debug reload
+watchdog>0.10,<0.11
diff --git a/setup.py b/setup.py
index cd66fa3..9e9b208 100755
--- a/setup.py
+++ b/setup.py
@@ -50,6 +50,8 @@ requirements = [
     "uvloop>=0.14.0 ;" + env_marker,
 ]
 
+extras_require = {"watchdogreload": ["watchdog>0.10,<0.11"]},
+
 
 setup(
     name="uvicorn",
@@ -63,6 +65,7 @@ setup(
     author_email="tom@tomchristie.com",
     packages=get_packages("uvicorn"),
     install_requires=requirements,
+    extras_require=extras_require,
     data_files=[("", ["LICENSE.md"])],
     classifiers=[
         "Development Status :: 4 - Beta",
diff --git a/tests/supervisors/test_statreload.py b/tests/supervisors/test_statreload.py
index b6aabab..aaf607e 100644
--- a/tests/supervisors/test_statreload.py
+++ b/tests/supervisors/test_statreload.py
@@ -6,7 +6,7 @@ from pathlib import Path
 import pytest
 
 from uvicorn.config import Config
-from uvicorn.supervisors import StatReload
+from uvicorn.supervisors.statreload import StatReload
 
 
 def run(sockets):
diff --git a/tests/supervisors/test_watchdogreload.py b/tests/supervisors/test_watchdogreload.py
new file mode 100644
index 0000000..f56059b
--- /dev/null
+++ b/tests/supervisors/test_watchdogreload.py
@@ -0,0 +1,42 @@
+import os
+import signal
+import time
+from pathlib import Path
+
+from uvicorn.config import Config
+from uvicorn.main import Server
+from uvicorn.supervisors.watchdogreload import WatchdogReload
+
+
+def run(sockets):
+    pass
+
+
+def test_statreload(certfile_and_keyfile):
+    config = Config(app=None)
+    reloader = WatchdogReload(config, target=run, sockets=[])
+    reloader.signal_handler(sig=signal.SIGINT, frame=None)
+    reloader.run()
+
+
+def test_should_reload(tmpdir):
+    update_file = Path(os.path.join(str(tmpdir), "example.py"))
+    update_file.touch()
+
+    working_dir = os.getcwd()
+    os.chdir(str(tmpdir))
+    try:
+        config = Config(app=None, reload=True)
+        reloader = WatchdogReload(config, target=run, sockets=[])
+        reloader.signal_handler(sig=signal.SIGINT, frame=None)
+        reloader.startup()
+
+        assert not reloader.should_restart()
+        update_file.touch()
+        time.sleep(0.1)
+        assert reloader.should_restart()
+
+        reloader.restart()
+        reloader.shutdown()
+    finally:
+        os.chdir(working_dir)
diff --git a/uvicorn/main.py b/uvicorn/main.py
index e5ed535..dc395d4 100644
--- a/uvicorn/main.py
+++ b/uvicorn/main.py
@@ -25,7 +25,7 @@ from uvicorn.config import (
     WS_PROTOCOLS,
     Config,
 )
-from uvicorn.supervisors import Multiprocess, StatReload
+from uvicorn.supervisors import Multiprocess, ChangeReload
 
 LEVEL_CHOICES = click.Choice(LOG_LEVELS.keys())
 HTTP_CHOICES = click.Choice(HTTP_PROTOCOLS.keys())
@@ -344,7 +344,7 @@ def run(app, **kwargs):
 
     if config.should_reload:
         sock = config.bind_socket()
-        supervisor = StatReload(config, target=server.run, sockets=[sock])
+        supervisor = ChangeReload(config, target=server.run, sockets=[sock])
         supervisor.run()
     elif config.workers > 1:
         sock = config.bind_socket()
diff --git a/uvicorn/supervisors/__init__.py b/uvicorn/supervisors/__init__.py
index dab32c1..4cd6d82 100644
--- a/uvicorn/supervisors/__init__.py
+++ b/uvicorn/supervisors/__init__.py
@@ -1,4 +1,8 @@
 from uvicorn.supervisors.multiprocess import Multiprocess
-from uvicorn.supervisors.statreload import StatReload
 
-__all__ = ["Multiprocess", "StatReload"]
+try:
+    from uvicorn.supervisors.watchdogreload import WatchdogReload as ChangeReload
+except ImportError:
+    from uvicorn.supervisors.statreload import StatReload as ChangeReload
+
+__all__ = ["Multiprocess", "ChangeReload"]
diff --git a/uvicorn/supervisors/basereload.py b/uvicorn/supervisors/basereload.py
new file mode 100644
index 0000000..89c0af1
--- /dev/null
+++ b/uvicorn/supervisors/basereload.py
@@ -0,0 +1,82 @@
+import logging
+import os
+import signal
+import threading
+
+import click
+
+from uvicorn.subprocess import get_subprocess
+
+HANDLED_SIGNALS = (
+    signal.SIGINT,  # Unix signal 2. Sent by Ctrl+C.
+    signal.SIGTERM,  # Unix signal 15. Sent by `kill <pid>`.
+)
+
+logger = logging.getLogger("uvicorn.error")
+
+
+class BaseReload:
+    def __init__(self, config, target, sockets):
+        self.config = config
+        self.target = target
+        self.sockets = sockets
+        self.should_exit = threading.Event()
+        self.pid = os.getpid()
+
+    def signal_handler(self, sig, frame):
+        """
+        A signal handler that is registered with the parent process.
+        """
+        self.should_exit.set()
+
+    def run(self):
+        self.startup()
+        while not self.should_exit.wait(0.25):
+            if self.should_restart():
+                self.restart()
+        self.shutdown()
+
+    def run(self):
+        self.startup()
+        while not self.should_exit.wait(0.25):
+            if self.should_restart():
+                self.restart()
+        self.shutdown()
+
+    def startup(self):
+        message = "Started reloader process [{}]".format(str(self.pid))
+        color_message = "Started reloader process [{}]".format(
+            click.style(str(self.pid), fg="cyan", bold=True)
+        )
+        logger.info(message, extra={"color_message": color_message})
+
+        for sig in HANDLED_SIGNALS:
+            signal.signal(sig, self.signal_handler)
+
+        self.process = get_subprocess(
+            config=self.config, target=self.target, sockets=self.sockets
+        )
+        self.process.start()
+
+    def restart(self):
+        self.mtimes = {}
+        os.kill(self.process.pid, signal.SIGTERM)
+        self.process.join()
+
+        self.process = get_subprocess(
+            config=self.config, target=self.target, sockets=self.sockets
+        )
+        self.process.start()
+
+    def shutdown(self):
+        self.process.join()
+        message = "Stopping reloader process [{}]".format(str(self.pid))
+        color_message = "Stopping reloader process [{}]".format(
+            click.style(str(self.pid), fg="cyan", bold=True)
+        )
+        logger.info(message, extra={"color_message": color_message})
+
+    def should_restart(self):
+        raise NotImplementedError(
+            "Reload strategies should override should_restart()"
+        )
diff --git a/uvicorn/supervisors/statreload.py b/uvicorn/supervisors/statreload.py
index 78cd92d..594f681 100644
--- a/uvicorn/supervisors/statreload.py
+++ b/uvicorn/supervisors/statreload.py
@@ -1,76 +1,17 @@
 import logging
 import os
-import signal
-import threading
 from pathlib import Path
 
-import click
-
-from uvicorn.subprocess import get_subprocess
-
-HANDLED_SIGNALS = (
-    signal.SIGINT,  # Unix signal 2. Sent by Ctrl+C.
-    signal.SIGTERM,  # Unix signal 15. Sent by `kill <pid>`.
-)
+from uvicorn.supervisors.basereload import BaseReload
 
 logger = logging.getLogger("uvicorn.error")
 
 
-class StatReload:
+class StatReload(BaseReload):
     def __init__(self, config, target, sockets):
-        self.config = config
-        self.target = target
-        self.sockets = sockets
-        self.should_exit = threading.Event()
-        self.pid = os.getpid()
+        super().__init__(config, target, sockets)
         self.mtimes = {}
 
-    def signal_handler(self, sig, frame):
-        """
-        A signal handler that is registered with the parent process.
-        """
-        self.should_exit.set()
-
-    def run(self):
-        self.startup()
-        while not self.should_exit.wait(0.25):
-            if self.should_restart():
-                self.restart()
-        self.shutdown()
-
-    def startup(self):
-        message = "Started reloader process [{}]".format(str(self.pid))
-        color_message = "Started reloader process [{}]".format(
-            click.style(str(self.pid), fg="cyan", bold=True)
-        )
-        logger.info(message, extra={"color_message": color_message})
-
-        for sig in HANDLED_SIGNALS:
-            signal.signal(sig, self.signal_handler)
-
-        self.process = get_subprocess(
-            config=self.config, target=self.target, sockets=self.sockets
-        )
-        self.process.start()
-
-    def restart(self):
-        self.mtimes = {}
-        os.kill(self.process.pid, signal.SIGTERM)
-        self.process.join()
-
-        self.process = get_subprocess(
-            config=self.config, target=self.target, sockets=self.sockets
-        )
-        self.process.start()
-
-    def shutdown(self):
-        self.process.join()
-        message = "Stopping reloader process [{}]".format(str(self.pid))
-        color_message = "Stopping reloader process [{}]".format(
-            click.style(str(self.pid), fg="cyan", bold=True)
-        )
-        logger.info(message, extra={"color_message": color_message})
-
     def should_restart(self):
         for filename in self.iter_py_files():
             try:
diff --git a/uvicorn/supervisors/watchdogreload.py b/uvicorn/supervisors/watchdogreload.py
new file mode 100644
index 0000000..94699ee
--- /dev/null
+++ b/uvicorn/supervisors/watchdogreload.py
@@ -0,0 +1,83 @@
+import logging
+from os import path
+
+from watchdog.observers import Observer
+from watchdog.events import PatternMatchingEventHandler
+
+from uvicorn.supervisors.basereload import BaseReload
+
+logger = logging.getLogger("uvicorn.error")
+
+
+class WatchdogReload(BaseReload):
+    def __init__(self, config, target, sockets):
+        super().__init__(config, target, sockets)
+
+        self.reload_count = 0
+        self.has_changed = False
+
+        # watchdog only accept directories
+        watch_dirs = {
+            path.realpath(watch_dir)
+            for watch_dir in self.config.reload_dirs
+            if path.isdir(watch_dir)
+        }
+
+        watch_dirs_set = set(watch_dirs)
+
+        # remove directories that already have a parent watched, so that we don't have
+        # duplicated change events
+        for watch_dir in watch_dirs:
+            for compare_dir in watch_dirs:
+                if compare_dir is watch_dir:
+                    continue
+
+                if watch_dir.startswith(compare_dir) and len(watch_dir) > len(
+                    compare_dir
+                ):
+                    watch_dirs_set.remove(watch_dir)
+
+        def callback(event):
+            display_path = getattr(event, "dest_path", event.src_path)
+            message = "Detected file change in '%s'. Reloading..."
+            logger.warning(message, display_path)
+            self.has_changed = True
+
+        observer = Observer()
+        event_handler = ChangeEventHandler(patterns=["*.py"], callback=callback)
+
+        for watch_dir in watch_dirs_set:
+            observer.schedule(event_handler, watch_dir, recursive=True)
+
+        observer.start()
+
+    def should_restart(self):
+        if self.has_changed:
+            self.has_changed = False
+            return True
+
+        return False
+
+
+class ChangeEventHandler(PatternMatchingEventHandler):
+    def __init__(
+        self,
+        patterns=None,
+        ignore_patterns=None,
+        ignore_directories=False,
+        case_sensitive=False,
+        callback=None,
+    ):
+        super().__init__(
+            patterns=patterns,
+            ignore_patterns=ignore_patterns,
+            ignore_directories=ignore_directories,
+            case_sensitive=case_sensitive,
+        )
+
+        self.callback = callback
+
+    def on_any_event(self, event):
+        super().on_any_event(event)
+        if self.callback is not None:
+            self.callback(event)
