diff --git a/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesBinaryExpressionMultiTypeDispatcher.java b/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesBinaryExpressionMultiTypeDispatcher.java
index 4c8c5b8c8a..10dbb150e4 100644
--- a/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesBinaryExpressionMultiTypeDispatcher.java
+++ b/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesBinaryExpressionMultiTypeDispatcher.java
@@ -45,7 +45,6 @@ import org.codehaus.groovy.syntax.TokenUtil;
 import org.objectweb.asm.Label;
 import org.objectweb.asm.MethodVisitor;
 
-import java.lang.reflect.Modifier;
 import java.util.Map;
 import java.util.Objects;
 import java.util.concurrent.atomic.AtomicInteger;
@@ -182,28 +181,24 @@ public class StaticTypesBinaryExpressionMultiTypeDispatcher extends BinaryExpres
     @Override
     public void evaluateEqual(final BinaryExpression expression, final boolean defineVariable) {
         Expression leftExpression = expression.getLeftExpression();
-        if (!defineVariable) {
-            if (leftExpression instanceof PropertyExpression) {
-                PropertyExpression pexp = (PropertyExpression) leftExpression;
-                if (makeSetProperty(
-                        pexp.getObjectExpression(),
-                        pexp.getProperty(),
-                        expression.getRightExpression(),
-                        pexp.isSafe(),
-                        pexp.isSpreadSafe(),
-                        pexp.isImplicitThis(),
-                        pexp instanceof AttributeExpression)) {
-                    return;
-                }
+        if (leftExpression instanceof PropertyExpression) {
+            PropertyExpression pexp = (PropertyExpression) leftExpression;
+            if (!defineVariable && makeSetProperty(
+                    pexp.getObjectExpression(),
+                    pexp.getProperty(),
+                    expression.getRightExpression(),
+                    pexp.isSafe(),
+                    pexp.isSpreadSafe(),
+                    pexp.isImplicitThis(),
+                    pexp instanceof AttributeExpression)) {
+                return;
+            }
+            // GROOVY-5620: spread-safe operator on LHS is not supported
+            if (pexp.isSpreadSafe() && isAssignment(expression.getOperation().getType())) {
+                // rewrite it so that it can be statically compiled
+                transformSpreadOnLHS(expression);
+                return;
             }
-        }
-        // GROOVY-5620: spread-safe operator on LHS is not supported
-        if (leftExpression instanceof PropertyExpression
-                && ((PropertyExpression) leftExpression).isSpreadSafe()
-                && isAssignment(expression.getOperation().getType())) {
-            // rewrite it so that it can be statically compiled
-            transformSpreadOnLHS(expression);
-            return;
         }
         super.evaluateEqual(expression, defineVariable);
     }
@@ -257,9 +252,10 @@ public class StaticTypesBinaryExpressionMultiTypeDispatcher extends BinaryExpres
 
     private boolean makeSetProperty(final Expression receiver, final Expression message, final Expression arguments, final boolean safe, final boolean spreadSafe, final boolean implicitThis, final boolean isAttribute) {
         ClassNode receiverType = controller.getTypeChooser().resolveType(receiver, controller.getClassNode());
+        boolean isThisReceiver = isThisExpression(receiver);
         String property = message.getText();
-        boolean isThisExpression = isThisExpression(receiver);
-        if (isAttribute || (isThisExpression && receiverType.getDeclaredField(property) != null)) {
+
+        if (isAttribute || (isThisReceiver && receiverType.getDeclaredField(property) != null)) {
             ClassNode current = receiverType;
             FieldNode fn = null;
             while (fn == null && current != null) {
@@ -291,27 +287,32 @@ public class StaticTypesBinaryExpressionMultiTypeDispatcher extends BinaryExpres
                 return true;
             }
         }
+
         if (!isAttribute) {
-            String setter = getSetterName(property);
-            MethodNode setterMethod = receiverType.getSetterMethod(setter, false);
-            ClassNode declaringClass = setterMethod != null ? setterMethod.getDeclaringClass() : null;
-            if (isThisExpression && declaringClass != null && declaringClass.equals(controller.getClassNode())) {
-                // this.x = ... shouldn't use a setter if in the same class
-                setterMethod = null;
-            } else if (setterMethod == null) {
+            String setterName = getSetterName(property);
+            MethodNode setterMethod = receiverType.getSetterMethod(setterName, false);
+            if (setterMethod != null) {
+                if (isThisReceiver && setterMethod.getDeclaringClass().equals(controller.getClassNode())) {
+                    // this.x = ... should not use setter from same class
+                    setterMethod = null;
+                } else { // GROOVY-11119
+                    java.util.List<MethodNode> setters = receiverType.getMethods(setterName);
+                    setters.removeIf(s -> s.isAbstract() || s.getParameters().length != 1);
+                    if (setters.size() > 1) setterMethod = null;
+                }
+            } else {
                 PropertyNode propertyNode = receiverType.getProperty(property);
-                if (propertyNode != null) {
-                    if (!Modifier.isFinal(propertyNode.getModifiers())) {
-                        setterMethod = new MethodNode(
-                                setter,
-                                ACC_PUBLIC,
-                                ClassHelper.VOID_TYPE,
-                                new Parameter[]{new Parameter(propertyNode.getOriginType(), "value")},
-                                ClassNode.EMPTY_ARRAY,
-                                EmptyStatement.INSTANCE
-                        );
-                        setterMethod.setDeclaringClass(receiverType);
-                    }
+                if (propertyNode != null && !propertyNode.isFinal()) {
+                    setterMethod = new MethodNode(
+                            setterName,
+                            ACC_PUBLIC,
+                            ClassHelper.VOID_TYPE,
+                            new Parameter[]{new Parameter(propertyNode.getOriginType(), "value")},
+                            ClassNode.EMPTY_ARRAY,
+                            EmptyStatement.INSTANCE
+                    );
+                    setterMethod.setDeclaringClass(receiverType);
+                    setterMethod.setSynthetic(true);
                 }
             }
             if (setterMethod != null) {
@@ -328,13 +329,14 @@ public class StaticTypesBinaryExpressionMultiTypeDispatcher extends BinaryExpres
                 call.visit(controller.getAcg());
                 return true;
             }
-            if (isThisExpression && !controller.isInGeneratedFunction()) {
+            if (isThisReceiver && !controller.isInGeneratedFunction()) {
                 receiverType = controller.getClassNode();
             }
             if (makeSetPrivateFieldWithBridgeMethod(receiver, receiverType, property, arguments, safe, spreadSafe, implicitThis)) {
                 return true;
             }
         }
+
         return false;
     }
 
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 2c96a568e4..32f5f3c132 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -1415,32 +1415,30 @@ out:    if ((samParameterTypes.length == 1 && isOrImplements(samParameterTypes[0
     }
 
     protected void checkGroovyConstructorMap(final Expression receiver, final ClassNode receiverType, final MapExpression mapExpression) {
-        // workaround for map-style checks putting setter info on wrong AST node
-        typeCheckingContext.pushEnclosingBinaryExpression(null);
         for (MapEntryExpression entryExpression : mapExpression.getMapEntryExpressions()) {
             Expression keyExpression = entryExpression.getKeyExpression();
             if (!(keyExpression instanceof ConstantExpression)) {
                 addStaticTypeError("Dynamic keys in map-style constructors are unsupported in static type checking", keyExpression);
             } else {
                 String propName = keyExpression.getText();
-                PropertyLookup requestor = new PropertyLookup(receiverType);
-                if (!existsProperty(propX(varX("_", receiverType), propName), false, requestor)) {
+                Set<ClassNode> propertyTypes = new HashSet<>();
+                Expression valueExpression = entryExpression.getValueExpression();
+                typeCheckingContext.pushEnclosingBinaryExpression(assignX(keyExpression, valueExpression, entryExpression));
+                if (!existsProperty(propX(varX("_", receiverType), propName), false, new PropertyLookup(receiverType, propertyTypes::add))) {
+                    typeCheckingContext.popEnclosingBinaryExpression();
                     addStaticTypeError("No such property: " + propName + " for class: " + prettyPrintTypeName(receiverType), receiver);
                 } else {
-                    Expression valueExpression = entryExpression.getValueExpression();
-                    ClassNode  valueType = getType(valueExpression);
-
-                    ClassNode targetType = requestor.propertyType;
-                    ClassNode resultType = getResultType(targetType, ASSIGN, valueType,
-                                assignX(keyExpression, valueExpression, entryExpression));
-                    if (!checkCompatibleAssignmentTypes(targetType, resultType, valueExpression)
-                            && !extension.handleIncompatibleAssignment(targetType, valueType, entryExpression)) {
-                        addAssignmentError(targetType, valueType, entryExpression);
+                    ClassNode valueType = getType(valueExpression);
+                    BinaryExpression kv = typeCheckingContext.popEnclosingBinaryExpression();
+                    if (propertyTypes.stream().noneMatch(targetType -> checkCompatibleAssignmentTypes(targetType, getResultType(targetType, ASSIGN, valueType, kv), valueExpression))) {
+                        ClassNode targetType = propertyTypes.size() == 1 ? propertyTypes.iterator().next() : new UnionTypeClassNode(propertyTypes.toArray(ClassNode.EMPTY_ARRAY));
+                        if (!extension.handleIncompatibleAssignment(targetType, valueType, entryExpression)) {
+                            addAssignmentError(targetType, valueType, entryExpression);
+                        }
                     }
                 }
             }
         }
-        typeCheckingContext.popEnclosingBinaryExpression();
     }
 
     @Deprecated(forRemoval = true, since = "4.0.0")
@@ -1753,9 +1751,9 @@ out:    if ((samParameterTypes.length == 1 && isOrImplements(samParameterTypes[0
         GenericsType[] gts = compositeType.getGenericsTypes();
         ClassNode itemType = (gts != null && gts.length == 1 ? getCombinedBoundType(gts[0]) : OBJECT_TYPE);
 
-        PropertyLookup requestor = new PropertyLookup(itemType);
-        if (existsProperty(propX(varX("{}", itemType), prop), true, requestor)) {
-            return extension.buildListType(requestor.propertyType);
+        List<ClassNode> propertyTypes = new ArrayList<>();
+        if (existsProperty(propX(varX("_", itemType), prop), true, new PropertyLookup(itemType, propertyTypes::add))) {
+            return extension.buildListType(propertyTypes.get(0));
         }
         return null;
     }
@@ -5912,6 +5910,7 @@ out:                if (mn.size() != 1) {
     private static BinaryExpression assignX(final Expression lhs, final Expression rhs, final ASTNode pos) {
         BinaryExpression exp = (BinaryExpression) GeneralUtils.assignX(lhs, rhs);
         exp.setSourcePosition(pos);
+        exp.setSynthetic(true);
         return exp;
     }
 
@@ -6025,10 +6024,12 @@ out:                if (mn.size() != 1) {
     }
 
     private class PropertyLookup extends ClassCodeVisitorSupport {
-        ClassNode propertyType, receiverType;
+        private final ClassNode receiverType;
+        private final Consumer<ClassNode> propertyType;
 
-        PropertyLookup(final ClassNode type) {
-            receiverType = type;
+        PropertyLookup(final ClassNode receiverType, final Consumer<ClassNode> propertyType) {
+            this.receiverType = receiverType;
+            this.propertyType = propertyType;
         }
 
         @Override
@@ -6038,26 +6039,25 @@ out:                if (mn.size() != 1) {
 
         @Override
         public void visitField(final FieldNode node) {
-            storePropertyType(node.getType(), node.isStatic() ? null : node.getDeclaringClass());
+            reportPropertyType(node.getType(), node.isStatic() ? null : node.getDeclaringClass());
         }
 
         @Override
         public void visitMethod(final MethodNode node) {
-            storePropertyType(node.getReturnType(), node.isStatic() ? null : node.getDeclaringClass());
+            reportPropertyType(node.getReturnType(), node.isStatic() ? null : node.getDeclaringClass());
         }
 
         @Override
         public void visitProperty(final PropertyNode node) {
-            storePropertyType(node.getOriginType(), node.isStatic() ? null : node.getDeclaringClass());
+            reportPropertyType(node.getOriginType(), node.isStatic() ? null : node.getDeclaringClass());
         }
 
-        private void storePropertyType(ClassNode type, final ClassNode declaringClass) {
+        private void reportPropertyType(ClassNode type, final ClassNode declaringClass) {
             if (declaringClass != null && GenericsUtils.hasUnresolvedGenerics(type)) { // GROOVY-10787
                 Map<GenericsTypeName, GenericsType> spec = extractPlaceHolders(receiverType, declaringClass);
                 type = applyGenericsContext(spec, type);
             }
-            // TODO: if (propertyType != null) merge types
-            propertyType = type;
+            propertyType.accept(type);
         }
     }
 
diff --git a/src/test/groovy/transform/stc/ConstructorsSTCTest.groovy b/src/test/groovy/transform/stc/ConstructorsSTCTest.groovy
index 352dfc24ff..2e79c75995 100644
--- a/src/test/groovy/transform/stc/ConstructorsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/ConstructorsSTCTest.groovy
@@ -536,6 +536,24 @@ class ConstructorsSTCTest extends StaticTypeCheckingTestCase {
         '''
     }
 
+    // GROOVY-11119
+    void testMapStyleConstructorWithOverloadedSetterName() {
+        assertScript '''import java.util.regex.Pattern
+            class C {
+                void setP(Pattern p) {
+                    which = 'Pattern'
+                }
+                void setP(String re) {
+                    which = 'String'
+                }
+                def which
+            }
+
+            assert new C(p:"xx").which == 'String'
+            assert new C(p:~/x/).which == 'Pattern'
+        '''
+    }
+
     // GROOVY-11122
     void testMapStyleInnerClassConstructorWithinClosure() {
         assertScript '''
