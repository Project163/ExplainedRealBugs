diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 882e71fb1a..d2dfa5603c 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -1226,7 +1226,12 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         ClassNode receiver = call.isThisCall() ? classNode :
                 call.isSuperCall() ? classNode.getSuperClass() : call.getType();
         Expression arguments = call.getArguments();
-        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(arguments));
+
+        ArgumentListExpression argumentList = InvocationWriter.makeArgumentList(arguments);
+
+        checkForbiddenSpreadArgument(argumentList);
+
+        ClassNode[] args = getArgumentTypes(argumentList);
         MethodNode node = null;
         if (args.length == 1 && implementsInterfaceOrIsSubclassOf(args[0], MAP_TYPE) && findMethod(receiver, "<init>", ClassNode.EMPTY_ARRAY).size() == 1) {
             // bean-style constructor
@@ -1443,6 +1448,10 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         final ClassNode rememberLastItType = lastImplicitItType;
         Expression callArguments = call.getArguments();
 
+        ArgumentListExpression argumentList = InvocationWriter.makeArgumentList(callArguments);
+
+        checkForbiddenSpreadArgument(argumentList);
+
         boolean isWithCall = isWithCall(name, callArguments);
 
         if (!isWithCall) {
@@ -1450,7 +1459,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             callArguments.visit(this);
         }
 
-        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));
+        ClassNode[] args = getArgumentTypes(argumentList);
         final ClassNode receiver = call.getOwnerType();
 
         if (isWithCall) {
@@ -1602,6 +1611,9 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
         final ClassNode rememberLastItType = lastImplicitItType;
         Expression callArguments = call.getArguments();
+        ArgumentListExpression argumentList = InvocationWriter.makeArgumentList(callArguments);
+
+        checkForbiddenSpreadArgument(argumentList);
 
         boolean isWithCall = isWithCall(name, callArguments);
 
@@ -1610,7 +1622,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             callArguments.visit(this);
         }
 
-        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));
+        ClassNode[] args = getArgumentTypes(argumentList);
         final boolean isCallOnClosure = isClosureCall(name, objectExpression, callArguments);
         final ClassNode receiver = getType(objectExpression);
 
@@ -1813,6 +1825,14 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         }
     }
 
+    private void checkForbiddenSpreadArgument(ArgumentListExpression argumentList) {
+        for (Expression arg : argumentList.getExpressions()) {
+            if (arg instanceof SpreadExpression) {
+                addStaticTypeError("The spread operator cannot be used as argument of method or closure calls with static type checking because the number of arguments cannot be determined at compile time", arg);
+            }
+        }
+    }
+
     private List<ClassNode> getTemporaryTypesForExpression(final Expression objectExpression) {
         List<ClassNode> classNodes = null;
         int depth = temporaryIfBranchTypeInformation.size();
diff --git a/src/test/groovy/transform/stc/MethodCallsSTCTest.groovy b/src/test/groovy/transform/stc/MethodCallsSTCTest.groovy
index 70fc75826a..dd3c417280 100644
--- a/src/test/groovy/transform/stc/MethodCallsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/MethodCallsSTCTest.groovy
@@ -720,6 +720,51 @@ class MethodCallsSTCTest extends StaticTypeCheckingTestCase {
         '''
     }
 
+    void testSpreadArgsForbiddenInMethodCall() {
+        shouldFailWithMessages '''
+            void foo(String a, String b, int c, double d1, double d2) {}
+            void bar(String[] args, int c, double[] nums) {
+                foo(*args, c, *nums)
+            }
+        ''',
+                'The spread operator cannot be used as argument of method or closure calls with static type checking because the number of arguments cannot be determined at compile time',
+                'The spread operator cannot be used as argument of method or closure calls with static type checking because the number of arguments cannot be determined at compile time',
+                'Cannot find matching method'
+    }
+
+    void testSpreadArgsForbiddenInStaticMethodCall() {
+        shouldFailWithMessages '''
+            static void foo(String a, String b, int c, double d1, double d2) {}
+            static void bar(String[] args, int c, double[] nums) {
+                foo(*args, c, *nums)
+            }
+        ''',
+                'The spread operator cannot be used as argument of method or closure calls with static type checking because the number of arguments cannot be determined at compile time',
+                'The spread operator cannot be used as argument of method or closure calls with static type checking because the number of arguments cannot be determined at compile time',
+                'Cannot find matching method'
+    }
+
+    void testSpreadArgsForbiddenInConstructorCall() {
+        shouldFailWithMessages '''
+            class SpreadInCtor {
+                SpreadInCtor(String a, String b) { }
+            }
+
+            new SpreadInCtor(*['A', 'B'])
+        ''',
+                'The spread operator cannot be used as argument of method or closure calls with static type checking because the number of arguments cannot be determined at compile time',
+                'Cannot find matching method'
+    }
+
+    void testSpreadArgsForbiddenInClosureCall() {
+        shouldFailWithMessages '''
+            def closure = { String a, String b, String c -> println "$a $b $c" }
+            def strings = ['A', 'B', 'C']
+            closure(*strings)
+        ''',
+                'The spread operator cannot be used as argument of method or closure calls with static type checking because the number of arguments cannot be determined at compile time'
+    }
+
     static class MyMethodCallTestClass {
 
         static int mul(int... args) { args.toList().inject(1) { x,y -> x*y } }
