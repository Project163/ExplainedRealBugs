diff --git a/src/main/groovy/beans/BindableASTTransformation.java b/src/main/groovy/beans/BindableASTTransformation.java
index 73e6846446..62ae64ed79 100644
--- a/src/main/groovy/beans/BindableASTTransformation.java
+++ b/src/main/groovy/beans/BindableASTTransformation.java
@@ -23,6 +23,7 @@ import org.codehaus.groovy.ast.stmt.ReturnStatement;
 import org.codehaus.groovy.ast.stmt.Statement;
 import org.codehaus.groovy.control.CompilePhase;
 import org.codehaus.groovy.control.SourceUnit;
+import org.codehaus.groovy.control.messages.SimpleMessage;
 import org.codehaus.groovy.control.messages.SyntaxErrorMessage;
 import org.codehaus.groovy.runtime.MetaClassHelper;
 import org.codehaus.groovy.syntax.SyntaxException;
@@ -55,11 +56,6 @@ import java.util.Collection;
 @GroovyASTTransformation(phase= CompilePhase.CANONICALIZATION)
 public class BindableASTTransformation implements ASTTransformation, Opcodes {
 
-    /**
-     * The found or created PropertyChangeSupport field
-     */
-    protected FieldNode pcsField;
-
     protected static ClassNode boundClassNode = new ClassNode(Bindable.class);
     protected ClassNode pcsClassNode = new ClassNode(PropertyChangeSupport.class);
 
@@ -105,7 +101,6 @@ public class BindableASTTransformation implements ASTTransformation, Opcodes {
             }
             addListenerToProperty(source, node, declaringClass, (FieldNode) parent);
         } else if (parent instanceof ClassNode) {
-
             addListenerToClass(source, node, (ClassNode) parent);
         }
     }
@@ -123,7 +118,7 @@ public class BindableASTTransformation implements ASTTransformation, Opcodes {
                                     node.getColumnNumber()),
                                     source));
                 } else {
-                    if (needsPropertyChangeSupport(declaringClass)) {
+                    if (needsPropertyChangeSupport(declaringClass, source)) {
                         addPropertyChangeSupport(declaringClass);
                     }
                     createListenerSetter(source, node, declaringClass, propertyNode);
@@ -141,7 +136,7 @@ public class BindableASTTransformation implements ASTTransformation, Opcodes {
     }
 
     private void addListenerToClass(SourceUnit source, AnnotationNode node, ClassNode classNode) {
-        if (needsPropertyChangeSupport(classNode)) {
+        if (needsPropertyChangeSupport(classNode, source)) {
             addPropertyChangeSupport(classNode);
         }
         for (PropertyNode propertyNode : (Collection<PropertyNode>) classNode.getProperties()) {
@@ -181,7 +176,7 @@ public class BindableASTTransformation implements ASTTransformation, Opcodes {
 
     /**
      * Creates a statement body similar to:
-     * <code>pcsField.firePropertyChange("field", field, field = value)</code>
+     * <code>this.firePropertyChange("field", field, field = value)</code>
      *
      * @param propertyNode           the field node for the property
      * @param fieldExpression a field expression for setting the property value
@@ -189,29 +184,18 @@ public class BindableASTTransformation implements ASTTransformation, Opcodes {
      */
     protected Statement createBindableStatement(PropertyNode propertyNode, Expression fieldExpression) {
         // create statementBody
-        Expression methodArguments = new ArgumentListExpression(
-                new Expression[]{
-                        new ConstantExpression(propertyNode.getName()),
-                        fieldExpression,
-                        new BinaryExpression(
-                                fieldExpression,
-                                Token.newSymbol(Types.EQUAL, 0, 0),
-                                new VariableExpression("value"))});
-        if (pcsField == null) {
-            // call is directly on the object
-            return new ExpressionStatement(
-                    new MethodCallExpression(
-                            VariableExpression.THIS_EXPRESSION,
-                            "firePropertyChange",
-                            methodArguments));
-        } else {
-            // call is on the propertyChangeSupport
-            return new ExpressionStatement(
-                    new MethodCallExpression(
-                            new FieldExpression(pcsField),
-                            "firePropertyChange",
-                            methodArguments));
-        }
+        return new ExpressionStatement(
+                new MethodCallExpression(
+                        VariableExpression.THIS_EXPRESSION,
+                        "firePropertyChange",
+                        new ArgumentListExpression(
+                                new Expression[]{
+                                        new ConstantExpression(propertyNode.getName()),
+                                        fieldExpression,
+                                        new BinaryExpression(
+                                                fieldExpression,
+                                                Token.newSymbol(Types.EQUAL, 0, 0),
+                                                new VariableExpression("value"))})));
     }
 
     /**
@@ -232,32 +216,39 @@ public class BindableASTTransformation implements ASTTransformation, Opcodes {
     }
 
     /**
-     * Snoops through the declaring class and all parents looking for a field
-     * of type PropertyChangeSupport.  Remembers the field and returns false
-     * if found otherwise returns true to indicate that such support should
-     * be added.
+     * Snoops through the declaring class and all parents looking for methods
+     * void addPropertyChangeListener(PropertyChangeListener),
+     * void removePropertyChangeListener(PropertyChangeListener), and
+     * void firePropertyChange(String, Object, Object).  If any are defined all
+     * must be defined or a compilation error results. 
      *
      * @param declaringClass the class to search
+     * @param sourceUnit the source unit, for error reporting.  @NotNull
      * @return true if property change support should be added
      */
-    protected boolean needsPropertyChangeSupport(ClassNode declaringClass) {
-        while (declaringClass != null) {
-            for (FieldNode field : (Collection<FieldNode>) declaringClass.getFields()) {
-                if (field.getType() == null) {
-                    continue;
-                }
-                if (pcsClassNode.equals(field.getType())) {
-                    // if field is not private, use it directly
-                    // else, rely on exposed firePropertyChange methods
-                    if ((field.getModifiers() &
-                            (ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED)) != ACC_PRIVATE) {
-                        pcsField = field;
-                    }
+    protected boolean needsPropertyChangeSupport(ClassNode declaringClass, SourceUnit sourceUnit) {
+        boolean foundAdd = false, foundRemove = false, foundFire = false;
+        ClassNode consideredClass = declaringClass;
+        while (consideredClass!= null) {
+            for (MethodNode method : consideredClass.getMethods()) {
+                // just check length, MOP will match it up
+                foundAdd = foundAdd || method.getName().equals("addPropertyChangeListener") && method.getParameters().length == 1;
+                foundRemove = foundRemove || method.getName().equals("removePropertyChangeListener") && method.getParameters().length == 1;
+                foundFire = foundFire || method.getName().equals("firePropertyChange") && method.getParameters().length == 3;
+                if (foundAdd && foundRemove && foundFire) {
                     return false;
                 }
             }
-            //TODO check add/remove conflicts
-            declaringClass = declaringClass.getSuperClass();
+            consideredClass = consideredClass.getSuperClass();
+        }
+        if (foundAdd || foundRemove || foundFire) {
+            sourceUnit.getErrorCollector().addErrorAndContinue(
+                new SimpleMessage("@Bindable cannot be processed on "
+                    + declaringClass.getName()
+                    + " because some but not all of addPropertyChangeListener, removePropertyChange, and firePropertyChange were declared in the current or super classes.",
+                sourceUnit)
+            );
+            return false;
         }
         return true;
     }
@@ -284,9 +275,9 @@ public class BindableASTTransformation implements ASTTransformation, Opcodes {
 
         // add field:
         // protected final PropertyChangeSupport this$propertyChangeSupport = new java.beans.PropertyChangeSupport(this)
-        pcsField = declaringClass.addField(
+        FieldNode pcsField = declaringClass.addField(
                 "this$propertyChangeSupport",
-                ACC_FINAL | ACC_PROTECTED | ACC_SYNTHETIC,
+                ACC_FINAL | ACC_PRIVATE | ACC_SYNTHETIC,
                 pcsClassNode,
                 new ConstructorCallExpression(pcsClassNode,
                         new ArgumentListExpression(new Expression[]{new VariableExpression("this")})));
@@ -360,6 +351,27 @@ public class BindableASTTransformation implements ASTTransformation, Opcodes {
                                         new ArgumentListExpression(
                                                 new Expression[]{new VariableExpression("name"), new VariableExpression("listener")})))));
 
+        // add method:
+        // void firePropertyChange(String name, Object oldValue, Object newValue) {
+        //     this$propertyChangeSupport.firePropertyChange(name, oldValue, newValue)
+        //  }
+        declaringClass.addMethod(
+                new MethodNode(
+                        "firePropertyChange",
+                        ACC_PUBLIC | ACC_SYNTHETIC,
+                        ClassHelper.VOID_TYPE,
+                        new Parameter[]{new Parameter(ClassHelper.STRING_TYPE, "name"), new Parameter(ClassHelper.OBJECT_TYPE, "oldValue"), new Parameter(ClassHelper.OBJECT_TYPE, "newValue")},
+                        ClassNode.EMPTY_ARRAY,
+                        new ExpressionStatement(
+                                new MethodCallExpression(
+                                        new FieldExpression(pcsField),
+                                        "firePropertyChange",
+                                        new ArgumentListExpression(
+                                                new Expression[]{
+                                                        new VariableExpression("name"),
+                                                        new VariableExpression("oldValue"),
+                                                        new VariableExpression("newValue")})))));
+
         // add method:
         // PropertyChangeSupport[] getPropertyChangeListeners() {
         //   return this$propertyChangeSupport.getPropertyChangeListeners
diff --git a/src/main/groovy/beans/VetoableASTTransformation.java b/src/main/groovy/beans/VetoableASTTransformation.java
index d2cdcc11fa..eb52780f4b 100644
--- a/src/main/groovy/beans/VetoableASTTransformation.java
+++ b/src/main/groovy/beans/VetoableASTTransformation.java
@@ -24,6 +24,7 @@ import org.codehaus.groovy.ast.stmt.ReturnStatement;
 import org.codehaus.groovy.ast.stmt.Statement;
 import org.codehaus.groovy.control.CompilePhase;
 import org.codehaus.groovy.control.SourceUnit;
+import org.codehaus.groovy.control.messages.SimpleMessage;
 import org.codehaus.groovy.control.messages.SyntaxErrorMessage;
 import org.codehaus.groovy.runtime.MetaClassHelper;
 import org.codehaus.groovy.syntax.SyntaxException;
@@ -57,10 +58,6 @@ public class VetoableASTTransformation extends BindableASTTransformation {
 
     protected static ClassNode constrainedClassNode = new ClassNode(Vetoable.class);
     protected ClassNode vcsClassNode = new ClassNode(VetoableChangeSupport.class);
-    /**
-     * Field use to remember a discovered vcs field
-     */
-    protected FieldNode vcsField;
 
     /**
      * Convienience method to see if an annotatied node is @Vetoable.
@@ -143,10 +140,10 @@ public class VetoableASTTransformation extends BindableASTTransformation {
     }
 
     private void createListenerSetter(SourceUnit source, AnnotationNode node, boolean bindable, ClassNode declaringClass, PropertyNode propertyNode) {
-        if (bindable && needsPropertyChangeSupport(declaringClass)) {
+        if (bindable && needsPropertyChangeSupport(declaringClass, source)) {
             addPropertyChangeSupport(declaringClass);
         }
-        if (needsVetoableChangeSupport(declaringClass)) {
+        if (needsVetoableChangeSupport(declaringClass, source)) {
             addVetoableChangeSupport(declaringClass);
         }
         String setterName = "set" + MetaClassHelper.capitalize(propertyNode.getName());
@@ -175,33 +172,22 @@ public class VetoableASTTransformation extends BindableASTTransformation {
 
     /**
      * Creates a statement body silimar to:
-     * <code>vcsField.fireVetoableChange("field", field, field = value)</code>
+     * <code>this.fireVetoableChange("field", field, field = value)</code>
      *
      * @param propertyNode           the field node for the property
      * @param fieldExpression a field expression for setting the property value
      * @return the created statement
      */
     protected Statement createConstrainedStatement(PropertyNode propertyNode, Expression fieldExpression) {
-        Expression methodArguments = new ArgumentListExpression(
-                new Expression[]{
-                        new ConstantExpression(propertyNode.getName()),
-                        fieldExpression,
-                        new VariableExpression("value")});
-        if (vcsField == null) {
-            // call is directly on the object
-            return new ExpressionStatement(
-                    new MethodCallExpression(
-                            VariableExpression.THIS_EXPRESSION,
-                            "fireVetoableChange",
-                            methodArguments));
-        } else {
-            // call is on the vetoableChangeSupport
-            return new ExpressionStatement(
-                    new MethodCallExpression(
-                            new FieldExpression(vcsField),
-                            "fireVetoableChange",
-                            methodArguments));
-        }
+        return new ExpressionStatement(
+                new MethodCallExpression(
+                        VariableExpression.THIS_EXPRESSION,
+                        "fireVetoableChange",
+                        new ArgumentListExpression(
+                                new Expression[]{
+                                        new ConstantExpression(propertyNode.getName()),
+                                        fieldExpression,
+                                        new VariableExpression("value")})));
     }
 
     /**
@@ -230,24 +216,29 @@ public class VetoableASTTransformation extends BindableASTTransformation {
      * @param declaringClass the class to search
      * @return true if vetoable change support should be added
      */
-    protected boolean needsVetoableChangeSupport(ClassNode declaringClass) {
-        while (declaringClass != null) {
-            for (FieldNode field : (Collection<FieldNode>) declaringClass.getFields()) {
-                if (field.getType() == null) {
-                    continue;
-                }
-                if (vcsClassNode.equals(field.getType())) {
-                    // if field is not private, use it directly
-                    // else, rely on exposed fireVetoableChange methods
-                    if ((field.getModifiers() &
-                            (ACC_PUBLIC | ACC_PRIVATE | ACC_PROTECTED)) != ACC_PRIVATE) {
-                        vcsField = field;
-                    }
+    protected boolean needsVetoableChangeSupport(ClassNode declaringClass, SourceUnit sourceUnit) {
+        boolean foundAdd = false, foundRemove = false, foundFire = false;
+        ClassNode consideredClass = declaringClass;
+        while (consideredClass!= null) {
+            for (MethodNode method : consideredClass.getMethods()) {
+                // just check length, MOP will match it up
+                foundAdd = foundAdd || method.getName().equals("addVetoableChangeListener") && method.getParameters().length == 1;
+                foundRemove = foundRemove || method.getName().equals("removeVetoableChangeListener") && method.getParameters().length == 1;
+                foundFire = foundFire || method.getName().equals("fireVetoableChange") && method.getParameters().length == 3;
+                if (foundAdd && foundRemove && foundFire) {
                     return false;
                 }
             }
-            //TODO check add/remove conflicts
-            declaringClass = declaringClass.getSuperClass();
+            consideredClass = consideredClass.getSuperClass();
+        }
+        if (foundAdd || foundRemove || foundFire) {
+            sourceUnit.getErrorCollector().addErrorAndContinue(
+                new SimpleMessage("@Vetoable cannot be processed on "
+                    + declaringClass.getName()
+                    + " because some but not all of addVetoableChangeListener, removeVetoableChange, and fireVetoableChange were declared in the current or super classes.",
+                sourceUnit)
+            );
+            return false;
         }
         return true;
     }
@@ -294,9 +285,9 @@ public class VetoableASTTransformation extends BindableASTTransformation {
 
         // add field:
         // protected static VetoableChangeSupport this$vetoableChangeSupport = new java.beans.VetoableChangeSupport(this)
-        vcsField = declaringClass.addField(
+        FieldNode vcsField = declaringClass.addField(
                 "this$vetoableChangeSupport",
-                ACC_FINAL | ACC_PROTECTED | ACC_SYNTHETIC,
+                ACC_FINAL | ACC_PRIVATE | ACC_SYNTHETIC,
                 vcsClassNode,
                 new ConstructorCallExpression(vcsClassNode,
                         new ArgumentListExpression(new Expression[]{new VariableExpression("this")})));
@@ -370,6 +361,29 @@ public class VetoableASTTransformation extends BindableASTTransformation {
                                         new ArgumentListExpression(
                                                 new Expression[]{new VariableExpression("name"), new VariableExpression("listener")})))));
 
+        // add method:
+        // void fireVetoableChange(String name, Object oldValue, Object newValue)
+        //    throws PropertyVetoException
+        // {
+        //     this$vetoableChangeSupport.fireVetoableChange(name, oldValue, newValue)
+        //  }
+        declaringClass.addMethod(
+                new MethodNode(
+                        "fireVetoableChange",
+                        ACC_PUBLIC | ACC_SYNTHETIC,
+                        ClassHelper.VOID_TYPE,
+                        new Parameter[]{new Parameter(ClassHelper.STRING_TYPE, "name"), new Parameter(ClassHelper.OBJECT_TYPE, "oldValue"), new Parameter(ClassHelper.OBJECT_TYPE, "newValue")},
+                        new ClassNode[] {new ClassNode(PropertyVetoException.class)},
+                        new ExpressionStatement(
+                                new MethodCallExpression(
+                                        new FieldExpression(vcsField),
+                                        "fireVetoableChange",
+                                        new ArgumentListExpression(
+                                                new Expression[]{
+                                                        new VariableExpression("name"),
+                                                        new VariableExpression("oldValue"),
+                                                        new VariableExpression("newValue")})))));
+
         // add method:
         // VetoableChangeSupport[] getVetoableChangeListeners() {
         //   return this$vetoableChangeSupport.getVetoableChangeListeners
diff --git a/src/test/groovy/beans/vm5/BindableTest.groovy b/src/test/groovy/beans/vm5/BindableTest.groovy
index 025001af33..82cb9e939d 100644
--- a/src/test/groovy/beans/vm5/BindableTest.groovy
+++ b/src/test/groovy/beans/vm5/BindableTest.groovy
@@ -149,4 +149,67 @@ class BindableTest extends GroovySwingTestCase {
             """)
         }
     }
+
+    public void testPrimitaveTypes() {
+        GroovyShell shell = new GroovyShell()
+        shell.evaluate("""
+            import groovy.beans.Bindable
+
+            class BindableTestBean7 {
+                @Bindable String testField
+                @Bindable boolean testBoolean
+                @Bindable byte testByte
+                @Bindable short testShort
+                @Bindable int testInt
+                @Bindable long testLong
+                @Bindable float testFloat
+                @Bindable double testDouble
+            }
+
+            sb = new BindableTestBean7()
+            sb.testField = "bar"
+            int changed = 0
+            sb.propertyChange = {changed++}
+            sb.testField = "foo"
+            sb.testBoolean = true
+            sb.testByte = 1
+            sb.testShort = 1
+            sb.testInt = 1
+            sb.testLong = 1
+            sb.testFloat = 1
+            sb.testDouble = 1
+            assert changed == 8
+        """)
+    }
+
+    public void testBadInheritance() {
+        shouldFail(CompilationFailedException) {
+            GroovyShell shell = new GroovyShell()
+            shell.evaluate("""
+                import groovy.beans.Bindable
+
+                class BindableTestBean8  {
+                    @Bindable String testField
+                    void addPropertyChangeListener(java.beans.PropertyChangeListener l) {}
+                }
+                new BindableTestBean8()
+            """)
+        }
+        shouldFail(CompilationFailedException) {
+            GroovyShell shell = new GroovyShell()
+            shell.evaluate("""
+                import groovy.beans.Bindable
+
+                class BindableTestBean9  {
+                    void addPropertyChangeListener(java.beans.PropertyChangeListener l) {}
+                }
+
+                class BindableTestBean10 extends BindableTestBean9 {
+                    @Bindable String testField
+                }
+
+                new BindableTestBean10()
+            """)
+        }
+    }
 }
\ No newline at end of file
diff --git a/src/test/groovy/beans/vm5/VetoableTest.groovy b/src/test/groovy/beans/vm5/VetoableTest.groovy
index c1461eedf5..3a72617989 100644
--- a/src/test/groovy/beans/vm5/VetoableTest.groovy
+++ b/src/test/groovy/beans/vm5/VetoableTest.groovy
@@ -207,6 +207,69 @@ class VetoableTest extends GroovySwingTestCase {
         }
     }
 
+    public void testPrimitaveTypes() {
+        GroovyShell shell = new GroovyShell()
+        shell.evaluate("""
+                import groovy.beans.Vetoable
+
+                class VetoableTestBean8 {
+                    @Vetoable String testField
+                    @Vetoable boolean testBoolean
+                    @Vetoable byte testByte
+                    @Vetoable short testShort
+                    @Vetoable int testInt
+                    @Vetoable long testLong
+                    @Vetoable float testFloat
+                    @Vetoable double testDouble
+                }
+
+                sb = new VetoableTestBean8()
+                sb.testField = "bar"
+                int changed = 0
+                sb.vetoableChange = {changed++}
+                sb.testField = "foo"
+                sb.testBoolean = true
+                sb.testByte = 1
+                sb.testShort = 1
+                sb.testInt = 1
+                sb.testLong = 1
+                sb.testFloat = 1
+                sb.testDouble = 1
+                assert changed == 8
+            """)
+    }
+
+    public void testBadInheritance() {
+        shouldFail(CompilationFailedException) {
+            GroovyShell shell = new GroovyShell()
+            shell.evaluate("""
+                    import groovy.beans.Vetoable
+
+                    class VetoableTestBean9  {
+                        @Vetoable String testField
+                        void addVetoableChangeListener(java.beans.VetoableChangeListener l) {}
+                    }
+                    new VetoableTestBean9()
+                """)
+        }
+        shouldFail(CompilationFailedException) {
+            GroovyShell shell = new GroovyShell()
+            shell.evaluate("""
+                    import groovy.beans.Vetoable
+
+                    class VetoableTestBean10  {
+                        void addPropertyChangeListener(java.beans.VetoableChangeListener l) {}
+                    }
+
+                    class VetoableTestBean11 extends VetoableTestBean9 {
+                        @Vetoable String testField
+                    }
+
+                    new VetoableTestBean10()
+                """)
+        }
+    }
+
     public void testClassMarkers() {
         for (int i = 0; i < 31; i++) {
             boolean bindField  = i & 1
