diff --git a/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java b/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java
index 8c796ea24c..b18df3a02a 100644
--- a/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java
+++ b/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java
@@ -1866,7 +1866,7 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
                 throw new ASTRuntimeException(node, "\n'" + ((MapExpression) leftExpression).getText() + "' is a map expression, but it should be a variable expression");
             }
             else {
-                throw new ASTRuntimeException(node, "\n" + leftExpression.getClass() + ", with its value '" + leftExpression.getText() + "', is a bad expression as the LSH of an assignment operator");
+                throw new ASTRuntimeException(node, "\n" + leftExpression.getClass() + ", with its value '" + leftExpression.getText() + "', is a bad expression as the left hand side of an assignment operator");
             }
         }
         /*if (rightNode == null) {
diff --git a/src/main/org/codehaus/groovy/control/StaticImportVisitor.java b/src/main/org/codehaus/groovy/control/StaticImportVisitor.java
index 13425600cf..1ce2f761e9 100644
--- a/src/main/org/codehaus/groovy/control/StaticImportVisitor.java
+++ b/src/main/org/codehaus/groovy/control/StaticImportVisitor.java
@@ -103,17 +103,17 @@ public class StaticImportVisitor extends ClassCodeExpressionTransformer {
         Expression args = transform(mce.getArguments());
         Expression method = transform(mce.getMethod());
         Expression object = transform(mce.getObjectExpression());
-        boolean isExplicitThis = false;
+        boolean isExplicitThisOrSuper = false;
         if (object instanceof VariableExpression) {
             VariableExpression ve = (VariableExpression) object;
-            isExplicitThis = !mce.isImplicitThis() && ve.getName().equals("this");
-            if (isExplicitThis && currentMethod != null && currentMethod.isStatic()) {
-                addError("Non-static variable 'this' cannot be referenced from the static method " + currentMethod.getName() + ".", mce);
+            isExplicitThisOrSuper = !mce.isImplicitThis() && (ve.getName().equals("this") || ve.getName().equals("super"));
+            if (isExplicitThisOrSuper && currentMethod != null && currentMethod.isStatic()) {
+                addError("Non-static variable '" + ve.getName() + "' cannot be referenced from the static method " + currentMethod.getName() + ".", mce);
                 return null;
             }
         }
 
-        if (mce.isImplicitThis() || isExplicitThis) {
+        if (mce.isImplicitThis() || isExplicitThisOrSuper) {
             Expression ret = findStaticMethodImportFromModule(method, args);
             if (ret != null) {
                 return ret;
diff --git a/src/test/groovy/StaticThisTest.groovy b/src/test/groovy/StaticThisTest.groovy
index 0c13d4595b..af191199ba 100644
--- a/src/test/groovy/StaticThisTest.groovy
+++ b/src/test/groovy/StaticThisTest.groovy
@@ -1,6 +1,8 @@
 package groovy
 
-class StaticThisTest extends GroovyTestCase {
+import gls.CompilableTestSupport
+
+class StaticThisTest extends CompilableTestSupport {
 
     void testThisFail() {
         staticMethod()
@@ -8,17 +10,32 @@ class StaticThisTest extends GroovyTestCase {
 
     static def staticMethod() {
         def foo = this
-
         assert foo != null
         assert foo.name.endsWith("StaticThisTest")
 
-        println("this: " + this)
-
         def s = super
-
         assert s != null
-        assert s.name.endsWith("GroovyTestCase")
+        assert s.name.endsWith("CompilableTestSupport")
+    }
+
+    void testThisMethodInStaticMethodShouldNotCompile() {
+        shouldNotCompile """
+            class A {
+                static method(){
+                    this.toString()
+                }
+            }
+            """
+    }
 
-        println("super: " + super)
+    void testSuperMethodInStaticMethodShouldNotCompile() {
+        shouldNotCompile """
+            class A {
+                static method(){
+                    super.toString()
+                }
+            }
+            """
     }
+
 }
