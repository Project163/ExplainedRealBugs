diff --git a/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java b/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
index 0772c1cedc..2bd4b914c5 100644
--- a/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
+++ b/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
@@ -69,6 +69,7 @@ import java.util.regex.Pattern;
  * @author John Wilson
  * @author Hein Meling
  * @author Dierk Koenig
+ * @author Pilho Kim
  * @version $Revision$
  */
 public class DefaultGroovyMethods {
@@ -3545,8 +3546,29 @@ public class DefaultGroovyMethods {
      * parameters as separate items in the array.
      * @return the Process which has just started for this command line string.
      */
-    public static Process execute ( final String[] commandArray ) throws IOException {
-      return Runtime.getRuntime ( ).exec ( commandArray ) ;
+    public static Process execute(final String[] commandArray) throws IOException {
+        return Runtime.getRuntime().exec(commandArray) ;
+    }
+
+    /**
+     * Executes the command specified by the <code>self</code> with environments <code>envp</code>
+     * under the working directory <code>dir</code>.
+     * For more control over the process mechanism in JDK 1.5 you can use <code>java.lang.ProcessBuilder</code>.
+     *
+     * @param   self      a command line String to be executed.
+     * @param   envp      an array of Strings, each element of which
+     *                    has environment variable settings in the format
+     *                    <i>name</i>=<i>value</i>, or
+     *                    <tt>null</tt> if the subprocess should inherit
+     *                    the environment of the current process.
+     * @param   dir       the working directory of the subprocess, or
+     *                    <tt>null</tt> if the subprocess should inherit
+     *                    the working directory of the current process.
+     * @return   the Process which has just started for this command line string.
+     *
+     */
+    public static Process execute(String self,  final String[] envp, File dir) throws IOException {
+        return Runtime.getRuntime().exec(self, envp, dir) ;
     }
 
     /**
@@ -3559,13 +3581,39 @@ public class DefaultGroovyMethods {
      * parameters as separate items in the list.
      * @return the Process which has just started for this command line string.
      */
-    public static Process execute ( final List commandList ) throws IOException {
-      final String[] commandArray = new String[commandList.size ( )] ;
-      Iterator it = commandList.iterator ( ) ;
-      for ( int i = 0 ; it.hasNext ( ) ; ++i ) {
-        commandArray[i] = it.next ( ).toString ( ) ;
+    public static Process execute(final List commandList) throws IOException {
+      final String[] commandArray = new String[commandList.size()] ;
+      Iterator it = commandList.iterator();
+      for (int i = 0; it.hasNext(); ++i) {
+          commandArray[i] = it.next().toString();
+      }
+      return execute(commandArray) ;
+    }
+
+    /**
+     * Executes the command specified by the <code>self</code> with environments <code>envp</code>
+     * under the working directory <code>dir</code>.
+     * For more control over the process mechanism in JDK 1.5 you can use <code>java.lang.ProcessBuilder</code>.
+     *
+     * @param   self      a command line String to be executed.
+     * @param   envp      a List of Strings, each member of which
+     *                    has environment variable settings in the format
+     *                    <i>name</i>=<i>value</i>, or
+     *                    <tt>null</tt> if the subprocess should inherit
+     *                    the environment of the current process.
+     * @param   dir       the working directory of the subprocess, or
+     *                    <tt>null</tt> if the subprocess should inherit
+     *                    the working directory of the current process.
+     * @return   the Process which has just started for this command line string.
+     *
+     */
+    public static Process execute(String self, final List envp, File dir) throws IOException {
+      final String[] commandArray = new String[envp.size()] ;
+      Iterator it = envp.iterator();
+      for (int i = 0; it.hasNext(); ++i) {
+          commandArray[i] = it.next().toString();
       }
-      return execute ( commandArray ) ;
+      return execute(self, commandArray, dir);
     }
 
     /**
diff --git a/src/test/groovy/GroovyMethodsTest.groovy b/src/test/groovy/GroovyMethodsTest.groovy
index c212e2acad..0198b33747 100644
--- a/src/test/groovy/GroovyMethodsTest.groovy
+++ b/src/test/groovy/GroovyMethodsTest.groovy
@@ -185,6 +185,38 @@ class GroovyMethodsTest extends GroovyTestCase {
         println "Exit value of command line is ${value}"
     }
     
+    void DISABLE_testExecuteCommandLineUnderWorkingDirectory() {
+        def cmd = "ls -l"
+        if (System.getProperty('os.name', '').contains('Win')) {
+            cmd = "dir"
+        }
+
+        def envp = java.util.Array.newInstance(String, 0)
+        def workDir = new File(".")
+
+        println "executing command: ${cmd} under the directory ${workDir}"
+
+        def process = cmd.execute(envp, workDir)
+
+        // lets have an easier way to do this!
+        def count = 0
+
+        println "Read the following lines under the directory ${workDir} ..."
+
+        /** @todo we should simplify the following line!!! */
+        new InputStreamReader(process.in).eachLine { line ->
+            println line
+            ++count
+        }
+        println ""
+
+        process.waitFor()
+        def value = process.exitValue()
+        println "Exit value of command line is ${value}"
+
+        assert count > 1
+    }
+    
     void testDisplaySystemProperties() {
         println "System properties are..."
         def properties = System.properties
