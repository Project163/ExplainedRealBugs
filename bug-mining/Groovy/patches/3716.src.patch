diff --git a/src/main/java/groovy/transform/NullCheck.java b/src/main/java/groovy/transform/NullCheck.java
index 9f007ea4df..a27afbb893 100644
--- a/src/main/java/groovy/transform/NullCheck.java
+++ b/src/main/java/groovy/transform/NullCheck.java
@@ -28,7 +28,8 @@ import java.lang.annotation.Target;
 /**
  * Class, method or constructor annotation which indicates that each parameter
  * should be checked to ensure it isn't null. If placed at the class level,
- * all explicit methods and constructors will be checked.
+ * all explicit methods and constructors will be checked. Explicit means those
+ * declared within the class and not inherited or added by transforms (but see {@link #includeGenerated()}).
  * <p>
  * Example usage:
  * <pre class="groovyTestCase">
@@ -80,4 +81,14 @@ import java.lang.annotation.Target;
 @Target({ElementType.TYPE})
 @GroovyASTTransformationClass("org.codehaus.groovy.transform.NullCheckASTTransformation")
 public @interface NullCheck {
+    /**
+     * Whether to try to add null checking to generated methods/constructors such as those added by other transforms.
+     * Using this option may lead to surprising results, e.g.&nbsp;it will only apply to methods/constructors added prior
+     * to when the {@code NullCheck} transformation is processed.
+     * Null checking is not enabled for constructors containing generated bytecode or
+     * generated constructors with calls to this(...) or super(...) regardless of this flag.
+     *
+     * @since 3.0.2
+     */
+    boolean includeGenerated() default false;
 }
diff --git a/src/main/java/org/codehaus/groovy/transform/NullCheckASTTransformation.java b/src/main/java/org/codehaus/groovy/transform/NullCheckASTTransformation.java
index f57a91a9b0..0308a0ff9c 100644
--- a/src/main/java/org/codehaus/groovy/transform/NullCheckASTTransformation.java
+++ b/src/main/java/org/codehaus/groovy/transform/NullCheckASTTransformation.java
@@ -19,6 +19,7 @@
 package org.codehaus.groovy.transform;
 
 import groovy.transform.NullCheck;
+import org.apache.groovy.ast.tools.ConstructorNodeUtils;
 import org.codehaus.groovy.ast.ASTNode;
 import org.codehaus.groovy.ast.AnnotatedNode;
 import org.codehaus.groovy.ast.AnnotationNode;
@@ -27,11 +28,14 @@ import org.codehaus.groovy.ast.ClassNode;
 import org.codehaus.groovy.ast.ConstructorNode;
 import org.codehaus.groovy.ast.MethodNode;
 import org.codehaus.groovy.ast.Parameter;
+import org.codehaus.groovy.ast.expr.ConstructorCallExpression;
 import org.codehaus.groovy.ast.stmt.BlockStatement;
-import org.codehaus.groovy.ast.stmt.Statement;
+import org.codehaus.groovy.classgen.BytecodeSequence;
 import org.codehaus.groovy.control.CompilePhase;
 import org.codehaus.groovy.control.SourceUnit;
 
+import static org.apache.groovy.ast.tools.AnnotatedNodeUtils.isGenerated;
+import static org.apache.groovy.ast.tools.MethodNodeUtils.getCodeAsBlock;
 import static org.codehaus.groovy.ast.ClassHelper.make;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.constX;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.ctorX;
@@ -41,11 +45,11 @@ import static org.codehaus.groovy.ast.tools.GeneralUtils.throwS;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.varX;
 
 /**
- * Handles generation of code for the @AutoImplement annotation.
+ * Handles generation of code for the @NullCheck annotation.
  */
 @GroovyASTTransformation(phase = CompilePhase.CANONICALIZATION)
 public class NullCheckASTTransformation extends AbstractASTTransformation {
-    private static final Class MY_CLASS = NullCheck.class;
+    private static final Class<NullCheck> MY_CLASS = NullCheck.class;
     private static final ClassNode MY_TYPE = make(MY_CLASS);
     private static final String MY_TYPE_NAME = "@" + MY_TYPE.getNameWithoutPackage();
     private static final ClassNode EXCEPTION = ClassHelper.make(IllegalArgumentException.class);
@@ -56,37 +60,46 @@ public class NullCheckASTTransformation extends AbstractASTTransformation {
         AnnotatedNode parent = (AnnotatedNode) nodes[1];
         AnnotationNode anno = (AnnotationNode) nodes[0];
         if (!MY_TYPE.equals(anno.getClassNode())) return;
+        boolean includeGenerated = memberHasValue(anno, "includeGenerated", true);
 
         if (parent instanceof ClassNode) {
             ClassNode cNode = (ClassNode) parent;
             if (!checkNotInterface(cNode, MY_TYPE_NAME)) return;
             for (ConstructorNode cn : cNode.getDeclaredConstructors()) {
-                adjustMethod(cn);
+                adjustMethod(cn, includeGenerated);
             }
             for (MethodNode mn : cNode.getAllDeclaredMethods()) {
-                adjustMethod(mn);
+                adjustMethod(mn, includeGenerated);
             }
         } else if (parent instanceof MethodNode) {
             // handles constructor case too
-            adjustMethod((MethodNode) parent);
+            adjustMethod((MethodNode) parent, includeGenerated);
         }
     }
 
-    private void adjustMethod(MethodNode mn) {
-        Statement origCode = mn.getCode();
-        BlockStatement newCode = new BlockStatement();
+    private void adjustMethod(MethodNode mn, boolean includeGenerated) {
+        BlockStatement newCode = getCodeAsBlock(mn);
         if (mn.getParameters().length == 0) return;
+        boolean generated = isGenerated(mn);
+        int startingIndex = 0;
+        if (!includeGenerated && generated) return;
+        if (mn instanceof ConstructorNode) {
+            // some transform has been here already and we assume it knows what it is doing
+            if (mn.getFirstStatement() instanceof BytecodeSequence) return;
+            // ignore any constructors calling this(...) or super(...)
+            ConstructorCallExpression cce = ConstructorNodeUtils.getFirstIfSpecialConstructorCall(mn.getCode());
+            if (cce != null) {
+                if (generated) {
+                    return;
+                } else {
+                    startingIndex = 1; // skip over this/super() call
+                }
+            }
+        }
         for (Parameter p : mn.getParameters()) {
-            newCode.addStatement(ifS(isNullX(varX(p)),
+            newCode.getStatements().add(startingIndex, ifS(isNullX(varX(p)),
                     throwS(ctorX(EXCEPTION, constX(p.getName() + " cannot be null")))));
         }
-        if (origCode instanceof BlockStatement) {
-            for (Statement s : ((BlockStatement) origCode).getStatements()) {
-                newCode.addStatement(s);
-            }
-        } else {
-            newCode.addStatement(origCode);
-        }
         mn.setCode(newCode);
     }
 }
diff --git a/src/test/org/codehaus/groovy/transform/NullCheckTransformTest.groovy b/src/test/org/codehaus/groovy/transform/NullCheckTransformTest.groovy
new file mode 100644
index 0000000000..0e849bfc46
--- /dev/null
+++ b/src/test/org/codehaus/groovy/transform/NullCheckTransformTest.groovy
@@ -0,0 +1,132 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package org.codehaus.groovy.transform
+
+import groovy.test.GroovyTestCase
+
+/**
+ * Tests for the {@code @NullCheck} AST transform.
+ */
+class NullCheckTransformTest extends GroovyTestCase {
+
+    // GROOVY-9406
+    void testNullCheckDoesNotConflictWithGeneratedConstructors() {
+        assertScript '''
+            import groovy.transform.*
+            import static groovy.test.GroovyAssert.shouldFail
+
+            class Base1 {
+                Long id
+                Base1(Long id) { this.id = id }
+            }
+
+            @NullCheck
+            @InheritConstructors
+            class Sub1A extends Base1 {}
+            assert new Sub1A(null).id == null
+
+            @InheritConstructors
+            @NullCheck
+            class Sub1B extends Base1 {}
+            assert new Sub1B(null).id == null
+
+            @NullCheck
+            class Sub1C extends Base1 {
+                Sub1C(Long id) { super(id) }
+                Sub1C(Long id, Boolean flag) { super(id) }
+            }
+            def ex = shouldFail(IllegalArgumentException) { new Sub1C(null).id == null }
+            assert ex.message == 'id cannot be null'
+            ex = shouldFail(IllegalArgumentException) { new Sub1C(42L, null).id == null }
+            assert ex.message == 'flag cannot be null'
+        '''
+    }
+
+    void testNullCheckWithIncludeGenerated() {
+        assertScript '''
+            import groovy.transform.*
+            import static groovy.test.GroovyAssert.shouldFail
+
+            @EqualsAndHashCode
+            @NullCheck
+            class OneHolder {
+                String one
+            }
+
+            @EqualsAndHashCode
+            @NullCheck(includeGenerated=true)
+            class TwoHolder {
+                String two
+            }
+
+            def one = new OneHolder(one: 'One')
+            assert !one.equals(null)
+            def two = new TwoHolder(two: 'Two')
+            def ex = shouldFail(IllegalArgumentException) { two.equals(null) }
+            assert ex.message == 'other cannot be null'
+        '''
+    }
+
+    void testNullCheckMethodWithDefaultValues() {
+        assertScript '''
+            import groovy.transform.*
+            import static groovy.test.GroovyAssert.shouldFail
+
+            @NullCheck
+            class ConsWithDefaults {
+                ConsWithDefaults(String first, String middle = 'M', String last = 'L') {}
+                ConsWithDefaults(String part, Integer times, Boolean flag) {
+                    this('dummy', 'value')
+                }
+            }
+
+            def ex = shouldFail(IllegalArgumentException) { new ConsWithDefaults(null) }
+            assert ex.message == 'first cannot be null'
+            ex = shouldFail(IllegalArgumentException) { new ConsWithDefaults('F', null) }
+            assert ex.message == 'middle cannot be null'
+            ex = shouldFail(IllegalArgumentException) { new ConsWithDefaults('Foo', null, true) }
+            assert ex.message == 'times cannot be null'
+            ex = shouldFail(IllegalArgumentException) { new ConsWithDefaults('Foo', 3, null) }
+            assert ex.message == 'flag cannot be null'
+        '''
+    }
+
+    void testNullCheckMethodWithNullDefaultValue() {
+        assertScript '''
+            import groovy.transform.*
+            import static groovy.test.GroovyAssert.shouldFail
+
+            @NullCheck
+            class ConsWithNullDefault {
+                ConsWithNullDefault(Integer first = null, Integer second = 42) {}
+            }
+
+            assert new ConsWithNullDefault(42)
+
+            def ex = shouldFail(IllegalArgumentException) { new ConsWithNullDefault() }
+            assert ex.message == 'first cannot be null'
+
+            ex = shouldFail(IllegalArgumentException) { new ConsWithNullDefault(null) }
+            assert ex.message == 'first cannot be null'
+
+            ex = shouldFail(IllegalArgumentException) { new ConsWithNullDefault(42, null) }
+            assert ex.message == 'second cannot be null'
+        '''
+    }
+}
