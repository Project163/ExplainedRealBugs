diff --git a/src/main/org/codehaus/groovy/ast/MethodNode.java b/src/main/org/codehaus/groovy/ast/MethodNode.java
index b6493cb9b9..2c9e880efd 100644
--- a/src/main/org/codehaus/groovy/ast/MethodNode.java
+++ b/src/main/org/codehaus/groovy/ast/MethodNode.java
@@ -42,6 +42,9 @@ public class MethodNode extends AnnotatedNode implements Opcodes {
     // type spec for generics
     private GenericsType[] genericsTypes=null;
     private boolean hasDefault;
+    
+    // cached data
+    String typeDescriptor;
 
     public MethodNode(String name, int modifiers, ClassNode returnType, Parameter[] parameters, ClassNode[] exceptions, Statement code) {
         this.name = name;
@@ -58,27 +61,30 @@ public class MethodNode extends AnnotatedNode implements Opcodes {
     /**
      * The type descriptor for a method node is a string containing the name of the method, its return type,
      * and its parameter types in a canonical form. For simplicity, I'm using the format of a Java declaration
-     * without parameter names, and with $dynamic as the type for any dynamically typed values.
+     * without parameter names.
      */
-    // TODO: add test case for type descriptor
     public String getTypeDescriptor() {
-        StringBuffer buf = new StringBuffer(name.length()+parameters.length*10);
-        // buf.append(dynamicReturnType ? "$dynamic" : cleanupTypeName(returnType));
-        //
-        buf.append(returnType.getName()); // br  to replace the above. Dynamic type returns Object.
-        //
-        buf.append(' ');
-        buf.append(name);
-        buf.append('(');
-        for (int i = 0; i < parameters.length; i++) {
-            if (i > 0) {
-                buf.append(", ");
+        if (typeDescriptor==null) { 
+            StringBuffer buf = new StringBuffer(name.length()+parameters.length*10);
+            buf.append(returnType.getName());
+            buf.append(' ');
+            buf.append(name);
+            buf.append('(');
+            for (int i = 0; i < parameters.length; i++) {
+                if (i > 0) {
+                    buf.append(", ");
+                }
+                Parameter param = parameters[i];
+                buf.append(param.getType().getName());
             }
-            Parameter param = parameters[i];
-            buf.append(param.getType().getName());
+            buf.append(')');
+            typeDescriptor = buf.toString();
         }
-        buf.append(')');
-        return buf.toString();
+        return typeDescriptor;
+    }
+    
+    private void invalidateCachedData() {
+        typeDescriptor = null;
     }
  
     public boolean isVoidMethod() {
@@ -98,6 +104,7 @@ public class MethodNode extends AnnotatedNode implements Opcodes {
     }
 
     public void setModifiers(int modifiers) {
+        invalidateCachedData();
         this.modifiers = modifiers;
     }
 
@@ -110,6 +117,7 @@ public class MethodNode extends AnnotatedNode implements Opcodes {
     }
 
     public void setParameters(Parameter[] parameters) {
+        invalidateCachedData();
         VariableScope scope = new VariableScope();
         this.parameters = parameters;
         if (parameters != null && parameters.length > 0) {
@@ -167,10 +175,11 @@ public class MethodNode extends AnnotatedNode implements Opcodes {
     }
 
     public String toString() {
-        return super.toString() + "[name: " + name + "]";
+        return "MethodNode@"+hashCode()+"[" + getTypeDescriptor() + "]";
     }
 
     public void setReturnType(ClassNode returnType) {
+        invalidateCachedData();
     	dynamicReturnType |= ClassHelper.DYNAMIC_TYPE==returnType;
         this.returnType = returnType;
         if (returnType==null) this.returnType = ClassHelper.OBJECT_TYPE;
@@ -199,6 +208,7 @@ public class MethodNode extends AnnotatedNode implements Opcodes {
     }
 
     public void setGenericsTypes(GenericsType[] genericsTypes) {
+        invalidateCachedData();
         this.genericsTypes = genericsTypes;
     }
 
diff --git a/src/main/org/codehaus/groovy/classgen/Verifier.java b/src/main/org/codehaus/groovy/classgen/Verifier.java
index dca3a5a3b6..c2448ec45a 100644
--- a/src/main/org/codehaus/groovy/classgen/Verifier.java
+++ b/src/main/org/codehaus/groovy/classgen/Verifier.java
@@ -902,21 +902,26 @@ public class Verifier implements GroovyClassVisitor, Opcodes {
         Map methodsToAdd = new HashMap();
         Map genericsSpec = new HashMap();
 
-        List declaredMethods = classNode.getAllDeclaredMethods();
+        // unimplemented abstract methods from interfaces
+        Map abstractMethods = new HashMap();
+        ClassNode[] interfaces = classNode.getInterfaces();
+        for (int i = 0; i < interfaces.length; i++) {
+            ClassNode iface = interfaces[i];
+            Map ifaceMethodsMap = iface.getDeclaredMethodsMap();
+            abstractMethods.putAll(ifaceMethodsMap);
+        }
+        
+        List declaredMethods = new ArrayList(classNode.getMethods());
         // remove all static, private and package private methods
-        // we remove also abstract methods if the current class is not abstract
-        // we do remove abstract methods, because covariation may automatically implement them
-        boolean isNotAbstract = (classNode.getModifiers() & ACC_ABSTRACT)==0;
         for (Iterator methodsIterator = declaredMethods.iterator(); methodsIterator.hasNext();) {
             MethodNode m = (MethodNode) methodsIterator.next();
+            abstractMethods.remove(m.getTypeDescriptor());
             if (m.isStatic() || !(m.isPublic() || m.isProtected())) {
                 methodsIterator.remove();
-            } else if (isNotAbstract && m.isAbstract()) {
-                methodsIterator.remove();
-            }
+            } 
         }
         
-        addCovariantMethods(classNode, declaredMethods, methodsToAdd, genericsSpec);
+        addCovariantMethods(classNode, declaredMethods, abstractMethods, methodsToAdd, genericsSpec);
 
         Map declaredMethodsMap = new HashMap();
         if (methodsToAdd.size()>0) {
@@ -936,27 +941,40 @@ public class Verifier implements GroovyClassVisitor, Opcodes {
         }
     }
     
-    private void addCovariantMethods(ClassNode classNode, List declaredMethods, Map methodsToAdd, Map oldGenericsSpec) {
+    private void addCovariantMethods(ClassNode classNode, List declaredMethods, Map abstractMethods, Map methodsToAdd, Map oldGenericsSpec) {
         ClassNode sn = classNode.getUnresolvedSuperClass(false);
+        
         if (sn!=null) {
             Map genericsSpec = createGenericsSpec(sn,oldGenericsSpec);
+            List classMethods = sn.getMethods();
+            // original class causing bridge methods for methods in super class
             for (Iterator it = declaredMethods.iterator(); it.hasNext();) {
                 MethodNode method = (MethodNode) it.next();
                 if (method.isStatic()) continue;
-                storeMissingCovariantMethods(sn,method,methodsToAdd,genericsSpec);
+                storeMissingCovariantMethods(classMethods,method,methodsToAdd,genericsSpec);
+            }
+            // super class causing bridge methods for abstract methods in original class
+            if (!abstractMethods.isEmpty()) {
+                for (Iterator it = classMethods.iterator(); it.hasNext();) {
+                    MethodNode method = (MethodNode) it.next();
+                    if (method.isStatic()) continue;
+                    storeMissingCovariantMethods(abstractMethods.values(),method,methodsToAdd,Collections.EMPTY_MAP);
+                }
             }
-            addCovariantMethods(sn.redirect(),declaredMethods,methodsToAdd,genericsSpec);
+            
+            addCovariantMethods(sn.redirect(),declaredMethods,abstractMethods,methodsToAdd,genericsSpec);
         }
         
         ClassNode[] interfaces = classNode.getInterfaces();
         for (int i=0; i<interfaces.length; i++) {
+            List interfacesMethods = interfaces[i].getMethods();
             Map genericsSpec = createGenericsSpec(interfaces[i],oldGenericsSpec);
             for (Iterator it = declaredMethods.iterator(); it.hasNext();) {
                 MethodNode method = (MethodNode) it.next();
                 if (method.isStatic()) continue;
-                storeMissingCovariantMethods(interfaces[i],method,methodsToAdd,genericsSpec);
+                storeMissingCovariantMethods(interfacesMethods,method,methodsToAdd,genericsSpec);
             }
-            addCovariantMethods(interfaces[i],declaredMethods,methodsToAdd,genericsSpec);
+            addCovariantMethods(interfaces[i],declaredMethods,abstractMethods,methodsToAdd,genericsSpec);
         }
         
     }
@@ -1062,8 +1080,7 @@ public class Verifier implements GroovyClassVisitor, Opcodes {
         return params;
     }
 
-    private void storeMissingCovariantMethods(ClassNode current, MethodNode method, Map methodsToAdd, Map genericsSpec) {
-        List methods = current.getMethods();
+    private void storeMissingCovariantMethods(Collection methods, MethodNode method, Map methodsToAdd, Map genericsSpec) {
         for (Iterator sit = methods.iterator(); sit.hasNext();) {
             MethodNode toOverride = (MethodNode) sit.next();
             MethodNode bridgeMethod = getCovariantImplementation(toOverride,method,genericsSpec);
diff --git a/src/test/gls/invocation/CovariantReturnTest.groovy b/src/test/gls/invocation/CovariantReturnTest.groovy
index ac652fb470..7cf5592483 100644
--- a/src/test/gls/invocation/CovariantReturnTest.groovy
+++ b/src/test/gls/invocation/CovariantReturnTest.groovy
@@ -119,7 +119,7 @@ public class CovariantReturnTest extends CompilableTestSupport {
     // is also a GroovyObject, meaning a "Object getProperty(String)" method
     // should be implemented. But this method should not be the usual automatically
     // added getProperty, but a bridge to the getProperty method provided by Properties 
-    shouldCompile """
+    assertScript """
       class Configuration extends java.util.Properties {}
       assert Configuration.declaredMethods.findAll{it.name=="getProperty"}.size() == 1
       def conf = new Configuration()
@@ -130,6 +130,16 @@ public class CovariantReturnTest extends CompilableTestSupport {
     """
   }
   
+  void testImplementedInterfacesNotInfluencing(){
+    // in GROOVY-3229 some methods from Appendable were not correctly recognized
+    // as already being overriden (PrintWriter<Writer<Appenable)
+    shouldCompile """
+        class IndentWriter extends java.io.PrintWriter {
+           public IndentWriter(Writer w)  { super(w, true) }
+        }
+    """
+  }
+  
   void testCovariantMethodReturnTypeFromGenericsInterface() {
     shouldCompile """
         interface MyCallable<T> {
