diff --git a/src/main/org/codehaus/groovy/control/StaticImportVisitor.java b/src/main/org/codehaus/groovy/control/StaticImportVisitor.java
index fd965ad6d3..563f94009b 100644
--- a/src/main/org/codehaus/groovy/control/StaticImportVisitor.java
+++ b/src/main/org/codehaus/groovy/control/StaticImportVisitor.java
@@ -156,7 +156,7 @@ public class StaticImportVisitor extends ClassCodeExpressionTransformer {
                 return result;
             }
         } else {
-            left = transform(be.getLeftExpression());            
+            left = transform(be.getLeftExpression());
         }
         be.setLeftExpression(left);
         return be;
@@ -266,7 +266,7 @@ public class StaticImportVisitor extends ClassCodeExpressionTransformer {
                     if (inSpecialConstructorCall ||
                             (lookForPossibleStaticMethod && currentClass.hasPossibleStaticMethod(methodName, args))) {
                         StaticMethodCallExpression smce = new StaticMethodCallExpression(currentClass, methodName, args);
-                    	setSourcePosition(smce, mce);
+                        setSourcePosition(smce, mce);
                         return smce;
                     }
                 }
@@ -320,11 +320,16 @@ public class StaticImportVisitor extends ClassCodeExpressionTransformer {
         foundArgs = null;
         foundConstant = null;
         Expression objectExpression = transform(pe.getObjectExpression());
+        boolean candidate = false;
+        if (objectExpression instanceof MethodCallExpression) {
+            candidate = ((MethodCallExpression)objectExpression).isImplicitThis();
+        }
 
-        if (foundArgs != null && foundConstant != null) {
+        if (foundArgs != null && foundConstant != null && candidate) {
             Expression result = findStaticMethodImportFromModule(foundConstant, foundArgs);
             if (result != null) {
                 objectExpression = result;
+                objectExpression.setSourcePosition(pe);
             }
         }
         inPropertyExpression = oldInPropertyExpression;
@@ -361,7 +366,7 @@ public class StaticImportVisitor extends ClassCodeExpressionTransformer {
                 if (expression != null) return expression;
             }
         }
-        
+
         // look for one of these:
         //   import static MyClass.prop [as otherProp]
         // when resolving prop or field reference
diff --git a/src/test/groovy/StaticImportTest.groovy b/src/test/groovy/StaticImportTest.groovy
index e595efae8b..9321d75852 100644
--- a/src/test/groovy/StaticImportTest.groovy
+++ b/src/test/groovy/StaticImportTest.groovy
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2010 the original author or authors.
+ * Copyright 2003-2011 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -292,6 +292,10 @@ class StaticImportTest extends CompilableTestSupport {
         assert AttrName.class.name == 'java.util.jar.Attributes$Name'
     }
 
+    void testExplicitStaticMethodCallHasPrecedenceOverStaticImport() {
+        Bar4964.run()
+    }
+
     // TODO GROOVY-4287: reinstate next two tests
 //    void testStaticStarImportOfStaticInnerClassExternalClass() {
 //        assert Inner3.class.name == 'Outer3$Inner3'
@@ -329,3 +333,18 @@ class Outer1 {
 class Outer2 {
     static class Inner2 {}
 }
+
+class Foo4964 {
+    static doIt() { [k: 'foo'] }
+}
+
+import static Foo4964.*
+class Bar4964 {
+    static doIt() { [k: 'bar'] }
+    static run() {
+        assert doIt().k == 'foo'
+        assert doIt() == [k: 'foo']
+        assert Bar4964.doIt() == [k: 'bar']
+        assert Bar4964.doIt().k == 'bar'
+    }
+}
