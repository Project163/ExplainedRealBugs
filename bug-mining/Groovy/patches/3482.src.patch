diff --git a/src/main/groovy/groovy/transform/AnnotationCollector.java b/src/main/groovy/groovy/transform/AnnotationCollector.java
index b9f2161fa6..d0a5653ce0 100644
--- a/src/main/groovy/groovy/transform/AnnotationCollector.java
+++ b/src/main/groovy/groovy/transform/AnnotationCollector.java
@@ -196,4 +196,13 @@ public @interface AnnotationCollector {
      * List of aliased annotations.
      */
     Class[] value() default {};
+
+    /**
+     * Used internally - the default value is a marker value indicating that the attribute hasn't been set.
+     * Normally set automatically during annotation processing to an automatically created
+     * nested helper class which holds serialization information used in pre-compiled scenarios.
+     * If set to the collector annotation, re-purposes the annotation itself to become the helper
+     * class (legacy approach used in Groovy 2.5 up to 2.5.2).
+     */
+    Class serializeClass() default Undefined.CLASS.class;
 }
diff --git a/src/main/groovy/groovy/transform/Immutable.groovy b/src/main/groovy/groovy/transform/Immutable.groovy
index 638a9db3ce..9955051802 100644
--- a/src/main/groovy/groovy/transform/Immutable.groovy
+++ b/src/main/groovy/groovy/transform/Immutable.groovy
@@ -20,6 +20,11 @@ package groovy.transform
 
 import groovy.transform.options.ImmutablePropertyHandler
 
+import java.lang.annotation.ElementType
+import java.lang.annotation.Retention
+import java.lang.annotation.RetentionPolicy
+import java.lang.annotation.Target
+
 /**
  * Meta annotation used when defining immutable classes.
  * <p>
@@ -182,4 +187,15 @@ import groovy.transform.options.ImmutablePropertyHandler
 @MapConstructor(noArg = true, includeSuperProperties = true, includeFields = true)
 @KnownImmutable
 @AnnotationCollector(mode=AnnotationCollectorMode.PREFER_EXPLICIT_MERGED)
-@interface Immutable { }
+@Retention(RetentionPolicy.RUNTIME)
+@Target([ ElementType.TYPE ])
+@interface Immutable {
+    /** No longer used directly but exists for legacy handling only. See component annotations. */
+    Class[] knownImmutableClasses() default []
+
+    /** No longer used directly but exists for legacy handling only. See component annotations. */
+    String[] knownImmutables() default []
+
+    /** No longer used directly but exists for legacy handling only. See component annotations. */
+    boolean copyWith() default false
+}
diff --git a/src/main/java/org/codehaus/groovy/transform/AnnotationCollectorTransform.java b/src/main/java/org/codehaus/groovy/transform/AnnotationCollectorTransform.java
index 4d00531e52..b41c08b38e 100644
--- a/src/main/java/org/codehaus/groovy/transform/AnnotationCollectorTransform.java
+++ b/src/main/java/org/codehaus/groovy/transform/AnnotationCollectorTransform.java
@@ -25,6 +25,8 @@ import org.codehaus.groovy.ast.AnnotatedNode;
 import org.codehaus.groovy.ast.AnnotationNode;
 import org.codehaus.groovy.ast.ClassHelper;
 import org.codehaus.groovy.ast.ClassNode;
+import org.codehaus.groovy.ast.InnerClassNode;
+import org.codehaus.groovy.ast.MethodNode;
 import org.codehaus.groovy.ast.Parameter;
 import org.codehaus.groovy.ast.expr.AnnotationConstantExpression;
 import org.codehaus.groovy.ast.expr.ArrayExpression;
@@ -49,6 +51,7 @@ import java.util.ListIterator;
 import java.util.Map;
 import java.util.Set;
 
+import static org.codehaus.groovy.transform.trait.TraitComposer.COMPILESTATIC_CLASSNODE;
 import static org.objectweb.asm.Opcodes.ACC_ABSTRACT;
 import static org.objectweb.asm.Opcodes.ACC_ANNOTATION;
 import static org.objectweb.asm.Opcodes.ACC_ENUM;
@@ -96,7 +99,7 @@ public class AnnotationCollectorTransform {
          */
         public void transformClass(ClassNode cn) {
             AnnotationNode collector = null;
-            for (ListIterator<AnnotationNode> it = cn.getAnnotations().listIterator(); it.hasNext();) {
+            for (ListIterator<AnnotationNode> it = cn.getAnnotations().listIterator(); it.hasNext(); ) {
                 AnnotationNode an = it.next();
                 if (an.getClassNode().getName().equals(AnnotationCollector.class.getName())) {
                     collector = an;
@@ -106,15 +109,31 @@ public class AnnotationCollectorTransform {
             if (collector == null) {
                 return;
             }
-            // force final class, remove interface, annotation, enum and abstract modifiers
-            cn.setModifiers((ACC_FINAL+cn.getModifiers()) & ~(ACC_ENUM|ACC_INTERFACE|ACC_ANNOTATION|ACC_ABSTRACT));
-            // force Object super class
-            cn.setSuperClass(ClassHelper.OBJECT_TYPE);
-            // force no interfaces implemented
-            cn.setInterfaces(ClassNode.EMPTY_ARRAY);
+            boolean legacySerialization = false;
+            final Expression member = collector.getMember("serializeClass");
+            if (member instanceof ClassExpression) {
+                ClassExpression ce = (ClassExpression) member;
+                legacySerialization = ce.getType().getName().equals(cn.getName());
+            }
+            ClassNode helper = cn;
+            if (legacySerialization) {
+                // force final class, remove interface, annotation, enum and abstract modifiers
+                helper.setModifiers((ACC_FINAL + helper.getModifiers()) & ~(ACC_ENUM | ACC_INTERFACE | ACC_ANNOTATION | ACC_ABSTRACT));
+                // force Object super class
+                helper.setSuperClass(ClassHelper.OBJECT_TYPE);
+                // force no interfaces implemented
+                helper.setInterfaces(ClassNode.EMPTY_ARRAY);
+            } else {
+                helper = new InnerClassNode(cn.getPlainNodeReference(), cn.getName() + "$CollectorHelper",
+                        ACC_PUBLIC | ACC_STATIC | ACC_FINAL, ClassHelper.OBJECT_TYPE.getPlainNodeReference());
+                cn.getModule().addClass(helper);
+                helper.addAnnotation(new AnnotationNode(COMPILESTATIC_CLASSNODE));
+                MethodNode serializeClass = collector.getClassNode().getMethod("serializeClass", Parameter.EMPTY_ARRAY);
+                collector.setMember("serializeClass", new ClassExpression(helper.getPlainNodeReference()));
+            }
 
             // add static value():Object[][] method
-            List<AnnotationNode> meta = getMeta(cn); 
+            List<AnnotationNode> meta = getMeta(cn);
             List<Expression> outer = new ArrayList<Expression>(meta.size());
             for (AnnotationNode an : meta) {
                 Expression serialized = serialize(an);
@@ -123,15 +142,14 @@ public class AnnotationCollectorTransform {
 
             ArrayExpression ae = new ArrayExpression(ClassHelper.OBJECT_TYPE.makeArray(), outer);
             Statement code = new ReturnStatement(ae);
-            cn.addMethod(   "value", ACC_PUBLIC+ACC_STATIC,
-                            ClassHelper.OBJECT_TYPE.makeArray().makeArray(), 
-                            Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY,
-                            code);
+            helper.addMethod("value", ACC_PUBLIC + ACC_STATIC,
+                    ClassHelper.OBJECT_TYPE.makeArray().makeArray(),
+                    Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, code);
 
             // remove annotations
-            for (ListIterator<AnnotationNode> it = cn.getAnnotations().listIterator(); it.hasNext();) {
+            for (ListIterator<AnnotationNode> it = cn.getAnnotations().listIterator(); it.hasNext(); ) {
                 AnnotationNode an = it.next();
-                if (an == collector) {
+                if (an == collector || "java.lang.annotation".equals(an.getClassNode().getPackageName())) {
                     continue;
                 }
                 it.remove();
@@ -232,7 +250,7 @@ public class AnnotationCollectorTransform {
         List<AnnotationNode> ret = new ArrayList<AnnotationNode>(annotations.size());
         for (AnnotationNode an : annotations) {
             ClassNode type = an.getClassNode();
-            if (type.getName().equals(AnnotationCollector.class.getName())) continue;
+            if (type.getName().equals(AnnotationCollector.class.getName()) || "java.lang.annotation".equals(type.getPackageName())) continue;
             AnnotationNode toAdd = new AnnotationNode(type);
             copyMembers(an, toAdd);
             ret.add(toAdd);
@@ -252,6 +270,7 @@ public class AnnotationCollectorTransform {
     }
 
     private static List<AnnotationNode> getTargetListFromClass(ClassNode alias) {
+        alias = getSerializeClass(alias);
         Class<?> c = alias.getTypeClass();
         Object[][] data;
         try {
@@ -262,7 +281,23 @@ public class AnnotationCollectorTransform {
         }
         return makeListOfAnnotations(data);
     }
-    
+
+    // 2.5.3 and above gets from annotation attribute otherwise self
+    private static ClassNode getSerializeClass(ClassNode alias) {
+        List<AnnotationNode> annotations = alias.getAnnotations(ClassHelper.make(AnnotationCollector.class));
+        if (!annotations.isEmpty()) {
+            AnnotationNode annotationNode = annotations.get(0);
+            Expression member = annotationNode.getMember("serializeClass");
+            if (member instanceof ClassExpression) {
+                ClassExpression ce = (ClassExpression) member;
+                if (!ce.getType().getName().equals(AnnotationCollector.class.getName())) {
+                    alias = ce.getType();
+                }
+            }
+        }
+        return alias;
+    }
+
     private static List<AnnotationNode> makeListOfAnnotations(Object[][] data) {
         if (data.length == 0) {
             return Collections.emptyList();
@@ -349,7 +384,7 @@ public class AnnotationCollectorTransform {
     public List<AnnotationNode> visit(AnnotationNode collector, AnnotationNode aliasAnnotationUsage, AnnotatedNode aliasAnnotated, SourceUnit source) {
         List<AnnotationNode> ret =  getTargetAnnotationList(collector, aliasAnnotationUsage, source);
         Set<String> unusedNames = new HashSet<String>(aliasAnnotationUsage.getMembers().keySet());
-        
+
         for (AnnotationNode an: ret) {
             for (String name : aliasAnnotationUsage.getMembers().keySet()) {
                 if (an.getClassNode().hasMethod(name, Parameter.EMPTY_ARRAY)) {
diff --git a/src/test/groovy/transform/AnnotationCollectorLegacyTest.groovy b/src/test/groovy/transform/AnnotationCollectorLegacyTest.groovy
new file mode 100644
index 0000000000..b7237695bf
--- /dev/null
+++ b/src/test/groovy/transform/AnnotationCollectorLegacyTest.groovy
@@ -0,0 +1,482 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package groovy.transform
+
+import org.codehaus.groovy.ast.AnnotatedNode
+import org.codehaus.groovy.ast.AnnotationNode
+import org.codehaus.groovy.control.MultipleCompilationErrorsException
+import org.codehaus.groovy.control.SourceUnit
+import org.codehaus.groovy.transform.AnnotationCollectorTransform
+
+class AnnotationCollectorLegacyTest extends GroovyTestCase {
+
+    static class MyProcessor extends AnnotationCollectorTransform {
+        List<AnnotationNode> visit(AnnotationNode collector, AnnotationNode aliasAnnotationUsage, AnnotatedNode aliasAnnotated, SourceUnit source) {
+            def excludes = aliasAnnotationUsage.getMember("excludes")
+            if (excludes) {
+                addError("use myex instead of excludes", aliasAnnotationUsage, source)
+                return []
+            }
+            def myex = aliasAnnotationUsage.getMembers().remove("myex")
+            if (myex) aliasAnnotationUsage.addMember("excludes", myex)
+            return super.visit(collector, aliasAnnotationUsage, aliasAnnotated, source)
+        }
+    }
+
+    void assertScript(String script) {
+        GroovyShell shell = new GroovyShell(this.class.classLoader)
+        shell.evaluate(script, getTestClassName())
+    }
+
+    void shouldNotCompile(String script, Closure failureAction) {
+        GroovyShell shell = new GroovyShell(this.class.classLoader)
+        try {
+            shell.parse(script, getTestClassName())
+            assert false
+        } catch (MultipleCompilationErrorsException mce) {
+            failureAction(mce)
+        }
+    }
+
+    void testSimpleUsage() {
+        assert PreCompiledAliasL.value().length == 0
+        assert PreCompiledAliasL.value() instanceof Object[][]
+        assertScript '''
+            import groovy.transform.PreCompiledAliasL
+            @PreCompiledAliasL
+            class Foo {
+                Integer a, b
+            }
+            assert Foo.class.annotations.size() == 3
+            assert new Foo(a: 1, b: 2).toString() == "Foo(1, 2)"
+            assert PreCompiledAliasL.value().length == 0
+            assert PreCompiledAliasL.value() instanceof Object[][]
+        '''
+
+        assertScript '''
+            import groovy.transform.*
+            @AnnotationCollector(value = [ToString, EqualsAndHashCode, Sortable], serializeClass = NotPreCompiledAlias)
+            @interface NotPreCompiledAlias {}
+
+            @NotPreCompiledAlias
+            class Foo {
+                Integer a, b
+            }
+            assert Foo.class.annotations.size() == 3
+            assert new Foo(a: 1, b: 2).toString() == "Foo(1, 2)"
+            assert NotPreCompiledAlias.value().length == 0
+            assert NotPreCompiledAlias.value() instanceof Object[][]
+        '''
+    }
+
+    void testUsageWithArgument() {
+        assertScript '''
+            import groovy.transform.*
+
+            @PreCompiledAliasL(excludes=["a"])
+            class Foo {
+                Integer a, b
+            }
+            assert Foo.class.annotations.size() == 3
+            assert new Foo(a: 1, b: 2).toString() == "Foo(2)"
+            assert PreCompiledAliasL.value().length == 0
+            assert PreCompiledAliasL.value() instanceof Object[][]
+        '''
+
+        assertScript '''
+            import groovy.transform.*
+            @AnnotationCollector(value = [ToString, EqualsAndHashCode, Sortable], serializeClass = NotPreCompiledAlias)
+            @interface NotPreCompiledAlias {}
+
+            @NotPreCompiledAlias(excludes=["a"])
+            class Foo {
+                Integer a, b
+            }
+            assert Foo.class.annotations.size() == 3 
+            assert new Foo(a: 1, b: 2).toString() == "Foo(2)"
+            assert NotPreCompiledAlias.value().length == 0
+            assert NotPreCompiledAlias.value() instanceof Object[][]
+        '''
+    }
+
+    void testClosureAnnotation() {
+        assertScript '''
+            import groovy.transform.*
+            @AnnotationCollector(value = [ConditionalInterrupt], serializeClass = NotPreCompiledAlias)
+            @interface NotPreCompiledAlias {}
+
+            @NotPreCompiledAlias(applyToAllClasses=false, value={ counter++> 10})
+            class X {
+                def counter = 0
+                def method() {
+                  4.times {null}
+                 }
+            }
+            def x = new X(counter:20)
+            try {
+                x.method()
+                assert false
+            } catch (InterruptedException ie)  {
+                assert true
+            }
+            assert NotPreCompiledAlias.value().length == 0
+            assert NotPreCompiledAlias.value() instanceof Object[][]
+        '''
+        assertScript '''
+            import groovy.transform.*
+    
+            @OtherPreCompiledAliasL(applyToAllClasses=false, value={ counter++> 10})
+            class X {
+                def counter = 0
+                def method() {
+                  4.times {null}
+                 }
+            }
+            def x = new X(counter:20)
+            try {
+                x.method()
+                assert false
+            } catch (InterruptedException ie)  {
+                assert true
+            }
+            assert OtherPreCompiledAliasL.value().length == 0
+            assert OtherPreCompiledAliasL.value() instanceof Object[][]
+        '''
+    }
+
+    void testAST() {
+        assertScript """
+            import groovy.transform.*
+            @AnnotationCollector(value = [ToString, EqualsAndHashCode, Sortable], serializeClass = Alias)
+            @interface Alias {}
+
+            @Alias(excludes=["a"])
+            @ASTTest(phase=org.codehaus.groovy.control.CompilePhase.INSTRUCTION_SELECTION, value={
+                def annotations = node.annotations
+                assert annotations.size() == 4 //ASTTest + 3
+                annotations.each {
+                    assert it.lineNumber == 6 || it.classNode.name.contains("ASTTest")
+                }
+            })
+            class Foo {
+                Integer a, b
+            }
+            assert Foo.class.annotations.size() == 4
+            assert new Foo(a: 1, b: 2).toString() == "Foo(2)"
+            assert Alias.value().length == 0
+            assert Alias.value() instanceof Object[][]
+        """
+    }
+
+    void testConflictingAnnotations() {
+        shouldNotCompile """
+            import groovy.transform.*
+            @interface ConflictingA {String foo()}
+            @interface ConflictingB {int foo()}
+
+            @AnnotationCollector([ConflictingA, ConflictingB])
+            @interface Alias {}
+
+            @Alias(foo="1") class X{}
+        """, { exception ->
+            exception.message.contains("line 9, column 24")
+            exception.message.contains("Attribute 'foo' should have type 'java.lang.Integer'")
+        }
+    }
+
+    void testCustomProcessor() {
+        assertScript '''
+            import groovy.transform.*
+            @AnnotationCollector(value=[ToString, EqualsAndHashCode, Sortable], processor='groovy.transform.AnnotationCollectorTest$MyProcessor', serializeClass = Alias)
+            @interface Alias {}
+
+            @Alias(myex=["a"])
+            class Foo {
+                Integer a, b
+            }
+            assert Foo.class.annotations.size() == 3
+            assert new Foo(a: 1, b: 2).toString() == "Foo(2)"
+            assert Alias.value().length == 0
+            assert Alias.value() instanceof Object[][]
+        '''
+    }
+
+    void testProcessorThrowingCustomMessage() {
+        shouldNotCompile '''
+            import groovy.transform.*
+            @AnnotationCollector(value=[ToString, EqualsAndHashCode, Sortable], processor='groovy.transform.AnnotationCollectorTest$MyProcessor')
+            @interface Alias {}
+
+            @Alias(excludes=["a"])
+            class Foo {
+                Integer a, b
+            }
+            assert Foo.class.annotations.size() == 3
+            assert new Foo(a: 1, b: 2).toString() == "Foo(2)"
+        ''', { ex ->
+            assert ex.message.contains("use myex instead of excludes @ line 6, column 13")
+        }
+    }
+
+    void testWrongProcessorName() {
+        shouldNotCompile '''
+            import groovy.transform.*
+            @AnnotationCollector(value=[ToString, EqualsAndHashCode, Sortable], processor='MyProcessor')
+            @interface Alias {}
+
+            @Alias(excludes=["a"])
+            class Foo {
+                Integer a, b
+            }
+            assert Foo.class.annotations.size() == 3
+            assert new Foo(a: 1, b: 2).toString() == "Foo(2)"
+        ''', { ex ->
+            assert ex.message.contains("Could not find class for Transformation Processor MyProcessor declared by Alias")
+        }
+    }
+
+    void testAnnotationOnAnnotation() {
+        assertScript """
+            import groovy.transform.*
+
+            @PreCompiledAlias3L
+            class Foo {
+                Integer a, b
+            }
+            assert Foo.class.annotations.size() == 2
+            assert new Foo(a: 1, b: 2).toString() == "Foo(2)"
+
+            def data = PreCompiledAlias3L.value()
+            assert data.length == 2
+            assert data instanceof Object[][]
+            assert data[0].length == 2
+            assert data[0][0] == groovy.transform.Sortable
+            assert data[0][1] instanceof Map
+            assert data[0][1].size() == 0
+            assert data[1][0] == groovy.transform.ToString
+            assert data[1][1] instanceof Map
+            assert data[1][1].size() == 1
+            assert data[1][1].excludes instanceof Object[]
+            assert data[1][1].excludes[0] == "a"
+        """
+
+        assertScript """
+            import groovy.transform.*
+            @Sortable
+            @ToString(excludes=["a"])
+            @AnnotationCollector(serializeClass = Alias)
+            class Alias {}
+
+            @Alias
+            class Foo {
+                Integer a, b
+            }
+            assert Foo.class.annotations.size() == 2
+            assert new Foo(a: 1, b: 2).toString() == "Foo(2)"
+
+            def data = Alias.value()
+            assert data.length == 2
+            assert data instanceof Object[][]
+            assert data[0].length == 2
+            assert data[0][0] == groovy.transform.Sortable
+            assert data[0][1] instanceof Map
+            assert data[0][1].size() == 0
+            assert data[1][0] == groovy.transform.ToString
+            assert data[1][1] instanceof Map
+            assert data[1][1].size() == 1
+            assert data[1][1].excludes instanceof Object[]
+            assert data[1][1].excludes[0] == "a"
+        """
+    }
+
+    void testAnnotationTakingAnnotationParams() {
+        assertScript """
+            import groovy.transform.*
+
+            @TheSuperGroovyHeroesL
+            class Team {}
+
+            assert Team.class.annotations.size() == 1
+            assert Team.class.annotations[0] instanceof GroovyCoreTeam
+            assert Team.class.annotations[0].value().size() == 4
+            assert Team.class.annotations[0].value().collect { it.value() } == ['Paul', 'Cedric', 'Jochen', 'Guillaume']
+
+            def data = TheSuperGroovyHeroesL.value()
+            assert data.length == 1
+            assert data instanceof Object[][]
+            assert data[0].length == 2
+            assert data[0][0] == groovy.transform.GroovyCoreTeam
+            assert data[0][1] instanceof Map
+            assert data[0][1].size() == 1
+            data = data[0][1].value
+            assert data.length == 4
+            assert data[0][0] == GroovyDeveloper
+            assert data[0][1].value == "Paul"
+            assert data[1][0] == GroovyDeveloper
+            assert data[1][1].value == "Cedric"
+            assert data[2][0] == GroovyDeveloper
+            assert data[2][1].value == "Jochen"
+            assert data[3][0] == GroovyDeveloper
+            assert data[3][1].value == "Guillaume"
+        """
+
+        assertScript """
+            import groovy.transform.*
+
+            @GroovyCoreTeam([
+                @GroovyDeveloper('Paul'),
+                @GroovyDeveloper('Cedric'),
+                @GroovyDeveloper('Jochen'),
+                @GroovyDeveloper('Guillaume')
+            ])
+            @AnnotationCollector(serializeClass = SuperHeroes)
+            @interface SuperHeroes {}
+
+            @SuperHeroes
+            class Team {}
+
+            assert Team.class.annotations.size() == 1
+            assert Team.class.annotations[0] instanceof GroovyCoreTeam
+            assert Team.class.annotations[0].value().size() == 4
+            assert Team.class.annotations[0].value().collect { it.value() } == ['Paul', 'Cedric', 'Jochen', 'Guillaume']
+
+            def data = SuperHeroes.value()
+            assert data.length == 1
+            assert data instanceof Object[][]
+            assert data[0].length == 2
+            assert data[0][0] == groovy.transform.GroovyCoreTeam
+            assert data[0][1] instanceof Map
+            assert data[0][1].size() == 1
+            data = data[0][1].value
+            assert data.length == 4
+            assert data[0][0] == GroovyDeveloper
+            assert data[0][1].value == "Paul"
+            assert data[1][0] == GroovyDeveloper
+            assert data[1][1].value == "Cedric"
+            assert data[2][0] == GroovyDeveloper
+            assert data[2][1].value == "Jochen"
+            assert data[3][0] == GroovyDeveloper
+            assert data[3][1].value == "Guillaume"
+        """
+    }
+
+    void testAnnotationCollectorModePreferCollector() {
+        assertScript """
+            import groovy.transform.*
+
+            @ToString(includeNames=true)
+            @AnnotationCollector(mode=AnnotationCollectorMode.PREFER_COLLECTOR)
+            @interface ToStringNames {}
+
+            @ToString(excludes='prop1')
+            @ToStringNames(excludes='prop2')
+            class Dummy1 { String prop1, prop2 }
+
+            @ToString(excludes='prop1')
+            @ToStringNames
+            class Dummy2 { String prop1, prop2 }
+
+            assert new Dummy1(prop1: 'hello', prop2: 'goodbye').toString() == 'Dummy1(prop1:hello)'
+            assert new Dummy2(prop1: 'hello', prop2: 'goodbye').toString() == 'Dummy2(prop1:hello, prop2:goodbye)'
+        """
+    }
+
+    void testAnnotationCollectorModePreferCollectorMerged() {
+        assertScript """
+            import groovy.transform.*
+
+            @ToString(includeNames=true)
+            @AnnotationCollector(mode=AnnotationCollectorMode.PREFER_COLLECTOR_MERGED)
+            @interface ToStringNames {}
+
+            @ToString(excludes='prop1')
+            @ToStringNames(excludes='prop2')
+            class Dummy1 { String prop1, prop2 }
+
+            @ToString(excludes='prop1')
+            @ToStringNames
+            class Dummy2 { String prop1, prop2 }
+
+            assert new Dummy1(prop1: 'hello', prop2: 'goodbye').toString() == 'Dummy1(prop1:hello)'
+            assert new Dummy2(prop1: 'hello', prop2: 'goodbye').toString() == 'Dummy2(prop2:goodbye)'
+        """
+    }
+
+    void testAnnotationCollectorModePreferCollectorExplicit() {
+        assertScript """
+            import groovy.transform.*
+
+            @ToString(includeNames=true)
+            @AnnotationCollector(mode=AnnotationCollectorMode.PREFER_EXPLICIT)
+            @interface ToStringNames {}
+
+            @ToString(excludes='prop1')
+            @ToStringNames(excludes='prop2')
+            class Dummy1 { String prop1, prop2 }
+
+            @ToString(excludes='prop1')
+            @ToStringNames
+            class Dummy2 { String prop1, prop2 }
+
+            assert new Dummy1(prop1: 'hello', prop2: 'goodbye').toString() == 'Dummy1(goodbye)'
+            assert new Dummy2(prop1: 'hello', prop2: 'goodbye').toString() == 'Dummy2(goodbye)'
+        """
+    }
+
+    void testAnnotationCollectorModePreferCollectorExplicitMerged() {
+        assertScript """
+            import groovy.transform.*
+
+            @ToString(includeNames=true)
+            @AnnotationCollector(mode=AnnotationCollectorMode.PREFER_EXPLICIT_MERGED)
+            @interface ToStringNames {}
+
+            @ToString(excludes='prop1')
+            @ToStringNames(excludes='prop2')
+            class Dummy1 { String prop1, prop2 }
+
+            @ToString(excludes='prop1')
+            @ToStringNames
+            class Dummy2 { String prop1, prop2 }
+
+            assert new Dummy1(prop1: 'hello', prop2: 'goodbye').toString() == 'Dummy1(prop2:goodbye)'
+            assert new Dummy2(prop1: 'hello', prop2: 'goodbye').toString() == 'Dummy2(prop2:goodbye)'
+        """
+    }
+}
+
+@AnnotationCollector(value = [ToString, EqualsAndHashCode, Sortable], serializeClass = PreCompiledAliasL)
+@interface PreCompiledAliasL {}
+
+@AnnotationCollector(value = [ConditionalInterrupt], serializeClass = OtherPreCompiledAliasL)
+@interface OtherPreCompiledAliasL {}
+
+@Sortable
+@ToString(excludes = ["a"])
+@AnnotationCollector(serializeClass = PreCompiledAlias3L)
+class PreCompiledAlias3L {}
+
+@GroovyCoreTeam([
+        @GroovyDeveloper('Paul'),
+        @GroovyDeveloper('Cedric'),
+        @GroovyDeveloper('Jochen'),
+        @GroovyDeveloper('Guillaume')
+])
+@AnnotationCollector(serializeClass = TheSuperGroovyHeroesL)
+@interface TheSuperGroovyHeroesL {}
diff --git a/src/test/groovy/transform/AnnotationCollectorTest.groovy b/src/test/groovy/transform/AnnotationCollectorTest.groovy
index 984c6fc607..25971b09a9 100644
--- a/src/test/groovy/transform/AnnotationCollectorTest.groovy
+++ b/src/test/groovy/transform/AnnotationCollectorTest.groovy
@@ -37,7 +37,7 @@ class AnnotationCollectorTest extends GroovyTestCase {
                 return []
             }
             def myex = aliasAnnotationUsage.getMembers().remove("myex")
-            if (myex) aliasAnnotationUsage.addMember("excludes", myex);
+            if (myex) aliasAnnotationUsage.addMember("excludes", myex)
             return super.visit(collector, aliasAnnotationUsage, aliasAnnotated, source)
         }
     }
@@ -58,21 +58,22 @@ class AnnotationCollectorTest extends GroovyTestCase {
     }
 
     void testSimpleUsage() {
-        assert PreCompiledAlias.value().length == 0
-        assert PreCompiledAlias.value() instanceof Object[][]
-        assertScript """
-            import groovy.transform.PreCompiledAlias 
+        def data = PreCompiledAlias.getAnnotation(AnnotationCollector).serializeClass().value()
+        assert data.length == 0
+        assert data instanceof Object[][]
+        assertScript '''
+            import groovy.transform.PreCompiledAlias
             @PreCompiledAlias
             class Foo {
                 Integer a, b
             }
             assert Foo.class.annotations.size() == 3
             assert new Foo(a: 1, b: 2).toString() == "Foo(1, 2)"
-            assert PreCompiledAlias.value().length == 0
-            assert PreCompiledAlias.value() instanceof Object[][]
-        """
+            assert PreCompiledAlias.CollectorHelper.value().length == 0
+            assert PreCompiledAlias.CollectorHelper.value() instanceof Object[][]
+        '''
 
-        assertScript """
+        assertScript '''
             import groovy.transform.*
             @AnnotationCollector([ToString, EqualsAndHashCode, Sortable])
             @interface NotPreCompiledAlias {}
@@ -83,13 +84,14 @@ class AnnotationCollectorTest extends GroovyTestCase {
             }
             assert Foo.class.annotations.size() == 3
             assert new Foo(a: 1, b: 2).toString() == "Foo(1, 2)"
-            assert NotPreCompiledAlias.value().length == 0
-            assert NotPreCompiledAlias.value() instanceof Object[][]
-        """
+            def data = NotPreCompiledAlias.getAnnotation(AnnotationCollector).serializeClass().value()
+            assert data.length == 0
+            assert data instanceof Object[][]
+        '''
     }
 
     void testUsageWithArgument() {
-        assertScript """
+        assertScript '''
             import groovy.transform.*
 
             @PreCompiledAlias(excludes=["a"])
@@ -98,11 +100,11 @@ class AnnotationCollectorTest extends GroovyTestCase {
             }
             assert Foo.class.annotations.size() == 3
             assert new Foo(a: 1, b: 2).toString() == "Foo(2)"
-            assert PreCompiledAlias.value().length == 0
-            assert PreCompiledAlias.value() instanceof Object[][]
-        """
+            assert PreCompiledAlias.CollectorHelper.value().length == 0
+            assert PreCompiledAlias.CollectorHelper.value() instanceof Object[][]
+        '''
 
-        assertScript """
+        assertScript '''
             import groovy.transform.*
             @AnnotationCollector([ToString, EqualsAndHashCode, Sortable])
             @interface NotPreCompiledAlias {}
@@ -113,13 +115,14 @@ class AnnotationCollectorTest extends GroovyTestCase {
             }
             assert Foo.class.annotations.size() == 3 
             assert new Foo(a: 1, b: 2).toString() == "Foo(2)"
-            assert NotPreCompiledAlias.value().length == 0
-            assert NotPreCompiledAlias.value() instanceof Object[][]
-        """
+            def data = NotPreCompiledAlias.getAnnotation(AnnotationCollector).serializeClass().value()
+            assert data.length == 0
+            assert data instanceof Object[][]
+        '''
     }
 
     void testClosureAnnotation() {
-        assertScript """
+        assertScript '''
             import groovy.transform.*
             @AnnotationCollector([ConditionalInterrupt])
             @interface NotPreCompiledAlias {}
@@ -138,10 +141,11 @@ class AnnotationCollectorTest extends GroovyTestCase {
             } catch (InterruptedException ie)  {
                 assert true
             }
-            assert NotPreCompiledAlias.value().length == 0
-            assert NotPreCompiledAlias.value() instanceof Object[][]
-        """
-        assertScript """
+            def data = NotPreCompiledAlias.getAnnotation(AnnotationCollector).serializeClass().value()
+            assert data.length == 0
+            assert data instanceof Object[][]
+        '''
+        assertScript '''
             import groovy.transform.*
     
             @OtherPreCompiledAlias(applyToAllClasses=false, value={ counter++> 10})
@@ -158,13 +162,13 @@ class AnnotationCollectorTest extends GroovyTestCase {
             } catch (InterruptedException ie)  {
                 assert true
             }
-            assert OtherPreCompiledAlias.value().length == 0
-            assert OtherPreCompiledAlias.value() instanceof Object[][]
-        """
+            assert OtherPreCompiledAlias.CollectorHelper.value().length == 0
+            assert OtherPreCompiledAlias.CollectorHelper.value() instanceof Object[][]
+        '''
     }
 
     void testAST() {
-        assertScript """
+        assertScript '''
             import groovy.transform.*
             @AnnotationCollector([ToString, EqualsAndHashCode, Sortable])
             @interface Alias {}
@@ -182,13 +186,14 @@ class AnnotationCollectorTest extends GroovyTestCase {
             }
             assert Foo.class.annotations.size() == 4
             assert new Foo(a: 1, b: 2).toString() == "Foo(2)"
-            assert Alias.value().length == 0
-            assert Alias.value() instanceof Object[][]
-        """
+            def data = Alias.getAnnotation(AnnotationCollector).serializeClass().value()
+            assert data.length == 0
+            assert data instanceof Object[][]
+        '''
     }
 
     void testConflictingAnnotations() {
-        shouldNotCompile """
+        shouldNotCompile '''
             import groovy.transform.*
             @interface ConflictingA {String foo()}
             @interface ConflictingB {int foo()}
@@ -197,16 +202,16 @@ class AnnotationCollectorTest extends GroovyTestCase {
             @interface Alias {}
 
             @Alias(foo="1") class X{}
-        """, { exception ->
+        ''', { exception ->
             exception.message.contains("line 9, column 24")
             exception.message.contains("Attribute 'foo' should have type 'java.lang.Integer'")
         }
     }
 
     void testCustomProcessor() {
-        assertScript """
+        assertScript '''
             import groovy.transform.*
-            @AnnotationCollector(value=[ToString, EqualsAndHashCode, Sortable], processor='groovy.transform.AnnotationCollectorTest\$MyProcessor')
+            @AnnotationCollector(value=[ToString, EqualsAndHashCode, Sortable], processor='groovy.transform.AnnotationCollectorTest$MyProcessor')
             @interface Alias {}
 
             @Alias(myex=["a"])
@@ -215,9 +220,10 @@ class AnnotationCollectorTest extends GroovyTestCase {
             }
             assert Foo.class.annotations.size() == 3
             assert new Foo(a: 1, b: 2).toString() == "Foo(2)"
-            assert Alias.value().length == 0
-            assert Alias.value() instanceof Object[][]
-        """
+            def data = Alias.getAnnotation(AnnotationCollector).serializeClass().value()
+            assert data.length == 0
+            assert data instanceof Object[][]
+        '''
     }
 
     void testProcessorThrowingCustomMessage() {
@@ -255,7 +261,7 @@ class AnnotationCollectorTest extends GroovyTestCase {
     }
 
     void testAnnotationOnAnnotation() {
-        assertScript """
+        assertScript '''
             import groovy.transform.*
 
             @PreCompiledAlias3
@@ -265,7 +271,7 @@ class AnnotationCollectorTest extends GroovyTestCase {
             assert Foo.class.annotations.size() == 2
             assert new Foo(a: 1, b: 2).toString() == "Foo(2)"
 
-            def data = PreCompiledAlias3.value()
+            def data = PreCompiledAlias3.CollectorHelper.value()
             assert data.length == 2
             assert data instanceof Object[][]
             assert data[0].length == 2
@@ -277,9 +283,9 @@ class AnnotationCollectorTest extends GroovyTestCase {
             assert data[1][1].size() == 1
             assert data[1][1].excludes instanceof Object[]
             assert data[1][1].excludes[0] == "a"
-        """
+        '''
 
-        assertScript """
+        assertScript '''
             import groovy.transform.*
             @Sortable
             @ToString(excludes=["a"])
@@ -293,7 +299,7 @@ class AnnotationCollectorTest extends GroovyTestCase {
             assert Foo.class.annotations.size() == 2
             assert new Foo(a: 1, b: 2).toString() == "Foo(2)"
 
-            def data = Alias.value()
+            def data = Alias.getAnnotation(AnnotationCollector).serializeClass().value()
             assert data.length == 2
             assert data instanceof Object[][]
             assert data[0].length == 2
@@ -305,11 +311,11 @@ class AnnotationCollectorTest extends GroovyTestCase {
             assert data[1][1].size() == 1
             assert data[1][1].excludes instanceof Object[]
             assert data[1][1].excludes[0] == "a"
-        """
+        '''
     }
 
     void testAnnotationTakingAnnotationParams() {
-        assertScript """
+        assertScript '''
             import groovy.transform.*
 
             @TheSuperGroovyHeroes
@@ -320,7 +326,7 @@ class AnnotationCollectorTest extends GroovyTestCase {
             assert Team.class.annotations[0].value().size() == 4
             assert Team.class.annotations[0].value().collect { it.value() } == ['Paul', 'Cedric', 'Jochen', 'Guillaume']
 
-            def data = TheSuperGroovyHeroes.value()
+            def data = TheSuperGroovyHeroes.CollectorHelper.value()
             assert data.length == 1
             assert data instanceof Object[][]
             assert data[0].length == 2
@@ -337,9 +343,9 @@ class AnnotationCollectorTest extends GroovyTestCase {
             assert data[2][1].value == "Jochen"
             assert data[3][0] == GroovyDeveloper
             assert data[3][1].value == "Guillaume"
-        """
+        '''
 
-        assertScript """
+        assertScript '''
             import groovy.transform.*
 
             @GroovyCoreTeam([
@@ -359,7 +365,7 @@ class AnnotationCollectorTest extends GroovyTestCase {
             assert Team.class.annotations[0].value().size() == 4
             assert Team.class.annotations[0].value().collect { it.value() } == ['Paul', 'Cedric', 'Jochen', 'Guillaume']
 
-            def data = SuperHeroes.value()
+            def data = SuperHeroes.getAnnotation(AnnotationCollector).serializeClass().value()
             assert data.length == 1
             assert data instanceof Object[][]
             assert data[0].length == 2
@@ -376,11 +382,11 @@ class AnnotationCollectorTest extends GroovyTestCase {
             assert data[2][1].value == "Jochen"
             assert data[3][0] == GroovyDeveloper
             assert data[3][1].value == "Guillaume"
-        """
+        '''
     }
 
     void testAnnotationCollectorModePreferCollector() {
-        assertScript """
+        assertScript '''
             import groovy.transform.*
 
             @ToString(includeNames=true)
@@ -397,11 +403,11 @@ class AnnotationCollectorTest extends GroovyTestCase {
 
             assert new Dummy1(prop1: 'hello', prop2: 'goodbye').toString() == 'Dummy1(prop1:hello)'
             assert new Dummy2(prop1: 'hello', prop2: 'goodbye').toString() == 'Dummy2(prop1:hello, prop2:goodbye)'
-        """
+        '''
     }
 
     void testAnnotationCollectorModePreferCollectorMerged() {
-        assertScript """
+        assertScript '''
             import groovy.transform.*
 
             @ToString(includeNames=true)
@@ -418,11 +424,11 @@ class AnnotationCollectorTest extends GroovyTestCase {
 
             assert new Dummy1(prop1: 'hello', prop2: 'goodbye').toString() == 'Dummy1(prop1:hello)'
             assert new Dummy2(prop1: 'hello', prop2: 'goodbye').toString() == 'Dummy2(prop2:goodbye)'
-        """
+        '''
     }
 
     void testAnnotationCollectorModePreferCollectorExplicit() {
-        assertScript """
+        assertScript '''
             import groovy.transform.*
 
             @ToString(includeNames=true)
@@ -439,11 +445,11 @@ class AnnotationCollectorTest extends GroovyTestCase {
 
             assert new Dummy1(prop1: 'hello', prop2: 'goodbye').toString() == 'Dummy1(goodbye)'
             assert new Dummy2(prop1: 'hello', prop2: 'goodbye').toString() == 'Dummy2(goodbye)'
-        """
+        '''
     }
 
     void testAnnotationCollectorModePreferCollectorExplicitMerged() {
-        assertScript """
+        assertScript '''
             import groovy.transform.*
 
             @ToString(includeNames=true)
@@ -460,7 +466,7 @@ class AnnotationCollectorTest extends GroovyTestCase {
 
             assert new Dummy1(prop1: 'hello', prop2: 'goodbye').toString() == 'Dummy1(prop2:goodbye)'
             assert new Dummy2(prop1: 'hello', prop2: 'goodbye').toString() == 'Dummy2(prop2:goodbye)'
-        """
+        '''
     }
 }
 
