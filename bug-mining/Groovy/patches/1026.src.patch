diff --git a/src/main/org/codehaus/groovy/runtime/metaclass/MemoryAwareConcurrentReadMap.java b/src/main/org/codehaus/groovy/runtime/metaclass/MemoryAwareConcurrentReadMap.java
index dab8213072..244e550e95 100644
--- a/src/main/org/codehaus/groovy/runtime/metaclass/MemoryAwareConcurrentReadMap.java
+++ b/src/main/org/codehaus/groovy/runtime/metaclass/MemoryAwareConcurrentReadMap.java
@@ -43,7 +43,7 @@ import java.lang.ref.SoftReference;
  * one of value or key are removed, so will be complete entry. This map
  * will not use the equals method to compare keys, think of it as a
  * IdentityHashMap with features of concurrency and memory aware caching.
- * As  ConcurrentReaderHashMap also does this implementation prefere read
+ * As  ConcurrentReaderHashMap also does this implementation prefer read
  * operations and tries not to lock if possible. SoftReferenced values
  * are only removed from the map if the map goes into a synchronization
  * block on this. This may affect reads, but only in rare cases.
@@ -551,7 +551,7 @@ public class MemoryAwareConcurrentReadMap {
 
                         Entry head = e.next;
                         for (Entry p = first; p != e; p = p.next) 
-                            head = new Entry(p.hash, p.key, p.value, head, queue);
+                            head = new Entry(p.hash, p.key, p.value, head);
 
                         tab[index] = head;
                         recordModification(head);
diff --git a/src/test/org/codehaus/groovy/runtime/MemoryAwareConcurrentReadMapTest.groovy b/src/test/org/codehaus/groovy/runtime/MemoryAwareConcurrentReadMapTest.groovy
new file mode 100644
index 0000000000..66c1a674b0
--- /dev/null
+++ b/src/test/org/codehaus/groovy/runtime/MemoryAwareConcurrentReadMapTest.groovy
@@ -0,0 +1,48 @@
+package org.codehaus.groovy.runtime
+
+import org.codehaus.groovy.runtime.metaclass.*
+
+class MemoryAwareConcurrentReadMapTest extends GroovyTestCase {
+
+    void testRemove() {
+        def map = new MemoryAwareConcurrentReadMap(4, 100)
+        def keys = [new MapCollisionKey(),new MapCollisionKey(),new MapCollisionKey()]
+        def values = []
+        keys.eachWithIndex {it,i-> 
+          map.put(it,i)
+          values << i
+        }
+        
+        assert map.size() == 3
+        
+        map.remove(keys[1])
+        assert map.get(keys[0]) == 0
+        assert map.get(keys[1]) == null
+        assert map.get(keys[2]) == 2  
+        assert map.size() == 2
+        
+        map.remove(keys[1])
+        assert map.get(keys[0]) == 0
+        assert map.get(keys[1]) == null
+        assert map.get(keys[2]) == 2  
+        assert map.size() == 2
+        
+        map.remove(keys[0])
+        assert map.get(keys[0]) == null
+        assert map.get(keys[1]) == null
+        assert map.get(keys[2]) == 2  
+        assert map.size() == 1
+        
+        map.remove(keys[2])
+        assert map.get(keys[0]) == null
+        assert map.get(keys[1]) == null
+        assert map.get(keys[2]) == null
+        assert map.size() == 0
+       
+    }
+}
+
+class MapCollisionKey {
+    // equals only if identitiy, hashcode always the same
+    int hashCode(){1}
+}
\ No newline at end of file
