diff --git a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
index b33510ce63..acb7c40807 100644
--- a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
+++ b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
@@ -34,9 +34,7 @@ import java.lang.reflect.Modifier;
 import java.util.*;
 
 import static org.codehaus.groovy.ast.ClassHelper.*;
-import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.chooseBestMethod;
-import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.findDGMMethodsByNameAndArguments;
-import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.implementsInterfaceOrIsSubclassOf;
+import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.*;
 
 /**
  * A call site writer which replaces call site caching with static calls. This means that the generated code
@@ -93,9 +91,7 @@ public class StaticTypesCallSiteWriter extends CallSiteWriter implements Opcodes
             receiverType = (ClassNode) type;
         }
         boolean isClassReceiver = false;
-        if (receiverType.equals(CLASS_Type)
-                && receiverType.getGenericsTypes()!=null
-                && !receiverType.getGenericsTypes()[0].isPlaceholder()) {
+        if (isClassClassNodeWrappingConcreteType(receiverType)) {
             isClassReceiver = true;
             receiverType = receiverType.getGenericsTypes()[0].getType();
         }
diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
index 407de927fa..f67c5369d4 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
@@ -1748,4 +1748,21 @@ public abstract class StaticTypeCheckingSupport {
         out.addAll(allInterfaces);
         collectAllInterfaces(node.getSuperClass(), out);
     }
+
+    /**
+     * Returns true if the class node represents a the class node for the Class class
+     * and if the parametrized type is a neither a placeholder or a wildcard. For example,
+     * the class node Class&lt;Foo&gt; where Foo is a class would return true, but the class
+     * node for Class&lt;?&gt; would return false.
+     * @param classNode a class node to be tested
+     * @return true if it is the class node for Class and its generic type is a real class
+     */
+    public static boolean isClassClassNodeWrappingConcreteType(ClassNode classNode) {
+        GenericsType[] genericsTypes = classNode.getGenericsTypes();
+        return ClassHelper.CLASS_Type.equals(classNode)
+                && classNode.isUsingGenerics()
+                && genericsTypes!=null
+                && !genericsTypes[0].isPlaceholder()
+                && !genericsTypes[0].isWildcard();
+    }
 }
diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index cdbbf8444a..930910f669 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -919,7 +919,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         Expression objectExpression = pexp.getObjectExpression();
         final ClassNode objectExpressionType = getType(objectExpression);
 
-        boolean staticOnlyAccess = objectExpressionType.equals(CLASS_Type);
+        boolean staticOnlyAccess = isClassClassNodeWrappingConcreteType(objectExpressionType);
         if (objectExpressionType.isArray() && "length".equals(pexp.getPropertyAsString())) {
             storeType(pexp, int_TYPE);
             if (visitor != null) {
@@ -955,7 +955,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                     // as well, since in case of a static property access we have the class
                     // itself in the list of receivers already;
                     boolean staticOnly;
-                    if (current.equals(CLASS_Type)) {
+                    if (isClassClassNodeWrappingConcreteType(current)) {
                         staticOnly = false;
                     } else {
                         staticOnly = staticOnlyAccess;
@@ -2587,7 +2587,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         final ClassNode receiver = getType(objectExpression);
         List<Receiver<String>> owners = new LinkedList<Receiver<String>>();
         owners.add(Receiver.<String>make(receiver));
-        if (receiver.equals(CLASS_Type) && receiver.getGenericsTypes() != null) {
+        if (isClassClassNodeWrappingConcreteType(receiver)) {
             GenericsType clazzGT = receiver.getGenericsTypes()[0];
             owners.add(0,Receiver.<String>make(clazzGT.getType()));
         }
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy6533Bug.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy6533Bug.groovy
new file mode 100644
index 0000000000..cf6d198cf9
--- /dev/null
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy6533Bug.groovy
@@ -0,0 +1,67 @@
+/*
+ * Copyright 2003-2014 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.codehaus.groovy.classgen.asm.sc.bugs
+
+import groovy.transform.stc.StaticTypeCheckingTestCase
+import org.codehaus.groovy.classgen.asm.sc.StaticCompilationTestSupport
+
+@Mixin(StaticCompilationTestSupport)
+class Groovy6533Bug extends StaticTypeCheckingTestCase {
+    @Override
+    protected void setUp() {
+        super.setUp()
+        extraSetup()
+    }
+
+     void testSelectedMethodShouldBeTheSameWithAndWithoutWildcard() {
+         assertScript '''
+class ShowMcStatic {
+    MetaClass findMc(Class someClass) {
+        def mc = someClass.metaClass
+        mc
+    }
+    MetaClass findMcWithGenericsParam(Class<?> someClass) {
+        def mc = someClass.metaClass
+        mc
+    }
+}
+
+def mcByStatic = new ShowMcStatic().findMc(String)
+def mcByStatic2 = new ShowMcStatic().findMcWithGenericsParam(String)
+assert mcByStatic.theClass==String
+assert mcByStatic2.theClass==String'''
+     }
+
+     void testSelectedMethodShouldBeTheSameWithAndWithoutWildcardUsingMethodCall() {
+         assertScript '''
+class ShowMcStatic {
+    MetaClass findMc(Class someClass) {
+        def mc = someClass.getMetaClass()
+        mc
+    }
+    MetaClass findMcWithGenericsParam(Class<?> someClass) {
+        def mc = someClass.getMetaClass()
+        mc
+    }
+}
+
+def mcByStatic = new ShowMcStatic().findMc(String)
+def mcByStatic2 = new ShowMcStatic().findMcWithGenericsParam(String)
+assert mcByStatic.theClass==String
+assert mcByStatic2.theClass==String'''
+     }
+}
