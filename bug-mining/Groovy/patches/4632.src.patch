diff --git a/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesWriterController.java b/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesWriterController.java
index b05dbe2386..5a7e216c77 100644
--- a/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesWriterController.java
+++ b/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesWriterController.java
@@ -18,8 +18,6 @@
  */
 package org.codehaus.groovy.classgen.asm.sc;
 
-import org.codehaus.groovy.ast.AnnotatedNode;
-import org.codehaus.groovy.ast.ClassHelper;
 import org.codehaus.groovy.ast.ClassNode;
 import org.codehaus.groovy.ast.ConstructorNode;
 import org.codehaus.groovy.ast.MethodNode;
@@ -39,11 +37,11 @@ import org.codehaus.groovy.classgen.asm.UnaryExpressionHelper;
 import org.codehaus.groovy.classgen.asm.WriterController;
 import org.codehaus.groovy.classgen.asm.indy.sc.IndyStaticTypesMultiTypeDispatcher;
 import org.codehaus.groovy.control.CompilerConfiguration;
-import org.codehaus.groovy.transform.sc.StaticCompilationMetadataKeys;
-import org.codehaus.groovy.transform.sc.StaticCompilationVisitor;
 import org.codehaus.groovy.transform.stc.StaticTypesMarker;
 import org.objectweb.asm.ClassVisitor;
 
+import static org.codehaus.groovy.transform.sc.StaticCompilationVisitor.isStaticallyCompiled;
+
 /**
  * An alternative {@link org.codehaus.groovy.classgen.asm.WriterController} which handles static types and method
  * dispatch. In case of a "mixed mode" where only some methods are annotated with {@link groovy.transform.TypeChecked}
@@ -87,24 +85,13 @@ public class StaticTypesWriterController extends DelegatingController {
 
     @Override
     public void setMethodNode(final MethodNode mn) {
-        updateStaticCompileFlag(mn);
+        isInStaticallyCheckedMethod = isStaticallyCompiled(mn);
         super.setMethodNode(mn);
     }
 
-    private void updateStaticCompileFlag(final MethodNode mn) {
-        AnnotatedNode outer = mn;
-        ClassNode classNode = getClassNode();
-        boolean inClosureOrLambda = ClassHelper.isGeneratedFunction(classNode);
-        if (inClosureOrLambda) {
-            outer = classNode.getOuterClass();
-        }
-        boolean isStaticCompileNode = Boolean.TRUE.equals(classNode.getNodeMetaData(StaticCompilationMetadataKeys.STATIC_COMPILE_NODE));
-        isInStaticallyCheckedMethod = mn != null && (StaticCompilationVisitor.isStaticallyCompiled(outer) || inClosureOrLambda && isStaticCompileNode);
-    }
-
     @Override
     public void setConstructorNode(final ConstructorNode cn) {
-        updateStaticCompileFlag(cn);
+        isInStaticallyCheckedMethod = isStaticallyCompiled(cn);
         super.setConstructorNode(cn);
     }
 
diff --git a/src/test/groovy/transform/stc/MethodReferenceTest.groovy b/src/test/groovy/transform/stc/MethodReferenceTest.groovy
index ad5a5c5914..0b62f5cbec 100644
--- a/src/test/groovy/transform/stc/MethodReferenceTest.groovy
+++ b/src/test/groovy/transform/stc/MethodReferenceTest.groovy
@@ -684,6 +684,28 @@ final class MethodReferenceTest {
         assert err =~ /Cannot find matching constructor Bar\(java.lang.String\)/
     }
 
+    @Test // class::new -- GROOVY-11001
+    void testFunctionCN6() {
+        assertScript shell, '''
+            @Grab('io.vavr:vavr:0.10.4')
+            import io.vavr.control.Try
+
+            class StringInputStream {
+                StringInputStream(String s) {
+                }
+            }
+
+            @CompileStatic
+            void test() {
+                Try.success('string').flatMap { // <U> Try<U> flatMap(Function<? super T,? extends Try<? extends U>> mapper)
+                    Try.success(it).map(StringInputStream::new)
+                }
+            }
+
+            test()
+        '''
+    }
+
     @Test // arrayClass::new
     void testIntFunctionCN() {
         assertScript shell, '''
