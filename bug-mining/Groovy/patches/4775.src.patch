diff --git a/src/main/java/org/codehaus/groovy/ast/ClassNode.java b/src/main/java/org/codehaus/groovy/ast/ClassNode.java
index 0b726ef719..4f7b167cf9 100644
--- a/src/main/java/org/codehaus/groovy/ast/ClassNode.java
+++ b/src/main/java/org/codehaus/groovy/ast/ClassNode.java
@@ -933,6 +933,11 @@ public class ClassNode extends AnnotatedNode {
         if (ClassHelper.isObjectType(type)) {
             return true;
         }
+        if (this.isArray() && type.isArray()
+                && ClassHelper.isObjectType(type.getComponentType())
+                && !ClassHelper.isPrimitiveType(this.getComponentType())) {
+            return true;
+        }
         for (ClassNode node = this; node != null; node = node.getSuperClass()) {
             if (type.equals(node)) {
                 return true;
diff --git a/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java b/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
index f14b2dc077..c14097fb2f 100644
--- a/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
+++ b/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
@@ -60,7 +60,6 @@ import org.apache.groovy.util.SystemUtil;
 import org.codehaus.groovy.classgen.Verifier;
 import org.codehaus.groovy.reflection.ClassInfo;
 import org.codehaus.groovy.reflection.MixinInMetaClass;
-import org.codehaus.groovy.reflection.ReflectionCache;
 import org.codehaus.groovy.reflection.ReflectionUtils;
 import org.codehaus.groovy.reflection.stdclasses.CachedSAMClass;
 import org.codehaus.groovy.runtime.callsite.BooleanClosureForMapPredicate;
@@ -14525,12 +14524,18 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      * @since 1.8.1
      */
     public static <T> Collection<T> unique(Collection<T> self, boolean mutate) {
-        List<T> answer = uniqueItems(self);
+        Collection<T> answer = null;
+        if (mutate || (self != null && self.size() > 1)) {
+            answer = uniqueItems(self);
+        }
         if (mutate) {
             self.clear();
             self.addAll(answer);
+
+            return self;
+        } else {
+            return answer;
         }
-        return mutate ? self : answer ;
     }
 
     /**
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index ee93f90787..d091f9c60f 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -2262,7 +2262,14 @@ out:    if ((samParameterTypes.length == 1 && isOrImplements(samParameterTypes[0
     public void visitExpressionStatement(final ExpressionStatement statement) {
         typeCheckingContext.pushTemporaryTypeInfo();
         super.visitExpressionStatement(statement);
-        typeCheckingContext.popTemporaryTypeInfo();
+        Map<?,List<ClassNode>> tti = typeCheckingContext.temporaryIfBranchTypeInformation.pop();
+        if (!tti.isEmpty() && !typeCheckingContext.temporaryIfBranchTypeInformation.isEmpty()) {
+            tti.forEach((k, tempTypes) -> {
+                if (tempTypes.contains(VOID_TYPE))
+                    typeCheckingContext.temporaryIfBranchTypeInformation.peek()
+                        .computeIfAbsent(k, x -> new LinkedList<>()).add(VOID_TYPE);
+            });
+        }
     }
 
     @Override
@@ -4438,11 +4445,9 @@ out:                if (mn.size() != 1) {
                 List<ClassNode> assignedTypes = typeCheckingContext.closureSharedVariablesAssignmentTypes.computeIfAbsent(var, k -> new LinkedList<>());
                 assignedTypes.add(cn);
             }
-            List<ClassNode> temporaryTypesForExpression = getTemporaryTypesForExpression(var);
-            if (temporaryTypesForExpression != null) {
-                // a type inference has been made on a variable whose type was defined in an instanceof block
-                // erase available information with the new type
-                temporaryTypesForExpression.clear();
+            if (!var.isThisExpression() && !var.isSuperExpression() && !typeCheckingContext.temporaryIfBranchTypeInformation.isEmpty()) {
+                // GROOVY-5226, GROOVY-11290: assignment voids instanceof
+                pushInstanceOfTypeInfo(var, classX(VOID_TYPE));
             }
         }
     }
@@ -5986,50 +5991,73 @@ out:                if (mn.size() != 1) {
      * is not found. The returned type class depends on whether we have temporary type information available (due to
      * instanceof checks) and whether there is a single candidate in that case.
      *
-     * @param expr the expression for which an unknown field has been found
+     * @param expression the expression for which an unknown field has been found
      * @param type the type of the expression (used as fallback type)
      * @return if temporary information is available and there's only one type, returns the temporary type class
      * otherwise falls back to the provided type class.
      */
-    protected ClassNode findCurrentInstanceOfClass(final Expression expr, final ClassNode type) {
-        if (!typeCheckingContext.temporaryIfBranchTypeInformation.isEmpty()) {
-            List<ClassNode> types = getTemporaryTypesForExpression(expr);
-            if (types != null && types.size() == 1) return types.get(0);
-        }
+    protected ClassNode findCurrentInstanceOfClass(final Expression expression, final ClassNode type) {
+        List<ClassNode> tempTypes = getTemporaryTypesForExpression(expression);
+        if (tempTypes.size() == 1) return tempTypes.get(0);
         return type;
     }
 
     protected List<ClassNode> getTemporaryTypesForExpression(final Expression expression) {
-        List<ClassNode> types = null;
-        int depth = typeCheckingContext.temporaryIfBranchTypeInformation.size();
-        while (types == null && depth > 0) {
-            Map<Object, List<ClassNode>> tempo = typeCheckingContext.temporaryIfBranchTypeInformation.get(--depth);
-            if (!tempo.isEmpty()) {
-                Object key = expression instanceof ParameterVariableExpression
-                        ? ((ParameterVariableExpression) expression).parameter
-                        : extractTemporaryTypeInfoKey(expression);
-                types = tempo.get(key);
-            }
+        Object key = extractTemporaryTypeInfoKey(expression);
+        List<ClassNode> tempTypes = typeCheckingContext.temporaryIfBranchTypeInformation.stream().flatMap(tti ->
+            tti.getOrDefault(key, Collections.emptyList()).stream()
+        ).collect(Collectors.toList());
+        int i = tempTypes.lastIndexOf(VOID_TYPE);
+        if (i != -1) { // assignment overwrites instanceof
+            tempTypes = tempTypes.subList(i + 1, tempTypes.size());
         }
-        return types;
+        return DefaultGroovyMethods.unique(tempTypes); // GROOVY-6429
     }
 
     private ClassNode getInferredTypeFromTempInfo(final Expression expression, final ClassNode expressionType) {
-        if (expression instanceof VariableExpression && !typeCheckingContext.temporaryIfBranchTypeInformation.isEmpty()) {
+        if (expression instanceof VariableExpression) {
             List<ClassNode> tempTypes = getTemporaryTypesForExpression(expression);
-            if (tempTypes != null && !tempTypes.isEmpty()) {
-                Set<ClassNode> types = new LinkedHashSet<>(tempTypes.size() + 1);
-                if (expressionType != null && !isObjectType(expressionType) // GROOVY-7333
-                        && tempTypes.stream().noneMatch(t -> implementsInterfaceOrIsSubclassOf(t, expressionType))) { // GROOVY-9769
-                    types.add(expressionType);
-                }
-                types.addAll(tempTypes);
-
-                if (types.isEmpty()) {
-                    return OBJECT_TYPE;
-                } else if (types.size() == 1) {
-                    return types.iterator().next();
+            if (!tempTypes.isEmpty()) {
+                ClassNode   superclass;
+                ClassNode[] interfaces;
+                if (expressionType instanceof WideningCategories.LowestUpperBoundClassNode) {
+                    superclass = expressionType.getSuperClass();
+                    interfaces = expressionType.getInterfaces();
+                } else if (expressionType != null && expressionType.isInterface()) {
+                    superclass = OBJECT_TYPE;
+                    interfaces = new ClassNode[]{expressionType};
                 } else {
+                    superclass = expressionType;
+                    interfaces = ClassNode.EMPTY_ARRAY;
+                }
+
+                List<ClassNode> types = new ArrayList<>();
+                if (superclass != null && !superclass.equals(OBJECT_TYPE) // GROOVY-7333
+                        && tempTypes.stream().noneMatch(t -> !t.equals(superclass) && t.isDerivedFrom(superclass))) { // GROOVY-9769
+                    types.add(superclass);
+                }
+                for (ClassNode anInterface : interfaces) {
+                    if (tempTypes.stream().noneMatch(t -> t.implementsInterface(anInterface))) { // GROOVY-9769
+                        types.add(anInterface);
+                    }
+                }
+                int tempTypesCount = tempTypes.size();
+                if (tempTypesCount == 1 && types.isEmpty()) {
+                    types.add(tempTypes.get(0));
+                } else for (ClassNode tempType : tempTypes) {
+                    if (!tempType.isInterface() // GROOVY-11290: keep most-specific types
+                            ? (superclass == null || !superclass.isDerivedFrom(tempType))
+                                    && (tempTypesCount == 1 || tempTypes.stream().noneMatch(t -> !t.equals(tempType) && t.isDerivedFrom(tempType)))
+                            : (expressionType == null || !isOrImplements(expressionType, tempType))
+                                    && (tempTypesCount == 1 || tempTypes.stream().noneMatch(t -> t != tempType && t.implementsInterface(tempType)))) {
+                        types.add(tempType);
+                    }
+                }
+
+                int typesCount = types.size();
+                if (typesCount == 1) {
+                    return types.get(0);
+                } else if (typesCount > 1) {
                     return new UnionTypeClassNode(types.toArray(ClassNode.EMPTY_ARRAY));
                 }
             }
diff --git a/src/test/groovy/transform/stc/MethodCallsSTCTest.groovy b/src/test/groovy/transform/stc/MethodCallsSTCTest.groovy
index 06575bdf5a..c5876589cd 100644
--- a/src/test/groovy/transform/stc/MethodCallsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/MethodCallsSTCTest.groovy
@@ -827,42 +827,78 @@ class MethodCallsSTCTest extends StaticTypeCheckingTestCase {
         '''
     }
 
+    // GROOVY-5226, GROOVY-11290
     void testShouldFailBecauseVariableIsReassigned() {
-        shouldFailWithMessages '''
-            static String foo(String s) {
-                'String'
-            }
+        String foo = 'def foo(CharSequence cs) { }'
+
+        shouldFailWithMessages foo + '''
             def it
             if (it instanceof String) {
                 it = new Date()
                 foo(it)
             }
         ''',
-        'foo(java.util.Date)'
+        'Cannot find matching method','#foo(java.util.Date)'
+
+        shouldFailWithMessages foo + '''
+            def bar(CharSequence cs) { }
+            def it
+            if (it instanceof CharSequence) {
+                if (it instanceof String) {
+                    it = new Date()
+                    foo(it)
+                }
+                bar(it) // it is CharSequence or Date
+            }
+        ''',
+        'Cannot find matching method','#foo(java.util.Date)',
+        'Cannot find matching method','#bar(java.util.Date)'
     }
 
+    // GROOVY-5226, GROOVY-11290
     void testShouldNotFailEvenIfVariableIsReassigned() {
-        assertScript '''
-            static String foo(int val) {
-                'int'
-            }
-            def it
+        String foobar = 'def foo(int i) { }\ndef bar(CharSequence cs) { }'
+
+        assertScript foobar + '''
+            def it = ""
             if (it instanceof String) {
+                bar(it)
                 it = 123
                 foo(it)
             }
         '''
-    }
 
-    void testShouldNotFailEvenIfVariableIsReassignedAndInstanceOfIsEmbed() {
-        assertScript '''
-            static String foo(int val) {
-                'int'
+        assertScript foobar + '''
+            def it = ""
+            if (it instanceof CharSequence) {
+                bar(it)
+                if (it instanceof String) {
+                    bar(it)
+                    it = 123
+                    foo(it)
+                } else {
+                    bar(it)
+                }
             }
-            static String foo(Date val) {
-                'Date'
+        '''
+
+        assertScript foobar + '''
+            def it = ~/regexp/
+            if (it !instanceof String) {
+                it = 123
+                foo(it)
+            } else {
+                bar(it)
             }
-            def it
+        '''
+    }
+
+    // GROOVY-5226, GROOVY-11290
+    void testShouldNotFailEvenIfVariableIsReassignedAndMultipleInstanceOf() {
+        assertScript '''
+            def foo(int i) { 'int' }
+            def foo(Date d) { 'Date' }
+            def it = ""
             if (it instanceof String) {
                 it = 123
                 foo(it)
diff --git a/src/test/groovy/transform/stc/TypeInferenceSTCTest.groovy b/src/test/groovy/transform/stc/TypeInferenceSTCTest.groovy
index bd8e467d7e..2d57ff3427 100644
--- a/src/test/groovy/transform/stc/TypeInferenceSTCTest.groovy
+++ b/src/test/groovy/transform/stc/TypeInferenceSTCTest.groovy
@@ -242,7 +242,8 @@ class TypeInferenceSTCTest extends StaticTypeCheckingTestCase {
         '''
     }
 
-    @NotYetImplemented // GROOVY-10096
+    // GROOVY-10096
+    @NotYetImplemented
     void testInstanceOf10() {
         shouldFailWithMessages '''
             class Foo {
@@ -282,9 +283,24 @@ class TypeInferenceSTCTest extends StaticTypeCheckingTestCase {
         '''
     }
 
+    // GROOVY-11290
+    void testInstanceOf12() {
+        assertScript '''
+            def test(List<String> list) {
+                if (list instanceof List) {
+                    (list*.toLowerCase()).join()
+                }
+            }
+
+            String result = test(['foo', 'bar'])
+            assert result == 'foobar'
+        '''
+    }
+
+    // GROOVY-5226
     void testNestedInstanceOf1() {
         assertScript '''
-            Object o
+            Object o = "foo"
             if (o instanceof Object) {
                 if (o instanceof String) {
                     o.toUpperCase()
@@ -293,19 +309,42 @@ class TypeInferenceSTCTest extends StaticTypeCheckingTestCase {
         '''
     }
 
+    // GROOVY-5226
     void testNestedInstanceOf2() {
-        shouldFailWithMessages '''
-            Object o
+        assertScript '''
+            Object o = "foo"
             if (o instanceof String) {
-                if (o instanceof Object) { // causes the inferred type of 'o' to be overwritten
+                if (o instanceof Object) {
                     o.toUpperCase()
                 }
             }
-        ''',
-        'Cannot find matching method java.lang.Object#toUpperCase()'
+        '''
     }
 
+    // GROOVY-11290
     void testNestedInstanceOf3() {
+        assertScript '''
+            Object o = null
+            if (o instanceof Closeable) {
+                if (o instanceof Cloneable) {
+                    o.close()
+                }
+            }
+        '''
+    }
+
+    void testNestedInstanceOf4() {
+        assertScript '''
+            Object o = [1,2] as Number[]
+            if (o instanceof Object[]) {
+                if (o instanceof Number[]) {
+                    o[0].intValue()
+                }
+            }
+        '''
+    }
+
+    void testNestedInstanceOf5() {
         assertScript '''
             class A {
                int foo() { 1 }
@@ -313,8 +352,16 @@ class TypeInferenceSTCTest extends StaticTypeCheckingTestCase {
             class B {
                int foo2() { 2 }
             }
+
             def o = new A()
             int result = o instanceof A ? o.foo() : (o instanceof B ? o.foo2() : 3)
+            assert result == 1
+            o = new B()
+            result = o instanceof A ? o.foo() : (o instanceof B ? o.foo2() : 3)
+            assert result == 2
+            o = new Object()
+            result = o instanceof A ? o.foo() : (o instanceof B ? o.foo2() : 3)
+            assert result == 3
         '''
     }
 
