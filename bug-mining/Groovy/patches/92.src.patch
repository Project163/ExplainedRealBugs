diff --git a/src/main/org/codehaus/groovy/ast/VariableScope.java b/src/main/org/codehaus/groovy/ast/VariableScope.java
index 7e7a604e05..8bca23875f 100644
--- a/src/main/org/codehaus/groovy/ast/VariableScope.java
+++ b/src/main/org/codehaus/groovy/ast/VariableScope.java
@@ -54,7 +54,7 @@ import java.util.Set;
 /**
  * Represents a variable scope. This is primarily used to determine variable sharing
  * across method and closure boundaries.
- * 
+ *
  * @author <a href="mailto:james@coredevelopers.net">James Strachan</a>
  * @version $Revision$
  */
@@ -80,7 +80,7 @@ public class VariableScope  {
     public Set getReferencedVariables() {
         return referencedVariables;
     }
- 
+
     /**
      * @return all the child scopes
      */
@@ -91,7 +91,7 @@ public class VariableScope  {
     /**
      * Creates a composite variable scope combining all the variable references
      * and declarations from all the child scopes not including this scope
-     * 
+     *
      * @return
      */
     public VariableScope createCompositeChildScope() {
@@ -105,7 +105,7 @@ public class VariableScope  {
 
     /**
      * Creates a scope including this scope and all nested scopes combined together
-     * 
+     *
      * @return
      */
     public VariableScope createRecursiveChildScope() {
@@ -117,13 +117,13 @@ public class VariableScope  {
 
     /**
      * Creates a scope including this scope and all parent scopes combined together
-     * 
+     *
      * @return
      */
     public VariableScope createRecursiveParentScope() {
         VariableScope answer = new VariableScope();
         VariableScope node = this;
-        do { 
+        do {
             answer.append(node);
             node = node.parent;
         }
@@ -134,23 +134,23 @@ public class VariableScope  {
     /**
      * Appends all of the references and declarations from the given scope
      * to this one
-     * 
+     *
      * @param scope
      */
     protected void append(VariableScope scope) {
         referencedVariables.addAll(scope.referencedVariables);
         declaredVariables.addAll(scope.declaredVariables);
     }
-    
+
     /**
      * Appends all of the references and declarations from the given scope
      * and all its children to this one
-     * 
+     *
      * @param scope
      */
     protected void appendRecursive(VariableScope scope) {
         append(scope);
-        
+
         // now lets traverse the children
         for (Iterator iter = scope.children.iterator(); iter.hasNext(); ) {
             appendRecursive((VariableScope) iter.next());
diff --git a/src/main/org/codehaus/groovy/ast/expr/BinaryExpression.java b/src/main/org/codehaus/groovy/ast/expr/BinaryExpression.java
index 5f4369af01..2cb52bed4e 100644
--- a/src/main/org/codehaus/groovy/ast/expr/BinaryExpression.java
+++ b/src/main/org/codehaus/groovy/ast/expr/BinaryExpression.java
@@ -45,6 +45,7 @@
  */
 package org.codehaus.groovy.ast.expr;
 
+import org.codehaus.groovy.ast.Type;
 import org.codehaus.groovy.ast.GroovyCodeVisitor;
 import org.codehaus.groovy.syntax.Types;
 import org.codehaus.groovy.syntax.Token;
@@ -107,5 +108,37 @@ public class BinaryExpression extends Expression {
         }
         return "(" + leftExpression.getText() + " " + operation.getText() + " " + rightExpression.getText() + ")";
     }
+    
+    
+   /**
+    *  Creates an assignment expression in which the specified expression
+    *  is written into the specified variable name.   
+    */
+    
+    public static BinaryExpression newAssignmentExpression( String variable, Expression rhs ) {
+    	VariableExpression lhs = new VariableExpression( variable );
+    	Token         operator = Token.newPlaceholder( Types.ASSIGN );
+    
+    	return new BinaryExpression( lhs, operator, rhs );
+    }
+
+
+    /**
+     *  Creates variable initialization expression in which the specified expression
+     *  is written into the specified variable name.   
+     */
+     
+     public static BinaryExpression newInitializationExpression( String variable, Type type, Expression rhs ) {
+     	VariableExpression lhs = new VariableExpression( variable );
+     
+     	if( type != null ) {
+     	    lhs.setType( type.getName() );
+     	}
+     
+     	Token operator = Token.newPlaceholder( Types.ASSIGN );
+     
+        return new BinaryExpression( lhs, operator, rhs );
+     }
+
 
 }
diff --git a/src/main/org/codehaus/groovy/ast/expr/VariableExpression.java b/src/main/org/codehaus/groovy/ast/expr/VariableExpression.java
index 052eaf93c1..bb02658b4c 100644
--- a/src/main/org/codehaus/groovy/ast/expr/VariableExpression.java
+++ b/src/main/org/codehaus/groovy/ast/expr/VariableExpression.java
@@ -47,6 +47,7 @@ package org.codehaus.groovy.ast.expr;
 
 import org.codehaus.groovy.ast.GroovyCodeVisitor;
 
+
 /**
  * Represents a local variable name, the simplest form of expression. e.g. "foo".
  * 
@@ -101,4 +102,6 @@ public class VariableExpression extends Expression {
     public String toString() {
         return super.toString() + "[variable: " + variable + ((isDynamic()) ? "" : " type: " + type) + "]";
     }
+    
+    
 }
diff --git a/src/main/org/codehaus/groovy/classgen/ClassGenerator.java b/src/main/org/codehaus/groovy/classgen/ClassGenerator.java
index 96c69e54fd..7ccbf13724 100644
--- a/src/main/org/codehaus/groovy/classgen/ClassGenerator.java
+++ b/src/main/org/codehaus/groovy/classgen/ClassGenerator.java
@@ -1,8 +1,8 @@
 /*
  * $Id$
- * 
+ *
  * Copyright 2003 (C) James Strachan and Bob Mcwhirter. All Rights Reserved.
- * 
+ *
  * Redistribution and use of this software and associated documentation
  * ("Software"), with or without modification, are permitted provided that the
  * following conditions are met: 1. Redistributions of source code must retain
@@ -17,7 +17,7 @@
  * their names without prior written permission of The Codehaus. "groovy" is a
  * registered trademark of The Codehaus. 5. Due credit should be given to The
  * Codehaus - http://groovy.codehaus.org/
- * 
+ *
  * THIS SOFTWARE IS PROVIDED BY THE CODEHAUS AND CONTRIBUTORS ``AS IS'' AND ANY
  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
@@ -29,7 +29,7 @@
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
  * DAMAGE.
- *  
+ *
  */
 package org.codehaus.groovy.classgen;
 
@@ -121,7 +121,7 @@ import org.objectweb.asm.Label;
 
 /**
  * Generates Java class versions of Groovy classes
- * 
+ *
  * @author <a href="mailto:james@coredevelopers.net">James Strachan</a>
  * @version $Revision$
  */
@@ -201,11 +201,11 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
 
     MethodCaller iteratorNextMethod = MethodCaller.newInterface(Iterator.class, "next");
     MethodCaller iteratorHasNextMethod = MethodCaller.newInterface(Iterator.class, "hasNext");
-    
+
     // current stack index
     private int lastVariableIndex;
     private static int tempVariableNameCounter;
-    
+
     // exception blocks list
     private List exceptionBlocks = new ArrayList();
 
@@ -251,16 +251,16 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
             this.classNode = classNode;
             this.outermostClass = null;
             this.internalClassName = BytecodeHelper.getClassInternalName(classNode.getName());
-            
+
             //System.out.println("Generating class: " + classNode.getName());
-            
+
             // lets check that the classes are all valid
             classNode.setSuperClass(checkValidType(classNode.getSuperClass(), classNode, "Must be a valid base class"));
             String[] interfaces = classNode.getInterfaces();
             for (int i = 0; i < interfaces.length; i++ ) {
                 interfaces[i] = checkValidType(interfaces[i], classNode, "Must be a valid interface name");
             }
-            
+
             this.internalBaseClassName = BytecodeHelper.getClassInternalName(classNode.getSuperClass());
 
             cw.visit(
@@ -300,9 +300,9 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
         this.constructorNode = node;
         this.methodNode = null;
         this.variableScope = null;
-        
+
         visitParameters(node, node.getParameters());
-        
+
         String methodType = BytecodeHelper.getMethodDescriptor("void", node.getParameters());
         cv = cw.visitMethod(node.getModifiers(), "<init>", methodType, null, null);
         helper = new BytecodeHelper(cv);
@@ -333,7 +333,7 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
 
         visitParameters(node, node.getParameters());
         node.setReturnType(checkValidType(node.getReturnType(), node, "Must be a valid return type"));
-        
+
         String methodType = BytecodeHelper.getMethodDescriptor(node.getReturnType(), node.getParameters());
         cv = cw.visitMethod(node.getModifiers(), node.getName(), methodType, null, null);
         helper = new BytecodeHelper(cv);
@@ -423,8 +423,20 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
     public void visitForLoop(ForStatement loop) {
         onLineNumber(loop);
 
+
+        //
+        // Declare the loop counter.
+
         Type variableType = checkValidType(loop.getVariableType(), loop, "for loop variable");
-        int iIdx = defineVariable(loop.getVariable(), variableType, true).getIndex();
+        Variable variable = defineVariable(loop.getVariable(), variableType, true);
+
+        if( isInScriptBody() ) {
+            variable.setProperty( true );
+        }
+
+
+        //
+        // Then initialize the iterator and generate the loop control
 
         loop.getCollectionExpression().visit(this);
 
@@ -447,11 +459,19 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
                 iteratorNextMethod.call(cv);
             }
         };
-        evaluateEqual(
-            new BinaryExpression(new VariableExpression(loop.getVariable()), Token.newSymbol(Types.EQUAL, -1, -1), expression));
+
+        evaluateEqual( BinaryExpression.newAssignmentExpression(loop.getVariable(), expression) );
+
+
+        //
+        // Generate the loop body
 
         loop.getLoopBlock().visit(this);
 
+
+        //
+        // Generate the loop tail
+
         cv.visitLabel(continueLabel);
         cv.visitVarInsn(ALOAD, iteratorIdx);
 
@@ -910,7 +930,7 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
         else {
             doConvertAndCast(returnType, expression);
             cv.visitInsn(ARETURN);
-            
+
             /*
             if (c == Boolean.class) {
                 Label l0 = new Label();
@@ -1135,6 +1155,13 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
         ConstructorNode node = (ConstructorNode) constructors.get(0);
         Parameter[] localVariableParams = node.getParameters();
 
+
+        //
+        // Define in the context any variables that will be
+        // created inside the closure.  Note that the first two
+        // parameters are always _outerInstance and _delegate,
+        // so we don't worry about them.
+
         for (int i = 2; i < localVariableParams.length; i++) {
             Parameter param = localVariableParams[i];
             String name = param.getName();
@@ -1151,7 +1178,7 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
             cv.visitVarInsn(ALOAD, 0);
             cv.visitFieldInsn(GETFIELD, internalClassName, "owner", helper.getTypeDescription(ownerTypeName));
             cv.visitVarInsn(ASTORE, paramIdx);
-        
+
             cv.visitTypeInsn(NEW, innerClassinternalName);
             cv.visitInsn(DUP);
             cv.visitVarInsn(ALOAD, paramIdx);
@@ -1274,9 +1301,9 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
         		throw new ClassGeneratorException(
         				"Cannot generate bytecode for constant: " + value
         				+ " of type: " + value.getClass().getName()
-        				+".  Numeric constant type not supported.");	
+        				+".  Numeric constant type not supported.");
         	}
-             
+
             cv.visitMethodInsn(INVOKESPECIAL, className, "<init>", methodType);
         }
         else if (value instanceof Boolean) {
@@ -1367,24 +1394,24 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
                 if (superMethodCall) {
                     if (method.equals("super") || method.equals("<init>")) {
                         ConstructorNode constructorNode = findSuperConstructor(call);
-                        
+
                         cv.visitVarInsn(ALOAD, 0);
-                        
+
                         loadArguments(constructorNode.getParameters(), arguments);
-                        
+
                         String descriptor = BytecodeHelper.getMethodDescriptor("void", constructorNode.getParameters());
                         cv.visitMethodInsn(INVOKESPECIAL, BytecodeHelper.getClassInternalName(classNode.getSuperClass()), "<init>", descriptor);
                     }
                     else {
                         MethodNode methodNode = findSuperMethod(call);
-                        
+
                         cv.visitVarInsn(ALOAD, 0);
-                        
+
                         loadArguments(methodNode.getParameters(), arguments);
-                        
+
                         String descriptor = BytecodeHelper.getMethodDescriptor(methodNode.getReturnType(), methodNode.getParameters());
                         cv.visitMethodInsn(INVOKESPECIAL, BytecodeHelper.getClassInternalName(methodNode.getDeclaringClass().getName()), method, descriptor);
-                    } 
+                    }
                 }
                 else {
                     if (emptyArguments(arguments) && !call.isSafe()) {
@@ -1396,15 +1423,15 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
                         if (argumentsUseStack(arguments)) {
                             int paramIdx =
                                 defineVariable(createVariableName("temp"), "java.lang.Object", false).getIndex();
-                            
+
                             arguments.visit(this);
-                            
+
                             cv.visitVarInsn(ASTORE, paramIdx);
-                            
+
                             call.getObjectExpression().visit(this);
-                            
+
                             cv.visitLdcInsn(method);
-                            
+
                             cv.visitVarInsn(ALOAD, paramIdx);
                         }
                         else {
@@ -1412,7 +1439,7 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
                             cv.visitLdcInsn(method);
                             arguments.visit(this);
                         }
-                        
+
                         if (call.isSafe()) {
                             invokeMethodSafeMethod.call(cv);
                         }
@@ -1424,7 +1451,7 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
             }
         }
     }
-    
+
     /**
      * Loads and coerces the argument values for the given method call
      */
@@ -1435,7 +1462,7 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
             Expression argExp = argListExp.getExpression(i);
             Parameter param = parameters[i];
             visitAndAutobox(argExp);
-            
+
             String type = param.getType();
             if (helper.isPrimitiveType(type)) {
                 helper.unbox(type);
@@ -1548,9 +1575,9 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
         }
         /*
          * cv.visitLdcInsn(type);
-         * 
+         *
          * arguments.visit(this);
-         * 
+         *
          * invokeConstructorMethod.call(cv);
          */
     }
@@ -1707,27 +1734,17 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
         }
     }
 
-    protected void visitOuterFieldExpression(FieldExpression expression) {
-        ClassNode outerClassNode = classNode.getOuterClass();
-        if (outerClassNode instanceof InnerClassNode) {
-            visitPropertyExpression(
-                new PropertyExpression(new FieldExpression(classNode.getField("owner")), expression.getFieldName()));
-            return;
-        }
-
+    protected void visitOuterFieldExpression(FieldExpression expression, ClassNode outerClassNode, int steps, boolean first ) {
         int valueIdx = defineVariable(createVariableName("temp"), "java.lang.Object", false).getIndex();
-        
-        
-        if (leftHandExpression) {
+
+        if (leftHandExpression && first) {
             cv.visitVarInsn(ASTORE, valueIdx);
         }
 
         FieldNode field = expression.getField();
         boolean isStatic = field.isStatic();
 
-        // lets load an extra one just in case as we may be getting & putting a
-        // field
-        if (!isStatic) {
+        if (steps > 1 || !isStatic) {
             cv.visitVarInsn(ALOAD, 0);
             cv.visitFieldInsn(
                 GETFIELD,
@@ -1736,34 +1753,58 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
                 BytecodeHelper.getTypeDescription(outerClassNode.getName()));
         }
 
-        int opcode = (leftHandExpression) ? ((isStatic) ? PUTSTATIC : PUTFIELD) : ((isStatic) ? GETSTATIC : GETFIELD);
-        String ownerName = BytecodeHelper.getClassInternalName(outerClassNode.getName());
+        if( steps == 1 ) {
+            int opcode = (leftHandExpression) ? ((isStatic) ? PUTSTATIC : PUTFIELD) : ((isStatic) ? GETSTATIC : GETFIELD);
+            String ownerName = BytecodeHelper.getClassInternalName(outerClassNode.getName());
 
-        if (leftHandExpression) {
-            cv.visitVarInsn(ALOAD, valueIdx);
-            boolean holder = field.isHolder() && !isInClosureConstructor();
-            if (!holder) {
-                doConvertAndCast(field.getType());
+            if (leftHandExpression) {
+                cv.visitVarInsn(ALOAD, valueIdx);
+                boolean holder = field.isHolder() && !isInClosureConstructor();
+                if ( !holder) {
+                    doConvertAndCast(field.getType());
+                }
             }
+            cv.visitFieldInsn(opcode, ownerName, expression.getFieldName(), BytecodeHelper.getTypeDescription(field.getType()));
         }
 
-        cv.visitFieldInsn(opcode, ownerName, expression.getFieldName(), BytecodeHelper.getTypeDescription(field.getType()));
-        /*
-         * if (leftHandExpression) { cv.visitVarInsn(ALOAD, valueIdx); }
-         */
+        else {
+            visitOuterFieldExpression( expression, outerClassNode.getOuterClass(), steps - 1, false );
+        }
     }
 
+
+
+    /**
+     *  Visits a bare (unqualified) variable expression.
+     */
+
     public void visitVariableExpression(VariableExpression expression) {
-        // lets see if the variable is a field
+
         String variableName = expression.getVariable();
+
+      //-----------------------------------------------------------------------
+      // SPECIAL CASES
+
+        //
+        // "this" for static methods is the Class instance
+
         if (isStaticMethod() && variableName.equals("this")) {
             visitClassExpression(new ClassExpression(classNode.getName()));
-            return;
+            return;                                               // <<< FLOW CONTROL <<<<<<<<<
         }
+
+        //
+        // "super" also requires special handling
+
         if (variableName.equals("super")) {
             visitClassExpression(new ClassExpression(classNode.getSuperClass()));
-            return;
+            return;                                               // <<< FLOW CONTROL <<<<<<<<<
         }
+
+
+        //
+        // class names return a Class instance, too
+
         if (!variableName.equals("this")) {
             String className = resolveClassName(variableName);
             if (className != null) {
@@ -1773,134 +1814,168 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
                         expression);
                 }
                 visitClassExpression(new ClassExpression(className));
-                return;
+                return;                                               // <<< FLOW CONTROL <<<<<<<<<
             }
         }
-        FieldNode field = classNode.getField(variableName);
-        if (field != null && variableStack.get(variableName) == null) {
-            visitFieldExpression(new FieldExpression(field));
+
+
+      //-----------------------------------------------------------------------
+      // GENERAL VARIABLE LOOKUP
+
+
+        //
+        // We are handling only unqualified variables here.  Therefore,
+        // we do not care about accessors, because local access doesn't
+        // go through them.  Therefore, precedence is as follows:
+        //   1) local variables, nearest block first
+        //   2) class fields
+        //   3) repeat search from 2) in next outer class
+
+        boolean  handled  = false;
+        Variable variable = (Variable)variableStack.get( variableName );
+
+        if( variable != null ) {
+
+            if( variable.isProperty() ) {
+                processPropertyVariable( variableName, variable );
+            }
+            else {
+                processStackVariable( variableName, variable );
+            }
+
+            handled = true;
         }
+
+        //
+        // Loop through outer classes for fields
+
         else {
-            field = classNode.getOuterField(variableName);
-            if (field != null) {
-                visitOuterFieldExpression(new FieldExpression(field));
+
+            int       steps   = 0;
+            ClassNode current = classNode;
+            FieldNode field   = null;
+
+            do {
+                if( (field = current.getField(variableName)) != null ) {
+                    break;
+                }
+                steps++;
+
+            } while( (current = current.getOuterClass()) != null );
+
+            if( field != null ) {
+                processFieldAccess( variableName, field, steps );
+                handled = true;
+            }
+        }
+
+
+        //
+        // Finally, if unhandled, create a variable for it.
+        // Except there a stack variable should be created,
+        // we define the variable as a property accessor and
+        // let other parts of the classgen report the error
+        // if the property doesn't exist.
+
+        if( !handled ) {
+           String variableType = expression.getType();
+           variable = defineVariable( variableName, variableType );
+
+           if( isInScriptBody() || !leftHandExpression ) {
+               variable.setProperty( true );
+               processPropertyVariable( variableName, variable );
+           }
+           else {
+               processStackVariable( variableName, variable );
+           }
+        }
+    }
+
+
+    protected void processStackVariable( String name, Variable variable ) {
+        String  type   = variable.getTypeName();
+        int     index  = variable.getIndex();
+        boolean holder = variable.isHolder() && !passingClosureParams;
+
+        if( leftHandExpression ) {
+            if (holder) {
+                int tempIndex = defineVariable(createVariableName("reference"), type, false).getIndex();
+
+                cv.visitVarInsn(ASTORE, tempIndex);
+
+                cv.visitVarInsn(ALOAD, index);
+                cv.visitVarInsn(ALOAD, tempIndex);
+                cv.visitMethodInsn(INVOKEVIRTUAL, "groovy/lang/Reference", "set", "(Ljava/lang/Object;)V");
             }
             else {
-                String name = variableName;
-                Variable variable = null;
-                String variableType = expression.getType();
-                boolean useProperty = isInScriptBody();
-                if (!leftHandExpression) {
-                    variable = (Variable) variableStack.get(name);
+                //TODO: make work with arrays
+                if (type.equals("double")) {
+                    cv.visitVarInsn(DSTORE, index);
+                }
+                else if (type.equals("float")) {
+                    cv.visitVarInsn(FSTORE, index);
+                }
+                else if (type.equals("long")) {
+                    cv.visitVarInsn(LSTORE, index);
+                }
+                else if (
+                    type.equals("byte")
+                        || type.equals("short")
+                        || type.equals("boolean")
+                        || type.equals("int")) {
+                    cv.visitVarInsn(ISTORE, index);
                 }
                 else {
-                    if (!useProperty) {
-                        variable = defineVariable(name, variableType);
-                    }
+                    cv.visitVarInsn(ASTORE, index);
                 }
-                if (variable == null || variable.isProperty()) {
-                    if (variable == null) {
-                        variable = defineVariable(name, variableType);
-                        variable.setProperty(true);
-                    }
-                    //variable = defineVariable(name, variableType, false);
-                    if (variable.isHolder() && passingClosureParams && useProperty) {
-                        // lets create a ScriptReference to pass into the closure
-                        cv.visitTypeInsn(NEW, "org/codehaus/groovy/runtime/ScriptReference");
-                        cv.visitInsn(DUP);
+            }
+        }
+        else {
+            if (holder) {
+                cv.visitVarInsn(ALOAD, index);
+                cv.visitMethodInsn(INVOKEVIRTUAL, "groovy/lang/Reference", "get", "()Ljava/lang/Object;");
+            }
+            else {
+                cv.visitVarInsn(ALOAD, index);
+            }
+        }
 
-                        loadThisOrOwner();
-                        cv.visitLdcInsn(name);
+    }
 
-                        cv.visitMethodInsn(
-                            INVOKESPECIAL,
-                            "org/codehaus/groovy/runtime/ScriptReference",
-                            "<init>",
-                            "(Lgroovy/lang/Script;Ljava/lang/String;)V");
-                    }
-                    else {
-                        visitPropertyExpression(new PropertyExpression(VariableExpression.THIS_EXPRESSION, name));
-                    }
-                    // We need to store this in a local variable now since it
-                    // has been looked at in this scope and possibly
-                    // compared and it hasn't been referenced before.
-                    //cv.visitInsn(DUP);
-                    //cv.visitVarInsn(ASTORE, variable.getIndex());
-                    return;
-                }
-                String type = variable.getTypeName();
-                int index = variable.getIndex();
-                boolean holder = variable.isHolder() && !passingClosureParams;
+    protected void processPropertyVariable( String name, Variable variable ) {
+        if (variable.isHolder() && passingClosureParams && isInScriptBody() ) {
+            // lets create a ScriptReference to pass into the closure
+            cv.visitTypeInsn(NEW, "org/codehaus/groovy/runtime/ScriptReference");
+            cv.visitInsn(DUP);
 
-                if (leftHandExpression) {
-                    if (holder) {
-                        int tempIndex = defineVariable(createVariableName("reference"), variableType, false).getIndex();
+            loadThisOrOwner();
+            cv.visitLdcInsn(name);
 
-                        cv.visitVarInsn(ASTORE, tempIndex);
+            cv.visitMethodInsn(
+                INVOKESPECIAL,
+                "org/codehaus/groovy/runtime/ScriptReference",
+                "<init>",
+                "(Lgroovy/lang/Script;Ljava/lang/String;)V");
+        }
+        else {
+            visitPropertyExpression(new PropertyExpression(VariableExpression.THIS_EXPRESSION, name));
+        }
+    }
 
-                        cv.visitVarInsn(ALOAD, index);
-                        cv.visitVarInsn(ALOAD, tempIndex);
-                        cv.visitMethodInsn(INVOKEVIRTUAL, "groovy/lang/Reference", "set", "(Ljava/lang/Object;)V");
-                    }
-                    else {
-                        //TODO: make work with arrays
-                        if (type.equals("double")) {
-                            cv.visitVarInsn(DSTORE, index);
-                        }
-                        else if (type.equals("float")) {
-                            cv.visitVarInsn(FSTORE, index);
-                        }
-                        else if (type.equals("long")) {
-                            cv.visitVarInsn(LSTORE, index);
-                        }
-                        else if (
-                            type.equals("byte")
-                                || type.equals("short")
-                                || type.equals("boolean")
-                                || type.equals("int")) {
-                            cv.visitVarInsn(ISTORE, index);
-                        }
-                        else {
-                            cv.visitVarInsn(ASTORE, index);
-                        }
-                    }
-                }
-                else {
-                    if (holder) {
-                        cv.visitVarInsn(ALOAD, index);
-                        cv.visitMethodInsn(INVOKEVIRTUAL, "groovy/lang/Reference", "get", "()Ljava/lang/Object;");
-                    }
-                    else {
 
-                        /*
-                        //TODO: make work with arrays
-                        if (type.equals("double")) {
-                            cv.visitVarInsn(DLOAD, index);
-                        }
-                        else if (type.equals("float")) {
-                            cv.visitVarInsn(FLOAD, index);
-                        }
-                        else if (type.equals("long")) {
-                            cv.visitVarInsn(LLOAD, index);
-                        }
-                        else if (
-                            type.equals("byte")
-                                || type.equals("short")
-                                || type.equals("boolean")
-                                || type.equals("int")) {
-                            cv.visitVarInsn(ILOAD, index);
-                        }
-                        else {
-                            cv.visitVarInsn(ALOAD, index);
-                        }
-                        */
-                        cv.visitVarInsn(ALOAD, index);
-                    }
-                }
-            }
+    protected void processFieldAccess( String name, FieldNode field, int steps ) {
+        FieldExpression expression = new FieldExpression(field);
+
+        if( steps == 0 ) {
+            visitFieldExpression( expression );
+        }
+        else {
+            visitOuterFieldExpression( expression, classNode.getOuterClass(), steps, true );
         }
     }
 
+
+
     /**
      * @return true if we are in a script body, where all variables declared are no longer
      * local variables but are properties
@@ -2459,7 +2534,7 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
         */
 
         leftHandExpression = false;
-        
+
         evaluateExpression(leftExpression);
         leftHandExpression = false;
         evaluateExpression(expression.getRightExpression());
@@ -2519,7 +2594,7 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
 
     /**
      * Deduces the type name required for some casting
-     * 
+     *
      * @return the type of the given (LHS) expression or null if it is java.lang.Object or it cannot be deduced
      */
     protected String getLHSType(Expression leftExpression) {
@@ -2688,7 +2763,7 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
 
     /**
      * For assignment expressions, return a safe expression for the LHS we can use
-     * to return the value 
+     * to return the value
      */
     protected Expression createReturnLHSExpression(Expression expression) {
         if (expression instanceof BinaryExpression) {
@@ -2789,6 +2864,12 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
      */
     protected Parameter[] getClosureSharedVariables(ClosureExpression expression) {
         List vars = new ArrayList();
+
+        //
+        // First up, get the scopes for outside and inside the closure.
+        // The inner scope must cover all nested closures, as well, as
+        // everything that will be needed must be imported.
+
         VariableScope outerScope = getVariableScope().createRecursiveParentScope();
         VariableScope innerScope = expression.getVariableScope();
         if (innerScope == null) {
@@ -2800,12 +2881,35 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
             innerScope = innerScope.createRecursiveChildScope();
         }
 
-        // now any variables declared in the outer context that are referred to
-        // in the inner context need to be copied
+
+        //
+        // DeclaredVariables include any name that was assigned to within
+        // the scope.  ReferencedVariables include any name that was read
+        // from within the scope.  We get the sets from each and must piece
+        // together the stack variable import list for the closure.  Note
+        // that we don't worry about field variables here, as we don't have
+        // to do anything special with them.  Stack variables, on the other
+        // hand, have to be wrapped up in References for use.
+
         Set outerDecls = outerScope.getDeclaredVariables();
-        Set outerRefs = outerScope.getReferencedVariables();
+        Set outerRefs  = outerScope.getReferencedVariables();
         Set innerDecls = innerScope.getDeclaredVariables();
-        Set innerRefs = innerScope.getReferencedVariables();
+        Set innerRefs  = innerScope.getReferencedVariables();
+
+
+        //
+        // So, we care about any name referenced in the closure UNLESS:
+        //   1) it's not declared in the outer context;
+        //   2) it's a parameter;
+        //   3) it's a field in the context class that isn't overridden
+        //      by a stack variable in the outer context.
+        //
+        // BUG: We don't actually have the necessary information to do
+        //      this right!  The outer declarations don't distinguish
+        //      between assignments and variable declarations.  Therefore
+        //      we can't tell when field variables have been overridden
+        //      by stack variables in the outer context.  This must
+        //      be fixed!
 
         Set varSet = new HashSet();
         for (Iterator iter = innerRefs.iterator(); iter.hasNext();) {
@@ -2825,6 +2929,8 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
                 vars.add(new Parameter(type, var));
             }
         }
+
+
         Parameter[] answer = new Parameter[vars.size()];
         vars.toArray(answer);
         return answer;
@@ -2839,9 +2945,9 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
         /*
         VariableScopeCodeVisitor outerVisitor = new VariableScopeCodeVisitor(true);
         node.getCode().visit(outerVisitor);
-        
+
         addFieldsToVisitor(outerVisitor);
-        
+
         VariableScopeCodeVisitor innerVisitor = outerVisitor.getClosureVisitor();
         */
         VariableScope outerScope = getVariableScope();
@@ -2906,10 +3012,10 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
     protected void resetVariableStack(Parameter[] parameters) {
         lastVariableIndex = -1;
         variableStack.clear();
-        
+
         scope = null;
         pushBlockScope();
-        
+
         // lets push this onto the stack
         definingParameters = true;
         if (!isStaticMethod()) {
@@ -2930,7 +3036,7 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
 
     protected void popScope() {
         int lastID = scope.getLastVariableIndex();
-        
+
         List removeKeys = new ArrayList();
         for (Iterator iter = variableStack.entrySet().iterator(); iter.hasNext();) {
             Map.Entry entry = (Map.Entry) iter.next();
@@ -3066,7 +3172,7 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
     protected String getExpressionType(Expression expression) {
         if (comparisonExpression(expression)) {
             return "boolean";
-        } 
+        }
         if (expression instanceof VariableExpression) {
             VariableExpression varExpr = (VariableExpression) expression;
             Variable variable = (Variable) variableStack.get(varExpr.getVariable());
diff --git a/src/main/org/codehaus/groovy/classgen/Variable.java b/src/main/org/codehaus/groovy/classgen/Variable.java
index f4337993f8..2b4a4e6009 100644
--- a/src/main/org/codehaus/groovy/classgen/Variable.java
+++ b/src/main/org/codehaus/groovy/classgen/Variable.java
@@ -47,6 +47,7 @@ package org.codehaus.groovy.classgen;
 
 import org.codehaus.groovy.ast.Type;
 
+
 /**
  * Represents compile time variable metadata while compiling a method.
  * 
diff --git a/src/test/groovy/bugs/ForLoopBug.groovy b/src/test/groovy/bugs/ForLoopBug.groovy
index db14345e6f..e1543b2c77 100644
--- a/src/test/groovy/bugs/ForLoopBug.groovy
+++ b/src/test/groovy/bugs/ForLoopBug.groovy
@@ -9,8 +9,8 @@ class ForLoopBug extends GroovyTestCase {
 list = []
 a = 1
 b = 5
-for (a in a..b) {
-    list << a
+for (c in a..b) {
+    list << c
 }
 assert list == [1, 2, 3, 4, 5]
 EOF)        
@@ -23,13 +23,13 @@ for (i in 1..10) {
 }
 EOF)        
     }
-    
+
     void testNormalMethod() {
         list = []
         a = 1
         b = 5
-        for (a in a..b) {
-            list << a
+        for (c in a..b) {
+            list << c
         }
         assert list == [1, 2, 3, 4, 5]
     }
@@ -45,4 +45,18 @@ EOF)
         
 		assert a == 5
     }
-}
\ No newline at end of file
+
+
+    void testVisibility() {
+        assertScript( <<<EOF
+
+array = [ true, true, true ];
+for( boolean i in array ) {
+   1.times {
+       assert i == true;
+   }
+}
+EOF)        
+    }
+
+}
diff --git a/src/test/groovy/bugs/VariablePrecedence.groovy b/src/test/groovy/bugs/VariablePrecedence.groovy
new file mode 100644
index 0000000000..707f80cfaa
--- /dev/null
+++ b/src/test/groovy/bugs/VariablePrecedence.groovy
@@ -0,0 +1,51 @@
+/**
+ * @author John Wilson
+ * @version $Revision$
+ */
+class VariblePrecedence extends GroovyTestCase {
+    
+    void testVariablePrecedence() {
+ /*
+        assertScript( <<<-EOF
+            class VariableFoo {
+                x = 100
+                y = 93
+                c = {|x| assert x == 1; assert y == 93; }
+                static void main(args) {
+                    vfoo = new VariableFoo()
+                    vfoo.c.call(1)
+
+                    z = 874;
+                    1.times { assert vfoo.x == 100; assert z == 874; z = 39; }
+                    assert z == 39;
+
+                    vfoo.local();
+                }
+
+                void local() {
+                    c.call(1);
+
+                    z = 874;
+                    1.times { assert x == 100; assert z == 874; z = 39; }
+                    assert z == 39;
+                } 
+            }
+
+        EOF );
+ */
+    }
+
+
+/*
+    void testVariablePrecedenceInScript() {
+        assertScript( <<<-EOF
+            c = { |x| assert x == 1; assert y == 93; }
+            x = 100;
+            y = 93;
+
+            c.call(1);
+        EOF);
+    }
+*/
+
+}
