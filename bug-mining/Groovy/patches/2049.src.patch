diff --git a/src/main/org/codehaus/groovy/util/ManagedConcurrentValueMap.java b/src/main/org/codehaus/groovy/util/ManagedConcurrentValueMap.java
index 7a21dc790c..533994ec32 100644
--- a/src/main/org/codehaus/groovy/util/ManagedConcurrentValueMap.java
+++ b/src/main/org/codehaus/groovy/util/ManagedConcurrentValueMap.java
@@ -28,11 +28,20 @@ import java.util.concurrent.ConcurrentHashMap;
  * @param <V> the value type
  */
 public class ManagedConcurrentValueMap<K,V> {
-    private final ReferenceBundle bundle;
     private final ConcurrentHashMap<K,ManagedReference<V>> internalMap;
+    private ReferenceBundle bundle;
     public ManagedConcurrentValueMap(ReferenceBundle bundle){
         this.bundle = bundle;
-        internalMap = new ConcurrentHashMap();
+        internalMap = new ConcurrentHashMap<K, ManagedReference<V>>();
+    }
+    
+    /**
+     * Sets a new bundle used for reference creation. Be warned that
+     * older entries will not be changed by this
+     * @param bundle - the ReferenceBundle
+     */
+    public void setBundle(ReferenceBundle bundle) {
+        this.bundle = bundle;
     }
 
     /**
@@ -52,7 +61,7 @@ public class ManagedConcurrentValueMap<K,V> {
      * @param value the new value
      */
     public void put(final K key, V value) {
-        ManagedReference<V> ref = new ManagedReference(bundle, value) {
+        ManagedReference<V> ref = new ManagedReference<V>(bundle, value) {
             @Override
             public void finalizeReference() {
                 super.finalizeReference();
diff --git a/src/main/org/codehaus/groovy/util/ReferenceBundle.java b/src/main/org/codehaus/groovy/util/ReferenceBundle.java
index 484a7895dc..b0162838b2 100644
--- a/src/main/org/codehaus/groovy/util/ReferenceBundle.java
+++ b/src/main/org/codehaus/groovy/util/ReferenceBundle.java
@@ -31,20 +31,30 @@ public class ReferenceBundle{
         return manager;
     }      
     
-    private static final ReferenceBundle softReferences, weakReferences;
+    private static final ReferenceBundle softReferences, weakReferences, hardReferences, phantomReferences;
     static {
         ReferenceQueue queue = new ReferenceQueue();
         ReferenceManager callBack = ReferenceManager.createCallBackedManager(queue);
         ReferenceManager manager  = ReferenceManager.createThresholdedIdlingManager(queue, callBack, 5000);
         softReferences = new ReferenceBundle(manager, ReferenceType.SOFT);
         weakReferences = new ReferenceBundle(manager, ReferenceType.WEAK);
+        phantomReferences = new ReferenceBundle(manager, ReferenceType.PHANTOM);
+        hardReferences = new ReferenceBundle(ReferenceManager.createIdlingManager(null), ReferenceType.HARD);
     }
 
     public static ReferenceBundle getSoftBundle() {
         return softReferences;
     }
-    
+
     public static ReferenceBundle getWeakBundle() {
         return weakReferences;
     }
+
+    public static ReferenceBundle getHardBundle() {
+        return hardReferences;
+    }
+
+    public static ReferenceBundle getPhantomBundle() {
+        return phantomReferences;
+    }
 }
\ No newline at end of file
diff --git a/subprojects/groovy-jsr223/src/main/java/org/codehaus/groovy/jsr223/GroovyScriptEngineImpl.java b/subprojects/groovy-jsr223/src/main/java/org/codehaus/groovy/jsr223/GroovyScriptEngineImpl.java
index 14bb34782b..ba4bbee288 100644
--- a/subprojects/groovy-jsr223/src/main/java/org/codehaus/groovy/jsr223/GroovyScriptEngineImpl.java
+++ b/subprojects/groovy-jsr223/src/main/java/org/codehaus/groovy/jsr223/GroovyScriptEngineImpl.java
@@ -79,14 +79,13 @@ import java.lang.String;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
-import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
 
 /*
  * @author Mike Grogan
  * @author A. Sundararajan
  * @author Jim White
  * @author Guillaume Laforge
+ * @author Jochen Theodorou
  */
 public class GroovyScriptEngineImpl
         extends AbstractScriptEngine implements Compilable, Invocable {
@@ -97,7 +96,7 @@ public class GroovyScriptEngineImpl
     private ManagedConcurrentMap<String, Class> classMap = new ManagedConcurrentMap<String, Class>(ReferenceBundle.getSoftBundle());
     // global closures map - this is used to simulate a single
     // global functions namespace 
-    private ManagedConcurrentValueMap<String, Closure> globalClosures = new ManagedConcurrentValueMap<String, Closure>(ReferenceBundle.getSoftBundle());
+    private ManagedConcurrentValueMap<String, Closure> globalClosures = new ManagedConcurrentValueMap<String, Closure>(ReferenceBundle.getHardBundle());
     // class loader for Groovy generated classes
     private GroovyClassLoader loader;
     // lazily initialized factory
@@ -111,7 +110,7 @@ public class GroovyScriptEngineImpl
     }
 
     public GroovyScriptEngineImpl() {
-        this.loader = new GroovyClassLoader(getParentLoader(), new CompilerConfiguration());
+        this(new GroovyClassLoader(getParentLoader(), new CompilerConfiguration()));
     }
 
     public GroovyScriptEngineImpl(GroovyClassLoader classLoader) {
@@ -126,6 +125,21 @@ public class GroovyScriptEngineImpl
 
     public Object eval(String script, ScriptContext ctx)
             throws ScriptException {
+        try {
+            String val = (String) ctx.getAttribute("#jsr223.groovy.engine.keep.globals", ScriptContext.ENGINE_SCOPE);
+            ReferenceBundle bundle = ReferenceBundle.getHardBundle();
+            if (val!=null && val.length()>0) {
+                if (val.equalsIgnoreCase("soft")) {
+                    bundle = ReferenceBundle.getSoftBundle();
+                } else if (val.equalsIgnoreCase("weak")) {
+                    bundle = ReferenceBundle.getWeakBundle();
+                } else if (val.equalsIgnoreCase("phantom")) {
+                    bundle = ReferenceBundle.getPhantomBundle();
+                }
+            }
+            globalClosures.setBundle(bundle);
+        } catch (ClassCastException cce) { /*ignore.*/ }
+
         try {
             Class clazz = getScriptClass(script);
             if (clazz == null) throw new ScriptException("Script class is null");
@@ -430,7 +444,7 @@ public class GroovyScriptEngineImpl
 
     // determine appropriate class loader to serve as parent loader
     // for GroovyClassLoader instance
-    private ClassLoader getParentLoader() {
+    private static ClassLoader getParentLoader() {
         // check whether thread context loader can "see" Groovy Script class
         ClassLoader ctxtLoader = Thread.currentThread().getContextClassLoader();
         try {
