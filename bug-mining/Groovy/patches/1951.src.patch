diff --git a/src/main/org/codehaus/groovy/util/ManagedConcurrentValueMap.java b/src/main/org/codehaus/groovy/util/ManagedConcurrentValueMap.java
new file mode 100644
index 0000000000..7a21dc790c
--- /dev/null
+++ b/src/main/org/codehaus/groovy/util/ManagedConcurrentValueMap.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2003-2012 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.codehaus.groovy.util;
+
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * This is a basic implementation of a map able to forget its values. This
+ * map uses internally a ConcurrentHashMap, thus should be save for concurrency.
+ * hashcode and equals are used to find the entries and should thus be implemented
+ * properly for the keys. This map does not support null keys.
+ * @author <a href="mailto:blackdrag@gmx.org">Jochen "blackdrag" Theodorou</a>
+ *
+ * @param <K> the key type
+ * @param <V> the value type
+ */
+public class ManagedConcurrentValueMap<K,V> {
+    private final ReferenceBundle bundle;
+    private final ConcurrentHashMap<K,ManagedReference<V>> internalMap;
+    public ManagedConcurrentValueMap(ReferenceBundle bundle){
+        this.bundle = bundle;
+        internalMap = new ConcurrentHashMap();
+    }
+
+    /**
+     * Returns the value stored for the given key at the point of call.
+     * @param key a non null key
+     * @return the value stored in the map for the given key
+     */
+    public V get(K key) {
+        ManagedReference<V> ref = internalMap.get(key);
+        if (ref!=null) return ref.get();
+        return null;
+    }
+
+    /**
+     * Sets a new value for a given key. an older value is overwritten.
+     * @param key a non null key
+     * @param value the new value
+     */
+    public void put(final K key, V value) {
+        ManagedReference<V> ref = new ManagedReference(bundle, value) {
+            @Override
+            public void finalizeReference() {
+                super.finalizeReference();
+                internalMap.remove(key, get());
+            }
+        };
+        internalMap.put(key, ref);
+    }
+    
+}
diff --git a/subprojects/groovy-jsr223/src/main/java/org/codehaus/groovy/jsr223/GroovyScriptEngineImpl.java b/subprojects/groovy-jsr223/src/main/java/org/codehaus/groovy/jsr223/GroovyScriptEngineImpl.java
index ca1b62b953..14bb34782b 100644
--- a/subprojects/groovy-jsr223/src/main/java/org/codehaus/groovy/jsr223/GroovyScriptEngineImpl.java
+++ b/subprojects/groovy-jsr223/src/main/java/org/codehaus/groovy/jsr223/GroovyScriptEngineImpl.java
@@ -53,6 +53,7 @@ import org.codehaus.groovy.control.CompilationFailedException;
 import org.codehaus.groovy.control.CompilerConfiguration;
 import org.codehaus.groovy.syntax.SyntaxException;
 import org.codehaus.groovy.util.ManagedConcurrentMap;
+import org.codehaus.groovy.util.ManagedConcurrentValueMap;
 import org.codehaus.groovy.util.ReferenceBundle;
 import org.codehaus.groovy.runtime.InvokerHelper;
 import org.codehaus.groovy.runtime.MetaClassHelper;
@@ -78,6 +79,8 @@ import java.lang.String;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
 
 /*
  * @author Mike Grogan
@@ -94,7 +97,7 @@ public class GroovyScriptEngineImpl
     private ManagedConcurrentMap<String, Class> classMap = new ManagedConcurrentMap<String, Class>(ReferenceBundle.getSoftBundle());
     // global closures map - this is used to simulate a single
     // global functions namespace 
-    private ManagedConcurrentMap<String, Closure> globalClosures = new ManagedConcurrentMap<String, Closure>(ReferenceBundle.getSoftBundle());
+    private ManagedConcurrentValueMap<String, Closure> globalClosures = new ManagedConcurrentValueMap<String, Closure>(ReferenceBundle.getSoftBundle());
     // class loader for Groovy generated classes
     private GroovyClassLoader loader;
     // lazily initialized factory
