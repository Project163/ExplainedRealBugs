diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index a140d681d4..19105eb4de 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -340,6 +340,12 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
     public void visitPropertyExpression(final PropertyExpression pexp) {
         super.visitPropertyExpression(pexp);
         if (!existsProperty(pexp, true)) {
+            // if the property doesn't exist, we can do a last check, which is verifying if a setter exists
+            // and that the expression is the left hand side of an assignment
+            if (currentBinaryExpression!=null && currentBinaryExpression.getLeftExpression()==pexp && isAssignment(currentBinaryExpression.getOperation().getType())) {
+                if (hasSetter(pexp)) return;
+            }
+
             Expression objectExpression = pexp.getObjectExpression();
             addStaticTypeError("No such property: " + pexp.getPropertyAsString() +
                     " for class: " + findCurrentInstanceOfClass(objectExpression, getType(objectExpression)).toString(false), pexp);
@@ -865,6 +871,51 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         return false;
     }
 
+    protected boolean hasSetter(final PropertyExpression pexp) {
+        Expression objectExpression = pexp.getObjectExpression();
+        ClassNode clazz = getType(objectExpression);
+        List<ClassNode> tests = new LinkedList<ClassNode>();
+        tests.add(clazz);
+        if (clazz.equals(CLASS_Type) && clazz.getGenericsTypes() != null) {
+            tests.add(clazz.getGenericsTypes()[0].getType());
+        }
+        if (!temporaryIfBranchTypeInformation.empty()) {
+            List<ClassNode> classNodes = getTemporaryTypesForExpression(objectExpression);
+            if (classNodes != null) tests.addAll(classNodes);
+        }
+        if (lastImplicitItType != null
+                && pexp.getObjectExpression() instanceof VariableExpression
+                && ((VariableExpression) pexp.getObjectExpression()).getName().equals("it")) {
+            tests.add(lastImplicitItType);
+        }
+        String propertyName = pexp.getPropertyAsString();
+        if (propertyName == null) return false;
+        String capName = MetaClassHelper.capitalize(propertyName);
+        boolean isAttributeExpression = pexp instanceof AttributeExpression;
+        if (clazz.isInterface()) tests.add(OBJECT_TYPE);
+        for (ClassNode testClass : tests) {
+            LinkedList<ClassNode> queue = new LinkedList<ClassNode>();
+            queue.add(testClass);
+            if (testClass.isInterface()) {
+                queue.addAll(testClass.getAllInterfaces());
+            }
+            while (!queue.isEmpty()) {
+                ClassNode current = queue.removeFirst();
+                current = current.redirect();
+                // check that a setter also exists
+                MethodNode setterMethod = current.getSetterMethod("set" + capName, false);
+                if (setterMethod!=null) {
+                    storeType(pexp, setterMethod.getParameters()[0].getType());
+                    return true;
+                }
+                if (!isAttributeExpression && current.getSuperClass() != null) {
+                    queue.add(current.getSuperClass());
+                }
+            }
+        }
+        return false;
+    }
+
     @Override
     public void visitField(final FieldNode node) {
         final boolean osc = isInStaticContext;
diff --git a/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy b/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy
index 260fdfa268..6c352aad3a 100644
--- a/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy
+++ b/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy
@@ -297,6 +297,32 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
         '''
     }
 
+    void testSetterUsingPropertyNotation() {
+        assertScript '''
+            class A {
+                boolean ok = false;
+                void setFoo(String foo) { ok = foo == 'foo' }
+            }
+            def a = new A()
+            a.foo = 'foo'
+            assert a.ok
+        '''
+    }
+
+    void testSetterUsingPropertyNotationOnInterface() {
+        assertScript '''
+                interface FooAware { void setFoo(String arg) }
+                class A implements FooAware {
+                    void setFoo(String foo) { }
+                }
+                void test(FooAware a) {
+                    a.foo = 'foo'
+                }
+                def a = new A()
+                test(a)
+            '''
+    }
+
 
     public static class BaseClass {
         int x
