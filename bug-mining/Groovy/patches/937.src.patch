diff --git a/src/main/groovy/beans/BindableASTTransformation.java b/src/main/groovy/beans/BindableASTTransformation.java
index de603612ae..514a7d56b0 100644
--- a/src/main/groovy/beans/BindableASTTransformation.java
+++ b/src/main/groovy/beans/BindableASTTransformation.java
@@ -36,7 +36,6 @@ import org.objectweb.asm.Opcodes;
 
 import java.beans.PropertyChangeListener;
 import java.beans.PropertyChangeSupport;
-import java.util.Collection;
 
 /**
  * Handles generation of code for the {@code @Bindable} annotation when {@code @Vetoable}
@@ -68,7 +67,7 @@ public class BindableASTTransformation implements ASTTransformation, Opcodes {
      * @return true if the node is bindable
      */
     public static boolean hasBindableAnnotation(AnnotatedNode node) {
-        for (AnnotationNode annotation : (Collection<AnnotationNode>) node.getAnnotations()) {
+        for (AnnotationNode annotation : node.getAnnotations()) {
             if (boundClassNode.equals(annotation.getClassNode())) {
                 return true;
             }
@@ -96,8 +95,16 @@ public class BindableASTTransformation implements ASTTransformation, Opcodes {
 
         ClassNode declaringClass = parent.getDeclaringClass();
         if (parent instanceof FieldNode) {
-            if (VetoableASTTransformation.hasVetoableAnnotation(parent.getDeclaringClass()))
-            {
+            if ((((FieldNode)parent).getModifiers() & Opcodes.ACC_FINAL) != 0) {
+                source.getErrorCollector().addErrorAndContinue(
+                            new SyntaxErrorMessage(new SyntaxException(
+                                "@groovy.beans.Bindable cannot annotate a final property.",
+                                node.getLineNumber(),
+                                node.getColumnNumber()),
+                                source));
+            }
+
+            if (VetoableASTTransformation.hasVetoableAnnotation(parent.getDeclaringClass())) {
                 // VetoableASTTransformation will handle both @Bindable and @Vetoable
                 return;
             }
@@ -109,7 +116,7 @@ public class BindableASTTransformation implements ASTTransformation, Opcodes {
 
     private void addListenerToProperty(SourceUnit source, AnnotationNode node, ClassNode declaringClass, FieldNode field) {
         String fieldName = field.getName();
-        for (PropertyNode propertyNode : (Collection<PropertyNode>) declaringClass.getProperties()) {
+        for (PropertyNode propertyNode : declaringClass.getProperties()) {
             if (propertyNode.getName().equals(fieldName)) {
                 if (field.isStatic()) {
                     //noinspection ThrowableInstanceNeverThrown
@@ -141,14 +148,16 @@ public class BindableASTTransformation implements ASTTransformation, Opcodes {
         if (needsPropertyChangeSupport(classNode, source)) {
             addPropertyChangeSupport(classNode);
         }
-        for (PropertyNode propertyNode : (Collection<PropertyNode>) classNode.getProperties()) {
+        for (PropertyNode propertyNode : classNode.getProperties()) {
             FieldNode field = propertyNode.getField();
             // look to see if per-field handlers will catch this one...
             if (hasBindableAnnotation(field)
+                || ((field.getModifiers() & Opcodes.ACC_FINAL) != 0)
                 || field.isStatic()
                 || VetoableASTTransformation.hasVetoableAnnotation(field))
             {
                 // explicitly labeled properties are already handled,
+                // don't transform final properties
                 // don't transform static properties
                 // VetoableASTTransformation will handle both @Bindable and @Vetoable
                 continue;
diff --git a/src/main/groovy/beans/VetoableASTTransformation.java b/src/main/groovy/beans/VetoableASTTransformation.java
index 9577918137..f814f857b1 100644
--- a/src/main/groovy/beans/VetoableASTTransformation.java
+++ b/src/main/groovy/beans/VetoableASTTransformation.java
@@ -31,11 +31,11 @@ import org.codehaus.groovy.syntax.SyntaxException;
 import org.codehaus.groovy.syntax.Token;
 import org.codehaus.groovy.syntax.Types;
 import org.codehaus.groovy.transform.GroovyASTTransformation;
+import org.objectweb.asm.Opcodes;
 
 import java.beans.PropertyVetoException;
 import java.beans.VetoableChangeListener;
 import java.beans.VetoableChangeSupport;
-import java.util.Collection;
 
 /**
  * Handles generation of code for the {@code @Vetoable} annotation, and {@code @Bindable}
@@ -67,7 +67,7 @@ public class VetoableASTTransformation extends BindableASTTransformation {
      * @return true if the node is constrained
      */
     public static boolean hasVetoableAnnotation(AnnotatedNode node) {
-        for (AnnotationNode annotation : (Collection<AnnotationNode>) node.getAnnotations()) {
+        for (AnnotationNode annotation : node.getAnnotations()) {
             if (constrainedClassNode.equals(annotation.getClassNode())) {
                 return true;
             }
@@ -90,6 +90,15 @@ public class VetoableASTTransformation extends BindableASTTransformation {
         if (nodes[1] instanceof ClassNode) {
             addListenerToClass(source, node, (ClassNode) nodes[1]);
         } else {
+            if ((((FieldNode)nodes[1]).getModifiers() & Opcodes.ACC_FINAL) != 0) {
+                source.getErrorCollector().addErrorAndContinue(
+                            new SyntaxErrorMessage(new SyntaxException(
+                                "@groovy.beans.Vetoable cannot annotate a final property.",
+                                node.getLineNumber(),
+                                node.getColumnNumber()),
+                                source));
+            }
+
             addListenerToProperty(source, node, (AnnotatedNode) nodes[1]);
         }
     }
@@ -98,7 +107,7 @@ public class VetoableASTTransformation extends BindableASTTransformation {
         ClassNode declaringClass = parent.getDeclaringClass();
         FieldNode field = ((FieldNode) parent);
         String fieldName = field.getName();
-        for (PropertyNode propertyNode : (Collection<PropertyNode>) declaringClass.getProperties()) {
+        for (PropertyNode propertyNode : declaringClass.getProperties()) {
             boolean bindable = BindableASTTransformation.hasBindableAnnotation(parent)
                 || BindableASTTransformation.hasBindableAnnotation(parent.getDeclaringClass());
 
@@ -129,8 +138,9 @@ public class VetoableASTTransformation extends BindableASTTransformation {
 
     private void addListenerToClass(SourceUnit source, AnnotationNode node, ClassNode classNode) {
         boolean bindable = BindableASTTransformation.hasBindableAnnotation(classNode);
-        for (PropertyNode propertyNode : (Collection<PropertyNode>) classNode.getProperties()) {
+        for (PropertyNode propertyNode : classNode.getProperties()) {
             if (!hasVetoableAnnotation(propertyNode.getField())
+                && !((propertyNode.getField().getModifiers() & Opcodes.ACC_FINAL) != 0)
                 && !propertyNode.getField().isStatic())
             {
                 createListenerSetter(source, node,
diff --git a/src/test/groovy/beans/vm5/BindableTest.groovy b/src/test/groovy/beans/vm5/BindableTest.groovy
index f342de5821..75f9177030 100644
--- a/src/test/groovy/beans/vm5/BindableTest.groovy
+++ b/src/test/groovy/beans/vm5/BindableTest.groovy
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008 the original author or authors.
+ * Copyright 2008-2009 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -258,4 +258,64 @@ class BindableTest extends GroovySwingTestCase {
             """)
         }
     }
+
+    public void testFinalProperty() {
+        shouldFail(CompilationFailedException) {
+            GroovyShell shell = new GroovyShell()
+            shell.evaluate("""
+                import groovy.beans.Bindable
+
+                class BindableTestBean11  {
+                  @Bindable final String testField
+                }
+                1+1
+            """)
+        }
+    }
+
+    public void testOnClassFinalProperty() {
+        shouldFail(ReadOnlyPropertyException) {
+            GroovyShell shell = new GroovyShell()
+            shell.evaluate("""
+                import groovy.beans.Bindable
+
+                @Bindable class BindableTestBean12  {
+                  String testField
+                  final String anotherTestField = 'Fixed'
+                }
+
+                sb = new BindableTestBean12()
+                int changed = 0
+                sb.propertyChange = {changed++}
+                sb.testField = 'newValue'
+                assert changed == 1
+
+                sb.anotherTestField = 'Changed'
+            """)
+        }
+    }
+
+    public void testFinalClass() {
+        shouldFail(ReadOnlyPropertyException) {
+            GroovyShell shell = new GroovyShell()
+            shell.evaluate("""
+                import groovy.beans.Bindable
+
+                @Bindable final class BindableTestBean12  {
+                  String testField
+                  final String anotherTestField = 'Fixed'
+                }
+
+                sb = new BindableTestBean12()
+                int changed = 0
+                sb.propertyChange = {changed++}
+                sb.testField = 'newValue'
+                assert changed == 1
+
+                sb.anotherTestField = 'Changed'
+            """)
+        }
+    }
+
+
 }
\ No newline at end of file
diff --git a/src/test/groovy/beans/vm5/VetoableTest.groovy b/src/test/groovy/beans/vm5/VetoableTest.groovy
index bfb7ac8847..3d5cd8e2b9 100644
--- a/src/test/groovy/beans/vm5/VetoableTest.groovy
+++ b/src/test/groovy/beans/vm5/VetoableTest.groovy
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008 the original author or authors.
+ * Copyright 2008-2009 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -308,6 +308,64 @@ class VetoableTest extends GroovySwingTestCase {
         }
     }
 
+    public void testFinalProperty() {
+        shouldFail(CompilationFailedException) {
+            GroovyShell shell = new GroovyShell()
+            shell.evaluate("""
+                import groovy.beans.Vetoable
+
+                class VetoableTestBean11  {
+                  @Vetoable final String testField
+                }
+                1+1
+            """)
+        }
+    }
+
+    public void testOnClassFinalProperty() {
+        shouldFail(ReadOnlyPropertyException) {
+            GroovyShell shell = new GroovyShell()
+            shell.evaluate("""
+                import groovy.beans.Vetoable
+
+                @Vetoable class VetoableTestBean12  {
+                  String testField
+                  final String anotherTestField = 'Fixed'
+                }
+
+                sb = new VetoableTestBean12()
+                int changed = 0
+                sb.vetoableChange = {changed++}
+                sb.testField = 'newValue'
+                assert changed == 1
+
+                sb.anotherTestField = 'Changed'
+            """)
+        }
+    }
+
+    public void testFinalClass() {
+        shouldFail(ReadOnlyPropertyException) {
+            GroovyShell shell = new GroovyShell()
+            shell.evaluate("""
+                import groovy.beans.Vetoable
+
+                @Vetoable final class VetoableTestBean12  {
+                  String testField
+                  final String anotherTestField = 'Fixed'
+                }
+
+                sb = new VetoableTestBean12()
+                int changed = 0
+                sb.vetoableChange = {changed++}
+                sb.testField = 'newValue'
+                assert changed == 1
+
+                sb.anotherTestField = 'Changed'
+            """)
+        }
+    }
+
     public void testClassMarkers() {
         for (int i = 0; i < 31; i++) {
             boolean bindField  = i & 1
