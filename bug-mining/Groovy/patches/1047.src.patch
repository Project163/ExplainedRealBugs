diff --git a/src/main/groovy/lang/Immutable.java b/src/main/groovy/lang/Immutable.java
index e1e7e48801..a42b6f3620 100644
--- a/src/main/groovy/lang/Immutable.java
+++ b/src/main/groovy/lang/Immutable.java
@@ -47,6 +47,17 @@ import java.lang.annotation.Target;
  * <li>A map-based constructor is provided which allows you to set properties by name.
  * <li>A tuple-style constructor is provided which allows you to set properties in the same order as they are defined.
  * <li>Default {@code equals}, {@code hashCode} and {@code toString} methods are provided based on the property values.
+ * Though not normally required, you may write your own implementations of these methods. For {@code equals} and {@code hashCode},
+ * if you do write your own method, it is up to you to obey the general contract for {@code equals} methods and supply a corresponding matching {@code hashCode} method.
+ * If you do provide one of these methods explicitly, the default implementation will be made available in a private
+ * "underscore" variant which you can call. E.g., you could provide a (not very elegant) multi-line formatted
+ * {@code toString} method for {@code Customer} above as follows:
+ * <pre>
+ *     String toString() {
+ *        _toString().replaceAll(/\(/, '(\n\t').replaceAll(/\)/, '\n)').replaceAll(/, /, '\n\t')
+ *    }
+ * </pre>
+ * If an "underscore" version of the respective method already exists, then no default implementation is provided.
  * <li>{@code Date}s, {@code Cloneable}s and arrays are defensively copied on the way in (constructor) and out (getters).
  * Arrays and {@code Cloneable} objects use the {@code clone} method. For your own classes,
  * it is up to you to define this method and use deep cloning if appropriate.
diff --git a/src/main/org/codehaus/groovy/transform/ImmutableASTTransformation.java b/src/main/org/codehaus/groovy/transform/ImmutableASTTransformation.java
index 6a0fe5f6c3..c7aaa7460f 100644
--- a/src/main/org/codehaus/groovy/transform/ImmutableASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/ImmutableASTTransformation.java
@@ -117,6 +117,17 @@ public class ImmutableASTTransformation implements ASTTransformation, Opcodes {
         }
     }
 
+    private boolean hasDeclaredMethod(ClassNode cNode, String name, int argsCount) {
+        List<MethodNode> ms = cNode.getDeclaredMethods(name);
+        for(MethodNode m : ms) {
+           Parameter[] paras = m.getParameters();
+           if(paras != null && paras.length == argsCount) {
+                return true;
+           }
+        }
+        return false;
+    }
+
     private void ensureNotPublic(String cNode, FieldNode fNode) {
         String fName = fNode.getName();
         // TODO: do we need to lock down things like: $ownClass
@@ -126,6 +137,10 @@ public class ImmutableASTTransformation implements ASTTransformation, Opcodes {
     }
 
     private void createHashCode(ClassNode cNode) {
+        // make a public method if none exists otherwise try a private method with leading underscore
+        boolean hasExistingHashCode = hasDeclaredMethod(cNode, "hashCode", 0);
+        if (hasExistingHashCode && hasDeclaredMethod(cNode, "_hashCode", 0)) return;
+
         final FieldNode hashField = cNode.addField("$hash$code", ACC_PRIVATE | ACC_SYNTHETIC, ClassHelper.int_TYPE, null);
         final BlockStatement body = new BlockStatement();
         final Expression hash = new FieldExpression(hashField);
@@ -139,10 +154,15 @@ public class ImmutableASTTransformation implements ASTTransformation, Opcodes {
 
         body.addStatement(new ReturnStatement(hash));
 
-        cNode.addMethod(new MethodNode("hashCode", ACC_PUBLIC, ClassHelper.int_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, body));
+        cNode.addMethod(new MethodNode(hasExistingHashCode ? "_hashCode" : "hashCode", hasExistingHashCode ? ACC_PRIVATE : ACC_PUBLIC,
+                ClassHelper.int_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, body));
     }
 
     private void createToString(ClassNode cNode) {
+        // make a public method if none exists otherwise try a private method with leading underscore
+        boolean hasExistingToString = hasDeclaredMethod(cNode, "toString", 0);
+        if (hasExistingToString && hasDeclaredMethod(cNode, "_toString", 0)) return;
+        
         final BlockStatement body = new BlockStatement();
         final List<PropertyNode> list = cNode.getProperties();
         // def _result = new StringBuffer()
@@ -169,7 +189,8 @@ public class ImmutableASTTransformation implements ASTTransformation, Opcodes {
         }
         body.addStatement(append(result, new ConstantExpression(")")));
         body.addStatement(new ReturnStatement(new MethodCallExpression(result, "toString", MethodCallExpression.NO_ARGUMENTS)));
-        cNode.addMethod(new MethodNode("toString", ACC_PUBLIC, ClassHelper.STRING_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, body));
+        cNode.addMethod(new MethodNode(hasExistingToString ? "_toString" : "toString", hasExistingToString ? ACC_PRIVATE : ACC_PUBLIC,
+                ClassHelper.STRING_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, body));
     }
 
     private Statement toStringPropertyName(Expression result, String fName) {
@@ -204,6 +225,10 @@ public class ImmutableASTTransformation implements ASTTransformation, Opcodes {
     }
 
     private void createEquals(ClassNode cNode) {
+        // make a public method if none exists otherwise try a private method with leading underscore
+        boolean hasExistingEquals = hasDeclaredMethod(cNode, "equals", 1);
+        if (hasExistingEquals && hasDeclaredMethod(cNode, "_equals", 1)) return;
+
         final BlockStatement body = new BlockStatement();
         Expression other = new VariableExpression("other");
 
@@ -222,7 +247,8 @@ public class ImmutableASTTransformation implements ASTTransformation, Opcodes {
         body.addStatement(new ReturnStatement(ConstantExpression.TRUE));
 
         Parameter[] params = {new Parameter(OBJECT_TYPE, "other")};
-        cNode.addMethod(new MethodNode("equals", ACC_PUBLIC, ClassHelper.boolean_TYPE, params, ClassNode.EMPTY_ARRAY, body));
+        cNode.addMethod(new MethodNode(hasExistingEquals ? "_equals" : "equals", hasExistingEquals ? ACC_PRIVATE : ACC_PUBLIC,
+                ClassHelper.boolean_TYPE, params, ClassNode.EMPTY_ARRAY, body));
     }
 
     private Statement returnFalseIfWrongType(ClassNode cNode, Expression other) {
@@ -490,11 +516,11 @@ public class ImmutableASTTransformation implements ASTTransformation, Opcodes {
     }
 
     private BooleanExpression isZeroExpr(Expression expr) {
-        return new BooleanExpression(new BinaryExpression(expr, COMPARE_EQUAL, new ConstantExpression(Integer.valueOf(0))));
+        return new BooleanExpression(new BinaryExpression(expr, COMPARE_EQUAL, new ConstantExpression(0)));
     }
 
     private BooleanExpression isOneExpr(Expression expr) {
-        return new BooleanExpression(new BinaryExpression(expr, COMPARE_EQUAL, new ConstantExpression(Integer.valueOf(1))));
+        return new BooleanExpression(new BinaryExpression(expr, COMPARE_EQUAL, new ConstantExpression(1)));
     }
 
     private BooleanExpression notEqualsExpr(PropertyNode pNode, Expression other) {
@@ -549,7 +575,8 @@ public class ImmutableASTTransformation implements ASTTransformation, Opcodes {
     }
 
     private static String createErrorMessage(String className, String fieldName, String typeName, String mode) {
-        return MY_TYPE_NAME + " processor doesn't know how to handle field '" + fieldName + "' of type '" + prettyTypeName(typeName) + "' while " + mode + " class " + className + ".\n" +
+        return MY_TYPE_NAME + " processor doesn't know how to handle field '" + fieldName + "' of type '" +
+                prettyTypeName(typeName) + "' while " + mode + " class " + className + ".\n" +
                 MY_TYPE_NAME + " classes currently only support properties with known immutable types " +
                 "or types where special handling achieves immutable behavior, including:\n" +
                 "- Strings, primitive types, wrapper types, BigInteger and BigDecimal\n" +
@@ -589,7 +616,7 @@ public class ImmutableASTTransformation implements ASTTransformation, Opcodes {
                 new ExpressionStatement(expression));
     }
 
-    public static Object checkImmutable(String className, String fieldName, Object field) {
+    private static Object checkImmutable(String className, String fieldName, Object field) {
         if (field == null || field instanceof Enum || inImmutableList(field.getClass())) return field;
         if (field instanceof Collection) return DefaultGroovyMethods.asImmutable((Collection) field);
         if (field.getClass().getAnnotation(MY_CLASS) != null) return field;
diff --git a/src/test/org/codehaus/groovy/transform/ImmutableTransformTest.groovy b/src/test/org/codehaus/groovy/transform/ImmutableTransformTest.groovy
index 49c8301317..0d601cfe05 100644
--- a/src/test/org/codehaus/groovy/transform/ImmutableTransformTest.groovy
+++ b/src/test/org/codehaus/groovy/transform/ImmutableTransformTest.groovy
@@ -90,4 +90,100 @@ class ImmutableTransformTest extends GroovyShellTestCase {
             assert new Other() != new This("foo")
         """
     }
+
+    void testExistingToString() {
+        assertScript """
+            @Immutable class Foo {
+                String value
+            }
+            @Immutable class Bar {
+                String value
+                String toString() { 'zzz' + _toString() }
+            }
+            @Immutable class Baz {
+                String value
+                String toString() { 'zzz' + _toString() }
+                def _toString() { 'xxx' }
+            }
+            def foo = new Foo('abc')
+            def bar = new Bar('abc')
+            def baz = new Baz('abc')
+            assert bar.toString() == 'zzz' + foo.toString().replaceAll('Foo', 'Bar')
+            assert baz.toString() == 'zzzxxx'
+        """
+    }
+
+    void testExistingEquals() {
+        assertScript """
+            @Immutable class Foo {
+                String value
+            }
+            @Immutable class Bar {
+                String value
+                // doesn't follow normal conventions - for testing only
+                boolean equals(other) { value == 'abc' || _equals(other) }
+            }
+            @Immutable class Baz {
+                String value
+                // doesn't follow normal conventions - for testing only
+                boolean equals(Baz other) { value == 'abc' || _equals(other) }
+                def _equals(other) { false }
+            }
+            def foo1 = new Foo('abc')
+            def foo2 = new Foo('abc')
+            def foo3 = new Foo('def')
+            assert foo1 == foo2
+            assert foo1 != foo3
+
+            def bar1 = new Bar('abc')
+            def bar2 = new Bar('abc')
+            def bar3 = new Bar('def')
+            def bar4 = new Bar('def')
+            assert bar1 == bar2
+            assert bar1 == bar3
+            assert bar3 != bar1
+
+            def baz1 = new Baz('abc')
+            def baz2 = new Baz('abc')
+            def baz3 = new Baz('def')
+            def baz4 = new Baz('def')
+            assert baz1 == baz2
+            assert baz1 == baz3
+            assert baz3 != baz1
+            assert baz3 != baz4
+        """
+    }
+
+    void testExistingHashCode() {
+        assertScript """
+            @Immutable class Foo {
+                String value
+            }
+            @Immutable class Bar {
+                String value
+                // doesn't follow normal conventions - for testing only
+                int hashCode() { value == 'abc' ? -1 : _hashCode() }
+            }
+            @Immutable class Baz {
+                String value
+                // doesn't follow normal conventions - for testing only
+                int hashCode() { value == 'abc' ? -1 : _hashCode() }
+                def _hashCode() { -100 }
+            }
+            def foo1 = new Foo('abc')
+            def foo2 = new Foo('abc')
+            assert foo1.hashCode() == foo2.hashCode()
+
+            def bar1 = new Bar('abc')
+            def bar2 = new Bar('def')
+            def bar3 = new Bar('def')
+            assert bar1.hashCode() == -1
+            assert bar2.hashCode() == bar3.hashCode()
+
+            def baz1 = new Baz('abc')
+            def baz2 = new Baz('def')
+            assert baz1.hashCode() == -1
+            assert baz2.hashCode() == -100
+        """
+    }
 }
\ No newline at end of file
