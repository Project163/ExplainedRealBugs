diff --git a/src/main/org/codehaus/groovy/control/ResolveVisitor.java b/src/main/org/codehaus/groovy/control/ResolveVisitor.java
index 1595a0cb62..3dddb18bee 100644
--- a/src/main/org/codehaus/groovy/control/ResolveVisitor.java
+++ b/src/main/org/codehaus/groovy/control/ResolveVisitor.java
@@ -554,13 +554,20 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
             }
             if (aliasedNode == null) {
                 importNode = module.getStaticImports().get(pname);
-                if (importNode != null && importNode != currImportNode && importNode.isStatic()) {
-                    aliasedNode = importNode.getType();
+                if (importNode != null && importNode != currImportNode) {
+                    // static alias only for inner classes and must be at end of chain
+                    ClassNode tmp = ClassHelper.make(importNode.getType().getName() + "$" + importNode.getFieldName());
+                    if (resolve(tmp, false, false, true)) {
+                        if ((tmp.getModifiers() & Opcodes.ACC_STATIC) != 0) {
+                            type.setRedirect(tmp.redirect());
+                            return true;
+                        }
+                    }
                 }
             }
 
             if (aliasedNode != null) {
-                if (pname.length() == name.length() && !importNode.isStatic()) {
+                if (pname.length() == name.length()) {
                     // full match
 
                     // We can compare here by length, because pname is always
@@ -577,8 +584,7 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
                     // Since we do not want to have useless lookups we create the name
                     // completely and use a ConstructedClassWithPackage to prevent lookups against the package.
                     String className = aliasedNode.getNameWithoutPackage() + '$' +
-                            (importNode.isStatic() ? pname :
-                                       name.substring(pname.length()+1).replace('.', '$'));
+                            name.substring(pname.length() + 1).replace('.', '$');
                     ConstructedClassWithPackage tmp = new ConstructedClassWithPackage(aliasedNode.getPackageName()+".", className);
                     if (resolve(tmp, true, true, false)) {
                         type.setRedirect(tmp.redirect());
@@ -637,11 +643,24 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
                 // compiler tries to find an inner class.
                 ConstructedClassWithPackage tmp =  new ConstructedClassWithPackage(module.getPackageName(),name);
                 if (resolve(tmp, false, false, false)) {
+                    ambiguousClass(type, tmp, name);
                     type.setRedirect(tmp.redirect());
                     return true;
                 }
             }
 
+            // check module static imports (for static inner classes)
+            for (ImportNode importNode : module.getStaticImports().values()) {
+                ClassNode tmp = ClassHelper.make(importNode.getType().getName() + "$" + name);
+                if (resolve(tmp, false, false, false)) {
+                    if ((tmp.getModifiers() & Opcodes.ACC_STATIC) != 0) {
+                        ambiguousClass(type, tmp, name);
+                        type.setRedirect(tmp.redirect());
+                        return true;
+                    }
+                }
+            }
+
             // check module node import packages
             for (ImportNode importNode : module.getStarImports()) {
                 String packagePrefix = importNode.getPackageName();
@@ -656,12 +675,14 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
                     return true;
                 }
             }
+
             // check for star imports (import static pkg.Outer.*) matching static inner classes
             for (ImportNode importNode : module.getStaticStarImports().values()) {
-                ClassNode node = ClassHelper.make(importNode.getType().getName() + "$" + name);
-                if (resolve(node, false, false, false)) {
-                    if ((node.getModifiers() & ~Opcodes.ACC_STATIC) != 0) {
-                        type.setRedirect(node.redirect());
+                ClassNode tmp = ClassHelper.make(importNode.getType().getName() + "$" + name);
+                if (resolve(tmp, false, false, false)) {
+                    if ((tmp.getModifiers() & Opcodes.ACC_STATIC) != 0) {
+                        ambiguousClass(type, tmp, name);
+                        type.setRedirect(tmp.redirect());
                         return true;
                     }
                 }
@@ -713,7 +734,7 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
         //TODO: the case of a NoClassDefFoundError needs a bit more research
         // a simple recompilation is not possible it seems. The current class
         // we are searching for is there, so we should mark that somehow.
-        // Basically the missing class needs to be completly compiled before
+        // Basically the missing class needs to be completely compiled before
         // we can again search for the current name.
         /*catch (NoClassDefFoundError ncdfe) {
             cachedClasses.put(name,SCRIPT);
diff --git a/src/test/Outer4.groovy b/src/test/Outer4.groovy
new file mode 100644
index 0000000000..fb1efd763f
--- /dev/null
+++ b/src/test/Outer4.groovy
@@ -0,0 +1,19 @@
+/*
+ * Copyright 2003-2010 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+class Outer4 {
+    // test class with no package and having a static inner class
+    static class Inner4 {}
+}
diff --git a/src/test/groovy/StaticImportTest.groovy b/src/test/groovy/StaticImportTest.groovy
index a34d83b226..6a85ca4689 100644
--- a/src/test/groovy/StaticImportTest.groovy
+++ b/src/test/groovy/StaticImportTest.groovy
@@ -31,7 +31,9 @@ import static groovy.StaticImportChild.*
 import static groovy.bugs.Groovy4145.foo4145
 import static groovy.Outer1.*
 import static groovy.Outer2.Inner2
+import static groovy.Outer2.Inner2 as InnerAlias2
 import static Outer3.*
+import static Outer4.Inner4
 import gls.CompilableTestSupport
 
 class StaticImportTest extends CompilableTestSupport {
@@ -267,17 +269,25 @@ class StaticImportTest extends CompilableTestSupport {
         '''
     }
 
-    void testStaticStarImportOfStaticInnerClasses() {
+    void testStaticStarImportOfStaticInnerClass() {
         assert Inner1.class.name == 'groovy.Outer1$Inner1'
     }
 
-    void testStaticImportOfStaticInnerClasses() {
+    void testStaticImportOfStaticInnerClass() {
         assert Inner2.class.name == 'groovy.Outer2$Inner2'
     }
 
-    void testStaticStarImportOfStaticInnerClassesExternalClass() {
+    void testStaticImportOfStaticInnerClassWithAlias() {
+        assert InnerAlias2.class.name == 'groovy.Outer2$Inner2'
+    }
+
+    void testStaticStarImportOfStaticInnerClassExternalClass() {
         assert Inner3.class.name == 'Outer3$Inner3'
     }
+
+    void testStaticImportOfStaticInnerClassExternalClass() {
+        assert Inner4.class.name == 'Outer4$Inner4'
+    }
 }
 
 class API {
