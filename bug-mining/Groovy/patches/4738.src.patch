diff --git a/src/main/java/org/codehaus/groovy/ast/tools/WideningCategories.java b/src/main/java/org/codehaus/groovy/ast/tools/WideningCategories.java
index d7ba138ff5..01cd514e2b 100644
--- a/src/main/java/org/codehaus/groovy/ast/tools/WideningCategories.java
+++ b/src/main/java/org/codehaus/groovy/ast/tools/WideningCategories.java
@@ -245,7 +245,7 @@ public class WideningCategories {
         // it according to the types provided by the two class nodes
         ClassNode holderForA = findGenericsTypeHolderForClass(a, lub);
         ClassNode holderForB = findGenericsTypeHolderForClass(b, lub);
-        // let's compare their generics type
+        // let's compare their generics
         GenericsType[] agt = holderForA == null ? null : holderForA.getGenericsTypes();
         GenericsType[] bgt = holderForB == null ? null : holderForB.getGenericsTypes();
         if (agt == null || bgt == null || agt.length != bgt.length) {
@@ -349,32 +349,25 @@ public class WideningCategories {
         boolean isInterfaceA = a.isInterface();
         boolean isInterfaceB = b.isInterface();
         if (isInterfaceA && isInterfaceB) {
-            if (a.equals(b)) return a;
-            if (b.implementsInterface(a)) {
+            if (a.equals(b) || b.implementsInterface(a)) {
                 return a;
             }
             if (a.implementsInterface(b)) {
                 return b;
             }
-            // each interface may have one or more "extends", so we must find those
-            // which are common
-            ClassNode[] interfacesFromA = a.getInterfaces();
-            ClassNode[] interfacesFromB = b.getInterfaces();
-            Set<ClassNode> common = new HashSet<>();
-            Collections.addAll(common, interfacesFromA);
-            Set<ClassNode> fromB = new HashSet<>();
-            Collections.addAll(fromB, interfacesFromB);
-            common.retainAll(fromB);
+
+            // GROOVY-11189: find common interface(s)
+            interfacesImplementedByA = GeneralUtils.getInterfacesAndSuperInterfaces(a);
+            interfacesImplementedByB = GeneralUtils.getInterfacesAndSuperInterfaces(b);
+            Collection<ClassNode> common = keepLowestCommonInterfaces(interfacesImplementedByA, interfacesImplementedByB);
 
             if (common.size() == 1) {
                 return common.iterator().next();
             } else if (common.size() > 1) {
                 return buildTypeWithInterfaces(a, b, common);
+            } else {
+                return OBJECT_TYPE; // no common interface, so Object is implied
             }
-
-            // we have two interfaces, but none inherits from the other
-            // so the only possible return type is Object
-            return OBJECT_TYPE;
         } else if (isInterfaceB) {
             return lowestUpperBound(b, a, null, null);
         } else if (isInterfaceA) {
diff --git a/src/test/org/codehaus/groovy/ast/tools/WideningCategoriesTest.groovy b/src/test/org/codehaus/groovy/ast/tools/WideningCategoriesTest.groovy
index 6af94aba2e..18ddd66165 100644
--- a/src/test/org/codehaus/groovy/ast/tools/WideningCategoriesTest.groovy
+++ b/src/test/org/codehaus/groovy/ast/tools/WideningCategoriesTest.groovy
@@ -60,7 +60,14 @@ final class WideningCategoriesTest extends GenericsTestCase {
         assert lowestUpperBound(a,b) == SERIALIZABLE_TYPE
     }
 
-    void testBuildCommonTypeWithOneInterfaceInheritsFromOther() {
+    void testBuildCommonTypeWithDivergentInterfaces() {
+        ClassNode a = SET_TYPE
+        ClassNode b = LIST_TYPE
+        assert lowestUpperBound(a,b) == COLLECTION_TYPE
+        assert lowestUpperBound(b,a) == COLLECTION_TYPE
+    }
+
+    void testBuildCommonTypeWithOneInterfaceExtendsOther() {
         ClassNode a = SET_TYPE
         ClassNode b = make(SortedSet)
         assert lowestUpperBound(a,b) == SET_TYPE
@@ -134,6 +141,14 @@ final class WideningCategoriesTest extends GenericsTestCase {
         assert lowestUpperBound(b,a) == make(InterfaceA)
     }
 
+    // GROOVY-11189
+    void testBuildCommonTypeWithTwoInterfacesSharingOneParent2() {
+        ClassNode a = make(InterfaceCCA)
+        ClassNode b = make(InterfaceDDA)
+        assert lowestUpperBound(a,b) == make(InterfaceA)
+        assert lowestUpperBound(b,a) == make(InterfaceA)
+    }
+
     void testBuildCommonTypeWithTwoInterfacesSharingTwoParents() {
         ClassNode a = make(InterfaceCAB)
         ClassNode b = make(InterfaceDAB)
@@ -357,6 +372,8 @@ final class WideningCategoriesTest extends GenericsTestCase {
     private static interface InterfaceE {}
     private static interface InterfaceCA extends InterfaceA {}
     private static interface InterfaceDA extends InterfaceA {}
+    private static interface InterfaceCCA extends InterfaceCA {}
+    private static interface InterfaceDDA extends InterfaceDA {}
     private static interface InterfaceCAB extends InterfaceA, InterfaceB {}
     private static interface InterfaceDAB extends InterfaceA, InterfaceB {}
     private static interface InterfaceDABE extends InterfaceA, InterfaceB, InterfaceE {}
