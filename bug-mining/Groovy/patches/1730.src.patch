diff --git a/src/main/groovy/sql/GroovyRowResult.java b/src/main/groovy/sql/GroovyRowResult.java
index 474df6fee2..ec6b4d3712 100644
--- a/src/main/groovy/sql/GroovyRowResult.java
+++ b/src/main/groovy/sql/GroovyRowResult.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2007 the original author or authors.
+ * Copyright 2003-2012 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -15,6 +15,7 @@
  */
 package groovy.sql;
 
+import groovy.lang.GString;
 import groovy.lang.GroovyObjectSupport;
 import groovy.lang.MissingPropertyException;
 
@@ -47,20 +48,14 @@ public class GroovyRowResult extends GroovyObjectSupport implements Map {
      */
     public Object getProperty(String property) {
         try {
+            // try to match with exact case first for efficiency
             Object value = result.get(property);
-            if (value != null)
+            if (value != null || result.containsKey(property))
                 return value;
-            // if property exists and value is null, return null
-            if (result.containsKey(property))
-                return null;
-            // with some databases/drivers, the columns names are stored uppercase.
-            String propertyUpper = property.toUpperCase();
-            value = result.get(propertyUpper);
-            if (value != null)
+            // now try again ignoring case to cater for how some databases/drivers store column names.
+            value = getPropertyIgnoringCase(property);
+            if (value != null || containsKey(property))
                 return value;
-            // if property exists and value is null, return null
-            if (result.containsKey(propertyUpper)) 
-                return null;
             throw new MissingPropertyException(property, GroovyRowResult.class);
         }
         catch (Exception e) {
@@ -68,6 +63,16 @@ public class GroovyRowResult extends GroovyObjectSupport implements Map {
         }
     }
 
+    private Object getPropertyIgnoringCase(String property) {
+        for (Object key : result.keySet()) {
+            if (!(key instanceof String))
+                continue;
+            if (property.equalsIgnoreCase((String)key))
+                return result.get(key);
+        }
+        return null;
+    }
+
     /**
      * Retrieve the value of the property by its index.
      * A negative index will count backwards from the last column.
@@ -90,7 +95,7 @@ public class GroovyRowResult extends GroovyObjectSupport implements Map {
                     it.next();
                 i++;
             }
-            return (obj);
+            return obj;
         }
         catch (Exception e) {
             throw new MissingPropertyException(Integer.toString(index), GroovyRowResult.class, e);
@@ -98,12 +103,12 @@ public class GroovyRowResult extends GroovyObjectSupport implements Map {
     }
 
     public String toString() {
-        return (result.toString());
+        return result.toString();
     }
 
     /*
      * The following methods are needed for implementing the Map interface.
-     * They are just delegating the request to the internal LinkedHashMap
+     * They are mostly delegating the request to the provided Map.
      */
      
     public void clear() {
@@ -111,7 +116,17 @@ public class GroovyRowResult extends GroovyObjectSupport implements Map {
     }
 
     public boolean containsKey(Object key) {
-        return result.containsKey(key);
+        // first look for exact case for efficiency
+        if (result.containsKey(key)) return true;
+        // now try again ignoring case
+        for (Object next : result.keySet()) {
+            if (!(next instanceof String) && !(key instanceof String || key instanceof GString))
+                continue;
+            if (key.toString().equalsIgnoreCase((String) next)) {
+                return true;
+            }
+        }
+        return false;
     }
 
     public boolean containsValue(Object value) {
@@ -129,8 +144,7 @@ public class GroovyRowResult extends GroovyObjectSupport implements Map {
     public Object get(Object property) {
         if (property instanceof String)
             return getProperty((String)property);
-        else
-            return null;
+        return null;
     }
 
     public int hashCode() {
diff --git a/src/test/groovy/sql/GroovyRowResultTest.groovy b/src/test/groovy/sql/GroovyRowResultTest.groovy
index 1f27a9d299..ab0de1db45 100644
--- a/src/test/groovy/sql/GroovyRowResultTest.groovy
+++ b/src/test/groovy/sql/GroovyRowResultTest.groovy
@@ -1,116 +1,117 @@
+/*
+ * Copyright 2003-2012 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package groovy.sql
 
-import java.util.LinkedHashMap
-
 class GroovyRowResultTest extends GroovyTestCase {
 
     void testMap() {
         def row = createRow();
         def row2 = createRow();
-        
+
         /**
          * Test for implementing Map
-         */ 
-        assert row instanceof Map, "GroovyRowResult doesn't implement Map interface"
-        
+         */
+        assert row instanceof Map, "BUG! GroovyRowResult doesn't implement Map!"
+
         /**
          * Test for put and accessing the new property
-         */ 
-        row.put("john","Doe")
-        assert row.john=="Doe"
-        assert row["john"]=="Doe"
-        assert row['john']=='Doe'
+         */
+        row.put("john", "Doe")
+        assert row.john == "Doe"
+        assert row["john"] == "Doe"
+        assert row['john'] == 'Doe'
         assert row.containsKey("john")
+        assert row.containsKey("JOHN")
+        assert row.containsKey("John")
         assert !row2.containsKey("john")
         assert row.containsValue("Doe")
         assert !row2.containsKey("Doe")
 
         /**
          * Test for equality (1) and size
-         */ 
-        assert row!=row2, "rows unexpectedly equal"
-        assert row.size()==7
-        assert row2.size()==6
-        
+         */
+        assert row != row2, "rows unexpectedly equal"
+        assert row.size() == 7
+        assert row2.size() == 6
+
         /**
          * Test for remove, equality (2) and isEmpty (1)
-         */ 
-        row.remove("john")        
-        assert row==row2, "rows different after remove"
+         */
+        row.remove("john")
+        assert row == row2, "rows different after remove"
         assert !row.isEmpty(), "row empty after remove"
-        
+
         /**
          * Test for clear, equality (3) and isEmpty (2)
-         */ 
+         */
         row.clear()
         row2.clear()
-        assert row==row2, "rows different after clear"
+        assert row == row2, "rows different after clear"
         assert row.isEmpty(), "row not empty after clear"
     }
-    
+
     void testProperties() {
         def row = createRow()
         assert row.miXed == "quick"
+        assert row.mixed == "quick"
         assert row.lower == "brown"
+        assert row.LOWER == "brown"
         assert row.upper == "fox"
         assert row.UPPER == "fox"
-        
-        try {
-            assert row.LOWER == "brown"
-            assert false
-        } catch (MissingPropertyException mpe) {
-        } catch (Exception e) {
-            assert false
-        }
 
-        try {
-            println row.foo
-            assert false
-        } catch (MissingPropertyException mpe) {
-        } catch (Exception e) {
-            assert false
+        shouldFail(MissingPropertyException) {
+            row.foo
         }
 
         /**
          * This is for GROOVY-1296
          */
-        assert row.nullMixed==null
-        assert row[1]==null
-        assert row.nulllower==null
-        assert row[3]==null
-        assert row.NULLUPPER==null
-        assert row[5]==null
-        
-    } 
-    
+        assert row.nullMixed == null
+        assert row[1] == null
+        assert row.nulllower == null
+        assert row[3] == null
+        assert row.NULLUPPER == null
+        assert row[5] == null
+
+    }
+
     void testOrder() {
         def row = createRow()
-        assert row[0] == "quick" 
-        assert row[1] == null 
-        assert row[2] == "brown" 
-        assert row[3] == null 
-        assert row[4] == "fox" 
-        assert row[5] == null 
-        assert row[27] == null 
-        assert row[-1] == null 
-        assert row[-2] == "fox" 
+        assert row[0] == "quick"
+        assert row[1] == null
+        assert row[2] == "brown"
+        assert row[3] == null
+        assert row[4] == "fox"
+        assert row[5] == null
+        assert row[27] == null
+        assert row[-1] == null
+        assert row[-2] == "fox"
     }
 
     protected def createRow() {
         def map = new LinkedHashMap()
-        assert map != null , "failed to load LinkedHashMap class"
-
         map.put("miXed", "quick")
         map.put("nullMixed", null)
         map.put("lower", "brown")
         map.put("nulllower", null)
         map.put("UPPER", "fox")
         map.put("NULLUPPER", null)
-
         def row = new GroovyRowResult(map)
-        assert row != null , "failed to load GroovyRowResult class"
-
+        assert row != null, "failed to load GroovyRowResult class"
         return row
     }
-    
+
 }
\ No newline at end of file
