diff --git a/subprojects/groovy-sql/src/main/java/groovy/sql/Sql.java b/subprojects/groovy-sql/src/main/java/groovy/sql/Sql.java
index b115ed813f..a896109332 100644
--- a/subprojects/groovy-sql/src/main/java/groovy/sql/Sql.java
+++ b/subprojects/groovy-sql/src/main/java/groovy/sql/Sql.java
@@ -27,6 +27,7 @@ import java.security.PrivilegedExceptionAction;
 import java.sql.CallableStatement;
 import java.sql.Connection;
 import java.sql.DriverManager;
+import java.sql.ParameterMetaData;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
@@ -39,6 +40,7 @@ import java.util.regex.Pattern;
 
 import javax.sql.DataSource;
 
+import groovy.lang.MissingPropertyException;
 import groovy.lang.Tuple;
 import org.codehaus.groovy.runtime.InvokerHelper;
 
@@ -4106,6 +4108,14 @@ public class Sql {
      */
     protected void setParameters(List<Object> params, PreparedStatement statement) throws SQLException {
         int i = 1;
+        ParameterMetaData metaData = statement.getParameterMetaData();
+        if (metaData.getParameterCount() == 0 && params.size() == 1 && params.get(0) instanceof Map) {
+            Map paramsMap = (Map) params.get(0);
+            if (paramsMap.isEmpty()) return;
+        }
+        if (metaData.getParameterCount() != params.size()) {
+            throw new IllegalArgumentException("Found " + metaData.getParameterCount() + " parameter placeholders but supplied with " + params.size() + " parameters");
+        }
         for (Object value : params) {
             setObject(statement, i++, value);
         }
@@ -4444,7 +4454,11 @@ public class Sql {
             String prop = (String) tuple.get(1);
             if (index < 0 || index >= params.size())
                 throw new IllegalArgumentException("Invalid index " + index + " should be in range 1.." + params.size());
-            updatedParams.add(prop.equals("<this>") ? params.get(index) : InvokerHelper.getProperty(params.get(index), prop));
+            try {
+                updatedParams.add(prop.equals("<this>") ? params.get(index) : InvokerHelper.getProperty(params.get(index), prop));
+            } catch(MissingPropertyException mpe) {
+                throw new IllegalArgumentException("Property '" + prop + "' not found for parameter " + index);
+            }
         }
         return updatedParams;
     }
diff --git a/subprojects/groovy-sql/src/test/groovy/groovy/sql/SqlCompleteTest.groovy b/subprojects/groovy-sql/src/test/groovy/groovy/sql/SqlCompleteTest.groovy
index b1c1176e0c..7ee8705fd4 100644
--- a/subprojects/groovy-sql/src/test/groovy/groovy/sql/SqlCompleteTest.groovy
+++ b/subprojects/groovy-sql/src/test/groovy/groovy/sql/SqlCompleteTest.groovy
@@ -141,6 +141,23 @@ class SqlCompleteTest extends SqlHelperTestCase {
         assert results == ["James": "Strachan", "Sam": "Pullara"]
     }
 
+    void testRowsWithEmptyMapParams() {
+        def results = sql.rows("select * from PERSON where firstname like '%am%' and lastname like '%a%'", [:])
+        assert results.collectEntries{ [it.firstname, it.lastname] } == ["James": "Strachan", "Sam": "Pullara"]
+    }
+
+    void testRowsWithIncorrectNumberOfParams() {
+        shouldFail(IllegalArgumentException) {
+            sql.rows("select * from PERSON where firstname like ? and lastname like ?", ['foo', 'bar', 'baz'])
+        }
+    }
+
+    void testRowsWithIncorrectParam() {
+        shouldFail(IllegalArgumentException) {
+            sql.rows("select * from PERSON where firstname like :x", ['foo'])
+        }
+    }
+
     void testEachRowWithStringAndClosure() {
         def results = [:]
         sql.eachRow("select * from PERSON", personMetaClosure) {
