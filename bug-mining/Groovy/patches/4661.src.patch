diff --git a/src/main/java/org/codehaus/groovy/transform/sc/transformers/BinaryExpressionTransformer.java b/src/main/java/org/codehaus/groovy/transform/sc/transformers/BinaryExpressionTransformer.java
index df458b6c2d..aa752eae75 100644
--- a/src/main/java/org/codehaus/groovy/transform/sc/transformers/BinaryExpressionTransformer.java
+++ b/src/main/java/org/codehaus/groovy/transform/sc/transformers/BinaryExpressionTransformer.java
@@ -232,12 +232,17 @@ public class BinaryExpressionTransformer {
     }
 
     private Expression transformInOperation(final BinaryExpression bin, final boolean in) {
+        MethodNode target = bin.getNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET);
+        if (target == null) return staticCompilationTransformer.superTransform(bin); // GROOVY-10915
         Expression leftExpression = bin.getLeftExpression(), rightExpression = bin.getRightExpression();
 
         // transform "left [!]in right" into "right.is[Not]Case(left)"
         MethodCallExpression call = callX(rightExpression, in ? "isCase" : "isNotCase", leftExpression);
-        call.setImplicitThis(false); call.setSourcePosition(bin); call.copyNodeMetaData(bin);
-        call.setMethodTarget(bin.getNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET));
+        call.setImplicitThis(false);
+        call.setMethodTarget(target);
+        call.setSourcePosition(bin);
+        call.copyNodeMetaData(bin);
+
         // GROOVY-7473: no null test for simple cases
         if (rightExpression instanceof ListExpression
                 || rightExpression instanceof MapExpression
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index fbd88efbc1..b63f6d9721 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -3769,20 +3769,17 @@ out:                if (mn.size() != 1) {
      * @return fixed return type if the selected method is {@link org.codehaus.groovy.runtime.DefaultGroovyMethods#withTraits(Object, Class[]) withTraits}
      */
     private static ClassNode adjustWithTraits(final MethodNode directMethodCallCandidate, final ClassNode receiver, final ClassNode[] args, final ClassNode returnType) {
-        if (directMethodCallCandidate instanceof ExtensionMethodNode) {
-            ExtensionMethodNode emn = (ExtensionMethodNode) directMethodCallCandidate;
-            if ("withTraits".equals(emn.getName()) && "DefaultGroovyMethods".equals(emn.getExtensionMethodNode().getDeclaringClass().getNameWithoutPackage())) {
-                List<ClassNode> nodes = new LinkedList<>();
-                Collections.addAll(nodes, receiver.getInterfaces());
-                for (ClassNode arg : args) {
-                    if (isClassClassNodeWrappingConcreteType(arg)) {
-                        nodes.add(arg.getGenericsTypes()[0].getType());
-                    } else {
-                        nodes.add(arg);
-                    }
+        if ("withTraits".equals(directMethodCallCandidate.getName()) && isDefaultExtension(directMethodCallCandidate)) {
+            List<ClassNode> nodes = new ArrayList<>();
+            Collections.addAll(nodes, receiver.getInterfaces());
+            for (ClassNode arg : args) {
+                if (isClassClassNodeWrappingConcreteType(arg)) {
+                    nodes.add(arg.getGenericsTypes()[0].getType());
+                } else {
+                    nodes.add(arg);
                 }
-                return new WideningCategories.LowestUpperBoundClassNode(returnType.getName() + "Composed", OBJECT_TYPE, nodes.toArray(ClassNode.EMPTY_ARRAY));
             }
+            return new WideningCategories.LowestUpperBoundClassNode(returnType.getName() + "Composed", OBJECT_TYPE, nodes.toArray(ClassNode.EMPTY_ARRAY));
         }
         return returnType;
     }
@@ -4518,6 +4515,12 @@ out:                if (mn.size() != 1) {
         }
         MethodNode method = findMethodOrFail(expr, left, operationName, right);
         if (method != null) {
+            if (op == COMPARE_NOT_IN && isDefaultExtension(method)) {
+                // GROOVY-10915: check if left implements its own isCase method
+                MethodNode isCase = findMethodOrFail(expr, left, "isCase", right);
+                if (isCase != null && !isDefaultExtension(isCase)) return null; // require dynamic dispatch
+            }
+
             storeTargetMethod(expr, method);
             typeCheckMethodsWithGenericsOrFail(left, new ClassNode[]{right}, method, expr);
 
@@ -4739,7 +4742,7 @@ out:                if (mn.size() != 1) {
         if ("use".equals(name) && args != null && args.length == 2 && args[1].equals(CLOSURE_TYPE)) {
             category = true;
             for (MethodNode method : foundMethods) {
-                if (!(method instanceof ExtensionMethodNode) || !((ExtensionMethodNode) method).getExtensionMethodNode().getDeclaringClass().equals(DGM_CLASSNODE)) {
+                if (!isDefaultExtension(method)) {
                     category = false;
                     break;
                 }
@@ -5593,6 +5596,10 @@ out:                if (mn.size() != 1) {
         return args;
     }
 
+    private static boolean isDefaultExtension(final MethodNode method) {
+        return method instanceof ExtensionMethodNode && ((ExtensionMethodNode) method).getExtensionMethodNode().getDeclaringClass().equals(DGM_CLASSNODE);
+    }
+
     private static boolean isGenericsPlaceHolderOrArrayOf(ClassNode cn) {
         while (cn.isArray()) cn = cn.getComponentType();
         return cn.isGenericsPlaceHolder();
diff --git a/src/test/groovy/transform/stc/STCnAryExpressionTest.groovy b/src/test/groovy/transform/stc/STCnAryExpressionTest.groovy
index 54e11ffdc9..67f4b06fcb 100644
--- a/src/test/groovy/transform/stc/STCnAryExpressionTest.groovy
+++ b/src/test/groovy/transform/stc/STCnAryExpressionTest.groovy
@@ -156,17 +156,31 @@ class STCnAryExpressionTest extends StaticTypeCheckingTestCase {
             class C {
                 int i = 0
                 int getA() { i++ }
-                boolean isCase(val) { true }
-                boolean isNotCase(val) { false }
-
-                void test() {
-                    assert !(a !in this)
-                    assert i == 1
-                    assert a in this
-                    assert i == 2
-                }
+                boolean isCase(obj) { true }
+                boolean isNotCase(obj) { false }
             }
-            new C().test()
+
+            new C().with { c ->
+                assert !(a !in c)
+                assert i == 1
+                assert a in c
+                assert i == 2
+            }
+        '''
+    }
+
+    // GROOVY-10915
+    void testInNotInAndUnaryNotOperatorConsistent() {
+        assertScript '''
+            class C {
+                boolean isCase(obj) { true }
+            }
+
+            def c = new C()
+            assert 0 in c
+            assert !!(0 in c)
+            assert !(0 !in c)
+            assert  (0 !in c) == false
         '''
     }
 
