diff --git a/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java b/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
index 33bac69e8c..e7b670f4aa 100644
--- a/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
+++ b/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
@@ -273,14 +273,13 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
     protected void visitConstructorOrMethod(final MethodNode node, final boolean isConstructor) {
         VariableScope oldScope = currentScope;
         currentScope = node.getVariableScope();
-        Map<GenericsTypeName, GenericsType> oldPNames = genericParameterNames;
+        Map<GenericsTypeName, GenericsType> oldNames = genericParameterNames;
         genericParameterNames = node.isStatic() && !Traits.isTrait(node.getDeclaringClass())
                 ? new HashMap<>() : new HashMap<>(genericParameterNames);
 
         resolveGenericsHeader(node.getGenericsTypes());
 
-        Parameter[] paras = node.getParameters();
-        for (Parameter p : paras) {
+        for (Parameter p : node.getParameters()) {
             p.setInitialExpression(transform(p.getInitialExpression()));
             resolveOrFail(p.getType(), p.getType());
             visitAnnotations(p);
@@ -297,7 +296,7 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
         super.visitConstructorOrMethod(node, isConstructor);
 
         currentMethod = oldCurrentMethod;
-        genericParameterNames = oldPNames;
+        genericParameterNames = oldNames;
         currentScope = oldScope;
     }
 
@@ -379,7 +378,6 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
         resolveGenericsTypes(genericsTypes);
 
         if (type.isPrimaryClassNode()) return true;
-        if (type.isResolved()) return true;
         if (type.isArray()) {
             ClassNode element = type.getComponentType();
             boolean resolved = resolve(element, testModuleImports, testDefaultImports, testStaticInnerClasses);
@@ -389,6 +387,7 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
             }
             return resolved;
         }
+        if (type.isResolved()) return true;
 
         String typeName = type.getName();
 
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
index 20484f4dd4..0a6bbbcd1d 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
@@ -1082,7 +1082,7 @@ public abstract class StaticTypeCheckingSupport {
                     Parameter p = parameters[i];
                     ClassNode t = p.getOriginType();
                     if (t.isGenericsPlaceHolder() || isUsingGenericsOrIsArrayUsingGenerics(t))
-                        parameters[i] = new Parameter(t.getPlainNodeReference(), p.getName());
+                        parameters[i] = new Parameter(GenericsUtils.nonGeneric(t), p.getName());
                 }
             }
 
@@ -1507,9 +1507,9 @@ public abstract class StaticTypeCheckingSupport {
     }
 
     private static boolean inferenceCheck(final Set<GenericsTypeName> fixedPlaceHolders, final Map<GenericsTypeName, GenericsType> resolvedMethodGenerics, ClassNode type, final ClassNode wrappedArgument, final boolean lastArg) {
-        // GROOVY-8090: handle generics varargs like "T x = ...; Arrays.asList(x)"
-        if (lastArg && type.isArray() && type.getComponentType().isGenericsPlaceHolder()
-                && !wrappedArgument.isArray() && wrappedArgument.isGenericsPlaceHolder()) {
+        // GROOVY-8090, GROOVY-11003: handle vararg generics like "T x = ...; Arrays.asList(x)"
+        if (lastArg && type.isArray() && dimensions(type) != dimensions(wrappedArgument)
+                && isUsingGenericsOrIsArrayUsingGenerics(type.getComponentType())) {
             type = type.getComponentType();
         }
         // the context we compare with in the end is the one of the callsite
@@ -1557,6 +1557,15 @@ public abstract class StaticTypeCheckingSupport {
         return !typeCheckMethodArgumentWithGenerics(resolvedType, wrappedArgument, lastArg);
     }
 
+    private static int dimensions(ClassNode cn) {
+        int dims = 0;
+        while (cn.isArray()) {
+            cn = cn.getComponentType();
+            dims += 1;
+        }
+        return dims;
+    }
+
     private static boolean compatibleConnection(final GenericsType resolved, final GenericsType connection) {
         if (resolved.isPlaceholder()
                 &&  resolved.getUpperBounds() != null
diff --git a/src/test/groovy/transform/stc/GenericsSTCTest.groovy b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
index 1373132734..29ff41d8eb 100644
--- a/src/test/groovy/transform/stc/GenericsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
@@ -3376,6 +3376,20 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
         '''
     }
 
+    // GROOVY-11003
+    void testCompatibleArgumentsForPlaceholders13() {
+        assertScript '''
+            def <T> void m(Integer x, java.util.List<T>... lists) {
+            }
+            void test(java.util.List<Integer> p) {
+                m(1, p)
+                m(2)
+            }
+
+            test([1,2,3])
+        '''
+    }
+
     void testIncompatibleArgumentsForPlaceholders1() {
         shouldFailWithMessages '''
             def <T extends Number> T test(T one, T two) { }
