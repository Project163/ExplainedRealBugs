diff --git a/src/main/org/codehaus/groovy/runtime/metaclass/ClosureMetaMethod.java b/src/main/org/codehaus/groovy/runtime/metaclass/ClosureMetaMethod.java
index 7d49baf756..5b6dd06674 100644
--- a/src/main/org/codehaus/groovy/runtime/metaclass/ClosureMetaMethod.java
+++ b/src/main/org/codehaus/groovy/runtime/metaclass/ClosureMetaMethod.java
@@ -99,7 +99,8 @@ public class ClosureMetaMethod extends MetaMethod implements ClosureInvokingMeth
             Class ownerClass = (Class) (owner instanceof Class ? owner : owner.getClass());
             for (CachedMethod method : ReflectionCache.getCachedClass(ownerClass).getMethods() ) {
                 if (method.getName().equals(methodClosure.getMethod())) {
-                    res.add(new MethodClosureMetaMethod(name, declaringClass, closure, method));
+                	MetaMethod metaMethod = new MethodClosureMetaMethod(name, declaringClass, closure, method); 
+                	res.add(adjustParamTypesForStdMethods(metaMethod, name));
                 }
             }
         }
@@ -107,12 +108,14 @@ public class ClosureMetaMethod extends MetaMethod implements ClosureInvokingMeth
             if (closure instanceof GeneratedClosure) {
                 for (CachedMethod method : ReflectionCache.getCachedClass(closure.getClass()).getMethods() ) {
                     if (method.getName().equals("doCall")) {
-                        res.add(new ClosureMetaMethod(name, declaringClass, closure, method));
+                    	MetaMethod metaMethod = new ClosureMetaMethod(name, declaringClass, closure, method);
+                    	res.add(adjustParamTypesForStdMethods(metaMethod, name));
                     }
                 }
             }
             else {
-                res.add(new MetaMethod(closure.getParameterTypes()){
+            	MetaMethod metaMethod = 
+            	new MetaMethod(closure.getParameterTypes()){
                     public int getModifiers() {
                         return Modifier.PUBLIC;
                     }
@@ -135,12 +138,23 @@ public class ClosureMetaMethod extends MetaMethod implements ClosureInvokingMeth
                         arguments = coerceArgumentsToClasses(arguments);
                         return InvokerHelper.invokeMethod(closure, "call", arguments);
                     }
-                });
+                };
+                res.add(adjustParamTypesForStdMethods(metaMethod, name));
             }
         }
         return res;
     }
-
+    
+    private static MetaMethod adjustParamTypesForStdMethods(MetaMethod metaMethod, String methodName) {
+    	Class[] nativeParamTypes = metaMethod.getNativeParameterTypes();
+    	nativeParamTypes = (nativeParamTypes != null) ? nativeParamTypes : new Class[0];
+    	// for methodMissing, first parameter should be String type - to allow overriding of this method without
+    	// type String explicitly specified for first parameter (missing method name) - GROOVY-2951
+    	if("methodMissing".equals(methodName) && nativeParamTypes.length == 2 && nativeParamTypes[0] != String.class) {
+    		nativeParamTypes[0] = String.class;
+    	}
+    	return metaMethod;
+    }
     public CachedMethod getDoCall() {
         return doCall;
     }
diff --git a/src/test/groovy/bugs/Groovy2951Bug.groovy b/src/test/groovy/bugs/Groovy2951Bug.groovy
new file mode 100644
index 0000000000..99ec05f764
--- /dev/null
+++ b/src/test/groovy/bugs/Groovy2951Bug.groovy
@@ -0,0 +1,35 @@
+class Groovy2951Bug extends GroovyTestCase{
+    def void testInstanceLevelMissingMethodWithRegularClosure1() {
+        Groovy2951BugClass1.metaClass.methodMissing = {
+            method, args ->
+            return method
+        }
+        def result = new Groovy2951BugClass1().test1("arg1", "arg2")
+        assert result == "test1"
+    }
+
+    def void testInstanceLevelMissingMethodWithRegularClosure2() {
+        Groovy2951BugClass2.metaClass.methodMissing << { method, args ->
+            return method
+        }
+        def result = new Groovy2951BugClass2().test2("arg1", "arg2")
+        assert result == "test2"
+    }
+
+    def void testInstanceLevelMissingMethodWithMethodClosure() {
+        Groovy2951BugClass3.metaClass.methodMissing = Groovy2951BugClass3.&mm
+
+        def result = new Groovy2951BugClass3().test3("arg3", "arg4")
+        assert result == "test3"
+    }
+}
+
+class Groovy2951BugClass1 {}
+
+class Groovy2951BugClass2 {}
+
+class Groovy2951BugClass3 {
+    static def mm(method, args) {
+        return method
+    }	
+}
