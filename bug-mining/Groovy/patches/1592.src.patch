diff --git a/src/main/groovy/lang/MetaClassImpl.java b/src/main/groovy/lang/MetaClassImpl.java
index 1caad88c72..9d16887ee2 100644
--- a/src/main/groovy/lang/MetaClassImpl.java
+++ b/src/main/groovy/lang/MetaClassImpl.java
@@ -31,7 +31,6 @@ import org.codehaus.groovy.reflection.ReflectionCache;
 import org.codehaus.groovy.runtime.ConvertedClosure;
 import org.codehaus.groovy.runtime.CurriedClosure;
 import org.codehaus.groovy.runtime.DefaultGroovyMethods;
-import org.codehaus.groovy.runtime.GeneratedClosure;
 import org.codehaus.groovy.runtime.GroovyCategorySupport;
 import org.codehaus.groovy.runtime.InvokerHelper;
 import org.codehaus.groovy.runtime.InvokerInvocationException;
@@ -77,6 +76,7 @@ import java.lang.reflect.Modifier;
 import java.lang.reflect.Proxy;
 import java.net.URL;
 import java.security.AccessController;
+import java.security.PrivilegedAction;
 import java.security.PrivilegedActionException;
 import java.security.PrivilegedExceptionAction;
 import java.util.ArrayList;
@@ -893,24 +893,24 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
             throw new NullPointerException("Cannot invoke method: " + methodName + " on null object");
         }
 
-        String correctedMethodName = methodName;
-        if (object instanceof GeneratedClosure && CLOSURE_CALL_METHOD.equals(methodName)) {
-            correctedMethodName = CLOSURE_DO_CALL_METHOD;
-        }
-
         final Object[] arguments = originalArguments == null ? EMPTY_ARGUMENTS : originalArguments;
-        MetaMethod method = getMethodWithCaching(sender, correctedMethodName, arguments, isCallToSuper);
+//        final Class[] argClasses = MetaClassHelper.convertToTypeArray(arguments);
+//
+//        unwrap(arguments);
+
+        MetaMethod method = getMethodWithCaching(sender, methodName, arguments, isCallToSuper);
         MetaClassHelper.unwrap(arguments);
 
         if (method == null)
-            method = tryListParamMetaMethod(sender, correctedMethodName, isCallToSuper, arguments);
+            method = tryListParamMetaMethod(sender, methodName, isCallToSuper, arguments);
 
         final boolean isClosure = object instanceof Closure;
         if (isClosure) {
             final Closure closure = (Closure) object;
 
             final Object owner = closure.getOwner();
-            if (CLOSURE_DO_CALL_METHOD.equals(methodName) || CLOSURE_CALL_METHOD.equals(methodName)) {
+
+            if (CLOSURE_CALL_METHOD.equals(methodName) || CLOSURE_DO_CALL_METHOD.equals(methodName)) {
                 final Class objectClass = object.getClass();
                 if (objectClass == MethodClosure.class) {
                     final MethodClosure mc = (MethodClosure) object;
diff --git a/src/test/groovy/lang/ClosureMetaClassTest.groovy b/src/test/groovy/lang/ClosureMetaClassTest.groovy
deleted file mode 100644
index ae3f2d9967..0000000000
--- a/src/test/groovy/lang/ClosureMetaClassTest.groovy
+++ /dev/null
@@ -1,28 +0,0 @@
-package groovy.lang
-
-import groovy.util.GroovyTestCase
-import org.codehaus.groovy.runtime.metaclass.ClosureMetaClass
-
-class ClosureMetaClassTest extends GroovyTestCase {
-    
-    void testClosureMetaClass() {
-        Object[] myObjectArray = ['a', 'b'] as Object[]
-        def closure = {1}
-        assert closure.metaClass.getClass() == ClosureMetaClass.class
-        assert closure(myObjectArray) == 1
-    }    
-
-    void testMetaClassImpl() {
-        Object[] myObjectArray = ['a', 'b'] as Object[]
-        def closure = {1}
-        closure.metaClass == new MetaClassImpl(closure.getClass())
-        assert closure(myObjectArray) == 1
-    }
-    
-    void testEMC() {
-        Object[] myObjectArray = ['a', 'b'] as Object[]
-        def closure = {1}
-        closure.metaClass == new ExpandoMetaClass(closure.getClass())
-        assert closure(myObjectArray) == 1
-    }
-}
\ No newline at end of file
