diff --git a/src/main/groovy/lang/GroovyShell.java b/src/main/groovy/lang/GroovyShell.java
index 2b21442e0e..0dd31a6917 100644
--- a/src/main/groovy/lang/GroovyShell.java
+++ b/src/main/groovy/lang/GroovyShell.java
@@ -365,7 +365,7 @@ public class GroovyShell extends GroovyObjectSupport {
      */
     private Object runTest(Class scriptClass) {
         try {
-            Object testSuite = InvokerHelper.invokeConstructor("junit.framework.TestSuite",new Object[]{scriptClass});
+            Object testSuite = InvokerHelper.invokeConstructorOf("junit.framework.TestSuite",new Object[]{scriptClass});
             return InvokerHelper.invokeStaticMethod("junit.textui.TestRunner", "run", new Object[]{testSuite});
         } catch (Exception e) {
             throw new GroovyRuntimeException("Failed to run the unit test. JUnit is not on the Classpath.");
diff --git a/src/main/groovy/lang/MetaClass.java b/src/main/groovy/lang/MetaClass.java
index 74cc980512..2f8a2ffe0e 100644
--- a/src/main/groovy/lang/MetaClass.java
+++ b/src/main/groovy/lang/MetaClass.java
@@ -611,6 +611,36 @@ public class MetaClass {
                        + "("+InvokerHelper.toTypeString(arguments)+")");
    }
 
+   public Object invokeConstructorAt(Class at, Object[] arguments) {
+       Class[] argClasses = convertToTypeArray(arguments);
+       Constructor constructor = (Constructor) chooseMethod("<init>", constructors, argClasses, false);
+       if (constructor != null) {
+           return doConstructorInvokeAt(at, constructor, arguments);
+       }
+       else {
+           constructor = (Constructor) chooseMethod("<init>", constructors, argClasses, true);
+           if (constructor != null) {
+               return doConstructorInvokeAt(at, constructor, arguments);
+           }
+       }
+
+       if (arguments.length == 1) {
+           Object firstArgument = arguments[0];
+           if (firstArgument instanceof Map) {
+               constructor = (Constructor) chooseMethod("<init>", constructors, EMPTY_TYPE_ARRAY, false);
+               if (constructor != null) {
+                   Object bean = doConstructorInvokeAt(at, constructor, EMPTY_ARRAY);
+                   setProperties(bean, ((Map) firstArgument));
+                   return bean;
+               }
+           }
+       }
+       throw new GroovyRuntimeException(
+                   "Could not find matching constructor for: "
+                       + theClass.getName()
+                       + "("+InvokerHelper.toTypeString(arguments)+")");
+   }
+
    /**
     * Sets a number of bean properties from the given Map where the keys are
     * the String names of properties and the values are the values of the
@@ -1804,6 +1834,131 @@ public class MetaClass {
        }
    }
 
+   protected Object doConstructorInvokeAt(final Class at, Constructor constructor, Object[] argumentArray) {
+       if (log.isLoggable(Level.FINER)) {
+           logMethodCall(constructor.getDeclaringClass(), constructor.getName(), argumentArray);
+       }
+
+       try {
+           // To fix JIRA 435
+           // Every constructor should be opened to the accessible classes.
+           final boolean accessible = accessibleToConstructor(at, constructor);
+
+           final Constructor ctor = constructor;
+           AccessController.doPrivileged(new PrivilegedAction() {
+               public Object run() {
+                   ctor.setAccessible(accessible);
+                   return null;
+               }
+           });
+           // end of patch
+
+           return constructor.newInstance(argumentArray);
+       }
+       catch (InvocationTargetException e) {
+           /*Throwable t = e.getTargetException();
+           if (t instanceof Error) {
+               Error error = (Error) t;
+               throw error;
+           }
+           if (t instanceof RuntimeException) {
+               RuntimeException runtimeEx = (RuntimeException) t;
+               throw runtimeEx;
+           }*/
+           throw new InvokerInvocationException(e);
+       }
+       catch (IllegalArgumentException e) {
+           if (coerceGStrings(argumentArray)) {
+               try {
+                   return constructor.newInstance(argumentArray);
+               }
+               catch (Exception e2) {
+                   // allow fall through
+               }
+           }
+           throw new GroovyRuntimeException(
+               "failed to invoke constructor: "
+                   + constructor
+                   + " with arguments: "
+                   + InvokerHelper.toString(argumentArray)
+                   + " reason: "
+                   + e);
+       }
+       catch (IllegalAccessException e) {
+           throw new GroovyRuntimeException(
+               "could not access constructor: "
+                   + constructor
+                   + " with arguments: "
+                   + InvokerHelper.toString(argumentArray)
+                   + " reason: "
+                   + e);
+       }
+       catch (Exception e) {
+           throw new GroovyRuntimeException(
+               "failed to invoke constructor: "
+                   + constructor
+                   + " with arguments: "
+                   + InvokerHelper.toString(argumentArray)
+                   + " reason: "
+                   + e,
+                   e);
+       }
+   }
+
+   protected boolean accessibleToConstructor(final Class at, final Constructor constructor) {
+       boolean accessible = false;
+       if (Modifier.isPublic(constructor.getModifiers())) {
+           accessible = true;
+       }
+       else if (Modifier.isPrivate(constructor.getModifiers())) {
+           accessible = at.getName().equals(constructor.getName());
+       }
+       else if ( Modifier.isProtected(constructor.getModifiers()) ) {
+           if ( at.getPackage() == null && constructor.getDeclaringClass().getPackage() == null ) {
+               accessible = true;
+           }
+           else if ( at.getPackage() == null && constructor.getDeclaringClass().getPackage() != null ) {
+               accessible = false;
+           }
+           else if ( at.getPackage() != null && constructor.getDeclaringClass().getPackage() == null ) {
+               accessible = false;
+           }
+           else if ( at.getPackage().equals(constructor.getDeclaringClass().getPackage()) ) {
+               accessible = true;
+           }
+           else {
+               boolean flag = false;
+               Class clazz = at;
+               while ( !flag && clazz != null ) {
+                   if (clazz.equals(constructor.getDeclaringClass()) ) {
+                       flag = true;
+                       break;
+                   }
+                   if (clazz.equals(Object.class) ) {
+                       break;
+                   }
+                   clazz = clazz.getSuperclass();
+               }
+               accessible = flag;
+           }
+       }
+       else {
+           if ( at.getPackage() == null && constructor.getDeclaringClass().getPackage() == null ) {
+               accessible = true;
+           }
+           else if ( at.getPackage() == null && constructor.getDeclaringClass().getPackage() != null ) {
+               accessible = false;
+           }
+           else if ( at.getPackage() != null && constructor.getDeclaringClass().getPackage() == null ) {
+               accessible = false;
+           }
+           else if ( at.getPackage().equals(constructor.getDeclaringClass().getPackage()) ) {
+               accessible = true;
+           }
+       }
+       return accessible;
+   }
+
    /**
     * Chooses the correct method to use from a list of methods which match by
     * name.
diff --git a/src/main/groovy/lang/ProxyMetaClass.java b/src/main/groovy/lang/ProxyMetaClass.java
index 4a744f3499..a171f13fbc 100644
--- a/src/main/groovy/lang/ProxyMetaClass.java
+++ b/src/main/groovy/lang/ProxyMetaClass.java
@@ -111,6 +111,14 @@ public class ProxyMetaClass extends MetaClass {
         });
     }
 
+    public Object invokeConstructorAt(final Class at, final Object[] arguments) {
+        return doCall(theClass, "ctor", arguments, new Callable() {
+            public Object call() {
+                return adaptee.invokeConstructorAt(at, arguments);
+            }
+        });
+    }
+
     // since Java has no Closures...
     private interface Callable{
         Object call();
diff --git a/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java b/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
index 54ff9bd82d..f33b98105b 100644
--- a/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
+++ b/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
@@ -139,6 +139,8 @@ public class AsmClassGenerator extends ClassGenerator {
     MethodCaller invokeConstructorMethod = MethodCaller.newStatic(ScriptBytecodeAdapter.class, "invokeConstructor");
     MethodCaller invokeConstructorOfMethod = MethodCaller.newStatic(ScriptBytecodeAdapter.class, "invokeConstructorOf");
     MethodCaller invokeNoArgumentsConstructorOf = MethodCaller.newStatic(ScriptBytecodeAdapter.class, "invokeNoArgumentsConstructorOf");
+    MethodCaller invokeConstructorAtMethod = MethodCaller.newStatic(ScriptBytecodeAdapter.class, "invokeConstructorAt");
+    MethodCaller invokeNoArgumentsConstructorAt = MethodCaller.newStatic(ScriptBytecodeAdapter.class, "invokeNoArgumentsConstructorAt");
     MethodCaller invokeClosureMethod = MethodCaller.newStatic(ScriptBytecodeAdapter.class, "invokeClosure");
     MethodCaller invokeSuperMethodMethod = MethodCaller.newStatic(ScriptBytecodeAdapter.class, "invokeSuperMethod");
     MethodCaller invokeNoArgumentsMethod = MethodCaller.newStatic(ScriptBytecodeAdapter.class, "invokeNoArgumentsMethod");
@@ -1708,15 +1710,49 @@ public class AsmClassGenerator extends ClassGenerator {
         type = classNode.resolveClassName(type, "");
         call.setType(type);
         
-        visitClassExpression(new ClassExpression(type));
-        if (arguments !=null) {
-               arguments.visit(this);
-            invokeConstructorOfMethod.call(cv);     // todo subject to opti
-        } else {
-            invokeNoArgumentsConstructorOf.call(cv); // todo subject to opti
+        if (this.classNode != null) {
+            // TODO: GROOVY-435
+            pushClassTypeArgument(this.classNode.getType(), this.classNode.getType());
+            pushClassTypeArgument(this.classNode.getType(), type);
+
+            if (arguments != null) {
+                arguments.visit(this);
+                invokeConstructorAtMethod.call(cv);
+            } else {
+                invokeNoArgumentsConstructorAt.call(cv);
+            }
+        }
+        else {
+            pushClassTypeArgument(this.classNode.getType(), type);
+
+            if (arguments !=null) {
+                arguments.visit(this);
+                invokeConstructorOfMethod.call(cv);
+            } else {
+                invokeNoArgumentsConstructorOf.call(cv);
+            }
         }
     }
     
+    protected void pushClassTypeArgument(final Type ownerType, final Type type) {
+        String staticFieldName = "class$" + type.getName().replace('.', '$').replace('[', '_').replace(';', '_');
+        String ownerName = ownerType.getName().replace('.','/');
+
+        syntheticStaticFields.add(staticFieldName);
+        cv.visitFieldInsn(GETSTATIC, ownerName, staticFieldName, "Ljava/lang/Class;");
+        Label l0 = new Label();
+        cv.visitJumpInsn(IFNONNULL, l0);
+        cv.visitLdcInsn(type.getName());
+        cv.visitMethodInsn(INVOKESTATIC, ownerName, "class$", "(Ljava/lang/String;)Ljava/lang/Class;");
+        cv.visitInsn(DUP);
+        cv.visitFieldInsn(PUTSTATIC, ownerName, staticFieldName, "Ljava/lang/Class;");
+        Label l1 = new Label();
+        cv.visitJumpInsn(GOTO, l1);
+        cv.visitLabel(l0);
+        cv.visitFieldInsn(GETSTATIC, ownerName, staticFieldName, "Ljava/lang/Class;");
+        cv.visitLabel(l1);
+    }
+    
     // TODO: move this check before any scope checks, but after we know all classes
     // iterate from the inner most to the outer and check for classes
     // this check will ignore a .class property, for Exmaple Integer.class will be
diff --git a/src/main/org/codehaus/groovy/runtime/Invoker.java b/src/main/org/codehaus/groovy/runtime/Invoker.java
index 13774b9ac0..5e8b73f99b 100644
--- a/src/main/org/codehaus/groovy/runtime/Invoker.java
+++ b/src/main/org/codehaus/groovy/runtime/Invoker.java
@@ -185,8 +185,13 @@ public class Invoker {
         return metaClass.invokeStaticMethod(null, method, asArray(arguments));
     }
 
-    public Object invokeConstructor(String type, Object arguments) {
-        return invokeConstructorOf(loadClass(type), arguments);
+    public Object invokeConstructorAt(Class at, Class type, Object arguments) {
+        MetaClass metaClass = metaRegistry.getMetaClass(type);
+        return metaClass.invokeConstructorAt(at, asArray(arguments));
+    }
+
+    public Object invokeConstructorAt(Class at, String type, Object arguments) {
+        return invokeConstructorAt(at, loadClass(type), arguments);
     }
 
     public Object invokeConstructorOf(Class type, Object arguments) {
@@ -194,6 +199,10 @@ public class Invoker {
         return metaClass.invokeConstructor(asArray(arguments));
     }
 
+    public Object invokeConstructorOf(String type, Object arguments) {
+        return invokeConstructorOf(loadClass(type), arguments);
+    }
+
     /**
      * Converts the given object into an array; if its an array then just
      * cast otherwise wrap it in an array
diff --git a/src/main/org/codehaus/groovy/runtime/InvokerHelper.java b/src/main/org/codehaus/groovy/runtime/InvokerHelper.java
index 4d2c6cc0f7..44e4078008 100644
--- a/src/main/org/codehaus/groovy/runtime/InvokerHelper.java
+++ b/src/main/org/codehaus/groovy/runtime/InvokerHelper.java
@@ -123,8 +123,20 @@ public class InvokerHelper {
         return getInstance().invokeStaticMethod(type, methodName, EMPTY_ARGS);
     }
 
-    public static Object invokeConstructor(String type, Object arguments) {
-        return getInstance().invokeConstructor(type, arguments);
+    public static Object invokeConstructorAt(Class at, Class type, Object arguments) {
+        return getInstance().invokeConstructorAt(at, type, arguments);
+    }
+
+    public static Object invokeConstructorAt(Class at, String type, Object arguments) {
+        return getInstance().invokeConstructorAt(at, type, arguments);
+    }
+
+    public static Object invokeNoArgumentsConstructorAt(Class at, Class type) {
+        return getInstance().invokeConstructorAt(at, type, EMPTY_ARGS);
+    }
+
+    public static Object invokeConstructorOf(String type, Object arguments) {
+        return getInstance().invokeConstructorOf(type, arguments);
     }
 
     public static Object invokeConstructorOf(Class type, Object arguments) {
diff --git a/src/main/org/codehaus/groovy/runtime/ScriptBytecodeAdapter.java b/src/main/org/codehaus/groovy/runtime/ScriptBytecodeAdapter.java
index f66fdf79ca..f727939648 100644
--- a/src/main/org/codehaus/groovy/runtime/ScriptBytecodeAdapter.java
+++ b/src/main/org/codehaus/groovy/runtime/ScriptBytecodeAdapter.java
@@ -118,14 +118,27 @@ public class ScriptBytecodeAdapter {
         }
     }
 
-    public static Object invokeConstructor(String type, Object arguments) throws Throwable{
+    public static Object invokeConstructorAt(Class at, Class type, Object arguments) throws Throwable{
         try {
-            return InvokerHelper.invokeConstructor(type, arguments);
+            return InvokerHelper.invokeConstructorAt(at, type, arguments);
         } catch (GroovyRuntimeException gre) {
             return unwrap(gre);
         }
     }
 
+    /// public static Object invokeConstructorAt(Class at, String type, Object arguments) throws Throwable{
+    ///     try {
+    ///         return InvokerHelper.invokeConstructorAt(at, type, arguments);
+    ///     } catch (GroovyRuntimeException gre) {
+    ///         return unwrap(gre);
+    ///     }
+    /// }
+
+    public static Object invokeNoArgumentsConstructorAt(Class at, Class type) throws Throwable {
+        return invokeConstructorAt(at, type, EMPTY_ARGS);
+    }
+    
+    
     public static Object invokeConstructorOf(Class type, Object arguments) throws Throwable{
         try {
             return InvokerHelper.invokeConstructorOf(type, arguments);
@@ -134,7 +147,15 @@ public class ScriptBytecodeAdapter {
         }  
     }
     
-    public static Object invokeNoArgumentsConstructorOf(Class type) throws Throwable{
+    /// public static Object invokeConstructorOf(String type, Object arguments) throws Throwable{
+    ///     try {
+    ///         return InvokerHelper.invokeConstructorOf(type, arguments);
+    ///     } catch (GroovyRuntimeException gre) {
+    ///         return unwrap(gre);
+    ///     }  
+    /// }
+    
+    public static Object invokeNoArgumentsConstructorOf(Class type) throws Throwable {
         return invokeConstructorOf(type, EMPTY_ARGS);
     }
     
diff --git a/src/test/UberTestCase.java b/src/test/UberTestCase.java
index 5fc3bd460a..e99fe9eb55 100644
--- a/src/test/UberTestCase.java
+++ b/src/test/UberTestCase.java
@@ -215,6 +215,7 @@ public class UberTestCase extends TestCase {
         suite.addTestSuite(SpreadMapOperatorTest.class);
         suite.addTestSuite(SerializeTest.class);
         suite.addTestSuite(ShellTest.class);
+        suite.addTestSuite(SingletonBugTest.class);
         suite.addTestSuite(SmallTreeTest.class);
         suite.addTestSuite(SocketTest.class);
         suite.addTestSuite(SortTest.class);
diff --git a/src/test/groovy/SingletonBugTest.groovy b/src/test/groovy/SingletonBugTest.groovy
new file mode 100644
index 0000000000..4cbc919f8d
--- /dev/null
+++ b/src/test/groovy/SingletonBugTest.groovy
@@ -0,0 +1,105 @@
+// TODO: GROOVY-435
+
+class SingletonBugTest extends GroovyTestCase {
+
+    public void testPrivate() {
+        def x = SingletonBugPrivate.getInstance()
+        def y = SingletonBugPrivate.getInstance()
+        println "Get one private instance: $x"
+        println "Get another private instance: $y"
+        assert x == y
+
+        // println(SingletonBugPrivateSecond.getInstanceSecond())
+        // println(SingletonBugPrivateSecond.doTestSecond())
+        shouldFail { println(SingletonBugPrivateSecond.getInstanceSecond()) }
+        shouldFail { println(SingletonBugPrivateSecond.doTestSecond()) }
+    }
+
+    public void testProtected() {
+        def x = SingletonBugProtected.getInstance()
+        def y = SingletonBugProtected.getInstance()
+        println "Get one protected instance: $x"
+        println "Get another protected instance: $y"
+        assert x == y
+
+        println(SingletonBugProtectedSecond.getInstanceSecond())
+        println(SingletonBugProtectedSecond.doTestSecond())
+        x = SingletonBugProtectedSecond.getInstanceSecond()
+        y = SingletonBugProtectedSecond.doTestSecond()
+        assert x != y
+    }
+
+  /*
+    static void main(args) {
+        def app = new SingletonBugTest()
+        app.testPrivate()
+        app.testProtected()
+    }
+  */
+}
+
+
+class SingletonBugPrivate {
+
+    private static SingletonBugPrivate instance1 = null
+
+    private SingletonBugPrivate() {
+    }
+    
+    static SingletonBugPrivate getInstance() {
+        if (instance1 == null)
+            instance1 = new SingletonBugPrivate()
+        return instance1
+    }
+    
+    // private static SingletonBugPrivate getInstance2() {
+    //     if (instance1 == null)
+    //         instance1 = new SingletonBugPrivate()
+    //     return instance1
+    // }
+}
+
+
+class SingletonBugProtected {
+
+    private static SingletonBugProtected instance1 = null
+
+    protected SingletonBugProtected() {
+    }
+    
+    static SingletonBugProtected getInstance() {
+        if (instance1 == null)
+            instance1 = new SingletonBugProtected()
+        return instance1
+    }
+    
+    // private static SingletonBugProtected getInstance2() {
+    //     if (instance1 == null)
+    //         instance1 = new SingletonBugProtected()
+    //     return instance1
+    // }
+}
+
+
+class SingletonBugPrivateSecond extends SingletonBugPrivate {
+
+    static SingletonBugPrivate getInstanceSecond() {
+        return doTestSecond()
+    }
+
+    static SingletonBugPrivate doTestSecond() {
+        return new SingletonBugPrivate()
+    }
+}
+
+
+class SingletonBugProtectedSecond extends SingletonBugProtected {
+
+    static SingletonBugProtected getInstanceSecond() {
+        return doTestSecond()
+    }
+
+    static SingletonBugProtected doTestSecond() {
+        return new SingletonBugProtected()
+    }
+}
diff --git a/src/test/groovy/j2ee/J2eeConsole.java b/src/test/groovy/j2ee/J2eeConsole.java
index 1afb34eacd..ec7434f8c2 100644
--- a/src/test/groovy/j2ee/J2eeConsole.java
+++ b/src/test/groovy/j2ee/J2eeConsole.java
@@ -96,7 +96,7 @@ public class J2eeConsole {
             //shell.evaluate("src/test/groovy/j2ee/CreateData.groovy");
             
             //shell.evaluate("src/main/groovy/ui/Console.groovy");
-            GroovyObject console = (GroovyObject) InvokerHelper.invokeConstructor("groovy.ui.Console", null);
+            GroovyObject console = (GroovyObject) InvokerHelper.invokeConstructorOf("groovy.ui.Console", null);
             console.setProperty("shell", shell);
             console.invokeMethod("run", null);
             /*
diff --git a/src/test/org/codehaus/groovy/classgen/DummyReflector.java b/src/test/org/codehaus/groovy/classgen/DummyReflector.java
index 10a4331df5..eb5eb28b75 100644
--- a/src/test/org/codehaus/groovy/classgen/DummyReflector.java
+++ b/src/test/org/codehaus/groovy/classgen/DummyReflector.java
@@ -87,7 +87,11 @@ public class DummyReflector extends Reflector {
         }
     }
 
-    public Object invokeConstructor(Object constructor, Object[] arguments) {
+    public Object invokeConstructorAt(Object at, Object constructor, Object[] arguments) {
+        return null; // noSuchMethod(method, object, arguments);
+    }
+
+    public Object invokeConstructorOf(Object constructor, Object[] arguments) {
         return null; // noSuchMethod(method, object, arguments);
     }
 
diff --git a/src/test/org/codehaus/groovy/classgen/DumpClass2.java b/src/test/org/codehaus/groovy/classgen/DumpClass2.java
index d849ff0bc0..475e05b58d 100644
--- a/src/test/org/codehaus/groovy/classgen/DumpClass2.java
+++ b/src/test/org/codehaus/groovy/classgen/DumpClass2.java
@@ -89,6 +89,6 @@ public class DumpClass2 {
     }
     
     public Object callConstructor() {
-        return InvokerHelper.invokeConstructor("java.lang.String", "hello");
+        return InvokerHelper.invokeConstructorOf("java.lang.String", "hello");
     }
 }
diff --git a/src/test/org/codehaus/groovy/classgen/DumpClass4.java b/src/test/org/codehaus/groovy/classgen/DumpClass4.java
index 9170712e25..f0793a800f 100644
--- a/src/test/org/codehaus/groovy/classgen/DumpClass4.java
+++ b/src/test/org/codehaus/groovy/classgen/DumpClass4.java
@@ -63,7 +63,7 @@ public class DumpClass4 {
     }
 
     public void throwException() {
-        throw (RuntimeException) InvokerHelper.invokeConstructor("java.lang.RuntimeException", "Hello");
+        throw (RuntimeException) InvokerHelper.invokeConstructorOf("java.lang.RuntimeException", "Hello");
     }
 
     public void switchTest(int i) {
diff --git a/src/test/org/codehaus/groovy/runtime/InvokeConstructorTest.java b/src/test/org/codehaus/groovy/runtime/InvokeConstructorTest.java
index 4c33c58d66..fdca0c1d36 100644
--- a/src/test/org/codehaus/groovy/runtime/InvokeConstructorTest.java
+++ b/src/test/org/codehaus/groovy/runtime/InvokeConstructorTest.java
@@ -91,7 +91,7 @@ public class InvokeConstructorTest extends GroovyTestCase {
 
     protected Object invoke(String type, Object args) throws Throwable {
         try {
-            return invoker.invokeConstructor(type, args);
+            return invoker.invokeConstructorOf(type, args);
         }
         catch (InvokerInvocationException e) {
             throw e.getCause();
