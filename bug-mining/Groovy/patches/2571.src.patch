diff --git a/src/main/org/codehaus/groovy/control/ResolveVisitor.java b/src/main/org/codehaus/groovy/control/ResolveVisitor.java
index d6501fba55..63e9820ae4 100644
--- a/src/main/org/codehaus/groovy/control/ResolveVisitor.java
+++ b/src/main/org/codehaus/groovy/control/ResolveVisitor.java
@@ -1264,12 +1264,15 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
         return source;
     }
 
-    private void resolveGenericsTypes(GenericsType[] types) {
-        if (types == null) return;
+    private boolean resolveGenericsTypes(GenericsType[] types) {
+        if (types == null) return true;
         currentClass.setUsingGenerics(true);
+        boolean resolved = true;
         for (GenericsType type : types) {
-            resolveGenericsType(type);
+            // attempt resolution on all types, so don't short-circuit and stop if we've previously failed
+            resolved = resolveGenericsType(type) && resolved;
         }
+        return resolved;
     }
 
     private void resolveGenericsHeader(GenericsType[] types) {
@@ -1298,8 +1301,8 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
         }
     }
 
-    private void resolveGenericsType(GenericsType genericsType) {
-        if (genericsType.isResolved()) return;
+    private boolean resolveGenericsType(GenericsType genericsType) {
+        if (genericsType.isResolved()) return true;
         currentClass.setUsingGenerics(true);
         ClassNode type = genericsType.getType();
         // save name before redirect
@@ -1326,8 +1329,12 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
         if (genericsType.getLowerBound() != null) {
             resolveOrFail(genericsType.getLowerBound(), genericsType);
         }
-        resolveGenericsTypes(type.getGenericsTypes());
-        genericsType.setResolved(genericsType.getType().isResolved());
+
+        if (resolveGenericsTypes(type.getGenericsTypes())) {
+            genericsType.setResolved(genericsType.getType().isResolved());
+        }
+        return genericsType.isResolved();
+
     }
 
     public void setClassNodeResolver(ClassNodeResolver classNodeResolver) {
diff --git a/src/test/groovy/bugs/Groovy6755Bug.groovy b/src/test/groovy/bugs/Groovy6755Bug.groovy
new file mode 100644
index 0000000000..3e98206806
--- /dev/null
+++ b/src/test/groovy/bugs/Groovy6755Bug.groovy
@@ -0,0 +1,68 @@
+package groovy.bugs
+
+import org.codehaus.groovy.control.CompilerConfiguration
+import org.codehaus.groovy.tools.FileSystemCompiler
+
+class Groovy6755Bug extends GroovyTestCase {
+
+    public void testDeeepGenericJointCompilationImportResolution() {
+        File workDir = new File("target/tmp/Groovy6755Bug")
+        workDir.deleteDir()
+        workDir.mkdirs()
+
+        File classesDir = new File(workDir, "classes")
+        classesDir.mkdirs()
+
+        final File itemJava = new File(workDir, "a/Item.java");
+        itemJava.parentFile.mkdirs()
+        itemJava.text = """
+package a;
+
+public interface Item {
+}
+
+"""
+
+        final File itemListListGroovy = new File(workDir, "b/ItemListList.groovy");
+        itemListListGroovy.parentFile.mkdirs()
+        itemListListGroovy.text = """
+package b
+// Use a star import from a different package here to expose the bug
+import a.*
+import java.util.List
+
+class ItemListList {
+    // The local class must be a generic type of a generic type
+    static List<List<Item>> ITEMS
+}
+
+"""
+
+        try {
+// needs to be joint compiler
+            FileSystemCompiler.commandLineCompile(
+                    "-j -sourcepath ${workDir.path} -d ${classesDir.path} ${itemJava.path} ${itemListListGroovy.path}".
+                            split(' '), true)
+
+            // So the bug would produce an ItemListList with a field of type:
+            //   java.util.List<java.util.List<Item>>
+            // note that Item is not fully qualified as a.Item as it should be
+            // and thus reference to the class will fail during loading. Instead
+            // of analysing the class, We'll just trigger a classload of it
+            // to ensure that it ended up being valid. If the bug exists,
+            // then we should get an error like 'Type Item not present'
+            CompilerConfiguration cc = new CompilerConfiguration();
+            cc.setClasspath(classesDir.path);
+            // I'm sure there's a nicer way of triggering this via the classloader, but this will do
+            new GroovyShell(cc).evaluate("""
+import b.ItemListList
+
+def x = ItemListList.ITEMS
+
+""")
+        } finally {
+            workDir.deleteDir()
+        }
+
+    }
+}
