diff --git a/src/main/java/org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformation.java b/src/main/java/org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformation.java
index 5707158350..37db751600 100644
--- a/src/main/java/org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformation.java
+++ b/src/main/java/org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformation.java
@@ -56,48 +56,53 @@ import java.util.stream.LongStream;
  */
 public class DefaultTypeTransformation {
 
+    @Deprecated(forRemoval = true, since = "5.0.0")
     protected static final Object[] EMPTY_ARGUMENTS = {};
+    @Deprecated(forRemoval = true, since = "5.0.0")
     protected static final BigInteger ONE_NEG = new BigInteger("-1");
-    private static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];
 
     //  --------------------------------------------------------
     //                  unboxing methods
     //  --------------------------------------------------------
 
-    public static byte byteUnbox(Object value) {
+    public static byte byteUnbox(final Object value) {
         Number n = castToNumber(value, byte.class);
         return n.byteValue();
     }
 
-    public static char charUnbox(Object value) {
-        return ShortTypeHandling.castToChar(value);
+    public static char charUnbox(final Object value) {
+        if (value == null) return '\u0000'; // GROOVY-11371
+        var ch = ShortTypeHandling.castToChar(value);
+        return ch.charValue();
     }
 
-    public static short shortUnbox(Object value) {
+    public static short shortUnbox(final Object value) {
         Number n = castToNumber(value, short.class);
         return n.shortValue();
     }
 
-    public static int intUnbox(Object value) {
+    public static int intUnbox(final Object value) {
         Number n = castToNumber(value, int.class);
         return n.intValue();
     }
 
-    public static boolean booleanUnbox(Object value) {
+    public static boolean booleanUnbox(final Object value) {
         return castToBoolean(value);
     }
 
-    public static long longUnbox(Object value) {
+    public static long longUnbox(final Object value) {
         Number n = castToNumber(value, long.class);
         return n.longValue();
     }
 
-    public static float floatUnbox(Object value) {
+    public static float floatUnbox(final Object value) {
+        if (value == null) return Float.NaN; // GROOVY-11371
         Number n = castToNumber(value, float.class);
         return n.floatValue();
     }
 
-    public static double doubleUnbox(Object value) {
+    public static double doubleUnbox(final Object value) {
+        if (value == null) return Double.NaN; // GROOVY-11371
         Number n = castToNumber(value, double.class);
         return n.doubleValue();
     }
@@ -106,71 +111,67 @@ public class DefaultTypeTransformation {
     //                  boxing methods
     //  --------------------------------------------------------
 
-    @Deprecated
+    @Deprecated(since = "2.3.0")
     public static Object box(boolean value) {
         return value ? Boolean.TRUE : Boolean.FALSE;
     }
 
-    @Deprecated
+    @Deprecated(since = "2.3.0")
     public static Object box(byte value) {
         return value;
     }
 
-    @Deprecated
+    @Deprecated(since = "2.3.0")
     public static Object box(char value) {
         return value;
     }
 
-    @Deprecated
+    @Deprecated(since = "2.3.0")
     public static Object box(short value) {
         return value;
     }
 
-    @Deprecated
+    @Deprecated(since = "2.3.0")
     public static Object box(int value) {
         return value;
     }
 
-    @Deprecated
+    @Deprecated(since = "2.3.0")
     public static Object box(long value) {
         return value;
     }
 
-    @Deprecated
+    @Deprecated(since = "2.3.0")
     public static Object box(float value) {
         return value;
     }
 
-    @Deprecated
+    @Deprecated(since = "2.3.0")
     public static Object box(double value) {
         return value;
     }
 
     public static Number castToNumber(Object object) {
-        // default to Number class in exception details, else use the specified Number subtype.
+        // default to Number class in exception detail
         return castToNumber(object, Number.class);
     }
 
     public static Number castToNumber(Object object, Class type) {
-        if (object instanceof Number)
+        if (object instanceof Number) {
             return (Number) object;
+        }
         if (object instanceof Character) {
-            return (int) (Character) object;
+            char c = (Character) object;
+            return (int) c;
         }
         if (object instanceof GString) {
-            String c = ((GString) object).toString();
-            if (c.length() == 1) {
-                return (int) c.charAt(0);
-            } else {
-                throw new GroovyCastException(c, type);
-            }
+            object = object.toString();
         }
         if (object instanceof String) {
-            String c = (String) object;
-            if (c.length() == 1) {
-                return (int) c.charAt(0);
-            } else {
-                throw new GroovyCastException(c, type);
+            String s = (String) object;
+            if (s.length() == 1) {
+                char c = s.charAt(0);
+                return (int) c;
             }
         }
         throw new GroovyCastException(object, type);
@@ -184,7 +185,7 @@ public class DefaultTypeTransformation {
      * @return a boolean value
      */
     public static boolean castToBoolean(Object object) {
-        // null is always false
+        // GROOVY-6467, GROOVY-9916: null is false
         if (object == null) {
             return false;
         }
@@ -194,11 +195,11 @@ public class DefaultTypeTransformation {
             return (Boolean) object;
         }
 
-        // if the object is not null and no Boolean, try to call an asBoolean() method on the object
+        // if the object isn't null and no Boolean, try to call an asBoolean() method on the object
         return (Boolean) InvokerHelper.invokeMethod(object, "asBoolean", InvokerHelper.EMPTY_ARGS);
     }
 
-    @Deprecated
+    @Deprecated(since = "2.3.0")
     public static char castToChar(Object object) {
         if (object instanceof Character) {
             return (Character) object;
@@ -216,8 +217,12 @@ public class DefaultTypeTransformation {
     }
 
     public static Object castToType(final Object object, final Class type) {
-        if (object == null) return type == boolean.class ? Boolean.FALSE : null;
-        if (type == Object.class) return object;
+        if (type.isPrimitive()) { // GROOVY-9916, GROOVY-11371
+            return castToPrimitive(object, type);
+        }
+        if (object == null || type == Object.class) {
+            return object;
+        }
 
         final Class aClass = object.getClass();
         if (type == aClass || type.isAssignableFrom(aClass)) {
@@ -232,14 +237,12 @@ public class DefaultTypeTransformation {
             return continueCastOnCollection(object, type);
         } else if (type == String.class) {
             return FormatHelper.toString(object);
-        } else if (type == Character.class) {
-            return ShortTypeHandling.castToChar(object);
         } else if (type == Boolean.class) {
             return castToBoolean(object);
+        } else if (type == Character.class) {
+            return ShortTypeHandling.castToChar(object);
         } else if (type == Class.class) {
             return ShortTypeHandling.castToClass(object);
-        } else if (type.isPrimitive()) {
-            return castToPrimitive(object, type);
         }
 
         return continueCastOnNumber(object, type);
@@ -308,14 +311,12 @@ public class DefaultTypeTransformation {
                 return n.floatValue();
             }
             if (type == Double.class) {
-                double answer = n.doubleValue();
-                //throw a runtime exception if conversion would be out-of-range for the type.
-                if (!(n instanceof Double) && (answer == Double.NEGATIVE_INFINITY
-                        || answer == Double.POSITIVE_INFINITY)) {
-                    throw new GroovyRuntimeException("Automatic coercion of " + n.getClass().getName()
-                            + " value " + n + " to double failed. Value is out of range.");
+                double value = n.doubleValue();
+                // throw a runtime exception if conversion would be out-of-range for the type
+                if ((value == Double.NEGATIVE_INFINITY || value == Double.POSITIVE_INFINITY) && !(n instanceof Double)) {
+                    throw new GroovyRuntimeException("Automatic coercion of " + n.getClass().getName() + " value " + n + " to double failed. Value is out of range.");
                 }
-                return answer;
+                return value;
             }
             if (type == BigDecimal.class) {
                 return NumberMath.toBigDecimal(n);
@@ -330,7 +331,7 @@ public class DefaultTypeTransformation {
 
     private static Object castToPrimitive(Object object, Class type) {
         if (type == boolean.class) {
-            return booleanUnbox(object);
+            return castToBoolean(object);
         } else if (type == byte.class) {
             return byteUnbox(object);
         } else if (type == char.class) {
@@ -344,16 +345,14 @@ public class DefaultTypeTransformation {
         } else if (type == float.class) {
             return floatUnbox(object);
         } else if (type == double.class) {
-            double answer = doubleUnbox(object);
-            //throw a runtime exception if conversion would be out-of-range for the type.
-            if (!(object instanceof Double) && (answer == Double.NEGATIVE_INFINITY
-                    || answer == Double.POSITIVE_INFINITY)) {
-                throw new GroovyRuntimeException("Automatic coercion of " + object.getClass().getName()
-                        + " value " + object + " to double failed. Value is out of range.");
+            double value = doubleUnbox(object);
+            // throw a runtime exception if conversion would be out-of-range for the type
+            if ((value == Double.NEGATIVE_INFINITY || value == Double.POSITIVE_INFINITY) && !(object instanceof Double)) {
+                throw new GroovyRuntimeException("Automatic coercion of " + object.getClass().getName() + " value " + object + " to double failed. Value is out of range.");
             }
-            return answer;
-        } //nothing else possible
-        throw new GroovyCastException(object, type);
+            return value;
+        }
+        throw new GroovyCastException(object, type); // nothing else is possible
     }
 
     private static Object continueCastOnSAM(Object object, Class type) {
@@ -487,7 +486,7 @@ public class DefaultTypeTransformation {
         } else if (value instanceof Optional) { // GROOVY-10223
             return ((Optional<?>) value).map(Collections::singleton).orElseGet(Collections::emptySet);
         } else if (value instanceof Class && ((Class) value).isEnum()) {
-            Object[] values = (Object[]) InvokerHelper.invokeMethod(value, "values", EMPTY_OBJECT_ARRAY);
+            Object[] values = (Object[]) InvokerHelper.invokeMethod(value, "values", InvokerHelper.EMPTY_ARGS);
             return Arrays.asList(values);
         } else if (value instanceof File) {
             try {
@@ -525,7 +524,7 @@ public class DefaultTypeTransformation {
      * @param value an object
      * @return true if the object is an Enum
      */
-    @Deprecated
+    @Deprecated(since = "2.3.0")
     public static boolean isEnumSubclass(Object value) {
         if (value instanceof Class) {
             Class superclass = ((Class) value).getSuperclass();
@@ -885,7 +884,7 @@ public class DefaultTypeTransformation {
         return (value instanceof String || value instanceof GString) && value.toString().length() == 1;
     }
 
-    @Deprecated
+    @Deprecated(since = "2.3.0")
     public static int[] convertToIntArray(Object a) {
         int[] ans = null;
 
@@ -905,7 +904,7 @@ public class DefaultTypeTransformation {
         return ans;
     }
 
-    @Deprecated
+    @Deprecated(since = "2.3.0")
     public static boolean[] convertToBooleanArray(Object a) {
         boolean[] ans = null;
 
@@ -923,7 +922,7 @@ public class DefaultTypeTransformation {
         return ans;
     }
 
-    @Deprecated
+    @Deprecated(since = "2.3.0")
     public static byte[] convertToByteArray(Object a) {
         byte[] ans = null;
 
@@ -942,7 +941,7 @@ public class DefaultTypeTransformation {
         return ans;
     }
 
-    @Deprecated
+    @Deprecated(since = "2.3.0")
     public static short[] convertToShortArray(Object a) {
         short[] ans = null;
 
@@ -959,7 +958,7 @@ public class DefaultTypeTransformation {
         return ans;
     }
 
-    @Deprecated
+    @Deprecated(since = "2.3.0")
     public static char[] convertToCharArray(Object a) {
         char[] ans = null;
 
@@ -979,7 +978,7 @@ public class DefaultTypeTransformation {
         return ans;
     }
 
-    @Deprecated
+    @Deprecated(since = "2.3.0")
     public static long[] convertToLongArray(Object a) {
         long[] ans = null;
 
@@ -999,7 +998,7 @@ public class DefaultTypeTransformation {
         return ans;
     }
 
-    @Deprecated
+    @Deprecated(since = "2.3.0")
     public static float[] convertToFloatArray(Object a) {
         float[] ans = null;
 
@@ -1019,7 +1018,7 @@ public class DefaultTypeTransformation {
         return ans;
     }
 
-    @Deprecated
+    @Deprecated(since = "2.3.0")
     public static double[] convertToDoubleArray(Object a) {
         double[] ans = null;
 
@@ -1039,7 +1038,7 @@ public class DefaultTypeTransformation {
         return ans;
     }
 
-    @Deprecated
+    @Deprecated(since = "2.3.0")
     public static Object convertToPrimitiveArray(Object a, Class type) {
         if (type == Byte.TYPE) {
             return convertToByteArray(a);
@@ -1069,7 +1068,7 @@ public class DefaultTypeTransformation {
         }
     }
 
-    @Deprecated
+    @Deprecated(since = "2.3.0")
     public static Character getCharFromSizeOneString(Object value) {
         if (value instanceof GString) value = value.toString();
         if (value instanceof String) {
@@ -1093,5 +1092,4 @@ public class DefaultTypeTransformation {
         }
         return newArray;
     }
-
 }
diff --git a/src/main/java/org/codehaus/groovy/runtime/typehandling/GroovyCastException.java b/src/main/java/org/codehaus/groovy/runtime/typehandling/GroovyCastException.java
index 053353a312..9996c8a5fd 100644
--- a/src/main/java/org/codehaus/groovy/runtime/typehandling/GroovyCastException.java
+++ b/src/main/java/org/codehaus/groovy/runtime/typehandling/GroovyCastException.java
@@ -18,6 +18,8 @@
  */
 package org.codehaus.groovy.runtime.typehandling;
 
+import java.util.Optional;
+
 public class GroovyCastException extends ClassCastException {
 
     private static final long serialVersionUID = 6859089155641797356L;
@@ -27,49 +29,37 @@ public class GroovyCastException extends ClassCastException {
      * @param classToCastTo class we tried to cast to
      * @param cause not kept but we pass on message from this Exception if any
      */
-    public GroovyCastException(Object objectToCast, Class classToCastTo, Exception cause) {
-        super(makeMessage(objectToCast,classToCastTo) + " due to: " +
-                cause.getClass().getName() + (cause.getMessage() == null ? "" : ": " + cause.getMessage()));
+    public GroovyCastException(final Object objectToCast, final Class classToCastTo, final Exception cause) {
+        super(makeMessage(objectToCast, classToCastTo) +
+            " due to: " + cause.getClass().getName() + Optional.ofNullable(cause.getMessage()).map(msg -> ": " + msg).orElse(""));
     }
 
     /**
      * @param objectToCast object we tried to cast
      * @param classToCastTo class we tried to cast to
      */
-    public GroovyCastException(Object objectToCast, Class classToCastTo) {
-        super(makeMessage(objectToCast,classToCastTo));
+    public GroovyCastException(final Object objectToCast, final Class classToCastTo) {
+        super(makeMessage(objectToCast, classToCastTo));
     }
 
     /**
-     * @param message custom Exception message
+     * @param message custom problem message
      */
-    public GroovyCastException(String message) {
+    public GroovyCastException(final String message) {
         super(message);
     }
 
-    private static String makeMessage(Object objectToCast, Class classToCastTo) {
-       String classToCastFrom;
-       Object msgObject = objectToCast;
-       if (objectToCast!=null) {
-           classToCastFrom = objectToCast.getClass().getName();
-       } else {
-           msgObject = "null";
-           classToCastFrom = "null";
-       }
-       String msg = 
-               "Cannot cast object '" + msgObject + "' " +
-               "with class '" + classToCastFrom + "' " +
-               "to class '" + classToCastTo.getName() + "'";
-
-       if (objectToCast==null){
-           msg += getWrapper(classToCastTo);
-       }
+    //--------------------------------------------------------------------------
 
-       return msg;
+    private static String makeMessage(final Object object, final Class<?> target) {
+        if (object == null) {
+            return "Cannot cast 'null' to class '" + target.getName() + "'" + getWrapper(target);
+        }
+        return "Cannot cast object '" + object + "' with class '" + object.getClass().getName() + "' to class '" + target.getName() + "'";
     }
 
-    private static String getWrapper(Class cls) {
-        Class ncls = cls;
+    private static String getWrapper(final Class<?> cls) {
+        Class<?> ncls = cls;
         if (cls==byte.class)        {ncls=Byte.class;}
         else if (cls==short.class)  {ncls=Short.class;}
         else if (cls==char.class)   {ncls=Character.class;}
@@ -83,5 +73,4 @@ public class GroovyCastException extends ClassCastException {
         }
         return "";
     }
-
 }
diff --git a/src/spec/test/RecordSpecificationTest.groovy b/src/spec/test/RecordSpecificationTest.groovy
index c2a2fe7868..31fcebf4f8 100644
--- a/src/spec/test/RecordSpecificationTest.groovy
+++ b/src/spec/test/RecordSpecificationTest.groovy
@@ -77,9 +77,9 @@ assert new ColoredPoint(x: 5).toString() == 'ColoredPoint[x=5, y=0, color=white]
 assert new ColoredPoint(x: 0, y: 5).toString() == 'ColoredPoint[x=0, y=5, color=white]'
 // end::record_point_named_args[]
 def ex = shouldFail(ClassCastException) { new ColoredPoint(x: 0, y: null) }
-assert ex.message.contains("Cannot cast object 'null' with class 'null' to class 'int'")
+assert ex.message.contains("Cannot cast 'null' to class 'int'")
 ex = shouldFail(ClassCastException) { new ColoredPoint(x: null) }
-assert ex.message.contains("Cannot cast object 'null' with class 'null' to class 'int'")
+assert ex.message.contains("Cannot cast 'null' to class 'int'")
 ex = shouldFail { new ColoredPoint(x: 0, z: 5) }
 assert ex.message.contains('Unrecognized namedArgKey: z')
 // tag::record_point_named_args_off[]
diff --git a/src/test/groovy/bugs/Groovy11203.groovy b/src/test/groovy/bugs/Groovy11203.groovy
index 31d10bd0a5..6987016895 100644
--- a/src/test/groovy/bugs/Groovy11203.groovy
+++ b/src/test/groovy/bugs/Groovy11203.groovy
@@ -30,6 +30,6 @@ final class Groovy11203 {
             void setX(int i) { }
             this.x = null
         '''
-        assert err.message.startsWith('Cannot call method with null')
+        assert err.message.startsWith("Cannot cast 'null' to class 'int'")
     }
 }
diff --git a/src/test/groovy/transform/stc/TernaryOperatorSTCTest.groovy b/src/test/groovy/transform/stc/TernaryOperatorSTCTest.groovy
index 61fbc15e00..b1c116cb22 100644
--- a/src/test/groovy/transform/stc/TernaryOperatorSTCTest.groovy
+++ b/src/test/groovy/transform/stc/TernaryOperatorSTCTest.groovy
@@ -18,8 +18,6 @@
  */
 package groovy.transform.stc
 
-import groovy.test.NotYetImplemented
-
 /**
  * Unit tests for static type checking : ternary operator.
  */
@@ -387,7 +385,7 @@ class TernaryOperatorSTCTest extends StaticTypeCheckingTestCase {
         '''
     }
 
-    @NotYetImplemented // GROOVY-10095
+    // GROOVY-10095
     void testNull4() {
         assertScript '''
             float x = false ? 1.0 : null
diff --git a/src/test/org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformationTest.groovy b/src/test/org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformationTest.groovy
index fa547527f0..036622e877 100644
--- a/src/test/org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformationTest.groovy
+++ b/src/test/org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformationTest.groovy
@@ -25,19 +25,46 @@ import static groovy.test.GroovyAssert.shouldFail
 
 final class DefaultTypeTransformationTest {
 
+    // GROOVY-9916, GROOVY-11371
     @Test
     void testCastToType1() {
-        def input = null, result
+        Object result
 
-        result = DefaultTypeTransformation.castToType(input, int)
-        assert result === null
+        result = DefaultTypeTransformation.castToType(null, boolean)
+        assert result instanceof Boolean && result == false
 
-        result = DefaultTypeTransformation.castToType(input, long)
-        assert result === null
+        result = DefaultTypeTransformation.castToType(null, double)
+        assert result instanceof Double && result.isNaN()
+
+        result = DefaultTypeTransformation.castToType(null, float)
+        assert result instanceof Float && result.isNaN()
+
+        result = DefaultTypeTransformation.castToType(null, char)
+        assert result == Character.MIN_VALUE // 'NULL'
+    }
+
+    // GROOVY-11203, GROOVY-11371
+    @Test
+    void testCastToType2() {
+        shouldFail(ClassCastException) {
+            DefaultTypeTransformation.castToType(null, int)
+        }
+        shouldFail(ClassCastException) {
+            DefaultTypeTransformation.castToType(null, byte)
+        }
+        shouldFail(ClassCastException) {
+            DefaultTypeTransformation.castToType(null, long)
+        }
+        shouldFail(ClassCastException) {
+            DefaultTypeTransformation.castToType(null, short)
+        }
+    }
 
-        result = DefaultTypeTransformation.castToType(input, boolean)
-        assert result === false // GROOVY-9916
+    @Test
+    void testCastToType3() {
+        Object input, result
 
+        input = null
         result = DefaultTypeTransformation.castToType(input, Object)
         assert result === null
 
@@ -55,8 +82,8 @@ final class DefaultTypeTransformationTest {
     }
 
     @Test
-    void testCastToType2() {
-        def input = new int[] {0,1}, result
+    void testCastToType4() {
+        Object input = new int[] {0,1}, result
 
         result = DefaultTypeTransformation.castToType(input, Number[])
         assert result instanceof Number[]
@@ -75,8 +102,8 @@ final class DefaultTypeTransformationTest {
     }
 
     @Test
-    void testCastToType3() {
-        def input = Arrays.asList(0,1), result
+    void testCastToType5() {
+        Object input = Arrays.asList(0,1), result
 
         result = DefaultTypeTransformation.castToType(input, Number[])
         assert result instanceof Number[]
@@ -94,9 +121,10 @@ final class DefaultTypeTransformationTest {
         assert result[1] == 1
     }
 
-    @Test // GROOVY-10028
-    void testCastToType4() {
-        def result
+    // GROOVY-10028
+    @Test
+    void testCastToType6() {
+        Object result
 
         result = DefaultTypeTransformation.castToType(Arrays.stream(0,1), Number[])
         assert result instanceof Number[]
@@ -119,9 +147,10 @@ final class DefaultTypeTransformationTest {
         assert result[1] == 1
     }
 
-    @Test // GROOVY-11378
-    void testCastToType5() {
-        def input = new org.codehaus.groovy.util.ArrayIterable<Integer>(0,1), result
+    // GROOVY-11378
+    @Test
+    void testCastToType7() {
+        Object input = new org.codehaus.groovy.util.ArrayIterable<Integer>(0,1), result
 
         result = DefaultTypeTransformation.castToType(input, Number[])
         assert result instanceof Number[]
@@ -144,9 +173,10 @@ final class DefaultTypeTransformationTest {
         assert result[1] == 1
     }
 
-    @Test // GROOVY-10223
-    void testCastToType6() {
-        def err = shouldFail GroovyCastException, {
+    // GROOVY-10223
+    @Test
+    void testCastToType8() {
+        def err = shouldFail(ClassCastException) {
             DefaultTypeTransformation.castToType(Optional.of('123'), Number[])
         }
         assert err =~ /Cannot cast object '123' with class 'java.lang.String' to class 'java.lang.Number'/
@@ -187,7 +217,8 @@ final class DefaultTypeTransformationTest {
         assert result.isEmpty()
     }
 
-    @Test // GROOVY-10223: interesting emergent properties
+    // GROOVY-10223: interesting emergent properties
+    @Test
     void testAsCollection() {
         assertScript '''
             def nothing = Optional.empty(), something = Optional.of('foo')
