diff --git a/src/main/org/codehaus/groovy/ast/ClassCodeExpressionTransformer.java b/src/main/org/codehaus/groovy/ast/ClassCodeExpressionTransformer.java
new file mode 100644
index 0000000000..de31bd854d
--- /dev/null
+++ b/src/main/org/codehaus/groovy/ast/ClassCodeExpressionTransformer.java
@@ -0,0 +1,156 @@
+/*
+ * Copyright 2003-2007 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.codehaus.groovy.ast;
+
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+
+import org.codehaus.groovy.ast.AnnotatedNode;
+import org.codehaus.groovy.ast.AnnotationNode;
+import org.codehaus.groovy.ast.ClassCodeVisitorSupport;
+import org.codehaus.groovy.ast.FieldNode;
+import org.codehaus.groovy.ast.MethodNode;
+import org.codehaus.groovy.ast.Parameter;
+import org.codehaus.groovy.ast.expr.*;
+import org.codehaus.groovy.ast.stmt.AssertStatement;
+import org.codehaus.groovy.ast.stmt.CaseStatement;
+import org.codehaus.groovy.ast.stmt.DoWhileStatement;
+import org.codehaus.groovy.ast.stmt.ExpressionStatement;
+import org.codehaus.groovy.ast.stmt.ForStatement;
+import org.codehaus.groovy.ast.stmt.IfStatement;
+import org.codehaus.groovy.ast.stmt.ReturnStatement;
+import org.codehaus.groovy.ast.stmt.Statement;
+import org.codehaus.groovy.ast.stmt.SwitchStatement;
+import org.codehaus.groovy.ast.stmt.SynchronizedStatement;
+import org.codehaus.groovy.ast.stmt.ThrowStatement;
+import org.codehaus.groovy.ast.stmt.WhileStatement;
+
+/**
+ * Visitor to transform expressions in a whole class. 
+ * Transformed Expressions are usually not visited. 
+ *
+ * @author Jochen Theodorou
+ */
+public abstract class ClassCodeExpressionTransformer extends ClassCodeVisitorSupport implements ExpressionTransformer {
+    
+    protected void visitConstructorOrMethod(MethodNode node, boolean isConstructor) {
+        Parameter[] paras = node.getParameters();
+        for (int i=0; i<paras.length; i++) {
+            Parameter p = paras[i];
+            if (p.hasInitialExpression()) {
+                Expression init = p.getInitialExpression();
+                p.setInitialExpression(transform(init));
+            }
+        }
+        super.visitConstructorOrMethod(node,isConstructor);
+    }
+
+    public void visitSwitch(SwitchStatement statement) {
+        Expression exp = statement.getExpression();
+        statement.setExpression(transform(exp));
+        List list = statement.getCaseStatements();
+        for (Iterator iter = list.iterator(); iter.hasNext(); ) {
+            CaseStatement caseStatement = (CaseStatement) iter.next();
+            caseStatement.visit(this);
+        }
+        statement.getDefaultStatement().visit(this);
+    }
+
+    public void visitField(FieldNode node) {
+        visitAnnotations(node);
+        Expression init = node.getInitialExpression();
+        node.setInitialValueExpression(transform(init));
+    }
+    
+    public void visitProperty(PropertyNode node) {
+        visitAnnotations(node);
+        Statement statement = node.getGetterBlock();
+        visitClassCodeContainer(statement);
+        
+        statement = node.getSetterBlock();
+        visitClassCodeContainer(statement);
+    }
+    
+    public void visitIfElse(IfStatement ifElse) {
+        ifElse.setBooleanExpression((BooleanExpression) (transform(ifElse.getBooleanExpression())));
+        ifElse.getIfBlock().visit(this);
+        ifElse.getElseBlock().visit(this);
+    }
+
+    public Expression transform(Expression exp) {
+        if (exp==null) return null;
+        return exp.transformExpression(this);
+    }
+        
+    public void visitAnnotations(AnnotatedNode node) {
+        Map annotionMap = node.getAnnotations();
+        if (annotionMap.isEmpty()) return;
+        Iterator it = annotionMap.values().iterator();
+        while (it.hasNext()) {
+            AnnotationNode an = (AnnotationNode) it.next();
+            //skip builtin properties
+            if (an.isBuiltIn()) continue;
+            for (Iterator iter = an.getMembers().entrySet().iterator(); iter.hasNext();) {
+                Map.Entry member = (Map.Entry) iter.next();
+                Expression memberValue = (Expression) member.getValue();
+                member.setValue(transform(memberValue));
+            }
+        }
+    }
+
+    public void visitReturnStatement(ReturnStatement statement) {
+       statement.setExpression(transform(statement.getExpression()));
+    }
+
+    public void visitAssertStatement(AssertStatement as) {
+        as.setBooleanExpression((BooleanExpression) (transform(as.getBooleanExpression())));
+        as.setMessageExpression(transform(as.getMessageExpression()));
+    }
+
+    public void visitCaseStatement(CaseStatement statement) {
+    	statement.setExpression(transform(statement.getExpression()));
+    	statement.getCode().visit(this);
+    }
+
+    public void visitDoWhileLoop(DoWhileStatement loop) {
+        loop.setBooleanExpression((BooleanExpression) (transform(loop.getBooleanExpression())));
+        super.visitDoWhileLoop(loop);
+    }
+
+    public void visitForLoop(ForStatement forLoop) {
+        forLoop.setCollectionExpression(transform(forLoop.getCollectionExpression()));
+        super.visitForLoop(forLoop);
+    }
+
+    public void visitSynchronizedStatement(SynchronizedStatement sync) {
+        sync.setExpression(transform(sync.getExpression()));
+        super.visitSynchronizedStatement(sync);
+    }
+
+    public void visitThrowStatement(ThrowStatement ts) {
+        ts.setExpression(transform(ts.getExpression()));
+    }
+
+    public void visitWhileLoop(WhileStatement loop) {
+    	loop.setBooleanExpression((BooleanExpression) transform(loop.getBooleanExpression()));
+    	super.visitWhileLoop(loop);
+    }
+
+    public void visitExpressionStatement(ExpressionStatement es) {
+        es.setExpression(transform(es.getExpression()));
+    }    
+}
diff --git a/src/main/org/codehaus/groovy/ast/ClassCodeVisitorSupport.java b/src/main/org/codehaus/groovy/ast/ClassCodeVisitorSupport.java
index b0676d62db..d75b3a695a 100644
--- a/src/main/org/codehaus/groovy/ast/ClassCodeVisitorSupport.java
+++ b/src/main/org/codehaus/groovy/ast/ClassCodeVisitorSupport.java
@@ -63,7 +63,6 @@ public abstract class ClassCodeVisitorSupport extends CodeVisitorSupport impleme
             if (an.isBuiltIn()) continue;
             for (Iterator iter = an.getMembers().entrySet().iterator(); iter.hasNext();) {
                 Map.Entry member = (Map.Entry) iter.next();
-//                String memberName = (String) member.getKey();
                 Expression memberValue = (Expression) member.getValue();
                 memberValue.visit(this);
             }  
@@ -101,6 +100,7 @@ public abstract class ClassCodeVisitorSupport extends CodeVisitorSupport impleme
     }
     
     public void visitProperty(PropertyNode node) {
+        visitAnnotations(node);
         Statement statement = node.getGetterBlock();
         visitClassCodeContainer(statement);
         
diff --git a/src/main/org/codehaus/groovy/ast/Parameter.java b/src/main/org/codehaus/groovy/ast/Parameter.java
index 6f3ab97ef2..de1527193e 100644
--- a/src/main/org/codehaus/groovy/ast/Parameter.java
+++ b/src/main/org/codehaus/groovy/ast/Parameter.java
@@ -17,7 +17,6 @@ package org.codehaus.groovy.ast;
 
 import org.codehaus.groovy.ast.expr.*;
 
-import java.util.Map;
 
 /**
  * Represents a parameter on a constructor or method call. The type name is
diff --git a/src/main/org/codehaus/groovy/control/CompilationUnit.java b/src/main/org/codehaus/groovy/control/CompilationUnit.java
index b1b87d850d..0e28dd9f5a 100644
--- a/src/main/org/codehaus/groovy/control/CompilationUnit.java
+++ b/src/main/org/codehaus/groovy/control/CompilationUnit.java
@@ -88,7 +88,8 @@ public class CompilationUnit extends ProcessingUnit {
     protected ClassgenCallback classgenCallback;  // A callback for use during classgen()
     protected ProgressCallback progressCallback;  // A callback for use during compile()
     protected ResolveVisitor resolveVisitor;
-
+    protected StaticImportVisitor staticImportVisitor;
+    
     LinkedList[] phaseOperations;
     
 
@@ -136,6 +137,7 @@ public class CompilationUnit extends ProcessingUnit {
 
         this.verifier = new Verifier();
         this.resolveVisitor = new ResolveVisitor(this);
+        this.staticImportVisitor = new StaticImportVisitor(this);
         
         phaseOperations = new LinkedList[Phases.ALL+1];
         for (int i=0; i<phaseOperations.length; i++) {
@@ -146,10 +148,11 @@ public class CompilationUnit extends ProcessingUnit {
                 source.parse();
             }
         }, Phases.PARSING);
-        addPhaseOperation(convert,   Phases.CONVERSION);
-        addPhaseOperation(resolve,   Phases.SEMANTIC_ANALYSIS);
+        addPhaseOperation(convert,      Phases.CONVERSION);
+        addPhaseOperation(resolve,      Phases.SEMANTIC_ANALYSIS);
+        addPhaseOperation(staticImport, Phases.SEMANTIC_ANALYSIS);
         addPhaseOperation(compileCompleteCheck, Phases.CANONICALIZATION);
-        addPhaseOperation(classgen,  Phases.CLASS_GENERATION);
+        addPhaseOperation(classgen,     Phases.CLASS_GENERATION);
         addPhaseOperation(output);
         
         this.classgenCallback = null;
@@ -529,6 +532,12 @@ public class CompilationUnit extends ProcessingUnit {
         }
     };
     
+    private PrimaryClassNodeOperation staticImport = new PrimaryClassNodeOperation() {
+        public void call(SourceUnit source, GeneratorContext context, ClassNode classNode) throws CompilationFailedException {
+                staticImportVisitor.visitClass(classNode);
+        }
+    };
+    
     /**
      * Runs convert() on a single SourceUnit.
      */
diff --git a/src/main/org/codehaus/groovy/control/ResolveVisitor.java b/src/main/org/codehaus/groovy/control/ResolveVisitor.java
index 329c999d39..2291a2eb51 100644
--- a/src/main/org/codehaus/groovy/control/ResolveVisitor.java
+++ b/src/main/org/codehaus/groovy/control/ResolveVisitor.java
@@ -32,7 +32,7 @@ import java.net.URLConnection;
 import org.codehaus.groovy.ast.ASTNode;
 import org.codehaus.groovy.ast.AnnotatedNode;
 import org.codehaus.groovy.ast.AnnotationNode;
-import org.codehaus.groovy.ast.ClassCodeVisitorSupport;
+import org.codehaus.groovy.ast.ClassCodeExpressionTransformer;
 import org.codehaus.groovy.ast.ClassHelper;
 import org.codehaus.groovy.ast.ClassNode;
 import org.codehaus.groovy.ast.CompileUnit;
@@ -47,20 +47,10 @@ import org.codehaus.groovy.ast.PropertyNode;
 import org.codehaus.groovy.ast.Variable;
 import org.codehaus.groovy.ast.VariableScope;
 import org.codehaus.groovy.ast.expr.*;
-import org.codehaus.groovy.ast.stmt.AssertStatement;
 import org.codehaus.groovy.ast.stmt.BlockStatement;
-import org.codehaus.groovy.ast.stmt.CaseStatement;
 import org.codehaus.groovy.ast.stmt.CatchStatement;
-import org.codehaus.groovy.ast.stmt.DoWhileStatement;
-import org.codehaus.groovy.ast.stmt.ExpressionStatement;
 import org.codehaus.groovy.ast.stmt.ForStatement;
-import org.codehaus.groovy.ast.stmt.IfStatement;
-import org.codehaus.groovy.ast.stmt.ReturnStatement;
 import org.codehaus.groovy.ast.stmt.Statement;
-import org.codehaus.groovy.ast.stmt.SwitchStatement;
-import org.codehaus.groovy.ast.stmt.SynchronizedStatement;
-import org.codehaus.groovy.ast.stmt.ThrowStatement;
-import org.codehaus.groovy.ast.stmt.WhileStatement;
 import org.codehaus.groovy.classgen.Verifier;
 import org.codehaus.groovy.control.messages.ExceptionMessage;
 import org.codehaus.groovy.syntax.Types;
@@ -77,7 +67,7 @@ import org.codehaus.groovy.syntax.Types;
  *
  * @author Jochen Theodorou
  */
-public class ResolveVisitor extends ClassCodeVisitorSupport implements ExpressionTransformer {
+public class ResolveVisitor extends ClassCodeExpressionTransformer {
     private ClassNode currentClass;
     // note: BigInteger and BigDecimal are also imported by default
     private static final String[] DEFAULT_IMPORTS = {"java.lang.", "java.io.", "java.net.", "java.util.", "groovy.lang.", "groovy.util."};
@@ -117,11 +107,6 @@ public class ResolveVisitor extends ClassCodeVisitorSupport implements Expressio
 
             resolveOrFail(p.getType(),p.getType());
             visitAnnotations(p);
-
-            if (p.hasInitialExpression()) {
-                Expression init = p.getInitialExpression();
-                p.setInitialExpression(transform(init));
-            }
         }
         ClassNode[] exceptions = node.getExceptions();
         for (int i=0; i<exceptions.length; i++) {
@@ -136,40 +121,16 @@ public class ResolveVisitor extends ClassCodeVisitorSupport implements Expressio
         currentScope = oldScope;
     }
 
-    public void visitSwitch(SwitchStatement statement) {
-        Expression exp = statement.getExpression();
-        statement.setExpression(transform(exp));
-        List list = statement.getCaseStatements();
-        for (Iterator iter = list.iterator(); iter.hasNext(); ) {
-            CaseStatement caseStatement = (CaseStatement) iter.next();
-            caseStatement.visit(this);
-        }
-        statement.getDefaultStatement().visit(this);
-    }
-
     public void visitField(FieldNode node) {
-        visitAnnotations(node);
         ClassNode t = node.getType();
         resolveOrFail(t,node);
-        Expression init = node.getInitialExpression();
-        node.setInitialValueExpression(transform(init));
+        super.visitField(node);
     }
 
     public void visitProperty(PropertyNode node) {
-        visitAnnotations(node);
         ClassNode t = node.getType();
         resolveOrFail(t,node);
-        Statement code = node.getGetterBlock();
-        if (code!=null) code.visit(this);
-        code = node.getSetterBlock();
-        if (code!=null) code.visit(this);
-    }
-
-    public void visitIfElse(IfStatement ifElse) {
-        visitStatement(ifElse);
-        ifElse.setBooleanExpression((BooleanExpression) (transform(ifElse.getBooleanExpression())));
-        ifElse.getIfBlock().visit(this);
-        ifElse.getElseBlock().visit(this);
+        super.visitProperty(node);
     }
 
     private void resolveOrFail(ClassNode type, String msg, ASTNode node) {
@@ -192,7 +153,7 @@ public class ResolveVisitor extends ClassCodeVisitorSupport implements Expressio
     }
 
     private boolean resolve(ClassNode type, boolean testModuleImports, boolean testDefaultImports, boolean testStaticInnerClasses) {
-        if (type.isResolved()) return true;
+        if (type.isResolved() || type.isPrimaryClassNode()) return true;
         resolveGenericsTypes(type.getGenericsTypes());
         if (type.isArray()) {
             ClassNode element = type.getComponentType();
@@ -421,72 +382,6 @@ public class ResolveVisitor extends ClassCodeVisitorSupport implements Expressio
          return false;
     }
 
-    private Expression findStaticFieldImportFromModule(String name) {
-        ModuleNode module = currentClass.getModule();
-        if (module == null) return null;
-        Map aliases = module.getStaticImportAliases();
-        if (aliases.containsKey(name)) {
-            ClassNode node = (ClassNode) aliases.get(name);
-            Map fields = module.getStaticImportFields();
-            String fieldName = (String) fields.get(name);
-            Expression expression = findStaticField(node, fieldName);
-            if (expression != null) return expression;
-    }
-        Map importedClasses = module.getStaticImportClasses();
-        Iterator it = importedClasses.keySet().iterator();
-        while (it.hasNext()) {
-            String className = (String) it.next();
-            ClassNode node = (ClassNode) importedClasses.get(className);
-            Expression expression = findStaticField(node, name);
-            if (expression != null) return expression;
-        }
-        return null;
-    }
-
-    private Expression findStaticField(ClassNode staticImportType, String fieldName) {
-        if (resolve(staticImportType, true, true, true)) {
-            staticImportType.getFields(); // force init
-            FieldNode field = staticImportType.getField(fieldName);
-            if (field != null && field.isStatic()) {
-                return new PropertyExpression(new ClassExpression(staticImportType), fieldName);
-            }
-        }
-        return null;
-    }
-
-    private Expression findStaticMethodImportFromModule(Expression method, Expression args) {
-        ModuleNode module = currentClass.getModule();
-        if (module == null || !(method instanceof ConstantExpression)) return null;
-        Map aliases = module.getStaticImportAliases();
-        ConstantExpression ce = (ConstantExpression) method;
-        final String name = (String) ce.getValue();
-        if (aliases.containsKey(name)) {
-            ClassNode node = (ClassNode) aliases.get(name);
-            Map fields = module.getStaticImportFields();
-            String fieldName = (String) fields.get(name);
-            Expression expression = findStaticMethod(node, fieldName, args);
-            if (expression != null) return expression;
-        }
-        Map importPackages = module.getStaticImportClasses();
-        Iterator it = importPackages.keySet().iterator();
-        while (it.hasNext()) {
-            String className = (String) it.next();
-            ClassNode starImportType = (ClassNode) importPackages.get(className);
-            Expression expression = findStaticMethod(starImportType, name, args);
-            if (expression != null) return expression;
-        }
-        return null;
-    }
-
-    private Expression findStaticMethod(ClassNode staticImportType, String methodName, Expression args) {
-        if (resolve(staticImportType, true, true, true)) {
-            if (staticImportType.hasPossibleStaticMethod(methodName, args)) {
-                return new StaticMethodCallExpression(staticImportType, methodName, args);
-            }
-        }
-        return null;
-    }
-
     private boolean resolveFromModule(ClassNode type, boolean testModuleImports) {
         String name = type.getName();
         ModuleNode module = currentClass.getModule();
@@ -718,10 +613,6 @@ public class ResolveVisitor extends ClassCodeVisitorSupport implements Expressio
         if (ve.getName().equals("super")) return VariableExpression.SUPER_EXPRESSION;
         Variable v = ve.getAccessedVariable();
         if (v instanceof DynamicVariable) {
-            Expression result = findStaticFieldImportFromModule(ve.getName());
-            if (result != null) {
-                return result;
-            }
             ClassNode t = ClassHelper.make(ve.getName());
             if (resolve(t)) {
                 // the name is a type so remove it from the scoping
@@ -807,12 +698,6 @@ public class ResolveVisitor extends ClassCodeVisitorSupport implements Expressio
         Expression args = transform(mce.getArguments());
         Expression method = transform(mce.getMethod());
 
-        if (mce.isImplicitThis()) {
-            Expression ret = findStaticMethodImportFromModule(method, args);
-            if (ret != null) {
-        return ret;
-    }
-        }
         Expression obj = mce.getObjectExpression();
         Expression newObject = transform(obj);
         MethodCallExpression result = new MethodCallExpression(newObject,method,args);
@@ -865,8 +750,8 @@ public class ResolveVisitor extends ClassCodeVisitorSupport implements Expressio
                 member.setValue(transform(memberValue));
             }
         }
-    }
-
+    }    
+    
     public void visitClass(ClassNode node) {
         ClassNode oldNode = currentClass;
         currentClass = node;
@@ -882,6 +767,22 @@ public class ResolveVisitor extends ClassCodeVisitorSupport implements Expressio
                if (resolve(type,false,false,true)) continue;
                addError("unable to resolve class "+type.getName(),type);
            }
+           Map importPackages = module.getStaticImportClasses();
+           for (Iterator iter = importPackages.values().iterator(); iter.hasNext();) {
+               ClassNode type = (ClassNode) iter.next();
+               if (resolve(type,false,false,true)) continue;
+               addError("unable to resolve class "+type.getName(),type);               
+           }
+           for (Iterator iter = module.getStaticImportAliases().values().iterator(); iter.hasNext();) {
+               ClassNode type = (ClassNode) iter.next();
+               if (resolve(type,true,true,true)) continue;
+               addError("unable to resolve class "+type.getName(),type);               
+           }
+           for (Iterator iter = module.getStaticImportClasses().values().iterator(); iter.hasNext();) {
+               ClassNode type = (ClassNode) iter.next();
+               if (resolve(type,true,true,true)) continue;
+               addError("unable to resolve class "+type.getName(),type);               
+           }
            module.setImportsResolved(true);
         }
 
@@ -898,21 +799,7 @@ public class ResolveVisitor extends ClassCodeVisitorSupport implements Expressio
         
         currentClass = oldNode;
     }
-
-    public void visitReturnStatement(ReturnStatement statement) {
-       statement.setExpression(transform(statement.getExpression()));
-    }
-
-    public void visitAssertStatement(AssertStatement as) {
-        as.setBooleanExpression((BooleanExpression) (transform(as.getBooleanExpression())));
-        as.setMessageExpression(transform(as.getMessageExpression()));
-    }
-
-    public void visitCaseStatement(CaseStatement statement) {
-    	statement.setExpression(transform(statement.getExpression()));
-    	statement.getCode().visit(this);
-    }
-
+    
     public void visitCatchStatement(CatchStatement cs) {
         resolveOrFail(cs.getExceptionType(),cs);
         if (cs.getExceptionType()==ClassHelper.DYNAMIC_TYPE) {
@@ -920,36 +807,12 @@ public class ResolveVisitor extends ClassCodeVisitorSupport implements Expressio
         }
         super.visitCatchStatement(cs);
     }
-
-    public void visitDoWhileLoop(DoWhileStatement loop) {
-        loop.setBooleanExpression((BooleanExpression) (transform(loop.getBooleanExpression())));
-        super.visitDoWhileLoop(loop);
-    }
-
+    
     public void visitForLoop(ForStatement forLoop) {
-        forLoop.setCollectionExpression(transform(forLoop.getCollectionExpression()));
         resolveOrFail(forLoop.getVariableType(),forLoop);
         super.visitForLoop(forLoop);
     }
 
-    public void visitSynchronizedStatement(SynchronizedStatement sync) {
-        sync.setExpression(transform(sync.getExpression()));
-        super.visitSynchronizedStatement(sync);
-    }
-
-    public void visitThrowStatement(ThrowStatement ts) {
-        ts.setExpression(transform(ts.getExpression()));
-    }
-
-    public void visitWhileLoop(WhileStatement loop) {
-    	loop.setBooleanExpression((BooleanExpression) transform(loop.getBooleanExpression()));
-    	super.visitWhileLoop(loop);
-    }
-
-    public void visitExpressionStatement(ExpressionStatement es) {
-        es.setExpression(transform(es.getExpression()));
-    }
-
     public void visitBlockStatement(BlockStatement block) {
         VariableScope oldScope = currentScope;
         currentScope = block.getVariableScope();
diff --git a/src/main/org/codehaus/groovy/control/StaticImportVisitor.java b/src/main/org/codehaus/groovy/control/StaticImportVisitor.java
new file mode 100644
index 0000000000..9a1cbcd9e1
--- /dev/null
+++ b/src/main/org/codehaus/groovy/control/StaticImportVisitor.java
@@ -0,0 +1,148 @@
+/*
+ * Copyright 2003-2007 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.codehaus.groovy.control;
+
+import java.util.Iterator;
+import java.util.Map;
+
+import org.codehaus.groovy.ast.ClassCodeExpressionTransformer;
+import org.codehaus.groovy.ast.ClassNode;
+import org.codehaus.groovy.ast.DynamicVariable;
+import org.codehaus.groovy.ast.FieldNode;
+import org.codehaus.groovy.ast.ModuleNode;
+import org.codehaus.groovy.ast.Variable;
+import org.codehaus.groovy.ast.expr.*;
+
+/**
+ * Visitor to resolve constants and method calls from static Imports
+ *
+ * @author Jochen Theodorou
+ * @auther Paul King
+ */
+public class StaticImportVisitor extends ClassCodeExpressionTransformer {
+    private ClassNode currentClass;
+    private CompilationUnit compilationUnit;
+
+    public StaticImportVisitor(CompilationUnit cu) {
+        compilationUnit = cu;
+    }
+
+    public void visitClass(ClassNode node) {
+        this.currentClass = node;
+        super.visitClass(node);
+    }
+
+    private Expression findStaticFieldImportFromModule(String name) {
+        ModuleNode module = currentClass.getModule();
+        if (module == null) return null;
+        Map aliases = module.getStaticImportAliases();
+        if (aliases.containsKey(name)) {
+            ClassNode node = (ClassNode) aliases.get(name);
+            Map fields = module.getStaticImportFields();
+            String fieldName = (String) fields.get(name);
+            Expression expression = findStaticField(node, fieldName);
+            if (expression != null) return expression;
+        }
+        Map importedClasses = module.getStaticImportClasses();
+        Iterator it = importedClasses.keySet().iterator();
+        while (it.hasNext()) {
+            String className = (String) it.next();
+            ClassNode node = (ClassNode) importedClasses.get(className);
+            Expression expression = findStaticField(node, name);
+            if (expression != null) return expression;
+        }
+        return null;
+    }
+
+    private Expression findStaticField(ClassNode staticImportType, String fieldName) {
+        if (staticImportType.isPrimaryClassNode() || staticImportType.isResolved()) {
+            staticImportType.getFields(); // force init
+            FieldNode field = staticImportType.getField(fieldName);
+            if (field != null && field.isStatic()) {
+                return new PropertyExpression(new ClassExpression(staticImportType), fieldName);
+            }
+        }
+        return null;
+    }
+
+    private Expression findStaticMethodImportFromModule(Expression method, Expression args) {
+        ModuleNode module = currentClass.getModule();
+        if (module == null || !(method instanceof ConstantExpression)) return null;
+        Map aliases = module.getStaticImportAliases();
+        ConstantExpression ce = (ConstantExpression) method;
+        final String name = (String) ce.getValue();
+        if (aliases.containsKey(name)) {
+            ClassNode node = (ClassNode) aliases.get(name);
+            Map fields = module.getStaticImportFields();
+            String fieldName = (String) fields.get(name);
+            Expression expression = findStaticMethod(node, fieldName, args);
+            if (expression != null) return expression;
+        }
+        Map importPackages = module.getStaticImportClasses();
+        Iterator it = importPackages.keySet().iterator();
+        while (it.hasNext()) {
+            String className = (String) it.next();
+            ClassNode starImportType = (ClassNode) importPackages.get(className);
+            Expression expression = findStaticMethod(starImportType, name, args);
+            if (expression != null) return expression;
+        }
+        return null;
+    }
+
+    private Expression findStaticMethod(ClassNode staticImportType, String methodName, Expression args) {
+        if (staticImportType.isPrimaryClassNode() || staticImportType.isResolved()) {
+            if (staticImportType.hasPossibleStaticMethod(methodName, args)) {
+                return new StaticMethodCallExpression(staticImportType, methodName, args);
+            }
+        }
+        return null;
+    }
+
+    public Expression transform(Expression exp) {
+        if (exp==null) return null;
+        if (exp instanceof VariableExpression) {
+            return transformVariableExpression((VariableExpression) exp);
+        } else if (exp instanceof MethodCallExpression) {
+            return transformMethodCallExpression((MethodCallExpression)exp);
+        } else {
+            return exp.transformExpression(this);
+        }
+    }
+
+    protected Expression transformVariableExpression(VariableExpression ve) {
+        Variable v = ve.getAccessedVariable();
+        if (v instanceof DynamicVariable) {
+            Expression result = findStaticFieldImportFromModule(ve.getName());
+            if (result != null) return result;
+        }
+        return ve;
+    }
+    
+    protected Expression transformMethodCallExpression(MethodCallExpression mce) {
+        Expression args = transform(mce.getArguments());
+        Expression method = transform(mce.getMethod());
+
+        if (mce.isImplicitThis()) {
+            Expression ret = findStaticMethodImportFromModule(method, args);
+            if (ret != null) return ret;
+        }
+        return mce;
+    }
+
+    protected SourceUnit getSourceUnit() {
+        return null;
+    }
+}
