diff --git a/src/main/java/groovy/lang/MetaClassImpl.java b/src/main/java/groovy/lang/MetaClassImpl.java
index 2753ce21c2..1b9f504ffc 100644
--- a/src/main/java/groovy/lang/MetaClassImpl.java
+++ b/src/main/java/groovy/lang/MetaClassImpl.java
@@ -1057,7 +1057,8 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
                     }
                 } else if (ownerClass != Class.class) { // not "new"; maybe it's a reference to a Class method
                     try {
-                        return InvokerHelper.getMetaClass(owner).invokeMethod(Class.class, owner, methodName, arguments, false, false);
+                        MetaClass cmc = registry.getMetaClass(Class.class);
+                        return cmc.invokeMethod(Class.class, owner, methodName, arguments, false, false);
 
                     } catch (MissingMethodExceptionNoStack nope) {
                     }
@@ -1670,8 +1671,8 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
             }
         }
         if (method == null && theClass != Class.class) {
-            MetaClass classMetaClass = registry.getMetaClass(Class.class);
-            method = classMetaClass.pickMethod(methodName, arguments);
+            MetaClass cmc = registry.getMetaClass(Class.class);
+            method = cmc.pickMethod(methodName, arguments);
         }
         if (method == null) {
             method = (MetaMethod) chooseMethod(methodName, methods, MetaClassHelper.convertToTypeArray(arguments));
@@ -2009,14 +2010,19 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
             method = genericGetMethod;
         }
 
-        if (method == null) {
+        if (method != null) {
+            //------------------------------------------------------------------
+            // executing the method
+            //------------------------------------------------------------------
+            MetaMethod metaMethod = VM_PLUGIN.transformMetaMethod(this, method);
+            return metaMethod.doMethodInvoke(object, arguments);
+        } else {
             //------------------------------------------------------------------
-            // special cases
+            // special cases -- maybe these cases should be special MetaClasses!
             //------------------------------------------------------------------
-            // TODO: maybe these special cases should be special MetaClasses
-            if (theClass != Class.class && object instanceof Class) {
-                MetaClass mc = registry.getMetaClass(Class.class);
-                return mc.getProperty(Class.class, object, name, useSuper, false);
+            if (isStatic) {
+                MetaClass cmc = registry.getMetaClass(Class.class);
+                return cmc.getProperty(Class.class, object, name, false, false);
             }
             if (object instanceof Collection) {
                 return DefaultGroovyMethods.getAt((Collection<?>) object, name);
@@ -2029,18 +2035,12 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
                 // TODO: one day we could try return the previously registered Closure listener for easy removal
                 return null;
             }
-        } else {
-            //------------------------------------------------------------------
-            // executing the method
-            //------------------------------------------------------------------
-            MetaMethod transformedMetaMethod = VM_PLUGIN.transformMetaMethod(this, method);
-            return transformedMetaMethod.doMethodInvoke(object, arguments);
         }
 
         //----------------------------------------------------------------------
         // missing property protocol
         //----------------------------------------------------------------------
-        if (isStatic || object instanceof Class) {
+        if (object instanceof Class) {
             return invokeStaticMissingProperty(object, name, null, true);
         }
         return invokeMissingProperty(object, name, null, true);
@@ -2136,8 +2136,8 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
             return new MetaProperty(name, Object.class) {
                 @Override
                 public Object getProperty(Object object) {
-                    MetaClass mc = registry.getMetaClass(Class.class);
-                    return mc.getProperty(Class.class, object, name, useSuper, false);
+                    MetaClass cmc = registry.getMetaClass(Class.class);
+                    return cmc.getProperty(Class.class, object, name, false, false);
                 }
 
                 @Override
@@ -2796,9 +2796,9 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
         //----------------------------------------------------------------------
         // handling of static
         //----------------------------------------------------------------------
-        boolean isStatic = theClass != Class.class && object instanceof Class;
+        boolean isStatic = (theClass != Class.class && object instanceof Class);
         if (isStatic && object != theClass) {
-            MetaClass mc = registry.getMetaClass((Class) object);
+            MetaClass mc = registry.getMetaClass((Class<?>) object);
             mc.getProperty(sender, object, name, useSuper, fromInsideClass);
             return;
         }
@@ -2936,7 +2936,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
         if (mp != null) {
             throw new ReadOnlyPropertyException(name, theClass);
         }
-        if ((isStatic || object instanceof Class) && !"metaClass".equals(name)) {
+        if (object instanceof Class && !"metaClass".equals(name)) {
             invokeStaticMissingProperty(object, name, newValue, false);
         } else {
             invokeMissingProperty(object, name, newValue, false);
@@ -3010,14 +3010,13 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
     public Object getAttribute(final Class sender, final Object object, final String attribute, final boolean useSuper, final boolean fromInsideClass) {
         checkInitalised();
 
-        boolean isStatic = theClass != Class.class && object instanceof Class;
+        boolean isStatic = (theClass != Class.class && object instanceof Class);
         if (isStatic && object != theClass) {
-            MetaClass mc = registry.getMetaClass((Class) object);
+            MetaClass mc = registry.getMetaClass((Class<?>) object);
             return mc.getAttribute(sender, object, attribute, useSuper);
         }
 
         MetaProperty mp = getMetaProperty(sender, attribute, useSuper, isStatic);
-
         if (mp != null) {
             if (mp instanceof MetaBeanProperty) {
                 MetaBeanProperty mbp = (MetaBeanProperty) mp;
@@ -3052,15 +3051,14 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
     public void setAttribute(final Class sender, final Object object, final String attribute, final Object newValue, final boolean useSuper, final boolean fromInsideClass) {
         checkInitalised();
 
-        boolean isStatic = theClass != Class.class && object instanceof Class;
+        boolean isStatic = (theClass != Class.class && object instanceof Class);
         if (isStatic && object != theClass) {
-            MetaClass mc = registry.getMetaClass((Class) object);
+            MetaClass mc = registry.getMetaClass((Class<?>) object);
             mc.setAttribute(sender, object, attribute, newValue, useSuper, fromInsideClass);
             return;
         }
 
         MetaProperty mp = getMetaProperty(sender, attribute, useSuper, isStatic);
-
         if (mp != null) {
             if (mp instanceof MetaBeanProperty) {
                 MetaBeanProperty mbp = (MetaBeanProperty) mp;
diff --git a/src/main/java/org/codehaus/groovy/runtime/InvokerHelper.java b/src/main/java/org/codehaus/groovy/runtime/InvokerHelper.java
index b6fa036b7d..f226d55832 100644
--- a/src/main/java/org/codehaus/groovy/runtime/InvokerHelper.java
+++ b/src/main/java/org/codehaus/groovy/runtime/InvokerHelper.java
@@ -561,10 +561,13 @@ public class InvokerHelper {
     }
 
     public static MetaClass getMetaClass(Object object) {
-        if (object instanceof GroovyObject)
+        if (object instanceof GroovyObject) {
             return ((GroovyObject) object).getMetaClass();
-        else
+        } else if (object instanceof Class) {
+            return metaRegistry.getMetaClass((Class<?>) object); // GROOVY-10819
+        } else {
             return ((MetaClassRegistryImpl) GroovySystem.getMetaClassRegistry()).getMetaClass(object);
+        }
     }
 
     public static MetaClass getMetaClass(Class cls) {
diff --git a/src/main/java/org/codehaus/groovy/runtime/callsite/PojoMetaClassSite.java b/src/main/java/org/codehaus/groovy/runtime/callsite/PojoMetaClassSite.java
index 7acfca411c..03d59dcdef 100644
--- a/src/main/java/org/codehaus/groovy/runtime/callsite/PojoMetaClassSite.java
+++ b/src/main/java/org/codehaus/groovy/runtime/callsite/PojoMetaClassSite.java
@@ -27,33 +27,34 @@ import org.codehaus.groovy.runtime.ScriptBytecodeAdapter;
  * POJO call site
  *   metaclass - cached
  *   method - not cached
-*/
-public class PojoMetaClassSite extends MetaClassSite{
+ */
+public class PojoMetaClassSite extends MetaClassSite {
+
     private final ClassInfo classInfo;
     private final int version;
 
-    public PojoMetaClassSite(CallSite site, MetaClass metaClass) {
+    public PojoMetaClassSite(final CallSite site, final MetaClass metaClass) {
         super(site, metaClass);
         classInfo = ClassInfo.getClassInfo(metaClass.getTheClass());
         version = classInfo.getVersion();
     }
 
     @Override
-    public Object call(Object receiver, Object[] args) throws Throwable {
-        if(checkCall(receiver)) {
-          try{
-              return metaClass.invokeMethod(receiver, name, args);
-          } catch (GroovyRuntimeException gre) {
-              throw ScriptBytecodeAdapter.unwrap(gre);
-          }
+    public Object call(final Object receiver, final Object[] args) throws Throwable {
+        if (checkCall(receiver)) {
+            try {
+                return metaClass.invokeMethod(receiver, name, args);
+            } catch (GroovyRuntimeException gre) {
+                throw ScriptBytecodeAdapter.unwrap(gre);
+            }
         } else {
-          return CallSiteArray.defaultCall(this, receiver, args);
+            return CallSiteArray.defaultCall(this, receiver, args);
         }
     }
 
-    protected final boolean checkCall(Object receiver) {
-        return  receiver!=null &&
-                receiver.getClass() == metaClass.getTheClass() &&
-                version == classInfo.getVersion(); // metaClass is still valid
+    protected final boolean checkCall(final Object receiver) {
+        return receiver != null
+            && receiver.getClass() == metaClass.getTheClass()
+            && version == classInfo.getVersion(); // metaClass is still valid
     }
 }
diff --git a/src/main/java/org/codehaus/groovy/runtime/metaclass/MetaClassRegistryImpl.java b/src/main/java/org/codehaus/groovy/runtime/metaclass/MetaClassRegistryImpl.java
index 8b33af99b7..14b5681c93 100644
--- a/src/main/java/org/codehaus/groovy/runtime/metaclass/MetaClassRegistryImpl.java
+++ b/src/main/java/org/codehaus/groovy/runtime/metaclass/MetaClassRegistryImpl.java
@@ -270,27 +270,26 @@ public class MetaClassRegistryImpl implements MetaClassRegistry{
     }
 
     public MetaClass getMetaClass(Object obj) {
-        return ClassInfo.getClassInfo(obj.getClass()).getMetaClass(obj);
+        Class theClass = obj instanceof Class ? (Class)obj : obj.getClass();
+        return ClassInfo.getClassInfo(theClass).getMetaClass(obj);
     }
 
     /**
-     * if oldMc is null, newMc will replace whatever metaclass was used before.
-     * if oldMc is not null, then newMc will be used only if the stored mc is
-     * the same as oldMc
+     * If oldMC is null, newMC will replace whatever MC is present.
+     * Otherwise, newMC will be used only if the stored MC is the same as oldMC
      */
-    private void setMetaClass(Class theClass, MetaClass oldMc, MetaClass newMc) {
-        final ClassInfo info = ClassInfo.getClassInfo(theClass);
-
+    private void setMetaClass(Class theClass, MetaClass oldMC, MetaClass newMC) {
+        ClassInfo info = ClassInfo.getClassInfo(theClass);
         MetaClass mc = null;
         info.lock();
         try {
             mc = info.getStrongMetaClass();
-            info.setStrongMetaClass(newMc);
+            info.setStrongMetaClass(newMC);
         } finally {
             info.unlock();
         }
-        if ((oldMc == null && mc != newMc) || (oldMc != null && mc != newMc && mc != oldMc)) {
-            fireConstantMetaClassUpdate(null, theClass, mc, newMc);
+        if ((oldMC == null && mc != newMC) || (oldMC != null && mc != newMC && mc != oldMC)) {
+            fireConstantMetaClassUpdate(null, theClass, mc, newMC);
         }
     }
 
@@ -299,35 +298,26 @@ public class MetaClassRegistryImpl implements MetaClassRegistry{
         setMetaClass(theClass, null, null);
     }
 
-    /**
-     * Registers a new MetaClass in the registry to customize the type
-     *
-     * @param theClass
-     * @param theMetaClass
-     */
     @Override
     public void setMetaClass(Class theClass, MetaClass theMetaClass) {
-        setMetaClass(theClass,null,theMetaClass);
+        setMetaClass(theClass, null, theMetaClass);
     }
 
-
     public void setMetaClass(Object obj, MetaClass theMetaClass) {
-        Class theClass = obj.getClass ();
-        final ClassInfo info = ClassInfo.getClassInfo(theClass);
-        MetaClass oldMC = null;
+        Class theClass = obj instanceof Class ? (Class)obj : obj.getClass();
+        ClassInfo info = ClassInfo.getClassInfo(theClass);
+        MetaClass mc = null;
         info.lock();
         try {
-            oldMC = info.getPerInstanceMetaClass(obj);
+            mc = info.getPerInstanceMetaClass(obj);
             info.setPerInstanceMetaClass(obj, theMetaClass);
         }
         finally {
             info.unlock();
         }
-
-        fireConstantMetaClassUpdate(obj, theClass, oldMC, theMetaClass);
+        fireConstantMetaClassUpdate(obj, theClass, mc, theMetaClass);
     }
 
-
     public boolean useAccessible() {
         return useAccessible;
     }
diff --git a/src/spec/test/testingguide/MockingExampleTests.groovy b/src/spec/test/testingguide/MockingExampleTests.groovy
index ae3da30715..924c77d43f 100644
--- a/src/spec/test/testingguide/MockingExampleTests.groovy
+++ b/src/spec/test/testingguide/MockingExampleTests.groovy
@@ -134,7 +134,7 @@ class MockingExampleTests extends GroovyTestCase {
         // end::emc[]
 
         // tag::emc4[]
-        GroovySystem.metaClassRegistry.setMetaClass(java.lang.String, null)
+        GroovySystem.metaClassRegistry.removeMetaClass(String)
         // end::emc4[]
     }
 
diff --git a/src/test/groovy/bugs/Groovy3873Bug.groovy b/src/test/groovy/bugs/Groovy3873Bug.groovy
index 5e3ed63735..77f07a8a20 100644
--- a/src/test/groovy/bugs/Groovy3873Bug.groovy
+++ b/src/test/groovy/bugs/Groovy3873Bug.groovy
@@ -30,7 +30,8 @@ class Groovy3873Bug extends GroovyTestCase {
             def list = []
             assert list.noSuchMethod()
         } finally {
+            List.metaClass = null
             ExpandoMetaClass.disableGlobally()
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/MixedModeStaticCompilationTest.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/MixedModeStaticCompilationTest.groovy
index 87d8452782..1ef31745fd 100644
--- a/src/test/org/codehaus/groovy/classgen/asm/sc/MixedModeStaticCompilationTest.groovy
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/MixedModeStaticCompilationTest.groovy
@@ -31,262 +31,229 @@ final class MixedModeStaticCompilationTest extends StaticTypeCheckingTestCase im
     }
 
     void testDynamicMethodCall() {
-        try {
-            assertScript '''import groovy.transform.CompileStatic
-                @CompileStatic(extensions='groovy/transform/sc/MixedMode.groovy')
-                int bar() {
-                    foo() + baz()
-                }
-                int baz() {
-                    456
-                }
-                this.metaClass.foo = { 123 }
-                assert bar() == 579
-            '''
-        } finally {
-            // println astTrees
-        }
+        assertScript '''import groovy.transform.CompileStatic
+            @CompileStatic(extensions='groovy/transform/sc/MixedMode.groovy')
+            int bar() {
+                foo() + baz()
+            }
+            int baz() {
+                456
+            }
+            this.metaClass.foo = { 123 }
+            assert bar() == 579
+        '''
     }
 
     void testDynamicMethodCallInsideClosure() {
-        try {
-            assertScript '''import groovy.transform.CompileStatic
-                @CompileStatic(extensions='groovy/transform/sc/MixedMode.groovy')
-                int bar() {
-                    def cl = { foo() + baz() }
-                    cl()
-                }
-                int baz() {
-                    456
-                }
-                this.metaClass.foo = { 123 }
-                assert bar() == 579
-            '''
-        } finally {
-//            println astTrees
-        }
+        assertScript '''import groovy.transform.CompileStatic
+            @CompileStatic(extensions='groovy/transform/sc/MixedMode.groovy')
+            int bar() {
+                def cl = { foo() + baz() }
+                cl()
+            }
+            int baz() {
+                456
+            }
+            this.metaClass.foo = { 123 }
+            assert bar() == 579
+        '''
     }
 
     void testDynamicMethodCallWithStaticCallArgument() {
-        try {
-            assertScript '''import groovy.transform.CompileStatic
-                @CompileStatic(extensions='groovy/transform/sc/MixedMode.groovy')
-                int bar() {
-                    twice(baz())
-                }
-                int baz() {
-                    456
-                }
-                this.metaClass.twice = { 2*it }
-                assert bar() == 912
-            '''
-        } finally {
-            // println astTrees
-        }
+        assertScript '''import groovy.transform.CompileStatic
+            @CompileStatic(extensions='groovy/transform/sc/MixedMode.groovy')
+            int bar() {
+                twice(baz())
+            }
+            int baz() {
+                456
+            }
+            this.metaClass.twice = { 2*it }
+            assert bar() == 912
+        '''
     }
 
     void testDynamicMethodCallOnField() {
-        try {
-            assertScript '''import groovy.transform.CompileStatic
-                @CompileStatic(extensions='groovy/transform/sc/MixedMode.groovy')
-                class Holder {
-                    def delegate
-                    int bar() {
-                        2*delegate.baz()
-                    }
-                }
-                class Baz {
-                    int baz() { 456 }
+        assertScript '''import groovy.transform.CompileStatic
+            @CompileStatic(extensions='groovy/transform/sc/MixedMode.groovy')
+            class Holder {
+                def delegate
+                int bar() {
+                    2*delegate.baz()
                 }
-                def holder = new Holder(delegate: new Baz())
-                assert holder.bar() == 912
-            '''
-        } finally {
-            // println astTrees
-        }
+            }
+            class Baz {
+                int baz() { 456 }
+            }
+            def holder = new Holder(delegate: new Baz())
+            assert holder.bar() == 912
+        '''
     }
 
     void testDynamicProperty() {
-        try {
-            assertScript '''import groovy.transform.CompileStatic
-                @CompileStatic(extensions='groovy/transform/sc/MixedMode.groovy')
-                int value(String str) {
-                    str.val
-                }
-                @Category(String)
-                class StringCategory {
-                    int getVal() { this.length() }
-                }
-                use (StringCategory) {
-                    assert value('abc') == 3
-                }
-            '''
-        } finally {
-            // println astTrees
-        }
+        assertScript '''import groovy.transform.CompileStatic
+            @CompileStatic(extensions='groovy/transform/sc/MixedMode.groovy')
+            int value(String str) {
+                str.val
+            }
+            @Category(String)
+            class StringCategory {
+                int getVal() { this.length() }
+            }
+            use (StringCategory) {
+                assert value('abc') == 3
+            }
+        '''
     }
 
     void testDynamicPropertyMixedWithStatic() {
-        try {
-            assertScript '''import groovy.transform.CompileStatic
-                @CompileStatic(extensions='groovy/transform/sc/MixedMode.groovy')
-                class Holder {
-                    int offset() { 2 }
-                    int value(String str) {
-                        str.val + offset()
-                    }
-                }
-                @Category(String)
-                class StringCategory {
-                    int getVal() { this.length() }
-                }
-                def holder = new Holder()
-                use (StringCategory) {
-                    assert holder.value('abc') == 5
+        assertScript '''import groovy.transform.CompileStatic
+            @CompileStatic(extensions='groovy/transform/sc/MixedMode.groovy')
+            class Holder {
+                int offset() { 2 }
+                int value(String str) {
+                    str.val + offset()
                 }
-            '''
-        } finally {
-            // println astTrees
-        }
+            }
+            @Category(String)
+            class StringCategory {
+                int getVal() { this.length() }
+            }
+            def holder = new Holder()
+            use (StringCategory) {
+                assert holder.value('abc') == 5
+            }
+        '''
     }
 
     void testDynamicPropertyAsStaticArgument() {
-        try {
-            assertScript '''import groovy.transform.CompileStatic
-                @CompileStatic(extensions='groovy/transform/sc/MixedMode.groovy')
-                class Holder {
-                    int twice(int v) { 2*v }
-                    int value(String str) {
-                        twice(str.val)
-                    }
-                }
-                @Category(String)
-                class StringCategory {
-                    int getVal() { this.length() }
-                }
-                def holder = new Holder()
-                use (StringCategory) {
-                    assert holder.value('abc') == 6
+        assertScript '''import groovy.transform.CompileStatic
+            @CompileStatic(extensions='groovy/transform/sc/MixedMode.groovy')
+            class Holder {
+                int twice(int v) { 2*v }
+                int value(String str) {
+                    twice(str.val)
                 }
-            '''
-        } finally {
-            // println astTrees
-        }
+            }
+            @Category(String)
+            class StringCategory {
+                int getVal() { this.length() }
+            }
+            def holder = new Holder()
+            use (StringCategory) {
+                assert holder.value('abc') == 6
+            }
+        '''
     }
 
     void testDynamicVariable() {
-        try {
-            shell.setVariable("myVariable", 123)
-            assertScript '''import groovy.transform.CompileStatic
-                @CompileStatic(extensions='groovy/transform/sc/MixedMode.groovy')
-                int value() {
-                    myVariable
-                }
-                assert value() == 123
-            '''
-        } finally {
-            // println astTrees
-        }
+        shell.setVariable('myVariable', 123)
+        assertScript '''import groovy.transform.CompileStatic
+            @CompileStatic(extensions='groovy/transform/sc/MixedMode.groovy')
+            int value() {
+                myVariable
+            }
+            assert value() == 123
+        '''
     }
 
     void testDynamicVariableMixedWithStaticCall() {
-        try {
-            shell.setVariable("myVariable", 123)
-            assertScript '''import groovy.transform.CompileStatic
-                @CompileStatic(extensions='groovy/transform/sc/MixedMode.groovy')
-                class Holder {
-                    def binding
-                    def propertyMissing(String name) { binding.getVariable(name) }
-                    int value() {
-                        myVariable + offset()
-                    }
-                    int offset() { 123 }
+        shell.setVariable('myVariable', 123)
+        assertScript '''import groovy.transform.CompileStatic
+            @CompileStatic(extensions='groovy/transform/sc/MixedMode.groovy')
+            class Holder {
+                def binding
+                def propertyMissing(String name) { binding.getVariable(name) }
+                int value() {
+                    myVariable + offset()
                 }
-                def h = new Holder(binding:binding)
-                assert h.value() == 246
-            '''
-        } finally {
-            // println astTrees
-        }
+                int offset() { 123 }
+            }
+            def h = new Holder(binding:binding)
+            assert h.value() == 246
+        '''
     }
 
     void testDynamicVariableAsStaticCallParameter() {
-        try {
-            shell.setVariable("myVariable", 123)
-            assertScript '''import groovy.transform.CompileStatic
-                @CompileStatic(extensions='groovy/transform/sc/MixedMode.groovy')
-                class Holder {
-                    def binding
-                    def propertyMissing(String name) { binding.getVariable(name) }
-                    int value() {
-                        twice(myVariable)
-                    }
-                    int twice(int x) { 2*x }
+        shell.setVariable('myVariable', 123)
+        assertScript '''import groovy.transform.CompileStatic
+            @CompileStatic(extensions='groovy/transform/sc/MixedMode.groovy')
+            class Holder {
+                def binding
+                def propertyMissing(String name) { binding.getVariable(name) }
+                int value() {
+                    twice(myVariable)
                 }
-                def h = new Holder(binding:binding)
-                assert h.value() == 246
-            '''
-        } finally {
-            // println astTrees
-        }
+                int twice(int x) { 2*x }
+            }
+            def h = new Holder(binding:binding)
+            assert h.value() == 246
+        '''
     }
 
     void testAllowMetaClass() {
         assertScript '''import groovy.transform.CompileStatic
             @CompileStatic(extensions='groovy/transform/sc/MixedMode.groovy')
             void test() {
+                assert String.metaClass !== Class.metaClass
+                assert String.metaClass !== Class.getMetaClass()
+                assert String.getMetaClass() !== Class.getMetaClass()
                 String.metaClass.up = { -> (delegate as String).toUpperCase() }
             }
-            test()
-            assert 'aaa'.up() == 'AAA'
+            try {
+                test()
+                assert 'aaa'.up() == 'AAA'
+            } finally {
+                GroovySystem.getMetaClassRegistry().removeMetaClass(String)
+            }
         '''
     }
 
     void testRecognizeStaticMethodCall() {
         assertScript '''import groovy.transform.CompileStatic
-                @CompileStatic(extensions='groovy/transform/sc/MixedMode2.groovy')
-                Map<String, Integer> foo() {
-                    String.map()
-                }
-                @CompileStatic(extensions='groovy/transform/sc/MixedMode2.groovy')
-                List<Integer> bar() {
-                    Date.list()
-                }
+            @CompileStatic(extensions='groovy/transform/sc/MixedMode2.groovy')
+            Map<String, Integer> foo() {
+                String.map()
+            }
+            @CompileStatic(extensions='groovy/transform/sc/MixedMode2.groovy')
+            List<Integer> bar() {
+                Date.list()
+            }
+            try {
                 String.metaClass.static.map = { [a: 1, b:2 ]}
                 Date.metaClass.static.list = { [1,2] }
                 assert foo().values().sort() == bar()
+            } finally {
+                GroovySystem.getMetaClassRegistry().removeMetaClass(Date)
+                GroovySystem.getMetaClassRegistry().removeMetaClass(String)
+            }
         '''
     }
 
     void testDynamicBuilder() {
-        try {
-            assertScript '''import groovy.transform.CompileStatic
-                import groovy.xml.MarkupBuilder
-
-                @CompileStatic(extensions='groovy/transform/sc/MixedModeDynamicBuilder.groovy')
-                String render(List<String> items) {
-                    def sw = new StringWriter()
-                    def mb = new MarkupBuilder(sw)
-                    mb.html {
-                        body {
-                            ul {
-                                items.each { String item ->
-                                    li("Item ${item.toUpperCase()}")
-                                }
+        assertScript '''import groovy.transform.CompileStatic
+            import groovy.xml.MarkupBuilder
+
+            @CompileStatic(extensions='groovy/transform/sc/MixedModeDynamicBuilder.groovy')
+            String render(List<String> items) {
+                def sw = new StringWriter()
+                def mb = new MarkupBuilder(sw)
+                mb.html {
+                    body {
+                        ul {
+                            items.each { String item ->
+                                li("Item ${item.toUpperCase()}")
                             }
                         }
                     }
-
-                    sw
                 }
-                def list = ['Chocolate','Milk','Butter']
-                def rendered = render(list).replaceAll(/[\r\n]|[ ]{2,}/,'')
-                assert rendered == '<html><body><ul><li>Item CHOCOLATE</li><li>Item MILK</li><li>Item BUTTER</li></ul></body></html>'
-                '''
-        } finally {
-//            println astTrees
-        }
 
+                sw
+            }
+            def list = ['Chocolate','Milk','Butter']
+            def rendered = render(list).replaceAll(/[\r\n]|[ ]{2,}/,'')
+            assert rendered == '<html><body><ul><li>Item CHOCOLATE</li><li>Item MILK</li><li>Item BUTTER</li></ul></body></html>'
+        '''
     }
 
     void testDynamicClassWithStaticConstructorAndInitialization() {
