diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index e4c6ddb17f..c5bc7df760 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -197,6 +197,7 @@ import static org.codehaus.groovy.ast.ClassHelper.isPrimitiveType;
 import static org.codehaus.groovy.ast.ClassHelper.isPrimitiveVoid;
 import static org.codehaus.groovy.ast.ClassHelper.isSAMType;
 import static org.codehaus.groovy.ast.ClassHelper.isStringType;
+import static org.codehaus.groovy.ast.ClassHelper.isWrapperBoolean;
 import static org.codehaus.groovy.ast.ClassHelper.isWrapperByte;
 import static org.codehaus.groovy.ast.ClassHelper.isWrapperCharacter;
 import static org.codehaus.groovy.ast.ClassHelper.isWrapperDouble;
@@ -204,6 +205,7 @@ import static org.codehaus.groovy.ast.ClassHelper.isWrapperFloat;
 import static org.codehaus.groovy.ast.ClassHelper.isWrapperInteger;
 import static org.codehaus.groovy.ast.ClassHelper.isWrapperLong;
 import static org.codehaus.groovy.ast.ClassHelper.isWrapperShort;
+import static org.codehaus.groovy.ast.ClassHelper.isWrapperVoid;
 import static org.codehaus.groovy.ast.ClassHelper.long_TYPE;
 import static org.codehaus.groovy.ast.ClassHelper.short_TYPE;
 import static org.codehaus.groovy.ast.tools.ClosureUtils.getParametersSafe;
@@ -4088,19 +4090,20 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         } else if (isClosureWithType(type) && source instanceof ClosureExpression) {
             storeInferredReturnType(source, getCombinedBoundType(type.getGenericsTypes()[0]));
         }
+        ClassNode expect = wrapTypeIfNecessary(getInferredReturnType(source)); // GROOVY-10277
 
         source.visit(this);
 
-        if (!expression.isCoerce() && !checkCast(type, source) && !isDelegateOrOwnerInClosure(source)) {
-            addStaticTypeError("Inconvertible types: cannot cast " + prettyPrintType(getType(source)) + " to " + prettyPrintType(type), expression);
+        if (!expression.isCoerce()) {
+            if (!checkCast(type, source))
+                addStaticTypeError("Inconvertible types: cannot cast " + prettyPrintType(getType(source)) + " to " + prettyPrintType(type), expression);
+        } else if (expect != null && !isObjectType(expect) && !isWrapperVoid(expect) && !isWrapperBoolean(expect)) {
+            ClassNode actual = getInferredReturnType(source); // check return type(s) against the target return type
+            if (actual != null && !GenericsUtils.buildWildcardType(expect).isCompatibleWith(wrapTypeIfNecessary(actual)))
+                addStaticTypeError("Cannot coerce lambda or closure returning " + prettyPrintType(actual) + " to " + prettyPrintType(type), expression);
         }
     }
 
-    private boolean isDelegateOrOwnerInClosure(final Expression exp) {
-        return typeCheckingContext.getEnclosingClosure() != null && exp instanceof VariableExpression
-                && (("delegate".equals(((VariableExpression) exp).getName())) || ("owner".equals(((VariableExpression) exp).getName())));
-    }
-
     protected boolean checkCast(final ClassNode targetType, final Expression source) {
         boolean sourceIsNull = isNullConstant(source);
         ClassNode expressionType = getType(source);
@@ -5846,8 +5849,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
      * @return the wrapped type
      */
     protected static ClassNode wrapTypeIfNecessary(final ClassNode type) {
-        if (isPrimitiveType(type)) return getWrapper(type);
-        return type;
+        return (type != null && isPrimitiveType(type) ? getWrapper(type) : type);
     }
 
     protected static boolean isClassInnerClassOrEqualTo(final ClassNode toBeChecked, final ClassNode start) {
diff --git a/src/test/groovy/bugs/Groovy8764Bug.groovy b/src/test/groovy/bugs/Groovy8764.groovy
similarity index 86%
rename from src/test/groovy/bugs/Groovy8764Bug.groovy
rename to src/test/groovy/bugs/Groovy8764.groovy
index 1150db1739..fe9905e9bf 100644
--- a/src/test/groovy/bugs/Groovy8764Bug.groovy
+++ b/src/test/groovy/bugs/Groovy8764.groovy
@@ -18,9 +18,13 @@
  */
 package groovy.bugs
 
-import groovy.test.GroovyTestCase
+import org.junit.Test
 
-class Groovy8764Bug extends GroovyTestCase {
+import static groovy.test.GroovyAssert.assertScript
+
+final class Groovy8764 {
+
+    @Test
     void testDgmMethodInClosureInAnonymousInnerClass() {
         assertScript '''
             import groovy.transform.*
@@ -44,7 +48,8 @@ class Groovy8764Bug extends GroovyTestCase {
         '''
     }
 
-    void testDgmMethodInClosureInInnerClass() {
+    @Test
+    void testDgmMethodInClosureInStaticInnerClass() {
         assertScript '''
             import groovy.transform.*
             import java.util.function.Function
@@ -54,10 +59,10 @@ class Groovy8764Bug extends GroovyTestCase {
             class Outer {
                 static class Inner {
                     List<Optional<String>> pets = [Optional.of('goldfish'), Optional.of('cat')]
-                    Optional<Integer> test(int index) {
-                        pets[index].flatMap({ String s ->
-                            // sprintf is a DGM method on Object
-                            sprintf('%s', s).size() == 3 ? Optional.of(index) : Optional.empty()
+                    Optional<Integer> test(int i) {
+                        pets[i].flatMap({ String s ->
+                            // sprintf is a DGM of Object
+                            sprintf('%s', s).size() == 3 ? Optional.of(i) : Optional.<Integer>empty()
                         } as Function<String, Optional<Integer>>)
                     }
                 }
diff --git a/src/test/groovy/transform/stc/CoercionSTCTest.groovy b/src/test/groovy/transform/stc/CoercionSTCTest.groovy
index 3139704d46..81d9be1892 100644
--- a/src/test/groovy/transform/stc/CoercionSTCTest.groovy
+++ b/src/test/groovy/transform/stc/CoercionSTCTest.groovy
@@ -124,4 +124,26 @@ class CoercionSTCTest extends StaticTypeCheckingTestCase {
             assert s == '[]'
         '''
     }
+
+    // GROOVY-10277
+    void testCoerceToFunctionalInterface() {
+        assertScript '''
+            import java.util.function.*
+            Supplier<Number> s = { -> 42 }
+            Predicate<Number> p = { n -> 42 }
+        '''
+        assertScript '''
+            import java.util.function.*
+            def s = { -> 42 } as Supplier<Number>
+            def p = { n -> 42 } as Predicate<Number>
+        '''
+        shouldFailWithMessages '''
+            import java.util.function.*
+            def s = { -> false } as Supplier<Number>
+        ''', 'Cannot coerce lambda or closure returning boolean to java.util.function.Supplier<java.lang.Number>'
+        shouldFailWithMessages '''
+            import java.util.function.*
+            def s = (() -> false) as Supplier<Number>
+        ''', 'Cannot coerce lambda or closure returning boolean to java.util.function.Supplier<java.lang.Number>'
+    }
 }
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/MixedModeStaticCompilationTest.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/MixedModeStaticCompilationTest.groovy
index ebd2b637ec..4d8d7d378a 100644
--- a/src/test/org/codehaus/groovy/classgen/asm/sc/MixedModeStaticCompilationTest.groovy
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/MixedModeStaticCompilationTest.groovy
@@ -233,13 +233,13 @@ final class MixedModeStaticCompilationTest extends StaticTypeCheckingTestCase im
 
     void testAllowMetaClass() {
         assertScript '''import groovy.transform.CompileStatic
-                @CompileStatic(extensions='groovy/transform/sc/MixedMode.groovy')
-                void foo() {
-                    String.metaClass.up = { ((String)delegate).toUpperCase() }
-                }
-                foo()
-                assert 'aaa'.up() == 'AAA'
-'''
+            @CompileStatic(extensions='groovy/transform/sc/MixedMode.groovy')
+            void test() {
+                String.metaClass.up = { -> (delegate as String).toUpperCase() }
+            }
+            test()
+            assert 'aaa'.up() == 'AAA'
+        '''
     }
 
     void testRecognizeStaticMethodCall() {
