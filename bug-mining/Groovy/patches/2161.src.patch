diff --git a/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java b/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java
index d53cb4db8a..4620091051 100644
--- a/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java
+++ b/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2012 the original author or authors.
+ * Copyright 2003-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -693,7 +693,18 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
 
         if (element != null) {
             init = expression(element);
-            ClassNode innerClass = getAnonymousInnerClassNode(init);
+            ClassNode innerClass;
+            if (element.getNextSibling() == null) {
+                innerClass = getAnonymousInnerClassNode(init);
+                if (innerClass != null) {
+                    init = null;
+                }
+            } else {
+                element = element.getNextSibling();
+                Expression next = expression(element);
+                innerClass = getAnonymousInnerClassNode(next);
+                // TODO: assert innerClass != null
+            }
 
             if (innerClass != null) {
                 // we have to handle an enum that defines a class for a constant
@@ -701,8 +712,20 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
                 // to configure the inner class 
                 innerClass.setSuperClass(classNode.getPlainNodeReference());
                 innerClass.setModifiers(classNode.getModifiers() | Opcodes.ACC_FINAL);
-                // we use a ClassExpression for transportation o EnumVisitor
-                init = new ClassExpression(innerClass);
+                // we use a ClassExpression for transportation to EnumVisitor
+                Expression inner = new ClassExpression(innerClass);
+                if (init == null) {
+                    init = inner;
+                } else {
+                    if (init instanceof ListExpression) {
+                        ((ListExpression) init).addExpression(inner);
+                    } else {
+                        ListExpression le = new ListExpression();
+                        le.addExpression(init);
+                        le.addExpression(inner);
+                        init = le;
+                    }
+                }
                 // and remove the final modifier from classNode to allow the sub class
                 classNode.setModifiers(classNode.getModifiers() & ~Opcodes.ACC_FINAL);
             } else if (isType(ELIST, element)) {
diff --git a/src/main/org/codehaus/groovy/classgen/EnumCompletionVisitor.java b/src/main/org/codehaus/groovy/classgen/EnumCompletionVisitor.java
index 98f4936091..5cf0c7807c 100644
--- a/src/main/org/codehaus/groovy/classgen/EnumCompletionVisitor.java
+++ b/src/main/org/codehaus/groovy/classgen/EnumCompletionVisitor.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2011 the original author or authors.
+ * Copyright 2003-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -56,23 +56,40 @@ public class EnumCompletionVisitor extends ClassCodeVisitorSupport {
     private void addConstructor(ClassNode enumClass) {
         // first look if there are declared constructors
         List<ConstructorNode> ctors = new ArrayList<ConstructorNode>(enumClass.getDeclaredConstructors());
+        boolean isAic = isAnonymousInnerClass(enumClass);
         if (ctors.size() == 0) {
-            // add default constructor
-            ConstructorNode init = new ConstructorNode(Opcodes.ACC_PUBLIC, new Parameter[0], ClassNode.EMPTY_ARRAY, new BlockStatement());
-            enumClass.addConstructor(init);
-            ctors.add(init);
+            if (isAic) {
+                ClassNode sn = enumClass.getSuperClass();
+                List<ConstructorNode> sctors = new ArrayList<ConstructorNode>(sn.getDeclaredConstructors());
+                if (sctors.size() == 0) {
+                    ctors.add(defaultConstructor(enumClass));
+                } else {
+                    for (ConstructorNode constructorNode : sctors) {
+                        ConstructorNode init = new ConstructorNode(Opcodes.ACC_PUBLIC, constructorNode.getParameters(), ClassNode.EMPTY_ARRAY, new BlockStatement());
+                        enumClass.addConstructor(init);
+                        ctors.add(init);
+                    }
+                }
+            } else {
+                ctors.add(defaultConstructor(enumClass));
+            }
         }
 
         // for each constructor:
         // if constructor does not define a call to super, then transform constructor
-        // to get String,int parameters at beginning and add call super(String,int)  
-
+        // to get String,int parameters at beginning and add call super(String,int)
         for (ConstructorNode ctor : ctors) {
-            transformConstructor(ctor);
+            transformConstructor(ctor, isAic);
         }
     }
 
-    private void transformConstructor(ConstructorNode ctor) {
+    private ConstructorNode defaultConstructor(ClassNode enumClass) {
+        ConstructorNode init = new ConstructorNode(Opcodes.ACC_PUBLIC, new Parameter[0], ClassNode.EMPTY_ARRAY, new BlockStatement());
+        enumClass.addConstructor(init);
+        return init;
+    }
+
+    private void transformConstructor(ConstructorNode ctor, boolean isAic) {
         boolean chainedThisConstructorCall = false;
         ConstructorCallExpression cce = null;
         if (ctor.firstStatementIsSpecialConstructorCall()) {
@@ -97,14 +114,16 @@ public class EnumCompletionVisitor extends ClassCodeVisitorSupport {
             argsExprs.add(0, new VariableExpression(stringParameterName));
             argsExprs.add(1, new VariableExpression(intParameterName));
         } else {
-            // and a super call
-            cce = new ConstructorCallExpression(
-                    ClassNode.SUPER,
-                    new ArgumentListExpression(
-                            new VariableExpression(stringParameterName),
-                            new VariableExpression(intParameterName)
-                    )
-            );
+            // add a super call
+            List<Expression> args = new ArrayList<Expression>();
+            args.add(new VariableExpression(stringParameterName));
+            args.add(new VariableExpression(intParameterName));
+            if (isAic) {
+                for (Parameter parameter : oldP) {
+                    args.add(new VariableExpression(parameter.getName()));
+                }
+            }
+            cce = new ConstructorCallExpression(ClassNode.SUPER, new ArgumentListExpression(args));
             BlockStatement code = new BlockStatement();
             code.addStatement(new ExpressionStatement(cce));
             Statement oldCode = ctor.getCode();
@@ -126,4 +145,9 @@ public class EnumCompletionVisitor extends ClassCodeVisitorSupport {
         return name;
     }
 
+    private boolean isAnonymousInnerClass(ClassNode enumClass) {
+        if (!(enumClass instanceof EnumConstantClassNode)) return false;
+        InnerClassNode ic = (InnerClassNode) enumClass;
+        return ic.getVariableScope() == null;
+    }
 }
diff --git a/src/test/gls/enums/EnumTest.groovy b/src/test/gls/enums/EnumTest.groovy
index 60b9eaaf7b..db58cc0498 100644
--- a/src/test/gls/enums/EnumTest.groovy
+++ b/src/test/gls/enums/EnumTest.groovy
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2009 the original author or authors.
+ * Copyright 2003-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -408,7 +408,7 @@ class EnumTest extends CompilableTestSupport {
             assert foos[1].j == 2
         """
     }
-    
+
     void testNamedArguments() {
         // this test is a result of GROOVY-4219 and should be changed once
         // GROOVY-4582 is implemented.
@@ -426,8 +426,23 @@ class EnumTest extends CompilableTestSupport {
             }
         """
     }
-}
 
+    void testOverridingMethodsWithExplicitConstructor() {
+        // GROOVY-6065
+        assertScript """
+            enum Country {
+                Hungary(9_939_000), Italy(61_482_000), Poland(38_383_000) { String getCountryCode() { 'pl' } }
+                int population
+                Country(population) { this.population = population }
+                String getCountryCode() { name()[0..1].toLowerCase() }
+            }
+
+            assert Country.Hungary.countryCode == 'hu'
+            assert Country.Italy.countryCode == 'it'
+            assert Country.Poland.countryCode == 'pl'
+        """
+    }
+}
 
 enum UsCoin {
     penny(1), nickel(5), dime(10), quarter(25)
