diff --git a/.classpath b/.classpath
index 2587a0b007..15904b54c8 100644
--- a/.classpath
+++ b/.classpath
@@ -1,52 +1,28 @@
 <?xml version="1.0" encoding="UTF-8"?>
-
 <classpath>
-  <classpathentry kind="src" path="src/main">
-  </classpathentry>
-  <classpathentry output="target/test-classes" kind="src" path="src/test">
-  </classpathentry>
-  <classpathentry kind="var" path="MAVEN_REPO/junit/jars/junit-3.8.1.jar">
-  </classpathentry>
-  <classpathentry kind="var" rootpath="JRE_SRCROOT" path="JRE_LIB" sourcepath="JRE_SRC">
-  </classpathentry>
-  <classpathentry kind="var" path="MAVEN_REPO/asm/jars/asm-1.4.1.jar">
-  </classpathentry>
-  <classpathentry kind="var" path="MAVEN_REPO/xerces/jars/xerces-2.4.0.jar">
-  </classpathentry>
-  <classpathentry kind="var" path="MAVEN_REPO/xml-apis/jars/xml-apis-1.0.b2.jar">
-  </classpathentry>
-  <classpathentry kind="var" path="MAVEN_REPO/classworlds/jars/classworlds-1.0-rc2.jar">
-  </classpathentry>
-  <classpathentry kind="var" path="MAVEN_REPO/commons-cli/jars/commons-cli-1.0.jar">
-  </classpathentry>
-  <classpathentry kind="var" path="MAVEN_REPO/ant/jars/ant-1.5.2.jar">
-  </classpathentry>
-  <classpathentry kind="var" path="MAVEN_REPO/asm/jars/asm-util-1.4.1.jar">
-  </classpathentry>
-  <classpathentry kind="var" path="MAVEN_REPO/asm/jars/asm-attrs-1.4.1.jar">
-  </classpathentry>
-  <classpathentry kind="var" path="MAVEN_REPO/bsf/jars/bsf-2.3.0-rc1.jar">
-  </classpathentry>
-  <classpathentry kind="var" path="MAVEN_REPO/mx4j/jars/mx4j-2.0-beta-1.jar">
-  </classpathentry>
-  <classpathentry kind="var" path="MAVEN_REPO/mockobjects/jars/mockobjects-core-0.09.jar">
-  </classpathentry>
-  <classpathentry kind="var" path="MAVEN_REPO/openejb/jars/openejb-loader-0.9.2.jar">
-  </classpathentry>
-  <classpathentry kind="var" path="MAVEN_REPO/axion/jars/axion-1.0-M3-dev.jar">
-  </classpathentry>
-  <classpathentry kind="var" path="MAVEN_REPO/commons-logging/jars/commons-logging-1.0.3.jar">
-  </classpathentry>
-  <classpathentry kind="var" path="MAVEN_REPO/commons-collections/jars/commons-collections-3.0-dev2.jar">
-  </classpathentry>
-  <classpathentry kind="var" path="MAVEN_REPO/regexp/jars/regexp-1.2.jar">
-  </classpathentry>
-  <classpathentry kind="var" path="MAVEN_REPO/servletapi/jars/servletapi-2.3.jar">
-  </classpathentry>
-  <classpathentry kind="var" path="MAVEN_REPO/radeox/jars/radeox-0.9.jar">
-  </classpathentry>
-  <classpathentry kind="var" path="MAVEN_REPO/radeox/jars/radeox-oro-0.9.jar">
-  </classpathentry>
-  <classpathentry kind="output" path="bin">
-  </classpathentry>
-</classpath>
\ No newline at end of file
+	<classpathentry kind="src" path="src/main"/>
+	<classpathentry kind="src" path="src/test"/>
+	<classpathentry kind="var" path="MAVEN_REPO/junit/jars/junit-3.8.1.jar"/>
+	<classpathentry sourcepath="JRE_SRC" kind="var" path="JRE_LIB"/>
+	<classpathentry kind="var" path="MAVEN_REPO/asm/jars/asm-1.4.1.jar"/>
+	<classpathentry kind="var" path="MAVEN_REPO/xerces/jars/xerces-2.4.0.jar"/>
+	<classpathentry kind="var" path="MAVEN_REPO/xml-apis/jars/xml-apis-1.0.b2.jar"/>
+	<classpathentry kind="var" path="MAVEN_REPO/classworlds/jars/classworlds-1.0-rc2.jar"/>
+	<classpathentry kind="var" path="MAVEN_REPO/commons-cli/jars/commons-cli-1.0.jar"/>
+	<classpathentry kind="var" path="MAVEN_REPO/ant/jars/ant-1.5.2.jar"/>
+	<classpathentry kind="var" path="MAVEN_REPO/asm/jars/asm-util-1.4.1.jar"/>
+	<classpathentry kind="var" path="MAVEN_REPO/asm/jars/asm-attrs-1.4.1.jar"/>
+	<classpathentry kind="var" path="MAVEN_REPO/bsf/jars/bsf-2.3.0-rc1.jar"/>
+	<classpathentry kind="var" path="MAVEN_REPO/mx4j/jars/mx4j-2.0-beta-1.jar"/>
+	<classpathentry kind="var" path="MAVEN_REPO/mockobjects/jars/mockobjects-core-0.09.jar"/>
+	<classpathentry kind="var" path="MAVEN_REPO/openejb/jars/openejb-loader-0.9.2.jar"/>
+	<classpathentry kind="var" path="MAVEN_REPO/axion/jars/axion-1.0-M3-dev.jar"/>
+	<classpathentry kind="var" path="MAVEN_REPO/commons-logging/jars/commons-logging-1.0.3.jar"/>
+	<classpathentry kind="var" path="MAVEN_REPO/commons-collections/jars/commons-collections-3.0-dev2.jar"/>
+	<classpathentry kind="var" path="MAVEN_REPO/regexp/jars/regexp-1.2.jar"/>
+	<classpathentry kind="var" path="MAVEN_REPO/servletapi/jars/servletapi-2.3.jar"/>
+	<classpathentry kind="var" path="MAVEN_REPO/radeox/jars/radeox-0.9.jar"/>
+	<classpathentry kind="var" path="MAVEN_REPO/radeox/jars/radeox-oro-0.9.jar"/>
+	<classpathentry kind="lib" path="target/test-classes"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
diff --git a/TODO.txt b/TODO.txt
index 9b3fb6c492..1ab5c538ab 100644
--- a/TODO.txt
+++ b/TODO.txt
@@ -217,16 +217,8 @@ sql.table("users") {
 	- using beans + listeners
 	- expression language
 
-* allow constructors to have optional trailing closure...
-	new JFrame() { text = 'hello'; size = [1, 2] }
-  closure on construction of beans?
-	new JTable() {....}
-		invokes the closure with the new object as delegate for setting properties etc
-
 * support -ve indices on subscript operator
 
-* foo[1, 2] versus foo[1..2] etc
-
 * MetaClass -> add getPropertyDescriptor which has methods
 	- get(), set(), type(), cardinality() etc
 	
diff --git a/src/main/groovy/lang/MetaClass.java b/src/main/groovy/lang/MetaClass.java
index be11c9618b..f0730efab6 100644
--- a/src/main/groovy/lang/MetaClass.java
+++ b/src/main/groovy/lang/MetaClass.java
@@ -1,47 +1,35 @@
 /*
- $Id$
-
- Copyright 2003 (C) James Strachan and Bob Mcwhirter. All Rights Reserved.
-
- Redistribution and use of this software and associated documentation
- ("Software"), with or without modification, are permitted provided
- that the following conditions are met:
-
- 1. Redistributions of source code must retain copyright
-    statements and notices.  Redistributions must also contain a
-    copy of this document.
-
- 2. Redistributions in binary form must reproduce the
-    above copyright notice, this list of conditions and the
-    following disclaimer in the documentation and/or other
-    materials provided with the distribution.
-
- 3. The name "groovy" must not be used to endorse or promote
-    products derived from this Software without prior written
-    permission of The Codehaus.  For written permission,
-    please contact info@codehaus.org.
-
- 4. Products derived from this Software may not be called "groovy"
-    nor may "groovy" appear in their names without prior written
-    permission of The Codehaus. "groovy" is a registered
-    trademark of The Codehaus.
-
- 5. Due credit should be given to The Codehaus -
-    http://groovy.codehaus.org/
-
- THIS SOFTWARE IS PROVIDED BY THE CODEHAUS AND CONTRIBUTORS
- ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
- NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
- FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
- THE CODEHAUS OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
- INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
- OF THE POSSIBILITY OF SUCH DAMAGE.
-
+ * $Id$
+ * 
+ * Copyright 2003 (C) James Strachan and Bob Mcwhirter. All Rights Reserved.
+ * 
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided that the
+ * following conditions are met: 1. Redistributions of source code must retain
+ * copyright statements and notices. Redistributions must also contain a copy
+ * of this document. 2. Redistributions in binary form must reproduce the above
+ * copyright notice, this list of conditions and the following disclaimer in
+ * the documentation and/or other materials provided with the distribution. 3.
+ * The name "groovy" must not be used to endorse or promote products derived
+ * from this Software without prior written permission of The Codehaus. For
+ * written permission, please contact info@codehaus.org. 4. Products derived
+ * from this Software may not be called "groovy" nor may "groovy" appear in
+ * their names without prior written permission of The Codehaus. "groovy" is a
+ * registered trademark of The Codehaus. 5. Due credit should be given to The
+ * Codehaus - http://groovy.codehaus.org/
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE CODEHAUS AND CONTRIBUTORS ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE CODEHAUS OR ITS CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *  
  */
 package groovy.lang;
 
@@ -71,6 +59,7 @@ import java.util.Map;
 import org.codehaus.groovy.ast.ClassNode;
 import org.codehaus.groovy.ast.CompileUnit;
 import org.codehaus.groovy.classgen.CompilerFacade;
+import org.codehaus.groovy.runtime.ClosureListener;
 import org.codehaus.groovy.runtime.DefaultGroovyMethods;
 import org.codehaus.groovy.runtime.InvokerHelper;
 import org.codehaus.groovy.runtime.InvokerInvocationException;
@@ -89,8 +78,9 @@ public class MetaClass {
     protected static final Object[] EMPTY_ARRAY = {
     };
     protected static final Object[] ARRAY_WITH_NULL = { null };
-    protected static Class[] EMPTY_TYPE_ARRAY = {};
-    
+    protected static Class[] EMPTY_TYPE_ARRAY = {
+    };
+
     private MetaClassRegistry registry;
     private Class theClass;
     private ClassNode classNode;
@@ -132,11 +122,11 @@ public class MetaClass {
         for (int i = 0; i < interfaces.length; i++) {
             addNewStaticMethodsFrom(interfaces[i]);
         }
-        
-        if (theClass.isArray() && ! theClass.equals(Object[].class)) {
+
+        if (theClass.isArray() && !theClass.equals(Object[].class)) {
             addNewStaticMethodsFrom(Object[].class);
         }
-        
+
         // lets add all the base class methods
         Class c = theClass;
         while (true) {
@@ -147,13 +137,13 @@ public class MetaClass {
             addNewStaticMethodsFrom(c);
             addMethods(c);
         }
-        
-        
+
     }
 
     /**
-     * @return all the normal instance methods avaiable on this class for the given name
-     */
+	 * @return all the normal instance methods avaiable on this class for the
+	 *         given name
+	 */
     public List getMethods(String name) {
         List answer = (List) methodIndex.get(name);
         if (answer == null) {
@@ -163,8 +153,9 @@ public class MetaClass {
     }
 
     /**
-     * @return all the normal static methods avaiable on this class for the given name
-     */
+	 * @return all the normal static methods avaiable on this class for the
+	 *         given name
+	 */
     public List getStaticMethods(String name) {
         List answer = (List) staticMethodIndex.get(name);
         if (answer == null) {
@@ -174,11 +165,11 @@ public class MetaClass {
     }
 
     /**
-     * Allows static method definitions to be added to a meta class as if it was an instance 
-     * method
-     * 
-     * @param method
-     */
+	 * Allows static method definitions to be added to a meta class as if it
+	 * was an instance method
+	 * 
+	 * @param method
+	 */
     protected void addNewStaticInstanceMethod(Method method) {
         String name = method.getName();
         List list = (List) newStaticInstanceMethodIndex.get(name);
@@ -191,33 +182,26 @@ public class MetaClass {
 
     public Object invokeMethod(Object object, String methodName, Object arguments) {
         /*
-        System.out.println(
-            "MetaClass: Invoking method on object: " + object + " method: " + methodName + " arguments: " + arguments);
-        */
+		 * System.out.println( "MetaClass: Invoking method on object: " +
+		 * object + " method: " + methodName + " arguments: " + arguments);
+		 */
         return invokeMethod(object, methodName, asArray(arguments));
     }
 
     /**
-     * Invokes the given method on the object. 
-     * 
-     */
+	 * Invokes the given method on the object.
+	 *  
+	 */
     public Object invokeMethod(Object object, String methodName, Object[] arguments) {
         /*
-        Class type = arguments == null ? null : arguments.getClass();
-        System
-            .out
-            .println(
-                "MetaClass(Object[]) Invoking method on object: "
-                    + object
-                    + " method: "
-                    + methodName
-                    + " argument type: "
-                    + type
-                    + " arguments: "
-                    + InvokerHelper.toString(arguments));
-        
-        //System.out.println("Type of first arg: " + arguments[0] + " type: " + arguments[0].getClass());
-         */
+		 * Class type = arguments == null ? null : arguments.getClass(); System
+		 * .out .println( "MetaClass(Object[]) Invoking method on object: " +
+		 * object + " method: " + methodName + " argument type: " + type + "
+		 * arguments: " + InvokerHelper.toString(arguments));
+		 * 
+		 * //System.out.println("Type of first arg: " + arguments[0] + " type: " +
+		 * arguments[0].getClass());
+		 */
 
         if (object == null) {
             throw new NullPointerException("Cannot invoke method: " + methodName + " on null object");
@@ -231,7 +215,8 @@ public class MetaClass {
             }
         }
 
-        // lets see if there's a new static method we've added in groovy-land to this class
+        // lets see if there's a new static method we've added in groovy-land
+        // to this class
         List newStaticInstanceMethods = getNewStaticInstanceMethods(methodName);
         int size = (arguments != null) ? arguments.length : 0;
         Object[] staticArguments = new Object[size + 1];
@@ -259,7 +244,8 @@ public class MetaClass {
             if (size == 1) {
                 Object firstArgument = arguments[0];
                 if (firstArgument instanceof List) {
-                    // lets coerce the list arguments into an array of arguments
+                    // lets coerce the list arguments into an array of
+                    // arguments
                     // e.g. calling JFrame.setLocation( [100, 100] )
 
                     List list = (List) firstArgument;
@@ -272,11 +258,12 @@ public class MetaClass {
 
     public Object invokeStaticMethod(Object object, String methodName, Object[] arguments) {
         /*
-        System.out.println("Calling static method: " + methodName + " on args: " + InvokerHelper.toString(arguments));
-        Class type = arguments == null ? null : arguments.getClass();
-        System.out.println("Argument type: " + type);
-        System.out.println("Type of first arg: " + arguments[0] + " type: " + arguments[0].getClass());
-        */
+		 * System.out.println("Calling static method: " + methodName + " on
+		 * args: " + InvokerHelper.toString(arguments)); Class type = arguments ==
+		 * null ? null : arguments.getClass(); System.out.println("Argument
+		 * type: " + type); System.out.println("Type of first arg: " +
+		 * arguments[0] + " type: " + arguments[0].getClass());
+		 */
 
         List methods = getStaticMethods(methodName);
 
@@ -303,12 +290,34 @@ public class MetaClass {
         if (constructor != null) {
             return doConstructorInvoke(constructor, arguments);
         }
+        if (arguments.length == 1 && arguments[0] instanceof Map) {
+            constructor = (Constructor) chooseMethod("<init>", constructors, EMPTY_ARRAY);
+            if (constructor != null) {
+                Object bean = doConstructorInvoke(constructor, EMPTY_ARRAY);
+                setProperties(bean, ((Map) arguments[0]));
+                return bean;
+            }
+        }
         throw new GroovyRuntimeException("Could not find matching constructor for class: " + theClass.getName());
     }
 
     /**
-     * @return the currently registered static methods against this class
-     */
+	 * Sets a number of bean properties from the given Map where the keys are
+	 * the String names of properties and the values are the values of the
+	 * properties to set
+	 */
+    public void setProperties(Object bean, Map map) {
+        for (Iterator iter = map.entrySet().iterator(); iter.hasNext();) {
+            Map.Entry entry = (Map.Entry) iter.next();
+            String key = entry.getKey().toString();
+            Object value = entry.getValue();
+            setProperty(bean, key, value);
+        }
+    }
+
+    /**
+	 * @return the currently registered static methods against this class
+	 */
     public List getNewStaticInstanceMethods(String methodName) {
         List newStaticInstanceMethods = (List) newStaticInstanceMethodIndex.get(methodName);
         if (newStaticInstanceMethods == null) {
@@ -318,8 +327,8 @@ public class MetaClass {
     }
 
     /**
-     * @return the given property's value on the object
-     */
+	 * @return the given property's value on the object
+	 */
     public Object getProperty(final Object object, final String property) {
         PropertyDescriptor descriptor = (PropertyDescriptor) propertyDescriptors.get(property);
         if (descriptor != null) {
@@ -338,13 +347,25 @@ public class MetaClass {
             }
         }
 
-        // is the property the name of a method - in which case return a 
+        // is the property the name of a method - in which case return a
         // closure
         List methods = getMethods(property);
         if (!methods.isEmpty()) {
             return new MethodClosure(object, property);
         }
 
+        // lets try invoke a static getter method
+        Exception lastException = null;
+        try {
+            Method method = findGetter(object, "get" + capitalize(property));
+            if (method != null) {
+                return doMethodInvoke(object, method, EMPTY_ARRAY);
+            }
+        }
+        catch (GroovyRuntimeException e) {
+            lastException = e;
+        }
+
         /** @todo or are we an extensible groovy class? */
         if (genericGetMethod != null) {
             return null;
@@ -361,13 +382,20 @@ public class MetaClass {
             if (object instanceof Object[]) {
                 return DefaultGroovyMethods.get(Arrays.asList((Object[]) object), property);
             }
-            throw new MissingPropertyException(property, theClass);
+
+            // lets try the getter method
+            if (lastException == null) {
+                throw new MissingPropertyException(property, theClass);
+            }
+            else {
+                throw new MissingPropertyException(property, theClass, lastException);
+            }
         }
     }
 
     /**
-     * Sets the property value on an object
-     */
+	 * Sets the property value on an object
+	 */
     public void setProperty(Object object, String property, Object newValue) {
         PropertyDescriptor descriptor = (PropertyDescriptor) propertyDescriptors.get(property);
 
@@ -381,7 +409,7 @@ public class MetaClass {
                 doMethodInvoke(object, method, arguments);
             }
             catch (GroovyRuntimeException e) {
-                // if the value is a List see if we can construct the value 
+                // if the value is a List see if we can construct the value
                 // from a constructor
                 if (newValue instanceof List) {
                     List list = (List) newValue;
@@ -390,7 +418,8 @@ public class MetaClass {
                     for (int i = 0; i < constructors.length; i++) {
                         Constructor constructor = constructors[i];
                         if (constructor.getParameterTypes().length == params) {
-                            //System.out.println("Found constructor: " + constructor);
+                            //System.out.println("Found constructor: " +
+                            // constructor);
                             Object value = doConstructorInvoke(constructor, list.toArray());
                             doMethodInvoke(object, method, new Object[] { value });
                             return;
@@ -422,8 +451,8 @@ public class MetaClass {
         String method = "set" + capitalize(property);
         invokeMethod(object, method, new Object[] { newValue });
     }
-    
-     public ClassNode getClassNode() {
+
+    public ClassNode getClassNode() {
         if (classNode == null && GroovyObject.class.isAssignableFrom(theClass)) {
             // lets try load it from the classpath
             String className = theClass.getName();
@@ -443,14 +472,16 @@ public class MetaClass {
                 try {
                     InputStream in = url.openStream();
 
-                    /** @todo there is no CompileUnit in scope so class name 
-                     * checking won't work but that mostly affects the bytecode generation
-                     * rather than viewing the AST
-                     */
+                    /**
+					 * @todo there is no CompileUnit in scope so class name
+					 * checking won't work but that mostly affects the bytecode
+					 * generation rather than viewing the AST
+					 */
                     CompilerFacade compiler = new CompilerFacade(theClass.getClassLoader(), new CompileUnit()) {
                         protected void onClass(ClassWriter classWriter, ClassNode classNode) {
                             if (classNode.getName().equals(theClass.getName())) {
-                                //System.out.println("Found: " + classNode.getName());
+                                //System.out.println("Found: " +
+                                // classNode.getName());
                                 MetaClass.this.classNode = classNode;
                             }
                         }
@@ -474,9 +505,9 @@ public class MetaClass {
     //-------------------------------------------------------------------------
 
     /**
-     * Converts the given object into an array; if its an array then just
-     * cast otherwise wrap it in an array
-     */
+	 * Converts the given object into an array; if its an array then just cast
+	 * otherwise wrap it in an array
+	 */
     protected Object[] asArray(Object arguments) {
         if (arguments == null) {
             return EMPTY_ARRAY;
@@ -493,30 +524,28 @@ public class MetaClass {
         }
     }
     /**
-     * @param listenerType the interface of the listener to proxy
-     * @param listenerMethodName the name of the method in the listener API to call the closure on
-     * @param closure the closure to invoke on the listenerMethodName method invocation
-     * @return a dynamic proxy which calls the given closure on the given method name
-     */
+	 * @param listenerType
+	 *            the interface of the listener to proxy
+	 * @param listenerMethodName
+	 *            the name of the method in the listener API to call the
+	 *            closure on
+	 * @param closure
+	 *            the closure to invoke on the listenerMethodName method
+	 *            invocation
+	 * @return a dynamic proxy which calls the given closure on the given
+	 *         method name
+	 */
     protected Object createListenerProxy(Class listenerType, final String listenerMethodName, final Closure closure) {
-        InvocationHandler handler = new InvocationHandler() {
-            public Object invoke(Object object, Method method, Object[] arguments) throws Throwable {
-                if (listenerMethodName.equals(method.getName())) {
-                    /** @todo hack! */
-                    closure.call(arguments[0]);
-                }
-                return null;
-            }
-        };
+        InvocationHandler handler = new ClosureListener(listenerMethodName, closure);
         return Proxy.newProxyInstance(listenerType.getClassLoader(), new Class[] { listenerType }, handler);
     }
 
     /**
-     * Adds all the methods declared in the given class to the metaclass
-     * ignoring any matching methods already defined by a derived class
-     * 
-     * @param theClass
-     */
+	 * Adds all the methods declared in the given class to the metaclass
+	 * ignoring any matching methods already defined by a derived class
+	 * 
+	 * @param theClass
+	 */
     protected void addMethods(Class theClass) {
         Method[] methodArray = theClass.getDeclaredMethods();
         for (int i = 0; i < methodArray.length; i++) {
@@ -559,8 +588,9 @@ public class MetaClass {
     }
 
     /**
-     * @return true if a method of the same matching prototype was found in the list
-     */
+	 * @return true if a method of the same matching prototype was found in the
+	 *         list
+	 */
     protected boolean containsMatchingMethod(List list, Method method) {
         for (Iterator iter = list.iterator(); iter.hasNext();) {
             Method aMethod = (Method) iter.next();
@@ -583,11 +613,11 @@ public class MetaClass {
     }
 
     /**
-     * Adds all of the newly defined methods from the given class to this
-     * metaclass
-     * 
-     * @param theClass
-     */
+	 * Adds all of the newly defined methods from the given class to this
+	 * metaclass
+	 * 
+	 * @param theClass
+	 */
     protected void addNewStaticMethodsFrom(Class theClass) {
         MetaClass interfaceMetaClass = registry.getMetaClass(theClass);
         Iterator iter = interfaceMetaClass.newStaticInstanceMethodIndex.entrySet().iterator();
@@ -609,11 +639,12 @@ public class MetaClass {
     }
 
     /**
-     * @return the value of the static property of the given class
-     */
+	 * @return the value of the static property of the given class
+	 */
     protected Object getStaticProperty(Class aClass, String property) {
-        //System.out.println("Invoking property: " + property + " on class: " + aClass);
-        
+        //System.out.println("Invoking property: " + property + " on class: "
+        // + aClass);
+
         Exception lastException = null;
         try {
             Field field = aClass.getField(property);
@@ -626,7 +657,7 @@ public class MetaClass {
         catch (Exception e) {
             lastException = e;
         }
-        
+
         // lets try invoke a static getter method
         try {
             Method method = findStaticGetter(aClass, "get" + capitalize(property));
@@ -637,16 +668,39 @@ public class MetaClass {
         catch (GroovyRuntimeException e) {
             throw new MissingPropertyException(property, aClass, e);
         }
-        
-        throw new MissingPropertyException(property, aClass, lastException);
+
+        if (lastException == null) {
+            throw new MissingPropertyException(property, aClass);
+        }
+        else {
+            throw new MissingPropertyException(property, aClass, lastException);
+        }
+    }
+
+    /**
+	 * @return the getter method for the given object
+	 */
+    protected Method findGetter(Object object, String name) {
+        try {
+            return object.getClass().getMethod(name, EMPTY_TYPE_ARRAY);
+        }
+        catch (Exception e) {
+            return null;
+        }
     }
 
     /**
-     * @return the Method of the given name with no parameters or null
-     */
+	 * @return the Method of the given name with no parameters or null
+	 */
     protected Method findStaticGetter(Class type, String name) {
         try {
-            return type.getMethod(name, EMPTY_TYPE_ARRAY);
+            Method method = type.getMethod(name, EMPTY_TYPE_ARRAY);
+            if ((method.getModifiers() & Modifier.STATIC) != 0) {
+                return method;
+            }
+            else {
+                return null;
+            }
         }
         catch (Exception e) {
             return null;
@@ -654,8 +708,9 @@ public class MetaClass {
     }
 
     /**
-     * Lets walk the base class & interfaces list to see if we can find the method
-     */
+	 * Lets walk the base class & interfaces list to see if we can find the
+	 * method
+	 */
     protected Method findNewStaticInstanceMethod(String methodName, Object[] staticArguments) {
         if (theClass.equals(Object.class)) {
             return null;
@@ -676,7 +731,8 @@ public class MetaClass {
 
     protected Object doMethodInvoke(Object object, Method method, Object[] argumentArray) {
         //System.out.println("Evaluating method: " + method);
-        //System.out.println("on object: " + object + " with arguments: " + InvokerHelper.toString(argumentArray));
+        //System.out.println("on object: " + object + " with arguments: " +
+        // InvokerHelper.toString(argumentArray));
         //System.out.println(this.theClass);
 
         try {
@@ -748,7 +804,8 @@ public class MetaClass {
     }
 
     protected Object doConstructorInvoke(Constructor constructor, Object[] argumentArray) {
-        //System.out.println("Evaluating constructor: " + constructor + " with arguments: " + InvokerHelper.toString(argumentArray));
+        //System.out.println("Evaluating constructor: " + constructor + " with
+        // arguments: " + InvokerHelper.toString(argumentArray));
         //System.out.println(this.theClass);
 
         try {
@@ -789,19 +846,26 @@ public class MetaClass {
     }
 
     /**
-     * Chooses the correct method to use from a list of methods which match by name.
-     * 
-     * @param methods the possible methods to choose from
-     * @param arguments the original argument to the method
-     * @return
-     */
+	 * Chooses the correct method to use from a list of methods which match by
+	 * name.
+	 * 
+	 * @param methods
+	 *            the possible methods to choose from
+	 * @param arguments
+	 *            the original argument to the method
+	 * @return
+	 */
     protected Object chooseMethod(String methodName, List methods, Object[] arguments) {
         int methodCount = methods.size();
         if (methodCount <= 0) {
             return null;
         }
         else if (methodCount == 1) {
-            return methods.get(0);
+            Object method = methods.get(0);
+            if (isValidMethod(method, arguments, true)) {
+                return method;
+            }
+            return null;
         }
         Object answer = null;
         if (arguments.length == 1 && arguments[0] == null) {
@@ -811,24 +875,13 @@ public class MetaClass {
             answer = chooseEmptyMethodParams(methods);
         }
         else {
-            int size = arguments.length;
             List matchingMethods = new ArrayList();
 
             for (Iterator iter = methods.iterator(); iter.hasNext();) {
                 Object method = iter.next();
-                Class[] paramTypes = getParameterTypes(method);
-                if (paramTypes.length == size) {
-                    // lets check the parameter types match
-                    boolean validMethod = true;
-                    for (int i = 0; i < size; i++) {
-                        Object value = arguments[i];
-                        if (!isCompatibleInstance(paramTypes[i], value)) {
-                            validMethod = false;
-                        }
-                    }
-                    if (validMethod) {
-                        matchingMethods.add(method);
-                    }
+                Class[] paramTypes;
+                if (isValidMethod(method, arguments, false)) {
+                    matchingMethods.add(method);
                 }
             }
             if (matchingMethods.isEmpty()) {
@@ -850,6 +903,31 @@ public class MetaClass {
                 + InvokerHelper.toString(arguments));
     }
 
+    protected boolean isValidMethod(Object method, Object[] arguments, boolean includeCoerce) {
+        if (arguments == null) {
+            return true;
+        }
+        int size = arguments.length;
+        Class[] paramTypes = getParameterTypes(method);
+        boolean validMethod = false;
+        if (paramTypes.length == size) {
+            // lets check the parameter types match
+            validMethod = true;
+            for (int i = 0; i < size; i++) {
+                Object value = arguments[i];
+                if (!isCompatibleInstance(paramTypes[i], value, includeCoerce)) {
+                    validMethod = false;
+                }
+            }
+        }
+        else {
+            if (paramTypes.length == 1 && size == 0) {
+                return true;
+            }
+        }
+        return validMethod;
+    }
+
     protected Object chooseMostSpecificParams(String name, List matchingMethods, Object[] arguments) {
         Object answer = null;
         int size = arguments.length;
@@ -889,16 +967,15 @@ public class MetaClass {
     }
 
     /**
-     * Checks that one of the parameter types is a superset of the other
-     * and that the two lists of types don't conflict. e.g.
-     * foo(String, Object) and foo(Object, String) would conflict if called with
-     * foo("a", "b").
-     * 
-     * Note that this method is only called with 2 possible signnatures. i.e. possible
-     * invalid combinations will already have been filtered out. So if there were
-     * methods foo(String, Object) and foo(Object, String) then one of these would be
-     * already filtered out if foo was called as foo(12, "a")
-     */
+	 * Checks that one of the parameter types is a superset of the other and
+	 * that the two lists of types don't conflict. e.g. foo(String, Object) and
+	 * foo(Object, String) would conflict if called with foo("a", "b").
+	 * 
+	 * Note that this method is only called with 2 possible signnatures. i.e.
+	 * possible invalid combinations will already have been filtered out. So if
+	 * there were methods foo(String, Object) and foo(Object, String) then one
+	 * of these would be already filtered out if foo was called as foo(12, "a")
+	 */
     protected void checkForInvalidOverloading(String name, Class[] baseTypes, Class[] derivedTypes) {
         for (int i = 0, size = baseTypes.length; i < size; i++) {
             Class baseType = baseTypes[i];
@@ -928,10 +1005,12 @@ public class MetaClass {
     }
 
     /**
-     * @return the method with 1 parameter which takes the most general type of object (e.g. Object)
-     */
+	 * @return the method with 1 parameter which takes the most general type of
+	 *         object (e.g. Object)
+	 */
     protected Object chooseMostGeneralMethodWith1Param(List methods) {
-        // lets look for methods with 1 argument which matches the type of the arguments
+        // lets look for methods with 1 argument which matches the type of the
+        // arguments
         Class closestClass = null;
         Object answer = null;
 
@@ -951,8 +1030,9 @@ public class MetaClass {
     }
 
     /**
-     * @return the method with 1 parameter which takes the most general type of object (e.g. Object)
-     */
+	 * @return the method with 1 parameter which takes the most general type of
+	 *         object (e.g. Object)
+	 */
     protected Object chooseEmptyMethodParams(List methods) {
         for (Iterator iter = methods.iterator(); iter.hasNext();) {
             Object method = iter.next();
@@ -965,7 +1045,7 @@ public class MetaClass {
         return null;
     }
 
-    protected boolean isCompatibleInstance(Class type, Object value) {
+    protected boolean isCompatibleInstance(Class type, Object value, boolean includeCoerce) {
         boolean answer = value == null || type.isInstance(value);
         if (!answer) {
             if (type.isPrimitive() && value instanceof Number) {
@@ -991,6 +1071,9 @@ public class MetaClass {
                     return value instanceof Short;
                 }
             }
+            else if (includeCoerce && type == String.class && value instanceof GString) {
+                return true;
+            }
         }
         return answer;
     }
diff --git a/src/main/org/codehaus/groovy/runtime/ClosureListener.java b/src/main/org/codehaus/groovy/runtime/ClosureListener.java
new file mode 100644
index 0000000000..e33a8c7814
--- /dev/null
+++ b/src/main/org/codehaus/groovy/runtime/ClosureListener.java
@@ -0,0 +1,95 @@
+/*
+ * $Id$
+ * 
+ * Copyright 2003 (C) James Strachan and Bob Mcwhirter. All Rights Reserved.
+ * 
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided that the
+ * following conditions are met: 1. Redistributions of source code must retain
+ * copyright statements and notices. Redistributions must also contain a copy
+ * of this document. 2. Redistributions in binary form must reproduce the above
+ * copyright notice, this list of conditions and the following disclaimer in
+ * the documentation and/or other materials provided with the distribution. 3.
+ * The name "groovy" must not be used to endorse or promote products derived
+ * from this Software without prior written permission of The Codehaus. For
+ * written permission, please contact info@codehaus.org. 4. Products derived
+ * from this Software may not be called "groovy" nor may "groovy" appear in
+ * their names without prior written permission of The Codehaus. "groovy" is a
+ * registered trademark of The Codehaus. 5. Due credit should be given to The
+ * Codehaus - http://groovy.codehaus.org/
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE CODEHAUS AND CONTRIBUTORS ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE CODEHAUS OR ITS CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *  
+ */
+package org.codehaus.groovy.runtime;
+
+import groovy.lang.Closure;
+
+import java.lang.reflect.InvocationHandler;
+import java.lang.reflect.Method;
+
+/**
+ * Represents a method on an object using a closure which can be invoked at any
+ * time
+ * 
+ * @author <a href="mailto:james@coredevelopers.net">James Strachan</a>
+ * @version $Revision$
+ */
+public class ClosureListener implements InvocationHandler {
+
+    private String listenerMethodName;
+    private Closure closure;
+
+    public ClosureListener(String listenerMethodName, Closure closure) {
+        this.listenerMethodName = listenerMethodName;
+        this.closure = closure;
+    }
+
+    public Object invoke(Object object, Method method, Object[] arguments) throws Throwable {
+        if (listenerMethodName.equals(method.getName())) {
+            /** @todo hack! */
+            closure.call(arguments[0]);
+            return null;
+        }
+
+        // lets try call this object
+        String name = method.getName();
+        if (name.equals("equals")) {
+            return object == arguments[0] ? Boolean.TRUE : Boolean.FALSE;
+        }
+        else if (name.equals("hashCode")) {
+            return new Integer(hashCode());
+        }
+        else if (name.equals("toString")) {
+            return super.toString() + "[listener:" + listenerMethodName + "]";
+        }
+
+        /*
+		 * int paramCount = method.getParameterTypes().length;
+		 * 
+		 * System.out.println("Now calling method: " + method);
+		 * 
+		 * Method[] methods = Object.class.getMethods(); for (int i = 0; i
+		 * < methods.length; i++ ) { Method aMethod = methods[i]; if
+		 * (name.equals(aMethod.getName()) &&
+		 * aMethod.getParameterTypes().length == paramCount) { return
+		 * aMethod.invoke(object, arguments); } }
+		 */
+        return null;
+    }
+
+    public boolean equals(Object that) {
+        return this == that;
+    }
+
+}
\ No newline at end of file
diff --git a/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java b/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
index d26aad86ae..ad228237d8 100644
--- a/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
+++ b/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
@@ -58,6 +58,7 @@ import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.PrintWriter;
+import java.lang.reflect.Array;
 import java.lang.reflect.Field;
 import java.lang.reflect.Modifier;
 import java.sql.Connection;
@@ -554,6 +555,16 @@ public class DefaultGroovyMethods {
         return text.length();
     }
 
+    /**
+     * Makes an Array look like a Collection by adding support for the size() method
+     * 
+     * @param text
+     * @return
+     */
+    public static int size(Object[] self) {
+        return self.length;
+    }
+
     /**
      * Support the subscript operator for String
      * 
@@ -602,7 +613,7 @@ public class DefaultGroovyMethods {
     public static Object get(Object[] array, int idx) {
         return array[normaliseIndex(idx, array.length)];
     }
-    
+
     /**
      * Support the subscript operator for an Array
      * 
@@ -637,6 +648,9 @@ public class DefaultGroovyMethods {
         return i;
     }
 
+    
+
+    
     /**
      * Support the subscript operator for List
      * 
@@ -870,6 +884,125 @@ public class DefaultGroovyMethods {
         return true;
     }
 
+    // Primitive type array methods
+    //-------------------------------------------------------------------------
+    
+    public static Object get(byte[] array, int idx) {
+        return primitiveArrayGet(array, idx);
+    }
+    public static Object get(char[] array, int idx) {
+        return primitiveArrayGet(array, idx);
+    }
+    public static Object get(short[] array, int idx) {
+        return primitiveArrayGet(array, idx);
+    }
+    public static Object get(int[] array, int idx) {
+        return primitiveArrayGet(array, idx);
+    }
+    public static Object get(long[] array, int idx) {
+        return primitiveArrayGet(array, idx);
+    }
+    public static Object get(float[] array, int idx) {
+        return primitiveArrayGet(array, idx);
+    }
+    public static Object get(double[] array, int idx) {
+        return primitiveArrayGet(array, idx);
+    }
+    
+    public static Object get(byte[] array, Range range) {
+        return primitiveArrayGet(array, range);
+    }
+    public static Object get(char[] array, Range range) {
+        return primitiveArrayGet(array, range);
+    }
+    public static Object get(short[] array, Range range) {
+        return primitiveArrayGet(array, range);
+    }
+    public static Object get(int[] array, Range range) {
+        return primitiveArrayGet(array, range);
+    }
+    public static Object get(long[] array, Range range) {
+        return primitiveArrayGet(array, range);
+    }
+    public static Object get(float[] array, Range range) {
+        return primitiveArrayGet(array, range);
+    }
+    public static Object get(double[] array, Range range) {
+        return primitiveArrayGet(array, range);
+    }
+    
+    public static void put(byte[] array, int idx, Object newValue) {
+        primitiveArrayPut(array, idx, newValue);
+    }
+    
+    public static void put(char[] array, int idx, Object newValue) {
+        primitiveArrayPut(array, idx, newValue);
+    }
+    public static void put(short[] array, int idx, Object newValue) {
+        primitiveArrayPut(array, idx, newValue);
+    }
+    public static void put(int[] array, int idx, Object newValue) {
+        primitiveArrayPut(array, idx, newValue);
+    }
+    public static void put(long[] array, int idx, Object newValue) {
+        primitiveArrayPut(array, idx, newValue);
+    }
+    public static void put(float[] array, int idx, Object newValue) {
+        primitiveArrayPut(array, idx, newValue);
+    }
+    public static void put(double[] array, int idx, Object newValue) {
+        primitiveArrayPut(array, idx, newValue);
+    }
+    
+    public static int size(byte[] array) {
+        return Array.getLength(array);
+    }
+    public static int size(char[] array) {
+        return Array.getLength(array);
+    }
+    public static int size(short[] array) {
+        return Array.getLength(array);
+    }
+    public static int size(int[] array) {
+        return Array.getLength(array);
+    }
+    public static int size(long[] array) {
+        return Array.getLength(array);
+    }
+    public static int size(float[] array) {
+        return Array.getLength(array);
+    }
+    public static int size(double[] array) {
+        return Array.getLength(array);
+    }
+    
+    /**
+     * Implements the get(int idx) method for primitve type arrays
+     */
+    protected static Object primitiveArrayGet(Object array, int idx) {
+        return Array.get(array, normaliseIndex(idx, Array.getLength(array)));
+    }
+    
+    /**
+     * Implements the get(int idx) method for primitve type arrays
+     */
+    protected static Object primitiveArrayGet(Object array, Range range) {
+        List answer = new ArrayList();
+        for (Iterator iter = range.iterator(); iter.hasNext(); ) {
+            int idx = InvokerHelper.asInt(iter.next());
+            answer.add(primitiveArrayGet(array, idx));
+        }
+        return answer;
+    }
+    
+    /**
+     * Implements the set(int idx) method for primitve type arrays
+     */
+    protected static void primitiveArrayPut(Object array, int idx, Object newValue) {
+        Array.set(array, normaliseIndex(idx, Array.getLength(array)), newValue);
+    }
+    
+    
     // String methods
     //-------------------------------------------------------------------------
     public static Object tokenize(String self, String token) {
diff --git a/src/main/org/codehaus/groovy/syntax/parser/ASTBuilder.java b/src/main/org/codehaus/groovy/syntax/parser/ASTBuilder.java
index 27bab1534d..4c494b498c 100644
--- a/src/main/org/codehaus/groovy/syntax/parser/ASTBuilder.java
+++ b/src/main/org/codehaus/groovy/syntax/parser/ASTBuilder.java
@@ -904,8 +904,9 @@ public class ASTBuilder
     {
         String datatype = resolvedQualifiedNameNotNull( expressionRoot.getChild( 0 ) );
 
-        TupleExpression args = tupleExpression( expressionRoot.getChild( 1 ) );
-
+        //TupleExpression args = tupleExpression( expressionRoot.getChild( 1 ) );
+        Expression args = actualParameterList( expressionRoot.getChild( 1 ) );
+        
         return new ConstructorCallExpression( datatype,
                                               args );
     }
diff --git a/src/main/org/codehaus/groovy/syntax/parser/Parser.java b/src/main/org/codehaus/groovy/syntax/parser/Parser.java
index 64f36e0c8d..b71e3558f4 100644
--- a/src/main/org/codehaus/groovy/syntax/parser/Parser.java
+++ b/src/main/org/codehaus/groovy/syntax/parser/Parser.java
@@ -1580,12 +1580,32 @@ public class Parser
 
         expr.addChild( datatype() );
 
+        /*
         consume( Token.LEFT_PARENTHESIS );
 
         expr.addChild( parameterList( Token.RIGHT_PARENTHESIS ) );
 
         consume( Token.RIGHT_PARENTHESIS );
+        */
 
+        CSTNode paramList  = null;
+        
+        if ( lt_bare() == Token.LEFT_PARENTHESIS )
+        {
+            consume( Token.LEFT_PARENTHESIS );
+
+            expr.addChild( parameterList( Token.RIGHT_PARENTHESIS ) );
+
+            consume( Token.RIGHT_PARENTHESIS );
+        }
+        else
+        if ( lt_bare() == Token.LEFT_CURLY_BRACE )
+        {
+                paramList = parameterList( Token.LEFT_CURLY_BRACE );
+                expr.addChild( paramList );
+                expr.addChild( closureExpression() );
+        }
+    
         return expr;
     }
 
diff --git a/src/test/groovy/ClosureListenerTest.groovy b/src/test/groovy/ClosureListenerTest.groovy
new file mode 100644
index 0000000000..d0f62d86ac
--- /dev/null
+++ b/src/test/groovy/ClosureListenerTest.groovy
@@ -0,0 +1,35 @@
+import javax.swing.JButton
+import java.util.Arrays
+
+/**
+ * @version $Revision$
+ */
+class ClosureListenerTest extends GroovyTestCase {
+     
+    void testBug() {
+        b = new JButton("foo")
+        b.actionPerformed = { println("Found ${it}") }
+
+        size = b.actionListeners.size()
+        assert size == 1
+        
+        l = b.actionListeners[0]
+		code = l.hashCode()
+        
+        println("listener: ${l} with hashCode code ${code}")
+        
+        assert l.toString() != "null"
+        
+        assert l.equals(b) == false
+        assert l.equals(l)
+        
+        assert l.hashCode() != 0
+        
+        b.removeActionListener(l)
+        
+        println(b.actionListeners)
+        
+        size = b.actionListeners.size()
+        assert size == 0
+    }
+}
\ No newline at end of file
diff --git a/src/test/groovy/LocalVariableTest.groovy b/src/test/groovy/LocalVariableTest.groovy
index 7e3f4f29d4..8dd32584b4 100644
--- a/src/test/groovy/LocalVariableTest.groovy
+++ b/src/test/groovy/LocalVariableTest.groovy
@@ -19,6 +19,7 @@ class LocalVariableTest extends GroovyTestCase {
         catch (MissingPropertyException e) {
 			assert e.getProperty() == "x"            
             text = e.message
+			//e.printStackTrace()
             assert text == "No such property: x for class: LocalVariableTest"
         }
     }
diff --git a/src/test/groovy/PropertyTest.groovy b/src/test/groovy/PropertyTest.groovy
index 2498506ec4..316f197124 100644
--- a/src/test/groovy/PropertyTest.groovy
+++ b/src/test/groovy/PropertyTest.groovy
@@ -76,4 +76,12 @@ class PropertyTest extends GroovyTestCase {
 	    shouldFail { foo.getQ() }
 	}
 
+    void testConstructorWithNamedProperties() {
+        foo = new Foo(name:'Gromit', location:'Moon')
+        
+        assert foo.name == 'Gromit'
+        assert foo.location == 'Moon'
+        
+        println("created bean ${foo.inspect()}")
+    }
 }
\ No newline at end of file
diff --git a/src/test/groovy/SubscriptTest.groovy b/src/test/groovy/SubscriptTest.groovy
index 46a1c5a7c1..91a29bdc27 100644
--- a/src/test/groovy/SubscriptTest.groovy
+++ b/src/test/groovy/SubscriptTest.groovy
@@ -1,13 +1,11 @@
 class SubscriptTest extends GroovyTestCase {
 
     void testListRange() {
-        /** @todo fixme
         list = ['a', 'b', 'c', 'd', 'e']
 		
 		sub = list[2..4]
 
 		assert sub == ['c', 'd']
-		 */
     }
     
     void testStringSubscript() {
diff --git a/src/test/groovy/bugs/PropertyBug.groovy b/src/test/groovy/bugs/PropertyBug.groovy
new file mode 100644
index 0000000000..c207dd5966
--- /dev/null
+++ b/src/test/groovy/bugs/PropertyBug.groovy
@@ -0,0 +1,18 @@
+import javax.swing.JButton
+import javax.swing.JPanel
+
+/**
+ * @version $Revision$
+ */
+class PropertyBug extends GroovyTestCase {
+     
+    void testBug() {
+        panel = new JPanel()
+        bean = new JButton()
+        
+        panel.add(bean)
+        
+        value = bean.parent
+        assert value != null
+    }
+}
\ No newline at end of file
diff --git a/src/test/groovy/bugs/SubscriptOnPrimitiveTypeArrayBug.groovy b/src/test/groovy/bugs/SubscriptOnPrimitiveTypeArrayBug.groovy
new file mode 100644
index 0000000000..45bd3e49ee
--- /dev/null
+++ b/src/test/groovy/bugs/SubscriptOnPrimitiveTypeArrayBug.groovy
@@ -0,0 +1,22 @@
+package groovy.bugs
+
+class SubscriptOnPrimitiveTypeArrayBug extends TestSupport {
+
+    void testBug() {
+        array = getIntArray()
+        
+        value = array[2]
+        
+        assert value == 3
+        
+        array[2] = 8
+
+        value = array[2]
+        assert value == 8
+        
+        // lets test a range
+        range = array[1..3]
+        
+        assert range == [2, 8]
+    }
+}
\ No newline at end of file
diff --git a/src/test/groovy/bugs/TestSupport.java b/src/test/groovy/bugs/TestSupport.java
index 5561400f3f..bc4b1c5735 100644
--- a/src/test/groovy/bugs/TestSupport.java
+++ b/src/test/groovy/bugs/TestSupport.java
@@ -67,4 +67,8 @@ public class TestSupport extends GroovyTestCase {
     public static String getMockStaticProperty() {
         return "cheese";
     }
+    
+    public int[] getIntArray() {
+        return new int[] { 1, 2, 3, 4, 5 };
+    }
 }
diff --git a/src/test/org/codehaus/groovy/runtime/InvokeMethodTest.java b/src/test/org/codehaus/groovy/runtime/InvokeMethodTest.java
index 214bff1395..7465bdf02f 100644
--- a/src/test/org/codehaus/groovy/runtime/InvokeMethodTest.java
+++ b/src/test/org/codehaus/groovy/runtime/InvokeMethodTest.java
@@ -1,56 +1,47 @@
 /*
- $Id$
-
- Copyright 2003 (C) James Strachan and Bob Mcwhirter. All Rights Reserved.
-
- Redistribution and use of this software and associated documentation
- ("Software"), with or without modification, are permitted provided
- that the following conditions are met:
-
- 1. Redistributions of source code must retain copyright
-    statements and notices.  Redistributions must also contain a
-    copy of this document.
-
- 2. Redistributions in binary form must reproduce the
-    above copyright notice, this list of conditions and the
-    following disclaimer in the documentation and/or other
-    materials provided with the distribution.
-
- 3. The name "groovy" must not be used to endorse or promote
-    products derived from this Software without prior written
-    permission of The Codehaus.  For written permission,
-    please contact info@codehaus.org.
-
- 4. Products derived from this Software may not be called "groovy"
-    nor may "groovy" appear in their names without prior written
-    permission of The Codehaus. "groovy" is a registered
-    trademark of The Codehaus.
-
- 5. Due credit should be given to The Codehaus -
-    http://groovy.codehaus.org/
-
- THIS SOFTWARE IS PROVIDED BY THE CODEHAUS AND CONTRIBUTORS
- ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
- NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
- FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
- THE CODEHAUS OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
- INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
- OF THE POSSIBILITY OF SUCH DAMAGE.
-
+ * $Id$
+ * 
+ * Copyright 2003 (C) James Strachan and Bob Mcwhirter. All Rights Reserved.
+ * 
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided that the
+ * following conditions are met:
+ *  1. Redistributions of source code must retain copyright statements and
+ * notices. Redistributions must also contain a copy of this document.
+ *  2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *  3. The name "groovy" must not be used to endorse or promote products
+ * derived from this Software without prior written permission of The Codehaus.
+ * For written permission, please contact info@codehaus.org.
+ *  4. Products derived from this Software may not be called "groovy" nor may
+ * "groovy" appear in their names without prior written permission of The
+ * Codehaus. "groovy" is a registered trademark of The Codehaus.
+ *  5. Due credit should be given to The Codehaus - http://groovy.codehaus.org/
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE CODEHAUS AND CONTRIBUTORS ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE CODEHAUS OR ITS CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *  
  */
 
 package org.codehaus.groovy.runtime;
 
 import groovy.lang.GString;
 import groovy.lang.GroovyRuntimeException;
+import groovy.lang.IntRange;
 import groovy.util.GroovyTestCase;
 
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collection;
 import java.util.Date;
 import java.util.List;
@@ -91,6 +82,11 @@ public class InvokeMethodTest extends GroovyTestCase {
         assertEquals("return value", "OneParamWithNull", value);
     }
 
+    public void testInvokeOverloadedMethodWithOneParamWhichIsNull() throws Throwable {
+        Object value = invoke(this, "mockOverloadedMethod", new Object[] { null });
+        assertEquals("return value", "Object", value);
+    }
+
     public void testInvokeMethodOneCollectionParameter() throws Throwable {
         Object[] foo = { "a", "b", "c" };
 
@@ -230,7 +226,7 @@ public class InvokeMethodTest extends GroovyTestCase {
     }
 
     public void testCallIntMethodWithInteger() throws Throwable {
-        Object value = invoke(this, "overloadedRemove", new Object[] { new Integer(5) });
+        Object value = invoke(this, "overloadedRemove", new Object[] { new Integer(5)});
         assertEquals("called with integer", "int5", value);
     }
 
@@ -238,9 +234,9 @@ public class InvokeMethodTest extends GroovyTestCase {
         List list = new ArrayList();
         list.add("foo");
         list.add("bar");
-        
-        Object value = invoke(list, "remove", new Object[] { new Integer(0) });
-        
+
+        Object value = invoke(list, "remove", new Object[] { new Integer(0)});
+
         assertEquals("Should have just 1 item left: " + list, 1, list.size());
     }
 
@@ -284,6 +280,15 @@ public class InvokeMethodTest extends GroovyTestCase {
         assertEquals("substring(1,3)", object.substring(1, 3), value);
     }
 
+    public void testListGetWithRange() throws Throwable {
+        List list = Arrays.asList(new Object[] { "a", "b", "c" });
+        Object range = new IntRange(1, 3);
+        Object value = invoke(list, "get", range);
+        assertTrue("Returned List: " + value, value instanceof List);
+        List retList = (List) value;
+        assertEquals("List size", 2, retList.size());
+    }
+
     public void testInvokeUnknownMethod() throws Throwable {
         try {
             Object value = invoke(this, "unknownMethod", "abc");
@@ -381,7 +386,6 @@ public class InvokeMethodTest extends GroovyTestCase {
         return "Object" + value;
     }
 
-    
     // Implementation methods
     //-------------------------------------------------------------------------
 
@@ -399,11 +403,14 @@ public class InvokeMethodTest extends GroovyTestCase {
     }
 
     /**
-     * Asserts that invoking the method chooser finds the right overloaded method implementation
-     * 
-     * @param expected is the expected value of the method
-     * @param arguments the argument(s) to the method invocation
-     */
+	 * Asserts that invoking the method chooser finds the right overloaded
+	 * method implementation
+	 * 
+	 * @param expected
+	 *            is the expected value of the method
+	 * @param arguments
+	 *            the argument(s) to the method invocation
+	 */
     protected void assertMethodChooser(Object expected, Object arguments) throws Throwable {
         Object value = invoke(this, "mockOverloadedMethod", arguments);
 
diff --git a/src/test/org/codehaus/groovy/runtime/PropertyTest.java b/src/test/org/codehaus/groovy/runtime/PropertyTest.java
index 46a7cbbd1d..d86c2acd76 100644
--- a/src/test/org/codehaus/groovy/runtime/PropertyTest.java
+++ b/src/test/org/codehaus/groovy/runtime/PropertyTest.java
@@ -56,7 +56,9 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
+import javax.swing.JButton;
 import javax.swing.JFrame;
+import javax.swing.JPanel;
 
 /**
  * Test the property access of the Invoker class
@@ -202,6 +204,16 @@ public class PropertyTest extends GroovyTestCase {
         return "cheddar";
     }
 
+    public void testComponentParent() {
+        JPanel panel = new JPanel();
+        JButton bean = new JButton();
+        
+        panel.add(bean);
+        
+        Object value = InvokerHelper.getProperty(bean, "parent");
+        assertTrue(value != null);
+    }
+    
     // Implementation methods
     //-------------------------------------------------------------------------
 
diff --git a/xdocs/beans.wiki b/xdocs/beans.wiki
index ca3e826c00..98b642efbb 100644
--- a/xdocs/beans.wiki
+++ b/xdocs/beans.wiki
@@ -5,6 +5,8 @@ GroovyBeans are JavaBeans but using a much simpler syntax.
 Here's an example 
 
 {code:gsh}
+import java.util.Date
+
 class Customer {
     // properties
     Integer id
@@ -13,10 +15,7 @@ class Customer {
     
     // sample code
     static void main(args) {
-        customer = new Customer()
-        customer.id = 1
-        customer.name = "Gromit"
-        
+        customer = new Customer(id:1, name:"Gromit", dob:new Date())
         println("Hello ${customer.name}")
     }
 }
@@ -25,16 +24,19 @@ class Customer {
 Hello Gromit
 {code}
 
-Notice how the properties look just like public fields. In Groovy fields and properties
+Notice how the properties look just like public fields. You can also set
+named properties in a bean constructor in Groovy. In Groovy fields and properties
 have been merged so that they act and look the same. So the above is equivlent to the
 following Java code...
 
 {code:java}
+import java.util.Date;
+
 public class Customer {
     // properties
-    private Integer id
-    private String name
-    private Date dob
+    private Integer id;
+    private String name;
+    private Date dob;
     
     public Integer getId() {
         return id;
