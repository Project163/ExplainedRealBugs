diff --git a/src/main/groovy/transform/EqualsAndHashCode.java b/src/main/groovy/transform/EqualsAndHashCode.java
index 3092bd9a80..8c5d4d2daf 100644
--- a/src/main/groovy/transform/EqualsAndHashCode.java
+++ b/src/main/groovy/transform/EqualsAndHashCode.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2010 the original author or authors.
+ * Copyright 2008-2011 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -44,9 +44,110 @@ import java.lang.annotation.Target;
  * AST transformation which adds the necessary equals and hashCode methods to the class.
  * <p/>
  * The {@code hashCode()} method is calculated using Groovy's {@code HashCodeHelper} class
- * which implements an algorithm similar to the outlined in the book <em>Effective Java</em>.
+ * which implements an algorithm similar to the one outlined in the book <em>Effective Java</em>.
  * <p/>
- * The {@code equals()} method compares the values of the individual properties of the class.
+ * The {@code equals()} method compares the values of the individual properties (and optionally fields)
+ * of the class.  It can also optionally call equals on the super class. Two different equals method
+ * implementations are supported both of which support the equals contract outlined in the javadoc
+ * for <code>java.lang.Object</code>
+ * <p/>
+ * To illustrate the 'canEqual' implementation style (see http://www.artima.com/lejava/articles/equality.html
+ * for further details), consider this class:
+ * <pre>
+ * {@code @EqualsAndHashCode}
+ * class IntPair {
+ *     int x, y
+ * }
+ * </pre>
+ * The generated <code>equals</code> and <code>canEqual</code> methods will be something like below:
+ * <pre>
+ * public boolean equals(java.lang.Object other)
+ *     if (other == null) return false
+ *     if (this.is(other)) return true
+ *     if (!(other instanceof IntPair)) return false
+ *     if (!other.canEqual(this)) return false
+ *     if (x != other.x) return false
+ *     if (y != other.y) return false
+ *     return true
+ * }
+ *
+ * public boolean canEqual(java.lang.Object other) {
+ *     return other instanceof IntPair
+ * }
+ * </pre>
+ * If no further options are specified, this is the default style for non-final {@code @Canonical} and
+ * {@code @EqualsAndHashCode} annotated classes. The advantage of this style is that it allows inheritance
+ * to be used in limited cases where its purpose is for overriding implementation details rather than
+ * creating a derived type with different behavior. This is useful when using JPA Proxies for example or
+ * as shown in the following examples:
+ * <pre>
+ * {@code @Canonical} class IntPair { int x, y }
+ * def p1 = new IntPair(1, 2)
+ *
+ * // overriden getter but deemed an IntPair as far as domain is concerned
+ * def p2 = new IntPair(1, 1) { int getY() { 2 } }
+ *
+ * // additional helper method added through inheritance but
+ * // deemed an IntPair as far as our domain is concerned
+ * {@code @InheritConstructors} class IntPairWithSum extends IntPair {
+ *     def sum() { x + y }
+ * }
+ *
+ * def p3 = new IntPairWithSum(1, 2)
+ *
+ * assert p1 == p2 && p2 == p1
+ * assert p1 == p3 && p3 == p1
+ * assert p3 == p2 && p2 == p3
+ * </pre>
+ * Note that if you create any domain classes which don't have exactly the
+ * same contract as <code>IntPair</code> then you should provide an appropriate
+ * <code>equals</code> and <code>canEqual</code> method. The easiest way to
+ * achieve this would be to use the {@code @Canonical} or
+ * {@code @EqualsAndHashCode} annotations as shown below:
+ * <pre>
+ * {@code @EqualsAndHashCode}
+ * {@code @TupleConstructor(includeSuperProperties=true)}
+ * class IntTriple extends IntPair { int z }
+ * def t1 = new IntTriple(1, 2, 3)
+ * assert p1 != t1 && p2 != t1 && t1 != p3
+ * </pre>
+ *
+ * The alternative supported style regards any kind of inheritance as creation of
+ * a new type and is illustrated in the following example:
+ * <pre>
+ * {@code @EqualsAndHashCode(useCanEqual=false)}
+ * class IntPair {
+ *     int x, y
+ * }
+ * </pre>
+ * The generated equals method will be something like below:
+ * <pre>
+ * public boolean equals(java.lang.Object other)
+ *     if (other == null) return false
+ *     if (this.is(other)) return true
+ *     if (IntPair != other.getClass()) return false
+ *     if (x != other.x) return false
+ *     if (y != other.y) return false
+ *     return true
+ * }
+ * </pre>
+ * This style is appropriate for final classes where inheritance is not
+ * allowed (e.g. for {@code @Immutable} classes) and hence there is no need
+ * to introduce the <code>canEqual()</code> method.
+ * <p/>
+ * Note that the two implementations supported adhere to the equals
+ * contract. You can provide your own equivalence relationships if you need,
+ * e.g. for comparing the <code>IntPair</code> and <code>IntTriple</code>
+ * discussed earlier, you could provide the following method in <code>IntPair</code>:
+ * <pre>
+ * boolean hasEqualXY(other) { other.x == getX() && other.y == getY() }
+ * </pre>
+ * Then for the objects defined earlier, the following would be true:
+ * <pre>
+ * assert p1.hasEqualXY(t1) && t1.hasEqualXY(p1)
+ * assert p2.hasEqualXY(t1) && t1.hasEqualXY(p2)
+ * assert p3.hasEqualXY(t1) && t1.hasEqualXY(p3)
+ * </pre>
  *
  * @see org.codehaus.groovy.util.HashCodeHelper
  * @author Paul King
@@ -71,4 +172,9 @@ public @interface EqualsAndHashCode {
      * Include fields as well as properties in equals and hashCode calculations
      */
     boolean includeFields() default false;
+
+    /**
+     * Generate a canEqual method to be used by equals
+     */
+    boolean useCanEqual() default true;
 }
diff --git a/src/main/org/codehaus/groovy/transform/AbstractASTTransformUtil.java b/src/main/org/codehaus/groovy/transform/AbstractASTTransformUtil.java
index 0dc7392979..a914d9c68a 100644
--- a/src/main/org/codehaus/groovy/transform/AbstractASTTransformUtil.java
+++ b/src/main/org/codehaus/groovy/transform/AbstractASTTransformUtil.java
@@ -30,6 +30,7 @@ import org.codehaus.groovy.ast.stmt.ExpressionStatement;
 import org.codehaus.groovy.ast.stmt.IfStatement;
 import org.codehaus.groovy.ast.stmt.ReturnStatement;
 import org.codehaus.groovy.ast.stmt.Statement;
+import org.codehaus.groovy.classgen.Verifier;
 import org.codehaus.groovy.syntax.Token;
 import org.codehaus.groovy.syntax.Types;
 import org.objectweb.asm.Opcodes;
@@ -194,9 +195,10 @@ public abstract class AbstractASTTransformUtil implements Opcodes {
     }
 
     private static BooleanExpression notEqualsPropertyExpr(PropertyNode pNode, Expression other) {
-        final Expression fieldExpr = new VariableExpression(pNode);
-        final Expression otherExpr = new PropertyExpression(other, pNode.getName());
-        return new BooleanExpression(new BinaryExpression(fieldExpr, COMPARE_NOT_EQUAL, otherExpr));
+        String getterName = "get" + Verifier.capitalize(pNode.getName());
+        Expression selfGetter = new MethodCallExpression(VariableExpression.THIS_EXPRESSION, getterName, MethodCallExpression.NO_ARGUMENTS);
+        Expression otherGetter = new MethodCallExpression(other, getterName, MethodCallExpression.NO_ARGUMENTS);
+        return new BooleanExpression(new BinaryExpression(selfGetter, COMPARE_NOT_EQUAL, otherGetter));
     }
 
     private static BooleanExpression identicalExpr(Expression self, Expression other) {
@@ -208,7 +210,7 @@ public abstract class AbstractASTTransformUtil implements Opcodes {
                 new MethodCallExpression(other, "getClass", MethodCallExpression.NO_ARGUMENTS)));
     }
 
-    private static BooleanExpression isInstanceof(ClassNode cNode, Expression other) {
+    public static BooleanExpression isInstanceof(ClassNode cNode, Expression other) {
         return new BooleanExpression(new BinaryExpression(other, INSTANCEOF, new ClassExpression(cNode)));
     }
 
diff --git a/src/main/org/codehaus/groovy/transform/CanonicalASTTransformation.java b/src/main/org/codehaus/groovy/transform/CanonicalASTTransformation.java
index b871002c77..e38c43b4cb 100644
--- a/src/main/org/codehaus/groovy/transform/CanonicalASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/CanonicalASTTransformation.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2010 the original author or authors.
+ * Copyright 2008-2011 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -60,7 +60,7 @@ public class CanonicalASTTransformation extends AbstractASTTransformation {
             }
             if (!hasAnnotation(cNode, EqualsAndHashCodeASTTransformation.MY_TYPE)) {
                 createHashCode(cNode, false, false, false, new ArrayList<String>());
-                createEquals(cNode, false, false, new ArrayList<String>());
+                createEquals(cNode, false, false, true, new ArrayList<String>());
             }
             if (!hasAnnotation(cNode, ToStringASTTransformation.MY_TYPE)) {
                 toStringInit(cNode, ConstantExpression.FALSE);
diff --git a/src/main/org/codehaus/groovy/transform/EqualsAndHashCodeASTTransformation.java b/src/main/org/codehaus/groovy/transform/EqualsAndHashCodeASTTransformation.java
index 0ecd424c0e..54193999d6 100644
--- a/src/main/org/codehaus/groovy/transform/EqualsAndHashCodeASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/EqualsAndHashCodeASTTransformation.java
@@ -16,14 +16,7 @@
 package org.codehaus.groovy.transform;
 
 import groovy.transform.EqualsAndHashCode;
-import org.codehaus.groovy.ast.ASTNode;
-import org.codehaus.groovy.ast.AnnotatedNode;
-import org.codehaus.groovy.ast.AnnotationNode;
-import org.codehaus.groovy.ast.ClassHelper;
-import org.codehaus.groovy.ast.ClassNode;
-import org.codehaus.groovy.ast.FieldNode;
-import org.codehaus.groovy.ast.MethodNode;
-import org.codehaus.groovy.ast.Parameter;
+import org.codehaus.groovy.ast.*;
 import org.codehaus.groovy.ast.expr.*;
 import org.codehaus.groovy.ast.stmt.BlockStatement;
 import org.codehaus.groovy.ast.stmt.EmptyStatement;
@@ -31,12 +24,14 @@ import org.codehaus.groovy.ast.stmt.ExpressionStatement;
 import org.codehaus.groovy.ast.stmt.IfStatement;
 import org.codehaus.groovy.ast.stmt.ReturnStatement;
 import org.codehaus.groovy.ast.stmt.Statement;
+import org.codehaus.groovy.classgen.Verifier;
 import org.codehaus.groovy.control.CompilePhase;
 import org.codehaus.groovy.control.SourceUnit;
 import org.codehaus.groovy.syntax.Token;
 import org.codehaus.groovy.syntax.Types;
 import org.codehaus.groovy.util.HashCodeHelper;
 
+import java.util.ArrayList;
 import java.util.List;
 
 import static org.codehaus.groovy.transform.AbstractASTTransformUtil.*;
@@ -60,13 +55,14 @@ public class EqualsAndHashCodeASTTransformation extends AbstractASTTransformatio
             ClassNode cNode = (ClassNode) parent;
             checkNotInterface(cNode, MY_TYPE_NAME);
             boolean callSuper = memberHasValue(anno, "callSuper", true);
+            boolean useCanEqual = !memberHasValue(anno, "useCanEqual", false);
             if (callSuper && cNode.getSuperClass().getName().equals("java.lang.Object")) {
                 addError("Error during " + MY_TYPE_NAME + " processing: callSuper=true but '" + cNode.getName() + "' has no super class.", anno);
             }
             boolean includeFields = memberHasValue(anno, "includeFields", true);
             List<String> excludes = tokenize((String) getMemberValue(anno, "excludes"));
             createHashCode(cNode, false, includeFields, callSuper, excludes);
-            createEquals(cNode, includeFields, callSuper, excludes);
+            createEquals(cNode, includeFields, callSuper, useCanEqual, excludes);
         }
     }
 
@@ -76,35 +72,47 @@ public class EqualsAndHashCodeASTTransformation extends AbstractASTTransformatio
         if (hasExistingHashCode && hasDeclaredMethod(cNode, "_hashCode", 0)) return;
 
         final BlockStatement body = new BlockStatement();
-        List<FieldNode> list = getInstancePropertyFields(cNode);
-        if (includeFields) {
-            list.addAll(getInstanceNonPropertyFields(cNode));
-        }
+        // TODO use pList and fList
         if (cacheResult) {
             final FieldNode hashField = cNode.addField("$hash$code", ACC_PRIVATE | ACC_SYNTHETIC, ClassHelper.int_TYPE, null);
             final Expression hash = new VariableExpression(hashField);
             body.addStatement(new IfStatement(
                     isZeroExpr(hash),
-                    calculateHashStatements(hash, list, callSuper, excludes),
+                    calculateHashStatements(cNode, hash, includeFields, callSuper, excludes),
                     new EmptyStatement()
             ));
             body.addStatement(new ReturnStatement(hash));
         } else {
-            body.addStatement(calculateHashStatements(null, list, callSuper, excludes));
+            body.addStatement(calculateHashStatements(cNode, null, includeFields, callSuper, excludes));
         }
 
         cNode.addMethod(new MethodNode(hasExistingHashCode ? "_hashCode" : "hashCode", hasExistingHashCode ? ACC_PRIVATE : ACC_PUBLIC,
                 ClassHelper.int_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, body));
     }
 
-    private static Statement calculateHashStatements(Expression hash, List<FieldNode> list, boolean callSuper, List<String> excludes) {
+    private static Statement calculateHashStatements(ClassNode cNode, Expression hash, boolean includeFields, boolean callSuper, List<String> excludes) {
+        final List<PropertyNode> pList = getInstanceProperties(cNode);
+        final List<FieldNode> fList = new ArrayList<FieldNode>();
+        if (includeFields) {
+            fList.addAll(getInstanceNonPropertyFields(cNode));
+        }
         final BlockStatement body = new BlockStatement();
         // def _result = HashCodeHelper.initHash()
         final Expression result = new VariableExpression("_result");
         final Expression init = new StaticMethodCallExpression(HASHUTIL_TYPE, "initHash", MethodCallExpression.NO_ARGUMENTS);
         body.addStatement(new ExpressionStatement(new DeclarationExpression(result, ASSIGN, init)));
 
-        for (FieldNode fNode : list) {
+        for (PropertyNode pNode : pList) {
+            if (excludes.contains(pNode.getName()) || pNode.getName().contains("$")) continue;
+            // _result = HashCodeHelper.updateHash(_result, getProperty())
+            String getterName = "get" + Verifier.capitalize(pNode.getName());
+            Expression getter = new MethodCallExpression(VariableExpression.THIS_EXPRESSION, getterName, MethodCallExpression.NO_ARGUMENTS);
+            final Expression args = new TupleExpression(result, getter);
+            final Expression current = new StaticMethodCallExpression(HASHUTIL_TYPE, "updateHash", args);
+            body.addStatement(assignStatement(result, current));
+
+        }
+        for (FieldNode fNode : fList) {
             if (excludes.contains(fNode.getName()) || fNode.getName().contains("$")) continue;
             // _result = HashCodeHelper.updateHash(_result, field)
             final Expression fieldExpr = new VariableExpression(fNode);
@@ -127,42 +135,69 @@ public class EqualsAndHashCodeASTTransformation extends AbstractASTTransformatio
         return body;
     }
 
-    public static void createEquals(ClassNode cNode, boolean includeFields, boolean callSuper, List<String> excludes) {
+    private static void createCanEqual(ClassNode cNode) {
+        boolean hasExistingCanEqual = hasDeclaredMethod(cNode, "canEqual", 1);
+        if (hasExistingCanEqual && hasDeclaredMethod(cNode, "_canEqual", 1)) return;
+
+        final BlockStatement body = new BlockStatement();
+        VariableExpression other = new VariableExpression("other");
+        body.addStatement(new ReturnStatement(isInstanceof(cNode, other)));
+        Parameter[] params = {new Parameter(OBJECT_TYPE, other.getName())};
+        cNode.addMethod(new MethodNode(hasExistingCanEqual ? "_canEqual" : "canEqual", hasExistingCanEqual ? ACC_PRIVATE : ACC_PUBLIC,
+                ClassHelper.boolean_TYPE, params, ClassNode.EMPTY_ARRAY, body));
+
+    }
+
+    public static void createEquals(ClassNode cNode, boolean includeFields, boolean callSuper, boolean useCanEqual, List<String> excludes) {
+        if (useCanEqual) createCanEqual(cNode);
         // make a public method if none exists otherwise try a private method with leading underscore
         boolean hasExistingEquals = hasDeclaredMethod(cNode, "equals", 1);
         if (hasExistingEquals && hasDeclaredMethod(cNode, "_equals", 1)) return;
 
         final BlockStatement body = new BlockStatement();
-        Expression other = new VariableExpression("other");
+        VariableExpression other = new VariableExpression("other");
 
         // some short circuit cases for efficiency
         body.addStatement(returnFalseIfNull(other));
-        body.addStatement(returnFalseIfWrongType(cNode, other));
         body.addStatement(returnTrueIfIdentical(VariableExpression.THIS_EXPRESSION, other));
 
-        body.addStatement(new ExpressionStatement(new BinaryExpression(other, ASSIGN, new CastExpression(cNode, other))));
+        if (useCanEqual) {
+            body.addStatement(returnFalseIfNotInstanceof(cNode, other));
+            body.addStatement(new IfStatement(
+                    new BooleanExpression(new MethodCallExpression(other, "canEqual", VariableExpression.THIS_EXPRESSION)),
+                    new EmptyStatement(),
+                    new ReturnStatement(ConstantExpression.FALSE)
+            ));
+        } else {
+            body.addStatement(returnFalseIfWrongType(cNode, other));
+        }
+//        body.addStatement(new ExpressionStatement(new BinaryExpression(other, ASSIGN, new CastExpression(cNode, other))));
 
-        List<FieldNode> list = getInstancePropertyFields(cNode);
+        List<PropertyNode> pList = getInstanceProperties(cNode);
+        for (PropertyNode pNode : pList) {
+            if (excludes.contains(pNode.getName()) || pNode.getName().contains("$")) continue;
+            body.addStatement(returnFalseIfPropertyNotEqual(pNode, other));
+        }
+        List<FieldNode> fList = new ArrayList<FieldNode>();
         if (includeFields) {
-            list.addAll(getInstanceNonPropertyFields(cNode));
+            fList.addAll(getInstanceNonPropertyFields(cNode));
         }
-        for (FieldNode fNode : list) {
+        for (FieldNode fNode : fList) {
             if (excludes.contains(fNode.getName()) || fNode.getName().contains("$")) continue;
-            body.addStatement(returnFalseIfPropertyNotEqual(fNode, other));
+            body.addStatement(returnFalseIfFieldNotEqual(fNode, other));
         }
         if (callSuper) {
-            Statement result = new IfStatement(
+            body.addStatement(new IfStatement(
                     isTrueExpr(new MethodCallExpression(VariableExpression.SUPER_EXPRESSION, "equals", other)),
                     new EmptyStatement(),
                     new ReturnStatement(ConstantExpression.FALSE)
-            );
-            body.addStatement(result);
+            ));
         }
 
         // default
         body.addStatement(new ReturnStatement(ConstantExpression.TRUE));
 
-        Parameter[] params = {new Parameter(OBJECT_TYPE, "other")};
+        Parameter[] params = {new Parameter(OBJECT_TYPE, other.getName())};
         cNode.addMethod(new MethodNode(hasExistingEquals ? "_equals" : "equals", hasExistingEquals ? ACC_PRIVATE : ACC_PUBLIC,
                 ClassHelper.boolean_TYPE, params, ClassNode.EMPTY_ARRAY, body));
     }
diff --git a/src/main/org/codehaus/groovy/transform/ImmutableASTTransformation.java b/src/main/org/codehaus/groovy/transform/ImmutableASTTransformation.java
index 0d3aa38ef7..ef353def36 100644
--- a/src/main/org/codehaus/groovy/transform/ImmutableASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/ImmutableASTTransformation.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2010 the original author or authors.
+ * Copyright 2008-2011 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -117,7 +117,7 @@ public class ImmutableASTTransformation extends AbstractASTTransformation {
             }
             createConstructors(cNode);
             createHashCode(cNode, true, false, false, new ArrayList<String>());
-            createEquals(cNode, false, false, new ArrayList<String>());
+            createEquals(cNode, false, false, false, new ArrayList<String>());
             createToString(cNode, false, false, new ArrayList<String>());
         }
     }
@@ -426,6 +426,7 @@ public class ImmutableASTTransformation extends AbstractASTTransformation {
         return safeExpression(fieldExpr, expression);
     }
 
+    @SuppressWarnings("Unchecked")
     public static Object checkImmutable(String className, String fieldName, Object field) {
         if (field == null || field instanceof Enum || inImmutableList(field.getClass().getName())) return field;
         if (field instanceof Collection) return DefaultGroovyMethods.asImmutable((Collection) field);
diff --git a/src/test/groovy/inspect/swingui/AstNodeToScriptAdapterTest.groovy b/src/test/groovy/inspect/swingui/AstNodeToScriptAdapterTest.groovy
index 55c5a8ac14..b3599542b7 100644
--- a/src/test/groovy/inspect/swingui/AstNodeToScriptAdapterTest.groovy
+++ b/src/test/groovy/inspect/swingui/AstNodeToScriptAdapterTest.groovy
@@ -576,9 +576,9 @@ public class AstNodeToScriptAdapterTest extends GroovyTestCase {
         // assert hashCode
         assert result.contains('public int hashCode()')
         assert result.contains('java.lang.Object _result = org.codehaus.groovy.util.HashCodeHelper.initHash()')
-        assert result.contains('_result = org.codehaus.groovy.util.HashCodeHelper.updateHash( _result , title )')
-        assert result.contains('_result = org.codehaus.groovy.util.HashCodeHelper.updateHash( _result , when )')
-        assert result.contains('_result = org.codehaus.groovy.util.HashCodeHelper.updateHash( _result , color )')
+        assert result.contains('_result = org.codehaus.groovy.util.HashCodeHelper.updateHash( _result , this.getTitle())')
+        assert result.contains('_result = org.codehaus.groovy.util.HashCodeHelper.updateHash( _result , this.getWhen())')
+        assert result.contains('_result = org.codehaus.groovy.util.HashCodeHelper.updateHash( _result , this.getColor())')
 
         // assert clones
         assert result.contains('return when.clone()')
diff --git a/src/test/org/codehaus/groovy/transform/CanonicalComponentsTransformTest.groovy b/src/test/org/codehaus/groovy/transform/CanonicalComponentsTransformTest.groovy
index be027cd60a..9c4b99191a 100644
--- a/src/test/org/codehaus/groovy/transform/CanonicalComponentsTransformTest.groovy
+++ b/src/test/org/codehaus/groovy/transform/CanonicalComponentsTransformTest.groovy
@@ -22,6 +22,8 @@ import groovy.transform.TupleConstructor
 import static groovy.transform.AutoCloneStyle.COPY_CONSTRUCTOR
 import static groovy.transform.AutoCloneStyle.SERIALIZATION
 import groovy.transform.ToString
+//import groovy.transform.InheritConstructors
+import groovy.transform.Canonical
 
 /**
  * @author Paul King
@@ -118,6 +120,64 @@ class CanonicalComponentsTransformTest extends GroovyShellTestCase {
         assert p1.toString() == 'org.codehaus.groovy.transform.Point(1, 2)'
         assert p2.toString() == 'org.codehaus.groovy.transform.Point(1, 2)'
     }
+
+    // GROOVY-4849
+    void testEqualsOnEquivalentClasses() {
+        def (p1, p2, p3) = new GroovyShell().evaluate("""
+        import groovy.transform.*
+        @Canonical class IntPair {
+            int x, y
+        }
+
+        @InheritConstructors
+        class IntPairWithSum extends IntPair {
+            def sum() { x + y }
+        }
+
+        [new IntPair(1, 2), new IntPair(1, 1) { int getY() { 2 } }, new IntPairWithSum(x:1, y:2)]
+        """)
+
+        assert p1 == p2 && p2 == p1
+        assert p1 == p3 && p3 == p1
+        assert p3 == p2 && p2 == p3
+    }
+
+    // GROOVY-4849
+    void testEqualsOnDifferentClasses() {
+        def (p1, p2, p3, t1) = new GroovyShell().evaluate("""
+        import groovy.transform.*
+        @Canonical class IntPair {
+            int x, y
+            boolean hasEqualXY(other) { other.x == getX() && other.y == getY() }
+        }
+
+        @InheritConstructors
+        class IntPairWithSum extends IntPair {
+            def sum() { x + y }
+        }
+
+        @EqualsAndHashCode
+        @TupleConstructor(includeSuperProperties=true)
+        class IntTriple extends IntPair { int z }
+
+        [new IntPair(1, 2), new IntPair(1, 1) { int getY() { 2 } }, new IntPairWithSum(x:1, y:2), new IntTriple(1, 2, 3)]
+        """)
+
+        assert p1 != t1 && p2 != t1 && t1 != p3
+        assert p1.hasEqualXY(t1) && t1.hasEqualXY(p1)
+        assert p2.hasEqualXY(t1) && t1.hasEqualXY(p2)
+        assert p3.hasEqualXY(t1) && t1.hasEqualXY(p3)
+    }
+
+    // GROOVY-4849
+    void testCanEqualDefined() {
+        def p1 = new IntPair(1, 2)
+        def p2 = new IntPairNoCanEqual(x:1, y:2)
+        assert p1 != p2
+        assert p1.hashCode() == p2.hashCode()
+        assert 'canEqual' in p1.class.methods*.name
+        assert !('canEqual' in p2.class.methods*.name)
+    }
 }
 
 @TupleConstructor
@@ -173,3 +233,14 @@ class PointIgnoreY {
 // GROOVY-4844
 @TupleConstructor @ToString
 class Point { int x, y }
+
+// GROOVY-4849
+@Canonical class IntPair {
+    int x, y
+}
+
+// GROOVY-4849
+@EqualsAndHashCode(useCanEqual=false)
+class IntPairNoCanEqual {
+    int x, y
+}
