diff --git a/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java b/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
index 667ca500c3..be7e97e51f 100644
--- a/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
+++ b/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
@@ -1247,7 +1247,8 @@ public class AsmClassGenerator extends ClassGenerator {
                     "getThisObject",
                     "()Ljava/lang/Object;"
             );
-            controller.getOperandStack().push(controller.getClassNode().getOuterClass());
+            controller.getOperandStack().push(ClassHelper.OBJECT_TYPE);
+//            controller.getOperandStack().push(controller.getClassNode().getOuterClass());
         } else {
             controller.getOperandStack().push(controller.getClassNode());
         }
diff --git a/src/main/org/codehaus/groovy/classgen/asm/ClosureWriter.java b/src/main/org/codehaus/groovy/classgen/asm/ClosureWriter.java
index 802ec73114..e44e7a0ce4 100644
--- a/src/main/org/codehaus/groovy/classgen/asm/ClosureWriter.java
+++ b/src/main/org/codehaus/groovy/classgen/asm/ClosureWriter.java
@@ -93,30 +93,9 @@ public class ClosureWriter {
         for (int i = 2; i < localVariableParams.length; i++) {
             Parameter param = localVariableParams[i];
             String name = param.getName();
-
-            // compileStack.containsVariable(name) means to ask if the variable is already declared
-            // compileStack.getScope().isReferencedClassVariable(name) means to ask if the variable is a field
-            // If it is no field and is not yet declared, then it is either a closure shared variable or
-            // an already declared variable.
-            if (!compileStack.containsVariable(name) && compileStack.getScope().isReferencedClassVariable(name)) {
-                acg.visitFieldExpression(new FieldExpression(classNode.getDeclaredField(name)));
-            } else {
-                BytecodeVariable v = compileStack.getVariable(name, !classNodeUsesReferences());
-                if (v == null) {
-                    // variable is not on stack because we are
-                    // inside a nested Closure and this variable
-                    // was not used before
-                    // then load it from the Closure field
-                    FieldNode field = classNode.getDeclaredField(name);
-                    mv.visitVarInsn(ALOAD, 0);
-                    mv.visitFieldInsn(GETFIELD, controller.getInternalClassName(), name, BytecodeHelper.getTypeDescription(field.getType()));
-                } else {
-                    mv.visitVarInsn(ALOAD, v.getIndex());
-                }
-                if (param.getNodeMetaData(ClosureWriter.UseExistingReference.class)==null) {
-                        param.setNodeMetaData(ClosureWriter.UseExistingReference.class,Boolean.TRUE);
-                }
-                controller.getOperandStack().push(ClassHelper.REFERENCE_TYPE);
+            loadReference(name, controller);
+            if (param.getNodeMetaData(ClosureWriter.UseExistingReference.class)==null) {
+                param.setNodeMetaData(ClosureWriter.UseExistingReference.class,Boolean.TRUE);
             }
         }
 
@@ -129,6 +108,35 @@ public class ClosureWriter {
                 BytecodeHelper.getMethodDescriptor(ClassHelper.VOID_TYPE, localVariableParams));
         controller.getOperandStack().replace(ClassHelper.CLOSURE_TYPE, localVariableParams.length);
     }
+    
+    public static void loadReference(String name, WriterController controller) {
+        CompileStack compileStack = controller.getCompileStack();
+        MethodVisitor mv = controller.getMethodVisitor();
+        ClassNode classNode = controller.getClassNode();
+        AsmClassGenerator acg = controller.getAcg();
+        
+        // compileStack.containsVariable(name) means to ask if the variable is already declared
+        // compileStack.getScope().isReferencedClassVariable(name) means to ask if the variable is a field
+        // If it is no field and is not yet declared, then it is either a closure shared variable or
+        // an already declared variable.
+        if (!compileStack.containsVariable(name) && compileStack.getScope().isReferencedClassVariable(name)) {
+            acg.visitFieldExpression(new FieldExpression(classNode.getDeclaredField(name)));
+        } else {
+            BytecodeVariable v = compileStack.getVariable(name, !classNodeUsesReferences(controller.getClassNode()));
+            if (v == null) {
+                // variable is not on stack because we are
+                // inside a nested Closure and this variable
+                // was not used before
+                // then load it from the Closure field
+                FieldNode field = classNode.getDeclaredField(name);
+                mv.visitVarInsn(ALOAD, 0);
+                mv.visitFieldInsn(GETFIELD, controller.getInternalClassName(), name, BytecodeHelper.getTypeDescription(field.getType()));
+            } else {
+                mv.visitVarInsn(ALOAD, v.getIndex());
+            }
+            controller.getOperandStack().push(ClassHelper.REFERENCE_TYPE);
+        }
+    }
 
     public ClassNode getOrAddClosureClass(ClosureExpression expression, int mods) {
         ClassNode closureClass = closureClassMap.get(expression);
@@ -141,8 +149,7 @@ public class ClosureWriter {
         return closureClass;
     }
 
-    private boolean classNodeUsesReferences() {
-        ClassNode classNode = controller.getClassNode();
+    private static boolean classNodeUsesReferences(ClassNode classNode) {
         boolean ret = classNode.getSuperClass() == ClassHelper.CLOSURE_TYPE;
         if (ret) return ret;
         if (classNode instanceof InnerClassNode) {
diff --git a/src/main/org/codehaus/groovy/classgen/asm/InvocationWriter.java b/src/main/org/codehaus/groovy/classgen/asm/InvocationWriter.java
index 19bedd29e7..e107900b53 100644
--- a/src/main/org/codehaus/groovy/classgen/asm/InvocationWriter.java
+++ b/src/main/org/codehaus/groovy/classgen/asm/InvocationWriter.java
@@ -354,25 +354,35 @@ public class InvocationWriter {
         if (meta!=null) cn = (ConstructorNode) meta.target;
         if (cn==null) return false;
         
+        String ownerDescriptor = prepareConstructorCall(cn);
+        TupleExpression args = makeArgumentList(call.getArguments());
+        loadArguments(args.getExpressions(), cn.getParameters());
+        finnishConstructorCall(cn, ownerDescriptor, args.getExpressions().size());
+        
+        return true;
+    }
+    
+    private String prepareConstructorCall(ConstructorNode cn) {
         String owner = BytecodeHelper.getClassInternalName(cn.getDeclaringClass());
-        String desc = BytecodeHelper.getMethodDescriptor(ClassHelper.VOID_TYPE, cn.getParameters());
         MethodVisitor mv = controller.getMethodVisitor();
         
         mv.visitTypeInsn(NEW, owner);
         mv.visitInsn(DUP);
+        return owner;
+    }
+    
+    private void finnishConstructorCall(ConstructorNode cn, String ownerDescriptor, int argsToRemove) {
+        String desc = BytecodeHelper.getMethodDescriptor(ClassHelper.VOID_TYPE, cn.getParameters());
+        MethodVisitor mv = controller.getMethodVisitor();
+        mv.visitMethodInsn(INVOKESPECIAL, ownerDescriptor, "<init>", desc);
         
-        TupleExpression args = makeArgumentList(call.getArguments());
-        loadArguments(args.getExpressions(), cn.getParameters());
-        
-        mv.visitMethodInsn(INVOKESPECIAL, owner, "<init>", desc);
-        
-        controller.getOperandStack().remove(args.getExpressions().size());
+        controller.getOperandStack().remove(argsToRemove);
         controller.getOperandStack().push(cn.getDeclaringClass());
-        return true;
     }
 
     public void writeInvokeConstructor(ConstructorCallExpression call) {
         if (writeDirectConstructorCall(call)) return;
+        if (writeAICCall(call)) return;
         
         Expression arguments = call.getArguments();
         if (arguments instanceof TupleExpression) {
@@ -389,4 +399,38 @@ public class InvocationWriter {
                 arguments, false, false, false,
                 false);
     }
+
+    private boolean writeAICCall(ConstructorCallExpression call) {
+        if (!call.isUsingAnonymousInnerClass()) return false;
+        ConstructorNode cn = call.getType().getDeclaredConstructors().get(0);
+        OperandStack os = controller.getOperandStack();
+        
+        String ownerDescriptor = prepareConstructorCall(cn);
+        
+        List<Expression> args = makeArgumentList(call.getArguments()).getExpressions();
+        Parameter[] params = cn.getParameters(); 
+        for (int i=0; i<params.length; i++) {
+            Parameter p = params[i];
+            Expression arg = args.get(i);
+            if (arg instanceof VariableExpression) {
+                VariableExpression var = (VariableExpression) arg;
+                loadVariableWithReference(var);
+            } else {
+                arg.visit(controller.getAcg());
+            }
+            os.doGroovyCast(p.getType());
+        }
+        
+        finnishConstructorCall(cn, ownerDescriptor, args.size());
+        return true;
+    }
+    
+    private void loadVariableWithReference(VariableExpression var) {
+        String name = var.getName();
+        if (name.equals("this") || name.equals("super")) {
+            var.visit(controller.getAcg());
+        } else {
+            ClosureWriter.loadReference(var.getName(), controller);
+        }
+    }
 }
diff --git a/src/test/gls/innerClass/InnerClassTest.groovy b/src/test/gls/innerClass/InnerClassTest.groovy
index acdc282eee..ed4e1bd36b 100644
--- a/src/test/gls/innerClass/InnerClassTest.groovy
+++ b/src/test/gls/innerClass/InnerClassTest.groovy
@@ -380,6 +380,35 @@ class A {
      def u (i) { println i + s + field }
    }}"""
     }
+    
+    void testReferencedVariableInAIC() {
+        assertScript """
+            interface X{}
+            
+            final double delta = 0.1
+            (0 ..< 1).collect { n ->
+                new X () {
+                    Double foo () {
+                        delta
+                    }
+                }
+            }
+        """
+        assertScript """
+            interface X{}
+            
+            final double delta1 = 0.1
+            final double delta2 = 0.1
+            (0 ..< 1).collect { n ->
+                new X () {
+                    Double foo () {
+                        delta1 + delta2
+                    }
+                }
+            }
+        """
+    }
+     
 
 } 
 
