diff --git a/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesLambdaWriter.java b/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesLambdaWriter.java
index 6d59e04f8a..38afb25a93 100644
--- a/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesLambdaWriter.java
+++ b/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesLambdaWriter.java
@@ -22,7 +22,6 @@ import org.codehaus.groovy.GroovyBugError;
 import org.codehaus.groovy.ast.ClassNode;
 import org.codehaus.groovy.ast.CodeVisitorSupport;
 import org.codehaus.groovy.ast.ConstructorNode;
-import org.codehaus.groovy.ast.GroovyCodeVisitor;
 import org.codehaus.groovy.ast.InnerClassNode;
 import org.codehaus.groovy.ast.MethodNode;
 import org.codehaus.groovy.ast.Parameter;
@@ -33,8 +32,6 @@ import org.codehaus.groovy.ast.expr.LambdaExpression;
 import org.codehaus.groovy.ast.expr.VariableExpression;
 import org.codehaus.groovy.ast.stmt.BlockStatement;
 import org.codehaus.groovy.ast.stmt.Statement;
-import org.codehaus.groovy.ast.tools.ClosureUtils;
-import org.codehaus.groovy.ast.tools.GeneralUtils;
 import org.codehaus.groovy.classgen.BytecodeInstruction;
 import org.codehaus.groovy.classgen.BytecodeSequence;
 import org.codehaus.groovy.classgen.asm.BytecodeHelper;
@@ -47,7 +44,6 @@ import org.codehaus.groovy.transform.sc.StaticCompilationMetadataKeys;
 import org.codehaus.groovy.transform.stc.StaticTypesMarker;
 import org.objectweb.asm.MethodVisitor;
 
-import java.util.Arrays;
 import java.util.HashMap;
 import java.util.LinkedList;
 import java.util.List;
@@ -62,8 +58,10 @@ import static org.codehaus.groovy.ast.ClassHelper.SERIALIZEDLAMBDA_TYPE;
 import static org.codehaus.groovy.ast.ClassHelper.VOID_TYPE;
 import static org.codehaus.groovy.ast.ClassHelper.findSAM;
 import static org.codehaus.groovy.ast.ClassHelper.long_TYPE;
+import static org.codehaus.groovy.ast.tools.ClosureUtils.getParametersSafe;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.block;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.classX;
+import static org.codehaus.groovy.ast.tools.GeneralUtils.cloneParams;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.constX;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.declS;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.localVarX;
@@ -149,18 +147,19 @@ public class StaticTypesLambdaWriter extends LambdaWriter implements AbstractFun
         return new Parameter[]{new Parameter(SERIALIZEDLAMBDA_TYPE, "serializedLambda")};
     }
 
-    private static boolean isAccessingInstanceMembersOfEnclosingClass(final MethodNode syntheticLambdaMethodNode) {
+    private static boolean isAccessingInstanceMembersOfEnclosingClass(final MethodNode lambdaMethod) {
         boolean[] result = new boolean[1];
 
-        GroovyCodeVisitor visitor = new CodeVisitorSupport() {
+        ClassNode enclosingClass = lambdaMethod.getDeclaringClass().getOuterClass();
+
+        lambdaMethod.getCode().visit(new CodeVisitorSupport() {
             @Override
             public void visitVariableExpression(final VariableExpression expression) {
-                if (expression.isThisExpression()) {
+                if (expression.isThisExpression() || enclosingClass.equals(expression.getNodeMetaData(StaticCompilationMetadataKeys.PROPERTY_OWNER))) {
                     result[0] = true;
                 }
             }
-        };
-        syntheticLambdaMethodNode.getCode().visit(visitor);
+        });
 
         return result[0];
     }
@@ -281,7 +280,7 @@ public class StaticTypesLambdaWriter extends LambdaWriter implements AbstractFun
                 "doCall",
                 ACC_PUBLIC,
                 abstractMethod.getReturnType(),
-                Arrays.copyOf(parametersWithExactType, parametersWithExactType.length),
+                parametersWithExactType.clone(),
                 ClassNode.EMPTY_ARRAY,
                 expression.getCode()
         );
@@ -292,10 +291,10 @@ public class StaticTypesLambdaWriter extends LambdaWriter implements AbstractFun
         return doCallMethod;
     }
 
-    private Parameter[] createParametersWithExactType(final LambdaExpression expression, MethodNode abstractMethod) {
-        Parameter[] targetParameters = GeneralUtils.cloneParams(abstractMethod.getParameters());
-        Parameter[] parameters = ClosureUtils.getParametersSafe(expression);
-        for (int i = 0; i < parameters.length; i++) {
+    private Parameter[] createParametersWithExactType(final LambdaExpression expression, final MethodNode abstractMethod) {
+        Parameter[] targetParameters = cloneParams(abstractMethod.getParameters());
+        Parameter[] parameters = getParametersSafe(expression);
+        for (int i = 0, n = parameters.length; i < n; i += 1) {
             Parameter targetParameter = targetParameters[i];
             Parameter parameter = parameters[i];
             ClassNode inferredType = parameter.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);
diff --git a/src/test/groovy/transform/stc/LambdaTest.groovy b/src/test/groovy/transform/stc/LambdaTest.groovy
index 7d0dedc8ac..20451116df 100644
--- a/src/test/groovy/transform/stc/LambdaTest.groovy
+++ b/src/test/groovy/transform/stc/LambdaTest.groovy
@@ -1602,7 +1602,7 @@ final class LambdaTest {
 
                 byte[] test() {
                     def out = new ByteArrayOutputStream()
-                    SerializableFunction<Integer, String> f = (Integer i) -> getS() + i
+                    SerializableFunction<Integer, String> f = (Integer i) -> s + i
                     out.withObjectOutputStream {
                         it.writeObject(f)
                     }
@@ -1633,7 +1633,7 @@ final class LambdaTest {
 
                 byte[] test() {
                     def out = new ByteArrayOutputStream()
-                    SerializableFunction<Integer, String> f = (Integer i) -> getS() + i
+                    SerializableFunction<Integer, String> f = (Integer i) -> s + i
                     out.withObjectOutputStream {
                         it.writeObject(f)
                     }
@@ -1877,17 +1877,6 @@ final class LambdaTest {
         '''
     }
 
-    @Test // GROOVY-9146
-    void testScriptWithExistingMainCS() {
-        assertScript '''
-            @groovy.transform.CompileStatic
-            static void main(args) {
-                java.util.function.Function<String, String> lower = String::toLowerCase
-                assert lower.toString().contains('$$Lambda$')
-            }
-        '''
-    }
-
     @Test
     void testDeserializeNestedLambda4() {
         assertScript '''
@@ -1895,51 +1884,60 @@ final class LambdaTest {
             }
 
             @groovy.transform.CompileStatic
-            class Test1 {
-                static p() {
-                        def out1 = new ByteArrayOutputStream()
-                        SerializableFunction<Integer, String> f1 = (Integer e) -> 'a' + e
-                        out1.withObjectOutputStream {
-                            it.writeObject(f1)
-                        }
-                        def result1 = out1.toByteArray()
+            class C {
+                static test() {
+                    def out1 = new ByteArrayOutputStream()
+                    SerializableFunction<Integer, String> f1 = (Integer i) -> 'a' + i
+                    out1.withObjectOutputStream {
+                        it.writeObject(f1)
+                    }
 
-                        def out2 = new ByteArrayOutputStream()
-                        SerializableFunction<Integer, String> f2 = (Integer e) -> 'b' + e
-                        out2.withObjectOutputStream {
-                            it.writeObject(f2)
-                        }
-                        def result2 = out2.toByteArray()
+                    def out2 = new ByteArrayOutputStream()
+                    SerializableFunction<Integer, String> f2 = (Integer i) -> 'b' + i
+                    out2.withObjectOutputStream {
+                        it.writeObject(f2)
+                    }
 
-                        // nested lambda expression
-                        def out3 = new ByteArrayOutputStream()
-                        SerializableFunction<Integer, String> f3 = (Integer e) -> {
-                            SerializableFunction<Integer, String> nf = ((Integer ne) -> 'n' + ne)
-                            'c' + nf(e)
-                        }
-                        out3.withObjectOutputStream {
-                            it.writeObject(f3)
-                        }
-                        def result3 = out3.toByteArray()
+                    // nested lambda expression
+                    def out3 = new ByteArrayOutputStream()
+                    SerializableFunction<Integer, String> f3 = (Integer i) -> {
+                        SerializableFunction<Integer, String> nf = (Integer j) -> 'c' + j
+                        nf(i) + 'c'
+                    }
+                    out3.withObjectOutputStream {
+                        it.writeObject(f3)
+                    }
 
-                        return [result1, result2, result3]
+                    [out1.toByteArray(), out2.toByteArray(), out3.toByteArray()]
                 }
             }
 
-            def (byte[] serializedLambdaBytes1, byte[] serializedLambdaBytes2, byte[] serializedLambdaBytes3) = Test1.p()
-            new ByteArrayInputStream(serializedLambdaBytes1).withObjectInputStream(Test1.class.classLoader) {
+            def (serializedLambdaBytes1, serializedLambdaBytes2, serializedLambdaBytes3) = C.test()
+
+            new ByteArrayInputStream(serializedLambdaBytes1).withObjectInputStream(this.class.classLoader) {
                 SerializableFunction<Integer, String> f = (SerializableFunction<Integer, String>) it.readObject()
-                assert 'a1' == f.apply(1)
+                assert f.apply(1) == 'a1'
             }
 
-            new ByteArrayInputStream(serializedLambdaBytes2).withObjectInputStream(Test1.class.classLoader) {
+            new ByteArrayInputStream(serializedLambdaBytes2).withObjectInputStream(this.class.classLoader) {
                 SerializableFunction<Integer, String> f = (SerializableFunction<Integer, String>) it.readObject()
-                assert 'b1' == f.apply(1)
+                assert f.apply(1) == 'b1'
             }
 
-            new ByteArrayInputStream(serializedLambdaBytes3).withObjectInputStream(Test1.class.classLoader) {
+            new ByteArrayInputStream(serializedLambdaBytes3).withObjectInputStream(this.class.classLoader) {
                 SerializableFunction<Integer, String> f = (SerializableFunction<Integer, String>) it.readObject()
-                assert 'cn1' == f.apply(1)
+                assert f.apply(1) == 'c1c'
+            }
+        '''
+    }
+
+    @Test // GROOVY-9146
+    void testScriptWithExistingMainCS() {
+        assertScript '''
+            @groovy.transform.CompileStatic
+            static void main(args) {
+                java.util.function.Function<String, String> lower = String::toLowerCase
+                assert lower.toString().contains('$$Lambda$')
             }
         '''
     }
