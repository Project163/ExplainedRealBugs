diff --git a/src/main/groovy/lang/Closure.java b/src/main/groovy/lang/Closure.java
index 2bdfee3b2a..f851253299 100644
--- a/src/main/groovy/lang/Closure.java
+++ b/src/main/groovy/lang/Closure.java
@@ -24,9 +24,6 @@ import org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation;
 import java.io.IOException;
 import java.io.StringWriter;
 import java.io.Writer;
-import java.lang.reflect.Method;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
 
 /**
  * Represents any closure object in Groovy.
@@ -155,7 +152,7 @@ public abstract class Closure extends GroovyObjectSupport implements Cloneable,
         return resolveStrategy;
     }
 
-    protected Object getThisObject(){
+    public Object getThisObject(){
         return thisObject;
     }
 
diff --git a/src/main/org/codehaus/groovy/runtime/metaclass/ClosureMetaClass.java b/src/main/org/codehaus/groovy/runtime/metaclass/ClosureMetaClass.java
index 1683593ded..2ec5ea5204 100644
--- a/src/main/org/codehaus/groovy/runtime/metaclass/ClosureMetaClass.java
+++ b/src/main/org/codehaus/groovy/runtime/metaclass/ClosureMetaClass.java
@@ -17,6 +17,7 @@
 package org.codehaus.groovy.runtime.metaclass;
 
 import groovy.lang.*;
+
 import org.codehaus.groovy.reflection.CachedClass;
 import org.codehaus.groovy.reflection.CachedField;
 import org.codehaus.groovy.reflection.CachedMethod;
@@ -247,6 +248,7 @@ public final class ClosureMetaClass extends MetaClassImpl {
         if (method == null) {
             final Object owner = closure.getOwner();
             final Object delegate = closure.getDelegate();
+            final Object thisObject = closure.getThisObject();
             final int resolveStrategy = closure.getResolveStrategy();
             boolean invokeOnDelegate = false;
             boolean invokeOnOwner = false;
@@ -284,11 +286,26 @@ public final class ClosureMetaClass extends MetaClassImpl {
                     }
                     break;
                 default: // owner first
-                    method = getDelegateMethod(closure, owner, methodName, argClasses);
-                    callObject = owner;
+                    // owner first means we start with the outer most owner that is not a generated closure
+                    // this owner is equal to the this object, so we check that one first.                    
+                    method = getDelegateMethod(closure, thisObject, methodName, argClasses);
+                    callObject = thisObject;
                     if (method == null) {
-                        method = getDelegateMethod(closure, delegate, methodName, argClasses);
-                        callObject = delegate;
+                        //try finding a delegate that has that method... we start from 
+                        // outside building a stack and try each delegate
+                        LinkedList list = new LinkedList();
+                        for (Object current = closure; current!=thisObject; ) {
+                            Closure currentClosure = (Closure) current; 
+                            if (currentClosure.getDelegate()!=null) list.add(current);
+                            current=currentClosure.getOwner();
+                        }
+
+                        while (!list.isEmpty() && method==null) {
+                            Closure closureWithDelegate = (Closure) list.removeLast();
+                            Object currentDelegate = closureWithDelegate.getDelegate();
+                            method = getDelegateMethod(closureWithDelegate,currentDelegate,methodName,argClasses);
+                            callObject = currentDelegate;
+                        }
                     }
                     if (method == null) {
                         invokeOnDelegate = delegate != closure && (delegate instanceof GroovyObject);
diff --git a/src/test/groovy/lang/ClosureResolvingTest.groovy b/src/test/groovy/lang/ClosureResolvingTest.groovy
index 7310b1dc79..e68acb9c18 100644
--- a/src/test/groovy/lang/ClosureResolvingTest.groovy
+++ b/src/test/groovy/lang/ClosureResolvingTest.groovy
@@ -140,7 +140,43 @@ class ClosureResolvingTest extends GroovyTestCase {
         assertEquals "stuff", c.call()
 
     }
+    
+    void testOwnerDelegateChain() {
+        def outerdel= new TestResolve3(del: "outer delegate" )
+        def innerdel= new TestResolve3(del: "inner delegate")
+        
+        def cout= {
+            assert delegate == outerdel
+            assert delegate.whoisThis() == outerdel
+            assert delegate.del == "outer delegate"
+            assert delegate.met() == "I'm the method inside 'outer delegate'"
+
+            assert whoisThis() == outerdel
+            assert del == "outer delegate"
+            assert met() == "I'm the method inside 'outer delegate'"
+
+            def cin= {
+                assert delegate == innerdel
+                assert delegate.whoisThis() == innerdel
+                assert delegate.del == "inner delegate"
+                assert delegate.met() == "I'm the method inside 'inner delegate'"
+
+                assert whoisThis() == outerdel
+                assert del == "outer delegate"
+                assert met() == "I'm the method inside 'outer delegate'"
+            
+            }
+
+            cin.delegate= innerdel
+            cin()
+        }
+
+        cout.delegate= outerdel
+        cout() 
+    }
+    
 }
+
 class TestResolve1 {
     def foo = "hello"
 
@@ -151,4 +187,12 @@ class TestResolve2 {
     def bar = "world"
 
     def doStuff() { "bar" }
-}
\ No newline at end of file
+}
+
+ class TestResolve3 {
+    def del;
+    String toString(){del}
+    def whoisThis() { return this }
+    def met() { return "I'm the method inside '"+del+"'" }
+ }
+
