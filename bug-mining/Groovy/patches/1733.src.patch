diff --git a/src/main/groovy/lang/MetaClassImpl.java b/src/main/groovy/lang/MetaClassImpl.java
index 2cff239b80..8a612ae7a6 100644
--- a/src/main/groovy/lang/MetaClassImpl.java
+++ b/src/main/groovy/lang/MetaClassImpl.java
@@ -76,21 +76,9 @@ import java.lang.reflect.Modifier;
 import java.lang.reflect.Proxy;
 import java.net.URL;
 import java.security.AccessController;
-import java.security.PrivilegedAction;
 import java.security.PrivilegedActionException;
 import java.security.PrivilegedExceptionAction;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
+import java.util.*;
 
 /**
  * Allows methods to be dynamically added to existing classes at runtime
@@ -119,6 +107,11 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
     private static final Class[] METHOD_MISSING_ARGS = new Class[]{String.class, Object.class};
     private static final Class[] GETTER_MISSING_ARGS = new Class[]{String.class};
     private static final Class[] SETTER_MISSING_ARGS = METHOD_MISSING_ARGS;
+    private static final Comparator<CachedClass> CACHED_CLASS_NAME_COMPARATOR = new Comparator<CachedClass>() {
+        public int compare(final CachedClass o1, final CachedClass o2) {
+            return o1.getName().compareTo(o2.getName());
+        }
+    };
 
     protected final Class theClass;
     protected final CachedClass theCachedClass;
@@ -1933,18 +1926,25 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
      * This will build up the property map (Map of MetaProperty objects, keyed on
      * property name).
      */
+    @SuppressWarnings("unchecked")
     private void setupProperties(PropertyDescriptor[] propertyDescriptors) {
         if (theCachedClass.isInterface) {
             LinkedList<CachedClass> superClasses = new LinkedList<CachedClass>();
             superClasses.add(ReflectionCache.OBJECT_CLASS);
             Set interfaces = theCachedClass.getInterfaces();
 
+            LinkedList<CachedClass> superInterfaces = new LinkedList<CachedClass>(interfaces);
+            // sort interfaces so that we may ensure a deterministic behaviour in case of
+            // ambiguous fields (class implementing two interfaces using the same field)
+            Collections.sort(superInterfaces, CACHED_CLASS_NAME_COMPARATOR);
+            superInterfaces.remove(theCachedClass);
+
             classPropertyIndexForSuper = classPropertyIndex;
             final SingleKeyHashMap cPI = classPropertyIndex.getNotNull(theCachedClass);
             for (Iterator interfaceIter = interfaces.iterator(); interfaceIter.hasNext();) {
                 CachedClass iclass = (CachedClass) interfaceIter.next();
                 SingleKeyHashMap iPropertyIndex = cPI;
-                addFields(iclass, iPropertyIndex);
+                inheritStaticInterfaceFields(superInterfaces, interfaces);
                 classPropertyIndex.put(iclass, iPropertyIndex);
             }
             classPropertyIndex.put(ReflectionCache.OBJECT_CLASS, cPI);
@@ -1955,7 +1955,10 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
             makeStaticPropertyIndex();
         } else {
             LinkedList<CachedClass> superClasses = getSuperClasses();
-            Set interfaces = theCachedClass.getInterfaces();
+            LinkedList<CachedClass> interfaces = new LinkedList<CachedClass>(theCachedClass.getInterfaces());
+            // sort interfaces so that we may ensure a deterministic behaviour in case of
+            // ambiguous fields (class implementing two interfaces using the same field)
+            Collections.sort(interfaces, CACHED_CLASS_NAME_COMPARATOR);
 
             // if this an Array, then add the special read-only "length" property
             if (theCachedClass.isArray) {
@@ -1964,7 +1967,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
                 classPropertyIndex.put(theCachedClass, map);
             }
 
-            inheritStaticInterfaceFields(superClasses, interfaces);
+            inheritStaticInterfaceFields(superClasses, new LinkedHashSet(interfaces));
             inheritFields(superClasses);
 
             applyPropertyDescriptors(propertyDescriptors);
diff --git a/src/test/groovy/bugs/Groovy5272Bug.groovy b/src/test/groovy/bugs/Groovy5272Bug.groovy
new file mode 100644
index 0000000000..da3c339e9d
--- /dev/null
+++ b/src/test/groovy/bugs/Groovy5272Bug.groovy
@@ -0,0 +1,44 @@
+package groovy.bugs
+
+class Groovy5272Bug extends GroovyTestCase {
+    /**
+     * In Groovy-5272, there are chances that the following test fails.
+     */
+    void testShouldNeverFail() {
+        10.times {
+            assertScript '''
+            public interface InterfaceA {
+                String FOO="Foo A";
+            }
+            public interface InterfaceB extends InterfaceA {
+                String FOO="Foo B";
+            }
+
+            // Fails randomly
+            assert InterfaceA.FOO!=InterfaceB.FOO
+            '''
+        }
+    }
+
+    void testResolvingAmbiguousStaticFieldShouldAlwaysReturnTheSameValue() {
+        10.times {
+        assertScript '''
+            public interface InterfaceA {
+                String FOO="Foo A";
+            }
+            public interface InterfaceB extends InterfaceA {
+                String FOO="Foo B";
+            }
+            public interface InterfaceC extends InterfaceA {
+                String FOO="Foo C";
+            }
+
+            class A implements InterfaceB, InterfaceC {
+            }
+
+            assert A.FOO == "Foo C"
+            '''
+        }
+
+    }
+}
