diff --git a/src/main/java/org/codehaus/groovy/classgen/asm/sc/AbstractFunctionalInterfaceWriter.java b/src/main/java/org/codehaus/groovy/classgen/asm/sc/AbstractFunctionalInterfaceWriter.java
index 8a01b6fec9..4274ba105a 100644
--- a/src/main/java/org/codehaus/groovy/classgen/asm/sc/AbstractFunctionalInterfaceWriter.java
+++ b/src/main/java/org/codehaus/groovy/classgen/asm/sc/AbstractFunctionalInterfaceWriter.java
@@ -107,7 +107,7 @@ public interface AbstractFunctionalInterfaceWriter {
         return argumentList.toArray();
     }
 
-    default ClassNode convertParameterType(ClassNode parameterType, ClassNode inferredType) {
+    default ClassNode convertParameterType(ClassNode targetType, ClassNode parameterType, ClassNode inferredType) {
         if (!getWrapper(inferredType).isDerivedFrom(getWrapper(parameterType))) {
             throw new RuntimeParserException("The inferred type[" + inferredType.redirect() + "] is not compatible with the parameter type[" + parameterType.redirect() + "]", parameterType);
         }
@@ -116,9 +116,12 @@ public interface AbstractFunctionalInterfaceWriter {
         boolean isParameterTypePrimitive = ClassHelper.isPrimitiveType(parameterType);
         boolean isInferredTypePrimitive = ClassHelper.isPrimitiveType(inferredType);
         if (!isParameterTypePrimitive && isInferredTypePrimitive) {
-            if (parameterType != getUnwrapper(parameterType) && inferredType != getWrapper(inferredType)) {
+            if (ClassHelper.DYNAMIC_TYPE.equals(parameterType) && ClassHelper.isPrimitiveType(targetType) // (1)
+                    || parameterType != getUnwrapper(parameterType) && inferredType != getWrapper(inferredType) // (2)
+            ) {
                 // GROOVY-9790: bootstrap method initialization exception raised when lambda parameter type is wrong
-                // java.lang.BootstrapMethodError: bootstrap method initialization exception
+                // (1) java.lang.invoke.LambdaConversionException: Type mismatch for instantiated parameter 0: class java.lang.Integer is not a subtype of int
+                // (2) java.lang.BootstrapMethodError: bootstrap method initialization exception
                 type = inferredType;
             } else {
                 // The non-primitive type and primitive type are not allowed to mix since Java 9+
diff --git a/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesLambdaWriter.java b/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesLambdaWriter.java
index a92770f24b..6d59e04f8a 100644
--- a/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesLambdaWriter.java
+++ b/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesLambdaWriter.java
@@ -34,6 +34,7 @@ import org.codehaus.groovy.ast.expr.VariableExpression;
 import org.codehaus.groovy.ast.stmt.BlockStatement;
 import org.codehaus.groovy.ast.stmt.Statement;
 import org.codehaus.groovy.ast.tools.ClosureUtils;
+import org.codehaus.groovy.ast.tools.GeneralUtils;
 import org.codehaus.groovy.classgen.BytecodeInstruction;
 import org.codehaus.groovy.classgen.BytecodeSequence;
 import org.codehaus.groovy.classgen.asm.BytecodeHelper;
@@ -272,7 +273,7 @@ public class StaticTypesLambdaWriter extends LambdaWriter implements AbstractFun
     }
 
     private MethodNode addSyntheticLambdaMethodNode(final LambdaExpression expression, final ClassNode lambdaClass, final MethodNode abstractMethod) {
-        Parameter[] parametersWithExactType = createParametersWithExactType(expression);
+        Parameter[] parametersWithExactType = createParametersWithExactType(expression, abstractMethod);
         Parameter[] localVariableParameters = getLambdaSharedVariables(expression);
         removeInitialValues(localVariableParameters);
 
@@ -291,12 +292,15 @@ public class StaticTypesLambdaWriter extends LambdaWriter implements AbstractFun
         return doCallMethod;
     }
 
-    private Parameter[] createParametersWithExactType(final LambdaExpression expression) {
+    private Parameter[] createParametersWithExactType(final LambdaExpression expression, MethodNode abstractMethod) {
+        Parameter[] targetParameters = GeneralUtils.cloneParams(abstractMethod.getParameters());
         Parameter[] parameters = ClosureUtils.getParametersSafe(expression);
-        for (Parameter parameter : parameters) {
+        for (int i = 0; i < parameters.length; i++) {
+            Parameter targetParameter = targetParameters[i];
+            Parameter parameter = parameters[i];
             ClassNode inferredType = parameter.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);
             if (inferredType != null) {
-                ClassNode type = convertParameterType(parameter.getType(), inferredType);
+                ClassNode type = convertParameterType(targetParameter.getType(), parameter.getType(), inferredType);
                 parameter.setOriginType(type);
                 parameter.setType(type);
             }
diff --git a/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesMethodReferenceExpressionWriter.java b/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesMethodReferenceExpressionWriter.java
index 626eb25147..24b6088a8d 100644
--- a/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesMethodReferenceExpressionWriter.java
+++ b/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesMethodReferenceExpressionWriter.java
@@ -241,9 +241,11 @@ public class StaticTypesMethodReferenceExpressionWriter extends MethodReferenceE
             for (int i = 0, n = parameters.length; i < n; i += 1) {
                 ClassNode inferredParamType = inferredParamTypes[i];
                 if (inferredParamType == null) continue;
+
                 Parameter parameter = parameters[i];
+                Parameter targetParameter = parameter;
 
-                ClassNode type = convertParameterType(parameter.getType(), inferredParamType);
+                ClassNode type = convertParameterType(targetParameter.getType(), parameter.getType(), inferredParamType);
                 parameter.setOriginType(type);
                 parameter.setType(type);
             }
diff --git a/src/test/groovy/bugs/Groovy9790.groovy b/src/test/groovy/bugs/Groovy9790.groovy
index 85b17a447d..ca04ddd716 100644
--- a/src/test/groovy/bugs/Groovy9790.groovy
+++ b/src/test/groovy/bugs/Groovy9790.groovy
@@ -55,6 +55,20 @@ final class Groovy9790 {
         '''
     }
 
+    @Test
+    void testLambdaWithNoExplicitType() {
+        assertScript '''
+            @groovy.transform.CompileStatic
+            void test() {
+                java.util.stream.IntStream.range(0, 2).forEach(
+                    i -> { assert i >= 0 && i < 2 }
+                )
+            }
+
+            test()
+        '''
+    }
+
     @Test
     void testLambdaWithIncompatibleType() {
         def err = shouldFail '''
diff --git a/subprojects/groovy-ginq/src/main/groovy/org/apache/groovy/ginq/provider/collection/runtime/AsciiTableMaker.groovy b/subprojects/groovy-ginq/src/main/groovy/org/apache/groovy/ginq/provider/collection/runtime/AsciiTableMaker.groovy
index f291fad0c0..e61ec16924 100644
--- a/subprojects/groovy-ginq/src/main/groovy/org/apache/groovy/ginq/provider/collection/runtime/AsciiTableMaker.groovy
+++ b/subprojects/groovy-ginq/src/main/groovy/org/apache/groovy/ginq/provider/collection/runtime/AsciiTableMaker.groovy
@@ -18,11 +18,11 @@
  */
 package org.apache.groovy.ginq.provider.collection.runtime
 
-import static java.util.stream.IntStream.range
-
 import groovy.transform.CompileStatic
 import groovy.transform.PackageScope
 
+import static java.util.stream.IntStream.range
+
 /**
  * @since 4.0.0
  */
@@ -144,7 +144,7 @@ class AsciiTableMaker {
         result.append(line)
 
         range(1, finalTable.length)
-                .forEach((int i) -> result.append(String.format(formatString.toString(), (Object[]) finalTable[i])))
+                .forEach(i -> result.append(String.format(formatString.toString(), (Object[]) finalTable[i])))
         result.append(line)
 
         return result.toString()
