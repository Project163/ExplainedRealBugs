diff --git a/src/main/org/codehaus/groovy/control/ResolveVisitor.java b/src/main/org/codehaus/groovy/control/ResolveVisitor.java
index 32d5f7933b..02936952f8 100644
--- a/src/main/org/codehaus/groovy/control/ResolveVisitor.java
+++ b/src/main/org/codehaus/groovy/control/ResolveVisitor.java
@@ -45,6 +45,7 @@ import java.util.*;
  * Note: the method to start the resolving is  startResolving(ClassNode, SourceUnit).
  *
  * @author Jochen Theodorou
+ * @author Roshan Dawrani
  */
 public class ResolveVisitor extends ClassCodeExpressionTransformer {
     private ClassNode currentClass;
@@ -1141,32 +1142,44 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
         }
 
         ClassNode sn = node.getUnresolvedSuperClass();
-        if (sn != null) {
-            resolveOrFail(sn, node, true);
-            checkCyclicInheritence(node);
-        }
+        if (sn != null) resolveOrFail(sn, node, true);
 
         for (ClassNode anInterface : node.getInterfaces()) {
             resolveOrFail(anInterface, node, true);
         }
 
+        checkCyclicInheritence(node, node.getUnresolvedSuperClass(), node.getInterfaces());
+        
         super.visitClass(node);
 
         currentClass = oldNode;
     }
     
-    private void checkCyclicInheritence(ClassNode node) {
-        ClassNode sn = node;
-        while(true) {
-            sn = sn.getUnresolvedSuperClass();
-            if(sn == null) break;
-
-            if(node == sn.redirect()) {
-                addError("Cyclic inheritance involving " + sn.getName() + " in class " + node.getName(), node);
-                break;
+    private void checkCyclicInheritence(ClassNode originalNode, ClassNode parentToCompare, ClassNode[] interfacesToCompare) {
+        if(!originalNode.isInterface()) {
+            if(parentToCompare == null) return;
+            if(originalNode == parentToCompare.redirect()) {
+                addError("Cyclic inheritance involving " + parentToCompare.getName() + " in class " + originalNode.getName(), originalNode);
+                return;
+            }
+            if(parentToCompare == ClassHelper.OBJECT_TYPE) return;
+            checkCyclicInheritence(originalNode, parentToCompare.getUnresolvedSuperClass(), null);
+        } else {
+            if(interfacesToCompare != null && interfacesToCompare.length > 0) {
+                // check interfaces at this level first
+                for(ClassNode intfToCompare : interfacesToCompare) {
+                    if(originalNode == intfToCompare.redirect()) {
+                        addError("Cyclic inheritance involving " + intfToCompare.getName() + " in interface " + originalNode.getName(), originalNode);
+                        return;
+                    }
+                }
+                // check next level of interfaces
+                for(ClassNode intf : interfacesToCompare) {
+                    checkCyclicInheritence(originalNode, null, intf.getInterfaces());
+                }
+            } else {
+                return;
             }
-            
-            if(sn == ClassHelper.OBJECT_TYPE) break;
         }
     }
 
diff --git a/src/test/groovy/bugs/Groovy1465Bug.groovy b/src/test/groovy/bugs/Groovy1465Bug.groovy
new file mode 100644
index 0000000000..ec5cff18d8
--- /dev/null
+++ b/src/test/groovy/bugs/Groovy1465Bug.groovy
@@ -0,0 +1,39 @@
+package groovy.bugs
+
+import org.codehaus.groovy.control.MultipleCompilationErrorsException
+
+class Groovy1465Bug extends GroovyTestCase {
+    
+    void compileAndVerifyCyclicInheritenceCompilationError(script) {
+        try {
+            new GroovyShell().parse(script)
+            fail('The compilation should have failed as it is a cyclic reference')
+        } catch (MultipleCompilationErrorsException e) {
+            def syntaxError = e.errorCollector.getSyntaxError(0)
+            assert syntaxError.message.contains('Cyclic inheritance')
+        }
+    }
+    
+    void testInterfaceCyclicInheritenceTC1() {
+        compileAndVerifyCyclicInheritenceCompilationError """
+            interface G1465Tt extends G1465Tt { }
+            def tt = {} as G1465Tt
+        """ 
+    }
+
+    void testInterfaceCyclicInheritenceTC2() {
+        compileAndVerifyCyclicInheritenceCompilationError """
+            interface G1465Rr extends G1465Ss { }
+            interface G1465Ss extends G1465Rr { }
+            def ss = {} as G1465Ss
+        """ 
+    }
+
+    void testInterfaceCyclicInheritenceTC3() {
+        compileAndVerifyCyclicInheritenceCompilationError """
+            interface G1465A extends G1465B { }
+            interface G1465B extends G1465C { }
+            interface G1465C extends G1465B { }
+        """ 
+    }
+}
\ No newline at end of file
