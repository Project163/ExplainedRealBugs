diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 30a32bef94..0f6ccaa30d 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -753,8 +753,11 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 }
                 lType = getType(leftExpression);
             } else {
-                lType = getType(leftExpression);
-                if (op == ASSIGN) {
+                if (op != ASSIGN && op != ELVIS_EQUAL) {
+                    lType = getType(leftExpression);
+                } else {
+                    lType = getOriginalDeclarationType(leftExpression);
+
                     if (isFunctionalInterface(lType)) {
                         processFunctionalInterfaceAssignment(lType, rightExpression);
                     } else if (isClosureWithType(lType) && rightExpression instanceof ClosureExpression) {
@@ -783,20 +786,43 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                     fullExpression.visit(this);
 
                     resultType = getType(fullExpression);
-                    storeType(leftExpression, resultType);
-                } else if (isArrayOp(op)
-                        && leftExpression instanceof VariableExpression
-                        && leftExpression.getNodeMetaData(INFERRED_TYPE) == null) {
-                    storeType(leftExpression, lType);
                 }
             }
-
             if (resultType == null) {
                 resultType = lType;
-            } else if (isAssignment(op)) {
-                if (rightExpression instanceof ConstructorCallExpression) {
-                    inferDiamondType((ConstructorCallExpression) rightExpression, lType);
+            }
+
+            if (isArrayOp(op)) {
+                if (leftExpression instanceof VariableExpression) {//GROOVY-6782
+                    if (leftExpression.getNodeMetaData(INFERRED_TYPE) == null) {
+                        leftExpression.removeNodeMetaData(INFERRED_RETURN_TYPE);
+                        storeType(leftExpression, lType);
+                    }
                 }
+                if (!lType.isArray()
+                        && enclosingBinaryExpression != null
+                        && enclosingBinaryExpression.getLeftExpression() == expression
+                        && isAssignment(enclosingBinaryExpression.getOperation().getType())) {
+                    // left hand side of a subscript assignment: map['foo'] = ...
+                    Expression enclosingExpressionRHS = enclosingBinaryExpression.getRightExpression();
+                    if (!(enclosingExpressionRHS instanceof ClosureExpression)) {
+                        enclosingExpressionRHS.visit(this);
+                    }
+                    ClassNode[] arguments = {rType, getType(enclosingExpressionRHS)};
+                    List<MethodNode> nodes = findMethod(lType.redirect(), "putAt", arguments);
+                    if (nodes.size() == 1) {
+                        typeCheckMethodsWithGenericsOrFail(lType, arguments, nodes.get(0), enclosingExpressionRHS);
+                    } else if (nodes.isEmpty()) {
+                        addNoMatchingMethodError(lType, "putAt", arguments, enclosingBinaryExpression);
+                    }
+                }
+            }
+
+            boolean isEmptyDeclaration = (expression instanceof DeclarationExpression && rightExpression instanceof EmptyExpression);
+            if (!isEmptyDeclaration && isAssignment(op)) {
+                if (rightExpression instanceof ConstructorCallExpression)
+                    inferDiamondType((ConstructorCallExpression) rightExpression, lType);
+
                 if (lType.isUsingGenerics() && missesGenericsTypes(resultType)) {
                     // unchecked assignment
                     // List<Type> list = new LinkedList()
@@ -807,47 +833,15 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                     // "completed" with generics type information available from the LHS
                     if (!resultType.isGenericsPlaceHolder()) // plain reference drops placeholder
                         resultType = GenericsUtils.parameterizeType(lType, resultType.getPlainNodeReference());
-                } else if (lType.equals(OBJECT_TYPE) && GenericsUtils.hasUnresolvedGenerics(resultType)) { // def list = []
-                    Map<GenericsTypeName, GenericsType> placeholders = extractGenericsParameterMapOfThis(typeCheckingContext);
-                    resultType = fullyResolveType(resultType, Optional.ofNullable(placeholders).orElseGet(Collections::emptyMap));
-                }
-            }
-
-            // GROOVY-5874: if left expression is a closure shared variable, a second pass should be done
-            if (leftExpression instanceof VariableExpression && ((VariableExpression) leftExpression).isClosureSharedVariable()) {
-                typeCheckingContext.secondPassExpressions.add(new SecondPassExpression<>(expression));
-            }
-
-            if (isArrayOp(op)
-                    && !lType.isArray()
-                    && enclosingBinaryExpression != null
-                    && enclosingBinaryExpression.getLeftExpression() == expression
-                    && isAssignment(enclosingBinaryExpression.getOperation().getType())) {
-                // left hand side of an assignment: map['foo'] = ...
-                Expression enclosingExpressionRHS = enclosingBinaryExpression.getRightExpression();
-                if (!(enclosingExpressionRHS instanceof ClosureExpression)) {
-                    enclosingExpressionRHS.visit(this);
-                }
-                ClassNode[] arguments = {rType, getType(enclosingExpressionRHS)};
-                List<MethodNode> nodes = findMethod(lType.redirect(), "putAt", arguments);
-                if (nodes.size() == 1) {
-                    typeCheckMethodsWithGenericsOrFail(lType, arguments, nodes.get(0), enclosingExpressionRHS);
-                } else if (nodes.isEmpty()) {
-                    addNoMatchingMethodError(lType, "putAt", arguments, enclosingBinaryExpression);
                 }
-            }
 
-            boolean isEmptyDeclaration = (expression instanceof DeclarationExpression && rightExpression instanceof EmptyExpression);
-            if (!isEmptyDeclaration && isAssignment(op)) {
                 ClassNode originType = getOriginalDeclarationType(leftExpression);
                 typeCheckAssignment(expression, leftExpression, originType, rightExpression, resultType);
-                // if assignment succeeds but result type is not a subtype of original type, then we are in a special cast handling
-                // and we must update the result type
-                if (!implementsInterfaceOrIsSubclassOf(getWrapper(resultType), getWrapper(originType))) {
+                // check for implicit conversion like "String a = 123", "int[] b = [1,2,3]", "List c = [].stream()", etc.
+                if (!implementsInterfaceOrIsSubclassOf(wrapTypeIfNecessary(resultType), wrapTypeIfNecessary(originType))) {
                     resultType = originType;
-                } else if (lType.isUsingGenerics() && !lType.isEnum() && GenericsUtils.hasUnresolvedGenerics(resultType)) {
-                    // for example, LHS is List<ConcreteClass> and RHS is List<T> where T is a placeholder
-                    resultType = lType;
+                } else if (isPrimitiveType(originType) && resultType.equals(getWrapper(originType))) {
+                    resultType = originType; // retain primitive semantics
                 } else {
                     // GROOVY-7549: RHS type may not be accessible to enclosing class
                     int modifiers = resultType.getModifiers();
@@ -856,14 +850,12 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                             && !getOutermost(enclosingType).equals(getOutermost(resultType))
                             && (Modifier.isPrivate(modifiers) || !Objects.equals(enclosingType.getPackageName(), resultType.getPackageName()))) {
                         resultType = originType; // TODO: Find accesible type in hierarchy of resultType?
+                    } else if (GenericsUtils.hasUnresolvedGenerics(resultType)) {// GROOVY-9033, GROOVY-10089, et al.
+                        Map<GenericsTypeName, GenericsType> enclosing = extractGenericsParameterMapOfThis(typeCheckingContext);
+                        resultType = fullyResolveType(resultType, Optional.ofNullable(enclosing).orElseGet(Collections::emptyMap));
                     }
                 }
 
-                // make sure we keep primitive types
-                if (isPrimitiveType(originType) && resultType.equals(getWrapper(originType))) {
-                    resultType = originType;
-                }
-
                 // track conditional assignment
                 if (!isNullConstant(rightExpression)
                         && leftExpression instanceof VariableExpression
@@ -900,6 +892,11 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             }
 
             validateResourceInARM(expression, resultType);
+
+            // GROOVY-5874: if left expression is a closure shared variable, a second pass should be done
+            if (leftExpression instanceof VariableExpression && ((VariableExpression) leftExpression).isClosureSharedVariable()) {
+                typeCheckingContext.secondPassExpressions.add(new SecondPassExpression<>(expression));
+            }
         } finally {
             typeCheckingContext.popEnclosingBinaryExpression();
         }
diff --git a/src/test/groovy/transform/stc/TypeInferenceSTCTest.groovy b/src/test/groovy/transform/stc/TypeInferenceSTCTest.groovy
index ec9119ec41..bd812b395e 100644
--- a/src/test/groovy/transform/stc/TypeInferenceSTCTest.groovy
+++ b/src/test/groovy/transform/stc/TypeInferenceSTCTest.groovy
@@ -1062,6 +1062,60 @@ class TypeInferenceSTCTest extends StaticTypeCheckingTestCase {
         }
     }
 
+    // GROOVY-5655
+    void testByteArrayInference() {
+        assertScript '''
+            @ASTTest(phase=INSTRUCTION_SELECTION, value={
+                assert node.getNodeMetaData(INFERRED_TYPE) == byte_TYPE.makeArray()
+            })
+            def b = "foo".bytes
+            new String(b)
+        '''
+    }
+
+    // GROOVY-
+    void testGetAnnotationFails() {
+        assertScript '''
+            import groovy.transform.*
+            import java.lang.annotation.*
+
+            @Retention(RetentionPolicy.RUNTIME)
+            @Target([ElementType.FIELD])
+            @interface Ann1 {}
+
+            @Retention(RetentionPolicy.RUNTIME)
+            @Target([ElementType.FIELD])
+            @interface Ann2 {}
+
+            class A {
+                @Ann2
+                String field
+            }
+
+            @ASTTest(phase=INSTRUCTION_SELECTION,value={
+                lookup('second').each {
+                  assert it.expression.getNodeMetaData(INFERRED_TYPE).name == 'Ann2'
+                }
+            })
+            def doit(obj, String propName) {
+                def field = obj.getClass().getDeclaredField(propName)
+                if (field) {
+                    @ASTTest(phase=INSTRUCTION_SELECTION,value={
+                        assert node.getNodeMetaData(INFERRED_TYPE).name == 'Ann1'
+                    })
+                    def annotation = field.getAnnotation Ann1
+                    if(true) {
+                        second: annotation = field.getAnnotation Ann2
+                    }
+                    return annotation
+                }
+                return null
+            }
+
+            assert Ann2.isAssignableFrom(doit(new A(), "field").class)
+        '''
+    }
+
     // GROOVY-9077
     void testInferredTypeForPropertyThatResolvesToMethod() {
         assertScript '''
@@ -1094,4 +1148,27 @@ class TypeInferenceSTCTest extends StaticTypeCheckingTestCase {
             meth()
         '''
     }
+
+    // GROOVY-10089
+    void testInferredTypeForMapOfList() {
+        assertScript '''
+            void test(... attributes) {
+                List one = [
+                    [id:'x', options:[count:1]]
+                ]
+                List two = attributes.collect {
+                    def node = Collections.singletonMap('children', one)
+                    if (node) {
+                        node = node.get('children').find { child -> child['id'] == 'x' }
+                    }
+                    // inferred type of node must be something like Map<String,List<...>>
+
+                    [id: it['id'], name: node['name'], count: node['options']['count']]
+                    //                                        ^^^^^^^^^^^^^^^ GroovyCastException (map ctor for Collection)
+                }
+            }
+
+            test( [id:'x'] )
+        '''
+    }
 }
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/TypeInferenceStaticCompileTest.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/TypeInferenceStaticCompileTest.groovy
index 40fc4e7184..afe168980f 100644
--- a/src/test/org/codehaus/groovy/classgen/asm/sc/TypeInferenceStaticCompileTest.groovy
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/TypeInferenceStaticCompileTest.groovy
@@ -21,73 +21,7 @@ package org.codehaus.groovy.classgen.asm.sc
 import groovy.transform.stc.TypeInferenceSTCTest
 
 /**
- * Unit tests for static type checking : type inference.
+ * Unit tests for static compilation : type inference.
  */
 class TypeInferenceStaticCompileTest extends TypeInferenceSTCTest implements StaticCompilationTestSupport {
-
-    // GROOVY-5655
-    void testByteArrayInference() {
-        assertScript '''
-                @ASTTest(phase=INSTRUCTION_SELECTION, value={
-                    assert node.getNodeMetaData(INFERRED_TYPE) == byte_TYPE.makeArray()
-                })
-                def b = "foo".bytes
-                new String(b)
-            '''
-    }
-
-    @Override
-    void testShouldNotThrowIncompatibleArgToFunVerifyError() {
-        try {
-            super.testShouldNotThrowIncompatibleArgToFunVerifyError()
-        } finally {
-//            println astTrees
-        }
-    }
-
-    // GROOVY-
-    void testGetAnnotationFail() {
-            assertScript '''import groovy.transform.*
-    import java.lang.annotation.ElementType;
-    import java.lang.annotation.Retention;
-    import java.lang.annotation.RetentionPolicy;
-    import java.lang.annotation.Target;
-
-            @Retention(RetentionPolicy.RUNTIME)
-            @Target([ElementType.FIELD])
-            @interface Ann1 {}
-            @Retention(RetentionPolicy.RUNTIME)
-            @Target([ElementType.FIELD])
-            @interface Ann2 {}
-
-            class A {
-                @Ann2
-                String field
-            }
-
-                @ASTTest(phase=INSTRUCTION_SELECTION,value={
-                    lookup('second').each {
-                      assert it.expression.getNodeMetaData(INFERRED_TYPE).name == 'Ann2'
-                    }
-                })
-                def doit(obj, String propName) {
-                def field = obj.getClass().getDeclaredField propName
-                println field
-                if(field) {
-                    @ASTTest(phase=INSTRUCTION_SELECTION,value={
-                        assert node.getNodeMetaData(INFERRED_TYPE).name == 'Ann1'
-                    })
-                    def annotation = field.getAnnotation Ann1
-                    if(true) {
-                        second: annotation = field.getAnnotation Ann2
-                    }
-                    return annotation
-                }
-                return null
-            }
-
-            assert Ann2.isAssignableFrom (doit(new A(), "field").class)
-            '''
-    }
 }
-
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy6782Bug.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy6782.groovy
similarity index 69%
rename from src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy6782Bug.groovy
rename to src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy6782.groovy
index 34b31c0726..63fc3342b6 100644
--- a/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy6782Bug.groovy
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy6782.groovy
@@ -16,23 +16,25 @@
  *  specific language governing permissions and limitations
  *  under the License.
  */
-
-
-
-
 package org.codehaus.groovy.classgen.asm.sc.bugs
 
-import groovy.transform.stc.StaticTypeCheckingTestCase
-import org.codehaus.groovy.classgen.asm.sc.StaticCompilationTestSupport
+import org.junit.Test
 
-class Groovy6782Bug extends StaticTypeCheckingTestCase implements StaticCompilationTestSupport {
+import static groovy.test.GroovyAssert.assertScript
 
+final class Groovy6782 {
+    @Test
     void testFlowTypingBreaksSubscriptOperator() {
-            assertScript '''String[] array = [123]
-def tokens = array
-def t = tokens[0]
-tokens = [:]    // if this line is removed, compiles fine
+        assertScript '''
+            @groovy.transform.CompileStatic
+            void test() {
+                String[] array = [123]
+                def temp = array
+                def x = temp[0]
+
+                temp = [:] // if this line is removed, compiles fine
+            }
+            test()
         '''
     }
-
 }
