diff --git a/src/main/java/groovy/lang/MetaClassImpl.java b/src/main/java/groovy/lang/MetaClassImpl.java
index 690cc8d8ed..71e89ac635 100644
--- a/src/main/java/groovy/lang/MetaClassImpl.java
+++ b/src/main/java/groovy/lang/MetaClassImpl.java
@@ -379,8 +379,8 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
 
             for (var metaMethod : c.getMethods()) {
                 addToAllMethodsIfPublic(metaMethod);
-                if (c == firstGroovySuper
-                      || !metaMethod.isPrivate()) {
+                if (c == firstGroovySuper || (metaMethod.isPublic() || metaMethod.isProtected() ||
+                        (!metaMethod.isPrivate() && inSamePackage(metaMethod.getDeclaringClass().getTheClass(), theClass)))) { // GROOVY-11357
                     addMetaMethodToIndex(metaMethod, header);
                 }
             }
diff --git a/src/main/java/org/codehaus/groovy/runtime/metaclass/MetaMethodIndex.java b/src/main/java/org/codehaus/groovy/runtime/metaclass/MetaMethodIndex.java
index 1459966f0c..ae20307f30 100644
--- a/src/main/java/org/codehaus/groovy/runtime/metaclass/MetaMethodIndex.java
+++ b/src/main/java/org/codehaus/groovy/runtime/metaclass/MetaMethodIndex.java
@@ -19,12 +19,12 @@
 package org.codehaus.groovy.runtime.metaclass;
 
 import groovy.lang.MetaMethod;
+import org.codehaus.groovy.ast.tools.GeneralUtils;
 import org.codehaus.groovy.reflection.CachedClass;
 import org.codehaus.groovy.reflection.GeneratedMetaMethod;
 import org.codehaus.groovy.util.FastArray;
 
 import java.util.Map;
-import java.util.Objects;
 import java.util.concurrent.ConcurrentHashMap;
 
 public class MetaMethodIndex {
@@ -171,7 +171,7 @@ public class MetaMethodIndex {
 
     private boolean isNonPrivate(final MetaMethod method) {
         return !method.isPrivate() && (!method.isPackagePrivate() || // GROOVY-11357
-                Objects.equals(method.getDeclaringClass().getTheClass().getPackage(), mainClass.getPackage()));
+                GeneralUtils.inSamePackage(method.getDeclaringClass().getTheClass(), mainClass));
     }
 
     public Object addMethodToList(final Object o, final MetaMethod toIndex) {
diff --git a/src/test/org/codehaus/groovy/transform/packageScope/DifferentPackageTest.groovy b/src/test/org/codehaus/groovy/transform/packageScope/DifferentPackageTest.groovy
index e4a195687a..ba1644879e 100644
--- a/src/test/org/codehaus/groovy/transform/packageScope/DifferentPackageTest.groovy
+++ b/src/test/org/codehaus/groovy/transform/packageScope/DifferentPackageTest.groovy
@@ -20,6 +20,7 @@ package org.codehaus.groovy.transform.packageScope
 
 import org.codehaus.groovy.control.*
 import org.codehaus.groovy.tools.GroovyClass
+import org.codehaus.groovy.tools.javac.JavaAwareCompilationUnit
 import org.junit.Test
 
 import static groovy.test.GroovyAssert.shouldFail
@@ -246,6 +247,81 @@ final class DifferentPackageTest {
         shouldFail MissingMethodException, {
             two.size()
         }
+
+        loader = addSources(
+            One: P_DOT_ONE,
+            Two: '''
+                package q
+
+                class Two extends p.One {
+                    // getThing shouldn't be indexed for Two
+                }
+            ''',
+            Three: '''
+                package r
+
+                class Three {
+                    int size() {
+                        def two = new q.Two()
+                        two.getThing().size() // not visible
+                    }
+                }
+            '''
+        )
+        def three = loader.loadClass('r.Three').newInstance()
+        shouldFail MissingMethodException, {
+            three.size()
+        }
+
+        //
+
+        def config = new CompilerConfiguration(
+            targetDirectory: File.createTempDir(),
+            jointCompilationOptions: [memStub: true]
+        )
+        def parentDir = File.createTempDir()
+        try {
+            new File(parentDir, 'p').mkdir()
+            new File(parentDir, 'q').mkdir()
+            new File(parentDir, 'r').mkdir()
+
+            def a = new File(parentDir, 'p/A.java')
+            a.write '''
+                package p;
+                public class A {
+                    void packagePrivate() {}
+                }
+            '''
+            def b = new File(parentDir, 'q/B.java')
+            b.write '''
+                package q;
+                public class B extends p.A {
+                }
+            '''
+            def c = new File(parentDir, 'r/C.groovy')
+            c.write '''
+                package r
+                class C {
+                    void test() {
+                        def q_b = new q.B()
+                        q_b.packagePrivate() // indirect reference
+                    }
+                }
+            '''
+
+            loader = new GroovyClassLoader(this.class.classLoader)
+            def cu = new JavaAwareCompilationUnit(config, loader)
+            cu.addSources(a, b, c)
+            cu.compile()
+
+            def pogo = loader.loadClass('r.C').newInstance()
+            shouldFail MissingMethodException, {
+                pogo.test()
+            }
+        } finally {
+            config.targetDirectory.deleteDir()
+            parentDir.deleteDir()
+        }
     }
 
     // GROOVY-9093
