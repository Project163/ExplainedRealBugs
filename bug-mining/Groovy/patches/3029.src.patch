diff --git a/src/main/org/codehaus/groovy/classgen/ClassCompletionVerifier.java b/src/main/org/codehaus/groovy/classgen/ClassCompletionVerifier.java
index 2867c0aa67..47e3175d47 100644
--- a/src/main/org/codehaus/groovy/classgen/ClassCompletionVerifier.java
+++ b/src/main/org/codehaus/groovy/classgen/ClassCompletionVerifier.java
@@ -68,6 +68,7 @@ public class ClassCompletionVerifier extends ClassCodeVisitorSupport {
         if (source != null && !source.getErrorCollector().hasErrors()) {
             checkClassForIncorrectModifiers(node);
             checkInterfaceMethodVisibility(node);
+            checkAbstractMethodVisibility(node);
             checkClassForOverwritingFinal(node);
             checkMethodsForIncorrectModifiers(node);
             checkMethodsForWeakerAccess(node);
@@ -127,6 +128,21 @@ public class ClassCompletionVerifier extends ClassCodeVisitorSupport {
         }
     }
 
+    private void checkAbstractMethodVisibility(ClassNode node) {
+        // we only do check abstract classes (including enums), no interfaces or non-abstract classes
+        if (!isAbstract(node.getModifiers()) || isInterface(node.getModifiers())) return;
+
+        List<MethodNode> abstractMethods = node.getAbstractMethods();
+        if (abstractMethods == null || abstractMethods.isEmpty()) return;
+
+        for (MethodNode method : abstractMethods) {
+            if (method.isPrivate()) {
+                addError("Method '" + method.getName() + "' from " + getDescription(node) +
+                        " must not be private as it is declared as an abstract method.", method);
+            }
+        }
+    }
+
     private void checkNoAbstractMethodsNonabstractClass(ClassNode node) {
         if (isAbstract(node.getModifiers())) return;
         List<MethodNode> abstractMethods = node.getAbstractMethods();
diff --git a/src/test/groovy/AbstractClassAndInterfaceTest.groovy b/src/test/groovy/AbstractClassAndInterfaceTest.groovy
index 5cdcc3211b..92440ff0fd 100644
--- a/src/test/groovy/AbstractClassAndInterfaceTest.groovy
+++ b/src/test/groovy/AbstractClassAndInterfaceTest.groovy
@@ -260,4 +260,67 @@ class AbstractClassAndInterfaceTest extends CompilableTestSupport {
         """
         shouldNotCompile scriptStr
     }
+
+    void testAbstractClassWithPrivateAbstractMethod() {
+        def msg = shouldNotCompile """
+            abstract class X {
+                private abstract void y()
+            }
+        """
+        assert msg.contains("Method 'y' from class 'X' must not be private as it is declared as an abstract method.")
+    }
+
+    void testAbstractClassWithPrivateAbstractMethods() {
+        def msg = shouldNotCompile """
+            abstract class X {
+                private abstract void y()
+                private abstract void z()
+            }
+        """
+        assert msg.contains("Method 'y' from class 'X' must not be private as it is declared as an abstract method.")
+        assert msg.contains("Method 'z' from class 'X' must not be private as it is declared as an abstract method.")
+    }
+
+    void testAbstractNestedClassWithPrivateAbstractMethod() {
+        def msg = shouldNotCompile """
+            class Z {
+                abstract class X {
+                    private abstract void y()
+                }
+            }
+        """
+        assert msg.contains("Method 'y' from class 'Z\$X' must not be private as it is declared as an abstract method.")
+    }
+
+    void testClassWithPrivateAbstractMethod() {
+        def msg = shouldNotCompile """
+            class X {
+                private abstract void y()
+            }
+        """
+        assert !msg.contains("Method 'y' from class 'X' must not be private as it is declared as an abstract method.")
+        assert msg.contains("Can't have an abstract method in a non-abstract class. The class 'X' must be declared abstract or the method 'void y()' must be implemented.")
+    }
+
+    void testEnumWithPrivateAbstractMethod() {
+        def msg = shouldNotCompile """
+            enum X {
+                CONST {
+                    private void y() { }
+                }
+
+                private abstract void y()
+            }
+        """
+        assert msg.contains("Method 'y' from class 'X' must not be private as it is declared as an abstract method.")
+    }
+
+    void testInterfaceWithPrivateAbstractMethod() {
+        def msg = shouldNotCompile """
+            interface X {
+                private abstract void y()
+            }
+        """
+        assert msg.contains("Method 'y' is private but should be public in interface 'X'.")
+    }
 }
\ No newline at end of file
diff --git a/src/test/org/codehaus/groovy/classgen/ClassCompletionVerifierTest.java b/src/test/org/codehaus/groovy/classgen/ClassCompletionVerifierTest.java
index d3eaae0009..5233cb26e9 100644
--- a/src/test/org/codehaus/groovy/classgen/ClassCompletionVerifierTest.java
+++ b/src/test/org/codehaus/groovy/classgen/ClassCompletionVerifierTest.java
@@ -73,6 +73,8 @@ public class ClassCompletionVerifierTest extends TestSupport {
             "Method 'prom' is protected but should be public in interface 'zzz'.";
     private static final String EXPECTED_PRIVATE_METHOD_ERROR_MESSAGE =
             "Method 'prim' is private but should be public in interface 'zzz'.";
+    private static final String EXPECTED_ABSTRACT_PRIVATE_METHOD_ERROR_MESSAGE =
+            "Method 'y' from class 'X' must not be private as it is declared as an abstract method.";
 
     protected void setUp() throws Exception {
         super.setUp();
@@ -80,6 +82,13 @@ public class ClassCompletionVerifierTest extends TestSupport {
         verifier = new ClassCompletionVerifier(source);
     }
 
+    public void testDetectsAbstractPrivateMethod() throws Exception {
+        ClassNode node = new ClassNode("X", ACC_ABSTRACT, ClassHelper.OBJECT_TYPE);
+        node.addMethod(new MethodNode("y", ACC_PRIVATE | ACC_ABSTRACT, ClassHelper.VOID_TYPE, new Parameter[0], ClassNode.EMPTY_ARRAY, null));
+        verifier.visitClass(node);
+        checkErrorMessage(EXPECTED_ABSTRACT_PRIVATE_METHOD_ERROR_MESSAGE);
+    }
+
     public void testDetectsFinalAbstractClass() throws Exception {
         checkVisitErrors("FinalClass", ACC_FINAL, false);
         checkVisitErrors("AbstractClass", ACC_ABSTRACT, false);
