diff --git a/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java b/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
index 5c5cd1bd90..558199b316 100644
--- a/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
+++ b/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
@@ -28,6 +28,7 @@ import org.codehaus.groovy.classgen.Verifier;
 import org.codehaus.groovy.reflection.ClassInfo;
 import org.codehaus.groovy.reflection.MixinInMetaClass;
 import org.codehaus.groovy.reflection.ReflectionCache;
+import org.codehaus.groovy.runtime.callsite.BooleanClosureWrapper;
 import org.codehaus.groovy.runtime.dgmimpl.NumberNumberDiv;
 import org.codehaus.groovy.runtime.dgmimpl.NumberNumberMinus;
 import org.codehaus.groovy.runtime.dgmimpl.NumberNumberMultiply;
@@ -1446,8 +1447,9 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      * @since 1.0
      */
     public static boolean every(Object self, Closure closure) {
+        BooleanClosureWrapper bcw = new BooleanClosureWrapper(closure);
         for (Iterator iter = InvokerHelper.asIterator(self); iter.hasNext();) {
-            if (!DefaultTypeTransformation.castToBoolean(closure.call(iter.next()))) {
+            if (!bcw.call(iter.next())) {
                 return false;
             }
         }
@@ -1470,8 +1472,9 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      * @since 1.5.0
      */
     public static <K, V> boolean every(Map<K, V> self, Closure closure) {
-        for (Map.Entry entry : self.entrySet()) {
-            if (!DefaultTypeTransformation.castToBoolean(callClosureForMapEntry(closure, entry))) {
+        BooleanClosureWrapper bcw = new BooleanClosureWrapper(closure);
+        for (Map.Entry<K, V> entry : self.entrySet()) {
+            if (!bcw.callForMap(entry)) {
                 return false;
             }
         }
@@ -1507,10 +1510,9 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      * @since 1.0
      */
     public static boolean any(Object self, Closure closure) {
+        BooleanClosureWrapper bcw = new BooleanClosureWrapper(closure);
         for (Iterator iter = InvokerHelper.asIterator(self); iter.hasNext();) {
-            if (DefaultTypeTransformation.castToBoolean(closure.call(iter.next()))) {
-                return true;
-            }
+            if (bcw.call(iter.next())) return true;
         }
         return false;
     }
@@ -1532,8 +1534,9 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      * @since 1.5.0
      */
     public static <K, V> boolean any(Map<K, V> self, Closure<?> closure) {
+        BooleanClosureWrapper bcw = new BooleanClosureWrapper(closure);
         for (Map.Entry<K, V> entry : self.entrySet()) {
-            if (DefaultTypeTransformation.castToBoolean(callClosureForMapEntry(closure, entry))) {
+            if (bcw.callForMap(entry)) {
                 return true;
             }
         }
@@ -1747,8 +1750,9 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      */
     public static Number count(Iterator self, Closure closure) {
         long answer = 0;
+        BooleanClosureWrapper bcw = new BooleanClosureWrapper(closure);
         while (self.hasNext()) {
-            if (DefaultTypeTransformation.castToBoolean(closure.call(self.next()))) {
+            if (bcw.call(self.next())) {
                 ++answer;
             }
         }
@@ -1804,8 +1808,9 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      */
     public static Number count(Map self, Closure<?> closure) {
         long answer = 0;
+        BooleanClosureWrapper bcw = new BooleanClosureWrapper(closure);
         for (Object entry : self.entrySet()) {
-            if (DefaultTypeTransformation.castToBoolean(callClosureForMapEntry(closure, (Map.Entry) entry))) {
+            if (bcw.callForMap((Map.Entry)entry)) {
                 ++answer;
             }
         }
@@ -2766,9 +2771,10 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      * @since 1.0
      */
     public static Object find(Object self, Closure closure) {
+        BooleanClosureWrapper bcw = new BooleanClosureWrapper(closure);
         for (Iterator iter = InvokerHelper.asIterator(self); iter.hasNext();) {
             Object value = iter.next();
-            if (DefaultTypeTransformation.castToBoolean(closure.call(value))) {
+            if (bcw.call(value)) {
                 return value;
             }
         }
@@ -2839,8 +2845,9 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      * @since 1.0
      */
     public static <T> T find(Collection<T> self, Closure closure) {
+        BooleanClosureWrapper bcw = new BooleanClosureWrapper(closure);
         for (T value : self) {
-            if (DefaultTypeTransformation.castToBoolean(closure.call(value))) {
+            if (bcw.call(value)) {
                 return value;
             }
         }
@@ -2862,8 +2869,9 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      * @since 2.0
      */
     public static <T> T find(T[] self, Closure condition) {
+        BooleanClosureWrapper bcw = new BooleanClosureWrapper(condition);
         for (T element : self) {
-            if (DefaultTypeTransformation.castToBoolean(condition.call(element))) {
+            if (bcw.call(element)) {
                 return element;
             }
         }
@@ -3004,8 +3012,9 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      * @since 1.0
      */
     public static <K, V> Map.Entry<K, V> find(Map<K, V> self, Closure<?> closure) {
+        BooleanClosureWrapper bcw = new BooleanClosureWrapper(closure);
         for (Map.Entry<K, V> entry : self.entrySet()) {
-            if (DefaultTypeTransformation.castToBoolean(callClosureForMapEntry(closure, entry))) {
+            if (bcw.callForMap(entry)) {
                 return entry;
             }
         }
@@ -3160,12 +3169,13 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
     }
 
     private static <T> Collection<T> findAll(Closure closure, Collection<T> answer, Iterator<? extends T> iter) {
-            while (iter.hasNext()) {
-                T value = iter.next();
-                if (DefaultTypeTransformation.castToBoolean(closure.call(value))) {
-                    answer.add(value);
-                }
+        BooleanClosureWrapper bcw = new BooleanClosureWrapper(closure);
+        while (iter.hasNext()) {
+            T value = iter.next();
+            if (bcw.call(value)) {
+                answer.add(value);
             }
+        }
         return answer;
     }
 
@@ -3235,10 +3245,11 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      */
     public static boolean retainAll(Collection self, Closure condition) {
         Iterator iter = InvokerHelper.asIterator(self);
+        BooleanClosureWrapper bcw = new BooleanClosureWrapper(condition);
         boolean result = false;
         while (iter.hasNext()) {
             Object value = iter.next();
-            if (!DefaultTypeTransformation.castToBoolean(condition.call(value))) {
+            if (!bcw.call(value)) {
                 iter.remove();
                 result = true;
             }
@@ -3261,10 +3272,11 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      */
     public static boolean removeAll(Collection self, Closure condition) {
         Iterator iter = InvokerHelper.asIterator(self);
+        BooleanClosureWrapper bcw = new BooleanClosureWrapper(condition);
         boolean result = false;
         while (iter.hasNext()) {
             Object value = iter.next();
-            if (DefaultTypeTransformation.castToBoolean(condition.call(value))) {
+            if (bcw.call(value)) {
                 iter.remove();
                 result = true;
             }
@@ -3352,9 +3364,10 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
 
     private static <T> Collection<Collection<T>> split(Closure closure, Collection<T> accept, Collection<T> reject, Iterator<T> iter) {
         List<Collection<T>> answer = new ArrayList<Collection<T>>();
+        BooleanClosureWrapper bcw = new BooleanClosureWrapper(closure);
         while (iter.hasNext()) {
             T value = iter.next();
-            if (DefaultTypeTransformation.castToBoolean(closure.call(value))) {
+            if (bcw.call(value)) {
                 accept.add(value);
             } else {
                 reject.add(value);
@@ -3480,8 +3493,9 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      */
     public static <K, V> Map<K, V> findAll(Map<K, V> self, Closure closure) {
         Map<K, V> answer = createSimilarMap(self);
+        BooleanClosureWrapper bcw = new BooleanClosureWrapper(closure);
         for (Map.Entry<K, V> entry : self.entrySet()) {
-            if (DefaultTypeTransformation.castToBoolean(callClosureForMapEntry(closure, entry))) {
+            if (bcw.callForMap(entry)) {
                 answer.put(entry.getKey(), entry.getValue());
             }
         }
@@ -6771,8 +6785,9 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      */
     public static <T> List<T> takeWhile(List<T> self, Closure condition) {
         int num = 0;
+        BooleanClosureWrapper bcw = new BooleanClosureWrapper(condition);
         for (T value : self) {
-            if (DefaultTypeTransformation.castToBoolean(condition.call(value))) {
+            if (bcw.call(value)) {
                 num += 1;
             } else {
                 break;
@@ -6828,8 +6843,9 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
             return createSimilarMap(self);
         }
         Map<K, V> ret = createSimilarMap(self);
+        BooleanClosureWrapper bcw = new BooleanClosureWrapper(condition);
         for (Map.Entry<K, V> entry : self.entrySet()) {
-            if (!DefaultTypeTransformation.castToBoolean(callClosureForMapEntry(condition, entry))) break;
+            if (!bcw.callForMap(entry)) break;
             ret.put(entry.getKey(), entry.getValue());
         }
         return ret;
@@ -6854,9 +6870,10 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      */
     public static <T> T[] takeWhile(T[] self, Closure condition) {
         int num = 0;
+        BooleanClosureWrapper bcw = new BooleanClosureWrapper(condition);
         while (num < self.length) {
             T value = self[num];
-            if (DefaultTypeTransformation.castToBoolean(condition.call(value))) {
+            if (bcw.call(value)) {
                 num += 1;
             } else {
                 break;
@@ -6891,13 +6908,13 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
 
     private static class TakeWhileIterator<E> implements Iterator<E> {
         private final Iterator<E> delegate;
-        private final Closure condition;
+        private final BooleanClosureWrapper condition;
         private boolean exhausted;
         private E next;
 
         private TakeWhileIterator(Iterator<E> delegate, Closure condition) {
             this.delegate = delegate;
-            this.condition = condition;
+            this.condition = new BooleanClosureWrapper(condition);
             advance();
         }
 
@@ -6921,7 +6938,7 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
             exhausted = !delegate.hasNext();
             if (!exhausted) {
                 next = delegate.next();
-                if (!DefaultTypeTransformation.castToBoolean(condition.call(next))) {
+                if (!condition.call(next)) {
                     exhausted = true;
                     next = null;
                 }
@@ -6950,8 +6967,9 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      */
     public static <T> List<T> dropWhile(List<T> self, Closure<?> condition) {
         int num = 0;
+        BooleanClosureWrapper bcw = new BooleanClosureWrapper(condition);
         for (T value : self) {
-            if (DefaultTypeTransformation.castToBoolean(condition.call(value))) {
+            if (bcw.call(value)) {
                 num += 1;
             } else {
                 break;
@@ -7008,8 +7026,9 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
         }
         Map<K, V> ret = createSimilarMap(self);
         boolean dropping = true;
+        BooleanClosureWrapper bcw = new BooleanClosureWrapper(condition);
         for (Map.Entry<K, V> entry : self.entrySet()) {
-            if (dropping && !DefaultTypeTransformation.castToBoolean(callClosureForMapEntry(condition, entry))) dropping = false;
+            if (dropping && !bcw.callForMap(entry)) dropping = false;
             if (!dropping) ret.put(entry.getKey(), entry.getValue());
         }
         return ret;
@@ -7036,8 +7055,9 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      */
     public static <T> T[] dropWhile(T[] self, Closure<?> condition) {
         int num = 0;
+        BooleanClosureWrapper bcw = new BooleanClosureWrapper(condition);
         while (num < self.length) {
-            if (DefaultTypeTransformation.castToBoolean(condition.call(self[num]))) {
+            if (bcw.call(self[num])) {
                 num += 1;
             } else {
                 break;
@@ -7106,9 +7126,10 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
         }
 
         private void prepare() {
+            BooleanClosureWrapper bcw = new BooleanClosureWrapper(condition);
             while (delegate.hasNext()) {
                 E next = delegate.next();
-                if (!DefaultTypeTransformation.castToBoolean(condition.call(next))) {
+                if (!bcw.call(next)) {
                     buffer = next;
                     buffering = true;
                     break;
@@ -11601,12 +11622,13 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
     public static int findIndexOf(Object self, int startIndex, Closure closure) {
         int result = -1;
         int i = 0;
+        BooleanClosureWrapper bcw = new BooleanClosureWrapper(closure);
         for (Iterator iter = InvokerHelper.asIterator(self); iter.hasNext(); i++) {
             Object value = iter.next();
             if (i < startIndex) {
                 continue;
             }
-            if (DefaultTypeTransformation.castToBoolean(closure.call(value))) {
+            if (bcw.call(value)) {
                 result = i;
                 break;
             }
@@ -11641,12 +11663,13 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
     public static int findLastIndexOf(Object self, int startIndex, Closure closure) {
         int result = -1;
         int i = 0;
+        BooleanClosureWrapper bcw = new BooleanClosureWrapper(closure);
         for (Iterator iter = InvokerHelper.asIterator(self); iter.hasNext(); i++) {
             Object value = iter.next();
             if (i < startIndex) {
                 continue;
             }
-            if (DefaultTypeTransformation.castToBoolean(closure.call(value))) {
+            if (bcw.call(value)) {
                 result = i;
             }
         }
@@ -11681,12 +11704,13 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
         List<Number> result = new ArrayList<Number>();
         long count = 0;
         long startCount = startIndex.longValue();
+        BooleanClosureWrapper bcw = new BooleanClosureWrapper(closure);
         for (Iterator iter = InvokerHelper.asIterator(self); iter.hasNext(); count++) {
             Object value = iter.next();
             if (count < startCount) {
                 continue;
             }
-            if (DefaultTypeTransformation.castToBoolean(closure.call(value))) {
+            if (bcw.call(value)) {
                 result.add(count);
             }
         }
diff --git a/src/main/org/codehaus/groovy/runtime/IOGroovyMethods.java b/src/main/org/codehaus/groovy/runtime/IOGroovyMethods.java
index 2fa6bc0137..19aa99543c 100644
--- a/src/main/org/codehaus/groovy/runtime/IOGroovyMethods.java
+++ b/src/main/org/codehaus/groovy/runtime/IOGroovyMethods.java
@@ -19,6 +19,8 @@ import groovy.io.GroovyPrintWriter;
 import groovy.lang.Closure;
 import groovy.lang.StringWriterIOException;
 import groovy.lang.Writable;
+
+import org.codehaus.groovy.runtime.callsite.BooleanClosureWrapper;
 import org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation;
 
 import java.io.*;
@@ -1401,8 +1403,9 @@ public class IOGroovyMethods extends DefaultGroovyMethodsSupport {
         BufferedWriter bw = new BufferedWriter(writer);
         String line;
         try {
+            BooleanClosureWrapper bcw = new BooleanClosureWrapper(closure);
             while ((line = br.readLine()) != null) {
-                if (DefaultTypeTransformation.castToBoolean(closure.call(line))) {
+                if (bcw.call(line)) {
                     bw.write(line);
                     bw.newLine();
                 }
@@ -1441,8 +1444,9 @@ public class IOGroovyMethods extends DefaultGroovyMethodsSupport {
             public Writer writeTo(Writer out) throws IOException {
                 BufferedWriter bw = new BufferedWriter(out);
                 String line;
+                BooleanClosureWrapper bcw = new BooleanClosureWrapper(closure);
                 while ((line = br.readLine()) != null) {
-                    if (DefaultTypeTransformation.castToBoolean(closure.call(line))) {
+                    if (bcw.call(line)) {
                         bw.write(line);
                         bw.newLine();
                     }
diff --git a/src/main/org/codehaus/groovy/runtime/StringGroovyMethods.java b/src/main/org/codehaus/groovy/runtime/StringGroovyMethods.java
index 78e8ad3806..ff208741c7 100644
--- a/src/main/org/codehaus/groovy/runtime/StringGroovyMethods.java
+++ b/src/main/org/codehaus/groovy/runtime/StringGroovyMethods.java
@@ -20,6 +20,8 @@ import groovy.lang.EmptyRange;
 import groovy.lang.GString;
 import groovy.lang.IntRange;
 import groovy.lang.Range;
+
+import org.codehaus.groovy.runtime.callsite.BooleanClosureWrapper;
 import org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation;
 
 import java.io.BufferedWriter;
@@ -549,9 +551,10 @@ public class StringGroovyMethods extends DefaultGroovyMethodsSupport {
      */
     public static CharSequence dropWhile(CharSequence self, Closure condition) {
         int num = 0;
+        BooleanClosureWrapper bcw = new BooleanClosureWrapper(condition);
         while (num < self.length()) {
             char value = self.charAt(num);
-            if (DefaultTypeTransformation.castToBoolean(condition.call(value))) {
+            if (bcw.call(value)) {
                 num += 1;
             } else {
                 break;
@@ -3311,9 +3314,10 @@ public class StringGroovyMethods extends DefaultGroovyMethodsSupport {
      */
     public static CharSequence takeWhile(CharSequence self, Closure condition) {
         int num = 0;
+        BooleanClosureWrapper bcw = new BooleanClosureWrapper(condition);
         while (num < self.length()) {
             char value = self.charAt(num);
-            if (DefaultTypeTransformation.castToBoolean(condition.call(value))) {
+            if (bcw.call(value)) {
                 num += 1;
             } else {
                 break;
diff --git a/src/main/org/codehaus/groovy/runtime/callsite/BooleanClosureWrapper.java b/src/main/org/codehaus/groovy/runtime/callsite/BooleanClosureWrapper.java
new file mode 100644
index 0000000000..e5835ce8d8
--- /dev/null
+++ b/src/main/org/codehaus/groovy/runtime/callsite/BooleanClosureWrapper.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright 2003-2012 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.codehaus.groovy.runtime.callsite;
+
+import java.util.Map;
+import java.util.Map.Entry;
+
+import org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation;
+
+import groovy.lang.Closure;
+
+/**
+ * Helper class for internal use only. This allows to call a {@link Closure} and 
+ * convert the result to a boolean. It will do this by caching the possible "doCall"
+ * as well as the "asBoolean" in CallSiteArray fashion. "asBoolean" will not be 
+ * called if the result is null or a Boolean. In case of null we return false and
+ * in case of a Boolean we simply unbox. This logic is designed after the one present 
+ * in {@link DefaultTypeTransformation#castToBoolean(Object)}. The purpose of 
+ * this class is to avoid the slow "asBoolean" call in that method.
+ * @author <a href="mailto:blackdrag@gmx.org">Jochen "blackdrag" Theodorou</a>
+ *
+ */
+public class BooleanClosureWrapper {
+    private final CallSiteArray csa = new CallSiteArray(BooleanClosureWrapper.class, new String[]{"call", "asBoolean"});
+    private final Closure wrapped;
+    private final int numberOfArguments;
+    
+    public BooleanClosureWrapper(Closure wrapped) {
+        this.wrapped = wrapped;
+        numberOfArguments = wrapped.getMaximumNumberOfParameters();
+    }
+
+    /**
+     * normal closure call
+     */
+    public boolean call(Object... args) {
+        try {
+            // make cached call to doCall:
+            Object ret = csa.array[0].call(wrapped, args);
+            // handle conversion to boolean
+            if (ret == null) return false;
+            if (ret instanceof Boolean) {
+                return ((Boolean) ret).booleanValue();
+            }
+            // it was not null and not boolean, so call asBoolean
+            ret = csa.array[1].call(ret, CallSiteArray.NOPARAM);
+            return ((Boolean) ret).booleanValue();
+        } catch (Throwable t) {
+            sun.misc.Unsafe.getUnsafe().throwException(t);
+            return false;
+        }
+    }
+    
+    /**
+     * Bridge for a call based on a map entry. If the call is done on a {@link Closure}
+     * taking one argument, then we give in the {@link Entry}, otherwise we will
+     * give in the key and value.
+     */
+    public <K,V> boolean callForMap(Map.Entry<K, V> entry) {
+        if (numberOfArguments==2) {
+            return call(entry.getKey(), entry.getValue());
+        } else {
+            return call(entry);
+        }
+    }
+}
