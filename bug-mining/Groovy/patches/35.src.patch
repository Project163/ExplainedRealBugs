diff --git a/.classpath b/.classpath
index 15904b54c8..d89e05874e 100644
--- a/.classpath
+++ b/.classpath
@@ -1,28 +1,54 @@
 <?xml version="1.0" encoding="UTF-8"?>
+
 <classpath>
-	<classpathentry kind="src" path="src/main"/>
-	<classpathentry kind="src" path="src/test"/>
-	<classpathentry kind="var" path="MAVEN_REPO/junit/jars/junit-3.8.1.jar"/>
-	<classpathentry sourcepath="JRE_SRC" kind="var" path="JRE_LIB"/>
-	<classpathentry kind="var" path="MAVEN_REPO/asm/jars/asm-1.4.1.jar"/>
-	<classpathentry kind="var" path="MAVEN_REPO/xerces/jars/xerces-2.4.0.jar"/>
-	<classpathentry kind="var" path="MAVEN_REPO/xml-apis/jars/xml-apis-1.0.b2.jar"/>
-	<classpathentry kind="var" path="MAVEN_REPO/classworlds/jars/classworlds-1.0-rc2.jar"/>
-	<classpathentry kind="var" path="MAVEN_REPO/commons-cli/jars/commons-cli-1.0.jar"/>
-	<classpathentry kind="var" path="MAVEN_REPO/ant/jars/ant-1.5.2.jar"/>
-	<classpathentry kind="var" path="MAVEN_REPO/asm/jars/asm-util-1.4.1.jar"/>
-	<classpathentry kind="var" path="MAVEN_REPO/asm/jars/asm-attrs-1.4.1.jar"/>
-	<classpathentry kind="var" path="MAVEN_REPO/bsf/jars/bsf-2.3.0-rc1.jar"/>
-	<classpathentry kind="var" path="MAVEN_REPO/mx4j/jars/mx4j-2.0-beta-1.jar"/>
-	<classpathentry kind="var" path="MAVEN_REPO/mockobjects/jars/mockobjects-core-0.09.jar"/>
-	<classpathentry kind="var" path="MAVEN_REPO/openejb/jars/openejb-loader-0.9.2.jar"/>
-	<classpathentry kind="var" path="MAVEN_REPO/axion/jars/axion-1.0-M3-dev.jar"/>
-	<classpathentry kind="var" path="MAVEN_REPO/commons-logging/jars/commons-logging-1.0.3.jar"/>
-	<classpathentry kind="var" path="MAVEN_REPO/commons-collections/jars/commons-collections-3.0-dev2.jar"/>
-	<classpathentry kind="var" path="MAVEN_REPO/regexp/jars/regexp-1.2.jar"/>
-	<classpathentry kind="var" path="MAVEN_REPO/servletapi/jars/servletapi-2.3.jar"/>
-	<classpathentry kind="var" path="MAVEN_REPO/radeox/jars/radeox-0.9.jar"/>
-	<classpathentry kind="var" path="MAVEN_REPO/radeox/jars/radeox-oro-0.9.jar"/>
-	<classpathentry kind="lib" path="target/test-classes"/>
-	<classpathentry kind="output" path="bin"/>
-</classpath>
+  <classpathentry kind="src" path="src/main">
+  </classpathentry>
+  <classpathentry output="target/test-classes" kind="src" path="src/test">
+  </classpathentry>
+  <classpathentry kind="var" path="MAVEN_REPO/junit/jars/junit-3.8.1.jar">
+  </classpathentry>
+  <classpathentry kind="var" rootpath="JRE_SRCROOT" path="JRE_LIB" sourcepath="JRE_SRC">
+  </classpathentry>
+  <classpathentry kind="var" path="MAVEN_REPO/asm/jars/asm-1.4.1.jar">
+  </classpathentry>
+  <classpathentry kind="var" path="MAVEN_REPO/xerces/jars/xerces-2.4.0.jar">
+  </classpathentry>
+  <classpathentry kind="var" path="MAVEN_REPO/xml-apis/jars/xml-apis-1.0.b2.jar">
+  </classpathentry>
+  <classpathentry kind="var" path="MAVEN_REPO/classworlds/jars/classworlds-1.0-rc2.jar">
+  </classpathentry>
+  <classpathentry kind="var" path="MAVEN_REPO/commons-cli/jars/commons-cli-1.0.jar">
+  </classpathentry>
+  <classpathentry kind="var" path="MAVEN_REPO/ant/jars/ant-1.5.2.jar">
+  </classpathentry>
+  <classpathentry kind="var" path="MAVEN_REPO/asm/jars/asm-util-1.4.1.jar">
+  </classpathentry>
+  <classpathentry kind="var" path="MAVEN_REPO/asm/jars/asm-attrs-1.4.1.jar">
+  </classpathentry>
+  <classpathentry kind="var" path="MAVEN_REPO/bsf/jars/bsf-2.3.0-rc1.jar">
+  </classpathentry>
+  <classpathentry kind="var" path="MAVEN_REPO/mx4j/jars/mx4j-2.0-beta-1.jar">
+  </classpathentry>
+  <classpathentry kind="var" path="MAVEN_REPO/mockobjects/jars/mockobjects-core-0.09.jar">
+  </classpathentry>
+  <classpathentry kind="var" path="MAVEN_REPO/openejb/jars/openejb-loader-0.9.2.jar">
+  </classpathentry>
+  <classpathentry kind="var" path="MAVEN_REPO/axion/jars/axion-1.0-M3-dev.jar">
+  </classpathentry>
+  <classpathentry kind="var" path="MAVEN_REPO/commons-logging/jars/commons-logging-1.0.3.jar">
+  </classpathentry>
+  <classpathentry kind="var" path="MAVEN_REPO/commons-collections/jars/commons-collections-3.0-dev2.jar">
+  </classpathentry>
+  <classpathentry kind="var" path="MAVEN_REPO/regexp/jars/regexp-1.2.jar">
+  </classpathentry>
+  <classpathentry kind="var" path="MAVEN_REPO/servletapi/jars/servletapi-2.3.jar">
+  </classpathentry>
+  <classpathentry kind="var" path="MAVEN_REPO/radeox/jars/radeox-0.9.jar">
+  </classpathentry>
+  <classpathentry kind="var" path="MAVEN_REPO/radeox/jars/radeox-oro-0.9.jar">
+  </classpathentry>
+  <classpathentry kind="var" path="MAVEN_REPO/nekohtml/jars/nekohtml-0.7.7.jar">
+  </classpathentry>
+  <classpathentry kind="output" path="bin">
+  </classpathentry>
+</classpath>
\ No newline at end of file
diff --git a/maven.xml b/maven.xml
index 9b958c9799..f8d06167f0 100644
--- a/maven.xml
+++ b/maven.xml
@@ -26,6 +26,13 @@
    <attainGoal name="dist:deploy-src"/>
    <attainGoal name="jar:deploy"/>
   </goal>
+
+  <goal name="groovy:test-wiki" description="Generates the test cases for the wiki and runs the tests">
+   <attainGoal name="clean"/>
+   <attainGoal name="groovy:compile"/>
+   <j:set var="testcase" value="org.codehaus.groovy.wiki.RunWikiTest"/>
+   <attainGoal name="test:single"/>
+  </goal>
   
   <postGoal name="dist:prepare-bin-filesystem">
   	<attainGoal name="groovy:make-install"/>
@@ -91,11 +98,14 @@
 
 
   <preGoal name="xdoc:jelly-transform">
+    <mkdir dir="${maven.html2xdoc.dir}"/>
+  	<!--
     <copy toDir="${maven.html2xdoc.dir}">
       <fileset dir="${basedir}/xdocs">
         <include name="**/*.html"/>
       </fileset>
   	</copy>
+  	-->
   	
   	<!-- now lets run the wiki plugin -->
   	<attainGoal name="java:compile"/>
diff --git a/project.xml b/project.xml
index f167da5cd7..9505a9794f 100644
--- a/project.xml
+++ b/project.xml
@@ -320,6 +320,11 @@
       <id>radeox+oro</id>
       <version>0.9</version>
     </dependency>
+  <!-- only used for the HTML to Wiki script -->
+    <dependency>
+      <id>nekohtml</id>
+      <version>0.7.7</version>
+    </dependency>
   
   </dependencies>
 
diff --git a/src/main/groovy/lang/GString.java b/src/main/groovy/lang/GString.java
index 4ec9df025c..a6e5cfd53e 100644
--- a/src/main/groovy/lang/GString.java
+++ b/src/main/groovy/lang/GString.java
@@ -37,6 +37,8 @@ import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 
+import org.codehaus.groovy.runtime.InvokerHelper;
+
 /**
  * Represents a String which contains embedded values such as "hello there
  * ${user} how are you?" which can be evaluated lazily. Advanced users can
@@ -66,6 +68,21 @@ public abstract class GString extends GroovyObjectSupport implements Comparable,
     // will be static in an instance
     public abstract String[] getStrings();
 
+    /**
+     * Overloaded to implement duck typing for Strings 
+     * so that any method that can't be evaluated on this
+     * object will be forwarded to the toString() object instead.
+     */
+    public Object invokeMethod(String name, Object args) {
+        try {
+            return super.invokeMethod(name, args);
+        }
+        catch (MissingMethodException e) {
+            // lets try invoke the method on the real String
+            return InvokerHelper.invokeMethod(toString(), name, args);
+        }
+    }
+
     public Object[] getValues() {
         return values;
     }
diff --git a/src/main/groovy/lang/MetaClass.java b/src/main/groovy/lang/MetaClass.java
index 4e3f3834ce..964464d866 100644
--- a/src/main/groovy/lang/MetaClass.java
+++ b/src/main/groovy/lang/MetaClass.java
@@ -387,10 +387,10 @@ public class MetaClass {
                 return getStaticProperty((Class) object, property);
             }
             if (object instanceof Collection) {
-                return DefaultGroovyMethods.get((Collection) object, property);
+                return DefaultGroovyMethods.getAt((Collection) object, property);
             }
             if (object instanceof Object[]) {
-                return DefaultGroovyMethods.get(Arrays.asList((Object[]) object), property);
+                return DefaultGroovyMethods.getAt(Arrays.asList((Object[]) object), property);
             }
 
             // lets try the getter method
@@ -877,12 +877,12 @@ public class MetaClass {
             return null;
         }
         Object answer = null;
-        if (arguments.length == 1 && arguments[0] == null) {
-            answer = chooseMostGeneralMethodWith1Param(methods);
-        }
-        else if (arguments.length == 0) {
+        if (arguments == null || arguments.length == 0) {
             answer = chooseEmptyMethodParams(methods);
         }
+        else if (arguments.length == 1 && arguments[0] == null) {
+            answer = chooseMostGeneralMethodWith1Param(methods);
+        }
         else {
             List matchingMethods = new ArrayList();
 
diff --git a/src/main/groovy/sql/DataSet.java b/src/main/groovy/sql/DataSet.java
index 953bdc4f9d..a90dfe6984 100644
--- a/src/main/groovy/sql/DataSet.java
+++ b/src/main/groovy/sql/DataSet.java
@@ -182,7 +182,9 @@ public class DataSet extends Sql {
             if (where != null) {
                 MethodNode method = where.getMetaClass().getClassNode().getMethod("doCall");
                 Statement statement = method.getCode();
-                statement.visit(visitor);
+                if (statement != null) {
+                    statement.visit(visitor);
+                }
             }
         }
         return visitor;
diff --git a/src/main/groovy/ui/Console.groovy b/src/main/groovy/ui/Console.groovy
index 40135d5970..e519a8d64c 100644
--- a/src/main/groovy/ui/Console.groovy
+++ b/src/main/groovy/ui/Console.groovy
@@ -99,7 +99,7 @@ class Console extends ConsoleSupport {
         
         answer = evaluate(text)
 
-        output = "\n" + InvokerHelper.toString(answer)
+        output = "\n" + InvokerHelper.inspect(answer)
         
         doc.insertString(doc.getLength(), output, outputStyle)
         
diff --git a/src/main/groovy/ui/InteractiveShell.java b/src/main/groovy/ui/InteractiveShell.java
index 27f1f9f027..247fbadb94 100644
--- a/src/main/groovy/ui/InteractiveShell.java
+++ b/src/main/groovy/ui/InteractiveShell.java
@@ -98,7 +98,7 @@ public class InteractiveShell {
             }
             try {
                 Object answer = shell.evaluate(command, "CommandLine" + counter++ +".groovy");
-                System.out.println(InvokerHelper.toString(answer));
+                System.out.println(InvokerHelper.inspect(answer));
             }
             catch (Exception e) {
                 System.out.println("Caught: " + e);
diff --git a/src/main/groovy/util/GroovyTestCase.java b/src/main/groovy/util/GroovyTestCase.java
index d616de9ec3..542fc384ba 100644
--- a/src/main/groovy/util/GroovyTestCase.java
+++ b/src/main/groovy/util/GroovyTestCase.java
@@ -45,7 +45,10 @@
  */
 package groovy.util;
 
+import java.util.logging.Logger;
+
 import groovy.lang.Closure;
+import groovy.lang.GroovyShell;
 import junit.framework.TestCase;
 
 import org.codehaus.groovy.runtime.InvokerHelper;
@@ -61,6 +64,8 @@ import org.codehaus.groovy.runtime.InvokerHelper;
  */
 public class GroovyTestCase extends TestCase {
 
+    protected Logger log = Logger.getLogger(getClass().getName());
+    
     public GroovyTestCase() {
     }
 
@@ -157,6 +162,17 @@ public class GroovyTestCase extends TestCase {
         assertEquals("inspect() on value: " + value, expected, console);
     }
     
+    /**
+     * Asserts that the script runs without any exceptions
+     * @param script
+     */
+    protected void assertScript(String script) throws Exception {
+        log.info("About to execute script");
+        log.info(script);
+        
+        GroovyShell shell = new GroovyShell();
+        shell.evaluate(script, "TestScript.groovy");
+    }
     
     /**
      * Asserts that the given code closure fails when it is evaluated
diff --git a/src/main/groovy/util/XmlParser.java b/src/main/groovy/util/XmlParser.java
index 147cae8063..aa61f0e7e9 100644
--- a/src/main/groovy/util/XmlParser.java
+++ b/src/main/groovy/util/XmlParser.java
@@ -83,7 +83,6 @@ import org.xml.sax.XMLReader;
 public class XmlParser implements ContentHandler {
 
     private StringBuffer bodyText = new StringBuffer();
-    private List bodyTexts = new ArrayList();
     private List stack = new ArrayList();
     private Locator locator;
     private XMLReader reader;
@@ -103,6 +102,15 @@ public class XmlParser implements ContentHandler {
         reader = parser.getXMLReader();
     }
 
+    public XmlParser(XMLReader reader) {
+        this.reader = reader;
+    }
+
+    public XmlParser(SAXParser parser) throws SAXException {
+        reader = parser.getXMLReader();
+    }
+
+    
     /**
      * Parses the content of the given file as XML turning it into a tree
      * of Nodes
@@ -162,15 +170,13 @@ public class XmlParser implements ContentHandler {
     }
 
     public void endDocument() throws SAXException {
-        bodyTexts.clear();
         stack.clear();
     }
 
     public void startElement(String namespaceURI, String localName, String qName, Attributes list)
         throws SAXException {
-        bodyTexts.add(bodyText);
-        bodyText = new StringBuffer();
-
+        addTextToNode();
+        
         Object name = getElementName(namespaceURI, localName, qName);
 
         int size = list.getLength();
@@ -185,21 +191,14 @@ public class XmlParser implements ContentHandler {
     }
 
     public void endElement(String namespaceURI, String localName, String qName) throws SAXException {
-        String text = bodyText.toString();
-        if (trimWhitespace) {
-            text = text.trim();
-        }
-        if (text.length() > 0) {
-            parent.children().add(text);
-        }
-
+        addTextToNode();
+        
         if (!stack.isEmpty()) {
             stack.remove(stack.size() - 1);
             if (!stack.isEmpty()) {
                 parent = (Node) stack.get(stack.size() - 1);
             }
         }
-        bodyText = (StringBuffer) bodyTexts.remove(bodyTexts.size() - 1);
     }
 
     public void characters(char buffer[], int start, int length) throws SAXException {
@@ -236,6 +235,17 @@ public class XmlParser implements ContentHandler {
         return reader;
     }
 
+    protected void addTextToNode() {
+        String text = bodyText.toString();
+        if (trimWhitespace) {
+            text = text.trim();
+        }
+        if (text.length() > 0) {
+            parent.children().add(text);
+        }
+        bodyText = new StringBuffer();
+    }
+
     protected Object getElementName(String namespaceURI, String localName, String qName) throws SAXException {
         String name = localName;
         if ((name == null) || (name.length() < 1)) {
diff --git a/src/main/groovy/xml/MarkupBuilder.java b/src/main/groovy/xml/MarkupBuilder.java
index da327451a2..017e0187e1 100644
--- a/src/main/groovy/xml/MarkupBuilder.java
+++ b/src/main/groovy/xml/MarkupBuilder.java
@@ -56,12 +56,14 @@ import java.util.Map;
  * A helper class for creating XML or HTML markup
  * 
  * @author <a href="mailto:james@coredevelopers.net">James Strachan</a>
+ * @author Stefan Matthias Aust
  * @version $Revision$
  */
 public class MarkupBuilder extends BuilderSupport {
 
     private IndentPrinter out;
-    private boolean newline;
+    private boolean nospace;
+    private int state;
 
     public MarkupBuilder() {
         this(new IndentPrinter());
@@ -78,61 +80,138 @@ public class MarkupBuilder extends BuilderSupport {
     protected void setParent(Object parent, Object child) {
     }
 
+    public Object getProperty(String property) {
+        if (property.equals("_")) {
+            nospace = true;
+            return null;
+        } else {
+            Object node = createNode(property);
+            nodeCompleted(getCurrent(), node);
+            return node;
+        }
+    }
+
     protected Object createNode(Object name) {
-        out.printIndent();
-        out.print("<");
-        print(name);
-        out.println(">");
-        out.incrementIndent();
-        newline = true;
+        toState(1, name);
         return name;
     }
 
     protected Object createNode(Object name, Object value) {
-        out.printIndent();
-        out.print("<");
-        print(name);
+        toState(2, name);
         out.print(">");
         print(value);
-        newline = false;
         return name;
     }
 
     protected Object createNode(Object name, Map attributes) {
-        out.printIndent();
-        out.print("<");
-        out.print(name.toString());
+        toState(1, name);
         for (Iterator iter = attributes.entrySet().iterator(); iter.hasNext();) {
             Map.Entry entry = (Map.Entry) iter.next();
             out.print(" ");
-            print(entry.getKey());
+            print(transformName(entry.getKey().toString()));
             out.print("='");
-            print(entry.getValue());
+            print(transformValue(entry.getValue().toString()));
             out.print("'");
         }
-        out.println(">");
-        out.incrementIndent();
-        newline = true;
         return name;
     }
 
     protected void nodeCompleted(Object parent, Object node) {
-        if (newline) {
-            out.decrementIndent();
-            out.printIndent();
-        }
-        out.print("</");
-        print(node);
-        out.println(">");
+        toState(3, node);
         out.flush();
     }
 
     protected void print(Object node) {
-        if (node != null) {
-            out.print(node.toString());
-        }
-        else {
-            out.print("null");
+        out.print(node == null ? "null" : node.toString());
+    }
+
+    protected Object getName(String methodName) {
+		return super.getName(transformName(methodName));
+	}
+
+    protected String transformName(String name) {
+    	if (name.startsWith("_")) name = name.substring(1);
+    	return name.replace('_', '-');
+    }
+
+    protected String transformValue(String value) {
+        return value.replaceAll("\\'", "&quot;");
+    }
+
+    private void toState(int next, Object name) {
+        switch (state) {
+        case 0:
+            switch (next) {
+            case 1:
+            case 2:
+                out.print("<");
+                print(name);
+                break;
+            case 3:
+                throw new Error();
+            }
+            break;
+        case 1:
+            switch (next) {
+            case 1:
+            case 2:
+                out.print(">");
+                if (nospace) {
+                    nospace = false;
+                } else {
+                    out.println();
+                    out.incrementIndent();
+                    out.printIndent();
+                }
+                out.print("<");
+                print(name);
+                break;
+            case 3:
+                out.print("/>");
+                break;
+            }
+            break;
+        case 2:
+            switch (next) {
+            case 1:
+            case 2:
+                throw new Error();
+            case 3:
+                out.print("</");
+                print(name);
+                out.print(">");
+                break;
+            }
+            break;
+        case 3:
+            switch (next) {
+            case 1:
+            case 2:
+                if (nospace) {
+                    nospace = false;
+                } else {
+                    out.println();
+	                out.printIndent();
+                }
+                out.print("<");
+                print(name);
+                break;
+            case 3:
+                if (nospace) {
+                    nospace = false;
+                } else {
+                    out.println();
+                    out.decrementIndent();
+                    out.printIndent();
+                }
+                out.print("</");
+                print(name);
+                out.print(">");
+                break;
+            }
+            break;
         }
+        state = next;
     }
+
 }
diff --git a/src/main/org/codehaus/groovy/ast/ModuleNode.java b/src/main/org/codehaus/groovy/ast/ModuleNode.java
index 16f72d277e..b1ee52ecb1 100644
--- a/src/main/org/codehaus/groovy/ast/ModuleNode.java
+++ b/src/main/org/codehaus/groovy/ast/ModuleNode.java
@@ -254,4 +254,8 @@ public class ModuleNode extends ASTNode implements Constants {
         return answer;
     }
 
+    public boolean isEmpty() {
+        return classes.isEmpty() && statementBlock.getStatements().isEmpty();
+    }
+
 }
diff --git a/src/main/org/codehaus/groovy/ast/expr/MethodCallExpression.java b/src/main/org/codehaus/groovy/ast/expr/MethodCallExpression.java
index 2e1a5032e1..4c9d89fe07 100644
--- a/src/main/org/codehaus/groovy/ast/expr/MethodCallExpression.java
+++ b/src/main/org/codehaus/groovy/ast/expr/MethodCallExpression.java
@@ -59,6 +59,7 @@ public class MethodCallExpression extends Expression {
     private String method;
     private Expression arguments;
     private boolean safe;
+    private boolean implicitThis;
 
     public MethodCallExpression(Expression objectExpression, String method, Expression arguments) {
         this.objectExpression = objectExpression;
@@ -105,6 +106,19 @@ public class MethodCallExpression extends Expression {
         this.safe = safe;
     }
 
+    /**
+     * @return true if no object expression was specified otherwise if 
+     * some expression was specified for the object on which to evaluate
+     * the method then return false
+     */
+    public boolean isImplicitThis() {
+        return implicitThis;
+    }
+
+    public void setImplicitThis(boolean implicitThis) {
+        this.implicitThis = implicitThis;
+    }
+
     public String toString() {
         return super.toString()
             + "[object: "
diff --git a/src/main/org/codehaus/groovy/classgen/ClassGenerator.java b/src/main/org/codehaus/groovy/classgen/ClassGenerator.java
index f66c8a16c6..53111568f0 100644
--- a/src/main/org/codehaus/groovy/classgen/ClassGenerator.java
+++ b/src/main/org/codehaus/groovy/classgen/ClassGenerator.java
@@ -846,7 +846,7 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
                 cv.visitInsn(ARETURN);
             }
             else {
-                if (returnType != null && !returnType.equals("java.lang.Object") && !returnType.equals(c.getName())) {
+                if (isValidTypeForCast(returnType) && !returnType.equals(c.getName())) {
                     doCast(returnType);
                 }
                 cv.visitInsn(ARETURN);
@@ -963,10 +963,10 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
             case Token.LEFT_SQUARE_BRACKET :
                 if (leftHandExpression) {
                     throw new RuntimeException("Should not be called");
-                    //evaluateBinaryExpression("put", expression);
+                    //evaluateBinaryExpression("putAt", expression);
                 }
                 else {
-                    evaluateBinaryExpression("get", expression);
+                    evaluateBinaryExpression("getAt", expression);
                 }
                 break;
 
@@ -1375,14 +1375,16 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
             cv.visitVarInsn(ASTORE, valueIdx);
         }
 
-        // lets load an extra one just in case as we may be getting & putting a
-        // field
-        cv.visitVarInsn(ALOAD, 0);
-        cv.visitFieldInsn(GETFIELD, internalClassName, "owner", getTypeDescription(outerClassNode.getName()));
-
         FieldNode field = expression.getField();
         boolean isStatic = field.isStatic();
 
+        // lets load an extra one just in case as we may be getting & putting a
+        // field
+        if (!isStatic) {
+            cv.visitVarInsn(ALOAD, 0);
+            cv.visitFieldInsn(GETFIELD, internalClassName, "owner", getTypeDescription(outerClassNode.getName()));
+        }
+
         int opcode = (leftHandExpression) ? ((isStatic) ? PUTSTATIC : PUTFIELD) : ((isStatic) ? GETSTATIC : GETFIELD);
         String ownerName = getClassInternalName(outerClassNode.getName());
 
@@ -1887,7 +1889,7 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
     protected void doConvertAndCast(String type) {
         if (!type.equals("java.lang.Object")) {
             /** @todo should probably support array coercions */
-            if (!type.endsWith("[]")) {
+            if (!type.endsWith("[]") && isValidTypeForCast(type)) {
                 visitClassExpression(new ClassExpression(type));
                 asTypeMethod.call(cv);
             }
@@ -1958,7 +1960,7 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
                 // method call
                 // e.g. x[5] += 10
                 // -> (x, [], 5), =, x[5] + 10
-                // -> methodCall(x, "put", [5, methodCall(x[5], "plus", 10)])
+                // -> methodCall(x, "putAt", [5, methodCall(x[5], "plus", 10)])
 
                 MethodCallExpression methodCall =
                     new MethodCallExpression(
@@ -1971,7 +1973,7 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
                 visitMethodCallExpression(
                     new MethodCallExpression(
                         leftBinExpr.getLeftExpression(),
-                        "put",
+                        "putAt",
                         new ArgumentListExpression(new Expression[] { safeIndexExpr, methodCall })));
                 cv.visitInsn(POP);
                 return;
@@ -2010,11 +2012,11 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
                 // method call
                 // e.g. x[5] = 10
                 // -> (x, [], 5), =, 10
-                // -> methodCall(x, "set", [5, 10])
+                // -> methodCall(x, "putAt", [5, 10])
                 visitMethodCallExpression(
                     new MethodCallExpression(
                         leftBinExpr.getLeftExpression(),
-                        "put",
+                        "putAt",
                         new ArgumentListExpression(
                             new Expression[] { leftBinExpr.getRightExpression(), expression.getRightExpression()})));
                 cv.visitInsn(POP);
@@ -2031,6 +2033,8 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
 
         String type = getLHSType(leftExpression);
         if (type != null) {
+            //System.out.println("### expression: " + leftExpression);
+            //System.out.println("### type: " + type);
             visitCastExpression(new CastExpression(type, rightExpression));
         }
         else {
@@ -2051,17 +2055,17 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
         if (leftExpression instanceof VariableExpression) {
             VariableExpression varExp = (VariableExpression) leftExpression;
             String type = varExp.getType();
-            if (type != null && !type.equals("java.lang.Object")) {
+            if (isValidTypeForCast(type)) {
                 return type;
             }
             String variableName = varExp.getVariable();
             Variable variable = (Variable) variableStack.get(variableName);
             if (variable != null) {
-                if (variable.isHolder()) {
+                if (variable.isHolder() || variable.isProperty()) {
                     return null;
                 }
                 type = variable.getType();
-                if (type != null && !type.equals("java.lang.Object")) {
+                if (isValidTypeForCast(type)) {
                     return type;
                 }
             }
@@ -2072,7 +2076,7 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
                 }
                 if (field != null) {
                     type = field.getType();
-                    if (!field.isHolder() && type != null && !type.equals("java.lang.Object")) {
+                    if (!field.isHolder() && isValidTypeForCast(type)) {
                         return type;
                     }
                 }
@@ -2081,6 +2085,10 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
         return null;
     }
 
+    protected boolean isValidTypeForCast(String type) {
+        return type != null && !type.equals("java.lang.Object") && !type.equals("groovy.lang.Reference");
+    }
+
     protected void visitAndAutobox(Expression expression) {
         expression.visit(this);
 
@@ -2228,7 +2236,7 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
                 return expression;
             }
         };
-        
+
         // could just be a postfix / prefix expression or nested inside some other expression
         return transformer.transform(expression.transformExpression(transformer));
     }
@@ -2293,50 +2301,50 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
      *         passed into a closure
      */
     protected Parameter[] getClosureSharedVariables(ClosureExpression expression) {
-        VariableScopeCodeVisitor outerVisitor = new VariableScopeCodeVisitor();
-        VariableScopeCodeVisitor innerVisitor = new VariableScopeCodeVisitor();
-
-        if (methodNode != null) {
-            // we must be in a property
-            outerVisitor.setParameters(methodNode.getParameters());
-            methodNode.getCode().visit(outerVisitor);
-        }
-        else {
-            // propertyNode.getInitialValueExpression().visit(outerVisitor);
-        }
-        expression.getCode().visit(innerVisitor);
-
-        // now any variables declared in the outer context that are referred to
-        // in the inner context need to be copied
-        Set outerDecls = outerVisitor.getDeclaredVariables();
-        outerDecls.addAll(outerVisitor.getParameterSet());
-        Set outerRefs = outerVisitor.getReferencedVariables();
-        Set innerDecls = innerVisitor.getDeclaredVariables();
-        Set innerRefs = innerVisitor.getReferencedVariables();
-
         List vars = new ArrayList();
-        Set varSet = new HashSet();
-        for (Iterator iter = innerRefs.iterator(); iter.hasNext();) {
-            String var = (String) iter.next();
-            if (outerDecls.contains(var) && classNode.getField(var) == null) {
-                String type = getVariableType(var);
-                vars.add(new Parameter(type, var));
-                varSet.add(var);
+        if (!isInScriptBody()) {
+            VariableScopeCodeVisitor outerVisitor = new VariableScopeCodeVisitor();
+            VariableScopeCodeVisitor innerVisitor = new VariableScopeCodeVisitor();
+
+            if (methodNode != null) {
+                // we must be in a property
+                outerVisitor.setParameters(methodNode.getParameters());
+                methodNode.getCode().visit(outerVisitor);
             }
-        }
-        for (Iterator iter = outerRefs.iterator(); iter.hasNext();) {
-            String var = (String) iter.next();
-            if (innerDecls.contains(var) && classNode.getField(var) == null && !varSet.contains(var)) {
-                String type = getVariableType(var);
-                vars.add(new Parameter(type, var));
+            else {
+                // propertyNode.getInitialValueExpression().visit(outerVisitor);
+            }
+            expression.getCode().visit(innerVisitor);
+
+            // now any variables declared in the outer context that are referred to
+            // in the inner context need to be copied
+            Set outerDecls = outerVisitor.getDeclaredVariables();
+            outerDecls.addAll(outerVisitor.getParameterSet());
+            Set outerRefs = outerVisitor.getReferencedVariables();
+            Set innerDecls = innerVisitor.getDeclaredVariables();
+            Set innerRefs = innerVisitor.getReferencedVariables();
+
+            Set varSet = new HashSet();
+            for (Iterator iter = innerRefs.iterator(); iter.hasNext();) {
+                String var = (String) iter.next();
+                if (outerDecls.contains(var) && classNode.getField(var) == null) {
+                    String type = getVariableType(var);
+                    vars.add(new Parameter(type, var));
+                    varSet.add(var);
+                }
+            }
+            for (Iterator iter = outerRefs.iterator(); iter.hasNext();) {
+                String var = (String) iter.next();
+                if (innerDecls.contains(var) && classNode.getField(var) == null && !varSet.contains(var)) {
+                    String type = getVariableType(var);
+                    vars.add(new Parameter(type, var));
+                }
             }
-        }
-
-        //        if (!vars.isEmpty()) {
-        //            System.out.println(classNode.getName() + " - closure is copying
-        // variables from outer context: " + vars);
-        //        }
 
+            //            if (!vars.isEmpty()) {
+            //                System.out.println(classNode.getName() + " - closure is copying variables from outer context: " + vars);
+            //            }
+        }
         Parameter[] answer = new Parameter[vars.size()];
         vars.toArray(answer);
         return answer;
@@ -2350,7 +2358,7 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
         Set outerDecls = outerVisitor.getDeclaredVariables();
         Set outerRefs = outerVisitor.getReferencedVariables();
         Set innerDecls = innerVisitor.getDeclaredVariables();
-        //Set innerRefs = innerVisitor.getReferencedVariables();
+        Set innerRefs = innerVisitor.getReferencedVariables();
 
         mutableVars.clear();
 
@@ -2360,6 +2368,15 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
                 mutableVars.add(var);
             }
         }
+
+        // we may call the closure twice and modify the variable in the outer scope
+        // so for now lets assume that all variables are mutable
+        for (Iterator iter = innerRefs.iterator(); iter.hasNext();) {
+            String var = (String) iter.next();
+            if (outerDecls.contains(var) && classNode.getField(var) == null) {
+                mutableVars.add(var);
+            }
+        }
     }
 
     protected String getVariableType(String name) {
diff --git a/src/main/org/codehaus/groovy/classgen/VariableScopeCodeVisitor.java b/src/main/org/codehaus/groovy/classgen/VariableScopeCodeVisitor.java
index 2238dc002a..8272379220 100644
--- a/src/main/org/codehaus/groovy/classgen/VariableScopeCodeVisitor.java
+++ b/src/main/org/codehaus/groovy/classgen/VariableScopeCodeVisitor.java
@@ -53,6 +53,7 @@ import org.codehaus.groovy.ast.Parameter;
 import org.codehaus.groovy.ast.expr.BinaryExpression;
 import org.codehaus.groovy.ast.expr.ClosureExpression;
 import org.codehaus.groovy.ast.expr.Expression;
+import org.codehaus.groovy.ast.expr.MethodCallExpression;
 import org.codehaus.groovy.ast.expr.PostfixExpression;
 import org.codehaus.groovy.ast.expr.PrefixExpression;
 import org.codehaus.groovy.ast.expr.VariableExpression;
@@ -139,6 +140,13 @@ public class VariableScopeCodeVisitor extends CodeVisitorSupport {
         }
     }
 
+    public void visitMethodCallExpression(MethodCallExpression call) {
+        if (call.isImplicitThis()) {
+            referencedVariables.add(call.getMethod());
+        }
+        super.visitMethodCallExpression(call);
+    }
+
     protected void setParameters(Parameter[] parameters) {
         parameterSet.clear();
         for (int i = 0; i < parameters.length; i++) {
diff --git a/src/main/org/codehaus/groovy/classgen/Verifier.java b/src/main/org/codehaus/groovy/classgen/Verifier.java
index 7994dae2ab..4ae474c341 100644
--- a/src/main/org/codehaus/groovy/classgen/Verifier.java
+++ b/src/main/org/codehaus/groovy/classgen/Verifier.java
@@ -45,6 +45,8 @@
  */
 package org.codehaus.groovy.classgen;
 
+import groovy.lang.Closure;
+import groovy.lang.GString;
 import groovy.lang.GroovyObject;
 import groovy.lang.MetaClass;
 import groovy.lang.Script;
@@ -130,9 +132,13 @@ public class Verifier implements GroovyClassVisitor, Constants {
             Parameter.EMPTY_ARRAY,
             new BlockStatement(new Statement[] { initMetaClassField, new ReturnStatement(metaClassVar)}));
 
+        // @todo we should check if the base class implements the invokeMethod method
+
         // lets add the invokeMethod implementation
+        String superClass = node.getSuperClass();
         boolean addDelegateObject =
-            node instanceof InnerClassNode && node.getSuperClass().equals("groovy.lang.Closure");
+            (node instanceof InnerClassNode && superClass.equals(Closure.class.getName()))
+                || superClass.equals(GString.class.getName());
 
         // don't do anything as the base class implements the invokeMethod
         if (!addDelegateObject) {
@@ -157,7 +163,7 @@ public class Verifier implements GroovyClassVisitor, Constants {
                                         new VariableExpression("arguments")})))
             }));
 
-            if (!node.getSuperClass().equals(Script.class.getName())) {
+            if (!superClass.equals(Script.class.getName())) {
                 node.addMethod(
                     "getProperty",
                     ACC_PUBLIC,
diff --git a/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java b/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
index d7e7f211cd..414a62cadd 100644
--- a/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
+++ b/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
@@ -51,7 +51,11 @@ import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.FileWriter;
 import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
 import java.io.PrintWriter;
+import java.io.Reader;
+import java.io.Writer;
 import java.lang.reflect.Array;
 import java.lang.reflect.Field;
 import java.lang.reflect.Modifier;
@@ -75,6 +79,7 @@ import java.util.SortedMap;
 import java.util.SortedSet;
 import java.util.StringTokenizer;
 import java.util.TreeSet;
+import java.util.logging.Logger;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
@@ -91,6 +96,8 @@ import java.util.regex.Pattern;
  */
 public class DefaultGroovyMethods {
 
+    private static Logger log = Logger.getLogger(DefaultGroovyMethods.class.getName());
+
     private static final Integer ONE = new Integer(1);
 
     /**
@@ -287,6 +294,19 @@ public class DefaultGroovyMethods {
         return false;
     }
 
+    /**
+     * @return the number of occurrencies of the given value inside this collection
+     */
+    public static int count(Collection self, Object value) {
+        int answer = 0;
+        for (Iterator iter = self.iterator(); iter.hasNext();) {
+            if (InvokerHelper.compareEqual(iter.next(), value)) {
+                ++answer;
+            }
+        }
+        return answer;
+    }
+
     /**
      * Maps the values of a collection to new values using the
      * 
@@ -577,27 +597,26 @@ public class DefaultGroovyMethods {
      * @param text
      * @return the Character object at the given index
      */
-    public static CharSequence get(CharSequence text, int index) {
+    public static CharSequence getAt(CharSequence text, int index) {
         index = normaliseIndex(index, text.length());
         return text.subSequence(index, index + 1);
     }
-    
+
     /**
      * Support the subscript operator for String
      * 
      * @param text
      * @return the Character object at the given index
      */
-    public static String get(String text, int index) {
+    public static String getAt(String text, int index) {
         index = normaliseIndex(index, text.length());
         return text.substring(index, index + 1);
     }
-    
 
     /**
      * Support the range subscript operator for CharSequence
      */
-    public static CharSequence get(CharSequence text, Range range) {
+    public static CharSequence getAt(CharSequence text, Range range) {
         int from = normaliseIndex(InvokerHelper.asInt(range.getFrom()), text.length());
         int to = normaliseIndex(InvokerHelper.asInt(range.getTo()), text.length());
         int length = text.length();
@@ -615,7 +634,7 @@ public class DefaultGroovyMethods {
     /**
      * Support the range subscript operator for String
      */
-    public static String get(String text, Range range) {
+    public static String getAt(String text, Range range) {
         int from = normaliseIndex(InvokerHelper.asInt(range.getFrom()), text.length());
         int to = normaliseIndex(InvokerHelper.asInt(range.getTo()), text.length());
         int length = text.length();
@@ -635,7 +654,7 @@ public class DefaultGroovyMethods {
      * 
      * @returns the group at the given index
      */
-    public static String get(Matcher matcher, int idx) {
+    public static String getAt(Matcher matcher, int idx) {
         matcher.reset();
         idx = normaliseIndex(idx, matcher.groupCount());
 
@@ -661,7 +680,7 @@ public class DefaultGroovyMethods {
      * @returns a range of a list from the range's from index up to but not
      * including the ranges's to value
      */
-    public static List get(List list, Range range) {
+    public static List getAt(List list, Range range) {
         return list.subList(InvokerHelper.asInt(range.getFrom()), InvokerHelper.asInt(range.getTo()) + 1);
     }
 
@@ -670,19 +689,19 @@ public class DefaultGroovyMethods {
      * 
      * @returns a new list of the values at the given indices
      */
-    public static List get(List self, Collection indices) {
+    public static List getAt(List self, Collection indices) {
         List answer = new ArrayList(indices.size());
         for (Iterator iter = indices.iterator(); iter.hasNext();) {
             Object value = iter.next();
             if (value instanceof Range) {
-                answer.addAll(get(self, (Range) value));
+                answer.addAll(getAt(self, (Range) value));
             }
             else if (value instanceof List) {
-                answer.addAll(get(self, (List) value));
+                answer.addAll(getAt(self, (List) value));
             }
             else {
                 int idx = InvokerHelper.asInt(value);
-                answer.add(self.get(idx));
+                answer.add(getAt(self, idx));
             }
         }
         return answer;
@@ -693,19 +712,19 @@ public class DefaultGroovyMethods {
      * 
      * @returns a new list of the values at the given indices
      */
-    public static List get(Object[] self, Collection indices) {
+    public static List getAt(Object[] self, Collection indices) {
         List answer = new ArrayList(indices.size());
         for (Iterator iter = indices.iterator(); iter.hasNext();) {
             Object value = iter.next();
             if (value instanceof Range) {
-                answer.addAll(get(self, (Range) value));
+                answer.addAll(getAt(self, (Range) value));
             }
             else if (value instanceof Collection) {
-                answer.addAll(get(self, (Collection) value));
+                answer.addAll(getAt(self, (Collection) value));
             }
             else {
                 int idx = InvokerHelper.asInt(value);
-                answer.add(get(self, idx));
+                answer.add(getAt(self, idx));
             }
         }
         return answer;
@@ -716,51 +735,51 @@ public class DefaultGroovyMethods {
      * 
      * @returns a String of the values at the given indices
      */
-    public static CharSequence get(CharSequence self, Collection indices) {
+    public static CharSequence getAt(CharSequence self, Collection indices) {
         StringBuffer answer = new StringBuffer();
         for (Iterator iter = indices.iterator(); iter.hasNext();) {
             Object value = iter.next();
             if (value instanceof Range) {
-                answer.append(get(self, (Range) value));
+                answer.append(getAt(self, (Range) value));
             }
             else if (value instanceof Collection) {
-                answer.append(get(self, (Collection) value));
+                answer.append(getAt(self, (Collection) value));
             }
             else {
                 int idx = InvokerHelper.asInt(value);
-                answer.append(get(self, idx));
+                answer.append(getAt(self, idx));
             }
         }
         return answer.toString();
     }
-    
+
     /**
      * Allows a List to be used as the indices to be used on a String
      * 
      * @returns a String of the values at the given indices
      */
-    public static String get(String self, Collection indices) {
-        return (String) get((CharSequence) self, indices);
+    public static String getAt(String self, Collection indices) {
+        return (String) getAt((CharSequence) self, indices);
     }
-        
+
     /**
      * Allows a List to be used as the indices to be used on a Matcher
      * 
      * @returns a String of the values at the given indices
      */
-    public static String get(Matcher self, Collection indices) {
+    public static String getAt(Matcher self, Collection indices) {
         StringBuffer answer = new StringBuffer();
         for (Iterator iter = indices.iterator(); iter.hasNext();) {
             Object value = iter.next();
             if (value instanceof Range) {
-                answer.append(get(self, (Range) value));
+                answer.append(getAt(self, (Range) value));
             }
             else if (value instanceof Collection) {
-                answer.append(get(self, (Collection) value));
+                answer.append(getAt(self, (Collection) value));
             }
             else {
                 int idx = InvokerHelper.asInt(value);
-                answer.append(get(self, idx));
+                answer.append(getAt(self, idx));
             }
         }
         return answer.toString();
@@ -787,9 +806,9 @@ public class DefaultGroovyMethods {
      * @returns a range of a list from the range's from index up to but not
      * including the ranges's to value
      */
-    public static List get(Object[] array, Range range) {
+    public static List getAt(Object[] array, Range range) {
         List list = Arrays.asList(array);
-        return get(list, range);
+        return getAt(list, range);
     }
 
     /**
@@ -797,7 +816,7 @@ public class DefaultGroovyMethods {
      * 
      * @returns the value at the given index
      */
-    public static Object get(Object[] array, int idx) {
+    public static Object getAt(Object[] array, int idx) {
         return array[normaliseIndex(idx, array.length)];
     }
 
@@ -805,14 +824,44 @@ public class DefaultGroovyMethods {
      * Support the subscript operator for an Array
      *  
      */
-    public static void put(Object[] array, int idx, Object value) {
+    public static void putAt(Object[] array, int idx, Object value) {
         array[normaliseIndex(idx, array.length)] = value;
     }
 
+    /**
+     * Allows conversion of arrays into a mutable List
+     * 
+     * @returns the array as a List
+     */
+    public static List toList(Object[] array) {
+        int size = array.length;
+        List list = new ArrayList(size);
+        for (int i = 0; i < size; i++) {
+            list.add(array[i]);
+        }
+        return list;
+    }
+
+    /**
+     * Support the subscript operator for a List
+     * 
+     * @returns the value at the given index
+     */
+    public static Object getAt(List self, int idx) {
+        int size = self.size();
+        int i = normaliseIndex(idx, size);
+        if (i < size) {
+            return self.get(i);
+        }
+        else {
+            return null;
+        }
+    }
+
     /**
      * A helper method to allow lists to work with subscript operators
      */
-    public static void put(List self, int i, Object value) {
+    public static void putAt(List self, int i, Object value) {
         int size = self.size();
         i = normaliseIndex(i, size);
         if (i < size) {
@@ -826,6 +875,22 @@ public class DefaultGroovyMethods {
         }
     }
 
+    /**
+     * Support the subscript operator for a List
+     * 
+     * @returns the value at the given index
+     */
+    public static Object getAt(Map self, Object key) {
+        return self.get(key);
+    }
+
+    /**
+     * A helper method to allow lists to work with subscript operators
+     */
+    public static Object putAt(Map self, Object key, Object value) {
+        return self.put(key, value);
+    }
+
     protected static int normaliseIndex(int i, int size) {
         while (i < 0) {
             i += size;
@@ -838,7 +903,7 @@ public class DefaultGroovyMethods {
      * 
      * @return
      */
-    public static List get(Collection coll, String property) {
+    public static List getAt(Collection coll, String property) {
         List answer = new ArrayList(coll.size());
         for (Iterator iter = coll.iterator(); iter.hasNext();) {
             Object item = iter.next();
@@ -1069,92 +1134,92 @@ public class DefaultGroovyMethods {
     // Primitive type array methods
     //-------------------------------------------------------------------------
 
-    public static Object get(byte[] array, int idx) {
+    public static Object getAt(byte[] array, int idx) {
         return primitiveArrayGet(array, idx);
     }
-    public static Object get(char[] array, int idx) {
+    public static Object getAt(char[] array, int idx) {
         return primitiveArrayGet(array, idx);
     }
-    public static Object get(short[] array, int idx) {
+    public static Object getAt(short[] array, int idx) {
         return primitiveArrayGet(array, idx);
     }
-    public static Object get(int[] array, int idx) {
+    public static Object getAt(int[] array, int idx) {
         return primitiveArrayGet(array, idx);
     }
-    public static Object get(long[] array, int idx) {
+    public static Object getAt(long[] array, int idx) {
         return primitiveArrayGet(array, idx);
     }
-    public static Object get(float[] array, int idx) {
+    public static Object getAt(float[] array, int idx) {
         return primitiveArrayGet(array, idx);
     }
-    public static Object get(double[] array, int idx) {
+    public static Object getAt(double[] array, int idx) {
         return primitiveArrayGet(array, idx);
     }
 
-    public static Object get(byte[] array, Range range) {
+    public static Object getAt(byte[] array, Range range) {
         return primitiveArrayGet(array, range);
     }
-    public static Object get(char[] array, Range range) {
+    public static Object getAt(char[] array, Range range) {
         return primitiveArrayGet(array, range);
     }
-    public static Object get(short[] array, Range range) {
+    public static Object getAt(short[] array, Range range) {
         return primitiveArrayGet(array, range);
     }
-    public static Object get(int[] array, Range range) {
+    public static Object getAt(int[] array, Range range) {
         return primitiveArrayGet(array, range);
     }
-    public static Object get(long[] array, Range range) {
+    public static Object getAt(long[] array, Range range) {
         return primitiveArrayGet(array, range);
     }
-    public static Object get(float[] array, Range range) {
+    public static Object getAt(float[] array, Range range) {
         return primitiveArrayGet(array, range);
     }
-    public static Object get(double[] array, Range range) {
+    public static Object getAt(double[] array, Range range) {
         return primitiveArrayGet(array, range);
     }
 
-    public static Object get(byte[] array, Collection indices) {
+    public static Object getAt(byte[] array, Collection indices) {
         return primitiveArrayGet(array, indices);
     }
-    public static Object get(char[] array, Collection indices) {
+    public static Object getAt(char[] array, Collection indices) {
         return primitiveArrayGet(array, indices);
     }
-    public static Object get(short[] array, Collection indices) {
+    public static Object getAt(short[] array, Collection indices) {
         return primitiveArrayGet(array, indices);
     }
-    public static Object get(int[] array, Collection indices) {
+    public static Object getAt(int[] array, Collection indices) {
         return primitiveArrayGet(array, indices);
     }
-    public static Object get(long[] array, Collection indices) {
+    public static Object getAt(long[] array, Collection indices) {
         return primitiveArrayGet(array, indices);
     }
-    public static Object get(float[] array, Collection indices) {
+    public static Object getAt(float[] array, Collection indices) {
         return primitiveArrayGet(array, indices);
     }
-    public static Object get(double[] array, Collection indices) {
+    public static Object getAt(double[] array, Collection indices) {
         return primitiveArrayGet(array, indices);
     }
 
-    public static void put(byte[] array, int idx, Object newValue) {
+    public static void putAt(byte[] array, int idx, Object newValue) {
         primitiveArrayPut(array, idx, newValue);
     }
 
-    public static void put(char[] array, int idx, Object newValue) {
+    public static void putAt(char[] array, int idx, Object newValue) {
         primitiveArrayPut(array, idx, newValue);
     }
-    public static void put(short[] array, int idx, Object newValue) {
+    public static void putAt(short[] array, int idx, Object newValue) {
         primitiveArrayPut(array, idx, newValue);
     }
-    public static void put(int[] array, int idx, Object newValue) {
+    public static void putAt(int[] array, int idx, Object newValue) {
         primitiveArrayPut(array, idx, newValue);
     }
-    public static void put(long[] array, int idx, Object newValue) {
+    public static void putAt(long[] array, int idx, Object newValue) {
         primitiveArrayPut(array, idx, newValue);
     }
-    public static void put(float[] array, int idx, Object newValue) {
+    public static void putAt(float[] array, int idx, Object newValue) {
         primitiveArrayPut(array, idx, newValue);
     }
-    public static void put(double[] array, int idx, Object newValue) {
+    public static void putAt(double[] array, int idx, Object newValue) {
         primitiveArrayPut(array, idx, newValue);
     }
 
@@ -1180,15 +1245,37 @@ public class DefaultGroovyMethods {
         return Array.getLength(array);
     }
 
+    public static List toList(byte[] array) {
+        return primitiveArrayToList(array);
+    }
+    public static List toList(char[] array) {
+        return primitiveArrayToList(array);
+    }
+    public static List toList(short[] array) {
+        return primitiveArrayToList(array);
+    }
+    public static List toList(int[] array) {
+        return primitiveArrayToList(array);
+    }
+    public static List toList(long[] array) {
+        return primitiveArrayToList(array);
+    }
+    public static List toList(float[] array) {
+        return primitiveArrayToList(array);
+    }
+    public static List toList(double[] array) {
+        return primitiveArrayToList(array);
+    }
+
     /**
-     * Implements the get(int) method for primitve type arrays
+     * Implements the getAt(int) method for primitve type arrays
      */
     protected static Object primitiveArrayGet(Object array, int idx) {
         return Array.get(array, normaliseIndex(idx, Array.getLength(array)));
     }
 
     /**
-     * Implements the get(Range) method for primitve type arrays
+     * Implements the getAt(Range) method for primitve type arrays
      */
     protected static List primitiveArrayGet(Object array, Range range) {
         List answer = new ArrayList();
@@ -1200,7 +1287,7 @@ public class DefaultGroovyMethods {
     }
 
     /**
-     * Implements the get(Collection) method for primitve type arrays
+     * Implements the getAt(Collection) method for primitve type arrays
      */
     protected static List primitiveArrayGet(Object self, Collection indices) {
         List answer = new ArrayList();
@@ -1227,6 +1314,20 @@ public class DefaultGroovyMethods {
         Array.set(array, normaliseIndex(idx, Array.getLength(array)), newValue);
     }
 
+    /**
+     * Allows conversion of arrays into a mutable List
+     * 
+     * @returns the array as a List
+     */
+    protected static List primitiveArrayToList(Object array) {
+        int size = Array.getLength(array);
+        List list = new ArrayList(size);
+        for (int i = 0; i < size; i++) {
+            list.add(Array.get(array, i));
+        }
+        return list;
+    }
+
     // String methods
     //-------------------------------------------------------------------------
     public static Object tokenize(String self, String token) {
@@ -1238,8 +1339,8 @@ public class DefaultGroovyMethods {
     }
 
     public static String plus(String left, Object value) {
-        return left + value;
-        //return left + toString(value);
+        //return left + value;
+        return left + toString(value);
     }
 
     public static String minus(String left, Object value) {
@@ -1247,6 +1348,34 @@ public class DefaultGroovyMethods {
         return left.replaceFirst(text, "");
     }
 
+    /**
+     * Provide an implementation of contains() like Collection to make Strings more polymorphic
+     * This method is not required on JDK 1.5 onwards
+     * 
+     * @return true if this string contains the given text
+     */
+    public static boolean contains(String self, String text) {
+        int idx = self.indexOf(text);
+        return idx >= 0;
+    }
+
+    /**
+     * @return the number of occurrencies of the given string inside this String
+     */
+    public static int count(String self, String text) {
+        int answer = 0;
+        for (int idx = 0; true; idx++) {
+            idx = self.indexOf(text, idx);
+            if (idx >= 0) {
+                ++answer;
+            }
+            else {
+                break;
+            }
+        }
+        return answer;
+    }
+
     public static String multiply(String self, Number factor) {
         int size = factor.intValue();
         if (size < 1) {
@@ -1287,6 +1416,37 @@ public class DefaultGroovyMethods {
         }
     }
 
+    public static int compareTo(Number left, Number right) {
+        /** @todo maybe a double dispatch thing to handle new large numbers? */
+        if (isFloatingPoint(left) || isFloatingPoint(right)) {
+            double diff = left.doubleValue() - right.doubleValue();
+            if (diff == 0) {
+                return 0;
+            }
+            else {
+                return (diff > 0) ? 1 : -1;
+            }
+        }
+        else if (isLong(left) || isLong(right)) {
+            long diff = left.longValue() - right.longValue();
+            if (diff == 0) {
+                return 0;
+            }
+            else {
+                return (diff > 0) ? 1 : -1;
+            }
+        }
+        else {
+            int diff = left.intValue() - right.intValue();
+            if (diff == 0) {
+                return 0;
+            }
+            else {
+                return (diff > 0) ? 1 : -1;
+            }
+        }
+    }
+
     public static Number minus(Number left, Number right) {
         if (isFloatingPoint(left) || isFloatingPoint(right)) {
             return new Double(left.doubleValue() - right.doubleValue());
@@ -1463,6 +1623,19 @@ public class DefaultGroovyMethods {
         return new BufferedOutputStream(new FileOutputStream(file));
     }
 
+    /**
+     * Helper method to create a new OutputStream for a file and then 
+     * passes it into the closure and ensures its closed again afterwords
+     * 
+     * @param file
+     * @return @throws
+     *         FileNotFoundException
+     */
+    public static void eachOutputStream(File file, Closure closure) throws IOException {
+        useStream(newOutputStream(file), closure);
+    }
+
+    
     /**
      * Helper method to create a buffered writer for a file
      * 
@@ -1474,6 +1647,164 @@ public class DefaultGroovyMethods {
         return new BufferedWriter(new FileWriter(file));
     }
 
+    /**
+     * Helper method to create a new BufferedWriter for a file and then 
+     * passes it into the closure and ensures its closed again afterwords
+     * 
+     * @param file
+     * @return @throws
+     *         FileNotFoundException
+     */
+    public static void eachWriter(File file, Closure closure) throws IOException {
+        useWriter(newWriter(file), closure);
+    }
+    /**
+     * Helper method to create a new PrintWriter for a file
+     * 
+     * @param file
+     * @return @throws
+     *         FileNotFoundException
+     */
+    public static PrintWriter newPrintWriter(File file) throws IOException {
+        return new PrintWriter(newWriter(file));
+    }
+
+    /**
+     * Helper method to create a new PrintWriter for a file and then 
+     * passes it into the closure and ensures its closed again afterwords
+     * 
+     * @param file
+     * @return @throws
+     *         FileNotFoundException
+     */
+    public static void eachPrintWriter(File file, Closure closure) throws IOException {
+        useWriter(newPrintWriter(file), closure);
+    }
+
+    /**
+     * Allows a writer to be used, calling the closure with the writer
+     * and then ensuring that the writer is closed down again irrespective
+     * of whether exceptions occur or the 
+     * 
+     * @param writer the writer which is used and then closed
+     * @param closure the closure that the writer is passed into 
+     * @throws IOException
+     */
+    public static void useWriter(Writer writer, Closure closure) throws IOException {
+        try {
+            closure.call(writer);
+            
+            // lets try close the writer & throw the exception if it fails
+            // but not try to reclose it in the finally block
+            Writer temp = writer;
+            writer = null;
+            temp.close();
+        }
+        finally {
+            if (writer != null) {
+                try {
+                    writer.close();
+                }
+                catch (IOException e) {
+                    log.warning("Caught exception closing writer: " + e);
+                }
+            }
+        }
+    }
+    
+    /**
+     * Allows a Reader to be used, calling the closure with the writer
+     * and then ensuring that the writer is closed down again irrespective
+     * of whether exceptions occur or the 
+     * 
+     * @param writer the writer which is used and then closed
+     * @param closure the closure that the writer is passed into 
+     * @throws IOException
+     */
+    public static void useReader(Reader writer, Closure closure) throws IOException {
+        try {
+            closure.call(writer);
+            
+            // lets try close the writer & throw the exception if it fails
+            // but not try to reclose it in the finally block
+            Reader temp = writer;
+            writer = null;
+            temp.close();
+        }
+        finally {
+            if (writer != null) {
+                try {
+                    writer.close();
+                }
+                catch (IOException e) {
+                    log.warning("Caught exception closing writer: " + e);
+                }
+            }
+        }
+    }
+    
+    /**
+     * Allows a InputStream to be used, calling the closure with the stream
+     * and then ensuring that the stream is closed down again irrespective
+     * of whether exceptions occur or the 
+     * 
+     * @param stream the stream which is used and then closed
+     * @param closure the closure that the stream is passed into 
+     * @throws IOException
+     */
+    public static void useStream(InputStream stream, Closure closure) throws IOException {
+        try {
+            closure.call(stream);
+            
+            // lets try close the stream & throw the exception if it fails
+            // but not try to reclose it in the finally block
+            InputStream temp = stream;
+            stream = null;
+            temp.close();
+        }
+        finally {
+            if (stream != null) {
+                try {
+                    stream.close();
+                }
+                catch (IOException e) {
+                    log.warning("Caught exception closing stream: " + e);
+                }
+            }
+        }
+    }
+    
+    /**
+     * Allows a OutputStream to be used, calling the closure with the stream
+     * and then ensuring that the stream is closed down again irrespective
+     * of whether exceptions occur or the 
+     * 
+     * @param stream the stream which is used and then closed
+     * @param closure the closure that the stream is passed into 
+     * @throws IOException
+     */
+    public static void useStream(OutputStream stream, Closure closure) throws IOException {
+        try {
+            closure.call(stream);
+            
+            // lets try close the stream & throw the exception if it fails
+            // but not try to reclose it in the finally block
+            OutputStream temp = stream;
+            stream = null;
+            temp.close();
+        }
+        finally {
+            if (stream != null) {
+                try {
+                    stream.close();
+                }
+                catch (IOException e) {
+                    log.warning("Caught exception closing stream: " + e);
+                }
+            }
+        }
+    }
+    
     /**
      * Helper method to create a buffered input stream for a file
      *
diff --git a/src/main/org/codehaus/groovy/runtime/Invoker.java b/src/main/org/codehaus/groovy/runtime/Invoker.java
index 7c55adddd6..080fdcdc02 100644
--- a/src/main/org/codehaus/groovy/runtime/Invoker.java
+++ b/src/main/org/codehaus/groovy/runtime/Invoker.java
@@ -136,7 +136,7 @@ public class Invoker {
     }
 
     public Object invokeConstructor(String type, Object arguments) {
-        System.out.println("Invoking constructor of type: " + type);
+        //System.out.println("Invoking constructor of type: " + type);
         return invokeConstructorOf(loadClass(type), arguments);
     }
 
@@ -269,15 +269,14 @@ public class Invoker {
      */
     public int compareTo(Object left, Object right) {
         //System.out.println("Comparing: " + left + " to: " + right);
-
-        if (left instanceof Float)
-            left = new Double(((Float) left).doubleValue());
-        if (right instanceof Float)
-            right = new Double(((Float) left).doubleValue());
-
         if (left instanceof Comparable) {
-            Comparable comparable = (Comparable) left;
-            return comparable.compareTo(right);
+            if (left instanceof Number) {
+                return DefaultGroovyMethods.compareTo((Number) left, asNumber(right));
+            }
+            else {
+                Comparable comparable = (Comparable) left;
+                return comparable.compareTo(right);
+            }
         }
         /** todo we might wanna do some type conversion here */
         throw new GroovyRuntimeException("Cannot compare values: " + left + " and " + " right");
@@ -316,7 +315,7 @@ public class Invoker {
     public String inspect(Object self) {
         return format(self, true);
     }
-    
+
     /**
      * A helper method to provide some better toString() behaviour such as turning arrays
      * into tuples
@@ -324,7 +323,7 @@ public class Invoker {
     public String toString(Object arguments) {
         return format(arguments, false);
     }
-    
+
     protected String format(Object arguments, boolean verbose) {
         if (arguments == null) {
             return "null";
@@ -400,8 +399,6 @@ public class Invoker {
         }
     }
 
-
-    
     /**
      * Sets the property on the given object
      * 
@@ -459,6 +456,18 @@ public class Invoker {
         throw new GroovyRuntimeException("Could not convert object: " + value + " into an int");
     }
 
+    public Number asNumber(Object value) {
+        if (value instanceof Number) {
+            return (Number) value;
+        }
+        else if (value instanceof String) {
+            return Double.valueOf((String) value);
+        }
+        else {
+            throw new GroovyRuntimeException("Could not convert object: " + value + " into a Number");
+        }
+    }
+
     /**
      * Attempts to load the given class via name using the current class loader
      * for this code or the thread context class loader
diff --git a/src/main/org/codehaus/groovy/runtime/InvokerHelper.java b/src/main/org/codehaus/groovy/runtime/InvokerHelper.java
index b5e0131063..64a3d52e3d 100644
--- a/src/main/org/codehaus/groovy/runtime/InvokerHelper.java
+++ b/src/main/org/codehaus/groovy/runtime/InvokerHelper.java
@@ -291,7 +291,20 @@ public class InvokerHelper {
     public static Script createScript(Class scriptClass, Binding context) {
         try {
             Constructor constructor = scriptClass.getConstructor(new Class[] {});
-            Script script = (Script) constructor.newInstance(new Object[] {});
+            final GroovyObject object = (GroovyObject) constructor.newInstance(new Object[] {});
+            Script script = null;
+            if (object instanceof Script) {
+                script = (Script) object;
+            }
+            else {
+                // it could just be a class, so lets wrap it in a Script wrapper
+                // though the bindings will be ignored
+                script = new Script() {
+                    public Object run() {
+                        object.invokeMethod("main", new Object[] { new String[0] });
+                        return null;
+                    } };
+            }
             Method setBindings = script.getClass().getMethod("setBindings", new Class[] { Binding.class });
             setBindings.invoke(script, new Object[] { context });
             return script;
diff --git a/src/main/org/codehaus/groovy/runtime/InvokerInvocationException.java b/src/main/org/codehaus/groovy/runtime/InvokerInvocationException.java
index 178e443037..76a74f5485 100644
--- a/src/main/org/codehaus/groovy/runtime/InvokerInvocationException.java
+++ b/src/main/org/codehaus/groovy/runtime/InvokerInvocationException.java
@@ -58,7 +58,7 @@ import java.lang.reflect.InvocationTargetException;
 public class InvokerInvocationException extends GroovyRuntimeException {
 
     public InvokerInvocationException(InvocationTargetException e) {
-        super(e.getTargetException().getMessage(), e.getTargetException());
+        super(e.getTargetException().toString(), e.getTargetException());
     }
 
 }
diff --git a/src/main/org/codehaus/groovy/syntax/lexer/Lexer.java b/src/main/org/codehaus/groovy/syntax/lexer/Lexer.java
index c9a5a0f882..eae9fac461 100644
--- a/src/main/org/codehaus/groovy/syntax/lexer/Lexer.java
+++ b/src/main/org/codehaus/groovy/syntax/lexer/Lexer.java
@@ -11,1107 +11,989 @@ import org.codehaus.groovy.syntax.Token;
  * @author James Strachan
  * @author John Wilson
  */
-public class Lexer
-{
-	private final char[] buf = new char[5];
-	private final int[] charWidth = new int[buf.length];
-	private int cur = 0;
-	private int charsInBuffer = 0;
-	private boolean eosRead = false;
-	private boolean escapeLookahead = false;
-	private char escapeLookaheadChar;
-	
-	private int line;
+public class Lexer {
+    private final char[] buf = new char[5];
+    private final int[] charWidth = new int[buf.length];
+    private int cur = 0;
+    private int charsInBuffer = 0;
+    private boolean eosRead = false;
+    private boolean escapeLookahead = false;
+    private char escapeLookaheadChar;
+
+    private int line;
     private int column;
 
     private int startLine;
     private int startColumn;
-    
+
     private CharStream charStream;
 
-    public Lexer(CharStream charStream)
-    {
+    public Lexer(CharStream charStream) {
         this.charStream = charStream;
-        this.line   = 1;
+        this.line = 1;
         this.column = 1;
     }
 
-    public CharStream getCharStream()
-    {
+    public CharStream getCharStream() {
         return this.charStream;
     }
 
-    public Token nextToken()
-        throws IOException, LexerException
-    {
+    public Token nextToken() throws IOException, LexerException {
         Token token = null;
 
-      OUTER_LOOP:
-        while ( token == null )
-        {
+        OUTER_LOOP : while (token == null) {
             char c = la();
 
-          ROOT_SWITCH:
-            switch ( c )
-            {
-                case ( CharStream.EOS ):
-                {
-                    break OUTER_LOOP;
-                }
-                case ( ' ' ):
-                case ( '\t' ):
-                {
-                    consume();
-                    token = null;
-                    break ROOT_SWITCH;
-                }
-                case ( '\r' ):
-                {
-                    consume();
-                    if ( la() == '\n' )
+            ROOT_SWITCH : switch (c) {
+                case (CharStream.EOS) :
                     {
-                        consume();
-                        token = Token.newline( getStartLine(),
-                                              getStartColumn() );
+                        break OUTER_LOOP;
                     }
-                    else
+                case (' ') :
+                case ('\t') :
                     {
+                        consume();
                         token = null;
+                        break ROOT_SWITCH;
                     }
-                    eol();
-                    break ROOT_SWITCH;
-                }
-                case ( '\n' ):
-                {
-                    consume();
-                    if ( la() == '\r')
+                case ('\r') :
                     {
                         consume();
+                        if (la() == '\n') {
+                            consume();
+                            token = Token.newline(getStartLine(), getStartColumn());
+                        }
+                        else {
+                            token = null;
+                        }
+                        eol();
+                        break ROOT_SWITCH;
                     }
-                    eol();
-                    token = Token.newline( getStartLine(),
-                            getStartColumn() );
-                    break ROOT_SWITCH;
-                }
-                case ( '{' ):
-                {
-                    mark();
-                    consume();
-                    token = Token.leftCurlyBrace( getStartLine(),
-                                                  getStartColumn() );
-                    break ROOT_SWITCH;
-                }
-                case ( '}' ):
-                {
-                    mark();
-                    consume();
-                    token = Token.rightCurlyBrace( getStartLine(),
-                                                   getStartColumn() );
-                    break ROOT_SWITCH;
-                }
-                case ( '[' ):
-                {
-                    mark();
-                    consume();
-                    token = Token.leftSquareBracket( getStartLine(),
-                                                     getStartColumn() );
-                    break ROOT_SWITCH;
-                }
-                case ( ']' ):
-                {
-                    mark();
-                    consume();
-                    token = Token.rightSquareBracket( getStartLine(),
-                                                      getStartColumn() );
-                    break ROOT_SWITCH;
-                }
-                case ( '(' ):
-                {
-                    mark();
-                    consume();
-                    token = Token.leftParenthesis( getStartLine(),
-                                                   getStartColumn() );
-                    break ROOT_SWITCH;
-                }
-                case ( ')' ):
-                {
-                    mark();
-                    consume();
-                    token = Token.rightParenthesis( getStartLine(),
-                                                    getStartColumn() );
-                    break ROOT_SWITCH;
-                }
-                case ( '.' ):
-                {
-                    mark();
-                    consume();
-                    if ( la() == '.' )
+                case ('\n') :
                     {
                         consume();
-                        token = Token.dotDot( getStartLine(),
-                                              getStartColumn() );
+                        if (la() == '\r') {
+                            consume();
+                        }
+                        eol();
+                        token = Token.newline(getStartLine(), getStartColumn());
+                        break ROOT_SWITCH;
                     }
-                    else
+                case ('{') :
                     {
-                        token = Token.dot( getStartLine(),
-                                           getStartColumn() );
+                        mark();
+                        consume();
+                        token = Token.leftCurlyBrace(getStartLine(), getStartColumn());
+                        break ROOT_SWITCH;
                     }
-                    break ROOT_SWITCH;
-                }
-                case ( '#' ):
-                {
-                    consume();
-
-                  CONSUME_LOOP:
-                    while ( true )
+                case ('}') :
                     {
-                        switch ( la() )
-                        {
-                            case ( '\r' ):
-                            {
-                                consume();
-                                if ( la() == '\n' )
-                                {
-                                    consume();
-                                }
-                                eol();
-                                break CONSUME_LOOP;
-                            }
-                            case ( '\n' ):
-                            {
-                                consume();
-                                eol();
-                                break CONSUME_LOOP;
-                            }
-                            default:
-                            {
-                                consume();
-                            }
-                        }
+                        mark();
+                        consume();
+                        token = Token.rightCurlyBrace(getStartLine(), getStartColumn());
+                        break ROOT_SWITCH;
                     }
-                    token = null;
-                    break ROOT_SWITCH;
-                }
-                case ( '/' ):
-                {
-                    mark();
-                    consume();
-
-                    c = la();
-
-                  MULTICHAR_SWITCH:
-                    switch ( c )
+                case ('[') :
+                    {
+                        mark();
+                        consume();
+                        token = Token.leftSquareBracket(getStartLine(), getStartColumn());
+                        break ROOT_SWITCH;
+                    }
+                case (']') :
+                    {
+                        mark();
+                        consume();
+                        token = Token.rightSquareBracket(getStartLine(), getStartColumn());
+                        break ROOT_SWITCH;
+                    }
+                case ('(') :
+                    {
+                        mark();
+                        consume();
+                        token = Token.leftParenthesis(getStartLine(), getStartColumn());
+                        break ROOT_SWITCH;
+                    }
+                case (')') :
+                    {
+                        mark();
+                        consume();
+                        token = Token.rightParenthesis(getStartLine(), getStartColumn());
+                        break ROOT_SWITCH;
+                    }
+                case ('.') :
                     {
-                        case ( '=' ):
-                        {
+                        mark();
+                        consume();
+                        if (la() == '.') {
                             consume();
-                            token = Token.divideEqual( getStartLine(),
-                                                       getStartColumn() );
-                            break MULTICHAR_SWITCH;
+                            token = Token.dotDot(getStartLine(), getStartColumn());
                         }
-                        case ( '/' ):
-                        {
-                            consume();
+                        else {
+                            token = Token.dot(getStartLine(), getStartColumn());
+                        }
+                        break ROOT_SWITCH;
+                    }
+                case ('#') :
+                    {
+                        consume();
 
-                          CONSUME_LOOP:
-                            while ( true )
-                            {
-                                switch ( la() )
-                                {
-                                    case ( '\r' ):
+                        CONSUME_LOOP : while (true) {
+                            switch (la()) {
+                                case ('\r') :
                                     {
                                         consume();
-                                        if ( la() == '\n' )
-                                        {
+                                        if (la() == '\n') {
                                             consume();
                                         }
                                         eol();
                                         break CONSUME_LOOP;
                                     }
-                                    case ( '\n' ):
+                                case ('\n') :
                                     {
                                         consume();
                                         eol();
                                         break CONSUME_LOOP;
                                     }
-                                    default:
+                                case CharStream.EOS :
+                                    {
+                                        break CONSUME_LOOP;
+                                    }
+                                default :
                                     {
                                         consume();
                                     }
-                                }
                             }
-                            token = null;
-                            break MULTICHAR_SWITCH;
                         }
-                        case ( '*' ):
-                        {
-                          CONSUME_LOOP:
-                            while ( true )
-                            {
-                              CONSUME_SWITCH:
-                                switch ( la() )
+                        token = null;
+                        break ROOT_SWITCH;
+                    }
+                case ('/') :
+                    {
+                        mark();
+                        consume();
+
+                        c = la();
+
+                        MULTICHAR_SWITCH : switch (c) {
+                            case ('=') :
                                 {
-                                    case ( '*' ):
-                                    {
-                                        consume();
-                                        if ( la() == '/' )
-                                        {
-                                            consume();
-                                            break CONSUME_LOOP;
+                                    consume();
+                                    token = Token.divideEqual(getStartLine(), getStartColumn());
+                                    break MULTICHAR_SWITCH;
+                                }
+                            case ('/') :
+                                {
+                                    consume();
+
+                                    CONSUME_LOOP : while (true) {
+                                        switch (la()) {
+                                            case ('\r') :
+                                                {
+                                                    consume();
+                                                    if (la() == '\n') {
+                                                        consume();
+                                                    }
+                                                    eol();
+                                                    break CONSUME_LOOP;
+                                                }
+                                            case ('\n') :
+                                                {
+                                                    consume();
+                                                    eol();
+                                                    break CONSUME_LOOP;
+                                                }
+                                            case CharStream.EOS :
+                                                {
+                                                    break CONSUME_LOOP;
+                                                }
+                                            default :
+                                                {
+                                                    consume();
+                                                }
                                         }
-                                        break CONSUME_SWITCH;
                                     }
-                                    case ( '\r' ):
-                                    {
-                                        consume();
-                                        if ( la() == '\n' )
-                                        {
-                                            consume();
+                                    token = null;
+                                    break MULTICHAR_SWITCH;
+                                }
+                            case ('*') :
+                                {
+                                    CONSUME_LOOP : while (true) {
+                                        CONSUME_SWITCH : switch (la()) {
+                                            case ('*') :
+                                                {
+                                                    consume();
+                                                    if (la() == '/') {
+                                                        consume();
+                                                        break CONSUME_LOOP;
+                                                    }
+                                                    break CONSUME_SWITCH;
+                                                }
+                                            case ('\r') :
+                                                {
+                                                    consume();
+                                                    if (la() == '\n') {
+                                                        consume();
+                                                    }
+                                                    eol();
+                                                    break CONSUME_SWITCH;
+                                                }
+                                            case ('\n') :
+                                                {
+                                                    eol();
+                                                    consume();
+                                                    break CONSUME_SWITCH;
+                                                }
+                                            case CharStream.EOS :
+                                                {
+                                                    break CONSUME_LOOP;
+                                                }
+                                            default :
+                                                {
+                                                    consume();
+                                                }
                                         }
-                                        eol();
-                                        break CONSUME_SWITCH;
-                                    }
-                                    case ( '\n' ):
-                                    {
-                                        eol();
-                                        consume();
-                                        break CONSUME_SWITCH;
-                                    }
-                                    default:
-                                    {
-                                        consume();
                                     }
+                                    token = null;
+                                    break MULTICHAR_SWITCH;
+                                }
+                            default :
+                                {
+                                    token = Token.divide(getStartLine(), getStartColumn());
+                                    break MULTICHAR_SWITCH;
                                 }
-                            }
-                            token = null;
-                            break MULTICHAR_SWITCH;
-                        }
-                        default:
-                        {
-                            token = Token.divide( getStartLine(),
-                                                  getStartColumn() );
-                            break MULTICHAR_SWITCH;
                         }
+                        break ROOT_SWITCH;
                     }
-                    break ROOT_SWITCH;
-                }
-                case ( '%' ):
-                {
-                    mark();
-                    consume();
+                case ('%') :
+                    {
+                        mark();
+                        consume();
 
-                    c = la();
+                        c = la();
 
-                  MULTICHAR_SWITCH:
-                    switch ( c )
-                    {
-                        case ( '=' ):
-                        {
-                            consume();
-                            token = Token.modEqual( getStartLine(),
-                                                    getStartColumn() );
-                            break MULTICHAR_SWITCH;
-                        }
-                        default:
-                        {
-                            token = Token.mod( getStartLine(),
-                                               getStartColumn() );
-                            break MULTICHAR_SWITCH;
+                        MULTICHAR_SWITCH : switch (c) {
+                            case ('=') :
+                                {
+                                    consume();
+                                    token = Token.modEqual(getStartLine(), getStartColumn());
+                                    break MULTICHAR_SWITCH;
+                                }
+                            default :
+                                {
+                                    token = Token.mod(getStartLine(), getStartColumn());
+                                    break MULTICHAR_SWITCH;
+                                }
                         }
+                        break ROOT_SWITCH;
                     }
-                    break ROOT_SWITCH;
-                }
-                case ( '~' ):
-                {
-                	mark();
-                	consume();
-                 	// Support ~<double quoted string>
-                    token = Token.patternRegex( getStartLine(),
-                    							getStartColumn() );
-                    break ROOT_SWITCH;
-                }
-                case ( '!' ):
-                {
-                    mark();
-                    consume();
-
-                    c = la();
-
-                  MULTICHAR_SWITCH:
-                    switch ( c )
+                case ('~') :
                     {
-                        case ( '=' ):
-                        {
-                            consume();
-                            token = Token.compareNotEqual( getStartLine(),
-                                                           getStartColumn() );
-                            break MULTICHAR_SWITCH;
-                        }
-                        default:
-                        {
-                            token = Token.not( getStartLine(),
-                                               getStartColumn() );
-                            break MULTICHAR_SWITCH;
-                        }
+                        mark();
+                        consume();
+                        // Support ~<double quoted string>
+                        token = Token.patternRegex(getStartLine(), getStartColumn());
+                        break ROOT_SWITCH;
                     }
-                    break ROOT_SWITCH;
-                }
-                case ( '=' ):
-                {
-                    mark();
-                    consume();
+                case ('!') :
+                    {
+                        mark();
+                        consume();
 
-                    c = la();
+                        c = la();
 
-                  MULTICHAR_SWITCH:
-                    switch ( c )
+                        MULTICHAR_SWITCH : switch (c) {
+                            case ('=') :
+                                {
+                                    consume();
+                                    token = Token.compareNotEqual(getStartLine(), getStartColumn());
+                                    break MULTICHAR_SWITCH;
+                                }
+                            default :
+                                {
+                                    token = Token.not(getStartLine(), getStartColumn());
+                                    break MULTICHAR_SWITCH;
+                                }
+                        }
+                        break ROOT_SWITCH;
+                    }
+                case ('=') :
                     {
-                        case ( '=' ):
-                        {
-                            consume();
-                            c = la();
+                        mark();
+                        consume();
+
+                        c = la();
 
-                            switch ( c ) {
-                            	case '=':
-                            	{
-                            		consume();
-                           			token = Token.compareIdentical( getStartLine(),
-                           											getStartColumn() );
-                            		break;
+                        MULTICHAR_SWITCH : switch (c) {
+                            case ('=') :
+                                {
+                                    consume();
+                                    c = la();
+
+                                    switch (c) {
+                                        case '=' :
+                                            {
+                                                consume();
+                                                token = Token.compareIdentical(getStartLine(), getStartColumn());
+                                                break;
+                                            }
+                                        case '~' :
+                                            {
+                                                consume();
+                                                token = Token.matchRegex(getStartLine(), getStartColumn());
+                                                break;
+                                            }
+                                        default :
+                                            {
+                                                token = Token.compareEqual(getStartLine(), getStartColumn());
+                                            }
+                                    }
+                                    break MULTICHAR_SWITCH;
                                 }
-                            	case '~':
-                            	{
-                            		consume();
-                            		token = Token.matchRegex( getStartLine(),
-                            								  getStartColumn());
-                            		break;
-                            	}
-                            	default:
+                            case '~' :
                                 {
-                                    token = Token.compareEqual( getStartLine(),
-                                                                getStartColumn() );
-                            	}
-                            }
-                            break MULTICHAR_SWITCH;
-                        }
-                        case '~':
-                        {
-                        	consume();
-                        	token = Token.findRegex( getStartLine(),
-                        			getStartColumn() );
-                        	break MULTICHAR_SWITCH;
-                        }
-                        default:
-                        {
-                            token = Token.equal( getStartLine(),
-                                                 getStartColumn() );
-                            break MULTICHAR_SWITCH;
+                                    consume();
+                                    token = Token.findRegex(getStartLine(), getStartColumn());
+                                    break MULTICHAR_SWITCH;
+                                }
+                            default :
+                                {
+                                    token = Token.equal(getStartLine(), getStartColumn());
+                                    break MULTICHAR_SWITCH;
+                                }
                         }
+                        break ROOT_SWITCH;
                     }
-                    break ROOT_SWITCH;
-                }
-                case ( '&' ):
-                {
-                    mark();
-                    consume();
+                case ('&') :
+                    {
+                        mark();
+                        consume();
 
-                    c = la();
+                        c = la();
 
-                  MULTICHAR_SWITCH:
-                    switch ( c )
-                    {
-                        case ( '&' ):
-                        {
-                            consume();
-                            token = Token.logicalAnd( getStartLine(),
-                                                      getStartColumn() );
-                            break MULTICHAR_SWITCH;
-                        }
-                        default:
-                        {
-                            throw new UnexpectedCharacterException( getStartLine(),
-                                                                    getStartColumn()+1,
-                                                                    c,
-                                                                    new char[] { '&' } );
+                        MULTICHAR_SWITCH : switch (c) {
+                            case ('&') :
+                                {
+                                    consume();
+                                    token = Token.logicalAnd(getStartLine(), getStartColumn());
+                                    break MULTICHAR_SWITCH;
+                                }
+                            default :
+                                {
+                                    throw new UnexpectedCharacterException(
+                                        getStartLine(),
+                                        getStartColumn() + 1,
+                                        c,
+                                        new char[] { '&' });
+                                }
                         }
+                        break ROOT_SWITCH;
                     }
-                    break ROOT_SWITCH;
-                }
-                case ( '|' ):
-                {
-                    mark();
-                    consume();
-                    c = la();
-                    
-                  MULTICHAR_SWITCH:
-                    switch ( c )
+                case ('|') :
                     {
-                        case ( '|' ):
-                        {
-                            consume();
-                            token = Token.logicalOr( getStartLine(),
-                                                     getStartColumn() );
-                            break MULTICHAR_SWITCH;
-                        }
-                        default:
-                        {
-                            token = Token.pipe( getStartLine(),
-                                                getStartColumn() );
-                            break MULTICHAR_SWITCH;
+                        mark();
+                        consume();
+                        c = la();
+
+                        MULTICHAR_SWITCH : switch (c) {
+                            case ('|') :
+                                {
+                                    consume();
+                                    token = Token.logicalOr(getStartLine(), getStartColumn());
+                                    break MULTICHAR_SWITCH;
+                                }
+                            default :
+                                {
+                                    token = Token.pipe(getStartLine(), getStartColumn());
+                                    break MULTICHAR_SWITCH;
+                                }
                         }
+                        break ROOT_SWITCH;
                     }
-                    break ROOT_SWITCH;
-                }
-                case ( '+' ):
-                {
-                    mark();
-                    consume();
-                    
-                    c = la();
-
-                  MULTICHAR_SWITCH:
-                    switch ( c )
+                case ('+') :
                     {
-                        case ( '+' ):
-                        {
-                            consume();
-                            token = Token.plusPlus( getStartLine(),
-                                                    getStartColumn() );
-                            break MULTICHAR_SWITCH;
-                        }
-                        case ( '=' ):
-                        {
-                            consume();
-                            token = Token.plusEqual( getStartLine(),
-                                                     getStartColumn() );
-                            break MULTICHAR_SWITCH;
-                        }
-                        default:
-                        {
-                            token = Token.plus( getStartLine(),
-                                                getStartColumn() );
-                            break MULTICHAR_SWITCH;
+                        mark();
+                        consume();
+
+                        c = la();
+
+                        MULTICHAR_SWITCH : switch (c) {
+                            case ('+') :
+                                {
+                                    consume();
+                                    token = Token.plusPlus(getStartLine(), getStartColumn());
+                                    break MULTICHAR_SWITCH;
+                                }
+                            case ('=') :
+                                {
+                                    consume();
+                                    token = Token.plusEqual(getStartLine(), getStartColumn());
+                                    break MULTICHAR_SWITCH;
+                                }
+                            default :
+                                {
+                                    token = Token.plus(getStartLine(), getStartColumn());
+                                    break MULTICHAR_SWITCH;
+                                }
                         }
+                        break ROOT_SWITCH;
                     }
-                    break ROOT_SWITCH;
-                }
-                case ( '-' ):
-                {
-                    mark();
-                    consume();
+                case ('-') :
+                    {
+                        mark();
+                        consume();
 
-                    c = la();
+                        c = la();
 
-                  MULTICHAR_SWITCH:
-                    switch ( c )
-                    {
-                        case ( '-' ):
-                        {
-                            consume();
-                            token = Token.minusMinus( getStartLine(),
-                                                      getStartColumn() );
-                            break MULTICHAR_SWITCH;
-                        }
-                        case ( '=' ):
-                        {
-                            consume();
-                            token = Token.minusEqual( getStartLine(),
-                                                      getStartColumn() );
-                            break MULTICHAR_SWITCH;
-                        }
-                        case ( '>' ):
-                        {
-                            consume();
-                            token = Token.navigate( getStartLine(),
-                                                    getStartColumn() );
-                            break MULTICHAR_SWITCH;
-                        }
-                        default:
-                        {
-                            token = Token.minus( getStartLine(),
-                                                 getStartColumn() );
-                            break MULTICHAR_SWITCH;
+                        MULTICHAR_SWITCH : switch (c) {
+                            case ('-') :
+                                {
+                                    consume();
+                                    token = Token.minusMinus(getStartLine(), getStartColumn());
+                                    break MULTICHAR_SWITCH;
+                                }
+                            case ('=') :
+                                {
+                                    consume();
+                                    token = Token.minusEqual(getStartLine(), getStartColumn());
+                                    break MULTICHAR_SWITCH;
+                                }
+                            case ('>') :
+                                {
+                                    consume();
+                                    token = Token.navigate(getStartLine(), getStartColumn());
+                                    break MULTICHAR_SWITCH;
+                                }
+                            default :
+                                {
+                                    token = Token.minus(getStartLine(), getStartColumn());
+                                    break MULTICHAR_SWITCH;
+                                }
                         }
+                        break ROOT_SWITCH;
                     }
-                    break ROOT_SWITCH;
-                }
-                case ( '*' ):
-                {
-                    mark();
-                    consume();
+                case ('*') :
+                    {
+                        mark();
+                        consume();
 
-                    c = la();
+                        c = la();
 
-                  MULTICHAR_SWITCH:
-                    switch( c )
-                    {
-                        case ( '=' ):
-                        {
-                            consume();
-                            token = Token.multiplyEqual( getStartLine(),
-                                                         getStartColumn() );
-                            break MULTICHAR_SWITCH;
-                        }
-                        default:
-                        {
-                            token = Token.multiply( getStartLine(),
-                                                    getStartColumn() );
-                            break MULTICHAR_SWITCH;
+                        MULTICHAR_SWITCH : switch (c) {
+                            case ('=') :
+                                {
+                                    consume();
+                                    token = Token.multiplyEqual(getStartLine(), getStartColumn());
+                                    break MULTICHAR_SWITCH;
+                                }
+                            default :
+                                {
+                                    token = Token.multiply(getStartLine(), getStartColumn());
+                                    break MULTICHAR_SWITCH;
+                                }
                         }
+                        break ROOT_SWITCH;
                     }
-                    break ROOT_SWITCH;
-                }
-                case ( ':' ):
-                {
-                    mark();
-                    consume();
-
-                    token = Token.colon( getStartLine(),
-                                         getStartColumn() );
-                    break ROOT_SWITCH;
-                }
-                case ( ',' ):
-                {
-                    mark();
-                    consume();
-                    token = Token.comma( getStartLine(),
-                                         getStartColumn() );
-                    break ROOT_SWITCH;
-                }
-                case ( ';' ):
-                {
-                    mark();
-                    consume();
-                    token = Token.semicolon( getStartLine(),
-                                             getStartColumn() );
-                    break ROOT_SWITCH;
-                }
-                case ( '?' ):
-                {
-                    mark();
-                    consume();
-                    token = Token.question( getStartLine(),
-                                            getStartColumn() );
-                    break ROOT_SWITCH;
-                }
-                case ( '<' ):
-                {
-                    mark();
-                    consume();
-
-                    c = la();
+                case (':') :
+                    {
+                        mark();
+                        consume();
 
-                  MULTICHAR_SWITCH:
-                    switch ( c )
+                        token = Token.colon(getStartLine(), getStartColumn());
+                        break ROOT_SWITCH;
+                    }
+                case (',') :
                     {
-                        case ( '=' ):
-                        {
-                            consume();
-                            c = la();
-                            if ( c == '>' ) {
-                                consume();
-                                token = Token.compareTo( getStartLine(), getStartColumn() );
-                            }   
-                            else {
-                                token = Token.compareLessThanEqual( getStartLine(),
-                                                                    getStartColumn() );
-                            }
-                            break MULTICHAR_SWITCH;
-                        }
-                        case ( '<' ):
-                        {
-                        	consume();
-                        	c = la();
-                        	// Long strings can be created by using <<<TOK ... \nTOK
-                        	// They are exactly like double quoted strings except you don't need to escape anything
-                        	if ( c == '<' ) {
-								consume();
-								// The marker consists of everything from the end of the <<< to the end of the line.
-								StringBuffer marker = new StringBuffer();
-								while((c = la()) != '\n') {
-									marker.append(c);
-									consume();
-								}
-								consume(); // consume the nextline
-								eol(); // next line
-								mark(); // this is the start of the string
-
-								StringBuffer stringLiteral = new StringBuffer();
-
-							  LITERAL_LOOP:
-								while ( true )
-								{
-									c = la();
-
-								  LITERAL_SWITCH:
-									switch ( c )
-									{
-										case ( '\n' ):
-										{
-											eol(); // bump the line number
-											StringBuffer markerBuffer = new StringBuffer();
-											markerBuffer.append(consume());
-											for (int i = 0; i < marker.length(); i++) {
-												if (la() != marker.charAt(i)) {
-													stringLiteral.append(markerBuffer);
-													continue LITERAL_LOOP;
-												}
-												c = consume();
-												markerBuffer.append(c);
-											}
-											break LITERAL_LOOP;
-										}
-										case ( CharStream.EOS ):
-										{
-											throw new UnterminatedStringLiteralException( getStartLine(),
-																						  getStartColumn() );
-										}
-									}
-								  	stringLiteral.append( consume() );
-								}
-
-							  	// Fortunately they have the same semantics as a double quoted string once lexed
-								token = Token.doubleQuoteString( getStartLine(),
-																 getStartColumn(),
-																 stringLiteral.toString() );
-								break ROOT_SWITCH;
-								
-                        	} else {
-                        		throw new UnexpectedCharacterException( getStartLine(),
-                                                                		getStartColumn()+1,
-                                                                		c,
-                                                                		new char[] { } );
-                        	}
-                        }
-                        default:
-                        {
-                            token = Token.compareLessThan( getStartLine(),
-                                                           getStartColumn() );
-                            break MULTICHAR_SWITCH;
-                        }
+                        mark();
+                        consume();
+                        token = Token.comma(getStartLine(), getStartColumn());
+                        break ROOT_SWITCH;
                     }
-                    break ROOT_SWITCH;
-                }
-                case ( '>' ):
-                {
-                    mark();
-                    consume();
+                case (';') :
+                    {
+                        mark();
+                        consume();
+                        token = Token.semicolon(getStartLine(), getStartColumn());
+                        break ROOT_SWITCH;
+                    }
+                case ('?') :
+                    {
+                        mark();
+                        consume();
+                        token = Token.question(getStartLine(), getStartColumn());
+                        break ROOT_SWITCH;
+                    }
+                case ('<') :
+                    {
+                        mark();
+                        consume();
 
-                    c = la();
+                        c = la();
 
-                  MULTICHAR_SWITCH:
-                    switch ( c )
-                    {
-                        case ( '=' ):
-                        {
-                            consume();
-                            token = Token.compareGreaterThanEqual( getStartLine(),
-                                                                   getStartColumn() );
-                            break MULTICHAR_SWITCH;
-                        }
-                        default:
-                        {
-                            token = Token.compareGreaterThan( getStartLine(),
-                                                              getStartColumn() );
-                            break MULTICHAR_SWITCH;
+                        MULTICHAR_SWITCH : switch (c) {
+                            case ('=') :
+                                {
+                                    consume();
+                                    c = la();
+                                    if (c == '>') {
+                                        consume();
+                                        token = Token.compareTo(getStartLine(), getStartColumn());
+                                    }
+                                    else {
+                                        token = Token.compareLessThanEqual(getStartLine(), getStartColumn());
+                                    }
+                                    break MULTICHAR_SWITCH;
+                                }
+                            case ('<') :
+                                {
+                                    consume();
+                                    c = la();
+                                    // Long strings can be created by using <<<TOK ... \nTOK
+                                    // They are exactly like double quoted strings except you don't need to escape anything
+                                    if (c == '<') {
+                                        consume();
+                                        // The marker consists of everything from the end of the <<< to the end of the line.
+                                        StringBuffer marker = new StringBuffer();
+                                        while ((c = la()) != '\n') {
+                                            marker.append(c);
+                                            consume();
+                                        }
+                                        consume(); // consume the nextline
+                                        eol(); // next line
+                                        mark(); // this is the start of the string
+
+                                        StringBuffer stringLiteral = new StringBuffer();
+
+                                        LITERAL_LOOP : while (true) {
+                                            c = la();
+
+                                            LITERAL_SWITCH : switch (c) {
+                                                case ('\n') :
+                                                    {
+                                                        eol(); // bump the line number
+                                                        StringBuffer markerBuffer = new StringBuffer();
+                                                        markerBuffer.append(consume());
+                                                        for (int i = 0; i < marker.length(); i++) {
+                                                            if (la() != marker.charAt(i)) {
+                                                                stringLiteral.append(markerBuffer);
+                                                                continue LITERAL_LOOP;
+                                                            }
+                                                            c = consume();
+                                                            markerBuffer.append(c);
+                                                        }
+                                                        break LITERAL_LOOP;
+                                                    }
+                                                case (CharStream.EOS) :
+                                                    {
+                                                        throw new UnterminatedStringLiteralException(
+                                                            getStartLine(),
+                                                            getStartColumn());
+                                                    }
+                                            }
+                                            stringLiteral.append(consume());
+                                        }
+
+                                        // Fortunately they have the same semantics as a double quoted string once lexed
+                                        token =
+                                            Token.doubleQuoteString(
+                                                getStartLine(),
+                                                getStartColumn(),
+                                                stringLiteral.toString());
+                                        break ROOT_SWITCH;
+
+                                    }
+                                    else {
+                                        throw new UnexpectedCharacterException(
+                                            getStartLine(),
+                                            getStartColumn() + 1,
+                                            c,
+                                            new char[] {
+                                        });
+                                    }
+                                }
+                            default :
+                                {
+                                    token = Token.compareLessThan(getStartLine(), getStartColumn());
+                                    break MULTICHAR_SWITCH;
+                                }
                         }
+                        break ROOT_SWITCH;
                     }
-                    break ROOT_SWITCH;
-                }
-                case ( '\'') :
-                {
-                    mark();
-                    consume();
-                    
-                    StringBuffer stringLiteral = new StringBuffer();
-                    
-                  LITERAL_LOOP:
-                    while ( true )
+                case ('>') :
                     {
-                        c = la();
-                        
-                      LITERAL_SWITCH:
-                        switch ( c )
-                        {
-                            case ( '\\' ):
-                            {
-                                consume();
+                        mark();
+                        consume();
 
-                                c = la();
+                        c = la();
 
-                              ESCAPE_SWITCH:
-                                switch ( c )
+                        MULTICHAR_SWITCH : switch (c) {
+                            case ('=') :
+                                {
+                                    consume();
+                                    token = Token.compareGreaterThanEqual(getStartLine(), getStartColumn());
+                                    break MULTICHAR_SWITCH;
+                                }
+                            default :
                                 {
-                                    case ( 't' ):
+                                    token = Token.compareGreaterThan(getStartLine(), getStartColumn());
+                                    break MULTICHAR_SWITCH;
+                                }
+                        }
+                        break ROOT_SWITCH;
+                    }
+                case ('\'') :
+                    {
+                        mark();
+                        consume();
+
+                        StringBuffer stringLiteral = new StringBuffer();
+
+                        LITERAL_LOOP : while (true) {
+                            c = la();
+
+                            LITERAL_SWITCH : switch (c) {
+                                case ('\\') :
                                     {
                                         consume();
-                                        stringLiteral.append( '\t' );
-                                        break ESCAPE_SWITCH;
+
+                                        c = la();
+
+                                        ESCAPE_SWITCH : switch (c) {
+                                            case ('t') :
+                                                {
+                                                    consume();
+                                                    stringLiteral.append('\t');
+                                                    break ESCAPE_SWITCH;
+                                                }
+                                            case ('n') :
+                                                {
+                                                    consume();
+                                                    stringLiteral.append('\n');
+                                                    break ESCAPE_SWITCH;
+                                                }
+                                            case ('r') :
+                                                {
+                                                    consume();
+                                                    stringLiteral.append('\r');
+                                                    break ESCAPE_SWITCH;
+                                                }
+                                            default :
+                                                {
+                                                    stringLiteral.append(consume());
+                                                    break ESCAPE_SWITCH;
+                                                }
+                                        }
+                                        break LITERAL_SWITCH;
                                     }
-                                    case ( 'n' ):
+                                case ('\r') :
+                                case ('\n') :
+                                case (CharStream.EOS) :
                                     {
-                                        consume();
-                                        stringLiteral.append( '\n' );
-                                        break ESCAPE_SWITCH;
+                                        throw new UnterminatedStringLiteralException(getStartLine(), getStartColumn());
                                     }
-                                    case ( 'r' ):
+                                case ('\'') :
                                     {
                                         consume();
-                                        stringLiteral.append( '\r' );
-                                        break ESCAPE_SWITCH;
+                                        break LITERAL_LOOP;
                                     }
-                                    default:
+                                default :
                                     {
-                                        stringLiteral.append( consume() );
-                                        break ESCAPE_SWITCH;
+                                        stringLiteral.append(consume());
+                                        break LITERAL_SWITCH;
                                     }
-                                }
-                                break LITERAL_SWITCH;
-                            }
-                            case ( '\r' ):
-                            case ( '\n' ):
-                            case ( CharStream.EOS ):
-                            {
-                                throw new UnterminatedStringLiteralException( getStartLine(),
-                                                                              getStartColumn() );
-                            }
-                            case ( '\'' ):
-                            {
-                                consume();
-                                break LITERAL_LOOP;
-                            }
-                            default:
-                            {
-                                stringLiteral.append( consume() );
-                                break LITERAL_SWITCH;
                             }
                         }
-                    }
 
-                    token = Token.singleQuoteString( getStartLine(),
-                                                     getStartColumn(),
-                                                     stringLiteral.toString() );
+                        token = Token.singleQuoteString(getStartLine(), getStartColumn(), stringLiteral.toString());
 
-                    break ROOT_SWITCH;
-                }
-                case ( '"' ):
-                {
-                    mark();
-                    consume();
-
-                    StringBuffer stringLiteral = new StringBuffer();
-
-                  LITERAL_LOOP:
-                    while ( true )
+                        break ROOT_SWITCH;
+                    }
+                case ('"') :
                     {
-                        c = la();
+                        mark();
+                        consume();
 
-                      LITERAL_SWITCH:
-                        switch ( c )
-                        {
-                            case ( '\\' ):
-                            {
-                                consume();
+                        StringBuffer stringLiteral = new StringBuffer();
 
-                                c = la();
+                        LITERAL_LOOP : while (true) {
+                            c = la();
 
-                              ESCAPE_SWITCH:
-                                switch ( c )
-                                {
-                                    case ( 't' ):
+                            int x = (int) c;
+
+                            LITERAL_SWITCH : switch (c) {
+                                case ('\\') :
                                     {
                                         consume();
-                                        stringLiteral.append( '\t' );
-                                        break ESCAPE_SWITCH;
+
+                                        c = la();
+
+                                        ESCAPE_SWITCH : switch (c) {
+                                            case ('t') :
+                                                {
+                                                    consume();
+                                                    stringLiteral.append('\t');
+                                                    break ESCAPE_SWITCH;
+                                                }
+                                            case ('n') :
+                                                {
+                                                    consume();
+                                                    stringLiteral.append('\n');
+                                                    break ESCAPE_SWITCH;
+                                                }
+                                            case ('r') :
+                                                {
+                                                    consume();
+                                                    stringLiteral.append('\r');
+                                                    break ESCAPE_SWITCH;
+                                                }
+                                            default :
+                                                {
+                                                    stringLiteral.append(consume());
+                                                    break ESCAPE_SWITCH;
+                                                }
+                                        }
+                                        break LITERAL_SWITCH;
                                     }
-                                    case ( 'n' ):
+                                case ('"') :
                                     {
                                         consume();
-                                        stringLiteral.append( '\n' );
-                                        break ESCAPE_SWITCH;
+                                        break LITERAL_LOOP;
                                     }
-                                    case ( 'r' ):
+                                case (char) - 1 :
                                     {
-                                        consume();
-                                        stringLiteral.append( '\r' );
-                                        break ESCAPE_SWITCH;
+                                        throw new UnterminatedStringLiteralException(getStartLine(), getStartColumn());
                                     }
-                                    default:
+                                    /* lets allow multi-line strings
+                                    case ( '\r' ):
+                                    case ( '\n' ):
+                                    case ( CharStream.EOS ):
                                     {
-                                        stringLiteral.append( consume() );
-                                        break ESCAPE_SWITCH;
+                                        throw new UnterminatedStringLiteralException( getStartLine(),
+                                                                                      getStartColumn() );
+                                    }
+                                    */
+                                default :
+                                    {
+                                        stringLiteral.append(consume());
+                                        break LITERAL_SWITCH;
                                     }
-                                }
-                                break LITERAL_SWITCH;
-                            }
-                            case ( '"' ):
-                            {
-                                consume();
-                                break LITERAL_LOOP;
-                            }
-                            case ( '\r' ):
-                            case ( '\n' ):
-                            case ( CharStream.EOS ):
-                            {
-                                throw new UnterminatedStringLiteralException( getStartLine(),
-                                                                              getStartColumn() );
-                            }
-                            default:
-                            {
-                                stringLiteral.append( consume() );
-                                break LITERAL_SWITCH;
                             }
                         }
-                    }
 
-                    token = Token.doubleQuoteString( getStartLine(),
-                                                     getStartColumn(),
-                                                     stringLiteral.toString() );
+                        token = Token.doubleQuoteString(getStartLine(), getStartColumn(), stringLiteral.toString());
 
-                    break ROOT_SWITCH;
-                }
-                case ( '0' ):
-                case ( '1' ):
-                case ( '2' ):
-                case ( '3' ):
-                case ( '4' ):
-                case ( '5' ):
-                case ( '6' ):
-                case ( '7' ):
-                case ( '8' ):
-                case ( '9' ):
-                {
-                    mark();
-                    StringBuffer numericLiteral = new StringBuffer();
-
-                    boolean isFloat = false;
-
-                    while ( c == '0'
-                            ||
-                            c == '1'
-                            ||
-                            c == '2'
-                            ||
-                            c == '3'
-                            ||
-                            c == '4'
-                            ||
-                            c == '5'
-                            ||
-                            c == '6'
-                            ||
-                            c == '7'
-                            ||
-                            c == '8'
-                            ||
-                            c == '9' )
-                    {
-                        numericLiteral.append( consume() );
-                        c = la();
+                        break ROOT_SWITCH;
                     }
-
-                    if ( c == '.' )
+                case ('0') :
+                case ('1') :
+                case ('2') :
+                case ('3') :
+                case ('4') :
+                case ('5') :
+                case ('6') :
+                case ('7') :
+                case ('8') :
+                case ('9') :
                     {
-                        if ( ( c = la( 2 ) ) == '.' )
-                        {
-                            // int followed by range op, break out.
+                        mark();
+                        StringBuffer numericLiteral = new StringBuffer();
+
+                        boolean isFloat = false;
+
+                        while (c == '0'
+                            || c == '1'
+                            || c == '2'
+                            || c == '3'
+                            || c == '4'
+                            || c == '5'
+                            || c == '6'
+                            || c == '7'
+                            || c == '8'
+                            || c == '9') {
+                            numericLiteral.append(consume());
+                            c = la();
                         }
-                        else
-                        {
-                            while ( c == '0' 
-                                    ||
-                                    c == '1'
-                                    ||
-                                    c == '2'
-                                    ||
-                                    c == '3'
-                                    ||
-                                    c == '4'
-                                    ||
-                                    c == '5'
-                                    ||
-                                    c == '6'
-                                    ||
-                                    c == '7'
-                                    ||
-                                    c == '8'
-                                    ||
-                                    c == '9' )
-                            {
-                            	if ( !isFloat ) numericLiteral.append( consume() );
-								isFloat = true;
-                                numericLiteral.append( consume() );
-                                c = la();
+
+                        if (c == '.') {
+                            if ((c = la(2)) == '.') {
+                                // int followed by range op, break out.
+                            }
+                            else {
+                                while (c == '0'
+                                    || c == '1'
+                                    || c == '2'
+                                    || c == '3'
+                                    || c == '4'
+                                    || c == '5'
+                                    || c == '6'
+                                    || c == '7'
+                                    || c == '8'
+                                    || c == '9') {
+                                    if (!isFloat)
+                                        numericLiteral.append(consume());
+                                    isFloat = true;
+                                    numericLiteral.append(consume());
+                                    c = la();
+                                }
                             }
                         }
-                    }
 
-                    if ( isFloat )
-                    {
-                        token = Token.floatNumber( getStartLine(),
-                                                   getStartColumn(),
-                                                   numericLiteral.toString() );
-                    }
-                    else
-                    {
-                        token = Token.integerNumber( getStartLine(),
-                                                     getStartColumn(),
-                                                     numericLiteral.toString() );
+                        if (isFloat) {
+                            token = Token.floatNumber(getStartLine(), getStartColumn(), numericLiteral.toString());
+                        }
+                        else {
+                            token = Token.integerNumber(getStartLine(), getStartColumn(), numericLiteral.toString());
+                        }
+                        break ROOT_SWITCH;
                     }
-                    break ROOT_SWITCH;
-                }
-                default:
-                {
-                    mark();
-                    if ( Character.isJavaIdentifierStart( c ) )
+                default :
                     {
-                        StringBuffer identifier = new StringBuffer();
-                        
-                        identifier.append( consume() );
-                        
-                      IDENTIFIER_LOOP:
-                        while ( true )
-                        {
-                            c = la();
-                            
-                            if ( Character.isJavaIdentifierPart( c ) )
-                            {
-                                identifier.append( consume() );
-                            }
-                            else
-                            {
-                                break IDENTIFIER_LOOP;
+                        mark();
+                        if (Character.isJavaIdentifierStart(c)) {
+                            StringBuffer identifier = new StringBuffer();
+
+                            identifier.append(consume());
+
+                            IDENTIFIER_LOOP : while (true) {
+                                c = la();
+
+                                if (Character.isJavaIdentifierPart(c)) {
+                                    identifier.append(consume());
+                                }
+                                else {
+                                    break IDENTIFIER_LOOP;
+                                }
                             }
-                        }
 
-                        token = Token.keyword( getStartLine(),
-                                               getStartColumn(),
-                                               identifier.toString() );
+                            token = Token.keyword(getStartLine(), getStartColumn(), identifier.toString());
 
-                        if ( token == null )
-                        {
-                            token = Token.identifier( getStartLine(),
-                                                      getStartColumn(),
-                                                      identifier.toString() );
+                            if (token == null) {
+                                token = Token.identifier(getStartLine(), getStartColumn(), identifier.toString());
+                            }
                         }
+                        else {
+                            throw new UnexpectedCharacterException(
+                                getStartLine(),
+                                getStartColumn() + 1,
+                                c,
+                                new char[] {
+                            });
+                        }
+                        break ROOT_SWITCH;
                     }
-                    else
-                    {
-                        throw new UnexpectedCharacterException( getStartLine(),
-                                                                getStartColumn()+1,
-                                                                c,
-                                                                new char[] { } );
-                    }
-                    break ROOT_SWITCH;
-                }
             }
         }
 
         return token;
     }
 
-    protected void eol()
-    {
+    protected void eol() {
         ++this.line;
         this.column = 1;
     }
 
-    protected void mark()
-    {
+    protected void mark() {
         this.startLine = this.line;
         this.startColumn = this.column;
     }
 
-    protected int getStartLine()
-    {
+    protected int getStartLine() {
         return this.startLine;
     }
 
-    protected int getStartColumn()
-    {
+    protected int getStartColumn() {
         return this.startColumn;
     }
 
-    protected char la()
-        throws UnexpectedCharacterException, IOException
-    {
+    protected char la() throws UnexpectedCharacterException, IOException {
         return la(1);
     }
 
-    protected char la(int k)
-        throws UnexpectedCharacterException, IOException
-    {
-    	if (k > this.charsInBuffer) {
-    		if (k > this.buf.length) throw new LookAheadExhaustionException(k);
-    		
-    		for (int i = 0; i != this.charsInBuffer; i++, this.cur++) {
-    			this.buf[i] = this.buf[this.cur];
-    			this.charWidth[i] = this.charWidth[this.cur];
-    		}
-    		
-    		fillBuffer();
-    	}
-    	
-    	return this.buf[this.cur + k - 1];
+    protected char la(int k) throws UnexpectedCharacterException, IOException {
+        if (k > this.charsInBuffer) {
+            if (k > this.buf.length)
+                throw new LookAheadExhaustionException(k);
+
+            for (int i = 0; i != this.charsInBuffer; i++, this.cur++) {
+                this.buf[i] = this.buf[this.cur];
+                this.charWidth[i] = this.charWidth[this.cur];
+            }
+
+            fillBuffer();
+        }
+
+        return this.buf[this.cur + k - 1];
     }
 
-    protected char consume()
-        throws UnexpectedCharacterException, IOException
-    {
-    	if (this.charsInBuffer == 0) fillBuffer();
-    	
-    	this.charsInBuffer--;
-    	
-    	this.column += this.charWidth[this.cur];
-    	
-    	return this.buf[this.cur++];
+    protected char consume() throws UnexpectedCharacterException, IOException {
+        if (this.charsInBuffer == 0)
+            fillBuffer();
+
+        this.charsInBuffer--;
+
+        this.column += this.charWidth[this.cur];
+
+        return this.buf[this.cur++];
     }
-    
-    private void fillBuffer()
-    	throws IOException, UnexpectedCharacterException
-    {
-    	this.cur = 0;
-    	
-    	do {
-    		if (this.eosRead) {
-    			this.buf[this.charsInBuffer] = CharStream.EOS;
-    		} else {
-    			char c = this.escapeLookahead ? this.escapeLookaheadChar : charStream.consume();
-    			
-    			this.escapeLookahead = false;
-    			this.charWidth[this.charsInBuffer] = 1;
-
-    			if (c == CharStream.EOS) this.eosRead = true;
-    			
-    			if (c == '\\') {
-    				c = charStream.consume();
-    				
-    				if (c == 'u') {
-    					do {
-    						this.charWidth[this.charsInBuffer]++;
-    						c = charStream.consume();
-    					} while (c == 'u');	// the spec allows any number of u characters after the \	
-    					
-    					try {
-    						c = (char)Integer.parseInt(new String(new char[] {c, charStream.consume(), charStream.consume(), charStream.consume()}), 16);
-    						this.charWidth[this.charsInBuffer] += 4;
-    					}
-    					catch (NumberFormatException e) {
-    						throw new UnexpectedCharacterException( getStartLine(),
-    								getStartColumn()+1,
-    								c,
-									new char[] { } );    						
-     					}
-    				} else {
-    					this.escapeLookahead = true;
-    					this.escapeLookaheadChar = c;
-    					c = '\\';
-    				}
-    			}
-    			
-    			this.buf[this.charsInBuffer] = c;
-    		}
-    	} while (++this.charsInBuffer != this.buf.length);
+
+    private void fillBuffer() throws IOException, UnexpectedCharacterException {
+        this.cur = 0;
+
+        do {
+            if (this.eosRead) {
+                this.buf[this.charsInBuffer] = CharStream.EOS;
+            }
+            else {
+                char c = this.escapeLookahead ? this.escapeLookaheadChar : charStream.consume();
+
+                this.escapeLookahead = false;
+                this.charWidth[this.charsInBuffer] = 1;
+
+                if (c == CharStream.EOS)
+                    this.eosRead = true;
+
+                if (c == '\\') {
+                    c = charStream.consume();
+
+                    if (c == 'u') {
+                        do {
+                            this.charWidth[this.charsInBuffer]++;
+                            c = charStream.consume();
+                        }
+                        while (c == 'u'); // the spec allows any number of u characters after the \	
+
+                        try {
+                            c =
+                                (char) Integer.parseInt(
+                                    new String(
+                                        new char[] {
+                                            c,
+                                            charStream.consume(),
+                                            charStream.consume(),
+                                            charStream.consume()}),
+                                    16);
+                            this.charWidth[this.charsInBuffer] += 4;
+                        }
+                        catch (NumberFormatException e) {
+                            throw new UnexpectedCharacterException(
+                                getStartLine(),
+                                getStartColumn() + 1,
+                                c,
+                                new char[] {
+                            });
+                        }
+                    }
+                    else {
+                        this.escapeLookahead = true;
+                        this.escapeLookaheadChar = c;
+                        c = '\\';
+                    }
+                }
+
+                this.buf[this.charsInBuffer] = c;
+            }
+        }
+        while (++this.charsInBuffer != this.buf.length);
     }
-    
+
 }
diff --git a/src/main/org/codehaus/groovy/syntax/lexer/LexerException.java b/src/main/org/codehaus/groovy/syntax/lexer/LexerException.java
index f7954d3df8..36c274a979 100644
--- a/src/main/org/codehaus/groovy/syntax/lexer/LexerException.java
+++ b/src/main/org/codehaus/groovy/syntax/lexer/LexerException.java
@@ -54,9 +54,7 @@ import org.codehaus.groovy.syntax.SyntaxException;
  *
  *  @version $Id$
  */
-public class LexerException
-    extends SyntaxException
-{
+public class LexerException extends SyntaxException {
     // ----------------------------------------------------------------------
     //     Instance members
     // ----------------------------------------------------------------------
@@ -71,18 +69,24 @@ public class LexerException
     //     Constructors
     // ----------------------------------------------------------------------
 
-    /** Construct.
-     *
+    /** 
      *  @param line Line upon which the error occurred.
      *  @param column Column upon which the error occurred.
      */
-    public LexerException(int line,
-                          int column)
-    {
-        this.line   = line;
+    public LexerException(String message, int line, int column) {
+        super(message + " at " + line + ":" + column);
+        this.line = line;
         this.column = column;
     }
 
+    /** 
+     *  @param line Line upon which the error occurred.
+     *  @param column Column upon which the error occurred.
+     */
+    public LexerException(int line, int column) {
+        this("", line, column);
+    }
+
     // ----------------------------------------------------------------------
     //     Instance methods
     // ----------------------------------------------------------------------
@@ -91,8 +95,7 @@ public class LexerException
      *
      *  @return The line.
      */
-    public int getLine()
-    {
+    public int getLine() {
         return this.line;
     }
 
@@ -100,8 +103,7 @@ public class LexerException
      *
      *  @return The column.
      */
-    public int getColumn()
-    {
+    public int getColumn() {
         return this.column;
     }
 }
diff --git a/src/main/org/codehaus/groovy/syntax/lexer/UnterminatedStringLiteralException.java b/src/main/org/codehaus/groovy/syntax/lexer/UnterminatedStringLiteralException.java
index 47d78d6294..c9393f72af 100644
--- a/src/main/org/codehaus/groovy/syntax/lexer/UnterminatedStringLiteralException.java
+++ b/src/main/org/codehaus/groovy/syntax/lexer/UnterminatedStringLiteralException.java
@@ -1,12 +1,7 @@
 package org.codehaus.groovy.syntax.lexer;
 
-public class UnterminatedStringLiteralException
-    extends LexerException
-{
-    public UnterminatedStringLiteralException(int line,
-                                              int column)
-    {
-        super( line,
-               column );
+public class UnterminatedStringLiteralException extends LexerException {
+    public UnterminatedStringLiteralException(int line, int column) {
+        super("Unterminated string literal", line, column);
     }
 }
diff --git a/src/main/org/codehaus/groovy/syntax/parser/ASTBuilder.java b/src/main/org/codehaus/groovy/syntax/parser/ASTBuilder.java
index c735ff4328..fdd0af898b 100644
--- a/src/main/org/codehaus/groovy/syntax/parser/ASTBuilder.java
+++ b/src/main/org/codehaus/groovy/syntax/parser/ASTBuilder.java
@@ -43,6 +43,9 @@ public class ASTBuilder {
             datatypeDeclaration(answer, packageName, children[i]);
         }
 
+        if (answer.isEmpty()) {
+            answer.addStatement(new BlockStatement());
+        }
         return answer;
     }
 
@@ -811,8 +814,10 @@ public class ASTBuilder {
         
         Expression objectExpression = null;
 
+        boolean implicitThis = false;
         if (objectExpressionRoot.getToken() == null) {
             objectExpression = VariableExpression.THIS_EXPRESSION;
+            implicitThis = true;
         }
         else {
             objectExpression = expression(expressionRoot.getChild(0));
@@ -823,7 +828,8 @@ public class ASTBuilder {
         Expression paramList = actualParameterList(expressionRoot.getChild(2));
 
         MethodCallExpression answer = new MethodCallExpression(objectExpression, methodName, paramList);
-
+        answer.setImplicitThis(implicitThis);
+        
         if (expressionRoot.getChildren().length > 3) {
             CSTNode notExpr = expressionRoot.getChild(3);
             if (notExpr != null && notExpr.getToken().getType() == Token.NAVIGATE) {
diff --git a/src/main/org/codehaus/groovy/syntax/parser/Parser.java b/src/main/org/codehaus/groovy/syntax/parser/Parser.java
index 2972d5ae6e..3a8c74a330 100644
--- a/src/main/org/codehaus/groovy/syntax/parser/Parser.java
+++ b/src/main/org/codehaus/groovy/syntax/parser/Parser.java
@@ -1355,6 +1355,9 @@ public class Parser {
 
             if (exprStart > 0) {
                 if (text.charAt(exprStart - 1) == '$') {
+                    StringBuffer buf = new StringBuffer(text);
+                    buf.replace(exprStart -1, exprStart, "");
+                    text = buf.toString();
                     cur = exprStart + 1;
                     continue;
                 }
@@ -1430,7 +1433,7 @@ public class Parser {
     }
 
     protected CSTNode parameterList(int endOfListDemarc) throws IOException, SyntaxException {
-        if (lt_bare() == Token.IDENTIFIER && lt_bare(2) == Token.COLON) {
+        if ((lt_bare() == Token.IDENTIFIER || lt_bare() == Token.KEYWORD_CLASS) && lt_bare(2) == Token.COLON) {
             return namedParameterList(endOfListDemarc);
         }
 
@@ -1455,7 +1458,10 @@ public class Parser {
         CSTNode parameterList = new CSTNode(Token.syntheticList());
 
         while (lt() != endOfListDemarc) {
-            CSTNode name = rootNode(Token.IDENTIFIER);
+            if (lt_bare() != Token.IDENTIFIER && lt_bare() != Token.KEYWORD_CLASS) {
+                throwExpected(new int[] { Token.IDENTIFIER, Token.KEYWORD_CLASS });
+            }
+            CSTNode name = rootNode(lt_bare());
 
             CSTNode namedParam = rootNode_bare(Token.COLON, name);
 
diff --git a/src/main/org/codehaus/groovy/wiki/TestCaseRenderEngine.java b/src/main/org/codehaus/groovy/wiki/TestCaseRenderEngine.java
index 3ebb62b816..1dc1eb4bb4 100644
--- a/src/main/org/codehaus/groovy/wiki/TestCaseRenderEngine.java
+++ b/src/main/org/codehaus/groovy/wiki/TestCaseRenderEngine.java
@@ -58,6 +58,7 @@ import org.radeox.api.engine.context.RenderContext;
  */
 public class TestCaseRenderEngine implements RenderEngine {
     Pattern groovyCodePattern = Pattern.compile("\\{code:groovy\\}");
+    Pattern groovyShellPattern = Pattern.compile("\\{code:groovysh\\}");
     Pattern codePattern = Pattern.compile("\\{code\\}");
     
     public TestCaseRenderEngine() {
@@ -84,19 +85,57 @@ public class TestCaseRenderEngine implements RenderEngine {
         String[] parts = groovyCodePattern.split(content);
         
         buf.append( "package wiki\nclass " + name + " extends GroovyTestCase {\n\n");
-        buf.append("void testDummy() {\n// this is a dummy test case\n}\n\n");
         buf.append("/*\n");
-        buf.append(parts[0]);
+        buf.append(processShellScripts(parts[0]));
 
-        int count = 1;
-        for (int i = 1; i < parts.length; i++ ) {
-            buf.append("*/ \n\n  void testCase" + (count++) + "() {\n");
+        for (int count = 1; count < parts.length; count++ ) {
+            buf.append("*/ \n\n  void testCase" + count + "() {\n");
             
-            buf.append(removeCloseCode(parts[i]));
+            buf.append(processShellScripts(removeCloseCode(parts[count])));
         }
        
-        buf.append("\n*/\n\n}\n");
+        buf.append("\n*/\n\n");
+        buf.append("void testDummy() {\n// this is a dummy test case\n}\n\n}\n");
+        
+        return buf.toString();
+    }
+
+    /**
+     * Splits the comment block extracting any scripts that need to be tested
+     * @param text
+     * @return
+     */
+    protected String processShellScripts(String text) {
+        StringBuffer buf = new StringBuffer();
+
+        String[] parts = groovyShellPattern.split(text);
         
+        buf.append(parts[0]);
+
+        for (int count = 1; count < parts.length; count++ ) {
+            buf.append("*/ \n\n  void testScript" + count + "() {\n");
+            buf.append("    assertScript( <<<SCRIPT_EOF" + count + "\n");
+            
+            String code = parts[count].replaceFirst("\\{code\\}", "\nSCRIPT_EOF" + count + " )\n}    \n\n /*");
+            
+            // lets escape ${foo} expressions
+            StringBuffer temp = new StringBuffer(code);
+            for (int idx = 0; true; idx++) {
+                idx = temp.indexOf("$", idx);
+                if (idx >= 0) {
+                    String next = temp.substring(++idx, idx+1);
+                    if (next.equals("{")) {
+                        temp.insert(idx, "$");
+                        idx++;
+                    }
+                }
+                else {
+                    break;
+                }
+            }
+            
+            buf.append(temp.toString());
+        }
         return buf.toString();
     }
 
diff --git a/src/test/groovy/ArrayParamMethodTest.groovy b/src/test/groovy/ArrayParamMethodTest.groovy
index 2c211cf8ae..2d220eaac7 100644
--- a/src/test/groovy/ArrayParamMethodTest.groovy
+++ b/src/test/groovy/ArrayParamMethodTest.groovy
@@ -12,5 +12,14 @@ class ArrayParamMethodTest extends GroovyTestCase implements DummyInterface {
     
     void methodWithArrayParam(String[] args) {
         println("first item: ${args[0]}")
+        
+        // lets turn it into a list
+        list = args.toList()
+        assert list instanceof java.util.List
+        list[4] = "e"
+        
+        assert list == ["a", "b", "c", null, "e"]
+        
+        println("Created list ${list}")
     }
 }
\ No newline at end of file
diff --git a/src/test/groovy/DollarEscapingTest.groovy b/src/test/groovy/DollarEscapingTest.groovy
new file mode 100644
index 0000000000..b2c309aa56
--- /dev/null
+++ b/src/test/groovy/DollarEscapingTest.groovy
@@ -0,0 +1,12 @@
+class DollarEscapingTest extends GroovyTestCase {
+
+    void testEscaping() {
+        foo = "hello $${foo}"
+        
+        assert foo instanceof String
+        
+        c = foo.count("$")
+        
+        assert c == 1 : foo
+    }
+}
diff --git a/src/test/groovy/HeredocsTest.groovy b/src/test/groovy/HeredocsTest.groovy
new file mode 100644
index 0000000000..0e8ec81662
--- /dev/null
+++ b/src/test/groovy/HeredocsTest.groovy
@@ -0,0 +1,33 @@
+class HeredocsTest extends GroovyTestCase {
+
+    void testHeredocs() {
+        name = "James"
+        s = <<<EOF
+abcd
+efg
+
+hijk
+     
+hello ${name}
+        
+EOF
+        println s
+		assert s != null
+		assert s instanceof GString
+
+		assert s.contains("i")
+		assert s.contains("James")
+    }
+    
+    void testDollarEscaping() {
+        /** @todo use EOF again */
+        s = <<<EOF
+hello $${name}
+EOF
+		println s
+		assert s != null
+		assert s.contains("$")
+		c = s.count("$")
+		assert c == 1
+    }
+}
diff --git a/src/test/groovy/MultilineStringTest.groovy b/src/test/groovy/MultilineStringTest.groovy
new file mode 100644
index 0000000000..77e5044d52
--- /dev/null
+++ b/src/test/groovy/MultilineStringTest.groovy
@@ -0,0 +1,15 @@
+class MultilineStringTest extends GroovyTestCase {
+
+    void testMultilineString() {
+        s = "abcd
+efg
+
+        hijk
+        
+"
+        println(s)
+		assert s != null
+        idx = s.indexOf("i")
+		assert idx > 0
+    }
+}
diff --git a/src/test/groovy/NumberTest.groovy b/src/test/groovy/NumberTest.groovy
new file mode 100644
index 0000000000..8218b8e0a5
--- /dev/null
+++ b/src/test/groovy/NumberTest.groovy
@@ -0,0 +1,56 @@
+/**
+ * @version $Revision$
+ */
+class NumberTest extends GroovyTestCase { 
+    void testCompareByteToInt() { 
+        Byte a = 12
+        Integer b = 10
+        
+        assert a instanceof Byte
+        assert b instanceof Integer
+        
+        assert a > b
+    } 
+    
+    void testCompareByteToDouble() { 
+        Byte a = 12
+        Double b = 10
+        
+        assert a instanceof Byte
+        assert b instanceof Double
+        
+        assert a > b
+    } 
+     
+    void testCompareLongToDouble() { 
+        Long a = 12
+        Double b = 10
+        
+        assert a instanceof Long
+        assert b instanceof Double
+        
+        assert a > b
+    } 
+     
+    void testCompareLongToByte() { 
+        Long a = 12
+        Byte b = 10
+        
+        assert a instanceof Long
+        assert b instanceof Byte
+        
+        assert a > b
+    } 
+     
+    void testCompareIntegerToByte() { 
+        Integer a = 12
+        Byte b = 10
+        
+        assert a instanceof Integer
+        assert b instanceof Byte
+        
+        assert a > b
+    } 
+} 
+
+
diff --git a/src/test/groovy/RangeTest.groovy b/src/test/groovy/RangeTest.groovy
index 1180837315..0c9078781a 100644
--- a/src/test/groovy/RangeTest.groovy
+++ b/src/test/groovy/RangeTest.groovy
@@ -55,4 +55,10 @@ class RangeTest extends GroovyTestCase {
 	    text = list.inspect()
 	    assert text == "[1, 4..10, 9]"
 	}
+	
+	void testRangeSize() {
+	    range = 1..10
+		s = range.size()
+	    assert s == 10
+	}
 }
diff --git a/src/test/groovy/bugs/ClassInNamedParamsBug.groovy b/src/test/groovy/bugs/ClassInNamedParamsBug.groovy
new file mode 100644
index 0000000000..6e9f6f0ccb
--- /dev/null
+++ b/src/test/groovy/bugs/ClassInNamedParamsBug.groovy
@@ -0,0 +1,20 @@
+import java.util.Map
+
+class ClassInNamedParamsBug extends GroovyTestCase {
+    
+    void testBug() {
+        foo = method(class:'cheese', name:'cheddar')
+        
+        assert foo.name == "cheddar"
+        assert foo.class == "cheese"
+        
+        foo = method(name:'cheddar', class:'cheese')
+        
+        assert foo.name == "cheddar"
+        assert foo.class == "cheese"
+    }
+    
+    method(Map data) {
+        data
+    }
+}
\ No newline at end of file
diff --git a/src/test/groovy/bugs/ClosureVariableBug.groovy b/src/test/groovy/bugs/ClosureVariableBug.groovy
new file mode 100644
index 0000000000..6c85734f5c
--- /dev/null
+++ b/src/test/groovy/bugs/ClosureVariableBug.groovy
@@ -0,0 +1,14 @@
+/**
+ * @version $Revision$
+ */
+class ClosureVariableBug extends GroovyTestCase {
+    
+    void testBug() {
+        count = 0
+        closure = { assert count == it }
+        closure(0)
+        
+        count = 1
+        closure(1)
+    }
+}
\ No newline at end of file
diff --git a/src/test/groovy/bugs/SubscriptAndExpressionBug.groovy b/src/test/groovy/bugs/SubscriptAndExpressionBug.groovy
index 5fea02d297..769ca15ee6 100644
--- a/src/test/groovy/bugs/SubscriptAndExpressionBug.groovy
+++ b/src/test/groovy/bugs/SubscriptAndExpressionBug.groovy
@@ -31,14 +31,15 @@ class SubscriptAndExpressionBug extends GroovyTestCase {
         
         assert foo[10] == 123
         
-        /** @todo 
+        foo.putAt(12, 55)
+        assert foo[12] == 55
+        
         i = 20
+        foo[i] = 1
         foo[i++] += 5
         
         assert i == 21
-        assert foo[20] == 5
-        */
-        
+        assert foo[20] == 6
     }
     
     void testDoubleSubscript() {
diff --git a/src/test/groovy/bugs/UseClosureInClosureBug.groovy b/src/test/groovy/bugs/UseClosureInClosureBug.groovy
new file mode 100644
index 0000000000..a0a7314b54
--- /dev/null
+++ b/src/test/groovy/bugs/UseClosureInClosureBug.groovy
@@ -0,0 +1,12 @@
+/**
+ * @version $Revision$
+ */
+class UseClosureInClosureBug extends GroovyTestCase {
+    
+    void testBug() {
+        closure = { println it }
+        
+        anotherClosure = { closure(it) }
+        anotherClosure("Hello")
+    }
+}
\ No newline at end of file
diff --git a/src/test/groovy/bugs/UseStaticInClosureBug.groovy b/src/test/groovy/bugs/UseStaticInClosureBug.groovy
index 67b03699b6..86c3430438 100644
--- a/src/test/groovy/bugs/UseStaticInClosureBug.groovy
+++ b/src/test/groovy/bugs/UseStaticInClosureBug.groovy
@@ -4,11 +4,22 @@
 class UseStaticInClosureBug extends GroovyTestCase {
 
     static stuff = [:]
-    
+
     void testBug() {
         [1,2,3].each { stuff[it] = "dog" }
-        
+
+        assert stuff.size() == 3
+        assert stuff[2] == "dog"
+    }
+
+    void testBug2() {
+        doStatic()
+    }
+
+    static doStatic() {
+        [1,2,3].each { stuff[it] = "dog" }
+
         assert stuff.size() == 3
         assert stuff[2] == "dog"
     }
-}
\ No newline at end of file
+}
diff --git a/src/test/groovy/script/UseClosureInScript.groovy b/src/test/groovy/script/UseClosureInScript.groovy
index 9dabfbe0c6..97691950a3 100644
--- a/src/test/groovy/script/UseClosureInScript.groovy
+++ b/src/test/groovy/script/UseClosureInScript.groovy
@@ -1,6 +1,4 @@
 a = 1
 [1].each { 
-    /** @todo bug
     a = it 
-    */
 }
diff --git a/src/test/groovy/tree/TreeTest.groovy b/src/test/groovy/tree/TreeTest.groovy
index 753d03e3f0..51a9eea016 100644
--- a/src/test/groovy/tree/TreeTest.groovy
+++ b/src/test/groovy/tree/TreeTest.groovy
@@ -40,11 +40,11 @@ class TreeTest extends GroovyTestCase {
         
         print(root)
 
-		elem1 = root.elem1.get(0)
-        assert elem1.value() == 'hello1'
+		e1 = root.elem1.get(0)
+        assert e1.value() == 'hello1'
         
-        elem2 = root.elem2.get(0)
-        assert elem2.value() == 'hello2'
+        e2 = root.elem2.get(0)
+        assert e2.value() == 'hello2'
 
         assert root.elem1.get(0).value() == 'hello1'
         assert root.elem2.get(0).value() == 'hello2'
diff --git a/src/test/groovy/tree/VerboseTreeTest.groovy b/src/test/groovy/tree/VerboseTreeTest.groovy
index 7dca0b0c48..2099434cd5 100644
--- a/src/test/groovy/tree/VerboseTreeTest.groovy
+++ b/src/test/groovy/tree/VerboseTreeTest.groovy
@@ -43,11 +43,11 @@ class VerboseTreeTest extends GroovyTestCase {
         
         print(root)
 
-        elem1 = root.elem1.get(0)
-        assert elem1.value() == 'hello1'
+        e1 = root.elem1.get(0)
+        assert e1.value() == 'hello1'
         
-        elem2 = root.elem2.get(0)
-        assert elem2.value() == 'hello2'
+        e2 = root.elem2.get(0)
+        assert e2.value() == 'hello2'
 
         assert root.elem1.get(0).value() == 'hello1'
         assert root.elem2.get(0).value() == 'hello2'
diff --git a/src/test/groovy/util/EmptyScriptTest.java b/src/test/groovy/util/EmptyScriptTest.java
new file mode 100644
index 0000000000..2f4a852b89
--- /dev/null
+++ b/src/test/groovy/util/EmptyScriptTest.java
@@ -0,0 +1,60 @@
+/*
+ $Id$
+
+ Copyright 2003 (C) James Strachan and Bob Mcwhirter. All Rights Reserved.
+
+ Redistribution and use of this software and associated documentation
+ ("Software"), with or without modification, are permitted provided
+ that the following conditions are met:
+
+ 1. Redistributions of source code must retain copyright
+    statements and notices.  Redistributions must also contain a
+    copy of this document.
+
+ 2. Redistributions in binary form must reproduce the
+    above copyright notice, this list of conditions and the
+    following disclaimer in the documentation and/or other
+    materials provided with the distribution.
+
+ 3. The name "groovy" must not be used to endorse or promote
+    products derived from this Software without prior written
+    permission of The Codehaus.  For written permission,
+    please contact info@codehaus.org.
+
+ 4. Products derived from this Software may not be called "groovy"
+    nor may "groovy" appear in their names without prior written
+    permission of The Codehaus. "groovy" is a registered
+    trademark of The Codehaus.
+
+ 5. Due credit should be given to The Codehaus -
+    http://groovy.codehaus.org/
+
+ THIS SOFTWARE IS PROVIDED BY THE CODEHAUS AND CONTRIBUTORS
+ ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ THE CODEHAUS OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ OF THE POSSIBILITY OF SUCH DAMAGE.
+
+ */
+
+package groovy.util;
+
+import org.codehaus.groovy.classgen.TestSupport;
+
+/**
+ * @author <a href="mailto:james@coredevelopers.net">James Strachan</a>
+ * @version $Revision$
+ */
+public class EmptyScriptTest extends TestSupport {
+
+    public void testEmptyScript() throws Exception {
+        assertScript("");
+    }
+}
diff --git a/src/test/groovy/util/XmlParserTest.groovy b/src/test/groovy/util/XmlParserTest.groovy
index a404bece9e..8c56230479 100644
--- a/src/test/groovy/util/XmlParserTest.groovy
+++ b/src/test/groovy/util/XmlParserTest.groovy
@@ -44,4 +44,22 @@ EOF
         answer = node.character.find { it.attribute('id') == '1' }.likes.get(0).text()
         assert answer == "cheese"
     }
+    
+    void testMixedMarkup() {
+        text = <<<EOF
+<p>Please read the <a href="index.html">Home</a> page</p>
+EOF
+        
+        parser = new XmlParser()
+        node = parser.parse(new StringReader(text))
+        
+        new NodePrinter().print(node)
+        
+        assert node != null
+        children = node.children()
+        assert children.size() == 3 : "Children ${children}"
+        assert children[0] instanceof String
+        assert children[1] instanceof Node
+        assert children[2] instanceof String
+    }
 }
diff --git a/src/test/org/codehaus/groovy/classgen/RunBugsTest.java b/src/test/org/codehaus/groovy/classgen/RunBugsTest.java
index f4f1ca6917..ec1089e094 100644
--- a/src/test/org/codehaus/groovy/classgen/RunBugsTest.java
+++ b/src/test/org/codehaus/groovy/classgen/RunBugsTest.java
@@ -72,5 +72,15 @@ public class RunBugsTest extends TestSupport {
     public void testGuillaumesMapBug() throws Exception {
         GroovyObject object = compile("src/test/groovy/bugs/GuillaumesMapBug.groovy");
         object.invokeMethod("testBug", null);
-    }    
+    } 
+    
+    public void testUseClosureInScript() throws Exception {
+        GroovyObject object = compile("src/test/groovy/script/UseClosureInScript.groovy");
+        object.invokeMethod("run", null);
+    } 
+    
+    public void testUseStaticInClosure() throws Exception {
+        GroovyObject object = compile("src/test/groovy/bugs/UseStaticInClosureBug.groovy");
+        object.invokeMethod("testBug2", null);
+    } 
 }
diff --git a/src/test/org/codehaus/groovy/runtime/InvokeMethodTest.java b/src/test/org/codehaus/groovy/runtime/InvokeMethodTest.java
index f57236ed73..2b4088c2bf 100644
--- a/src/test/org/codehaus/groovy/runtime/InvokeMethodTest.java
+++ b/src/test/org/codehaus/groovy/runtime/InvokeMethodTest.java
@@ -284,7 +284,7 @@ public class InvokeMethodTest extends GroovyTestCase {
     public void testListGetWithRange() throws Throwable {
         List list = Arrays.asList(new Object[] { "a", "b", "c" });
         Object range = new IntRange(0, 2);
-        Object value = invoke(list, "get", range);
+        Object value = invoke(list, "getAt", range);
         assertTrue("Returned List: " + value, value instanceof List);
         List retList = (List) value;
         assertEquals("List size", 3, retList.size());
diff --git a/src/test/org/codehaus/groovy/syntax/lexer/LexerTest.java b/src/test/org/codehaus/groovy/syntax/lexer/LexerTest.java
index b40a6e31cd..2ae957b4d6 100644
--- a/src/test/org/codehaus/groovy/syntax/lexer/LexerTest.java
+++ b/src/test/org/codehaus/groovy/syntax/lexer/LexerTest.java
@@ -4,15 +4,11 @@ import groovy.util.GroovyTestCase;
 
 import org.codehaus.groovy.syntax.Token;
 
-public class LexerTest
-    extends GroovyTestCase
-{
+public class LexerTest extends GroovyTestCase {
     private Lexer lexer;
 
-    public void testEndOfStream()
-        throws Exception
-    {
-        newLexer( "" );
+    public void testEndOfStream() throws Exception {
+        newLexer("");
 
         assertEnd();
 
@@ -23,639 +19,437 @@ public class LexerTest
         assertEnd();
     }
 
-    public void testSingleLineComment_Newline()
-        throws Exception
-    {
-        newLexer( "// I like cheese\ncheese" );
+    public void testSingleLineComment_Newline() throws Exception {
+        newLexer("// I like cheese\ncheese");
 
-        assertNextToken( Token.IDENTIFIER,
-                         "cheese" );
+        assertNextToken(Token.IDENTIFIER, "cheese");
 
         assertEnd();
     }
 
-    public void testSingleLineComment_CarriageReturn()
-        throws Exception
-    {
-        newLexer( "// I like cheese\rcheese" );
+    public void testSingleLineComment_CarriageReturn() throws Exception {
+        newLexer("// I like cheese\rcheese");
 
-        assertNextToken( Token.IDENTIFIER,
-                         "cheese" );
+        assertNextToken(Token.IDENTIFIER, "cheese");
 
         assertEnd();
     }
 
-    public void testSingleLineComment_CarriageReturn_Newline()
-        throws Exception
-    {
-        newLexer( "// I like cheese\r\ncheese" );
+    public void testSingleLineComment_CarriageReturn_Newline() throws Exception {
+        newLexer("// I like cheese\r\ncheese");
 
-        assertNextToken( Token.IDENTIFIER,
-                         "cheese" );
+        assertNextToken(Token.IDENTIFIER, "cheese");
 
         assertEnd();
     }
 
-    public void testSingleLineHashComment_CarriageReturn()
-        throws Exception
-    {
-        newLexer( "# I like cheese\rcheese" );
+    public void testSingleLineHashComment_CarriageReturn() throws Exception {
+        newLexer("# I like cheese\rcheese");
 
-        assertNextToken( Token.IDENTIFIER,
-                         "cheese" );
+        assertNextToken(Token.IDENTIFIER, "cheese");
 
         assertEnd();
     }
 
-    public void testMultilineComment_MiddleOfLine()
-        throws Exception
-    {
-        newLexer( "cheese /* is */ toasty" );
+    public void testMultilineComment_MiddleOfLine() throws Exception {
+        newLexer("cheese /* is */ toasty");
 
-        assertNextToken( Token.IDENTIFIER,
-                         "cheese" );
+        assertNextToken(Token.IDENTIFIER, "cheese");
 
-        assertNextToken( Token.IDENTIFIER,
-                         "toasty" );
+        assertNextToken(Token.IDENTIFIER, "toasty");
 
         assertEnd();
     }
 
-    public void testMultilineComment_SpanningLines()
-        throws Exception
-    {
-        newLexer( "cheese /* is \n really */ toasty" );
+    public void testMultilineComment_SpanningLines() throws Exception {
+        newLexer("cheese /* is \n really */ toasty");
 
-        assertNextToken( Token.IDENTIFIER,
-                         "cheese" );
+        assertNextToken(Token.IDENTIFIER, "cheese");
 
-        assertNextToken( Token.IDENTIFIER,
-                         "toasty" );
+        assertNextToken(Token.IDENTIFIER, "toasty");
 
         assertEnd();
     }
 
-    public void testMultilineComment_EmbeddedStarts()
-        throws Exception
-    {
-        newLexer( "cheese /* * * * / * / */ toasty" );
+    public void testMultilineComment_EmbeddedStarts() throws Exception {
+        newLexer("cheese /* * * * / * / */ toasty");
 
-        assertNextToken( Token.IDENTIFIER,
-                         "cheese" );
+        assertNextToken(Token.IDENTIFIER, "cheese");
 
-        assertNextToken( Token.IDENTIFIER,
-                         "toasty" );
+        assertNextToken(Token.IDENTIFIER, "toasty");
 
         assertEnd();
     }
 
-    public void testIgnoredWhitespace()
-        throws Exception
-    {
-        newLexer( " \r \n \r\n \n\r    \t   \t");
+    public void testIgnoredWhitespace() throws Exception {
+        newLexer(" \r \n \r\n \n\r    \t   \t");
+
+        assertNextToken(Token.NEWLINE, "<newline>");
+        assertNextToken(Token.NEWLINE, "<newline>");
+        assertNextToken(Token.NEWLINE, "<newline>");
 
-        assertNextToken( Token.NEWLINE, "<newline>" );
-        assertNextToken( Token.NEWLINE, "<newline>" );
-        assertNextToken( Token.NEWLINE, "<newline>" );
-        
         assertEnd();
     }
 
-    public void testLeftCurlyBrace()
-        throws Exception
-    {
-        assertSimple( "{",
-                      Token.LEFT_CURLY_BRACE );
+    public void testLeftCurlyBrace() throws Exception {
+        assertSimple("{", Token.LEFT_CURLY_BRACE);
     }
 
-    public void testRightCurlyBrace()
-        throws Exception
-    {
-        assertSimple( "}",
-                      Token.RIGHT_CURLY_BRACE );
+    public void testRightCurlyBrace() throws Exception {
+        assertSimple("}", Token.RIGHT_CURLY_BRACE);
     }
 
-    public void testLeftSquareBracket()
-        throws Exception
-    {
-        assertSimple( "[",
-                      Token.LEFT_SQUARE_BRACKET );
+    public void testLeftSquareBracket() throws Exception {
+        assertSimple("[", Token.LEFT_SQUARE_BRACKET);
     }
 
-    public void testRightSquareBracket()
-        throws Exception
-    {
-        assertSimple( "]",
-                      Token.RIGHT_SQUARE_BRACKET );
+    public void testRightSquareBracket() throws Exception {
+        assertSimple("]", Token.RIGHT_SQUARE_BRACKET);
     }
 
-    public void testLeftParenthesis()
-        throws Exception
-    {
-        assertSimple( "(",
-                      Token.LEFT_PARENTHESIS );
+    public void testLeftParenthesis() throws Exception {
+        assertSimple("(", Token.LEFT_PARENTHESIS);
     }
 
-    public void testRightParenthesis()
-        throws Exception
-    {
-        assertSimple( ")",
-                      Token.RIGHT_PARENTHESIS );
+    public void testRightParenthesis() throws Exception {
+        assertSimple(")", Token.RIGHT_PARENTHESIS);
     }
 
-    public void testDot()
-        throws Exception
-    {
-        assertSimple( ".",
-                      Token.DOT );
+    public void testDot() throws Exception {
+        assertSimple(".", Token.DOT);
     }
 
-    public void testDotDot()
-        throws Exception
-    {
-        assertSimple( "..",
-                      Token.DOT_DOT );
+    public void testDotDot() throws Exception {
+        assertSimple("..", Token.DOT_DOT);
     }
 
-    public void testNot()
-        throws Exception
-    {
-        assertSimple( "!",
-                      Token.NOT );
+    public void testNot() throws Exception {
+        assertSimple("!", Token.NOT);
     }
 
-    public void testCompareNotEqual()
-        throws Exception
-    {
-        assertSimple( "!=",
-                      Token.COMPARE_NOT_EQUAL );
+    public void testCompareNotEqual() throws Exception {
+        assertSimple("!=", Token.COMPARE_NOT_EQUAL);
     }
 
-    public void testEqual()
-        throws Exception
-    {
-        assertSimple( "=",
-                      Token.EQUAL );
+    public void testEqual() throws Exception {
+        assertSimple("=", Token.EQUAL);
     }
 
-    public void testCompareEqual()
-        throws Exception
-    {
-        assertSimple( "==",
-                      Token.COMPARE_EQUAL );
+    public void testCompareEqual() throws Exception {
+        assertSimple("==", Token.COMPARE_EQUAL);
     }
 
-    public void testCompareIdentical()
-        throws Exception
-    {
-        assertSimple( "===",
-                      Token.COMPARE_IDENTICAL );
+    public void testCompareIdentical() throws Exception {
+        assertSimple("===", Token.COMPARE_IDENTICAL);
     }
 
-    public void testCompareLessThan()
-        throws Exception
-    {
-        assertSimple( "<",
-                      Token.COMPARE_LESS_THAN );
+    public void testCompareLessThan() throws Exception {
+        assertSimple("<", Token.COMPARE_LESS_THAN);
     }
 
-    public void testCompareLessThanEqual()
-        throws Exception
-    {
-        assertSimple( "<=",
-                      Token.COMPARE_LESS_THAN_EQUAL );
+    public void testCompareLessThanEqual() throws Exception {
+        assertSimple("<=", Token.COMPARE_LESS_THAN_EQUAL);
     }
 
-    public void testCompareGreaterThan()
-        throws Exception
-    {
-        assertSimple( ">",
-                      Token.COMPARE_GREATER_THAN );
+    public void testCompareGreaterThan() throws Exception {
+        assertSimple(">", Token.COMPARE_GREATER_THAN);
     }
 
-    public void testCompareGreaterThanEqual()
-    throws Exception
-    {
-        assertSimple( ">=",
-            Token.COMPARE_GREATER_THAN_EQUAL );
+    public void testCompareGreaterThanEqual() throws Exception {
+        assertSimple(">=", Token.COMPARE_GREATER_THAN_EQUAL);
     }
 
-    public void testCompareTo()
-    throws Exception
-    {
-        assertSimple( "<=>",
-            Token.COMPARE_TO );
+    public void testCompareTo() throws Exception {
+        assertSimple("<=>", Token.COMPARE_TO);
     }
 
-    public void testNavigate()
-    throws Exception
-    {
-        assertSimple( "->",
-            Token.NAVIGATE );
+    public void testNavigate() throws Exception {
+        assertSimple("->", Token.NAVIGATE);
     }
 
-    public void testLogicalOr()
-        throws Exception
-    {
-        assertSimple( "||",
-                      Token.LOGICAL_OR );
+    public void testLogicalOr() throws Exception {
+        assertSimple("||", Token.LOGICAL_OR);
     }
 
-    public void testPipe()
-        throws Exception
-    {
-        assertSimple( "|",
-                      Token.PIPE );
+    public void testPipe() throws Exception {
+        assertSimple("|", Token.PIPE);
     }
 
-    public void testLogicalAnd()
-        throws Exception
-    {
-        assertSimple( "&&",
-                      Token.LOGICAL_AND );
+    public void testLogicalAnd() throws Exception {
+        assertSimple("&&", Token.LOGICAL_AND);
     }
 
-    public void testAmpersand_UnexpectedCharacter()
-        throws Exception
-    {
-        newLexer( "&a" );
+    public void testAmpersand_UnexpectedCharacter() throws Exception {
+        newLexer("&a");
 
-        char[] expected = assertUnexpectedCharacter( 'a',
-                                                     1,
-                                                     2 );
+        char[] expected = assertUnexpectedCharacter('a', 1, 2);
 
-        assertLength( 1,
-                      expected );
+        assertLength(1, expected);
 
-        assertContains( '&',
-                        expected );
+        assertContains('&', expected);
     }
 
-    public void testPlus()
-        throws Exception
-    {
-        assertSimple( "+",
-                      Token.PLUS );
+    public void testPlus() throws Exception {
+        assertSimple("+", Token.PLUS);
     }
 
-    public void testPlusPlus()
-        throws Exception
-    {
-        assertSimple( "++",
-                      Token.PLUS_PLUS );
+    public void testPlusPlus() throws Exception {
+        assertSimple("++", Token.PLUS_PLUS);
     }
 
-    public void testPlusEqual()
-        throws Exception
-    {
-        assertSimple( "+=",
-                      Token.PLUS_EQUAL );
+    public void testPlusEqual() throws Exception {
+        assertSimple("+=", Token.PLUS_EQUAL);
     }
 
-    public void testMinus()
-        throws Exception
-    {
-        assertSimple( "-",
-                      Token.MINUS );
+    public void testMinus() throws Exception {
+        assertSimple("-", Token.MINUS);
     }
 
-    public void testMinusMinus()
-        throws Exception
-    {
-        assertSimple( "--",
-                      Token.MINUS_MINUS );
+    public void testMinusMinus() throws Exception {
+        assertSimple("--", Token.MINUS_MINUS);
     }
 
-    public void testMinusEqual()
-        throws Exception
-    {
-        assertSimple( "-=",
-                      Token.MINUS_EQUAL );
+    public void testMinusEqual() throws Exception {
+        assertSimple("-=", Token.MINUS_EQUAL);
     }
 
-    public void testDivide()
-        throws Exception
-    {
-        assertSimple( "/",
-                      Token.DIVIDE );
+    public void testDivide() throws Exception {
+        assertSimple("/", Token.DIVIDE);
     }
 
-    public void testDivideEqual()
-        throws Exception
-    {
-        assertSimple( "/=",
-                      Token.DIVIDE_EQUAL );
+    public void testDivideEqual() throws Exception {
+        assertSimple("/=", Token.DIVIDE_EQUAL);
     }
 
-    public void testMod()
-        throws Exception
-    {
-        assertSimple( "%",
-                      Token.MOD );
+    public void testMod() throws Exception {
+        assertSimple("%", Token.MOD);
     }
 
-    public void testModEqual()
-        throws Exception
-    {
-        assertSimple( "%=",
-                      Token.MOD_EQUAL );
+    public void testModEqual() throws Exception {
+        assertSimple("%=", Token.MOD_EQUAL);
     }
 
-    public void testMultiply()
-        throws Exception
-    {
-        assertSimple( "*",
-                      Token.MULTIPLY );
+    public void testMultiply() throws Exception {
+        assertSimple("*", Token.MULTIPLY);
     }
 
-    public void testMultiplyEqual()
-        throws Exception
-    {
-        assertSimple( "*=",
-                      Token.MULTIPLY_EQUAL );
+    public void testMultiplyEqual() throws Exception {
+        assertSimple("*=", Token.MULTIPLY_EQUAL);
     }
 
-    public void testColon()
-        throws Exception
-    {
-        assertSimple( ":",
-                      Token.COLON );
+    public void testColon() throws Exception {
+        assertSimple(":", Token.COLON);
     }
 
-    public void testSemicolon()
-        throws Exception
-    {
-        assertSimple( ";",
-                      Token.SEMICOLON );
+    public void testSemicolon() throws Exception {
+        assertSimple(";", Token.SEMICOLON);
     }
 
-    public void testQuestion()
-        throws Exception
-    {
-        assertSimple( "?",
-                      Token.QUESTION );
+    public void testQuestion() throws Exception {
+        assertSimple("?", Token.QUESTION);
     }
 
-    public void testDoubleQuoteString_Simple()
-        throws Exception
-    {
-        newLexer( "\"cheese\"" );
+    public void testDoubleQuoteString_Simple() throws Exception {
+        newLexer("\"cheese\"");
 
-        assertNextToken( Token.DOUBLE_QUOTE_STRING,
-                         "cheese" );
+        assertNextToken(Token.DOUBLE_QUOTE_STRING, "cheese");
 
         assertEnd();
     }
 
-    public void testDoubleQuoteString_EscapedTab()
-        throws Exception
-    {
-        newLexer( "\"che\\tese\"" );
+    public void testDoubleQuoteString_EscapedDollar() throws Exception {
+        newLexer("\"foo $${bar}\"");
 
-        assertNextToken( Token.DOUBLE_QUOTE_STRING,
-                         "che\tese" );
+        assertNextToken(Token.DOUBLE_QUOTE_STRING, "foo $${bar}");
 
         assertEnd();
     }
 
-    public void testDoubleQuoteString_EscapedNewline()
-        throws Exception
-    {
-        newLexer( "\"che\\nese\"" );
+    public void testDoubleQuoteString_EscapedTab() throws Exception {
+        newLexer("\"che\\tese\"");
 
-        assertNextToken( Token.DOUBLE_QUOTE_STRING,
-                         "che\nese" );
+        assertNextToken(Token.DOUBLE_QUOTE_STRING, "che\tese");
 
         assertEnd();
     }
-    
-    public void testDoubleQuoteString_EscapedCarriageReturn()
-        throws Exception
-    {
-        newLexer( "\"che\\rese\"" );
 
-        assertNextToken( Token.DOUBLE_QUOTE_STRING,
-                         "che\rese" );
+    public void testDoubleQuoteString_EscapedNewline() throws Exception {
+        newLexer("\"che\\nese\"");
+
+        assertNextToken(Token.DOUBLE_QUOTE_STRING, "che\nese");
 
         assertEnd();
     }
 
-    public void testDoubleQuoteString_EscapedOther()
-        throws Exception
-    {
-        newLexer( "\"che\\bese\"" );
+    public void testDoubleQuoteString_EscapedCarriageReturn() throws Exception {
+        newLexer("\"che\\rese\"");
 
-        assertNextToken( Token.DOUBLE_QUOTE_STRING,
-                         "chebese" );
+        assertNextToken(Token.DOUBLE_QUOTE_STRING, "che\rese");
 
         assertEnd();
     }
 
-    public void testSingleQuoteString_Simple()
-        throws Exception
-    {
-        newLexer( "'cheese'" );
+    public void testDoubleQuoteString_EscapedOther() throws Exception {
+        newLexer("\"che\\bese\"");
 
-        assertNextToken( Token.SINGLE_QUOTE_STRING,
-                         "cheese" );
+        assertNextToken(Token.DOUBLE_QUOTE_STRING, "chebese");
 
         assertEnd();
     }
 
-    public void testSingleQuoteString_EscapedTab()
-        throws Exception
-    {
-        newLexer( "'che\\tese'" );
+    public void testSingleQuoteString_Simple() throws Exception {
+        newLexer("'cheese'");
 
-        assertNextToken( Token.SINGLE_QUOTE_STRING,
-                         "che\tese" );
+        assertNextToken(Token.SINGLE_QUOTE_STRING, "cheese");
 
         assertEnd();
     }
 
-    public void testSingleQuoteString_EscapedNewline()
-        throws Exception
-    {
-        newLexer( "'che\\nese'" );
+    public void testSingleQuoteString_EscapedTab() throws Exception {
+        newLexer("'che\\tese'");
 
-        assertNextToken( Token.SINGLE_QUOTE_STRING,
-                         "che\nese" );
+        assertNextToken(Token.SINGLE_QUOTE_STRING, "che\tese");
 
         assertEnd();
     }
-    
-    public void testSingleQuoteString_EscapedCarriageReturn()
-        throws Exception
-    {
-        newLexer( "'che\\rese'" );
 
-        assertNextToken( Token.SINGLE_QUOTE_STRING,
-                         "che\rese" );
+    public void testSingleQuoteString_EscapedNewline() throws Exception {
+        newLexer("'che\\nese'");
+
+        assertNextToken(Token.SINGLE_QUOTE_STRING, "che\nese");
 
         assertEnd();
     }
 
-    public void testSingleQuoteString_EscapedOther()
-        throws Exception
-    {
-        newLexer( "'che\\bese'" );
+    public void testSingleQuoteString_EscapedCarriageReturn() throws Exception {
+        newLexer("'che\\rese'");
 
-        assertNextToken( Token.SINGLE_QUOTE_STRING,
-                         "chebese" );
+        assertNextToken(Token.SINGLE_QUOTE_STRING, "che\rese");
 
         assertEnd();
     }
 
-    public void testUnterminatedStringLiteral_DoubleQuote_Newline()
-        throws Exception
-    {
-        newLexer( "\"cheese\n\"" );
+    public void testSingleQuoteString_EscapedOther() throws Exception {
+        newLexer("'che\\bese'");
+
+        assertNextToken(Token.SINGLE_QUOTE_STRING, "chebese");
+
+        assertEnd();
+    }
 
-        try
-        {
+    public void testUnterminatedStringLiteral_DoubleQuote_Newline() throws Exception {
+        newLexer("\"cheese\n");
+
+        try {
             nextToken();
-            fail( "should have thrown UnterminatedStringLiteralException" );
+            fail("should have thrown UnterminatedStringLiteralException");
         }
-        catch (UnterminatedStringLiteralException e)
-        {
+        catch (UnterminatedStringLiteralException e) {
             // expected and correct
         }
     }
 
-    public void testUnterminatedStringLiteral_DoubleQuote_CarriageReturn()
-        throws Exception
-    {
-        newLexer( "\"cheese\r\"" );
+    public void testUnterminatedStringLiteral_DoubleQuote_CarriageReturn() throws Exception {
+        newLexer("\"cheese\r");
 
-        try
-        {
+        try {
             nextToken();
-            fail( "should have thrown UnterminatedStringLiteralException" );
+            fail("should have thrown UnterminatedStringLiteralException");
         }
-        catch (UnterminatedStringLiteralException e)
-        {
+        catch (UnterminatedStringLiteralException e) {
             // expected and correct
         }
     }
 
-    public void testUnterminatedStringLiteral_DoubleQuote_EndOfStream()
-        throws Exception
-    {
-        newLexer( "\"cheese" );
+    public void testUnterminatedStringLiteral_DoubleQuote_EndOfStream() throws Exception {
+        newLexer("\"cheese");
 
-        try
-        {
+        try {
             nextToken();
-            fail( "should have thrown UnterminatedStringLiteralException" );
+            fail("should have thrown UnterminatedStringLiteralException");
         }
-        catch (UnterminatedStringLiteralException e)
-        {
+        catch (UnterminatedStringLiteralException e) {
             // expected and correct
         }
     }
 
-    public void testUnterminatedStringLiteral_SingleQuote_Newline()
-        throws Exception
-    {
-        newLexer( "'cheese\n'" );
+    public void testUnterminatedStringLiteral_SingleQuote_Newline() throws Exception {
+        newLexer("'cheese\n'");
 
-        try
-        {
+        try {
             nextToken();
-            fail( "should have thrown UnterminatedStringLiteralException" );
+            fail("should have thrown UnterminatedStringLiteralException");
         }
-        catch (UnterminatedStringLiteralException e)
-        {
+        catch (UnterminatedStringLiteralException e) {
             // expected and correct
         }
     }
 
-    public void testUnterminatedStringLiteral_SingleQuote_CarriageReturn()
-        throws Exception
-    {
-        newLexer( "'cheese\r'" );
+    public void testUnterminatedStringLiteral_SingleQuote_CarriageReturn() throws Exception {
+        newLexer("'cheese\r'");
 
-        try
-        {
+        try {
             nextToken();
-            fail( "should have thrown UnterminatedStringLiteralException" );
+            fail("should have thrown UnterminatedStringLiteralException");
         }
-        catch (UnterminatedStringLiteralException e)
-        {
+        catch (UnterminatedStringLiteralException e) {
             // expected and correct
         }
     }
-    
-    public void testUnterminatedStringLiteral_SingleQuote_EndOfStream()
-        throws Exception
-    {
-        newLexer( "'cheese" );
 
-        try
-        {
+    public void testUnterminatedStringLiteral_SingleQuote_EndOfStream() throws Exception {
+        newLexer("'cheese");
+
+        try {
             nextToken();
-            fail( "should have thrown UnterminatedStringLiteralException" );
+            fail("should have thrown UnterminatedStringLiteralException");
         }
-        catch (UnterminatedStringLiteralException e)
-        {
+        catch (UnterminatedStringLiteralException e) {
             // expected and correct
         }
     }
 
-    public void testIdentifier()
-        throws Exception
-    {
-        assertSimple( "cheese",
-                      Token.IDENTIFIER );
+    public void testIdentifier() throws Exception {
+        assertSimple("cheese", Token.IDENTIFIER);
     }
 
-    public void testNumber_Integer()
-        throws Exception
-    {
-        assertSimple( "42",
-                      Token.INTEGER_NUMBER );
+    public void testNumber_Integer() throws Exception {
+        assertSimple("42", Token.INTEGER_NUMBER);
     }
 
-    public void testNumber_FloatingPoint()
-        throws Exception
-    {
-        assertSimple( "42.84",
-                      Token.FLOAT_NUMBER );
-    }
-
-	public void testNumber_IntegerCall()
-		throws Exception
-	{
-		newLexer( "42.cheese");
-    	
-		assertNextToken(Token.INTEGER_NUMBER, "42");
-		assertNextToken(Token.DOT, ".");
-		assertNextToken(Token.IDENTIFIER, "cheese");
-	}
-
-	public void testNumber_FloatCall()
-		throws Exception
-	{
-		newLexer( "42.0.cheese");
-    	
-		assertNextToken(Token.FLOAT_NUMBER, "42.0");
-		assertNextToken(Token.DOT, ".");
-		assertNextToken(Token.IDENTIFIER, "cheese");
-	}
+    public void testNumber_FloatingPoint() throws Exception {
+        assertSimple("42.84", Token.FLOAT_NUMBER);
+    }
+
+    public void testNumber_IntegerCall() throws Exception {
+        newLexer("42.cheese");
+
+        assertNextToken(Token.INTEGER_NUMBER, "42");
+        assertNextToken(Token.DOT, ".");
+        assertNextToken(Token.IDENTIFIER, "cheese");
+    }
+
+    public void testNumber_FloatCall() throws Exception {
+        newLexer("42.0.cheese");
+
+        assertNextToken(Token.FLOAT_NUMBER, "42.0");
+        assertNextToken(Token.DOT, ".");
+        assertNextToken(Token.IDENTIFIER, "cheese");
+    }
 
     /*
     public void testNumber_UnexpectedCharacter()
         throws Exception
     {
         newLexer( "4.0cheese" );
-
+    
         char[] expected = assertUnexpectedCharacter( 'c',
                                                      1,
                                                      4 );
-
+    
         assertLength( 10,
                       expected );
-
+    
         assertContains( '0',
                         expected );
         assertContains( '1',
@@ -678,368 +472,229 @@ public class LexerTest
                         expected );
     }
     */
-    
+
     // ----------------------------------------------------------------------
     // ----------------------------------------------------------------------
 
-    public void testKeyword_Abstract()
-        throws Exception
-    {
-        assertSimple( "abstract",
-                       Token.KEYWORD_ABSTRACT );
+    public void testKeyword_Abstract() throws Exception {
+        assertSimple("abstract", Token.KEYWORD_ABSTRACT);
     }
 
-    public void testKeyword_As()
-        throws Exception
-    {
-        assertSimple( "as",
-                      Token.KEYWORD_AS );
+    public void testKeyword_As() throws Exception {
+        assertSimple("as", Token.KEYWORD_AS);
     }
 
-    public void testKeyword_Break()
-        throws Exception
-    {
-        assertSimple( "break",
-                      Token.KEYWORD_BREAK );
+    public void testKeyword_Break() throws Exception {
+        assertSimple("break", Token.KEYWORD_BREAK);
     }
 
-    public void testKeyword_Case()
-        throws Exception
-    {
-        assertSimple( "case",
-                      Token.KEYWORD_CASE );
+    public void testKeyword_Case() throws Exception {
+        assertSimple("case", Token.KEYWORD_CASE);
     }
 
-    public void testKeyword_Catch()
-        throws Exception
-    {
-        assertSimple( "catch",
-                      Token.KEYWORD_CATCH );
+    public void testKeyword_Catch() throws Exception {
+        assertSimple("catch", Token.KEYWORD_CATCH);
     }
 
-    public void testKeyword_Class()
-        throws Exception
-    {
-        assertSimple( "class",
-                      Token.KEYWORD_CLASS );
+    public void testKeyword_Class() throws Exception {
+        assertSimple("class", Token.KEYWORD_CLASS);
     }
 
-    public void testKeyword_Const()
-        throws Exception
-    {
-        assertSimple( "const",
-                      Token.KEYWORD_CONST );
+    public void testKeyword_Const() throws Exception {
+        assertSimple("const", Token.KEYWORD_CONST);
     }
 
-    public void testKeyword_Continue()
-        throws Exception
-    {
-        assertSimple( "continue",
-                      Token.KEYWORD_CONTINUE );
+    public void testKeyword_Continue() throws Exception {
+        assertSimple("continue", Token.KEYWORD_CONTINUE);
     }
 
-    public void testKeyword_Default()
-        throws Exception
-    {
-        assertSimple( "default",
-                      Token.KEYWORD_DEFAULT );
+    public void testKeyword_Default() throws Exception {
+        assertSimple("default", Token.KEYWORD_DEFAULT);
     }
 
-    public void testKeyword_Do()
-        throws Exception
-    {
-        assertSimple( "do",
-                      Token.KEYWORD_DO );
+    public void testKeyword_Do() throws Exception {
+        assertSimple("do", Token.KEYWORD_DO);
     }
 
-    public void testKeyword_Else()
-        throws Exception
-    {
-        assertSimple( "else",
-                      Token.KEYWORD_ELSE );
+    public void testKeyword_Else() throws Exception {
+        assertSimple("else", Token.KEYWORD_ELSE);
     }
 
-    public void testKeyword_Extends()
-        throws Exception
-    {
-        assertSimple( "extends",
-                      Token.KEYWORD_EXTENDS );
+    public void testKeyword_Extends() throws Exception {
+        assertSimple("extends", Token.KEYWORD_EXTENDS);
     }
 
-    public void testKeyword_Final()
-        throws Exception
-    {
-        assertSimple( "final",
-                      Token.KEYWORD_FINAL );
+    public void testKeyword_Final() throws Exception {
+        assertSimple("final", Token.KEYWORD_FINAL);
     }
 
-    public void testKeyword_Finally()
-        throws Exception
-    {
-        assertSimple( "finally",
-                      Token.KEYWORD_FINALLY );
+    public void testKeyword_Finally() throws Exception {
+        assertSimple("finally", Token.KEYWORD_FINALLY);
     }
 
-    public void testKeyword_For()
-        throws Exception
-    {
-        assertSimple( "for",
-                      Token.KEYWORD_FOR );
+    public void testKeyword_For() throws Exception {
+        assertSimple("for", Token.KEYWORD_FOR);
     }
 
-    public void testKeyword_Goto()
-        throws Exception
-    {
-        assertSimple( "goto",
-                      Token.KEYWORD_GOTO );
+    public void testKeyword_Goto() throws Exception {
+        assertSimple("goto", Token.KEYWORD_GOTO);
     }
 
-    public void testKeyword_If()
-        throws Exception
-    {
-        assertSimple( "if",
-                      Token.KEYWORD_IF );
+    public void testKeyword_If() throws Exception {
+        assertSimple("if", Token.KEYWORD_IF);
     }
 
-    public void testKeyword_Implements()
-        throws Exception
-    {
-        assertSimple( "implements",
-                      Token.KEYWORD_IMPLEMENTS );
+    public void testKeyword_Implements() throws Exception {
+        assertSimple("implements", Token.KEYWORD_IMPLEMENTS);
     }
 
-    public void testKeyword_Import()
-        throws Exception
-    {
-        assertSimple( "import",
-                      Token.KEYWORD_IMPORT );
+    public void testKeyword_Import() throws Exception {
+        assertSimple("import", Token.KEYWORD_IMPORT);
     }
 
-    public void testKeyword_Instanceof()
-        throws Exception
-    {
-        assertSimple( "instanceof",
-                      Token.KEYWORD_INSTANCEOF );
+    public void testKeyword_Instanceof() throws Exception {
+        assertSimple("instanceof", Token.KEYWORD_INSTANCEOF);
     }
 
-    public void testKeyword_Interface()
-        throws Exception
-    {
-        assertSimple( "interface",
-                      Token.KEYWORD_INTERFACE );
+    public void testKeyword_Interface() throws Exception {
+        assertSimple("interface", Token.KEYWORD_INTERFACE);
     }
 
-    public void testKeyword_Native()
-        throws Exception
-    {
-        assertSimple( "native",
-                      Token.KEYWORD_NATIVE );
+    public void testKeyword_Native() throws Exception {
+        assertSimple("native", Token.KEYWORD_NATIVE);
     }
 
-    public void testKeyword_New()
-        throws Exception
-    {
-        assertSimple( "new",
-                      Token.KEYWORD_NEW );
+    public void testKeyword_New() throws Exception {
+        assertSimple("new", Token.KEYWORD_NEW);
     }
 
-    public void testKeyword_Package()
-        throws Exception
-    {
-        assertSimple( "package",
-                      Token.KEYWORD_PACKAGE );
+    public void testKeyword_Package() throws Exception {
+        assertSimple("package", Token.KEYWORD_PACKAGE);
     }
 
-    public void testKeyword_Private()
-        throws Exception
-    {
-        assertSimple( "private",
-                     Token.KEYWORD_PRIVATE );
+    public void testKeyword_Private() throws Exception {
+        assertSimple("private", Token.KEYWORD_PRIVATE);
     }
 
-    public void testKeyword_Property()
-        throws Exception
-    {
-        assertSimple( "property",
-                     Token.KEYWORD_PROPERTY );
+    public void testKeyword_Property() throws Exception {
+        assertSimple("property", Token.KEYWORD_PROPERTY);
     }
 
-    public void testKeyword_Protected()
-        throws Exception
-    {
-        assertSimple( "protected",
-                      Token.KEYWORD_PROTECTED );
+    public void testKeyword_Protected() throws Exception {
+        assertSimple("protected", Token.KEYWORD_PROTECTED);
     }
 
-    public void testKeyword_Public()
-        throws Exception
-    {
-        assertSimple( "public",
-                      Token.KEYWORD_PUBLIC );
+    public void testKeyword_Public() throws Exception {
+        assertSimple("public", Token.KEYWORD_PUBLIC);
     }
 
-    public void testKeyword_Return()
-        throws Exception
-    {
-        assertSimple( "return",
-                      Token.KEYWORD_RETURN );
+    public void testKeyword_Return() throws Exception {
+        assertSimple("return", Token.KEYWORD_RETURN);
     }
 
-    public void testKeyword_Static()
-        throws Exception
-    {
-        assertSimple( "static",
-                      Token.KEYWORD_STATIC );
+    public void testKeyword_Static() throws Exception {
+        assertSimple("static", Token.KEYWORD_STATIC);
     }
 
-    public void testKeyword_Super()
-        throws Exception
-    {
-        assertSimple( "super",
-                      Token.KEYWORD_SUPER );
+    public void testKeyword_Super() throws Exception {
+        assertSimple("super", Token.KEYWORD_SUPER);
     }
 
-    public void testKeyword_Switch()
-        throws Exception
-    {
-        assertSimple( "switch",
-                      Token.KEYWORD_SWITCH );
+    public void testKeyword_Switch() throws Exception {
+        assertSimple("switch", Token.KEYWORD_SWITCH);
     }
 
-    public void testKeyword_Synchronized()
-        throws Exception
-    {
-        assertSimple( "synchronized",
-                      Token.KEYWORD_SYNCHRONIZED );
+    public void testKeyword_Synchronized() throws Exception {
+        assertSimple("synchronized", Token.KEYWORD_SYNCHRONIZED);
     }
 
-    public void testKeyword_This()
-        throws Exception
-    {
-        assertSimple( "this",
-                      Token.KEYWORD_THIS );
+    public void testKeyword_This() throws Exception {
+        assertSimple("this", Token.KEYWORD_THIS);
     }
 
-    public void testKeyword_Throw()
-        throws Exception
-    {
-        assertSimple( "throw",
-                      Token.KEYWORD_THROW );
+    public void testKeyword_Throw() throws Exception {
+        assertSimple("throw", Token.KEYWORD_THROW);
     }
 
-    public void testKeyword_Throws()
-        throws Exception
-    {
-        assertSimple( "throws",
-                      Token.KEYWORD_THROWS );
+    public void testKeyword_Throws() throws Exception {
+        assertSimple("throws", Token.KEYWORD_THROWS);
     }
 
-    public void testKeyword_Try()
-        throws Exception
-    {
-        assertSimple( "try",
-                      Token.KEYWORD_TRY );
+    public void testKeyword_Try() throws Exception {
+        assertSimple("try", Token.KEYWORD_TRY);
     }
 
-    public void testKeyword_While()
-        throws Exception
-    {
-        assertSimple( "while",
-                      Token.KEYWORD_WHILE );
+    public void testKeyword_While() throws Exception {
+        assertSimple("while", Token.KEYWORD_WHILE);
     }
 
-    public void testUnexpecteCharacterException()
-        throws Exception
-    {
-        newLexer( "" );
+    public void testUnexpecteCharacterException() throws Exception {
+        newLexer("");
 
-        try
-        {
+        try {
             nextToken();
-            fail( "should have thrown UnexpectedCharacterException" );
+            fail("should have thrown UnexpectedCharacterException");
         }
-        catch (UnexpectedCharacterException e)
-        {
+        catch (UnexpectedCharacterException e) {
             // expected and correct
-            assertEquals( '',
-                          e.getCharacter() );
+            assertEquals('', e.getCharacter());
         }
     }
 
     // ----------------------------------------------------------------------
     // ----------------------------------------------------------------------
 
-    protected void assertSimple(String text,
-                                int type)
-        throws Exception
-    {
-        newLexer( text );
+    protected void assertSimple(String text, int type) throws Exception {
+        newLexer(text);
+
+        assertNextToken(type, text);
 
-        assertNextToken( type,
-                         text );
-           
         assertEnd();
     }
-                                 
-    protected void assertNextToken(int type,
-                                   String text)
-        throws Exception
-    {
+
+    protected void assertNextToken(int type, String text) throws Exception {
         Token token = this.lexer.nextToken();
 
-        assertNotNull( token );
+        assertNotNull(token);
 
-        assertEquals( type,
-                      token.getType() );
+        assertEquals(type, token.getType());
 
-        assertEquals( text,
-                      token.getText() );
+        //System.out.println("Expected: " + text + " but got: " + token.getText());
+        
+        assertEquals(text, token.getText());
     }
 
-    protected void nextToken()
-        throws Exception
-    {
+    protected void nextToken() throws Exception {
         this.lexer.nextToken();
     }
 
-    protected char[] assertUnexpectedCharacter(char c,
-                                               int line,
-                                               int column)
-        throws Exception
-    {
-        try
-        {
+    protected char[] assertUnexpectedCharacter(char c, int line, int column) throws Exception {
+        try {
             this.lexer.nextToken();
-            fail( "should have thrown UnexpectedCharacterException" );
+            fail("should have thrown UnexpectedCharacterException");
         }
-        catch (UnexpectedCharacterException e)
-        {
+        catch (UnexpectedCharacterException e) {
             // expected and correct
-            assertEquals( c,
-                          e.getCharacter() );
+            assertEquals(c, e.getCharacter());
 
-            assertEquals( line,
-                          e.getLine() );
+            assertEquals(line, e.getLine());
 
-            assertEquals( column,
-                          e.getColumn() );
+            assertEquals(column, e.getColumn());
 
             return e.getExpected();
         }
 
-        return new char[]{};
+        return new char[] {
+        };
     }
 
-    protected void assertEnd()
-        throws Exception
-    {
-        assertNull( this.lexer.nextToken() );
+    protected void assertEnd() throws Exception {
+        assertNull(this.lexer.nextToken());
     }
 
-    protected void newLexer(String text)
-    {
-        StringCharStream in = new StringCharStream( text );
+    protected void newLexer(String text) {
+        StringCharStream in = new StringCharStream(text);
 
-        this.lexer = new Lexer( in );
+        this.lexer = new Lexer(in);
     }
 }
diff --git a/src/test/org/codehaus/groovy/syntax/parser/ParserTest.java b/src/test/org/codehaus/groovy/syntax/parser/ParserTest.java
index 4693bdd9e1..ee42d1cc92 100644
--- a/src/test/org/codehaus/groovy/syntax/parser/ParserTest.java
+++ b/src/test/org/codehaus/groovy/syntax/parser/ParserTest.java
@@ -9,154 +9,113 @@ import org.codehaus.groovy.syntax.lexer.LexerTokenStream;
 import org.codehaus.groovy.syntax.Token;
 import org.codehaus.groovy.syntax.TokenStream;
 
-public class ParserTest
-    extends GroovyTestCase
-{ 
+public class ParserTest extends GroovyTestCase {
 
     // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
     //     package
     // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 
-    public void testPackageDeclaration_NoDots()
-        throws Exception
-    {
-        Parser parser = newParser( "package cheese" );
+    public void testEmptyScript() throws Exception {
+        Parser parser = newParser("");
+
+        CSTNode root = parser.compilationUnit();
+
+        assertEquals(null, root.getToken());
+        
+        System.out.println("Root: " + root);
+        {
+            CSTNode child = root.getChild(0);
+            
+            System.out.println("Child: "+ child);
+            
+            //assertEquals(null, child);
+        }
+    }
+
+    public void testPackageDeclaration_NoDots() throws Exception {
+        Parser parser = newParser("package cheese");
 
         CSTNode root = parser.packageDeclaration();
 
-        assertNode( root,
-                    "package",
-                    Token.KEYWORD_PACKAGE,
-                    1 );
+        assertNode(root, "package", Token.KEYWORD_PACKAGE, 1);
 
         {
-            assertNode( root.getChild( 0 ),
-                        "cheese",
-                        Token.IDENTIFIER,
-                        0 );
+            assertNode(root.getChild(0), "cheese", Token.IDENTIFIER, 0);
         }
     }
 
-    public void testPackageDeclaration_OneDot()
-        throws Exception
-    {
-        Parser parser = newParser( "package cheese.toast" );
+    public void testPackageDeclaration_OneDot() throws Exception {
+        Parser parser = newParser("package cheese.toast");
 
         CSTNode root = parser.packageDeclaration();
 
-        assertNode( root,
-                    "package",
-                    Token.KEYWORD_PACKAGE,
-                    1 );
+        assertNode(root, "package", Token.KEYWORD_PACKAGE, 1);
 
         {
-            assertNode( root.getChild( 0 ),
-                        ".",
-                        Token.DOT,
-                        2 );
+            assertNode(root.getChild(0), ".", Token.DOT, 2);
 
             {
-                assertNode( root.getChild( 0 ).getChild( 0 ),
-                            "cheese",
-                            Token.IDENTIFIER,
-                            0 );
-
-                assertNode( root.getChild( 0 ).getChild( 1 ),
-                            "toast",
-                            Token.IDENTIFIER,
-                            0 );
+                assertNode(root.getChild(0).getChild(0), "cheese", Token.IDENTIFIER, 0);
+
+                assertNode(root.getChild(0).getChild(1), "toast", Token.IDENTIFIER, 0);
             }
         }
     }
 
-    public void testPackageDeclaration_MultipleDots()
-        throws Exception
-    {
-        Parser parser = newParser( "package cheddar.cheese.toast" );
+    public void testPackageDeclaration_MultipleDots() throws Exception {
+        Parser parser = newParser("package cheddar.cheese.toast");
 
         CSTNode root = parser.packageDeclaration();
 
-        assertNode( root,
-                    "package",
-                    Token.KEYWORD_PACKAGE,
-                    1 );
+        assertNode(root, "package", Token.KEYWORD_PACKAGE, 1);
 
         {
-            assertNode( root.getChild( 0 ),
-                        ".",
-                        Token.DOT,
-                        2 );
+            assertNode(root.getChild(0), ".", Token.DOT, 2);
 
             {
-                assertNode( root.getChild( 0 ).getChild( 0 ),
-                            ".",
-                            Token.DOT,
-                            2 );
+                assertNode(root.getChild(0).getChild(0), ".", Token.DOT, 2);
                 {
-                    assertNode( root.getChild( 0 ).getChild( 0 ).getChild( 0 ),
-                                "cheddar",
-                                Token.IDENTIFIER,
-                                0 );
-
-                    assertNode( root.getChild( 0 ).getChild( 0 ).getChild( 1 ),
-                                "cheese",
-                                Token.IDENTIFIER,
-                                0 );
+                    assertNode(root.getChild(0).getChild(0).getChild(0), "cheddar", Token.IDENTIFIER, 0);
+
+                    assertNode(root.getChild(0).getChild(0).getChild(1), "cheese", Token.IDENTIFIER, 0);
                 }
 
-                assertNode( root.getChild( 0 ).getChild( 1 ),
-                            "toast",
-                            Token.IDENTIFIER,
-                            0 );
+                assertNode(root.getChild(0).getChild(1), "toast", Token.IDENTIFIER, 0);
             }
         }
     }
 
-    public void testPackageDeclaration_UnexpectedToken_NoInitialIdentifier()
-        throws Exception
-    {
-        Parser parser = newParser( "package ." );
+    public void testPackageDeclaration_UnexpectedToken_NoInitialIdentifier() throws Exception {
+        Parser parser = newParser("package .");
 
-        try
-        {
+        try {
             parser.packageDeclaration();
-            fail( "should have thrown UnexpectedTokenException" );
+            fail("should have thrown UnexpectedTokenException");
         }
-        catch (UnexpectedTokenException e)
-        {
+        catch (UnexpectedTokenException e) {
             // expected and correct
-            assertToken( e.getToken(),
-                         ".",
-                         Token.DOT );
-            
-            assertLength( 1,
-                          e.getExpectedTypes() );
+            assertToken(e.getToken(), ".", Token.DOT);
 
-            assertContains( Token.IDENTIFIER,
-                            e.getExpectedTypes() );
+            assertLength(1, e.getExpectedTypes());
+
+            assertContains(Token.IDENTIFIER, e.getExpectedTypes());
         }
     }
 
-    public void testPackageDeclaration_UnexpectedToken_NoIdentifierFollowingDot()
-        throws Exception
-    {
-        Parser parser = newParser( "package cheese." );
+    public void testPackageDeclaration_UnexpectedToken_NoIdentifierFollowingDot() throws Exception {
+        Parser parser = newParser("package cheese.");
 
-        try
-        {
+        try {
             parser.packageDeclaration();
-            fail( "should have thrown UnexpectedTokenException" );
+            fail("should have thrown UnexpectedTokenException");
         }
-        catch (UnexpectedTokenException e)
-        {
+        catch (UnexpectedTokenException e) {
             // expected and correct
-            assertNull( e.getToken() );
-            
-            assertLength( 1,
-                          e.getExpectedTypes() );
+            assertNull(e.getToken());
 
-            assertContains( Token.IDENTIFIER,
-                            e.getExpectedTypes() );
+            assertLength(1, e.getExpectedTypes());
+
+            assertContains(Token.IDENTIFIER, e.getExpectedTypes());
         }
     }
 
@@ -164,347 +123,208 @@ public class ParserTest
     //     import
     // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 
-    public void testImportStatement_NoDots()
-        throws Exception
-    {
-        Parser parser = newParser( "import Cheese" );
+    public void testImportStatement_NoDots() throws Exception {
+        Parser parser = newParser("import Cheese");
 
         CSTNode root = parser.importStatement();
 
-        assertNode( root,
-                    "import",
-                    Token.KEYWORD_IMPORT,
-                    2 );
+        assertNode(root, "import", Token.KEYWORD_IMPORT, 2);
 
         {
-            assertNode( root.getChild( 0 ),
-                        "Cheese",
-                        Token.IDENTIFIER,
-                        0 );
+            assertNode(root.getChild(0), "Cheese", Token.IDENTIFIER, 0);
 
-            assertNullNode( root.getChild( 1 ),
-                            0 );
+            assertNullNode(root.getChild(1), 0);
         }
     }
 
-    public void testImportStatement_As_NoDots()
-        throws Exception
-    {
-        Parser parser = newParser( "import Cheese as Toast" );
+    public void testImportStatement_As_NoDots() throws Exception {
+        Parser parser = newParser("import Cheese as Toast");
 
         CSTNode root = parser.importStatement();
 
-        assertNode( root,
-                    "import",
-                    Token.KEYWORD_IMPORT,
-                    2 );
+        assertNode(root, "import", Token.KEYWORD_IMPORT, 2);
 
         {
-            assertNode( root.getChild( 0 ),
-                        "Cheese",
-                        Token.IDENTIFIER,
-                        0 );
-
-            assertNode( root.getChild( 1 ),
-                        "as",
-                        Token.KEYWORD_AS,
-                        1 );
+            assertNode(root.getChild(0), "Cheese", Token.IDENTIFIER, 0);
+
+            assertNode(root.getChild(1), "as", Token.KEYWORD_AS, 1);
             {
-                assertNode( root.getChild( 1 ).getChild( 0 ),
-                            "Toast",
-                            Token.IDENTIFIER,
-                            0 );
+                assertNode(root.getChild(1).getChild(0), "Toast", Token.IDENTIFIER, 0);
             }
         }
     }
 
-    public void testImportStatement_OneDot()
-        throws Exception
-    {
-        Parser parser = newParser( "import cheese.Toast" );
+    public void testImportStatement_OneDot() throws Exception {
+        Parser parser = newParser("import cheese.Toast");
 
         CSTNode root = parser.importStatement();
 
-        assertNode( root,
-                    "import",
-                    Token.KEYWORD_IMPORT,
-                    2 );
+        assertNode(root, "import", Token.KEYWORD_IMPORT, 2);
 
         {
-            assertNode( root.getChild( 0 ),
-                        ".",
-                        Token.DOT,
-                        2 );
+            assertNode(root.getChild(0), ".", Token.DOT, 2);
 
             {
-                assertNode( root.getChild( 0 ).getChild( 0 ),
-                            "cheese",
-                            Token.IDENTIFIER,
-                            0 );
-
-                assertNode( root.getChild( 0 ).getChild( 1 ),
-                            "Toast",
-                            Token.IDENTIFIER,
-                            0 );
+                assertNode(root.getChild(0).getChild(0), "cheese", Token.IDENTIFIER, 0);
+
+                assertNode(root.getChild(0).getChild(1), "Toast", Token.IDENTIFIER, 0);
             }
 
-            assertNullNode( root.getChild( 1 ),
-                            0 );
+            assertNullNode(root.getChild(1), 0);
         }
     }
 
-    public void testImportStatement_As_OneDot()
-        throws Exception
-    {
-        Parser parser = newParser( "import cheese.Toast as Bread" );
+    public void testImportStatement_As_OneDot() throws Exception {
+        Parser parser = newParser("import cheese.Toast as Bread");
 
         CSTNode root = parser.importStatement();
 
-        assertNode( root,
-                    "import",
-                    Token.KEYWORD_IMPORT,
-                    2 );
+        assertNode(root, "import", Token.KEYWORD_IMPORT, 2);
 
         {
-            assertNode( root.getChild( 0 ),
-                        ".",
-                        Token.DOT,
-                        2 );
+            assertNode(root.getChild(0), ".", Token.DOT, 2);
 
             {
-                assertNode( root.getChild( 0 ).getChild( 0 ),
-                            "cheese",
-                            Token.IDENTIFIER,
-                            0 );
-
-                assertNode( root.getChild( 0 ).getChild( 1 ),
-                            "Toast",
-                            Token.IDENTIFIER,
-                            0 );
+                assertNode(root.getChild(0).getChild(0), "cheese", Token.IDENTIFIER, 0);
+
+                assertNode(root.getChild(0).getChild(1), "Toast", Token.IDENTIFIER, 0);
             }
 
-            assertNode( root.getChild( 1 ),
-                        "as",
-                        Token.KEYWORD_AS,
-                        1 );
+            assertNode(root.getChild(1), "as", Token.KEYWORD_AS, 1);
             {
-                assertNode( root.getChild( 1 ).getChild( 0 ),
-                            "Bread",
-                            Token.IDENTIFIER,
-                            0 );
+                assertNode(root.getChild(1).getChild(0), "Bread", Token.IDENTIFIER, 0);
             }
         }
     }
 
-    public void testImportStatement_MultipleDots()
-        throws Exception
-    {
-        Parser parser = newParser( "import cheddar.cheese.Toast" );
+    public void testImportStatement_MultipleDots() throws Exception {
+        Parser parser = newParser("import cheddar.cheese.Toast");
 
         CSTNode root = parser.importStatement();
 
-        assertNode( root,
-                    "import",
-                    Token.KEYWORD_IMPORT,
-                    2 );
+        assertNode(root, "import", Token.KEYWORD_IMPORT, 2);
 
         {
-            assertNode( root.getChild( 0 ),
-                        ".",
-                        Token.DOT,
-                        2 );
+            assertNode(root.getChild(0), ".", Token.DOT, 2);
 
             {
-                assertNode( root.getChild( 0 ).getChild( 0 ),
-                            ".",
-                            Token.DOT,
-                            2 );
+                assertNode(root.getChild(0).getChild(0), ".", Token.DOT, 2);
                 {
-                    assertNode( root.getChild( 0 ).getChild( 0 ).getChild( 0 ),
-                                "cheddar",
-                                Token.IDENTIFIER,
-                                0 );
-
-                    assertNode( root.getChild( 0 ).getChild( 0 ).getChild( 1 ),
-                                "cheese",
-                                Token.IDENTIFIER,
-                                0 );
+                    assertNode(root.getChild(0).getChild(0).getChild(0), "cheddar", Token.IDENTIFIER, 0);
+
+                    assertNode(root.getChild(0).getChild(0).getChild(1), "cheese", Token.IDENTIFIER, 0);
                 }
-                
-                assertNode( root.getChild( 0 ).getChild( 1 ),
-                            "Toast",
-                            Token.IDENTIFIER,
-                            0 );
+
+                assertNode(root.getChild(0).getChild(1), "Toast", Token.IDENTIFIER, 0);
             }
 
-            assertNullNode( root.getChild( 1 ),
-                            0 );
+            assertNullNode(root.getChild(1), 0);
         }
     }
 
-    public void testImportStatement_As_MultipleDots()
-        throws Exception
-    {
-        Parser parser = newParser( "import cheddar.cheese.Toast as Bread" );
+    public void testImportStatement_As_MultipleDots() throws Exception {
+        Parser parser = newParser("import cheddar.cheese.Toast as Bread");
 
         CSTNode root = parser.importStatement();
 
-        assertNode( root,
-                    "import",
-                    Token.KEYWORD_IMPORT,
-                    2 );
+        assertNode(root, "import", Token.KEYWORD_IMPORT, 2);
 
         {
-            assertNode( root.getChild( 0 ),
-                        ".",
-                        Token.DOT,
-                        2 );
+            assertNode(root.getChild(0), ".", Token.DOT, 2);
 
             {
-                assertNode( root.getChild( 0 ).getChild( 0 ),
-                            ".",
-                            Token.DOT,
-                            2 );
+                assertNode(root.getChild(0).getChild(0), ".", Token.DOT, 2);
                 {
-                    assertNode( root.getChild( 0 ).getChild( 0 ).getChild( 0 ),
-                                "cheddar",
-                                Token.IDENTIFIER,
-                                0 );
-
-                    assertNode( root.getChild( 0 ).getChild( 0 ).getChild( 1 ),
-                                "cheese",
-                                Token.IDENTIFIER,
-                                0 );
+                    assertNode(root.getChild(0).getChild(0).getChild(0), "cheddar", Token.IDENTIFIER, 0);
+
+                    assertNode(root.getChild(0).getChild(0).getChild(1), "cheese", Token.IDENTIFIER, 0);
                 }
 
-                assertNode( root.getChild( 0 ).getChild( 1 ),
-                            "Toast",
-                            Token.IDENTIFIER,
-                            0 );
+                assertNode(root.getChild(0).getChild(1), "Toast", Token.IDENTIFIER, 0);
             }
 
-            assertNode( root.getChild( 1 ),
-                        "as",
-                        Token.KEYWORD_AS,
-                        1 );
+            assertNode(root.getChild(1), "as", Token.KEYWORD_AS, 1);
             {
-                assertNode( root.getChild( 1 ).getChild( 0 ),
-                            "Bread",
-                            Token.IDENTIFIER,
-                            0 );
+                assertNode(root.getChild(1).getChild(0), "Bread", Token.IDENTIFIER, 0);
             }
         }
     }
 
-    public void testImportStatement_UnexpectedToken_NoInitialIdentifier()
-        throws Exception
-    {
-        Parser parser = newParser( "import ." );
+    public void testImportStatement_UnexpectedToken_NoInitialIdentifier() throws Exception {
+        Parser parser = newParser("import .");
 
-        try
-        {
+        try {
             parser.importStatement();
-            fail( "should have thrown UnexpectedTokenException" );
+            fail("should have thrown UnexpectedTokenException");
         }
-        catch (UnexpectedTokenException e)
-        {
+        catch (UnexpectedTokenException e) {
             // expected and correct
-            assertToken( e.getToken(),
-                         ".",
-                         Token.DOT );
-            
-            assertLength( 1,
-                          e.getExpectedTypes() );
+            assertToken(e.getToken(), ".", Token.DOT);
 
-            assertContains( Token.IDENTIFIER,
-                            e.getExpectedTypes() );
+            assertLength(1, e.getExpectedTypes());
+
+            assertContains(Token.IDENTIFIER, e.getExpectedTypes());
         }
     }
 
-    public void testImportStatement_UnexpectedToken_NoIdentifierFollowingDot()
-        throws Exception
-    {
-        Parser parser = newParser( "import cheese." );
+    public void testImportStatement_UnexpectedToken_NoIdentifierFollowingDot() throws Exception {
+        Parser parser = newParser("import cheese.");
 
-        try
-        {
+        try {
             parser.importStatement();
-            fail( "should have thrown UnexpectedTokenException" );
+            fail("should have thrown UnexpectedTokenException");
         }
-        catch (UnexpectedTokenException e)
-        {
+        catch (UnexpectedTokenException e) {
             // expected and correct
-            assertNull( e.getToken() );
-            
-            assertLength( 1,
-                          e.getExpectedTypes() );
+            assertNull(e.getToken());
 
-            assertContains( Token.IDENTIFIER,
-                            e.getExpectedTypes() );
+            assertLength(1, e.getExpectedTypes());
+
+            assertContains(Token.IDENTIFIER, e.getExpectedTypes());
         }
     }
-        
+
     // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
     //     class
     // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 
-    public void testClassDeclaration_NoModifiers_NoBody_NoExtendsOrImplements()
-        throws Exception
-    {
-        Parser parser = newParser( "class Cheese { }" );
+    public void testClassDeclaration_NoModifiers_NoBody_NoExtendsOrImplements() throws Exception {
+        Parser parser = newParser("class Cheese { }");
 
         CSTNode modifiers = new CSTNode();
 
-        CSTNode root = parser.classDeclaration( modifiers );
+        CSTNode root = parser.classDeclaration(modifiers);
 
-        assertNode( root,
-                    "class",
-                    Token.KEYWORD_CLASS,
-                    5 );
+        assertNode(root, "class", Token.KEYWORD_CLASS, 5);
 
         {
-            assertSame( modifiers,
-                        root.getChild( 0 ) );
+            assertSame(modifiers, root.getChild(0));
 
-            assertNode( root.getChild( 1 ),
-                        "Cheese",
-                        Token.IDENTIFIER,
-                        0 );
+            assertNode(root.getChild(1), "Cheese", Token.IDENTIFIER, 0);
 
-            assertNullNode( root.getChild( 2 ),
-                            0 );
+            assertNullNode(root.getChild(2), 0);
 
-            assertNullNode( root.getChild( 3 ),
-                            0 );
+            assertNullNode(root.getChild(3), 0);
 
-            assertNullNode( root.getChild( 4 ),
-                            0 );
+            assertNullNode(root.getChild(4), 0);
         }
     }
 
-    public void testClassDeclaration_NoIdentifier()
-        throws Exception
-    {
-        Parser parser = newParser( "class {" );
+    public void testClassDeclaration_NoIdentifier() throws Exception {
+        Parser parser = newParser("class {");
 
         CSTNode modifiers = new CSTNode();
 
-        try
-        {
-            parser.classDeclaration( modifiers );
+        try {
+            parser.classDeclaration(modifiers);
         }
-        catch (UnexpectedTokenException e)
-        {
+        catch (UnexpectedTokenException e) {
             // expected and correct
-            assertToken( e.getToken(),
-                         "{",
-                         Token.LEFT_CURLY_BRACE );
+            assertToken(e.getToken(), "{", Token.LEFT_CURLY_BRACE);
 
-            assertLength( 1,
-                          e.getExpectedTypes() );
+            assertLength(1, e.getExpectedTypes());
 
-            assertContains( Token.IDENTIFIER,
-                            e.getExpectedTypes() );
+            assertContains(Token.IDENTIFIER, e.getExpectedTypes());
         }
     }
 
@@ -512,31 +332,21 @@ public class ParserTest
     //     interface
     // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 
-    public void testInterfaceDeclaration_NoModifiers_NoBody_NoExtendsOrImplements()
-        throws Exception
-    {
-        Parser parser = newParser( "interface Cheese { }" );
+    public void testInterfaceDeclaration_NoModifiers_NoBody_NoExtendsOrImplements() throws Exception {
+        Parser parser = newParser("interface Cheese { }");
 
         CSTNode modifiers = new CSTNode();
 
-        CSTNode root = parser.interfaceDeclaration( modifiers );
+        CSTNode root = parser.interfaceDeclaration(modifiers);
 
-        assertNode( root,
-                    "interface",
-                    Token.KEYWORD_INTERFACE,
-                    3 );
+        assertNode(root, "interface", Token.KEYWORD_INTERFACE, 3);
 
         {
-            assertSame( modifiers,
-                        root.getChild( 0 ) );
+            assertSame(modifiers, root.getChild(0));
 
-            assertNode( root.getChild( 1 ),
-                        "Cheese",
-                        Token.IDENTIFIER,
-                        0 );
+            assertNode(root.getChild(1), "Cheese", Token.IDENTIFIER, 0);
 
-            assertNullNode( root.getChild( 2 ),
-                            0 );
+            assertNullNode(root.getChild(2), 0);
         }
     }
 
@@ -544,143 +354,93 @@ public class ParserTest
     //     <type declaration>
     // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 
-    public void testTypeDeclaration_Class_NoModifiers_NoBody_NoExtendsOrImplements()
-        throws Exception
-    {
-        Parser parser = newParser( "class Cheese { }" );
+    public void testTypeDeclaration_Class_NoModifiers_NoBody_NoExtendsOrImplements() throws Exception {
+        Parser parser = newParser("class Cheese { }");
 
         CSTNode root = parser.typeDeclaration();
 
-        assertNode( root,
-                    "class",
-                    Token.KEYWORD_CLASS,
-                    5 );
+        assertNode(root, "class", Token.KEYWORD_CLASS, 5);
 
         {
-            assertNullNode( root.getChild( 0 ),
-                            0 );
+            assertNullNode(root.getChild(0), 0);
 
-            assertNode( root.getChild( 1 ),
-                        "Cheese",
-                        Token.IDENTIFIER,
-                        0 );
+            assertNode(root.getChild(1), "Cheese", Token.IDENTIFIER, 0);
 
-            assertNullNode( root.getChild( 2 ),
-                            0 );
+            assertNullNode(root.getChild(2), 0);
 
-            assertNullNode( root.getChild( 3 ),
-                            0 );
+            assertNullNode(root.getChild(3), 0);
 
-            assertNullNode( root.getChild( 4 ),
-                            0 );
+            assertNullNode(root.getChild(4), 0);
         }
     }
 
-    public void testTypeDeclaration_Class_WithModifiers_NoBody_NoExtendsOrImplements()
-        throws Exception
-    {
-        Parser parser = newParser( "public class Cheese { }" );
+    public void testTypeDeclaration_Class_WithModifiers_NoBody_NoExtendsOrImplements() throws Exception {
+        Parser parser = newParser("public class Cheese { }");
 
         CSTNode root = parser.typeDeclaration();
 
-        assertNode( root,
-                    "class",
-                    Token.KEYWORD_CLASS,
-                    5 );
+        assertNode(root, "class", Token.KEYWORD_CLASS, 5);
 
         {
-            assertNullNode( root.getChild( 0 ),
-                            1 );
+            assertNullNode(root.getChild(0), 1);
             {
-                assertNode( root.getChild( 0 ).getChild( 0 ),
-                            "public",
-                            Token.KEYWORD_PUBLIC,
-                            0 );
+                assertNode(root.getChild(0).getChild(0), "public", Token.KEYWORD_PUBLIC, 0);
             }
 
-            assertNode( root.getChild( 1 ),
-                        "Cheese",
-                        Token.IDENTIFIER,
-                        0 );
+            assertNode(root.getChild(1), "Cheese", Token.IDENTIFIER, 0);
 
-            assertNullNode( root.getChild( 2 ),
-                            0 );
+            assertNullNode(root.getChild(2), 0);
 
-            assertNullNode( root.getChild( 3 ),
-                            0 );
+            assertNullNode(root.getChild(3), 0);
 
-            assertNullNode( root.getChild( 4 ),
-                            0 );
+            assertNullNode(root.getChild(4), 0);
         }
     }
 
-    public void testTypeDeclaration_Interface_NoModifiers_NoBody_NoExtendsOrImplements()
-        throws Exception
-    {
-        Parser parser = newParser( "interface Cheese { }" );
+    public void testTypeDeclaration_Interface_NoModifiers_NoBody_NoExtendsOrImplements() throws Exception {
+        Parser parser = newParser("interface Cheese { }");
 
         CSTNode root = parser.typeDeclaration();
 
-        assertNode( root,
-                    "interface",
-                    Token.KEYWORD_INTERFACE,
-                    3 );
+        assertNode(root, "interface", Token.KEYWORD_INTERFACE, 3);
 
         {
-            assertNullNode( root.getChild( 0 ),
-                            0 );
+            assertNullNode(root.getChild(0), 0);
 
-            assertNode( root.getChild( 1 ),
-                        "Cheese",
-                        Token.IDENTIFIER,
-                        0 );
+            assertNode(root.getChild(1), "Cheese", Token.IDENTIFIER, 0);
 
-            assertNullNode( root.getChild( 2 ),
-                            0 );
+            assertNullNode(root.getChild(2), 0);
         }
     }
 
-    public void testTypeDeclaration_Interface_WithModifiers_NoBody_NoExtendsOrImplements()
-        throws Exception
-    {
-        Parser parser = newParser( "public interface Cheese { }" );
+    public void testTypeDeclaration_Interface_WithModifiers_NoBody_NoExtendsOrImplements() throws Exception {
+        Parser parser = newParser("public interface Cheese { }");
 
         CSTNode root = parser.typeDeclaration();
 
-        assertNode( root,
-                    "interface",
-                    Token.KEYWORD_INTERFACE,
-                    3 );
+        assertNode(root, "interface", Token.KEYWORD_INTERFACE, 3);
 
         {
-            assertNullNode( root.getChild( 0 ),
-                            1 );
+            assertNullNode(root.getChild(0), 1);
             {
-                assertNode( root.getChild( 0 ).getChild( 0 ),
-                            "public",
-                            Token.KEYWORD_PUBLIC,
-                            0 );
+                assertNode(root.getChild(0).getChild(0), "public", Token.KEYWORD_PUBLIC, 0);
             }
 
-            assertNode( root.getChild( 1 ),
-                        "Cheese",
-                        Token.IDENTIFIER,
-                        0 );
+            assertNode(root.getChild(1), "Cheese", Token.IDENTIFIER, 0);
 
-            assertNullNode( root.getChild( 2 ),
-                            0 );
+            assertNullNode(root.getChild(2), 0);
         }
     }
 
     /*
-
+    
     The following is actually now valid...
     
     public void testTypeDeclaration_UnexpectedToken()
         throws Exception
     {
         Parser parser = newParser( "cheese" );
-
+    
         try
         {
             parser.typeDeclaration();
@@ -691,13 +451,13 @@ public class ParserTest
             assertToken( e.getToken(),
                          "cheese",
                          Token.IDENTIFIER );
-
+    
             assertLength( 2,
                           e.getExpectedTypes() );
-
+    
             assertContains( Token.KEYWORD_CLASS,
                             e.getExpectedTypes() );
-
+    
             assertContains( Token.KEYWORD_INTERFACE,
                             e.getExpectedTypes() );
         }
@@ -708,175 +468,103 @@ public class ParserTest
     //     <compilation unit>
     // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 
-    public void testCompilationUnit_NoImports_OneClass()
-        throws Exception
-    {
-        Parser parser = newParser( "package cheese; public class Cheese{}" );
+    public void testCompilationUnit_NoImports_OneClass() throws Exception {
+        Parser parser = newParser("package cheese; public class Cheese{}");
 
         CSTNode root = parser.compilationUnit();
 
-        assertNullNode( root,
-                        3 );
+        assertNullNode(root, 3);
 
         {
-            assertNode( root.getChild( 0 ),
-                        "package",
-                        Token.KEYWORD_PACKAGE,
-                        1 );
+            assertNode(root.getChild(0), "package", Token.KEYWORD_PACKAGE, 1);
 
             {
-                assertNode( root.getChild( 0 ).getChild( 0 ),
-                            "cheese",
-                            Token.IDENTIFIER,
-                            0 );
+                assertNode(root.getChild(0).getChild(0), "cheese", Token.IDENTIFIER, 0);
             }
 
-            assertNullNode( root.getChild( 1 ),
-                            0 );
+            assertNullNode(root.getChild(1), 0);
 
-            assertNode( root.getChild( 2 ),
-                        "class",
-                        Token.KEYWORD_CLASS,
-                        5 );
+            assertNode(root.getChild(2), "class", Token.KEYWORD_CLASS, 5);
         }
     }
 
-    public void testCompilationUnit_NoImports_OneInterface()
-        throws Exception
-    {
-        Parser parser = newParser( "package cheese; public interface Cheese{}" );
+    public void testCompilationUnit_NoImports_OneInterface() throws Exception {
+        Parser parser = newParser("package cheese; public interface Cheese{}");
 
         CSTNode root = parser.compilationUnit();
 
-        assertNullNode( root,
-                        3 );
+        assertNullNode(root, 3);
 
         {
-            assertNode( root.getChild( 0 ),
-                        "package",
-                        Token.KEYWORD_PACKAGE,
-                        1 );
+            assertNode(root.getChild(0), "package", Token.KEYWORD_PACKAGE, 1);
 
             {
-                assertNode( root.getChild( 0 ).getChild( 0 ),
-                            "cheese",
-                            Token.IDENTIFIER,
-                            0 );
+                assertNode(root.getChild(0).getChild(0), "cheese", Token.IDENTIFIER, 0);
             }
 
-            assertNullNode( root.getChild( 1 ),
-                            0 );
+            assertNullNode(root.getChild(1), 0);
 
-            assertNode( root.getChild( 2 ),
-                        "interface",
-                        Token.KEYWORD_INTERFACE,
-                        3 );
+            assertNode(root.getChild(2), "interface", Token.KEYWORD_INTERFACE, 3);
         }
     }
 
-    public void testCompilationUnit_WithImports_OneClass()
-        throws Exception
-    {
-        Parser parser = newParser( "package cheese; import com.Toast; import com.Jelly; public class Cheese{}" );
+    public void testCompilationUnit_WithImports_OneClass() throws Exception {
+        Parser parser = newParser("package cheese; import com.Toast; import com.Jelly; public class Cheese{}");
 
         CSTNode root = parser.compilationUnit();
 
-        assertNullNode( root,
-                        3 );
+        assertNullNode(root, 3);
 
         {
-            assertNode( root.getChild( 0 ),
-                        "package",
-                        Token.KEYWORD_PACKAGE,
-                        1 );
+            assertNode(root.getChild(0), "package", Token.KEYWORD_PACKAGE, 1);
 
             {
-                assertNode( root.getChild( 0 ).getChild( 0 ),
-                            "cheese",
-                            Token.IDENTIFIER,
-                            0 );
+                assertNode(root.getChild(0).getChild(0), "cheese", Token.IDENTIFIER, 0);
             }
 
-            assertNullNode( root.getChild( 1 ),
-                            2 );
+            assertNullNode(root.getChild(1), 2);
 
             {
-                assertNode( root.getChild( 1 ).getChild( 0 ),
-                            "import",
-                            Token.KEYWORD_IMPORT,
-                            2 );
-
-                assertNode( root.getChild( 1 ).getChild( 1 ),
-                            "import",
-                            Token.KEYWORD_IMPORT,
-                            2 );
+                assertNode(root.getChild(1).getChild(0), "import", Token.KEYWORD_IMPORT, 2);
+
+                assertNode(root.getChild(1).getChild(1), "import", Token.KEYWORD_IMPORT, 2);
             }
 
-            assertNode( root.getChild( 2 ),
-                        "class",
-                        Token.KEYWORD_CLASS,
-                        5 );
+            assertNode(root.getChild(2), "class", Token.KEYWORD_CLASS, 5);
         }
     }
 
-    public void testCompilationUnit_WithImports_TwoClasses()
-        throws Exception
-    {
-        Parser parser = newParser( "package cheese; import com.Toast; import com.Jelly; public class Cheese{} public class Goober {}" );
+    public void testCompilationUnit_WithImports_TwoClasses() throws Exception {
+        Parser parser =
+            newParser("package cheese; import com.Toast; import com.Jelly; public class Cheese{} public class Goober {}");
 
         CSTNode root = parser.compilationUnit();
 
-        assertNullNode( root,
-                        4 );
+        assertNullNode(root, 4);
 
         {
-            assertNode( root.getChild( 0 ),
-                        "package",
-                        Token.KEYWORD_PACKAGE,
-                        1 );
+            assertNode(root.getChild(0), "package", Token.KEYWORD_PACKAGE, 1);
 
             {
-                assertNode( root.getChild( 0 ).getChild( 0 ),
-                            "cheese",
-                            Token.IDENTIFIER,
-                            0 );
+                assertNode(root.getChild(0).getChild(0), "cheese", Token.IDENTIFIER, 0);
             }
 
-            assertNullNode( root.getChild( 1 ),
-                            2 );
+            assertNullNode(root.getChild(1), 2);
 
             {
-                assertNode( root.getChild( 1 ).getChild( 0 ),
-                            "import",
-                            Token.KEYWORD_IMPORT,
-                            2 );
-
-                assertNode( root.getChild( 1 ).getChild( 1 ),
-                            "import",
-                            Token.KEYWORD_IMPORT,
-                            2 );
+                assertNode(root.getChild(1).getChild(0), "import", Token.KEYWORD_IMPORT, 2);
+
+                assertNode(root.getChild(1).getChild(1), "import", Token.KEYWORD_IMPORT, 2);
             }
-            
-            assertNode( root.getChild( 2 ),
-                        "class",
-                        Token.KEYWORD_CLASS,
-                        5 );
+
+            assertNode(root.getChild(2), "class", Token.KEYWORD_CLASS, 5);
             {
-                assertNode( root.getChild( 2 ).getChild( 1 ),
-                            "Cheese",
-                            Token.IDENTIFIER,
-                            0 );
+                assertNode(root.getChild(2).getChild(1), "Cheese", Token.IDENTIFIER, 0);
             }
 
-            assertNode( root.getChild( 3 ),
-                        "class",
-                        Token.KEYWORD_CLASS,
-                        5 );
+            assertNode(root.getChild(3), "class", Token.KEYWORD_CLASS, 5);
             {
-                assertNode( root.getChild( 3 ).getChild( 1 ),
-                            "Goober",
-                            Token.IDENTIFIER,
-                            0 );
+                assertNode(root.getChild(3).getChild(1), "Goober", Token.IDENTIFIER, 0);
             }
         }
     }
@@ -885,335 +573,195 @@ public class ParserTest
     //     <body statement>
     // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 
-    public void testBodyStatement_PropertyDeclaration_NoModifiers_NoType()
-        throws Exception
-    {
-        Parser parser = newParser( "property cheese;" );
+    public void testBodyStatement_PropertyDeclaration_NoModifiers_NoType() throws Exception {
+        Parser parser = newParser("property cheese;");
 
         CSTNode root = parser.bodyStatement();
 
         System.out.println("Got: " + root);
-        
-        assertNode( root,
-                    "property",
-                    Token.KEYWORD_PROPERTY,
-                    3 );
+
+        assertNode(root, "property", Token.KEYWORD_PROPERTY, 3);
 
         {
-            assertNullNode( root.getChild( 0 ),
-                            0 );
+            assertNullNode(root.getChild(0), 0);
 
-            assertNode( root.getChild( 1 ),
-                        "cheese",
-                        Token.IDENTIFIER,
-                        0 );
+            assertNode(root.getChild(1), "cheese", Token.IDENTIFIER, 0);
 
-            assertNullNode( root.getChild( 2 ),
-                            0 );
+            assertNullNode(root.getChild(2), 0);
         }
     }
 
-    public void testBodyStatement_PropertyDeclaration_OneModifier_NoType()
-        throws Exception
-    {
-        Parser parser = newParser( "static property cheese;" );
+    public void testBodyStatement_PropertyDeclaration_OneModifier_NoType() throws Exception {
+        Parser parser = newParser("static property cheese;");
 
         CSTNode root = parser.bodyStatement();
 
-        assertNode( root,
-                    "property",
-                    Token.KEYWORD_PROPERTY,
-                    3 );
+        assertNode(root, "property", Token.KEYWORD_PROPERTY, 3);
 
         {
-            assertNullNode( root.getChild( 0 ),
-                            1 );
+            assertNullNode(root.getChild(0), 1);
 
             {
-                assertNode( root.getChild( 0 ).getChild( 0 ),
-                            "static",
-                            Token.KEYWORD_STATIC,
-                            0 );
+                assertNode(root.getChild(0).getChild(0), "static", Token.KEYWORD_STATIC, 0);
             }
 
-            assertNode( root.getChild( 1 ),
-                        "cheese",
-                        Token.IDENTIFIER,
-                        0 );
+            assertNode(root.getChild(1), "cheese", Token.IDENTIFIER, 0);
 
-            assertNullNode( root.getChild( 2 ),
-                            0 );
+            assertNullNode(root.getChild(2), 0);
         }
     }
 
-    public void testBodyStatement_PropertyDeclaration_TwoModifiers_NoType()
-        throws Exception
-    {
-        Parser parser = newParser( "static synchronized property cheese;" );
+    public void testBodyStatement_PropertyDeclaration_TwoModifiers_NoType() throws Exception {
+        Parser parser = newParser("static synchronized property cheese;");
 
         CSTNode root = parser.bodyStatement();
 
-        assertNode( root,
-                    "property",
-                    Token.KEYWORD_PROPERTY,
-                    3 );
+        assertNode(root, "property", Token.KEYWORD_PROPERTY, 3);
 
         {
-            assertNullNode( root.getChild( 0 ),
-                            2 );
+            assertNullNode(root.getChild(0), 2);
 
             {
-                assertNode( root.getChild( 0 ).getChild( 0 ),
-                            "static",
-                            Token.KEYWORD_STATIC,
-                            0 );
-
-                assertNode( root.getChild( 0 ).getChild( 1 ),
-                            "synchronized",
-                            Token.KEYWORD_SYNCHRONIZED,
-                            0 );
+                assertNode(root.getChild(0).getChild(0), "static", Token.KEYWORD_STATIC, 0);
+
+                assertNode(root.getChild(0).getChild(1), "synchronized", Token.KEYWORD_SYNCHRONIZED, 0);
             }
-            
-            assertNode( root.getChild( 1 ),
-                        "cheese",
-                        Token.IDENTIFIER,
-                        0 );
 
-            assertNullNode( root.getChild( 2 ),
-                            0 );
+            assertNode(root.getChild(1), "cheese", Token.IDENTIFIER, 0);
+
+            assertNullNode(root.getChild(2), 0);
         }
     }
 
-    
-    
-    
-    public void testBodyStatement_PropertyDeclaration_NoProperty_NoModifiers_NoType()
-    throws Exception
-    {
-        Parser parser = newParser( "cheese;" );
+    public void testBodyStatement_PropertyDeclaration_NoProperty_NoModifiers_NoType() throws Exception {
+        Parser parser = newParser("cheese;");
 
         CSTNode root = parser.bodyStatement();
 
         System.out.println("Got: " + root);
-        
-        assertNode( root,
-                "property",
-                Token.KEYWORD_PROPERTY,
-                3 );
+
+        assertNode(root, "property", Token.KEYWORD_PROPERTY, 3);
 
         {
-            assertNullNode( root.getChild( 0 ),
-                0 );
+            assertNullNode(root.getChild(0), 0);
 
-            assertNode( root.getChild( 1 ),
-                        "cheese",
-                        Token.IDENTIFIER,
-                        0 );
+            assertNode(root.getChild(1), "cheese", Token.IDENTIFIER, 0);
 
-            assertNullNode( root.getChild( 2 ),
-                                0 );
+            assertNullNode(root.getChild(2), 0);
         }
     }
 
-    public void testBodyStatement_PropertyDeclaration_NoProperty_OneModifier_NoType()
-    throws Exception
-    {
-        Parser parser = newParser( "static cheese;" );
+    public void testBodyStatement_PropertyDeclaration_NoProperty_OneModifier_NoType() throws Exception {
+        Parser parser = newParser("static cheese;");
 
         CSTNode root = parser.bodyStatement();
 
-        assertNode( root,
-                "property",
-                Token.KEYWORD_PROPERTY,
-                3 );
+        assertNode(root, "property", Token.KEYWORD_PROPERTY, 3);
 
         {
-            assertNullNode( root.getChild( 0 ),
-                1 );
+            assertNullNode(root.getChild(0), 1);
 
             {
-                assertNode( root.getChild( 0 ).getChild( 0 ),
-                    "static",
-                    Token.KEYWORD_STATIC,
-                    0 );
+                assertNode(root.getChild(0).getChild(0), "static", Token.KEYWORD_STATIC, 0);
             }
 
-            assertNode( root.getChild( 1 ),
-                    "cheese",
-                    Token.IDENTIFIER,
-                    0 );
+            assertNode(root.getChild(1), "cheese", Token.IDENTIFIER, 0);
 
-            assertNullNode( root.getChild( 2 ),
-                            0 );
+            assertNullNode(root.getChild(2), 0);
         }
     }
 
-    public void testBodyStatement_PropertyDeclaration_NoProperty_TwoModifiers_NoType()
-    throws Exception
-    {
-        Parser parser = newParser( "static synchronized cheese;" );
+    public void testBodyStatement_PropertyDeclaration_NoProperty_TwoModifiers_NoType() throws Exception {
+        Parser parser = newParser("static synchronized cheese;");
 
         CSTNode root = parser.bodyStatement();
 
-        assertNode( root,
-                "property",
-                Token.KEYWORD_PROPERTY,
-                3 );
+        assertNode(root, "property", Token.KEYWORD_PROPERTY, 3);
 
         {
-            assertNullNode( root.getChild( 0 ),
-                2 );
+            assertNullNode(root.getChild(0), 2);
 
             {
-                assertNode( root.getChild( 0 ).getChild( 0 ),
-                    "static",
-                    Token.KEYWORD_STATIC,
-                    0 );
-
-                assertNode( root.getChild( 0 ).getChild( 1 ),
-                            "synchronized",
-                            Token.KEYWORD_SYNCHRONIZED,
-                            0 );
+                assertNode(root.getChild(0).getChild(0), "static", Token.KEYWORD_STATIC, 0);
+
+                assertNode(root.getChild(0).getChild(1), "synchronized", Token.KEYWORD_SYNCHRONIZED, 0);
             }
-            
-            assertNode( root.getChild( 1 ),
-                    "cheese",
-                    Token.IDENTIFIER,
-                    0 );
 
-            assertNullNode( root.getChild( 2 ),
-                            0 );
+            assertNode(root.getChild(1), "cheese", Token.IDENTIFIER, 0);
+
+            assertNullNode(root.getChild(2), 0);
         }
     }
 
-    
-
-    public void testBodyStatement_PropertyDeclaration_NoType_WithExpression()
-    throws Exception
-    {
-        Parser parser = newParser( "cheese = 1234" );
+    public void testBodyStatement_PropertyDeclaration_NoType_WithExpression() throws Exception {
+        Parser parser = newParser("cheese = 1234");
 
         CSTNode root = parser.bodyStatement();
 
-        assertNode( root,
-                "property",
-                Token.KEYWORD_PROPERTY,
-                4 );
+        assertNode(root, "property", Token.KEYWORD_PROPERTY, 4);
 
         {
-            assertNullNode( root.getChild( 0 ),
-                0 );
+            assertNullNode(root.getChild(0), 0);
 
-            assertNode( root.getChild( 1 ),
-                    "cheese",
-                    Token.IDENTIFIER,
-                    0 );
+            assertNode(root.getChild(1), "cheese", Token.IDENTIFIER, 0);
 
-            assertNullNode( root.getChild( 2 ),
-                            0 );
-            
-            assertNode( root.getChild(3),
-                        "1234",
-                         Token.INTEGER_NUMBER, 0);
+            assertNullNode(root.getChild(2), 0);
+
+            assertNode(root.getChild(3), "1234", Token.INTEGER_NUMBER, 0);
         }
     }
-    
-    public void testBodyStatement_PropertyDeclaration_Type_WithExpression()
-    throws Exception
-    {
-        Parser parser = newParser( "Food cheese = defaultValue()" );
+
+    public void testBodyStatement_PropertyDeclaration_Type_WithExpression() throws Exception {
+        Parser parser = newParser("Food cheese = defaultValue()");
 
         CSTNode root = parser.bodyStatement();
 
-        assertNode( root,
-                "property",
-                Token.KEYWORD_PROPERTY,
-                4 );
+        assertNode(root, "property", Token.KEYWORD_PROPERTY, 4);
 
         {
-            assertNullNode( root.getChild( 0 ),
-                0 );
-
-            assertNode( root.getChild( 1 ),
-                        "cheese",
-                        Token.IDENTIFIER,
-                        0 );
-
-            assertNode( root.getChild( 2 ),
-                                "Food",
-                                Token.IDENTIFIER,
-                                0 );
-            
-            assertNode( root.getChild(3),
-                                        "(",
-                                        Token.LEFT_PARENTHESIS, 3);
+            assertNullNode(root.getChild(0), 0);
+
+            assertNode(root.getChild(1), "cheese", Token.IDENTIFIER, 0);
+
+            assertNode(root.getChild(2), "Food", Token.IDENTIFIER, 0);
+
+            assertNode(root.getChild(3), "(", Token.LEFT_PARENTHESIS, 3);
         }
     }
-    
-    
-    
-    
-    public void testBodyStatement_MethodDeclaration_NoReturnType_NoParameters()
-        throws Exception
-    {
-        Parser parser = newParser( "cheeseIt() { } " );
+
+    public void testBodyStatement_MethodDeclaration_NoReturnType_NoParameters() throws Exception {
+        Parser parser = newParser("cheeseIt() { } ");
 
         CSTNode root = parser.bodyStatement();
 
-        assertNode( root,
-                    "<synthetic>",
-                    Token.SYNTH_METHOD,
-                    5 );
+        assertNode(root, "<synthetic>", Token.SYNTH_METHOD, 5);
 
         {
-            assertNullNode( root.getChild( 0 ),
-                            0 );
+            assertNullNode(root.getChild(0), 0);
 
-            assertNode( root.getChild( 1 ),
-                        "cheeseIt",
-                        Token.IDENTIFIER,
-                        0 );
+            assertNode(root.getChild(1), "cheeseIt", Token.IDENTIFIER, 0);
 
-            assertNullNode( root.getChild( 2 ),
-                            0 );
+            assertNullNode(root.getChild(2), 0);
 
-            assertNode( root.getChild( 3 ),
-                        "(",
-                        Token.LEFT_PARENTHESIS,
-                        0 );
+            assertNode(root.getChild(3), "(", Token.LEFT_PARENTHESIS, 0);
         }
     }
 
-    public void testBodyStatement_MethodDeclaration_WithReturnType_NoParameters()
-        throws Exception
-    {
-        Parser parser = newParser( "String cheeseIt() { }" );
+    public void testBodyStatement_MethodDeclaration_WithReturnType_NoParameters() throws Exception {
+        Parser parser = newParser("String cheeseIt() { }");
 
         CSTNode root = parser.bodyStatement();
 
-        assertNode( root,
-                    "<synthetic>",
-                    Token.SYNTH_METHOD,
-                    5 );
+        assertNode(root, "<synthetic>", Token.SYNTH_METHOD, 5);
 
         {
-            assertNullNode( root.getChild( 0 ),
-                            0 );
-
-            assertNode( root.getChild( 1 ),
-                        "cheeseIt",
-                        Token.IDENTIFIER,
-                        0 );
-
-            assertNode( root.getChild( 2 ),
-                        "String",
-                        Token.IDENTIFIER,
-                        0 );
-
-            assertNode( root.getChild( 3 ),
-                        "(",
-                        Token.LEFT_PARENTHESIS,
-                        0 );
+            assertNullNode(root.getChild(0), 0);
+
+            assertNode(root.getChild(1), "cheeseIt", Token.IDENTIFIER, 0);
+
+            assertNode(root.getChild(2), "String", Token.IDENTIFIER, 0);
+
+            assertNode(root.getChild(3), "(", Token.LEFT_PARENTHESIS, 0);
         }
     }
 
@@ -1221,152 +769,87 @@ public class ParserTest
     //     <parameter>
     // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 
-    public void testParameterList()
-        throws Exception
-    {
+    public void testParameterList() throws Exception {
     }
 
-    public void testParameterDeclarationWithoutDatatype()
-        throws Exception
-    {
-        Parser parser = newParser( "cheese" );
+    public void testParameterDeclarationWithoutDatatype() throws Exception {
+        Parser parser = newParser("cheese");
 
         CSTNode root = parser.parameterDeclarationWithoutDatatype();
 
-        assertNode( root,
-                    "<synthetic>",
-                    Token.SYNTH_PARAMETER_DECLARATION,
-                    2 );
+        assertNode(root, "<synthetic>", Token.SYNTH_PARAMETER_DECLARATION, 2);
 
         {
-            assertNode( root.getChild( 0 ),
-                        "cheese",
-                        Token.IDENTIFIER,
-                        0 );
+            assertNode(root.getChild(0), "cheese", Token.IDENTIFIER, 0);
 
-            assertNullNode( root.getChild( 1 ),
-                            0 );
+            assertNullNode(root.getChild(1), 0);
         }
     }
 
-    public void testParameterDeclarationWithDatatype_Simple()
-        throws Exception
-    {
-        Parser parser = newParser( "String cheese" );
+    public void testParameterDeclarationWithDatatype_Simple() throws Exception {
+        Parser parser = newParser("String cheese");
 
         CSTNode root = parser.parameterDeclarationWithDatatype();
 
-        assertNode( root,
-                    "<synthetic>",
-                    Token.SYNTH_PARAMETER_DECLARATION,
-                    2 );
+        assertNode(root, "<synthetic>", Token.SYNTH_PARAMETER_DECLARATION, 2);
 
         {
-            assertNode( root.getChild( 0 ),
-                        "String",
-                        Token.IDENTIFIER,
-                        0 );
-
-            assertNode( root.getChild( 1 ),
-                        "cheese",
-                        Token.IDENTIFIER,
-                        0 );
+            assertNode(root.getChild(0), "String", Token.IDENTIFIER, 0);
+
+            assertNode(root.getChild(1), "cheese", Token.IDENTIFIER, 0);
         }
     }
 
-    public void testParameterDeclarationWithDatatype_Qualified()
-        throws Exception
-    {
-        Parser parser = newParser( "java.lang.String cheese" );
+    public void testParameterDeclarationWithDatatype_Qualified() throws Exception {
+        Parser parser = newParser("java.lang.String cheese");
 
         CSTNode root = parser.parameterDeclarationWithDatatype();
 
-        assertNode( root,
-                    "<synthetic>",
-                    Token.SYNTH_PARAMETER_DECLARATION,
-                    2 );
+        assertNode(root, "<synthetic>", Token.SYNTH_PARAMETER_DECLARATION, 2);
 
         {
-            assertNode( root.getChild( 0 ),
-                        ".",
-                        Token.DOT,
-                        2 );
+            assertNode(root.getChild(0), ".", Token.DOT, 2);
             {
-                assertNode( root.getChild( 0 ).getChild( 0 ),
-                            ".",
-                            Token.DOT,
-                            2 );
+                assertNode(root.getChild(0).getChild(0), ".", Token.DOT, 2);
 
                 {
-                    assertNode( root.getChild( 0 ).getChild( 0 ).getChild( 0 ),
-                                "java",
-                                Token.IDENTIFIER,
-                                0 );
-
-                    assertNode( root.getChild( 0 ).getChild( 0 ).getChild( 1 ),
-                                "lang",
-                                Token.IDENTIFIER,
-                                0 );
+                    assertNode(root.getChild(0).getChild(0).getChild(0), "java", Token.IDENTIFIER, 0);
+
+                    assertNode(root.getChild(0).getChild(0).getChild(1), "lang", Token.IDENTIFIER, 0);
                 }
 
-                assertNode( root.getChild( 0 ).getChild( 1 ),
-                            "String",
-                            Token.IDENTIFIER,
-                            0 );
+                assertNode(root.getChild(0).getChild(1), "String", Token.IDENTIFIER, 0);
             }
 
-            assertNode( root.getChild( 1 ),
-                        "cheese",
-                        Token.IDENTIFIER,
-                        0 );
+            assertNode(root.getChild(1), "cheese", Token.IDENTIFIER, 0);
         }
     }
 
-    public void testParameterDeclaration_General_WithoutDatatype()
-        throws Exception
-    {
-        Parser parser = newParser( "cheese" );
+    public void testParameterDeclaration_General_WithoutDatatype() throws Exception {
+        Parser parser = newParser("cheese");
 
         CSTNode root = parser.parameterDeclaration();
 
-        assertNode( root,
-                    "<synthetic>",
-                    Token.SYNTH_PARAMETER_DECLARATION,
-                    2 );
+        assertNode(root, "<synthetic>", Token.SYNTH_PARAMETER_DECLARATION, 2);
 
         {
-            assertNode( root.getChild( 0 ),
-                        "cheese",
-                        Token.IDENTIFIER,
-                        0 );
+            assertNode(root.getChild(0), "cheese", Token.IDENTIFIER, 0);
 
-            assertNullNode( root.getChild( 1 ),
-                            0 );
+            assertNullNode(root.getChild(1), 0);
         }
     }
 
-    public void testParameterDeclaration_General_WithDatatype()
-        throws Exception
-    {
-        Parser parser = newParser( "String cheese" );
+    public void testParameterDeclaration_General_WithDatatype() throws Exception {
+        Parser parser = newParser("String cheese");
 
         CSTNode root = parser.parameterDeclaration();
 
-        assertNode( root,
-                    "<synthetic>",
-                    Token.SYNTH_PARAMETER_DECLARATION,
-                    2 );
+        assertNode(root, "<synthetic>", Token.SYNTH_PARAMETER_DECLARATION, 2);
 
         {
-            assertNode( root.getChild( 0 ),
-                        "String",
-                        Token.IDENTIFIER,
-                        0 );
-
-            assertNode( root.getChild( 1 ),
-                        "cheese",
-                        Token.IDENTIFIER,
-                        0 );
+            assertNode(root.getChild(0), "String", Token.IDENTIFIER, 0);
+
+            assertNode(root.getChild(1), "cheese", Token.IDENTIFIER, 0);
         }
     }
 
@@ -1374,49 +857,33 @@ public class ParserTest
     //     <parameter list>
     // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 
-    public void testParameterList_Empty()
-        throws Exception
-    {
-        Parser parser = newParser( "" );
+    public void testParameterList_Empty() throws Exception {
+        Parser parser = newParser("");
 
         CSTNode root = parser.parameterDeclarationList();
 
-        assertNullNode( root,
-                        0 );
+        assertNullNode(root, 0);
     }
 
     // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
     //     method
     // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 
-    public void testMethod_NoModifiers_NoReturnType_NoParameters()
-        throws Exception
-    {
-        Parser parser = newParser( "cheeseIt() { }" );
+    public void testMethod_NoModifiers_NoReturnType_NoParameters() throws Exception {
+        Parser parser = newParser("cheeseIt() { }");
 
         CSTNode root = parser.bodyStatement();
 
-        assertNode( root,
-                    "<synthetic>",
-                    Token.SYNTH_METHOD,
-                    5 );
+        assertNode(root, "<synthetic>", Token.SYNTH_METHOD, 5);
 
         {
-            assertNullNode( root.getChild( 0 ),
-                            0 );
+            assertNullNode(root.getChild(0), 0);
 
-            assertNode( root.getChild( 1 ),
-                        "cheeseIt",
-                        Token.IDENTIFIER,
-                        0 );
+            assertNode(root.getChild(1), "cheeseIt", Token.IDENTIFIER, 0);
 
-            assertNullNode( root.getChild( 2 ),
-                            0 );
+            assertNullNode(root.getChild(2), 0);
 
-            assertNode( root.getChild( 3 ),
-                        "(",
-                        Token.LEFT_PARENTHESIS,
-                        0 );
+            assertNode(root.getChild(3), "(", Token.LEFT_PARENTHESIS, 0);
         }
     }
 
@@ -1424,300 +891,196 @@ public class ParserTest
     //     property
     // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 
-    public void testProperty_NoModifiers_NoType()
-        throws Exception
-    {
-        Parser parser = newParser( "property cheese" );
+    public void testProperty_NoModifiers_NoType() throws Exception {
+        Parser parser = newParser("property cheese");
 
         CSTNode root = parser.bodyStatement();
 
-        assertNode( root,
-                    "property",
-                    Token.KEYWORD_PROPERTY,
-                    3 );
+        assertNode(root, "property", Token.KEYWORD_PROPERTY, 3);
 
         {
-            assertNullNode( root.getChild( 0 ), 0 );
+            assertNullNode(root.getChild(0), 0);
 
-            assertNode( root.getChild( 1 ),
-                        "cheese",
-                        Token.IDENTIFIER,
-                        0 );
+            assertNode(root.getChild(1), "cheese", Token.IDENTIFIER, 0);
 
-            assertNullNode( root.getChild( 2 ),
-                            0 );
+            assertNullNode(root.getChild(2), 0);
         }
     }
 
-    public void testProperty_NoModifiers_NoProperty_NoType()
-    throws Exception
-    {
-        Parser parser = newParser( "cheese" );
+    public void testProperty_NoModifiers_NoProperty_NoType() throws Exception {
+        Parser parser = newParser("cheese");
 
         CSTNode root = parser.bodyStatement();
 
-        assertNode( root,
-                "property",
-                Token.KEYWORD_PROPERTY,
-                3 );
+        assertNode(root, "property", Token.KEYWORD_PROPERTY, 3);
 
         {
-            assertNullNode( root.getChild( 0 ), 0 );
+            assertNullNode(root.getChild(0), 0);
 
-            assertNode( root.getChild( 1 ),
-                    "cheese",
-                    Token.IDENTIFIER,
-                    0 );
+            assertNode(root.getChild(1), "cheese", Token.IDENTIFIER, 0);
 
-            assertNullNode( root.getChild( 2 ),
-                            0 );
+            assertNullNode(root.getChild(2), 0);
         }
     }
 
     //     ((misc))
     // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 
-    public void testIsModifier()
-        throws Exception
-    {
-        assertTrue( Parser.isModifier( Token.KEYWORD_PUBLIC ) );
-        assertTrue( Parser.isModifier( Token.KEYWORD_PROTECTED ) );
-        assertTrue( Parser.isModifier( Token.KEYWORD_PRIVATE ) );
-        assertTrue( Parser.isModifier( Token.KEYWORD_STATIC ) );
-        assertTrue( Parser.isModifier( Token.KEYWORD_FINAL ) );
-        assertTrue( Parser.isModifier( Token.KEYWORD_SYNCHRONIZED ) );
-        assertFalse( Parser.isModifier( Token.IDENTIFIER ) );
+    public void testIsModifier() throws Exception {
+        assertTrue(Parser.isModifier(Token.KEYWORD_PUBLIC));
+        assertTrue(Parser.isModifier(Token.KEYWORD_PROTECTED));
+        assertTrue(Parser.isModifier(Token.KEYWORD_PRIVATE));
+        assertTrue(Parser.isModifier(Token.KEYWORD_STATIC));
+        assertTrue(Parser.isModifier(Token.KEYWORD_FINAL));
+        assertTrue(Parser.isModifier(Token.KEYWORD_SYNCHRONIZED));
+        assertFalse(Parser.isModifier(Token.IDENTIFIER));
     }
 
-    public void testConsumeUntil_Found()
-        throws Exception
-    {
-        Parser parser = newParser( "cheese toast is; bread" );
+    public void testConsumeUntil_Found() throws Exception {
+        Parser parser = newParser("cheese toast is; bread");
 
-        assertToken( parser.la(),
-                     "cheese",
-                     Token.IDENTIFIER );
+        assertToken(parser.la(), "cheese", Token.IDENTIFIER);
 
-        parser.consumeUntil( Token.SEMICOLON );
+        parser.consumeUntil(Token.SEMICOLON);
 
-        assertToken( parser.la(),
-                     "bread",
-                     Token.IDENTIFIER );
+        assertToken(parser.la(), "bread", Token.IDENTIFIER);
     }
-    
-    public void testConsumeUntil_NotFound()
-        throws Exception
-    {
-        Parser parser = newParser( "cheese toast" );
 
-        assertToken( parser.la(),
-                     "cheese",
-                     Token.IDENTIFIER );
+    public void testConsumeUntil_NotFound() throws Exception {
+        Parser parser = newParser("cheese toast");
 
-        parser.consumeUntil( Token.SEMICOLON );
+        assertToken(parser.la(), "cheese", Token.IDENTIFIER);
 
-        assertNull( parser.la() );
+        parser.consumeUntil(Token.SEMICOLON);
+
+        assertNull(parser.la());
     }
 
-    public void testAssignmentExpression()
-    throws Exception
-    {
-        Parser parser = newParser( "answer = list.collect( { item | return item * 2 } )" );
+    public void testAssignmentExpression() throws Exception {
+        Parser parser = newParser("answer = list.collect( { item | return item * 2 } )");
 
         CSTNode root = parser.expression();
     }
 
-    public void testSafeMethodCallExpression()
-    throws Exception
-    {
-        Parser parser = newParser( "answer = foo->someMethod()" );
+    public void testSafeMethodCallExpression() throws Exception {
+        Parser parser = newParser("answer = foo->someMethod()");
 
         CSTNode root = parser.expression();
-        
-        System.out.println("Got: " + root );
+
+        System.out.println("Got: " + root);
     }
 
-    public void testLogicalAndExpression()
-    throws Exception
-    {
-        Parser parser = newParser( "x > 1 && \n y < 2" );
+    public void testLogicalAndExpression() throws Exception {
+        Parser parser = newParser("x > 1 && \n y < 2");
 
         CSTNode root = parser.expression();
-        
+
         System.out.println("Got: " + root);
     }
 
-    public void testStatement_CharacterizeMePlease()
-        throws Exception
-    {
-        Parser parser = newParser( "callBlock(5, { owner | owner.incrementCallCount() })" );
+    public void testStatement_CharacterizeMePlease() throws Exception {
+        Parser parser = newParser("callBlock(5, { owner | owner.incrementCallCount() })");
 
         CSTNode root = parser.statement();
     }
 
-    public void testStatementBlock_CharacterizeMePlease()        
-        throws Exception
-    {
-        Parser parser = newParser( "keys = answer.collect( { entry | return entry.key } ) values = answer.collect( { entry | return entry.value })" );
+    public void testStatementBlock_CharacterizeMePlease() throws Exception {
+        Parser parser =
+            newParser("keys = answer.collect( { entry | return entry.key } ) values = answer.collect( { entry | return entry.value })");
 
         CSTNode root = parser.statement();
 
         root = parser.statement();
     }
 
-    public void testNewExpression()
-        throws Exception
-    {
-        Parser parser = newParser( "new Cheese()" );
+    public void testNewExpression() throws Exception {
+        Parser parser = newParser("new Cheese()");
 
         CSTNode root = parser.newExpression();
 
-        assertNode( root,
-                    "new",
-                    Token.KEYWORD_NEW,
-                    2 );
+        assertNode(root, "new", Token.KEYWORD_NEW, 2);
 
         {
-            assertNode( root.getChild( 0 ),
-                        "Cheese",
-                        Token.IDENTIFIER,
-                        0 );
-
-            assertNode( root.getChild( 1 ),
-                        "<synthetic>",
-                        Token.SYNTH_LIST,
-                        0 );
+            assertNode(root.getChild(0), "Cheese", Token.IDENTIFIER, 0);
+
+            assertNode(root.getChild(1), "<synthetic>", Token.SYNTH_LIST, 0);
         }
     }
 
-    public void testDatatype_NoDots()
-        throws Exception
-    {
-        Parser parser = newParser( "Cheese" );
+    public void testDatatype_NoDots() throws Exception {
+        Parser parser = newParser("Cheese");
 
         CSTNode root = parser.datatype();
 
-        assertNode( root,
-                    "Cheese",
-                    Token.IDENTIFIER,
-                    0 );
+        assertNode(root, "Cheese", Token.IDENTIFIER, 0);
     }
 
-    public void testDatatype_OneDot()
-        throws Exception
-    {
-        Parser parser = newParser( "cheese.Toast" );
+    public void testDatatype_OneDot() throws Exception {
+        Parser parser = newParser("cheese.Toast");
 
         CSTNode root = parser.datatype();
 
-        assertNode( root,
-                    ".",
-                    Token.DOT,
-                    2 );
+        assertNode(root, ".", Token.DOT, 2);
         {
-            assertNode( root.getChild( 0 ),
-                        "cheese",
-                        Token.IDENTIFIER,
-                        0 );
-
-            assertNode( root.getChild( 1 ),
-                        "Toast",
-                        Token.IDENTIFIER,
-                        0 );
+            assertNode(root.getChild(0), "cheese", Token.IDENTIFIER, 0);
+
+            assertNode(root.getChild(1), "Toast", Token.IDENTIFIER, 0);
         }
     }
 
-    public void testDatatype_TwoDots()
-        throws Exception
-    {
-        Parser parser = newParser( "toast.is.Bread" );
+    public void testDatatype_TwoDots() throws Exception {
+        Parser parser = newParser("toast.is.Bread");
 
         CSTNode root = parser.datatype();
 
-        assertNode( root,
-                    ".",
-                    Token.DOT,
-                    2 );
+        assertNode(root, ".", Token.DOT, 2);
         {
-            assertNode( root.getChild( 0 ),
-                        ".",
-                        Token.DOT,
-                        2 );
+            assertNode(root.getChild(0), ".", Token.DOT, 2);
             {
-                assertNode( root.getChild( 0 ).getChild( 0 ),
-                            "toast",
-                            Token.IDENTIFIER,
-                            0 );
-
-                assertNode( root.getChild( 0 ).getChild( 1 ),
-                            "is",
-                            Token.IDENTIFIER,
-                            0 );
+                assertNode(root.getChild(0).getChild(0), "toast", Token.IDENTIFIER, 0);
+
+                assertNode(root.getChild(0).getChild(1), "is", Token.IDENTIFIER, 0);
             }
 
-            assertNode( root.getChild( 1 ),
-                        "Bread",
-                        Token.IDENTIFIER,
-                        0 );
+            assertNode(root.getChild(1), "Bread", Token.IDENTIFIER, 0);
         }
     }
 
     // ----------------------------------------------------------------------
     // ----------------------------------------------------------------------
 
-    protected void assertNullNode(CSTNode node,
-                                  int numChildren)
-    {
-        assertNotNull( node );
-        assertNull( node.getToken() );
-        assertLength( numChildren,
-                      node.getChildren() );
+    protected void assertNullNode(CSTNode node, int numChildren) {
+        assertNotNull(node);
+        assertNull(node.getToken());
+        assertLength(numChildren, node.getChildren());
     }
 
-    protected void assertNode(CSTNode node,
-                              String text,
-                              int type)
-    {
-        assertNotNull( node );
-        assertNotNull( node.getToken() );
-        assertEquals( text,
-                      node.getToken().getText() );
-        assertEquals( type,
-                      node.getToken().getType() );
+    protected void assertNode(CSTNode node, String text, int type) {
+        assertNotNull(node);
+        assertNotNull(node.getToken());
+        assertEquals(text, node.getToken().getText());
+        assertEquals(type, node.getToken().getType());
     }
 
-    protected void assertNode(CSTNode node,
-                              String text,
-                              int type,
-                              int numChildren)
-    {
-        assertNotNull( "Node should not be null!", node );
-        assertNotNull( node.getToken() );
-        assertEquals( text,
-                      node.getToken().getText() );
-        assertEquals( type,
-                      node.getToken().getType() );
-        assertLength( numChildren,
-                      node.getChildren() );
+    protected void assertNode(CSTNode node, String text, int type, int numChildren) {
+        assertNotNull("Node should not be null!", node);
+        assertNotNull(node.getToken());
+        assertEquals(text, node.getToken().getText());
+        assertEquals(type, node.getToken().getType());
+        assertLength(numChildren, node.getChildren());
     }
 
-    protected void assertToken(Token token,
-                               String text,
-                               int type)
-    {
-        assertNotNull( token );
-        assertEquals( text,
-                      token.getText() );
-        assertEquals( type,
-                      token.getType() );
+    protected void assertToken(Token token, String text, int type) {
+        assertNotNull(token);
+        assertEquals(text, token.getText());
+        assertEquals(type, token.getType());
     }
 
-    protected Parser newParser(String text)
-    {
-        CharStream  chars  = new StringCharStream( text );
-        Lexer       lexer  = new Lexer( chars );
-        TokenStream tokens = new LexerTokenStream( lexer );
+    protected Parser newParser(String text) {
+        CharStream chars = new StringCharStream(text);
+        Lexer lexer = new Lexer(chars);
+        TokenStream tokens = new LexerTokenStream(lexer);
 
-        return new Parser( tokens );
+        return new Parser(tokens);
     }
 }
diff --git a/src/test/org/codehaus/groovy/wiki/Html2Wiki.groovy b/src/test/org/codehaus/groovy/wiki/Html2Wiki.groovy
new file mode 100644
index 0000000000..82f7f0bc46
--- /dev/null
+++ b/src/test/org/codehaus/groovy/wiki/Html2Wiki.groovy
@@ -0,0 +1,104 @@
+import groovy.util.XmlParser
+
+import java.io.File
+
+import org.cyberneko.html.parsers.SAXParser
+
+class Html2Wiki {
+    
+    protected out
+    
+    static void main(args) {
+        gen = new Html2Wiki()
+        for (arg in args) {
+            gen.createWiki(arg)
+        }
+    }
+    
+    void createWiki(fileName) {
+        htmlParser = new SAXParser()
+        htmlParser.setProperty("http://cyberneko.org/html/properties/names/elems", "lower")
+        htmlParser.setProperty("http://cyberneko.org/html/properties/names/attrs", "lower")
+        parser = new XmlParser(htmlParser)
+        println "Parsing ${fileName}"
+        node = parser.parse(fileName)
+        
+        outputName = getOutputName(fileName)
+        new File(outputName).eachPrintWriter { out = it; makeWikiPage(node) }
+    }
+
+    getOutputName(fileName) {
+	    lastIdx = fileName.lastIndexOf(".")
+	    if (lastIdx > 0) {
+	        fileName = fileName.substring(0, lastIdx)
+	    }
+	    return fileName + ".wiki"
+	}
+    
+    void makeWikiPage(node) {
+        body = node.html.body
+        if (body == null) {
+            println "Warning empty document, no <html><body> section"
+        }
+        else {
+            applyTemplatesForChildren(node)
+        }
+    }
+    
+    void applyTemplates(node) {
+        switch (node.name()) {
+            case "h1":
+                out.println "1 " + node.text() 
+                out.println()
+                break
+            case "h2":
+                out.println "1.1 " + node.text()
+                out.println()
+                break
+            case "h3":
+                out.println "1.1.1 " + node.text()
+                out.println()
+                break
+            case "h4":
+                out.println "1.1.1.1 " + node.text()
+                out.println()
+                break
+            case "a":
+                out.print "{link:${node.text()}|${node.attribute('href')}} "
+                break
+            case "b":
+                out.print "~~~${node.text()}~~~ "
+                break
+            case "i":
+                out.print "~~${node.text()}~~ "
+                break
+            case "source":
+                out.println "{code:groovysh}
+${node.text()}
+{code}
+"
+               break
+            case "li":
+                out.print "- "
+                applyTemplatesForChildren(node)
+                out.println()
+                break
+            case "p":
+            default:
+                applyTemplatesForChildren(node)
+                out.println()
+                out.println()
+        }
+    }
+    
+    void applyTemplatesForChildren(node) {
+        for (c in node.children()) {
+            if (c instanceof String) {
+                out.print c + " "
+            }
+            else {
+                applyTemplates(c)
+            }
+        }
+    }
+}
diff --git a/src/test/org/codehaus/groovy/wiki/RunHtml2WikiTest.java b/src/test/org/codehaus/groovy/wiki/RunHtml2WikiTest.java
new file mode 100644
index 0000000000..24c0484b87
--- /dev/null
+++ b/src/test/org/codehaus/groovy/wiki/RunHtml2WikiTest.java
@@ -0,0 +1,71 @@
+/*
+ * $Id$
+ * 
+ * Copyright 2003 (C) James Strachan and Bob Mcwhirter. All Rights Reserved.
+ * 
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided that the
+ * following conditions are met:
+ *  1. Redistributions of source code must retain copyright statements and
+ * notices. Redistributions must also contain a copy of this document.
+ *  2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *  3. The name "groovy" must not be used to endorse or promote products
+ * derived from this Software without prior written permission of The Codehaus.
+ * For written permission, please contact info@codehaus.org.
+ *  4. Products derived from this Software may not be called "groovy" nor may
+ * "groovy" appear in their names without prior written permission of The
+ * Codehaus. "groovy" is a registered trademark of The Codehaus.
+ *  5. Due credit should be given to The Codehaus - http://groovy.codehaus.org/
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE CODEHAUS AND CONTRIBUTORS ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE CODEHAUS OR ITS CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *  
+ */
+
+package org.codehaus.groovy.wiki;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.util.List;
+
+import groovy.lang.GroovyObject;
+
+import org.codehaus.groovy.classgen.TestSupport;
+
+/**
+ * A helper class for running the Html2Wiki script as a JUnit test in an IDE
+ * 
+ * @author <a href="mailto:james@coredevelopers.net">James Strachan</a>
+ * @version $Revision$
+ */
+public class RunHtml2WikiTest extends TestSupport {
+
+    public void testRun() throws Exception {
+        List list = new ArrayList();
+        File dir = new File("xdocs");
+        File[] files = dir.listFiles();
+        for (int i = 0; i < files.length; i++) {
+            File file = files[i];
+            String name = file.getName();
+            if (name.endsWith(".html")) {
+                list.add("xdocs/" + file.getName());
+            }
+        }
+        String[] args = new String[list.size()];
+        list.toArray(args);
+
+        GroovyObject object = compile("src/test/org/codehaus/groovy/wiki/Html2Wiki.groovy");
+        object.invokeMethod("main", new Object[] { args });
+    }
+}
diff --git a/src/test/org/codehaus/groovy/wiki/RunWikiTest.java b/src/test/org/codehaus/groovy/wiki/RunWikiTest.java
new file mode 100644
index 0000000000..e371cb61d6
--- /dev/null
+++ b/src/test/org/codehaus/groovy/wiki/RunWikiTest.java
@@ -0,0 +1,69 @@
+/*
+ * $Id$
+ * 
+ * Copyright 2003 (C) James Strachan and Bob Mcwhirter. All Rights Reserved.
+ * 
+ * Redistribution and use of this software and associated documentation
+ * ("Software"), with or without modification, are permitted provided that the
+ * following conditions are met:
+ *  1. Redistributions of source code must retain copyright statements and
+ * notices. Redistributions must also contain a copy of this document.
+ *  2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *  3. The name "groovy" must not be used to endorse or promote products
+ * derived from this Software without prior written permission of The Codehaus.
+ * For written permission, please contact info@codehaus.org.
+ *  4. Products derived from this Software may not be called "groovy" nor may
+ * "groovy" appear in their names without prior written permission of The
+ * Codehaus. "groovy" is a registered trademark of The Codehaus.
+ *  5. Due credit should be given to The Codehaus - http://groovy.codehaus.org/
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE CODEHAUS AND CONTRIBUTORS ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE CODEHAUS OR ITS CONTRIBUTORS BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+ * DAMAGE.
+ *  
+ */
+
+package org.codehaus.groovy.wiki;
+
+import java.io.File;
+
+import org.codehaus.groovy.classgen.TestSupport;
+
+import groovy.util.GroovyTestSuite;
+import junit.framework.Test;
+import junit.framework.TestSuite;
+
+/**
+ * Tests the execution of wiki-generated test cases
+ * 
+ * @author <a href="mailto:james@coredevelopers.net">James Strachan</a>
+ * @version $Revision$
+ */
+public class RunWikiTest extends TestSupport {
+
+    public static Test suite() {
+        TestSuite suite = new TestSuite();
+        File dir = new File("xdocs");
+        File[] files = dir.listFiles();
+        for (int i = 0; i < files.length; i++) {
+            File file = files[i];
+            String name = file.getName();
+            if (name.endsWith(".wiki")) {
+                name = "target/test-classes/wiki/" + name.replaceAll(".wiki", "Test.groovy");
+                System.setProperty("test", name);
+                suite.addTest(GroovyTestSuite.suite());
+            }
+        }
+        return suite; 
+    }    
+}
diff --git a/src/test/org/codehaus/groovy/wiki/TestCaseRenderEngineTest.java b/src/test/org/codehaus/groovy/wiki/TestCaseRenderEngineTest.java
index 20772e0dc5..5d9a866ce0 100644
--- a/src/test/org/codehaus/groovy/wiki/TestCaseRenderEngineTest.java
+++ b/src/test/org/codehaus/groovy/wiki/TestCaseRenderEngineTest.java
@@ -60,7 +60,13 @@ public class TestCaseRenderEngineTest extends TestCase {
     public void testRender() {
         assertRender(
             "blah blah {code:groovy}x = 1; assert x == 1{code} whatnot",
-            "package wiki\nclass someFileTest extends GroovyTestCase {\n\nvoid testDummy() {\n// this is a dummy test case\n}\n\n/*\nblah blah */ \n\n  void testCase1() {\nx = 1; assert x == 1\n}\n\n /* whatnot\n*/\n\n}\n");
+            "package wiki\nclass someFileTest extends GroovyTestCase {\n\n/*\nblah blah */ \n\n  void testCase1() {\nx = 1; assert x == 1\n}\n\n /* whatnot\n*/\n\nvoid testDummy() {\n// this is a dummy test case\n}\n\n}\n");		
+    }
+
+    public void testRenderWithScript() {
+        assertRender(
+            "blah blah {code:groovysh}x = 1; println 'hello ${x}'{code} whatnot",
+             "package wiki\nclass someFileTest extends GroovyTestCase {\n\n/*\nblah blah */ \n\n  void testScript1() {\n    assertScript( <<<SCRIPT_EOF1\nx = 1; println 'hello $${x}'\nSCRIPT_EOF1 )\n}    \n\n /* whatnot\n*/\n\nvoid testDummy() {\n// this is a dummy test case\n}\n\n}\n");
     }
 
     protected void assertRender(String input, String expected) {
@@ -68,9 +74,12 @@ public class TestCaseRenderEngineTest extends TestCase {
         context.set("name", "someFile.wiki");
         String answer = test.render(input, context);
 
-//        System.out.println("Converted: " + input);
-//        System.out.println("Into: " + answer);
+        System.out.println("Converted: " + input);
+        System.out.println("Into: " + answer);
 
+        // lets convert the output to a String we can cut-n-paste
+        System.out.println(answer.replaceAll("\n", "\\\\n"));
+        
         assertEquals("Rendering", expected, answer);
     }
 
diff --git a/xdocs/bsf.wiki b/xdocs/bsf.wiki
new file mode 100644
index 0000000000..8e3fcd0ab3
--- /dev/null
+++ b/xdocs/bsf.wiki
@@ -0,0 +1,35 @@
+Working with BSF 
+
+
+
+1 Working with BSF
+
+Groovy integrates cleanly with {link:BSF|http://jakarta.apache.org/bsf/} (the Bean Scripting Framework) which allows you to embed any scripting engine 
+into your Java code while keeping your Java code decoupled from any particular 
+scripting engine specifics. 
+
+The BSF engine for Groovy is implementated by the {link:GroovyEngine|apidocs/org/codehaus/groovy/bsf/GroovyEngine.html} class.
+From bsf 2.3.0-rc2 onwards the integration should be included in the release of BSF
+although until then you'll need to manually register this class with your BSF installation.
+You can manually register Groovy into BSF via the following... 
+
+{code:groovysh}
+BSFManager.registerScriptingEngine(
+	"groovy", 
+	"org.codehaus.groovy.bsf.GroovyEngine", 
+	new String[] { "groovy", "gy" }
+);
+{code}
+
+You can then treat Groovy like any of the other scripting languages via the BSF API... 
+
+{code:groovysh}
+String text = "println('Hello World')\n  return [1, 2, 3]"
+BSFManager manager = new BSFManager();
+Object answer = manager.eval("groovy", "Test1.groovy", 0, 0, text);
+{code}
+
+If you want to see more examples of using Groovy with BSF you could try the {link:unit test cases|http://cvs.groovy.codehaus.org/viewcvs.cgi/groovy/groovy-core/src/test/org/codehaus/groovy/bsf/BSFTest.java?rev=HEAD&view=auto} 
+
+
+
diff --git a/xdocs/classes.wiki b/xdocs/classes.wiki
new file mode 100644
index 0000000000..61979ac028
--- /dev/null
+++ b/xdocs/classes.wiki
@@ -0,0 +1,68 @@
+
+1 Classes
+
+Classes are defined in Groovy similarly to Java. Methods can be class (static) or instance based
+and can be public, protected, private and support all the usual Java modifiers like synchronized.
+
+One difference with Groovy is that by default things are public unless you specify otherwise.
+
+Groovy also merges the idea of fields and properties together to make code simpler, please refer
+to the {link:GroovyBeans|beans.html} section for details of how they work. 
+
+Each class in Groovy a Java classe at the bytecode / JVM level. Any methods declared will
+be available to Java and vice versa. You can specify the types of parameters or return types
+on methods so that they work nicely in normal Java code. Also you can implement interfaces
+or overload Java methods using this approach.
+
+If you omit the types of any methods or properties they will default to java.lang.Object at the 
+bytecode/JVM level.
+
+1.1 Scripts
+
+Groovy supports plain scripts, which do not have a class declaration. Here's the hello world
+script
+
+{code:groovysh}
+println "Nice cheese Gromit!"
+{code}
+
+You can run scripts in the {link:interactive terminal|running.html} or inside your own Java code or 
+via the {link:Bean Scripting Framework|bsf.html}.
+
+If you compile the above script to bytecode using the {link:groovyc|compiling.html} Ant task you get
+a single class named after the name of the script. e.g. if this was saved in Foo.script you'd get
+a Foo.class file.
+
+You can run this Java code on the command line (assuming you're classpath has groovy.jar and asm.jar).
+
+{code:shell}
+java Foo
+{code}
+
+This will execute the autogenerated main(String[] args) method in the bytecode which instantiates the Foo
+class, which extends {link:Script|http://groovy.codehaus.org/apidocs/groovy/lang/Script.html} class
+and then call its ~~~run()~~~ method.
+
+If you like you could use this class directly in Java code, passing in variables to the script.
+
+{code:java}
+import groovy.lang.Binding;
+import groovy.lang.Script;
+
+public class UseFoo {
+	public static void main(String[] args) {
+		// lets pass in some variables
+		Binding binding = new Binding();
+		binding.setVariable("cheese", "Cheddar")
+		binding.setVariable("args", args)
+		
+		Script foo = new Foo(binding);
+		foo.run();
+	}
+}
+{code}
+
+There's no need to use a Binding if you don't want to; Foo will have a no-argument constructor
+as well. Though using a Binding you can easily pass in variables. After the end of the script
+any variables created will be in the Binding for you to access in Java.
+
diff --git a/xdocs/collections.wiki b/xdocs/collections.wiki
new file mode 100644
index 0000000000..315dfe7397
--- /dev/null
+++ b/xdocs/collections.wiki
@@ -0,0 +1,121 @@
+
+1 Collections
+
+Groovy has native language support for collections, lists, maps and arrays.
+
+1.1 Lists
+
+You can create lists as follows. Notice that [] is the empty list expression.
+
+{code:groovy}
+list = [5, 6, 7, 8]
+assert list.get(2) == 7
+assert list instanceof java.util.List
+
+emptyList = []
+assert emptyList.size() == 0
+emptyList.add(5)
+assert emptyList.size() == 1
+{code}
+
+Each list expression creates an implemenation of the {api:java.util.List}.
+
+1.1 Ranges
+
+Ranges allow you to create a list of sequential values. These can be used as Lists since
+{link:GString|http://groovy.codehaus.org/apidocs/groovy/lang/Range.html} extends {api:java.util.List}.
+
+{code:groovy}
+range = 5..8
+assert range.size() == 4
+assert range.get(2) == 7
+assert range instanceof java.util.List
+{code}
+
+Note that ranges are implemented efficiently, creating a lightweight Java object containing a from and to value.
+
+Ranges can be used to iterate using the for statement.
+
+{code:groovy}
+for (i in 1..10) {
+	println "Hello ${i}"
+}
+{code}
+
+1.1 Maps
+
+Maps can be created using the following syntax. Notice that [:] is the empty map expresion.
+
+{code:groovy}
+map = ["name":"Gromit", "likes":"cheese", "id":1234]
+assert map.get("name") == "Gromit"
+assert map.get("id") == 1234
+assert map instanceof java.util.Map
+
+emptyMap = [:]
+assert emptyMap.size() == 0
+emptyMap.put(5, "foo")
+assert emptyMap.size() == 1
+assert emptyMap.get(5) == "foo"
+{code}
+
+Maps also act like beans so you can use the property notation to get/set items inside the Map 
+provided that the keys are Strings which are valid Groovy identifiers.
+
+{code:groovy}
+map = ["name":"Gromit", "likes":"cheese", "id":1234]
+assert map.name == "Gromit"
+assert map.id == 1234
+
+emptyMap = [:]
+assert emptyMap.size() == 0
+emptyMap.foo = 5
+assert emptyMap.size() == 1
+assert emptyMap.foo == 5
+{code}
+
+
+1.1 Subscript operators
+
+You can index into Strings, Lists, arrays, Maps, regexs and such like using the subscript expression.
+
+{code:groovy}
+text = "nice cheese gromit!"
+x = text[2]
+
+assert x == "c"
+assert x.class == String
+
+sub = text[5..10]
+
+assert sub == 'cheese'
+{code}
+
+Notice that you can use ranges to extract part of a List/array/String/regex. You can also use a list of indexes too.
+
+{code:groovy}
+list = 100..200
+sub = list[1, 3, 20..25, 33]
+assert sub == [101, 103, 120, 121, 122, 123, 124, 125, 133]
+{code}
+
+You can update items using the subscript operator too
+
+{code:groovy}
+list = ["a", "b", "c"]
+list[2] = "d"
+list[0] = list[1]
+list[3] = 5
+assert list == ["b", "b", "d", 5]
+{code}
+
+You can use negative indices to count from the end of the List, array, String etc.
+
+{code:groovy}
+text = "nice cheese gromit!"
+x = text[-1]
+assert x == "!"
+
+name = text[-7..-2]
+assert name == "gromit"
+{code}
\ No newline at end of file
diff --git a/xdocs/compiling.wiki b/xdocs/compiling.wiki
new file mode 100644
index 0000000000..229e4b4ce1
--- /dev/null
+++ b/xdocs/compiling.wiki
@@ -0,0 +1,45 @@
+Compiling Groovy Code 
+
+
+
+1 Compiling Groovy
+
+There are various options for compiling Groovy code and then either running it or
+using the Java objects it creates in Java code. 
+
+1.1 Compling Groovy code to bytecode
+
+There is an Ant task called ~~~groovyc~~~ which works pretty similarly to the ~~~javac~~~ Ant
+task which takes a bunch of groovy source files and compiles them into Java bytecode. Each
+groovy class then just becomes a normal Java class you can use inside your Java code if you wish.
+Indeed the generated Java class is indistinguishable from a normal Java class, other than it
+implements the {link:GroovyObject|apidocs/groovy/lang/GroovyObject.html} interface. 
+
+The groovyc Ant task is implemented by the {link:Groovyc|apidocs/org/codehaus/groovy/ant/Groovyc.html} class.
+You can see an example of this in action inside Groovy's maven.xml file (just search for 'groovyc') 
+
+1.1 Dynamically loading and running Groovy code inside Java
+
+Another option is to use a {link:GroovyClassLoader|apidocs/groovy/lang/GroovyClassLoader.html} to load classes dynamically into a Java program and execute them (or use them) directly.
+The following Java code shows an example... 
+
+{code:groovysh}
+ClassLoader parent = getClass().getClassLoader();
+GroovyClassLoader loader = new GroovyClassLoader(parent);
+Class groovyClass = loader.parse("Foo.groovy");
+
+// lets call some method on an instance
+GroovyObject groovyObject = (GroovyObject) groovyClass.newInstance();
+Object[] args = {};
+groovyObject.invokeMethod("run", args);
+{code}
+
+1.1 Runtime dependencies
+
+As well as the Groovy jar we also depend at runtime on 
+
+- asm 
+
+
+
+
diff --git a/xdocs/download.wiki b/xdocs/download.wiki
new file mode 100644
index 0000000000..dbb2632b50
--- /dev/null
+++ b/xdocs/download.wiki
@@ -0,0 +1,16 @@
+Download Groovy 
+
+
+
+1 Download Groovy
+
+You can download a distribution of Groovy from {link:this site|http://dist.codehaus.org/groovy/distributions/} .
+Once you've download the distribution, please read the {link:installation instructions|install.html} . 
+
+If you want to grab just a jar of groovy to embed in your application then try using {link:Maven|http://maven.apache.org/} as your build tool and it'll download it for
+you or you can grab a jar from the {link:jar repository|http://dist.codehaus.org/groovy/jars/} . 
+
+If you're happy to work directly with {link:Maven|http://maven.apache.org/} then either download a {link:source distribution|http://dist.codehaus.org/groovy/distributions/} or {link:grab the code from CVS|cvs-usage.html} 
+
+
+
diff --git a/xdocs/eclipse.wiki b/xdocs/eclipse.wiki
new file mode 100644
index 0000000000..3dbbf0dfaf
--- /dev/null
+++ b/xdocs/eclipse.wiki
@@ -0,0 +1,17 @@
+Groovy Eclipse 
+
+
+
+1 Groovy Eclipse
+
+There is a Groovy Eclipse plugin avaiable for editing and running groovy scripts
+from inside Eclipse. Its currently in the {link:groovy-eclipse|http://cvs.groovy.codehaus.org/viewcvs.cgi/groovy/groovy-eclipse/} CVS module. 
+
+The plugin provides a Groovy editor for editing scripts or classes in Groovy. 
+You can also use the editor as a kind of shell / scrapbook. If you install the 
+plugin and associate it with *.groovy files, then you can right click on any groovy
+file and run it as Groovy directly from the menu. Or you can type in some groovy, 
+highlight it in the editor and right click -> Evaluate Groovy. 
+
+
+
diff --git a/xdocs/faq.fml b/xdocs/faq.fml
index aa4b238a8e..62ab32c47d 100644
--- a/xdocs/faq.fml
+++ b/xdocs/faq.fml
@@ -120,6 +120,28 @@
   <part id="developer">
     <title>Groovy Developers FAQ</title>
     
+    <faq id="build">
+      <question>
+        How do I build Groovy from the source code?
+      </question>
+      <answer>
+        <p>
+        We use <a href="">Maven</a> as the build tool for Groovy.
+        From a source distribution, or <a href="cvs-usage.html">CVS checkout</a>
+        you need to install Maven as per the instructions on Maven's website.
+        </p>
+        <p>
+        Basically this involves setting the JAVA_HOME and MAVEN_HOME environment
+        variables and adding JAVA_HOME/bin and MAVEN_HOME/bin to your path.
+        Once you have installed Maven you can build Groovy and run all the unit tests
+        by typing the following in a command line shell
+       </p>
+		<source>
+		maven
+		</source>
+      </answer>
+    </faq>   
+
     <faq id="quick-build">
       <question>
         All the unit test cases take a while to run. Can I do a quicker build?
@@ -134,7 +156,6 @@
       </answer>
     </faq>   
 
-    
     <faq id="some-tests">
       <question>
         All the unit test cases take a while to run. Can I run just some of the tests?
diff --git a/xdocs/index.wiki b/xdocs/index.wiki
new file mode 100644
index 0000000000..3baf94191a
--- /dev/null
+++ b/xdocs/index.wiki
@@ -0,0 +1,88 @@
+Groovy language for the JVM 
+
+
+
+1 Introduction
+
+Groovy is a powerful new high level dynamic language for the JVM combining lots of great features from languages like Python, Ruby and Smalltalk 
+and making them available to the Java developers using a Java-like syntax. 
+
+Groovy is designed to help you get things done on the Java platform in a quicker, more concise and fun way - bringing the power
+of Python and Ruby inside the Java platform. 
+
+Groovy can be used as an alternative compiler to javac to generate standard Java bytecode to be used by any Java project
+or it can be used dynamically as an alternative language such as for writing scripts or unit test cases. 
+
+1.1 Features
+
+- {link:Closure support|closures.html} 
+- {link:Native syntax for Lists and Maps|http://wiki.codehaus.org/groovy/SyntaxForTuplesListsMaps} 
+- {link:Groovy Markup|markup.html} 
+- {link:Groovy Path expression language|http://wiki.codehaus.org/groovy/PathExpressionLanguage} 
+- {link:Groovlets|servlets.html} for implementing Servlets easily in simple Groovy scripts 
+- {link:Groovy SQL|sql.html} for making SQL more Groovy 
+- {link:Ant Scripting|ant.html} 
+- {link:Regex|regex.html} syntax for neater scripting with regular expressions 
+- {link:Groovy Beans|beans.html} for simpler syntax for working with beans 
+- {link:Operator Overloading|operators.html} to simplify working with datatypes Collections and Maps 
+- Polymorphic iteration and Autoboxing 
+- Compiles straight to Java bytecode & works cleanly with all existing Java objects & libraries 
+
+
+1.1 Examples
+
+Here's a simple example which demonstrates the basic syntax. Notice that Groovy is dynamically typed, has closure support and supports
+something similar to Python's tuple / sequence / dictionary support (List and Map in Java) 
+
+{code:groovysh}
+class Foo {
+  doSomething() {
+    data = ["name": "James", "location": "London"]
+    for (e in data) {
+      println("entry ${e.key} is ${e.value}")
+    }
+  }
+  
+  closureExample(collection) {
+    collection.each { println("value ${it}") }
+  }
+  
+  static void main(args) {
+    values = [1, 2, 3, "abc"]
+    foo = new Foo()
+    foo.closureExample(values)
+    foo.doSomething()
+  }
+}
+{code}
+
+For more examples please try the examples section or try {link:these sample scripts|http://cvs.groovy.codehaus.org/viewcvs.cgi/groovy/groovy-core/src/test/groovy/script/} or {link:the unit test cases|http://cvs.groovy.codehaus.org/viewcvs.cgi/groovy/groovy-core/src/test/groovy/} 
+
+1.1 Getting started
+
+Probably the best way to get started on Groovy is to install Maven, get a {link:CVS checkout|cvs-usage.html} of the source code and then 
+try running the unit tests & looking at them to see how Groovy works.
+e.g. 
+
+{code:groovysh}
+maven clean test
+{code}
+
+Groovy has a Swing interactive console that allows you to type in commmands and execute them
+rather like using an SQL query tool. History is available and such like so you can move forwards
+and backwards through commands etc. 
+
+To run the Swing console type... 
+
+{code:groovysh}
+maven console
+{code}
+
+Or to see a simple example of how Groovy can be used to script things like creating Swing user interfaces try... 
+
+{code:groovysh}
+maven swing:demo
+{code}
+
+
+
diff --git a/xdocs/install.wiki b/xdocs/install.wiki
new file mode 100644
index 0000000000..8cefdf8583
--- /dev/null
+++ b/xdocs/install.wiki
@@ -0,0 +1,37 @@
+Installing Groovy 
+
+
+
+1 Installing Groovy
+
+This document describes how to install a binary distribution of Groovy. 
+For those familiar with tools like {link:Ant|http://ant.apache.org/} or {link:Maven|http://maven.apache.org/} these steps will be very familiar. 
+
+- {link:download|download.html} a binary distribution of Groovy and unpack the
+distribution into some file on your local file system. 
+- set your ~~~GROOVY_HOME~~~ environment variable to the directory you unpacked
+the distribution 
+- add ~~~GROOVY_HOME/bin~~~ to your ~~~PATH~~~ environment variable. 
+- you should now have Groovy installed properly. You can test this by typing 
+the following in a command shell... 
+
+
+{code:groovysh}
+groovysh
+{code}
+
+Which should create an interactive groovy shell where you can type Groovy statements.
+Or to run the Swing interactive console type 
+
+{code:groovysh}
+groovyConsole
+{code}
+
+To run a specific groovy script type 
+
+{code:groovysh}
+groovysh SomeScript.groovy
+{code}
+
+
+
diff --git a/xdocs/markup.wiki b/xdocs/markup.wiki
new file mode 100644
index 0000000000..e37c79c2fc
--- /dev/null
+++ b/xdocs/markup.wiki
@@ -0,0 +1,111 @@
+GroovyMarkup 
+
+
+
+1 GroovyMarkup
+
+Groovy has native support for various markup languages from XML, HTML,
+SAX, W3C DOM, Ant tasks, Swing user interfaces and so forth. 
+This is all accomplished via the following syntax... {code:groovysh}
+someBuilder.people(kind:'folks', groovy:true) {
+  person(x:123,  name:'James', cheese:'edam') {
+    project(name:'groovy')
+    project(name:'geronimo')
+  }
+  person(x:234,  name:'bob', cheese:'cheddar') {
+    project(name:'groovy')
+    project(name:'drools')
+  }
+}
+{code}
+
+Whichever kind of builder object is used, the syntax is the same. What
+the above means is that the someBuilder object has a method called
+'people' invoked with 2 parameters... - a Map of arguments ['kind':'folks', 'groovy':true] 
+- a Closure object which when invoked will call 2 methods on the
+builder called 'person', each taking 2 parameters, a map of values and
+a closure... 
+
+
+So we can easily represent any arbitrary nested markup with ease using
+a simple concise syntax. No pointy brackets! :)
+
+Whats more is this is native Groovy syntax; so you can mix and match
+this markup syntax with any other Groovy features (iteration,
+branching, method calls, variables, expressions etc). e.g.
+
+// lets create a form with a label & text field for each property
+of a bean< {code:groovysh}
+widget = swing.frame(title:'My Frame') {
+    panel() {
+       for (entry in someBean) {
+          label(text:entry.key)
+          textField(text:entry.value)
+       }
+       button(text:'OK', actionPerformed:{ println("I've been clicked with event ${it}") })
+    }
+}
+widget.show()
+{code}
+
+1.1 Trees, DOMs, beans and event processing
+
+The really neat thing about GroovyMarkup is that its just a syntax
+which maps down to method calls. So it can easily support the building
+of any arbitary object structure - so it can build any DOMish model, a
+bean structure, JMX MBeans, PicoComponents, Swing front ends, Ant tasks
+etc. Whats more since its just normal method invocations it can
+naturally map to SAX event processing too.
+
+Out of the box Groovy comes with a few different markup builders you
+can use - NodeBuilder - creates a tree of Node instances which can be
+easily navigated in Groovy using an XPath-like syntax 
+- DOMBuilder - creates a W3C DOM document from the markup its given 
+- SAXBuilder - fires SAX events into a given SAX ContentHandler 
+- MarkupBuilder - outputs XML / HTML markup to some PrintWriter for
+things like implementing servlets or code generation 
+- AntBuilder - fires off Ant tasks using familiar markup for
+processing build tasks 
+- SwingBuilder - creates rich Swing user interfaces using a simple markup 
+
+
+1.1 Examples
+
+Here's a simple example which shows how you could iterate through some SQL result set
+and output a dynamic XML document containing the results in a custom format using GroovyMarkup 
+
+{code:groovysh}
+// lets output some XML builder (could be SAX / DOM / TrAX / text)
+xml = createXmlBuilder()
+xml.customers() {
+	loc = 'London'
+	sql.queryEach ("select * from customer where location = ${loc}) {
+
+		// lets process each row by emitting some markup
+		xml.customer(id:it.id, type:'Customer', foo:someVariable)) {
+			role(it.person_role) 
+			name(it.customer_name)
+			location(id:it.location_id, name:it.location_name)
+		}
+	}
+}
+{code}
+
+The interesting thing about the above is that the XML technology used at the other end 
+could be push-event based (SAX) or pull-event based (StAX) or a DOM-ish API (W3C, dom4j, JDOM, 
+EXML, XOM) or some JAXB-ish thing (XMLBeans, Castor) or just beans or just good old text files.
+e.g. a pull parser could literally pull the data out of the database - or the data could be pushed 
+into data some structure or piped straight to a file using IO or async NIO.
+The use of GroovyMarkup means developers can hide the XML plumbing and focus on tackling the real problems we're trying to solve. 
+
+To see more examples of using GroovyMarkup try looking at our unit test cases 
+
+- {link:XML unit tests|http://cvs.groovy.codehaus.org/viewcvs.cgi/groovy/groovy-core/src/test/groovy/xml/} 
+- {link:Ant unit tests|http://cvs.groovy.codehaus.org/viewcvs.cgi/groovy/groovy-core/src/test/groovy/ant/} 
+- {link:Swing demos|http://cvs.groovy.codehaus.org/viewcvs.cgi/groovy/groovy-core/src/test/groovy/swing/} 
+
+
+There is more {link:detail on markup here|http://wiki.codehaus.org/groovy/TreeBasedSyntax} . 
+
+
+
diff --git a/xdocs/navigation.xml b/xdocs/navigation.xml
index 4607394ac9..fbd154107f 100644
--- a/xdocs/navigation.xml
+++ b/xdocs/navigation.xml
@@ -53,6 +53,10 @@
     </menu>
 
     <menu name="User Guide">
+      <item name="Statements"       	href="/statements.html"/>
+      <item name="Strings"       		href="/strings.html"/>
+      <item name="Collections"       	href="/collections.html"/>
+      <item name="Classes"       	    href="/classes.html"/>
       <item name="Closures"       	    href="/closures.html"/>
       <item name="Operator Overloading" href="/operators.html"/>
     </menu>
diff --git a/xdocs/operators.wiki b/xdocs/operators.wiki
index 561ad3adb4..e1b03a4c1a 100644
--- a/xdocs/operators.wiki
+++ b/xdocs/operators.wiki
@@ -17,8 +17,8 @@ a * b | a.multiply(b)
 a / b | a.divide(b)
 a++ or ++a | a.increment()
 a\-\- or \-\-a | a.decrement()
-a\[b\] | a.get(b)
-a\[b\] = c | a.put(b, c)
+a\[b\] | a.getAt(b)
+a\[b\] = c | a.putAt(b, c)
 {table}
 
 Note that all the following comparison operators handle nulls gracefully avoiding 
@@ -35,3 +35,30 @@ a >= b | a.compareTo(b) >= 0
 a < b | a.compareTo(b) < 0
 a <= b | a.compareTo(b) <= 0
 {table}
+
+1.1 Notes about operations
+
+Also in Groovy comparison operators handle nulls gracefully. So that a == b will never throw a 
+NullPointerException whether a or b or both are null.
+
+{code:groovy}
+a = null
+b = "foo"
+
+assert a != b
+assert b != a
+assert a == null
+{code}
+
+In addition when comparing numbers of different types then type coercion rules apply to convert
+numbers to the largest numeric type before the comparison. So the following is valid in Groovy
+
+{code:groovy}
+Byte a = 12
+Double b = 10
+
+assert a instanceof Byte
+assert b instanceof Double
+
+assert a > b
+{code}
diff --git a/xdocs/quickStart.wiki b/xdocs/quickStart.wiki
new file mode 100644
index 0000000000..68bfa29793
--- /dev/null
+++ b/xdocs/quickStart.wiki
@@ -0,0 +1,172 @@
+Groovy Quick Start Guide 
+
+
+
+1 Quick Start Guide to Groovy
+
+Groovy classes compile down to Java bytecode and so there's a 1-1 mapping between a Groovy class and a Java class.
+Indeed each Groovy class can be used inside normal Java code - since it is a Java class too. 
+
+Probably the easiest way to get groovy is to try working with collections. In Groovy List (java.util.List) and Map (java.util.Map)
+are both first class objects in the syntax. So to create a List of objects you can do the following... 
+
+Note that in the following snippets of Groovy code, the ~~groovy>~~ means a command line prompt - you don't need to type this. 
+
+{code:groovysh}
+groovy> list = [1, 2, 'hello', new java.util.Date()]
+  groovy> list.size()
+  4
+  groovy> list.get(2)
+  'hello'
+{code}
+
+Notice that everything is an object (or that auto-boxing takes place when working with numbers). To create maps... {code:groovysh}
+groovy> map = ['name':'James', 'location':'London']
+  groovy> map.size()
+  2
+  groovy> map.get('name')
+  'James'
+{code}
+
+Iterating over collections is easy... {code:groovysh}
+groovy> list = [1, 2, 3]
+  groovy> for (i in list) { println(i) }
+  1
+  2
+  3
+{code}
+
+Once you have some collections you can then use some of the new collection helper methods or try working with closures... 1.1 Working with closures
+
+Closures are similar to Java's inner classes, except they are a single method which is invokable, with arbitrary parameters.
+A closure can have as many parameters as you wish... {code:groovysh}
+groovy> closure = { param | println("hello ${param}") }
+  groovy> closure.call("world!")
+  hello world!
+  groovy> closure = { greeting, name | println(greeting + name) }
+  groovy> closure.call("hello ", "world!")
+  hello world!
+{code}
+
+If no parameter(s) is(are) specified before the | symbol then a default named parameter, called 'it' can be used. e.g. {code:groovysh}
+groovy> closure = { println("hello " + it) }
+  groovy> closure.call("world!")
+  hello world!
+{code}
+
+Using closures allows us to process collections (arrays, maps, strings, files, SQL connections and so forth) in a clean way.
+
+Here are a number of helper methods available on collections & strings... 1.1.1 each
+
+iterate via a closure {code:groovysh}
+groovy>[1, 2, 3].each { item | print("${item}-" }
+  1-2-3-
+{code}
+
+1.1.1 map
+
+convert values to new list using closure {code:groovysh}
+groovy> [1, 2, 3].map { it * 2 }
+  [2, 4, 6]
+{code}
+
+1.1.1 find
+
+finds first item matching closure predicate {code:groovysh}
+groovy> [1, 2, 3].find { it > 1 }
+  2
+{code}
+
+1.1.1 findAll
+
+finds all items matching closure predicate {code:groovysh}
+groovy> [1, 2, 3].findAll { it > 1 }
+  [2, 3]
+{code}
+
+1.1.1 inject
+
+allows you to pass a value into the first iteration and then
+ pass the result of that iteration into the next iteration and so
+ on. This is ideal for counting and other forms of processing 
+
+{code:groovysh}
+groovy> [1, 2, 3].inject('counting: ') { str, item | str + item }
+  "counting: 123"
+  groovy> [1, 2, 3].inject(0) { count, item | count + item }
+  6
+{code}
+
+In addition there's 2 new methods for doing boolean logic on some collection... 
+
+1.1.1 every
+
+returns true if all items match the closure predicate {code:groovysh}
+groovy> [1, 2, 3].every { it < 5 }
+  true
+  groovy> [1, 2, 3].every { item | item < 3 }
+  false
+{code}
+
+1.1.1 any
+
+returns true if any item match the closure predicate {code:groovysh}
+groovy> [1, 2, 3].any { it > 2 }
+  true
+  groovy> [1, 2, 3].any { item | item > 3 }
+  false
+{code}
+
+Other helper methods include 1.1.1 max / min
+
+returns the max/min values of the collection - for Comparable objects {code:groovysh}
+groovy> [9, 4, 2, 10, 5].max()
+  10
+  groovy>   [9, 4, 2, 10, 5].min()
+  2
+  groovy> ['x', 'y', 'a', 'z'].min()
+  'a'
+{code}
+
+1.1.1 join
+
+concatenates the values of the collection together with a string value {code:groovysh}
+groovy> [1, 2, 3].join('-')
+  '1-2-3'
+{code}
+
+Also the 'yield' style of creating iterators, available in Python and
+Ruby via the yield statement, is available. The only difference is
+rather than using a yield statement, we're just using closures. {code:groovysh}
+class Foo {
+  myGenerator(Closure yield) {
+    yield.call("A")
+    yield.call("B")
+    yield.call("C")
+  }
+}
+
+foo = new Foo()
+for (x in foo.myGenerator) {
+  print("${x}-")
+}
+{code}
+
+outputs
+  A-B-C-
+
+The use of Closure in the method prototype is optional. If we have
+syntax sugar for invoking closures as if they are method calls, then
+the generator method could look even more like the python/ruby
+equivalent. Especially if parentheses are optional... {code:groovysh}
+class Foo {
+  myGenerator(yield) {
+    yield "A"
+    yield "B"
+    yield("C") 
+  }
+}
+{code}
+
+
+
diff --git a/xdocs/regex.wiki b/xdocs/regex.wiki
new file mode 100644
index 0000000000..c3f92c7d08
--- /dev/null
+++ b/xdocs/regex.wiki
@@ -0,0 +1,29 @@
+Regular Expressions in Groovy 
+
+
+
+1 Regular Expressions in Groovy
+
+Groovy supports regular expressions natively using the ~~~"..."~~ expression. Plus
+Groovy supports the =~ (create Matcher) and ==~ (matches regex) operators. e.g. 
+
+{code:groovysh}
+assert "cheesecheese" =~ "cheese"
+
+// lets create a regex Pattern
+pattern = ~"foo"
+assert pattern instanceof Pattern
+assert pattern.matcher("foo").matches()
+
+// lets create a Matcher
+matcher = "cheesecheese" =~ "cheese"
+assert matcher instanceof Matcher
+answer = matcher.replaceAll("edam")
+
+// lets do some replacement
+cheese = ("cheesecheese" =~ "cheese").replaceFirst("nice")
+assert cheese == "nicecheese"
+{code}
+
+
+
diff --git a/xdocs/running.wiki b/xdocs/running.wiki
new file mode 100644
index 0000000000..617a5c9c51
--- /dev/null
+++ b/xdocs/running.wiki
@@ -0,0 +1,93 @@
+Running Groovy scripts 
+
+
+
+1 Running Groovy scripts
+
+Groovy scripts are a number of statements and class declarations in a text file.
+Groovy scripts can be used similarly to other scripting languages.
+There are various ways of running Groovy scripts... 
+
+1.1 Using the interactive console
+
+Groovy has a Swing interactive console that allows you to type in commmands and execute them
+rather like using an SQL query tool. History is available and such like so you can move forwards
+and backwards through commands etc. 
+
+If you {link:install|install.html} a binary distribution of Groovy then you can run the
+Groovy Swing console by typing this on the command line. 
+
+{code:groovysh}
+groovyConsole
+{code}
+
+For a command line interactive shell type 
+
+{code:groovysh}
+groovysh
+{code}
+
+To run the Swing Groovy console from a source distribution type... 
+
+{code:groovysh}
+maven console
+{code}
+
+1.1 Running Groovy scripts from your IDE
+
+There is a helper class called {link:GroovyShell|apidocs/groovy/lang/GroovyShell.html} which 
+has a main(String[]) method for running any Groovy script. 
+You can run any groovy script as follows 
+
+{code:groovysh}
+java groovy.lang.GroovyShell foo/MyScript.groovy [arguments]
+{code}
+
+You can then run the above Groovy main() in your IDE to run or debug any Groovy script. 
+
+1.1 Running Groovy scripts from the command line
+
+There are shell scripts called 'groovy' or 'groovy.bat' depending on your platform
+which is part of the Groovy runtime.
+Once the runtime is {link:installed|install.html} you can just run groovy like any other script... 
+
+{code:groovysh}
+groovy foo/MyScript.groovy [arguments]
+{code}
+
+To work from the latest and greatest Groovy, do a cvs checkout and then type 
+
+{code:groovysh}
+maven groovy:make-install
+{code}
+
+You'll then have a full binary distribution made for you in groovy/target/install.
+You can then add groovy/target/install/bin to your path and you can then run groovy scripts
+easily from the command line. 
+
+1.1 Creating Unix scripts with Groovy
+
+You can write unix scripts with Groovy and execute them directly on the command line as 
+if they were normal unix shell scripts. Providing you have installed the Groovy binary
+distribution (see above) and 'groovy' is on your PATH then the following should work.
+There now follows a sample script which is {link:in CVS|http://cvs.groovy.codehaus.org/viewcvs.cgi/groovy/groovy-core/src/script/helloWorld?rev=HEAD} . 
+Save it as helloWorld. 
+
+{code:groovysh}
+#!/usr/bin/env groovy
+println("Hello world")
+for (a in this.args) {
+  println("Argument: " + a)
+}
+{code}
+
+Then to run the script from the command line, just make sure the script is executable then you 
+can call it 
+
+{code:groovysh}
+chmod +x helloWorld
+./helloWorld
+{code}
+
+
+
diff --git a/xdocs/servlets.wiki b/xdocs/servlets.wiki
new file mode 100644
index 0000000000..942956f82b
--- /dev/null
+++ b/xdocs/servlets.wiki
@@ -0,0 +1,38 @@
+Groovlets: Writing Servlets in Groovy 
+
+
+
+1 Groovlets: Writing Servlets in Groovy
+
+You can write normal Java servlets in Groovy. 
+There is also a {link:GroovyServlet|} which automatically compile your .groovy
+source files, turn them into bytecode, load the Class and cache it until you
+change the source file. 
+
+Here's a simple example to show you the kind of thing you can do from a Groovlet.
+Notice the use of implicit variables to access the session, output & request. 
+
+{code:groovysh}
+import java.util.Date
+
+if (session.counter == null) {
+session.counter = 1
+}
+
+out.println(<<<EOS
+<html>
+<head>
+<title>Groovy Servlet</title>
+</head>
+<body>
+Hello, ${request.remoteHost}: ${session.counter}! ${new Date()} 
+<br>src
+</body>
+</html>
+EOS)
+
+session.counter = session.counter + 1
+{code}
+
+
+
diff --git a/xdocs/sql.wiki b/xdocs/sql.wiki
new file mode 100644
index 0000000000..06b9cce1ad
--- /dev/null
+++ b/xdocs/sql.wiki
@@ -0,0 +1,68 @@
+GroovySql 
+
+
+
+1 GroovySql: Making SQL more Groovy
+
+Groovy supports a few neat ways to work with SQL more easily. 
+You can perform queries and SQL statements, passing in variables easily with proper handling
+of statements, connections and exception handling thanks to closures. 
+
+{code:groovysh}
+foo = 'cheese'
+sql.queryEach("select * from FOOD where type=${foo}") { 
+    println("Gromit likes ${it.name}") 
+}
+{code}
+
+Or you can create a DataSet which allows you to query SQL using familar closure syntax 
+so that the same query could work easily on in memory objects or via SQL. e.g. 
+
+{code:groovysh}
+food = sql.dataSet('FOOD')
+cheese = food.findAll { it.type == 'cheese' }
+cheese.each { println("Eat ${it.name}") }
+{code}
+
+1.1 Examples
+
+Here's an example of using Groovy SQL along with {link:GroovyMarkup|markup.html} . 
+
+{code:groovysh}
+# lets output some XML builder 
+# could be SAX / StAX / DOM / TrAX / text etc
+xml = createXmlBuilder()
+
+xml.customers() {
+    loc = 'London'
+    sql.queryEach ("select * from customer where location = ${loc}) {
+
+     # lets process each row by emitting some markup
+        xml.customer(id:it.id, type:'Customer', foo:someVariable)) {
+            if (it.parter == 'Y') {
+                role("partner") 
+            }
+            name(it.customer_name)
+            location(id:it.location_id, name:it.location_name)
+        }
+    }
+}
+{code}
+
+This could generate, dynamically something like 
+
+{code:groovysh}
+<customers>
+  <customer id="123" type="Customer" foo="whatever">
+    <role>partner</role>
+    <name>James</name>
+    <location id="5" name="London"/>
+  </customer>
+  ...
+</customers>
+{code}
+
+There's an example {link:test case which demonstrates|http://cvs.groovy.codehaus.org/viewcvs.cgi/groovy/groovy-core/src/test/groovy/sql/SqlCompleteTest.groovy?rev=HEAD&view=auto} all of these query mechanisms in action. 
+
+
+
diff --git a/xdocs/statements.wiki b/xdocs/statements.wiki
new file mode 100644
index 0000000000..624f2d4b0d
--- /dev/null
+++ b/xdocs/statements.wiki
@@ -0,0 +1,177 @@
+
+1 Statements
+
+Groovy uses a similar syntax to Java although in Groovy semicolons are optional. 
+This saves a little typing but also makes code look much cleaner (surprisingly so for such
+a minor change). So normally if one statement is on each line you can ommit semicolons
+altogether - though its no problem to use them if you want to. If you want to put multiple statements on a line
+use a semicolon to separate the statements.
+
+{code:groovy}
+x = [1, 2, 3]
+println(x)
+y = 5; x = y + 7
+println(x)
+assert x == 12
+{code}
+
+If the end of the line is reached and the current statement is not yet complete
+it can be spanned across multiple lines. So for things like method parameters
+or creating lists or for complex if expressions you can span multiple lines.
+
+{code:groovy}
+x = [1, 2, 3,
+	4, 5, 6]
+println(
+	x
+)
+if (x != null && 
+	x.size() > 5) {
+	println("Works!")
+}
+else {
+	assert false: "should never happen ${x}"
+}
+{code}
+
+
+1.1 Method calls
+
+Method calling syntax is similar to Java where methods can be called on an object (using dot) or
+a method on the current class can be called. Static and instance methods are supported.
+
+{code:groovysh}
+class Foo {
+	calculatePrice() {
+		1.23
+	}
+	
+	static void main(args) {
+		foo = new Foo()
+		p = foo.calculatePrice()
+		assert p > 0
+		
+		println "Found price: " + p
+	}
+}
+{code}
+
+Notice that the ~~return~~ statement is optional at the end of methods. 
+Also you don't need to specify a return type (it will default to Object in the bytecode
+if none is specified).
+
+1.1 Optional parenthesis
+
+Method calls in Groovy can ommit the parenthesis if there is at least one 
+parameter and there is no ambiguity.
+
+{code:groovysh}
+println "Hello world"
+System.out.println "Nice cheese Gromit!"
+{code}
+
+1.1 Named parameter passing 
+
+When calling a method you can pass in named parameters. Parameter
+names and values are separated by a colon (like the Map syntax)
+though the parameter names are identifiers rather than Strings.
+
+Currently this kind of method passing is only implemented for calling methods which take a Map or
+for constructing JavaBeans. 
+
+{code:groovysh}
+bean = new Expando(name:"James", location:"London", id:123)
+println "Hey " + bean.name
+assert bean.id == 123
+{code}
+
+Please refer to {link:GroovyMarkup|markup.html} for more examples
+
+1.1 Passing closures into methods
+
+Closures are described in more detail {link:here|closures.html}. Closures can
+be passed into methods like any other object
+
+{code:groovysh}
+closure = { param | param + 1 }
+answer = [1, 2].map(closure)
+assert answer == [2, 3]
+{code}
+
+Though there is some syntax sugar to make calling methods which take a closure easier.
+Instead of specifying parenthesis, you can just specify a closure. e.g.
+
+{code:groovysh}
+answer = [1, 2].map { param | param + 1 }
+assert answer == [2, 3]
+{code}
+
+The above code is equivalent to the previous code, just a little more groovy.
+If a method takes parameters you can leave the closure outside of the parenthesis
+(provided that the closure parameter is the last parameter on the underlying method).
+
+{code:groovysh}
+value = [1, 2, 3].inject(0) { count, item | count + item }
+assert value == 6
+{code}
+
+The above code is equivlanent to the following (but just neater)
+
+{code:groovysh}
+value = [1, 2, 3].inject(0, { count, item | count + item })
+assert value == 6
+{code}
+
+~~~NOTE~~ that when using the neater syntax for specifying closures either without parenthesis or
+by specifying the closure after the parenthesis, the closure must start on the same line.
+i.e. the { symbol must be on the same line as the method call statement. Otherwise the parser
+interprets the { as a start of a block.
+
+
+1.1 Dynamic method dispatch
+
+If a variable is not constrained by a type then dynamic method dispatch is used. This is 
+often referred to as ~~dynamic typing~~ whereas Java uses ~~static typing~~ by default.
+
+You can mix and match both dynamic and static typing in your code by just adding or removing
+types. e.g.
+
+{code:groovysh}
+dynamicObject = "hello world".replaceAll("world", "Gromit")
+dynamicObject += "!"
+assert dynamicObject == "hello Gromit!"
+
+String staticObject = "hello there"
+staticObject += "!"
+assert staticObject == "hello there!"
+{code}
+
+1.1 Properties
+
+These are described in more detail in the {link:GroovyBeans|beans.html} section.
+
+To access properties you use dot with the property name. e.g.
+
+{code:groovysh}
+bean = new Expando(name:"James", location:"London", id:123)
+name = bean.name
+println("Hey ${name}")
+bean.location = "Vegas"
+println bean.name + " is now in " + bean.location
+assert bean.location == "Vegas"
+{code}
+
+
+1.1 Safe navigation
+
+If you are walking a complex object graph and don't want to have NullPointerExceptions thrown
+you can use the -> operator rather than . to perform your navigation.
+
+{code:groovysh}
+bean = new Expando(name:"James", location:"London", id:123)
+name = bean.name
+println("Hey ${name}")
+bean.location = "Vegas"
+println bean.name + " is now in " + bean.location
+assert bean.location == "Vegas"
+{code}
diff --git a/xdocs/strings.wiki b/xdocs/strings.wiki
new file mode 100644
index 0000000000..8d3f26171f
--- /dev/null
+++ b/xdocs/strings.wiki
@@ -0,0 +1,59 @@
+
+1 Strings
+
+Groovy uses both " and ' for strings. Either can be used. Using either
+type of string allows you to use strings with quotations easily.
+
+{code:groovysh}
+println "he said 'cheese' once"
+println 'he said "cheese!" again'
+{code}
+
+Also strings support the \u001234 style mechanism for unicode.
+
+1.1 Multi-line strings
+
+Strings in Groovy can span multiple lines. This makes outputting a large block of text easy.
+
+{code:groovysh}
+foo = "hello
+ there 
+ how are things?"
+println(foo)
+{code}
+
+1.1 Here-docs
+
+If you have a block of text which you wish to use but don't want to have to encode it all
+(e.g. if its a block of HTML or something) then you can use here-docs.
+
+{code:groovysh}
+name = "James"
+text = <<<FOO
+hello there ${name}
+how are you today?
+FOO
+
+assert text != null
+println(text)
+{code}
+
+
+1.1 GStrings
+
+Strings can contain arbitrary expressions inside them as shown above using the 
+~~~${expression}~~~ syntax in a similar way to JSP EL, Velocity and Jexl. 
+Any valid Groovy expression can be enclosed in the ${...} including method calls etc
+
+What actually happens is a
+{link:GString|http://groovy.codehaus.org/apidocs/groovy/lang/GString.html} object is created
+which contains the text and values used inside the String. GString uses lazy evaluation so its not
+until the toString() method is invoked that the GString is evaluated. 
+
+This lazy evaluation is useful for things like logging
+as it allows the calculation of the string, the calls to toString() on the values and the concatenation of
+the different strings to be done laziy if at all.
+
+Another use case for GString is {link:GroovySql|sql.html} where parameters can be passed into SQL statements
+using this same mechanism which makes for a neat way to integrate Groovy with other languages like SQL. GroovySql then
+converts the expressions to ? and uses a JDBC PreparedStatement and passes the values in, preserving their types.
diff --git a/xdocs/unitTesting.wiki b/xdocs/unitTesting.wiki
new file mode 100644
index 0000000000..e724deb4b6
--- /dev/null
+++ b/xdocs/unitTesting.wiki
@@ -0,0 +1,56 @@
+Unit Testing with Groovy 
+
+
+
+1 Unit Testing with Groovy
+
+By default Groovy unit test cases generate java bytecode and so are just the same
+as any other Java unit test cases. One thing to watch is often Ant / Maven look 
+for *.java files to find unit tests with pattern matching, rather than *.class files.
+There's an option in Maven to ensure you search for classes (and so find any Groovy 
+unit test cases) via this property 
+
+{code:groovysh}
+maven.test.search.classdir = true
+{code}
+
+Once you've got this enabled you can use Maven goals to run individual test cases like this 
+
+{code:groovysh}
+maven test:single -Dtestcase=foo.MyGroovyTest
+{code}
+
+1.1 Running GroovyUnitTests in IDEs
+
+Most IDEs support JUnit but maybe don't yet handle Groovy (shame!:).
+Firstly if you compile the groovy code to bytecode, then it'll just work in any JUnit IDE just fine. 
+
+Sometimes though you want to just hack the unit test script and run from in your IDE without
+doing a build. 
+If you're IDE doesn't automatically recompile Groovy for you then there's 
+a utility to help you run Groovy unit test cases inside any JUnit IDE without needing to 
+run your Ant / Maven build. 
+
+The {link:GroovyTestSuite|apidocs/groovy/util/GroovyTestSuite.html} class 
+is a JUnit TestSuite which will compile and run a GroovyUnit test case
+from a command line argument (when run as an application) or from the ~~~test~~~ system property
+when run as a JUnit test suite. 
+
+To run the GroovyUnitTest as an application, just do the equivalent of this in your IDE 
+
+{code:groovysh}
+java groovy.util.GroovyTestSuite src/test/Foo.groovy
+{code}
+
+Or to run the test suite inside your IDE, just run the GroovyTestSuite test 
+with this system property defined 
+
+{code:groovysh}
+-Dtest=src/test/Foo.groovy
+{code}
+
+Either of the above can really help improve the development experience of writing 
+Groovy unit test cases in IDEs that don't yet support Groovy natively. 
+
+
+
