diff --git a/src/main/groovy/lang/GroovyClassLoader.java b/src/main/groovy/lang/GroovyClassLoader.java
index 53e71a40e2..306617d809 100644
--- a/src/main/groovy/lang/GroovyClassLoader.java
+++ b/src/main/groovy/lang/GroovyClassLoader.java
@@ -859,6 +859,8 @@ public class GroovyClassLoader extends URLClassLoader {
         // incorrect results (-1)
         if (isFile(source)) {
             // Coerce the file URL to a File
+            // See ClassNodeResolver.isSourceNewer for another method that replaces '|' with ':'.
+            // WTF: Why is this done and where is it documented?
             String path = source.getPath().replace('/', File.separatorChar).replace('|', ':');
             File file = new File(path);
             lastMod = file.lastModified();
@@ -881,21 +883,45 @@ public class GroovyClassLoader extends URLClassLoader {
         AccessController.doPrivileged(new PrivilegedAction<Void>() {
             public Void run() {
                 try {
-                    File f = new File(path);
-                    URL newURL = f.toURI().toURL();
+                    // As the java.net.URL Javadoc says, the recommended way to get a URL is via URI.
+                    // http://docs.oracle.com/javase/7/docs/api/java/net/URL.html
+                    // "Note, the URI class does perform escaping of its component fields in certain circumstances.
+                    // The recommended way to manage the encoding and decoding of URLs is to use URI, and to convert
+                    // between these two classes using toURI() and URI.toURL()."
+                    // A possibly better approach here is to construct a URI and then resolve it against
+                    // a URI for the current working directory.
+                    // But we use this string match for now so everyone can see it doesn't hurt file-only classpaths.
+                    URI newURI;
+                    if (!isPathURI(path)) {
+                        newURI = new File(path).toURI();
+                    } else {
+                        newURI = new URI(path);
+                    }
                     URL[] urls = getURLs();
                     for (URL url : urls) {
-                        if (url.equals(newURL)) return null;
+                        // Do not use URL.equals.  It uses the network to resolve names and compares ip addresses!
+                        // That is a violation of RFC and just plain evil.
+                        // http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html
+                        // http://docs.oracle.com/javase/7/docs/api/java/net/URL.html#equals(java.lang.Object)
+                        // "Since hosts comparison requires name resolution, this operation is a blocking operation.
+                        // Note: The defined behavior for equals is known to be inconsistent with virtual hosting in HTTP."
+                        if (newURI.equals(url.toURI())) return null;
                     }
-                    addURL(newURL);
+                    addURL(newURI.toURL());
                 } catch (MalformedURLException e) {
                     //TODO: fail through ?
+                } catch (URISyntaxException e) {
+                    // Just doing the same thing...
                 }
                 return null;
             }
         });
     }
 
+    private static boolean isPathURI(String path) {
+        return path.matches("^\\w+:.*");
+    }
+
     /**
      * <p>Returns all Groovy classes loaded by this class loader.
      *
diff --git a/src/test/groovy/CompileOrderTest.groovy b/src/test/groovy/CompileOrderTest.groovy
index 89ac13e317..e963494dc6 100644
--- a/src/test/groovy/CompileOrderTest.groovy
+++ b/src/test/groovy/CompileOrderTest.groovy
@@ -32,4 +32,38 @@ class CompileOrderTest extends GroovyTestCase {
          concreteFile.delete()
       }
    }
+
+    public void testCompileFileURI() {
+        def interfaceFile = File.createTempFile("TestURLOrderInterface", ".groovy", new File("target"))
+        def concreteFile = File.createTempFile("TestURLOrderConcrete", ".groovy", new File("target"))
+
+        def cl = new GroovyClassLoader(this.class.classLoader);
+        def currentDir = concreteFile.parentFile.absolutePath
+        println currentDir
+        cl.addClasspath(currentDir)
+        cl.shouldRecompile = true
+
+        try {
+            // Create the interface
+            println "a"
+            interfaceFile.deleteOnExit()
+            def interfaceName = interfaceFile.name - ".groovy"
+            interfaceFile.write "interface $interfaceName { }\n"
+
+            // Create a concrete class which implements the interface
+            concreteFile.deleteOnExit()
+            def concreteName = concreteFile.name - ".groovy"
+            concreteFile.write "class $concreteName implements $interfaceName { }\n"
+
+            GroovyCodeSource codeSource = new GroovyCodeSource(concreteFile.toURI())
+            // We're testing whether this fails:
+            def groovyClass = cl.parseClass(codeSource,false)
+            // Create an object, just for good measure.
+            def object = groovyClass.newInstance()
+        } finally {
+            interfaceFile.delete()
+            concreteFile.delete()
+        }
+    }
+
 }
diff --git a/src/test/groovy/ui/GroovyMainTest.groovy b/src/test/groovy/ui/GroovyMainTest.groovy
index 6a0e04e2e1..c7b8d5f031 100644
--- a/src/test/groovy/ui/GroovyMainTest.groovy
+++ b/src/test/groovy/ui/GroovyMainTest.groovy
@@ -82,4 +82,53 @@ print myURI
             System.setOut(oldOut)
         }
     }
+
+    // Gotta use configscript for this because : separated paths can't have : in them
+    // and GroovyMain ignores -cp.
+    void testURIClasspath() {
+        def tempDir1 = new File("target/tmp/GroovyMainTest1")
+        tempDir1.mkdirs()
+        def interfaceFile = File.createTempFile("GroovyMainTestInterface", ".groovy", tempDir1)
+        interfaceFile.deleteOnExit()
+        def tempDir2 = new File("target/tmp/GroovyMainTest2")
+        tempDir2.mkdirs()
+        def concreteFile = File.createTempFile("GroovyMainTestConcrete", ".groovy", tempDir2)
+        concreteFile.deleteOnExit()
+
+        try {
+            // Create the interface
+            def interfaceName = interfaceFile.name - ".groovy"
+            interfaceFile.write "interface $interfaceName { }\n"
+
+            // Create a concrete class which implements the interface
+            def concreteName = concreteFile.name - ".groovy"
+            concreteFile.write """class MyConcreteClass implements $interfaceName { }
+assert new MyConcreteClass() != null"""
+
+            def tempDir = new File("target/tmp/GroovyMainTest3")
+            tempDir.mkdirs()
+            def configScriptFile = File.createTempFile("config", ".groovy", tempDir)
+            configScriptFile.deleteOnExit()
+            configScriptFile.text = "configuration.classpath << '${interfaceFile.parentFile.toURI()}'"
+
+            String[] args = ["--configscript", configScriptFile.path, concreteFile.toURI()]
+            GroovyMain.main(args)
+        } finally {
+            interfaceFile.delete()
+            concreteFile.delete()
+        }
+    }
+
+    // This works for a URL in the classpath, but there isn't a way to do this from the command line.
+//    public void testConfigURIClasspath() {
+//        URI baseURI = new URI("https://raw.github.com/jimwhite/groovy-snippets/master/GROOVY-6451/")
+//        GroovyCodeSource codeSource = new GroovyCodeSource(baseURI.resolve("run_from_uri_test.groovy"))
+//        def shell = new GroovyShell()
+//        shell.classLoader.addURL(baseURI.toURL())
+//        // We're testing whether this fails:
+//        def script = shell.parse(codeSource)
+//        script.run()
+//    }
+
+
 }
