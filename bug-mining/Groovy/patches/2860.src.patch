diff --git a/src/main/groovy/transform/TupleConstructor.java b/src/main/groovy/transform/TupleConstructor.java
index d28a6c188f..dae1cd1f3b 100644
--- a/src/main/groovy/transform/TupleConstructor.java
+++ b/src/main/groovy/transform/TupleConstructor.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2013 the original author or authors.
+ * Copyright 2008-2014 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -111,4 +111,12 @@ public @interface TupleConstructor {
      * whether existing constructors exist. It is up to you to avoid creating duplicate constructors.
      */
     boolean force() default false;
+
+    /**
+     * By default, properties are set directly using their respective field.
+     * By setting {@code useSetters=true} then a writable property will be set using its setter.
+     * If turning on this flag we recommend that setters that might be called are
+     * made null-safe wrt the parameter.
+     */
+    boolean useSetters() default false;
 }
diff --git a/src/main/groovy/transform/builder/Builder.java b/src/main/groovy/transform/builder/Builder.java
index 17fac339c2..5e8551b2cc 100644
--- a/src/main/groovy/transform/builder/Builder.java
+++ b/src/main/groovy/transform/builder/Builder.java
@@ -122,4 +122,12 @@ public @interface Builder {
      * can be used in addition to an array (using Groovy's literal list notation) of String values.
      */
     String[] includes() default {};
+
+    /**
+     * By default, properties are set directly using their respective field.
+     * By setting {@code useSetters=true} then a writable property will be set using its setter.
+     * If turning on this flag we recommend that setters that might be called are
+     * made null-safe wrt the parameter.
+     */
+    boolean useSetters() default false;
 }
diff --git a/src/main/groovy/transform/builder/DefaultStrategy.java b/src/main/groovy/transform/builder/DefaultStrategy.java
index 6b9a53d88b..8b650d0856 100644
--- a/src/main/groovy/transform/builder/DefaultStrategy.java
+++ b/src/main/groovy/transform/builder/DefaultStrategy.java
@@ -157,6 +157,7 @@ import static org.objectweb.asm.Opcodes.ACC_STATIC;
  * </pre>
  *
  * The 'forClass' annotation attribute for the {@code @Builder} transform isn't applicable for this strategy.
+ * The 'useSetters' annotation attribute for the {@code @Builder} transform is ignored by this strategy which always uses setters.
  *
  * @author Paul King
  */
diff --git a/src/main/groovy/transform/builder/ExternalStrategy.java b/src/main/groovy/transform/builder/ExternalStrategy.java
index cab24b24cb..445a232987 100644
--- a/src/main/groovy/transform/builder/ExternalStrategy.java
+++ b/src/main/groovy/transform/builder/ExternalStrategy.java
@@ -87,6 +87,7 @@ import static org.objectweb.asm.Opcodes.ACC_PRIVATE;
  * The {@code @Builder} 'buildMethodName' annotation attribute can be used for configuring the build method's name, default "build".
  *
  * The {@code @Builder} 'builderMethodName' and 'builderClassName' annotation attributes aren't applicable for this strategy.
+ * The {@code @Builder} 'useSetters' annotation attribute is ignored by this strategy which always uses setters.
  *
  * @author Marcin Grzejszczak
  * @author Paul King
diff --git a/src/main/groovy/transform/builder/InitializerStrategy.java b/src/main/groovy/transform/builder/InitializerStrategy.java
index 81d65b7134..68cec2f460 100644
--- a/src/main/groovy/transform/builder/InitializerStrategy.java
+++ b/src/main/groovy/transform/builder/InitializerStrategy.java
@@ -28,6 +28,7 @@ import org.codehaus.groovy.ast.MethodNode;
 import org.codehaus.groovy.ast.Parameter;
 import org.codehaus.groovy.ast.expr.Expression;
 import org.codehaus.groovy.ast.stmt.BlockStatement;
+import org.codehaus.groovy.classgen.Verifier;
 import org.codehaus.groovy.transform.AbstractASTTransformation;
 import org.codehaus.groovy.transform.BuilderASTTransformation;
 import org.codehaus.groovy.transform.ImmutableASTTransformation;
@@ -41,6 +42,7 @@ import static org.codehaus.groovy.ast.tools.GeneralUtils.args;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.assignX;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.block;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.callX;
+import static org.codehaus.groovy.ast.tools.GeneralUtils.callThisX;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.constX;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.ctorSuperS;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.ctorThisS;
@@ -131,14 +133,15 @@ public class InitializerStrategy extends BuilderASTTransformation.AbstractBuilde
 
     public void build(BuilderASTTransformation transform, AnnotatedNode annotatedNode, AnnotationNode anno) {
         if (unsupportedAttribute(transform, anno, "forClass")) return;
+        boolean useSetters = transform.memberHasValue(anno, "useSetters", true);
         if (annotatedNode instanceof ClassNode) {
-            createBuilderForAnnotatedClass(transform, (ClassNode) annotatedNode, anno);
+            createBuilderForAnnotatedClass(transform, (ClassNode) annotatedNode, anno, useSetters);
         } else if (annotatedNode instanceof MethodNode) {
-            createBuilderForAnnotatedMethod(transform, (MethodNode) annotatedNode, anno);
+            createBuilderForAnnotatedMethod(transform, (MethodNode) annotatedNode, anno, useSetters);
         }
     }
 
-    private void createBuilderForAnnotatedClass(BuilderASTTransformation transform, ClassNode buildee, AnnotationNode anno) {
+    private void createBuilderForAnnotatedClass(BuilderASTTransformation transform, ClassNode buildee, AnnotationNode anno, boolean useSetters) {
         List<String> excludes = new ArrayList<String>();
         List<String> includes = new ArrayList<String>();
         if (!getIncludeExclude(transform, anno, buildee, excludes, includes)) return;
@@ -148,10 +151,10 @@ public class InitializerStrategy extends BuilderASTTransformation.AbstractBuilde
         addFields(buildee, filteredFields, builder);
 
         buildCommon(buildee, anno, filteredFields, builder);
-        createBuildeeConstructors(transform, buildee, builder, filteredFields, true);
+        createBuildeeConstructors(transform, buildee, builder, filteredFields, true, useSetters);
     }
 
-    private void createBuilderForAnnotatedMethod(BuilderASTTransformation transform, MethodNode mNode, AnnotationNode anno) {
+    private void createBuilderForAnnotatedMethod(BuilderASTTransformation transform, MethodNode mNode, AnnotationNode anno, boolean useSetters) {
         if (transform.getMemberValue(anno, "includes") != null || transform.getMemberValue(anno, "includes") != null) {
             transform.addError("Error during " + BuilderASTTransformation.MY_TYPE_NAME +
                     " processing: includes/excludes only allowed on classes", anno);
@@ -172,7 +175,7 @@ public class InitializerStrategy extends BuilderASTTransformation.AbstractBuilde
 
         buildCommon(buildee, anno, convertedFields, builder);
         if (mNode instanceof ConstructorNode) {
-            createBuildeeConstructors(transform, buildee, builder, convertedFields, false);
+            createBuildeeConstructors(transform, buildee, builder, convertedFields, false, useSetters);
         } else {
             createBuildeeMethods(buildee, mNode, builder, convertedFields);
         }
@@ -251,18 +254,18 @@ public class InitializerStrategy extends BuilderASTTransformation.AbstractBuilde
         builder.addConstructor(ACC_PRIVATE, NO_PARAMS, NO_EXCEPTIONS, block(ctorSuperS()));
         final BlockStatement body = new BlockStatement();
         body.addStatement(ctorSuperS());
-        initializeFields(fields, body);
+        initializeFields(fields, body, false);
         builder.addConstructor(ACC_PRIVATE, getParams(fields, buildee), NO_EXCEPTIONS, body);
     }
 
-    private static void createBuildeeConstructors(BuilderASTTransformation transform, ClassNode buildee, ClassNode builder, List<FieldNode> fields, boolean needsConstructor) {
+    private static void createBuildeeConstructors(BuilderASTTransformation transform, ClassNode buildee, ClassNode builder, List<FieldNode> fields, boolean needsConstructor, boolean useSetters) {
         ConstructorNode initializer = createInitializerConstructor(buildee, builder, fields);
         if (transform.hasAnnotation(buildee, ImmutableASTTransformation.MY_TYPE)) {
             initializer.putNodeMetaData(ImmutableASTTransformation.IMMUTABLE_SAFE_FLAG, Boolean.TRUE);
         } else if (needsConstructor) {
             final BlockStatement body = new BlockStatement();
             body.addStatement(ctorSuperS());
-            initializeFields(fields, body);
+            initializeFields(fields, body, useSetters);
             buildee.addConstructor(ACC_PRIVATE | ACC_SYNTHETIC, getParams(fields, buildee), NO_EXCEPTIONS, body);
         }
     }
@@ -356,9 +359,19 @@ public class InitializerStrategy extends BuilderASTTransformation.AbstractBuilde
         return fields;
     }
 
-    private static void initializeFields(List<FieldNode> fields, BlockStatement body) {
+    private static void initializeFields(List<FieldNode> fields, BlockStatement body, boolean useSetters) {
         for (FieldNode field : fields) {
-            body.addStatement(stmt(assignX(propX(varX("this"), field.getName()), varX(param(field.getType(), field.getName())))));
+            String name = field.getName();
+            body.addStatement(
+                    stmt(useSetters && !field.isFinal()
+                                    ? callThisX(getSetterName(name), varX(param(field.getType(), name)))
+                                    : assignX(propX(varX("this"), field.getName()), varX(param(field.getType(), name)))
+                    )
+            );
         }
     }
+
+    private static String getSetterName(String name) {
+        return "set" + Verifier.capitalize(name);
+    }
 }
diff --git a/src/main/groovy/transform/builder/SimpleStrategy.java b/src/main/groovy/transform/builder/SimpleStrategy.java
index 26cf130292..24f4c69faa 100644
--- a/src/main/groovy/transform/builder/SimpleStrategy.java
+++ b/src/main/groovy/transform/builder/SimpleStrategy.java
@@ -30,6 +30,7 @@ import java.util.List;
 
 import static org.codehaus.groovy.ast.tools.GeneralUtils.assignX;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.block;
+import static org.codehaus.groovy.ast.tools.GeneralUtils.callThisX;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.fieldX;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.getInstancePropertyFields;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.param;
@@ -38,6 +39,7 @@ import static org.codehaus.groovy.ast.tools.GeneralUtils.returnS;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.stmt;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.varX;
 import static org.codehaus.groovy.ast.tools.GenericsUtils.newClass;
+import static org.codehaus.groovy.transform.AbstractASTTransformation.getMemberStringValue;
 import static org.codehaus.groovy.transform.BuilderASTTransformation.NO_EXCEPTIONS;
 
 /**
@@ -70,6 +72,7 @@ import static org.codehaus.groovy.transform.BuilderASTTransformation.NO_EXCEPTIO
  * When using the default prefix of "set", Groovy's normal setters will be replaced by the chained versions. When using
  * a custom prefix, Groovy's unchained setters will still be available for use in the normal unchained fashion.
  *
+ * The 'useSetters' annotation attribute can be used for writable properties as per the {@code Builder} transform documentation.
  * The other annotation attributes for the {@code @Builder} transform for configuring the building process aren't applicable for this strategy.
  *
  * @author Paul King
@@ -86,11 +89,12 @@ public class SimpleStrategy extends BuilderASTTransformation.AbstractBuilderStra
         if (unsupportedAttribute(transform, anno, "buildMethodName")) return;
         if (unsupportedAttribute(transform, anno, "builderMethodName")) return;
         if (unsupportedAttribute(transform, anno, "forClass")) return;
+        boolean useSetters = transform.memberHasValue(anno, "useSetters", true);
 
         List<String> excludes = new ArrayList<String>();
         List<String> includes = new ArrayList<String>();
         if (!getIncludeExclude(transform, anno, buildee, excludes, includes)) return;
-        String prefix = transform.getMemberStringValue(anno, "prefix", "set");
+        String prefix = getMemberStringValue(anno, "prefix", "set");
         List<FieldNode> fields = getInstancePropertyFields(buildee);
         for (String name : includes) {
             checkKnownField(transform, anno, name, fields);
@@ -101,7 +105,10 @@ public class SimpleStrategy extends BuilderASTTransformation.AbstractBuilderStra
                 String methodName = getSetterName(prefix, fieldName);
                 Parameter parameter = param(field.getType(), fieldName);
                 buildee.addMethod(methodName, Opcodes.ACC_PUBLIC, newClass(buildee), params(parameter), NO_EXCEPTIONS, block(
-                                stmt(assignX(fieldX(field), varX(parameter))),
+                                stmt(useSetters && !field.isFinal()
+                                                ? callThisX(getSetterName("set", fieldName), varX(parameter))
+                                                : assignX(fieldX(field), varX(parameter))
+                                ),
                                 returnS(varX("this")))
                 );
             }
diff --git a/src/main/org/codehaus/groovy/transform/CanonicalASTTransformation.java b/src/main/org/codehaus/groovy/transform/CanonicalASTTransformation.java
index 8af1eff440..32f679671a 100644
--- a/src/main/org/codehaus/groovy/transform/CanonicalASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/CanonicalASTTransformation.java
@@ -61,7 +61,7 @@ public class CanonicalASTTransformation extends AbstractASTTransformation {
             List<String> includes = getMemberList(anno, "includes");
             if (!checkIncludeExclude(anno, excludes, includes, MY_TYPE_NAME)) return;
             if (!hasAnnotation(cNode, TupleConstructorASTTransformation.MY_TYPE)) {
-                createConstructor(cNode, false, true, false, false, false, false, excludes, includes);
+                createConstructor(cNode, false, true, false, false, false, false, excludes, includes, false);
             }
             if (!hasAnnotation(cNode, EqualsAndHashCodeASTTransformation.MY_TYPE)) {
                 createHashCode(cNode, false, false, false, excludes, includes);
diff --git a/src/main/org/codehaus/groovy/transform/TupleConstructorASTTransformation.java b/src/main/org/codehaus/groovy/transform/TupleConstructorASTTransformation.java
index 7dab81d8fb..8a35655298 100644
--- a/src/main/org/codehaus/groovy/transform/TupleConstructorASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/TupleConstructorASTTransformation.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2014 the original author or authors.
+ * Copyright 2008-2015 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -31,6 +31,7 @@ import org.codehaus.groovy.ast.expr.VariableExpression;
 import org.codehaus.groovy.ast.stmt.BlockStatement;
 import org.codehaus.groovy.ast.stmt.Statement;
 import org.codehaus.groovy.ast.stmt.ThrowStatement;
+import org.codehaus.groovy.classgen.Verifier;
 import org.codehaus.groovy.control.CompilePhase;
 import org.codehaus.groovy.control.SourceUnit;
 
@@ -46,6 +47,7 @@ import static org.codehaus.groovy.ast.tools.GeneralUtils.args;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.assignS;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.block;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.callX;
+import static org.codehaus.groovy.ast.tools.GeneralUtils.callThisX;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.constX;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.ctorX;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.equalsNullX;
@@ -105,6 +107,7 @@ public class TupleConstructorASTTransformation extends AbstractASTTransformation
             boolean includeSuperProperties = memberHasValue(anno, "includeSuperProperties", true);
             boolean callSuper = memberHasValue(anno, "callSuper", true);
             boolean force = memberHasValue(anno, "force", true);
+            boolean useSetters = memberHasValue(anno, "useSetters", true);
             List<String> excludes = getMemberList(anno, "excludes");
             List<String> includes = getMemberList(anno, "includes");
             if (hasAnnotation(cNode, CanonicalASTTransformation.MY_TYPE)) {
@@ -115,11 +118,11 @@ public class TupleConstructorASTTransformation extends AbstractASTTransformation
             if (!checkIncludeExclude(anno, excludes, includes, MY_TYPE_NAME)) return;
             // if @Immutable is found, let it pick up options and do work so we'll skip
             if (hasAnnotation(cNode, ImmutableASTTransformation.MY_TYPE)) return;
-            createConstructor(cNode, includeFields, includeProperties, includeSuperFields, includeSuperProperties, callSuper, force, excludes, includes);
+            createConstructor(cNode, includeFields, includeProperties, includeSuperFields, includeSuperProperties, callSuper, force, excludes, includes, useSetters);
         }
     }
 
-    public static void createConstructor(ClassNode cNode, boolean includeFields, boolean includeProperties, boolean includeSuperFields, boolean includeSuperProperties, boolean callSuper, boolean force, List<String> excludes, List<String> includes) {
+    public static void createConstructor(ClassNode cNode, boolean includeFields, boolean includeProperties, boolean includeSuperFields, boolean includeSuperProperties, boolean callSuper, boolean force, List<String> excludes, List<String> includes, boolean useSetters) {
         // no processing if existing constructors found
         List<ConstructorNode> constructors = cNode.getDeclaredConstructors();
         if (constructors.size() > 1 && !force) return;
@@ -151,10 +154,15 @@ public class TupleConstructorASTTransformation extends AbstractASTTransformation
             String name = fNode.getName();
             if (shouldSkip(name, excludes, includes)) continue;
             params.add(createParam(fNode, name));
+            boolean hasSetter = cNode.getProperty(name) != null && !fNode.isFinal();
             if (callSuper) {
                 superParams.add(varX(name));
             } else {
-                body.addStatement(assignS(propX(varX("this"), name), varX(name)));
+                if (useSetters && hasSetter) {
+                    body.addStatement(stmt(callThisX(getSetterName(name), varX(name))));
+                } else {
+                    body.addStatement(assignS(propX(varX("this"), name), varX(name)));
+                }
             }
         }
         if (callSuper) {
@@ -165,7 +173,12 @@ public class TupleConstructorASTTransformation extends AbstractASTTransformation
             if (shouldSkip(name, excludes, includes)) continue;
             Parameter nextParam = createParam(fNode, name);
             params.add(nextParam);
-            body.addStatement(assignS(propX(varX("this"), name), varX(nextParam)));
+            boolean hasSetter = cNode.getProperty(name) != null && !fNode.isFinal();
+            if (useSetters && hasSetter) {
+                body.addStatement(stmt(callThisX(getSetterName(name), varX(nextParam))));
+            } else {
+                body.addStatement(assignS(propX(varX("this"), name), varX(nextParam)));
+            }
         }
         cNode.addConstructor(new ConstructorNode(ACC_PUBLIC, params.toArray(new Parameter[params.size()]), ClassNode.EMPTY_ARRAY, body));
         // add map constructor if needed, don't do it for LinkedHashMap for now (would lead to duplicate signature)
@@ -189,6 +202,10 @@ public class TupleConstructorASTTransformation extends AbstractASTTransformation
         }
     }
 
+    private static String getSetterName(String name) {
+        return "set" + Verifier.capitalize(name);
+    }
+
     private static Parameter createParam(FieldNode fNode, String name) {
         Parameter param = new Parameter(fNode.getType(), name);
         param.setInitialExpression(providedOrDefaultInitialValue(fNode));
diff --git a/src/spec/doc/core-metaprogramming.adoc b/src/spec/doc/core-metaprogramming.adoc
index b2d2a61cf8..4af0cfffa8 100644
--- a/src/spec/doc/core-metaprogramming.adoc
+++ b/src/spec/doc/core-metaprogramming.adoc
@@ -801,9 +801,20 @@ include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=
 ----
 include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=tupleconstructor_example_callSuper,indent=0]
 ----
-|force|False|By default, the transformation will do nothing if a constructor is already defined. Setting this property
-to true, the constructor will be generated and it's your responsibility to ensure that no duplicate constructor
-is defined|See javadocs
+|force|False|By default, the transformation will do nothing if a constructor is already defined. Setting this property to
+true, the constructor will be generated and it's your responsibility to ensure that no duplicate constructor is defined.|
+[source,groovy]
+----
+include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=tupleconstructor_example_force,indent=0]
+----
+|useSetters|False|By default, the transformation will include code which directly sets the backing field for each property
+from its corresponding constructor parameter. Setting this property to true, the constructor will instead call setters if
+they exist. It's usually deemed bad style from within a constructor to call setters that can be overridden. It's your
+responsibility to avoid such bad style.|
+[source,groovy]
+----
+include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=tupleconstructor_example_useSetters,indent=0]
+----
 |=======================================================================
 
 [[xform-Canonical]]
@@ -1074,6 +1085,9 @@ You can use the `SimpleStrategy` in conjunction with `@Canonical`. If your `@Bui
 explicit `includes` or `excludes` annotation attributes but your `@Canonical` annotation does, the ones
 from `@Canonical` will be re-used for `@Builder`.
 
+The annotation attribute `useSetters` can be used if you have a setter which you want called as part of the
+construction process. See the JavaDoc for details.
+
 The annotation attributes `builderClassName`, `buildMethodName`, `builderMethodName` and `forClass` are not supported for this strategy.
 
 NOTE: Groovy already has built-in building mechanisms. Don't rush to using `@Builder` if the built-in mechanisms meet your needs. Some examples:
@@ -1188,6 +1202,9 @@ from `@Canonical` will be re-used for `@Builder`. Here is an example using `@Bui
 include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=builder_initializer_immutable,indent=0]
 ----
 
+The annotation attribute `useSetters` can be used if you have a setter which you want called as part of the
+construction process. See the JavaDoc for details.
+
 This strategy also supports annotating static methods and constructors. In this case, the static method or constructor
 parameters become the properties to use for building purposes and in the case of static methods, the return type
 of the method becomes the target class being built. If you have more than one `@Builder` annotation used within
@@ -2506,4 +2523,4 @@ tree. Please check the <<xform-ASTTest,documentation for ASTTest>> for more deta
 ==== External references
 
 If you are interested in a step-by-step tutorial about writing AST transformations, you can follow
-http://melix.github.io/ast-workshop/[this workshop].
\ No newline at end of file
+http://melix.github.io/ast-workshop/[this workshop].
diff --git a/src/spec/test/CodeGenerationASTTransformsTest.groovy b/src/spec/test/CodeGenerationASTTransformsTest.groovy
index 2b927805c0..28d2c69589 100644
--- a/src/spec/test/CodeGenerationASTTransformsTest.groovy
+++ b/src/spec/test/CodeGenerationASTTransformsTest.groovy
@@ -495,6 +495,39 @@ assert p1.lastName == p2.lastName
 assert p1.toString() == 'Jack Nicholson: null'
 assert p2.toString() == 'Jack Nicholson: actor'
 // end::tupleconstructor_example_callSuper[]
+'''
+
+        assertScript '''
+// tag::tupleconstructor_example_force[]
+import groovy.transform.*
+
+@ToString @TupleConstructor(force=true)
+final class Person {
+    String name
+    // explicit constructor would normally disable tuple constructor
+    Person(String first, String last) { this("$first $last") }
+}
+
+assert new Person('john smith').toString() == 'Person(john smith)'
+assert new Person('john', 'smith').toString() == 'Person(john smith)'
+// end::tupleconstructor_example_force[]
+'''
+
+        assertScript '''
+// tag::tupleconstructor_example_useSetters[]
+import groovy.transform.*
+
+@ToString @TupleConstructor(useSetters=true)
+final class Foo {
+    String bar
+    void setBar(String bar) {
+        this.bar = bar?.toUpperCase() // null-safe
+    }
+}
+
+assert new Foo('cat').toString() == 'Foo(CAT)'
+assert new Foo(bar: 'cat').toString() == 'Foo(CAT)'
+// end::tupleconstructor_example_useSetters[]
 '''
     }
 
diff --git a/src/test/org/codehaus/groovy/transform/BuilderTransformTest.groovy b/src/test/org/codehaus/groovy/transform/BuilderTransformTest.groovy
index 565f72c248..85094f9436 100644
--- a/src/test/org/codehaus/groovy/transform/BuilderTransformTest.groovy
+++ b/src/test/org/codehaus/groovy/transform/BuilderTransformTest.groovy
@@ -95,6 +95,36 @@ class BuilderTransformTest extends CompilableTestSupport {
         """
     }
 
+    void testSimpleBuilderSetters() {
+        assertScript """
+            import groovy.transform.builder.*
+            import groovy.transform.*
+
+            @TupleConstructor(useSetters=true)
+            @Builder(builderStrategy=SimpleStrategy, prefix="", useSetters=true)
+            class Person {
+                String name
+                void setName(String name) { this.name = name?.toLowerCase() }
+                Integer age
+                void setAge(Integer age) { this.age = (age ?: 0) * 2 }
+            }
+
+            def person = new Person()
+            person.name("John").age(21)
+            assert person.name == "john"
+            assert person.age == 42
+
+            def p2 = new Person(name: 'Mary', age: 5)
+            assert p2.name == "mary"
+            assert p2.age == 10
+
+            def p3 = new Person(name: 'TOM')
+            p3.age = 15
+            assert p3.name == "tom"
+            assert p3.age == 30
+        """
+    }
+
     void testSimpleBuilderWithCanonicalAndExcludes() {
         assertScript '''
             import groovy.transform.builder.*
@@ -501,4 +531,25 @@ class BuilderTransformTest extends CompilableTestSupport {
             test()
         '''
     }
+
+    void testInitializerStrategySetters() {
+        assertScript '''
+            import groovy.transform.builder.*
+            import groovy.transform.*
+
+            @Canonical
+            @Builder(builderStrategy=InitializerStrategy, useSetters=true)
+            class Person {
+                String name
+                void setName(String name) { this.name = name?.toUpperCase() }
+            }
+
+            @CompileStatic
+            def make() {
+                assert new Person(Person.createInitializer().name("John")).toString() == 'Person(JOHN)'
+            }
+            make()
+        '''
+    }
+
 }
diff --git a/src/test/org/codehaus/groovy/transform/CanonicalComponentsTransformTest.groovy b/src/test/org/codehaus/groovy/transform/CanonicalComponentsTransformTest.groovy
index b5c14e44a3..5cd7cd6229 100644
--- a/src/test/org/codehaus/groovy/transform/CanonicalComponentsTransformTest.groovy
+++ b/src/test/org/codehaus/groovy/transform/CanonicalComponentsTransformTest.groovy
@@ -575,6 +575,41 @@ class CanonicalComponentsTransformTest extends GroovyShellTestCase {
             assert new A().clone()
         """
     }
+
+    void testTupleConstructorUsesSetters_GROOVY7087() {
+        new GroovyShell().evaluate """
+            import groovy.transform.*
+
+            @ToString @TupleConstructor(useSetters=true)
+            class Foo1 {
+                String bar, baz
+                void setBar(String bar) {
+                    this.bar = bar?.toUpperCase()
+                }
+            }
+
+            assert new Foo1('cat', 'dog').toString() == 'Foo1(CAT, dog)'
+            // check the default map-style constructor too
+            assert new Foo1(bar: 'cat', baz: 'dog').toString() == 'Foo1(CAT, dog)'
+        """
+    }
+
+    void testTupleConstructorWithForceDirectBypassesSetters_GROOVY7087() {
+        new GroovyShell().evaluate """
+            import groovy.transform.*
+
+            @ToString @TupleConstructor
+            class Foo2 {
+                String bar, baz
+                void setBar(String bar) {
+                    this.bar = bar.toUpperCase()
+                }
+            }
+
+            assert new Foo2(bar: 'cat', baz: 'dog').toString() == 'Foo2(CAT, dog)'
+            assert new Foo2('cat', 'dog').toString() == 'Foo2(cat, dog)'
+        """
+    }
 }
 
 @TupleConstructor
