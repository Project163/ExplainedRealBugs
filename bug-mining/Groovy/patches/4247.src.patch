diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 1cef134e7c..d485fe80ea 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -29,7 +29,6 @@ import groovy.transform.TypeCheckingMode;
 import groovy.transform.stc.ClosureParams;
 import groovy.transform.stc.ClosureSignatureConflictResolver;
 import groovy.transform.stc.ClosureSignatureHint;
-import org.apache.groovy.ast.tools.MethodNodeUtils;
 import org.apache.groovy.util.SystemUtil;
 import org.codehaus.groovy.GroovyBugError;
 import org.codehaus.groovy.ast.ASTNode;
@@ -221,7 +220,6 @@ import static org.codehaus.groovy.ast.tools.GeneralUtils.getSetterName;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.isOrImplements;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.localVarX;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.propX;
-import static org.codehaus.groovy.ast.tools.GeneralUtils.returnS;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.thisPropX;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.varX;
 import static org.codehaus.groovy.ast.tools.GenericsUtils.makeClassSafe0;
@@ -1622,11 +1620,12 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                         }
                     }
                 }
-                foundGetterOrSetter = (foundGetterOrSetter || !setters.isEmpty() || getter != null);
 
-                if (property != null && storeProperty(property, pexp, receiverType, visitor, receiver.getData())) return true;
+                if (property != null && storeProperty(property, pexp, receiverType, visitor, receiver.getData(), !readMode)) return true;
 
                 if (field != null && storeField(field, pexp, receiverType, visitor, receiver.getData(), !readMode)) return true;
+
+                foundGetterOrSetter = (foundGetterOrSetter || !setters.isEmpty() || getter != null);
             }
 
             // GROOVY-5568: the property may be defined by DGM
@@ -1841,16 +1840,29 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         return true;
     }
 
-    private boolean storeProperty(final PropertyNode property, final PropertyExpression expressionToStoreOn, final ClassNode receiver, final ClassCodeVisitorSupport visitor, final String delegationData) {
+    private boolean storeProperty(final PropertyNode property, final PropertyExpression expression, final ClassNode receiver, final ClassCodeVisitorSupport visitor, final String delegationData, final boolean lhsOfAssignment) {
         if (visitor != null) visitor.visitProperty(property);
-        storeWithResolve(property.getOriginType(), receiver, property.getDeclaringClass(), property.isStatic(), expressionToStoreOn);
+        ClassNode propertyType = property.getOriginType();
+
+        storeWithResolve(propertyType, receiver, property.getDeclaringClass(), property.isStatic(), expression);
+
         if (delegationData != null) {
-            expressionToStoreOn.putNodeMetaData(IMPLICIT_RECEIVER, delegationData);
+            expression.putNodeMetaData(IMPLICIT_RECEIVER, delegationData);
         }
         if (Modifier.isFinal(property.getModifiers())) {
-            expressionToStoreOn.putNodeMetaData(READONLY_PROPERTY, Boolean.TRUE);
+            expression.putNodeMetaData(READONLY_PROPERTY, Boolean.TRUE);
+            if (!lhsOfAssignment) {
+                MethodNode implicitGetter = new MethodNode(property.getGetterNameOrDefault(), Opcodes.ACC_PUBLIC, propertyType, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, null);
+                implicitGetter.setDeclaringClass(property.getDeclaringClass());
+                extension.onMethodSelection(expression, implicitGetter);
+            }
         } else {
-            expressionToStoreOn.removeNodeMetaData(READONLY_PROPERTY);
+            expression.removeNodeMetaData(READONLY_PROPERTY);
+            if (lhsOfAssignment) {
+                MethodNode implicitSetter = new MethodNode(property.getSetterNameOrDefault(), Opcodes.ACC_PUBLIC, VOID_TYPE, new Parameter[] {new Parameter(propertyType, "value")}, ClassNode.EMPTY_ARRAY, null);
+                implicitSetter.setDeclaringClass(property.getDeclaringClass());
+                extension.onMethodSelection(expression, implicitSetter);
+            }
         }
         return true;
     }
