diff --git a/src/main/org/codehaus/groovy/classgen/asm/InvocationWriter.java b/src/main/org/codehaus/groovy/classgen/asm/InvocationWriter.java
index 96430ab39c..2954f4e3ff 100644
--- a/src/main/org/codehaus/groovy/classgen/asm/InvocationWriter.java
+++ b/src/main/org/codehaus/groovy/classgen/asm/InvocationWriter.java
@@ -33,6 +33,7 @@ import org.codehaus.groovy.runtime.ScriptBytecodeAdapter;
 import org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation;
 import org.codehaus.groovy.runtime.typehandling.ShortTypeHandling;
 import org.codehaus.groovy.syntax.SyntaxException;
+import org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport;
 import org.objectweb.asm.Label;
 import org.objectweb.asm.MethodVisitor;
 
@@ -148,25 +149,40 @@ public class InvocationWriter {
                 argumentsToRemove++;
             } else {
                 mv.visitIntInsn(ALOAD,0);
+                operandStack.push(classNode);
+                argumentsToRemove++;
             }
         }
 
         int stackSize = operandStack.getStackLength();
-        loadArguments(args.getExpressions(), target.getParameters());
-
 
         String owner = BytecodeHelper.getClassInternalName(declaringClass);
         ClassNode receiverType = receiver!=null?controller.getTypeChooser().resolveType(receiver, classNode):target.getDeclaringClass();
-        if (opcode==INVOKEVIRTUAL
-                && target.isPublic()
-                && (!Modifier.isPublic(declaringClass.getModifiers())
-                && !receiverType.equals(declaringClass))
-                && receiverType.isDerivedFrom(declaringClass)
-                && !receiverType.getPackageName().equals(classNode.getPackageName())) {
-            // package private class, public method
-            // see GROOVY-6962
-            owner = BytecodeHelper.getClassInternalName(receiverType);
+        if (opcode == INVOKEVIRTUAL) {
+            if (!receiverType.equals(declaringClass)
+                    && !receiverType.isArray()
+                    && !receiverType.isInterface()
+                    && !ClassHelper.isPrimitiveType(receiverType) // e.g int.getClass()
+                    && receiverType.isDerivedFrom(declaringClass)) {
+
+                owner = BytecodeHelper.getClassInternalName(receiverType);
+                ClassNode top = operandStack.getTopOperand();
+                if (!receiverType.equals(top)) {
+                    mv.visitTypeInsn(CHECKCAST, owner);
+                }
+            } else if (target.isPublic()
+                    && (!Modifier.isPublic(declaringClass.getModifiers())
+                    && !receiverType.equals(declaringClass))
+                    && receiverType.isDerivedFrom(declaringClass)
+                    && !receiverType.getPackageName().equals(classNode.getPackageName())) {
+                // package private class, public method
+                // see GROOVY-6962
+                owner = BytecodeHelper.getClassInternalName(receiverType);
+            }
         }
+
+        loadArguments(args.getExpressions(), target.getParameters());
+
         String desc = BytecodeHelper.getMethodDescriptor(target.getReturnType(), target.getParameters());
         mv.visitMethodInsn(opcode, owner, methodName, desc, opcode == INVOKEINTERFACE);
         ClassNode ret = target.getReturnType().redirect();
diff --git a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java
index 428010b771..d8fb57a25d 100644
--- a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java
+++ b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java
@@ -25,6 +25,7 @@ import org.codehaus.groovy.ast.Parameter;
 import org.codehaus.groovy.ast.expr.*;
 import org.codehaus.groovy.ast.stmt.ExpressionStatement;
 import org.codehaus.groovy.ast.stmt.ForStatement;
+import org.codehaus.groovy.ast.tools.WideningCategories;
 import org.codehaus.groovy.classgen.AsmClassGenerator;
 import org.codehaus.groovy.classgen.Verifier;
 import org.codehaus.groovy.classgen.asm.*;
@@ -46,6 +47,8 @@ import java.util.Map;
 import java.util.concurrent.atomic.AtomicInteger;
 
 import static org.codehaus.groovy.ast.ClassHelper.CLOSURE_TYPE;
+import static org.codehaus.groovy.ast.ClassHelper.OBJECT_TYPE;
+import static org.codehaus.groovy.ast.ClassHelper.getWrapper;
 import static org.codehaus.groovy.transform.sc.StaticCompilationMetadataKeys.PRIVATE_BRIDGE_METHODS;
 import static org.objectweb.asm.Opcodes.*;
 
@@ -581,6 +584,8 @@ public class StaticInvocationWriter extends InvocationWriter {
         private final Expression receiver;
         private final MethodNode target;
 
+        private ClassNode resolvedType;
+
         public CheckcastReceiverExpression(final Expression receiver, final MethodNode target) {
             this.receiver = receiver;
             this.target = target;
@@ -596,12 +601,7 @@ public class StaticInvocationWriter extends InvocationWriter {
             receiver.visit(visitor);
             if (visitor instanceof AsmClassGenerator) {
                 ClassNode topOperand = controller.getOperandStack().getTopOperand();
-                ClassNode type;
-                if (target instanceof ExtensionMethodNode) {
-                    type = ((ExtensionMethodNode) target).getExtensionMethodNode().getDeclaringClass();
-                } else {
-                    type = target.getDeclaringClass();
-                }
+                ClassNode type = getType();
                 if (ClassHelper.GSTRING_TYPE.equals(topOperand) && ClassHelper.STRING_TYPE.equals(type)) {
                     // perform regular type conversion
                     controller.getOperandStack().doGroovyCast(type);
@@ -622,7 +622,25 @@ public class StaticInvocationWriter extends InvocationWriter {
 
         @Override
         public ClassNode getType() {
-            return controller.getTypeChooser().resolveType(receiver, controller.getClassNode());
+            if (resolvedType!=null) {
+                return resolvedType;
+            }
+            ClassNode type;
+            if (target instanceof ExtensionMethodNode) {
+                type = ((ExtensionMethodNode) target).getExtensionMethodNode().getDeclaringClass();
+            } else {
+                type = getWrapper(controller.getTypeChooser().resolveType(receiver, controller.getClassNode()));
+                ClassNode declaringClass = target.getDeclaringClass();
+                if (type.getClass() != ClassNode.class && type.getClass() !=InnerClassNode.class) {
+                    type = declaringClass; // ex: LUB type
+                }
+                if (OBJECT_TYPE.equals(type) && !OBJECT_TYPE.equals(declaringClass)) {
+                    // can happen for compiler rewritten code, where type information is missing
+                    type = declaringClass;
+                }
+            }
+            resolvedType = type;
+            return type;
         }
     }
 
diff --git a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesClosureWriter.java b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesClosureWriter.java
index c85ad12bce..70a5a5f48d 100644
--- a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesClosureWriter.java
+++ b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesClosureWriter.java
@@ -80,7 +80,7 @@ public class StaticTypesClosureWriter extends ClosureWriter {
         // call(Object)
         Parameter args = new Parameter(ClassHelper.OBJECT_TYPE, "args");
         MethodCallExpression doCall1arg = new MethodCallExpression(
-                new VariableExpression("this"),
+                new VariableExpression("this", closureClass),
                 "doCall",
                 new ArgumentListExpression(new VariableExpression(args))
         );
@@ -95,7 +95,7 @@ public class StaticTypesClosureWriter extends ClosureWriter {
                         new ReturnStatement(doCall1arg)));
 
         // call()
-        MethodCallExpression doCallNoArgs = new MethodCallExpression(new VariableExpression("this"), "doCall", new ArgumentListExpression(new ConstantExpression(null)));
+        MethodCallExpression doCallNoArgs = new MethodCallExpression(new VariableExpression("this", closureClass), "doCall", new ArgumentListExpression(new ConstantExpression(null)));
         doCallNoArgs.setImplicitThis(true);
         doCallNoArgs.setMethodTarget(doCallMethod);
         closureClass.addMethod(
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/FieldsAndPropertiesStaticCompileTest.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/FieldsAndPropertiesStaticCompileTest.groovy
index e756c53a5c..b7c1a93d42 100644
--- a/src/test/org/codehaus/groovy/classgen/asm/sc/FieldsAndPropertiesStaticCompileTest.groovy
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/FieldsAndPropertiesStaticCompileTest.groovy
@@ -179,7 +179,7 @@ class FieldsAndPropertiesStaticCompileTest extends FieldsAndPropertiesSTCTest im
                 assert b.isSetterCalled() == true
                 assert b.x == 2
             '''
-        assert astTrees['B'][1].contains('INVOKEVIRTUAL A.setX')
+        assert astTrees['B'][1].contains('INVOKEVIRTUAL B.setX')
     }
 
     void testDirectReadFieldFromSameClass() {
@@ -257,7 +257,7 @@ class FieldsAndPropertiesStaticCompileTest extends FieldsAndPropertiesSTCTest im
                     b.usingGetter()
                     assert b.isGetterCalled() == true
                 '''
-        assert astTrees['B'][1].contains('INVOKEVIRTUAL A.getX')
+        assert astTrees['B'][1].contains('INVOKEVIRTUAL B.getX')
     }
 
     void testUseAttributeExternal() {
