diff --git a/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java b/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java
index 3311fb027e..20a5483a71 100644
--- a/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java
+++ b/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java
@@ -626,10 +626,11 @@ public class StaticInvocationWriter extends InvocationWriter {
                     origMCE.getArguments()
             );
             MethodNode methodTarget = origMCE.getMethodTarget();
+            newMCE.setImplicitThis(origMCE.isImplicitThis());
             newMCE.setMethodTarget(methodTarget);
             newMCE.setSafe(false);
-            newMCE.setImplicitThis(origMCE.isImplicitThis());
             newMCE.setSourcePosition(origMCE);
+            newMCE.getObjectExpression().setSourcePosition(origMCE.getObjectExpression());
             newMCE.visit(controller.getAcg());
             compileStack.removeVar(slot.getIndex());
             ClassNode returnType = operandStack.getTopOperand();
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 49fe89a031..9c2ce3d326 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -4744,6 +4744,17 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
      * @return the methods that are defined on the receiver completed with stubs for future methods
      */
     protected List<MethodNode> findMethodsWithGenerated(final ClassNode receiver, final String name) {
+        if (receiver.isArray()) {
+            if (name.equals("clone")) { // GROOVY-10319: array clone -- <https://docs.oracle.com/javase/specs/jls/se8/html/jls-10.html#jls-10.7>
+                MethodNode clone = new MethodNode("clone", Opcodes.ACC_PUBLIC, OBJECT_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, null);
+                clone.setDeclaringClass(OBJECT_TYPE); // retain Object for declaringClass and returnType
+                clone.setNodeMetaData(INFERRED_RETURN_TYPE, receiver);
+                return Collections.singletonList(clone);
+            } else {
+                return OBJECT_TYPE.getMethods(name);
+            }
+        }
+
         List<MethodNode> methods = receiver.getMethods(name);
         if (receiver.isAbstract()) {
             collectAllInterfaceMethodsByName(receiver, name, methods);
diff --git a/src/test/groovy/transform/stc/ArraysAndCollectionsSTCTest.groovy b/src/test/groovy/transform/stc/ArraysAndCollectionsSTCTest.groovy
index d86840ce9e..f3750923a7 100644
--- a/src/test/groovy/transform/stc/ArraysAndCollectionsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/ArraysAndCollectionsSTCTest.groovy
@@ -661,7 +661,27 @@ class ArraysAndCollectionsSTCTest extends StaticTypeCheckingTestCase {
                 assert node.getNodeMetaData(INFERRED_TYPE) == int_TYPE.makeArray().makeArray()
             })
             int[][] array = [[1]] as int[][]
-            array[0].length
+            assert array[0].length == 1
+        '''
+    }
+
+    // GROOVY-10319
+    void testArrayClone() {
+        assertScript '''
+            package p // must be in package for protected method check
+
+            @groovy.transform.ToString(includeFields=true)
+            class C implements Cloneable {
+                private int[] array = [1]
+                @Override
+                C clone() {
+                    C c = (C) super.clone()
+                    c.array = array.clone()
+                    return c
+                }
+            }
+
+            assert new C().clone().toString() == 'p.C([1])'
         '''
     }
 
