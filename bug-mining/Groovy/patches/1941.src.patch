diff --git a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
index 438dc065cc..f361fa9c79 100644
--- a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
+++ b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
@@ -61,14 +61,6 @@ public class StaticTypesCallSiteWriter extends CallSiteWriter implements Opcodes
     public void makeCallSite(final Expression receiver, final String message, final Expression arguments, final boolean safe, final boolean implicitThis, final boolean callCurrent, final boolean callStatic) {
     }
 
-/*
-    @Override
-    public void generateCallSiteArray() {
-        // todo
-        // GROOVY-5564: call site array may be skipped if the class is fully statically compiled
-    }
-*/
-
     @Override
     public void makeGetPropertySite(Expression receiver, final String methodName, final boolean safe, final boolean implicitThis) {
         TypeChooser typeChooser = controller.getTypeChooser();
@@ -95,21 +87,6 @@ public class StaticTypesCallSiteWriter extends CallSiteWriter implements Opcodes
         }
         MethodVisitor mv = controller.getMethodVisitor();
 
-        boolean isStaticProperty = receiver instanceof ClassExpression
-                && (receiverType.isDerivedFrom(receiver.getType()) || receiverType.implementsInterface(receiver.getType()));
-
-        if (!isStaticProperty) {
-            if (receiverType.implementsInterface(MAP_TYPE) || MAP_TYPE.equals(receiverType)) {
-                // for maps, replace map.foo with map.get('foo')
-                writeMapDotProperty(receiver, methodName, mv);
-                return;
-            }
-            if (receiverType.implementsInterface(LIST_TYPE) || LIST_TYPE.equals(receiverType)) {
-                writeListDotProperty(receiver, methodName, mv);
-                return;
-            }
-        }
-
         if (receiverType.isArray() && methodName.equals("length")) {
             receiver.visit(controller.getAcg());
             ClassNode arrayGetReturnType = typeChooser.resolveType(receiver, classNode);
@@ -197,6 +174,22 @@ public class StaticTypesCallSiteWriter extends CallSiteWriter implements Opcodes
             }
         }
 
+        boolean isStaticProperty = receiver instanceof ClassExpression
+                && (receiverType.isDerivedFrom(receiver.getType()) || receiverType.implementsInterface(receiver.getType()));
+
+        if (!isStaticProperty) {
+            if (receiverType.implementsInterface(MAP_TYPE) || MAP_TYPE.equals(receiverType)) {
+                // for maps, replace map.foo with map.get('foo')
+                writeMapDotProperty(receiver, methodName, mv);
+                return;
+            }
+            if (receiverType.implementsInterface(LIST_TYPE) || LIST_TYPE.equals(receiverType)) {
+                writeListDotProperty(receiver, methodName, mv);
+                return;
+            }
+        }
+
+
         controller.getSourceUnit().addError(
                 new SyntaxException("Access to "+
                                                 (receiver instanceof ClassExpression ?receiver.getType():receiverType).toString(false)
diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 15b4be5110..7eb9520889 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -20,7 +20,6 @@ import groovy.lang.IntRange;
 import groovy.lang.ObjectRange;
 import groovy.transform.TypeChecked;
 import groovy.transform.TypeCheckingMode;
-import org.codehaus.groovy.GroovyBugError;
 import org.codehaus.groovy.ast.*;
 import org.codehaus.groovy.ast.expr.*;
 import org.codehaus.groovy.ast.stmt.*;
@@ -844,9 +843,6 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         boolean isAttributeExpression = pexp instanceof AttributeExpression;
         if (clazz.isInterface()) tests.add(OBJECT_TYPE);
         for (ClassNode testClass : tests) {
-            boolean isStaticProperty = pexp.getObjectExpression() instanceof ClassExpression && implementsInterfaceOrIsSubclassOf(testClass, pexp.getObjectExpression().getType());
-            // maps and lists have special handling for property expressions
-            if (isStaticProperty || (!implementsInterfaceOrIsSubclassOf(testClass, MAP_TYPE) && !implementsInterfaceOrIsSubclassOf(testClass, LIST_TYPE))) {
                 LinkedList<ClassNode> queue = new LinkedList<ClassNode>();
                 queue.add(testClass);
                 if (testClass.isInterface()) {
@@ -871,7 +867,8 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                         MethodNode setterMethod = current.getSetterMethod("set" + capName);
                         if (setterMethod != null) {
                             if (visitor != null) visitor.visitMethod(getter);
-                            storeType(pexp, inferReturnTypeGenerics(current, getter, ArgumentListExpression.EMPTY_ARGUMENTS));
+                            ClassNode cn = inferReturnTypeGenerics(current, getter, ArgumentListExpression.EMPTY_ARGUMENTS);
+                            storeInferredTypeForPropertyExpression(pexp, cn);
                             return true;
                         }
                     }
@@ -879,6 +876,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                         FieldNode field = current.getDeclaredField(propertyName);
                         if (field != null) {
                             if (visitor != null) visitor.visitField(field);
+                            storeInferredTypeForPropertyExpression(pexp, field.getOriginType());
                             storeType(pexp, field.getOriginType());
                             return true;
                         }
@@ -904,7 +902,8 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                         if (getter != null) {
                             if (visitor != null) visitor.visitMethod(getter);
                             pexp.putNodeMetaData(StaticTypesMarker.READONLY_PROPERTY, Boolean.TRUE);
-                            storeType(pexp, inferReturnTypeGenerics(current, getter, ArgumentListExpression.EMPTY_ARGUMENTS));
+                            ClassNode cn = inferReturnTypeGenerics(current, getter, ArgumentListExpression.EMPTY_ARGUMENTS);
+                            storeInferredTypeForPropertyExpression(pexp, cn);
                             return true;
                         }
                         if (pluginFactory != null) {
@@ -913,7 +912,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                                 PropertyNode result = plugin.resolveProperty(current, propertyName);
                                 if (result != null) {
                                     if (visitor != null) visitor.visitProperty(result);
-                                    storeType(pexp, result.getType());
+                                    storeInferredTypeForPropertyExpression(pexp, result.getType());
                                     return true;
                                 }
                             }
@@ -934,11 +933,15 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                         if (visitor != null) {
                             visitor.visitMethod(getter);
                         }
-                        storeType(pexp, inferReturnTypeGenerics(testClass, getter, ArgumentListExpression.EMPTY_ARGUMENTS));
+                        ClassNode cn = inferReturnTypeGenerics(testClass, getter, ArgumentListExpression.EMPTY_ARGUMENTS);
+                        storeInferredTypeForPropertyExpression(pexp, cn);
+
                         return true;
                     }
                 }
-            } else {
+        }
+        for (ClassNode testClass : tests) {
+            if (implementsInterfaceOrIsSubclassOf(testClass, MAP_TYPE) || implementsInterfaceOrIsSubclassOf(testClass, LIST_TYPE)) {
                 if (visitor != null) {
                     // todo : type inferrence on maps and lists, if possible
                     PropertyNode node = new PropertyNode(propertyName, Opcodes.ACC_PUBLIC, OBJECT_TYPE, clazz, null, null, null);
@@ -950,6 +953,18 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         return false;
     }
 
+    private void storeInferredTypeForPropertyExpression(final PropertyExpression pexp, final ClassNode flatInferredType) {
+        if (pexp.isSpreadSafe()) {
+            ClassNode list = LIST_TYPE.getPlainNodeReference();
+            list.setGenericsTypes(new GenericsType[] {
+                    new GenericsType(flatInferredType)
+            });
+            storeType(pexp, list);
+        } else {
+            storeType(pexp, flatInferredType);
+        }
+    }
+
     protected boolean hasSetter(final PropertyExpression pexp) {
         Expression objectExpression = pexp.getObjectExpression();
         ClassNode clazz = getType(objectExpression);
diff --git a/src/test/groovy/transform/stc/ArraysAndCollectionsSTCTest.groovy b/src/test/groovy/transform/stc/ArraysAndCollectionsSTCTest.groovy
index 5990631fd4..a46cd4f8e7 100644
--- a/src/test/groovy/transform/stc/ArraysAndCollectionsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/ArraysAndCollectionsSTCTest.groovy
@@ -166,8 +166,19 @@ class ArraysAndCollectionsSTCTest extends StaticTypeCheckingTestCase {
     void testListStarProperty() {
         assertScript '''
             List list = ['a','b','c']
+            @ASTTest(phase=INSTRUCTION_SELECTION, value={
+                def iType = node.getNodeMetaData(INFERRED_TYPE)
+                assert iType == make(List)
+                assert iType.isUsingGenerics()
+                assert iType.genericsTypes[0].type == CLASS_Type
+            })
             List classes = list*.class
             assert classes == [String,String,String]
+            @ASTTest(phase=INSTRUCTION_SELECTION, value={
+                assert node.getNodeMetaData(INFERRED_TYPE) == CLASS_Type
+            })
+            def listClass = list.class
+            assert listClass == ArrayList
         '''
     }
 
diff --git a/src/test/groovy/transform/stc/MiscSTCTest.groovy b/src/test/groovy/transform/stc/MiscSTCTest.groovy
index 35bdf1bd01..4b3e4a5a0f 100644
--- a/src/test/groovy/transform/stc/MiscSTCTest.groovy
+++ b/src/test/groovy/transform/stc/MiscSTCTest.groovy
@@ -203,6 +203,21 @@ class MiscSTCTest extends StaticTypeCheckingTestCase {
         '''
     }
 
+    // GROOVY-5699
+    void testIntRangeInference() {
+        assertScript '''
+            @ASTTest(phase=INSTRUCTION_SELECTION, value={
+                assert node.getNodeMetaData(INFERRED_TYPE) == make(IntRange)
+            })
+            def range = 1..10
+
+            @ASTTest(phase=INSTRUCTION_SELECTION, value={
+                assert node.getNodeMetaData(INFERRED_TYPE) == int_TYPE
+            })
+            def from = range.fromInt
+        '''
+    }
+
     public static class MiscSTCTestSupport {
         static def foo() { '123' }
     }
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/ArraysAndCollectionsStaticCompileTest.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/ArraysAndCollectionsStaticCompileTest.groovy
index 187af3f54d..257c65208b 100644
--- a/src/test/org/codehaus/groovy/classgen/asm/sc/ArraysAndCollectionsStaticCompileTest.groovy
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/ArraysAndCollectionsStaticCompileTest.groovy
@@ -66,12 +66,8 @@ class ArraysAndCollectionsStaticCompileTest extends ArraysAndCollectionsSTCTest
     }
 
     @Override
-    void testArrayLengthOnMultidimensionalArray() {
-        try {
-            super.testArrayLengthOnMultidimensionalArray()
-        } finally {
-            println astTrees
-        }
+    void testListStarProperty() {
+        super.testListStarProperty()
     }
 }
 
