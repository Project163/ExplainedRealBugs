diff --git a/src/main/groovy/grape/GrapeIvy.groovy b/src/main/groovy/grape/GrapeIvy.groovy
index 8db3a1c8a1..c8076ca03c 100644
--- a/src/main/groovy/grape/GrapeIvy.groovy
+++ b/src/main/groovy/grape/GrapeIvy.groovy
@@ -52,6 +52,8 @@ class GrapeIvy implements GrapeEngine {
     Ivy ivyInstance
     // weak hash map so we don't leak loaders directly
     Map<ClassLoader, Set<IvyGrabRecord>> loadedDeps = new WeakHashMap<ClassLoader, Set<IvyGrabRecord>>()
+    // set that stores the IvyGrabRecord(s) for all the dependencies in each grab() call 
+    Set<IvyGrabRecord> grabRecordsForCurrDepdendencies = new LinkedHashSet<IvyGrabRecord>()
 
     public GrapeIvy() {
         // if we are already inited, quit
@@ -210,9 +212,11 @@ class GrapeIvy implements GrapeEngine {
     }
 
     public grab(Map args, Map... dependencies) {
+        def loader
+        grabRecordsForCurrDepdendencies.clear()
         try {
             // identify the target classloader early, so we fail before checking repositories
-            def loader = chooseClassLoader(
+            loader = chooseClassLoader(
                 classLoader:args.remove('classLoader'),
                 refObject:args.remove('refObject'),
                 calleeDepth:args.calleeDepth?:DEFAULT_DEPTH,
@@ -227,6 +231,11 @@ class GrapeIvy implements GrapeEngine {
                 loader.addURL(uri.toURL())
             }
         } catch (Exception e) {
+            // clean-up the state first
+            Set<IvyGrabRecord> grabRecordsForCurrLoader = loadedDeps[loader]
+            grabRecordsForCurrLoader.removeAll(grabRecordsForCurrDepdendencies)
+            grabRecordsForCurrDepdendencies.clear()
+            
             if (args.noExceptions) {
                 return e
             } else {
@@ -348,7 +357,11 @@ class GrapeIvy implements GrapeEngine {
             loadedDeps.put(loader, localDeps)
         }
 
-        dependencies.each { localDeps.add(createGrabRecord(it)) }
+        dependencies.each {
+            IvyGrabRecord igr = createGrabRecord(it)
+            grabRecordsForCurrDepdendencies.add(igr)
+            localDeps.add(igr) 
+        }
         // the call to reverse ensures that the newest additions are in
         // front causing existing dependencies to come last and thus
         // claiming higher priority.  Thus when module versions clash we
diff --git a/src/test/groovy/bugs/Groovy3853Bug.groovy b/src/test/groovy/bugs/Groovy3853Bug.groovy
new file mode 100644
index 0000000000..0be359aa3d
--- /dev/null
+++ b/src/test/groovy/bugs/Groovy3853Bug.groovy
@@ -0,0 +1,34 @@
+package groovy.bugs
+
+class Groovy3853Bug extends GroovyTestCase {
+
+    void testConsecutiveGrabCallsWithASharedLoaderWhereFirstGrabFails() {
+        def classLoader = new GroovyClassLoader()
+
+        grabThatShouldFail(classLoader)
+        
+        // currently this call also fails because GrapeIvy maintains state from previous failure 
+        grabThatShouldGoThrough(classLoader) 
+    }
+    
+    def grabThatShouldFail(classLoader) {
+        try{
+            // just an unlikely grab, that's all
+            classLoader.parseClass """
+                @Grab(group="roshan", module="dawrani", version="0.0.7")
+                class Foo3853V1 {}
+            """
+            fail('This @Grab usage should have failed')
+        }catch(ex) {
+            // fine if it failed
+            assertTrue ex.message.contains('unresolved dependency')
+        }
+    }
+
+    def grabThatShouldGoThrough(classLoader) {
+        classLoader.parseClass """
+            @Grab(group="junit", module="junit", version="4.7")
+            class Foo3853V2 {}
+        """
+    }
+}
