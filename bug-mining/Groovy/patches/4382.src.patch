diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 6383657039..44cea80a81 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -1097,7 +1097,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             if (!argumentList.getExpressions().isEmpty() && constructor != null) {
                 ClassNode type = GenericsUtils.parameterizeType(cceType, cceType);
                 type = inferReturnTypeGenerics(type, constructor, argumentList);
-                if (type.toString(false).indexOf('#') > 0 // GROOVY-9983, GROOVY-10291
+                if (type.toString(false).indexOf('#') > 0 // GROOVY-9983, GROOVY-10291, GROOVY-10368
                         // GROOVY-6232, GROOVY-9956: if cce not assignment compatible, process target as additional type witness
                         || checkCompatibleAssignmentTypes(lType, type, cce) && !GenericsUtils.buildWildcardType(lType).isCompatibleWith(type)) {
                     // allow covariance of each type parameter, but maintain semantics for nested generics
@@ -1107,8 +1107,8 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                     if (lhs == null || rhs == null || lhs.length != rhs.length) throw new GroovyBugError(
                             "Parameterization failed: " + prettyPrintType(pType) + " ~ " + prettyPrintType(type));
 
-                    if (java.util.stream.IntStream.range(0, lhs.length).allMatch(i ->
-                            GenericsUtils.buildWildcardType(getCombinedBoundType(lhs[i])).isCompatibleWith(getCombinedBoundType(rhs[i])))) {
+                    if (IntStream.range(0, lhs.length).allMatch(i ->
+                            GenericsUtils.buildWildcardType(getCombinedBoundType(lhs[i])).isCompatibleWith(rhs[i].getType()))) {
                         type = pType; // lType proved to be a viable type witness
                     }
                 }
diff --git a/src/test/groovy/transform/stc/GenericsSTCTest.groovy b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
index 6b45ebf8a4..363c2f0050 100644
--- a/src/test/groovy/transform/stc/GenericsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
@@ -1167,6 +1167,21 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
         '''
     }
 
+    // GROOVY-10368
+    void testDiamondInferrenceFromConstructor25() {
+        ['T', 'T extends Number', 'T extends Object'].each {
+            assertScript """
+                class C<$it> {
+                    C(p) {
+                    }
+                }
+                void m(C<Integer> c) {
+                }
+                m(new C<>(null)) // Cannot call m(C<Integer>) with arguments [C<# extends Number>]
+            """
+        }
+    }
+
     // GROOVY-10280
     void testTypeArgumentPropagation() {
         assertScript '''
