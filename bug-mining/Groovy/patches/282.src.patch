diff --git a/src/main/org/codehaus/groovy/classgen/ClassCompletionVerifier.java b/src/main/org/codehaus/groovy/classgen/ClassCompletionVerifier.java
index 3939e75465..6c21672a19 100644
--- a/src/main/org/codehaus/groovy/classgen/ClassCompletionVerifier.java
+++ b/src/main/org/codehaus/groovy/classgen/ClassCompletionVerifier.java
@@ -7,9 +7,9 @@
  * 
  * Contributors:
  * IBM - Initial API and implementation
+ * Groovy community - subsequent modifications
  ******************************************************************************/
 
-
 package org.codehaus.groovy.classgen;
 
 import java.lang.reflect.Modifier;
@@ -56,6 +56,7 @@ public class ClassCompletionVerifier extends ClassCodeVisitorSupport {
         
         checkImplementsAndExtends(node);
         if (source!=null && !source.getErrorCollector().hasErrors()) {
+            checkClassForAbstractAndFinal(node);
             checkClassForOverwritingFinal(node);
             checkMethodsForOverwritingFinal(node);
             checkNoAbstractMethodsNonabstractClass(node);
@@ -73,26 +74,32 @@ public class ClassCompletionVerifier extends ClassCodeVisitorSupport {
         for (Iterator iter = abstractMethods.iterator(); iter.hasNext();) {
             MethodNode method = (MethodNode) iter.next();
             String methodName = method.getTypeDescriptor();
-            addError("Can't have an abstract method in a non abstract class."+
+            addError("Can't have an abstract method in a non-abstract class."+
                      " The class '"+node.getName()+"' must be declared abstract or"+
                      " the method '"+methodName+"' must be implemented.",node);
         }
     }
 
+    private void checkClassForAbstractAndFinal(ClassNode node) {
+        if (!Modifier.isAbstract(node.getModifiers())) return;
+        if (!Modifier.isFinal(node.getModifiers())) return;
+        addError("The class '" + node.getName() + "' must not be both final and abstract.", node);
+    }
+    
     private void checkAbstractDeclaration(MethodNode methodNode) {
         if (!Modifier.isAbstract(methodNode.getModifiers())) return;
         if (Modifier.isAbstract(currentClass.getModifiers())) return;
-        addError("Can't have an abstract method in a non abstract class." +
+        addError("Can't have an abstract method in a non-abstract class." +
                  " The class '" + currentClass.getName() +  "' must be declared abstract or the method '" +
                  methodNode.getTypeDescriptor() + "' must not be abstract.",methodNode);
     }
-    
+
     private void checkClassForOverwritingFinal(ClassNode cn) {
         ClassNode superCN = cn.getSuperClass();
         if (superCN==null) return;
         if (!Modifier.isFinal(superCN.getModifiers())) return;
         StringBuffer msg = new StringBuffer();
-        msg.append("you are not allowed to overwrite the final class ");
+        msg.append("You are not allowed to overwrite the final class ");
         msg.append(superCN.getName());
         msg.append(".");
         addError(msg.toString(),cn);        
@@ -100,11 +107,11 @@ public class ClassCompletionVerifier extends ClassCodeVisitorSupport {
     
     private void checkImplementsAndExtends(ClassNode node) {
         ClassNode cn = node.getSuperClass();
-        if (cn.isInterface() && !node.isInterface()) addError("you are not allowed to extend the Interface "+cn.getName()+", use implements instead", node);
+        if (cn.isInterface() && !node.isInterface()) addError("You are not allowed to extend the Interface "+cn.getName()+", use implements instead", node);
         ClassNode[] interfaces = node.getInterfaces();
         for (int i = 0; i < interfaces.length; i++) {
             cn = interfaces[i];
-            if (!cn.isInterface()) addError ("you are not allowed to implement the Class "+cn.getName()+", use extends instead", node); 
+            if (!cn.isInterface()) addError ("You are not allowed to implement the Class "+cn.getName()+", use extends instead", node);
         }
     }
 
@@ -122,7 +129,7 @@ public class ClassCompletionVerifier extends ClassCodeVisitorSupport {
                     if (!Modifier.isFinal(m.getModifiers())) return;
                     
                     StringBuffer msg = new StringBuffer();
-                    msg.append("you are not allowed to overwrite the final method ").append(method.getName());
+                    msg.append("You are not allowed to overwrite the final method ").append(method.getName());
                     msg.append("(");
                     boolean semi = false;
                     for (int i=0; i<parameters.length;i++) {
@@ -161,7 +168,7 @@ public class ClassCompletionVerifier extends ClassCodeVisitorSupport {
     public void visitConstructorCallExpression(ConstructorCallExpression call) {
         ClassNode type = call.getType();
         if (Modifier.isAbstract(type.getModifiers())) {
-            addError("cannot create an instance from the abstract class "+type.getName(),call);
+            addError("You cannot create an instance from the abstract class "+type.getName(),call);
         }
         super.visitConstructorCallExpression(call);
     }
@@ -220,7 +227,7 @@ public class ClassCompletionVerifier extends ClassCodeVisitorSupport {
     
     public void visitCatchStatement(CatchStatement cs) {
         if (!(cs.getExceptionType().isDerivedFrom(ClassHelper.make(Throwable.class)))) {
-            addError("catch statement parameter type is no subclass of Throwable",cs);
+            addError("Catch statement parameter type is not a subclass of Throwable",cs);
         }
         super.visitCatchStatement(cs);
     }
@@ -231,7 +238,7 @@ public class ClassCompletionVerifier extends ClassCodeVisitorSupport {
         if (!type.isResolved() && cu.hasClassNodeToCompile()) {
             String location = cu.getScriptSourceLocation(type.getName());
             if (location==null) return;
-            addError("expected to find the class "+ type.getName() +
+            addError("Expected to find the class "+ type.getName() +
                      " in "+location + ", but failed to find it.", expression);
         }
     }
diff --git a/src/test/AllCodehausJavaTestsSuite.java b/src/test/AllCodehausJavaTestsSuite.java
index 76f3493d34..d769f345bf 100644
--- a/src/test/AllCodehausJavaTestsSuite.java
+++ b/src/test/AllCodehausJavaTestsSuite.java
@@ -12,7 +12,6 @@ import org.codehaus.groovy.antlr.treewalker.*;
 import org.codehaus.groovy.bsf.*;
 import org.codehaus.groovy.ast.*;
 import org.codehaus.groovy.classgen.*;
-import org.codehaus.groovy.classgen.TupleListTest;
 import junit.framework.Test;
 import junit.framework.TestSuite;
 
@@ -24,49 +23,50 @@ public class AllCodehausJavaTestsSuite {
 
     public static Test suite() {
         TestSuite suite = new TestSuite();
-        suite.addTestSuite(GroovySourceASTTest.class);
-        suite.addTestSuite(SourceBufferTest.class);
-        suite.addTestSuite(SourcePrinterTest.class);  
-        suite.addTestSuite(ClassNodeTest.class);
-        suite.addTestSuite(ModuleNodeTest.class);
         suite.addTestSuite(BSFTest.class);
-        suite.addTestSuite(CacheBSFTest.class);
         suite.addTestSuite(BytecodeHelperTest.class);
+        suite.addTestSuite(CacheBSFTest.class);
         suite.addTestSuite(CapitalizeTest.class);
+        suite.addTestSuite(ClassCompletionVerifierTest.class);
+        suite.addTestSuite(ClassNodeTest.class);
+        suite.addTestSuite(CompilationUnitTest.class);
+        suite.addTestSuite(CompilerTest.class);
         suite.addTestSuite(ConstructorTest.class);
+        suite.addTestSuite(DefaultGroovyMethodsTest.class);
+        suite.addTestSuite(DomToGroovyTest.class);
+        suite.addTestSuite(FileSystemCompilerTest.class);
         suite.addTestSuite(ForTest.class);
         suite.addTestSuite(GetPropertyTest.class);
         suite.addTestSuite(GroovyClassLoaderTest.class);
+        suite.addTestSuite(GroovySourceASTTest.class);
         suite.addTestSuite(GStringTest.class);
         suite.addTestSuite(IfElseTest.class);
+        suite.addTestSuite(InvokerTest.class);
+        suite.addTestSuite(InvokeMethodTest.class);
+        suite.addTestSuite(InvokeGroovyMethodTest.class);
+        suite.addTestSuite(InvokeConstructorTest.class);
+        suite.addTestSuite(InheritedInterfaceMethodTest.class);
         suite.addTestSuite(MainTest.class);
+        suite.addTestSuite(MethodFailureTest.class);
+        suite.addTestSuite(MethodKeyTest.class);
         suite.addTestSuite(MethodTest.class);
+        suite.addTestSuite(ModuleNodeTest.class);
+        suite.addTestSuite(NewStaticMetaMethodTest.class);
+        suite.addTestSuite(org.codehaus.groovy.classgen.PropertyTest.class);
+        suite.addTestSuite(org.codehaus.groovy.runtime.PropertyTest.class);
         suite.addTestSuite(ReflectorGeneratorTest.class);
         suite.addTestSuite(RunBugsTest.class);
         suite.addTestSuite(RunClosureTest.class);
         suite.addTestSuite(RunGroovyTest.class);
-        suite.addTestSuite(TupleListTest.class);
-        suite.addTestSuite(VerifierCodeVisitorTest.class);
-        suite.addTestSuite(CompilationUnitTest.class);
-//        suite.addTestSuite(TestCaseRenderEngineTest.class);
 //        suite.addTestSuite(RunWikiTest.class);
-        suite.addTestSuite(DomToGroovyTest.class);
-        suite.addTestSuite(FileSystemCompilerTest.class);
-        suite.addTestSuite(CompilerTest.class);
-        suite.addTestSuite(TokenTest.class);
-        suite.addTestSuite(TupleListTest.class);
-        suite.addTestSuite(org.codehaus.groovy.classgen.PropertyTest.class);
-        suite.addTestSuite(org.codehaus.groovy.runtime.PropertyTest.class);
-        suite.addTestSuite(NewStaticMetaMethodTest.class);
-        suite.addTestSuite(MethodKeyTest.class);
-        suite.addTestSuite(MethodFailureTest.class);
-        suite.addTestSuite(InvokerTest.class);
-        suite.addTestSuite(InvokeMethodTest.class);
-        suite.addTestSuite(InvokeGroovyMethodTest.class);
-        suite.addTestSuite(InvokeConstructorTest.class);
-        suite.addTestSuite(InheritedInterfaceMethodTest.class);
-        suite.addTestSuite(DefaultGroovyMethodsTest.class);
+        suite.addTestSuite(SourceBufferTest.class);
+        suite.addTestSuite(SourcePrinterTest.class);
         suite.addTestSuite(SyntaxErrorMessageTest.class);
+//        suite.addTestSuite(TestCaseRenderEngineTest.class);
+        suite.addTestSuite(TokenTest.class);
+        suite.addTestSuite(org.codehaus.groovy.classgen.TupleListTest.class);
+        suite.addTestSuite(org.codehaus.groovy.runtime.TupleListTest.class);
+        suite.addTestSuite(VerifierCodeVisitorTest.class);
         return suite;
     }
 }
\ No newline at end of file
diff --git a/src/test/org/codehaus/groovy/classgen/ClassCompletionVerifierTest.java b/src/test/org/codehaus/groovy/classgen/ClassCompletionVerifierTest.java
new file mode 100644
index 0000000000..75c3a7ba3c
--- /dev/null
+++ b/src/test/org/codehaus/groovy/classgen/ClassCompletionVerifierTest.java
@@ -0,0 +1,45 @@
+package org.codehaus.groovy.classgen;
+
+import org.codehaus.groovy.ast.*;
+import org.codehaus.groovy.control.SourceUnit;
+
+import java.io.PrintWriter;
+import java.io.StringWriter;
+
+/**
+ *
+ * @author Paul King
+ */
+public class ClassCompletionVerifierTest extends TestSupport {
+    private SourceUnit source;
+    private ClassCompletionVerifier verifier;
+    private static final String ABSTRACT_FINAL_CLASS = "AbstractFinalClass";
+    private static final String EXPECTED_ERROR_MESSAGE = "The class '" + ABSTRACT_FINAL_CLASS + "' must not be both final and abstract.";
+
+    protected void setUp() throws Exception {
+        super.setUp();
+        source = SourceUnit.create("dummy.groovy", "");
+        verifier = new ClassCompletionVerifier(source);
+    }
+
+    public void testDetectsFinalAbstract() throws Exception {
+        checkVisitErrors("FinalClass", ACC_FINAL, false);
+        checkVisitErrors("AbstractClass", ACC_ABSTRACT, false);
+        checkVisitErrors(ABSTRACT_FINAL_CLASS, ACC_ABSTRACT | ACC_FINAL, true);
+        checkErrorMessage(EXPECTED_ERROR_MESSAGE);
+    }
+
+    private void checkVisitErrors(String name, int modifiers, boolean expectedToFail) {
+        ClassNode node = new ClassNode(name, modifiers, ClassHelper.OBJECT_TYPE);
+        verifier.visitClass(node);
+        assertTrue(source.getErrorCollector().hasErrors() == expectedToFail);
+    }
+
+    private void checkErrorMessage(String expectedErrorMessage) {
+        StringWriter stringWriter = new StringWriter();
+        PrintWriter writer = new PrintWriter(stringWriter, true);
+        source.getErrorCollector().getError(0).write(writer);
+        writer.close();
+        assertTrue(stringWriter.toString().indexOf(expectedErrorMessage) != -1);
+    }
+}
