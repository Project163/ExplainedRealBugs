diff --git a/src/main/groovy/lang/MetaClassImpl.java b/src/main/groovy/lang/MetaClassImpl.java
index f9f3cc02f8..e575ef9e62 100644
--- a/src/main/groovy/lang/MetaClassImpl.java
+++ b/src/main/groovy/lang/MetaClassImpl.java
@@ -86,7 +86,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
     private boolean initialized;
     // we only need one of these that can be reused over and over.
     private final MetaProperty arrayLengthProperty = new MetaArrayLengthProperty();
-    private static final MetaMethod AMBIGOUS_LISTENER_METHOD = new DummyMetaMethod();
+    private static final MetaMethod AMBIGUOUS_LISTENER_METHOD = new DummyMetaMethod();
     private static final Object[] EMPTY_ARGUMENTS = {};
     private final Set newGroovyMethodsSet = new HashSet();
 
@@ -1869,12 +1869,12 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
         //----------------------------------------------------------------------
         // listener method
         //----------------------------------------------------------------------
-        boolean ambigousListener = false;
+        boolean ambiguousListener = false;
         if (method == null) {
             method = (MetaMethod) listeners.get(name);
-            ambigousListener = method == AMBIGOUS_LISTENER_METHOD;
+            ambiguousListener = method == AMBIGUOUS_LISTENER_METHOD;
             if (method != null &&
-                    !ambigousListener &&
+                    !ambiguousListener &&
                     newValue instanceof Closure) {
                 // lets create a dynamic proxy
                 Object proxy = Proxy.newProxyInstance(
@@ -1934,7 +1934,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
         //----------------------------------------------------------------------
         // error due to missing method/field
         //----------------------------------------------------------------------
-        if (ambigousListener) {
+        if (ambiguousListener) {
             throw new GroovyRuntimeException("There are multiple listeners for the property " + name + ". Please do not use the bean short form to access this listener.");
         }
         if (mp != null) {
@@ -2378,7 +2378,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
             return null;
         }
 
-        //more than one matching method found --> ambigous!
+        //more than one matching method found --> ambiguous!
         String msg = "Ambiguous method overloading for method ";
         msg += theClass.getName() + "#" + name;
         msg += ".\nCannot resolve which method to invoke for ";
@@ -2410,15 +2410,24 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
 
     private void addProperties() {
         BeanInfo info;
+        final Class stopClass;
         //     introspect
         try {
-            info = (BeanInfo) AccessController.doPrivileged(new PrivilegedExceptionAction() {
-                public Object run() throws IntrospectionException {
-                    return Introspector.getBeanInfo(theClass);
-                }
-            });
+            if (isBeanDerivative(theClass)) {
+                info = (BeanInfo) AccessController.doPrivileged(new PrivilegedExceptionAction() {
+                    public Object run() throws IntrospectionException {
+                        return Introspector.getBeanInfo(theClass, Introspector.IGNORE_ALL_BEANINFO);
+                    }
+                });
+            } else {
+                info = (BeanInfo) AccessController.doPrivileged(new PrivilegedExceptionAction() {
+                    public Object run() throws IntrospectionException {
+                        return Introspector.getBeanInfo(theClass);
+                    }
+                });
+            }
         } catch (PrivilegedActionException pae) {
-            throw new GroovyRuntimeException("exception while bean introspection", pae.getException());
+            throw new GroovyRuntimeException("exception during bean introspection", pae.getException());
         }
         PropertyDescriptor[] descriptors = info.getPropertyDescriptors();
         // build up the metaproperties based on the public fields, property descriptors,
@@ -2435,7 +2444,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
                 addToAllMethodsIfPublic(metaMethod);
                 String name = listenerMethod.getName();
                 if (listeners.containsKey(name)) {
-                    listeners.put(name, AMBIGOUS_LISTENER_METHOD);
+                    listeners.put(name, AMBIGUOUS_LISTENER_METHOD);
                 } else {
                     listeners.put(name, metaMethod);
                 }
@@ -2443,6 +2452,15 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
         }
     }
 
+    private boolean isBeanDerivative(Class theClass) {
+        Class next = theClass;
+        while (next != null) {
+            if (Arrays.asList(next.getInterfaces()).contains(BeanInfo.class)) return true;
+            next = next.getSuperclass();
+        }
+        return false;
+    }
+
     private void addToAllMethodsIfPublic(MetaMethod metaMethod) {
         if (Modifier.isPublic(metaMethod.getModifiers()))
             allMethods.add(metaMethod);
diff --git a/src/test/groovy/bugs/Groovy596_Bug.groovy b/src/test/groovy/bugs/Groovy596_Bug.groovy
new file mode 100644
index 0000000000..4742dc636c
--- /dev/null
+++ b/src/test/groovy/bugs/Groovy596_Bug.groovy
@@ -0,0 +1,31 @@
+package groovy.bugs
+
+import java.beans.*
+
+/**
+ *  BeanInfo class usage
+ */
+
+class Groovy596_Bug extends GroovyTestCase {
+
+    void testMetaClassUsageOfBeanInfoDoesNotConflictWithScriptUsageLeadingToStackOverflow() {
+    	assertNotNull(new A());
+    	assertNotNull(new B());
+    	assertNotNull(new C());
+    	assertNotNull(new D());
+    }
+}
+
+class A extends java.beans.SimpleBeanInfo { }
+class B extends A { }
+class C implements java.beans.BeanInfo {
+    public BeanDescriptor getBeanDescriptor() {return null;}
+    public EventSetDescriptor[] getEventSetDescriptors() {return new EventSetDescriptor[0];}
+    public int getDefaultEventIndex() {return 0;}
+    public PropertyDescriptor[] getPropertyDescriptors() {return new PropertyDescriptor[0];}
+    public int getDefaultPropertyIndex() {return 0;}
+    public MethodDescriptor[] getMethodDescriptors() {return new MethodDescriptor[0];}
+    public BeanInfo[] getAdditionalBeanInfo() {return new BeanInfo[0];}
+    public java.awt.Image getIcon(int iconKind) {return null;}
+}
+class D extends C {}
