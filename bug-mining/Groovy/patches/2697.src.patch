diff --git a/src/main/org/codehaus/groovy/classgen/asm/InvocationWriter.java b/src/main/org/codehaus/groovy/classgen/asm/InvocationWriter.java
index fac5cc89c9..c4ab5ac92e 100644
--- a/src/main/org/codehaus/groovy/classgen/asm/InvocationWriter.java
+++ b/src/main/org/codehaus/groovy/classgen/asm/InvocationWriter.java
@@ -15,6 +15,7 @@
  */
 package org.codehaus.groovy.classgen.asm;
 
+import java.lang.reflect.Modifier;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
@@ -105,14 +106,16 @@ public class InvocationWriter {
         String methodName = target.getName();
         CompileStack compileStack = controller.getCompileStack();
         OperandStack operandStack = controller.getOperandStack();
-        
+        ClassNode declaringClass = target.getDeclaringClass();
+        ClassNode classNode = controller.getClassNode();
+
         MethodVisitor mv = controller.getMethodVisitor();
         int opcode = INVOKEVIRTUAL;
         if (target.isStatic()) {
             opcode = INVOKESTATIC;
         } else if (target.isPrivate() || ((receiver instanceof VariableExpression && ((VariableExpression) receiver).isSuperExpression()))) {
             opcode = INVOKESPECIAL;
-        } else if (target.getDeclaringClass().isInterface()) {
+        } else if (declaringClass.isInterface()) {
             opcode = INVOKEINTERFACE;
         }
 
@@ -122,8 +125,6 @@ public class InvocationWriter {
             if (receiver!=null) {
                 // load receiver if not static invocation
                 // todo: fix inner class case
-                ClassNode declaringClass = target.getDeclaringClass();
-                ClassNode classNode = controller.getClassNode();
                 if (implicitThis
                         && !classNode.isDerivedFrom(declaringClass)
                         && !classNode.implementsInterface(declaringClass)
@@ -152,7 +153,18 @@ public class InvocationWriter {
         loadArguments(args.getExpressions(), target.getParameters());
 
 
-        String owner = BytecodeHelper.getClassInternalName(target.getDeclaringClass());
+        String owner = BytecodeHelper.getClassInternalName(declaringClass);
+        ClassNode receiverType = receiver!=null?controller.getTypeChooser().resolveType(receiver, classNode):target.getDeclaringClass();
+        if (opcode==INVOKEVIRTUAL
+                && target.isPublic()
+                && (!Modifier.isPublic(declaringClass.getModifiers())
+                && !receiverType.equals(declaringClass))
+                && receiverType.isDerivedFrom(declaringClass)
+                && !receiverType.getPackageName().equals(classNode.getPackageName())) {
+            // package private class, public method
+            // see GROOVY-6962
+            owner = BytecodeHelper.getClassInternalName(receiverType);
+        }
         String desc = BytecodeHelper.getMethodDescriptor(target.getReturnType(), target.getParameters());
         mv.visitMethodInsn(opcode, owner, methodName, desc, opcode == INVOKEINTERFACE);
         ClassNode ret = target.getReturnType().redirect();
diff --git a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java
index 0cf131904a..45439bd80f 100644
--- a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java
+++ b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java
@@ -607,6 +607,11 @@ public class StaticInvocationWriter extends InvocationWriter {
                 controller.getOperandStack().replace(type);
             }
         }
+
+        @Override
+        public ClassNode getType() {
+            return controller.getTypeChooser().resolveType(receiver, controller.getClassNode());
+        }
     }
 
     public MethodCallExpression getCurrentCall() {
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy6962Bug.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy6962Bug.groovy
new file mode 100644
index 0000000000..ec25fbfecd
--- /dev/null
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy6962Bug.groovy
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2003-2014 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.codehaus.groovy.classgen.asm.sc.bugs
+
+import groovy.transform.stc.StaticTypeCheckingTestCase
+import org.codehaus.groovy.classgen.asm.sc.StaticCompilationTestSupport
+
+class Groovy6962Bug extends StaticTypeCheckingTestCase implements StaticCompilationTestSupport {
+    void testShouldNotThrowIllegalAccessException() {
+        try {
+            assertScript '''import org.codehaus.groovy.classgen.asm.sc.bugs.support.Groovy6962Ext
+        assert new Groovy6962Ext().foo() == 1
+    '''
+        } finally {
+            def bytecode = astTrees.values()[0][1]
+            assert bytecode.contains('INVOKEVIRTUAL org/codehaus/groovy/classgen/asm/sc/bugs/support/Groovy6962Ext.foo ()I')
+            println bytecode
+        }
+    }
+}
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/support/Groovy6962Base.java b/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/support/Groovy6962Base.java
new file mode 100644
index 0000000000..f376a9bb55
--- /dev/null
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/support/Groovy6962Base.java
@@ -0,0 +1,21 @@
+/*
+ * Copyright 2003-2014 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.codehaus.groovy.classgen.asm.sc.bugs.support;
+
+// package private
+class Groovy6962Base {
+    public int foo() { return 1; }
+}
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/support/Groovy6962Ext.java b/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/support/Groovy6962Ext.java
new file mode 100644
index 0000000000..3d6196f236
--- /dev/null
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/support/Groovy6962Ext.java
@@ -0,0 +1,21 @@
+/*
+ * Copyright 2003-2014 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.codehaus.groovy.classgen.asm.sc.bugs.support;
+
+public class Groovy6962Ext extends Groovy6962Base {
+
+}
