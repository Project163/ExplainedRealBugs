diff --git a/subprojects/groovy-sql/src/test/groovy/groovy/bugs/ForAndSqlBug.groovy b/src/test/groovy/bugs/Groovy5041.groovy
similarity index 54%
rename from subprojects/groovy-sql/src/test/groovy/groovy/bugs/ForAndSqlBug.groovy
rename to src/test/groovy/bugs/Groovy5041.groovy
index 8aa87bd510..5b4399ef61 100644
--- a/subprojects/groovy-sql/src/test/groovy/groovy/bugs/ForAndSqlBug.groovy
+++ b/src/test/groovy/bugs/Groovy5041.groovy
@@ -18,36 +18,26 @@
  */
 package groovy.bugs
 
-import groovy.sql.SqlHelperTestCase
-import groovy.test.GroovyTestCase
+import org.junit.Test
 
-class ForAndSqlBug extends GroovyTestCase {
+import static groovy.test.GroovyAssert.assertScript
 
-    void testBugInNormalMethod() {
-        def sql = SqlHelperTestCase.makeSql()
-        def li = ["a", "b"]
-        for (x in li) {
-            sql.eachRow("SELECT count(*) FROM FOOD") { e ->
-                println " ${x}"
-                assert x != null
+final class Groovy5041 {
+    @Test
+    void testAICParameter() {
+        assertScript '''
+            class C {
+                C(x) {}
+                abstract call()
             }
-        }
-        sql.close()
-    }
 
-    void testBugInsideScript() {
-        assertScript '''
-            import groovy.sql.SqlHelperTestCase
-            def sql = SqlHelperTestCase.makeSql()
-            def li = ["a", "b"]
-            for (x in li) {
-                sql.eachRow("SELECT count(*) FROM FOOD") { e ->
-                    println " ${x}"
-                    assert x != null
-                }
+            def x = 1
+            def c = new C(x) {
+                def call() { x }
             }
-            sql.close()
+            assert c.call() == 1
+            x = 2
+            assert c.call() == 2
         '''
     }
-
 }
diff --git a/subprojects/groovy-sql/src/test/groovy/groovy/bugs/Groovy5041Bug.groovy b/subprojects/groovy-sql/src/test/groovy/groovy/bugs/Groovy5041Bug.groovy
deleted file mode 100644
index c66f7dc64c..0000000000
--- a/subprojects/groovy-sql/src/test/groovy/groovy/bugs/Groovy5041Bug.groovy
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one
- *  or more contributor license agreements.  See the NOTICE file
- *  distributed with this work for additional information
- *  regarding copyright ownership.  The ASF licenses this file
- *  to you under the Apache License, Version 2.0 (the
- *  "License"); you may not use this file except in compliance
- *  with the License.  You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing,
- *  software distributed under the License is distributed on an
- *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- *  KIND, either express or implied.  See the License for the
- *  specific language governing permissions and limitations
- *  under the License.
- */
-package groovy.bugs
-
-import groovy.test.GroovyTestCase
-
-class Groovy5041Bug extends GroovyTestCase {
-    void testAICParameter() {
-        // GROOVY-5041
-        assertScript """
-            import java.sql.Connection
-            import groovy.sql.Sql
-
-            class GrailsPrecondition {
-
-                Connection getConnection() { database?.connection?.wrappedConnection }
-
-                Sql getSql() {
-                    if (!connection) return null
-
-                    if (!sql) {
-                        sql = new Sql(connection) {
-                            protected void closeResources(Connection c) {
-                                // do nothing, let Liquibase close the connection
-                            }
-                        }
-                    }
-
-                    sql
-                }
-            }
-            def x = new GrailsPrecondition()
-            try {
-                x.sql
-                assert false
-            } catch (MissingPropertyException mpe) {
-                assert true
-            }
-        """
-        assertScript """
-            class Foo {
-              def call(){}
-              def Foo(x){}
-            }
-
-            def x = 1
-            def caller = new Foo(x) {
-               def call(){x}
-            }
-            assert caller.call() == 1
-            x = 2
-            assert caller.call() == 2
-        """
-    }
-}
diff --git a/subprojects/groovy-sql/src/test/groovy/groovy/sql/GroovyRowResultTest.groovy b/subprojects/groovy-sql/src/test/groovy/groovy/sql/GroovyRowResultTest.groovy
index effffc4e47..6e4d56ad6c 100644
--- a/subprojects/groovy-sql/src/test/groovy/groovy/sql/GroovyRowResultTest.groovy
+++ b/subprojects/groovy-sql/src/test/groovy/groovy/sql/GroovyRowResultTest.groovy
@@ -18,72 +18,93 @@
  */
 package groovy.sql
 
-import groovy.test.GroovyTestCase
+import groovy.transform.CompileStatic
+import org.junit.Test
 
-class GroovyRowResultTest extends GroovyTestCase {
+import static groovy.test.GroovyAssert.shouldFail
 
-    void testMap() {
-        def row = createRow();
-        def row2 = createRow();
+final class GroovyRowResultTest {
 
-        /**
-         * Test for implementing Map
-         */
-        assert row instanceof Map, "BUG! GroovyRowResult doesn't implement Map!"
+    protected GroovyRowResult createRow() {
+        def map = [:]
+        map.put('miXed', 'quick')
+        map.put('nullMixed', null)
+        map.put('lower', 'brown')
+        map.put('nulllower', null)
+        map.put('UPPER', 'fox')
+        map.put('NULLUPPER', null)
+        def row = new GroovyRowResult(map)
+        assert row != null, 'failed to load GroovyRowResult class'
+        return row
+    }
+
+    @CompileStatic @Test
+    void testMapType() {
+        Map<String, Object> row = createRow() // GROOVY-9784
+    }
+
+    @Test
+    void testMapMethods() {
+        def row = createRow()
+        def row2 = createRow()
 
         /**
          * Test for put and accessing the new property
          */
-        row.put("john", "Doe")
-        assert row.john == "Doe"
-        assert row["john"] == "Doe"
+        row.put('john', 'Doe')
+        assert row.john == 'Doe'
         assert row['john'] == 'Doe'
-        assert row.containsKey("john")
-        assert row.containsKey("JOHN")
-        assert row.containsKey("John")
-        assert !row2.containsKey("john")
-        assert row.containsValue("Doe")
-        assert !row2.containsKey("Doe")
+        assert row['john'] == 'Doe'
+        assert row.containsKey('john')
+        assert row.containsKey('JOHN')
+        assert row.containsKey('John')
+        assert !row2.containsKey('john')
+        assert row.containsValue('Doe')
+        assert !row2.containsKey('Doe')
 
         /**
          * Test for equality (1) and size
          */
-        assert row != row2, "rows unexpectedly equal"
+        assert row != row2, 'rows unexpectedly equal'
         assert row.size() == 7
         assert row2.size() == 6
 
         /**
          * Test for remove, equality (2) and isEmpty (1)
          */
-        row.remove("john")
-        assert row == row2, "rows different after remove"
-        assert !row.isEmpty(), "row empty after remove"
+        row.remove('john')
+        assert row == row2, 'rows different after remove'
+        assert !row.isEmpty(), 'row empty after remove'
 
         /**
          * Test for clear, equality (3) and isEmpty (2)
          */
         row.clear()
         row2.clear()
-        assert row == row2, "rows different after clear"
-        assert row.isEmpty(), "row not empty after clear"
+        assert row == row2, 'rows different after clear'
+        assert row.isEmpty(), 'row not empty after clear'
     }
 
+    @Test
     void testProperties() {
         def row = createRow()
-        assert row.miXed == "quick"
-        assert row.mixed == "quick"
-        assert row.lower == "brown"
-        assert row.LOWER == "brown"
-        assert row.upper == "fox"
-        assert row.UPPER == "fox"
+
+        assert row.miXed == 'quick'
+        assert row.mixed == 'quick'
+        assert row.lower == 'brown'
+        assert row.LOWER == 'brown'
+        assert row.upper == 'fox'
+        assert row.UPPER == 'fox'
 
         shouldFail(MissingPropertyException) {
             row.foo
         }
+    }
+
+    @Test // GROOVY-1296
+    void testNullProperties() {
+        def row = createRow()
 
-        /**
-         * This is for GROOVY-1296
-         */
         assert row.nullMixed == null
         assert row[1] == null
         assert row.nulllower == null
@@ -98,36 +119,27 @@ class GroovyRowResultTest extends GroovyTestCase {
         assert !row.containsKey('UPPER')
     }
 
+    @Test
     void testOrder() {
         def row = createRow()
-        assert row[0] == "quick"
+
+        assert row[0] == 'quick'
         assert row[1] == null
-        assert row[2] == "brown"
+        assert row[2] == 'brown'
         assert row[3] == null
-        assert row[4] == "fox"
+        assert row[4] == 'fox'
         assert row[5] == null
         assert row[27] == null
         assert row[-1] == null
-        assert row[-2] == "fox"
-    }
-
-    protected def createRow() {
-        def map = new LinkedHashMap()
-        map.put("miXed", "quick")
-        map.put("nullMixed", null)
-        map.put("lower", "brown")
-        map.put("nulllower", null)
-        map.put("UPPER", "fox")
-        map.put("NULLUPPER", null)
-        def row = new GroovyRowResult(map)
-        assert row != null, "failed to load GroovyRowResult class"
-        return row
+        assert row[-2] == 'fox'
     }
 
+    @Test
     void testCaseInsensitivePut() {
-        def row = new GroovyRowResult(SOMEKEY: "v1")
+        def row = new GroovyRowResult(SOMEKEY: 'v1')
+
         assert row.someKEY == 'v1'
-        row.somekey = "v2"
+        row.somekey = 'v2'
         assert row.someKEY == 'v2'
         assert row.put('sOmEkEy', 'v3') == 'v2'
         assert row.someKEY == 'v3'
diff --git a/subprojects/groovy-sql/src/test/groovy/groovy/sql/SqlTest.groovy b/subprojects/groovy-sql/src/test/groovy/groovy/sql/SqlTest.groovy
index 300cfd3973..c5d9dba9f1 100644
--- a/subprojects/groovy-sql/src/test/groovy/groovy/sql/SqlTest.groovy
+++ b/subprojects/groovy-sql/src/test/groovy/groovy/sql/SqlTest.groovy
@@ -18,9 +18,11 @@
  */
 package groovy.sql
 
-import groovy.test.GroovyTestCase
+import org.junit.Before
+import org.junit.Rule
+import org.junit.Test
+import org.junit.rules.TestName
 
-import javax.sql.DataSource
 import java.sql.Connection
 
 import static groovy.sql.SqlTestConstants.DB_DATASOURCE
@@ -28,23 +30,27 @@ import static groovy.sql.SqlTestConstants.DB_DS_KEY
 import static groovy.sql.SqlTestConstants.DB_PASSWORD
 import static groovy.sql.SqlTestConstants.DB_URL_PREFIX
 import static groovy.sql.SqlTestConstants.DB_USER
+import static groovy.test.GroovyAssert.assertScript
 
 /**
  * This is more of a sample program than a unit test and is here as an easy
  * to read demo of GDO. The actual full unit test case is in SqlCompleteTest
  */
-class SqlTest extends GroovyTestCase {
+final class SqlTest {
 
-    private sql
+    private Sql sql
 
+    @Before
     void setUp() {
         sql = createSql()
     }
 
+    @Test
     void testSqlQuery() {
         sql.eachRow("select * from PERSON") { println("Hello ${it.firstname} ${it.lastname}") }
     }
 
+    @Test
     void testQueryUsingColumnIndex() {
         def answer = null
         sql.eachRow("select count(*) from PERSON") { answer = it[0] }
@@ -52,6 +58,7 @@ class SqlTest extends GroovyTestCase {
         assert answer == 3
     }
 
+    @Test
     void testQueryUsingNegativeColumnIndex() {
         def first = null
         def last = null
@@ -64,17 +71,20 @@ class SqlTest extends GroovyTestCase {
         assert last == "Strachan"
     }
 
+    @Test
     void testSqlQueryWithWhereClause() {
         def foo = "drink"
         sql.eachRow("select * from FOOD where type=${foo}") { println("Drink ${it.name}") }
     }
 
+    @Test
     void testEachRowWithWhereClauseWith2Arguments() {
         def foo = "cheese"
         def bar = "edam"
         sql.eachRow("select * from FOOD where type=${foo} and name != ${bar}") { println("Found cheese ${it.name}") }
     }
 
+    @Test
     void testFirstRowWithWhereClauseWith2Arguments() {
         def foo = "cheese"
         def bar = "edam"
@@ -82,22 +92,26 @@ class SqlTest extends GroovyTestCase {
         assert result.name == 'brie'
     }
 
+    @Test
     void testSqlQueryWithIncorrectlyQuotedDynamicExpressions() {
         def foo = "cheese"
         def bar = "edam"
         sql.eachRow("select * from FOOD where type='${foo}' and name != '${bar}'") { println("Found cheese ${it.name}") }
     }
 
+    @Test
     void testDataSet() {
         def people = sql.dataSet("PERSON")
         people.each { println("Hey ${it.firstname}") }
     }
 
+    @Test
     void testDataSetWithClosurePredicate() {
         def food = sql.dataSet("FOOD")
         food.findAll { it.type == "cheese" }.each { println("Cheese ${it.name}") }
     }
 
+    @Test
     void testExecuteUpdate() {
         def foo = 'food-drink'
         def bar = 'guinness'
@@ -107,6 +121,7 @@ class SqlTest extends GroovyTestCase {
         }
     }
 
+    @Test
     void testExecuteInsert() {
         def value = 'log entry'
         if (sql.dataSource.connection.metaData.supportsGetGeneratedKeys()) {
@@ -118,6 +133,7 @@ class SqlTest extends GroovyTestCase {
         }
     }
 
+    @Test
     void testExecuteInsertWithColumnNamesListParams() {
         def value = 'log entry'
         if (sql.dataSource.connection.metaData.supportsGetGeneratedKeys()) {
@@ -126,6 +142,7 @@ class SqlTest extends GroovyTestCase {
         }
     }
 
+    @Test
     void testExecuteInsertWithColumnNamesVarargParams() {
         def value = 'log entry'
         if (sql.dataSource.connection.metaData.supportsGetGeneratedKeys()) {
@@ -134,6 +151,7 @@ class SqlTest extends GroovyTestCase {
         }
     }
 
+    @Test
     void testExecuteInsertWithColumnNamesNoVarargs() {
         if (sql.dataSource.connection.metaData.supportsGetGeneratedKeys()) {
             def keys = sql.executeInsert("insert into LOG (value) values 'log entry'", ['ID'] as String[])
@@ -141,6 +159,7 @@ class SqlTest extends GroovyTestCase {
         }
     }
 
+    @Test
     void testExecuteInsertWithColumnNamesGString() {
         def value = 'log entry'
         if (sql.dataSource.connection.metaData.supportsGetGeneratedKeys()) {
@@ -152,6 +171,7 @@ class SqlTest extends GroovyTestCase {
         }
     }
 
+    @Test
     void testExecuteWithProcessResultsClosure() {
         sql.execute("insert into LOG (value) values ('log entry')") {
             isResultSet, result ->
@@ -159,6 +179,7 @@ class SqlTest extends GroovyTestCase {
         }
     }
 
+    @Test
     void testMetaData() {
         sql.eachRow('select * from PERSON') {
             assert it[0] != null
@@ -166,6 +187,7 @@ class SqlTest extends GroovyTestCase {
         }
     }
 
+    @Test
     void testSubClass() {
         def sub = new SqlSubclass(sql)
         def res = null
@@ -192,6 +214,7 @@ class SqlTest extends GroovyTestCase {
         assert data.size() == 2 && !(data - ['firstname', 'lastname'])
     }
 
+    @Test
     void testCallMethodFromObjectOnGroovyResultSet() {
         sql.eachRow('select * from PERSON') {
             println it.toString()
@@ -199,30 +222,62 @@ class SqlTest extends GroovyTestCase {
         }
     }
 
-    private createSql() {
-        DataSource ds = DB_DATASOURCE.newInstance(
-                (DB_DS_KEY): DB_URL_PREFIX + getMethodName(),
-                user: DB_USER,
-                password: DB_PASSWORD)
+    @Test // GROOVY-168
+    void testBugInNormalMethod() {
+        def li = ['a', 'b']
+        for (x in li) {
+            sql.eachRow('SELECT count(*) FROM FOOD') { e ->
+                println " ${x}"
+                assert x != null
+            }
+        }
+        sql.close()
+    }
+
+    @Test // GROOVY-168
+    void testBugInsideScript() {
+        assertScript '''
+            import groovy.sql.SqlHelperTestCase
+            def sql = SqlHelperTestCase.makeSql()
+            def li = ["a", "b"]
+            for (x in li) {
+                sql.eachRow("SELECT count(*) FROM FOOD") { e ->
+                    println " ${x}"
+                    assert x != null
+                }
+            }
+            sql.close()
+        '''
+    }
+
+    //--------------------------------------------------------------------------
+
+    @Rule
+    public final TestName test = new TestName()
+
+    private Sql createSql() {
+        javax.sql.DataSource ds = DB_DATASOURCE.newInstance(
+                (DB_DS_KEY): DB_URL_PREFIX + test.methodName,
+                user: DB_USER, password: DB_PASSWORD)
         sql = new Sql(ds.connection)
         def sql = new Sql(ds)
 
-        sql.execute("create table PERSON ( firstname VARCHAR(10), lastname VARCHAR(10) )")
-        sql.execute("create table FOOD ( type VARCHAR(10), name VARCHAR(10))")
-        sql.execute("create table LOG ( value VARCHAR(20), ID INTEGER IDENTITY)")
+        sql.execute('create table PERSON ( firstname VARCHAR(10), lastname VARCHAR(10) )')
+        sql.execute('create table FOOD ( type VARCHAR(10), name VARCHAR(10))')
+        sql.execute('create table LOG ( value VARCHAR(20), ID INTEGER IDENTITY)')
 
         // now let's populate the datasets
-        def people = sql.dataSet("PERSON")
-        people.add(firstname: "James", lastname: "Strachan")
-        people.add(firstname: "Bob", lastname: "Mcwhirter")
-        people.add(firstname: "Sam", lastname: "Pullara")
-
-        def food = sql.dataSet("FOOD")
-        food.add(type: "cheese", name: "edam")
-        food.add(type: "cheese", name: "brie")
-        food.add(type: "cheese", name: "cheddar")
-        food.add(type: "drink", name: "beer")
-        food.add(type: "drink", name: "coffee")
+        def people = sql.dataSet('PERSON')
+        people.add(firstname: 'James', lastname: 'Strachan')
+        people.add(firstname: 'Bob', lastname: 'Mcwhirter')
+        people.add(firstname: 'Sam', lastname: 'Pullara')
+
+        def food = sql.dataSet('FOOD')
+        food.add(type: 'cheese', name: 'edam')
+        food.add(type: 'cheese', name: 'brie')
+        food.add(type: 'cheese', name: 'cheddar')
+        food.add(type: 'drink', name: 'beer')
+        food.add(type: 'drink', name: 'coffee')
 
         return sql
     }
