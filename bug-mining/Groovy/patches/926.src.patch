diff --git a/src/main/groovy/lang/GroovyClassLoader.java b/src/main/groovy/lang/GroovyClassLoader.java
index 2258020393..aeebde63c9 100644
--- a/src/main/groovy/lang/GroovyClassLoader.java
+++ b/src/main/groovy/lang/GroovyClassLoader.java
@@ -32,10 +32,7 @@ import org.objectweb.asm.ClassWriter;
 
 import java.io.*;
 import java.net.*;
-import java.security.AccessController;
-import java.security.CodeSource;
-import java.security.PrivilegedAction;
-import java.security.ProtectionDomain;
+import java.security.*;
 import java.util.*;
 
 /**
@@ -327,6 +324,28 @@ public class GroovyClassLoader extends URLClassLoader {
         throw new DeprecationException("the method groovy.lang.GroovyClassLoader#defineClass(String,byte[],ProtectionDomain) is no longer used internally and removed");
     }
 
+    protected PermissionCollection getPermissions(CodeSource codeSource) {
+        PermissionCollection perms;
+        try {
+            perms = super.getPermissions(codeSource);
+        } catch (SecurityException e) {
+            // We lied about our CodeSource and that makes URLClassLoader unhappy.
+            perms = new Permissions();
+        }
+
+        ProtectionDomain myDomain = AccessController.doPrivileged(new PrivilegedAction<ProtectionDomain>() {
+            public ProtectionDomain run() {
+                return getClass().getProtectionDomain();
+            }
+        });
+        PermissionCollection myPerms = myDomain.getPermissions();
+        for (Enumeration<Permission> elements = myPerms.elements(); elements.hasMoreElements();) {
+            perms.add(elements.nextElement());
+        }
+        perms.setReadOnly();
+        return perms;
+    }
+
     public static class InnerLoader extends GroovyClassLoader {
         private final GroovyClassLoader delegate;
         private final long timeStamp;
@@ -621,16 +640,6 @@ public class GroovyClassLoader extends URLClassLoader {
         boolean recompile = isRecompilable(cls);
         if (!recompile) return cls;
 
-        // check security manager
-        SecurityManager sm = System.getSecurityManager();
-        if (sm != null) {
-            String className = name.replace('/', '.');
-            int i = className.lastIndexOf('.');
-            if (i != -1) {
-                sm.checkPackageAccess(className.substring(0, i));
-            }
-        }
-
         // try parent loader
         ClassNotFoundException last = null;
         try {
@@ -647,6 +656,19 @@ public class GroovyClassLoader extends URLClassLoader {
             }
         }
         
+        // check security manager
+        SecurityManager sm = System.getSecurityManager();
+        if (sm != null) {
+            String className = name.replace('/', '.');
+            int i = className.lastIndexOf('.');
+            // no checks on the sun.reflect classes for reflection speed-up
+            // in particular ConstructorAccessorImpl, MethodAccessorImpl, FieldAccessorImpl and SerializationConstructorAccessorImpl
+            // which are generated at runtime by the JDK
+            if (i != -1 && !className.startsWith("sun.reflect.")) {
+                sm.checkPackageAccess(className.substring(0, i));
+            }
+        }
+
         // prefer class if no recompilation
         if (cls != null && preferClassOverScript) return cls;
 
diff --git a/src/main/groovy/lang/MetaClassImpl.java b/src/main/groovy/lang/MetaClassImpl.java
index 6471fecf8e..b1f9d61d0f 100644
--- a/src/main/groovy/lang/MetaClassImpl.java
+++ b/src/main/groovy/lang/MetaClassImpl.java
@@ -2217,18 +2217,23 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
             // get the getter method
             Method method = pd.getReadMethod();
             MetaMethod getter;
-            if (method != null)
-                getter = findMethod(CachedMethod.find(method));
-            else
+
+            if (method != null) {
+                CachedMethod cachedGetter = CachedMethod.find(method);
+                getter = cachedGetter == null ? null : findMethod(cachedGetter);
+            } else {
                 getter = null;
+            }
 
             // get the setter method
             MetaMethod setter;
             method = pd.getWriteMethod();
-            if (method != null)
-                setter = findMethod(CachedMethod.find(method));
-            else
+            if (method != null) {
+                CachedMethod cachedSetter = CachedMethod.find(method);
+                setter = cachedSetter == null ? null : findMethod(cachedSetter);
+            } else {
                 setter = null;
+            }
 
             // now create the MetaProperty object
             MetaBeanProperty mp = new MetaBeanProperty(pd.getName(), pd.getPropertyType(), getter, setter);
diff --git a/src/main/org/codehaus/groovy/reflection/CachedClass.java b/src/main/org/codehaus/groovy/reflection/CachedClass.java
index 65ed0f05a8..1c57543175 100644
--- a/src/main/org/codehaus/groovy/reflection/CachedClass.java
+++ b/src/main/org/codehaus/groovy/reflection/CachedClass.java
@@ -45,7 +45,11 @@ public class CachedClass {
                AccessController.doPrivileged(new PrivilegedAction/*<Field[]>*/() {
                    public /*Field[]*/ Object run() {
                        final Field[] df = getTheClass().getDeclaredFields();
-                       AccessibleObject.setAccessible(df, true);
+                       try {
+                           AccessibleObject.setAccessible(df, true);
+                       } catch (SecurityException e) {
+                           // swallow for strict security managers
+                       }
                        return df;                                                   
                    }
                });
@@ -77,7 +81,11 @@ public class CachedClass {
                AccessController.doPrivileged(new PrivilegedAction/*<Method[]>*/() {
                    public /*Method[]*/ Object run() {
                        final Method[] dm = getTheClass().getDeclaredMethods();
-                       AccessibleObject.setAccessible(dm, true);
+                       try {
+                           AccessibleObject.setAccessible(dm, true);
+                       } catch (SecurityException e) {
+                           // swallow for strict security managers
+                       }
                        return dm;
                    }
                });
diff --git a/src/main/org/codehaus/groovy/reflection/CachedConstructor.java b/src/main/org/codehaus/groovy/reflection/CachedConstructor.java
index 0723716541..f934656821 100644
--- a/src/main/org/codehaus/groovy/reflection/CachedConstructor.java
+++ b/src/main/org/codehaus/groovy/reflection/CachedConstructor.java
@@ -21,6 +21,8 @@ import org.codehaus.groovy.runtime.InvokerInvocationException;
 
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
 
 /**
  * @author Alex.Tkachman
@@ -30,11 +32,16 @@ public class CachedConstructor extends ParameterTypes {
 
     public final Constructor cachedConstructor;
 
-    public CachedConstructor(CachedClass clazz, Constructor c) {
+    public CachedConstructor(CachedClass clazz, final Constructor c) {
         this.cachedConstructor = c;
         this.clazz = clazz;
         try {
-            c.setAccessible(true);
+            AccessController.doPrivileged(new PrivilegedAction() {
+                public Object run() {
+                    c.setAccessible(true);
+                    return null;
+                }
+            });
         }
         catch (SecurityException e) {
             // IGNORE
