diff --git a/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java b/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
index 4c1c4ae8d2..f500b141a5 100644
--- a/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
+++ b/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
@@ -1219,7 +1219,7 @@ public class AsmClassGenerator extends ClassGenerator {
 
             mv.visitMethodInsn(INVOKESPECIAL, "org/codehaus/groovy/runtime/ScriptReference", "<init>", "(Lgroovy/lang/Script;Ljava/lang/String;)V", false);
         } else {
-            PropertyExpression pexp = new PropertyExpression(VariableExpression.THIS_EXPRESSION, name);
+            PropertyExpression pexp = new PropertyExpression(new VariableExpression("this"), name);
             pexp.setImplicitThis(true);
             visitPropertyExpression(pexp);
         }
diff --git a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
index 2b9e9f1bb0..4e69759a24 100644
--- a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
+++ b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
@@ -77,16 +77,7 @@ public class StaticTypesCallSiteWriter extends CallSiteWriter implements Opcodes
     public void makeGetPropertySite(Expression receiver, final String methodName, final boolean safe, final boolean implicitThis) {
         Object dynamic = receiver.getNodeMetaData(StaticCompilationMetadataKeys.RECEIVER_OF_DYNAMIC_PROPERTY);
         if (dynamic !=null) {
-            MethodNode target = safe?INVOKERHELPER_GETPROPERTYSAFE_METHOD:INVOKERHELPER_GETPROPERTY_METHOD;
-            MethodCallExpression mce = new MethodCallExpression(
-                    new ClassExpression(INVOKERHELPER_TYPE),
-                    target.getName(),
-                    new ArgumentListExpression(receiver, new ConstantExpression(methodName))
-            );
-            mce.setSafe(false);
-            mce.setImplicitThis(false);
-            mce.setMethodTarget(target);
-            mce.visit(controller.getAcg());
+            makeDynamicGetProperty(receiver, methodName, safe);
             return;
         }
         TypeChooser typeChooser = controller.getTypeChooser();
@@ -235,6 +226,19 @@ public class StaticTypesCallSiteWriter extends CallSiteWriter implements Opcodes
         controller.getOperandStack().push(OBJECT_TYPE);
     }
 
+    private void makeDynamicGetProperty(final Expression receiver, final String methodName, final boolean safe) {
+        MethodNode target = safe?INVOKERHELPER_GETPROPERTYSAFE_METHOD:INVOKERHELPER_GETPROPERTY_METHOD;
+        MethodCallExpression mce = new MethodCallExpression(
+                new ClassExpression(INVOKERHELPER_TYPE),
+                target.getName(),
+                new ArgumentListExpression(receiver, new ConstantExpression(methodName))
+        );
+        mce.setSafe(false);
+        mce.setImplicitThis(false);
+        mce.setMethodTarget(target);
+        mce.visit(controller.getAcg());
+    }
+
     private void writeMapDotProperty(final Expression receiver, final String methodName, final MethodVisitor mv, final boolean safe) {
         receiver.visit(controller.getAcg()); // load receiver
 
@@ -346,6 +350,16 @@ public class StaticTypesCallSiteWriter extends CallSiteWriter implements Opcodes
     @SuppressWarnings("unchecked")
     private boolean makeGetPrivateFieldWithBridgeMethod(final Expression receiver, final ClassNode receiverType, final String fieldName, final boolean safe, final boolean implicitThis) {
         FieldNode field = receiverType.getField(fieldName);
+        ClassNode outerClass = receiverType.getOuterClass();
+        if (field==null && implicitThis && outerClass !=null && !receiverType.isStaticClass()) {
+            PropertyExpression pexp = new PropertyExpression(
+                    new ClassExpression(outerClass),
+                    "this"
+            );
+            pexp.setImplicitThis(true);
+            pexp.setSourcePosition(receiver);
+            return makeGetPrivateFieldWithBridgeMethod(pexp, outerClass, fieldName, safe, true);
+        }
         ClassNode classNode = controller.getClassNode();
         if (field!=null && Modifier.isPrivate(field.getModifiers())
                 && (StaticInvocationWriter.isPrivateBridgeMethodsCallAllowed(receiverType, classNode) || StaticInvocationWriter.isPrivateBridgeMethodsCallAllowed(classNode,receiverType))
@@ -402,8 +416,8 @@ public class StaticTypesCallSiteWriter extends CallSiteWriter implements Opcodes
             }
         }
 
-
         if (makeGetPropertyWithGetter(receiver, receiverType, property, safe, implicitThis)) return;
+        if (makeGetPrivateFieldWithBridgeMethod(receiver, receiverType, property, safe, true)) return;
         if (makeGetField(receiver, receiverType, property, safe, implicitThis, samePackages(receiverType.getPackageName(), classNode.getPackageName()))) return;
 
         MethodCallExpression call = new MethodCallExpression(
diff --git a/src/main/org/codehaus/groovy/transform/sc/transformers/VariableExpressionTransformer.java b/src/main/org/codehaus/groovy/transform/sc/transformers/VariableExpressionTransformer.java
index 21b4da851e..c465cba935 100644
--- a/src/main/org/codehaus/groovy/transform/sc/transformers/VariableExpressionTransformer.java
+++ b/src/main/org/codehaus/groovy/transform/sc/transformers/VariableExpressionTransformer.java
@@ -16,37 +16,68 @@
 package org.codehaus.groovy.transform.sc.transformers;
 
 import org.codehaus.groovy.ast.ClassNode;
+import org.codehaus.groovy.ast.FieldNode;
 import org.codehaus.groovy.ast.expr.Expression;
 import org.codehaus.groovy.ast.expr.PropertyExpression;
 import org.codehaus.groovy.ast.expr.VariableExpression;
 import org.codehaus.groovy.transform.sc.StaticCompilationMetadataKeys;
-import org.codehaus.groovy.transform.sc.StaticCompilationVisitor;
-import org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor;
 import org.codehaus.groovy.transform.stc.StaticTypesMarker;
 
 /**
  * Transformer for VariableExpression the bytecode backend wouldn't be able to
- * handle otherwise. 
+ * handle otherwise.
  * @author <a href="mailto:blackdrag@gmx.org">Jochen "blackdrag" Theodorou</a>
  */
 public class VariableExpressionTransformer {
 
     public Expression transformVariableExpression(VariableExpression expr) {
+        Expression trn = tryTransformPrivateFieldAccess(expr);
+        if (trn != null) {
+            return trn;
+        }
+        trn = tryTransformDelegateToProperty(expr);
+        if (trn != null) {
+            return trn;
+        }
+        return expr;
+    }
+
+    private Expression tryTransformDelegateToProperty(VariableExpression expr) {
         // we need to transform variable expressions that go to a delegate
         // to a property expression, as ACG would loose the information
         // in processClassVariable before it reaches any makeCall, that could
         // handle it
         Object val = expr.getNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER);
-        if (val==null) return expr;
+        if (val == null) return null;
         VariableExpression implicitThis = new VariableExpression("this");
         PropertyExpression pexp = new PropertyExpression(implicitThis, expr.getName());
         pexp.copyNodeMetaData(expr);
         pexp.setImplicitThis(true);
         ClassNode owner = expr.getNodeMetaData(StaticCompilationMetadataKeys.PROPERTY_OWNER);
-        if (owner!=null) {
+        if (owner != null) {
             implicitThis.putNodeMetaData(StaticTypesMarker.INFERRED_TYPE, owner);
             implicitThis.putNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER, val);
         }
         return pexp;
     }
+
+    private Expression tryTransformPrivateFieldAccess(VariableExpression expr) {
+        FieldNode field = expr.getNodeMetaData(StaticTypesMarker.PV_FIELDS_ACCESS);
+        if (field != null) {
+            // access to a private field from a section of code that normally doesn't have access to it, like a
+            // closure or an inner class
+            VariableExpression receiver = new VariableExpression("this");
+            PropertyExpression pexp = new PropertyExpression(
+                    receiver,
+                    expr.getName()
+            );
+            pexp.setImplicitThis(true);
+            // put the receiver inferred type so that the class writer knows that it will have to call a bridge method
+            receiver.putNodeMetaData(StaticTypesMarker.INFERRED_TYPE, field.getDeclaringClass());
+            // add inferred type information
+            pexp.putNodeMetaData(StaticTypesMarker.INFERRED_TYPE, field.getOriginType());
+            return pexp;
+        }
+        return null;
+    }
 }
diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index d4793fae80..8a0175148d 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -325,30 +325,31 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
     }
 
     @SuppressWarnings("unchecked")
-    private void addPrivateFieldOrMethodAccess(ClassNode cn, StaticTypesMarker type, ASTNode accessedMember) {
+    private void addPrivateFieldOrMethodAccess(Expression source, ClassNode cn, StaticTypesMarker type, ASTNode accessedMember) {
         Set<ASTNode> set = (Set<ASTNode>) cn.getNodeMetaData(type);
         if (set==null) {
             set = new LinkedHashSet<ASTNode>();
             cn.putNodeMetaData(type, set);
         }
         set.add(accessedMember);
+        source.putNodeMetaData(type, accessedMember);
     }
 
     /**
      * Given a field node, checks if we are calling a private field from an inner class.
      */
-    private void checkOrMarkPrivateAccess(FieldNode fn) {
+    private void checkOrMarkPrivateAccess(Expression source, FieldNode fn) {
         if (fn!=null && Modifier.isPrivate(fn.getModifiers()) &&
             (fn.getDeclaringClass() != typeCheckingContext.getEnclosingClassNode() || typeCheckingContext.getEnclosingClosure()!=null) &&
             fn.getDeclaringClass().getModule() == typeCheckingContext.getEnclosingClassNode().getModule()) {
-            addPrivateFieldOrMethodAccess(fn.getDeclaringClass(), StaticTypesMarker.PV_FIELDS_ACCESS, fn);
+            addPrivateFieldOrMethodAccess(source, fn.getDeclaringClass(), StaticTypesMarker.PV_FIELDS_ACCESS, fn);
         }
     }
 
     /**
      * Given a method node, checks if we are calling a private method from an inner class.
      */
-    private void checkOrMarkPrivateAccess(MethodNode mn) {
+    private void checkOrMarkPrivateAccess(Expression source, MethodNode mn) {
         if (mn==null) {
             return;
         }
@@ -363,7 +364,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             }
             if ((Modifier.isPrivate(mods) && sameModule)
                     || (Modifier.isProtected(mods) && !packageName.equals(enclosingClassNode.getPackageName()))) {
-                addPrivateFieldOrMethodAccess(sameModule? declaringClass : enclosingClassNode, StaticTypesMarker.PV_METHODS_ACCESS, mn);
+                addPrivateFieldOrMethodAccess(source, sameModule? declaringClass : enclosingClassNode, StaticTypesMarker.PV_METHODS_ACCESS, mn);
             }
         }
     }
@@ -1433,7 +1434,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         if (field==null || !returnTrueIfFieldExists) return false;
         if (visitor != null) visitor.visitField(field);
         storeWithResolve(field.getOriginType(), receiver, field.getDeclaringClass(), field.isStatic(), expressionToStoreOn);
-        checkOrMarkPrivateAccess(field);
+        checkOrMarkPrivateAccess(expressionToStoreOn, field);
         if (delegationData!=null) {
             expressionToStoreOn.putNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER, delegationData);
         }
@@ -3077,7 +3078,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
     protected void storeTargetMethod(final Expression call, final MethodNode directMethodCallCandidate) {
         call.putNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET, directMethodCallCandidate);
-        checkOrMarkPrivateAccess(directMethodCallCandidate);
+        checkOrMarkPrivateAccess(call, directMethodCallCandidate);
         checkSuperCallFromClosure(call, directMethodCallCandidate);
         extension.onMethodSelection(call, directMethodCallCandidate);
     }
@@ -3862,7 +3863,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             if (selfTrait!=null) return makeSelf(selfTrait);
             final Variable variable = vexp.getAccessedVariable();
             if (variable instanceof FieldNode) {
-                checkOrMarkPrivateAccess((FieldNode) variable);
+                checkOrMarkPrivateAccess(vexp, (FieldNode) variable);
                 return getType((FieldNode) variable);
             }
             if (variable != null && variable != vexp && variable instanceof VariableExpression) {
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7276Bug.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7276Bug.groovy
new file mode 100644
index 0000000000..f0337aacf1
--- /dev/null
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7276Bug.groovy
@@ -0,0 +1,92 @@
+/*
+ * Copyright 2003-2015 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+
+
+
+package org.codehaus.groovy.classgen.asm.sc.bugs
+
+import groovy.transform.NotYetImplemented
+import groovy.transform.stc.StaticTypeCheckingTestCase
+import org.codehaus.groovy.classgen.asm.sc.StaticCompilationTestSupport
+
+class Groovy7276Bug extends StaticTypeCheckingTestCase implements StaticCompilationTestSupport {
+    void testShouldGoThroughPrivateBridgeAccessor() {
+            assertScript '''
+                class Foo {
+                    private i = 1
+                    def m() { new String().with {i}}
+                }
+                assert new Foo().m() == 1
+                class Bar extends Foo {}
+                assert new Bar().m() == 1
+        '''
+    }
+
+    void testShouldGoThroughPrivateBridgeMethod() {
+            assertScript '''
+                class Foo {
+                    private i = 1
+                    private def pvI() { i }
+                    def m() { new String().with {pvI()}}
+                }
+                assert new Foo().m() == 1
+                class Bar extends Foo {}
+                assert new Bar().m() == 1
+        '''
+    }
+
+    void testPrivateAccessInInnerClass() {
+        assertScript '''import groovy.transform.CompileStatic
+
+class Outer {
+    private static class Inner {
+
+        private Set<String> variablesToCheck = []
+
+        private void checkAssertions(String name) {
+            Runnable r = {
+                def candidates = variablesToCheck.findAll { it == name }
+            }
+            r.run()
+        }
+    }
+
+    static void test() {
+        new Inner().checkAssertions('name')
+    }
+}
+
+Outer.test()'''
+    }
+
+    @NotYetImplemented
+    // GROOVY-7304
+    void testShouldGoThroughPrivateBridgeAccessorWithWriteAccess() {
+            assertScript '''
+                class Foo {
+                    private int i = 1
+                    def m() { new String().with {++i}}
+                }
+                assert new Foo().m() == 2
+                class Bar extends Foo {}
+                assert new Bar().m() == 2
+        '''
+    }
+
+
+}
