diff --git a/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java b/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
index 51dde2d4a3..ec22ff2e5c 100644
--- a/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
+++ b/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
@@ -1747,7 +1747,7 @@ public class AsmClassGenerator extends ClassGenerator {
             if (!compileStack.containsVariable(name) && compileStack.getScope().isReferencedClassVariable(name)) {
                 visitFieldExpression(new FieldExpression(classNode.getDeclaredField(name)));
             } else {
-                Variable v = compileStack.getVariable(name, classNode.getSuperClass() != ClassHelper.CLOSURE_TYPE);
+                Variable v = compileStack.getVariable(name, !classNodeUsesReferences());
                 if (v == null) {
                     // variable is not on stack because we are
                     // inside a nested Closure and this variable
@@ -1780,7 +1780,17 @@ public class AsmClassGenerator extends ClassGenerator {
                 BytecodeHelper.getMethodDescriptor(ClassHelper.VOID_TYPE, localVariableParams));
     }
 
-    /**
+    private boolean classNodeUsesReferences() {
+		boolean ret = classNode.getSuperClass() == ClassHelper.CLOSURE_TYPE;
+		if (ret) return ret;
+		if (classNode instanceof InnerClassNode) {
+			InnerClassNode inner = (InnerClassNode) classNode;
+			return inner.isAnonymous();
+		}
+		return false;
+	}
+
+	/**
      * Loads either this object or if we're inside a closure then load the top level owner
      */
     protected void loadThisOrOwner() {
diff --git a/src/main/org/codehaus/groovy/classgen/VariableScopeVisitor.java b/src/main/org/codehaus/groovy/classgen/VariableScopeVisitor.java
index 9ec6447d96..5354a2a923 100644
--- a/src/main/org/codehaus/groovy/classgen/VariableScopeVisitor.java
+++ b/src/main/org/codehaus/groovy/classgen/VariableScopeVisitor.java
@@ -405,6 +405,13 @@ public class VariableScopeVisitor extends ClassCodeVisitorSupport {
     // ------------------------------
 
     public void visitClass(ClassNode node) {
+    	// AIC are already done, doing them here again will lead
+    	// to wrong scopes
+    	if (node instanceof InnerClassNode) {
+    		InnerClassNode in = (InnerClassNode) node;
+    		if (in.isAnonymous()) return;
+    	}
+    	
         pushState();
 
         currentClass = node;
