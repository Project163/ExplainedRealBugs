diff --git a/src/main/org/codehaus/groovy/control/ResolveVisitor.java b/src/main/org/codehaus/groovy/control/ResolveVisitor.java
index 63e9820ae4..4cac786713 100644
--- a/src/main/org/codehaus/groovy/control/ResolveVisitor.java
+++ b/src/main/org/codehaus/groovy/control/ResolveVisitor.java
@@ -818,7 +818,7 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
                 addError("The usage of 'Class.this' and 'Class.super' is only allowed in nested/inner classes.", expression);
                 return;
             }
-            if (!currentScope.isInStaticContext() && Traits.isTrait(type) && "super".equals(prop) && directlyImplementsTrait(type)) {
+            if (currentScope!=null && !currentScope.isInStaticContext() && Traits.isTrait(type) && "super".equals(prop) && directlyImplementsTrait(type)) {
                 return;
             }
             ClassNode iterType = currentClass;
diff --git a/src/test/groovy/bugs/Groovy6841Bug.groovy b/src/test/groovy/bugs/Groovy6841Bug.groovy
new file mode 100644
index 0000000000..8bfec441cc
--- /dev/null
+++ b/src/test/groovy/bugs/Groovy6841Bug.groovy
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2003-2014 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package groovy.bugs
+
+class Groovy6841Bug extends GroovyTestCase {
+    void testShouldNotThrowNPEduringCompilation() {
+        assertScript '''
+@groovy.transform.InheritConstructors
+class Tuple<E> extends ArrayList<E> {
+
+   public ListIterator<E> listIterator(final int index) {
+        return new ListIterator<E>() {
+            private final ListIterator<? extends E> i = Tuple.super.listIterator(index)
+
+            public boolean hasNext()     {return i.hasNext();}
+            public E next()              {return i.next();}
+            public boolean hasPrevious() {return i.hasPrevious();}
+            public E previous()          {return i.previous();}
+            public int nextIndex()       {return i.nextIndex();}
+            public int previousIndex()   {return i.previousIndex();}
+
+            public void remove() {
+                throw new UnsupportedOperationException();
+            }
+            public void set(E e) {
+                throw new UnsupportedOperationException();
+            }
+            public void add(E e) {
+                throw new UnsupportedOperationException();
+            }
+        };
+    }
+}
+Tuple
+'''
+    }
+}
