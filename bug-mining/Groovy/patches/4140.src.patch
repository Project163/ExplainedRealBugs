diff --git a/src/main/java/org/codehaus/groovy/transform/DelegateASTTransformation.java b/src/main/java/org/codehaus/groovy/transform/DelegateASTTransformation.java
index 82b3dcbb7f..f6e79e59ad 100644
--- a/src/main/java/org/codehaus/groovy/transform/DelegateASTTransformation.java
+++ b/src/main/java/org/codehaus/groovy/transform/DelegateASTTransformation.java
@@ -41,13 +41,19 @@ import org.codehaus.groovy.control.SourceUnit;
 
 import java.lang.reflect.Modifier;
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.HashSet;
 import java.util.List;
+import java.util.ListIterator;
 import java.util.Map;
 import java.util.Set;
 
+import static java.util.stream.Collectors.toSet;
 import static org.apache.groovy.ast.tools.ClassNodeUtils.addGeneratedMethod;
 import static org.apache.groovy.util.BeanUtils.capitalize;
+import static org.codehaus.groovy.ast.ClassHelper.isGroovyObjectType;
+import static org.codehaus.groovy.ast.ClassHelper.isObjectType;
+import static org.codehaus.groovy.ast.ClassHelper.isPrimitiveBoolean;
 import static org.codehaus.groovy.ast.ClassHelper.make;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.assignS;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.callThisX;
@@ -67,9 +73,7 @@ import static org.codehaus.groovy.ast.tools.GenericsUtils.correctToGenericsSpec;
 import static org.codehaus.groovy.ast.tools.GenericsUtils.correctToGenericsSpecRecurse;
 import static org.codehaus.groovy.ast.tools.GenericsUtils.createGenericsSpec;
 import static org.codehaus.groovy.ast.tools.GenericsUtils.extractSuperClassGenerics;
-import static org.codehaus.groovy.ast.ClassHelper.isGroovyObjectType;
-import static org.codehaus.groovy.ast.ClassHelper.isObjectType;
-import static org.codehaus.groovy.ast.ClassHelper.isPrimitiveBoolean;
+import static org.codehaus.groovy.ast.tools.ParameterUtils.parametersEqual;
 import static org.objectweb.asm.Opcodes.ACC_ABSTRACT;
 import static org.objectweb.asm.Opcodes.ACC_FINAL;
 import static org.objectweb.asm.Opcodes.ACC_NATIVE;
@@ -148,26 +152,24 @@ public class DelegateASTTransformation extends AbstractASTTransformation {
                         ". Delegation to own type not supported. Please use a different type.", parent);
                 return;
             }
-            final List<MethodNode> delegateMethods = getAllMethods(delegate.type);
-            for (ClassNode next : delegate.type.getAllInterfaces()) {
-                delegateMethods.addAll(getAllMethods(next));
-            }
 
-            final boolean skipInterfaces = memberHasValue(node, MEMBER_INTERFACES, false);
-            final boolean includeDeprecated = memberHasValue(node, MEMBER_DEPRECATED, true) || (delegate.type.isInterface() && !skipInterfaces);
-            final boolean allNames = memberHasValue(node, MEMBER_ALL_NAMES, true);
+            final boolean skipInterfaces = memberHasValue(node, MEMBER_INTERFACES, Boolean.FALSE);
+            final boolean includeDeprecated = memberHasValue(node, MEMBER_DEPRECATED, Boolean.TRUE) || (delegate.type.isInterface() && !skipInterfaces);
+            final boolean allNames = memberHasValue(node, MEMBER_ALL_NAMES, Boolean.TRUE);
             delegate.excludes = getMemberStringList(node, MEMBER_EXCLUDES);
             delegate.includes = getMemberStringList(node, MEMBER_INCLUDES);
             delegate.excludeTypes = getMemberClassList(node, MEMBER_EXCLUDE_TYPES);
             delegate.includeTypes = getMemberClassList(node, MEMBER_INCLUDE_TYPES);
             checkIncludeExcludeUndefinedAware(node, delegate.excludes, delegate.includes,
                                               delegate.excludeTypes, delegate.includeTypes, MY_TYPE_NAME);
-            if (!checkPropertyOrMethodList(delegate.type, delegate.includes, "includes", node, MY_TYPE_NAME)) return;
             if (!checkPropertyOrMethodList(delegate.type, delegate.excludes, "excludes", node, MY_TYPE_NAME)) return;
+            if (!checkPropertyOrMethodList(delegate.type, delegate.includes, "includes", node, MY_TYPE_NAME)) return;
+
+            final Iterable<MethodNode> ownerMethods = getAllMethods(delegate.owner);
+            final Iterable<MethodNode> delegateMethods = filterMethods(collectMethods(delegate.type), delegate, allNames, includeDeprecated);
 
-            final List<MethodNode> ownerMethods = getAllMethods(delegate.owner);
             for (MethodNode mn : delegateMethods) {
-                addDelegateMethod(delegate, ownerMethods, mn, includeDeprecated, allNames);
+                addDelegateMethod(mn, delegate, ownerMethods);
             }
 
             for (PropertyNode prop : getAllProperties(delegate.type)) {
@@ -177,15 +179,19 @@ public class DelegateASTTransformation extends AbstractASTTransformation {
                 addGetterIfNeeded(delegate, prop, name, allNames);
                 addSetterIfNeeded(delegate, prop, name, allNames);
             }
+
             if (delegate.type.isArray()) {
                 boolean skipLength = delegate.excludes != null && (delegate.excludes.contains("length") || delegate.excludes.contains("getLength"));
                 if (!skipLength) {
-                    addGeneratedMethod(delegate.owner, "getLength",
+                    addGeneratedMethod(
+                            delegate.owner,
+                            "getLength",
                             ACC_PUBLIC,
                             ClassHelper.int_TYPE,
                             Parameter.EMPTY_ARRAY,
                             null,
-                            returnS(propX(delegate.getOp, "length")));
+                            returnS(propX(delegate.getOp, "length"))
+                    );
                 }
             }
 
@@ -211,6 +217,69 @@ public class DelegateASTTransformation extends AbstractASTTransformation {
         }
     }
 
+    private static Collection<MethodNode> collectMethods(final ClassNode type) {
+        List<MethodNode> methods = new java.util.LinkedList<>(getAllMethods(type));
+        // GROOVY-4320, GROOVY-4516
+        for (ListIterator<MethodNode> it = methods.listIterator(); it.hasNext();) {
+            MethodNode next = it.next();
+            if (next.isPublic() && !next.isAbstract() && next.hasDefaultValue()) {
+                int n = 0;
+                for (Parameter p : next.getParameters())
+                    if (p.hasInitialExpression()) n += 1;
+                for (int i = 1; i <= n; i += 1) { // from Verifier#addDefaultParameters
+                    Parameter[] params = new Parameter[next.getParameters().length - i];
+                    int index = 0, j = 1;
+                    for (Parameter parameter : next.getParameters()) {
+                        if (j > n - i && parameter.hasInitialExpression()) {
+                            j += 1;
+                        } else {
+                            params[index++] = parameter;
+                            if (parameter.hasInitialExpression()) j += 1;
+                        }
+                    }
+
+                    if (methods.stream().noneMatch(mn -> mn.getName().equals(next.getName()) && parametersEqual(mn.getParameters(), params))) {
+                        MethodNode mn = new MethodNode(next.getName(), next.getModifiers(), next.getReturnType(), params, next.getExceptions(), null);
+                        mn.setDeclaringClass(next.getDeclaringClass());
+                        mn.setGenericsTypes(next.getGenericsTypes());
+                        mn.addAnnotations(next.getAnnotations());
+                        it.add(mn);
+                    }
+                }
+            }
+        }
+
+        for (ClassNode face : type.getAllInterfaces()) {
+            methods.addAll(face.getMethods());
+        }
+
+        return methods;
+    }
+
+    private static Collection<MethodNode> filterMethods(final Collection<MethodNode> methods, final DelegateDescription delegate, final boolean allNames, final boolean includeDeprecated) {
+        Set<String> groovyObjectMethods = ClassHelper.GROOVY_OBJECT_TYPE.getMethods().stream().map(MethodNode::getTypeDescriptor).collect(toSet());
+        Set<String> javaObjectMethods = ClassHelper.OBJECT_TYPE.getMethods().stream().map(MethodNode::getTypeDescriptor).collect(toSet());
+        Set<String> ownClassMethods = delegate.owner.getMethods().stream().map(MethodNode::getTypeDescriptor).collect(toSet());
+
+        methods.removeIf(candidate -> {
+            if (!candidate.isPublic() || candidate.isStatic() || (candidate.getModifiers () & ACC_SYNTHETIC) != 0) return true;
+
+            if (shouldSkip(candidate.getName(), delegate.excludes, delegate.includes, allNames)) return true;
+
+            if (!includeDeprecated && !candidate.getAnnotations(DEPRECATED_TYPE).isEmpty()) return true;
+
+            if (groovyObjectMethods.contains(candidate.getTypeDescriptor())) return true;
+
+            if (javaObjectMethods.contains(candidate.getTypeDescriptor())) return true;
+
+            if (ownClassMethods.contains(candidate.getTypeDescriptor())) return true;
+
+            return false;
+        });
+
+        return methods;
+    }
+
     private boolean checkPropertyOrMethodList(final ClassNode cNode, final List<String> propertyNameList, final String listName, final AnnotationNode anno, final String typeName) {
         if (propertyNameList == null || propertyNameList.isEmpty()) {
             return true;
@@ -247,7 +316,9 @@ public class DelegateASTTransformation extends AbstractASTTransformation {
         if ((prop.getModifiers() & ACC_FINAL) == 0
                 && delegate.owner.getSetterMethod(setterName) == null && delegate.owner.getProperty(name) == null
                 && !shouldSkipPropertyMethod(name, setterName, delegate.excludes, delegate.includes, allNames)) {
-            addGeneratedMethod(delegate.owner, setterName,
+            addGeneratedMethod(
+                    delegate.owner,
+                    setterName,
                     ACC_PUBLIC,
                     ClassHelper.VOID_TYPE,
                     params(new Parameter(GenericsUtils.nonGeneric(prop.getType()), "value")),
@@ -284,7 +355,8 @@ public class DelegateASTTransformation extends AbstractASTTransformation {
                     GenericsUtils.nonGeneric(prop.getType()),
                     Parameter.EMPTY_ARRAY,
                     null,
-                    returnS(propX(delegate.getOp, name)));
+                    returnS(propX(delegate.getOp, name))
+            );
         }
 
         if (willHaveIsAccessor && !ownerWillHaveIsAccessor.get()
@@ -296,7 +368,8 @@ public class DelegateASTTransformation extends AbstractASTTransformation {
                     GenericsUtils.nonGeneric(prop.getType()),
                     Parameter.EMPTY_ARRAY,
                     null,
-                    returnS(propX(delegate.getOp, name)));
+                    returnS(propX(delegate.getOp, name))
+            );
         }
     }
 
@@ -314,17 +387,8 @@ public class DelegateASTTransformation extends AbstractASTTransformation {
                     || (includes != null && !includes.isEmpty() && !includes.contains(propertyName) && !includes.contains(methodName)));
     }
 
-    private void addDelegateMethod(final DelegateDescription delegate, final List<MethodNode> ownMethods, final MethodNode candidate, final boolean includeDeprecated, final boolean allNames) {
-        if (!candidate.isPublic() || candidate.isStatic() || 0 != (candidate.getModifiers () & ACC_SYNTHETIC))
-            return;
-
-        if (!candidate.getAnnotations(DEPRECATED_TYPE).isEmpty() && !includeDeprecated)
-            return;
-
-        if (shouldSkip(candidate.getName(), delegate.excludes, delegate.includes, allNames)) return;
-
-        Map<String,ClassNode> genericsSpec = createGenericsSpec(delegate.owner);
-        genericsSpec = addMethodGenerics(candidate, genericsSpec);
+    private void addDelegateMethod(final MethodNode candidate, final DelegateDescription delegate, final Iterable<MethodNode> ownMethods) {
+        Map<String,ClassNode> genericsSpec = addMethodGenerics(candidate, createGenericsSpec(delegate.owner));
         extractSuperClassGenerics(delegate.type, candidate.getDeclaringClass(), genericsSpec);
 
         if ((delegate.excludeTypes != null && !delegate.excludeTypes.isEmpty()) || delegate.includeTypes != null) {
@@ -334,25 +398,11 @@ public class DelegateASTTransformation extends AbstractASTTransformation {
                 return;
         }
 
-        // ignore methods from GroovyObject
-        for (MethodNode mn : ClassHelper.GROOVY_OBJECT_TYPE.getMethods()) {
-            if (mn.getTypeDescriptor().equals(candidate.getTypeDescriptor())) {
-                return;
-            }
-        }
-
-        // ignore methods already in owner
-        for (MethodNode mn : delegate.owner.getMethods()) {
-            if (mn.getTypeDescriptor().equals(candidate.getTypeDescriptor())) {
-                return;
-            }
-        }
-
         // give precedence to methods of self (but not abstract or static superclass methods)
         // also allows abstract or static self methods to be selected for overriding but they are ignored later
         MethodNode existingNode = null;
         for (MethodNode mn : ownMethods) {
-            if (mn.getTypeDescriptor().equals(candidate.getTypeDescriptor()) && !mn.isAbstract() && !mn.isStatic()) {
+            if (!mn.isAbstract() && !mn.isStatic() && mn.getTypeDescriptor().equals(candidate.getTypeDescriptor())) {
                 existingNode = mn;
                 break;
             }
@@ -365,12 +415,9 @@ public class DelegateASTTransformation extends AbstractASTTransformation {
             for (int i = 0, n = newParams.length; i < n; i += 1) {
                 ClassNode newParamType = correctToGenericsSpecRecurse(genericsSpec, params[i].getType(), currentMethodGenPlaceholders);
                 Parameter newParam = new Parameter(newParamType, getParamName(params, i, delegate.name));
-                newParam.setInitialExpression(params[i].getInitialExpression());
-
-                if (memberHasValue(delegate.annotation, MEMBER_PARAMETER_ANNOTATIONS, true)) {
+                if (memberHasValue(delegate.annotation, MEMBER_PARAMETER_ANNOTATIONS, Boolean.TRUE)) {
                     newParam.addAnnotations(copyAnnotatedNodeAnnotations(params[i], MY_TYPE_NAME));
                 }
-
                 newParams[i] = newParam;
                 args.addExpression(varX(newParam));
             }
@@ -384,14 +431,16 @@ public class DelegateASTTransformation extends AbstractASTTransformation {
             mce.setImplicitThis(false); // GROOVY-9938
             mce.setSourcePosition(delegate.delegate); // GROOVY-6542
             ClassNode returnType = correctToGenericsSpecRecurse(genericsSpec, candidate.getReturnType(), currentMethodGenPlaceholders);
-            MethodNode newMethod = addGeneratedMethod(delegate.owner, candidate.getName(),
+            MethodNode newMethod = addGeneratedMethod(
+                    delegate.owner,
+                    candidate.getName(),
                     candidate.getModifiers() & (~ACC_ABSTRACT) & (~ACC_NATIVE),
                     returnType,
                     newParams,
                     candidate.getExceptions(),
-                    candidate.isVoidMethod() ? stmt(mce) : returnS(mce));
+                    candidate.isVoidMethod() ? stmt(mce) : returnS(mce)
+            );
             newMethod.setGenericsTypes(candidate.getGenericsTypes());
-
             if (memberHasValue(delegate.annotation, MEMBER_METHOD_ANNOTATIONS, Boolean.TRUE)) {
                 newMethod.addAnnotations(copyAnnotatedNodeAnnotations(candidate, MY_TYPE_NAME, false));
             }
diff --git a/src/test/groovy/bugs/Groovy4516Bug.groovy b/src/test/groovy/bugs/Groovy4516Bug.groovy
deleted file mode 100644
index 498526b5a5..0000000000
--- a/src/test/groovy/bugs/Groovy4516Bug.groovy
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one
- *  or more contributor license agreements.  See the NOTICE file
- *  distributed with this work for additional information
- *  regarding copyright ownership.  The ASF licenses this file
- *  to you under the Apache License, Version 2.0 (the
- *  "License"); you may not use this file except in compliance
- *  with the License.  You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing,
- *  software distributed under the License is distributed on an
- *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- *  KIND, either express or implied.  See the License for the
- *  specific language governing permissions and limitations
- *  under the License.
- */
-package groovy.bugs
-
-import groovy.test.GroovyTestCase
-
-class Groovy4516Bug extends GroovyTestCase {
-    void testDelegateMethodsWithDefaultValues() {
-        assertScript """
-            class Del4516 {
-                def doSomething(boolean flag = true) { 
-                    flag 
-                }
-            }
-            
-            class AClass4516 { 
-                @Delegate Del4516 Del4516 = new Del4516() 
-            }
-            
-            def a = new AClass4516()
-            assert a.doSomething(false) == false
-            assert a.doSomething() == true
-        """
-    }
-}
diff --git a/src/test/org/codehaus/groovy/transform/DelegateTransformTest.groovy b/src/test/org/codehaus/groovy/transform/DelegateTransformTest.groovy
index 2dbaaa5f91..7f2eafac20 100644
--- a/src/test/org/codehaus/groovy/transform/DelegateTransformTest.groovy
+++ b/src/test/org/codehaus/groovy/transform/DelegateTransformTest.groovy
@@ -18,6 +18,8 @@
  */
 package org.codehaus.groovy.transform
 
+import org.codehaus.groovy.control.CompilerConfiguration
+import org.codehaus.groovy.tools.javac.JavaAwareCompilationUnit
 import org.junit.Test
 
 import java.util.concurrent.locks.Lock
@@ -63,58 +65,58 @@ final class DelegateTransformTest {
     @Test // GROOVY-5974
     void testDelegateExcludes() {
         assertScript '''
-          class MapSet {
-            @Delegate(interfaces=false, excludes=['remove','clear']) Map m = [a: 1]
-            @Delegate Set s = new LinkedHashSet([2, 3, 4] as Set) // HashSet not good enough in JDK 1.5
-            String toString() { m.toString() + ' ' + s }
-          }
-
-          def ms = new MapSet()
-          assert ms.size() == 1
-          assert ms.toString() == '[a:1] [2, 3, 4]'
-          ms.remove(3)
-          assert ms.size() == 1
-          assert ms.toString() == '[a:1] [2, 4]'
-          ms.clear()
-          assert ms.toString() == '[a:1] []'
+            class MapSet {
+                @Delegate(interfaces=false, excludes=['remove','clear']) Map m = [a: 1]
+                @Delegate Set s = new LinkedHashSet([2, 3, 4] as Set) // HashSet not good enough in JDK 1.5
+                String toString() { m.toString() + ' ' + s }
+            }
+
+            def ms = new MapSet()
+            assert ms.size() == 1
+            assert ms.toString() == '[a:1] [2, 3, 4]'
+            ms.remove(3)
+            assert ms.size() == 1
+            assert ms.toString() == '[a:1] [2, 4]'
+            ms.clear()
+            assert ms.toString() == '[a:1] []'
         '''
     }
 
     @Test
     void testDelegateCompileStatic() {
         assertScript '''
-          @groovy.transform.CompileStatic
-          class MapSet {
-            @Delegate(interfaces=false, excludes=['remove','clear']) Map m = [a: 1]
-            @Delegate Set s = new LinkedHashSet([2, 3, 4] as Set)
-            String toString() { m.toString() + ' ' + s }
-          }
-
-          def ms = new MapSet()
-          assert ms.size() == 1
-          assert ms.toString() == '{a=1} [2, 3, 4]'
-          ms.remove(3)
-          assert ms.size() == 1
-          assert ms.toString() == '{a=1} [2, 4]'
-          ms.clear()
-          assert ms.toString() == '{a=1} []'
+            @groovy.transform.CompileStatic
+            class MapSet {
+                @Delegate(interfaces=false, excludes=['remove','clear']) Map m = [a: 1]
+                @Delegate Set s = new LinkedHashSet([2, 3, 4] as Set)
+                String toString() { m.toString() + ' ' + s }
+            }
+
+            def ms = new MapSet()
+            assert ms.size() == 1
+            assert ms.toString() == '{a=1} [2, 3, 4]'
+            ms.remove(3)
+            assert ms.size() == 1
+            assert ms.toString() == '{a=1} [2, 4]'
+            ms.clear()
+            assert ms.toString() == '{a=1} []'
         '''
     }
 
     @Test
     void testLock() {
         def res = new GroovyShell().evaluate('''
-              import java.util.concurrent.locks.*
+            import java.util.concurrent.locks.*
 
-              class LockableMap {
-                 @Delegate private Map map = [:]
+            class LockableMap {
+               @Delegate private Map map = [:]
 
-                 @Delegate private Lock lock = new ReentrantLock ()
+               @Delegate private Lock lock = new ReentrantLock ()
 
-                 @Delegate(interfaces=false) private List list = new ArrayList ()
-              }
+               @Delegate(interfaces=false) private List list = new ArrayList ()
+            }
 
-              new LockableMap ()
+            new LockableMap ()
         ''')
 
         res.lock()
@@ -141,20 +143,20 @@ final class DelegateTransformTest {
     void testMultiple() {
         def res = new GroovyShell().evaluate('''
             class X {
-              def value = 10
+                def value = 10
             }
 
             class Y {
-              @Delegate X  x  = new X ()
-              @Delegate XX xx = new XX ()
+                @Delegate X  x  = new X ()
+                @Delegate XX xx = new XX ()
 
-              void setValue (v) {
-                this.@x.@value = 12
-              }
+                void setValue (v) {
+                    this.@x.@value = 12
+                }
             }
 
             class XX {
-              def value2 = 11
+                def value2 = 11
             }
 
             new Y ()
@@ -169,10 +171,10 @@ final class DelegateTransformTest {
     @Test
     void testUsingDateCompiles() {
         assertScript '''
-            class Foo {
-                @Delegate Date d = new Date();
+            class C {
+                @Delegate Date d = new Date()
             }
-            Foo
+            new C()
         '''
     }
 
@@ -221,7 +223,7 @@ final class DelegateTransformTest {
     @Test
     void testDelegateToObjectShouldFail() {
         shouldFail '''
-            class B {
+            class C {
                 @Delegate b = new Object()
             }
         '''
@@ -230,11 +232,8 @@ final class DelegateTransformTest {
     @Test
     void testDelegateToSelfTypeShouldFail() {
         shouldFail '''
-            class B {
-                @Delegate B b = new B()
-                static main(args) {
-                    new B()
-                }
+            class C {
+                @Delegate C c = new C()
             }
         '''
     }
@@ -888,6 +887,139 @@ final class DelegateTransformTest {
             assert new BarDelegate().name == 'Baz'
         '''
     }
+
+    @Test // GROOVY-4516
+    void testParameterWithDefaultArgument1() {
+        assertScript '''
+            class C {
+                def m(boolean b = true) {
+                    b
+                }
+            }
+            class D {
+                @Delegate private C c = new C()
+            }
+
+            assert new D().m() == true
+            assert new D().m(false) == false
+        '''
+    }
+
+    @Test // GROOVY-4516
+    void testParameterWithDefaultArgument2() {
+        assertScript '''
+            class C {
+                def m(x = 'x', y = 'y', int z) {
+                    '' + x + y + z
+                }
+            }
+            class D {
+                @Delegate private C c = new C()
+            }
+
+            assert new D().m(1) == 'xy1'
+            assert new D().m(1,2) == '1y2'
+            assert new D().m(1,2,3) == '123'
+        '''
+    }
+
+    @Test
+    void testParameterWithDefaultArgument3() {
+        assertScript '''
+            class C {
+                def m(x = 'x', y = why(), int z) {
+                    '' + x + y + z
+                }
+                private why() {
+                    'y'
+                }
+            }
+            class D {
+                @Delegate private C c = new C()
+            }
+
+            assert new D().m(1) == 'xy1'
+            assert new D().m(1,2) == '1y2'
+            assert new D().m(1,2,3) == '123'
+        '''
+    }
+
+    @Test // GROOVY-4320
+    void testParameterWithDefaultArgument4() {
+        assertScript '''
+            interface I {
+                String event(String name)
+                String event(String name, List values)
+            }
+            class C implements I {
+                String event(String name, List values = []) {
+                    return "$name:$values"
+                }
+            }
+            class D {
+                @Delegate private C c = new C() // The method with default parameters "..." defines a method "event(java.lang.String)" that is already defined.
+            }
+
+            String result = new D().event('x')
+            assert result == 'x:[]'
+        '''
+    }
+
+    @Test // GROOVY-4320
+    void testParameterWithDefaultArgument5() {
+        def config = new CompilerConfiguration(
+            targetDirectory: File.createTempDir(),
+            jointCompilationOptions: [memStub: true]
+        )
+        def parentDir = File.createTempDir()
+        try {
+            new File(parentDir, 'p').mkdir()
+
+            def a = new File(parentDir, 'p/I.java')
+            a.write '''
+                package p;
+                import java.util.List;
+                public interface I {
+                    String event(String name);
+                    String event(String name, List values);
+                }
+            '''
+            def b = new File(parentDir, 'p/C.groovy')
+            b.write '''
+                package p
+                class C implements I {
+                    private final I i
+                    C(I i) { this.i = i }
+
+                    String event(String name, List values = []) {
+                        return "$name:$values"
+                    }
+                }
+            '''
+            def c = new File(parentDir, 'p/Main.groovy')
+            c.write '''
+                package p
+                class Main {
+                    @Delegate private C c = new C(this)
+
+                    void test() {
+                        String result = this.event('x')
+                        assert result == 'x:[]'
+                    }
+                }
+            '''
+
+            def loader = new GroovyClassLoader(this.class.classLoader)
+            def cu = new JavaAwareCompilationUnit(config, loader)
+            cu.addSources(a, b, c)
+            cu.compile()
+
+            loader.loadClass('p.Main').newInstance().test()
+        } finally {
+            config.targetDirectory.deleteDir()
+            parentDir.deleteDir()
+        }
+    }
 }
 
 //------------------------------------------------------------------------------
