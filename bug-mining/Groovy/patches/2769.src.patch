diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 2cb05ec2dc..3b296069fd 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -3833,6 +3833,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             final Variable variable = vexp.getAccessedVariable();
             if (variable instanceof FieldNode) {
                 checkOrMarkPrivateAccess((FieldNode) variable);
+                return getType((FieldNode) variable);
             }
             if (variable != null && variable != vexp && variable instanceof VariableExpression) {
                 return getType((Expression) variable);
@@ -3914,14 +3915,32 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             return ((Parameter) exp).getOriginType();
         }
         if (exp instanceof FieldNode) {
-            return ((FieldNode) exp).getOriginType();
+            FieldNode fn = (FieldNode) exp;
+            return getGenericsResolvedTypeOfFieldOrProperty(fn, fn.getOriginType());
         }
         if (exp instanceof PropertyNode) {
-            return ((PropertyNode) exp).getOriginType();
+            PropertyNode pn = (PropertyNode) exp;
+            return getGenericsResolvedTypeOfFieldOrProperty(pn, pn.getOriginType());
         }
         return exp instanceof VariableExpression ? ((VariableExpression) exp).getOriginType() : ((Expression) exp).getType();
     }
 
+    /**
+     * resolves a Field or Property node generics by using the current class and
+     * the declaring class to extract the right meaning of the generics symbols
+     * @param an a FieldNode or PropertyNode
+     * @param type the origin type
+     * @return the new ClassNode with corrected generics
+     */
+    private ClassNode getGenericsResolvedTypeOfFieldOrProperty(AnnotatedNode an, ClassNode type) {
+        if (!type.isUsingGenerics()) return type;
+        Map<String, GenericsType> connections = new HashMap();
+        //TODO: inner classes mean a different this-type. This is ignored here!
+        extractGenericsConnections(connections, typeCheckingContext.getEnclosingClassNode(), an.getDeclaringClass());
+        type= applyGenericsContext(connections, type);
+        return type;
+    }
+
     private ClassNode makeSuper() {
         ClassNode ret = typeCheckingContext.getEnclosingClassNode().getSuperClass();
         if (typeCheckingContext.isInStaticContext) {
diff --git a/src/test/groovy/transform/stc/STCAssignmentTest.groovy b/src/test/groovy/transform/stc/STCAssignmentTest.groovy
index 4a0ea3a753..d8885d8bb0 100644
--- a/src/test/groovy/transform/stc/STCAssignmentTest.groovy
+++ b/src/test/groovy/transform/stc/STCAssignmentTest.groovy
@@ -806,5 +806,26 @@ class STCAssignmentTest extends StaticTypeCheckingTestCase {
             int[] array = o
         ''', 'Cannot assign value of type java.lang.Object to variable of type int[]'
     }
+
+    // GROOVY-7015
+    void testAssingmentToSuperclassFieldWithDifferingGenerics() {
+        assertScript '''
+            class Base {}
+            class Derived extends Base {
+                public String sayHello() { "hello"}
+            }
+
+            class GBase<T extends Base> {
+                T myVar;
+            }
+            class GDerived extends GBase<Derived> {
+                GDerived() { myVar = new Derived(); }
+                public String method() {myVar.sayHello()}
+            }
+
+            GDerived d = new GDerived();
+            assert d.method() == "hello"
+        '''
+    }
 }
 
