diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 6b654c9a71..bf7d8f48e2 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -399,6 +399,16 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 resultType = lType;
             }
 
+            // if left expression is a closure shared variable, a second pass should be done
+            if (leftExpression instanceof VariableExpression) {
+                VariableExpression leftVar = (VariableExpression) leftExpression;
+                if (leftVar.isClosureSharedVariable()) {
+                    // if left expression is a closure shared variable, we should check it twice
+                    // see GROOVY-5874
+                    typeCheckingContext.secondPassExpressions.add(new SecondPassExpression<Void>(expression));
+                }
+            }
+
             if (lType.isUsingGenerics() && missesGenericsTypes(resultType) && isAssignment(op)) {
                 // unchecked assignment
                 // examples:
@@ -3297,7 +3307,32 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
     public void performSecondPass() {
         for (SecondPassExpression wrapper : typeCheckingContext.secondPassExpressions) {
             Expression expression = wrapper.getExpression();
-            if (expression instanceof MethodCallExpression) {
+            if (expression instanceof BinaryExpression) {
+                Expression left = ((BinaryExpression) expression).getLeftExpression();
+                if (left instanceof VariableExpression) {
+                    // should always be the case
+                    // this should always be the case, but adding a test is safer
+                    Variable target = findTargetVariable((VariableExpression) left);
+                    if (target instanceof VariableExpression) {
+                        VariableExpression var = (VariableExpression) target;
+                        List<ClassNode> classNodes = typeCheckingContext.closureSharedVariablesAssignmentTypes.get(var);
+                        if (classNodes != null && classNodes.size() > 1) {
+                            ClassNode lub = lowestUpperBound(classNodes);
+                            String message = getOperationName(((BinaryExpression) expression).getOperation().getType());
+                            if (message!=null) {
+                                List<MethodNode> method = findMethod(lub, message, getType(((BinaryExpression) expression).getRightExpression()));
+                                if (method.isEmpty()) {
+                                    addStaticTypeError("A closure shared variable [" + target.getName() + "] has been assigned with various types and the method" +
+                                            " [" + toMethodParametersString(message, getType(((BinaryExpression) expression).getRightExpression())) + "]" +
+                                            " does not exist in the lowest upper bound of those types: [" +
+                                            lub.toString(false) + "]. In general, this is a bad practice (variable reuse) because the compiler cannot" +
+                                            " determine safely what is the type of the variable at the moment of the call in a multithreaded context.", expression);
+                                }
+                            }
+                        }
+                    }
+                }
+            } else if (expression instanceof MethodCallExpression) {
                 MethodCallExpression call = (MethodCallExpression) expression;
                 Expression objectExpression = call.getObjectExpression();
                 if (objectExpression instanceof VariableExpression) {
diff --git a/src/test/groovy/transform/stc/BugsSTCTest.groovy b/src/test/groovy/transform/stc/BugsSTCTest.groovy
index aee92610e4..0de72c486b 100644
--- a/src/test/groovy/transform/stc/BugsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/BugsSTCTest.groovy
@@ -280,4 +280,15 @@ class BugsSTCTest extends StaticTypeCheckingTestCase {
 
         execute()'''
     }
+
+    // GROOVY-5874-part-1
+    void testClosureSharedVariableInBinExp() {
+        shouldFailWithMessages '''
+            def sum = 0
+            def cl1 = { sum = sum + 1 }
+            def cl2 = { sum = new Date() }
+
+        ''', 'A closure shared variable [sum] has been assigned with various types'
+    }
+
 }
diff --git a/src/test/groovy/transform/stc/GenericsSTCTest.groovy b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
index 278362c7dd..dce716f8b5 100644
--- a/src/test/groovy/transform/stc/GenericsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
@@ -15,6 +15,8 @@
  */
 package groovy.transform.stc
 
+import groovy.transform.NotYetImplemented
+
 /**
  * Unit tests for static type checking : generics.
  *
@@ -1011,6 +1013,32 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
         '''
     }
 
+    // GROOVY-5893
+    @NotYetImplemented
+    void testPlusInClosure() {
+        assertScript '''
+        def list = [1, 2, 3]
+
+        @ASTTest(phase=INSTRUCTION_SELECTION,value={
+            assert node.getNodeMetaData(INFERRED_TYPE) == int_TYPE
+        })
+        def sum = 0
+        list.each { int i -> sum = sum+i }
+        assert sum == 6
+
+        sum = 0
+        list.each { int i -> sum += i }
+        assert sum == 6
+
+        @ASTTest(phase=INSTRUCTION_SELECTION, value={
+            assert node.getNodeMetaData(INFERRED_TYPE) == Integer_TYPE
+        })
+        def sumWithInject = list.inject(0, { int x, int y -> x + y })
+        sum = sumWithInject
+        assert sum == 6
+        '''
+    }
+
     static class MyList extends LinkedList<String> {}
 
     public static class ClassA<T> {
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/BugsStaticCompileTest.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/BugsStaticCompileTest.groovy
index 79b5e6ac77..2de7f30be5 100644
--- a/src/test/org/codehaus/groovy/classgen/asm/sc/BugsStaticCompileTest.groovy
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/BugsStaticCompileTest.groovy
@@ -15,6 +15,7 @@
  */
 package org.codehaus.groovy.classgen.asm.sc
 
+import groovy.transform.NotYetImplemented
 import groovy.transform.stc.BugsSTCTest
 
 /**
