diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
index d68fde1b87..96ded265d3 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
@@ -47,7 +47,6 @@ import org.codehaus.groovy.ast.tools.WideningCategories;
 import org.codehaus.groovy.control.CompilationUnit;
 import org.codehaus.groovy.control.CompilerConfiguration;
 import org.codehaus.groovy.control.Phases;
-import org.codehaus.groovy.runtime.ArrayTypeUtils;
 import org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl;
 import org.codehaus.groovy.syntax.Types;
 import org.codehaus.groovy.tools.GroovyClass;
@@ -1323,25 +1322,30 @@ public abstract class StaticTypeCheckingSupport {
      * for which placeholders are resolved recursively.
      */
     protected static GenericsType fullyResolve(GenericsType gt, final Map<GenericsTypeName, GenericsType> placeholders) {
-        GenericsType fromMap = placeholders.get(new GenericsTypeName(gt.getName()));
-        if (gt.isPlaceholder() && fromMap != null) {
-            gt = fromMap;
+        if (gt.isPlaceholder()) {
+            gt = placeholders.getOrDefault(new GenericsTypeName(gt.getName()), gt);
+        }
+        if (!gt.isPlaceholder() && !gt.isWildcard()) {
+            return new GenericsType(fullyResolveType(gt.getType(), placeholders), null, null);
         }
 
-        ClassNode type = fullyResolveType(gt.getType(), placeholders);
         ClassNode lowerBound = gt.getLowerBound();
-        if (lowerBound != null) lowerBound = fullyResolveType(lowerBound, placeholders);
         ClassNode[] upperBounds = gt.getUpperBounds();
-        if (upperBounds != null) {
-            ClassNode[] copy = new ClassNode[upperBounds.length];
-            for (int i = 0, upperBoundsLength = upperBounds.length; i < upperBoundsLength; i++) {
-                final ClassNode upperBound = upperBounds[i];
-                copy[i] = fullyResolveType(upperBound, placeholders);
+        if (lowerBound != null) {
+            lowerBound = fullyResolveType(lowerBound, placeholders);
+            upperBounds = null; // should be the case; let's be sure
+        } else if (upperBounds != null) {
+            upperBounds = upperBounds.clone();
+            for (int i = 0, n = upperBounds.length; i < n; i += 1) {
+                upperBounds[i] = fullyResolveType(upperBounds[i], placeholders);
             }
-            upperBounds = copy;
+        } else {
+            upperBounds = new ClassNode[]{fullyResolveType(gt.getType(), placeholders)};
         }
-        GenericsType genericsType = new GenericsType(type, upperBounds, lowerBound);
-        genericsType.setWildcard(gt.isWildcard());
+
+        GenericsType genericsType = new GenericsType(makeWithoutCaching("?"), upperBounds, lowerBound);
+        genericsType.getType().setRedirect(OBJECT_TYPE);
+        genericsType.setWildcard(true);
         return genericsType;
     }
 
@@ -1559,11 +1563,14 @@ public abstract class StaticTypeCheckingSupport {
     }
 
     private static int dimensions(ClassNode cn) {
-        if (!cn.isArray()) {
-            return 0;
+        int dims = 0;
+        while (cn.isArray()) {
+            cn = cn.getComponentType();
+            dims += 1;
         }
-        return ArrayTypeUtils.dimension(cn);
+        return dims;
     }
+
     private static boolean compatibleConnection(final GenericsType resolved, final GenericsType connection) {
         if (resolved.isPlaceholder()
                 &&  resolved.getUpperBounds() != null
@@ -1831,8 +1838,10 @@ public abstract class StaticTypeCheckingSupport {
             return gt;
         }
 
-        if (gt.isWildcard()) {
-            GenericsType newGT = new GenericsType(type, applyGenericsContext(spec, gt.getUpperBounds()), applyGenericsContext(spec, gt.getLowerBound()));
+        if (gt.isWildcard()) { // TODO: What if a bound itself resolves to a wildcard?
+            ClassNode[] upperBounds = applyGenericsContext(spec, gt.getUpperBounds());
+            ClassNode   lowerBound = applyGenericsContext(spec, gt.getLowerBound());
+            GenericsType newGT = new GenericsType(type, upperBounds, lowerBound);
             newGT.setWildcard(true);
             return newGT;
         }
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index acfc961488..44457cb528 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -224,6 +224,7 @@ import static org.codehaus.groovy.ast.tools.GeneralUtils.getGetterName;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.getSetterName;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.indexX;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.isOrImplements;
+import static org.codehaus.groovy.ast.tools.GeneralUtils.nullX;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.propX;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.thisPropX;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.varX;
@@ -2447,7 +2448,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                     // GROOVY-10930: check constructor reference
                     ClassNode[] signature = expression.getNodeMetaData(CLOSURE_ARGUMENTS);
                     if (signature != null) { Expression[] mocks = Arrays.stream(signature)
-                            .map(t->castX(t,defaultValueX(t))).toArray(Expression[]::new);
+                            .map(t -> typedValueExpression(t)).toArray(Expression[]::new);
                         Expression dummy = ctorX(type, args(mocks));
                         dummy.setSourcePosition(expression);
                         dummy.visit(this);
@@ -2523,6 +2524,13 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         }
     }
 
+    private static Expression typedValueExpression(final ClassNode type) {
+        if (isObjectType(type) && !type.isGenericsPlaceHolder()) {
+            return nullX(); // GROOVY-10971: unknown argument type
+        }
+        return castX(type, defaultValueX(type));
+    }
+
     private static ClassNode wrapClosureType(final ClassNode returnType) {
         return makeClassSafe0(CLOSURE_TYPE, wrapTypeIfNecessary(returnType).asGenericsType());
     }
@@ -3090,15 +3098,17 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                     }
 
                     for (GenericsType tp : typeParameters) {
-                        context.computeIfAbsent(new GenericsTypeName(tp.getName()), x -> fullyResolve(tp, context));
+                        GenericsTypeName name = new GenericsTypeName(tp.getName());
+                        context.computeIfAbsent(name, x -> fullyResolve(tp, context));
                     }
                 }
             }
 
-            ClassNode[] samParamTypes = GenericsUtils.parameterizeSAM(applyGenericsContext(context, target.getType())).getV1();
-
             ClassNode[] paramTypes = expression.getNodeMetaData(CLOSURE_ARGUMENTS);
             if (paramTypes == null) {
+                ClassNode targetType = applyGenericsContext(context, target.getType());
+                ClassNode[] samParamTypes = GenericsUtils.parameterizeSAM(targetType).getV1();
+
                 int n; Parameter[] p = expression.getParameters();
                 if (p == null) {
                     // zero parameters
diff --git a/src/test/groovy/transform/stc/LambdaTest.groovy b/src/test/groovy/transform/stc/LambdaTest.groovy
index 3380975445..db00ca3ffd 100644
--- a/src/test/groovy/transform/stc/LambdaTest.groovy
+++ b/src/test/groovy/transform/stc/LambdaTest.groovy
@@ -259,18 +259,26 @@ final class LambdaTest {
 
     @Test
     void testCollectors1() {
-        assertScript shell, '''
-            Set<String> set = ['a', 'b', 'c'] as Set
-            assert [a: 'a', b: 'b', c: 'c'] == set.stream().collect(Collectors.toMap(e -> e, e -> e))
-        '''
+        for (spec in ['', '<String,String,String>']) {
+            assertScript shell, """
+                def set = ['a', 'b', 'c'] as Set<String>
+                def map = set.stream().collect(Collectors.${spec}toMap(e -> e, e -> e))
+
+                assert map == [a: 'a', b: 'b', c: 'c']
+            """
+        }
     }
 
     @Test
     void testCollectors2() {
-        assertScript shell, '''
-            Set<String> set = ['a', 'b', 'c'] as Set
-            assert [a: 'a', b: 'b', c: 'c'] == set.stream().collect(Collectors.toMap(e -> e, e -> e, (o1, o2) -> o2))
-        '''
+        for (spec in ['', '<String,String,String>']) {
+            assertScript shell, """
+                def set = ['a', 'b', 'c'] as Set<String>
+                def map = set.stream().collect(Collectors.${spec}toMap(e -> e, e -> e, (v1,v2) -> v2))
+
+                assert map == [a: 'a', b: 'b', c: 'c']
+            """
+        }
     }
 
     @Test
diff --git a/src/test/groovy/transform/stc/MethodReferenceTest.groovy b/src/test/groovy/transform/stc/MethodReferenceTest.groovy
index a915ce7502..d9e9599e80 100644
--- a/src/test/groovy/transform/stc/MethodReferenceTest.groovy
+++ b/src/test/groovy/transform/stc/MethodReferenceTest.groovy
@@ -684,20 +684,35 @@ final class MethodReferenceTest {
     @Test // class::new -- GROOVY-10930
     void testFunctionCN5() {
         def err = shouldFail shell, '''
-            def <X> void m(Function<String,X> fn) { }
-            class Bar { }
+            class Foo { Foo() { } }
+            def <T> void m(Function<String,T> fn) { }
+
             @CompileStatic
             void test() {
-                m(Bar::new) // ctor does not accept String
+                m(Foo::new) // ctor does not accept String
             }
 
             test()
         '''
-        assert err =~ /Cannot find matching constructor Bar\(java.lang.String\)/
+        assert err =~ /Cannot find matching constructor Foo\(java.lang.String\)/
     }
 
-    @Test // class::new -- GROOVY-11001
+    @Test // class::new -- GROOVY-10971
     void testFunctionCN6() {
+        assertScript shell, '''
+            class Foo { Foo(String s) { } }
+
+            @CompileStatic
+            void test() {
+                Collectors.groupingBy(Foo::new) // Cannot find matching constructor Foo(Object)
+            }
+
+            test()
+        '''
+    }
+
+    @Test // class::new -- GROOVY-11001
+    void testFunctionCN7() {
         assertScript shell, '''
             @Grab('io.vavr:vavr:0.10.4')
             import io.vavr.control.Try
