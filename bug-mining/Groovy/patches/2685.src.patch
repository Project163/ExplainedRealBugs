diff --git a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java
index 17ba78037a..acf1600d0f 100644
--- a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java
+++ b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java
@@ -391,6 +391,9 @@ public class StaticInvocationWriter extends InvocationWriter {
             return;
         }
         Object implicitReceiver = origin.getNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER);
+        if (implicitThis && implicitReceiver==null && origin instanceof MethodCallExpression) {
+            implicitReceiver = ((MethodCallExpression) origin).getObjectExpression().getNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER);
+        }
         if (implicitReceiver !=null && implicitThis) {
             String[] propertyPath = ((String) implicitReceiver).split("\\.");
             // GROOVY-6021
diff --git a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesBinaryExpressionMultiTypeDispatcher.java b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesBinaryExpressionMultiTypeDispatcher.java
index 83651f360a..b4f5df3f66 100644
--- a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesBinaryExpressionMultiTypeDispatcher.java
+++ b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesBinaryExpressionMultiTypeDispatcher.java
@@ -34,6 +34,7 @@ import org.objectweb.asm.Label;
 import org.objectweb.asm.MethodVisitor;
 import org.objectweb.asm.Opcodes;
 
+import java.lang.reflect.Modifier;
 import java.util.concurrent.atomic.AtomicInteger;
 
 import static org.codehaus.groovy.ast.ClassHelper.*;
@@ -294,8 +295,9 @@ public class StaticTypesBinaryExpressionMultiTypeDispatcher extends BinaryExpres
         TypeChooser typeChooser = controller.getTypeChooser();
         ClassNode receiverType = typeChooser.resolveType(receiver, controller.getClassNode());
         String property = message.getText();
+        boolean isThisExpression = receiver instanceof VariableExpression && ((VariableExpression) receiver).isThisExpression();
         if (isAttribute
-                || ((receiver instanceof VariableExpression && ((VariableExpression) receiver).isThisExpression()) &&
+                || (isThisExpression &&
                     receiverType.getDeclaredField(property)!=null)) {
             ClassNode current = receiverType;
             FieldNode fn = null;
@@ -329,21 +331,29 @@ public class StaticTypesBinaryExpressionMultiTypeDispatcher extends BinaryExpres
                 operandStack.remove(fn.isStatic()?1:2);
                 return true;
             }
-        } else {
+        }
+        if (!isAttribute) {
             String setter = "set" + MetaClassHelper.capitalize(property);
             MethodNode setterMethod = receiverType.getSetterMethod(setter);
-            if (setterMethod == null) {
+            ClassNode declaringClass = setterMethod!=null?setterMethod.getDeclaringClass():null;
+            if (isThisExpression && declaringClass!=null && declaringClass.equals(controller.getClassNode())) {
+                // this.x = ... shouldn't use a setter if in the same class
+                setterMethod = null;
+            } else if (setterMethod == null) {
                 PropertyNode propertyNode = receiverType.getProperty(property);
                 if (propertyNode != null) {
-                    setterMethod = new MethodNode(
-                            setter,
-                            ACC_PUBLIC,
-                            ClassHelper.VOID_TYPE,
-                            new Parameter[]{new Parameter(propertyNode.getOriginType(), "value")},
-                            ClassNode.EMPTY_ARRAY,
-                            EmptyStatement.INSTANCE
-                    );
-                    setterMethod.setDeclaringClass(receiverType);
+                    int mods = propertyNode.getModifiers();
+                    if (!Modifier.isFinal(mods)) {
+                        setterMethod = new MethodNode(
+                                setter,
+                                ACC_PUBLIC,
+                                ClassHelper.VOID_TYPE,
+                                new Parameter[]{new Parameter(propertyNode.getOriginType(), "value")},
+                                ClassNode.EMPTY_ARRAY,
+                                EmptyStatement.INSTANCE
+                        );
+                        setterMethod.setDeclaringClass(receiverType);
+                    }
                 }
             }
             if (setterMethod != null) {
diff --git a/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java b/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
index 5e740927d0..8a6500da5c 100644
--- a/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
+++ b/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
@@ -221,7 +221,13 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      * @return result of calling the closure
      * @since 1.5.0
      */
-    public static <T> T with(Object self, Closure<T> closure) {
+    public static <T,U> T with(
+            @DelegatesTo.Target("self") U self,
+            @DelegatesTo(value=DelegatesTo.Target.class,
+                    target="self",
+                    strategy=Closure.DELEGATE_FIRST)
+            @ClosureParams(FirstParam.class)
+            Closure<T> closure) {
         @SuppressWarnings("unchecked")
         final Closure<T> clonedClosure = (Closure<T>) closure.clone();
         clonedClosure.setResolveStrategy(Closure.DELEGATE_FIRST);
diff --git a/src/main/org/codehaus/groovy/transform/ImmutableASTTransformation.java b/src/main/org/codehaus/groovy/transform/ImmutableASTTransformation.java
index b793499f33..e0711e9380 100644
--- a/src/main/org/codehaus/groovy/transform/ImmutableASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/ImmutableASTTransformation.java
@@ -27,6 +27,7 @@ import org.codehaus.groovy.ast.ClassHelper;
 import org.codehaus.groovy.ast.ClassNode;
 import org.codehaus.groovy.ast.ConstructorNode;
 import org.codehaus.groovy.ast.FieldNode;
+import org.codehaus.groovy.ast.MethodNode;
 import org.codehaus.groovy.ast.Parameter;
 import org.codehaus.groovy.ast.PropertyNode;
 import org.codehaus.groovy.ast.VariableScope;
@@ -45,6 +46,7 @@ import org.codehaus.groovy.control.CompilePhase;
 import org.codehaus.groovy.control.SourceUnit;
 import org.codehaus.groovy.runtime.DefaultGroovyMethods;
 import org.codehaus.groovy.runtime.InvokerHelper;
+import org.codehaus.groovy.runtime.MetaClassHelper;
 import org.codehaus.groovy.runtime.ReflectionMethodInvoker;
 
 import java.lang.reflect.Field;
diff --git a/src/main/org/codehaus/groovy/transform/sc/transformers/VariableExpressionTransformer.java b/src/main/org/codehaus/groovy/transform/sc/transformers/VariableExpressionTransformer.java
index b475bdec98..21b4da851e 100644
--- a/src/main/org/codehaus/groovy/transform/sc/transformers/VariableExpressionTransformer.java
+++ b/src/main/org/codehaus/groovy/transform/sc/transformers/VariableExpressionTransformer.java
@@ -15,9 +15,13 @@
  */
 package org.codehaus.groovy.transform.sc.transformers;
 
+import org.codehaus.groovy.ast.ClassNode;
 import org.codehaus.groovy.ast.expr.Expression;
 import org.codehaus.groovy.ast.expr.PropertyExpression;
 import org.codehaus.groovy.ast.expr.VariableExpression;
+import org.codehaus.groovy.transform.sc.StaticCompilationMetadataKeys;
+import org.codehaus.groovy.transform.sc.StaticCompilationVisitor;
+import org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor;
 import org.codehaus.groovy.transform.stc.StaticTypesMarker;
 
 /**
@@ -34,9 +38,15 @@ public class VariableExpressionTransformer {
         // handle it
         Object val = expr.getNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER);
         if (val==null) return expr;
-        PropertyExpression pexp = new PropertyExpression(new VariableExpression("this"), expr.getName());
+        VariableExpression implicitThis = new VariableExpression("this");
+        PropertyExpression pexp = new PropertyExpression(implicitThis, expr.getName());
         pexp.copyNodeMetaData(expr);
         pexp.setImplicitThis(true);
+        ClassNode owner = expr.getNodeMetaData(StaticCompilationMetadataKeys.PROPERTY_OWNER);
+        if (owner!=null) {
+            implicitThis.putNodeMetaData(StaticTypesMarker.INFERRED_TYPE, owner);
+            implicitThis.putNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER, val);
+        }
         return pexp;
     }
 }
diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 5fc219c854..a179a939da 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -388,13 +388,14 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         if (storeTypeForThis(vexp)) return;
         if (storeTypeForSuper(vexp)) return;
 
-        if (typeCheckingContext.getEnclosingClosure() != null) {
+        TypeCheckingContext.EnclosingClosure enclosingClosure = typeCheckingContext.getEnclosingClosure();
+        if (enclosingClosure != null) {
             String name = vexp.getName();
             if (name.equals("owner") || name.equals("thisObject")) {
                 storeType(vexp, typeCheckingContext.getEnclosingClassNode());
                 return;
             } else if ("delegate".equals(name)) {
-                DelegationMetadata md = getDelegationMetadata(typeCheckingContext.getEnclosingClosure().getClosureExpression());
+                DelegationMetadata md = getDelegationMetadata(enclosingClosure.getClosureExpression());
                 ClassNode type = typeCheckingContext.getEnclosingClassNode();
                 if (md!=null) type = md.getType();
                 storeType(vexp, type);
@@ -409,11 +410,15 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         DynamicVariable dyn = (DynamicVariable) vexp.getAccessedVariable();
         // first, we must check the 'with' context
         String dynName = dyn.getName();
-        PropertyExpression pe = new PropertyExpression(new VariableExpression("this"), dynName);
+        VariableExpression implicitThis = new VariableExpression("this");
+        PropertyExpression pe = new PropertyExpression(implicitThis, dynName);
         pe.setImplicitThis(true);
         if (visitPropertyExpressionSilent(pe, vexp)) {
+            ClassNode previousIt = vexp.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);
+            vexp.copyNodeMetaData(implicitThis);
+            vexp.putNodeMetaData(StaticTypesMarker.INFERRED_TYPE, previousIt);
             storeType(vexp, getType(pe));
-            Object val = pe.getNodeMetaData(StaticTypesMarker.READONLY_PROPERTY); 
+            Object val = pe.getNodeMetaData(StaticTypesMarker.READONLY_PROPERTY);
             if (val!=null) vexp.putNodeMetaData(StaticTypesMarker.READONLY_PROPERTY,val);
             val = pe.getNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER);
             if (val!=null) vexp.putNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER,val);
@@ -1987,26 +1992,12 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
         checkForbiddenSpreadArgument(argumentList);
 
-        boolean isWithCall = isWithCall(name, callArguments);
-
         final ClassNode receiver = call.getOwnerType();
         visitMethodCallArguments(receiver, argumentList, false, null);
 
         ClassNode[] args = getArgumentTypes(argumentList);
 
-        if (isWithCall) {
-            typeCheckingContext.lastImplicitItType = receiver;
-            // if the provided closure uses an explicit parameter definition, we can
-            // also check that the provided type is correct
-            checkClosureParameters(callArguments, receiver);
-        }
-
         try {
-            if (isWithCall) {
-                // in case of a with call, arguments (the closure) should be visited now that we checked
-                // the arguments
-                callArguments.visit(this);
-            }
 
             // method call receivers are :
             //   - possible "with" receivers
@@ -2053,13 +2044,15 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 }
             }
         } finally {
-            if (isWithCall) {
-                typeCheckingContext.lastImplicitItType = rememberLastItType;
-            }
             extension.afterMethodCall(call);
         }
     }
 
+    /**
+     * @deprecated this method is unused, replaced with {@link DelegatesTo} inference.
+     * @param callArguments
+     * @param receiver
+     */
     protected void checkClosureParameters(final Expression callArguments, final ClassNode receiver) {
         if (callArguments instanceof ArgumentListExpression) {
             ArgumentListExpression argList = (ArgumentListExpression) callArguments;
@@ -2093,15 +2086,27 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
     protected void visitMethodCallArguments(final ClassNode receiver, ArgumentListExpression arguments, boolean visitClosures, final MethodNode selectedMethod) {
         Parameter[] params = selectedMethod!=null?selectedMethod.getParameters():Parameter.EMPTY_ARRAY;
-        final List<Expression> expressions = arguments.getExpressions();
+        List<Expression> expressions = new LinkedList<Expression>(arguments.getExpressions());
+        if (selectedMethod instanceof ExtensionMethodNode) {
+            params = ((ExtensionMethodNode) selectedMethod).getExtensionMethodNode().getParameters();
+            expressions.add(0, new VariableExpression("$self", receiver));
+        }
+        ArgumentListExpression newArgs = new ArgumentListExpression(expressions);
+
         for (int i = 0, expressionsSize = expressions.size(); i < expressionsSize; i++) {
             final Expression expression = expressions.get(i);
             if (visitClosures && expression instanceof ClosureExpression
                     || !visitClosures && !(expression instanceof ClosureExpression)) {
                 if (i<params.length && visitClosures) {
                     Parameter param = params[i];
-                    checkClosureWithDelegatesTo(arguments, params, expression, param);
-                    inferClosureParameterTypes(receiver, arguments, (ClosureExpression)expression, param, selectedMethod);
+                    checkClosureWithDelegatesTo(newArgs,params , expression, param);
+                    if (selectedMethod instanceof ExtensionMethodNode) {
+                        if (i>0) {
+                            inferClosureParameterTypes(receiver, arguments, (ClosureExpression)expression, param, selectedMethod);
+                        }
+                    } else {
+                        inferClosureParameterTypes(receiver, newArgs, (ClosureExpression) expression, param, selectedMethod);
+                    }
                 }
                 expression.visit(this);
                 if (expression.getNodeMetaData(StaticTypesMarker.DELEGATION_METADATA)!=null) {
@@ -2559,7 +2564,6 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
         // for arguments, we need to visit closures *after* the method has been chosen
 
-        boolean isWithCall = isWithCall(name, callArguments);
 
         final ClassNode receiver = getType(objectExpression);
         visitMethodCallArguments(receiver, argumentList, false, null);
@@ -2567,13 +2571,6 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         ClassNode[] args = getArgumentTypes(argumentList);
         final boolean isCallOnClosure = isClosureCall(name, objectExpression, callArguments);
 
-        if (isWithCall) {
-            typeCheckingContext.lastImplicitItType = receiver;
-            // if the provided closure uses an explicit parameter definition, we can
-            // also check that the provided type is correct
-            checkClosureParameters(callArguments, receiver);
-        }
-
         try {
             boolean callArgsVisited = false;
             if (isCallOnClosure) {
@@ -2708,10 +2705,6 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
                         ClassNode returnType = null;
 
-                        if (isWithCall)  {
-                            returnType = getInferredReturnTypeFromWithClosureArgument(callArguments);
-                        }
-
                         if (returnType == null) {
                             returnType = getType(directMethodCallCandidate);
                         }
@@ -2778,9 +2771,6 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 }
             }
         } finally {
-            if (isWithCall) {
-                typeCheckingContext.lastImplicitItType = rememberLastItType;
-            }
             typeCheckingContext.popEnclosingMethodCall();
             extension.afterMethodCall(call);
         }
diff --git a/src/test/groovy/transform/stc/TypeInferenceSTCTest.groovy b/src/test/groovy/transform/stc/TypeInferenceSTCTest.groovy
index ee5e5e878f..b98ddce1ee 100644
--- a/src/test/groovy/transform/stc/TypeInferenceSTCTest.groovy
+++ b/src/test/groovy/transform/stc/TypeInferenceSTCTest.groovy
@@ -340,7 +340,7 @@ class TypeInferenceSTCTest extends StaticTypeCheckingTestCase {
             a.with { String it ->
                 it.x = 2 // should be recognized as a.x at compile time
             }
-        ''', 'Expected parameter type: A but was: java.lang.String'
+        ''', 'Expected parameter of type A but got java.lang.String'
     }
 
     void testShouldNotFailWithInheritanceAndWith() {
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/BugsStaticCompileTest.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/BugsStaticCompileTest.groovy
index 58ec88bee1..c7c930c1dd 100644
--- a/src/test/org/codehaus/groovy/classgen/asm/sc/BugsStaticCompileTest.groovy
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/BugsStaticCompileTest.groovy
@@ -1345,5 +1345,23 @@ println someInt
             assert versions == ['1.7.0','1.7.1','1.7.2','1.7.3']
         '''
     }
+
+    // GROOVY-6924
+    void testShouldNotThrowIncompatibleClassChangeError() {
+        try {
+            assertScript '''import org.codehaus.groovy.classgen.asm.sc.Groovy6924Support
+
+Groovy6924Support bean = new Groovy6924Support()
+bean.with {
+    foo = 'foo'
+    bar = 'bar'
+}
+String val = "$bean.foo and $bean.bar"
+assert val == 'foo and bar'
+        '''
+        } finally {
+            assert astTrees['TestScripttestShouldNotThrowIncompatibleClassChangeError0$_run_closure1'][1].contains('INVOKEVIRTUAL org/codehaus/groovy/classgen/asm/sc/Groovy6924Support.setFoo (Ljava/lang/String;)V')
+        }
+    }
 }
 
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/Groovy6924Support.java b/src/test/org/codehaus/groovy/classgen/asm/sc/Groovy6924Support.java
new file mode 100644
index 0000000000..17df4c023d
--- /dev/null
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/Groovy6924Support.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2003-2014 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.codehaus.groovy.classgen.asm.sc;
+
+public class Groovy6924Support {
+    private String foo;
+    private String bar;
+
+    public String getFoo() {
+        return foo;
+    }
+
+    public void setFoo(String foo) {
+        this.foo = foo;
+    }
+
+    public String getBar() {
+        return bar;
+    }
+
+    public void setBar(String bar) {
+        this.bar = bar;
+    }
+}
