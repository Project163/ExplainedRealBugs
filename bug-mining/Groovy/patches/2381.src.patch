diff --git a/src/main/groovy/lang/MetaClassImpl.java b/src/main/groovy/lang/MetaClassImpl.java
index 1b5713726f..4aa4d93e7f 100644
--- a/src/main/groovy/lang/MetaClassImpl.java
+++ b/src/main/groovy/lang/MetaClassImpl.java
@@ -16,6 +16,7 @@
 package groovy.lang;
 
 import org.codehaus.groovy.GroovyBugError;
+import org.codehaus.groovy.ast.ClassHelper;
 import org.codehaus.groovy.ast.ClassNode;
 import org.codehaus.groovy.classgen.asm.BytecodeHelper;
 import org.codehaus.groovy.control.CompilationUnit;
@@ -1404,6 +1405,19 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
     }
 
     public int selectConstructorAndTransformArguments(int numberOfConstructors, Object[] arguments) {
+        if (numberOfConstructors==-1) {
+            return selectConstructorAndTransformArguments1(arguments);
+        } else {
+            // falling back to pre 2.1.9 selection algorithm
+            // in practice this branch will only be reached if the class calling this code is a Groovy class
+            // compiled with an earlier version of the Groovy compiler
+            return selectConstructorAndTransformArguments0(numberOfConstructors, arguments);
+        }
+
+
+    }
+
+    private int selectConstructorAndTransformArguments0(final int numberOfConstructors, Object[] arguments) {
         //TODO: that is just a quick prototype, not the real thing!
         if (numberOfConstructors != constructors.size()) {
             throw new IncompatibleClassChangeError("the number of constructors during runtime and compile time for " +
@@ -1444,6 +1458,46 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
         return 0 | (found << 8);
     }
 
+    /**
+     * Constructor selection algorithm for Groovy 2.1.9+.
+     * This selection algorithm was introduced as a workaround for GROOVY-6080. Instead of generating an index between
+     * 0 and N where N is the number of super constructors at the time the class is compiled, this algorithm uses
+     * a hash of the constructor descriptor instead.
+     *
+     * This has the advantage of letting the super class add new constructors while being binary compatible. But there
+     * are still problems with this approach:
+     * <ul>
+     *     <li>There's a risk of hash collision, even if it's very low (two constructors of the same class must have the same hash)</li>
+     *     <li>If the super class adds a new constructor which takes as an argument a superclass of an existing constructor parameter and
+     *     that this new constructor is selected at runtime, it would not find it.</li>
+     * </ul>
+     *
+     * Hopefully in the last case, the error message is much nicer now since it explains that it's a binary incompatible change.
+     *
+     * @param arguments the actual constructor call arguments
+     * @return a hash used to identify the constructor to be called
+     * @since 2.1.9
+     */
+    private int selectConstructorAndTransformArguments1(Object[] arguments) {
+        if (arguments == null) arguments = EMPTY_ARGUMENTS;
+        Class[] argClasses = MetaClassHelper.convertToTypeArray(arguments);
+        MetaClassHelper.unwrap(arguments);
+        CachedConstructor constructor = (CachedConstructor) chooseMethod("<init>", constructors, argClasses);
+        if (constructor == null) {
+            constructor = (CachedConstructor) chooseMethod("<init>", constructors, argClasses);
+        }
+        if (constructor == null) {
+            throw new GroovyRuntimeException(
+                    "Could not find matching constructor for: "
+                            + theClass.getName()
+                            + "(" + InvokerHelper.toTypeString(arguments) + ")");
+        }
+        final String methodDescriptor = BytecodeHelper.getMethodDescriptor(Void.TYPE, constructor.getNativeParameterTypes());
+        // keeping 3 bits for additional information such as vargs
+        return BytecodeHelper.hashCode(methodDescriptor);
+    }
+
+
     /**
      * checks if the initialisation of the class id complete.
      * This method should be called as a form of assert, it is no
diff --git a/src/main/org/codehaus/groovy/classgen/asm/BytecodeHelper.java b/src/main/org/codehaus/groovy/classgen/asm/BytecodeHelper.java
index a084ca3789..268a610f32 100644
--- a/src/main/org/codehaus/groovy/classgen/asm/BytecodeHelper.java
+++ b/src/main/org/codehaus/groovy/classgen/asm/BytecodeHelper.java
@@ -662,4 +662,19 @@ public class BytecodeHelper implements Opcodes {
         CompileUnit cu2 = b.getCompileUnit();
         return cu1 !=null && cu2 !=null && cu1==cu2;
     }
+
+    /**
+     * Computes a hash code for a string. The purpose of this hashcode is to be constant independently of
+     * the JDK being used.
+     * @param str the string for which to compute the hashcode
+     * @return hashcode of the string
+     */
+    public static int hashCode(String str) {
+        final char[] chars = str.toCharArray();
+        int h = 0;
+        for (int i = 0; i < chars.length; i++) {
+            h = 31 * h + chars[i];
+        }
+        return h;
+    }
 }
diff --git a/src/main/org/codehaus/groovy/classgen/asm/InvocationWriter.java b/src/main/org/codehaus/groovy/classgen/asm/InvocationWriter.java
index 7ba3670e12..9e8cf407a5 100644
--- a/src/main/org/codehaus/groovy/classgen/asm/InvocationWriter.java
+++ b/src/main/org/codehaus/groovy/classgen/asm/InvocationWriter.java
@@ -16,16 +16,21 @@
 package org.codehaus.groovy.classgen.asm;
 
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.Comparator;
+import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.List;
+import java.util.TreeMap;
 
+import org.codehaus.groovy.GroovyBugError;
 import org.codehaus.groovy.ast.*;
 import org.codehaus.groovy.ast.expr.*;
 import org.codehaus.groovy.classgen.AsmClassGenerator;
 import org.codehaus.groovy.classgen.asm.OptimizingStatementWriter.StatementMeta;
 import org.codehaus.groovy.runtime.ScriptBytecodeAdapter;
+import org.codehaus.groovy.syntax.SyntaxException;
 import org.objectweb.asm.Label;
 import org.objectweb.asm.MethodVisitor;
 
@@ -635,29 +640,12 @@ public class InvocationWriter {
         // to select the constructor we need also the number of
         // available constructors and the class we want to make
         // the call on
-        BytecodeHelper.pushConstant(mv, constructors.size());
+        BytecodeHelper.pushConstant(mv, -1);
         controller.getAcg().visitClassExpression(new ClassExpression(callNode));
         operandStack.remove(1);
         // removes one Object[] leaves the int containing the
         // call flags and the constructor number
         selectConstructorAndTransformArguments.call(mv);
-        // Object[],int -> int,Object[],int
-        // we need to examine the flags and maybe change the
-        // Object[] later, so this reordering will do the job
-        mv.visitInsn(DUP_X1);
-        // test if rewrap flag is set
-        mv.visitInsn(ICONST_1);
-        mv.visitInsn(IAND);
-        Label afterIf = new Label();
-        mv.visitJumpInsn(IFEQ, afterIf);
-        // true part, so rewrap using the first argument
-        mv.visitInsn(ICONST_0);
-        mv.visitInsn(AALOAD);
-        mv.visitTypeInsn(CHECKCAST, "[Ljava/lang/Object;");
-        mv.visitLabel(afterIf);
-        // here the stack is int,Object[], but we need the
-        // the int for our table, so swap it
-        mv.visitInsn(SWAP);
         //load "this"
         if (controller.isConstructor()) {
             mv.visitVarInsn(ALOAD, 0);
@@ -665,15 +653,25 @@ public class InvocationWriter {
             mv.visitTypeInsn(NEW, BytecodeHelper.getClassInternalName(callNode));
         }
         mv.visitInsn(SWAP);
-        //prepare switch with >>8
-        mv.visitIntInsn(BIPUSH, 8);
-        mv.visitInsn(ISHR);
+        TreeMap<Integer,ConstructorNode> sortedConstructors = new TreeMap<Integer, ConstructorNode>();
+        for (ConstructorNode constructor : constructors) {
+            String typeDescriptor = BytecodeHelper.getMethodDescriptor(ClassHelper.VOID_TYPE, constructor.getParameters());
+            int hash = BytecodeHelper.hashCode(typeDescriptor);
+            ConstructorNode sameHashNode = sortedConstructors.put(hash, constructor);
+            if (sameHashNode!=null) {
+                controller.getSourceUnit().addError(
+                        new SyntaxException("Unable to compile class "+controller.getClassNode().getName() + " due to hash collision in constructors", call.getLineNumber(), call.getColumnNumber()));
+            }
+        }
         Label[] targets = new Label[constructors.size()];
         int[] indices = new int[constructors.size()];
+        Iterator<Integer> hashIt = sortedConstructors.keySet().iterator();
+        Iterator<ConstructorNode> constructorIt = sortedConstructors.values().iterator();
         for (int i = 0; i < targets.length; i++) {
             targets[i] = new Label();
-            indices[i] = i;
+            indices[i] = hashIt.next();
         }
+
         // create switch targets
         Label defaultLabel = new Label();
         Label afterSwitch = new Label();
@@ -704,7 +702,7 @@ public class InvocationWriter {
                 mv.visitInsn(POP);
             }
 
-            ConstructorNode cn = constructors.get(i);
+            ConstructorNode cn = constructorIt.next();
             String descriptor = BytecodeHelper.getMethodDescriptor(ClassHelper.VOID_TYPE, cn.getParameters());
             // unwrap the Object[] and make transformations if needed
             // that means, to duplicate the Object[], make a cast with possible
@@ -731,7 +729,7 @@ public class InvocationWriter {
         // this part should never be reached!
         mv.visitTypeInsn(NEW, "java/lang/IllegalArgumentException");
         mv.visitInsn(DUP);
-        mv.visitLdcInsn("illegal constructor number");
+        mv.visitLdcInsn("This class has been compiled with a super class which is binary incompatible with the current super class found on classpath. You should recompile this class with the new version.");
         mv.visitMethodInsn(INVOKESPECIAL, "java/lang/IllegalArgumentException", "<init>", "(Ljava/lang/String;)V");
         mv.visitInsn(ATHROW);
         mv.visitLabel(afterSwitch);
