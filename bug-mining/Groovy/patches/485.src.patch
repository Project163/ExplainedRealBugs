diff --git a/src/main/groovy/lang/Closure.java b/src/main/groovy/lang/Closure.java
index 5dae248c7b..ab191d4ad6 100644
--- a/src/main/groovy/lang/Closure.java
+++ b/src/main/groovy/lang/Closure.java
@@ -394,7 +394,7 @@ public abstract class Closure extends GroovyObjectSupport implements Cloneable,
      *   This has to be an inner class!
      * 
      * Reason: 
-     *   Closure.this.call will call the outer call method, bur
+     *   Closure.this.call will call the outer call method, but
      * with the inner class as executing object. This means any
      * invokeMethod or getProperty call will be called on this 
      * inner class instead of the outer!
@@ -446,16 +446,24 @@ public abstract class Closure extends GroovyObjectSupport implements Cloneable,
          * @see groovy.lang.Closure#call()
          */
         public Object call() {
-            return Closure.this.call();
+            return ((Closure) getOwner()).call();
         }
 
         /* (non-Javadoc)
          * @see groovy.lang.Closure#call(java.lang.Object)
          */
         public Object call(Object arguments) {
-            return Closure.this.call(arguments);
+            return ((Closure) getOwner()).call(arguments);
+        }
+        
+        public Object call(Object[] args) {
+            return ((Closure) getOwner()).call(args);
         }
 
+        public Object doCall(Object[] args) {
+            return call(args);
+        }
+        
         /* (non-Javadoc)
          * @see groovy.lang.Closure#getDelegate()
          */
diff --git a/src/main/groovy/lang/MetaClassImpl.java b/src/main/groovy/lang/MetaClassImpl.java
index b46e3de998..8e452dcca7 100644
--- a/src/main/groovy/lang/MetaClassImpl.java
+++ b/src/main/groovy/lang/MetaClassImpl.java
@@ -799,6 +799,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
                     final MetaClass ownerMetaClass = registry.getMetaClass(ownerClass);
                     return ownerMetaClass.invokeMethod(owner, methodName, curriedArguments);
                 }
+                if (method==null) invokeMissingMethod(object,methodName,arguments);
             } else if (CLOSURE_CURRY_METHOD.equals(methodName)) {
                 return closure.curry(arguments);
             }
@@ -2194,7 +2195,6 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
             return;
         }
         
-        Boolean bestMatch = null;
         Object data[] = list.getArray();
         for (int j = 0; j != len; ++j) {
             MetaMethod aMethod = (MetaMethod) data[j];
@@ -2203,17 +2203,15 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
             if (match==Boolean.TRUE) {
                 list.set(j, method);
                 return;
-            }
-
-            if (match==null) {
+            // null == ignore (we have a better method already)    
+            } else if (match==null) {
                 return;
             }
-
-            if (bestMatch==null) bestMatch=match;
         }
-        // false == add
-        if (bestMatch==Boolean.FALSE) list.add(method);
-        // only other value is null, which means to ignore that method
+        // the casese true and null for a match are through, the 
+        // remaining case is false and that means adding the method
+        // to our list
+        list.add(method);
     }
 
     private int findMatchingMethod(CachedMethod[] data, int from, int to, MetaMethod method) {
diff --git a/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java b/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
index 571d0e41aa..d3f02ddb36 100644
--- a/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
+++ b/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
@@ -421,7 +421,9 @@ public class AsmClassGenerator extends ClassGenerator {
         String methodType = BytecodeHelper.getMethodDescriptor(node.getReturnType(), parameters);
 
         String signature = BytecodeHelper.getGenericsMethodSignature(node);
-        mv = cv.visitMethod(node.getModifiers(), node.getName(), methodType, signature, buildExceptions(node.getExceptions()));
+        int modifiers = node.getModifiers();
+        if (isVargs(node.getParameters())) modifiers |= Opcodes.ACC_VARARGS;
+        mv = cv.visitMethod(modifiers, node.getName(), methodType, signature, buildExceptions(node.getExceptions()));
         visitAnnotations(node, mv);
         for (int i = 0; i < parameters.length; i++) {
             visitParameterAnnotations(parameters[i], i, mv);
@@ -463,6 +465,12 @@ public class AsmClassGenerator extends ClassGenerator {
         mv.visitEnd();
     }
 
+    private boolean isVargs(Parameter[] p) {
+        if (p.length==0) return false;
+        ClassNode clazz = p[p.length-1].getType();
+        return (clazz.isArray());
+    }
+
     public void visitConstructor(ConstructorNode node) {
         this.constructorNode = node;
         this.methodNode = null;
diff --git a/src/main/org/codehaus/groovy/reflection/ParameterTypes.java b/src/main/org/codehaus/groovy/reflection/ParameterTypes.java
index a8766d1a9a..ae90f7d975 100644
--- a/src/main/org/codehaus/groovy/reflection/ParameterTypes.java
+++ b/src/main/org/codehaus/groovy/reflection/ParameterTypes.java
@@ -147,15 +147,17 @@ public class ParameterTypes
             return newArgs;
         } else if (argumentArray.length == paramTypes.length) {
             // the number of arguments is correct, but if the last argument
-            // is no array we have to wrap it in a array. if the last argument
+            // is no array we have to wrap it in a array. If the last argument
             // is null, then we don't have to do anything
             Object lastArgument = argumentArray[argumentArray.length - 1];
             if (lastArgument != null && !lastArgument.getClass().isArray()) {
                 // no array so wrap it
-                Object vargs = MetaClassHelper.makeArray(lastArgument, vargsClass, 1);
-                System.arraycopy(argumentArray, argumentArray.length - 1, vargs, 0, 1);
-                argumentArray[argumentArray.length - 1] = vargs;
-                return argumentArray;
+                Object wrapped = MetaClassHelper.makeArray(lastArgument, vargsClass, 1);
+                System.arraycopy(argumentArray, argumentArray.length - 1, wrapped, 0, 1);
+                Object[] newArgs = new Object[paramTypes.length];
+                System.arraycopy(argumentArray, 0, newArgs, 0, paramTypes.length - 1);
+                newArgs[newArgs.length - 1] = wrapped;
+                return newArgs;
             } else {
                 // we may have to box the arguemnt!
                 return argumentArray;
diff --git a/src/main/org/codehaus/groovy/runtime/metaclass/ClosureMetaClass.java b/src/main/org/codehaus/groovy/runtime/metaclass/ClosureMetaClass.java
index f9b93a853b..15b5d7ee12 100644
--- a/src/main/org/codehaus/groovy/runtime/metaclass/ClosureMetaClass.java
+++ b/src/main/org/codehaus/groovy/runtime/metaclass/ClosureMetaClass.java
@@ -17,6 +17,7 @@
 package org.codehaus.groovy.runtime.metaclass;
 
 import groovy.lang.*;
+
 import org.codehaus.groovy.reflection.CachedClass;
 import org.codehaus.groovy.reflection.CachedField;
 import org.codehaus.groovy.reflection.CachedMethod;
@@ -235,6 +236,7 @@ public final class ClosureMetaClass extends MetaClassImpl {
                     };
                 }
             }
+            if (method==null) throw new MissingMethodException(methodName, theClass, arguments, false);
         } else if (CLOSURE_CURRY_METHOD.equals(methodName)) {
             return closure.curry(arguments);
         } else {
diff --git a/src/test/groovy/bugs/Groovy2339Bug.groovy b/src/test/groovy/bugs/Groovy2339Bug.groovy
new file mode 100644
index 0000000000..db3a91e646
--- /dev/null
+++ b/src/test/groovy/bugs/Groovy2339Bug.groovy
@@ -0,0 +1,17 @@
+package groovy.bugs
+
+class Groovy2339Bug extends GroovyTestCase {
+
+    void testBug () {
+        List list = ['groovy', 'java']
+        Map map = [a: 1, b: 2]
+        
+		shouldFail (MissingMethodException) {
+	        list.each {
+	            map.keySet().each {Date d ->
+	                println d
+	            }
+	        }
+        }
+    }
+}
\ No newline at end of file
