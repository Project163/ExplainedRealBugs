diff --git a/gradle/pomconfigurer.gradle b/gradle/pomconfigurer.gradle
index 10fad56d3f..d4b2cfe3fa 100644
--- a/gradle/pomconfigurer.gradle
+++ b/gradle/pomconfigurer.gradle
@@ -442,6 +442,9 @@ project.pomConfigureClosure = {
             contributor {
                 name 'Adam Murdoch'
             }
+            contributor {
+                name 'Cdric Champeau'
+            }
         }
         mailingLists {
             mailingList {
diff --git a/pom.xml b/pom.xml
index 9643e45005..6924a6ffbb 100644
--- a/pom.xml
+++ b/pom.xml
@@ -556,6 +556,10 @@
             <name>Adam Murdoch</name>
             <email></email>
         </contributor>
+        <contributor>
+            <name>CÃ©dric Champeau</name>
+            <email></email>
+        </contributor>
     </contributors>
 
     <dependencies>
diff --git a/src/main/org/codehaus/groovy/transform/FieldASTTransformation.java b/src/main/org/codehaus/groovy/transform/FieldASTTransformation.java
index 81e8a8229f..947a850a99 100644
--- a/src/main/org/codehaus/groovy/transform/FieldASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/FieldASTTransformation.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2010 the original author or authors.
+ * Copyright 2008-2011 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -19,22 +19,26 @@ package org.codehaus.groovy.transform;
 import groovy.transform.Field;
 import org.codehaus.groovy.GroovyBugError;
 import org.codehaus.groovy.ast.*;
-import org.codehaus.groovy.ast.expr.ArgumentListExpression;
+import org.codehaus.groovy.ast.expr.BinaryExpression;
+import org.codehaus.groovy.ast.expr.ClosureExpression;
 import org.codehaus.groovy.ast.expr.ConstantExpression;
 import org.codehaus.groovy.ast.expr.DeclarationExpression;
 import org.codehaus.groovy.ast.expr.Expression;
 import org.codehaus.groovy.ast.expr.VariableExpression;
+import org.codehaus.groovy.ast.stmt.ExpressionStatement;
 import org.codehaus.groovy.control.CompilePhase;
 import org.codehaus.groovy.control.SourceUnit;
 import org.objectweb.asm.Opcodes;
 
 import java.util.Arrays;
+import java.util.Iterator;
 
 /**
  * Handles transformation for the @Field annotation.
  * This is experimental, use at your own risk.
  *
  * @author Paul King
+ * @author Cdric Champeau
  */
 @GroovyASTTransformation(phase = CompilePhase.SEMANTIC_ANALYSIS)
 public class FieldASTTransformation extends ClassCodeExpressionTransformer implements ASTTransformation, Opcodes {
@@ -45,6 +49,9 @@ public class FieldASTTransformation extends ClassCodeExpressionTransformer imple
     private SourceUnit sourceUnit;
     private DeclarationExpression candidate;
     private boolean insideScriptBody;
+    private String variableName;
+    private FieldNode fieldNode;
+    private ClosureExpression currentClosure;
 
     public void visit(ASTNode[] nodes, SourceUnit source) {
         sourceUnit = source;
@@ -64,20 +71,22 @@ public class FieldASTTransformation extends ClassCodeExpressionTransformer imple
                 return;
             }
             candidate = de;
-            super.visitClass(cNode);
             // GROOVY-4548: temp fix to stop CCE until proper support is added
             if (de.isMultipleAssignmentDeclaration()) {
                 addError("Error: annotation " + MY_TYPE_NAME + " not supported with multiple assignment notation.", parent);
                 return;
             }
             VariableExpression ve = de.getVariableExpression();
+            variableName = ve.getName();
             // set owner null here, it will be updated by addField
-            FieldNode fNode = new FieldNode(ve.getName(), ve.getModifiers(), ve.getType(), null, de.getRightExpression());
-            fNode.setSourcePosition(de);
-            cNode.addField(fNode);
+            fieldNode = new FieldNode(variableName, ve.getModifiers(), ve.getType(), null, de.getRightExpression());
+            fieldNode.setSourcePosition(de);
+            cNode.addField(fieldNode);
+            super.visitClass(cNode);
         }
     }
 
+    @Override
     public Expression transform(Expression expr) {
         if (expr == null) return null;
         if (expr instanceof DeclarationExpression) {
@@ -92,10 +101,34 @@ public class FieldASTTransformation extends ClassCodeExpressionTransformer imple
                 addError("Error: annotation " + MY_TYPE_NAME + " can only be used within a Script body.", expr);
                 return expr;
             }
+        } else if (insideScriptBody && expr instanceof VariableExpression && currentClosure != null) {
+            VariableExpression ve = (VariableExpression) expr;
+            if (ve.getName().equals(variableName)) {
+                // we may only check the variable name because the Groovy compiler
+                // already fails if a variable with the same name already exists in the scope.
+                // this means that a closure cannot shadow a class variable
+                ve.setAccessedVariable(fieldNode);
+                final VariableScope variableScope = currentClosure.getVariableScope();
+                final Iterator<Variable> iterator = variableScope.getReferencedLocalVariablesIterator();
+                while (iterator.hasNext()) {
+                    Variable next = iterator.next();
+                    if (next.getName().equals(variableName)) iterator.remove();
+                }
+                variableScope.putReferencedClassVariable(fieldNode);
+                return ve;
+            }
         }
         return expr.transformExpression(this);
     }
 
+    @Override
+    public void visitClosureExpression(final ClosureExpression expression) {
+        ClosureExpression old = currentClosure;
+        currentClosure = expression;
+        super.visitClosureExpression(expression);
+        currentClosure = old;
+    }
+
     @Override
     public void visitMethod(MethodNode node) {
         Boolean oldInsideScriptBody = insideScriptBody;
@@ -104,6 +137,15 @@ public class FieldASTTransformation extends ClassCodeExpressionTransformer imple
         insideScriptBody = oldInsideScriptBody;
     }
 
+    @Override
+    public void visitExpressionStatement(ExpressionStatement es) {
+        Expression exp = es.getExpression();
+        if (exp instanceof BinaryExpression) {
+            exp.visit(this);
+        }
+        super.visitExpressionStatement(es);
+    }
+
     protected SourceUnit getSourceUnit() {
         return sourceUnit;
     }
diff --git a/src/test/org/codehaus/groovy/transform/FieldTransformTest.groovy b/src/test/org/codehaus/groovy/transform/FieldTransformTest.groovy
index 5bfcb6ac6e..9d1257e7e0 100644
--- a/src/test/org/codehaus/groovy/transform/FieldTransformTest.groovy
+++ b/src/test/org/codehaus/groovy/transform/FieldTransformTest.groovy
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2010 the original author or authors.
+ * Copyright 2008-2011 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -19,6 +19,7 @@ import gls.CompilableTestSupport
 
 /**
  * @author Paul King
+ * @author Cdric Champeau
  */
 class FieldTransformTest extends CompilableTestSupport {
 
@@ -140,4 +141,34 @@ class FieldTransformTest extends CompilableTestSupport {
         """
     }
 
+    void testFieldShouldBeAccessibleFromClosure() {
+        assertScript """
+            import groovy.transform.Field
+            @Field int x
+            def closure = { x = 1; x }
+            assert closure() == 1
+        """
+    }
+
+    void testFieldShouldBeAccessibleFromClosureWithoutAssignment() {
+        // GROOVY-4700
+        assertScript """import groovy.transform.Field
+            @Field xxx = 3
+            def foo = {
+                xxx + 1
+            }
+            assert foo() == 4
+        """
+    }
+
+    void testStaticFieldShouldBeAccessibleFromClosure() {
+        assertScript """
+            import groovy.transform.Field
+            @Field static int x
+            x = 10
+            def closure = { x * 2 }
+            assert closure() == 20
+        """
+    }
+
 }
\ No newline at end of file
