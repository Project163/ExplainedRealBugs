diff --git a/src/main/groovy/lang/MetaClassImpl.java b/src/main/groovy/lang/MetaClassImpl.java
index 65413cc04e..816aff049b 100644
--- a/src/main/groovy/lang/MetaClassImpl.java
+++ b/src/main/groovy/lang/MetaClassImpl.java
@@ -2725,6 +2725,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
         }
 
         FastArray methods = (FastArray) methodOrList;
+        if (methods==null) return null;
         int methodCount = methods.size();
         if (methodCount <= 0) {
             return null;
diff --git a/src/main/org/codehaus/groovy/classgen/ClassCompletionVerifier.java b/src/main/org/codehaus/groovy/classgen/ClassCompletionVerifier.java
index 5616a17e7d..fd35a64269 100644
--- a/src/main/org/codehaus/groovy/classgen/ClassCompletionVerifier.java
+++ b/src/main/org/codehaus/groovy/classgen/ClassCompletionVerifier.java
@@ -70,7 +70,6 @@ public class ClassCompletionVerifier extends ClassCodeVisitorSupport {
         if (abstractMethods == null) return;
         for (Iterator iter = abstractMethods.iterator(); iter.hasNext();) {
             MethodNode method = (MethodNode) iter.next();
-            String methodName = method.getTypeDescriptor();
             addError("Can't have an abstract method in a non-abstract class." +
                     " The " + getDescription(node) + " must be declared abstract or" +
                     " the " + getDescription(method) + " must be implemented.", node);
diff --git a/src/main/org/codehaus/groovy/runtime/metaclass/ClosureMetaClass.java b/src/main/org/codehaus/groovy/runtime/metaclass/ClosureMetaClass.java
index 8220d41cf4..1b27176cd2 100644
--- a/src/main/org/codehaus/groovy/runtime/metaclass/ClosureMetaClass.java
+++ b/src/main/org/codehaus/groovy/runtime/metaclass/ClosureMetaClass.java
@@ -17,6 +17,7 @@
 package org.codehaus.groovy.runtime.metaclass;
 
 import groovy.lang.*;
+
 import org.codehaus.groovy.reflection.*;
 import org.codehaus.groovy.runtime.InvokerHelper;
 import org.codehaus.groovy.runtime.MetaClassHelper;
@@ -30,7 +31,7 @@ import java.lang.reflect.Method;
 import java.util.*;
 
 /**
- * A Metaclass for closures generated by the Groovy compiler. These classes
+ * A meta class for closures generated by the Groovy compiler. These classes
  * have special characteristics this MetaClass uses. One of these is that a
  * generated Closure has only additional doCall methods, all other methods
  * are in the Closure class as well. To use this fact this MetaClass uses
@@ -38,7 +39,7 @@ import java.util.*;
  * MetaClass if needed. This allows a lean implementation for this MetaClass.
  * Multiple generated closures will then use the same MetaClass for Closure.
  * For static dispatching this class uses the MetaClass of Class, again
- * all isntances of this class will share that MetaClass. The Class MetaClass
+ * all instances of this class will share that MetaClass. The Class MetaClass
  * is initialized lazy, because most operations do not need this MetaClass.
  * <p/>
  * The Closure and Class MetaClasses are not replaceable.
@@ -382,6 +383,13 @@ public final class ClosureMetaClass extends MetaClassImpl {
         }
         return arguments;
     }
+    
+    private static Throwable unwrap(GroovyRuntimeException gre) {
+        Throwable th = gre;
+        if (th.getCause() != null && th.getCause() != gre) th = th.getCause();
+        if (th != gre && (th instanceof GroovyRuntimeException)) return unwrap((GroovyRuntimeException) th);
+        return th;
+    }
 
     private Object invokeOnDelegationObjects(
             boolean invoke1, Object o1,
@@ -394,6 +402,13 @@ public final class ClosureMetaClass extends MetaClassImpl {
                 return go.invokeMethod(methodName, args);
             } catch (MissingMethodException mme) {
                 first = mme;
+            } catch (GroovyRuntimeException gre) {
+                Throwable th = unwrap(gre);
+                if (th instanceof MissingMethodException) {
+                    first = (MissingMethodException) th;
+                } else {
+                    throw gre;
+                }
             }
         }
         if (invoke2) {
@@ -402,6 +417,13 @@ public final class ClosureMetaClass extends MetaClassImpl {
                 return go.invokeMethod(methodName, args);
             } catch (MissingMethodException mme) {
                 if (first == null) first = mme;
+            } catch (GroovyRuntimeException gre) {
+                Throwable th = unwrap(gre);
+                if (th instanceof MissingMethodException) {
+                    first = (MissingMethodException) th;
+                } else {
+                    throw gre;
+                }
             }
         }
         throw first;
diff --git a/src/main/org/codehaus/groovy/runtime/metaclass/MemoryAwareConcurrentReadMap.java b/src/main/org/codehaus/groovy/runtime/metaclass/MemoryAwareConcurrentReadMap.java
index 0311712088..5ba7a9be5d 100644
--- a/src/main/org/codehaus/groovy/runtime/metaclass/MemoryAwareConcurrentReadMap.java
+++ b/src/main/org/codehaus/groovy/runtime/metaclass/MemoryAwareConcurrentReadMap.java
@@ -36,7 +36,7 @@ import java.lang.ref.SoftReference;
 
 
 /**
- * This Map is astripped down version of ConcurrentReaderHashMap with
+ * This Map is a stripped down version of ConcurrentReaderHashMap with
  * small modifications here and there.
  * It is no full Map, it does have put/get/remove, but no iterators.
  * This map is intended to hold values and keys as SoftReference. If
diff --git a/src/test/gls/invocation/ClosureDelegationTest.groovy b/src/test/gls/invocation/ClosureDelegationTest.groovy
new file mode 100644
index 0000000000..1c1f6f425d
--- /dev/null
+++ b/src/test/gls/invocation/ClosureDelegationTest.groovy
@@ -0,0 +1,90 @@
+package gls.invocation
+
+import gls.scope.CompilableTestSupport
+
+public class ClosureDelegationTest extends CompilableTestSupport {
+
+    public void testMissingMethodMissingMethod() {
+      assertScript """
+class A {
+  def methodMissing(String name, args) {
+     "A" 
+  }
+}
+
+def methodMissing(String name, args) {
+  visited=true
+  throw new MissingMethodException(name,this.class,args)
+}
+
+visited=false
+def closure = { foo() }
+closure.delegate = new A()
+assert closure() == "A"
+assert visited==true
+        """
+    }
+
+    public void testInvokeMethodMissingMethod() {
+      assertScript """
+class A {
+  def invokeMethod(String name, args) {
+     "A" 
+  }
+}
+
+def methodMissing(String name, args) {
+  visited=true
+  throw new MissingMethodException(name,this.class,args)
+}
+
+visited=false
+def closure = { foo() }
+closure.delegate = new A()
+assert closure() == "A"
+assert visited==true
+        """
+    }
+    
+    public void testMissingMethodInvokeMethod() {
+      assertScript """
+class A {
+  def methodMissing(String name, args) {
+     "A" 
+  }
+}
+
+def invokeMethod(String name, args) {
+  visited=true
+  throw new MissingMethodException(name,this.class,args)
+}
+
+visited=false
+def closure = { foo() }
+closure.delegate = new A()
+assert closure() == "A"
+assert visited==true
+        """
+    }
+    
+    public void testInvokeMethodInvokeMethod() {
+      assertScript """
+class A {
+  def invokeMethod(String name, args) {
+     "A" 
+  }
+}
+
+def invokeMethod(String name, args) {
+  visited=true
+  throw new MissingMethodException(name,this.class,args)
+}
+
+visited=false
+def closure = { foo() }
+closure.delegate = new A()
+assert closure() == "A"
+assert visited==true
+        """
+    }
+}
\ No newline at end of file
