diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 7114479c6c..d8423541a3 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -721,6 +721,11 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
     @Override
     public void visitForLoop(final ForStatement forLoop) {
+        // collect every variable expression used in the loop body
+        final Map<VariableExpression, ClassNode> varOrigType = new HashMap<VariableExpression, ClassNode>();
+        forLoop.getLoopBlock().visit(new VariableExpressionTypeMemoizer(varOrigType));
+        
+        // visit body
         Map<VariableExpression, List<ClassNode>> oldTracker = pushAssignmentTracking();
         final ClassNode collectionType = getType(forLoop.getCollectionExpression());
         ClassNode componentType = collectionType.getComponentType();
@@ -744,7 +749,23 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         } finally {
             forLoopVariableTypes.remove(forLoop.getVariable());
         }
-        popAssignmentTracking(oldTracker);
+        boolean typeChanged = isSecondPassNeededForControlStructure(varOrigType, oldTracker);
+        if (typeChanged) visitForLoop(forLoop);
+    }
+
+    private boolean isSecondPassNeededForControlStructure(final Map<VariableExpression, ClassNode> varOrigType, final Map<VariableExpression, List<ClassNode>> oldTracker) {
+        Map<VariableExpression, ClassNode> assignedVars = popAssignmentTracking(oldTracker);
+        for (Map.Entry<VariableExpression, ClassNode> entry : assignedVars.entrySet()) {
+            Variable key = findTargetVariable(entry.getKey());
+            if (key instanceof VariableExpression) {
+                ClassNode origType = varOrigType.get((VariableExpression)key);
+                ClassNode newType = entry.getValue();
+                if (varOrigType.containsKey(key) && (origType==null || !newType.equals(origType))) {
+                    return true;
+                }
+            }
+        }
+        return false;
     }
 
     @Override
@@ -924,34 +945,44 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
     @Override
     public void visitClosureExpression(final ClosureExpression expression) {
-		// first, collect closure shared variables and reinitialize types
-		SharedVariableCollector collector = new SharedVariableCollector(getSourceUnit());
-		collector.visitClosureExpression(expression);
-		Set<VariableExpression> closureSharedExpressions = collector.getClosureSharedExpressions();
-		Map<VariableExpression, ListHashMap> typesBeforeVisit = null;
-		if (!closureSharedExpressions.isEmpty()) {
-			typesBeforeVisit = new HashMap<VariableExpression, ListHashMap>();
-			saveVariableExpressionMetadata(closureSharedExpressions, typesBeforeVisit);
-		}
+        // collect every variable expression used in the loop body
+        final Map<VariableExpression, ClassNode> varOrigType = new HashMap<VariableExpression, ClassNode>();
+        Statement code = expression.getCode();
+        code.visit(new VariableExpressionTypeMemoizer(varOrigType));
+
+        Map<VariableExpression, List<ClassNode>> oldTracker = pushAssignmentTracking();
 
-		// perform visit
+        // first, collect closure shared variables and reinitialize types
+        SharedVariableCollector collector = new SharedVariableCollector(getSourceUnit());
+        collector.visitClosureExpression(expression);
+        Set<VariableExpression> closureSharedExpressions = collector.getClosureSharedExpressions();
+        Map<VariableExpression, ListHashMap> typesBeforeVisit = null;
+        if (!closureSharedExpressions.isEmpty()) {
+            typesBeforeVisit = new HashMap<VariableExpression, ListHashMap>();
+            saveVariableExpressionMetadata(closureSharedExpressions, typesBeforeVisit);
+        }
+
+        // perform visit
         ClosureExpression oldClosureExpr = closureExpression;
         List<ClassNode> oldClosureReturnTypes = closureReturnTypes;
         closureExpression = expression;
         super.visitClosureExpression(expression);
-        MethodNode node = new MethodNode("dummy", 0, ClassHelper.OBJECT_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, expression.getCode());
+        MethodNode node = new MethodNode("dummy", 0, ClassHelper.OBJECT_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, code);
         closureReturnAdder.visitMethod(node);
 
-        if (closureReturnTypes!=null) {
+        if (closureReturnTypes != null) {
             expression.putNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE, lowestUpperBound(closureReturnTypes));
         }
 
         closureExpression = oldClosureExpr;
         closureReturnTypes = oldClosureReturnTypes;
-		
-		// restore original metadata
-		restoreVariableExpressionMetadata(typesBeforeVisit);
-	}
+
+        boolean typeChanged = isSecondPassNeededForControlStructure(varOrigType, oldTracker);
+        if (typeChanged) visitClosureExpression(expression);
+
+        // restore original metadata
+        restoreVariableExpressionMetadata(typesBeforeVisit);
+    }
 
 	private void restoreVariableExpressionMetadata(final Map<VariableExpression, ListHashMap> typesBeforeVisit) {
 		if (typesBeforeVisit!=null) {
@@ -1386,13 +1417,18 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         }
     }
 
-    private void popAssignmentTracking(final Map<VariableExpression, List<ClassNode>> oldTracker) {
+    private Map<VariableExpression, ClassNode> popAssignmentTracking(final Map<VariableExpression, List<ClassNode>> oldTracker) {
+        Map<VariableExpression, ClassNode> assignments = new HashMap<VariableExpression, ClassNode>();
         if (!ifElseForWhileAssignmentTracker.isEmpty()) {
             for (Map.Entry<VariableExpression, List<ClassNode>> entry : ifElseForWhileAssignmentTracker.entrySet()) {
-                storeType(entry.getKey(), lowestUpperBound(entry.getValue()));
+                VariableExpression key = entry.getKey();
+                ClassNode cn = lowestUpperBound(entry.getValue());
+                storeType(key, cn);
+                assignments.put(key, cn);
             }
         }
         ifElseForWhileAssignmentTracker = oldTracker;
+        return assignments;
     }
 
     private Map<VariableExpression, List<ClassNode>> pushAssignmentTracking() {
@@ -2188,4 +2224,27 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             result.set(field.getType());
         }
     }
+
+    private class VariableExpressionTypeMemoizer extends ClassCodeVisitorSupport {
+        private final Map<VariableExpression, ClassNode> varOrigType;
+
+        public VariableExpressionTypeMemoizer(final Map<VariableExpression, ClassNode> varOrigType) {
+            this.varOrigType = varOrigType;
+        }
+
+        @Override
+        protected SourceUnit getSourceUnit() {
+            return source;
+        }
+
+        @Override
+        public void visitVariableExpression(final VariableExpression expression) {
+            super.visitVariableExpression(expression);
+            Variable var = findTargetVariable(expression);
+            if (var instanceof VariableExpression) {
+                VariableExpression ve = (VariableExpression) var;
+                varOrigType.put(ve, (ClassNode) ve.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE));
+            }
+        }
+    }
 }
diff --git a/src/test/groovy/transform/stc/LoopsSTCTest.groovy b/src/test/groovy/transform/stc/LoopsSTCTest.groovy
new file mode 100644
index 0000000000..5cb26cad8b
--- /dev/null
+++ b/src/test/groovy/transform/stc/LoopsSTCTest.groovy
@@ -0,0 +1,111 @@
+/*
+ * Copyright 2003-2010 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package groovy.transform.stc
+
+/**
+ * Unit tests for static type checking : loops.
+ *
+ * @author Cedric Champeau
+ */
+class LoopsSTCTest extends StaticTypeCheckingTestCase {
+
+    void testMethodCallInLoop() {
+        assertScript '''
+            int foo(int x) { x+1 }
+            int x = 0
+            for (int i=0;i<10;i++) {
+                x = foo(x)
+            }
+        '''
+    }
+
+    void testMethodCallInLoopAndDef() {
+        assertScript '''
+            int foo(int x) { x+1 }
+            def x = 0
+            for (int i=0;i<10;i++) {
+                x = foo(x)
+            }
+        '''
+    }
+
+
+    void testMethodCallWithEachAndDefAndTwoFooMethods() {
+        shouldFailWithMessages '''
+            Double foo(Integer x) { x+1 }
+            Integer foo(Double x) { x+1 }
+            def x = 0
+            10.times {
+                 // there are two possible target methods. This is not a problem for STC, but it is for static compilation
+                x = foo(x)
+            }
+        ''', 'Cannot find matching method'
+    }
+
+    void testMethodCallInLoopAndDefAndTwoFooMethods() {
+        shouldFailWithMessages '''
+            Double foo(Integer x) { x+1 }
+            Integer foo(Double x) { x+1 }
+            def x = 0
+            for (int i=0;i<10;i++) {
+                 // there are two possible target methods. This is not a problem for STC, but it is for static compilation
+                x = foo(x)
+            }
+        ''', 'Cannot find matching method'
+    }
+
+    void testMethodCallInLoopAndDefAndTwoFooMethodsAndOneWithBadType() {
+        shouldFailWithMessages '''
+            Double foo(Integer x) { x+1 }
+            Date foo(Double x) { new Date((long)x) }
+            def x = 0
+            for (int i=0;i<10;i++) {
+                // there are two possible target methods and one returns a type which is assigned to 'x'
+                // then called in turn as a parameter of foo(). There's no #foo(Date)
+                x = foo(x)
+            }
+        ''', 'Cannot find matching method'
+    }
+
+    void testMethodCallInLoopAndDefAndTwoFooMethodsAndOneWithBadTypeAndIndirection() {
+        shouldFailWithMessages '''
+            Double foo(Integer x) { x+1 }
+            Date foo(Double x) { new Date((long)x) }
+            def x = 0
+            for (int i=0;i<10;i++) {
+                def y = foo(x)
+                // there are two possible target methods and one returns a type which is assigned to 'x'
+                // then called in turn as a parameter of foo(). There's no #foo(Date)
+                x = y
+            }
+        ''', 'Cannot find matching method'
+    }
+
+    void testMethodCallWithEachAndDefAndTwoFooMethodsAndOneWithBadTypeAndIndirection() {
+        shouldFailWithMessages '''
+            Double foo(Integer x) { x+1 }
+            Date foo(Double x) { new Date((long)x) }
+            def x = 0
+            10.times {
+                def y = foo(x)
+                // there are two possible target methods and one returns a type which is assigned to 'x'
+                // then called in turn as a parameter of foo(). There's no #foo(Date)
+                x = y
+            }
+        ''', 'Cannot find matching method'
+    }
+}
+
