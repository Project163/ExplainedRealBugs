diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
index 0ad8da2459..f252b76f70 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
@@ -1446,7 +1446,7 @@ public abstract class StaticTypeCheckingSupport {
 
     private static GenericsType buildWildcardType(GenericsType origin) {
         ClassNode lowerBound = origin.getType().getPlainNodeReference();
-        if (hasBounds(origin)) {
+        if (hasNonTrivialBounds(origin)) {
             lowerBound.setGenericsTypes(new GenericsType[]{origin});
         }
         ClassNode base = makeWithoutCaching("?");
@@ -1461,7 +1461,7 @@ public abstract class StaticTypeCheckingSupport {
             GenericsType resolved = resolvedMethodGenerics.get(entry.getKey());
             if (resolved==null) continue;
             GenericsType connection = entry.getValue();
-            if (connection.isPlaceholder() && !hasBounds(connection)) {
+            if (connection.isPlaceholder() && !hasNonTrivialBounds(connection)) {
                 continue;
             }
             if (!compatibleConnection(resolved,connection)) {
@@ -1492,7 +1492,7 @@ public abstract class StaticTypeCheckingSupport {
             return true;
         }
         ClassNode compareNode;
-        if (hasBounds(resolved)) {
+        if (hasNonTrivialBounds(resolved)) {
             compareNode = getCombinedBoundType(resolved);
             compareNode = compareNode.redirect().getPlainNodeReference();
         } else {
@@ -1753,7 +1753,7 @@ public abstract class StaticTypeCheckingSupport {
             String name = gt.getName();
             GenericsType specType = spec.get(name);
             if (specType!=null) return specType;
-            if (hasBounds(gt)) {
+            if (hasNonTrivialBounds(gt)) {
                 GenericsType newGT = new GenericsType(gt.getType(), applyGenericsContext(spec, gt.getUpperBounds()), applyGenericsContext(spec, gt.getLowerBound()));
                 newGT.setPlaceholder(true);
                 return newGT;
@@ -1773,8 +1773,13 @@ public abstract class StaticTypeCheckingSupport {
         return newGT;
     }
 
-    private static boolean hasBounds(GenericsType gt) {
-        return gt.getLowerBound() != null || gt.getUpperBounds() != null;
+    private static boolean hasNonTrivialBounds(GenericsType gt) {
+        ClassNode[] upperBounds = gt.getUpperBounds();
+        return gt.getLowerBound() != null || gt.isWildcard() ||
+                (upperBounds != null && (
+                        upperBounds.length != 1
+                                || upperBounds[0].isGenericsPlaceHolder()
+                                || !OBJECT_TYPE.equals(upperBounds[0])));
     }
 
     private static ClassNode[] applyGenericsContext(
@@ -1800,7 +1805,7 @@ public abstract class StaticTypeCheckingSupport {
         newBound.setGenericsTypes(applyGenericsContext(spec, bound.getGenericsTypes()));
         if (bound.isGenericsPlaceHolder()) {
             GenericsType[] gt= newBound.getGenericsTypes();
-            boolean hasBounds = hasBounds(gt[0]);
+            boolean hasBounds = hasNonTrivialBounds(gt[0]);
             if (hasBounds || !gt[0].isPlaceholder()) return getCombinedBoundType(gt[0]);
             String placeHolderName = newBound.getGenericsTypes()[0].getName();
             if (!placeHolderName.equals(newBound.getUnresolvedName())) {
@@ -1819,7 +1824,7 @@ public abstract class StaticTypeCheckingSupport {
         //TODO: this method should really return some kind of meta ClassNode
         // representing the combination of all bounds. The code here, just picks
         // something out to be able to proceed and is not actually correct
-        if (hasBounds(genericsType)) {
+        if (hasNonTrivialBounds(genericsType)) {
             if (genericsType.getLowerBound()!=null) return genericsType.getLowerBound();
             if (genericsType.getUpperBounds()!=null) return genericsType.getUpperBounds()[0];
         }
diff --git a/src/test/groovy/transform/stc/Groovy7907Bug.groovy b/src/test/groovy/transform/stc/Groovy7907Bug.groovy
new file mode 100644
index 0000000000..3114bb2144
--- /dev/null
+++ b/src/test/groovy/transform/stc/Groovy7907Bug.groovy
@@ -0,0 +1,41 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package groovy.transform.stc
+
+class Groovy7907Bug extends StaticTypeCheckingTestCase {
+    void testPlaceholdersInPrecompiledBinariesShouldBeHonored() {
+        assertScript '''
+            import groovy.transform.stc.*
+
+            def method() {
+                Ext create1 = new Groovy7907HelperPrecompiledJava().create(Ext)
+                Ext create2 = new Groovy7907HelperPrecompiledGroovy().create(Ext)
+                Ext create3 = new Groovy7907Helper().create(Ext)
+            }
+
+            class Groovy7907Helper {
+                public <T extends Object> T create(Class<T> type, Object... args) { null }
+            }
+
+            class Ext {}
+
+            method()
+        '''
+    }
+}
diff --git a/src/test/groovy/transform/stc/Groovy7907HelperPrecompiledGroovy.groovy b/src/test/groovy/transform/stc/Groovy7907HelperPrecompiledGroovy.groovy
new file mode 100644
index 0000000000..e369aeff3a
--- /dev/null
+++ b/src/test/groovy/transform/stc/Groovy7907HelperPrecompiledGroovy.groovy
@@ -0,0 +1,23 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package groovy.transform.stc
+
+class Groovy7907HelperPrecompiledGroovy {
+    public <T> T create(Class<T> type, Object... args) { null }
+}
\ No newline at end of file
diff --git a/src/test/groovy/transform/stc/Groovy7907HelperPrecompiledJava.java b/src/test/groovy/transform/stc/Groovy7907HelperPrecompiledJava.java
new file mode 100644
index 0000000000..b63dfeb575
--- /dev/null
+++ b/src/test/groovy/transform/stc/Groovy7907HelperPrecompiledJava.java
@@ -0,0 +1,23 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package groovy.transform.stc;
+
+public class Groovy7907HelperPrecompiledJava {
+    public <T> T create(Class<T> type, Object... args) { return null; }
+}
