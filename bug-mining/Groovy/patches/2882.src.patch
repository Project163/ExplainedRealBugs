diff --git a/src/main/groovy/lang/ExpandoMetaClass.java b/src/main/groovy/lang/ExpandoMetaClass.java
index c5b3efaeef..d0670a8e96 100644
--- a/src/main/groovy/lang/ExpandoMetaClass.java
+++ b/src/main/groovy/lang/ExpandoMetaClass.java
@@ -1307,6 +1307,8 @@ public class ExpandoMetaClass extends MetaClassImpl implements GroovyObject {
         return super.createStaticSite(site, args);
     }
 
+    public boolean hasCustomStaticInvokeMethod() {return invokeStaticMethodMethod!=null; }
+
     public CallSite createPogoCallSite(CallSite site, Object[] args) {
         if (invokeMethodMethod != null)
             return new PogoMetaClassSite(site, this);
diff --git a/src/main/groovy/lang/MetaClassImpl.java b/src/main/groovy/lang/MetaClassImpl.java
index 2630fa87ba..31e70b5467 100644
--- a/src/main/groovy/lang/MetaClassImpl.java
+++ b/src/main/groovy/lang/MetaClassImpl.java
@@ -3786,6 +3786,22 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
         return getMethodWithoutCaching(theClass, methodName, arguments, false);
     }
 
+    /**
+     * indicates is the meta class method invocation for non-static methods is done
+     * through a custom invoker object.
+     *
+     * @return true - if the method invocation is not done by the meta class itself
+     */
+    public boolean hasCustomInvokeMethod() {return invokeMethodMethod!=null; }
+
+    /**
+     * indicates is the meta class method invocation for static methods is done
+     * through a custom invoker object.
+     *
+     * @return true - if the method invocation is not done by the meta class itself
+     */
+    public boolean hasCustomStaticInvokeMethod() {return false; }
+
     /**
      * remove all method call cache entries. This should be done if a
      * method is added during runtime, but not by using a category.
diff --git a/src/main/org/codehaus/groovy/vmplugin/v7/Selector.java b/src/main/org/codehaus/groovy/vmplugin/v7/Selector.java
index 2c5f51957b..8ab4521998 100644
--- a/src/main/org/codehaus/groovy/vmplugin/v7/Selector.java
+++ b/src/main/org/codehaus/groovy/vmplugin/v7/Selector.java
@@ -550,11 +550,11 @@ public abstract class Selector {
             Object[] newArgs = removeRealReceiver(args);
             if (receiver instanceof Class) {
                 if (LOG_ENABLED) LOG.info("receiver is a class");
-                method = mci.retrieveStaticMethod(name, newArgs);
+                if (!mci.hasCustomStaticInvokeMethod()) method = mci.retrieveStaticMethod(name, newArgs);
             } else {
                 String changedName = name;
                 if (receiver instanceof GeneratedClosure && changedName.equals("call")) {changedName = "doCall";}
-                method = mci.getMethodWithCaching(selectionBase, changedName, newArgs, false);
+                if (!mci.hasCustomInvokeMethod()) method = mci.getMethodWithCaching(selectionBase, changedName, newArgs, false);
             }
             if (LOG_ENABLED) LOG.info("retrieved method from meta class: "+method);
         }
diff --git a/src/test/groovy/lang/ExpandoMetaClassTest.groovy b/src/test/groovy/lang/ExpandoMetaClassTest.groovy
index 948f09a17d..8d22593942 100644
--- a/src/test/groovy/lang/ExpandoMetaClassTest.groovy
+++ b/src/test/groovy/lang/ExpandoMetaClassTest.groovy
@@ -821,6 +821,35 @@ class ExpandoMetaClassTest extends GroovyTestCase {
           }
         """
     }
+
+    static class X {
+        def foo() {2}
+    }
+
+    void testPOJOMetaClassInterception() {
+        String invoking = 'ha'
+        try {
+            invoking.metaClass.invokeMethod = { String name, Object args ->
+                'invoked'
+            }
+            assert invoking.length() == 'invoked'
+            assert invoking.someMethod() == 'invoked'
+        } finally {
+            invoking.metaClass = null
+        }
+    }
+    void testPOGOMetaClassInterception() {
+        X entity = new X()
+        try {
+            entity.metaClass.invokeMethod = { String name, Object args ->
+                'invoked'
+            }
+            assert entity.foo() == 'invoked'
+            assert entity.someMethod() == 'invoked'
+        } finally {
+            entity.metaClass = null
+        }
+    }
 }
 
 interface EMCT_InterfaceWithFormat {
