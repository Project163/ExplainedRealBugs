diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 1aadaa5dae..2f07ba450d 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -1556,7 +1556,7 @@ out:    if ((samParameterTypes.length == 1 && isOrImplements(samParameterTypes[0
 
         boolean staticOnlyAccess = isClassClassNodeWrappingConcreteType(objectExpressionType);
         if (staticOnlyAccess) {
-            if ("this".equals(propertyName)) {
+            if (propertyName.equals("this")) {
                 // handle "Outer.this" for any level of nesting
                 ClassNode outer = objectExpressionType.getGenericsTypes()[0].getType();
 
@@ -1571,7 +1571,7 @@ out:    if ((samParameterTypes.length == 1 && isOrImplements(samParameterTypes[0
                     storeType(pexp, outer);
                     return true;
                 }
-            } else if ("super".equals(propertyName)) {
+            } else if (propertyName.equals("super")) {
                 // GROOVY-8299: handle "Iface.super" for interface default methods
                 ClassNode enclosingType = typeCheckingContext.getEnclosingClassNode();
                 ClassNode accessor = objectExpressionType.getGenericsTypes()[0].getType();
@@ -1665,13 +1665,17 @@ out:    if ((samParameterTypes.length == 1 && isOrImplements(samParameterTypes[0
 
                 MethodNode getter = current.getGetterMethod(isserName);
                 getter = allowStaticAccessToMember(getter, staticOnly);
-                if (getter == null) getter = current.getGetterMethod(getterName);
-                getter = allowStaticAccessToMember(getter, staticOnly);
+                if (getter == null) {
+                    getter = current.getGetterMethod(getterName);
+                    getter = allowStaticAccessToMember(getter, staticOnly);
+                }
                 if (getter != null
                         // GROOVY-11319:
                         && (!hasAccessToMember(typeCheckingContext.getEnclosingClassNode(), getter.getDeclaringClass(), getter.getModifiers())
                         // GROOVY-11369:
-                        || (!isThisExpression(objectExpression) && !isSuperExpression(objectExpression) && isOrImplements(objectExpressionType, MAP_TYPE)
+                        || (isOrImplements(receiverType, MAP_TYPE)
+                            && !isSuperExpression(objectExpression)
+                            && !(isThisExpression(objectExpression) && (!pexp.isImplicitThis() || typeCheckingContext.getEnclosingClosure() == null)) // GROOVY-11384
                             && (!getter.isPublic() || (propertyName.matches("empty|class|metaClass") && !List.of(getTypeCheckingAnnotations()).contains(COMPILESTATIC_CLASSNODE)))))) {
                     getter = null;
                 }
diff --git a/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy b/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy
index 4fc8912be7..c4071cea98 100644
--- a/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy
+++ b/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy
@@ -163,7 +163,7 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
              c.@x = '1'
          ''',
          'Cannot assign value of type java.lang.String to variable of type int'
-     }
+    }
 
     void testInferenceFromAttributeType() {
         assertScript '''
@@ -445,6 +445,7 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
             class C {
                 Closure<List> bar = { Date date -> date.getTime() }
             }
+            new C()
         ''',
         'Cannot return value of type long for closure expecting java.util.List'
 
@@ -452,6 +453,7 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
             class C {
                 java.util.function.Supplier<String> bar = { -> 123 }
             }
+            new C()
         ''',
         'Cannot return value of type int for closure expecting java.lang.String'
     }
@@ -578,6 +580,16 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
             def x = list.x
             assert x == [1,2]
         '''
+        assertScript '''
+            void test(List list) {
+                @ASTTest(phase=INSTRUCTION_SELECTION, value={
+                    def type = node.getNodeMetaData(INFERRED_TYPE)
+                    assert type.toString(false) == 'java.lang.Class<? extends java.lang.Object>'
+                })
+                def c = list.class
+            }
+            test([])
+        '''
     }
 
     // GROOVY-5700
@@ -629,7 +641,7 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
         '''
     }
 
-    // GROOVY-11369, GROOVY-11372
+    // GROOVY-11369, GROOVY-11372, GROOVY-11384
     void testMapPropertyAccess5() {
         assertScript '''
             def map = [:]
@@ -654,6 +666,18 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
             map.properties = null
         ''',
         'Cannot set read-only property: properties'
+
+        assertScript '''
+            void test(Map map) {
+                def str = ''
+                str += map.empty
+                str += map.with{ empty }
+                str += map.with{ delegate.empty }
+                str += map.with{ {->owner.empty}() }
+                assert str == 'entryentryentryentry'
+            }
+            test( [:].withDefault{ 'entry' } )
+        '''
     }
 
     // GROOVY-8074
@@ -929,6 +953,8 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
                 }
                 def p = 1
             }
+            def i = new Outer.Inner()
+            def x = i.m()
         ''',
         'The variable [p] is undeclared.'
     }
@@ -943,6 +969,8 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
                 }
                 def p = 1
             }
+            def i = new Outer.Inner()
+            def x = i.m()
         ''',
         'No such property: p for class: Outer$Inner'
     }
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/FieldsAndPropertiesStaticCompileTest.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/FieldsAndPropertiesStaticCompileTest.groovy
index e66dd10fec..d1bf593656 100644
--- a/src/test/org/codehaus/groovy/classgen/asm/sc/FieldsAndPropertiesStaticCompileTest.groovy
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/FieldsAndPropertiesStaticCompileTest.groovy
@@ -918,6 +918,18 @@ final class FieldsAndPropertiesStaticCompileTest extends FieldsAndPropertiesSTCT
             map.properties = null
         ''',
         'Cannot set read-only property: properties'
+
+        assertScript '''
+            void test(Map map) {
+                def str = ''
+                str += map.empty
+                str += map.with{ empty }
+                str += map.with{ delegate.empty }
+                str += map.with{ {->owner.empty}() }
+                assert str.equals('truetruetruetrue')
+            }
+            test( [:].withDefault{ 'entry' } )
+        '''
     }
 
     // GROOVY-11367, GROOVY-11368
