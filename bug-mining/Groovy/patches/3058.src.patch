diff --git a/subprojects/groovy-jsr223/src/main/java/org/codehaus/groovy/jsr223/GroovyScriptEngineImpl.java b/subprojects/groovy-jsr223/src/main/java/org/codehaus/groovy/jsr223/GroovyScriptEngineImpl.java
index 32f33bdfc9..338d1211d7 100644
--- a/subprojects/groovy-jsr223/src/main/java/org/codehaus/groovy/jsr223/GroovyScriptEngineImpl.java
+++ b/subprojects/groovy-jsr223/src/main/java/org/codehaus/groovy/jsr223/GroovyScriptEngineImpl.java
@@ -212,48 +212,6 @@ public class GroovyScriptEngineImpl extends AbstractScriptEngine implements Comp
 
     // package-privates
     Object eval(Class scriptClass, final ScriptContext ctx) throws ScriptException {
-        // Bindings so script has access to this environment.
-        // Only initialize once.
-        if (null == ctx.getAttribute("context", ScriptContext.ENGINE_SCOPE)) {
-            // add context to bindings
-            ctx.setAttribute("context", ctx, ScriptContext.ENGINE_SCOPE);
-
-            // direct output to ctx.getWriter
-            // If we're wrapping with a PrintWriter here,
-            // enable autoFlush because otherwise it might not get done!
-            final Writer writer = ctx.getWriter();
-            ctx.setAttribute("out", (writer instanceof PrintWriter) ?
-                            writer :
-                            new PrintWriter(writer, true),
-                    ScriptContext.ENGINE_SCOPE);
-
-// Not going to do this after all (at least for now).
-// Scripts can use context.{reader, writer, errorWriter}.
-// That is a modern version of System.{in, out, err} or Console.{reader, writer}().
-//
-//            // New I/O names consistent with ScriptContext and java.io.Console.
-//
-//            ctx.setAttribute("writer", writer, ScriptContext.ENGINE_SCOPE);
-//
-//            // Direct errors to ctx.getErrorWriter
-//            final Writer errorWriter = ctx.getErrorWriter();
-//            ctx.setAttribute("errorWriter", (errorWriter instanceof PrintWriter) ?
-//                                    errorWriter :
-//                                    new PrintWriter(errorWriter),
-//                                    ScriptContext.ENGINE_SCOPE);
-//
-//            // Get input from ctx.getReader
-//            // We don't wrap with BufferedReader here because we expect that if
-//            // the host wants that they do it.  Either way Groovy scripts will
-//            // always have readLine because the GDK supplies it for Reader.
-//            ctx.setAttribute("reader", ctx.getReader(), ScriptContext.ENGINE_SCOPE);
-        }
-
-        // Fix for GROOVY-3669: Can't use several times the same JSR-223 ScriptContext for differents groovy script
-        if (ctx.getWriter() != null) {
-            ctx.setAttribute("out", new PrintWriter(ctx.getWriter(), true), ScriptContext.ENGINE_SCOPE);
-        }
-
         /*
          * We use the following Binding instance so that global variable lookup
          * will be done in the current ScriptContext instance.
@@ -266,6 +224,19 @@ public class GroovyScriptEngineImpl extends AbstractScriptEngine implements Comp
                     if (scope != -1) {
                         return ctx.getAttribute(name, scope);
                     }
+                    // Redirect script output to context writer, if out var is not already provided
+                    if ("out".equals(name)) {
+                        Writer writer = ctx.getWriter();
+                        if (writer != null) {
+                            return (writer instanceof PrintWriter) ?
+                                    (PrintWriter) writer :
+                                    new PrintWriter(writer, true);
+                        }
+                    }
+                    // Provide access to engine context, if context var is not already provided
+                    if ("context".equals(name)) {
+                        return ctx;
+                    }
                 }
                 throw new MissingPropertyException(name, getClass());
             }
@@ -344,12 +315,6 @@ public class GroovyScriptEngineImpl extends AbstractScriptEngine implements Comp
             }
         } catch (Exception e) {
             throw new ScriptException(e);
-        } finally {
-            // Fix for GROOVY-3669: Can't use several times the same JSR-223 ScriptContext for different groovy script
-            // Groovy's scripting engine implementation adds those two variables in the binding
-            // but should clean up afterwards
-            ctx.removeAttribute("context", ScriptContext.ENGINE_SCOPE);
-            ctx.removeAttribute("out", ScriptContext.ENGINE_SCOPE);
         }
     }
 
diff --git a/subprojects/groovy-jsr223/src/test/groovy/org/codehaus/groovy/jsr223/JSR223Test.groovy b/subprojects/groovy-jsr223/src/test/groovy/org/codehaus/groovy/jsr223/JSR223Test.groovy
index da87cf3344..d6792befd7 100644
--- a/subprojects/groovy-jsr223/src/test/groovy/org/codehaus/groovy/jsr223/JSR223Test.groovy
+++ b/subprojects/groovy-jsr223/src/test/groovy/org/codehaus/groovy/jsr223/JSR223Test.groovy
@@ -18,6 +18,8 @@
  */
 package org.codehaus.groovy.jsr223
 
+import javax.script.Invocable
+import javax.script.ScriptContext
 import javax.script.ScriptEngineManager
 import javax.script.ScriptEngine
 import javax.script.ScriptEngineFactory
@@ -34,6 +36,8 @@ import javax.script.SimpleScriptContext
 class JSR223Test extends GroovyTestCase {
     protected ScriptEngineManager manager
 
+    static final Object[] EMPTY_ARGS = new Object[0]
+
     protected void setUp() {
         manager = new ScriptEngineManager()
     }
@@ -151,4 +155,63 @@ class JSR223Test extends GroovyTestCase {
 
         assert instance.class.isAssignableFrom(clazz)
     }
+
+    void testInvokeFunctionRedirectsOutputToContextWriter() {
+        def engine = manager.getEngineByName('groovy')
+        StringWriter writer = new StringWriter()
+        engine.getContext().setWriter(writer)
+        String code = 'def myFunction() { print "Hello World!" }'
+        engine.eval(code)
+        ((Invocable) engine).invokeFunction('myFunction', EMPTY_ARGS)
+        assert writer.toString() == 'Hello World!'
+
+        // make sure changes to writer are handled
+        writer = new StringWriter()
+        StringWriter writer2 = new StringWriter()
+        engine.getContext().setWriter(writer2)
+        ((Invocable) engine).invokeFunction('myFunction', EMPTY_ARGS)
+        assert writer.toString() == ''
+        assert writer2.toString() == 'Hello World!'
+    }
+
+    void testInvokeFunctionRedirectsOutputToContextOut() {
+        def engine = manager.getEngineByName('groovy')
+        StringWriter writer = new StringWriter()
+        StringWriter unusedWriter = new StringWriter()
+        engine.getContext().setWriter(unusedWriter)
+        engine.put('out', writer)
+        String code = 'def myFunction() { print "Hello World!" }'
+        engine.eval(code)
+        ((Invocable) engine).invokeFunction('myFunction', EMPTY_ARGS)
+        assert unusedWriter.toString() == ''
+        assert writer.toString() == 'Hello World!'
+
+        // make sure changes to writer are handled
+        writer = new StringWriter()
+        StringWriter writer2 = new StringWriter()
+        engine.put('out', writer2)
+        ((Invocable) engine).invokeFunction('myFunction', EMPTY_ARGS)
+        assert unusedWriter.toString() == ''
+        assert writer.toString() == ''
+        assert writer2.toString() == 'Hello World!'
+    }
+
+    void testEngineContextAccessibleToScript() {
+        def engine = manager.getEngineByName('groovy')
+        ScriptContext engineContext = engine.getContext()
+        engine.put('theEngineContext', engineContext)
+        String code = '[answer: theEngineContext.is(context)]'
+        assert engine.eval(code).answer == true
+    }
+
+    void testContextBindingOverridesEngineContext() {
+        def engine = manager.getEngineByName('groovy')
+        ScriptContext engineContext = engine.getContext()
+        def otherContext = [foo: 'bar']
+        engine.put('context', otherContext)
+        engine.put('theEngineContext', engineContext)
+        String code = '[answer: context.is(theEngineContext) ? "wrong" : context.foo]'
+        assert engine.eval(code).answer == 'bar'
+    }
+
 }
