diff --git a/src/main/groovy/lang/ObjectRange.java b/src/main/groovy/lang/ObjectRange.java
index e44c892e89..ca8937ee86 100644
--- a/src/main/groovy/lang/ObjectRange.java
+++ b/src/main/groovy/lang/ObjectRange.java
@@ -48,6 +48,7 @@ package groovy.lang;
 import org.codehaus.groovy.runtime.InvokerHelper;
 import org.codehaus.groovy.runtime.IteratorClosureAdapter;
 import org.codehaus.groovy.runtime.ScriptBytecodeAdapter;
+import org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation;
 
 import java.math.BigDecimal;
 import java.math.BigInteger;
@@ -117,18 +118,25 @@ public class ObjectRange extends AbstractList implements Range {
     }
 
     private void constructorHelper(Comparable from, Comparable to) {
-        if (from instanceof Short && to instanceof Short) {
-            this.from = new Integer(((Short) from).intValue());
-            this.to = new Integer(((Short) to).intValue());
-        } else if (from instanceof Float && to instanceof Float) {
-            this.from = new Double(((Float) from).doubleValue());
-            this.to = new Double(((Float) to).doubleValue());
-        } else if (from.getClass() == to.getClass()) {
+        if (from instanceof Short) {
+            from = new Integer(((Short) from).intValue());
+        }
+        if (to instanceof Short) {
+            to = new Integer(((Short) to).intValue());
+        }
+        if (from instanceof Float) {
+            from = new Double(((Float) from).doubleValue());
+        }
+        if (to instanceof Float) {
+            to = new Double(((Float) to).doubleValue());
+        }
+        // TODO: should we care about different types here?
+        if (from.getClass() == to.getClass()) {
             this.from = from;
             this.to = to;
         } else {
-            this.from = normaliseType(from);
-            this.to = normaliseType(to);
+            this.from = normaliseStringType(from);
+            this.to = normaliseStringType(to);
         }
         if (from instanceof String || to instanceof String) {
             // this test depends deeply on the String.next implementation
@@ -161,12 +169,13 @@ public class ObjectRange extends AbstractList implements Range {
      * Compares an {@link ObjectRange} to another {@link ObjectRange}.
      *
      * @return <code>true</code> if the ranges are equal
+     * @param that the object to check equality with
      */
     public boolean equals(ObjectRange that) {
         return that != null
                 && this.reverse == that.reverse
-                && this.from.equals(that.from)
-                && this.to.equals(that.to);
+                && DefaultTypeTransformation.compareEqual(this.from, that.from)
+                && DefaultTypeTransformation.compareEqual(this.to, that.to);
     }
 
     /**
@@ -200,7 +209,7 @@ public class ObjectRange extends AbstractList implements Range {
         if (index >= size()) {
             throw new IndexOutOfBoundsException("Index: " + index + " is too big for range: " + this);
         }
-        Object value = null;
+        Object value;
         if (reverse) {
             value = to;
 
@@ -338,6 +347,19 @@ public class ObjectRange extends AbstractList implements Range {
         return (reverse) ? "" + toText + ".." + fromText : "" + fromText + ".." + toText;
     }
 
+    public boolean contains(Object value) {
+        Iterator it = iterator();
+        if (value==null) return false;
+        while (it.hasNext()) {
+            try {
+                if (DefaultTypeTransformation.compareEqual(value, it.next())) return true;
+            } catch (ClassCastException e) {
+                return false;
+            }
+        }
+        return false;
+    }
+
     /**
      * {@inheritDoc}
      */
@@ -394,7 +416,7 @@ public class ObjectRange extends AbstractList implements Range {
         return InvokerHelper.invokeMethod(value, "previous", null);
     }
 
-    private static Comparable normaliseType(final Comparable operand) {
+    private static Comparable normaliseStringType(final Comparable operand) {
         if (operand instanceof Character) {
             return new Integer(((Character) operand).charValue());
         } else if (operand instanceof String) {
diff --git a/src/test/groovy/lang/RangeTest.java b/src/test/groovy/lang/RangeTest.java
index 5e78241577..968e722ea7 100644
--- a/src/test/groovy/lang/RangeTest.java
+++ b/src/test/groovy/lang/RangeTest.java
@@ -89,19 +89,30 @@ public class RangeTest extends TestCase {
         }
     }
 
+    public void testNullForFromOrToIsIllegal() {
+        Comparable dontcare = new Integer(0);
+        try {
+            new ObjectRange((Comparable)null, dontcare);
+            fail("Should have thrown IllegalArgumentException");
+        }
+        catch (IllegalArgumentException e) {
+            // worked
+        }
+    }
+
     public void testGetOutOfRange() {
         Range r = createRange(10, 20);
 
         try {
             r.get(-1);
-            fail("Should have thrown IndexOut");
+            fail("Should have thrown IndexOutOfBoundsException");
         }
         catch (IndexOutOfBoundsException e) {
             // worked
         }
         try {
             r.get(11);
-            fail("Should have thrown IndexOut");
+            fail("Should have thrown IndexOutOfBoundsException");
         }
         catch (IndexOutOfBoundsException e) {
             // worked
@@ -111,14 +122,14 @@ public class RangeTest extends TestCase {
 
         try {
             r.get(-1);
-            fail("Should have thrown IndexOut");
+            fail("Should have thrown IndexOutOfBoundsException");
         }
         catch (IndexOutOfBoundsException e) {
             // worked
         }
         try {
             r.get(7);
-            fail("Should have thrown IndexOut");
+            fail("Should have thrown IndexOutOfBoundsException");
         }
         catch (IndexOutOfBoundsException e) {
             // worked
@@ -148,6 +159,22 @@ public class RangeTest extends TestCase {
         assertFalse("containsWithinBounds 10.0001", r.containsWithinBounds(new BigDecimal("10.0001")));
     }
 
+    public void testContainsWithLikeNumbers() {
+        Range r = new ObjectRange(new Integer(1), new Short((short)3));
+        assertTrue("contains 2", r.contains(new Integer(2)));
+        r = new ObjectRange(new Float(1.0), new Double(3.0));
+        assertTrue("contains 2.0d", r.contains(new Double(2.0)));
+        assertTrue("contains 2.0g", r.contains(new BigDecimal(2.0)));
+        r = new ObjectRange(new BigDecimal(1.0), new BigDecimal(3.0));
+        assertTrue("contains 2.0d", r.contains(new Double(2.0)));
+        assertTrue("contains 2.0f", r.contains(new Float(2.0)));
+    }
+
+    public void testContainsWithIncompatibleType() {
+        Range r = new ObjectRange(new Integer(1), new Short((short)3));
+        assertFalse("shouldn't contain string", r.contains("String"));
+    }
+
     public void testSubList() {
         Range r = createRange(10, 20);
 
