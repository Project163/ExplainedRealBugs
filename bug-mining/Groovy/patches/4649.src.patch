diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 112210377c..26a5466a2a 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -5211,12 +5211,12 @@ out:                if (mn.size() != 1) {
                 ClassNode subType = lowestUpperBound(expressionTypes);
                 genericsTypes = new GenericsType[]{new GenericsType(wrapTypeIfNecessary(subType))};
             } else { // GROOVY-11028
-                GenericsType[] typeVars = listType.redirect().getGenericsTypes();
+                GenericsType[] typeVars = ArrayList_TYPE.getGenericsTypes();
                 Map<GenericsTypeName, GenericsType> spec = extractGenericsConnectionsFromArguments(
                     typeVars, Parameter.EMPTY_ARRAY, ArgumentListExpression.EMPTY_ARGUMENTS, null);
                 genericsTypes = applyGenericsContext(spec, typeVars);
             }
-            listType = listType.getPlainNodeReference();
+            listType = ArrayList_TYPE.getPlainNodeReference();
             listType.setGenericsTypes(genericsTypes);
         }
 
diff --git a/src/spec/test/typing/TypeCheckingTest.groovy b/src/spec/test/typing/TypeCheckingTest.groovy
index 84c18ac9ef..4655c32dad 100644
--- a/src/spec/test/typing/TypeCheckingTest.groovy
+++ b/src/spec/test/typing/TypeCheckingTest.groovy
@@ -16,7 +16,6 @@
  *  specific language governing permissions and limitations
  *  under the License.
  */
-
 package typing
 
 import groovy.transform.stc.StaticTypeCheckingTestCase
@@ -445,7 +444,8 @@ class TypeCheckingTest extends StaticTypeCheckingTestCase {
     void testCollectionLiteralInference() {
         assertScript '''
         @ASTTest(phase=INSTRUCTION_SELECTION,value={
-            assert node.getNodeMetaData(INFERRED_TYPE) == make(List)
+            def type = node.getNodeMetaData(INFERRED_TYPE)
+            assert type == make(ArrayList)
         })
         // tag::empty_list_literal_inference[]
         def list = []
@@ -454,9 +454,9 @@ class TypeCheckingTest extends StaticTypeCheckingTestCase {
 
         assertScript '''
         @ASTTest(phase=INSTRUCTION_SELECTION,value={
-            def inft = node.getNodeMetaData(INFERRED_TYPE)
-            assert inft == make(List)
-            assert inft.genericsTypes[0].type == make(String)
+            def type = node.getNodeMetaData(INFERRED_TYPE)
+            assert type == make(ArrayList)
+            assert type.genericsTypes[0].type == STRING_TYPE
         })
         // tag::list_literal_inference_simple[]
         def list = ['foo','bar']
@@ -467,9 +467,9 @@ class TypeCheckingTest extends StaticTypeCheckingTestCase {
         def foo = 1
         def bar = 2
         @ASTTest(phase=INSTRUCTION_SELECTION,value={
-            def inft = node.getNodeMetaData(INFERRED_TYPE)
-            assert inft == make(List)
-            assert inft.genericsTypes[0].type == make(GString)
+            def type = node.getNodeMetaData(INFERRED_TYPE)
+            assert type == make(ArrayList)
+            assert type.genericsTypes[0].type == GSTRING_TYPE
         })
         // tag::list_literal_inference_gstring[]
         def list = ["${foo}","${bar}"]
@@ -477,7 +477,8 @@ class TypeCheckingTest extends StaticTypeCheckingTestCase {
         '''
         assertScript '''
         @ASTTest(phase=INSTRUCTION_SELECTION,value={
-            assert node.getNodeMetaData(INFERRED_TYPE) == make(LinkedHashMap)
+             def type = node.getNodeMetaData(INFERRED_TYPE)
+             assert type == make(LinkedHashMap)
         })
         // tag::empty_map_literal_inference[]
         def map = [:]
@@ -486,10 +487,10 @@ class TypeCheckingTest extends StaticTypeCheckingTestCase {
 
         assertScript '''
         @ASTTest(phase=INSTRUCTION_SELECTION,value={
-             def inft = node.getNodeMetaData(INFERRED_TYPE)
-             assert inft == make(LinkedHashMap)
-             assert inft.genericsTypes[0].type == make(String)
-             assert inft.genericsTypes[1].type == make(String)
+             def type = node.getNodeMetaData(INFERRED_TYPE)
+             assert type == make(LinkedHashMap)
+             assert type.genericsTypes[0].type == STRING_TYPE
+             assert type.genericsTypes[1].type == STRING_TYPE
         })
         // tag::map_literal_inference_simple[]
         def map1 = [someKey: 'someValue']
@@ -502,8 +503,8 @@ class TypeCheckingTest extends StaticTypeCheckingTestCase {
         @ASTTest(phase=INSTRUCTION_SELECTION,value={
              def inft = node.getNodeMetaData(INFERRED_TYPE)
              assert inft == make(LinkedHashMap)
-             assert inft.genericsTypes[0].type == make(GString)
-             assert inft.genericsTypes[1].type == make(String)
+             assert inft.genericsTypes[0].type == GSTRING_TYPE
+             assert inft.genericsTypes[1].type == STRING_TYPE
         })
         // tag::map_literal_inference_gstring[]
         def map = ["${someKey}": 'someValue']
@@ -512,7 +513,8 @@ class TypeCheckingTest extends StaticTypeCheckingTestCase {
 
         assertScript '''
         @ASTTest(phase=INSTRUCTION_SELECTION,value={
-            assert node.getNodeMetaData(INFERRED_TYPE) == make(IntRange)
+            def type = node.getNodeMetaData(INFERRED_TYPE)
+            assert type == make(IntRange)
         })
         // tag::intRange_literal_inference[]
         def intRange = (0..10)
@@ -521,15 +523,14 @@ class TypeCheckingTest extends StaticTypeCheckingTestCase {
 
         assertScript '''
         @ASTTest(phase=INSTRUCTION_SELECTION,value={
-            def inft = node.getNodeMetaData(INFERRED_TYPE)
-            assert inft == make(Range)
-            assert inft.genericsTypes[0].type == make(String)
+            def type = node.getNodeMetaData(INFERRED_TYPE)
+            assert type == RANGE_TYPE
+            assert type.genericsTypes[0].type == STRING_TYPE
         })
         // tag::charRange_literal_inference[]
         def charRange = ('a'..'z')
         // end::charRange_literal_inference[]
         '''
-
     }
 
     void testTypeInferenceFieldVsLocalVariable() {
diff --git a/src/test/gls/generics/GenericsBytecodeTest.groovy b/src/test/gls/generics/GenericsBytecodeTest.groovy
index bc4a076480..c3aa3e0550 100644
--- a/src/test/gls/generics/GenericsBytecodeTest.groovy
+++ b/src/test/gls/generics/GenericsBytecodeTest.groovy
@@ -223,10 +223,10 @@ class GenericsBytecodeTest extends GenericsTestBase {
             }
         '''
         assert signatures == [
-            'a()Ljava/util/Map;'                        : '()Ljava/util/Map<Ljava/lang/String;*>;',
-            'b()Ljava/util/Map;'                        : '()Ljava/util/Map<Ljava/lang/String;Ljava/util/List<*>;>;',
-            'doCall()Ljava/util/List;'                  : '()Ljava/util/List<Ljava/util/Map<Ljava/lang/String;+Ljava/lang/Object;>;>;',
-            'doCall(Ljava/lang/Object;)Ljava/util/List;': '(Ljava/lang/Object;)Ljava/util/List<Ljava/util/Map<Ljava/lang/String;+Ljava/lang/Object;>;>;'
+            'a()Ljava/util/Map;'                             : '()Ljava/util/Map<Ljava/lang/String;*>;',
+            'b()Ljava/util/Map;'                             : '()Ljava/util/Map<Ljava/lang/String;Ljava/util/List<*>;>;',
+            'doCall()Ljava/util/ArrayList;'                  : '()Ljava/util/ArrayList<Ljava/util/Map<Ljava/lang/String;+Ljava/lang/Object;>;>;',
+            'doCall(Ljava/lang/Object;)Ljava/util/ArrayList;': '(Ljava/lang/Object;)Ljava/util/ArrayList<Ljava/util/Map<Ljava/lang/String;+Ljava/lang/Object;>;>;'
         ]
     }
 
diff --git a/src/test/groovy/bugs/Groovy10034.groovy b/src/test/groovy/bugs/Groovy10034.groovy
index 08979a7a87..7f745878b8 100644
--- a/src/test/groovy/bugs/Groovy10034.groovy
+++ b/src/test/groovy/bugs/Groovy10034.groovy
@@ -29,7 +29,7 @@ final class Groovy10034 extends AbstractBytecodeTestCase {
             }
         '''
         int offset = result.indexOf('ANEWARRAY java/lang/String', result.indexOf('--BEGIN--'))
-        assert result.hasStrictSequence(['ANEWARRAY java/lang/String','INVOKEINTERFACE java/util/List.toArray'], offset)
+        assert result.hasStrictSequence(['ANEWARRAY java/lang/String','INVOKEVIRTUAL java/util/ArrayList.toArray'], offset)
         // there should be no 'INVOKEDYNAMIC cast' instruction here: ^
     }
 }
diff --git a/src/test/groovy/transform/stc/ArraysAndCollectionsSTCTest.groovy b/src/test/groovy/transform/stc/ArraysAndCollectionsSTCTest.groovy
index 53aa87d81c..228faa875c 100644
--- a/src/test/groovy/transform/stc/ArraysAndCollectionsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/ArraysAndCollectionsSTCTest.groovy
@@ -782,7 +782,7 @@ class ArraysAndCollectionsSTCTest extends StaticTypeCheckingTestCase {
     // GROOVY-6266
     void testMapKeyGenerics() {
         assertScript '''
-            Map<String,List<List>> map = new HashMap<String,List<List>>()
+            Map<String, ? extends List<? extends List>> map = new HashMap<>()
             map.get('key',[['val1'],['val2']])
             assert map.'key'[0] == ['val1']
         '''
@@ -919,7 +919,7 @@ class ArraysAndCollectionsSTCTest extends StaticTypeCheckingTestCase {
             }
             A a = [1]
         ''',
-        'Cannot assign value of type java.util.List<java.lang.Integer> to variable of type A'
+        'Cannot assign value of type java.util.ArrayList<java.lang.Integer> to variable of type A'
     }
 
     // GROOVY-6912
@@ -1038,17 +1038,17 @@ class ArraysAndCollectionsSTCTest extends StaticTypeCheckingTestCase {
         shouldFailWithMessages '''
             Deque<String> deque = []
         ''',
-        'Cannot assign value of type java.util.List','to variable of type java.util.Deque<java.lang.String>'
+        'Cannot assign value of type java.util.ArrayList','to variable of type java.util.Deque<java.lang.String>'
 
         shouldFailWithMessages '''
             Queue<String> queue = []
         ''',
-        'Cannot assign value of type java.util.List','to variable of type java.util.Queue<java.lang.String>'
+        'Cannot assign value of type java.util.ArrayList','to variable of type java.util.Queue<java.lang.String>'
 
         shouldFailWithMessages '''
             Deque<String> deque = [""]
         ''',
-        'Cannot assign value of type java.util.List<java.lang.String> to variable of type java.util.Deque<java.lang.String>'
+        'Cannot assign value of type java.util.ArrayList<java.lang.String> to variable of type java.util.Deque<java.lang.String>'
     }
 
     // GROOVY-7128
diff --git a/src/test/groovy/transform/stc/BugsSTCTest.groovy b/src/test/groovy/transform/stc/BugsSTCTest.groovy
index 329948ed9b..e79c87af8e 100644
--- a/src/test/groovy/transform/stc/BugsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/BugsSTCTest.groovy
@@ -30,73 +30,85 @@ class BugsSTCTest extends StaticTypeCheckingTestCase {
         shouldFailWithMessages '''
             def foo(Closure cls) {}
             def bar() { foo { it / 2 } }
-        ''', 'Cannot find matching method java.lang.Object#div(int)'
+        ''',
+        'Cannot find matching method java.lang.Object#div(int)'
     }
     void testShouldNotAllowDivByUntypedVariable() {
         shouldFailWithMessages '''
             def foo(Closure cls) {}
             def bar() { foo { 2 / it } }
-        ''', 'Cannot find matching method int#div(java.lang.Object)'
+        ''',
+        'Cannot find matching method int#div(java.lang.Object)'
     }
     void testShouldNotAllowModOnUntypedVariable() {
         shouldFailWithMessages '''
             def foo(Closure cls) {}
             def bar() { foo { it.mod(2) } }
-        ''', 'Cannot find matching method java.lang.Object#mod(int)'
+        ''',
+        'Cannot find matching method java.lang.Object#mod(int)'
     }
     void testShouldNotAllowModByUntypedVariable() {
         shouldFailWithMessages '''
             def foo(Closure cls) {}
             def bar() { foo { 2.mod(it) } }
-        ''', 'Cannot find matching method int#mod(java.lang.Object)'
+        ''',
+        'Cannot find matching method int#mod(java.lang.Object)'
     }
     void testShouldNotAllowRemainderOnUntypedVariable() {
         shouldFailWithMessages '''
             def foo(Closure cls) {}
             def bar() { foo { it % 2 } }
-        ''', 'Cannot find matching method java.lang.Object#remainder(int)'
+        ''',
+        'Cannot find matching method java.lang.Object#remainder(int)'
     }
     void testShouldNotAllowRemainderByUntypedVariable() {
         shouldFailWithMessages '''
             def foo(Closure cls) {}
             def bar() { foo { 2 % it } }
-        ''', 'Cannot find matching method int#remainder(java.lang.Object)'
+        ''',
+        'Cannot find matching method int#remainder(java.lang.Object)'
     }
     void testShouldNotAllowMulOnUntypedVariable() {
         shouldFailWithMessages '''
             def foo(Closure cls) {}
             def bar() { foo { it * 2 } }
-        ''', 'Cannot find matching method java.lang.Object#multiply(int)'
+        ''',
+        'Cannot find matching method java.lang.Object#multiply(int)'
     }
     void testShouldNotAllowMulByUntypedVariable() {
         shouldFailWithMessages '''
             def foo(Closure cls) {}
             def bar() { foo { 2 * it } }
-        ''', 'Cannot find matching method int#multiply(java.lang.Object)'
+        ''',
+        'Cannot find matching method int#multiply(java.lang.Object)'
     }
     void testShouldNotAllowPlusOnUntypedVariable() {
         shouldFailWithMessages '''
             def foo(Closure cls) {}
             def bar() { foo { it + 2 } }
-        ''', 'Cannot find matching method java.lang.Object#plus(int)'
+        ''',
+        'Cannot find matching method java.lang.Object#plus(int)'
     }
     void testShouldNotAllowPlusWithUntypedVariable() {
         shouldFailWithMessages '''
             def foo(Closure cls) {}
             def bar() { foo { 2 + it } }
-        ''', 'Cannot find matching method int#plus(java.lang.Object)'
+        ''',
+        'Cannot find matching method int#plus(java.lang.Object)'
     }
     void testShouldNotAllowMinusOnUntypedVariable() {
         shouldFailWithMessages '''
             def foo(Closure cls) {}
             def bar() { foo { it - 2 } }
-        ''', 'Cannot find matching method java.lang.Object#minus(int)'
+        ''',
+        'Cannot find matching method java.lang.Object#minus(int)'
     }
     void testShouldNotAllowMinusByUntypedVariable() {
         shouldFailWithMessages '''
             def foo(Closure cls) {}
             def bar() { foo { 2 - it } }
-        ''', 'Cannot find matching method int#minus(java.lang.Object)'
+        ''',
+        'Cannot find matching method int#minus(java.lang.Object)'
     }
 
     // GROOVY-7929
@@ -112,7 +124,8 @@ class BugsSTCTest extends StaticTypeCheckingTestCase {
                     x()
                 }
             }
-        ''', 'Cannot find matching method <UnionType:C+T>#x'
+        ''',
+        'Cannot find matching method <UnionType:C+T>#x'
     }
 
     // GROOVY-10102
@@ -201,33 +214,33 @@ class BugsSTCTest extends StaticTypeCheckingTestCase {
 
     void testGroovy5487ReturnNull() {
         assertScript '''
-        @ASTTest(phase=INSTRUCTION_SELECTION, value= {
-            assert node.getNodeMetaData(INFERRED_RETURN_TYPE) == null // null since 2.1.9
-        })
-        List getList() {
-            null
-        }
+            @ASTTest(phase=INSTRUCTION_SELECTION, value= {
+                assert node.getNodeMetaData(INFERRED_RETURN_TYPE) == null // null since 2.1.9
+            })
+            List getList() {
+                null
+            }
         '''
     }
 
     void testGroovy5487ReturnNullWithExplicitReturn() {
         assertScript '''
-        @ASTTest(phase=INSTRUCTION_SELECTION, value= {
-            assert node.getNodeMetaData(INFERRED_RETURN_TYPE) == null // null since 2.1.9
-        })
-        List getList() {
-            return null
-        }
+            @ASTTest(phase=INSTRUCTION_SELECTION, value= {
+                assert node.getNodeMetaData(INFERRED_RETURN_TYPE) == null // null since 2.1.9
+            })
+            List getList() {
+                return null
+            }
         '''
     }
 
     void testGroovy5487ReturnNullWithEmptyBody() {
         assertScript '''
-        @ASTTest(phase=INSTRUCTION_SELECTION, value= {
-            assert node.getNodeMetaData(INFERRED_RETURN_TYPE) == null // null since 2.1.9
-        })
-        List getList() {
-        }
+            @ASTTest(phase=INSTRUCTION_SELECTION, value= {
+                assert node.getNodeMetaData(INFERRED_RETURN_TYPE) == null // null since 2.1.9
+            })
+            List getList() {
+            }
         '''
     }
 
@@ -250,26 +263,28 @@ class BugsSTCTest extends StaticTypeCheckingTestCase {
             L<String> items = ['foo', 'bar'] as L<String>
             items.removeIf({a, b -> 1} as Comparator<?>)
             assert items
-        ''', 'Cannot call L#removeIf(java.util.Comparator<? super java.lang.String>) with arguments [java.util.Comparator<?>]'
+        ''',
+        'Cannot call L#removeIf(java.util.Comparator<? super java.lang.String>) with arguments [java.util.Comparator<?>]'
     }
 
     void testGroovy5482ListsAndFlowTyping() {
         assertScript '''
-        class StaticGroovy2 {
-            def bar() {
+            class StaticGroovy2 {
+                def bar() {
 
-                def foo = [new Date(), 1, new C()]
-                foo.add( 2 ) // Compiles
-                foo.add( new Date() )
-                foo.add( new C() )
+                    def foo = [new Date(), 1, new C()]
+                    foo.add( 2 ) // Compiles
+                    foo.add( new Date() )
+                    foo.add( new C() )
 
-                foo = [new Date(), 1]
-                foo.add( 2 ) // Does not compile
+                    foo = [new Date(), 1]
+                    foo.add( 2 ) // Does not compile
+                }
             }
-        }
-        class C{
-        }
-        new StaticGroovy2()'''
+            class C {
+            }
+            new StaticGroovy2()
+        '''
     }
 
     void testClosureThisObjectDelegateOwnerProperty() {
@@ -359,80 +374,81 @@ class BugsSTCTest extends StaticTypeCheckingTestCase {
     // GROOVY-5616
     void testAssignToGroovyObject() {
         assertScript '''
-        class A {}
-        GroovyObject obj = new A()
+            class A {}
+            GroovyObject obj = new A()
         '''
     }
 
     void testAssignJavaClassToGroovyObject() {
         shouldFailWithMessages '''
-        GroovyObject obj = 'foo'
-        ''', 'Cannot assign value of type java.lang.String to variable of type groovy.lang.GroovyObject'
+            GroovyObject obj = 'foo'
+        ''',
+        'Cannot assign value of type java.lang.String to variable of type groovy.lang.GroovyObject'
     }
 
     void testCastToGroovyObject() {
         assertScript '''
-        class A {}
-        GroovyObject obj = new A()
+            class A {}
+            GroovyObject obj = new A()
         '''
     }
 
     void testAssignInnerClassToGroovyObject() {
         assertScript '''
-        class A { static class B {} }
-        GroovyObject obj = new A.B()
+            class A { static class B {} }
+            GroovyObject obj = new A.B()
         '''
     }
 
     void testCastInnerClassToGroovyObject() {
         assertScript '''
-        class A { static class B {} }
-        GroovyObject obj = (GroovyObject)new A.B()
+            class A { static class B {} }
+            GroovyObject obj = (GroovyObject)new A.B()
         '''
     }
 
     void testGroovyObjectInGenerics() {
         assertScript '''
-        class A {}
-        List<? extends GroovyObject> list = new LinkedList<? extends GroovyObject>()
-        list.add(new A())
+            class A {}
+            List<? extends GroovyObject> list = new LinkedList<? extends GroovyObject>()
+            list.add(new A())
         '''
     }
 
     // GROOVY-5656
     void testShouldNotThrowAmbiguousMethodError() {
         assertScript '''import groovy.transform.*
+            class Expr {}
+            class VarExpr extends Expr {}
 
-        class Expr {}
-        class VarExpr extends Expr {}
-
-        class ArgList {
-            ArgList(Expr e1) {  }
-            ArgList(Expr[] es) {  }
-        }
+            class ArgList {
+                ArgList(Expr e1) {  }
+                ArgList(Expr[] es) {  }
+            }
 
-        class Bug4 {
-            void test() {
-                new ArgList(new VarExpr())
+            class Bug4 {
+                void test() {
+                    new ArgList(new VarExpr())
+                }
             }
-        }
 
-        new Bug4().test()
+            new Bug4().test()
         '''
     }
 
     // GROOVY-5793
     void testByteAsParameter() {
         assertScript '''
-        void testMethod(java.lang.Byte param){
-            println(param)
-        }
+            void testMethod(java.lang.Byte param){
+                println(param)
+            }
 
-        void execute(){
-            testMethod(java.lang.Byte.valueOf("123"))
-        }
+            void execute(){
+                testMethod(java.lang.Byte.valueOf("123"))
+            }
 
-        execute()'''
+            execute()
+        '''
     }
 
     // GROOVY-5874 (pt.1)
@@ -441,8 +457,8 @@ class BugsSTCTest extends StaticTypeCheckingTestCase {
             def sum = 0
             def cl1 = { sum = sum + 1 }
             def cl2 = { sum = new Date() }
-
-        ''', 'A closure shared variable [sum] has been assigned with various types'
+        ''',
+        'A closure shared variable [sum] has been assigned with various types'
     }
 
     // GROOVY-5870
@@ -456,71 +472,71 @@ class BugsSTCTest extends StaticTypeCheckingTestCase {
     // GROOVY-5889
     void testShouldNotGoIntoInfiniteLoop() {
         assertScript '''
-        class Enclosing {
-            static class FMessage {
-                static enum LogLevel { finest, finer, fine, config, info, warning, severe }
-                LogLevel logLevel
+            class Enclosing {
+                static class FMessage {
+                    static enum LogLevel { finest, finer, fine, config, info, warning, severe }
+                    LogLevel logLevel
+                }
             }
-        }
-        new Enclosing()
+            new Enclosing()
         '''
     }
 
     // GROOVY-5959
     void testSwitchCaseShouldNotRemoveBreakStatements() {
         assertScript '''
-        int test(Map<String, String> token) {
-          switch(token.type) {
-            case 'case one':
-              1
-              break
-            case 'case two':
-              2
-              break
-            default:
-              3
-              break
-          }
-        }
-        assert test([type:'case one']) == 1
-        assert test([type:'case two']) == 2
-        assert test([type:'default']) == 3
+            int test(Map<String, String> token) {
+              switch(token.type) {
+                case 'case one':
+                  1
+                  break
+                case 'case two':
+                  2
+                  break
+                default:
+                  3
+                  break
+              }
+            }
+            assert test([type:'case one']) == 1
+            assert test([type:'case two']) == 2
+            assert test([type:'default']) == 3
         '''
     }
 
     void testShouldChooseFindMethodFromList() {
         assertScript '''
-        class Mylist implements List<Object> {
-
-            int size() { }
-            boolean isEmpty() {}
-            boolean contains(final Object o) {}
-            Iterator iterator() {[].iterator()}
-            Object[] toArray() {}
-            Object[] toArray(final Object[] a) {}
-            boolean add(final Object e) {}
-            boolean remove(final Object o) {}
-            boolean containsAll(final Collection<?> c) {}
-            boolean addAll(final Collection c) {}
-            boolean addAll(final int index, final Collection c) {}
-            boolean removeAll(final Collection<?> c) {}
-            boolean retainAll(final Collection<?> c) {}
-            void clear() {}
-            Object get(final int index) {}
-            Object set(final int index, final Object element) {}
-            void add(final int index, final Object element) {}
-            Object remove(final int index) {}
-            int indexOf(final Object o) {}
-            int lastIndexOf(final Object o) {}
-            ListIterator listIterator() {}
-            ListIterator listIterator(final int index) {}
-            List subList(final int fromIndex, final int toIndex) {}
-        }
+            class Mylist implements List<Object> {
+                int size() { }
+                boolean isEmpty() {}
+                boolean contains(final Object o) {}
+                Iterator iterator() {[].iterator()}
+                Object[] toArray() {}
+                Object[] toArray(final Object[] a) {}
+                boolean add(final Object e) {}
+                boolean remove(final Object o) {}
+                boolean containsAll(final Collection<?> c) {}
+                boolean addAll(final Collection c) {}
+                boolean addAll(final int index, final Collection c) {}
+                boolean removeAll(final Collection<?> c) {}
+                boolean retainAll(final Collection<?> c) {}
+                void clear() {}
+                Object get(final int index) {}
+                Object set(final int index, final Object element) {}
+                void add(final int index, final Object element) {}
+                Object remove(final int index) {}
+                int indexOf(final Object o) {}
+                int lastIndexOf(final Object o) {}
+                ListIterator listIterator() {}
+                ListIterator listIterator(final int index) {}
+                List subList(final int fromIndex, final int toIndex) {}
+            }
 
-           def whatthe(Mylist a) {
-               a.find { true }
-           }
-        whatthe(new Mylist())
+            def whatthe(Mylist a) {
+                a.find { true }
+            }
+
+            whatthe(new Mylist())
         '''
     }
 
@@ -636,60 +652,55 @@ class BugsSTCTest extends StaticTypeCheckingTestCase {
 
     void testConstructorNewInstance() {
         assertScript '''import java.lang.reflect.Constructor
+            class Person {
+                String name
+                Person(String name) { this.name = name }
+            }
 
-class Person {
-    String name
-    Person(String name) { this.name = name }
-}
-
-Constructor<Person> ctor = Person.getConstructor(String)
-def p = ctor.newInstance('Bob')
-assert p.name == 'Bob'
-'''
+            Constructor<Person> ctor = Person.getConstructor(String)
+            def p = ctor.newInstance('Bob')
+            assert p.name == 'Bob'
+        '''
     }
 
     void testOuterDotThisNotation() {
         assertScript '''
-class Outer {
-    int x
-    class Inner {
-        int foo() { 2*Outer.this.x }
-    }
-    int bar() {
-        new Inner().foo()
-    }
-}
-def o = new Outer(x:123)
-assert o.bar() == 2*o.x
-'''
+            class Outer {
+                int x
+                class Inner {
+                    int foo() { 2*Outer.this.x }
+                }
+                int bar() {
+                    new Inner().foo()
+                }
+            }
+            def o = new Outer(x:123)
+            assert o.bar() == 2*o.x
+        '''
     }
 
     // GROOVY-6965
     void testShouldNotFailWithClassCastExceptionDuringCompilation() {
         assertScript '''
-interface Job {
-  Runnable getRunnable()
-}
-
-
-class Printer implements Job{
-
-  protected void execute() {
-    println "Printing"
-  }
-
-  public void acceptsRunnable(Runnable r){
-    r.run()
-  }
+            interface Job {
+              Runnable getRunnable()
+            }
 
-  public Runnable getRunnable(){
-     acceptsRunnable(this.&execute) // OK
-     return this.&execute           // compile error
-  }
-}
+            class Printer implements Job {
+              protected void execute() {
+                println "Printing"
+              }
+              void acceptsRunnable(Runnable r) {
+                r.run()
+              }
+              Runnable getRunnable(){
+                 acceptsRunnable(this.&execute) // OK
+                 return this.&execute           // compile error
+              }
+            }
 
-Printer
-'''
+            null
+        '''
     }
 
     // GROOVY-6970
@@ -774,7 +785,8 @@ Printer
     void testAmbiguousMethodResolutionNoArgsOverload() {
         shouldFailWithMessages '''
             Arrays.sort()
-        ''', 'Reference to method is ambiguous. Cannot choose between '
+        ''',
+        'Reference to method is ambiguous. Cannot choose between '
     }
 
     // GROOVY-7711
@@ -842,6 +854,7 @@ Printer
 
             assert AbstractSubClass.name == 'AbstractSubClass'
         '''
+
         assertScript '''
             interface SomeInterface { void foo() }
             interface SomeOtherInterface { void bar() }
@@ -902,6 +915,7 @@ Printer
             }
             assert new Foo().bar() == ['x']
         '''
+
         assertScript '''
             class Foo {
                 def bar() {
@@ -914,6 +928,7 @@ Printer
             }
             assert new Foo().bar() == [[x:1], [y:2]]
         '''
+
         assertScript '''
             import groovy.transform.*
             @ToString(includeFields=true)
@@ -964,11 +979,13 @@ Printer
             List<C> list = [new C(foo:'bar'), new C(foo:'baz')]
             assert list.collect(C.&getFoo) == ['bar', 'baz'] // Cannot find matching method C#getFoo
         '''
+
         assertScript '''
             record R(def foo) { }
             List<R> list = [new R('bar'), new R('baz')]
             assert list.collect(R.&foo) == ['bar', 'baz'] // Cannot find matching method R#foo
         '''
+
         assertScript '''
             class C { def foo }
             def proc = C.&setFoo
@@ -977,17 +994,20 @@ Printer
             proc.call(pogo, 'baz')
             assert pogo.foo == 'baz'
         '''
+
         shouldFailWithMessages '''
             class C { final foo }
             def set = C.&setFoo
-        ''', 'Cannot find matching method C#setFoo'
+        ''',
+        'Cannot find matching method C#setFoo'
     }
 
     // GROOVY-9463
     void testMethodPointerUnknownReference() {
         shouldFailWithMessages '''
             def ptr = String.&toLowerCaseX
-        ''', 'Cannot find matching method java.lang.String#toLowerCaseX.'
+        ''',
+        'Cannot find matching method java.lang.String#toLowerCaseX.'
     }
 
     // GROOVY-9938
@@ -1133,11 +1153,13 @@ Printer
         assertScript '''
             new StringBuilder().setLength(0)
         '''
+
         assertScript '''
             new StringBuilder().with {
                 assert length() == 0 // access error
             }
         '''
+
         assertScript '''
             String sub = new StringBuilder("Hello World").substring(0,5)
             assert sub == 'Hello'
diff --git a/src/test/groovy/transform/stc/CoercionSTCTest.groovy b/src/test/groovy/transform/stc/CoercionSTCTest.groovy
index 5e304fa348..87ecdd84ea 100644
--- a/src/test/groovy/transform/stc/CoercionSTCTest.groovy
+++ b/src/test/groovy/transform/stc/CoercionSTCTest.groovy
@@ -161,7 +161,7 @@ class CoercionSTCTest extends StaticTypeCheckingTestCase {
         shouldFailWithMessages '''import java.util.function.*
             def s = (() -> ['']) as Supplier<Number>
         ''',
-        'Cannot return value of type java.util.List<java.lang.String> for lambda expecting java.lang.Number'
+        'Cannot return value of type java.util.ArrayList<java.lang.String> for lambda expecting java.lang.Number'
     }
 
     // GROOVY-8045
diff --git a/src/test/groovy/transform/stc/GenericsSTCTest.groovy b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
index 29ff41d8eb..06179ce082 100644
--- a/src/test/groovy/transform/stc/GenericsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
@@ -276,13 +276,13 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
               return x // List<E>
             }
         ''',
-        'Incompatible generic argument types.' // Cannot assign java.util.List<java.lang.Object> to: java.util.List<java.lang.String>
+        'Incompatible generic argument types.' // Cannot assign java.util.ArrayList<java.lang.Object> to: java.util.List<java.lang.String>
 
         assertScript '''
             @ASTTest(phase=INSTRUCTION_SELECTION, value={
                 def type = node.getNodeMetaData(INFERRED_TYPE)
                 assert type.genericsTypes[0].toString() == 'java.lang.String'
-                assert type.genericsTypes[1].toString() == 'java.util.List<java.lang.Object>' // not List<E>
+                assert type.genericsTypes[1].toString() == 'java.util.ArrayList<java.lang.Object>' // not <E>
             })
             def map = [ key: [] ]
         '''
@@ -2728,7 +2728,7 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
 
         assertScript base + '''
             @ASTTest(phase=INSTRUCTION_SELECTION, value={
-                assert node.getNodeMetaData(INFERRED_TYPE) == LIST_TYPE
+                assert node.getNodeMetaData(INFERRED_TYPE).implementsInterface(LIST_TYPE)
                 assert node.getNodeMetaData(INFERRED_TYPE).genericsTypes[0].type instanceof LUB
             })
             def list = ["foo", "$bar"]
@@ -2736,7 +2736,7 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
 
         shouldFailWithMessages base + '''
             @ASTTest(phase=INSTRUCTION_SELECTION, value={
-                assert node.getNodeMetaData(INFERRED_TYPE) == LIST_TYPE
+                assert node.getNodeMetaData(INFERRED_TYPE).implementsInterface(LIST_TYPE)
                 assert node.getNodeMetaData(INFERRED_TYPE).genericsTypes[0].type instanceof LUB
             })
             List<String> list = ["foo", "$bar"]
@@ -2745,7 +2745,7 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
 
         shouldFailWithMessages base + '''
             @ASTTest(phase=INSTRUCTION_SELECTION, value={
-                assert node.getNodeMetaData(INFERRED_TYPE) == LIST_TYPE
+                assert node.getNodeMetaData(INFERRED_TYPE).implementsInterface(LIST_TYPE)
                 assert node.getNodeMetaData(INFERRED_TYPE).genericsTypes[0].type == GSTRING_TYPE // single element means no LUB
             })
             List<String> list = ["$bar"]
diff --git a/src/test/groovy/transform/stc/MethodCallsSTCTest.groovy b/src/test/groovy/transform/stc/MethodCallsSTCTest.groovy
index 5e7602014f..417d02d36c 100644
--- a/src/test/groovy/transform/stc/MethodCallsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/MethodCallsSTCTest.groovy
@@ -226,7 +226,7 @@ class MethodCallsSTCTest extends StaticTypeCheckingTestCase {
             }
             m([1,2,3,3])
         ''',
-        'm(java.util.List<java.lang.Integer>). Please check if the declared type is correct and if the method exists.'
+        'Cannot find matching method','m(java.util.ArrayList<java.lang.Integer>). Please check if the declared type is correct and if the method exists.'
     }
 
     // GROOVY-7106, GROOVY-7274, GROOVY-9844
diff --git a/src/test/groovy/transform/stc/STCAssignmentTest.groovy b/src/test/groovy/transform/stc/STCAssignmentTest.groovy
index c4dca150bb..efbddd421c 100644
--- a/src/test/groovy/transform/stc/STCAssignmentTest.groovy
+++ b/src/test/groovy/transform/stc/STCAssignmentTest.groovy
@@ -1314,7 +1314,7 @@ class STCAssignmentTest extends StaticTypeCheckingTestCase {
                     } else if (value instanceof GString) {
                         value = value.toString()
                     }
-                    mvm.computeIfAbsent(name, k -> []).add(value)
+                    mvm.computeIfAbsent(name, k -> [] as List<Object>).add(value)
                 }
             }
             new M().setProperty('foo', 'bar')
diff --git a/src/test/groovy/transform/stc/STCnAryExpressionTest.groovy b/src/test/groovy/transform/stc/STCnAryExpressionTest.groovy
index ad2e05ed0f..54e11ffdc9 100644
--- a/src/test/groovy/transform/stc/STCnAryExpressionTest.groovy
+++ b/src/test/groovy/transform/stc/STCnAryExpressionTest.groovy
@@ -270,7 +270,7 @@ class STCnAryExpressionTest extends StaticTypeCheckingTestCase {
         shouldFailWithMessages '''
             [] < 1
         ''',
-        'Cannot find matching method java.util.List#compareTo(int)'
+        'Cannot find matching method java.util.ArrayList#compareTo(int)'
     }
 
     void testComparisonOperatorCheckWithIncompatibleTypesFailsIfComparableImplemented() {
diff --git a/src/test/groovy/transform/stc/TypeInferenceSTCTest.groovy b/src/test/groovy/transform/stc/TypeInferenceSTCTest.groovy
index b8d3478e28..bd8e467d7e 100644
--- a/src/test/groovy/transform/stc/TypeInferenceSTCTest.groovy
+++ b/src/test/groovy/transform/stc/TypeInferenceSTCTest.groovy
@@ -1283,7 +1283,7 @@ class TypeInferenceSTCTest extends StaticTypeCheckingTestCase {
                     lookup('test').each {
                         def call = it.expression
                         def type = call.getNodeMetaData(INFERRED_TYPE)
-                        assert type == LIST_TYPE
+                        assert type.implementsInterface(LIST_TYPE)
                     }
                 })
                 static void run() {
diff --git a/src/test/org/apache/groovy/parser/antlr4/util/ASTComparatorCategory.groovy b/src/test/org/apache/groovy/parser/antlr4/util/ASTComparatorCategory.groovy
index 1248e865de..e69f5ffd0a 100644
--- a/src/test/org/apache/groovy/parser/antlr4/util/ASTComparatorCategory.groovy
+++ b/src/test/org/apache/groovy/parser/antlr4/util/ASTComparatorCategory.groovy
@@ -187,7 +187,7 @@ class ASTComparatorCategory {
     ].asUnmodifiable()
 
     public static final Map<Class, List<String>> COLLECTION_PROPERTY_CONFIGURATION = [
-            (ModuleNode): ['classes', 'name']
+            (ModuleNode): ['classes', 'name'] as List<String>
     ].asUnmodifiable()
 
     public static Map<Class, List<String>> configuration = DEFAULT_CONFIGURATION
diff --git a/subprojects/groovy-ginq/src/main/groovy/org/apache/groovy/ginq/dsl/GinqAstOptimizer.groovy b/subprojects/groovy-ginq/src/main/groovy/org/apache/groovy/ginq/dsl/GinqAstOptimizer.groovy
index acb5cfac0f..225984f2c7 100644
--- a/subprojects/groovy-ginq/src/main/groovy/org/apache/groovy/ginq/dsl/GinqAstOptimizer.groovy
+++ b/subprojects/groovy-ginq/src/main/groovy/org/apache/groovy/ginq/dsl/GinqAstOptimizer.groovy
@@ -37,6 +37,7 @@ import org.codehaus.groovy.syntax.Token
 import org.codehaus.groovy.syntax.Types
 
 import java.util.stream.Collectors
+
 /**
  * Optimize the execution plan of GINQ through transforming AST.
  * <p>
@@ -315,14 +316,10 @@ class GinqAstOptimizer extends GinqAstBaseVisitor {
             return
         }
 
-        final alias = usedAliasSet[0]
-        if (!optimizingAliasList.contains(alias)) {
-            return
-        }
-
-        if (toAdd) {
-            expression.putNodeMetaData(TO_OPTIMIZE, true)
-            conditionsToOptimize.computeIfAbsent(alias, k -> []).add(expression)
+        String alias = usedAliasSet[0]
+        if (toAdd && optimizingAliasList.contains(alias)) {
+            expression.putNodeMetaData(TO_OPTIMIZE, Boolean.TRUE)
+            conditionsToOptimize.computeIfAbsent(alias, k -> new ArrayList<>()).add(expression)
         }
     }
 
