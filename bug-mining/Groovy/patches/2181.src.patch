diff --git a/src/main/groovy/transform/EqualsAndHashCode.java b/src/main/groovy/transform/EqualsAndHashCode.java
index fc2e8dcda9..064a532b18 100644
--- a/src/main/groovy/transform/EqualsAndHashCode.java
+++ b/src/main/groovy/transform/EqualsAndHashCode.java
@@ -177,15 +177,18 @@ import java.lang.annotation.Target;
  * assert  new Point1D(1, 1, 1).equals(new Point1D(1, 2, 1))
  * assert !new Point1D(1, 1, 1).equals(new Point1D(2, 1, 1))
  * </pre>
- * Note: {@code @EqualsAndHashCode} is a tool to help reduce boilerplate
+ * <b>Note:</b> {@code @EqualsAndHashCode} is a transform to help reduce boilerplate
  * in the common cases. It provides a useful implementation of {@code equals()}
  * and {@code hashCode()} but not necessarily the most appropriate or
  * efficient one for every use case. You should write custom versions if your
- * scenario demands it. In particular, if you have self-referential (for hashCode()) or
- * mutually-referential classes (for equals()) the implementations provided may not be suitable
- * and may recurse infinitely. In such cases, you need to remove the infinite loop from
- * your data structures or write your own custom methods. A future version of this
- * transform may better handle some recursive scenarios.
+ * scenario demands it. In particular, if you have
+ * mutually-referential classes, the implementations provided may not be suitable
+ * and may recurse infinitely (leading to a {@code StackOverflowError}). In such cases,
+ * you need to remove the infinite loop from your data structures or write your own custom methods.
+ * If your data structures are self-referencing, the code generated by this transform will try to avoid
+ * infinite recursion but the algorithm used may not suit your scenario, so use with caution if
+ * you have such structures.
+ * A future version of this transform may better handle some additional recursive scenarios.
  *
  * @see org.codehaus.groovy.util.HashCodeHelper
  * @author Paul King
diff --git a/src/main/org/codehaus/groovy/transform/EqualsAndHashCodeASTTransformation.java b/src/main/org/codehaus/groovy/transform/EqualsAndHashCodeASTTransformation.java
index 35204698a4..57e8db9829 100644
--- a/src/main/org/codehaus/groovy/transform/EqualsAndHashCodeASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/EqualsAndHashCodeASTTransformation.java
@@ -126,21 +126,25 @@ public class EqualsAndHashCodeASTTransformation extends AbstractASTTransformatio
 
         for (PropertyNode pNode : pList) {
             if (shouldSkip(pNode.getName(), excludes, includes)) continue;
-            // _result = HashCodeHelper.updateHash(_result, getProperty())
+            // _result = HashCodeHelper.updateHash(_result, getProperty()) // plus self-reference checking
             String getterName = "get" + Verifier.capitalize(pNode.getName());
             Expression getter = new MethodCallExpression(VariableExpression.THIS_EXPRESSION, getterName, MethodCallExpression.NO_ARGUMENTS);
             final Expression args = new TupleExpression(result, getter);
             final Expression current = new StaticMethodCallExpression(HASHUTIL_TYPE, "updateHash", args);
-            body.addStatement(assignStatement(result, current));
+            body.addStatement(new IfStatement(identicalExpr(getter, new VariableExpression("this")),
+                    EmptyStatement.INSTANCE,
+                    assignStatement(result, current)));
 
         }
         for (FieldNode fNode : fList) {
             if (shouldSkip(fNode.getName(), excludes, includes)) continue;
-            // _result = HashCodeHelper.updateHash(_result, field)
+            // _result = HashCodeHelper.updateHash(_result, field) // plus self-reference checking
             final Expression fieldExpr = new VariableExpression(fNode);
             final Expression args = new TupleExpression(result, fieldExpr);
             final Expression current = new StaticMethodCallExpression(HASHUTIL_TYPE, "updateHash", args);
-            body.addStatement(assignStatement(result, current));
+            body.addStatement(new IfStatement(identicalExpr(fieldExpr, new VariableExpression("this")),
+                    EmptyStatement.INSTANCE,
+                    assignStatement(result, current)));
         }
         if (callSuper) {
             // _result = HashCodeHelper.updateHash(_result, super.hashCode())
diff --git a/src/test/org/codehaus/groovy/transform/CanonicalTransformTest.groovy b/src/test/org/codehaus/groovy/transform/CanonicalTransformTest.groovy
index 3348df75b2..7e340c809e 100644
--- a/src/test/org/codehaus/groovy/transform/CanonicalTransformTest.groovy
+++ b/src/test/org/codehaus/groovy/transform/CanonicalTransformTest.groovy
@@ -526,10 +526,33 @@ class CanonicalTransformTest extends GroovyShellTestCase {
             def s = new Tree()
             s.left = s
             s.item = 4
-            // not smart enough to handle mutual-recursion yet
-            //t.right = s
-            //s.right = t
             assert s.equals(t)
+            // not smart enough to handle mutual-recursion yet
+            // don't use this annotation in such a scenario
+            //
+            // t.right = s
+            // s.right = t
+            // assert s.equals(t) // <= StackOverflowError
+        """
+    }
+
+    void testHashCodeCopesWithSelfReference() {
+        assertScript """
+            @groovy.transform.Canonical class Tree {
+                Object item
+                Tree left, right
+            }
+
+            def t = new Tree(4)
+            t.left = t
+            t.right = t
+            assert t.hashCode() == 3941
+            // not smart enough to handle mutual-recursion yet
+            // don't use this annotation in such a scenario
+            //
+            // def s = new Tree(5, t)
+            // t.left = s
+            // println t.hashCode() // <= StackOverflowError
         """
     }
 
