diff --git a/src/main/org/codehaus/groovy/classgen/asm/MopWriter.java b/src/main/org/codehaus/groovy/classgen/asm/MopWriter.java
index 2acf4d6837..a435634949 100644
--- a/src/main/org/codehaus/groovy/classgen/asm/MopWriter.java
+++ b/src/main/org/codehaus/groovy/classgen/asm/MopWriter.java
@@ -168,7 +168,7 @@ public class MopWriter {
      * @param mopCalls list of methods a mop call method should be generated for
      * @param useThis  true if "this" should be used for the naming
      */
-    private void generateMopCalls(LinkedList<MethodNode> mopCalls, boolean useThis) {
+    protected void generateMopCalls(LinkedList<MethodNode> mopCalls, boolean useThis) {
         for (MethodNode method : mopCalls) {
             String name = getMopMethodName(method, useThis);
             Parameter[] parameters = method.getParameters();
diff --git a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticCompilationMopWriter.java b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticCompilationMopWriter.java
index 8f3c3b0669..f0e8814f78 100644
--- a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticCompilationMopWriter.java
+++ b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticCompilationMopWriter.java
@@ -15,8 +15,13 @@
  */
 package org.codehaus.groovy.classgen.asm.sc;
 
+import org.codehaus.groovy.ast.ClassNode;
+import org.codehaus.groovy.ast.MethodNode;
 import org.codehaus.groovy.classgen.asm.MopWriter;
 import org.codehaus.groovy.classgen.asm.WriterController;
+import org.codehaus.groovy.transform.stc.StaticTypesMarker;
+
+import java.util.LinkedList;
 
 /**
  * A MOP Writer that skips the generation of MOP methods. This writer is used
@@ -44,7 +49,11 @@ public class StaticCompilationMopWriter extends MopWriter {
 
 
     public void createMopMethods() {
-
+        ClassNode classNode = controller.getClassNode();
+        LinkedList<MethodNode> requiredMopMethods = classNode.getNodeMetaData(StaticTypesMarker.SUPER_MOP_METHOD_REQUIRED);
+        if (requiredMopMethods!=null) {
+            generateMopCalls(requiredMopMethods, false);
+        }
     }
 
 }
diff --git a/src/main/org/codehaus/groovy/transform/sc/transformers/MethodCallExpressionTransformer.java b/src/main/org/codehaus/groovy/transform/sc/transformers/MethodCallExpressionTransformer.java
index 7a18563950..1e8f00bfe6 100644
--- a/src/main/org/codehaus/groovy/transform/sc/transformers/MethodCallExpressionTransformer.java
+++ b/src/main/org/codehaus/groovy/transform/sc/transformers/MethodCallExpressionTransformer.java
@@ -18,17 +18,23 @@ package org.codehaus.groovy.transform.sc.transformers;
 import org.codehaus.groovy.ast.ClassHelper;
 import org.codehaus.groovy.ast.ClassNode;
 import org.codehaus.groovy.ast.FieldNode;
+import org.codehaus.groovy.ast.MethodNode;
 import org.codehaus.groovy.ast.expr.BinaryExpression;
 import org.codehaus.groovy.ast.expr.Expression;
 import org.codehaus.groovy.ast.expr.MethodCallExpression;
 import org.codehaus.groovy.ast.expr.TupleExpression;
 import org.codehaus.groovy.ast.expr.VariableExpression;
+import org.codehaus.groovy.ast.stmt.EmptyStatement;
+import org.codehaus.groovy.classgen.asm.MopWriter;
 import org.codehaus.groovy.syntax.Token;
 import org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor;
 import org.codehaus.groovy.transform.stc.StaticTypesMarker;
 
 import java.util.List;
 
+import static org.objectweb.asm.Opcodes.ACC_PUBLIC;
+import static org.objectweb.asm.Opcodes.ACC_SYNTHETIC;
+
 public class MethodCallExpressionTransformer {
     private final StaticCompilationTransformer staticCompilationTransformer;
 
@@ -37,6 +43,10 @@ public class MethodCallExpressionTransformer {
     }
 
     Expression transformMethodCallExpression(final MethodCallExpression expr) {
+        ClassNode superCallReceiver = expr.getNodeMetaData(StaticTypesMarker.SUPER_MOP_METHOD_REQUIRED);
+        if (superCallReceiver!=null) {
+            return transformMethodCallExpression(transformToMopSuperCall(superCallReceiver, expr));
+        }
         Expression objectExpression = expr.getObjectExpression();
         ClassNode type = staticCompilationTransformer.getTypeChooser().resolveType(objectExpression, staticCompilationTransformer.getClassNode());
         if (isCallOnClosure(expr)) {
@@ -111,6 +121,31 @@ public class MethodCallExpressionTransformer {
         return staticCompilationTransformer.superTransform(expr);
     }
 
+    private MethodCallExpression transformToMopSuperCall(final ClassNode superCallReceiver, final MethodCallExpression expr) {
+        MethodNode mn = expr.getNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET);
+        String mopName = MopWriter.getMopMethodName(mn, false);
+        MethodNode direct = new MethodNode(
+                mopName,
+                ACC_PUBLIC | ACC_SYNTHETIC,
+                mn.getReturnType(),
+                mn.getParameters(),
+                mn.getExceptions(),
+                EmptyStatement.INSTANCE
+        );
+        direct.setDeclaringClass(superCallReceiver);
+        MethodCallExpression result = new MethodCallExpression(
+                new VariableExpression("this"),
+                mopName,
+                expr.getArguments()
+        );
+        result.setImplicitThis(true);
+        result.setSpreadSafe(false);
+        result.setSafe(false);
+        result.setSourcePosition(expr);
+        result.setMethodTarget(direct);
+        return result;
+    }
+
     private boolean isCallOnClosure(final MethodCallExpression expr) {
         return expr.isImplicitThis()
                 && expr.getNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET) == StaticTypeCheckingVisitor.CLOSURE_CALL_VARGS
diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index e0f4371c0e..1b4c858939 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -366,6 +366,25 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         }
     }
 
+    private void checkSuperCallFromClosure(Expression call, MethodNode directCallTarget) {
+        if (call instanceof MethodCallExpression && typeCheckingContext.getEnclosingClosure() != null) {
+            Expression objectExpression = ((MethodCallExpression)call).getObjectExpression();
+            if (objectExpression instanceof VariableExpression) {
+                VariableExpression var = (VariableExpression) objectExpression;
+                if (var.isSuperExpression()) {
+                    ClassNode current = typeCheckingContext.getEnclosingClassNode();
+                    LinkedList<MethodNode> list = current.getNodeMetaData(StaticTypesMarker.SUPER_MOP_METHOD_REQUIRED);
+                    if (list == null) {
+                        list = new LinkedList<MethodNode>();
+                        current.putNodeMetaData(StaticTypesMarker.SUPER_MOP_METHOD_REQUIRED, list);
+                    }
+                    list.add(directCallTarget);
+                    call.putNodeMetaData(StaticTypesMarker.SUPER_MOP_METHOD_REQUIRED, current);
+                }
+            }
+        }
+    }
+
     /**
      * wrap type in Class<> if usingClass==true
      */
@@ -3002,6 +3021,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
     protected void storeTargetMethod(final Expression call, final MethodNode directMethodCallCandidate) {
         call.putNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET, directMethodCallCandidate);
         checkOrMarkPrivateAccess(directMethodCallCandidate);
+        checkSuperCallFromClosure(call, directMethodCallCandidate);
         extension.onMethodSelection(call, directMethodCallCandidate);
     }
 
diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypesMarker.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypesMarker.java
index a7a7559a32..cfc51a2227 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypesMarker.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypesMarker.java
@@ -32,5 +32,6 @@ public enum StaticTypesMarker {
     IMPLICIT_RECEIVER, // if the receiver is implicit but not "this", store the name of the receiver (delegate or owner)
     PV_FIELDS_ACCESS, // set of private fields that are accessed from closures or inner classes
     PV_METHODS_ACCESS, // set of private methods that are accessed from closures or inner classes
-    DYNAMIC_RESOLUTION // call recognized by a type checking extension as a dynamic method call
+    DYNAMIC_RESOLUTION, // call recognized by a type checking extension as a dynamic method call
+    SUPER_MOP_METHOD_REQUIRED // used to store the list of MOP methods that still have to be generated
 }
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7138Bug.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7138Bug.groovy
new file mode 100644
index 0000000000..209f12bf7c
--- /dev/null
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7138Bug.groovy
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2003-2014 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+
+package org.codehaus.groovy.classgen.asm.sc.bugs
+
+import groovy.transform.stc.StaticTypeCheckingTestCase
+import org.codehaus.groovy.classgen.asm.sc.StaticCompilationTestSupport
+
+class Groovy7138Bug extends StaticTypeCheckingTestCase implements StaticCompilationTestSupport {
+    void testCallSuperFromAClosure() {
+        assertScript '''
+            class Top {
+               int x() { 3 }
+            }
+
+            class Bottom extends Top {
+               int x() {
+                  int y = 0
+                  def t = Thread.start { y=2*super.x() }
+                  t.join()
+                  y
+               }
+            }
+
+            assert new Bottom().x() == 6
+        '''
+    }
+
+    void testCallSuperFromAClosureWithParameter() {
+        assertScript '''
+            class Top {
+               int x(int y) { 3+y }
+            }
+
+            class Bottom extends Top {
+               int x(int d) {
+                  int y = 0
+                  def t = Thread.start { y=2*super.x(d) }
+                  t.join()
+                  y
+               }
+            }
+
+            assert new Bottom().x(4) == 14
+        '''
+    }
+}
