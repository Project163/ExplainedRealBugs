diff --git a/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java b/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java
index a28843a4f9..042ec078a2 100644
--- a/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java
+++ b/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java
@@ -1652,7 +1652,6 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
         } else if (isType(IDENT, node)) {
             objectExpression = VariableExpression.THIS_EXPRESSION;
             selector = node;
-
         } else {
             objectExpression = expression(node);
             selector = null;  // implicit "call"
@@ -1671,6 +1670,15 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
             throw new ASTRuntimeException(selector, "Primitive type literal: " + selector.getText()
                     + " cannot be used as a method name");
         }
+        else if (isType(SELECT_SLOT, selector)) {
+            String field = identifier(selector.getFirstChild());
+            AttributeExpression attributeExpression = new AttributeExpression(objectExpression, field, node.getType() != DOT);
+            configureAST(attributeExpression, node);
+            Expression arguments = arguments(elist);
+            MethodCallExpression expression = new MethodCallExpression(attributeExpression, "call", arguments);
+            configureAST(expression, methodCallNode);
+            return expression;
+        }
         else {
             name = identifier(selector);
         }
diff --git a/src/test/UberTestCase2.java b/src/test/UberTestCase2.java
index c5e5b26bfe..564ae42664 100644
--- a/src/test/UberTestCase2.java
+++ b/src/test/UberTestCase2.java
@@ -35,6 +35,7 @@ public class UberTestCase2 extends TestCase {
         suite.addTestSuite(groovy.bugs.Groovy872.class);
         suite.addTestSuite(groovy.bugs.Groovy996_Bug.class);
         suite.addTestSuite(groovy.bugs.Groovy1018_Bug.class);
+        suite.addTestSuite(groovy.bugs.Groovy1059_Bug.class);
         suite.addTestSuite(groovy.bugs.IanMaceysBug.class);
         suite.addTestSuite(groovy.bugs.InterfaceImplBug.class);
         suite.addTestSuite(groovy.bugs.MarkupInScriptBug.class);
diff --git a/src/test/groovy/bugs/Groovy1059_Bug.groovy b/src/test/groovy/bugs/Groovy1059_Bug.groovy
new file mode 100644
index 0000000000..1faaebc8c8
--- /dev/null
+++ b/src/test/groovy/bugs/Groovy1059_Bug.groovy
@@ -0,0 +1,52 @@
+package groovy.bugs
+
+/**
+ * TODO: GROOVY-1059
+ *
+ *    Accessible to a closure attribute of an abject with the operator ".@".
+ *    For examples, all of the expressions
+ *
+ *            object.@closure()
+ *            object.@closure.call()
+ *            object.@closure.doCall()
+ *            (object.@closure)()
+ *
+ *    have the same meaning.
+ *
+ * @author  Pilho Kim
+ */
+
+class Groovy1059_Bug extends GroovyTestCase {
+
+    void testClosureAsAttribute() {
+        def x = new Groovy1059Foo()
+
+        println( x.say() )
+        println( (x.@say)() )
+        println( x.@say() )  // TODO: Groovy-1059 should work
+        println( x.@say.call() )
+        println( x.@say.doCall() )
+        println( x.@say2() )
+
+        assert "I am a Method" == x.say()
+        assert "I am a Method" == x.@say2()
+        assert "I am a Closure" == (x.@say)()
+        assert "I am a Closure" == x.@say()
+        assert x.@say() == (x.@say)()
+        assert x.@say() == x.@say.call()
+        assert x.@say() == x.@say.doCall()
+        assert x.@say() != x.say()
+        assert x.@say2() == x.say()
+    }
+
+}
+
+class Groovy1059Foo {
+
+    def public say = { it -> return "I am a Closure" }
+    def public say2 = this.&say
+
+    public Object say() {
+       return "I am a Method"
+    }
+}
