diff --git a/src/main/org/codehaus/groovy/ast/ClassNode.java b/src/main/org/codehaus/groovy/ast/ClassNode.java
index 045bc17127..19b3b0acb2 100644
--- a/src/main/org/codehaus/groovy/ast/ClassNode.java
+++ b/src/main/org/codehaus/groovy/ast/ClassNode.java
@@ -15,14 +15,12 @@
  */
 package org.codehaus.groovy.ast;
 
-import groovy.lang.GroovyObject;
 import org.codehaus.groovy.GroovyBugError;
 import org.codehaus.groovy.ast.expr.ClassExpression;
 import org.codehaus.groovy.ast.expr.Expression;
 import org.codehaus.groovy.ast.expr.TupleExpression;
-import org.codehaus.groovy.ast.stmt.BlockStatement;
-import org.codehaus.groovy.ast.stmt.EmptyStatement;
 import org.codehaus.groovy.ast.stmt.Statement;
+import org.codehaus.groovy.ast.stmt.BlockStatement;
 import org.codehaus.groovy.control.CompilePhase;
 import org.codehaus.groovy.transform.ASTTransformation;
 import org.codehaus.groovy.transform.GroovyASTTransformation;
@@ -30,24 +28,23 @@ import org.codehaus.groovy.vmplugin.VMPluginFactory;
 import org.objectweb.asm.Opcodes;
 
 import java.lang.reflect.Array;
-import java.lang.reflect.Constructor;
-import java.lang.reflect.Field;
-import java.lang.reflect.Method;
 import java.util.*;
 
+import groovy.lang.GroovyObject;
+
 /**
  * Represents a class in the AST.<br/>
- * A ClassNode should be created using the methods in ClassHelper. 
+ * A ClassNode should be created using the methods in ClassHelper.
  * This ClassNode may be used to represent a class declaration or
  * any other type. This class uses a proxy meschanism allowing to
- * create a class for a plain name at ast creation time. In another 
+ * create a class for a plain name at ast creation time. In another
  * phase of the compiler the real ClassNode for the plain name may be
- * found. To avoid the need of exchanging this ClassNode with an 
- * instance of the correct ClassNode the correct ClassNode is set as 
+ * found. To avoid the need of exchanging this ClassNode with an
+ * instance of the correct ClassNode the correct ClassNode is set as
  * redirect. Most method calls are then redirected to that ClassNode.
  * <br>
  * <b>Note:</b> the proxy mechanism is only allowed for classes being marked
- * as primary ClassNode which means they represent no actual class. 
+ * as primary ClassNode which means they represent no actual class.
  * The redirect itself can be any type of ClassNode
  * <br>
  * To descirbe generic type signature see {@link #getGenericsTypes()} and
@@ -57,7 +54,7 @@ import java.util.*;
  * by the class are needed, then a call to {@link #redirect()} will help.
  *
  * @see org.codehaus.groovy.ast.ClassHelper
- * 
+ *
  * @author <a href="mailto:james@coredevelopers.net">James Strachan</a>
  * @author Jochen Theodorou
  * @version $Revision$
@@ -82,14 +79,14 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
                 list.add(value);
                 map.put(key, list);
             }
-        }        
+        }
     }
-    
+
     public static ClassNode[] EMPTY_ARRAY = new ClassNode[0];
-    
+
     public static ClassNode THIS = new ClassNode(Object.class);
     public static ClassNode SUPER = new ClassNode(Object.class);
-    
+
     private String name;
     private final int modifiers;
     private ClassNode[] interfaces;
@@ -107,7 +104,7 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
     private boolean scriptBody = false;
     private boolean script;
     private ClassNode superClass;
-    boolean isPrimaryNode;
+    protected boolean isPrimaryNode;
 
     /**
      * The ASTTransformations to be applied to the Class
@@ -120,24 +117,24 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
 
     // clazz!=null when resolved
     protected Class clazz;
-    // only false when this classNode is constructed from a class 
+    // only false when this classNode is constructed from a class
     private boolean lazyInitDone=true;
-    // not null if if the ClassNode is an array 
+    // not null if if the ClassNode is an array
     private ClassNode componentType = null;
-    // if not null this instance is handled as proxy 
+    // if not null this instance is handled as proxy
     // for the redirect
-    private ClassNode redirect=null; 
+    private ClassNode redirect=null;
     // flag if the classes or its members are annotated
     private boolean annotated;
-    
+
     // type spec for generics
     private GenericsType[] genericsTypes=null;
     private boolean usesGenerics=false;
-    
+
     // if set to true the name getGenericsTypes consists
     // of 1 element describing the name of the placeholder
     private boolean placeholder;
-    
+
     /**
      * Returns the ClassNode this ClassNode is redirecting to.
      */
@@ -145,9 +142,9 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
         if (redirect==null) return this;
         return redirect.redirect();
     }
-    
+
     /**
-     * Sets this instance as proxy for the given ClassNode. 
+     * Sets this instance as proxy for the given ClassNode.
      * @param cn the class to redirect to. If set to null the redirect will be removed
      */
     public void setRedirect(ClassNode cn) {
@@ -156,7 +153,7 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
         if (cn==this) return;
         redirect = cn;
     }
-    
+
     /**
      * Returns a ClassNode representing an array of the class
      * represented by this ClassNode
@@ -173,14 +170,14 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
         }
         return cn;
     }
-    
+
     /**
      * Returns if this instance is a primary ClassNode
      */
     public boolean isPrimaryClassNode(){
     	return redirect().isPrimaryNode || (componentType!= null && componentType.isPrimaryClassNode());
     }
-    
+
     /**
      * Constructor used by makeArray() if no real class is available
      */
@@ -189,7 +186,7 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
         this.componentType = componentType.redirect();
         isPrimaryNode=false;
     }
-    
+
     /**
      * Constructor used by makeArray() if a real class is available
      */
@@ -198,9 +195,9 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
         this.componentType = componentType;
         isPrimaryNode=false;
     }
-    
+
     /**
-     * Creates a ClassNode from a real class. The resulting 
+     * Creates a ClassNode from a real class. The resulting
      * ClassNode will be no primary ClassNode.
      */
     public ClassNode(Class c) {
@@ -210,62 +207,20 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
         CompileUnit cu = getCompileUnit();
         if (cu!=null) cu.addClass(this);
         isPrimaryNode=false;
-    }    
-    
+    }
+
     /**
      * The complete class structure will be initialized only when really
      * needed to avoid having too much objects during compilation
      */
-    private void lazyClassInit() {       
+    private void lazyClassInit() {
         synchronized (lazyInitLock) {
             if (lazyInitDone) return;
-            
-            Field[] fields = clazz.getDeclaredFields();
-            for (int i=0;i<fields.length;i++){
-                addField(fields[i].getName(),fields[i].getModifiers(),this,null);
-            }
-            Method[] methods = clazz.getDeclaredMethods();
-            for (int i=0;i<methods.length;i++){
-                Method m = methods[i];
-                MethodNode mn = new MethodNode(m.getName(), m.getModifiers(), ClassHelper.make(m.getReturnType()), createParameters(m.getParameterTypes()), ClassHelper.make(m.getExceptionTypes()), null);
-                VMPluginFactory.getPlugin().setMethodDefaultValue(mn,m);
-                addMethod(mn);
-            }
-            Constructor[] constructors = clazz.getDeclaredConstructors();
-            for (int i=0;i<constructors.length;i++){
-                Constructor ctor = constructors[i];
-                addConstructor(ctor.getModifiers(),createParameters(ctor.getParameterTypes()),ClassHelper.make(ctor.getExceptionTypes()),null);
-            }
-            Class sc = clazz.getSuperclass();
-            if (sc!=null) superClass = getPrimaryClassNode(sc);
-            buildInterfaceTypes(clazz);
-            VMPluginFactory.getPlugin().setAnnotationMetaData(this);
-            lazyInitDone=true;
+            VMPluginFactory.getPlugin().configureClassNode(compileUnit,this);
+            lazyInitDone = true;
         }
     }
 
-    private ClassNode getPrimaryClassNode(Class clazz) {
-        // there might be a new super class from the compile unit,
-        // we want to use this instead of simply referencing the old
-        // class
-        ClassNode result = null;
-        if (compileUnit!=null) {
-            result = compileUnit.getClass(clazz.getName());
-        }
-        if (result==null) result = ClassHelper.make(clazz);
-        return result;
-    }    
-    
-    private void buildInterfaceTypes(Class c) {
-        Class[] interfaces = c.getInterfaces();
-        ClassNode[] ret = new ClassNode[interfaces.length];
-        for (int i=0;i<interfaces.length;i++){
-            ret[i] = getPrimaryClassNode(interfaces[i]);
-        }
-        this.interfaces = ret;
-    }
-    
-    
     // added to track the enclosing method for local inner classes
     private MethodNode enclosingMethod = null;
 
@@ -323,7 +278,6 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
         }
     }
 
-    
     /**
      * Sets the superclass of this ClassNode
      */
@@ -355,6 +309,14 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
         return interfaces;
     }
 
+    public void setInterfaces(ClassNode[] interfaces) {
+        if (redirect!=null) {
+            redirect().setInterfaces(interfaces);
+        } else {
+            this.interfaces = interfaces;
+        }
+    }
+
     public MixinNode[] getMixins() {
         return redirect().mixins;
     }
@@ -362,7 +324,7 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
     /**
      * Returns a list containing MethodNode objects for
      * each method in the class represented by this ClassNode
-     */    
+     */
     public List getMethods() {
         if (!lazyInitDone) lazyClassInit();
         if (redirect!=null) return redirect().getMethods();
@@ -371,14 +333,14 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
 
     /**
      * Returns a list containing MethodNode objects for
-     * each abstract method in the class represented by 
+     * each abstract method in the class represented by
      * this ClassNode
-     */   
+     */
     public List getAbstractMethods() {
-        
+
         HashSet abstractNodes = new HashSet();
         // let us collect the abstract super classes and stop at the
-        // first non abstract super class. If such a class still 
+        // first non abstract super class. If such a class still
         // contains abstract methods, then loading that class will fail.
         // No need to be extra careful here for that.
         ClassNode parent = this.redirect();
@@ -394,13 +356,13 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
             }
             parent = parent.getSuperClass().redirect();
         } while (parent!=null && ((parent.getModifiers() & Opcodes.ACC_ABSTRACT) != 0));
-        
+
         List result = new ArrayList();
         for (Iterator methIt = getAllDeclaredMethods().iterator(); methIt.hasNext();) {
             MethodNode method = (MethodNode) methIt.next();
             // add only abstract methods from abtract classes that
             // are not overwritten
-            if ( abstractNodes.contains(method.getDeclaringClass().redirect()) && 
+            if ( abstractNodes.contains(method.getDeclaringClass().redirect()) &&
                  (method.getModifiers() & Opcodes.ACC_ABSTRACT) != 0
                ) {
                 result.add(method);
@@ -456,7 +418,7 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
     public String getName() {
         return redirect().name;
     }
-    
+
     public String setName(String name) {
         return redirect().name=name;
     }
@@ -526,7 +488,7 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
 
                 if (pn.getSetterBlock() == null && setterBlock != null)
                   pn.setSetterBlock(setterBlock);
-                
+
                 return pn;
             }
         }
@@ -612,10 +574,10 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
             redirect().interfaces = newInterfaces;
         }
     }
-    
+
     public boolean equals(Object o) {
         if (redirect!=null) return redirect().equals(o);
-        ClassNode cn = (ClassNode) o;        
+        ClassNode cn = (ClassNode) o;
         return (cn.getName().equals(getName()));
     }
 
@@ -654,11 +616,11 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
     public ClassNode getOuterClass() {
         return null;
     }
-    
+
     public void addObjectInitializerStatements(Statement statements) {
         objectInitializers.add(statements);
     }
-    
+
     public List getObjectInitializerStatements() {
         return objectInitializers;
     }
@@ -686,8 +648,8 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
             block = new BlockStatement();
             block.addStatement(statement);
         }
-        
-        // while anything inside a static initializer block is appended 
+
+        // while anything inside a static initializer block is appended
         // we don't want to append in the case we have a initialization
         // expression of a static field. In that case we want to add
         // before the other statements
@@ -805,7 +767,7 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
         if (sn!=null) sn=sn.redirect();
         return sn;
     }
-    
+
     public ClassNode getUnresolvedSuperClass() {
         return getUnresolvedSuperClass(true);
     }
@@ -817,32 +779,9 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
         }
         return redirect().superClass;
     }
-    
-    /**
-     * Factory method to create a new MethodNode via reflection
-     */
-    protected MethodNode createMethodNode(Method method) {
-        Parameter[] parameters = createParameters(method.getParameterTypes());
-        return new MethodNode(method.getName(), method.getModifiers(), ClassHelper.make(method.getReturnType()), parameters, ClassHelper.make(method.getExceptionTypes()), EmptyStatement.INSTANCE);
-    }
-
-    /**
-     * @param types
-     */
-    protected Parameter[] createParameters(Class[] types) {
-        Parameter[] parameters = Parameter.EMPTY_ARRAY;
-        int size = types.length;
-        if (size > 0) {
-            parameters = new Parameter[size];
-            for (int i = 0; i < size; i++) {
-                parameters[i] = createParameter(types[i], i);
-            }
-        }
-        return parameters;
-    }
 
-    protected Parameter createParameter(Class parameterType, int idx) {
-        return new Parameter(ClassHelper.make(parameterType), "param" + idx);
+    public void setUnresolvedSuperClass(ClassNode sn) {
+        superClass = sn;
     }
 
     public CompileUnit getCompileUnit() {
@@ -852,7 +791,7 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
         }
         return compileUnit;
     }
-    
+
     protected void setCompileUnit(CompileUnit cu) {
         if (redirect!=null) redirect().setCompileUnit(cu);
         if (compileUnit!= null) compileUnit = cu;
@@ -895,7 +834,7 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
     }
 
     public void visitContents(GroovyClassVisitor visitor) {
-        
+
         // now lets visit the contents of the class
         for (Iterator iter = getProperties().iterator(); iter.hasNext();) {
             PropertyNode pn = (PropertyNode) iter.next();
@@ -927,8 +866,8 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
                 return method;
             }
         }
-        ClassNode parent = getSuperClass(); 
-        if (parent!=null) return parent.getGetterMethod(getterName); 
+        ClassNode parent = getSuperClass();
+        if (parent!=null) return parent.getGetterMethod(getterName);
         return null;
     }
 
@@ -941,8 +880,8 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
                 return method;
             }
         }
-        ClassNode parent = getSuperClass(); 
-        if (parent!=null) return parent.getSetterMethod(setterName); 
+        ClassNode parent = getSuperClass();
+        if (parent!=null) return parent.getSetterMethod(setterName);
         return null;
     }
 
@@ -977,7 +916,7 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
     }
 
     public String toString() {
-        String ret = getName(); 
+        String ret = getName();
         if (genericsTypes!=null) {
             ret += " <";
             for (int i = 0; i < genericsTypes.length; i++) {
@@ -1016,7 +955,7 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
         while (node != null);
         return false;
     }
-    
+
     public MethodNode tryFindPossibleMethod(String name, Expression arguments) {
         int count = 0;
 
@@ -1098,21 +1037,21 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
     }
 
     public boolean isInterface(){
-        return (getModifiers() & Opcodes.ACC_INTERFACE) > 0; 
+        return (getModifiers() & Opcodes.ACC_INTERFACE) > 0;
     }
-    
+
     public boolean isResolved(){
         return redirect().clazz!=null || (componentType != null && componentType.isResolved());
     }
-    
+
     public boolean isArray(){
         return componentType!=null;
     }
-    
+
     public ClassNode getComponentType() {
         return componentType;
     }
-    
+
     public Class getTypeClass(){
         Class c = redirect().clazz;
         if (c!=null) return c;
@@ -1124,7 +1063,7 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
         }
         throw new GroovyBugError("ClassNode#getTypeClass for "+getName()+" is called before the type class is set ");
     }
-    
+
     public boolean hasPackageName(){
         return redirect().name.indexOf('.')>0;
     }
@@ -1136,7 +1075,7 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
     public void setAnnotated(boolean flag) {
         this.annotated = flag;
     }
-    
+
     public boolean isAnnotated() {
         return this.annotated;
     }
@@ -1154,19 +1093,19 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
         usesGenerics = usesGenerics || b;
         placeholder = b;
     }
-    
+
     public boolean isGenericsPlaceHolder() {
         return placeholder;
     }
-    
+
     public boolean isUsingGenerics() {
         return usesGenerics;
     }
-    
+
     public void setUsingGenerics(boolean b) {
         usesGenerics = b;
     }
-    
+
     public ClassNode getPlainNodeReference() {
         if (ClassHelper.isPrimitiveType(this)) return this;
         ClassNode n = new ClassNode(getName(),getModifiers(),getSuperClass(),null,null);
@@ -1176,8 +1115,8 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
     }
 
     public boolean isAnnotationDefinition() {
-        return redirect().isPrimaryNode && 
-               isInterface() && 
+        return redirect().isPrimaryNode &&
+               isInterface() &&
                (getModifiers() & Opcodes.ACC_ANNOTATION)!=0;
     }
 
@@ -1188,7 +1127,7 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
     }
 
     public List getAnnotations(ClassNode type) {
-        if (redirect!=null) return redirect.getAnnotations(type);        
+        if (redirect!=null) return redirect.getAnnotations(type);
         lazyClassInit();
         return super.getAnnotations(type);
     }
diff --git a/src/main/org/codehaus/groovy/classgen/Verifier.java b/src/main/org/codehaus/groovy/classgen/Verifier.java
index 1d42a77105..e7905f86cb 100644
--- a/src/main/org/codehaus/groovy/classgen/Verifier.java
+++ b/src/main/org/codehaus/groovy/classgen/Verifier.java
@@ -760,7 +760,7 @@ public class Verifier implements GroovyClassVisitor, Opcodes {
         }
         
         ClassNode[] interfaces = classNode.getInterfaces();
-        for (int i=0; i<interfaces.length; i++) {            
+        for (int i=0; i<interfaces.length; i++) {
             Map genericsSpec = createGenericsSpec(interfaces[i],oldGenericsSpec);
             for (Iterator it = declaredMethods.iterator(); it.hasNext();) {
                 MethodNode method = (MethodNode) it.next();
@@ -773,11 +773,22 @@ public class Verifier implements GroovyClassVisitor, Opcodes {
     }
     
     private MethodNode getCovariantImplementation(final MethodNode oldMethod, final MethodNode overridingMethod, Map genericsSpec) {
+        // method name
         if (!oldMethod.getName().equals(overridingMethod.getName())) return null;
-        if (!equalParameters(overridingMethod,oldMethod,genericsSpec)) return null;
+
+        // parameters
+        boolean normalEqualParamerters = equalParametersNormal(overridingMethod,oldMethod);
+        boolean genericEqualParamerters = equalParametersWithGenerics(overridingMethod,oldMethod,genericsSpec);
+        if (!normalEqualParamerters && !genericEqualParamerters) return null;
+
+        // return type
         ClassNode mr = overridingMethod.getReturnType();
         ClassNode omr = oldMethod.getReturnType();
-        if (mr.equals(omr)) return null;
+        boolean equalReturnType = mr.equals(omr);
+        if (equalReturnType && normalEqualParamerters) return null;
+
+        // if we reach this point we have at last one parameter or return type, that
+        // is different in its specified form. That means we have to create a bridge method!
         ClassNode testmr = correctToGenericsSpec(genericsSpec,omr);
         if (!mr.isDerivedFrom(testmr)) {
             throw new RuntimeParserException(
@@ -876,14 +887,27 @@ public class Verifier implements GroovyClassVisitor, Opcodes {
         return type;
     }
     
-    private boolean equalParameters(MethodNode m1, MethodNode m2, Map genericsSpec) {
+    private boolean equalParametersNormal(MethodNode m1, MethodNode m2) {
+        Parameter[] p1 = m1.getParameters();
+        Parameter[] p2 = m2.getParameters();
+        if (p1.length!=p2.length) return false;
+        for (int i = 0; i < p2.length; i++) {
+            ClassNode type = p2[i].getType();
+            ClassNode parameterType = p1[i].getType();
+            if (!parameterType.equals(type)) return false;
+        }
+        return true;
+    }
+
+    private boolean equalParametersWithGenerics(MethodNode m1, MethodNode m2, Map genericsSpec) {
         Parameter[] p1 = m1.getParameters();
         Parameter[] p2 = m2.getParameters();
         if (p1.length!=p2.length) return false;
         for (int i = 0; i < p2.length; i++) {
             ClassNode type = p2[i].getType();
-            type = correctToGenericsSpec(genericsSpec,type);
-            if (!p1[i].getType().equals(type)) return false;
+            ClassNode genericsType = correctToGenericsSpec(genericsSpec,type);
+            ClassNode parameterType = p1[i].getType();
+            if (!parameterType.equals(genericsType)) return false;
         }
         return true;
     }
@@ -907,6 +931,7 @@ public class Verifier implements GroovyClassVisitor, Opcodes {
                 spec[i]=correctToGenericsSpec(ret, sgts[i]);
             }
             GenericsType[] newGts = current.redirect().getGenericsTypes();
+            if (newGts==null) return ret;
             ret.clear();
             for (int i = 0; i < spec.length; i++) {
                 ret.put(newGts[i].getName(), spec[i]);
diff --git a/src/main/org/codehaus/groovy/vmplugin/VMPlugin.java b/src/main/org/codehaus/groovy/vmplugin/VMPlugin.java
index e91c94760d..d9a52eb3ab 100644
--- a/src/main/org/codehaus/groovy/vmplugin/VMPlugin.java
+++ b/src/main/org/codehaus/groovy/vmplugin/VMPlugin.java
@@ -15,11 +15,7 @@
  */
 package org.codehaus.groovy.vmplugin;
 
-import org.codehaus.groovy.ast.ClassNode;
-import org.codehaus.groovy.ast.MethodNode;
-import org.codehaus.groovy.ast.AnnotationNode;
-import org.codehaus.groovy.control.CompilationUnit;
-
+import org.codehaus.groovy.ast.*;
 import java.lang.reflect.Method;
 
 /**
@@ -32,7 +28,6 @@ public interface VMPlugin {
 
     void setAdditionalClassInformation(ClassNode c);
     Class[] getPluginDefaultGroovyMethods();
-    public void setMethodDefaultValue(MethodNode mn, Method m);
-    public void setAnnotationMetaData(ClassNode cn);
     public void configureAnnotation(AnnotationNode an);
+    public void configureClassNode(CompileUnit compileUnit, ClassNode classNode);
 }
diff --git a/src/main/org/codehaus/groovy/vmplugin/v4/Java4.java b/src/main/org/codehaus/groovy/vmplugin/v4/Java4.java
index 2a78b65285..fab69a554e 100644
--- a/src/main/org/codehaus/groovy/vmplugin/v4/Java4.java
+++ b/src/main/org/codehaus/groovy/vmplugin/v4/Java4.java
@@ -15,13 +15,12 @@
  */
 package org.codehaus.groovy.vmplugin.v4;
 
-import org.codehaus.groovy.ast.ClassNode;
-import org.codehaus.groovy.ast.MethodNode;
-import org.codehaus.groovy.ast.AnnotationNode;
+import org.codehaus.groovy.ast.*;
 import org.codehaus.groovy.vmplugin.VMPlugin;
-import org.codehaus.groovy.control.CompilationUnit;
 
+import java.lang.reflect.Field;
 import java.lang.reflect.Method;
+import java.lang.reflect.Constructor;
 
 /**
  * java 4 based functions
@@ -30,24 +29,78 @@ import java.lang.reflect.Method;
  */
 public class Java4 implements VMPlugin {
     private static Class[] EMPTY_CLASS_ARRAY = new Class[0];
-    
+
     public void setAdditionalClassInformation(ClassNode c) {
-        return;        
+        return;
     }
-    
+
     public Class[] getPluginDefaultGroovyMethods() {
         return EMPTY_CLASS_ARRAY;
     }
 
-    public void setMethodDefaultValue(MethodNode mn, Method m) {
+    public void configureAnnotation(AnnotationNode an) {
         // do nothing
     }
+    public void configureClassNode(CompileUnit compileUnit, ClassNode classNode) {
+        Class clazz = classNode.getTypeClass();
+        Field[] fields = clazz.getDeclaredFields();
+        for (int i = 0; i < fields.length; i++) {
+            classNode.addField(fields[i].getName(), fields[i].getModifiers(), classNode, null);
+        }
+        Method[] methods = clazz.getDeclaredMethods();
+        for (int i = 0; i < methods.length; i++) {
+            Method m = methods[i];
+            MethodNode mn = new MethodNode(m.getName(), m.getModifiers(), ClassHelper.make(m.getReturnType()), createParameters(m.getParameterTypes()), ClassHelper.make(m.getExceptionTypes()), null);
+            classNode.addMethod(mn);
+        }
+        Constructor[] constructors = clazz.getDeclaredConstructors();
+        for (int i = 0; i < constructors.length; i++) {
+            Constructor ctor = constructors[i];
+            classNode.addConstructor(ctor.getModifiers(), createParameters(ctor.getParameterTypes()), ClassHelper.make(ctor.getExceptionTypes()), null);
+        }
+
+        Class sc = clazz.getSuperclass();
+        if (sc != null) classNode.setUnresolvedSuperClass(getPrimaryClassNode(compileUnit,sc));
+
+        buildInterfaceTypes(compileUnit,classNode,clazz);
 
-    public void setAnnotationMetaData(ClassNode cn) {
-        // do nothing
     }
 
-    public void configureAnnotation(AnnotationNode an) {
-        // do nothing        
+    private ClassNode getPrimaryClassNode(CompileUnit compileUnit,Class clazz) {
+        // there might be a new super class from the compile unit,
+        // we want to use this instead of simply referencing the old
+        // class
+        ClassNode result = null;
+        if (compileUnit!=null) {
+            result = compileUnit.getClass(clazz.getName());
+        }
+        if (result==null) result = ClassHelper.make(clazz);
+        return result;
     }
+
+    private void buildInterfaceTypes(CompileUnit compileUnit, ClassNode classNode, Class c) {
+        Class[] interfaces = c.getInterfaces();
+        ClassNode[] ret = new ClassNode[interfaces.length];
+        for (int i=0;i<interfaces.length;i++){
+            ret[i] = getPrimaryClassNode(compileUnit, interfaces[i]);
+        }
+        classNode.setInterfaces(ret);
+    }
+
+    private Parameter[] createParameters(Class[] types) {
+        Parameter[] parameters = Parameter.EMPTY_ARRAY;
+        int size = types.length;
+        if (size > 0) {
+            parameters = new Parameter[size];
+            for (int i = 0; i < size; i++) {
+                parameters[i] = createParameter(types[i], i);
+            }
+        }
+        return parameters;
+    }
+
+    private Parameter createParameter(Class parameterType, int idx) {
+        return new Parameter(ClassHelper.make(parameterType), "param" + idx);
+    }
+
 }
diff --git a/src/main/org/codehaus/groovy/vmplugin/v5/Java5.java b/src/main/org/codehaus/groovy/vmplugin/v5/Java5.java
index 212749bd4b..2bb5228291 100644
--- a/src/main/org/codehaus/groovy/vmplugin/v5/Java5.java
+++ b/src/main/org/codehaus/groovy/vmplugin/v5/Java5.java
@@ -33,7 +33,7 @@ import org.codehaus.groovy.ast.ClassHelper;
  * @author Jochen Theodorou
  *
  */
-public class Java5 implements VMPlugin { 
+public class Java5 implements VMPlugin {
     private static Class[] PLUGIN_DGM={PluginDefaultGroovyMethods.class};
 
     public void setAdditionalClassInformation(ClassNode cn) {
@@ -45,7 +45,7 @@ public class Java5 implements VMPlugin {
         GenericsType[] gts = configureTypeVariable(tvs);
         cn.setGenericsTypes(gts);
     }
-    
+
     private GenericsType[] configureTypeVariable(TypeVariable[] tvs) {
         if (tvs.length==0) return null;
         GenericsType[] gts = new GenericsType[tvs.length];
@@ -57,44 +57,85 @@ public class Java5 implements VMPlugin {
 
     private GenericsType configureTypeVariableDefintion(TypeVariable tv) {
        ClassNode base = configureTypeVariableReference(tv);
+       ClassNode redirect = base.redirect();
+       base.setRedirect(null);
        Type[] tBounds = tv.getBounds();
-       if (tBounds.length==0) return new GenericsType(base);
-       ClassNode[] cBounds = new ClassNode[tBounds.length];
-       for (int i = 0; i < tBounds.length; i++) {
-           cBounds[i] = configureType(tBounds[i]);
+       GenericsType gt;
+       if (tBounds.length==0) {
+           gt = new GenericsType(base);
+       } else {
+           ClassNode[] cBounds = configureTypes(tBounds);
+           gt = new GenericsType(base,cBounds,null);
+           gt.setName(base.getName());
+           gt.setPlaceholder(true);
        }
-       GenericsType gt = new GenericsType(base,cBounds,null);
-       gt.setPlaceholder(true);
+       base.setRedirect(redirect);
        return gt;
     }
-    
+
+    private ClassNode[] configureTypes(Type[] types){
+        if (types.length==0) return null;
+        ClassNode[] nodes = new ClassNode[types.length];
+        for (int i=0; i<types.length; i++){
+            nodes[i] = configureType(types[i]);
+        }
+        return nodes;
+    }
+
     private ClassNode configureType(Type type) {
         if (type instanceof WildcardType) {
             return configureWildcardType((WildcardType) type);
         } else if (type instanceof ParameterizedType) {
             return configureParameterizedType((ParameterizedType) type);
         } else if (type instanceof GenericArrayType) {
-            throw new GroovyBugError("Not yet implemented");
+            return configureGenericArray((GenericArrayType) type);
         } else if (type instanceof TypeVariable) {
             return configureTypeVariableReference((TypeVariable) type);
         } else if (type instanceof Class) {
-            return ClassHelper.makeWithoutCaching((Class) type, false);
+            return configureClass((Class) type);
         } else {
             throw new GroovyBugError("unknown type: " + type + " := " + type.getClass());
-        }        
+        }
+    }
+
+    private ClassNode configureClass(Class c){
+        if (c.isPrimitive()) {
+            return ClassHelper.make(c);
+        } else {
+            return ClassHelper.makeWithoutCaching(c, false);
+        }
+    }
+
+    private ClassNode configureGenericArray(GenericArrayType genericArrayType) {
+        Type component = genericArrayType.getGenericComponentType();
+        ClassNode node = configureType(component);
+        return node.makeArray();
     }
-    
+
     private ClassNode configureWildcardType(WildcardType wildcardType) {
-        throw new GroovyBugError("Not yet implemented");
+        ClassNode base = ClassHelper.makeWithoutCaching("?");
+        //TODO: more than one lower bound for wildcards?
+        ClassNode[] lowers = configureTypes(wildcardType.getLowerBounds());
+        ClassNode lower=null;
+        if (lower!=null) lower = lowers[0];
+
+        ClassNode[] upper = configureTypes(wildcardType.getUpperBounds());
+        GenericsType t = new GenericsType(base,upper,lower);
+        t.setWildcard(true);
+
+        ClassNode ref = ClassHelper.makeWithoutCaching(Object.class,false);
+        ref.setGenericsTypes(new GenericsType[]{t});
+
+        return ref;
     }
-    
+
     private ClassNode configureParameterizedType(ParameterizedType parameterizedType) {
         ClassNode base = configureType(parameterizedType.getRawType());
         GenericsType[] gts = configureTypeArguments(parameterizedType.getActualTypeArguments());
         base.setGenericsTypes(gts);
         return base;
     }
-    
+
     private ClassNode configureTypeVariableReference(TypeVariable tv) {
         ClassNode cn = ClassHelper.makeWithoutCaching(tv.getName());
         cn.setGenericsPlaceHolder(true);
@@ -104,7 +145,7 @@ public class Java5 implements VMPlugin {
         cn.setRedirect(ClassHelper.OBJECT_TYPE);
         return cn;
     }
-    
+
     private GenericsType[] configureTypeArguments(Type[] ta) {
         if (ta.length==0) return null;
         GenericsType[] gts = new GenericsType[ta.length];
@@ -118,7 +159,7 @@ public class Java5 implements VMPlugin {
         return PLUGIN_DGM;
     }
 
-    public void setAnnotationMetaData(ClassNode cn) {
+    private void setAnnotationMetaData(ClassNode cn) {
         Annotation[] annotations =  cn.getTypeClass().getAnnotations();
         for (int i=0; i<annotations.length; i++) {
             Annotation annotation = annotations[i];
@@ -164,7 +205,7 @@ public class Java5 implements VMPlugin {
 
         configureAnnotationFromDefinition(node,node);
     }
-    
+
     private void configureAnnotation(AnnotationNode node, Annotation annotation) {
         Class type = annotation.annotationType();
         if (type == Retention.class) {
@@ -208,10 +249,92 @@ public class Java5 implements VMPlugin {
         }
     }
 
-    public void setMethodDefaultValue(MethodNode mn, Method m) {
+    private void setMethodDefaultValue(MethodNode mn, Method m) {
         Object defaultValue = m.getDefaultValue();
         mn.setCode(new ReturnStatement(new ConstantExpression(defaultValue)));
         mn.setAnnotationDefault(true);
     }
 
+    public void configureClassNode(CompileUnit compileUnit, ClassNode classNode) {
+        Class clazz = classNode.getTypeClass();
+        Field[] fields = clazz.getDeclaredFields();
+        for (int i = 0; i < fields.length; i++) {
+            classNode.addField(fields[i].getName(), fields[i].getModifiers(), classNode, null);
+        }
+        Method[] methods = clazz.getDeclaredMethods();
+        for (int i = 0; i < methods.length; i++) {
+            Method m = methods[i];
+            ClassNode ret = makeClassNode(compileUnit,m.getGenericReturnType(),m.getReturnType());
+            Parameter[] params = makeParameters(compileUnit,m.getGenericParameterTypes(),m.getParameterTypes());
+            ClassNode[] exceptions = makeClassNodes(compileUnit,m.getGenericExceptionTypes(),m.getExceptionTypes());
+            MethodNode mn = new MethodNode(m.getName(), m.getModifiers(), ret, params, exceptions, null);
+            setMethodDefaultValue(mn,m);
+            classNode.addMethod(mn);
+        }
+        Constructor[] constructors = clazz.getDeclaredConstructors();
+        for (int i = 0; i < constructors.length; i++) {
+            Constructor ctor = constructors[i];
+            Parameter[] params = makeParameters(compileUnit,ctor.getGenericParameterTypes(), ctor.getParameterTypes());
+            ClassNode[] exceptions = makeClassNodes(compileUnit,ctor.getGenericExceptionTypes(),ctor.getExceptionTypes());
+            classNode.addConstructor(ctor.getModifiers(), params, exceptions, null);
+        }
+
+        Class sc = clazz.getSuperclass();
+        if (sc != null) classNode.setUnresolvedSuperClass(makeClassNode(compileUnit,clazz.getGenericSuperclass(),sc));
+        makeInterfaceTypes(compileUnit,classNode,clazz);
+        setAnnotationMetaData(classNode);
+
+    }
+
+    private void makeInterfaceTypes(CompileUnit cu, ClassNode classNode, Class clazz) {
+        Type[] interfaceTypes = clazz.getGenericInterfaces();
+        if (interfaceTypes.length==0) {
+            classNode.setInterfaces(ClassNode.EMPTY_ARRAY);
+        } else {
+            Class[] interfaceClasses = clazz.getInterfaces();
+            ClassNode[] ret = new ClassNode[interfaceTypes.length];
+            for (int i=0;i<interfaceTypes.length;i++){
+                ret[i] = makeClassNode(cu, interfaceTypes[i], interfaceClasses[i]);
+            }
+            classNode.setInterfaces(ret);
+        }
+    }
+
+    private ClassNode[] makeClassNodes(CompileUnit cu, Type[] types, Class[] cls) {
+        ClassNode[] nodes = new ClassNode[types.length];
+        for (int i=0;i<nodes.length;i++) {
+            nodes[i] = makeClassNode(cu, types[i],cls[i]);
+        }
+        return nodes;
+    }
+
+    private ClassNode makeClassNode(CompileUnit cu, Type t, Class c) {
+        ClassNode back = null;
+        if (cu!=null)   back = cu.getClass(c.getName());
+        if (back==null) back = ClassHelper.make(c);
+        if (!(t instanceof Class)) {
+            ClassNode front = configureType(t);
+            front.setRedirect(back);
+            return front;
+        }
+        return back;
+    }
+
+    private Parameter[] makeParameters(CompileUnit cu, Type[] types, Class[] cls) {
+        Parameter[] params = Parameter.EMPTY_ARRAY;
+        if (types.length>0) {
+            params = new Parameter[types.length];
+            for (int i=0;i<params.length;i++) {
+                params[i] = makeParameter(cu,types[i],cls[i],i);
+            }
+        }
+        return params;
+    }
+
+    private Parameter makeParameter(CompileUnit cu, Type type, Class cl,int idx) {
+        ClassNode cn = makeClassNode(cu,type,cl);
+        return new Parameter(cn, "param" + idx);
+    }
+
 }
+
diff --git a/src/test/gls/invocaton/CovariantReturnTest.groovy b/src/test/gls/invocaton/CovariantReturnTest.groovy
index 7d474fe4e9..345c186485 100644
--- a/src/test/gls/invocaton/CovariantReturnTest.groovy
+++ b/src/test/gls/invocaton/CovariantReturnTest.groovy
@@ -54,5 +54,20 @@ public class CovariantReturnTest extends CompilableTestSupport {
       assert x.foo(true) == "true"
       assert x.foo(false) == "false"
     """
+  }
+
+  void testCovariantParameterType(){
+    assertScript """
+      class BaseA implements Comparable<BaseA> {
+        int index
+        public int compareTo(BaseA a){
+          return index <=> a.index
+        }
+      }
+
+      def a = new BaseA(index:1)
+      def b = new BaseA(index:2)
+      assert a < b
+    """
   }
-}
\ No newline at end of file
+}
