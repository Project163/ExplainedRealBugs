diff --git a/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java b/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java
index 2c851cf784..273df2a37e 100644
--- a/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java
+++ b/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java
@@ -1147,28 +1147,9 @@ public class AstBuilder extends GroovyParserBaseVisitor<Object> {
         throw createParsingFailedException("Unsupported type declaration: " + ctx.getText(), ctx);
     }
 
-    private void initUsingGenerics(final ClassNode classNode) {
-        if (classNode.isUsingGenerics()) {
-            return;
-        }
-
-        if (!classNode.isEnum()) {
-            classNode.setUsingGenerics(classNode.getSuperClass().isUsingGenerics());
-        }
-
-        if (!classNode.isUsingGenerics() && null != classNode.getInterfaces()) {
-            for (ClassNode anInterface : classNode.getInterfaces()) {
-                classNode.setUsingGenerics(classNode.isUsingGenerics() || anInterface.isUsingGenerics());
-
-                if (classNode.isUsingGenerics())
-                    break;
-            }
-        }
-    }
-
     @Override
     public ClassNode visitClassDeclaration(final ClassDeclarationContext ctx) {
-        String packageName = Optional.ofNullable(moduleNode.getPackageName()).orElse("");
+        String packageName = Optional.ofNullable(this.moduleNode.getPackageName()).orElse("");
         String className = this.visitIdentifier(ctx.identifier());
         if ("var".equals(className)) {
             throw createParsingFailedException("var cannot be used for type declarations", ctx.identifier());
@@ -1260,7 +1241,7 @@ public class AstBuilder extends GroovyParserBaseVisitor<Object> {
         boolean syntheticPublic = ((modifiers & Opcodes.ACC_SYNTHETIC) != 0);
         modifiers &= ~Opcodes.ACC_SYNTHETIC;
 
-        ClassNode classNode, outerClass = classNodeStack.peek();
+        ClassNode classNode, outerClass = this.classNodeStack.peek();
 
         if (isEnum) {
             classNode = EnumHelper.makeEnumNode(
@@ -1328,17 +1309,17 @@ public class AstBuilder extends GroovyParserBaseVisitor<Object> {
                 classNode.setSuperClass(scs[0]);
             }
             classNode.setInterfaces(this.visitTypeList(ctx.is));
-            this.initUsingGenerics(classNode);
+            this.checkUsingGenerics(classNode);
 
         } else if (isInterface) {
             classNode.setModifiers(classNode.getModifiers() | Opcodes.ACC_INTERFACE | Opcodes.ACC_ABSTRACT);
             classNode.setInterfaces(this.visitTypeList(ctx.scs));
-            this.initUsingGenerics(classNode);
+            this.checkUsingGenerics(classNode);
             this.hackMixins(classNode);
 
         } else if (isEnum || isRecord) {
             classNode.setInterfaces(this.visitTypeList(ctx.is));
-            this.initUsingGenerics(classNode);
+            this.checkUsingGenerics(classNode);
             if (isRecord) {
                 this.transformRecordHeaderToProperties(ctx, classNode);
             }
@@ -1352,32 +1333,45 @@ public class AstBuilder extends GroovyParserBaseVisitor<Object> {
             throw createParsingFailedException("Unsupported class declaration: " + ctx.getText(), ctx);
         }
 
-        // we put the class already in output to avoid the most inner classes
-        // will be used as first class later in the loader. The first class
-        // there determines what GCL#parseClass for example will return, so we
-        // have here to ensure it won't be the inner class
-        if (asBoolean(ctx.CLASS()) || asBoolean(ctx.TRAIT())) {
-            classNodeList.add(classNode);
-        }
-
-        classNodeStack.push(classNode);
+        this.classNodeStack.push(classNode);
         ctx.classBody().putNodeMetaData(CLASS_DECLARATION_CLASS_NODE, classNode);
         this.visitClassBody(ctx.classBody());
         if (isRecord) {
             classNode.getFields().stream().filter(f -> !isTrue(f, IS_RECORD_GENERATED) && !f.isStatic()).findFirst()
                     .ifPresent(fn -> this.createParsingFailedException("Instance field is not allowed in `record`", fn));
         }
-        classNodeStack.pop();
+        this.classNodeStack.pop();
 
-        if (!(asBoolean(ctx.CLASS()) || asBoolean(ctx.TRAIT()))) {
-            classNodeList.add(classNode);
+        // The first element in classNodeList determines what GCL#parseClass for
+        // example will return. So we have to ensure it won't be an inner class.
+        if (outerClass == null) {
+            this.addToClassNodeList(classNode);
         }
-
-        groovydocManager.handle(classNode, ctx);
+        this.groovydocManager.handle(classNode, ctx);
 
         return classNode;
     }
 
+    private void addToClassNodeList(final ClassNode classNode) {
+        this.classNodeList.add(classNode); // GROOVY-11117: outer class first
+        classNode.getInnerClasses().forEachRemaining(this::addToClassNodeList);
+    }
+
+    private void checkUsingGenerics(final ClassNode classNode) {
+        if (!classNode.isUsingGenerics()) {
+            if (!classNode.isEnum() && classNode.getSuperClass().isUsingGenerics()) {
+                classNode.setUsingGenerics(true);
+            } else if (classNode.getInterfaces() != null) {
+                for (ClassNode interfaceNode : classNode.getInterfaces()) {
+                    if (interfaceNode.isUsingGenerics()) {
+                        classNode.setUsingGenerics(true);
+                        break;
+                    }
+                }
+            }
+        }
+    }
+
     private void transformRecordHeaderToProperties(final ClassDeclarationContext ctx, final ClassNode classNode) {
         Parameter[] parameters = this.visitFormalParameters(ctx.formalParameters());
         classNode.putNodeMetaData(RECORD_HEADER, parameters);
@@ -3390,7 +3384,7 @@ public class AstBuilder extends GroovyParserBaseVisitor<Object> {
     @Override
     public InnerClassNode visitAnonymousInnerClassDeclaration(final AnonymousInnerClassDeclarationContext ctx) {
         ClassNode superClass = Objects.requireNonNull(ctx.getNodeMetaData(ANONYMOUS_INNER_CLASS_SUPER_CLASS), "superClass should not be null");
-        ClassNode outerClass = Optional.ofNullable(classNodeStack.peek()).orElse(moduleNode.getScriptClassDummy());
+        ClassNode outerClass = Optional.ofNullable(this.classNodeStack.peek()).orElse(this.moduleNode.getScriptClassDummy());
         String innerClassName = nextAnonymousClassName(outerClass);
 
         InnerClassNode anonymousInnerClass;
@@ -3406,12 +3400,14 @@ public class AstBuilder extends GroovyParserBaseVisitor<Object> {
         anonymousInnerClass.setUsingGenerics(false);
         anonymousInnerClass.putNodeMetaData(CLASS_NAME, innerClassName);
         configureAST(anonymousInnerClass, ctx);
-        classNodeList.add(anonymousInnerClass);
 
-        classNodeStack.push(anonymousInnerClass);
+        this.classNodeStack.push(anonymousInnerClass);
         ctx.classBody().putNodeMetaData(CLASS_DECLARATION_CLASS_NODE, anonymousInnerClass);
         this.visitClassBody(ctx.classBody());
-        classNodeStack.pop();
+        this.classNodeStack.pop();
+
+        if (this.classNodeStack.isEmpty())
+            this.addToClassNodeList(anonymousInnerClass);
 
         return anonymousInnerClass;
     }
@@ -4634,20 +4630,16 @@ public class AstBuilder extends GroovyParserBaseVisitor<Object> {
      * Sets the script source position.
      */
     private void configureScriptClassNode() {
-        ClassNode scriptClassNode = moduleNode.getScriptClassDummy();
-
-        if (!asBoolean(scriptClassNode)) {
-            return;
-        }
-
-        List<Statement> statements = moduleNode.getStatementBlock().getStatements();
-        if (!statements.isEmpty()) {
-            Statement firstStatement = statements.get(0);
-            Statement lastStatement = statements.get(statements.size() - 1);
-
-            scriptClassNode.setSourcePosition(firstStatement);
-            scriptClassNode.setLastColumnNumber(lastStatement.getLastColumnNumber());
-            scriptClassNode.setLastLineNumber(lastStatement.getLastLineNumber());
+        var scriptClassNode = moduleNode.getScriptClassDummy();
+        if (scriptClassNode != null) {
+            List<Statement> statements = moduleNode.getStatementBlock().getStatements();
+            if (!statements.isEmpty()) {
+                Statement firstStatement = statements.get(0);
+                scriptClassNode.setSourcePosition(firstStatement);
+                Statement lastStatement  = statements.get(statements.size() - 1);
+                scriptClassNode.setLastLineNumber(lastStatement.getLastLineNumber());
+                scriptClassNode.setLastColumnNumber(lastStatement.getLastColumnNumber());
+            }
         }
     }
 
@@ -4801,7 +4793,7 @@ public class AstBuilder extends GroovyParserBaseVisitor<Object> {
     private final GroovydocManager groovydocManager;
     private final TryWithResourcesASTTransformation tryWithResourcesASTTransformation;
 
-    private final List<ClassNode> classNodeList = new LinkedList<>();
+    private final List<ClassNode> classNodeList = new ArrayList<>();
     private final Deque<ClassNode> classNodeStack = new ArrayDeque<>();
     private final Deque<List<InnerClassNode>> anonymousInnerClassesDefinedInMethodStack = new ArrayDeque<>();
     private final Deque<GroovyParserRuleContext> switchExpressionRuleContextStack = new ArrayDeque<>();
diff --git a/src/main/java/org/codehaus/groovy/classgen/EnumCompletionVisitor.java b/src/main/java/org/codehaus/groovy/classgen/EnumCompletionVisitor.java
index da0ec9d807..87b8fa71d3 100644
--- a/src/main/java/org/codehaus/groovy/classgen/EnumCompletionVisitor.java
+++ b/src/main/java/org/codehaus/groovy/classgen/EnumCompletionVisitor.java
@@ -76,7 +76,14 @@ public class EnumCompletionVisitor extends ClassCodeVisitorSupport {
 
     @Override
     public void visitClass(final ClassNode node) {
-        if (node.isEnum()) completeEnum(node);
+        if (node.isEnum()
+                && !EnumVisitor.isAnonymousInnerClass(node)) {
+            node.getInnerClasses().forEachRemaining(innerClass -> {
+                // EnumConstantClassNode must be completed before its enum class
+                if (EnumVisitor.isAnonymousInnerClass(innerClass)) completeEnum(innerClass);
+            });
+            completeEnum(node);
+        }
     }
 
     private void completeEnum(final ClassNode enumClass) {
diff --git a/src/test/groovy/lang/GroovyClassLoaderTest.groovy b/src/test/groovy/lang/GroovyClassLoaderTest.groovy
index 83de0f50ef..75767ac96a 100644
--- a/src/test/groovy/lang/GroovyClassLoaderTest.groovy
+++ b/src/test/groovy/lang/GroovyClassLoaderTest.groovy
@@ -81,7 +81,7 @@ final class GroovyClassLoaderTest {
     //--------------------------------------------------------------------------
 
     @Test
-    void testAddsAClasspathEntryOnlyIfItHasNotAlreadyBeenAdded() {
+    void testAddsClasspathEntryOnlyIfItHasNotAlreadyBeenAdded() {
         String newClasspathEntry = '/tmp'
         int initialClasspathEntryCount = classLoader.classPath.length
 
@@ -252,6 +252,50 @@ final class GroovyClassLoaderTest {
         def clazz = loader.defineClass(classNode, classNode.getName() + '.groovy', '')
         verifyPackageDetails(clazz, 'pkg3')
     }
+
+    // GROOVY-11117
+    @Test
+    void testParseClassReturn() {
+        def c = classLoader.parseClass '''
+            interface A {
+                interface B { }
+                interface C { }
+            }
+        '''
+        assert c.name == 'A'
+
+        c = classLoader.parseClass '''
+            interface A {
+                trait B { }
+                class C { }
+            }
+        '''
+        assert c.name == 'A'
+
+        c = classLoader.parseClass '''
+            interface A {
+                trait B {
+                    static class C { }
+                }
+            }
+        '''
+        assert c.name == 'A'
+
+        c = classLoader.parseClass '''
+            def m() {
+                def aic = new Object() {}
+            }
+            interface A { }
+            trait B { }
+            class C { }
+        '''
+        assert c.name.startsWith('Script_')
+
+        c = classLoader.parseClass '''
+            print "hello"
+        '''
+        assert c.name.startsWith('Script_')
+    }
 }
 
 //------------------------------------------------------------------------------
