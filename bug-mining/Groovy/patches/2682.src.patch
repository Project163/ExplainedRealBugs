diff --git a/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/BaseTemplate.java b/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/BaseTemplate.java
index af7cb43f7f..d69caa09d9 100644
--- a/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/BaseTemplate.java
+++ b/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/BaseTemplate.java
@@ -18,6 +18,7 @@ package groovy.text.markup;
 import groovy.lang.Closure;
 import groovy.lang.Writable;
 import groovy.text.Template;
+import org.codehaus.groovy.control.io.NullWriter;
 import org.codehaus.groovy.runtime.ExceptionUtils;
 import org.codehaus.groovy.runtime.ResourceGroovyMethods;
 
@@ -101,6 +102,19 @@ public abstract class BaseTemplate implements Writable {
         return this;
     }
 
+    public String stringOf(Closure cl) throws IOException {
+        Writer old = out;
+        StringWriter stringWriter = new StringWriter(32);
+        out = stringWriter;
+        Object result = cl.call();
+        if (result!=null && result!=this) {
+            stringWriter.append(result.toString());
+        }
+        out = old;
+        return stringWriter.toString();
+    }
+
+
     /**
      * Renders the supplied object using its {@link Object#toString} method inside a
      * comment markup block (&lt;!-- ... --&gt;). The object is rendered as is, unescaped.
@@ -445,6 +459,10 @@ public abstract class BaseTemplate implements Writable {
      * @throws IOException
      */
     public Writer writeTo(final Writer out) throws IOException {
+        if (this.out!=null) {
+            // StackOverflow prevention
+            return NullWriter.DEFAULT;
+        }
         try {
             this.out = createWriter(out);
             run();
diff --git a/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/MarkupBuilderCodeTransformer.java b/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/MarkupBuilderCodeTransformer.java
index d3b57d4aa4..85e49a11ed 100644
--- a/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/MarkupBuilderCodeTransformer.java
+++ b/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/MarkupBuilderCodeTransformer.java
@@ -19,6 +19,8 @@ import org.codehaus.groovy.ast.ClassCodeExpressionTransformer;
 import org.codehaus.groovy.ast.ClassHelper;
 import org.codehaus.groovy.ast.ClassNode;
 import org.codehaus.groovy.ast.DynamicVariable;
+import org.codehaus.groovy.ast.Parameter;
+import org.codehaus.groovy.ast.VariableScope;
 import org.codehaus.groovy.ast.expr.ArgumentListExpression;
 import org.codehaus.groovy.ast.expr.ArrayExpression;
 import org.codehaus.groovy.ast.expr.BinaryExpression;
@@ -27,6 +29,7 @@ import org.codehaus.groovy.ast.expr.ConstantExpression;
 import org.codehaus.groovy.ast.expr.DeclarationExpression;
 import org.codehaus.groovy.ast.expr.EmptyExpression;
 import org.codehaus.groovy.ast.expr.Expression;
+import org.codehaus.groovy.ast.expr.GStringExpression;
 import org.codehaus.groovy.ast.expr.MapEntryExpression;
 import org.codehaus.groovy.ast.expr.MapExpression;
 import org.codehaus.groovy.ast.expr.MethodCallExpression;
@@ -38,23 +41,22 @@ import org.codehaus.groovy.ast.stmt.Statement;
 import org.codehaus.groovy.control.SourceUnit;
 import org.codehaus.groovy.syntax.Types;
 
+import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
 /**
- * <p>This AST transformer is responsible for modifying a source template into something
- * which can be compiled as a {@link groovy.text.markup.BaseTemplate} subclass.</p>
- *
+ * <p>This AST transformer is responsible for modifying a source template into something which can be compiled as a
+ * {@link groovy.text.markup.BaseTemplate} subclass.</p>
+ * <p/>
  * <p>It performs the following operations:</p>
- *
- * <ul>
- *     <li>replace dynamic variables with <i>getModel().get(dynamicVariable)</i> calls</li>
- *     <li>optionally wrap <i>getModel().get(...)</i> calls into <i>tryEscape</i> calls for automatic escaping</li>
- *     <li>replace <i>include XXX:'...'</i> calls with the appropriate <i>includeXXXX</i> method calls</li>
- *     <li>replace <i>':tagName'()</i> calls into <i>methodMissing('tagName', ...)</i> calls</li>
- * </ul>
+ * <p/>
+ * <ul> <li>replace dynamic variables with <i>getModel().get(dynamicVariable)</i> calls</li> <li>optionally wrap
+ * <i>getModel().get(...)</i> calls into <i>tryEscape</i> calls for automatic escaping</li> <li>replace <i>include
+ * XXX:'...'</i> calls with the appropriate <i>includeXXXX</i> method calls</li> <li>replace <i>':tagName'()</i> calls
+ * into <i>methodMissing('tagName', ...)</i> calls</li> </ul>
  *
  * @author Cedric Champeau
  */
@@ -80,7 +82,7 @@ class MarkupBuilderCodeTransformer extends ClassCodeExpressionTransformer {
     @Override
     public Expression transform(final Expression exp) {
         if (exp instanceof BinaryExpression) {
-            return transformBinaryExpression((BinaryExpression)exp);
+            return transformBinaryExpression((BinaryExpression) exp);
         }
         if (exp instanceof MethodCallExpression) {
             return transformMethodCall((MethodCallExpression) exp);
@@ -88,6 +90,7 @@ class MarkupBuilderCodeTransformer extends ClassCodeExpressionTransformer {
         if (exp instanceof ClosureExpression) {
             ClosureExpression cl = (ClosureExpression) exp;
             cl.getCode().visit(this);
+            return cl;
         }
         if (exp instanceof VariableExpression) {
             VariableExpression var = (VariableExpression) exp;
@@ -189,6 +192,25 @@ class MarkupBuilderCodeTransformer extends ClassCodeExpressionTransformer {
             call.setSpreadSafe(exp.isSpreadSafe());
             call.setSourcePosition(exp);
             return call;
+        } else if (name!=null && name.startsWith("$")) {
+            MethodCallExpression reformatted = new MethodCallExpression(
+                    exp.getObjectExpression(),
+                    name.substring(1),
+                    exp.getArguments()
+            );
+            reformatted.setImplicitThis(exp.isImplicitThis());
+            reformatted.setSafe(exp.isSafe());
+            reformatted.setSpreadSafe(exp.isSpreadSafe());
+            reformatted.setSourcePosition(exp);
+            // wrap in a stringOf { ... } closure call
+            ClosureExpression clos = new ClosureExpression(Parameter.EMPTY_ARRAY, new ExpressionStatement(reformatted));
+            clos.setVariableScope(new VariableScope());
+            MethodCallExpression stringOf = new MethodCallExpression(new VariableExpression("this"),
+                    "stringOf",
+                    clos);
+            stringOf.setImplicitThis(true);
+            stringOf.setSourcePosition(reformatted);
+            return stringOf;
         }
         return super.transform(exp);
     }
diff --git a/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/TemplateASTTransformer.java b/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/TemplateASTTransformer.java
index 5edefaf15b..b540ea918e 100644
--- a/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/TemplateASTTransformer.java
+++ b/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/TemplateASTTransformer.java
@@ -27,6 +27,7 @@ import org.codehaus.groovy.ast.expr.VariableExpression;
 import org.codehaus.groovy.ast.stmt.ExpressionStatement;
 import org.codehaus.groovy.ast.stmt.Statement;
 import org.codehaus.groovy.classgen.GeneratorContext;
+import org.codehaus.groovy.classgen.VariableScopeVisitor;
 import org.codehaus.groovy.control.CompilationFailedException;
 import org.codehaus.groovy.control.CompilePhase;
 import org.codehaus.groovy.control.SourceUnit;
@@ -65,6 +66,8 @@ class TemplateASTTransformer extends CompilationCustomizer {
             classNode.setSuperClass(ClassHelper.make(config.getBaseTemplateClass()));
             createConstructor(classNode);
             transformRunMethod(classNode, source);
+            VariableScopeVisitor visitor = new VariableScopeVisitor(source);
+            visitor.visitClass(classNode);
         }
     }
 
diff --git a/subprojects/groovy-templates/src/spec/doc/markup-template-engine.adoc b/subprojects/groovy-templates/src/spec/doc/markup-template-engine.adoc
index 5564dd95cb..ec7078a035 100644
--- a/subprojects/groovy-templates/src/spec/doc/markup-template-engine.adoc
+++ b/subprojects/groovy-templates/src/spec/doc/markup-template-engine.adoc
@@ -582,6 +582,67 @@ mention that a model variable should not be escaped by prefixing it with `unesca
 include::{rootdir}/subprojects/groovy-templates/src/spec/test/MarkupTemplateEngineSpecTest.groovy[tags=autoescape_template_unescaped,indent=0]
 ----
 
+[[markuptemplate-gotchas]]
+=== Common gotchas
+==== Strings containing markup
+
+Say that you want to generate a `<p>` tag which contains a string containing markup:
+
+[source,groovy]
+----
+include::{rootdir}/subprojects/groovy-templates/src/spec/test/MarkupTemplateEngineSpecTest.groovy[tags=gotcha_strings_longversion,indent=0]
+----
+
+and generates:
+
+[source,html]
+----
+include::{rootdir}/subprojects/groovy-templates/src/spec/test/MarkupTemplateEngineSpecTest.groovy[tags=gotcha_strings_longversion_expected,indent=0]
+----
+
+Can't this be written shorter? A naive alternative would be:
+
+[source,groovy]
+----
+include::{rootdir}/subprojects/groovy-templates/src/spec/test/MarkupTemplateEngineSpecTest.groovy[tags=gotcha_strings_naive_fail,indent=0]
+----
+
+but the result will not look as expected:
+
+[source,groovy]
+----
+include::{rootdir}/subprojects/groovy-templates/src/spec/test/MarkupTemplateEngineSpecTest.groovy[tags=gotcha_strings_naive_fail_expected,indent=0]
+----
+
+The reason is that the markup template engine is a _streaming_ engine. In the original version, the first `yield` call
+generates a string which is streamed to the output, then the `a` link is generated and streamed, and then the last `yield`
+call is streamed, leading in an execution *in order*. But with the string version above, the order of execution is different:
+
+* the `yield` call requires an argument, a _string_
+* that arguments needs to be evaluated _before_ the _yield_ call is generated
+
+so evaluating the string leads to an execution of the `a(href:...)` call *before* `yield` is itself called. This is not
+what you want to do. Instead, you want to generate a _string_ which contains markup, which is then passed to the `yield`
+call. This can be done this way:
+
+[source,groovy]
+----
+include::{rootdir}/subprojects/groovy-templates/src/spec/test/MarkupTemplateEngineSpecTest.groovy[tags=gotcha_strings_stringof,indent=0]
+----
+
+Note the `stringOf` call, which basically tells the markup template engine that the underlying markup needs to be rendered
+separately and exported as a string. Note that for simple expressions, `stringOf` can be replaced by an alternate tag
+notation that starts with a _dollar_ sign:
+
+[source,groovy]
+----
+include::{rootdir}/subprojects/groovy-templates/src/spec/test/MarkupTemplateEngineSpecTest.groovy[tags=gotcha_strings_stringof_dollar,indent=0]
+----
+
+TIP: It is worth noting that using `stringOf` or the special `$tag` notation triggers the creation of a distinct string writer
+which is then used to render the markup. It is slower than using the version with calls to `yield` which perform direct
+streaming of the markup instead.
+
 [[markuptemplate-i18n]]
 === Internationalization
 
diff --git a/subprojects/groovy-templates/src/spec/test/MarkupTemplateEngineSpecTest.groovy b/subprojects/groovy-templates/src/spec/test/MarkupTemplateEngineSpecTest.groovy
index ae19af2465..8919a9ee79 100644
--- a/subprojects/groovy-templates/src/spec/test/MarkupTemplateEngineSpecTest.groovy
+++ b/subprojects/groovy-templates/src/spec/test/MarkupTemplateEngineSpecTest.groovy
@@ -725,6 +725,63 @@ layout 'layout-main.tpl', true,                             // <1>
         assertRendered()
     }
 
+    void testStringMarkupGotcha() {
+        templateContents = '''
+// tag::gotcha_strings_longversion[]
+p {
+    yield "This is a "
+    a(href:'target.html', "link")
+    yield " to another page"
+}
+// end::gotcha_strings_longversion[]
+'''
+        expectedRendered = stripAsciidocMarkup '''
+// tag::gotcha_strings_longversion_expected[]
+<p>This is a <a href='target.html'>link</a> to another page</p>
+// end::gotcha_strings_longversion_expected[]
+'''
+        assertRendered()
+
+        templateContents = '''
+// tag::gotcha_strings_naive_fail[]
+p {
+    yield "This is a ${a(href:'target.html', "link")} to another page"
+}
+// end::gotcha_strings_naive_fail[]
+'''
+        expectedRendered = stripAsciidocMarkup '''
+// tag::gotcha_strings_naive_fail_expected[]
+<p><a href='target.html'>link</a>This is a  to another page</p>
+// end::gotcha_strings_naive_fail_expected[]
+'''
+        assertRendered()
+
+        templateContents = '''
+// tag::gotcha_strings_stringof[]
+p("This is a ${stringOf {a(href:'target.html', "link")}} to another page")
+// end::gotcha_strings_stringof[]
+'''
+        expectedRendered = stripAsciidocMarkup '''
+// tag::gotcha_strings_stringof_expected[]
+<p>This is a <a href='target.html'>link</a> to another page</p>
+// end::gotcha_strings_stringof_expected[]
+'''
+        assertRendered()
+
+        templateContents = '''
+// tag::gotcha_strings_stringof_dollar[]
+p("This is a ${$a(href:'target.html', "link")} to another page")
+// end::gotcha_strings_stringof_dollar[]
+'''
+        expectedRendered = stripAsciidocMarkup '''
+// tag::gotcha_strings_stringof_dollar_expected[]
+<p>This is a <a href='target.html'>link</a> to another page</p>
+// end::gotcha_strings_stringof_dollar_expected[]
+'''
+        assertRendered()
+
+    }
+
     // tag::page_class[]
     public class Page {
 
diff --git a/subprojects/groovy-templates/src/test/groovy/groovy/text/MarkupTemplateEngineTest.groovy b/subprojects/groovy-templates/src/test/groovy/groovy/text/MarkupTemplateEngineTest.groovy
index 4c22da6274..f12d921436 100644
--- a/subprojects/groovy-templates/src/test/groovy/groovy/text/MarkupTemplateEngineTest.groovy
+++ b/subprojects/groovy-templates/src/test/groovy/groovy/text/MarkupTemplateEngineTest.groovy
@@ -897,6 +897,52 @@ layout 'includes/body.tpl', bodyContents: contents {
         assert hit==2
     }
 
+    void testMarkupInGString() {
+        MarkupTemplateEngine engine = new MarkupTemplateEngine(new TemplateConfiguration())
+
+        def template = engine.createTemplate '''
+        html {
+            body {
+                def test = { p('hg') }
+                def x = "directly ${$test()}"
+                p("This is a p with ${true?$a(href:'link.html','link'):x}")
+                p("This is a p with ${false?$a(href:'link.html','link'):x}")
+            }
+        }
+        '''
+
+        String rendered = template.make()
+        assert rendered == '<html><body><p>This is a p with <a href=\'link.html\'>link</a></p><p>This is a p with directly <p>hg</p></p></body></html>'
+    }
+
+    void testMarkupInGStringUsingStringOf() {
+        MarkupTemplateEngine engine = new MarkupTemplateEngine(new TemplateConfiguration())
+
+        def template = engine.createTemplate '''
+        html {
+            body {
+                def test = { p('hg') }
+                def x = "directly ${stringOf { test()} }"
+                p("This is a p with ${stringOf { true?a(href:'link.html','link'):x} }")
+                p("This is a p with ${stringOf { false?a(href:'link.html','link'):x} }")
+            }
+        }
+        '''
+
+        String rendered = template.make()
+        assert rendered == '<html><body><p>This is a p with <a href=\'link.html\'>link</a></p><p>This is a p with directly <p>hg</p></p></body></html>'
+    }
+
+    void testShouldNotThrowStackOverflow() {
+        MarkupTemplateEngine engine = new MarkupTemplateEngine(new TemplateConfiguration())
+
+        def template = engine.createTemplate '''
+            p("This is an ${strong('error')}")
+        '''
+        String rendered = template.make().writeTo(new StringWriter())
+        assert rendered == '<strong>error</strong><p>This is an </p>'
+
+    }
     class SimpleTagLib {
         def emoticon = { attrs, body ->
             out << body() << (attrs.happy == 'true' ? " :-)" : " :-(")
