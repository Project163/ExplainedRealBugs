diff --git a/src/main/org/codehaus/groovy/runtime/ResourceGroovyMethods.java b/src/main/org/codehaus/groovy/runtime/ResourceGroovyMethods.java
index 395890b77e..d4a7fffe88 100644
--- a/src/main/org/codehaus/groovy/runtime/ResourceGroovyMethods.java
+++ b/src/main/org/codehaus/groovy/runtime/ResourceGroovyMethods.java
@@ -85,8 +85,6 @@ import static org.codehaus.groovy.runtime.DefaultGroovyMethods.get;
  */
 public class ResourceGroovyMethods extends DefaultGroovyMethodsSupport {
 
-//    private static final Logger LOG = Logger.getLogger(FileIOGroovyMethods.class.getName());
-
     /**
      * Provide the standard Groovy <code>size()</code> method for <code>File</code>.
      *
@@ -698,9 +696,9 @@ public class ResourceGroovyMethods extends DefaultGroovyMethodsSupport {
      * @since 1.0
      */
     public static void write(File file, String text) throws IOException {
-        BufferedWriter writer = null;
+        Writer writer = null;
         try {
-            writer = newWriter(file);
+            writer = new FileWriter(file);
             writer.write(text);
             writer.flush();
 
@@ -799,9 +797,9 @@ public class ResourceGroovyMethods extends DefaultGroovyMethodsSupport {
      * @since 1.0
      */
     public static void write(File file, String text, String charset) throws IOException {
-        BufferedWriter writer = null;
+        Writer writer = null;
         try {
-            writer = newWriter(file, charset);
+            writer = new OutputStreamWriter(new FileOutputStream(file), charset);
             writer.write(text);
             writer.flush();
 
@@ -822,6 +820,45 @@ public class ResourceGroovyMethods extends DefaultGroovyMethodsSupport {
      * @since 1.0
      */
     public static void append(File file, Object text) throws IOException {
+        Writer writer = null;
+        try {
+            writer = new FileWriter(file, true);
+            InvokerHelper.write(writer, text);
+            writer.flush();
+
+            Writer temp = writer;
+            writer = null;
+            temp.close();
+        } finally {
+            closeWithWarning(writer);
+        }
+    }
+    
+    /**
+     * Append the text supplied by the Writer at the end of the File.
+     *
+     * @param file a File
+     * @param reader the Reader supplying the text to append at the end of the File
+     * @throws IOException if an IOException occurs.
+     * @since 2.2
+     */
+    public static void append(File file, Reader reader) throws IOException {
+        appendBuffered(file, reader);
+    }
+    
+    /**
+     * Append the text supplied by the Writer at the end of the File.
+     *
+     * @param file a File
+     * @param writer the Writer supplying the text to append at the end of the File
+     * @throws IOException if an IOException occurs.
+     * @since 2.2
+     */
+    public static void append(File file, Writer writer) throws IOException {
+         appendBuffered(file, writer);
+    }
+    
+    private static void appendBuffered(File file, Object text) throws IOException {
         BufferedWriter writer = null;
         try {
             writer = newWriter(file, true);
@@ -845,9 +882,9 @@ public class ResourceGroovyMethods extends DefaultGroovyMethodsSupport {
      * @since 1.5.1
      */
     public static void append(File file, byte[] bytes) throws IOException {
-        BufferedOutputStream stream = null;
+        OutputStream stream = null;
         try {
-            stream = new BufferedOutputStream(new FileOutputStream(file, true));
+            stream = new FileOutputStream(file, true);
             stream.write(bytes, 0, bytes.length);
             stream.flush();
 
@@ -887,6 +924,47 @@ public class ResourceGroovyMethods extends DefaultGroovyMethodsSupport {
      * @since 1.0
      */
     public static void append(File file, Object text, String charset) throws IOException {
+        Writer writer = null;
+        try {
+            writer = new OutputStreamWriter(new FileOutputStream(file, true), charset); 
+            InvokerHelper.write(writer, text);
+            writer.flush();
+
+            Writer temp = writer;
+            writer = null;
+            temp.close();
+        } finally {
+            closeWithWarning(writer);
+        }
+    }
+    
+    /**
+     * Append the text supplied by the Writer at the end of the File, using a specified encoding.
+     *
+     * @param file a File
+     * @param writer the Writer supplying the text to append at the end of the File
+     * @param charset the charset used
+     * @throws IOException if an IOException occurs.
+     * @since 2.2
+     */
+    public static void append(File file, Writer writer, String charset) throws IOException {
+        appendBuffered(file, writer, charset);
+    }
+    
+    /**
+     * Append the text supplied by the Reader at the end of the File, using a specified encoding.
+     *
+     * @param file a File
+     * @param reader the Reader supplying the text to append at the end of the File
+     * @param charset the charset used
+     * @throws IOException if an IOException occurs.
+     * @since 2.2
+     */
+    public static void append(File file, Reader reader, String charset) throws IOException {
+        appendBuffered(file, reader, charset);
+    }
+    
+    private static void appendBuffered(File file, Object text, String charset) throws IOException {
         BufferedWriter writer = null;
         try {
             writer = newWriter(file, charset, true);
diff --git a/src/test/org/codehaus/groovy/runtime/ResourceGroovyMethodsTest.groovy b/src/test/org/codehaus/groovy/runtime/ResourceGroovyMethodsTest.groovy
new file mode 100644
index 0000000000..d85708cc3c
--- /dev/null
+++ b/src/test/org/codehaus/groovy/runtime/ResourceGroovyMethodsTest.groovy
@@ -0,0 +1,221 @@
+/*
+ * Copyright 2003-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.codehaus.groovy.runtime
+
+
+class ResourceGroovyMethodsTest extends GroovyTestCase {
+
+	void test_Should_write_String_to_File_using_default_encoding() {
+		File file = createDeleteOnExitTempFile()
+		String text = 'Hello World'
+		
+		ResourceGroovyMethods.write(file, text)
+		
+		assert file.text == text
+	}
+	
+	void test_Should_write_String_to_File_using_specified_encoding() {
+		File file = createDeleteOnExitTempFile()
+		String text = "؁"
+		String encoding = 'UTF-8'
+		
+		ResourceGroovyMethods.write(file, text, encoding)
+		
+		assert file.getText(encoding) == text
+	}
+	
+	void test_Should_append_ByteArray_to_File() {
+		File file = createDeleteOnExitTempFile()
+		file.write('Hello')
+		byte[] bytes = ' World'.bytes
+		
+		ResourceGroovyMethods.append(file, bytes)
+		
+		assert file.text == 'Hello World'
+	}
+	
+	void test_Should_append_String_to_File_using_default_encoding() {
+		File file = createDeleteOnExitTempFile()
+		file.write('Hello')
+		
+		ResourceGroovyMethods.append(file, ' World')
+		
+		assert file.text == 'Hello World'
+	}
+	
+	void test_Should_append_text_supplied_by_Reader_to_File_using_default_encoding() {
+		File file = createDeleteOnExitTempFile()
+		file.write('Hello')
+		Reader reader = new StringReader(' World')
+		
+		ResourceGroovyMethods.append(file, reader)
+		
+		assert file.text == 'Hello World'
+	}
+	
+	void test_Should_append_text_supplied_by_Writer_to_File_using_default_encoding() {
+		File file = createDeleteOnExitTempFile()
+		file.write('Hello')
+		
+		Writer writer = new StringWriter()
+		writer.append(' World')
+		
+		ResourceGroovyMethods.append(file, writer)
+		
+		assert file.text == 'Hello World'
+	}
+	
+	void test_Should_append_String_to_File_using_specified_encoding() {
+		File file = createDeleteOnExitTempFile()
+		String encoding = 'UTF-8'
+		file.write('؁', encoding)
+		
+		ResourceGroovyMethods.append(file, ' ؁', encoding)
+		
+		assert file.getText(encoding) == '؁ ؁'
+	}
+	
+	void test_Should_append_text_supplied_by_Reader_to_File_using_specified_encoding() {
+		File file = createDeleteOnExitTempFile()
+		String encoding = 'UTF-8'
+		file.write('؁', encoding)
+		Reader reader = new CharArrayReader([' ','؁'] as char[])
+		
+		ResourceGroovyMethods.append(file, reader, encoding)
+		
+		assert file.getText(encoding) == '؁ ؁'
+	}
+	
+	void test_Should_append_text_supplied_by_Writer_to_File_using_specified_encoding() {
+		File file = createDeleteOnExitTempFile()
+		String encoding = 'UTF-8'
+		file.write('؁', encoding)
+		
+		Writer writer = new CharArrayWriter()
+		writer.append(' ')
+		writer.append('؁')
+		
+		ResourceGroovyMethods.append(file, writer, encoding)
+		
+		assert file.getText(encoding) == '؁ ؁'
+	}
+
+	void testFileDirectorySizeExceptions() {
+		try {
+			ResourceGroovyMethods.directorySize(new File("doesn't exist"))
+			fail("directorySize() should fail when directory specified doesn't exist")
+		} catch (IOException expected) {
+		}
+
+		File tempFile = File.createTempFile("testDirectorySizeExceptions", "")
+
+		try {
+			ResourceGroovyMethods.directorySize(tempFile)
+			fail("directorySize() should fail when a file is specified")
+		} catch (IllegalArgumentException expected) {
+		}
+
+		tempFile.delete()
+	}
+
+	void testDirectorySize() {
+		File tempFile = File.createTempFile("__testDirectorySize__", "")
+		delete(tempFile)
+
+		File testDir = new File(tempFile.getAbsolutePath())
+		testDir.mkdirs()
+
+		final int nFiles = 3
+		final int maxFileSize = 102488
+
+		long totalSize = 0
+		Random r = new Random(new Random(System.currentTimeMillis()).nextLong())
+
+		for (int j = 0; j < nFiles; j++) {
+			int fileSize = r.nextInt(maxFileSize)
+			String path = (r.nextBoolean() ? "a/" : "") + (r.nextBoolean() ? "b/" : "") +
+					(r.nextBoolean() ? "c/" : "") + (r.nextBoolean() ? "d/" : "") +
+					(r.nextBoolean() ? "e/" : "") + (r.nextBoolean() ? "f" : "")
+
+			String filePath = String.format("%s/%s/%s", path, j, fileSize)
+			createFile(new File(testDir, filePath), fileSize)
+			totalSize += fileSize
+		}
+
+		assertEquals(totalSize, ResourceGroovyMethods.directorySize(testDir))
+		delete(testDir)
+	}
+
+	/**
+	 * Creates empty file of size specified.
+	 *
+	 * @param file file to create
+	 * @param size file size
+	 */
+	private static void createFile(File file, int size) {
+		file.getParentFile().mkdirs()
+
+		try {
+			OutputStream os = new FileOutputStream(file)
+			os.write(new byte[size])
+			os.close()
+		} catch (IOException e) {
+			throw new RuntimeException(String.format("Failed to create [%s] of size [%s]: %s",
+			file.getAbsolutePath(), size, e),
+			e)
+		}
+
+		if (file.length() != size) {
+			throw new RuntimeException(String.format("Failed to create [%s] of size [%s]",
+			file.getAbsolutePath(), size))
+		}
+	}
+
+	/**
+	 * Deletes file or directory specified. If directory is not empty, all its files are deleted as well.
+	 *
+	 * @param file file or directory to delete
+	 */
+	private static void delete(File file) {
+		if (file.isDirectory()) {
+			for (File f : file.listFiles()) {
+				delete(f)
+			}
+		}
+
+		if (!file.delete()) {
+			// Sometimes empty directory is not deleted on the first attempt
+			try {
+				Thread.sleep(1000)
+			} catch (InterruptedException ignored) {
+			}
+
+			if (!file.delete()) {
+				throw new RuntimeException(String.format("Failed to delete [%s]", file.getAbsolutePath()))
+			}
+		}
+
+		if (file.exists()) {
+			throw new RuntimeException(String.format("[%s] is not deleted", file.getAbsolutePath()))
+		}
+	}
+	
+	File createDeleteOnExitTempFile() {
+		File tempFile = File.createTempFile("tmp", "txt")
+		tempFile.deleteOnExit()
+		return tempFile
+	}
+}
diff --git a/src/test/org/codehaus/groovy/runtime/ResourceGroovyMethodsTest.java b/src/test/org/codehaus/groovy/runtime/ResourceGroovyMethodsTest.java
deleted file mode 100644
index 516cd11933..0000000000
--- a/src/test/org/codehaus/groovy/runtime/ResourceGroovyMethodsTest.java
+++ /dev/null
@@ -1,127 +0,0 @@
-/*
- * Copyright 2003-2013 the original author or authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.codehaus.groovy.runtime;
-
-import groovy.util.GroovyTestCase;
-
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.OutputStream;
-import java.util.Random;
-
-public class ResourceGroovyMethodsTest extends GroovyTestCase {
-
-    public void testFileDirectorySizeExceptions() throws IOException {
-        try {
-            ResourceGroovyMethods.directorySize(new File("doesn't exist"));
-            fail("directorySize() should fail when directory specified doesn't exist");
-        } catch (IOException expected) {
-        }
-
-        File tempFile = File.createTempFile("testDirectorySizeExceptions", "");
-
-        try {
-            ResourceGroovyMethods.directorySize(tempFile);
-            fail("directorySize() should fail when a file is specified");
-        } catch (IllegalArgumentException expected) {
-        }
-
-        tempFile.delete();
-    }
-
-    public void testDirectorySize() throws IOException {
-        File tempFile = File.createTempFile("__testDirectorySize__", "");
-        delete(tempFile);
-
-        File testDir = new File(tempFile.getAbsolutePath());
-        testDir.mkdirs();
-
-        final int nFiles = 3;
-        final int maxFileSize = 102488;
-
-        long totalSize = 0;
-        Random r = new Random(new Random(System.currentTimeMillis()).nextLong());
-
-        for (int j = 0; j < nFiles; j++) {
-            int fileSize = r.nextInt(maxFileSize);
-            String path = (r.nextBoolean() ? "a/" : "") + (r.nextBoolean() ? "b/" : "") +
-                    (r.nextBoolean() ? "c/" : "") + (r.nextBoolean() ? "d/" : "") +
-                    (r.nextBoolean() ? "e/" : "") + (r.nextBoolean() ? "f" : "");
-
-            String filePath = String.format("%s/%s/%s", path, j, fileSize);
-            createFile(new File(testDir, filePath), fileSize);
-            totalSize += fileSize;
-        }
-
-        assertEquals(totalSize, ResourceGroovyMethods.directorySize(testDir));
-        delete(testDir);
-    }
-
-    /**
-     * Creates empty file of size specified.
-     *
-     * @param file file to create
-     * @param size file size
-     */
-    private static void createFile(File file, int size) {
-        file.getParentFile().mkdirs();
-
-        try {
-            OutputStream os = new FileOutputStream(file);
-            os.write(new byte[size]);
-            os.close();
-        } catch (IOException e) {
-            throw new RuntimeException(String.format("Failed to create [%s] of size [%s]: %s",
-                    file.getAbsolutePath(), size, e),
-                    e);
-        }
-
-        if (file.length() != size) {
-            throw new RuntimeException(String.format("Failed to create [%s] of size [%s]",
-                    file.getAbsolutePath(), size));
-        }
-    }
-
-    /**
-     * Deletes file or directory specified. If directory is not empty, all its files are deleted as well.
-     *
-     * @param file file or directory to delete
-     */
-    private static void delete(File file) {
-        if (file.isDirectory()) {
-            for (File f : file.listFiles()) {
-                delete(f);
-            }
-        }
-
-        if (!file.delete()) {
-            // Sometimes empty directory is not deleted on the first attempt
-            try {
-                Thread.sleep(1000);
-            } catch (InterruptedException ignored) {
-            }
-
-            if (!file.delete()) {
-                throw new RuntimeException(String.format("Failed to delete [%s]", file.getAbsolutePath()));
-            }
-        }
-
-        if (file.exists()) {
-            throw new RuntimeException(String.format("[%s] is not deleted", file.getAbsolutePath()));
-        }
-    }
-}
