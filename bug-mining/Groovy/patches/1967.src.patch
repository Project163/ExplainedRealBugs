diff --git a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
index b8829b33c7..2eb8c2f415 100644
--- a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
+++ b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
@@ -363,6 +363,9 @@ public class StaticTypesCallSiteWriter extends CallSiteWriter implements Opcodes
             getterName = "is" + MetaClassHelper.capitalize(methodName);
             getterNode = receiverType.getGetterMethod(getterName);
         }
+        if (getterNode!=null && receiver instanceof ClassExpression && !CLASS_Type.equals(receiverType) && !getterNode.isStatic()) {
+            return false;
+        }
 
         // GROOVY-5561: if two files are compiled in the same source unit
         // and that one references the other, the getters for properties have not been
diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 00c07329cc..759acb667c 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -821,6 +821,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
     protected boolean existsProperty(final PropertyExpression pexp, final boolean checkForReadOnly, final ClassCodeVisitorSupport visitor) {
         Expression objectExpression = pexp.getObjectExpression();
         final ClassNode objectExpressionType = getType(objectExpression);
+        boolean staticProperty = false;
         if (objectExpressionType.isArray() && "length".equals(pexp.getPropertyAsString())) {
             if (visitor != null) {
                 PropertyNode node = new PropertyNode("length", Opcodes.ACC_PUBLIC | Opcodes.ACC_FINAL, int_TYPE, objectExpressionType, null, null, null);
@@ -833,6 +834,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         tests.add(objectExpressionType);
         if (objectExpressionType.equals(CLASS_Type) && objectExpressionType.getGenericsTypes() != null) {
             tests.add(objectExpressionType.getGenericsTypes()[0].getType());
+            staticProperty = true;
         }
         if (!temporaryIfBranchTypeInformation.empty()) {
             List<ClassNode> classNodes = getTemporaryTypesForExpression(objectExpression);
@@ -877,7 +879,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                     }
                     MethodNode getter = current.getGetterMethod("get" + capName);
                     if (getter == null) getter = current.getGetterMethod("is" + capName);
-                    if (getter != null) {
+                    if (getter != null && !(staticProperty && !CLASS_Type.equals(current) && !getter.isStatic())) {
                         // check that a setter also exists
                         MethodNode setterMethod = current.getSetterMethod("set" + capName);
                         if (setterMethod != null) {
@@ -914,13 +916,23 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
                         MethodNode getter = current.getGetterMethod("get" + capName);
                         if (getter == null) getter = current.getGetterMethod("is" + capName);
-                        if (getter != null) {
+                        if (getter != null && !(staticProperty && !CLASS_Type.equals(current) && !getter.isStatic())) {
                             if (visitor != null) visitor.visitMethod(getter);
                             pexp.putNodeMetaData(StaticTypesMarker.READONLY_PROPERTY, Boolean.TRUE);
                             ClassNode cn = inferReturnTypeGenerics(current, getter, ArgumentListExpression.EMPTY_ARGUMENTS);
                             storeInferredTypeForPropertyExpression(pexp, cn);
                             return true;
                         }
+                        if (getter!=null) {
+                            // it's not a call on this, yet we need to check if a field is defined
+                            FieldNode field = current.getDeclaredField(propertyName);
+                            if (field != null) {
+                                if (visitor != null) visitor.visitField(field);
+                                storeInferredTypeForPropertyExpression(pexp, field.getOriginType());
+                                storeType(pexp, field.getOriginType());
+                                return true;
+                            }
+                        }
                         if (pluginFactory != null) {
                             TypeCheckerPlugin plugin = pluginFactory.getTypeCheckerPlugin(classNode);
                             if (plugin != null) {
diff --git a/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy b/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy
index ef7ec8dad9..81a1d12e70 100644
--- a/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy
+++ b/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy
@@ -367,6 +367,13 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
         '''
     }
 
+    // GROOVY-5779
+    void testShouldNotUseNonStaticProperty() {
+        assertScript '''import java.awt.Color
+        Color c = Color.red // should not be interpreted as Color.getRed()
+        '''
+    }
+
     public static class BaseClass {
         int x
     }
