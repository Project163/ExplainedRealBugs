diff --git a/src/main/java/groovy/lang/MetaClassImpl.java b/src/main/java/groovy/lang/MetaClassImpl.java
index c57b0331c0..947007fe02 100644
--- a/src/main/java/groovy/lang/MetaClassImpl.java
+++ b/src/main/java/groovy/lang/MetaClassImpl.java
@@ -1022,7 +1022,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
         try {
             return ownerMetaClass.invokeMethod(ownerClass, owner, methodName, arguments, false, false);
 
-        } catch (MissingMethodExceptionNoStack | InvokerInvocationException e) {
+        } catch (MissingMethodExceptionNoStack | InvokerInvocationException | IllegalArgumentException e) {
             if (ownerIsClass) {
                 if (MethodClosure.NEW.equals(methodName)) { // CONSTRUCTOR REFERENCE
                     if (!ownerClass.isArray()) {
diff --git a/src/test/groovy/transform/stc/MethodReferenceTest.groovy b/src/test/groovy/transform/stc/MethodReferenceTest.groovy
index 0935f6f110..a3f401a1f4 100644
--- a/src/test/groovy/transform/stc/MethodReferenceTest.groovy
+++ b/src/test/groovy/transform/stc/MethodReferenceTest.groovy
@@ -709,4 +709,14 @@ final class MethodReferenceTest {
         '''
         assert err =~ /The argument is a method reference, but the parameter type is not a functional interface/
     }
+
+    @Test // GROOVY-10635
+    void testRecordComponentMethodReference() {
+        assertScript shell, '''
+            record Bar(String name) { }
+
+            def bars = [new Bar(name: 'A'), new Bar(name: 'B')]
+            assert bars.stream().map(Bar::name).map(String::toLowerCase).toList() == ['a', 'b']
+        '''
+    }
 }
