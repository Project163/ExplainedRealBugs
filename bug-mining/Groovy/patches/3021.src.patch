diff --git a/src/main/groovy/lang/Delegate.java b/src/main/groovy/lang/Delegate.java
index 7fb3016bce..e0e556a764 100644
--- a/src/main/groovy/lang/Delegate.java
+++ b/src/main/groovy/lang/Delegate.java
@@ -206,4 +206,12 @@ public @interface Delegate {
      * @since 2.3.0
      */
     Class[] includeTypes() default {Undefined.CLASS.class};
+
+    /**
+     * Whether to apply the delegate pattern to all methods, including those with names that are considered internal.
+     *
+     * @return true if owner class should delegate to methods which have internal names
+     * @since 2.5.0
+     */
+    boolean allNames() default false;
 }
diff --git a/src/main/groovy/transform/EqualsAndHashCode.java b/src/main/groovy/transform/EqualsAndHashCode.java
index fc54e0e937..11a385e805 100644
--- a/src/main/groovy/transform/EqualsAndHashCode.java
+++ b/src/main/groovy/transform/EqualsAndHashCode.java
@@ -265,4 +265,12 @@ public @interface EqualsAndHashCode {
      * Generate a canEqual method to be used by equals.
      */
     boolean useCanEqual() default true;
+
+    /**
+     * Whether to include all fields and/or properties in equals and hashCode calculations, including those
+     * with names that are considered internal.
+     *
+     * @since 2.5.0
+     */
+    boolean allNames() default false;
 }
diff --git a/src/main/groovy/transform/MapConstructor.java b/src/main/groovy/transform/MapConstructor.java
index d5ad3d2852..c37f05b0f8 100644
--- a/src/main/groovy/transform/MapConstructor.java
+++ b/src/main/groovy/transform/MapConstructor.java
@@ -120,4 +120,11 @@ public @interface MapConstructor {
      * A Closure containing statements which will be appended to the end of the generated constructor. Useful for validation steps or tweaking the populated fields/properties.
      */
     Class post();
+
+    /**
+     * Whether to include all fields and/or properties within the constructor, including those with names that are considered internal.
+     *
+     * @since 2.5.0
+     */
+    boolean allNames() default false;
 }
diff --git a/src/main/groovy/transform/ToString.java b/src/main/groovy/transform/ToString.java
index ab312b2407..c1e2145868 100644
--- a/src/main/groovy/transform/ToString.java
+++ b/src/main/groovy/transform/ToString.java
@@ -328,4 +328,11 @@ public @interface ToString {
      */
     boolean cache() default false;
 
+    /**
+     * Whether to include all fields and/or properties in the generated toString, including those with names that
+     * are considered internal.
+     *
+     * @since 2.5.0
+     */
+    boolean allNames() default false;
 }
diff --git a/src/main/groovy/transform/TupleConstructor.java b/src/main/groovy/transform/TupleConstructor.java
index 075fe2c5b9..9ea30df9b5 100644
--- a/src/main/groovy/transform/TupleConstructor.java
+++ b/src/main/groovy/transform/TupleConstructor.java
@@ -251,4 +251,12 @@ public @interface TupleConstructor {
      * made null-safe wrt the parameter.
      */
     boolean useSetters() default false;
+
+    /**
+     * Whether to include all fields and/or properties within the constructor, including those with names that are
+     * considered internal.
+     *
+     * @since 2.5.0
+     */
+    boolean allNames() default false;
 }
diff --git a/src/main/groovy/transform/builder/Builder.java b/src/main/groovy/transform/builder/Builder.java
index eba57e6f96..127273c136 100644
--- a/src/main/groovy/transform/builder/Builder.java
+++ b/src/main/groovy/transform/builder/Builder.java
@@ -140,4 +140,11 @@ public @interface Builder {
      * Generate builder methods for properties from super classes.
      */
     boolean includeSuperProperties() default false;
+
+    /**
+     * Whether the generated builder should support all properties, including those with names that are considered internal.
+     *
+     * @since 2.5.0
+     */
+    boolean allNames() default false;
 }
diff --git a/src/main/groovy/transform/builder/DefaultStrategy.java b/src/main/groovy/transform/builder/DefaultStrategy.java
index eb695627fe..6a72dc0a48 100644
--- a/src/main/groovy/transform/builder/DefaultStrategy.java
+++ b/src/main/groovy/transform/builder/DefaultStrategy.java
@@ -200,7 +200,8 @@ public class DefaultStrategy extends BuilderASTTransformation.AbstractBuilderStr
         ClassNode builder = createBuilder(anno, buildee);
         createBuilderFactoryMethod(anno, buildee, builder);
         List<FieldNode> fields = getFields(transform, anno, buildee);
-        List<FieldNode> filteredFields = selectFieldsFromExistingClass(fields, includes, excludes);
+        boolean allNames = transform.memberHasValue(anno, "allNames", true);
+        List<FieldNode> filteredFields = selectFieldsFromExistingClass(fields, includes, excludes, allNames);
         for (FieldNode fieldNode : filteredFields) {
             ClassNode correctedType = getCorrectedType(buildee, fieldNode);
             String fieldName = fieldNode.getName();
@@ -283,10 +284,10 @@ public class DefaultStrategy extends BuilderASTTransformation.AbstractBuilderStr
         return new FieldNode(fieldName, ACC_PRIVATE, fieldType, buildee, DEFAULT_INITIAL_VALUE);
     }
 
-    private static List<FieldNode> selectFieldsFromExistingClass(List<FieldNode> fieldNodes, List<String> includes, List<String> excludes) {
+    private static List<FieldNode> selectFieldsFromExistingClass(List<FieldNode> fieldNodes, List<String> includes, List<String> excludes, boolean allNames) {
         List<FieldNode> fields = new ArrayList<FieldNode>();
         for (FieldNode fNode : fieldNodes) {
-            if (shouldSkipUndefinedAware(fNode.getName(), excludes, includes)) continue;
+            if (shouldSkipUndefinedAware(fNode.getName(), excludes, includes, allNames)) continue;
             fields.add(fNode);
         }
         return fields;
diff --git a/src/main/groovy/transform/builder/ExternalStrategy.java b/src/main/groovy/transform/builder/ExternalStrategy.java
index 43274e6f0f..9596c197d2 100644
--- a/src/main/groovy/transform/builder/ExternalStrategy.java
+++ b/src/main/groovy/transform/builder/ExternalStrategy.java
@@ -120,10 +120,11 @@ public class ExternalStrategy extends BuilderASTTransformation.AbstractBuilderSt
         if (unsupportedAttribute(transform, anno, "builderClassName")) return;
         if (unsupportedAttribute(transform, anno, "builderMethodName")) return;
         List<PropertyInfo> props;
+        boolean allNames = transform.memberHasValue(anno, "allNames", true);
         if (buildee.getModule() == null) {
-            props = getPropertyInfoFromBeanInfo(buildee, includes, excludes);
+            props = getPropertyInfoFromBeanInfo(buildee, includes, excludes, allNames);
         } else {
-            props = getPropertyInfoFromClassNode(transform, anno, buildee, includes, excludes);
+            props = getPropertyInfoFromClassNode(transform, anno, buildee, includes, excludes, allNames);
         }
         if (includes != null) {
             for (String name : includes) {
@@ -159,12 +160,12 @@ public class ExternalStrategy extends BuilderASTTransformation.AbstractBuilderSt
         return new FieldNode(propName.equals("class") ? "clazz" : propName, ACC_PRIVATE, newClass(prop.getType()), builderClass, DEFAULT_INITIAL_VALUE);
     }
 
-    public static List<PropertyInfo> getPropertyInfoFromBeanInfo(ClassNode cNode, List<String> includes, List<String> excludes) {
+    public static List<PropertyInfo> getPropertyInfoFromBeanInfo(ClassNode cNode, List<String> includes, List<String> excludes, boolean allNames) {
         final List<PropertyInfo> result = new ArrayList<PropertyInfo>();
         try {
             BeanInfo beanInfo = Introspector.getBeanInfo(cNode.getTypeClass());
             for (PropertyDescriptor descriptor : beanInfo.getPropertyDescriptors()) {
-                if (AbstractASTTransformation.shouldSkipUndefinedAware(descriptor.getName(), excludes, includes)) continue;
+                if (AbstractASTTransformation.shouldSkipUndefinedAware(descriptor.getName(), excludes, includes, allNames)) continue;
                 // skip hidden and read-only props
                 if (descriptor.isHidden() || descriptor.getWriteMethod() == null) continue;
                 result.add(new PropertyInfo(descriptor.getName(), ClassHelper.make(descriptor.getPropertyType())));
@@ -174,10 +175,10 @@ public class ExternalStrategy extends BuilderASTTransformation.AbstractBuilderSt
         return result;
     }
 
-    private List<PropertyInfo> getPropertyInfoFromClassNode(BuilderASTTransformation transform, AnnotationNode anno, ClassNode cNode, List<String> includes, List<String> excludes) {
+    private List<PropertyInfo> getPropertyInfoFromClassNode(BuilderASTTransformation transform, AnnotationNode anno, ClassNode cNode, List<String> includes, List<String> excludes, boolean allNames) {
         List<PropertyInfo> props = new ArrayList<PropertyInfo>();
         for (FieldNode fNode : getFields(transform, anno, cNode)) {
-            if (shouldSkip(fNode.getName(), excludes, includes)) continue;
+            if (shouldSkip(fNode.getName(), excludes, includes, allNames)) continue;
             props.add(new PropertyInfo(fNode.getName(), fNode.getType()));
         }
         return props;
diff --git a/src/main/groovy/transform/builder/InitializerStrategy.java b/src/main/groovy/transform/builder/InitializerStrategy.java
index 0417f17cd2..4b598330ba 100644
--- a/src/main/groovy/transform/builder/InitializerStrategy.java
+++ b/src/main/groovy/transform/builder/InitializerStrategy.java
@@ -133,21 +133,22 @@ public class InitializerStrategy extends BuilderASTTransformation.AbstractBuilde
     public void build(BuilderASTTransformation transform, AnnotatedNode annotatedNode, AnnotationNode anno) {
         if (unsupportedAttribute(transform, anno, "forClass")) return;
         boolean useSetters = transform.memberHasValue(anno, "useSetters", true);
+        boolean allNames = transform.memberHasValue(anno, "allNames", true);
         if (annotatedNode instanceof ClassNode) {
-            createBuilderForAnnotatedClass(transform, (ClassNode) annotatedNode, anno, useSetters);
+            createBuilderForAnnotatedClass(transform, (ClassNode) annotatedNode, anno, useSetters, allNames);
         } else if (annotatedNode instanceof MethodNode) {
             createBuilderForAnnotatedMethod(transform, (MethodNode) annotatedNode, anno, useSetters);
         }
     }
 
-    private void createBuilderForAnnotatedClass(BuilderASTTransformation transform, ClassNode buildee, AnnotationNode anno, boolean useSetters) {
+    private void createBuilderForAnnotatedClass(BuilderASTTransformation transform, ClassNode buildee, AnnotationNode anno, boolean useSetters, boolean allNames) {
         List<String> excludes = new ArrayList<String>();
         List<String> includes = new ArrayList<String>();
         includes.add(Undefined.STRING);
         if (!getIncludeExclude(transform, anno, buildee, excludes, includes)) return;
         if (includes.size() == 1 && Undefined.isUndefined(includes.get(0))) includes = null;
         List<FieldNode> fields = getFields(transform, anno, buildee);
-        List<FieldNode> filteredFields = filterFields(fields, includes, excludes);
+        List<FieldNode> filteredFields = filterFields(fields, includes, excludes, allNames);
         if (filteredFields.isEmpty()) {
             transform.addError("Error during " + BuilderASTTransformation.MY_TYPE_NAME +
                     " processing: at least one property is required for this strategy", anno);
@@ -359,10 +360,10 @@ public class InitializerStrategy extends BuilderASTTransformation.AbstractBuilde
         return new FieldNode(fNode.getName(), fNode.getModifiers(), correctedType, buildee, DEFAULT_INITIAL_VALUE);
     }
 
-    private static List<FieldNode> filterFields(List<FieldNode> fieldNodes, List<String> includes, List<String> excludes) {
+    private static List<FieldNode> filterFields(List<FieldNode> fieldNodes, List<String> includes, List<String> excludes, boolean allNames) {
         List<FieldNode> fields = new ArrayList<FieldNode>();
         for (FieldNode fNode : fieldNodes) {
-            if (AbstractASTTransformation.shouldSkipUndefinedAware(fNode.getName(), excludes, includes)) continue;
+            if (AbstractASTTransformation.shouldSkipUndefinedAware(fNode.getName(), excludes, includes, allNames)) continue;
             fields.add(fNode);
         }
         return fields;
diff --git a/src/main/groovy/transform/builder/SimpleStrategy.java b/src/main/groovy/transform/builder/SimpleStrategy.java
index 9a7de9c779..980728e1dd 100644
--- a/src/main/groovy/transform/builder/SimpleStrategy.java
+++ b/src/main/groovy/transform/builder/SimpleStrategy.java
@@ -94,6 +94,7 @@ public class SimpleStrategy extends BuilderASTTransformation.AbstractBuilderStra
         if (unsupportedAttribute(transform, anno, "forClass")) return;
         if (unsupportedAttribute(transform, anno, "includeSuperProperties")) return;
         boolean useSetters = transform.memberHasValue(anno, "useSetters", true);
+        boolean allNames = transform.memberHasValue(anno, "allNames", true);
 
         List<String> excludes = new ArrayList<String>();
         List<String> includes = new ArrayList<String>();
@@ -109,7 +110,7 @@ public class SimpleStrategy extends BuilderASTTransformation.AbstractBuilderStra
         }
         for (FieldNode field : fields) {
             String fieldName = field.getName();
-            if (!AbstractASTTransformation.shouldSkipUndefinedAware(fieldName, excludes, includes)) {
+            if (!AbstractASTTransformation.shouldSkipUndefinedAware(fieldName, excludes, includes, allNames)) {
                 String methodName = getSetterName(prefix, fieldName);
                 Parameter parameter = param(field.getType(), fieldName);
                 buildee.addMethod(methodName, Opcodes.ACC_PUBLIC, newClass(buildee), params(parameter), NO_EXCEPTIONS, block(
diff --git a/src/main/org/codehaus/groovy/transform/AbstractASTTransformation.java b/src/main/org/codehaus/groovy/transform/AbstractASTTransformation.java
index d233a86ea2..b762153094 100644
--- a/src/main/org/codehaus/groovy/transform/AbstractASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/AbstractASTTransformation.java
@@ -260,11 +260,23 @@ public abstract class AbstractASTTransformation implements Opcodes, ASTTransform
     }
 
     public static boolean shouldSkipUndefinedAware(String name, List<String> excludes, List<String> includes) {
-        return (excludes != null && excludes.contains(name)) || deemedInternalName(name) || (includes != null && !includes.contains(name));
+        return shouldSkipUndefinedAware(name, excludes, includes, false);
+    }
+
+    public static boolean shouldSkipUndefinedAware(String name, List<String> excludes, List<String> includes, boolean allNames) {
+        return (excludes != null && excludes.contains(name)) ||
+            (!allNames && deemedInternalName(name)) ||
+            (includes != null && !includes.contains(name));
     }
 
     public static boolean shouldSkip(String name, List<String> excludes, List<String> includes) {
-        return (excludes != null && excludes.contains(name)) || deemedInternalName(name) || (includes != null && !includes.isEmpty() && !includes.contains(name));
+        return shouldSkip(name, excludes, includes, false);
+    }
+
+    public static boolean shouldSkip(String name, List<String> excludes, List<String> includes, boolean allNames) {
+        return (excludes != null && excludes.contains(name)) ||
+            (!allNames && deemedInternalName(name)) ||
+            (includes != null && !includes.isEmpty() && !includes.contains(name));
     }
 
     @Deprecated
diff --git a/src/main/org/codehaus/groovy/transform/BuilderASTTransformation.java b/src/main/org/codehaus/groovy/transform/BuilderASTTransformation.java
index 79ab5a85ae..255a895b11 100644
--- a/src/main/org/codehaus/groovy/transform/BuilderASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/BuilderASTTransformation.java
@@ -78,9 +78,13 @@ public class BuilderASTTransformation extends AbstractASTTransformation implemen
 
     public abstract static class AbstractBuilderStrategy implements BuilderStrategy {
         protected static List<PropertyInfo> getPropertyInfoFromClassNode(ClassNode cNode, List<String> includes, List<String> excludes) {
+            return getPropertyInfoFromClassNode(cNode, includes, excludes, false);
+        }
+
+        protected static List<PropertyInfo> getPropertyInfoFromClassNode(ClassNode cNode, List<String> includes, List<String> excludes, boolean allNames) {
             List<PropertyInfo> props = new ArrayList<PropertyInfo>();
             for (FieldNode fNode : getInstancePropertyFields(cNode)) {
-                if (shouldSkip(fNode.getName(), excludes, includes)) continue;
+                if (shouldSkip(fNode.getName(), excludes, includes, allNames)) continue;
                 props.add(new PropertyInfo(fNode.getName(), fNode.getType()));
             }
             return props;
diff --git a/src/main/org/codehaus/groovy/transform/DelegateASTTransformation.java b/src/main/org/codehaus/groovy/transform/DelegateASTTransformation.java
index d240dfe94f..7c805c02b6 100644
--- a/src/main/org/codehaus/groovy/transform/DelegateASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/DelegateASTTransformation.java
@@ -88,6 +88,7 @@ public class DelegateASTTransformation extends AbstractASTTransformation {
     private static final String MEMBER_EXCLUDE_TYPES = "excludeTypes";
     private static final String MEMBER_PARAMETER_ANNOTATIONS = "parameterAnnotations";
     private static final String MEMBER_METHOD_ANNOTATIONS = "methodAnnotations";
+    private static final String MEMBER_ALL_NAMES = "allNames";
 
     public void visit(ASTNode[] nodes, SourceUnit source) {
         init(nodes, source);
@@ -116,6 +117,7 @@ public class DelegateASTTransformation extends AbstractASTTransformation {
 
             final boolean skipInterfaces = memberHasValue(node, MEMBER_INTERFACES, false);
             final boolean includeDeprecated = memberHasValue(node, MEMBER_DEPRECATED, true) || (type.isInterface() && !skipInterfaces);
+            final boolean allNames = memberHasValue(node, MEMBER_ALL_NAMES, true);
             List<String> excludes = getMemberStringList(node, MEMBER_EXCLUDES);
             List<String> includes = getMemberStringList(node, MEMBER_INCLUDES);
             List<ClassNode> excludeTypes = getMemberClassList(node, MEMBER_EXCLUDE_TYPES);
@@ -124,15 +126,15 @@ public class DelegateASTTransformation extends AbstractASTTransformation {
 
             final List<MethodNode> ownerMethods = getAllMethods(owner);
             for (MethodNode mn : fieldMethods) {
-                addDelegateMethod(node, fieldNode, owner, ownerMethods, mn, includeDeprecated, includes, excludes, includeTypes, excludeTypes);
+                addDelegateMethod(node, fieldNode, owner, ownerMethods, mn, includeDeprecated, includes, excludes, includeTypes, excludeTypes, allNames);
             }
 
             for (PropertyNode prop : getAllProperties(type)) {
                 if (prop.isStatic() || !prop.isPublic())
                     continue;
                 String name = prop.getName();
-                addGetterIfNeeded(fieldNode, owner, prop, name, includes, excludes);
-                addSetterIfNeeded(fieldNode, owner, prop, name, includes, excludes);
+                addGetterIfNeeded(fieldNode, owner, prop, name, includes, excludes, allNames);
+                addSetterIfNeeded(fieldNode, owner, prop, name, includes, excludes, allNames);
             }
 
             if (skipInterfaces) return;
@@ -155,11 +157,11 @@ public class DelegateASTTransformation extends AbstractASTTransformation {
         }
     }
 
-    private static void addSetterIfNeeded(FieldNode fieldNode, ClassNode owner, PropertyNode prop, String name, List<String> includes, List<String> excludes) {
+    private static void addSetterIfNeeded(FieldNode fieldNode, ClassNode owner, PropertyNode prop, String name, List<String> includes, List<String> excludes, boolean allNames) {
         String setterName = "set" + Verifier.capitalize(name);
         if ((prop.getModifiers() & ACC_FINAL) == 0
                 && owner.getSetterMethod(setterName) == null
-                && !shouldSkipPropertyMethod(name, setterName, excludes, includes)) {
+                && !shouldSkipPropertyMethod(name, setterName, excludes, includes, allNames)) {
             owner.addMethod(setterName,
                     ACC_PUBLIC,
                     ClassHelper.VOID_TYPE,
@@ -170,10 +172,10 @@ public class DelegateASTTransformation extends AbstractASTTransformation {
         }
     }
 
-    private static void addGetterIfNeeded(FieldNode fieldNode, ClassNode owner, PropertyNode prop, String name, List<String> includes, List<String> excludes) {
+    private static void addGetterIfNeeded(FieldNode fieldNode, ClassNode owner, PropertyNode prop, String name, List<String> includes, List<String> excludes, boolean allNames) {
         String getterName = "get" + Verifier.capitalize(name);
         if (owner.getGetterMethod(getterName) == null
-                && !shouldSkipPropertyMethod(name, getterName, excludes, includes)) {
+                && !shouldSkipPropertyMethod(name, getterName, excludes, includes, allNames)) {
             owner.addMethod(getterName,
                     ACC_PUBLIC,
                     GenericsUtils.nonGeneric(prop.getType()),
@@ -183,20 +185,20 @@ public class DelegateASTTransformation extends AbstractASTTransformation {
         }
     }
     
-    private static boolean shouldSkipPropertyMethod(String propertyName, String methodName, List<String> excludes, List<String> includes) {
-        return (deemedInternalName(propertyName)
+    private static boolean shouldSkipPropertyMethod(String propertyName, String methodName, List<String> excludes, List<String> includes, boolean allNames) {
+        return ((!allNames && deemedInternalName(propertyName))
                     || excludes != null && (excludes.contains(propertyName) || excludes.contains(methodName)) 
                     || (includes != null && !includes.isEmpty() && !includes.contains(propertyName) && !includes.contains(methodName)));
     }
 
-    private void addDelegateMethod(AnnotationNode node, FieldNode fieldNode, ClassNode owner, List<MethodNode> ownMethods, MethodNode candidate, boolean includeDeprecated, List<String> includes, List<String> excludes, List<ClassNode> includeTypes, List<ClassNode> excludeTypes) {
+    private void addDelegateMethod(AnnotationNode node, FieldNode fieldNode, ClassNode owner, List<MethodNode> ownMethods, MethodNode candidate, boolean includeDeprecated, List<String> includes, List<String> excludes, List<ClassNode> includeTypes, List<ClassNode> excludeTypes, boolean allNames) {
         if (!candidate.isPublic() || candidate.isStatic() || 0 != (candidate.getModifiers () & ACC_SYNTHETIC))
             return;
 
         if (!candidate.getAnnotations(DEPRECATED_TYPE).isEmpty() && !includeDeprecated)
             return;
 
-        if (shouldSkip(candidate.getName(), excludes, includes)) return;
+        if (shouldSkip(candidate.getName(), excludes, includes, allNames)) return;
 
         Map<String,ClassNode> genericsSpec = createGenericsSpec(fieldNode.getDeclaringClass());
         genericsSpec = addMethodGenerics(candidate, genericsSpec);
diff --git a/src/main/org/codehaus/groovy/transform/EqualsAndHashCodeASTTransformation.java b/src/main/org/codehaus/groovy/transform/EqualsAndHashCodeASTTransformation.java
index 91e579d178..1c95a5696e 100644
--- a/src/main/org/codehaus/groovy/transform/EqualsAndHashCodeASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/EqualsAndHashCodeASTTransformation.java
@@ -73,15 +73,20 @@ public class EqualsAndHashCodeASTTransformation extends AbstractASTTransformatio
             boolean includeFields = memberHasValue(anno, "includeFields", true);
             List<String> excludes = getMemberStringList(anno, "excludes");
             List<String> includes = getMemberStringList(anno, "includes");
+            final boolean allNames = memberHasValue(anno, "allNames", true);
             if (!checkIncludeExcludeUndefinedAware(anno, excludes, includes, MY_TYPE_NAME)) return;
             if (!checkPropertyList(cNode, includes, "includes", anno, MY_TYPE_NAME, includeFields)) return;
             if (!checkPropertyList(cNode, excludes, "excludes", anno, MY_TYPE_NAME, includeFields)) return;
-            createHashCode(cNode, cacheHashCode, includeFields, callSuper, excludes, includes);
-            createEquals(cNode, includeFields, callSuper, useCanEqual, excludes, includes);
+            createHashCode(cNode, cacheHashCode, includeFields, callSuper, excludes, includes, allNames);
+            createEquals(cNode, includeFields, callSuper, useCanEqual, excludes, includes, allNames);
         }
     }
 
     public static void createHashCode(ClassNode cNode, boolean cacheResult, boolean includeFields, boolean callSuper, List<String> excludes, List<String> includes) {
+        createHashCode(cNode, cacheResult, includeFields, callSuper, excludes, includes, false);
+    }
+
+    public static void createHashCode(ClassNode cNode, boolean cacheResult, boolean includeFields, boolean callSuper, List<String> excludes, List<String> includes, boolean allNames) {
         // make a public method if none exists otherwise try a private method with leading underscore
         boolean hasExistingHashCode = hasDeclaredMethod(cNode, "hashCode", 0);
         if (hasExistingHashCode && hasDeclaredMethod(cNode, "_hashCode", 0)) return;
@@ -93,11 +98,11 @@ public class EqualsAndHashCodeASTTransformation extends AbstractASTTransformatio
             final Expression hash = varX(hashField);
             body.addStatement(ifS(
                     isZeroX(hash),
-                    calculateHashStatements(cNode, hash, includeFields, callSuper, excludes, includes)
+                    calculateHashStatements(cNode, hash, includeFields, callSuper, excludes, includes, allNames)
             ));
             body.addStatement(returnS(hash));
         } else {
-            body.addStatement(calculateHashStatements(cNode, null, includeFields, callSuper, excludes, includes));
+            body.addStatement(calculateHashStatements(cNode, null, includeFields, callSuper, excludes, includes, allNames));
         }
 
         cNode.addMethod(new MethodNode(
@@ -109,7 +114,7 @@ public class EqualsAndHashCodeASTTransformation extends AbstractASTTransformatio
                 body));
     }
 
-    private static Statement calculateHashStatements(ClassNode cNode, Expression hash, boolean includeFields, boolean callSuper, List<String> excludes, List<String> includes) {
+    private static Statement calculateHashStatements(ClassNode cNode, Expression hash, boolean includeFields, boolean callSuper, List<String> excludes, List<String> includes, boolean allNames) {
         final List<PropertyNode> pList = getInstanceProperties(cNode);
         final List<FieldNode> fList = new ArrayList<FieldNode>();
         if (includeFields) {
@@ -121,7 +126,7 @@ public class EqualsAndHashCodeASTTransformation extends AbstractASTTransformatio
         body.addStatement(declS(result, callX(HASHUTIL_TYPE, "initHash")));
 
         for (PropertyNode pNode : pList) {
-            if (shouldSkip(pNode.getName(), excludes, includes)) continue;
+            if (shouldSkip(pNode.getName(), excludes, includes, allNames)) continue;
             // _result = HashCodeHelper.updateHash(_result, getProperty()) // plus self-reference checking
             Expression getter = getterThisX(cNode, pNode);
             final Expression current = callX(HASHUTIL_TYPE, "updateHash", args(result, getter));
@@ -131,7 +136,7 @@ public class EqualsAndHashCodeASTTransformation extends AbstractASTTransformatio
 
         }
         for (FieldNode fNode : fList) {
-            if (shouldSkip(fNode.getName(), excludes, includes)) continue;
+            if (shouldSkip(fNode.getName(), excludes, includes, allNames)) continue;
             // _result = HashCodeHelper.updateHash(_result, field) // plus self-reference checking
             final Expression fieldExpr = varX(fNode);
             final Expression current = callX(HASHUTIL_TYPE, "updateHash", args(result, fieldExpr));
@@ -171,6 +176,10 @@ public class EqualsAndHashCodeASTTransformation extends AbstractASTTransformatio
     }
 
     public static void createEquals(ClassNode cNode, boolean includeFields, boolean callSuper, boolean useCanEqual, List<String> excludes, List<String> includes) {
+        createEquals(cNode, includeFields, callSuper, useCanEqual, excludes, includes, false);
+    }
+
+    public static void createEquals(ClassNode cNode, boolean includeFields, boolean callSuper, boolean useCanEqual, List<String> excludes, List<String> includes, boolean allNames) {
         if (useCanEqual) createCanEqual(cNode);
         // make a public method if none exists otherwise try a private method with leading underscore
         boolean hasExistingEquals = hasDeclaredMethod(cNode, "equals", 1);
@@ -200,7 +209,7 @@ public class EqualsAndHashCodeASTTransformation extends AbstractASTTransformatio
 
         List<PropertyNode> pList = getInstanceProperties(cNode);
         for (PropertyNode pNode : pList) {
-            if (shouldSkip(pNode.getName(), excludes, includes)) continue;
+            if (shouldSkip(pNode.getName(), excludes, includes, allNames)) continue;
             boolean canBeSelf = StaticTypeCheckingSupport.implementsInterfaceOrIsSubclassOf(
                     pNode.getOriginType(), cNode
             );
@@ -223,7 +232,7 @@ public class EqualsAndHashCodeASTTransformation extends AbstractASTTransformatio
             fList.addAll(getInstanceNonPropertyFields(cNode));
         }
         for (FieldNode fNode : fList) {
-            if (shouldSkip(fNode.getName(), excludes, includes)) continue;
+            if (shouldSkip(fNode.getName(), excludes, includes, allNames)) continue;
             body.addStatement(
                     ifS(notX(hasSameFieldX(fNode, otherTyped)),
                             ifElseS(differentSelfRecursiveFieldX(fNode, otherTyped),
diff --git a/src/main/org/codehaus/groovy/transform/MapConstructorASTTransformation.java b/src/main/org/codehaus/groovy/transform/MapConstructorASTTransformation.java
index 0964854b1d..ec7865cfe5 100644
--- a/src/main/org/codehaus/groovy/transform/MapConstructorASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/MapConstructorASTTransformation.java
@@ -90,6 +90,7 @@ public class MapConstructorASTTransformation extends AbstractASTTransformation {
             boolean useSetters = memberHasValue(anno, "useSetters", true);
             List<String> excludes = getMemberStringList(anno, "excludes");
             List<String> includes = getMemberStringList(anno, "includes");
+            boolean allNames = memberHasValue(anno, "allNames", true);
             if (!checkIncludeExcludeUndefinedAware(anno, excludes, includes, MY_TYPE_NAME)) return;
             if (!checkPropertyList(cNode, includes, "includes", anno, MY_TYPE_NAME, includeFields)) return;
             if (!checkPropertyList(cNode, excludes, "excludes", anno, MY_TYPE_NAME, includeFields)) return;
@@ -107,7 +108,7 @@ public class MapConstructorASTTransformation extends AbstractASTTransformation {
                 return;
             }
 
-            createConstructor(cNode, includeFields, includeProperties, includeSuperProperties, useSetters, excludes, includes, (ClosureExpression) pre, (ClosureExpression) post, source);
+            createConstructor(cNode, includeFields, includeProperties, includeSuperProperties, useSetters, excludes, includes, (ClosureExpression) pre, (ClosureExpression) post, source, allNames);
             if (pre != null) {
                 anno.setMember("pre", new ClosureExpression(new Parameter[0], new EmptyStatement()));
             }
@@ -117,7 +118,7 @@ public class MapConstructorASTTransformation extends AbstractASTTransformation {
         }
     }
 
-    public static void createConstructor(ClassNode cNode, boolean includeFields, boolean includeProperties, boolean includeSuperProperties, boolean useSetters, List<String> excludes, List<String> includes, ClosureExpression pre, ClosureExpression post, SourceUnit source) {
+    public static void createConstructor(ClassNode cNode, boolean includeFields, boolean includeProperties, boolean includeSuperProperties, boolean useSetters, List<String> excludes, List<String> includes, ClosureExpression pre, ClosureExpression post, SourceUnit source, boolean allNames) {
         List<ConstructorNode> constructors = cNode.getDeclaredConstructors();
         boolean foundEmpty = constructors.size() == 1 && constructors.get(0).getFirstStatement() == null;
         // HACK: JavaStubGenerator could have snuck in a constructor we don't want
@@ -145,12 +146,12 @@ public class MapConstructorASTTransformation extends AbstractASTTransformation {
         }
         for (FieldNode fNode : superList) {
             String name = fNode.getName();
-            if (shouldSkip(name, excludes, includes)) continue;
+            if (shouldSkip(name, excludes, includes, allNames)) continue;
             assignField(useSetters, map, body, name);
         }
         for (FieldNode fNode : list) {
             String name = fNode.getName();
-            if (shouldSkip(name, excludes, includes)) continue;
+            if (shouldSkip(name, excludes, includes, allNames)) continue;
             assignField(useSetters, map, body, name);
         }
         if (post != null) {
diff --git a/src/main/org/codehaus/groovy/transform/ToStringASTTransformation.java b/src/main/org/codehaus/groovy/transform/ToStringASTTransformation.java
index 6911ab59f3..504041421f 100644
--- a/src/main/org/codehaus/groovy/transform/ToStringASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/ToStringASTTransformation.java
@@ -80,11 +80,12 @@ public class ToStringASTTransformation extends AbstractASTTransformation {
             boolean ignoreNulls = memberHasValue(anno, "ignoreNulls", true);
             boolean includePackage = !memberHasValue(anno, "includePackage", false);
             boolean allProperties = !memberHasValue(anno, "allProperties", false);
+            boolean allNames = memberHasValue(anno, "allNames", true);
 
             if (!checkIncludeExcludeUndefinedAware(anno, excludes, includes, MY_TYPE_NAME)) return;
             if (!checkPropertyList(cNode, includes, "includes", anno, MY_TYPE_NAME, includeFields)) return;
             if (!checkPropertyList(cNode, excludes, "excludes", anno, MY_TYPE_NAME, includeFields)) return;
-            createToString(cNode, includeSuper, includeFields, excludes, includes, includeNames, ignoreNulls, includePackage, cacheToString, includeSuperProperties, allProperties);
+            createToString(cNode, includeSuper, includeFields, excludes, includes, includeNames, ignoreNulls, includePackage, cacheToString, includeSuperProperties, allProperties, allNames);
         }
     }
 
@@ -109,6 +110,10 @@ public class ToStringASTTransformation extends AbstractASTTransformation {
     }
 
     public static void createToString(ClassNode cNode, boolean includeSuper, boolean includeFields, List<String> excludes, List<String> includes, boolean includeNames, boolean ignoreNulls, boolean includePackage, boolean cache, boolean includeSuperProperties, boolean allProperties) {
+        createToString(cNode, includeSuper, includeFields, excludes, includes, includeNames, ignoreNulls, includePackage, cache, includeSuperProperties, allProperties, false);
+    }
+
+    public static void createToString(ClassNode cNode, boolean includeSuper, boolean includeFields, List<String> excludes, List<String> includes, boolean includeNames, boolean ignoreNulls, boolean includePackage, boolean cache, boolean includeSuperProperties, boolean allProperties, boolean allNames) {
         // make a public method if none exists otherwise try a private method with leading underscore
         boolean hasExistingToString = hasDeclaredMethod(cNode, "toString", 0);
         if (hasExistingToString && hasDeclaredMethod(cNode, "_toString", 0)) return;
@@ -120,11 +125,11 @@ public class ToStringASTTransformation extends AbstractASTTransformation {
             final Expression savedToString = varX(cacheField);
             body.addStatement(ifS(
                     equalsNullX(savedToString),
-                    assignS(savedToString, calculateToStringStatements(cNode, includeSuper, includeFields, excludes, includes, includeNames, ignoreNulls, includePackage, includeSuperProperties, allProperties, body))
+                    assignS(savedToString, calculateToStringStatements(cNode, includeSuper, includeFields, excludes, includes, includeNames, ignoreNulls, includePackage, includeSuperProperties, allProperties, body, allNames))
             ));
             tempToString = savedToString;
         } else {
-            tempToString = calculateToStringStatements(cNode, includeSuper, includeFields, excludes, includes, includeNames, ignoreNulls, includePackage, includeSuperProperties, allProperties, body);
+            tempToString = calculateToStringStatements(cNode, includeSuper, includeFields, excludes, includes, includeNames, ignoreNulls, includePackage, includeSuperProperties, allProperties, body, allNames);
         }
         body.addStatement(returnS(tempToString));
 
@@ -132,7 +137,7 @@ public class ToStringASTTransformation extends AbstractASTTransformation {
                 ClassHelper.STRING_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, body));
     }
 
-    private static Expression calculateToStringStatements(ClassNode cNode, boolean includeSuper, boolean includeFields, List<String> excludes, List<String> includes, boolean includeNames, boolean ignoreNulls, boolean includePackage, boolean includeSuperProperties, boolean allProperties, BlockStatement body) {
+    private static Expression calculateToStringStatements(ClassNode cNode, boolean includeSuper, boolean includeFields, List<String> excludes, List<String> includes, boolean includeNames, boolean ignoreNulls, boolean includePackage, boolean includeSuperProperties, boolean allProperties, BlockStatement body, boolean allNames) {
         // def _result = new StringBuilder()
         final Expression result = varX("_result");
         body.addStatement(declS(result, ctorX(STRINGBUILDER_TYPE)));
@@ -148,7 +153,7 @@ public class ToStringASTTransformation extends AbstractASTTransformation {
         // append properties
         List<PropertyNode> pList = BeanUtils.getAllProperties(cNode, includeSuperProperties, false, allProperties);
         for (PropertyNode pNode : pList) {
-            if (shouldSkip(pNode.getName(), excludes, includes)) continue;
+            if (shouldSkip(pNode.getName(), excludes, includes, allNames)) continue;
             Expression getter = getterThisX(cNode, pNode);
             appendValue(cNode, body, result, first, getter, pNode.getOriginType(), pNode.getName(), includeNames, ignoreNulls);
         }
@@ -158,7 +163,7 @@ public class ToStringASTTransformation extends AbstractASTTransformation {
             List<FieldNode> fList = new ArrayList<FieldNode>();
             fList.addAll(getInstanceNonPropertyFields(cNode));
             for (FieldNode fNode : fList) {
-                if (shouldSkip(fNode.getName(), excludes, includes)) continue;
+                if (shouldSkip(fNode.getName(), excludes, includes, allNames)) continue;
                 appendValue(cNode, body, result, first, varX(fNode), fNode.getType(), fNode.getName(), includeNames, ignoreNulls);
             }
         }
diff --git a/src/main/org/codehaus/groovy/transform/TupleConstructorASTTransformation.java b/src/main/org/codehaus/groovy/transform/TupleConstructorASTTransformation.java
index 3d971f2855..9d8a8009fc 100644
--- a/src/main/org/codehaus/groovy/transform/TupleConstructorASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/TupleConstructorASTTransformation.java
@@ -112,12 +112,13 @@ public class TupleConstructorASTTransformation extends AbstractASTTransformation
             boolean useSetters = memberHasValue(anno, "useSetters", true);
             List<String> excludes = getMemberStringList(anno, "excludes");
             List<String> includes = getMemberStringList(anno, "includes");
+            boolean allNames = memberHasValue(anno, "allNames", true);
             if (!checkIncludeExcludeUndefinedAware(anno, excludes, includes, MY_TYPE_NAME)) return;
             if (!checkPropertyList(cNode, includes, "includes", anno, MY_TYPE_NAME, includeFields)) return;
             if (!checkPropertyList(cNode, excludes, "excludes", anno, MY_TYPE_NAME, includeFields)) return;
             // if @Immutable is found, let it pick up options and do work so we'll skip
             if (hasAnnotation(cNode, ImmutableASTTransformation.MY_TYPE)) return;
-            createConstructor(this, cNode, includeFields, includeProperties, includeSuperFields, includeSuperProperties, callSuper, force, excludes, includes, useSetters, defaults);
+            createConstructor(this, cNode, includeFields, includeProperties, includeSuperFields, includeSuperProperties, callSuper, force, excludes, includes, useSetters, defaults, allNames);
         }
     }
 
@@ -126,6 +127,10 @@ public class TupleConstructorASTTransformation extends AbstractASTTransformation
     }
 
     public static void createConstructor(AbstractASTTransformation xform, ClassNode cNode, boolean includeFields, boolean includeProperties, boolean includeSuperFields, boolean includeSuperProperties, boolean callSuper, boolean force, List<String> excludes, List<String> includes, boolean useSetters, boolean defaults) {
+        createConstructor(xform, cNode, includeFields, includeProperties, includeSuperFields, includeSuperProperties, callSuper, force, excludes, includes, useSetters, defaults, false);
+    }
+
+    public static void createConstructor(AbstractASTTransformation xform, ClassNode cNode, boolean includeFields, boolean includeProperties, boolean includeSuperFields, boolean includeSuperProperties, boolean callSuper, boolean force, List<String> excludes, List<String> includes, boolean useSetters, boolean defaults, boolean allNames) {
         // no processing if existing constructors found
         if (!cNode.getDeclaredConstructors().isEmpty() && !force) return;
 
@@ -150,7 +155,7 @@ public class TupleConstructorASTTransformation extends AbstractASTTransformation
         final BlockStatement body = new BlockStatement();
         for (FieldNode fNode : superList) {
             String name = fNode.getName();
-            if (shouldSkipUndefinedAware(name, excludes, includes)) continue;
+            if (shouldSkipUndefinedAware(name, excludes, includes, allNames)) continue;
             params.add(createParam(fNode, name, defaults, xform));
             boolean hasSetter = cNode.getProperty(name) != null && !fNode.isFinal();
             if (callSuper) {
@@ -168,7 +173,7 @@ public class TupleConstructorASTTransformation extends AbstractASTTransformation
         }
         for (FieldNode fNode : list) {
             String name = fNode.getName();
-            if (shouldSkipUndefinedAware(name, excludes, includes)) continue;
+            if (shouldSkipUndefinedAware(name, excludes, includes, allNames)) continue;
             Parameter nextParam = createParam(fNode, name, defaults, xform);
             params.add(nextParam);
             boolean hasSetter = cNode.getProperty(name) != null && !fNode.isFinal();
diff --git a/src/spec/doc/contributors.adoc b/src/spec/doc/contributors.adoc
index 47770c8031..bdd7c8e710 100644
--- a/src/spec/doc/contributors.adoc
+++ b/src/spec/doc/contributors.adoc
@@ -34,6 +34,7 @@ The Groovy team would like to thank the contributors of this documentation (by a
 * https://github.com/tobia[Tobia Conforto]
 * https://github.com/ddimtirov[Dimitar Dimitrov]
 * http://twitter.com/werdnagreb[Andrew Eisenberg]
+* https://github.com/erdi[Marcin Erdmann]
 * https://github.com/christoph-frick[Christoph Frick]
 * http://twitter.com/marioggar[Mario Garc√≠a]
 * https://github.com/davidmichaelkarr[David Michael Karr]
diff --git a/src/spec/doc/core-metaprogramming.adoc b/src/spec/doc/core-metaprogramming.adoc
index c35b9f5fc3..565b204d90 100644
--- a/src/spec/doc/core-metaprogramming.adoc
+++ b/src/spec/doc/core-metaprogramming.adoc
@@ -826,6 +826,10 @@ include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=
 ----
 include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=tostring_example_cache,indent=0]
 ----
+|allNames|False|Should fields and/or properties with internal names be included in the generated toString|
+[source,groovy]
+----
+include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=tostring_example_allNames,indent=0]
 
 |=======================================================================
 
@@ -871,6 +875,11 @@ include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=
 include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=equalshashcode_example_cache,indent=0]
 ----
 |useCanEqual|True|Should equals call canEqual helper method.|See http://www.artima.com/lejava/articles/equality.html
+|allNames|False|Should fileds and/or properties with internal names be included in equals and hashCode calculations|
+[source,groovy]
+----
+include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=equalshashcode_example_allNames,indent=0]
+----
 |=======================================================================
 
 [[xform-TupleConstructor]]
@@ -966,6 +975,11 @@ Set to false to obtain exactly one constructor but with initial value support an
 ----
 include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=tupleconstructor_example_defaults_false,indent=0]
 ----
+|allNames|False|Should fields and/or properties with internal names be included within the constructor|
+[source,groovy]
+----
+include::{projectdir}/src/spec/test/CodeGenerationASTTransformsTest.groovy[tags=tupleconstructor_example_allNames,indent=0]
+----
 |=======================================================================
 
 Setting the `defaults` annotation attribute to `false` and the `force` annotation attribute to `true` allows
@@ -1226,11 +1240,11 @@ strategy class. The following table lists the available strategies that are bund
 configuration options each strategy supports.
 
 |================================
-| Strategy | Description | builderClassName | builderMethodName |buildMethodName | prefix | includes/excludes | includeSuperProperties
-| `SimpleStrategy` | chained setters | n/a | n/a | n/a | yes, default "set" | yes | n/a
-| `ExternalStrategy` | explicit builder class, class being built untouched | n/a | n/a | yes, default "build" | yes, default "" | yes | yes, default `false`
-| `DefaultStrategy` | creates a nested helper class | yes, default __<TypeName>__Builder | yes, default "builder" | yes, default "build" | yes, default "" | yes | yes, default `false`
-| `InitializerStrategy` | creates a nested helper class providing type-safe fluent creation | yes, default __<TypeName>__Initializer | yes, default "createInitializer" | yes, default "create" but usually only used internally | yes, default "" | yes | yes, default `false`
+| Strategy | Description | builderClassName | builderMethodName |buildMethodName | prefix | includes/excludes | includeSuperProperties | allNames
+| `SimpleStrategy` | chained setters | n/a | n/a | n/a | yes, default "set" | yes | n/a | yes, default `false`
+| `ExternalStrategy` | explicit builder class, class being built untouched | n/a | n/a | yes, default "build" | yes, default "" | yes | yes, default `false`| yes, default `false`
+| `DefaultStrategy` | creates a nested helper class | yes, default __<TypeName>__Builder | yes, default "builder" | yes, default "build" | yes, default "" | yes | yes, default `false`| yes, default `false`
+| `InitializerStrategy` | creates a nested helper class providing type-safe fluent creation | yes, default __<TypeName>__Initializer | yes, default "createInitializer" | yes, default "create" but usually only used internally | yes, default "" | yes | yes, default `false`| yes, default `false`
 |================================
 
 .SimpleStrategy
@@ -1487,6 +1501,11 @@ include::{projectdir}/src/spec/test/ClassDesignASTTransformsTest.groovy[tags=del
 include::{projectdir}/src/spec/test/ClassDesignASTTransformsTest.groovy[tags=delegate_example_includeTypes_header,indent=0]
 include::{projectdir}/src/spec/test/ClassDesignASTTransformsTest.groovy[tags=delegate_example_includeTypes_footer,indent=0]
 ----
+|allNames|False|Should the delegate pattern be also applied to methods with internal names|
+[source,groovy]
+----
+include::{projectdir}/src/spec/test/ClassDesignASTTransformsTest.groovy[tags=delegate_example_allNames,indent=0]
+----
 |=======================================================================
 
 [[xform-Immutable]]
diff --git a/src/spec/test/ClassDesignASTTransformsTest.groovy b/src/spec/test/ClassDesignASTTransformsTest.groovy
index 0350fb9982..41cbb0858a 100644
--- a/src/spec/test/ClassDesignASTTransformsTest.groovy
+++ b/src/spec/test/ClassDesignASTTransformsTest.groovy
@@ -189,14 +189,14 @@ class NumberBooleanBuilder {
     StringBuilder nums = new StringBuilder()
     @Delegate(includeTypes=[AppendFloatSelector], interfaces=false)
     StringBuilder bools = new StringBuilder()
-    String result() { "${nums.toString()} | ${bools.toString()}" }
+    String result() { "${nums.toString()} ~ ${bools.toString()}" }
 }
 def b = new NumberBooleanBuilder()
 b.append(true)
 b.append(3.14f)
 b.append(false)
 b.append(0.0f)
-assert b.result() == "truefalse | 3.140.0"
+assert b.result() == "truefalse ~ 3.140.0"
 // end::delegate_example_includeTypes_header[]
 groovy.test.GroovyAssert.shouldFail {
 // tag::delegate_example_includeTypes_footer[]
@@ -224,6 +224,19 @@ usb.append('hello')
 usb.append(true)
 assert usb.toString() == '3.5trueHELLO'
 // end::delegate_example_excludeTypes[]
+'''
+
+        assertScript '''
+// tag::delegate_example_allNames[]
+class Worker {
+    void task$() {}
+}
+class Delegating {
+    @Delegate(allNames=true) Worker worker = new Worker()
+}
+def d = new Delegating()
+d.task$() //passes
+// end::delegate_example_allNames[]
 '''
     }
 
diff --git a/src/spec/test/CodeGenerationASTTransformsTest.groovy b/src/spec/test/CodeGenerationASTTransformsTest.groovy
index 29335cd766..5131f24712 100644
--- a/src/spec/test/CodeGenerationASTTransformsTest.groovy
+++ b/src/spec/test/CodeGenerationASTTransformsTest.groovy
@@ -214,6 +214,20 @@ assert p.toString() == 'acme.Person(firstName:Jack, lastName:Nicholson)'
 
 '''
 
+        assertScript '''package acme
+import groovy.transform.ToString
+
+// tag::tostring_example_allNames[]
+@ToString(allNames=true)
+class Person {
+    String $firstName
+}
+
+def p = new Person($firstName: "Jack")
+assert p.toString() == 'acme.Person(Jack)'
+// end::tostring_example_allNames[]
+
+'''
     }
 
 
@@ -297,6 +311,24 @@ assert p1!=p2
 assert p1.hashCode() != p2.hashCode()
 // end::equalshashcode_example_super[]
 
+'''
+
+        assertScript '''
+// tag::equalshashcode_example_allNames[]
+import groovy.transform.EqualsAndHashCode
+
+@EqualsAndHashCode(allNames=true)
+class Person {
+    String $firstName
+}
+
+def p1 = new Person($firstName: 'Jack')
+def p2 = new Person($firstName: 'Bob')
+
+assert p1 != p2
+assert p1.hashCode() != p2.hashCode()
+// end::equalshashcode_example_allNames[]
+
 '''
 
         assertScript '''
@@ -673,6 +705,21 @@ assert new Book(2015, false).toString() == 'Book(year:2015, fiction:false)'
 assert new Book("Regina", false).toString() == 'Book(name:Regina, fiction:false)'
 assert Book.constructors.size() == 3
 // end::tupleconstructor_example_defaults_multipleIncludes[]
+'''
+
+        assertScript '''
+// tag::tupleconstructor_example_allNames[]
+import groovy.transform.TupleConstructor
+
+@TupleConstructor(allNames=true)
+class Person {
+    String $firstName
+}
+
+def p = new Person('Jack')
+
+assert p.$firstName == 'Jack'
+// end::tupleconstructor_example_allNames[]
 '''
     }
 
diff --git a/src/test/org/codehaus/groovy/transform/BuilderTransformTest.groovy b/src/test/org/codehaus/groovy/transform/BuilderTransformTest.groovy
index 4c006fb404..1e51e0d5d2 100644
--- a/src/test/org/codehaus/groovy/transform/BuilderTransformTest.groovy
+++ b/src/test/org/codehaus/groovy/transform/BuilderTransformTest.groovy
@@ -703,4 +703,58 @@ class BuilderTransformTest extends CompilableTestSupport {
         assert message.contains('at least one parameter is required for this strategy')
     }
 
+    void testInternalFieldsAreIncludedIfRequestedForSimpleStrategy_GROOVY6454() {
+        assertScript '''
+            import groovy.transform.builder.*
+
+            @Builder(builderStrategy = SimpleStrategy, allNames = true)
+            class HasInternalPropertyWithSimpleStrategy {
+                String $internal
+            }
+            assert new HasInternalPropertyWithSimpleStrategy().set$internal("foo").$internal == "foo"
+         '''
+    }
+
+    void testInternalFieldsAreIncludedIfRequestedForExternalStrategy_GROOVY6454() {
+        assertScript '''
+            import groovy.transform.builder.*
+
+            class HasInternalProperty {
+                String $internal
+            }
+
+            @Builder(builderStrategy = ExternalStrategy, forClass = HasInternalProperty, allNames = true)
+            class HasInternalPropertyBuilder { }
+
+            assert new HasInternalPropertyBuilder().$internal("foo").build().$internal == "foo"
+         '''
+    }
+
+    void testInternalFieldsAreIncludedIfRequestedForDefaultStrategy_GROOVY6454() {
+        assertScript '''
+            import groovy.transform.builder.*
+
+            @Builder(allNames = true)
+            class HasInternalProperty {
+                String $internal
+            }
+
+            assert HasInternalProperty.builder().$internal("foo").$internal == "foo"
+         '''
+    }
+
+    void testInternalFieldsAreIncludedIfRequestedForInitializerStrategyStrategy_GROOVY6454() {
+        assertScript '''
+            import groovy.transform.builder.*
+
+            @Builder(builderStrategy = InitializerStrategy, allNames = true)
+            class HasInternalProperty {
+                String $internal
+            }
+
+            def initializer = HasInternalProperty.createInitializer()
+            assert new HasInternalProperty(initializer.$internal("foo")).$internal == "foo"
+         '''
+    }
+
 }
diff --git a/src/test/org/codehaus/groovy/transform/DelegateTransformTest.groovy b/src/test/org/codehaus/groovy/transform/DelegateTransformTest.groovy
index f025494cdf..61b6ab289d 100644
--- a/src/test/org/codehaus/groovy/transform/DelegateTransformTest.groovy
+++ b/src/test/org/codehaus/groovy/transform/DelegateTransformTest.groovy
@@ -694,6 +694,57 @@ assert foo.dm.x == '123'
             assert f.internalDelegate == ['bar', 'baz']
         '''
     }
+
+    // GROOVY-6454
+    void testMethodsWithInternalNameShouldNotBeDelegatedTo() {
+        assertScript '''
+            class HasMethodWithInternalName {
+                void $() {
+                }
+            }
+
+            class DelegatesToHasMethodWithInternalName {
+                @Delegate
+                HasMethodWithInternalName hasMethodWithInternalName
+            }
+
+            assert !new DelegatesToHasMethodWithInternalName().respondsTo('$')
+        '''
+    }
+
+    // GROOVY-6454
+    void testMethodsWithInternalNameShouldBeDelegatedToIfRequested() {
+        assertScript '''
+            interface HasMethodWithInternalName {
+                void $()
+            }
+
+            class DelegatesToHasMethodWithInternalName {
+                @Delegate(allNames = true)
+                HasMethodWithInternalName hasMethodWithInternalName
+            }
+
+            assert new DelegatesToHasMethodWithInternalName().respondsTo('$')
+        '''
+    }
+
+    // GROOVY-6454
+    void testProperitesWithInternalNameShouldBeDelegatedToIfRequested() {
+        assertScript '''
+            class HasPropertyWithInternalName {
+                def $
+            }
+
+            class DelegatesToHasPropertyWithInternalName {
+                @Delegate(allNames = true)
+                HasPropertyWithInternalName hasPropertyWithInternalName
+            }
+
+            def delegates = new DelegatesToHasPropertyWithInternalName()
+            assert delegates.respondsTo('get$')
+            assert delegates.respondsTo('set$')
+        '''
+    }
 }
 
 interface DelegateFoo {
diff --git a/src/test/org/codehaus/groovy/transform/EqualsAndHashCodeTransformTest.groovy b/src/test/org/codehaus/groovy/transform/EqualsAndHashCodeTransformTest.groovy
index 13338875c2..4f189b0a2e 100644
--- a/src/test/org/codehaus/groovy/transform/EqualsAndHashCodeTransformTest.groovy
+++ b/src/test/org/codehaus/groovy/transform/EqualsAndHashCodeTransformTest.groovy
@@ -87,4 +87,20 @@ class EqualsAndHashCodeTransformTest extends GroovyShellTestCase {
         assert message.contains("Error during @EqualsAndHashCode processing: 'excludes' property 'sirName' does not exist.")
     }
 
+    void testIncludesInternalPropertyNamesIfRequested() {
+        assertScript '''
+            import groovy.transform.EqualsAndHashCode
+
+            @EqualsAndHashCode(allNames = true)
+            class HasInternalNameProperty {
+                String $
+            }
+
+            def a = new HasInternalNameProperty($: "a")
+            def b = new HasInternalNameProperty($: "b")
+            assert a != b
+            assert a.hashCode() != b.hashCode()
+        '''
+    }
+
 }
\ No newline at end of file
diff --git a/src/test/org/codehaus/groovy/transform/MapConstructorTransformTest.groovy b/src/test/org/codehaus/groovy/transform/MapConstructorTransformTest.groovy
index f59c26bb91..59fd20a80f 100644
--- a/src/test/org/codehaus/groovy/transform/MapConstructorTransformTest.groovy
+++ b/src/test/org/codehaus/groovy/transform/MapConstructorTransformTest.groovy
@@ -186,4 +186,18 @@ class MapConstructorTransformTest extends GroovyShellTestCase {
         }
         assert message.contains("Error during @MapConstructor processing: 'excludes' property 'sirName' does not exist.")
     }
+
+    void testInternalFieldsAreIncludedIfRequested() {
+        assertScript '''
+            import groovy.transform.*
+
+            @MapConstructor(allNames = true)
+            class HasInternalProperty {
+                final String $
+            }
+
+            assert new HasInternalProperty($: "foo").$ == "foo"
+        '''
+    }
+
 }
diff --git a/src/test/org/codehaus/groovy/transform/ToStringTransformTest.groovy b/src/test/org/codehaus/groovy/transform/ToStringTransformTest.groovy
index 237b6d4f01..7f28237b9d 100644
--- a/src/test/org/codehaus/groovy/transform/ToStringTransformTest.groovy
+++ b/src/test/org/codehaus/groovy/transform/ToStringTransformTest.groovy
@@ -436,4 +436,16 @@ class ToStringTransformTest extends GroovyShellTestCase {
         '''
     }
 
+    void testInternalFieldsAreIncludedIfRequested() {
+        evaluate '''
+            import groovy.transform.*
+
+            @ToString(allNames = true)
+            class HasInternalProperty {
+                String $
+            }
+            assert new HasInternalProperty($: "foo").toString() == 'HasInternalProperty(foo)'
+        '''
+    }
+
 }
diff --git a/src/test/org/codehaus/groovy/transform/TupleConstructorTransformTest.groovy b/src/test/org/codehaus/groovy/transform/TupleConstructorTransformTest.groovy
index 68284e4649..e4475ef3bb 100644
--- a/src/test/org/codehaus/groovy/transform/TupleConstructorTransformTest.groovy
+++ b/src/test/org/codehaus/groovy/transform/TupleConstructorTransformTest.groovy
@@ -164,4 +164,17 @@ class TupleConstructorTransformTest extends GroovyShellTestCase {
         '''
     }
 
+    void testInternalFieldsAreIncludedIfRequested_groovy6454() {
+        assertScript '''
+            import groovy.transform.*
+
+            @TupleConstructor(allNames = true)
+            class HasInternalName {
+                String $internal
+            }
+
+            assert new HasInternalName("foo").$internal == "foo"
+        '''
+    }
+
 }
\ No newline at end of file
