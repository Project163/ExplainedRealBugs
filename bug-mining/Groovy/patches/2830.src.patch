diff --git a/src/main/org/codehaus/groovy/ast/tools/GenericsUtils.java b/src/main/org/codehaus/groovy/ast/tools/GenericsUtils.java
index b2541c82ff..c5247706a3 100644
--- a/src/main/org/codehaus/groovy/ast/tools/GenericsUtils.java
+++ b/src/main/org/codehaus/groovy/ast/tools/GenericsUtils.java
@@ -293,6 +293,21 @@ public class GenericsUtils {
         return correctToGenericsSpecRecurse(genericsSpec, type, new ArrayList<String>());
     }
 
+    /**
+     * @since 2.4.1
+     */
+    public static ClassNode[] correctToGenericsSpecRecurse(Map<String,ClassNode> genericsSpec, ClassNode[] types) {
+        if (types==null || types.length==1) return types;
+        ClassNode[] newTypes = new ClassNode[types.length];
+        boolean modified = false;
+        for (int i=0; i<types.length; i++) {
+            newTypes[i] = correctToGenericsSpecRecurse(genericsSpec, types[i], new ArrayList<String>());
+            modified = modified || (types[i]!=newTypes[i]);
+        }
+        if (!modified) return types;
+        return newTypes;
+    }
+
     public static ClassNode correctToGenericsSpecRecurse(Map<String,ClassNode> genericsSpec, ClassNode type, List<String> exclusions) {
         if (type.isArray()) {
             return correctToGenericsSpecRecurse(genericsSpec, type.getComponentType(), exclusions).makeArray();
@@ -403,7 +418,7 @@ public class GenericsUtils {
         GenericsType[] sgts = current.getGenericsTypes();
         if (sgts != null) {
             for (GenericsType sgt : sgts) {
-                ret.put(sgt.getName(), correctToGenericsSpec(ret, sgt));
+                ret.put(sgt.getName(), sgt.getType());
             }
         }
         return ret;
@@ -545,4 +560,47 @@ public class GenericsUtils {
         visitor.startResolving(dummyClass, sourceUnit);
         return dummyMN.getReturnType();
     }
+
+    /**
+     * transforms generics types from an old context to a new context using the given spec. This method assumes
+     * all generics types will be placeholders. WARNING: The resulting generics types may or may not be placeholders
+     * after the transformation.
+     * @param genericsSpec the generics context information spec
+     * @param oldPlaceHolders the old placeholders
+     * @return the new generics types
+     */
+    public static GenericsType[] applyGenericsContextToPlaceHolders(Map<String, ClassNode> genericsSpec, GenericsType[] oldPlaceHolders) {
+        if (oldPlaceHolders==null || oldPlaceHolders.length==0) return oldPlaceHolders;
+        if (genericsSpec.isEmpty()) return oldPlaceHolders;
+        GenericsType[] newTypes = new GenericsType[oldPlaceHolders.length];
+        for (int i=0; i<oldPlaceHolders.length; i++) {
+            GenericsType old = oldPlaceHolders[i];
+            if (!old.isPlaceholder()) throw new GroovyBugError("Given generics type "+old+" must be a placeholder!");
+            ClassNode fromSpec = genericsSpec.get(old.getName());
+            if (fromSpec!=null) {
+                newTypes[i] = new GenericsType(fromSpec);
+            } else {
+                ClassNode[] upper = old.getUpperBounds();
+                ClassNode[] newUpper = upper;
+                if (upper!=null && upper.length>0) {
+                    ClassNode[] upperCorrected = new ClassNode[upper.length];
+                    for (int j=0;j<upper.length;j++) {
+                        upperCorrected[i] = correctToGenericsSpecRecurse(genericsSpec,upper[j]);
+                    }
+                    upper = upperCorrected;
+                }
+                ClassNode lower = old.getLowerBound();
+                ClassNode newLower = correctToGenericsSpecRecurse(genericsSpec,lower);
+                if (lower==newLower && upper==newUpper) {
+                    newTypes[i] = oldPlaceHolders[i];
+                } else {
+                    ClassNode newPlaceHolder = ClassHelper.make(old.getName());
+                    GenericsType gt = new GenericsType(newPlaceHolder, newUpper, newLower);
+                    gt.setPlaceholder(true);
+                    newTypes[i] = gt;
+                }
+            }
+        }
+        return newTypes;
+    }
 }
diff --git a/src/main/org/codehaus/groovy/classgen/Verifier.java b/src/main/org/codehaus/groovy/classgen/Verifier.java
index f025df460a..29787bf7f8 100644
--- a/src/main/org/codehaus/groovy/classgen/Verifier.java
+++ b/src/main/org/codehaus/groovy/classgen/Verifier.java
@@ -34,6 +34,7 @@ import org.codehaus.groovy.ast.stmt.BlockStatement;
 import org.codehaus.groovy.ast.stmt.ExpressionStatement;
 import org.codehaus.groovy.ast.stmt.ReturnStatement;
 import org.codehaus.groovy.ast.stmt.Statement;
+import org.codehaus.groovy.ast.tools.GenericsUtils;
 import org.codehaus.groovy.classgen.asm.BytecodeHelper;
 import org.codehaus.groovy.classgen.asm.MopWriter;
 import org.codehaus.groovy.classgen.asm.OptimizingStatementWriter.ClassNodeSkip;
@@ -1277,6 +1278,9 @@ public class Verifier implements GroovyClassVisitor, Opcodes {
         boolean genericEqualParameters = equalParametersWithGenerics(overridingMethod, oldMethod, genericsSpec);
         if (!normalEqualParameters && !genericEqualParameters) return null;
 
+        //correct to method level generics for the overriding method
+        genericsSpec = GenericsUtils.addMethodGenerics(overridingMethod, genericsSpec);
+
         // return type
         ClassNode mr = overridingMethod.getReturnType();
         ClassNode omr = oldMethod.getReturnType();
diff --git a/src/main/org/codehaus/groovy/transform/trait/TraitASTTransformation.java b/src/main/org/codehaus/groovy/transform/trait/TraitASTTransformation.java
index c1897a2a24..1543f788d1 100644
--- a/src/main/org/codehaus/groovy/transform/trait/TraitASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/trait/TraitASTTransformation.java
@@ -134,11 +134,6 @@ public class TraitASTTransformation extends AbstractASTTransformation implements
         }
     }
 
-    private static void fixGenerics(MethodNode mn, ClassNode cNode) {
-        if (!cNode.isUsingGenerics()) return;
-        mn.setGenericsTypes(cNode.getGenericsTypes());
-    }
-
     private void createHelperClass(final ClassNode cNode) {
         ClassNode helper = new InnerClassNode(
                 cNode,
@@ -234,7 +229,6 @@ public class TraitASTTransformation extends AbstractASTTransformation implements
                 ClassNode.EMPTY_ARRAY,
                 new BlockStatement()
         );
-        fixGenerics(initializer, cNode);
         helper.addMethod(initializer);
 
         // Cannot add static compilation of init method because of GROOVY-7217, see example 2 of test case
@@ -336,7 +330,6 @@ public class TraitASTTransformation extends AbstractASTTransformation implements
             MethodNode getter =
                     new MethodNode(getterName, propNodeModifiers, node.getType(), Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, getterBlock);
             getter.setSynthetic(true);
-            fixGenerics(getter, cNode);
             cNode.addMethod(getter);
 
             if (ClassHelper.boolean_TYPE == node.getType() || ClassHelper.Boolean_TYPE == node.getType()) {
@@ -344,7 +337,6 @@ public class TraitASTTransformation extends AbstractASTTransformation implements
                 MethodNode secondGetter =
                         new MethodNode(secondGetterName, propNodeModifiers, node.getType(), Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, getterBlock);
                 secondGetter.setSynthetic(true);
-                fixGenerics(secondGetter, cNode);
                 cNode.addMethod(secondGetter);
             }
         }
@@ -355,7 +347,6 @@ public class TraitASTTransformation extends AbstractASTTransformation implements
             MethodNode setter =
                     new MethodNode(setterName, propNodeModifiers, ClassHelper.VOID_TYPE, setterParameterTypes, ClassNode.EMPTY_ARRAY, setterBlock);
             setter.setSynthetic(true);
-            fixGenerics(setter, cNode);
             cNode.addMethod(setter);
         }
     }
diff --git a/src/main/org/codehaus/groovy/transform/trait/TraitComposer.java b/src/main/org/codehaus/groovy/transform/trait/TraitComposer.java
index c5940b64e0..a7f1cba00c 100644
--- a/src/main/org/codehaus/groovy/transform/trait/TraitComposer.java
+++ b/src/main/org/codehaus/groovy/transform/trait/TraitComposer.java
@@ -57,8 +57,10 @@ import org.objectweb.asm.Opcodes;
 
 import java.lang.reflect.Modifier;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.Comparator;
+import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
 import java.util.LinkedList;
@@ -286,13 +288,16 @@ public abstract class TraitComposer {
             Parameter[] traitMethodParams,
             Parameter[] forwarderParams,
             ArgumentListExpression helperMethodArgList) {
-        ClassNode[] exceptionNodes = copyExceptions(helperMethod.getExceptions());
         MethodCallExpression mce = new MethodCallExpression(
                 new ClassExpression(helperClassNode),
                 helperMethod.getName(),
                 helperMethodArgList
         );
         mce.setImplicitThis(false);
+
+        genericsSpec = GenericsUtils.addMethodGenerics(helperMethod,genericsSpec);
+
+        ClassNode[] exceptionNodes = correctToGenericsSpecRecurse(genericsSpec, copyExceptions(helperMethod.getExceptions()));
         ClassNode fixedReturnType = correctToGenericsSpecRecurse(genericsSpec, helperMethod.getReturnType());
         Expression forwardExpression = genericsSpec.isEmpty()?mce:new CastExpression(fixedReturnType,mce);
         int access = helperMethod.getModifiers();
@@ -322,7 +327,9 @@ public abstract class TraitComposer {
             forwarder.addAnnotations(copied);
         }
         if (originalMethod!=null) {
-            forwarder.setGenericsTypes(originalMethod.getGenericsTypes());
+            GenericsType[] newGt = GenericsUtils.applyGenericsContextToPlaceHolders(genericsSpec, originalMethod.getGenericsTypes());
+            newGt = removeNonPlaceHolders(newGt);
+            forwarder.setGenericsTypes(newGt);
         }
         // add a helper annotation indicating that it is a bridge method
         AnnotationNode bridgeAnnotation = new AnnotationNode(Traits.TRAITBRIDGE_CLASSNODE);
@@ -339,6 +346,23 @@ public abstract class TraitComposer {
         createSuperForwarder(targetNode, forwarder, genericsSpec);
     }
 
+    private static GenericsType[] removeNonPlaceHolders(GenericsType[] oldTypes) {
+        if (oldTypes==null || oldTypes.length==0) return oldTypes;
+        ArrayList<GenericsType> l = new ArrayList<GenericsType>(Arrays.asList(oldTypes));
+        Iterator<GenericsType> it = l.iterator();
+        boolean modified = false;
+        while (it.hasNext()) {
+            GenericsType gt = it.next();
+            if (!gt.isPlaceholder()) {
+                it.remove();
+                modified = true;
+            }
+        }
+        if (!modified) return oldTypes;
+        if (l.size()==0) return null;
+        return l.toArray(new GenericsType[l.size()]);
+    }
+
     /**
      * Creates, if necessary, a super forwarder method, for stackable traits.
      * @param forwarder a forwarder method
diff --git a/src/test/org/codehaus/groovy/transform/traitx/TraitASTTransformationTest.groovy b/src/test/org/codehaus/groovy/transform/traitx/TraitASTTransformationTest.groovy
index 1685e9d656..87ebebd158 100644
--- a/src/test/org/codehaus/groovy/transform/traitx/TraitASTTransformationTest.groovy
+++ b/src/test/org/codehaus/groovy/transform/traitx/TraitASTTransformationTest.groovy
@@ -2365,4 +2365,64 @@ assert c.b() == 2
     @SelfType([String, Date])
     trait DoubleSelfTypeTrait {}
 
+    //GROOVY-7287
+    void testTraitWithMethodLevelGenericsShadowing() {
+        assertScript '''
+            trait Configurable<ConfigObject> {
+                ConfigObject configObject
+
+                void configure(Closure<Void> configSpec) {
+                    configSpec.resolveStrategy = Closure.DELEGATE_FIRST
+                    configSpec.delegate = configObject
+                    configSpec()
+                }
+            }
+            public <T,U extends Configurable<T>> U configure(Class<U> clazz, @DelegatesTo(type="T") Closure configSpec) {
+                Configurable<T> obj = (Configurable<T>) clazz.newInstance()
+                obj.configure(configSpec)
+                obj
+            }
+
+
+            class Module implements Configurable<ModuleConfig> {
+                String value
+
+                Module(){
+                    configObject = new ModuleConfig()
+                }
+
+
+                @Override
+                void configure(Closure<Void> configSpec) {
+                    Configurable.super.configure(configSpec)
+                    value = "${configObject.name}-${configObject.version}"
+                }
+            }
+
+
+            class ModuleConfig {
+                String name
+                String version
+            }
+            def module = configure(Module) {
+                name = 'test\'
+                version = '1.0\'
+            }
+            assert module.value == 'test-1.0\'
+        '''
+
+        assertScript '''
+            trait SomeTrait {
+                def <T extends Number> T someOtherMethod() {}
+            }
+            class SuperClass<T> implements SomeTrait {}
+            class SubClass extends SuperClass<String> implements SomeTrait {}
+            SubClass.declaredMethods.findAll    {it.name=="someOtherMethod"}.
+                                     each {
+                                         assert it.returnType == Number
+                                         assert it.genericReturnType.name == "T"
+                                     }
+        '''
+    }
+
 }
