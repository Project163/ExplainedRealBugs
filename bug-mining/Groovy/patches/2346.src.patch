diff --git a/src/main/groovy/lang/Delegate.java b/src/main/groovy/lang/Delegate.java
index 88b8ee1901..696344923b 100644
--- a/src/main/groovy/lang/Delegate.java
+++ b/src/main/groovy/lang/Delegate.java
@@ -158,4 +158,45 @@ public @interface Delegate {
      * @return true if generated delegate methods should keep parameter annotations
      */
     boolean parameterAnnotations() default false;
+
+    /**
+     * List of method and/or property names to exclude when delegating.
+     * Must not be used if 'includes' is used. For convenience, a String with comma separated names
+     * can be used in addition to an array (using Groovy's literal list notation) of String values.
+     * If interfaces is true (the default), you will need to manually supply any methods excluded
+     * from delegation that are required for the interface.
+     * @since 2.2.0
+     */
+    String[] excludes() default {};
+
+
+    /* *
+     * List of interfaces containing method signatures to exclude when delegating.
+     * Only one of 'includes', 'includeTypes', 'excludes', 'excludeTypes' should be used.
+     * If interfaces is true (the default), you will need to manually supply any methods excluded
+     * from delegation that are required for the interface.
+     * @since ???
+     */
+    // GROOVY-6329: awaiting resolution of GROOVY-6330
+//    Class[] excludeTypes() default {};
+
+    /**
+     * List of method and/or property names to include when delegating.
+     * Must not be used if 'excludes' is used. For convenience, a String with comma separated names
+     * can be used in addition to an array (using Groovy's literal list notation) of String values.
+     * If interfaces is true (the default), you will need to manually supply any methods not included
+     * via delegation that are required for the interface.
+     * @since 2.2.0
+     */
+    String[] includes() default {};
+
+    /* *
+     * List of interfaces containing method signatures to exclude when delegating.
+     * Only one of 'includes', 'includeTypes', 'excludes', 'excludeTypes' should be used.
+     * If interfaces is true (the default), you will need to manually supply any methods excluded
+     * from delegation that are required for the interface.
+     * @since ???
+     */
+    // GROOVY-6329: awaiting resolution of GROOVY-6330
+//    Class[] includeTypes() default {};
 }
diff --git a/src/main/org/codehaus/groovy/transform/AbstractASTTransformation.java b/src/main/org/codehaus/groovy/transform/AbstractASTTransformation.java
index 5c0a89060b..9f63b9afb6 100644
--- a/src/main/org/codehaus/groovy/transform/AbstractASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/AbstractASTTransformation.java
@@ -19,7 +19,10 @@ import org.codehaus.groovy.GroovyBugError;
 import org.codehaus.groovy.ast.ASTNode;
 import org.codehaus.groovy.ast.AnnotatedNode;
 import org.codehaus.groovy.ast.AnnotationNode;
+import org.codehaus.groovy.ast.ClassHelper;
 import org.codehaus.groovy.ast.ClassNode;
+//import org.codehaus.groovy.ast.MethodNode;
+//import org.codehaus.groovy.ast.expr.ClassExpression;
 import org.codehaus.groovy.ast.expr.ConstantExpression;
 import org.codehaus.groovy.ast.expr.Expression;
 import org.codehaus.groovy.ast.expr.ListExpression;
@@ -81,6 +84,27 @@ public abstract class AbstractASTTransformation implements Opcodes, ASTTransform
         return list;
     }
 
+    // GROOVY-6329: awaiting resolution of GROOVY-6330
+/*
+    protected List<ClassNode> getClassList(AnnotationNode anno, String name) {
+        List<ClassNode> list = new ArrayList<ClassNode>();
+        Expression expr = anno.getMember(name);
+        if (expr != null && expr instanceof ListExpression) {
+            final ListExpression listExpression = (ListExpression) expr;
+            for (Expression itemExpr : listExpression.getExpressions()) {
+                if (itemExpr != null && itemExpr instanceof ClassExpression) {
+                    ClassNode cn = itemExpr.getType();
+                    if (cn != null) list.add(cn);
+                }
+            }
+        } else if (expr != null && expr instanceof ClassExpression) {
+            ClassNode cn = expr.getType();
+            if (cn != null) list.add(cn);
+        }
+        return list;
+    }
+*/
+
     protected void addError(String msg, ASTNode expr) {
         sourceUnit.getErrorCollector().addErrorAndContinue(new SyntaxErrorMessage(
                 new SyntaxException(msg + '\n', expr.getLineNumber(), expr.getColumnNumber(),
@@ -108,4 +132,61 @@ public abstract class AbstractASTTransformation implements Opcodes, ASTTransform
     public static boolean shouldSkip(String name, List<String> excludes, List<String> includes) {
         return (excludes != null && excludes.contains(name)) || name.contains("$") || (includes != null && !includes.isEmpty() && !includes.contains(name));
     }
+
+    // GROOVY-6329: awaiting resolution of GROOVY-6330
+/*
+    public static boolean shouldSkipOnDescriptor(String descriptor, List<ClassNode> excludeTypes, List<ClassNode> includeTypes) {
+        if (excludeTypes != null) {
+            for (ClassNode cn : excludeTypes) {
+                for (MethodNode mn : nonGeneric(cn).getMethods()) {
+                    if (mn.getTypeDescriptor().equals(descriptor)) return true;
+                }
+            }
+            return false;
+        }
+        if (includeTypes != null) {
+            for (ClassNode cn : includeTypes) {
+                for (MethodNode mn : nonGeneric(cn).getMethods()) {
+                    if (mn.getTypeDescriptor().equals(descriptor)) return false;
+                }
+            }
+            return true;
+        }
+        return false;
+    }
+*/
+
+    protected void checkIncludeExclude(AnnotationNode node, List<String> excludes, List<String> includes, String typeName) {
+        if (includes != null && !includes.isEmpty() && excludes != null && !excludes.isEmpty()) {
+            addError("Error during " + typeName + " processing: Only one of 'includes' and 'excludes' should be supplied not both.", node);
+        }
+    }
+
+    // GROOVY-6329: awaiting resolution of GROOVY-6330
+/*
+    protected void checkIncludeExclude(AnnotationNode node, List<String> excludes, List<String> includes, List<ClassNode> excludeTypes, List<ClassNode> includeTypes, String typeName) {
+        int found = 0;
+        if (includes != null && !includes.isEmpty()) found++;
+        if (excludes != null && !excludes.isEmpty()) found++;
+        if (includeTypes != null && !includeTypes.isEmpty()) found++;
+        if (excludeTypes != null && !excludeTypes.isEmpty()) found++;
+        if (found > 1) {
+            addError("Error during " + typeName + " processing: Only one of 'includes', 'excludes', 'includeTypes' and 'excludeTypes' should be supplied.", node);
+        }
+    }
+*/
+
+    public static ClassNode nonGeneric(ClassNode type) {
+        if (type.isUsingGenerics()) {
+            final ClassNode nonGen = ClassHelper.makeWithoutCaching(type.getName());
+            nonGen.setRedirect(type);
+            nonGen.setGenericsTypes(null);
+            nonGen.setUsingGenerics(false);
+            return nonGen;
+        }
+        if (type.isArray() && type.getComponentType().isUsingGenerics()) {
+            return type.getComponentType().getPlainNodeReference().makeArray();
+        }
+        return type;
+    }
 }
diff --git a/src/main/org/codehaus/groovy/transform/DelegateASTTransformation.java b/src/main/org/codehaus/groovy/transform/DelegateASTTransformation.java
index 7af865fcd2..448c6fff82 100644
--- a/src/main/org/codehaus/groovy/transform/DelegateASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/DelegateASTTransformation.java
@@ -15,6 +15,7 @@
  */
 package org.codehaus.groovy.transform;
 
+import groovy.lang.Delegate;
 import groovy.lang.GroovyObject;
 import org.codehaus.groovy.ast.*;
 import org.codehaus.groovy.ast.expr.*;
@@ -43,11 +44,19 @@ import java.util.*;
 @GroovyASTTransformation(phase = CompilePhase.CANONICALIZATION)
 public class DelegateASTTransformation extends AbstractASTTransformation implements ASTTransformation, Opcodes {
 
+    private static final Class MY_CLASS = Delegate.class;
+    private static final ClassNode MY_TYPE = ClassHelper.make(MY_CLASS);
+    private static final String MY_TYPE_NAME = "@" + MY_TYPE.getNameWithoutPackage();
     private static final ClassNode DEPRECATED_TYPE = ClassHelper.make(Deprecated.class);
     private static final ClassNode GROOVYOBJECT_TYPE = ClassHelper.make(GroovyObject.class);
 
     private static final String MEMBER_DEPRECATED = "deprecated";
     private static final String MEMBER_INTERFACES = "interfaces";
+    private static final String MEMBER_INCLUDES = "includes";
+    private static final String MEMBER_EXCLUDES = "excludes";
+    // GROOVY-6329: awaiting resolution of GROOVY-6330
+//    private static final String MEMBER_INCLUDE_TYPES = "includeTypes";
+//    private static final String MEMBER_EXCLUDE_TYPES = "excludeTypes";
     private static final String MEMBER_PARAMETER_ANNOTATIONS = "parameterAnnotations";
     private static final String MEMBER_METHOD_ANNOTATIONS = "methodAnnotations";
 
@@ -62,12 +71,12 @@ public class DelegateASTTransformation extends AbstractASTTransformation impleme
             final ClassNode type = fieldNode.getType();
             final ClassNode owner = fieldNode.getOwner();
             if (type.equals(ClassHelper.OBJECT_TYPE) || type.equals(GROOVYOBJECT_TYPE)) {
-                addError("@Delegate field '" + fieldNode.getName() + "' has an inappropriate type: " + type.getName() +
+                addError(MY_TYPE_NAME + " field '" + fieldNode.getName() + "' has an inappropriate type: " + type.getName() +
                         ". Please add an explicit type but not java.lang.Object or groovy.lang.GroovyObject.", parent);
                 return;
             }
             if (type.equals(owner)) {
-                addError("@Delegate field '" + fieldNode.getName() + "' has an inappropriate type: " + type.getName() +
+                addError(MY_TYPE_NAME + " field '" + fieldNode.getName() + "' has an inappropriate type: " + type.getName() +
                         ". Delegation to own type not supported. Please use a different type.", parent);
                 return;
             }
@@ -78,10 +87,21 @@ public class DelegateASTTransformation extends AbstractASTTransformation impleme
 
             final boolean skipInterfaces = hasBooleanValue(node.getMember(MEMBER_INTERFACES), false);
             final boolean includeDeprecated = hasBooleanValue(node.getMember(MEMBER_DEPRECATED), true) || (type.isInterface() && !skipInterfaces);
+            List<String> excludes = getMemberList(node, MEMBER_EXCLUDES);
+            List<String> includes = getMemberList(node, MEMBER_INCLUDES);
+            // GROOVY-6329: awaiting resolution of GROOVY-6330
+/*
+            List<ClassNode> excludeTypes = getClassList(node, MEMBER_EXCLUDE_TYPES);
+            List<ClassNode> includeTypes = getClassList(node, MEMBER_INCLUDE_TYPES);
+            checkIncludeExclude(node, excludes, includes, excludeTypes, includeTypes, MY_TYPE_NAME);
+*/
+            checkIncludeExclude(node, excludes, includes, MY_TYPE_NAME);
 
             final List<MethodNode> ownerMethods = getAllMethods(owner);
             for (MethodNode mn : fieldMethods) {
-                addDelegateMethod(node, fieldNode, owner, ownerMethods, mn, includeDeprecated);
+                // GROOVY-6329: awaiting resolution of GROOVY-6330
+//                addDelegateMethod(node, fieldNode, owner, ownerMethods, mn, includeDeprecated, includes, excludes, includeTypes, excludeTypes);
+                addDelegateMethod(node, fieldNode, owner, ownerMethods, mn, includeDeprecated, includes, excludes);
             }
 
             for (PropertyNode prop : getAllProperties(type)) {
@@ -179,13 +199,21 @@ public class DelegateASTTransformation extends AbstractASTTransformation impleme
         }
     }
 
-    private void addDelegateMethod(AnnotationNode node, FieldNode fieldNode, ClassNode owner, List<MethodNode> ownMethods, MethodNode candidate, boolean includeDeprecated) {
+    private void addDelegateMethod(AnnotationNode node, FieldNode fieldNode, ClassNode owner, List<MethodNode> ownMethods, MethodNode candidate, boolean includeDeprecated, List<String> includes, List<String> excludes/*, List<ClassNode> includeTypes, List<ClassNode> excludeTypes*/) {
         if (!candidate.isPublic() || candidate.isStatic() || 0 != (candidate.getModifiers () & Opcodes.ACC_SYNTHETIC))
             return;
 
         if (!candidate.getAnnotations(DEPRECATED_TYPE).isEmpty() && !includeDeprecated)
             return;
 
+        if (shouldSkip(candidate.getName(), excludes, includes)) return;
+        checkIncludeExclude(node, excludes, includes, MY_TYPE_NAME);
+        // GROOVY-6329: awaiting resolution of GROOVY-6330
+/*
+        checkIncludeExclude(node, excludes, includes, excludeTypes, includeTypes, MY_TYPE_NAME);
+        if (shouldSkipOnDescriptor(candidate.getTypeDescriptor(), excludeTypes, includeTypes)) return;
+*/
+
         // ignore methods from GroovyObject
         for (MethodNode mn : GROOVYOBJECT_TYPE.getMethods()) {
             if (mn.getTypeDescriptor().equals(candidate.getTypeDescriptor())) {
@@ -276,7 +304,7 @@ public class DelegateASTTransformation extends AbstractASTTransformation impleme
             if (annotations.isEmpty()) continue;
 
             if (hasClosureMember(annotation)) {
-                addError("@Delegate does not support keeping Closure annotation members.", annotation);
+                addError(MY_TYPE_NAME + " does not support keeping Closure annotation members.", annotation);
                 continue;
             }
 
@@ -320,18 +348,4 @@ public class DelegateASTTransformation extends AbstractASTTransformation impleme
 
         return false;
     }
-
-    private ClassNode nonGeneric(ClassNode type) {
-        if (type.isUsingGenerics()) {
-            final ClassNode nonGen = ClassHelper.makeWithoutCaching(type.getName());
-            nonGen.setRedirect(type);
-            nonGen.setGenericsTypes(null);
-            nonGen.setUsingGenerics(false);
-            return nonGen;
-        } else if (type.isArray() && type.getComponentType().isUsingGenerics()) {
-            return type.getComponentType().getPlainNodeReference().makeArray();
-        } else {
-            return type;
-        }
-    }
 }
diff --git a/src/test/org/codehaus/groovy/transform/DelegateTransformTest.groovy b/src/test/org/codehaus/groovy/transform/DelegateTransformTest.groovy
index b73dee068a..44150e330c 100644
--- a/src/test/org/codehaus/groovy/transform/DelegateTransformTest.groovy
+++ b/src/test/org/codehaus/groovy/transform/DelegateTransformTest.groovy
@@ -52,6 +52,26 @@ class DelegateTransformTest extends CompilableTestSupport {
         """
     }
 
+    /** test for GROOVY-GROOVY-5974 */
+    void testDelegateExcludes() {
+        assertScript """
+          class MapSet {
+            @Delegate(interfaces=false, excludes=['remove','clear']) Map m = [a: 1]
+            @Delegate Set s = [2, 3, 4]
+            String toString() { m.toString() + ' ' + s }
+          }
+
+          def ms = new MapSet()
+          assert ms.size() == 1
+          assert ms.toString() == '[a:1] [2, 3, 4]'
+          ms.remove(3)
+          assert ms.size() == 1
+          assert ms.toString() == '[a:1] [2, 4]'
+          ms.clear()
+          assert ms.toString() == '[a:1] []'
+        """
+    }
+
     void testLock() {
         def res = new GroovyShell().evaluate("""
               import java.util.concurrent.locks.*
