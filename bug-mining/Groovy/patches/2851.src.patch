diff --git a/src/main/org/codehaus/groovy/transform/stc/TraitTypeCheckingExtension.java b/src/main/org/codehaus/groovy/transform/stc/TraitTypeCheckingExtension.java
index fe19e79b98..76a0bf62bb 100644
--- a/src/main/org/codehaus/groovy/transform/stc/TraitTypeCheckingExtension.java
+++ b/src/main/org/codehaus/groovy/transform/stc/TraitTypeCheckingExtension.java
@@ -18,9 +18,11 @@ package org.codehaus.groovy.transform.stc;
 import org.codehaus.groovy.ast.ClassHelper;
 import org.codehaus.groovy.ast.ClassNode;
 import org.codehaus.groovy.ast.MethodNode;
+import org.codehaus.groovy.ast.Parameter;
 import org.codehaus.groovy.ast.expr.ArgumentListExpression;
 import org.codehaus.groovy.ast.expr.MethodCall;
 import org.codehaus.groovy.ast.expr.MethodCallExpression;
+import org.codehaus.groovy.ast.expr.VariableExpression;
 import org.codehaus.groovy.transform.trait.TraitASTTransformation;
 import org.codehaus.groovy.transform.trait.Traits;
 
@@ -29,6 +31,8 @@ import java.util.Collections;
 import java.util.LinkedHashSet;
 import java.util.List;
 
+import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.isClassClassNodeWrappingConcreteType;
+
 /**
  * A type checking extension that will take care of handling errors which are specific to traits. In particular, it will
  * hanldle the "super" method calls within a trait.
@@ -59,7 +63,33 @@ public class TraitTypeCheckingExtension extends AbstractTypeCheckingExtension {
             return convertToDynamicCall(call, receiver, decomposed, argumentTypes);
         }
         if (call instanceof MethodCallExpression) {
-            ClassNode dynamic = ((MethodCallExpression) call).getNodeMetaData(TraitASTTransformation.DO_DYNAMIC);
+            MethodCallExpression mce = (MethodCallExpression) call;
+            if (mce.getReceiver() instanceof VariableExpression) {
+                VariableExpression var = (VariableExpression) mce.getReceiver();
+
+                // GROOVY-7322
+                // static method call in trait?
+                ClassNode type = null;
+                if (isStaticTraitReceiver(receiver, var)) {
+                    type = receiver.getGenericsTypes()[0].getType();
+                } else if (isThisTraitReceiver(var)) {
+                    type = receiver;
+                }
+                if (type != null && Traits.isTrait(type)) {
+                    ClassNode helper = Traits.findHelper(type);
+                    Parameter[] params = new Parameter[argumentTypes.length + 1];
+                    params[0] = new Parameter(ClassHelper.CLASS_Type.getPlainNodeReference(), "staticSelf");
+                    for (int i = 1; i < params.length; i++) {
+                        params[i] = new Parameter(argumentTypes[i-1], "p" + i);
+                    }
+                    MethodNode method = helper.getDeclaredMethod(name, params);
+                    if (method != null) {
+                        return Collections.singletonList(makeDynamic(call, method.getReturnType()));
+                    }
+                }
+            }
+
+            ClassNode dynamic = mce.getNodeMetaData(TraitASTTransformation.DO_DYNAMIC);
             if (dynamic!=null) {
                 return Collections.singletonList(makeDynamic(call, dynamic));
             }
@@ -67,6 +97,14 @@ public class TraitTypeCheckingExtension extends AbstractTypeCheckingExtension {
         return NOTFOUND;
     }
 
+    private boolean isStaticTraitReceiver(final ClassNode receiver, final VariableExpression var) {
+        return Traits.STATIC_THIS_OBJECT.equals(var.getName()) && isClassClassNodeWrappingConcreteType(receiver);
+    }
+
+    private boolean isThisTraitReceiver(final VariableExpression var) {
+        return Traits.THIS_OBJECT.equals(var.getName());
+    }
+
     private List<MethodNode> convertToDynamicCall(MethodCall call, ClassNode receiver, String[] decomposed, ClassNode[] argumentTypes) {
         String traitName = decomposed[0];
         String name = decomposed[1];
diff --git a/src/main/org/codehaus/groovy/transform/trait/Traits.java b/src/main/org/codehaus/groovy/transform/trait/Traits.java
index a16c1c46e4..8fef09b5f9 100644
--- a/src/main/org/codehaus/groovy/transform/trait/Traits.java
+++ b/src/main/org/codehaus/groovy/transform/trait/Traits.java
@@ -64,7 +64,7 @@ public abstract class Traits {
     static final String INIT_METHOD = "$init$";
     static final String STATIC_INIT_METHOD = "$static$init$";
     public static final String THIS_OBJECT = "$self";
-    static final String STATIC_THIS_OBJECT = "$static$self";
+    public static final String STATIC_THIS_OBJECT = "$static$self";
     static final String STATIC_FIELD_PREFIX = "$static";
     static final String FIELD_PREFIX = "$ins";
     static final String PUBLIC_FIELD_PREFIX = "$0";
@@ -98,6 +98,14 @@ public abstract class Traits {
         return owner;
     }
 
+    public static ClassNode findHelper(final ClassNode trait) {
+        return findHelpers(trait).getHelper();
+    }
+
+    public static ClassNode findFieldHelper(final ClassNode trait) {
+        return findHelpers(trait).getFieldHelper();
+    }
+
     static TraitHelpersTuple findHelpers(final ClassNode trait) {
         ClassNode helperClassNode = null;
         ClassNode fieldHelperClassNode = null;
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7322Bug.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7322Bug.groovy
new file mode 100644
index 0000000000..4bd2f2dc4d
--- /dev/null
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7322Bug.groovy
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2003-2015 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+
+
+
+package org.codehaus.groovy.classgen.asm.sc.bugs
+
+import groovy.transform.stc.StaticTypeCheckingTestCase
+import org.codehaus.groovy.classgen.asm.sc.StaticCompilationTestSupport
+
+class Groovy7322Bug extends StaticTypeCheckingTestCase implements StaticCompilationTestSupport {
+    void testCallStaticTraitMethodFromTraitItself() {
+        assertScript '''
+            trait SomeTrait {
+
+                static someMethod() {
+                    List theNames = getNames()
+                    theNames
+                }
+
+                static List getNames() {
+                    ['Jeff', 'Betsy', 'Jake', 'Zack']
+                }
+            }
+
+            class SomeClass implements SomeTrait {}
+            assert SomeClass.someMethod() == ['Jeff', 'Betsy', 'Jake', 'Zack']
+        '''
+    }
+
+    // GROOVY-7191
+    void testCallStaticMethodFromInstanceMethodInTrait() {
+        assertScript '''
+            trait SomeTrait {
+                static int someStaticMethod(){ 1 }
+
+                int someInstanceMethod() {
+                    someStaticMethod()
+                }
+            }
+            class SomeClass implements SomeTrait {}
+            def o = new SomeClass()
+            assert o.someInstanceMethod() == 1
+        '''
+    }
+
+}
