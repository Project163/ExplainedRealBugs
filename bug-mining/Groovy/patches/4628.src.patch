diff --git a/src/main/groovy/org/codehaus/groovy/classgen/genMathModification.groovy b/src/main/groovy/org/codehaus/groovy/classgen/genMathModification.groovy
index cf326ddede..0894bff777 100644
--- a/src/main/groovy/org/codehaus/groovy/classgen/genMathModification.groovy
+++ b/src/main/groovy/org/codehaus/groovy/classgen/genMathModification.groovy
@@ -27,7 +27,7 @@ def ops = [
         'and',
         'xor',
         'intdiv',
-        'mod',
+        'remainder',
         'leftShift',
         'rightShift',
         'rightShiftUnsigned'
@@ -108,7 +108,7 @@ def getMath (left, right) {
                 and : '&',
                 xor : '^',
                 intdiv : '/',
-                mod : '%',
+                remainder : '%',
                 leftShift : '<<',
                 rightShift : '>>',
                 rightShiftUnsigned : '>>>'
@@ -125,7 +125,7 @@ def getMath (left, right) {
             and : '&',
             xor : '^',
             intdiv : '/',
-            mod : '%',
+            remainder : '%',
             leftShift : '<<',
             rightShift : '>>',
             rightShiftUnsigned : '>>>'
diff --git a/src/main/java/org/codehaus/groovy/classgen/asm/BinaryExpressionHelper.java b/src/main/java/org/codehaus/groovy/classgen/asm/BinaryExpressionHelper.java
index 2fce6a46f4..ba1050d71d 100644
--- a/src/main/java/org/codehaus/groovy/classgen/asm/BinaryExpressionHelper.java
+++ b/src/main/java/org/codehaus/groovy/classgen/asm/BinaryExpressionHelper.java
@@ -104,6 +104,8 @@ import static org.codehaus.groovy.syntax.Types.PLUS_EQUAL;
 import static org.codehaus.groovy.syntax.Types.PLUS_PLUS;
 import static org.codehaus.groovy.syntax.Types.POWER;
 import static org.codehaus.groovy.syntax.Types.POWER_EQUAL;
+import static org.codehaus.groovy.syntax.Types.REMAINDER;
+import static org.codehaus.groovy.syntax.Types.REMAINDER_EQUAL;
 import static org.codehaus.groovy.syntax.Types.RIGHT_SHIFT;
 import static org.codehaus.groovy.syntax.Types.RIGHT_SHIFT_EQUAL;
 import static org.codehaus.groovy.syntax.Types.RIGHT_SHIFT_UNSIGNED;
@@ -268,6 +270,14 @@ public class BinaryExpressionHelper {
             evaluateBinaryExpressionWithAssignment("mod", expression);
             break;
 
+        case REMAINDER:
+            evaluateBinaryExpression("remainder", expression);
+            break;
+
+        case REMAINDER_EQUAL:
+            evaluateBinaryExpressionWithAssignment("remainder", expression);
+            break;
+
         case POWER:
             evaluateBinaryExpression("power", expression);
             break;
diff --git a/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java b/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
index c08999c381..0fa2b12177 100644
--- a/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
+++ b/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
@@ -599,7 +599,7 @@ public class StaticTypesCallSiteWriter extends CallSiteWriter {
             } else if ("power".equals(message)) {
                 writePowerCall(receiver, arguments, rType, aType);
                 return true;
-            } else if ("mod".equals(message) || "leftShift".equals(message) || "rightShift".equals(message) || "rightShiftUnsigned".equals(message)
+            } else if ("remainder".equals(message) || "leftShift".equals(message) || "rightShift".equals(message) || "rightShiftUnsigned".equals(message)
                     || "and".equals(message) || "or".equals(message) || "xor".equals(message)) {
                 writeOperatorCall(receiver, arguments, message);
                 return true;
diff --git a/src/main/java/org/codehaus/groovy/control/customizers/SecureASTCustomizer.java b/src/main/java/org/codehaus/groovy/control/customizers/SecureASTCustomizer.java
index ac3dbda4df..7a76491070 100644
--- a/src/main/java/org/codehaus/groovy/control/customizers/SecureASTCustomizer.java
+++ b/src/main/java/org/codehaus/groovy/control/customizers/SecureASTCustomizer.java
@@ -142,7 +142,7 @@ import java.util.Map;
  *                 MINUS,
  *                 MULTIPLY,
  *                 DIVIDE,
- *                 MOD,
+ *                 REMAINDER,
  *                 POWER,
  *                 PLUS_PLUS,
  *                 MINUS_MINUS,
diff --git a/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java b/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
index 4d441e8597..4080a2df55 100644
--- a/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
+++ b/src/main/java/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
@@ -15516,7 +15516,7 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
     }
 
     /**
-     * Performs a division modulus operation.  Called by the '%' operator.
+     * Performs a division modulus operation.
      *
      * @param left  a Number
      * @param right another Number to mod
@@ -15527,6 +15527,18 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
         return NumberMath.mod(left, right);
     }
 
+    /**
+     * Performs a division modulus operation.  Called by the '%' operator.
+     *
+     * @param left  a Number
+     * @param right another Number to find the remainder
+     * @return the remainder result
+     * @since 5.0.0
+     */
+    public static Number remainder(Number left, Number right) {
+        return NumberMath.remainder(left, right);
+    }
+
     /**
      * Negates the number.  Equivalent to the '-' operator when it precedes
      * a single operand, i.e. <code>-10</code>
diff --git a/src/main/java/org/codehaus/groovy/runtime/typehandling/BigDecimalMath.java b/src/main/java/org/codehaus/groovy/runtime/typehandling/BigDecimalMath.java
index 6e3ce620ed..0487e83861 100644
--- a/src/main/java/org/codehaus/groovy/runtime/typehandling/BigDecimalMath.java
+++ b/src/main/java/org/codehaus/groovy/runtime/typehandling/BigDecimalMath.java
@@ -42,7 +42,7 @@ public final class BigDecimalMath extends NumberMath {
     private BigDecimalMath() {}
 
     @Override
-    protected Number absImpl(Number number) {
+    public Number absImpl(Number number) {
         return toBigDecimal(number).abs();
     }
 
@@ -83,17 +83,25 @@ public final class BigDecimalMath extends NumberMath {
     }
 
     @Override
-    protected Number unaryMinusImpl(Number left) {
+    public Number unaryMinusImpl(Number left) {
         return toBigDecimal(left).negate();
     }
 
     @Override
-    protected Number unaryPlusImpl(Number left) {
+    public Number unaryPlusImpl(Number left) {
         return toBigDecimal(left);
     }
 
     @Override
-    protected Number modImpl(Number left, Number right) {
+    public Number remainderImpl(Number left, Number right) {
         return toBigDecimal(left).remainder(toBigDecimal(right));
     }
+
+    @Override
+    public Number modImpl(Number self, Number divisor) {
+        BigDecimal selfDecimal = toBigDecimal(self);
+        BigDecimal divDecimal = toBigDecimal(divisor);
+        BigDecimal remainder = selfDecimal.remainder(divDecimal);
+        return remainder.signum() < 0 ? remainder.add(divDecimal) : remainder;
+    }
 }
diff --git a/src/main/java/org/codehaus/groovy/runtime/typehandling/BigIntegerMath.java b/src/main/java/org/codehaus/groovy/runtime/typehandling/BigIntegerMath.java
index 362944cac6..ea8d4ef151 100644
--- a/src/main/java/org/codehaus/groovy/runtime/typehandling/BigIntegerMath.java
+++ b/src/main/java/org/codehaus/groovy/runtime/typehandling/BigIntegerMath.java
@@ -28,7 +28,7 @@ public final class BigIntegerMath extends NumberMath {
     private BigIntegerMath() {}
 
     @Override
-    protected Number absImpl(Number number) {
+    public Number absImpl(Number number) {
         return toBigInteger(number).abs();
     }
 
@@ -57,52 +57,57 @@ public final class BigIntegerMath extends NumberMath {
     }
 
     @Override
-    protected Number intdivImpl(Number left, Number right) {
+    public Number intdivImpl(Number left, Number right) {
         return toBigInteger(left).divide(toBigInteger(right));
     }
 
     @Override
-    protected Number modImpl(Number left, Number right) {
+    public Number modImpl(Number left, Number right) {
         return toBigInteger(left).mod(toBigInteger(right));
     }
 
     @Override
-    protected Number unaryMinusImpl(Number left) {
+    public Number remainderImpl(Number left, Number right) {
+        return toBigInteger(left).remainder(toBigInteger(right));
+    }
+
+    @Override
+    public Number unaryMinusImpl(Number left) {
         return toBigInteger(left).negate();
     }
 
     @Override
-    protected Number unaryPlusImpl(Number left) {
+    public Number unaryPlusImpl(Number left) {
         return toBigInteger(left);
     }
 
     @Override
-    protected Number bitwiseNegateImpl(Number left) {
+    public Number bitwiseNegateImpl(Number left) {
         return toBigInteger(left).not();
     }
 
     @Override
-    protected Number orImpl(Number left, Number right) {
+    public Number orImpl(Number left, Number right) {
         return toBigInteger(left).or(toBigInteger(right));
     }
 
     @Override
-    protected Number andImpl(Number left, Number right) {
+    public Number andImpl(Number left, Number right) {
         return toBigInteger(left).and(toBigInteger(right));
     }
 
     @Override
-    protected Number xorImpl(Number left, Number right) {
+    public Number xorImpl(Number left, Number right) {
         return toBigInteger(left).xor(toBigInteger(right));
     }
 
     @Override
-    protected Number leftShiftImpl(Number left, Number right) {
+    public Number leftShiftImpl(Number left, Number right) {
         return toBigInteger(left).shiftLeft(right.intValue());
     }
 
     @Override
-    protected Number rightShiftImpl(Number left, Number right) {
+    public Number rightShiftImpl(Number left, Number right) {
         return toBigInteger(left).shiftRight(right.intValue());
     }
 }
diff --git a/src/main/java/org/codehaus/groovy/runtime/typehandling/FloatingPointMath.java b/src/main/java/org/codehaus/groovy/runtime/typehandling/FloatingPointMath.java
index 68ada03da6..aa0d5ab7b8 100644
--- a/src/main/java/org/codehaus/groovy/runtime/typehandling/FloatingPointMath.java
+++ b/src/main/java/org/codehaus/groovy/runtime/typehandling/FloatingPointMath.java
@@ -28,7 +28,7 @@ public final class FloatingPointMath extends NumberMath {
     private FloatingPointMath() {}
 
     @Override
-    protected Number absImpl(Number number) {
+    public Number absImpl(Number number) {
         return Math.abs(number.doubleValue());
     }
 
@@ -58,17 +58,22 @@ public final class FloatingPointMath extends NumberMath {
     }
 
     @Override
-    protected Number modImpl(Number left, Number right) {
+    public Number remainderImpl(Number left, Number right) {
         return left.doubleValue() % right.doubleValue();
     }
 
     @Override
-    protected Number unaryMinusImpl(Number left) {
+    public Number modImpl(Number left, Number right) {
+        return toBigInteger(left).mod(toBigInteger(right)).doubleValue();
+    }
+
+    @Override
+    public Number unaryMinusImpl(Number left) {
         return -left.doubleValue();
     }
 
     @Override
-    protected Number unaryPlusImpl(Number left) {
+    public Number unaryPlusImpl(Number left) {
         return left.doubleValue();
     }
 }
diff --git a/src/main/java/org/codehaus/groovy/runtime/typehandling/IntegerMath.java b/src/main/java/org/codehaus/groovy/runtime/typehandling/IntegerMath.java
index dd69b8cd9a..637ed9557c 100644
--- a/src/main/java/org/codehaus/groovy/runtime/typehandling/IntegerMath.java
+++ b/src/main/java/org/codehaus/groovy/runtime/typehandling/IntegerMath.java
@@ -28,7 +28,7 @@ public final class IntegerMath extends NumberMath {
     private IntegerMath() {}
 
     @Override
-    protected Number absImpl(Number number) {
+    public Number absImpl(Number number) {
         return Math.abs(number.intValue());
     }
 
@@ -60,57 +60,62 @@ public final class IntegerMath extends NumberMath {
     }
 
     @Override
-    protected Number orImpl(Number left, Number right) {
+    public Number orImpl(Number left, Number right) {
         return left.intValue() | right.intValue();
     }
 
     @Override
-    protected Number andImpl(Number left, Number right) {
+    public Number andImpl(Number left, Number right) {
         return left.intValue() & right.intValue();
     }
 
     @Override
-    protected Number xorImpl(Number left, Number right) {
+    public Number xorImpl(Number left, Number right) {
         return left.intValue() ^ right.intValue();
     }
 
     @Override
-    protected Number intdivImpl(Number left, Number right) {
+    public Number intdivImpl(Number left, Number right) {
         return left.intValue() / right.intValue();
     }
 
     @Override
-    protected Number modImpl(Number left, Number right) {
+    public Number modImpl(Number left, Number right) {
+        return toBigInteger(left).mod(toBigInteger(right)).intValue();
+    }
+
+    @Override
+    public Number remainderImpl(Number left, Number right) {
         return left.intValue() % right.intValue();
     }
 
     @Override
-    protected Number unaryMinusImpl(Number left) {
+    public Number unaryMinusImpl(Number left) {
         return -left.intValue();
     }
 
     @Override
-    protected Number unaryPlusImpl(Number left) {
+    public Number unaryPlusImpl(Number left) {
         return left.intValue();
     }
 
     @Override
-    protected Number bitwiseNegateImpl(Number left) {
+    public Number bitwiseNegateImpl(Number left) {
         return ~left.intValue();
     }
 
     @Override
-    protected Number leftShiftImpl(Number left, Number right) {
+    public Number leftShiftImpl(Number left, Number right) {
         return left.intValue() << right.intValue();
     }
 
     @Override
-    protected Number rightShiftImpl(Number left, Number right) {
+    public Number rightShiftImpl(Number left, Number right) {
         return left.intValue() >> right.intValue();
     }
 
     @Override
-    protected Number rightShiftUnsignedImpl(Number left, Number right) {
+    public Number rightShiftUnsignedImpl(Number left, Number right) {
         return left.intValue() >>> right.intValue();
     }
 }
diff --git a/src/main/java/org/codehaus/groovy/runtime/typehandling/LongMath.java b/src/main/java/org/codehaus/groovy/runtime/typehandling/LongMath.java
index f258e29daa..ad5a7369e9 100644
--- a/src/main/java/org/codehaus/groovy/runtime/typehandling/LongMath.java
+++ b/src/main/java/org/codehaus/groovy/runtime/typehandling/LongMath.java
@@ -28,7 +28,7 @@ public final class LongMath extends NumberMath {
     private LongMath() {}
 
     @Override
-    protected Number absImpl(Number number) {
+    public Number absImpl(Number number) {
         return Math.abs(number.longValue());
     }
 
@@ -60,61 +60,66 @@ public final class LongMath extends NumberMath {
     }
 
     @Override
-    protected Number intdivImpl(Number left, Number right) {
+    public Number intdivImpl(Number left, Number right) {
         return left.longValue() / right.longValue();
     }
 
     @Override
-    protected Number modImpl(Number left, Number right) {
+    public Number remainderImpl(Number left, Number right) {
         return left.longValue() % right.longValue();
     }
 
     @Override
-    protected Number unaryMinusImpl(Number left) {
+    public Number modImpl(Number left, Number right) {
+        return toBigInteger(left).mod(toBigInteger(right)).longValue();
+    }
+
+    @Override
+    public Number unaryMinusImpl(Number left) {
         return -left.longValue();
     }
 
     @Override
-    protected Number unaryPlusImpl(Number left) {
+    public Number unaryPlusImpl(Number left) {
         return left.longValue();
     }
 
     @Override
-    protected Number bitwiseNegateImpl(Number left) {
+    public Number bitwiseNegateImpl(Number left) {
         return ~left.longValue();
     }
 
     @Override
-    protected Number orImpl(Number left, Number right) {
+    public Number orImpl(Number left, Number right) {
         return left.longValue() | right.longValue();
     }
 
     @Override
-    protected Number andImpl(Number left, Number right) {
+    public Number andImpl(Number left, Number right) {
         return left.longValue() & right.longValue();
     }
 
     @Override
-    protected Number xorImpl(Number left, Number right) {
+    public Number xorImpl(Number left, Number right) {
         return left.longValue() ^ right.longValue();
     }
 
     @Override
-    protected Number leftShiftImpl(Number left, Number right) {
+    public Number leftShiftImpl(Number left, Number right) {
         return left.longValue() << right.longValue();
     }
 
     @Override
-    protected Number rightShiftImpl(Number left, Number right) {
+    public Number rightShiftImpl(Number left, Number right) {
         return left.longValue() >> right.longValue();
     }
 
     @Override
-    protected Number rightShiftUnsignedImpl(Number left, Number right) {
+    public Number rightShiftUnsignedImpl(Number left, Number right) {
         return left.longValue() >>> right.longValue();
     }
 
-    protected Number bitAndImpl(Number left, Number right) {
+    public Number bitAndImpl(Number left, Number right) {
         return left.longValue() & right.longValue();
     }
 }
diff --git a/src/main/java/org/codehaus/groovy/runtime/typehandling/NumberMath.java b/src/main/java/org/codehaus/groovy/runtime/typehandling/NumberMath.java
index 9ee014dcd6..f6b5f380e0 100644
--- a/src/main/java/org/codehaus/groovy/runtime/typehandling/NumberMath.java
+++ b/src/main/java/org/codehaus/groovy/runtime/typehandling/NumberMath.java
@@ -84,10 +84,15 @@ public abstract class NumberMath {
         return getMath(left, right).intdivImpl(left, right);
     }
 
+    // retain for backwards compatibility
     public static Number mod(Number left, Number right) {
         return getMath(left, right).modImpl(left, right);
     }
 
+    public static Number remainder(Number left, Number right) {
+        return getMath(left, right).remainderImpl(left, right);
+    }
+
     /**
      * For this operation, consider the operands independently.  Throw an exception if the right operand
      * (shift distance) is not an integral type.  For the left operand (shift value) also require an integral
@@ -292,6 +297,10 @@ public abstract class NumberMath {
         throw createUnsupportedException("xor()", left);
     }
 
+    protected Number remainderImpl(Number left, Number right) {
+        throw createUnsupportedException("remainder()", left);
+    }
+
     protected Number modImpl(Number left, Number right) {
         throw createUnsupportedException("mod()", left);
     }
diff --git a/src/main/java/org/codehaus/groovy/runtime/typehandling/NumberMathModificationInfo.java b/src/main/java/org/codehaus/groovy/runtime/typehandling/NumberMathModificationInfo.java
index adc9c76f63..3f11de289f 100644
--- a/src/main/java/org/codehaus/groovy/runtime/typehandling/NumberMathModificationInfo.java
+++ b/src/main/java/org/codehaus/groovy/runtime/typehandling/NumberMathModificationInfo.java
@@ -33,7 +33,7 @@ public class NumberMathModificationInfo {
     private static final HashSet<String> NAMES = new HashSet<String>();
 
     static {
-        Collections.addAll(NAMES, "plus", "minus", "multiply", "div", "compareTo", "or", "and", "xor", "intdiv", "mod", "leftShift", "rightShift", "rightShiftUnsigned");
+        Collections.addAll(NAMES, "plus", "minus", "multiply", "div", "compareTo", "or", "and", "xor", "intdiv", "mod", "remainder", "leftShift", "rightShift", "rightShiftUnsigned");
     }
 
     private NumberMathModificationInfo() { }
@@ -72,6 +72,8 @@ public class NumberMathModificationInfo {
             doCheckNumberOps(klazz, e -> byte_xor = true, e -> short_xor = true, e -> int_xor = true, e -> long_xor = true, e -> float_xor = true, e -> double_xor = true);
         } else if ("intdiv".equals(name)) {
             doCheckNumberOps(klazz, e -> byte_intdiv = true, e -> short_intdiv = true, e -> int_intdiv = true, e -> long_intdiv = true, e -> float_intdiv = true, e -> double_intdiv = true);
+        } else if ("remainder".equals(name)) {
+            doCheckNumberOps(klazz, e -> byte_remainder = true, e -> short_remainder = true, e -> int_remainder = true, e -> long_remainder = true, e -> float_remainder = true, e -> double_remainder = true);
         } else if ("mod".equals(name)) {
             doCheckNumberOps(klazz, e -> byte_mod = true, e -> short_mod = true, e -> int_mod = true, e -> long_mod = true, e -> float_mod = true, e -> double_mod = true);
         } else if ("leftShift".equals(name)) {
@@ -160,6 +162,12 @@ public class NumberMathModificationInfo {
     public boolean long_mod;
     public boolean float_mod;
     public boolean double_mod;
+    public boolean byte_remainder;
+    public boolean short_remainder;
+    public boolean int_remainder;
+    public boolean long_remainder;
+    public boolean float_remainder;
+    public boolean double_remainder;
     public boolean byte_leftShift;
     public boolean short_leftShift;
     public boolean int_leftShift;
@@ -183,7 +191,7 @@ public class NumberMathModificationInfo {
         if (instance.byte_plus) {
             return plusSlow(op1, op2);
         } else {
-            return ((int) op1) + ((int) op2);
+            return op1 + op2;
         }
     }
 
@@ -195,7 +203,7 @@ public class NumberMathModificationInfo {
         if (instance.byte_plus) {
             return plusSlow(op1, op2);
         } else {
-            return ((int) op1) + ((int) op2);
+            return op1 + op2;
         }
     }
 
@@ -207,7 +215,7 @@ public class NumberMathModificationInfo {
         if (instance.byte_plus) {
             return plusSlow(op1, op2);
         } else {
-            return ((int) op1) + op2;
+            return op1 + op2;
         }
     }
 
@@ -219,7 +227,7 @@ public class NumberMathModificationInfo {
         if (instance.byte_plus) {
             return plusSlow(op1, op2);
         } else {
-            return ((long) op1) + op2;
+            return op1 + op2;
         }
     }
 
@@ -2867,6 +2875,198 @@ public class NumberMathModificationInfo {
         return ((Number) InvokerHelper.invokeMethod(op1, "mod", op2)).longValue();
     }
 
+    public static int remainder(byte op1, byte op2) {
+        if (instance.byte_remainder) {
+            return remainderSlow(op1, op2);
+        } else {
+            return ((int) op1) % ((int) op2);
+        }
+    }
+
+    private static int remainderSlow(byte op1, byte op2) {
+        return ((Number) InvokerHelper.invokeMethod(op1, "remainder", op2)).intValue();
+    }
+
+    public static int remainder(byte op1, short op2) {
+        if (instance.byte_remainder) {
+            return remainderSlow(op1, op2);
+        } else {
+            return ((int) op1) % ((int) op2);
+        }
+    }
+
+    private static int remainderSlow(byte op1, short op2) {
+        return ((Number) InvokerHelper.invokeMethod(op1, "remainder", op2)).intValue();
+    }
+
+    public static int remainder(byte op1, int op2) {
+        if (instance.byte_remainder) {
+            return remainderSlow(op1, op2);
+        } else {
+            return ((int) op1) % op2;
+        }
+    }
+
+    private static int remainderSlow(byte op1, int op2) {
+        return ((Number) InvokerHelper.invokeMethod(op1, "remainder", op2)).intValue();
+    }
+
+    public static long remainder(byte op1, long op2) {
+        if (instance.byte_remainder) {
+            return remainderSlow(op1, op2);
+        } else {
+            return ((long) op1) % op2;
+        }
+    }
+
+    private static long remainderSlow(byte op1, long op2) {
+        return ((Number) InvokerHelper.invokeMethod(op1, "remainder", op2)).longValue();
+    }
+
+    public static int remainder(short op1, byte op2) {
+        if (instance.short_remainder) {
+            return remainderSlow(op1, op2);
+        } else {
+            return ((int) op1) % ((int) op2);
+        }
+    }
+
+    private static int remainderSlow(short op1, byte op2) {
+        return ((Number) InvokerHelper.invokeMethod(op1, "remainder", op2)).intValue();
+    }
+
+    public static int remainder(short op1, short op2) {
+        if (instance.short_remainder) {
+            return remainderSlow(op1, op2);
+        } else {
+            return ((int) op1) % ((int) op2);
+        }
+    }
+
+    private static int remainderSlow(short op1, short op2) {
+        return ((Number) InvokerHelper.invokeMethod(op1, "remainder", op2)).intValue();
+    }
+
+    public static int remainder(short op1, int op2) {
+        if (instance.short_remainder) {
+            return remainderSlow(op1, op2);
+        } else {
+            return ((int) op1) % op2;
+        }
+    }
+
+    private static int remainderSlow(short op1, int op2) {
+        return ((Number) InvokerHelper.invokeMethod(op1, "remainder", op2)).intValue();
+    }
+
+    public static long remainder(short op1, long op2) {
+        if (instance.short_remainder) {
+            return remainderSlow(op1, op2);
+        } else {
+            return ((long) op1) % op2;
+        }
+    }
+
+    private static long remainderSlow(short op1, long op2) {
+        return ((Number) InvokerHelper.invokeMethod(op1, "remainder", op2)).longValue();
+    }
+
+    public static int remainder(int op1, byte op2) {
+        if (instance.int_remainder) {
+            return remainderSlow(op1, op2);
+        } else {
+            return op1 % ((int) op2);
+        }
+    }
+
+    private static int remainderSlow(int op1, byte op2) {
+        return ((Number) InvokerHelper.invokeMethod(op1, "remainder", op2)).intValue();
+    }
+
+    public static int remainder(int op1, short op2) {
+        if (instance.int_remainder) {
+            return remainderSlow(op1, op2);
+        } else {
+            return op1 % ((int) op2);
+        }
+    }
+
+    private static int remainderSlow(int op1, short op2) {
+        return ((Number) InvokerHelper.invokeMethod(op1, "remainder", op2)).intValue();
+    }
+
+    public static int remainder(int op1, int op2) {
+        if (instance.int_remainder) {
+            return remainderSlow(op1, op2);
+        } else {
+            return op1 % op2;
+        }
+    }
+
+    private static int remainderSlow(int op1, int op2) {
+        return ((Number) InvokerHelper.invokeMethod(op1, "remainder", op2)).intValue();
+    }
+
+    public static long remainder(int op1, long op2) {
+        if (instance.int_remainder) {
+            return remainderSlow(op1, op2);
+        } else {
+            return ((long) op1) % op2;
+        }
+    }
+
+    private static long remainderSlow(int op1, long op2) {
+        return ((Number) InvokerHelper.invokeMethod(op1, "remainder", op2)).longValue();
+    }
+
+    public static long remainder(long op1, byte op2) {
+        if (instance.long_remainder) {
+            return remainderSlow(op1, op2);
+        } else {
+            return op1 % ((long) op2);
+        }
+    }
+
+    private static long remainderSlow(long op1, byte op2) {
+        return ((Number) InvokerHelper.invokeMethod(op1, "remainder", op2)).longValue();
+    }
+
+    public static long remainder(long op1, short op2) {
+        if (instance.long_remainder) {
+            return remainderSlow(op1, op2);
+        } else {
+            return op1 % ((long) op2);
+        }
+    }
+
+    private static long remainderSlow(long op1, short op2) {
+        return ((Number) InvokerHelper.invokeMethod(op1, "remainder", op2)).longValue();
+    }
+
+    public static long remainder(long op1, int op2) {
+        if (instance.long_remainder) {
+            return remainderSlow(op1, op2);
+        } else {
+            return op1 % ((long) op2);
+        }
+    }
+
+    private static long remainderSlow(long op1, int op2) {
+        return ((Number) InvokerHelper.invokeMethod(op1, "remainder", op2)).longValue();
+    }
+
+    public static long remainder(long op1, long op2) {
+        if (instance.long_remainder) {
+            return remainderSlow(op1, op2);
+        } else {
+            return op1 % op2;
+        }
+    }
+
+    private static long remainderSlow(long op1, long op2) {
+        return ((Number) InvokerHelper.invokeMethod(op1, "remainder", op2)).longValue();
+    }
+
     public static int leftShift(byte op1, byte op2) {
         if (instance.byte_leftShift) {
             return leftShiftSlow(op1, op2);
diff --git a/src/main/java/org/codehaus/groovy/syntax/TokenUtil.java b/src/main/java/org/codehaus/groovy/syntax/TokenUtil.java
index 884ab2d18c..de75acbd42 100644
--- a/src/main/java/org/codehaus/groovy/syntax/TokenUtil.java
+++ b/src/main/java/org/codehaus/groovy/syntax/TokenUtil.java
@@ -67,6 +67,7 @@ public class TokenUtil {
             case Types.BITWISE_OR_EQUAL: return Types.BITWISE_OR;
             case Types.BITWISE_AND_EQUAL: return Types.BITWISE_AND;
             case Types.BITWISE_XOR_EQUAL: return Types.BITWISE_XOR;
+            case Types.REMAINDER_EQUAL: return Types.REMAINDER;
             default: return op;
         }
     }
diff --git a/src/main/java/org/codehaus/groovy/syntax/Types.java b/src/main/java/org/codehaus/groovy/syntax/Types.java
index 12d19f2649..5c7ceb6cba 100644
--- a/src/main/java/org/codehaus/groovy/syntax/Types.java
+++ b/src/main/java/org/codehaus/groovy/syntax/Types.java
@@ -147,6 +147,8 @@ public class Types {
     public static final int BITWISE_AND_EQUAL = 351;   // &=
     public static final int BITWISE_XOR_EQUAL = 352;   // ^=
     public static final int BITWISE_NEGATION = REGEX_PATTERN;    // ~
+    public static final int REMAINDER = 353;   // %
+    public static final int REMAINDER_EQUAL = 354;   // %
 
 
     //
@@ -945,6 +947,7 @@ public class Types {
             case BITWISE_OR_EQUAL:
             case BITWISE_AND_EQUAL:
             case BITWISE_XOR_EQUAL:
+            case REMAINDER_EQUAL:
                 return 5;
 
             case QUESTION:
@@ -995,6 +998,7 @@ public class Types {
             case DIVIDE:
             case INTDIV:
             case MOD:
+            case REMAINDER:
                 return 45;
 
             case NOT:
@@ -1171,7 +1175,7 @@ public class Types {
         addTranslation("*", MULTIPLY);
         addTranslation("/", DIVIDE);
         addTranslation("\\", INTDIV);
-        addTranslation("%", MOD);
+        addTranslation("%", REMAINDER);
 
         addTranslation("**", POWER);
         addTranslation("+=", PLUS_EQUAL);
@@ -1179,7 +1183,7 @@ public class Types {
         addTranslation("*=", MULTIPLY_EQUAL);
         addTranslation("/=", DIVIDE_EQUAL);
         addTranslation("\\=", INTDIV_EQUAL);
-        addTranslation("%=", MOD_EQUAL);
+        addTranslation("%=", REMAINDER_EQUAL);
         addTranslation("**=", POWER_EQUAL);
         addTranslation("?=", ELVIS_EQUAL);
 
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
index fdb2967d71..20484f4dd4 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
@@ -166,6 +166,8 @@ import static org.codehaus.groovy.syntax.Types.PLUS;
 import static org.codehaus.groovy.syntax.Types.PLUS_EQUAL;
 import static org.codehaus.groovy.syntax.Types.POWER;
 import static org.codehaus.groovy.syntax.Types.POWER_EQUAL;
+import static org.codehaus.groovy.syntax.Types.REMAINDER;
+import static org.codehaus.groovy.syntax.Types.REMAINDER_EQUAL;
 import static org.codehaus.groovy.syntax.Types.RIGHT_SHIFT;
 import static org.codehaus.groovy.syntax.Types.RIGHT_SHIFT_EQUAL;
 import static org.codehaus.groovy.syntax.Types.RIGHT_SHIFT_UNSIGNED;
@@ -208,6 +210,7 @@ public abstract class StaticTypeCheckingSupport {
             "and",        BITWISE_AND,
             "xor",        BITWISE_XOR,
             "mod",        MOD,
+            "remainder",  REMAINDER,
             "intdiv",     INTDIV,
             "leftShift",  LEFT_SHIFT,
             "rightShift", RIGHT_SHIFT,
@@ -577,6 +580,10 @@ public abstract class StaticTypeCheckingSupport {
             case MOD_EQUAL:
                 return "mod";
 
+            case REMAINDER:
+            case REMAINDER_EQUAL:
+                return "remainder";
+
             case POWER:
             case POWER_EQUAL:
                 return "power";
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index eddd5a5760..42dd4c3633 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -260,6 +260,8 @@ import static org.codehaus.groovy.syntax.Types.MINUS_MINUS;
 import static org.codehaus.groovy.syntax.Types.MOD;
 import static org.codehaus.groovy.syntax.Types.MOD_EQUAL;
 import static org.codehaus.groovy.syntax.Types.PLUS_PLUS;
+import static org.codehaus.groovy.syntax.Types.REMAINDER;
+import static org.codehaus.groovy.syntax.Types.REMAINDER_EQUAL;
 import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.ArrayList_TYPE;
 import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.Collection_TYPE;
 import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.LinkedHashMap_TYPE;
@@ -4578,7 +4580,8 @@ out:                if (mn.size() != 1) {
                 return getGroupOperationResultType(leftRedirect, rightRedirect);
             }
         }
-        if (isNumberCategory(getWrapper(rightRedirect)) && isNumberCategory(getWrapper(leftRedirect)) && (MOD == op || MOD_EQUAL == op)) {
+        if (isNumberCategory(getWrapper(rightRedirect)) && isNumberCategory(getWrapper(leftRedirect)) &&
+            (REMAINDER == op || REMAINDER_EQUAL == op || MOD == op || MOD_EQUAL == op)) {
             return leftRedirect;
         }
         return null;
diff --git a/src/main/java/org/codehaus/groovy/vmplugin/v8/IndyMath.java b/src/main/java/org/codehaus/groovy/vmplugin/v8/IndyMath.java
index 476dbd6307..d3157e5c1f 100644
--- a/src/main/java/org/codehaus/groovy/vmplugin/v8/IndyMath.java
+++ b/src/main/java/org/codehaus/groovy/vmplugin/v8/IndyMath.java
@@ -27,6 +27,7 @@ import java.math.BigDecimal;
 import java.util.HashMap;
 import java.util.Map;
 
+import static org.codehaus.groovy.runtime.DefaultGroovyMethods.toBigInteger;
 import static org.codehaus.groovy.vmplugin.v8.IndyInterface.LOOKUP;
 import static org.codehaus.groovy.vmplugin.v8.TypeHelper.isBigDecCategory;
 import static org.codehaus.groovy.vmplugin.v8.TypeHelper.isDoubleCategory;
@@ -39,7 +40,7 @@ import static org.codehaus.groovy.vmplugin.v8.TypeHelper.replaceWithMoreSpecific
  * meta method and call site caching system. The goal is to avoid boxing, thus
  * use primitive types for parameters and return types where possible.
  * WARNING: This class is for internal use only. Do not use it outside the
- * org.codehaus.groovy.vmplugin.v7 package of groovy-core.
+ * org.codehaus.groovy.vmplugin.v8 package of groovy-core.
  */
 public class IndyMath {
 
@@ -90,6 +91,7 @@ public class IndyMath {
 
             keys = new MethodType[]{IIV, LLV};
             values = new MethodType[]{III, LLL};
+            makeMapEntry("remainder", keys, values);
             makeMapEntry("mod", keys, values);
             makeMapEntry("or", keys, values);
             makeMapEntry("xor", keys, values);
@@ -165,10 +167,14 @@ public class IndyMath {
         return a * b;
     }
 
-    public static int mod(int a, int b) {
+    public static int remainder(int a, int b) {
         return a % b;
     }
 
+    public static int mod(int a, int b) {
+        return toBigInteger(a).mod(toBigInteger(b)).intValue();
+    }
+
     public static int or(int a, int b) {
         return a | b;
     }
@@ -202,10 +208,14 @@ public class IndyMath {
         return a * b;
     }
 
-    public static long mod(long a, long b) {
+    public static long remainder(long a, long b) {
         return a % b;
     }
 
+    public static long mod(long a, long b) {
+        return toBigInteger(a).mod(toBigInteger(b)).longValue();
+    }
+
     public static long or(long a, long b) {
         return a | b;
     }
diff --git a/src/spec/test/CustomizersTest.groovy b/src/spec/test/CustomizersTest.groovy
index ce355a9e1d..166dfe9e7f 100644
--- a/src/spec/test/CustomizersTest.groovy
+++ b/src/spec/test/CustomizersTest.groovy
@@ -118,7 +118,7 @@ class CustomizersTest extends GroovyTestCase {
                     MINUS,
                     MULTIPLY,
                     DIVIDE,
-                    MOD,
+                    REMAINDER,
                     POWER,
                     PLUS_PLUS,
                     MINUS_MINUS,
diff --git a/src/test/groovy/ModuloTest.groovy b/src/test/groovy/ModuloTest.groovy
index 383019786a..2151efaa19 100644
--- a/src/test/groovy/ModuloTest.groovy
+++ b/src/test/groovy/ModuloTest.groovy
@@ -21,24 +21,27 @@ package groovy
 import groovy.test.GroovyTestCase
 
 class ModuloTest extends GroovyTestCase {
-  int modulo = 100
+    int modulo = 100
 
-  void testModuloLesser() {
-    for (i in 0..modulo-1) {
-      assert (i%modulo)==i
+    void testModuloLesser() {
+        for (i in 0..modulo - 1) {
+            assert i % modulo == i
+            assert i.mod(modulo) == i
+        }
     }
-  }
 
-  void testModuloEqual() {
-    for (i in 0..modulo) {
-      assert ((i*modulo) % modulo)==0
+    void testModuloEqual() {
+        for (i in 0..modulo) {
+            assert (i * modulo) % modulo == 0
+            assert (i * modulo).mod(modulo) == 0
+        }
     }
-  }
 
-  void testModuloBigger() {
-    for (i in 0..modulo-1) {
-      assert ((i*modulo+i) % modulo)==i
+    void testModuloBigger() {
+        for (i in 0..modulo - 1) {
+            assert (i * modulo + i) % modulo == i
+            assert (i * modulo + i).mod(modulo) == i
+        }
     }
-  }
 
 }
diff --git a/src/test/groovy/operator/BigDecimalOperatorsTest.groovy b/src/test/groovy/operator/BigDecimalOperatorsTest.groovy
index 0d75eb6c09..ce9be8ac7d 100644
--- a/src/test/groovy/operator/BigDecimalOperatorsTest.groovy
+++ b/src/test/groovy/operator/BigDecimalOperatorsTest.groovy
@@ -99,6 +99,19 @@ class BigDecimalOperatorsTest extends GroovyTestCase {
     }
 
     void testMod() {
+        x = 100.0.mod(3)
+
+        assert x == 1
+
+        y = 5.5
+        y = y.mod(2.0)
+        assert y == 1.5
+        y = -5.5
+        y = y.mod(2.0)
+        assert y == 0.5
+    }
+
+    void testRemainder() {
         x = 100.0 % 3
 
         assert x == 1
@@ -106,6 +119,9 @@ class BigDecimalOperatorsTest extends GroovyTestCase {
         y = 5.5
         y %= 2.0
         assert y == 1.5
+        y = -5.5
+        y %= 2.0
+        assert y == -1.5
     }
 
     BigDecimal echoX ( BigDecimal x, BigDecimal y) {x}
diff --git a/src/test/groovy/operator/BigIntegerOperationsTest.groovy b/src/test/groovy/operator/BigIntegerOperationsTest.groovy
index e54a7b47a9..0b5d6d2114 100644
--- a/src/test/groovy/operator/BigIntegerOperationsTest.groovy
+++ b/src/test/groovy/operator/BigIntegerOperationsTest.groovy
@@ -74,12 +74,27 @@ class BigIntegerOperationsTest extends GroovyTestCase {
     }
 
     void testMod() {
+        x = 100G.mod(3)
+        assert x == 1G
+
+        y = 11G
+        y = y.mod(3)
+        assert y == 2G
+        y = -11G
+        y = y.mod(3)
+        assert y == 1G
+    }
+
+    void testRemainder() {
         x = 100G % 3
         assert x == 1G
 
         y = 11G
         y %= 3
         assert y == 2G
+        y = -11G
+        y %= 3
+        assert y == -2G
     }
 
     void testAsOperatorPrecisionLoss() {
diff --git a/src/test/groovy/operator/DoubleOperationsTest.groovy b/src/test/groovy/operator/DoubleOperationsTest.groovy
index cc9fac3bf9..71199550a6 100644
--- a/src/test/groovy/operator/DoubleOperationsTest.groovy
+++ b/src/test/groovy/operator/DoubleOperationsTest.groovy
@@ -78,12 +78,27 @@ class DoubleOperationsTest extends GroovyTestCase {
     }
 
     void testMod() {
+        x = 100d.mod(3)
+        assert x == 1d
+
+        y = 11d
+        y = y.mod(3d)
+        assert y == 2d
+        y = -11d
+        y = y.mod(3d)
+        assert y == 1d
+    }
+
+    void testRemainder() {
         x = 100d % 3
         assert x == 1d
 
         y = 11d
         y %= 3d
         assert y == 2d
+        y = -11d
+        y %= 3d
+        assert y == -2d
     }
 
     void testMethodNotFound() {
diff --git a/src/test/groovy/operator/IntegerOperatorsTest.groovy b/src/test/groovy/operator/IntegerOperatorsTest.groovy
index c129381907..fd3910be07 100644
--- a/src/test/groovy/operator/IntegerOperatorsTest.groovy
+++ b/src/test/groovy/operator/IntegerOperatorsTest.groovy
@@ -145,6 +145,19 @@ class IntegerOperatorsTest extends GroovyTestCase {
     }
 
     void testMod() {
+        x = 100.mod(3)
+
+        assert x == 1
+
+        y = 11
+        y = y.mod(3)
+        assert y == 2
+        y = -11
+        y = y.mod(3)
+        assert y == 1
+    }
+
+    void testRemainder() {
         x = 100 % 3
 
         assert x == 1
@@ -152,6 +165,9 @@ class IntegerOperatorsTest extends GroovyTestCase {
         y = 11
         y %= 3
         assert y == 2
+        y = -11
+        y %= 3
+        assert y == -2
     }
 
     void testAnd() {
diff --git a/src/test/groovy/transform/stc/BugsSTCTest.groovy b/src/test/groovy/transform/stc/BugsSTCTest.groovy
index a50dfde53a..329948ed9b 100644
--- a/src/test/groovy/transform/stc/BugsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/BugsSTCTest.groovy
@@ -32,7 +32,7 @@ class BugsSTCTest extends StaticTypeCheckingTestCase {
             def bar() { foo { it / 2 } }
         ''', 'Cannot find matching method java.lang.Object#div(int)'
     }
-    void testShouldNotAllowDivBynUntypedVariable() {
+    void testShouldNotAllowDivByUntypedVariable() {
         shouldFailWithMessages '''
             def foo(Closure cls) {}
             def bar() { foo { 2 / it } }
@@ -41,22 +41,34 @@ class BugsSTCTest extends StaticTypeCheckingTestCase {
     void testShouldNotAllowModOnUntypedVariable() {
         shouldFailWithMessages '''
             def foo(Closure cls) {}
-            def bar() { foo { it % 2 } }
+            def bar() { foo { it.mod(2) } }
         ''', 'Cannot find matching method java.lang.Object#mod(int)'
     }
-    void testShouldNotAllowModBynUntypedVariable() {
+    void testShouldNotAllowModByUntypedVariable() {
         shouldFailWithMessages '''
             def foo(Closure cls) {}
-            def bar() { foo { 2 % it } }
+            def bar() { foo { 2.mod(it) } }
         ''', 'Cannot find matching method int#mod(java.lang.Object)'
     }
+    void testShouldNotAllowRemainderOnUntypedVariable() {
+        shouldFailWithMessages '''
+            def foo(Closure cls) {}
+            def bar() { foo { it % 2 } }
+        ''', 'Cannot find matching method java.lang.Object#remainder(int)'
+    }
+    void testShouldNotAllowRemainderByUntypedVariable() {
+        shouldFailWithMessages '''
+            def foo(Closure cls) {}
+            def bar() { foo { 2 % it } }
+        ''', 'Cannot find matching method int#remainder(java.lang.Object)'
+    }
     void testShouldNotAllowMulOnUntypedVariable() {
         shouldFailWithMessages '''
             def foo(Closure cls) {}
             def bar() { foo { it * 2 } }
         ''', 'Cannot find matching method java.lang.Object#multiply(int)'
     }
-    void testShouldNotAllowMulBynUntypedVariable() {
+    void testShouldNotAllowMulByUntypedVariable() {
         shouldFailWithMessages '''
             def foo(Closure cls) {}
             def bar() { foo { 2 * it } }
diff --git a/src/test/groovy/transform/stc/MiscSTCTest.groovy b/src/test/groovy/transform/stc/MiscSTCTest.groovy
index fe77518b9f..b497ec2239 100644
--- a/src/test/groovy/transform/stc/MiscSTCTest.groovy
+++ b/src/test/groovy/transform/stc/MiscSTCTest.groovy
@@ -493,6 +493,7 @@ class MiscSTCTest extends StaticTypeCheckingTestCase {
                 assert new Long(7L.leftShift(3)) == 56
                 assert new Long(7L.rightShift(1)) == 3
                 assert new Long(7L.mod(3)) == 1
+                assert new Long(7L.remainder(3)) == 1
                 assert new Long(7L.intdiv(3)) == 2
                 assert new Integer((-8).intdiv(-4)) == 2
                 Integer x = 9
