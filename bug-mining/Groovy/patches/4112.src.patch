diff --git a/src/main/java/org/codehaus/groovy/ast/GenericsType.java b/src/main/java/org/codehaus/groovy/ast/GenericsType.java
index 5ae6766cc5..2abde5fea6 100644
--- a/src/main/java/org/codehaus/groovy/ast/GenericsType.java
+++ b/src/main/java/org/codehaus/groovy/ast/GenericsType.java
@@ -475,15 +475,15 @@ public class GenericsType extends ASTNode {
     }
 
     /**
-     * Represents GenericsType name
-     * TODO In order to distinguish GenericsType with same name(See GROOVY-8409), we should add a property to keep the declaring class.
-     *
-     * fixing GROOVY-8409 steps:
-     * 1) change the signature of constructor GenericsTypeName to `GenericsTypeName(String name, ClassNode declaringClass)`
-     * 2) try to fix all compilation errors(if `GenericsType` has declaringClass property, the step would be a bit easy to fix...)
-     * 3) run all tests to see whether the change breaks anything
-     * 4) if all tests pass, congratulations! but if some tests are broken, try to debug and find why...
-     *
+     * Represents {@link GenericsType} name.
+     * <p>
+     * TODO: In order to distinguish GenericsType with same name, we should add a property to keep the declaring class.
+     * <ol>
+     * <li> change the signature of constructor GenericsTypeName to `GenericsTypeName(String name, ClassNode declaringClass)`
+     * <li> try to fix all compilation errors(if `GenericsType` has declaringClass property, the step would be a bit easy to fix...)
+     * <li> run all tests to see whether the change breaks anything
+     * <li> if all tests pass, congratulations! but if some tests are broken, try to debug and find why...
+     * </ol>
      * We should find a way to set declaring class for `GenericsType` first, it can be completed at the resolving phase.
      */
     public static class GenericsTypeName {
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
index 658ae95d4a..fa24e5a9d8 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
@@ -1802,22 +1802,8 @@ public abstract class StaticTypeCheckingSupport {
         return type.getGenericsTypes();
     }
 
-    static Map<GenericsTypeName, GenericsType> applyGenericsContextToParameterClass(final Map<GenericsTypeName, GenericsType> spec, final ClassNode parameterUsage) {
-        GenericsType[] gts = parameterUsage.getGenericsTypes();
-        if (gts == null) return Collections.emptyMap();
-
-        ClassNode newType = parameterUsage.redirect().getPlainNodeReference();
-        newType.setGenericsTypes(applyGenericsContext(spec, gts));
-
-        Map<GenericsTypeName, GenericsType> newSpec = GenericsUtils.extractPlaceholders(newType);
-        newSpec.replaceAll((xx, gt) -> // GROOVY-9762, GROOVY-9803: reduce "? super T" to "T"
-            Optional.ofNullable(gt.getLowerBound()).map(GenericsType::new).orElse(gt)
-        );
-        return newSpec;
-    }
-
-    private static GenericsType[] applyGenericsContext(final Map<GenericsTypeName, GenericsType> spec, final GenericsType[] gts) {
-        if (gts == null) return null;
+    static GenericsType[] applyGenericsContext(final Map<GenericsTypeName, GenericsType> spec, final GenericsType[] gts) {
+        if (gts == null || spec == null || spec.isEmpty()) return gts;
 
         int n = gts.length;
         if (n == 0) return gts;
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index d3d5159adf..67e00939f0 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -136,10 +136,9 @@ import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.BiPredicate;
 import java.util.function.Function;
-import java.util.function.Supplier;
 import java.util.stream.IntStream;
 
-import static java.util.stream.Collectors.toList;
+import static java.util.stream.Collectors.*;
 import static org.apache.groovy.util.BeanUtils.capitalize;
 import static org.apache.groovy.util.BeanUtils.decapitalize;
 import static org.codehaus.groovy.ast.ClassHelper.AUTOCLOSEABLE_TYPE;
@@ -241,7 +240,6 @@ import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.addMet
 import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.allParametersAndArgumentsMatchWithDefaultParams;
 import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.applyGenericsConnections;
 import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.applyGenericsContext;
-import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.applyGenericsContextToParameterClass;
 import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.boundUnboundedWildcards;
 import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.checkCompatibleAssignmentTypes;
 import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.checkPossibleLossOfPrecision;
@@ -276,7 +274,6 @@ import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.isPowe
 import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.isShiftOperation;
 import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.isTraitSelf;
 import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.isUsingGenericsOrIsArrayUsingGenerics;
-import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.isUsingUncheckedGenerics;
 import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.isVargs;
 import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.isWildcardLeftHandSide;
 import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.lastArgMatchesVarg;
@@ -1785,17 +1782,6 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         return member;
     }
 
-    private void storeWithResolve(ClassNode type, final ClassNode receiver, final ClassNode declaringClass, final boolean isStatic, final Expression expressionToStoreOn) {
-        if (GenericsUtils.hasUnresolvedGenerics(type)) {
-            type = resolveGenericsWithContext(resolvePlaceHoldersFromDeclaration(receiver, declaringClass, null, isStatic), type);
-        }
-        if (expressionToStoreOn instanceof PropertyExpression) {
-            storeInferredTypeForPropertyExpression((PropertyExpression) expressionToStoreOn, type);
-        } else {
-            storeType(expressionToStoreOn, type);
-        }
-    }
-
     private boolean storeField(final FieldNode field, final PropertyExpression expressionToStoreOn, final ClassNode receiver, final ClassCodeVisitorSupport visitor, final String delegationData, final boolean lhsOfAssignment) {
         if (visitor != null) visitor.visitField(field);
         checkOrMarkPrivateAccess(expressionToStoreOn, field, lhsOfAssignment);
@@ -1822,11 +1808,27 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         return true;
     }
 
-    protected void storeInferredTypeForPropertyExpression(final PropertyExpression pexp, final ClassNode flatInferredType) {
+    private void storeWithResolve(ClassNode type, final ClassNode receiver, final ClassNode declaringClass, final boolean isStatic, final Expression expressionToStoreOn) {
+        if (GenericsUtils.hasUnresolvedGenerics(type)) {
+            type = resolveGenericsWithContext(resolvePlaceHoldersFromDeclaration(receiver, declaringClass, null, isStatic), type);
+        }
+        if (expressionToStoreOn instanceof PropertyExpression) {
+            storeInferredTypeForPropertyExpression((PropertyExpression) expressionToStoreOn, type);
+        } else {
+            storeType(expressionToStoreOn, type);
+        }
+    }
+
+    private ClassNode resolveGenericsWithContext(final Map<GenericsTypeName, GenericsType> resolvedPlaceholders, final ClassNode currentType) {
+        Map<GenericsTypeName, GenericsType> placeholdersFromContext = extractGenericsParameterMapOfThis(typeCheckingContext);
+        return resolveClassNodeGenerics(resolvedPlaceholders, placeholdersFromContext, currentType);
+    }
+
+    private void storeInferredTypeForPropertyExpression(final PropertyExpression pexp, final ClassNode type) {
         if (pexp.isSpreadSafe()) {
-            storeType(pexp, extension.buildListType(flatInferredType));
+            storeType(pexp, extension.buildListType(type));
         } else {
-            storeType(pexp, flatInferredType);
+            storeType(pexp, type);
         }
     }
 
@@ -5196,121 +5198,125 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         return mapType;
     }
 
-    private static class ExtensionMethodDeclaringClass {
-    }
-
     /**
-     * If a method call returns a parameterized type, then we can perform additional inference on the
-     * return type, so that the type gets actual type parameters. For example, the method
-     * Arrays.asList(T...) is generified with type T which can be deduced from actual type
-     * arguments.
+     * If a method call returns a parameterized type, then perform additional
+     * inference on the return type, so that the type gets actual type arguments.
+     * For example, the method {@code Arrays.asList(T...)} is parameterized with
+     * {@code T}, which can be deduced type arguments or call arguments.
      *
-     * @param method    the method node
-     * @param arguments the method call arguments
-     * @return parameterized, infered, class node
+     * @param method            the method node
+     * @param arguments         the method call arguments
+     * @param receiver          the object expression type
      */
     protected ClassNode inferReturnTypeGenerics(final ClassNode receiver, final MethodNode method, final Expression arguments) {
         return inferReturnTypeGenerics(receiver, method, arguments, null);
     }
 
     /**
-     * If a method call returns a parameterized type, then we can perform additional inference on the
-     * return type, so that the type gets actual type parameters. For example, the method
-     * Arrays.asList(T...) is generified with type T which can be deduced from actual type
-     * arguments.
+     * If a method call returns a parameterized type, then perform additional
+     * inference on the return type, so that the type gets actual type arguments.
+     * For example, the method {@code Arrays.asList(T...)} is parameterized with
+     * {@code T}, which can be deduced type arguments or call arguments.
      *
      * @param method            the method node
      * @param arguments         the method call arguments
-     * @param explicitTypeHints explicit type hints as found for example in Collections.&lt;String&gt;emptyList()
-     * @return parameterized, infered, class node
+     * @param receiver          the object expression type
+     * @param explicitTypeHints type arguments (optional), for example {@code Collections.<String>emptyList()}
      */
     protected ClassNode inferReturnTypeGenerics(final ClassNode receiver, final MethodNode method, final Expression arguments, final GenericsType[] explicitTypeHints) {
         ClassNode returnType = method instanceof ConstructorNode ? method.getDeclaringClass() : method.getReturnType();
-        if (getGenericsWithoutArray(returnType) == null) {
+        if (!GenericsUtils.hasUnresolvedGenerics(returnType)) {
+            // GROOVY-7538: replace "Type<?>" with "Type<? extends/super X>" for any "Type<T extends/super X>"
+            if (getGenericsWithoutArray(returnType) != null) returnType = boundUnboundedWildcards(returnType);
+
             return returnType;
         }
+
         if (method instanceof ExtensionMethodNode) {
-            // check if the placeholder corresponds to the placeholder of the first parameter
-            ExtensionMethodNode emn = (ExtensionMethodNode) method;
-            MethodNode dgm = emn.getExtensionMethodNode();
-            ArgumentListExpression args = new ArgumentListExpression();
-            VariableExpression vexp = varX("$self", receiver);
-            args.addExpression(vexp);
-            vexp.setNodeMetaData(ExtensionMethodDeclaringClass.class, emn.getDeclaringClass());
-            if (arguments instanceof ArgumentListExpression) {
-                for (Expression argument : (ArgumentListExpression) arguments) {
-                    args.addExpression(argument);
-                }
-            } else {
-                args.addExpression(arguments);
-            }
-            return inferReturnTypeGenerics(receiver, dgm, args, explicitTypeHints);
+            ArgumentListExpression args = getExtensionArguments(receiver, method, arguments);
+            MethodNode extension = ((ExtensionMethodNode) method).getExtensionMethodNode();
+            return inferReturnTypeGenerics(receiver, extension, args, explicitTypeHints);
         }
 
-        Map<GenericsTypeName, GenericsType> resolvedPlaceholders = resolvePlaceHoldersFromDeclaration(receiver, getDeclaringClass(method, arguments), method, method.isStatic());
-        resolvePlaceholdersFromExplicitTypeHints(method, explicitTypeHints, resolvedPlaceholders);
-        if (resolvedPlaceholders.isEmpty()) {
-            if (receiver.getGenericsTypes() == null && receiver.redirect().getGenericsTypes() != null && GenericsUtils.hasUnresolvedGenerics(returnType)) {
-                return returnType.getPlainNodeReference(); // do not return Stream<E> for List#stream()
-            }
-            return boundUnboundedWildcards(returnType);
-        }
+        Map<GenericsTypeName, GenericsType> context = method.isStatic() || method instanceof ConstructorNode
+                                            ? null : extractPlaceHolders(null, receiver, getDeclaringClass(method, arguments));
+        GenericsType[] methodGenericTypes = method instanceof ConstructorNode ? method.getDeclaringClass().getGenericsTypes() : method.getGenericsTypes();
 
-        // resolve type parameters from method arguments
-        List<Expression> expressions = InvocationWriter.makeArgumentList(arguments).getExpressions();
-        Parameter[] parameters = method.getParameters();
-        boolean isVargs = isVargs(parameters);
-        int nArguments = expressions.size();
-        int nParams = parameters.length;
+        // 1) resolve type parameters of method
 
-        if (isVargs ? nArguments >= nParams - 1 : nArguments == nParams) {
-            for (int i = 0; i < nArguments; i += 1) {
-                if (isNullConstant(expressions.get(i)))
-                    continue; // GROOVY-9984: skip null
-                ClassNode paramType = parameters[Math.min(i, nParams - 1)].getType();
-                ClassNode argumentType = getDeclaredOrInferredType(expressions.get(i));
+        if (methodGenericTypes != null) {
+            Map<GenericsTypeName, GenericsType> resolvedPlaceholders = new HashMap<>();
+            for (GenericsType gt : applyGenericsContext(context, methodGenericTypes)) resolvedPlaceholders.put(new GenericsTypeName(gt.getName()), gt);
+            applyGenericsConnections(extractGenericsConnectionsFromArguments(methodGenericTypes, method.getParameters(), arguments, explicitTypeHints), resolvedPlaceholders);
 
-                if (isUsingGenericsOrIsArrayUsingGenerics(paramType)) {
-                    // if supplying array param with multiple arguments or single non-array argument, infer using element type
-                    if (isVargs && (i >= nParams || (i == nParams - 1 && (nArguments > nParams || !argumentType.isArray())))) {
-                        paramType = paramType.getComponentType();
-                    }
+            returnType = applyGenericsContext(resolvedPlaceholders, returnType);
+        }
 
-                    if (argumentType.isDerivedFrom(CLOSURE_TYPE)) {
-                        MethodNode sam = findSAM(paramType);
-                        if (sam != null) { // implicit closure coercion in action!
-                            argumentType = !paramType.isUsingGenerics() ? paramType
-                                    : convertClosureTypeToSAMType(expressions.get(i), argumentType, sam, paramType,
-                                            applyGenericsContextToParameterClass(resolvedPlaceholders, paramType));
-                        }
-                    }
+        // 2) resolve type parameters of method's enclosing context
 
-                    Map<GenericsTypeName, GenericsType> connections = new HashMap<>();
-                    extractGenericsConnections(connections, wrapTypeIfNecessary(argumentType), paramType);
-                    extractGenericsConnectionsForSuperClassAndInterfaces(resolvedPlaceholders, connections);
+        if (context != null) {
+            returnType = applyGenericsContext(context, returnType);
 
-                    applyGenericsConnections(connections, resolvedPlaceholders);
-                }
+            if (receiver.getGenericsTypes() == null && receiver.redirect().getGenericsTypes() != null && GenericsUtils.hasUnresolvedGenerics(returnType)) {
+                returnType = returnType.getPlainNodeReference(); // GROOVY-10049: do not return "Stream<E>" for raw type "List#stream()"
             }
         }
 
-        // GROOVY-9970: resolve from enclosing context after arguments, in case a type parameter name is reused
-        applyGenericsConnections(extractGenericsParameterMapOfThis(typeCheckingContext), resolvedPlaceholders);
+        // 3) resolve bounds of type parameters from calling context
 
-        return applyGenericsContext(resolvedPlaceholders, returnType);
+        returnType = applyGenericsContext(extractGenericsParameterMapOfThis(typeCheckingContext), returnType);
+
+        return returnType;
     }
 
-    private static void resolvePlaceholdersFromExplicitTypeHints(final MethodNode method, final GenericsType[] explicitTypeHints, final Map<GenericsTypeName, GenericsType> resolvedPlaceholders) {
-        if (explicitTypeHints != null) {
-            GenericsType[] methodGenericTypes = method.getGenericsTypes();
-            if (methodGenericTypes != null && methodGenericTypes.length == explicitTypeHints.length) {
-                for (int i = 0, n = methodGenericTypes.length; i < n; i += 1) {
-                    GenericsType methodGenericType = methodGenericTypes[i];
-                    GenericsType explicitTypeHint = explicitTypeHints[i];
-                    resolvedPlaceholders.put(new GenericsTypeName(methodGenericType.getName()), explicitTypeHint);
+    /**
+     * Resolves type parameters declared by method from type or call arguments.
+     */
+    private Map<GenericsTypeName, GenericsType> extractGenericsConnectionsFromArguments(final GenericsType[] methodGenericTypes, final Parameter[] parameters, final Expression arguments, final GenericsType[] explicitTypeHints) {
+        Map<GenericsTypeName, GenericsType> resolvedPlaceholders = new HashMap<>();
+
+        if (explicitTypeHints != null) { // resolve type parameters from type arguments
+            int n = methodGenericTypes.length;
+            if (n == explicitTypeHints.length) {
+                for (int i = 0; i < n; i += 1) {
+                    resolvedPlaceholders.put(new GenericsTypeName(methodGenericTypes[i].getName()), explicitTypeHints[i]);
+                }
+            }
+        } else if (parameters.length > 0) { // resolve type parameters from call arguments
+            List<Expression> expressions = InvocationWriter.makeArgumentList(arguments).getExpressions();
+            boolean isVargs = isVargs(parameters);
+            int nArguments = expressions.size();
+            int nParams = parameters.length;
+
+            if (isVargs ? nArguments >= nParams - 1 : nArguments == nParams) {
+                for (int i = 0; i < nArguments; i += 1) {
+                    if (isNullConstant(expressions.get(i)))
+                        continue; // GROOVY-9984: skip null
+                    ClassNode paramType = parameters[Math.min(i, nParams - 1)].getType();
+                    ClassNode argumentType = getDeclaredOrInferredType(expressions.get(i));
+
+                    if (isUsingGenericsOrIsArrayUsingGenerics(paramType)) {
+                        // if supplying array param with multiple arguments or single non-array argument, infer using element type
+                        if (isVargs && (i >= nParams || (i == nParams - 1 && (nArguments > nParams || !argumentType.isArray())))) {
+                            paramType = paramType.getComponentType();
+                        }
+
+                        Map<GenericsTypeName, GenericsType> connections = new HashMap<>();
+                        extractGenericsConnections(connections, wrapTypeIfNecessary(argumentType), paramType);
+                        connections.forEach((gtn, gt) -> resolvedPlaceholders.merge(gtn, gt, (gt1, gt2) -> {
+                            return gt2; // TODO
+                        }));
+                    }
                 }
             }
+
+            // in case of "<T, U extends Type<T>>" we can learn about "T" from resolved "U"
+            Map<GenericsTypeName, GenericsType> connections = Arrays.stream(methodGenericTypes)
+                    .collect(toMap(gt -> new GenericsTypeName(gt.getName()), Function.identity()));
+            extractGenericsConnectionsForSuperClassAndInterfaces(connections, resolvedPlaceholders);
         }
+
+        return resolvedPlaceholders;
     }
 
     /**
@@ -5351,7 +5357,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             // connect E:T from source to E:Type from target
             for (GenericsType placeholder : aNode.getGenericsTypes()) {
                 for (Map.Entry<GenericsTypeName, GenericsType> e : source.entrySet()) {
-                    if (e.getValue() == placeholder) {
+                    if (e.getValue().getName().equals(placeholder.getName())) {
                         Optional.ofNullable(target.get(e.getKey()))
                             // skip "f(g())" for "f(T<String>)" and "<U extends Number> U g()"
                             .filter(gt -> isAssignableTo(gt.getType(), placeholder.getType()))
@@ -5405,136 +5411,6 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         }
     }
 
-    private static MethodNode chooseMethod(final MethodPointerExpression source, final Supplier<ClassNode[]> samSignature) {
-        List<MethodNode> options = source.getNodeMetaData(MethodNode.class);
-        if (options == null || options.isEmpty()) {
-            return null;
-        }
-
-        ClassNode[] paramTypes = samSignature.get();
-        return options.stream().filter((MethodNode option) -> {
-            ClassNode[] types = collateMethodReferenceParameterTypes(source, option);
-            final int n = types.length;
-            if (n != paramTypes.length) {
-                return false;
-            }
-            for (int i = 0; i < n; i += 1) {
-                // param type represents incoming argument type
-                if (!isAssignableTo(paramTypes[i], types[i])) {
-                    return false;
-                }
-            }
-            return true;
-        }).findFirst().orElse(null); // TODO: order matches by param distance
-    }
-
-    private static ClassNode[] collateMethodReferenceParameterTypes(final MethodPointerExpression source, final MethodNode target) {
-        Parameter[] params;
-
-        if (target instanceof ExtensionMethodNode && !((ExtensionMethodNode) target).isStaticExtension()) {
-            params = ((ExtensionMethodNode) target).getExtensionMethodNode().getParameters();
-        } else if (!target.isStatic() && source.getExpression() instanceof ClassExpression) {
-            ClassNode thisType = ((ClassExpression) source.getExpression()).getType();
-            // there is an implicit parameter for "String::length"
-            int n = target.getParameters().length;
-            params = new Parameter[n + 1];
-            params[0] = new Parameter(thisType, "");
-            System.arraycopy(target.getParameters(), 0, params, 1, n);
-        } else {
-            params = target.getParameters();
-        }
-
-        return extractTypesFromParameters(params);
-    }
-
-    /**
-     * Converts a closure type to the appropriate SAM type, which is used to
-     * infer return type generics.
-     *
-     * @param expression closure, lambda, pointer or reference
-     * @param closureType the inferred type of {@code expression}
-     * @return {@code samType} augmented by argument expression information
-     */
-    private static ClassNode convertClosureTypeToSAMType(final Expression expression, final ClassNode closureType, final MethodNode sam, final ClassNode samType, final Map<GenericsTypeName, GenericsType> placeholders) {
-        // use the generics information from Closure to further specify the type
-        if (closureType.isUsingGenerics()) {
-            ClassNode closureReturnType = closureType.getGenericsTypes()[0].getType();
-
-            Parameter[] parameters = sam.getParameters();
-            if (parameters.length > 0 && expression instanceof MethodPointerExpression
-                    && isUsingUncheckedGenerics(closureReturnType)) { // needs resolve
-                MethodPointerExpression mp = (MethodPointerExpression) expression;
-                MethodNode mn = chooseMethod(mp, () ->
-                    applyGenericsContext(placeholders, extractTypesFromParameters(parameters))
-                );
-                if (mn != null) {
-                    ClassNode[] pTypes = collateMethodReferenceParameterTypes(mp, mn);
-                    Map<GenericsTypeName, GenericsType> connections = new HashMap<>();
-                    for (int i = 0, n = parameters.length; i < n; i += 1) {
-                        // SAM parameters should align one-for-one with the referenced method's parameters
-                        extractGenericsConnections(connections, parameters[i].getOriginType(), pTypes[i]);
-                    }
-                    // convert the method reference's generics into the SAM's generics domain
-                    closureReturnType = applyGenericsContext(connections, closureReturnType);
-                    // apply known generics connections to the placeholders of the return type
-                    closureReturnType = applyGenericsContext(placeholders, closureReturnType);
-                }
-            }
-
-            // the SAM's return type exactly corresponds to the inferred closure return type
-            extractGenericsConnections(placeholders, closureReturnType, sam.getReturnType());
-
-            // repeat the same for each parameter given in the ClosureExpression
-            if (parameters.length > 0 && expression instanceof ClosureExpression) {
-                List<ClassNode[]> genericsToConnect = new ArrayList<>();
-                Parameter[] closureParams = ((ClosureExpression) expression).getParameters();
-                ClassNode[] closureParamTypes = expression.getNodeMetaData(CLOSURE_ARGUMENTS);
-                if (closureParamTypes == null) closureParamTypes = extractTypesFromParameters(closureParams);
-
-                for (int i = 0, n = parameters.length; i < n; i += 1) {
-                    Parameter parameter = parameters[i];
-                    if (parameter.getOriginType().isUsingGenerics() && closureParamTypes.length > i) {
-                        genericsToConnect.add(new ClassNode[]{closureParamTypes[i], parameter.getOriginType()});
-                    }
-                }
-                for (ClassNode[] classNodes : genericsToConnect) {
-                    ClassNode found = classNodes[0];
-                    ClassNode expected = classNodes[1];
-                    if (!isAssignableTo(found, expected)) {
-                        // probably facing a type mismatch
-                        continue;
-                    }
-                    ClassNode generifiedType = GenericsUtils.parameterizeType(found, expected);
-                    while (expected.isArray()) {
-                        expected = expected.getComponentType();
-                        generifiedType = generifiedType.getComponentType();
-                    }
-                    if (expected.isGenericsPlaceHolder()) {
-                        placeholders.put(new GenericsTypeName(expected.getGenericsTypes()[0].getName()), new GenericsType(generifiedType));
-                    } else {
-                        GenericsType[] expectedGenericsTypes = expected.getGenericsTypes();
-                        GenericsType[] foundGenericsTypes = generifiedType.getGenericsTypes();
-
-                        for (int i = 0, n = expectedGenericsTypes.length; i < n; i += 1) {
-                            GenericsType type = expectedGenericsTypes[i];
-                            if (type.isPlaceholder()) {
-                                String name = type.getName();
-                                placeholders.put(new GenericsTypeName(name), foundGenericsTypes[i]);
-                            }
-                        }
-                    }
-                }
-            }
-        }
-
-        return applyGenericsContext(placeholders, samType.redirect());
-    }
-
-    private ClassNode resolveGenericsWithContext(final Map<GenericsTypeName, GenericsType> resolvedPlaceholders, final ClassNode currentType) {
-        Map<GenericsTypeName, GenericsType> placeholdersFromContext = extractGenericsParameterMapOfThis(typeCheckingContext);
-        return resolveClassNodeGenerics(resolvedPlaceholders, placeholdersFromContext, currentType);
-    }
-
     private ClassNode getDeclaredOrInferredType(final Expression expression) {
         ClassNode declaredOrInferred;
         // in case of "T t = new ExtendsOrImplementsT()", return T for the expression type
@@ -5562,12 +5438,37 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         return declaringClass;
     }
 
+    private static class ExtensionMethodDeclaringClass {
+    }
+
+    private static ArgumentListExpression getExtensionArguments(final ClassNode receiver, final MethodNode method, final Expression arguments) {
+        VariableExpression self = varX("$self", receiver); // implicit first argument
+        self.putNodeMetaData(ExtensionMethodDeclaringClass.class, method.getDeclaringClass());
+
+        ArgumentListExpression args = new ArgumentListExpression();
+        args.addExpression(self);
+        if (arguments instanceof TupleExpression) {
+            for (Expression argument : (TupleExpression) arguments) {
+                args.addExpression(argument);
+            }
+        } else {
+            args.addExpression(arguments);
+        }
+        return args;
+    }
+
+    private static boolean isGenericsPlaceHolderOrArrayOf(ClassNode cn) {
+        while (cn.isArray()) cn = cn.getComponentType();
+        return cn.isGenericsPlaceHolder();
+    }
+
     private static Map<GenericsTypeName, GenericsType> resolvePlaceHoldersFromDeclaration(final ClassNode receiver, final ClassNode declaration, final MethodNode method, final boolean isStaticTarget) {
         Map<GenericsTypeName, GenericsType> resolvedPlaceholders;
-        if (isStaticTarget && CLASS_Type.equals(receiver) &&
-                receiver.isUsingGenerics() &&
-                receiver.getGenericsTypes().length > 0 &&
-                !OBJECT_TYPE.equals(receiver.getGenericsTypes()[0].getType())) {
+        if (isStaticTarget
+                && CLASS_Type.equals(receiver)
+                && receiver.getGenericsTypes() != null
+                && receiver.getGenericsTypes().length > 0
+                && !OBJECT_TYPE.equals(receiver.getGenericsTypes()[0].getType())) {
             return resolvePlaceHoldersFromDeclaration(receiver.getGenericsTypes()[0].getType(), declaration, method, isStaticTarget);
         } else {
             resolvedPlaceholders = extractPlaceHolders(method, receiver, declaration);
@@ -5575,11 +5476,6 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         return resolvedPlaceholders;
     }
 
-    private static boolean isGenericsPlaceHolderOrArrayOf(final ClassNode cn) {
-        if (cn.isArray()) return isGenericsPlaceHolderOrArrayOf(cn.getComponentType());
-        return cn.isGenericsPlaceHolder();
-    }
-
     private static Map<GenericsTypeName, GenericsType> extractPlaceHolders(final MethodNode method, ClassNode receiver, final ClassNode declaringClass) {
         if (declaringClass.equals(OBJECT_TYPE)) {
             Map<GenericsTypeName, GenericsType> resolvedPlaceholders = new HashMap<>();
diff --git a/src/test/groovy/bugs/Groovy8409Bug.groovy b/src/test/groovy/bugs/Groovy8409Bug.groovy
deleted file mode 100644
index d122ae5bc9..0000000000
--- a/src/test/groovy/bugs/Groovy8409Bug.groovy
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one
- *  or more contributor license agreements.  See the NOTICE file
- *  distributed with this work for additional information
- *  regarding copyright ownership.  The ASF licenses this file
- *  to you under the Apache License, Version 2.0 (the
- *  "License"); you may not use this file except in compliance
- *  with the License.  You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing,
- *  software distributed under the License is distributed on an
- *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- *  KIND, either express or implied.  See the License for the
- *  specific language governing permissions and limitations
- *  under the License.
- */
-package groovy.bugs
-
-import gls.CompilableTestSupport
-import groovy.test.NotYetImplemented
-
-class Groovy8409Bug extends CompilableTestSupport {
-    @NotYetImplemented
-    void test() {
-        assertScript '''
-        import groovy.transform.CompileStatic
-        import java.util.function.BiFunction
-
-        @CompileStatic
-        class Groovy8409Bug {
-        
-            static <T> T actionWrapperT(BiFunction<Date, URL, T> action) {
-                T result = action.apply(new Date(), new URL('http://www.example.com'))
-                // do something else here
-                return result
-            }
-        
-            static void main(String[] args) {
-                Groovy8409Bug t = actionWrapperT { Date date, URL url -> new Groovy8409Bug() }
-            }
-        
-        }
-        '''
-    }
-
-    void testWorkaround() {
-        assertScript '''
-        import groovy.transform.CompileStatic
-        import java.util.function.BiFunction
-
-        @CompileStatic
-        class Groovy8409Bug {
-        
-            static <X> X actionWrapperT(BiFunction<Date, URL, X> action) {
-                X result = action.apply(new Date(), new URL('http://www.example.com'))
-                // do something else here
-                return result
-            }
-        
-            static void main(String[] args) {
-                Groovy8409Bug t = actionWrapperT { Date date, URL url -> new Groovy8409Bug() }
-            }
-        
-        }
-        '''
-    }
-}
diff --git a/src/test/groovy/transform/stc/GenericsSTCTest.groovy b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
index d8a738beb7..740972e0af 100644
--- a/src/test/groovy/transform/stc/GenericsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
@@ -419,6 +419,23 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
         '''
     }
 
+    // GROOVY-8409
+    void testReturnTypeInferenceWithMethodGenerics14() {
+        ['R', 'S', 'T', 'U'].each { t -> // BiFunction uses R, T and U
+            assertScript """
+                def <$t> $t applyFunction(java.util.function.BiFunction<Date, URL, $t> action) {
+                    $t result = action.apply(new Date(), new URL('http://www.example.com'))
+                    return result
+                }
+
+                // GroovyCastException: Cannot cast object 'foo' with class 'java.lang.String' to class 'java.util.Date'
+                java.util.function.BiFunction<Date, URL, String> func = { Date d, URL u -> 'foo' }
+                def result = applyFunction(func)
+                assert result == 'foo'
+            """
+        }
+    }
+
     void testDiamondInferrenceFromConstructor1() {
         assertScript '''
             class Foo<U> {
@@ -1394,7 +1411,7 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
         }
     }
 
-    // GROOVY-9803
+    @NotYetImplemented // GROOVY-9803
     void testShouldUseMethodGenericType8() {
         assertScript '''
             def opt = Optional.of(42)
diff --git a/subprojects/groovy-ginq/src/main/groovy/org/apache/groovy/ginq/provider/collection/GinqAstWalker.groovy b/subprojects/groovy-ginq/src/main/groovy/org/apache/groovy/ginq/provider/collection/GinqAstWalker.groovy
index 01dbde88f0..53ad277731 100644
--- a/subprojects/groovy-ginq/src/main/groovy/org/apache/groovy/ginq/provider/collection/GinqAstWalker.groovy
+++ b/subprojects/groovy-ginq/src/main/groovy/org/apache/groovy/ginq/provider/collection/GinqAstWalker.groovy
@@ -52,7 +52,6 @@ import org.codehaus.groovy.ast.Parameter
 import org.codehaus.groovy.ast.expr.ArgumentListExpression
 import org.codehaus.groovy.ast.expr.BinaryExpression
 import org.codehaus.groovy.ast.expr.CastExpression
-import org.codehaus.groovy.ast.expr.ClassExpression
 import org.codehaus.groovy.ast.expr.ConstantExpression
 import org.codehaus.groovy.ast.expr.ConstructorCallExpression
 import org.codehaus.groovy.ast.expr.DeclarationExpression
@@ -83,6 +82,8 @@ import static org.codehaus.groovy.ast.ClassHelper.makeWithoutCaching
 import static org.codehaus.groovy.ast.tools.GeneralUtils.args
 import static org.codehaus.groovy.ast.tools.GeneralUtils.block
 import static org.codehaus.groovy.ast.tools.GeneralUtils.callX
+import static org.codehaus.groovy.ast.tools.GeneralUtils.classX
+import static org.codehaus.groovy.ast.tools.GeneralUtils.constX
 import static org.codehaus.groovy.ast.tools.GeneralUtils.ctorX
 import static org.codehaus.groovy.ast.tools.GeneralUtils.declS
 import static org.codehaus.groovy.ast.tools.GeneralUtils.declX
@@ -179,34 +180,34 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
         boolean isRootGinqExpression = ginqExpression === ginqExpression.getNodeMetaData(GinqAstBuilder.ROOT_GINQ_EXPRESSION)
         boolean useWindowFunction = isRootGinqExpression && isUseWindowFunction(ginqExpression)
         if (useWindowFunction) {
-            statementList << stmt(callX(QUERYABLE_HELPER_TYPE, 'setVar', args(new ConstantExpression(USE_WINDOW_FUNCTION), new ConstantExpression(TRUE_STR))))
+            statementList << stmt(callX(QUERYABLE_HELPER_TYPE, 'setVar', args(constX(USE_WINDOW_FUNCTION), constX(TRUE_STR))))
         }
 
         boolean parallelEnabled = isRootGinqExpression && isParallel()
         if (parallelEnabled) {
-            statementList << stmt(callX(QUERYABLE_HELPER_TYPE, 'setVar', args(new ConstantExpression(PARALLEL), new ConstantExpression(TRUE_STR))))
+            statementList << stmt(callX(QUERYABLE_HELPER_TYPE, 'setVar', args(constX(PARALLEL), constX(TRUE_STR))))
         }
 
         statementList << declS(
                 localVarX(metaDataMapName).tap {it.modifiers |= Opcodes.ACC_FINAL},
                 callX(MAPS_TYPE, "of", args(
-                        new ConstantExpression(MD_ALIAS_NAME_LIST), aliasNameListExpression,
-                        new ConstantExpression(MD_GROUP_NAME_LIST), groupNameListExpression,
-                        new ConstantExpression(MD_SELECT_NAME_LIST), selectNameListExpression
+                        constX(MD_ALIAS_NAME_LIST), aliasNameListExpression,
+                        constX(MD_GROUP_NAME_LIST), groupNameListExpression,
+                        constX(MD_SELECT_NAME_LIST), selectNameListExpression
                 ))
         )
         if (rowNumberUsed) {
-            statementList << declS(localVarX(rowNumberName), ctorX(ATOMIC_LONG_TYPE, new ConstantExpression(-1L)))
+            statementList << declS(localVarX(rowNumberName), ctorX(ATOMIC_LONG_TYPE, constX(-1L)))
         }
 
         final resultName = "__r${System.nanoTime()}"
         statementList << declS(localVarX(resultName).tap {it.modifiers |= Opcodes.ACC_FINAL}, selectMethodCallExpression)
 
         if (parallelEnabled) {
-            statementList << stmt(callX(QUERYABLE_HELPER_TYPE, 'removeVar', args(new ConstantExpression(PARALLEL))))
+            statementList << stmt(callX(QUERYABLE_HELPER_TYPE, 'removeVar', args(constX(PARALLEL))))
         }
         if (useWindowFunction) {
-            statementList << stmt(callX(QUERYABLE_HELPER_TYPE, 'removeVar', args(new ConstantExpression(USE_WINDOW_FUNCTION))))
+            statementList << stmt(callX(QUERYABLE_HELPER_TYPE, 'removeVar', args(constX(USE_WINDOW_FUNCTION))))
         }
         statementList << returnS(varX(resultName))
 
@@ -336,13 +337,13 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
 
     @Override
     MethodCallExpression visitOnExpression(OnExpression onExpression) {
-        return null // do nothing
+        // do nothing
     }
 
     private MethodCallExpression constructFromMethodCallExpression(Expression dataSourceExpr) {
         callX(
-                makeQueryableCollectionClassExpression(),
-                "from",
+                classX(QUERYABLE_TYPE),
+                'from',
                 args(
                         dataSourceExpr instanceof AbstractGinqExpression
                                 ? this.visit((AbstractGinqExpression) dataSourceExpr)
@@ -601,16 +602,13 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
         Expression ordersExpr = orderExpression.ordersExpr
 
         List<Expression> orderCtorCallExpressions = constructOrderCtorCallExpressions(ordersExpr, dataSourceExpression)
-
         def orderMethodCallExpression = callX(orderMethodCallReceiver, "orderBy", args(orderCtorCallExpressions))
-        orderMethodCallExpression.setSourcePosition(orderExpression)
-
+        orderMethodCallExpression.sourcePosition = orderExpression
         return orderMethodCallExpression
     }
 
     private List<Expression> constructOrderCtorCallExpressions(Expression ordersExpr, DataSourceExpression dataSourceExpression) {
-        List<Expression> argumentExpressionList = ((ArgumentListExpression) ordersExpr).getExpressions()
-        List<Expression> orderCtorCallExpressions = argumentExpressionList.stream().map(e -> {
+        return ((ArgumentListExpression) ordersExpr).expressions.collect { e ->
             Expression target = e
             boolean asc = true
             boolean nullsLast = true
@@ -664,9 +662,8 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
 
             LambdaExpression lambdaExpression = constructLambdaExpression(dataSourceExpression, target)
 
-            return ctorX(ORDER_TYPE, args(lambdaExpression, new ConstantExpression(asc), new ConstantExpression(nullsLast)))
-        }).collect(Collectors.toList())
-        return orderCtorCallExpressions
+            (Expression) ctorX(ORDER_TYPE, args(lambdaExpression, constX(asc), constX(nullsLast)))
+        }
     }
 
     @Override
@@ -734,7 +731,7 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
 
                 if (expression instanceof AbstractGinqExpression) {
                     return callX(
-                            new ClassExpression(QUERYABLE_HELPER_TYPE), "singleValue",
+                            classX(QUERYABLE_HELPER_TYPE), "singleValue",
                             GinqAstWalker.this.visit((AbstractGinqExpression) expression)
                     )
                 }
@@ -835,7 +832,7 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
 
     @Override
     Expression visitShutdownExpression(ShutdownExpression shutdownExpression) {
-        return callX(new ClassExpression(makeCached(QueryableHelper)), 'shutdown', new ConstantExpression(shutdownExpression.mode))
+        return callX(classX(makeCached(QueryableHelper)), 'shutdown', constX(shutdownExpression.mode))
     }
 
     private MethodCallExpression getRowNumberMethodCall() {
@@ -946,12 +943,12 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
         })
 
         callX(
-                callX(new ClassExpression(WINDOW_DEFINITION_TYPE), 'of', args(argumentExpressionList)),
+                callX(classX(WINDOW_DEFINITION_TYPE), 'of', args(argumentExpressionList)),
                 'setId',
                 callX(TUPLE_TYPE, 'tuple', args(
-                        new ConstantExpression(partitionByClauseText),
-                        new ConstantExpression(orderByClauseText),
-                        new ConstantExpression(argumentListExpression.text)
+                        constX(partitionByClauseText),
+                        constX(orderByClauseText),
+                        constX(argumentListExpression.text)
                 ))
         )
     }
@@ -1049,11 +1046,11 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
 
         if (e instanceof CastExpression) {
             elementExpression = e.expression
-            nameExpression = new ConstantExpression(e.type.text)
+            nameExpression = constX(e.type.text)
         } else if (e instanceof PropertyExpression) {
             if (e.property instanceof ConstantExpression) {
                 elementExpression = e
-                nameExpression = new ConstantExpression(e.property.text)
+                nameExpression = constX(e.property.text)
             } else if (e.property instanceof GStringExpression) {
                 elementExpression = e
                 nameExpression = e.property
@@ -1061,7 +1058,7 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
         }
 
         if (null == nameExpression) {
-            nameExpression = new ConstantExpression(e.text)
+            nameExpression = constX(e.text)
         }
 
         return tuple(elementExpression, nameExpression)
@@ -1128,11 +1125,11 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
     }
 
     private MethodCallExpression getMetaDataMethodCall(String key) {
-        callX(varX(metaDataMapName), "get", new ConstantExpression(key))
+        callX(varX(metaDataMapName), 'get', constX(key))
     }
 
     private MethodCallExpression putMetaDataMethodCall(String key, Expression value) {
-        callX(varX(metaDataMapName), "put", args(new ConstantExpression(key), value))
+        callX(varX(metaDataMapName), 'put', args(constX(key), value))
     }
 
     private ListExpression getSelectNameListExpression() {
@@ -1144,7 +1141,7 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
     }
 
     private List<String> getGroupNameList() {
-        return groupNameListExpression.getExpressions().stream().map(e -> e.text).collect(Collectors.toList())
+        return groupNameListExpression.expressions*.text
     }
 
     private ListExpression getAliasNameListExpression() {
@@ -1152,13 +1149,11 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
     }
 
     private List<String> getAliasNameList() {
-        return aliasNameListExpression.getExpressions().stream().map(e -> e.text).collect(Collectors.toList())
+        return aliasExpressionList*.text
     }
 
     private List<Expression> getAliasExpressionList() {
-        dataSourceAliasList.stream()
-                .map(e -> new ConstantExpression(e))
-                .collect(Collectors.toList())
+        return dataSourceAliasList.collect { (Expression) constX(it) }
     }
 
     private List<String> getDataSourceAliasList() {
@@ -1261,7 +1256,7 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
                         if (FUNCTION_AGG == visitingAggregateFunctionStack.peek() && _G == expression.text) {
                             transformedExpression =
                                     callX(
-                                        new ClassExpression(QUERYABLE_HELPER_TYPE),
+                                        classX(QUERYABLE_HELPER_TYPE),
                                             "navigate",
                                         args(new VariableExpression(lambdaParamName), getMetaDataMethodCall(MD_ALIAS_NAME_LIST))
                                     )
@@ -1405,7 +1400,7 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
                                         : args(lambdaX(stmt(transformedLambdCode)))
 
             transformedLambdCode = callX(
-                    new ClassExpression(QUERYABLE_HELPER_TYPE),
+                    classX(QUERYABLE_HELPER_TYPE),
                     "supplyAsync",
                     argumentListExpression
             )
@@ -1516,10 +1511,6 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
         )
     }
 
-    private static ClassExpression makeQueryableCollectionClassExpression() {
-        new ClassExpression(QUERYABLE_TYPE)
-    }
-
     @Override
     SourceUnit getSourceUnit() {
         sourceUnit
