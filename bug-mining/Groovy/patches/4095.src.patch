diff --git a/src/main/java/org/codehaus/groovy/ast/ClassHelper.java b/src/main/java/org/codehaus/groovy/ast/ClassHelper.java
index f674e543b1..ae74efe4bf 100644
--- a/src/main/java/org/codehaus/groovy/ast/ClassHelper.java
+++ b/src/main/java/org/codehaus/groovy/ast/ClassHelper.java
@@ -499,30 +499,25 @@ public class ClassHelper {
      * @param goalClazz the goal class
      * @return the next super class or interface
      */
-    public static ClassNode getNextSuperClass(ClassNode clazz, ClassNode goalClazz) {
+    public static ClassNode getNextSuperClass(final ClassNode clazz, final ClassNode goalClazz) {
         if (clazz.isArray()) {
             if (!goalClazz.isArray()) return null;
+
             ClassNode cn = getNextSuperClass(clazz.getComponentType(), goalClazz.getComponentType());
             if (cn != null) cn = cn.makeArray();
             return cn;
         }
 
-        if (!goalClazz.isInterface()) {
-            if (clazz.isInterface()) {
-                if (OBJECT_TYPE.equals(clazz)) return null;
-                return OBJECT_TYPE;
-            } else {
-                return clazz.getUnresolvedSuperClass();
+        if (goalClazz.isInterface()) {
+            for (ClassNode face : clazz.getUnresolvedInterfaces()) {
+                if (StaticTypeCheckingSupport.implementsInterfaceOrIsSubclassOf(face, goalClazz)) {
+                    return face;
+                }
             }
+        } else if (clazz.isInterface()) {
+            return OBJECT_TYPE;
         }
 
-        ClassNode[] interfaces = clazz.getUnresolvedInterfaces();
-        for (ClassNode anInterface : interfaces) {
-            if (StaticTypeCheckingSupport.implementsInterfaceOrIsSubclassOf(anInterface, goalClazz)) {
-                return anInterface;
-            }
-        }
-        //none of the interfaces here match, so continue with super class
         return clazz.getUnresolvedSuperClass();
     }
 }
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 8119ffb35a..8278c5a47c 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -2908,11 +2908,12 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         // first we try to get as much information about the declaration class through the receiver
         Map<GenericsTypeName, GenericsType> targetMethodConnections = new HashMap<>();
         for (ClassNode face : receiver.getAllInterfaces()) {
-            extractGenericsConnections(targetMethodConnections, getCorrectedClassNode(receiver, face, true), face.redirect());
-        }
-        if (!receiver.isInterface()) {
-            extractGenericsConnections(targetMethodConnections, receiver, receiver.redirect());
+            if (face != receiver) {
+                ClassNode type = getCorrectedClassNode(receiver, face, true);
+                extractGenericsConnections(targetMethodConnections, type, face.redirect());
+            }
         }
+        extractGenericsConnections(targetMethodConnections, receiver, receiver.redirect());
 
         // then we use the method with the SAM-type parameter to get more information about the declaration
         Parameter[] parametersOfMethodContainingSAM = methodWithSAMParameter.getParameters();
@@ -5259,9 +5260,13 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             }
             return inferReturnTypeGenerics(receiver, dgm, args, explicitTypeHints);
         }
+
         Map<GenericsTypeName, GenericsType> resolvedPlaceholders = resolvePlaceHoldersFromDeclaration(receiver, getDeclaringClass(method, arguments), method, method.isStatic());
         resolvePlaceholdersFromExplicitTypeHints(method, explicitTypeHints, resolvedPlaceholders);
         if (resolvedPlaceholders.isEmpty()) {
+            if (receiver.getGenericsTypes() == null && receiver.redirect().getGenericsTypes() != null && GenericsUtils.hasUnresolvedGenerics(returnType)) {
+                return returnType.getPlainNodeReference(); // do not return Stream<E> for List#stream()
+            }
             return boundUnboundedWildcards(returnType);
         }
 
@@ -5624,8 +5629,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
                 if (resolvedPlaceholders != null) {
                     // merge maps
-                    Set<Map.Entry<GenericsTypeName, GenericsType>> entries = currentPlaceHolders.entrySet();
-                    for (Map.Entry<GenericsTypeName, GenericsType> entry : entries) {
+                    for (Map.Entry<GenericsTypeName, GenericsType> entry : currentPlaceHolders.entrySet()) {
                         GenericsType gt = entry.getValue();
                         if (!gt.isPlaceholder()) continue;
                         GenericsType referenced = resolvedPlaceholders.get(new GenericsTypeName(gt.getName()));
@@ -5638,11 +5642,15 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 // we are done if we are now in the declaring class
                 if (!continueLoop) break;
 
+                boolean isRawType = (current.getGenericsTypes() == null
+                        && current.redirect().getGenericsTypes() != null);
                 current = getNextSuperClass(current, declaringClass);
                 if (current == null && declaringClass.equals(CLASS_Type)) {
                     // this can happen if the receiver is Class<Foo>, then
                     // the actual receiver is Foo and declaringClass is Class
                     current = declaringClass;
+                } else if (isRawType) {
+                    current = current.getPlainNodeReference();
                 }
             }
         }
diff --git a/src/test/groovy/transform/stc/GenericsSTCTest.groovy b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
index 39460f0e52..9abd9cc1f3 100644
--- a/src/test/groovy/transform/stc/GenericsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
@@ -236,6 +236,40 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
         '''
     }
 
+    // GROOVY-10049
+    void testReturnTypeInferenceWithMethodGenerics9() {
+        assertScript '''
+            def <X> Set<X> f(Class<X> x) {
+                Collections.singleton(x.newInstance(42))
+            }
+            def <Y extends Number> List<Y> g(Class<Y> y) {
+                f(y).stream().filter(n -> n.intValue() > 0).toList()
+            }
+
+            def result = g(Integer)
+            assert result == [ 42 ]
+        '''
+
+        assertScript '''
+            def <T> String test(Iterable<T> iterable) {
+                Iterator<T> it = iterable.iterator()
+                if (it.hasNext()) {
+                    List<String[]> table = []
+                    it.forEachRemaining(r -> {
+                        if (r instanceof List) {
+                            String[] cells = ((List) r).stream().map(c -> c?.toString())
+                            table.add(cells)
+                        }
+                    })
+                    return table
+                }
+            }
+
+            String result = test([ ['x'], ['y'], [null] ])
+            assert result == '[[x], [y], [null]]'
+        '''
+    }
+
     void testDiamondInferrenceFromConstructor1() {
         assertScript '''
             class Foo<U> {
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/BugsStaticCompileTest.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/BugsStaticCompileTest.groovy
index e567be920a..b8c41d6fcc 100644
--- a/src/test/org/codehaus/groovy/classgen/asm/sc/BugsStaticCompileTest.groovy
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/BugsStaticCompileTest.groovy
@@ -1158,7 +1158,7 @@ assert it.next() == 1G
             @ASTTest(phase=INSTRUCTION_SELECTION, value={
                 def ift = node.getNodeMetaData(INFERRED_TYPE)
                 assert ift == SET_TYPE
-                assert ift.isUsingGenerics()
+                assert ift.genericsTypes != null
                 assert ift.genericsTypes[0].type == STRING_TYPE
             })
             def set = map.keySet()
@@ -1170,8 +1170,7 @@ assert it.next() == 1G
             @ASTTest(phase=INSTRUCTION_SELECTION, value={
                 def ift = node.getNodeMetaData(INFERRED_TYPE)
                 assert ift == SET_TYPE
-                assert ift.isUsingGenerics()
-                assert ift.genericsTypes[0].name == 'java.lang.Object'
+                assert ift.genericsTypes == null
             })
             def set = map.keySet()
             def key = set[0]
