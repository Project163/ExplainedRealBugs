diff --git a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
index fca8aa23d2..7dd59e5fc8 100644
--- a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
+++ b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
@@ -141,34 +141,43 @@ public class StaticTypesCallSiteWriter extends CallSiteWriter implements Opcodes
         if (makeGetPrivateFieldWithBridgeMethod(receiver, receiverType, methodName, safe, implicitThis)) return;
 
         // GROOVY-5580, it is still possible that we're calling a superinterface property
+        String getterName = "get" + MetaClassHelper.capitalize(methodName);
         if (receiverType.isInterface()) {
             Set<ClassNode> allInterfaces = receiverType.getAllInterfaces();
+            MethodNode getterMethod = null;
             for (ClassNode anInterface : allInterfaces) {
-                MethodNode getterMethod = anInterface.getGetterMethod("get" + MetaClassHelper.capitalize(methodName));
-                if (getterMethod!=null) {
-                    MethodCallExpression call = new MethodCallExpression(
-                            receiver,
-                            "get"+MetaClassHelper.capitalize(methodName),
-                            ArgumentListExpression.EMPTY_ARGUMENTS
-                    );
-                    call.setMethodTarget(getterMethod);
-                    call.setImplicitThis(false);
-                    call.setSourcePosition(receiver);
-                    call.visit(controller.getAcg());
-                    return;
-                }
+                getterMethod = anInterface.getGetterMethod(getterName);
+                if (getterMethod!=null) break;
+            }
+            // GROOVY-5585
+            if (getterMethod==null) {
+                getterMethod = ClassHelper.OBJECT_TYPE.getGetterMethod(getterName);
+            }
+
+            if (getterMethod!=null) {
+                MethodCallExpression call = new MethodCallExpression(
+                        receiver,
+                        getterName,
+                        ArgumentListExpression.EMPTY_ARGUMENTS
+                );
+                call.setMethodTarget(getterMethod);
+                call.setImplicitThis(false);
+                call.setSourcePosition(receiver);
+                call.visit(controller.getAcg());
+                return;
             }
+
         }
 
         // GROOVY-5568, we would be facing a DGM call, but instead of foo.getText(), have foo.text
-        List<MethodNode> methods = findDGMMethodsByNameAndArguments(receiverType, "get"+MetaClassHelper.capitalize(methodName), ClassNode.EMPTY_ARRAY);
+        List<MethodNode> methods = findDGMMethodsByNameAndArguments(receiverType, getterName, ClassNode.EMPTY_ARRAY);
         if (!methods.isEmpty()) {
             List<MethodNode> methodNodes = chooseBestMethod(receiverType, methods, ClassNode.EMPTY_ARRAY);
             if (methodNodes.size()==1) {
                 MethodNode getter = methodNodes.get(0);
                 MethodCallExpression call = new MethodCallExpression(
                         receiver,
-                        "get"+MetaClassHelper.capitalize(methodName),
+                        getterName,
                         ArgumentListExpression.EMPTY_ARGUMENTS
                 );
                 call.setMethodTarget(getter);
diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 49108163df..a140d681d4 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -760,6 +760,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         if (propertyName == null) return false;
         String capName = MetaClassHelper.capitalize(propertyName);
         boolean isAttributeExpression = pexp instanceof AttributeExpression;
+        if (clazz.isInterface()) tests.add(OBJECT_TYPE);
         for (ClassNode testClass : tests) {
             boolean isStaticProperty = pexp.getObjectExpression() instanceof ClassExpression && implementsInterfaceOrIsSubclassOf(testClass, pexp.getObjectExpression().getType());
             // maps and lists have special handling for property expressions
diff --git a/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy b/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy
index 6ba19234f6..260fdfa268 100644
--- a/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy
+++ b/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy
@@ -280,6 +280,22 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
         '''
     }
 
+    void testClassPropertyOnInterface() {
+        assertScript '''
+            Class test(Serializable arg) {
+                Class<?> clazz = arg.class
+                clazz
+            }
+            assert test('foo') == String
+        '''
+        assertScript '''
+            Class test(Serializable arg) {
+                Class<?> clazz = arg.getClass()
+                clazz
+            }
+            assert test('foo') == String
+        '''
+    }
 
 
     public static class BaseClass {
