diff --git a/src/main/org/codehaus/groovy/classgen/ClassGenerator.java b/src/main/org/codehaus/groovy/classgen/ClassGenerator.java
index 2dbc42c1c3..16d30f03bc 100644
--- a/src/main/org/codehaus/groovy/classgen/ClassGenerator.java
+++ b/src/main/org/codehaus/groovy/classgen/ClassGenerator.java
@@ -983,11 +983,15 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
                 break;
 
             case Token.DIVIDE :
-                evaluateBinaryExpression("divide", expression);
+            	//SPG don't use divide since BigInteger implements directly
+            	//and we want to dispatch through DefaultGroovyMethods to get a BigDecimal result
+                evaluateBinaryExpression("div", expression);
                 break;
 
             case Token.DIVIDE_EQUAL :
-                evaluateBinaryExpressionWithAsignment("divide", expression);
+				//SPG don't use divide since BigInteger implements directly
+				//and we want to dispatch through DefaultGroovyMethods to get a BigDecimal result
+                evaluateBinaryExpressionWithAsignment("div", expression);
                 break;
 
             case Token.LEFT_SHIFT :
diff --git a/src/main/org/codehaus/groovy/runtime/BigDecimalMath.java b/src/main/org/codehaus/groovy/runtime/BigDecimalMath.java
new file mode 100644
index 0000000000..c610699627
--- /dev/null
+++ b/src/main/org/codehaus/groovy/runtime/BigDecimalMath.java
@@ -0,0 +1,62 @@
+package org.codehaus.groovy.runtime;
+
+import java.math.BigDecimal;
+
+/**
+ * BigDecimal NumberMath operations
+ * 
+ * @author Steve Goetze
+ */
+public class BigDecimalMath extends NumberMath {
+
+	//This is an arbitrary value, picked as a reasonable choice for a rounding point
+	//for typical user math.
+	public static final int MAX_DIVISION_SCALE = 10;
+	
+	protected static BigDecimalMath instance = new BigDecimalMath();
+	
+	private BigDecimalMath() {}
+
+	protected Number absImpl(Number number) {
+		return toBigDecimal(number).abs();
+	}
+	
+	protected Number addImpl(Number left, Number right) {
+		return toBigDecimal(left).add(toBigDecimal(right));
+	}
+
+	protected Number subtractImpl(Number left, Number right) {
+		return toBigDecimal(left).subtract(toBigDecimal(right));
+	}
+
+	protected Number multiplyImpl(Number left, Number right) {
+		return toBigDecimal(left).multiply(toBigDecimal(right));
+	}
+
+	protected Number divideImpl(Number left, Number right) {
+		//Hack until Java 1.5 BigDecimal is available.  For now, pick
+		//a result scale which is the maximum of the scale of the
+		//two operands and an arbitrary maximum (similar to what a
+		//handheld calculator would do).  Then, normalize the result
+		//by removing any trailing zeros.
+		BigDecimal bigLeft = toBigDecimal(left);
+		BigDecimal bigRight = toBigDecimal(right);
+		int scale = Math.max(bigLeft.scale(), bigRight.scale());
+		return normalize(bigLeft.divide(bigRight, Math.max(scale, MAX_DIVISION_SCALE), BigDecimal.ROUND_HALF_UP));
+	}
+	
+	protected int compareToImpl(Number left, Number right) {
+		return toBigDecimal(left).compareTo(toBigDecimal(right));
+	}
+	
+	private BigDecimal normalize(BigDecimal number) {
+		try {
+			while (true) {
+				number = number.setScale(number.scale()-1);
+			} 
+		} catch (ArithmeticException e) {
+			return number;
+		}
+	}
+
+}
diff --git a/src/main/org/codehaus/groovy/runtime/BigIntegerMath.java b/src/main/org/codehaus/groovy/runtime/BigIntegerMath.java
new file mode 100644
index 0000000000..d2f68ea10a
--- /dev/null
+++ b/src/main/org/codehaus/groovy/runtime/BigIntegerMath.java
@@ -0,0 +1,38 @@
+package org.codehaus.groovy.runtime;
+
+/**
+ * BigInteger NumberMath operations
+ * 
+ * @author Steve Goetze
+ */
+public class BigIntegerMath extends NumberMath {
+
+	protected static BigIntegerMath instance = new BigIntegerMath();
+	
+	private BigIntegerMath() {}
+
+	protected Number absImpl(Number number) {
+		return toBigInteger(number).abs();
+	}
+	
+	protected Number addImpl(Number left, Number right) {
+		return toBigInteger(left).add(toBigInteger(right));
+	}
+
+	protected Number subtractImpl(Number left, Number right) {
+		return toBigInteger(left).subtract(toBigInteger(right));
+	}
+
+	protected Number multiplyImpl(Number left, Number right) {
+		return toBigInteger(left).multiply(toBigInteger(right));
+	}
+
+	protected Number divideImpl(Number left, Number right) {
+		return BigDecimalMath.instance.divideImpl(left, right);
+	}
+	
+	protected int compareToImpl(Number left, Number right) {
+		return toBigInteger(left).compareTo(toBigInteger(right));
+	}
+
+}
diff --git a/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java b/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
index dd07f1723f..a8720ed4ef 100644
--- a/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
+++ b/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
@@ -47,7 +47,6 @@ import groovy.util.OrderBy;
 import java.lang.reflect.Array;
 import java.lang.reflect.Field;
 import java.lang.reflect.Modifier;
-import java.math.BigDecimal;
 import java.net.MalformedURLException;
 import java.net.URI;
 import java.net.URL;
@@ -2123,27 +2122,7 @@ public class DefaultGroovyMethods {
      * @return the addition of both Numbers
      */
     public static Number plus(Number left, Number right) {
-        /** @todo maybe a double dispatch thing to handle new large numbers? */
-        if (isBigDecimal(left) || isBigDecimal(right)) {
-            return toBigDecimal(left).add(toBigDecimal(right));
-        }
-        else if (isFloatingPoint(left) || isFloatingPoint(right)) {
-            return new Double(left.doubleValue() + right.doubleValue());
-        }
-        else if (isLong(left) || isLong(right)) {
-            return new Long(left.longValue() + right.longValue());
-        }
-        else {
-            return new Integer(left.intValue() + right.intValue());
-        }
-    }
-
-    public static boolean isBigDecimal(Number number) {
-        return number instanceof BigDecimal;
-    }
-
-    public static BigDecimal toBigDecimal(Number n) {
-        return (n instanceof BigDecimal ? (BigDecimal) n : new BigDecimal(n.toString()));
+        return NumberMath.add(left, right);
     }
 
     /**
@@ -2188,33 +2167,7 @@ public class DefaultGroovyMethods {
      */
     public static int compareTo(Number left, Number right) {
         /** @todo maybe a double dispatch thing to handle new large numbers? */
-        if (isFloatingPoint(left) || isFloatingPoint(right)) {
-            double diff = left.doubleValue() - right.doubleValue();
-            if (diff == 0) {
-                return 0;
-            }
-            else {
-                return (diff > 0) ? 1 : -1;
-            }
-        }
-        else if (isLong(left) || isLong(right)) {
-            long diff = left.longValue() - right.longValue();
-            if (diff == 0) {
-                return 0;
-            }
-            else {
-                return (diff > 0) ? 1 : -1;
-            }
-        }
-        else {
-            int diff = left.intValue() - right.intValue();
-            if (diff == 0) {
-                return 0;
-            }
-            else {
-                return (diff > 0) ? 1 : -1;
-            }
-        }
+        return NumberMath.compareTo(left, right);
     }
 
     /**
@@ -2258,18 +2211,7 @@ public class DefaultGroovyMethods {
      * @return the substraction
      */
     public static Number minus(Number left, Number right) {
-        if (isBigDecimal(left) || isBigDecimal(right)) {
-            return toBigDecimal(left).subtract(toBigDecimal(right));
-        }
-        else if (isFloatingPoint(left) || isFloatingPoint(right)) {
-            return new Double(left.doubleValue() - right.doubleValue());
-        }
-        else if (isLong(left) || isLong(right)) {
-            return new Long(left.longValue() - right.longValue());
-        }
-        else {
-            return new Integer(left.intValue() - right.intValue());
-        }
+    	return NumberMath.subtract(left,right);
     }
 
     /**
@@ -2312,19 +2254,10 @@ public class DefaultGroovyMethods {
      * @param right another Number
      * @return the multiplication of both
      */
+	//Note:  This method is NOT called if left AND right are both BigIntegers or BigDecimals because
+	//those classes implement a method with a better exact match.
     public static Number multiply(Number left, Number right) {
-        if (isBigDecimal(left) || isBigDecimal(right)) {
-            return toBigDecimal(left).multiply(toBigDecimal(right));
-        }
-        else if (isFloatingPoint(left) || isFloatingPoint(right)) {
-            return new Double(left.doubleValue() * right.doubleValue());
-        }
-        else if (isLong(left) || isLong(right)) {
-            return new Long(left.longValue() * right.longValue());
-        }
-        else {
-            return new Integer(left.intValue() * right.intValue());
-        }
+    	return NumberMath.multiply(left, right);
     }
 
     /**
@@ -2335,16 +2268,16 @@ public class DefaultGroovyMethods {
      * @return a Number to the power of a certain exponent
      */
     public static Number power(Number self, Number exponent) {
-        double answer = Math.pow(self.doubleValue(), exponent.doubleValue());
-        if (isFloatingPoint(self) || isFloatingPoint(exponent) || answer < 1) {
-            return new Double(answer);
-        }
-        else if (isLong(self) || isLong(exponent) || answer > Integer.MAX_VALUE) {
-            return new Long((long) answer);
-        }
-        else {
-            return new Integer((int) answer);
-        }
+		double answer = Math.pow(self.doubleValue(), exponent.doubleValue());
+		if (NumberMath.isFloatingPoint(self) || NumberMath.isFloatingPoint(exponent) || answer < 1) {
+			return new Double(answer);
+		}
+		else if (NumberMath.isLong(self) || NumberMath.isLong(exponent) || answer > Integer.MAX_VALUE) {
+			return new Long((long) answer);
+		}
+		else {
+			return new Integer((int) answer);
+		}
     }
 
     /**
@@ -2354,8 +2287,8 @@ public class DefaultGroovyMethods {
      * @param right a Number
      * @return the multiplication of both
      */
-    public static Number divide(Character left, Number right) {
-        return divide(new Integer(left.charValue()), right);
+    public static Number div(Character left, Number right) {
+        return div(new Integer(left.charValue()), right);
     }
 
     /**
@@ -2365,8 +2298,8 @@ public class DefaultGroovyMethods {
      * @param right a Character
      * @return the multiplication of both
      */
-    public static Number divide(Number left, Character right) {
-        return divide(left, new Integer(right.charValue()));
+    public static Number div(Number left, Character right) {
+        return div(left, new Integer(right.charValue()));
     }
 
     /**
@@ -2376,44 +2309,21 @@ public class DefaultGroovyMethods {
      * @param right another Character
      * @return the multiplication of both
      */
-    public static Number divide(Character left, Character right) {
-        return divide(new Integer(left.charValue()), right);
+    public static Number div(Character left, Character right) {
+        return div(new Integer(left.charValue()), right);
     }
 
     /**
      * Divide two Numbers
-     *
+     * 
      * @param left a Number
      * @param right another Number
      * @return a Number resulting of the divide operation
      */
-    public static Number divide(Number left, Number right) {
-        // lets use double for division?
-        if (isBigDecimal(left) || isBigDecimal(right)) {
-            return toBigDecimal(left).divide(toBigDecimal(right), BigDecimal.ROUND_HALF_EVEN);
-        }
-        else
-            return new Double(left.doubleValue() / right.doubleValue());
-    }
-
-    /**
-     * Tell whether the Number is a Long
-     *
-     * @param number a Number
-     * @return true if the Number is a Long
-     */
-    public static boolean isLong(Number number) {
-        return number instanceof Long;
-    }
-
-    /**
-     * Tell whether the Number is a floating point Number (ie. Float or Double)
-     *
-     * @param number a Number
-     * @return true if the Number is a Double or a Float
-     */
-    public static boolean isFloatingPoint(Number number) {
-        return number instanceof Float || number instanceof Double;
+	//Method name changed from 'divide' to avoid collision with BigInteger method that has
+	//different semantics.  We want a BigDecimal result rather than a BigInteger.
+    public static Number div(Number left, Number right) {
+    	return NumberMath.divide(left, right);
     }
 
     /**
@@ -2461,6 +2371,8 @@ public class DefaultGroovyMethods {
      * @param number a Number
      * @return the absolute value of that Number
      */
+    //Note:  This method is NOT called if number is a BigInteger or BigDecimal because
+    //those classes implement a method with a better exact match.
     public static int abs(Number number) {
         return Math.abs(number.intValue());
     }
diff --git a/src/main/org/codehaus/groovy/runtime/FloatingPointMath.java b/src/main/org/codehaus/groovy/runtime/FloatingPointMath.java
new file mode 100644
index 0000000000..e7128bb7e0
--- /dev/null
+++ b/src/main/org/codehaus/groovy/runtime/FloatingPointMath.java
@@ -0,0 +1,42 @@
+package org.codehaus.groovy.runtime;
+
+/**
+ * FloatingPoint (Double and Float) NumberMath operations
+ * 
+ * @author Steve Goetze
+ */
+public class FloatingPointMath extends NumberMath {
+
+	protected static FloatingPointMath instance = new FloatingPointMath();
+	
+	private FloatingPointMath() {}
+				
+	protected Number absImpl(Number number) {
+		return new Double(Math.abs(number.doubleValue()));
+	}
+	
+	protected Number addImpl(Number left, Number right) {
+		return new Double(left.doubleValue() + right.doubleValue());
+	}
+
+	protected Number subtractImpl(Number left, Number right) {
+		return new Double(left.doubleValue() - right.doubleValue());
+	}
+
+	protected Number multiplyImpl(Number left, Number right) {
+		return new Double(left.doubleValue() * right.doubleValue());
+	}
+
+	protected Number divideImpl(Number left, Number right) {
+		return new Double(left.doubleValue() / right.doubleValue());
+	}
+	protected int compareToImpl(Number left, Number right) {
+		double diff = left.doubleValue() - right.doubleValue();
+		if (diff == 0) {
+			return 0;
+		}
+		else {
+			return (diff > 0) ? 1 : -1;
+		}
+	}
+}
diff --git a/src/main/org/codehaus/groovy/runtime/IntegerMath.java b/src/main/org/codehaus/groovy/runtime/IntegerMath.java
new file mode 100644
index 0000000000..04fc54368f
--- /dev/null
+++ b/src/main/org/codehaus/groovy/runtime/IntegerMath.java
@@ -0,0 +1,48 @@
+/*
+ * Created on Mar 5, 2004
+ *
+ */
+package org.codehaus.groovy.runtime;
+
+/**
+ * Integer NumberMath operations
+ * 
+ * @author Steve Goetze
+ */
+public class IntegerMath extends NumberMath {
+
+	protected static IntegerMath instance = new IntegerMath();
+
+	private IntegerMath() {}
+					
+	protected Number absImpl(Number number) {
+		return new Integer(Math.abs(number.intValue()));
+	}
+	
+	protected Number addImpl(Number left, Number right) {
+		return new Integer(left.intValue() + right.intValue());
+	}
+
+	protected Number subtractImpl(Number left, Number right) {
+		return new Integer(left.intValue() - right.intValue());
+	}
+
+	protected Number multiplyImpl(Number left, Number right) {
+		return new Integer(left.intValue() * right.intValue());
+	}
+
+	protected Number divideImpl(Number left, Number right) {
+		return BigDecimalMath.instance.divideImpl(left, right);
+	}
+	
+	protected int compareToImpl(Number left, Number right) {
+		int diff = left.intValue() - right.intValue();
+		if (diff == 0) {
+			return 0;
+		}
+		else {
+			return (diff > 0) ? 1 : -1;
+		}
+	}
+
+}
diff --git a/src/main/org/codehaus/groovy/runtime/LongMath.java b/src/main/org/codehaus/groovy/runtime/LongMath.java
new file mode 100644
index 0000000000..5b5eb18de8
--- /dev/null
+++ b/src/main/org/codehaus/groovy/runtime/LongMath.java
@@ -0,0 +1,48 @@
+/*
+ * Created on Mar 5, 2004
+ *
+ */
+package org.codehaus.groovy.runtime;
+
+/**
+ * Long NumberMath operations
+ * 
+ * @author Steve Goetze
+ */
+public class LongMath extends NumberMath {
+
+	protected static LongMath instance = new LongMath();
+
+	private LongMath() {}
+					
+	protected Number absImpl(Number number) {
+		return new Long(Math.abs(number.longValue()));
+	}
+	
+	protected Number addImpl(Number left, Number right) {
+		return new Long(left.longValue() + right.longValue());
+	}
+
+	protected Number subtractImpl(Number left, Number right) {
+		return new Long(left.longValue() - right.longValue());
+	}
+
+	protected Number multiplyImpl(Number left, Number right) {
+		return new Long(left.longValue() * right.longValue());
+	}
+
+	protected Number divideImpl(Number left, Number right) {
+		return BigDecimalMath.instance.divideImpl(left, right);
+	}
+	
+	protected int compareToImpl(Number left, Number right) {
+		long diff = left.longValue() - right.longValue();
+		if (diff == 0) {
+			return 0;
+		}
+		else {
+			return (diff > 0) ? 1 : -1;
+		}
+	}
+
+}
diff --git a/src/main/org/codehaus/groovy/runtime/NumberMath.java b/src/main/org/codehaus/groovy/runtime/NumberMath.java
new file mode 100644
index 0000000000..579def3455
--- /dev/null
+++ b/src/main/org/codehaus/groovy/runtime/NumberMath.java
@@ -0,0 +1,153 @@
+/*
+ * Created on Mar 7, 2004
+ *
+ */
+package org.codehaus.groovy.runtime;
+
+import java.math.BigDecimal;
+import java.math.BigInteger;
+
+/**
+ * Stateless objects used to perform math on the various Number subclasses.
+ * Instances are required so that polymorphic calls work properly, but each
+ * subclass creates a singleton instance to minimize garbage.  All methods
+ * must be thread-safe.
+ * 
+ * The methods here represent only the operations supported by <b>all</b> Number
+ * subclasses.  For example power() is not implemented here because it is not 
+ * currently supported by BigDecimal (but will be in Java 1.5).
+ * 
+ * The design goals of this class are as follows:
+ * <ol>
+ * <li>Support a 'least surprising' math model to scripting language users.  This
+ * means that exact, or decimal math should be used for default calculations.  This
+ * scheme assumes that by default, groovy literals with decimal points are instantiated
+ * as BigDecimal objects rather than binary floating points (Float, Double). 
+ * <li>Do not force the appearance of exactness on a number that is by definition not 
+ * guaranteed to be exact.  In particular this means that if an operand in a NumberMath 
+ * operation is a binary floating point number, ensure that the result remains a binary floating point 
+ * number (i.e. never automatically promote a binary floating point number to a BigDecimal).  
+ * This has the effect of preserving the expectations of binary floating point users and helps performance.
+ * <li>Provide an implementation that is as close as practical to the Java 1.5 BigDecimal math model 
+ * which implements precision based floating point decimal math (ANSI X3.274-1996 and 
+ * ANSI X3.274-1996/AM 1-2000 (section 7.4).  
+ * </ol>
+ * 
+ * @author Steve Goetze
+ */
+public abstract class NumberMath extends Object {
+		
+	public static Number abs(Number number) {
+		return getMath(number).absImpl(number);
+	}
+	
+	public static Number add(Number left, Number right) {
+		return getMath(left, right).addImpl(left,right);
+	}
+	
+	public static Number subtract(Number left, Number right) {
+		return getMath(left,right).subtractImpl(left,right);
+	}
+	
+	public static Number multiply(Number left, Number right) {
+		return getMath(left,right).multiplyImpl(left,right);
+	}
+	
+	public static Number divide(Number left, Number right) {
+		return getMath(left,right).divideImpl(left,right);
+ 	}
+ 	 
+	public static int compareTo(Number left, Number right) {
+		return getMath(left,right).compareToImpl(left, right);
+	}
+	
+	public static boolean isFloatingPoint(Number number) {
+		return number instanceof Double || number instanceof Float;
+	}
+
+	public static boolean isInteger(Number number) {
+		return number instanceof Integer;
+	}
+
+	public static boolean isLong(Number number) {
+		return number instanceof Long;
+	}
+
+	public static boolean isBigDecimal(Number number) {
+		return number instanceof BigDecimal;
+	}
+
+	public static boolean isBigInteger(Number number) {
+		return number instanceof BigInteger;
+	}
+
+	public static BigDecimal toBigDecimal(Number n) {
+		return (n instanceof BigDecimal ? (BigDecimal) n : new BigDecimal(n.toString()));
+	}
+				
+	public static BigInteger toBigInteger(Number n) {
+		return (n instanceof BigInteger ? (BigInteger) n : new BigInteger(n.toString()));
+	}
+					
+	/**
+	 * Determine which NumberMath instance to use, given the supplied operands.  This method implements
+	 * the type promotion rules discussed in the documentation.  Note that by the time this method is
+	 * called, any Byte, Character or Short operands will have been promoted to Integer.  For reference,
+	 * here is the promotion matrix:
+	 *    bD bI  D  F  L  I
+	 * bD bD bD  D  D bD bD
+	 * bI bD bI  D  D bI bI
+	 *  D  D  D  D  D  D  D
+	 *  F  D  D  D  D  D  D
+	 *  L bD bI  D  D  L  L
+	 *  I bD bI  D  D  L  I
+	 * 
+	 * Note that for division, if either operand isFloatingPoint, the result will be floating.  Otherwise,
+	 * the result is BigDecimal
+	 */
+	private static NumberMath getMath(Number left, Number right) {
+		if (isFloatingPoint(left) || isFloatingPoint(right)) {
+			return FloatingPointMath.instance;
+		}
+		else if (isBigDecimal(left) || isBigDecimal(right)) {
+			return BigDecimalMath.instance;
+		}
+		else if (isBigInteger(left) || isBigInteger(right)) {
+			return BigIntegerMath.instance;
+		}
+		else if (isLong(left) || isLong(right)){
+			return LongMath.instance;
+		}
+		return IntegerMath.instance;
+	}
+
+	private static NumberMath getMath(Number number) {
+		if (isInteger(number)) {
+			return IntegerMath.instance;
+		}
+		else if (isLong(number)) {
+			return LongMath.instance;
+		}
+		else if (isFloatingPoint(number)) {
+			return FloatingPointMath.instance;
+		}			
+		else if (isBigDecimal(number)) {
+			return BigDecimalMath.instance;
+		}
+		else if (isBigInteger(number)) {
+			return BigIntegerMath.instance;
+		}
+		else {
+			throw new IllegalArgumentException("An unexpected Number subclass was supplied.");
+		}
+	}
+	
+	//Subclasses implement according to the type promotion hierarchy rules
+	protected abstract Number absImpl(Number number);
+	protected abstract Number addImpl(Number left, Number right);
+	protected abstract Number subtractImpl(Number left, Number right);
+	protected abstract Number multiplyImpl(Number left, Number right);
+	protected abstract Number divideImpl(Number left, Number right);
+	protected abstract int compareToImpl(Number left, Number right);
+
+}
diff --git a/src/test/groovy/NumberMathTest.groovy b/src/test/groovy/NumberMathTest.groovy
new file mode 100644
index 0000000000..2e62aadd3b
--- /dev/null
+++ b/src/test/groovy/NumberMathTest.groovy
@@ -0,0 +1,94 @@
+import java.math.BigDecimal;
+import java.math.BigInteger;
+
+/** 
+ * Basic NumberMath test.
+ */
+class NumberMathTest extends GroovyTestCase {
+
+    void testPromotions() {
+    	I = new Integer(1);
+    	L = new Long(1);
+    	F = new Float(1.0);
+    	D = new Double(1.0);
+    	BI = new BigInteger("1");
+    	BD = new BigDecimal("1.0");
+    	
+    	//+, -, and * all promote the same way, so sample the matrix
+    	assert I+I instanceof Integer;
+    	assert I-F instanceof Double;
+    	assert I*D instanceof Double;
+    	assert I+BI instanceof BigInteger;
+    	assert I-BD instanceof BigDecimal;
+    	
+    	assert F*L instanceof Double;
+    	assert D+L instanceof Double;
+    	assert BI-L instanceof BigInteger;
+    	assert BD*L instanceof BigDecimal;
+    	
+    	assert F+F instanceof Double;
+    	assert F-BI instanceof Double;
+    	assert F*BD instanceof Double;
+    	
+    	assert F+D instanceof Double;
+    	assert BI-D instanceof Double;
+    	assert BD*D instanceof Double;
+    	
+    	assert BI+BI instanceof BigInteger;
+    	assert BD-BI instanceof BigDecimal;
+    	assert BD*BD instanceof BigDecimal;
+    	
+    	//Division (/) promotes differently so change the expected results:
+    	assert I/I instanceof BigDecimal;
+    	assert I/F instanceof Double;
+    	assert I/D instanceof Double;
+    	assert I/BI instanceof BigDecimal;
+    	assert I/BD instanceof BigDecimal;
+    	
+    	assert F/L instanceof Double;
+    	assert D/L instanceof Double;
+    	assert BI/L instanceof BigDecimal;
+    	assert BD/L instanceof BigDecimal;
+    	
+    	assert F/F instanceof Double;
+    	assert F/BI instanceof Double;
+    	assert F/BD instanceof Double;
+    	
+    	assert F/D instanceof Double;
+    	assert BI/D instanceof Double;
+    	assert BD/D instanceof Double;
+    	
+    	assert BI/BI instanceof BigDecimal;
+    	assert BD/BI instanceof BigDecimal;
+    	assert BD/BD instanceof BigDecimal;
+    }
+    
+    void testOperations() {
+    	I1 = new Integer(1);
+    	I2 = new Integer(2);
+    	I3 = new Integer(3);
+    	L1 = new Long(1);
+    	L2 = new Long(2);
+    	F1 = new Float(1.0);
+    	F2 = new Float(2.0);
+    	D1 = new Double(1.0);
+    	D2 = new Double(2.0);
+    	BI1 = new BigInteger("1");
+    	BI2 = new BigInteger("2");
+    	BD1 = new BigDecimal("1.0");
+    	BD2 = new BigDecimal("2.0");
+    	BD20 = new BigDecimal("2.00");
+
+    	
+    	assert I1/I2 instanceof BigDecimal;
+    	assert I1/I2 == new BigDecimal("0.5");
+
+    	assert I1/I3 instanceof BigDecimal;
+    	assert I1/I3 == new BigDecimal("0.3333333333");
+    	
+    	assert I2/I3 instanceof BigDecimal;
+    	assert I2/I3 == new BigDecimal("0.6666666667");
+    	    	
+    	assert I1/BD2 instanceof BigDecimal;
+	}    
+}
diff --git a/src/test/groovy/bugs/SimpleModel.java b/src/test/groovy/bugs/SimpleModel.java
new file mode 100644
index 0000000000..8bcd1d3d5c
--- /dev/null
+++ b/src/test/groovy/bugs/SimpleModel.java
@@ -0,0 +1,68 @@
+/*
+ $Id$
+
+ Copyright 2003 (C) James Strachan and Bob Mcwhirter. All Rights Reserved.
+
+ Redistribution and use of this software and associated documentation
+ ("Software"), with or without modification, are permitted provided
+ that the following conditions are met:
+
+ 1. Redistributions of source code must retain copyright
+    statements and notices.  Redistributions must also contain a
+    copy of this document.
+
+ 2. Redistributions in binary form must reproduce the
+    above copyright notice, this list of conditions and the
+    following disclaimer in the documentation and/or other
+    materials provided with the distribution.
+
+ 3. The name "groovy" must not be used to endorse or promote
+    products derived from this Software without prior written
+    permission of The Codehaus.  For written permission,
+    please contact info@codehaus.org.
+
+ 4. Products derived from this Software may not be called "groovy"
+    nor may "groovy" appear in their names without prior written
+    permission of The Codehaus. "groovy" is a registered
+    trademark of The Codehaus.
+
+ 5. Due credit should be given to The Codehaus -
+    http://groovy.codehaus.org/
+
+ THIS SOFTWARE IS PROVIDED BY THE CODEHAUS AND CONTRIBUTORS
+ ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ THE CODEHAUS OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ OF THE POSSIBILITY OF SUCH DAMAGE.
+
+ */
+
+package groovy.bugs;
+
+/**
+ * @author 
+ * @version $Revision$
+ */
+public class SimpleModel {
+    public String s;
+
+    SimpleModel () {
+        s="Hi!";
+    }
+
+    public void show() {
+        System.out.println(s);
+    }
+
+    public static void main(String[] args) {
+        SimpleModel simp = new SimpleModel();
+        simp.show();
+    }
+}
diff --git a/src/test/org/codehaus/groovy/runtime/InvokeMethodTest.java b/src/test/org/codehaus/groovy/runtime/InvokeMethodTest.java
index 9281593693..7efa165dab 100644
--- a/src/test/org/codehaus/groovy/runtime/InvokeMethodTest.java
+++ b/src/test/org/codehaus/groovy/runtime/InvokeMethodTest.java
@@ -180,11 +180,13 @@ public class InvokeMethodTest extends GroovyTestCase {
         assertEquals("toString", object.toString(), value);
     }
 
+	//SPG modified to reflect DefaultGroovyMethod name change and expected result from
+	//Integer/Integer division.
     public void testDivideNumbers() throws Throwable {
-        assertMethodCall(new Double(10), "divide", new Double(2), new Double(5));
-        assertMethodCall(new Double(10), "divide", new Integer(2), new Double(5));
-        assertMethodCall(new Integer(10), "divide", new Double(2), new Double(5));
-        assertMethodCall(new Integer(10), "divide", new Integer(2), new Double(5));
+        assertMethodCall(new Double(10), "div", new Double(2), new Double(5));
+        assertMethodCall(new Double(10), "div", new Integer(2), new Double(5));
+        assertMethodCall(new Integer(10), "div", new Double(2), new Double(5));
+        assertMethodCall(new Integer(10), "div", new Integer(2), new java.math.BigDecimal("5"));
     }
 
     public void testBaseFailMethod() throws Throwable {
