diff --git a/src/main/org/codehaus/groovy/runtime/ConversionHandler.java b/src/main/org/codehaus/groovy/runtime/ConversionHandler.java
index 2537c5b422..dda2b15351 100644
--- a/src/main/org/codehaus/groovy/runtime/ConversionHandler.java
+++ b/src/main/org/codehaus/groovy/runtime/ConversionHandler.java
@@ -75,7 +75,7 @@ public abstract class ConversionHandler implements InvocationHandler, Serializab
      * @see InvocationHandler#invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])
      */
     public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
-        if (!isCoreObjectMethod(method)) {
+        if (!checkMethod(method)) {
             return invokeCustom(proxy, method, args);
         }
         try {
@@ -84,6 +84,10 @@ public abstract class ConversionHandler implements InvocationHandler, Serializab
             throw ite.getTargetException();
         }
     }
+    
+    protected boolean checkMethod(Method method) {
+    	return isCoreObjectMethod(method);
+    }
 
     /**
      * This method is called for all Methods not defined on Object.
@@ -147,7 +151,7 @@ public abstract class ConversionHandler implements InvocationHandler, Serializab
      * @return true if the method is deemed to be a core method
      */
     public static boolean isCoreObjectMethod(Method method) {
-        return Object.class.equals(method.getDeclaringClass()) && !"toString".equals(method.getName());
+        return Object.class.equals(method.getDeclaringClass());
     }
 
 }
diff --git a/src/main/org/codehaus/groovy/runtime/ConvertedMap.java b/src/main/org/codehaus/groovy/runtime/ConvertedMap.java
index 17ed3a912f..6f7c1b2bc9 100644
--- a/src/main/org/codehaus/groovy/runtime/ConvertedMap.java
+++ b/src/main/org/codehaus/groovy/runtime/ConvertedMap.java
@@ -49,5 +49,22 @@ public class ConvertedMap extends ConversionHandler {
     public String toString() {
         return DefaultGroovyMethods.toString((Map) getDelegate());
     }
+
+    protected boolean checkMethod(Method method) {
+    	return isCoreObjectMethod(method);
+    }
+
+    /**
+     * Checks whether a method is a core method from java.lang.Object.
+     * Such methods often receive special treatment because they are
+     * deemed fundamental enough to not be tampered with.
+     * call toString() is an exception to allow overriding toString() by a closure specified in the map  
+     *
+     * @param method the method to check
+     * @return true if the method is deemed to be a core method
+     */
+    public static boolean isCoreObjectMethod(Method method) {
+        return ConversionHandler.isCoreObjectMethod(method) && !"toString".equals(method.getName());
+    }
 }
 
diff --git a/src/test/groovy/bugs/Groovy3574Bug.groovy b/src/test/groovy/bugs/Groovy3574Bug.groovy
new file mode 100644
index 0000000000..93c5e624f6
--- /dev/null
+++ b/src/test/groovy/bugs/Groovy3574Bug.groovy
@@ -0,0 +1,44 @@
+package groovy.bugs
+
+class Groovy3574Bug extends GroovyTestCase {
+    void testToStringCallDelegationToConvertedClosureProxy() {
+        Closure failing1 = { 
+            throw new RuntimeException("Call to this closure fails.") 
+        }
+        
+        Closure failing2 = { a, b ->
+            assert a == "a"
+            assert b == "b"
+            throw new RuntimeException("Call to this closure fails.") 
+        }
+        
+        MyType3574A instance1 = failing1 as MyType3574A
+
+        // test call without args
+        try{
+            instance1.m()
+            fail("The call m() should have failed - 1")
+        } catch (ex) {
+            // ok, if it failed
+        }
+        
+        // this call was getting delegated to the closure earlier
+        assert instance1.toString() != null
+        
+        // test call with args
+        MyType3574B instance2 = failing2 as MyType3574B
+        try{
+            instance2.m("a", "b")
+            fail("The call m() should have failed - 2")
+        } catch (ex) {
+            // ok, if it failed
+        }
+
+        // this call was getting delegated to the closure earlier
+        assert instance2.toString() != null
+    }
+}
+
+interface MyType3574A { def m()}
+
+interface MyType3574B { def m(a, b)}
\ No newline at end of file
