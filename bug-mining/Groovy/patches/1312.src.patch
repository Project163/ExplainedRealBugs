diff --git a/src/main/org/codehaus/groovy/control/ResolveVisitor.java b/src/main/org/codehaus/groovy/control/ResolveVisitor.java
index 734e194c4f..1595a0cb62 100644
--- a/src/main/org/codehaus/groovy/control/ResolveVisitor.java
+++ b/src/main/org/codehaus/groovy/control/ResolveVisitor.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2009 the original author or authors.
+ * Copyright 2003-2010 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -450,21 +450,21 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
             if (type instanceof ConstructedClassWithPackage) {
                 // we replace '.' only in the className part
                 // with '$' to find an inner class. The case that
-                // the package is really a class is handled else where
+                // the package is really a class is handled elsewhere
                 ConstructedClassWithPackage tmp = (ConstructedClassWithPackage) type;
-                String name = ((ConstructedClassWithPackage) type).className;
-                tmp.className = replaceLastPoint(name);
+                String savedName = tmp.className;
+                tmp.className = replaceLastPoint(savedName);
                 if (resolve(tmp, false, true, true)) {
                     type.setRedirect(tmp.redirect());
                     return true;
                 }
-                tmp.className = name;
+                tmp.className = savedName;
             }   else {
-                String name = type.getName();
-                String replacedPointType = replaceLastPoint(name);
+                String savedName = type.getName();
+                String replacedPointType = replaceLastPoint(savedName);
                 type.setName(replacedPointType);
                 if (resolve(type, false, true, true)) return true;
-                type.setName(name);
+                type.setName(savedName);
             }
         }
         return false;
@@ -474,7 +474,7 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
         // test default imports
         testDefaultImports &= !type.hasPackageName();
         // we do not resolve a vanilla name starting with a lower case letter
-        // try to resolve against adefault import, because we know that the
+        // try to resolve against a default import, because we know that the
         // default packages do not contain classes like these
         testDefaultImports &= !(type instanceof LowerCaseClass);
         if (testDefaultImports) {
@@ -484,8 +484,8 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
                 // We limit the inner class lookups here by using ConstructedClassWithPackage.
                 // This way only the name will change, the packagePrefix will
                 // not be included in the lookup. The case where the
-                // packagePrefix is really a class is handled else where.
-                // WARNING: This code does not expect a class that has an static
+                // packagePrefix is really a class is handled elsewhere.
+                // WARNING: This code does not expect a class that has a static
                 //          inner class in DEFAULT_IMPORTS
                 ConstructedClassWithPackage tmp =  new ConstructedClassWithPackage(packagePrefix,name);
                 if (resolve(tmp, false, false, false)) {
@@ -528,7 +528,7 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
     private boolean resolveAliasFromModule(ClassNode type) {
         // In case of getting a ConstructedClassWithPackage here we do not do checks for partial
         // matches with imported classes. The ConstructedClassWithPackage is already a constructed
-        // node and any subclass resolving will then take elsewhere place
+        // node and any subclass resolving will then take place elsewhere
         if (type instanceof ConstructedClassWithPackage) return false;
 
         ModuleNode module = currentClass.getModule();
@@ -549,16 +549,22 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
             pname = name.substring(0, index);
             ClassNode aliasedNode = null;
             ImportNode importNode = module.getImport(pname);
-            if(importNode != null && importNode != currImportNode) {
+            if (importNode != null && importNode != currImportNode) {
                 aliasedNode = importNode.getType();
             }
+            if (aliasedNode == null) {
+                importNode = module.getStaticImports().get(pname);
+                if (importNode != null && importNode != currImportNode && importNode.isStatic()) {
+                    aliasedNode = importNode.getType();
+                }
+            }
 
             if (aliasedNode != null) {
-                if (pname.length() == name.length()) {
+                if (pname.length() == name.length() && !importNode.isStatic()) {
                     // full match
 
                     // We can compare here by length, because pname is always
-                    // a sbustring of name, so same length means they are equal.
+                    // a substring of name, so same length means they are equal.
                     type.setRedirect(aliasedNode);
                     return true;
                 } else {
@@ -571,7 +577,8 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
                     // Since we do not want to have useless lookups we create the name
                     // completely and use a ConstructedClassWithPackage to prevent lookups against the package.
                     String className = aliasedNode.getNameWithoutPackage() + '$' +
-                                       name.substring(pname.length()+1).replace('.', '$');
+                            (importNode.isStatic() ? pname :
+                                       name.substring(pname.length()+1).replace('.', '$'));
                     ConstructedClassWithPackage tmp = new ConstructedClassWithPackage(aliasedNode.getPackageName()+".", className);
                     if (resolve(tmp, true, true, false)) {
                         type.setRedirect(tmp.redirect());
@@ -635,13 +642,13 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
                 }
             }
 
-            // check module node imports packages
+            // check module node import packages
             for (ImportNode importNode : module.getStarImports()) {
                 String packagePrefix = importNode.getPackageName();
                 // We limit the inner class lookups here by using ConstructedClassWithPackage.
                 // This way only the name will change, the packagePrefix will
                 // not be included in the lookup. The case where the
-                // packagePrefix is really a class is handled else where.
+                // packagePrefix is really a class is handled elsewhere.
                 ConstructedClassWithPackage tmp = new ConstructedClassWithPackage(packagePrefix, name);
                 if (resolve(tmp, false, false, true)) {
                     ambiguousClass(type, tmp, name);
@@ -649,6 +656,17 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
                     return true;
                 }
             }
+            // check for star imports (import static pkg.Outer.*) matching static inner classes
+            for (ImportNode importNode : module.getStaticStarImports().values()) {
+                ClassNode node = ClassHelper.make(importNode.getType().getName() + "$" + name);
+                if (resolve(node, false, false, false)) {
+                    if ((node.getModifiers() & ~Opcodes.ACC_STATIC) != 0) {
+                        type.setRedirect(node.redirect());
+                        return true;
+                    }
+                }
+
+            }
         }
         return false;
     }
diff --git a/src/test/groovy/StaticImportTest.groovy b/src/test/groovy/StaticImportTest.groovy
index 010c8fd345..20af754a98 100644
--- a/src/test/groovy/StaticImportTest.groovy
+++ b/src/test/groovy/StaticImportTest.groovy
@@ -1,3 +1,18 @@
+/*
+ * Copyright 2003-2010 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package groovy
 
 import static java.lang.Boolean.FALSE as F
@@ -14,6 +29,8 @@ import static java.util.Calendar.getInstance as now
 import static groovy.API.*
 import static groovy.StaticImportChild.*
 import static groovy.bugs.Groovy4145.foo4145
+import static Outer1.*
+import static Outer2.Inner2
 import gls.CompilableTestSupport
 
 class StaticImportTest extends CompilableTestSupport {
@@ -248,6 +265,14 @@ class StaticImportTest extends CompilableTestSupport {
             }
         '''
     }
+
+    void testStaticStarImportOfStaticInnerClasses() {
+        assert Inner1.class.name == 'groovy.Outer1$Inner1'
+    }
+
+    void testStaticImportOfStaticInnerClasses() {
+        assert Inner2.class.name == 'groovy.Outer2$Inner2'
+    }
 }
 
 class API {
@@ -269,3 +294,11 @@ class StaticImportChild extends StaticImportParent {
   static cfield = 21
   static cmethod() { 'hello from child' }
 }
+
+class Outer1 {
+    static class Inner1 {}
+}
+
+class Outer2 {
+    static class Inner2 {}
+}
