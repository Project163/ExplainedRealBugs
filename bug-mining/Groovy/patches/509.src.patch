diff --git a/src/main/groovy/lang/MetaClassImpl.java b/src/main/groovy/lang/MetaClassImpl.java
index 8e452dcca7..56dccfe452 100644
--- a/src/main/groovy/lang/MetaClassImpl.java
+++ b/src/main/groovy/lang/MetaClassImpl.java
@@ -2349,7 +2349,6 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
         for (Iterator iter = matchingMethods.iterator(); iter.hasNext();) {
             Object method = iter.next();
             Class[] paramTypes = MetaClassHelper.getParameterTypes(method).getNativeParameterTypes();
-            if (!MetaClassHelper.parametersAreCompatible(arguments, paramTypes)) continue;
             long dist = MetaClassHelper.calculateParameterDistance(arguments, paramTypes);
             if (dist == 0) return method;
             if (matches.size() == 0) {
diff --git a/src/main/org/codehaus/groovy/ast/Parameter.java b/src/main/org/codehaus/groovy/ast/Parameter.java
index 24c16fed78..b967f6526a 100644
--- a/src/main/org/codehaus/groovy/ast/Parameter.java
+++ b/src/main/org/codehaus/groovy/ast/Parameter.java
@@ -81,6 +81,7 @@ public class Parameter extends AnnotatedNode implements Variable {
     
     public void setInitialExpression(Expression init) {
         defaultValue = init;
+        if (defaultValue==null) hasDefaultValue=false;
     }
     
     public boolean isInStaticContext() {
diff --git a/src/main/org/codehaus/groovy/classgen/Verifier.java b/src/main/org/codehaus/groovy/classgen/Verifier.java
index d34496f14c..213fe2557f 100644
--- a/src/main/org/codehaus/groovy/classgen/Verifier.java
+++ b/src/main/org/codehaus/groovy/classgen/Verifier.java
@@ -211,27 +211,7 @@ public class Verifier implements GroovyClassVisitor, Opcodes {
         }
         
         if (!(node instanceof InnerClassNode)) {// add a static timestamp field to the class
-            FieldNode timeTagField = new FieldNode(
-                    Verifier.__TIMESTAMP,
-                    Modifier.PUBLIC | Modifier.STATIC,
-                    ClassHelper.Long_TYPE,
-                    //"",
-                    node,
-                    new ConstantExpression(new Long(System.currentTimeMillis())));
-            // alternatively , FieldNode timeTagField = SourceUnit.createFieldNode("public static final long __timeStamp = " + System.currentTimeMillis() + "L");
-            timeTagField.setSynthetic(true);
-            node.addField(timeTagField);
-
-            timeTagField = new FieldNode(
-                    Verifier.__TIMESTAMP__ + String.valueOf(System.currentTimeMillis()),
-                    Modifier.PUBLIC | Modifier.STATIC,
-                    ClassHelper.Long_TYPE,
-                    //"",
-                    node,
-                    new ConstantExpression(new Long(0)));
-            // alternatively , FieldNode timeTagField = SourceUnit.createFieldNode("public static final long __timeStamp = " + System.currentTimeMillis() + "L");
-            timeTagField.setSynthetic(true);
-            node.addField(timeTagField);
+            addTimeStamp(node);
         }
         
         addInitialization(node);
@@ -240,6 +220,31 @@ public class Verifier implements GroovyClassVisitor, Opcodes {
         addCovariantMethods(node);
         node.visitContents(this);
     }
+    
+    protected void addTimeStamp(ClassNode node) {
+        FieldNode timeTagField = new FieldNode(
+                Verifier.__TIMESTAMP,
+                Modifier.PUBLIC | Modifier.STATIC,
+                ClassHelper.Long_TYPE,
+                //"",
+                node,
+                new ConstantExpression(new Long(System.currentTimeMillis())));
+        // alternatively , FieldNode timeTagField = SourceUnit.createFieldNode("public static final long __timeStamp = " + System.currentTimeMillis() + "L");
+        timeTagField.setSynthetic(true);
+        node.addField(timeTagField);
+
+        timeTagField = new FieldNode(
+                Verifier.__TIMESTAMP__ + String.valueOf(System.currentTimeMillis()),
+                Modifier.PUBLIC | Modifier.STATIC,
+                ClassHelper.Long_TYPE,
+                //"",
+                node,
+                new ConstantExpression(new Long(0)));
+        // alternatively , FieldNode timeTagField = SourceUnit.createFieldNode("public static final long __timeStamp = " + System.currentTimeMillis() + "L");
+        timeTagField.setSynthetic(true);
+        node.addField(timeTagField);
+    }
+
     private void checkReturnInObjectInitializer(List init) {
         CodeVisitorSupport cvs = new CodeVisitorSupport() {
             public void visitReturnStatement(ReturnStatement statement) {
@@ -463,8 +468,19 @@ public class Verifier implements GroovyClassVisitor, Opcodes {
                             arguments.addExpression(new VariableExpression(parameters[i].getName()));
                         }
                     }
+                    if (parameters.length>0 && parameters[parameters.length-1].getType().isArray()) {
+                        // vargs call... better expand the argument:
+                        Expression exp = arguments.getExpression(parameters.length-1);
+                        SpreadExpression se = new SpreadExpression(exp);
+                        arguments.getExpressions().set(parameters.length-1, se);
+                    }
                     action.call(arguments,newParams,method);
                 }
+                
+                for (int i = 0; i < parameters.length; i++) {
+                    // remove default expression
+                    parameters[i].setInitialExpression(null);
+                }
             }
         }
     }
@@ -615,7 +631,7 @@ public class Verifier implements GroovyClassVisitor, Opcodes {
         return Long.MAX_VALUE;
     }
     
-    private void addCovariantMethods(ClassNode classNode) {
+    protected void addCovariantMethods(ClassNode classNode) {
         Map methodsToAdd = new HashMap();
         List declaredMethods = new ArrayList(classNode.getMethods());
         Map genericsSpec = new HashMap();
diff --git a/src/main/org/codehaus/groovy/runtime/MetaClassHelper.java b/src/main/org/codehaus/groovy/runtime/MetaClassHelper.java
index 47988e18f3..1cbdec1ff3 100644
--- a/src/main/org/codehaus/groovy/runtime/MetaClassHelper.java
+++ b/src/main/org/codehaus/groovy/runtime/MetaClassHelper.java
@@ -42,6 +42,7 @@ public class MetaClassHelper {
     public static final Object[] ARRAY_WITH_NULL = {null};
     protected static final Logger LOG = Logger.getLogger(MetaClassHelper.class.getName());
     private static final int MAX_ARG_LEN = 12;
+    private static final int VARGS_SHIFT = 28;
 
     public static boolean accessibleToConstructor(final Class at, final Constructor constructor) {
         boolean accessible = false;
@@ -249,29 +250,16 @@ public class MetaClassHelper {
         if (parameter == argument) return 0;
 
         if (parameter.isInterface()) {
-            long ret = PRIMITIVES.length;
-            ret = (ret << 32) | getMaximumInterfaceDistance(argument, parameter);
-            return ret;
+            return getMaximumInterfaceDistance(argument, parameter)<<1;
         }
 
         long objectDistance = 0;
         if (argument != null) {
-            if (parameter.isArray()) {
-                if (argument.isArray()) {
-                    return calculateParameterDistance(argument.getComponentType(), parameter.getComponentType());
-                } else {
-                    parameter = parameter.getComponentType();
-                    objectDistance++;
-                }
-            } else if (argument.isArray()) {
-                objectDistance++;
-            }
-
             long pd = getPrimitiveDistance(parameter, argument);
-            if (pd != -1) return pd << 33;
+            if (pd != -1) return pd << 32;
 
             // add one to dist to be sure interfaces are prefered
-            objectDistance += PRIMITIVES.length << 1 + 1;
+            objectDistance += PRIMITIVES.length + 1;
             Class clazz = ReflectionCache.autoboxType(argument);
             while (clazz != null) {
                 if (clazz == parameter) break;
@@ -302,25 +290,74 @@ public class MetaClassHelper {
     }
 
     public static long calculateParameterDistance(Class[] arguments, Class[] parameters) {
-        long ret = 0;
-        if (parameters.length == 0)
-          return 0;
-
-        int paramMinus1 = parameters.length-1;
-        for (int i = 0; i < paramMinus1; i++) {
+        if (parameters.length == 0) return 0;
+
+        long ret = 0;        
+        int noVargsLength = parameters.length-1;
+        
+        // if the number of parameters does not match we have 
+        // a vargs usage
+        //
+        // case A: arguments.length<parameters.length
+        //
+        //         In this case arguments.length is always equal to
+        //         noVargsLength because only the last parameter
+        //         might be a optional vargs parameter
+        //
+        // case B: arguments.lenth>parameters.length
+        //
+        //         In this case all arguments with a index bigger than
+        //         paramMinus1 are part of the vargs, so a 
+        //         distance calculaion needs to be done against 
+        //         parameters[noVargsLength].getComponentType()
+        //
+        // case C: arguments.length==parameters.length && 
+        //         isAssignableFrom( parameters[noVargsLength],
+        //                           arguments[noVargsLength] )
+        //
+        //         In this case we have no vargs, so calculate directly
+        //
+        // case D: arguments.length==parameters.length && 
+        //         !isAssignableFrom( parameters[noVargsLength],
+        //                            arguments[noVargsLength] )
+        //
+        //         In this case we have a vargs case again, we need 
+        //         to calculate arguments[noVargsLength] against
+        //         parameters[noVargsLength].getComponentType
+        
+        
+        
+        // first we calculate all arguments, that are for sure not part
+        // of vargs.  Since the minimum for arguments is noVargsLength
+        // we can safely iterate to this point
+        for (int i = 0; i < noVargsLength; i++) {
             ret += calculateParameterDistance(arguments[i], parameters[i]);
         }
-
-        if (parameters[paramMinus1].isArray() && (arguments.length > parameters.length) ) {
-            ret++;
-            Class type = parameters[paramMinus1].getComponentType();
-            for (int i = paramMinus1; i != arguments.length; ++i) {
-                ret += calculateParameterDistance(arguments[paramMinus1], type);
+        
+        if (arguments.length==parameters.length) {
+            // case C&D, we use baseType to calculate and set it
+            // to the value we need according to case C and D
+            Class baseType = parameters[noVargsLength]; // case C
+            if (!isAssignableFrom(parameters[noVargsLength],arguments[noVargsLength])) {
+                baseType=baseType.getComponentType(); // case D
+                ret+=2l<<VARGS_SHIFT; // penalty for vargs
             }
-        }
-        else {
-           ret += calculateParameterDistance(arguments[paramMinus1], parameters[paramMinus1]);
-        }
+            ret += calculateParameterDistance(arguments[noVargsLength], baseType);
+        } else if (arguments.length>parameters.length) {
+            // case B
+            // we give our a vargs penalty for each exceeding argument and iterate
+            // by using parameters[noVargsLength].getComponentType()
+            ret += (2+arguments.length-parameters.length)<<VARGS_SHIFT;
+            Class vargsType = parameters[noVargsLength].getComponentType();
+            for (int i = noVargsLength; i < arguments.length; i++) {
+                ret += calculateParameterDistance(arguments[i], vargsType);
+            }
+        } else {
+            // case A
+            // we give a penalty for vargs, since we have no direct
+            // match for the last argument
+            ret+=1l<<VARGS_SHIFT;            
+        }  
 
         return ret;
     }
@@ -696,6 +733,14 @@ public class MetaClassHelper {
         }
         return false;
     }
+    
+    public static boolean parametersAreCompatible(Class[] arguments, Class[] parameters) {
+        if (arguments.length != parameters.length) return false;
+        for (int i = 0; i < arguments.length; i++) {
+            if (!isAssignableFrom(parameters[i], arguments[i])) return false;
+        }
+        return true;
+    }
 
     public static boolean isValidMethod(ParameterTypes pt, Class[] arguments, boolean includeCoerce) {
         if (arguments == null) {
@@ -772,28 +817,6 @@ public class MetaClassHelper {
         return value;
     }
 
-    public static boolean parametersAreCompatible(Class[] arguments, Class[] parameters) {
-        if (arguments.length < parameters.length) return false;
-        if (parameters.length == 0)
-           return arguments.length == 0;
-        int paramMinus1 = parameters.length-1;
-        for (int i = 0; i < paramMinus1; i++) {
-            if (!isAssignableFrom(parameters[i], arguments[i]))
-               return false;
-        }
-        if (parameters[paramMinus1].isArray() && (arguments.length > parameters.length) ) {
-            Class type = parameters[paramMinus1].getComponentType();
-            for (int i = paramMinus1; i != arguments.length; ++i) {
-                if (!isAssignableFrom(type, arguments[i]))
-                   return false;
-            }
-        }
-        else {
-           return isAssignableFrom(parameters[paramMinus1], arguments[paramMinus1]);
-        }
-        return true;
-    }
-
     protected static String shortName(Object object) {
         if (object == null || object.getClass() == null) return "unknownClass";
         String name = getClassName(object);
diff --git a/src/main/org/codehaus/groovy/tools/javac/JavaStubGenerator.java b/src/main/org/codehaus/groovy/tools/javac/JavaStubGenerator.java
index 0db9ab8f72..ed2e473a7a 100644
--- a/src/main/org/codehaus/groovy/tools/javac/JavaStubGenerator.java
+++ b/src/main/org/codehaus/groovy/tools/javac/JavaStubGenerator.java
@@ -16,8 +16,6 @@
 
 package org.codehaus.groovy.tools.javac;
 
-import groovy.lang.GroovyObjectSupport;
-
 import org.codehaus.groovy.ast.*;
 import org.codehaus.groovy.ast.expr.ArgumentListExpression;
 import org.codehaus.groovy.ast.expr.ConstantExpression;
@@ -26,6 +24,7 @@ import org.codehaus.groovy.ast.expr.Expression;
 import org.codehaus.groovy.ast.stmt.BlockStatement;
 import org.codehaus.groovy.ast.stmt.ExpressionStatement;
 import org.codehaus.groovy.ast.stmt.Statement;
+import org.codehaus.groovy.classgen.Verifier;
 import org.codehaus.groovy.control.ResolveVisitor;
 import org.objectweb.asm.Opcodes;
 
@@ -72,6 +71,12 @@ public class JavaStubGenerator
         FileOutputStream fos = new FileOutputStream(file);
         PrintWriter out = new PrintWriter(fos);
 
+        Verifier verifier = new Verifier() {
+            public void addCovariantMethods(ClassNode cn) {}
+            protected void addTimeStamp(ClassNode node) {}
+        };
+        verifier.visitClass(classNode);
+        
         try {
             String packageName = classNode.getPackageName();
             if (packageName != null) {
@@ -97,14 +102,9 @@ public class JavaStubGenerator
 
             ClassNode superClass = classNode.getUnresolvedSuperClass(false);
 
-            if (!isInterface) {
-                if (superClass.equals(ClassHelper.OBJECT_TYPE)) {
-                    superClass = ClassHelper.make(GroovyObjectSupport.class);
-                }
-                if (!isEnum) {
-                    out.print("  extends ");
-                    printType(superClass,out);
-                }
+            if (!isInterface && !isEnum) {
+                out.print("  extends ");
+                printType(superClass,out);
             } 
 
             ClassNode[] interfaces = classNode.getInterfaces();
@@ -324,15 +324,6 @@ public class JavaStubGenerator
 
             out.println("}");
         }
-        
-        // handling of default values
-        Parameter[] params = getDefaultValueReducedParameters(constructorNode);
-        if (params!=constructorNode.getParameters()) {
-            ConstructorNode m = new ConstructorNode(
-                    constructorNode.getModifiers(), params,
-                    constructorNode.getExceptions(), constructorNode.getCode());
-            genConstructor(clazz,m,out);
-        }
     }
 
     private ConstructorNode selectAccessibleConstructorFromSuper(ConstructorNode node) {
@@ -454,29 +445,6 @@ public class JavaStubGenerator
             printReturn(out, retType);
             out.println("}");
         }
-        
-        // handling of default values
-        Parameter[] params = getDefaultValueReducedParameters(methodNode);
-        if (params!=methodNode.getParameters()) {
-            MethodNode m = new MethodNode(
-                    methodNode.getName(), methodNode.getModifiers(),
-                    methodNode.getReturnType(), params,
-                    methodNode.getExceptions(),null);
-            genMethod(clazz,m,out);
-        }
-    }
-
-    private Parameter[] getDefaultValueReducedParameters(MethodNode methodNode) {
-        Parameter[] params = methodNode.getParameters();
-        for (int i = params.length-1; i>-1; i--) {
-            if (params[i].hasInitialExpression()) {
-                Parameter[] newParams = new Parameter[params.length-1];
-                System.arraycopy(params, 0, newParams, 0, i);
-                System.arraycopy(params, i+1, newParams, i, params.length-i-1);
-                return newParams;
-            }
-        }
-        return params;
     }
 
     private void printReturn(PrintWriter out, ClassNode retType) {
diff --git a/src/test/groovy/DefaultParamTest.groovy b/src/test/groovy/DefaultParamTest.groovy
index 7efe0f8806..75cccb2662 100644
--- a/src/test/groovy/DefaultParamTest.groovy
+++ b/src/test/groovy/DefaultParamTest.groovy
@@ -2,6 +2,19 @@ package groovy
 
 class DefaultParamTest extends GroovyTestCase {
 
+    //GROOVY-2191
+
+    def m2191a(String one, String two = "two") {"$one $two"}
+    def m2191a(String one, String two = "two", String three = "three") {"$one $two $three"}
+    
+    def m2191b(String one, String two = "two", String three = "three") {"$one $two $three"}
+    def m2191b(String one, String two = "two") {"$one $two"}
+    
+    void test2191() {
+      assert m2191a("bar") == "bar two"
+      assert m2191b("bar") == "bar two three"
+    } 
+
     void testDefaultParameters() {
     
     	def value = doSomething("X", "Y", "Z")
diff --git a/src/test/groovy/PropertyTest.groovy b/src/test/groovy/PropertyTest.groovy
index 1a21f5c86a..59a45c135e 100644
--- a/src/test/groovy/PropertyTest.groovy
+++ b/src/test/groovy/PropertyTest.groovy
@@ -155,13 +155,13 @@ class Base {
     protected thing = 'foo thing'
     def getXprop() {'foo x prop'}
     def x() {'foo x'}
-    def setThing(value) {thing = value}
+    void setThing(value) {thing = value}
 }
 
 class Child extends Base {
     protected String field = 'foo' + super.field
     public getField() {field}
-    public setSuperField(value) {super.field = value}
+    void setSuperField(value) {super.field = value}
     public getSuperField() {super.field}
 
     def thing = 'bar thing'
diff --git a/src/test/groovy/VArgsTest.groovy b/src/test/groovy/VArgsTest.groovy
index 4c2c56582b..016824bb5b 100644
--- a/src/test/groovy/VArgsTest.groovy
+++ b/src/test/groovy/VArgsTest.groovy
@@ -95,4 +95,37 @@ class VArgsTest extends GroovyTestCase {
   void testArrayCoercion() {
     assert normalVargsMethod([1,2,3] as int[]) == 3
   }
-}
\ No newline at end of file
+  
+  
+  // GROOVY-2204
+  def m2204a(Map kwargs=[:], arg1, arg2, Object[] args) {
+    "arg1: $arg1, arg2: $arg2, args: $args, kwargs: $kwargs"
+  }
+
+  def m2204b(Map kwargs=[:], arg1, arg2="1", Object[] args) {
+    "arg1: $arg1, arg2: $arg2, args: $args, kwargs: $kwargs"
+  }
+
+  void test2204a() {
+     assert m2204a('hello', 'world') == 'arg1: hello, arg2: world, args: {}, kwargs: [:]'
+     assert m2204a('hello', 'world', 'from', 'list') == 'arg1: hello, arg2: world, args: {"from", "list"}, kwargs: [:]'
+     assert m2204a('hello', 'world', 'from', 'list', from: 'kwargs') == 'arg1: hello, arg2: world, args: {"from", "list"}, kwargs: ["from":"kwargs"]'
+     assert m2204a('hello', 'world', from: 'kwargs') == 'arg1: hello, arg2: world, args: {}, kwargs: ["from":"kwargs"]'
+     
+     assert m2204b('hello', 'world') == 'arg1: hello, arg2: 1, args: {"world"}, kwargs: [:]'
+     assert m2204b('hello', 'world', 'from', 'list') == 'arg1: hello, arg2: 1, args: {"world", "from", "list"}, kwargs: [:]'
+     assert m2204b('hello', 'world', 'from', 'list', from: 'kwargs') == 'arg1: hello, arg2: world, args: {"from", "list"}, kwargs: ["from":"kwargs"]'
+     assert m2204b('hello', 'world', from: 'kwargs') == 'arg1: hello, arg2: world, args: {}, kwargs: ["from":"kwargs"]'
+  }
+
+ 
+  // GROOVY-2351
+  
+  def m2351(Object... args)  {1}
+  def m2351(Integer... args) {2}
+ 
+  void test2351() {
+    assert m2351(1, 2, 3, 4, 5) == 2
+  }
+  
+}  
diff --git a/src/test/groovy/bugs/ChristofsPropertyBug.groovy b/src/test/groovy/bugs/ChristofsPropertyBug.groovy
index b09d0cddf6..05791e6051 100644
--- a/src/test/groovy/bugs/ChristofsPropertyBug.groovy
+++ b/src/test/groovy/bugs/ChristofsPropertyBug.groovy
@@ -13,5 +13,5 @@ class ChristofsPropertyBug extends GroovyTestCase {
     }
     
     def getMixedCaseProperty()    { mixedCaseProperty }
-    def setMixedCaseProperty(val) { this.mixedCaseProperty = val }
+    void setMixedCaseProperty(val) { this.mixedCaseProperty = val }
 }
\ No newline at end of file
