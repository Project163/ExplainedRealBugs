diff --git a/src/main/org/codehaus/groovy/ast/GenericsType.java b/src/main/org/codehaus/groovy/ast/GenericsType.java
index df55f6db4c..e1b09e2e8a 100644
--- a/src/main/org/codehaus/groovy/ast/GenericsType.java
+++ b/src/main/org/codehaus/groovy/ast/GenericsType.java
@@ -17,6 +17,7 @@
 package org.codehaus.groovy.ast;
 
 import org.codehaus.groovy.ast.tools.GenericsUtils;
+import org.codehaus.groovy.ast.tools.WideningCategories;
 
 import java.util.HashSet;
 import java.util.Map;
@@ -157,6 +158,30 @@ public class GenericsType extends ASTNode {
      */
     private class GenericsTypeMatcher {
 
+        public boolean implementsInterfaceOrIsSubclassOf(ClassNode type, ClassNode superOrInterface) {
+            boolean result = type.equals(superOrInterface)
+                    || type.isDerivedFrom(superOrInterface)
+                    || type.implementsInterface(superOrInterface);
+            if (result) {
+                return true;
+            }
+            if (superOrInterface instanceof WideningCategories.LowestUpperBoundClassNode) {
+                WideningCategories.LowestUpperBoundClassNode cn = (WideningCategories.LowestUpperBoundClassNode) superOrInterface;
+                result = implementsInterfaceOrIsSubclassOf(type, cn.getSuperClass());
+                if (result) {
+                    for (ClassNode interfaceNode : cn.getInterfaces()) {
+                        result = implementsInterfaceOrIsSubclassOf(type,interfaceNode);
+                        if (!result) break;
+                    }
+                }
+                if (result) return true;
+            }
+            if (type.isArray() && superOrInterface.isArray()) {
+                return implementsInterfaceOrIsSubclassOf(type.getComponentType(), superOrInterface.getComponentType());
+            }
+            return false;
+        }
+
         /**
          * Compares this generics type with the one represented by the provided class node. If the provided
          * classnode is compatible with the generics specification, returns true. Otherwise, returns false.
@@ -189,8 +214,7 @@ public class GenericsType extends ASTNode {
                     boolean upIsOk = true;
                     for (int i = 0, upperBoundsLength = upperBounds.length; i < upperBoundsLength && upIsOk; i++) {
                         final ClassNode upperBound = upperBounds[i];
-                        upIsOk = (classNode.isDerivedFrom(upperBound) ||
-                                (upperBound.isInterface() && classNode.implementsInterface(upperBound)));
+                        upIsOk = implementsInterfaceOrIsSubclassOf(classNode, upperBound);
                     }
                     // if the provided classnode is a subclass of the upper bound
                     // then check that the generic types supplied by the class node are compatible with
@@ -203,8 +227,7 @@ public class GenericsType extends ASTNode {
                 if (lowerBound != null) {
                     // if a lower bound is declared, then we must perform the same checks that for an upper bound
                     // but with reversed arguments
-                    return (lowerBound.isDerivedFrom(classNode) ||
-                            (classNode.isInterface() && lowerBound.implementsInterface(lowerBound))) && checkGenerics(classNode);
+                    return implementsInterfaceOrIsSubclassOf(lowerBound, classNode) && checkGenerics(classNode);
                 }
             }
             // if this is not a generics placeholder, first compare that types represent the same type
@@ -272,6 +295,18 @@ public class GenericsType extends ASTNode {
                         }
                     }
                 }
+                if (bound instanceof WideningCategories.LowestUpperBoundClassNode) {
+                    // another special case here, where the bound is a "virtual" type
+                    // we must then check the superclass and the interfaces
+                    boolean success = compareGenericsWithBound(classNode, bound.getSuperClass());
+                    if (success) {
+                        ClassNode[] interfaces = bound.getInterfaces();
+                        for (ClassNode anInterface : interfaces) {
+                            success &= compareGenericsWithBound(classNode, anInterface);
+                        }
+                    }
+                    if (success) return true;
+                }
                 return compareGenericsWithBound(classNode.getUnresolvedSuperClass(), bound);
             }
             GenericsType[] cnTypes = classNode.getGenericsTypes();
@@ -281,8 +316,8 @@ public class GenericsType extends ASTNode {
                 return true;
             }
             GenericsType[] redirectBoundGenericTypes = bound.redirect().getGenericsTypes();
-            Map<String, GenericsType> classNodePlaceholders = org.codehaus.groovy.ast.tools.GenericsUtils.extractPlaceholders(classNode);
-            Map<String, GenericsType> boundPlaceHolders = org.codehaus.groovy.ast.tools.GenericsUtils.extractPlaceholders(bound);
+            Map<String, GenericsType> classNodePlaceholders = GenericsUtils.extractPlaceholders(classNode);
+            Map<String, GenericsType> boundPlaceHolders = GenericsUtils.extractPlaceholders(bound);
             boolean match = true;
             for (int i = 0; i < redirectBoundGenericTypes.length && match; i++) {
                 GenericsType redirectBoundType = redirectBoundGenericTypes[i];
@@ -326,8 +361,7 @@ public class GenericsType extends ASTNode {
                                                     gt = classNodePlaceholders.get(gt.getName());
                                                 }
                                             }
-                                            match = (gt.getType().isDerivedFrom(classNodeType.getType())
-                                                || gt.getType().implementsInterface(classNodeType.getType()));
+                                            match = implementsInterfaceOrIsSubclassOf(gt.getType(), classNodeType.getType());
                                         }
                                         if (match && redirectBoundType.upperBounds!=null) {
                                             for (ClassNode upperBound : redirectBoundType.upperBounds) {
@@ -340,8 +374,7 @@ public class GenericsType extends ASTNode {
                                                     }
                                                 }
                                                 match = match &&
-                                                        (classNodeType.getType().isDerivedFrom(gt.getType())
-                                                         || classNodeType.getType().implementsInterface(gt.getType()));
+                                                        implementsInterfaceOrIsSubclassOf(classNodeType.getType(), gt.getType());
                                             }
                                         }
                                         return match;
diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
index f504c3898e..70d0e6efd4 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
@@ -675,6 +675,22 @@ public abstract class StaticTypeCheckingSupport {
         if (result) {
             return true;
         }
+        if (superOrInterface instanceof WideningCategories.LowestUpperBoundClassNode) {
+            WideningCategories.LowestUpperBoundClassNode cn = (WideningCategories.LowestUpperBoundClassNode) superOrInterface;
+            result = implementsInterfaceOrIsSubclassOf(type, cn.getSuperClass());
+            if (result) {
+                for (ClassNode interfaceNode : cn.getInterfaces()) {
+                    result = type.implementsInterface(interfaceNode);
+                    if (!result) break;
+                }
+            }
+            if (result) return true;
+        } else if (superOrInterface instanceof UnionTypeClassNode) {
+            UnionTypeClassNode union = (UnionTypeClassNode) superOrInterface;
+            for (ClassNode delegate : union.getDelegates()) {
+                if (implementsInterfaceOrIsSubclassOf(type, delegate)) return true;
+            }
+        }
         if (type.isArray() && superOrInterface.isArray()) {
             return implementsInterfaceOrIsSubclassOf(type.getComponentType(), superOrInterface.getComponentType());
         }
diff --git a/src/test/groovy/transform/stc/BugsSTCTest.groovy b/src/test/groovy/transform/stc/BugsSTCTest.groovy
index 64de6d1875..bbd90f0463 100644
--- a/src/test/groovy/transform/stc/BugsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/BugsSTCTest.groovy
@@ -62,4 +62,23 @@ class BugsSTCTest extends StaticTypeCheckingTestCase {
         }
         '''
     }
+
+    void testGroovy5482ListsAndFlowTyping() {
+        assertScript '''
+        class StaticGroovy2 {
+            def bar() {
+
+                def foo = [new Date(), 1, new C()]
+                foo.add( 2 ) // Compiles
+                foo.add( new Date() )
+                foo.add( new C() )
+
+                foo = [new Date(), 1]
+                foo.add( 2 ) // Does not compile
+            }
+        }
+        class C{
+        }
+        new StaticGroovy2()'''
+    }
 }
