diff --git a/src/main/java/org/codehaus/groovy/runtime/ScriptBytecodeAdapter.java b/src/main/java/org/codehaus/groovy/runtime/ScriptBytecodeAdapter.java
index 1e14400e80..a17ae83247 100644
--- a/src/main/java/org/codehaus/groovy/runtime/ScriptBytecodeAdapter.java
+++ b/src/main/java/org/codehaus/groovy/runtime/ScriptBytecodeAdapter.java
@@ -117,8 +117,8 @@ public class ScriptBytecodeAdapter {
     }
 
     public static Object invokeMethodOnCurrentNSpreadSafe(Class senderClass, GroovyObject receiver, String messageName, Object[] messageArguments) throws Throwable {
-        List answer = new ArrayList();
-        for (Iterator it = InvokerHelper.asIterator(receiver); it.hasNext();) {
+        List<Object> answer = new ArrayList<>();
+        for (Iterator<?> it = InvokerHelper.asIterator(receiver); it.hasNext();) {
             answer.add(invokeMethodNSafe(senderClass, it.next(), messageName, messageArguments));
         }
         return answer;
@@ -156,8 +156,8 @@ public class ScriptBytecodeAdapter {
     }
 
     public static Object invokeMethodOnSuperNSpreadSafe(Class senderClass, GroovyObject receiver, String messageName, Object[] messageArguments) throws Throwable {
-        List answer = new ArrayList();
-        for (Iterator it = InvokerHelper.asIterator(receiver); it.hasNext();) {
+        List<Object> answer = new ArrayList<>();
+        for (Iterator<?> it = InvokerHelper.asIterator(receiver); it.hasNext();) {
             answer.add(invokeMethodNSafe(senderClass, it.next(), messageName, messageArguments));
         }
         return answer;
@@ -193,8 +193,8 @@ public class ScriptBytecodeAdapter {
 
     public static Object invokeMethodNSpreadSafe(Class senderClass, Object receiver, String messageName, Object[] messageArguments) throws Throwable {
         if (receiver == null) return null;
-        List answer = new ArrayList();
-        for (Iterator it = InvokerHelper.asIterator(receiver); it.hasNext();) {
+        List<Object> answer = new ArrayList<>();
+        for (Iterator<?> it = InvokerHelper.asIterator(receiver); it.hasNext();) {
             answer.add(invokeMethodNSafe(senderClass, it.next(), messageName, messageArguments));
         }
         return answer;
@@ -278,8 +278,8 @@ public class ScriptBytecodeAdapter {
     }
 
     public static Object getFieldOnSuperSpreadSafe(Class senderClass, Object receiver, String messageName) throws Throwable {
-        List answer = new ArrayList();
-        for (Iterator it = InvokerHelper.asIterator(receiver); it.hasNext();) {
+        List<Object> answer = new ArrayList<>();
+        for (Iterator<?> it = InvokerHelper.asIterator(receiver); it.hasNext();) {
             answer.add(getFieldOnSuper(senderClass, it.next(), messageName));
         }
         return answer;
@@ -307,7 +307,7 @@ public class ScriptBytecodeAdapter {
     }
 
     public static void setFieldOnSuperSpreadSafe(Object messageArgument, Class senderClass, Object receiver, String messageName) throws Throwable {
-        for (Iterator it = InvokerHelper.asIterator(receiver); it.hasNext();) {
+        for (Iterator<?> it = InvokerHelper.asIterator(receiver); it.hasNext();) {
             setFieldOnSuper(messageArgument, senderClass, it.next(), messageName);
         }
     }
@@ -331,8 +331,8 @@ public class ScriptBytecodeAdapter {
 
     public static Object getFieldSpreadSafe(Class senderClass, Object receiver, String messageName) throws Throwable {
         if (receiver == null) return null;
-        List answer = new ArrayList();
-        for (Iterator it = InvokerHelper.asIterator(receiver); it.hasNext();) {
+        List<Object> answer = new ArrayList<>();
+        for (Iterator<?> it = InvokerHelper.asIterator(receiver); it.hasNext();) {
             answer.add(getFieldSafe(senderClass, it.next(), messageName));
         }
         return answer;
@@ -357,7 +357,7 @@ public class ScriptBytecodeAdapter {
 
     public static void setFieldSpreadSafe(Object messageArgument, Class senderClass, Object receiver, String messageName) throws Throwable {
         if (receiver == null) return;
-        for (Iterator it = InvokerHelper.asIterator(receiver); it.hasNext();) {
+        for (Iterator<?> it = InvokerHelper.asIterator(receiver); it.hasNext();) {
             setFieldSafe(messageArgument, senderClass, it.next(), messageName);
         }
     }
@@ -367,8 +367,8 @@ public class ScriptBytecodeAdapter {
     //  --------------------------------------------------------
 
     public static Object getGroovyObjectField(Class senderClass, GroovyObject receiver, String messageName) throws Throwable {
-        try  {
-            return receiver.getMetaClass().getAttribute(receiver, messageName);
+        try {
+            return receiver.getMetaClass().getAttribute(senderClass, receiver, messageName, false);
         } catch (GroovyRuntimeException gre) {
             throw unwrap(gre);
         }
@@ -377,7 +377,7 @@ public class ScriptBytecodeAdapter {
     public static Object getGroovyObjectFieldSafe(Class senderClass, GroovyObject receiver, String messageName) throws Throwable {
         if (receiver == null) return null;
         try {
-            return receiver.getMetaClass().getAttribute(receiver, messageName);
+            return receiver.getMetaClass().getAttribute(senderClass, receiver, messageName, false);
         } catch (GroovyRuntimeException gre) {
             throw unwrap(gre);
         }
@@ -385,8 +385,8 @@ public class ScriptBytecodeAdapter {
 
     public static Object getGroovyObjectFieldSpreadSafe(Class senderClass, GroovyObject receiver, String messageName) throws Throwable {
         if (receiver == null) return null;
-        List answer = new ArrayList();
-        for (Iterator it = InvokerHelper.asIterator(receiver); it.hasNext();) {
+        List<Object> answer = new ArrayList<>();
+        for (Iterator<?> it = InvokerHelper.asIterator(receiver); it.hasNext();) {
             answer.add(getFieldSafe(senderClass, it.next(), messageName));
         }
         return answer;
@@ -398,7 +398,7 @@ public class ScriptBytecodeAdapter {
 
     public static void setGroovyObjectField(Object messageArgument, Class senderClass, GroovyObject receiver, String messageName) throws Throwable {
         try {
-            receiver.getMetaClass().setAttribute(receiver, messageName, messageArgument);
+            receiver.getMetaClass().setAttribute(senderClass, receiver, messageName, messageArgument, false, false);
         } catch (GroovyRuntimeException gre) {
             throw unwrap(gre);
         }
@@ -415,7 +415,7 @@ public class ScriptBytecodeAdapter {
 
     public static void setGroovyObjectFieldSpreadSafe(Object messageArgument, Class senderClass, GroovyObject receiver, String messageName) throws Throwable {
         if (receiver == null) return;
-        for (Iterator it = InvokerHelper.asIterator(receiver); it.hasNext();) {
+        for (Iterator<?> it = InvokerHelper.asIterator(receiver); it.hasNext();) {
             setFieldSafe(messageArgument, senderClass, it.next(), messageName);
         }
     }
@@ -485,9 +485,8 @@ public class ScriptBytecodeAdapter {
 
     public static Object getPropertySpreadSafe(Class senderClass, Object receiver, String messageName) throws Throwable {
         if (receiver == null) return null;
-
-        List answer = new ArrayList();
-        for (Iterator it = InvokerHelper.asIterator(receiver); it.hasNext();) {
+        List<Object> answer = new ArrayList<>();
+        for (Iterator<?> it = InvokerHelper.asIterator(receiver); it.hasNext();) {
             answer.add(getPropertySafe(senderClass, it.next(), messageName));
         }
         return answer;
@@ -499,7 +498,7 @@ public class ScriptBytecodeAdapter {
 
     public static void setProperty(Object messageArgument, Class senderClass, Object receiver, String messageName) throws Throwable {
         try {
-            if (receiver==null) receiver= NullObject.getNullObject();
+            if (receiver == null) receiver = NullObject.getNullObject();
             InvokerHelper.setProperty(receiver, messageName, messageArgument);
         } catch (GroovyRuntimeException gre) {
             throw unwrap(gre);
@@ -513,8 +512,7 @@ public class ScriptBytecodeAdapter {
 
     public static void setPropertySpreadSafe(Object messageArgument, Class senderClass, Object receiver, String messageName) throws Throwable {
         if (receiver == null) return;
-
-        for (Iterator it = InvokerHelper.asIterator(receiver); it.hasNext();) {
+        for (Iterator<?> it = InvokerHelper.asIterator(receiver); it.hasNext();) {
             setPropertySafe(messageArgument, senderClass, it.next(), messageName);
         }
     }
@@ -534,9 +532,8 @@ public class ScriptBytecodeAdapter {
 
     public static Object getGroovyObjectPropertySpreadSafe(Class senderClass, GroovyObject receiver, String messageName) throws Throwable {
         if (receiver == null) return null;
-
-        List answer = new ArrayList();
-        for (Iterator it = InvokerHelper.asIterator(receiver); it.hasNext();) {
+        List<Object> answer = new ArrayList<>();
+        for (Iterator<?> it = InvokerHelper.asIterator(receiver); it.hasNext();) {
             answer.add(getPropertySafe(senderClass, it.next(), messageName));
         }
         return answer;
@@ -561,8 +558,7 @@ public class ScriptBytecodeAdapter {
 
     public static void setGroovyObjectPropertySpreadSafe(Object messageArgument, Class senderClass, GroovyObject receiver, String messageName) throws Throwable {
         if (receiver == null) return;
-
-        for (Iterator it = InvokerHelper.asIterator(receiver); it.hasNext();) {
+        for (Iterator<?> it = InvokerHelper.asIterator(receiver); it.hasNext();) {
             setPropertySafe(messageArgument, senderClass, it.next(), messageName);
         }
     }
@@ -907,7 +903,7 @@ public class ScriptBytecodeAdapter {
 
     //spread
     public static Object[] despreadList(final Object[] args, final Object[] spreads, final int[] positions) {
-        List ret = new ArrayList();
+        List<Object> ret = new ArrayList<>();
         int argsPos = 0;
         int spreadPos = 0;
         for (int position : positions) {
@@ -918,7 +914,7 @@ public class ScriptBytecodeAdapter {
             if (value == null) {
                 ret.add(null);
             } else if (value instanceof List) {
-                ret.addAll((List) value);
+                ret.addAll((List<?>) value);
             } else if (value.getClass().isArray()) {
                 ret.addAll(DefaultTypeTransformation.primitiveArrayToList(value));
             } else {
diff --git a/src/test/groovy/ClosureTest.groovy b/src/test/groovy/ClosureTest.groovy
index 8ca01954ff..35b67b72bd 100644
--- a/src/test/groovy/ClosureTest.groovy
+++ b/src/test/groovy/ClosureTest.groovy
@@ -18,14 +18,15 @@
  */
 package groovy
 
-import groovy.test.GroovyTestCase
 import org.codehaus.groovy.control.MultipleCompilationErrorsException
+import org.junit.Test
 
-import static groovy.lang.Closure.IDENTITY
+import static groovy.test.GroovyAssert.assertScript
+import static groovy.test.GroovyAssert.shouldFail
 import static java.lang.reflect.Modifier.isPublic
 import static java.lang.reflect.Modifier.isStatic
 
-final class ClosureTest extends GroovyTestCase {
+final class ClosureTest {
 
     private int count
 
@@ -51,16 +52,18 @@ final class ClosureTest extends GroovyTestCase {
 
     //--------------------------------------------------------------------------
 
+    @Test
     void testSimpleBlockCall() {
-        def c = { owner -> owner.incrementCallCount() }
+        def c = { ClosureTest ct -> ct.incrementCallCount() }
 
         assertClosure(c)
         assert count == 1
 
-        assertClosure({ owner -> owner.incrementCallCount() })
+        assertClosure { ClosureTest ct -> ct.incrementCallCount() }
         assert count == 2
     }
 
+    @Test
     void testVariableLengthParameterList() {
         def c1 = { Object[] args -> args.each { count += it } }
         c1(1, 2, 3)
@@ -89,14 +92,16 @@ final class ClosureTest extends GroovyTestCase {
         assert count == 6
     }
 
+    @Test
     void testBlockAsParameter() {
-        callBlock(5, { owner -> owner.incrementCallCount() })
+        callBlock(5, { ClosureTest ct -> ct.incrementCallCount() })
         assert count == 6
 
-        callBlock2(5, { owner -> owner.incrementCallCount() })
+        callBlock2(5, { ClosureTest ct -> ct.incrementCallCount() })
         assert count == 12
     }
 
+    @Test
     void testMethodClosure() {
         def block = this.&incrementCallCount
 
@@ -115,6 +120,7 @@ final class ClosureTest extends GroovyTestCase {
         int x
     }
 
+    @Test
     void testIntFieldAccess() {
         def agents = new ArrayList();
         numAgents.times {
@@ -127,6 +133,7 @@ final class ClosureTest extends GroovyTestCase {
     }
 
     // GROOVY-6989
+    @Test
     void testEach() {
         assertScript '''
             Object[] arr = new Object[1]
@@ -144,6 +151,7 @@ final class ClosureTest extends GroovyTestCase {
         '''
     }
 
+    @Test
     void testEachWithArray() {
         def l = []
         l << ([1, 2] as Object[])
@@ -152,6 +160,7 @@ final class ClosureTest extends GroovyTestCase {
         }
     }
 
+    @Test
     void testEachWithIndex() {
         def str = ''
         def sum = 0
@@ -159,6 +168,7 @@ final class ClosureTest extends GroovyTestCase {
         assert str == 'abcd' && sum == 6
     }
 
+    @Test
     void testMapEachWithIndex() {
         def keyStr = ''
         def valStr = ''
@@ -171,6 +181,7 @@ final class ClosureTest extends GroovyTestCase {
         assert keyStr == 'abcd' && valStr == 'zyxw' && sum == 6
     }
 
+    @Test
     void testMapEachWithIndexKV() {
         def keyStr = ''
         def valStr = ''
@@ -183,9 +194,8 @@ final class ClosureTest extends GroovyTestCase {
         assert keyStr == 'abcd' && valStr == 'zyxw' && sum == 6
     }
 
-    /**
-     * GROOVY-2089 access to Closure's properties
-     */
+    // GROOVY-2089: Closure properties
+    @Test
     void testGetProperties() {
         def c = { println it }
 
@@ -201,19 +211,21 @@ final class ClosureTest extends GroovyTestCase {
         assert c.metaClass != c.getMetaClass() // no idea why this isn't equal
     }
 
+    @Test
     void testGetPropertiesGenerically() {
-        // ensure closure metaclass is the original one
+        // ensure closure meta-class is the original
         Closure.metaClass = null
 
         Closure.metaClass.properties.each { property ->
             int modifiers = property.modifiers
             if (isPublic(modifiers) && !isStatic(modifiers)) {
                 Closure closure = { -> }
-                closure."$property.name" == closure."${MetaProperty.getGetterName(property.name, property.type)}"()
+                closure."$property.name" == closure.(MetaProperty.getGetterName(property.name, property.type))()
             }
         }
     }
 
+    @Test
     void testSetProperties() {
         def c = { println it }
 
@@ -230,18 +242,16 @@ final class ClosureTest extends GroovyTestCase {
         // like in testGetProperties(), don't know how to test metaClass property
     }
 
-    /**
-     * GROOVY-2150 ensure list call is available on closure
-     */
+    // GROOVY-2150: ensure list call is available on closure
+    @Test
     void testCallClosureWithList() {
         def list = [1, 2]
         def cl = { a, b -> a + b }
         assert cl(list) == 3
     }
 
-    /**
-     * GROOVY-4484 ensure variable can be used in assignment inside closure
-     */
+    // GROOVY-4484: ensure variable can be used in assignment inside closure
+    @Test
     void testDeclarationOutsideWithAssignmentInsideAndReferenceInNestedClosure() {
         assertScript '''
             class Dummy { }
@@ -256,31 +266,35 @@ final class ClosureTest extends GroovyTestCase {
         '''
     }
 
+    @Test
     void testIdentity() {
-        assert IDENTITY(42) == 42
-        assert IDENTITY([42, true, 'foo']) == [42, true, 'foo']
+        def identity = Closure.IDENTITY
+
+        assert identity(42) == 42
+        assert identity([42, true, 'foo']) == [42, true, 'foo']
 
         def items = [0, 1, 2, '', 'foo', [], ['bar'], true, false]
-        assert items.grep(IDENTITY) == [1, 2, 'foo', ['bar'], true]
-        assert items.findAll(IDENTITY) == [1, 2, 'foo', ['bar'], true]
-        assert items.grep(IDENTITY).groupBy(IDENTITY) == [1: [1], 2: [2], 'foo': ['foo'], ['bar']: [['bar']], (true): [true]]
-        assert items.collect(IDENTITY) == items
+        assert items.grep(identity) == [1, 2, 'foo', ['bar'], true]
+        assert items.findAll(identity) == [1, 2, 'foo', ['bar'], true]
+        assert items.grep(identity).groupBy(identity) == [1: [1], 2: [2], 'foo': ['foo'], ['bar']: [['bar']], (true): [true]]
+        assert items.collect(identity) == items
 
         def twice = { it + it }
-        def alsoTwice = twice >> IDENTITY
+        def alsoTwice = twice >> identity
         assert alsoTwice(6) == 12
-        def twiceToo = IDENTITY >> twice
+        def twiceToo = identity >> twice
         assert twiceToo(6) == 12
 
-        def fortyTwo = IDENTITY.curry(42)
+        def fortyTwo = identity.curry(42)
         assert fortyTwo() == 42
-        def foo = IDENTITY.rcurry('foo')
+        def foo = identity.rcurry('foo')
         assert foo() == 'foo'
 
         def map = [a: 1, b: 2]
-        assert map.collectEntries(IDENTITY) == map
+        assert map.collectEntries(identity) == map
     }
 
+    @Test
     void testClosureDehydrateAndRehydrate() {
         def closure = { 'Hello' }
         assert closure.delegate != null
@@ -305,6 +319,7 @@ final class ClosureTest extends GroovyTestCase {
     }
 
     // GROOVY-5151
+    @Test
     void testClosureSerialization() {
         // without dehydrate, as Controller is not serializable, the serialization will fail
         shouldFail NotSerializableException, '''
@@ -397,6 +412,7 @@ final class ClosureTest extends GroovyTestCase {
     }
 
     // GROOVY-5875
+    @Test
     void testStaticInnerClassDelegateFirstAccess() {
         assertScript '''
             class Owner {
@@ -426,6 +442,7 @@ final class ClosureTest extends GroovyTestCase {
         '''
     }
 
+    @Test
     void testStaticInnerClassOwnerFirstAccess() {
         assertScript '''
             class Owner {
@@ -455,35 +472,33 @@ final class ClosureTest extends GroovyTestCase {
         '''
     }
 
+    @Test
     void testStaticInnerClassOwnerWithPropertyMissingImplementation() {
-        def gcl = new GroovyClassLoader()
-        def msg = shouldFail MultipleCompilationErrorsException, {
-            gcl.parseClass('''
-                class ClosureTestA {
-                    static class ClosureTestB {
-                        def propertyMissing(String myName, Object myValue) {
-                            return myValue
-                        }
-
-                        def propertyMissing(String myName) {
-                            return 42
-                        }
-
-                        def methodMissing(String myName, Object myArgs) {
-                            return 42
-                        }
+        def err = shouldFail MultipleCompilationErrorsException, '''
+            class ClosureTestA {
+                static class ClosureTestB {
+                    def propertyMissing(String myName, Object myValue) {
+                        return myValue
+                    }
+
+                    def propertyMissing(String myName) {
+                        return 42
+                    }
+
+                    def methodMissing(String myName, Object myArgs) {
+                        return 42
                     }
                 }
-            ''')
-        }
+            }
+        '''
 
-        assert msg.contains('"methodMissing" implementations are not supported on static inner classes as a synthetic version of "methodMissing" is added during compilation for the purpose of outer class delegation.')
-        assert msg.contains('"propertyMissing" implementations are not supported on static inner classes as a synthetic version of "propertyMissing" is added during compilation for the purpose of outer class delegation.')
+        assert err.message.contains('"methodMissing" implementations are not supported on static inner classes as a synthetic version of "methodMissing" is added during compilation for the purpose of outer class delegation.')
+        assert err.message.contains('"propertyMissing" implementations are not supported on static inner classes as a synthetic version of "propertyMissing" is added during compilation for the purpose of outer class delegation.')
     }
 
+    @Test
     void testInnerClassOwnerWithPropertyMissingImplementation() {
-        def gcl = new GroovyClassLoader()
-        gcl.parseClass('''
+        assertScript '''
             class ClosureTestA {
                 class ClosureTestB {
                     def propertyMissing(String myName, Object myValue) {
@@ -499,25 +514,49 @@ final class ClosureTest extends GroovyTestCase {
                     }
                 }
             }
-        ''')
+
+            def a = new ClosureTestA()
+            def b = new ClosureTestA.ClosureTestB(a)
+        '''
     }
 
+    @Test
     void testStaticInnerClassHierarchyWithMethodMissing() {
-        def gcl = new GroovyClassLoader()
-        def msg = shouldFail MultipleCompilationErrorsException, {
-            gcl.parseClass('''
-                class ClosureTestA {
-                    static class ClosureTestB {
-                        def methodMissing(String myName, Object myArgs) {
-                            return 42
-                        }
+        def err = shouldFail MultipleCompilationErrorsException, '''
+            class ClosureTestA {
+                static class ClosureTestB {
+                    def methodMissing(String myName, Object myArgs) {
+                        return 42
                     }
+                }
 
-                    static class ClosureTestB1 extends ClosureTestB {
-                    }
+                static class ClosureTestB1 extends ClosureTestB {
                 }
-            ''')
-        }
-        assert msg.contains('"methodMissing" implementations are not supported on static inner classes as a synthetic version of "methodMissing" is added during compilation for the purpose of outer class delegation.')
+            }
+        '''
+
+        assert err.message.contains('"methodMissing" implementations are not supported on static inner classes as a synthetic version of "methodMissing" is added during compilation for the purpose of outer class delegation.')
+    }
+
+    // GROOVY-3142
+    @Test
+    void testClosureAccessToEnclosingClassPrivateField() {
+        assertScript '''
+            class C {
+                private String string = 'foo'
+                def test(List<String> strings) {
+                    strings.collect { this.@string + it }
+                }
+            }
+
+            def result = new C().test(['bar','baz'])
+            assert result == ['foobar','foobaz']
+
+            class D extends C {
+            }
+
+            result = new D().test(['bar','baz'])
+            assert result == ['foobar','foobaz']
+        '''
     }
 }
diff --git a/src/test/groovy/ClosureUsingOuterVariablesTest.groovy b/src/test/groovy/ClosureUsingOuterVariablesTest.groovy
index 8d39d1641d..8fca4d0639 100644
--- a/src/test/groovy/ClosureUsingOuterVariablesTest.groovy
+++ b/src/test/groovy/ClosureUsingOuterVariablesTest.groovy
@@ -18,12 +18,12 @@
  */
 package groovy
 
-import groovy.test.GroovyTestCase
+import org.junit.Test
 
-class ClosureUsingOuterVariablesTest extends GroovyTestCase {
+final class ClosureUsingOuterVariablesTest {
 
+    @Test
     void testUseOfOuterVariable() {
-
         def x = 123
         def y = "hello"
 
@@ -35,19 +35,8 @@ class ClosureUsingOuterVariablesTest extends GroovyTestCase {
         closure.call(321)
     }
 
-    /*
-    TODO: is this a valid test case?
-    void testInnerVariablesVisibleInOuterScope() {
-
-       closure = { z = 456 }
-       closure.call(321)
-
-       assert z == 456
-   }
-   */
-
+    @Test
     void testModifyingOuterVariable() {
-
         def m = 123
 
         def closure = { m = 456 }
@@ -56,6 +45,7 @@ class ClosureUsingOuterVariablesTest extends GroovyTestCase {
         assert m == 456
     }
 
+    @Test
     void testCounting() {
         def sum = 0
 
@@ -64,6 +54,7 @@ class ClosureUsingOuterVariablesTest extends GroovyTestCase {
         assert sum == 10
     }
 
+    @Test
     void testExampleUseOfClosureScopes() {
         def a = 123
         def b
@@ -73,6 +64,7 @@ class ClosureUsingOuterVariablesTest extends GroovyTestCase {
         assert b == a + 5
     }
 
+    @Test
     void testExampleUseOfClosureScopesUsingEach() {
         def a = 123
         def b
