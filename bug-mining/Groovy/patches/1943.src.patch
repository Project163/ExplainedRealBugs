diff --git a/src/main/org/codehaus/groovy/transform/sc/StaticCompilationVisitor.java b/src/main/org/codehaus/groovy/transform/sc/StaticCompilationVisitor.java
index 6f604385af..2deece8b33 100644
--- a/src/main/org/codehaus/groovy/transform/sc/StaticCompilationVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/sc/StaticCompilationVisitor.java
@@ -275,7 +275,7 @@ public class StaticCompilationVisitor extends StaticTypeCheckingVisitor {
         if (exists) {
             Expression objectExpression = pexp.getObjectExpression();
             ClassNode objectExpressionType = getType(objectExpression);
-            if (objectExpressionType.implementsInterface(ClassHelper.LIST_TYPE)) {
+            if (StaticTypeCheckingSupport.implementsInterfaceOrIsSubclassOf(objectExpressionType, ClassHelper.LIST_TYPE)) {
                 objectExpression.putNodeMetaData(COMPONENT_TYPE, inferComponentType(objectExpressionType, ClassHelper.int_TYPE));
             }
         }
diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 7eb9520889..7274c3d940 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -425,7 +425,6 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 // "completed" with generics type information available in the LHS
                 ClassNode completedType = GenericsUtils.parameterizeType(lType, resultType.getPlainNodeReference());
 
-//                addStaticTypeError("Unchecked assignment: " + WideningCategories.lowestUpperBound(lType, resultType).toString(false), expression);
                 resultType = completedType;
 
             }
@@ -437,11 +436,6 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 // left hand side of an assignment : map['foo'] = ...
                 ClassNode[] arguments = {rType, getType(oldBinaryExpression.getRightExpression())};
                 List<MethodNode> nodes = findMethod(lType.redirect(), "putAt", arguments);
-                /*if (nodes.isEmpty() && lType.implementsInterface(MAP_TYPE)) {
-                    nodes = findMethod(lType, "put", arguments);
-                } else if (nodes.isEmpty() && lType.implementsInterface(LIST_TYPE)) {
-                    nodes = findMethod(lType, "add", arguments);
-                }*/
                 if (nodes.size() == 1) {
                     typeCheckMethodsWithGenerics(lType, arguments, nodes.get(0), expression);
                 }
@@ -814,19 +808,19 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
      */
     protected boolean existsProperty(final PropertyExpression pexp, final boolean checkForReadOnly, final ClassCodeVisitorSupport visitor) {
         Expression objectExpression = pexp.getObjectExpression();
-        ClassNode clazz = getType(objectExpression);
-        if (clazz.isArray() && "length".equals(pexp.getPropertyAsString())) {
+        final ClassNode objectExpressionType = getType(objectExpression);
+        if (objectExpressionType.isArray() && "length".equals(pexp.getPropertyAsString())) {
             if (visitor != null) {
-                PropertyNode node = new PropertyNode("length", Opcodes.ACC_PUBLIC | Opcodes.ACC_FINAL, int_TYPE, clazz, null, null, null);
+                PropertyNode node = new PropertyNode("length", Opcodes.ACC_PUBLIC | Opcodes.ACC_FINAL, int_TYPE, objectExpressionType, null, null, null);
                 storeType(pexp, int_TYPE);
                 visitor.visitProperty(node);
             }
             return true;
         }
         List<ClassNode> tests = new LinkedList<ClassNode>();
-        tests.add(clazz);
-        if (clazz.equals(CLASS_Type) && clazz.getGenericsTypes() != null) {
-            tests.add(clazz.getGenericsTypes()[0].getType());
+        tests.add(objectExpressionType);
+        if (objectExpressionType.equals(CLASS_Type) && objectExpressionType.getGenericsTypes() != null) {
+            tests.add(objectExpressionType.getGenericsTypes()[0].getType());
         }
         if (!temporaryIfBranchTypeInformation.empty()) {
             List<ClassNode> classNodes = getTemporaryTypesForExpression(objectExpression);
@@ -841,7 +835,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         if (propertyName == null) return false;
         String capName = MetaClassHelper.capitalize(propertyName);
         boolean isAttributeExpression = pexp instanceof AttributeExpression;
-        if (clazz.isInterface()) tests.add(OBJECT_TYPE);
+        if (objectExpressionType.isInterface()) tests.add(OBJECT_TYPE);
         for (ClassNode testClass : tests) {
                 LinkedList<ClassNode> queue = new LinkedList<ClassNode>();
                 queue.add(testClass);
@@ -943,8 +937,30 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         for (ClassNode testClass : tests) {
             if (implementsInterfaceOrIsSubclassOf(testClass, MAP_TYPE) || implementsInterfaceOrIsSubclassOf(testClass, LIST_TYPE)) {
                 if (visitor != null) {
+                    ClassNode propertyType = OBJECT_TYPE;
+                    if (implementsInterfaceOrIsSubclassOf(objectExpressionType, MAP_TYPE)) {
+                        ClassNode intf = GenericsUtils.parameterizeType(objectExpressionType, MAP_TYPE.getPlainNodeReference());
+                        if (intf.isUsingGenerics() && intf.getGenericsTypes()!=null && intf.getGenericsTypes().length==2) {
+                            // should normally be the case
+                            propertyType = intf.getGenericsTypes()[1].getType(); // 0 is the key, 1 is the value
+                        }
+                    } else {
+                        // list type
+                        ClassNode intf = GenericsUtils.parameterizeType(objectExpressionType, LIST_TYPE.getPlainNodeReference());
+                        if (intf.isUsingGenerics() && intf.getGenericsTypes()!=null && intf.getGenericsTypes().length==1) {
+                            PropertyExpression subExp = new PropertyExpression(
+                                    new VariableExpression("{}", intf.getGenericsTypes()[0].getType()),
+                                    pexp.getPropertyAsString()
+                            );
+                            AtomicReference<ClassNode> result = new AtomicReference<ClassNode>();
+                            if (existsProperty(subExp, checkForReadOnly, new PropertyLookupVisitor(result))) {
+                                intf.setGenericsTypes(new GenericsType[] { new GenericsType(getWrapper(result.get()))});
+                                propertyType = intf;
+                            }
+                        }
+                    }
                     // todo : type inferrence on maps and lists, if possible
-                    PropertyNode node = new PropertyNode(propertyName, Opcodes.ACC_PUBLIC, OBJECT_TYPE, clazz, null, null, null);
+                    PropertyNode node = new PropertyNode(propertyName, Opcodes.ACC_PUBLIC, propertyType, objectExpressionType, null, null, null);
                     visitor.visitProperty(node);
                 }
                 return true;
diff --git a/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy b/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy
index 6dd9683e2a..1fac001991 100644
--- a/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy
+++ b/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy
@@ -311,6 +311,35 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
             '''
     }
 
+    // GROOVY-5700
+    void testInferenceOfMapDotProperty() {
+        assertScript '''
+            def m = [retries: 10]
+            @ASTTest(phase=INSTRUCTION_SELECTION, value={
+                assert node.getNodeMetaData(INFERRED_TYPE) == Integer_TYPE
+            })
+            def r1 = m['retries']
+
+            @ASTTest(phase=INSTRUCTION_SELECTION, value={
+                assert node.getNodeMetaData(INFERRED_TYPE) == Integer_TYPE
+            })
+            def r2 = m.retries
+        '''
+    }
+
+    void testInferenceOfListDotProperty() {
+        assertScript '''class Foo { int x }
+            def list = [new Foo(x:1), new Foo(x:2)]
+            @ASTTest(phase=INSTRUCTION_SELECTION, value={
+                def iType = node.getNodeMetaData(INFERRED_TYPE)
+                assert iType == make(List)
+                assert iType.isUsingGenerics()
+                assert iType.genericsTypes[0].type == Integer_TYPE
+            })
+            def r2 = list.x
+            assert r2 == [ 1,2 ]
+        '''
+    }
 
     public static class BaseClass {
         int x
