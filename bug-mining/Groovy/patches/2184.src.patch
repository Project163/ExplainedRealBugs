diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 1b1a19dffa..368dc2d72c 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -284,11 +284,17 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             if (vexp.getName().equals("this")) storeType(vexp, typeCheckingContext.getEnclosingClassNode());
             if (vexp.getName().equals("super")) storeType(vexp, typeCheckingContext.getEnclosingClassNode().getSuperClass());
             if (typeCheckingContext.getEnclosingClosure() != null) {
-                if (vexp.getName().equals("owner")
-                        || vexp.getName().equals("delegate")
-                        || vexp.getName().equals("thisObject")) {
+                if (vexp.getName().equals("owner") || vexp.getName().equals("thisObject")) {
                     storeType(vexp, typeCheckingContext.getEnclosingClassNode());
                     return;
+                } else if ("delegate".equals(vexp.getName())) {
+                    DelegationMetadata md = getDelegationMetadata(typeCheckingContext.getEnclosingClosure().getClosureExpression());
+                    ClassNode type = typeCheckingContext.getEnclosingClassNode();
+                    if (md!=null) {
+                        type = md.getType();
+                    }
+                    storeType(vexp, type);
+                    return;
                 }
             }
         }
@@ -2113,6 +2119,13 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                             returnType = irtg != null && implementsInterfaceOrIsSubclassOf(irtg, returnType) ? irtg : returnType;
                             callArgsVisited = true;
                         }
+                        if (directMethodCallCandidate==GET_DELEGATE && typeCheckingContext.getEnclosingClosure()!=null) {
+                            DelegationMetadata md = getDelegationMetadata(typeCheckingContext.getEnclosingClosure().getClosureExpression());
+                            returnType = typeCheckingContext.getEnclosingClassNode();
+                            if (md!=null) {
+                                returnType = md.getType();
+                            }
+                        }
                         storeType(call, returnType);
                         storeTargetMethod(call, directMethodCallCandidate);
                         String data = chosenReceiver!=null?chosenReceiver.getData():null;
@@ -2121,7 +2134,6 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                             // so we store the information so that the static compiler may reuse it
                             call.putNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER, data);
                         }
-
                         // if the object expression is a closure shared variable, we will have to perform a second pass
                         if (objectExpression instanceof VariableExpression) {
                             VariableExpression var = (VariableExpression) objectExpression;
diff --git a/src/test/groovy/transform/stc/DelegatesToSTCTest.groovy b/src/test/groovy/transform/stc/DelegatesToSTCTest.groovy
index c7e1be3d25..c97bd33ae6 100644
--- a/src/test/groovy/transform/stc/DelegatesToSTCTest.groovy
+++ b/src/test/groovy/transform/stc/DelegatesToSTCTest.groovy
@@ -437,4 +437,46 @@ class DelegatesToSTCTest extends StaticTypeCheckingTestCase {
             test()
         '''
     }
+
+    // GROOVY-6091
+    void testExplicitUseOfDelegateProperty() {
+        assertScript '''
+            def with(@DelegatesTo.Target Object target, @DelegatesTo(strategy = Closure.DELEGATE_FIRST) Closure arg) {
+                arg.delegate = target
+                arg.setResolveStrategy(Closure.DELEGATE_FIRST)
+                arg()
+            }
+
+            def test() {
+                def obj = [1, 2]
+                with(obj) {
+                    print(delegate.last()) //error is here
+                }
+            }
+
+            test()
+
+        '''
+    }
+
+    // GROOVY-6091
+    void testExplicitUseOfDelegateMethod() {
+        assertScript '''
+            def with(@DelegatesTo.Target Object target, @DelegatesTo(strategy = Closure.DELEGATE_FIRST) Closure arg) {
+                arg.delegate = target
+                arg.setResolveStrategy(Closure.DELEGATE_FIRST)
+                arg()
+            }
+
+            def test() {
+                def obj = [1, 2]
+                with(obj) {
+                    print(getDelegate().last()) //error is here
+                }
+            }
+
+            test()
+
+        '''
+    }
 }
