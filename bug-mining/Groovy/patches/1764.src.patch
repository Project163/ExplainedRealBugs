diff --git a/src/main/org/codehaus/groovy/classgen/InnerClassCompletionVisitor.java b/src/main/org/codehaus/groovy/classgen/InnerClassCompletionVisitor.java
index af55356f9a..7c02aa3dc7 100644
--- a/src/main/org/codehaus/groovy/classgen/InnerClassCompletionVisitor.java
+++ b/src/main/org/codehaus/groovy/classgen/InnerClassCompletionVisitor.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2010 the original author or authors.
+ * Copyright 2003-2012 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -17,33 +17,68 @@ package org.codehaus.groovy.classgen;
 
 import org.codehaus.groovy.ast.ClassHelper;
 import org.codehaus.groovy.ast.ClassNode;
+import org.codehaus.groovy.ast.ConstructorNode;
+import org.codehaus.groovy.ast.FieldNode;
 import org.codehaus.groovy.ast.InnerClassNode;
 import org.codehaus.groovy.ast.MethodNode;
 import org.codehaus.groovy.ast.Parameter;
 import org.codehaus.groovy.ast.expr.ClassExpression;
+import org.codehaus.groovy.ast.expr.ConstructorCallExpression;
+import org.codehaus.groovy.ast.expr.Expression;
+import org.codehaus.groovy.ast.expr.TupleExpression;
 import org.codehaus.groovy.ast.expr.VariableExpression;
 import org.codehaus.groovy.ast.stmt.BlockStatement;
+import org.codehaus.groovy.ast.stmt.ExpressionStatement;
+import org.codehaus.groovy.ast.stmt.Statement;
 import org.codehaus.groovy.classgen.asm.BytecodeHelper;
+import org.codehaus.groovy.control.CompilationUnit;
+import org.codehaus.groovy.control.SourceUnit;
 import org.objectweb.asm.MethodVisitor;
 import org.objectweb.asm.Opcodes;
 
-import static org.objectweb.asm.Opcodes.*;
-import static org.codehaus.groovy.classgen.InnerClassVisitorHelper.*;
+import java.util.List;
 
-public class InnerClassCompletionVisitor {
+public class InnerClassCompletionVisitor extends InnerClassVisitorHelper implements Opcodes {
 
+    private final SourceUnit sourceUnit;
+    private ClassNode classNode;
+    private FieldNode thisField = null;
+
+    public InnerClassCompletionVisitor(CompilationUnit cu, SourceUnit su) {
+        sourceUnit = su;
+    }
+
+    @Override
+    protected SourceUnit getSourceUnit() {
+        return sourceUnit;
+    }
+
+    @Override
     public void visitClass(ClassNode node) {
+        this.classNode = node;
+        thisField = null;
         InnerClassNode innerClass = null;
         if (!node.isEnum() && !node.isInterface() && node instanceof InnerClassNode) {
             innerClass = (InnerClassNode) node;
+            thisField = innerClass.getField("this$0");
+            if (innerClass.getVariableScope() == null && innerClass.getDeclaredConstructors().isEmpty()) {
+                // add dummy constructor
+                innerClass.addConstructor(ACC_PUBLIC, new Parameter[0], null, null);
+            }
         }
         if (node.isEnum() || node.isInterface()) return;
         addDispatcherMethods(node);
         if (innerClass == null) return;
-
+        super.visitClass(node);
         addDefaultMethods(innerClass);
     }
 
+    @Override
+    public void visitConstructor(ConstructorNode node) {
+        addThisReference(node);
+        super.visitConstructor(node);
+    }
+
     private String getTypeDescriptor(ClassNode node, boolean isStatic) {
         return BytecodeHelper.getTypeDescription(getClassNode(node, isStatic));
     }
@@ -227,4 +262,111 @@ public class InnerClassCompletionVisitor {
         }
         method.setCode(block);
     }
+
+    private boolean shouldHandleImplicitThisForInnerClass(ClassNode cn) {
+        if (cn.isEnum() || cn.isInterface()) return false;
+        if ((cn.getModifiers() & Opcodes.ACC_STATIC) != 0) return false;
+        if (!(cn instanceof InnerClassNode)) return false;
+        InnerClassNode innerClass = (InnerClassNode) cn;
+        // scope != null means aic, we don't handle that here
+        if (innerClass.getVariableScope() != null) return false;
+        // static inner classes don't need this$0
+        return (innerClass.getModifiers() & ACC_STATIC) == 0;
+    }
+
+    private void addThisReference(ConstructorNode node) {
+        if (!shouldHandleImplicitThisForInnerClass(classNode)) return;
+        Statement code = node.getCode();
+
+        // add "this$0" field init
+
+        //add this parameter to node
+        Parameter[] params = node.getParameters();
+        Parameter[] newParams = new Parameter[params.length + 1];
+        System.arraycopy(params, 0, newParams, 1, params.length);
+        String name = getUniqueName(params, node);
+
+        Parameter thisPara = new Parameter(classNode.getOuterClass().getPlainNodeReference(), name);
+        newParams[0] = thisPara;
+        node.setParameters(newParams);
+
+        BlockStatement block = null;
+        if (code == null) {
+            block = new BlockStatement();
+        } else if (!(code instanceof BlockStatement)) {
+            block = new BlockStatement();
+            block.addStatement(code);
+        } else {
+            block = (BlockStatement) code;
+        }
+        BlockStatement newCode = new BlockStatement();
+        addFieldInit(thisPara, thisField, newCode);
+        ConstructorCallExpression cce = getFirstIfSpecialConstructorCall(block);
+        if (cce == null) {
+            cce = new ConstructorCallExpression(ClassNode.SUPER, new TupleExpression());
+            block.getStatements().add(0, new ExpressionStatement(cce));
+        }
+        if (shouldImplicitlyPassThisPara(cce)) {
+            // add thisPara to this(...)
+            TupleExpression args = (TupleExpression) cce.getArguments();
+            List<Expression> expressions = args.getExpressions();
+            VariableExpression ve = new VariableExpression(thisPara.getName());
+            ve.setAccessedVariable(thisPara);
+            expressions.add(0, ve);
+        }
+        if (cce.isSuperCall()) {
+            // we have a call to super here, so we need to add
+            // our code after that
+            block.getStatements().add(1, newCode);
+        }
+        node.setCode(block);
+    }
+
+    private boolean shouldImplicitlyPassThisPara(ConstructorCallExpression cce) {
+        boolean pass = false;
+        ClassNode superCN = classNode.getSuperClass();
+        if (cce.isThisCall()) {
+            pass = true;
+        } else if (cce.isSuperCall()) {
+            // if the super class is another non-static inner class in the same outer class hierarchy, implicit this
+            // needs to be passed
+            if (!superCN.isEnum() && !superCN.isInterface() && superCN instanceof InnerClassNode) {
+                InnerClassNode superInnerCN = (InnerClassNode) superCN;
+                if (!isStatic(superInnerCN) && classNode.getOuterClass().isDerivedFrom(superCN.getOuterClass())) {
+                    pass = true;
+                }
+            }
+        }
+        return pass;
+    }
+
+    private String getUniqueName(Parameter[] params, ConstructorNode node) {
+        String namePrefix = "$p";
+        outer:
+        for (int i = 0; i < 100; i++) {
+            namePrefix = namePrefix + "$";
+            for (Parameter p : params) {
+                if (p.getName().equals(namePrefix)) continue outer;
+            }
+            return namePrefix;
+        }
+        addError("unable to find a unique prefix name for synthetic this reference in inner class constructor", node);
+        return namePrefix;
+    }
+
+    private ConstructorCallExpression getFirstIfSpecialConstructorCall(BlockStatement code) {
+        if (code == null) return null;
+
+        final List<Statement> statementList = code.getStatements();
+        if (statementList.isEmpty()) return null;
+
+        final Statement statement = statementList.get(0);
+        if (!(statement instanceof ExpressionStatement)) return null;
+
+        Expression expression = ((ExpressionStatement) statement).getExpression();
+        if (!(expression instanceof ConstructorCallExpression)) return null;
+        ConstructorCallExpression cce = (ConstructorCallExpression) expression;
+        if (cce.isSpecialCall()) return cce;
+        return null;
+    }
 }
diff --git a/src/main/org/codehaus/groovy/classgen/InnerClassVisitor.java b/src/main/org/codehaus/groovy/classgen/InnerClassVisitor.java
index 673de5e70b..e755ba2c4a 100644
--- a/src/main/org/codehaus/groovy/classgen/InnerClassVisitor.java
+++ b/src/main/org/codehaus/groovy/classgen/InnerClassVisitor.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2010 the original author or authors.
+ * Copyright 2003-2012 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -15,21 +15,23 @@
  */
 package org.codehaus.groovy.classgen;
 
-import org.codehaus.groovy.ast.*;
-import org.codehaus.groovy.ast.expr.BinaryExpression;
+import org.codehaus.groovy.ast.ClassHelper;
+import org.codehaus.groovy.ast.ClassNode;
+import org.codehaus.groovy.ast.FieldNode;
+import org.codehaus.groovy.ast.InnerClassNode;
+import org.codehaus.groovy.ast.MethodNode;
+import org.codehaus.groovy.ast.Parameter;
+import org.codehaus.groovy.ast.PropertyNode;
+import org.codehaus.groovy.ast.VariableScope;
 import org.codehaus.groovy.ast.expr.ConstructorCallExpression;
 import org.codehaus.groovy.ast.expr.Expression;
-import org.codehaus.groovy.ast.expr.FieldExpression;
 import org.codehaus.groovy.ast.expr.PropertyExpression;
 import org.codehaus.groovy.ast.expr.TupleExpression;
 import org.codehaus.groovy.ast.expr.VariableExpression;
 import org.codehaus.groovy.ast.stmt.BlockStatement;
 import org.codehaus.groovy.ast.stmt.ExpressionStatement;
-import org.codehaus.groovy.ast.stmt.Statement;
 import org.codehaus.groovy.control.CompilationUnit;
 import org.codehaus.groovy.control.SourceUnit;
-import org.codehaus.groovy.syntax.Token;
-import org.codehaus.groovy.syntax.Types;
 import org.objectweb.asm.Opcodes;
 
 import java.util.ArrayList;
@@ -60,18 +62,11 @@ public class InnerClassVisitor extends InnerClassVisitorHelper implements Opcode
         this.classNode = node;
         thisField = null;
         InnerClassNode innerClass = null;
-        if (!node.isEnum() && !node.isInterface() &&
-                node instanceof InnerClassNode) {
+        if (!node.isEnum() && !node.isInterface() && node instanceof InnerClassNode) {
             innerClass = (InnerClassNode) node;
             if (!isStatic(innerClass) && innerClass.getVariableScope() == null) {
                 thisField = innerClass.addField("this$0", PUBLIC_SYNTHETIC, node.getOuterClass().getPlainNodeReference(), null);
             }
-
-            if (innerClass.getVariableScope() == null &&
-                    innerClass.getDeclaredConstructors().isEmpty()) {
-                // add dummy constructor
-                innerClass.addConstructor(ACC_PUBLIC, new Parameter[0], null, null);
-            }
         }
 
         super.visitClass(node);
@@ -92,12 +87,6 @@ public class InnerClassVisitor extends InnerClassVisitorHelper implements Opcode
         processingObjInitStatements = false;
     }
 
-    @Override
-    public void visitConstructor(ConstructorNode node) {
-        addThisReference(node);
-        super.visitConstructor(node);
-    }
-
     private boolean shouldHandleImplicitThisForInnerClass(ClassNode cn) {
         if (cn.isEnum() || cn.isInterface()) return false;
         if ((cn.getModifiers() & Opcodes.ACC_STATIC) != 0) return false;
@@ -107,103 +96,7 @@ public class InnerClassVisitor extends InnerClassVisitorHelper implements Opcode
         // scope != null means aic, we don't handle that here
         if (innerClass.getVariableScope() != null) return false;
         // static inner classes don't need this$0
-        if ((innerClass.getModifiers() & ACC_STATIC) != 0) return false;
-
-        return true;
-    }
-
-    private void addThisReference(ConstructorNode node) {
-        if (!shouldHandleImplicitThisForInnerClass(classNode)) return;
-        Statement code = node.getCode();
-
-        // add "this$0" field init
-
-        //add this parameter to node
-        Parameter[] params = node.getParameters();
-        Parameter[] newParams = new Parameter[params.length + 1];
-        System.arraycopy(params, 0, newParams, 1, params.length);
-        Parameter thisPara = new Parameter(classNode.getOuterClass().getPlainNodeReference(), getUniqueName(params, node));
-        newParams[0] = thisPara;
-        node.setParameters(newParams);
-
-        BlockStatement block = null;
-        if (code == null) {
-            block = new BlockStatement();
-        } else if (!(code instanceof BlockStatement)) {
-            block = new BlockStatement();
-            block.addStatement(code);
-        } else {
-            block = (BlockStatement) code;
-        }
-        BlockStatement newCode = new BlockStatement();
-        addFieldInit(thisPara, thisField, newCode);
-        ConstructorCallExpression cce = getFirstIfSpecialConstructorCall(block);
-        if (cce == null) {
-            cce = new ConstructorCallExpression(ClassNode.SUPER, new TupleExpression());
-            block.getStatements().add(0, new ExpressionStatement(cce));
-        }
-        if (shouldImplicitlyPassThisPara(cce)) {
-            // add thisPara to this(...)
-            TupleExpression args = (TupleExpression) cce.getArguments();
-            List<Expression> expressions = args.getExpressions();
-            VariableExpression ve = new VariableExpression(thisPara.getName());
-            ve.setAccessedVariable(thisPara);
-            expressions.add(0, ve);
-        }
-        if (cce.isSuperCall()) {
-            // we have a call to super here, so we need to add 
-            // our code after that
-            block.getStatements().add(1, newCode);
-        }
-        node.setCode(block);
-    }
-
-    private boolean shouldImplicitlyPassThisPara(ConstructorCallExpression cce) {
-        boolean pass = false;
-        ClassNode superCN = classNode.getSuperClass();
-        if (cce.isThisCall()) {
-            pass = true;
-        } else if (cce.isSuperCall()) {
-            // if the super class is another non-static inner class in the same outer class hierarchy, implicit this
-            // needs to be passed
-            if (!superCN.isEnum() && !superCN.isInterface() && superCN instanceof InnerClassNode) {
-                InnerClassNode superInnerCN = (InnerClassNode) superCN;
-                if (!isStatic(superInnerCN) && classNode.getOuterClass().isDerivedFrom(superCN.getOuterClass())) {
-                    pass = true;
-                }
-            }
-        }
-        return pass;
-    }
-
-    private String getUniqueName(Parameter[] params, ConstructorNode node) {
-        String namePrefix = "$p";
-        outer:
-        for (int i = 0; i < 100; i++) {
-            namePrefix = namePrefix + "$";
-            for (Parameter p : params) {
-                if (p.getName().equals(namePrefix)) continue outer;
-            }
-            return namePrefix;
-        }
-        addError("unable to find a unique prefix name for synthetic this reference", node);
-        return namePrefix;
-    }
-
-    private ConstructorCallExpression getFirstIfSpecialConstructorCall(BlockStatement code) {
-        if (code == null) return null;
-
-        final List<Statement> statementList = code.getStatements();
-        if (statementList.isEmpty()) return null;
-
-        final Statement statement = statementList.get(0);
-        if (!(statement instanceof ExpressionStatement)) return null;
-
-        Expression expression = ((ExpressionStatement) statement).getExpression();
-        if (!(expression instanceof ConstructorCallExpression)) return null;
-        ConstructorCallExpression cce = (ConstructorCallExpression) expression;
-        if (cce.isSpecialCall()) return cce;
-        return null;
+        return (innerClass.getModifiers() & ACC_STATIC) == 0;
     }
 
     @Override
@@ -357,16 +250,4 @@ public class InnerClassVisitor extends InnerClassVisitorHelper implements Opcode
             argsListExp.getExpressions().add(0, this0);
         }
     }
-
-    private static void addFieldInit(Parameter p, FieldNode fn, BlockStatement block) {
-        VariableExpression ve = new VariableExpression(p);
-        FieldExpression fe = new FieldExpression(fn);
-        block.addStatement(new ExpressionStatement(
-                new BinaryExpression(
-                        fe,
-                        Token.newSymbol(Types.ASSIGN, -1, -1),
-                        ve
-                )
-        ));
-    }
 }
diff --git a/src/main/org/codehaus/groovy/classgen/InnerClassVisitorHelper.java b/src/main/org/codehaus/groovy/classgen/InnerClassVisitorHelper.java
index 7cddc68ca3..59658536e9 100644
--- a/src/main/org/codehaus/groovy/classgen/InnerClassVisitorHelper.java
+++ b/src/main/org/codehaus/groovy/classgen/InnerClassVisitorHelper.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2010 the original author or authors.
+ * Copyright 2003-2012 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -18,6 +18,7 @@ package org.codehaus.groovy.classgen;
 import org.codehaus.groovy.ast.ClassCodeVisitorSupport;
 import org.codehaus.groovy.ast.ClassHelper;
 import org.codehaus.groovy.ast.ClassNode;
+import org.codehaus.groovy.ast.FieldNode;
 import org.codehaus.groovy.ast.InnerClassNode;
 import org.codehaus.groovy.ast.Parameter;
 import org.codehaus.groovy.ast.VariableScope;
@@ -43,10 +44,7 @@ public abstract class InnerClassVisitorHelper extends ClassCodeVisitorSupport {
                 new ReturnStatement(
                         new AttributeExpression(
                                 thiz,
-                                new GStringExpression("$name",
-                                        gStringStrings,
-                                        gStringValues
-                                )
+                                new GStringExpression("$name", gStringStrings, gStringValues)
                         )
                 )
         );
@@ -63,10 +61,7 @@ public abstract class InnerClassVisitorHelper extends ClassCodeVisitorSupport {
                         new BinaryExpression(
                                 new AttributeExpression(
                                         thiz,
-                                        new GStringExpression("$name",
-                                                gStringStrings,
-                                                gStringValues
-                                        )
+                                        new GStringExpression("$name", gStringStrings, gStringValues)
                                 ),
                                 Token.newSymbol(Types.ASSIGN, -1, -1),
                                 new VariableExpression(parameters[1])
@@ -85,10 +80,7 @@ public abstract class InnerClassVisitorHelper extends ClassCodeVisitorSupport {
                 new ReturnStatement(
                         new MethodCallExpression(
                                 thiz,
-                                new GStringExpression("$name",
-                                        gStringStrings,
-                                        gStringValues
-                                ),
+                                new GStringExpression("$name", gStringStrings, gStringValues),
                                 new ArgumentListExpression(
                                         new SpreadExpression(new VariableExpression(parameters[1]))
                                 )
@@ -116,4 +108,12 @@ public abstract class InnerClassVisitorHelper extends ClassCodeVisitorSupport {
         }
         return count;
     }
+
+    protected static void addFieldInit(Parameter p, FieldNode fn, BlockStatement block) {
+        VariableExpression ve = new VariableExpression(p);
+        FieldExpression fe = new FieldExpression(fn);
+        block.addStatement(new ExpressionStatement(
+                new BinaryExpression(fe, Token.newSymbol(Types.ASSIGN, -1, -1), ve)
+        ));
+    }
 }
diff --git a/src/main/org/codehaus/groovy/control/CompilationUnit.java b/src/main/org/codehaus/groovy/control/CompilationUnit.java
index b51de8c421..60be774907 100644
--- a/src/main/org/codehaus/groovy/control/CompilationUnit.java
+++ b/src/main/org/codehaus/groovy/control/CompilationUnit.java
@@ -197,7 +197,7 @@ public class CompilationUnit extends ProcessingUnit {
             @Override
             public void call(SourceUnit source, GeneratorContext context,
                              ClassNode classNode) throws CompilationFailedException {
-                InnerClassCompletionVisitor iv = new InnerClassCompletionVisitor();
+                InnerClassCompletionVisitor iv = new InnerClassCompletionVisitor(CompilationUnit.this, source);
                 iv.visitClass(classNode);
             }
         }, Phases.CANONICALIZATION);
diff --git a/src/main/org/codehaus/groovy/transform/ImmutableASTTransformation.java b/src/main/org/codehaus/groovy/transform/ImmutableASTTransformation.java
index 83cbd16953..85b664b307 100644
--- a/src/main/org/codehaus/groovy/transform/ImmutableASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/ImmutableASTTransformation.java
@@ -25,7 +25,6 @@ import org.codehaus.groovy.ast.ClassHelper;
 import org.codehaus.groovy.ast.ClassNode;
 import org.codehaus.groovy.ast.ConstructorNode;
 import org.codehaus.groovy.ast.FieldNode;
-import org.codehaus.groovy.ast.InnerClassNode;
 import org.codehaus.groovy.ast.Parameter;
 import org.codehaus.groovy.ast.PropertyNode;
 import org.codehaus.groovy.ast.expr.*;
@@ -40,8 +39,14 @@ import org.codehaus.groovy.control.SourceUnit;
 import org.codehaus.groovy.runtime.DefaultGroovyMethods;
 import org.codehaus.groovy.runtime.InvokerHelper;
 
-import java.lang.reflect.Modifier;
-import java.util.*;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
 
 import static org.codehaus.groovy.transform.AbstractASTTransformUtil.*;
 import static org.codehaus.groovy.transform.EqualsAndHashCodeASTTransformation.createEquals;
@@ -265,12 +270,6 @@ public class ImmutableASTTransformation extends AbstractASTTransformation {
     }
 
     private boolean validateConstructors(ClassNode cNode) {
-        if(cNode instanceof InnerClassNode && Modifier.isStatic(cNode.getModifiers())) {
-            List<ConstructorNode> constructors = cNode.getDeclaredConstructors();
-            if (constructors.size() == 1 && constructors.get(0).getCode() == null) {
-                constructors.remove(0);
-            }
-        }
         if (cNode.getDeclaredConstructors().size() != 0) {
             // TODO: allow constructors which only call provided constructor?
             addError("Explicit constructors not allowed for " + ImmutableASTTransformation.MY_TYPE_NAME + " class: " + cNode.getNameWithoutPackage(), cNode.getDeclaredConstructors().get(0));
diff --git a/src/test/org/codehaus/groovy/transform/ImmutableTransformTest.groovy b/src/test/org/codehaus/groovy/transform/ImmutableTransformTest.groovy
index 01887f4337..5b024a1197 100644
--- a/src/test/org/codehaus/groovy/transform/ImmutableTransformTest.groovy
+++ b/src/test/org/codehaus/groovy/transform/ImmutableTransformTest.groovy
@@ -410,16 +410,23 @@ class ImmutableTransformTest extends GroovyShellTestCase {
             assert new Person1("Hamlet", "D'Arcy").toString() == "Person1(Hamlet, D'Arcy)"
             assert new Person2(first: "Hamlet", last: "D'Arcy").toString() == "Person2(first:Hamlet, last:D'Arcy)"
             assert new Person3("Hamlet", "D'Arcy").toString() == "Person3(Hamlet)"
-            '''
+        '''
     }
 
-    void testImmutableUsageOnStaticInnerClasses() {
-        shell.parse '''
+    void testImmutableUsageOnInnerClasses() {
+        assertScript '''
             import groovy.transform.Immutable
             class A4997 {
                 @Immutable
-                static class B4997 {}
+                static class B4997 { String name }
+                @Immutable
+                class C4997 { String name }
+                def test() {
+                    assert new C4997(name: 'foo').toString() == 'A4997$C4997(foo)'
+                }
             }
-            '''
+            assert new A4997.B4997(name: 'bar').toString() == 'A4997$B4997(bar)'
+            new A4997().test()
+        '''
     }
 }
diff --git a/src/test/org/codehaus/groovy/transform/InheritConstructorsTransformTest.groovy b/src/test/org/codehaus/groovy/transform/InheritConstructorsTransformTest.groovy
index 7d9e8e22ba..a322b95728 100644
--- a/src/test/org/codehaus/groovy/transform/InheritConstructorsTransformTest.groovy
+++ b/src/test/org/codehaus/groovy/transform/InheritConstructorsTransformTest.groovy
@@ -57,4 +57,33 @@ class InheritConstructorsTransformTest extends GroovyShellTestCase {
         """
     }
 
+    void testInnerClassUsage() {
+        assertScript """
+            import groovy.transform.InheritConstructors
+            @InheritConstructors
+            class Outer extends RuntimeException {
+                @InheritConstructors
+                class Inner extends RuntimeException {}
+                @InheritConstructors
+                static class StaticInner extends RuntimeException {}
+                void test() {
+                    assert new StaticInner('bar').message == 'bar'
+                    assert new Inner('foo').message == 'foo'
+                }
+            }
+            class Outer2 extends Outer {
+                @InheritConstructors
+                class Inner2 extends Outer.Inner {}
+                void test() {
+                    assert new Inner2('foobar').message == 'foobar'
+                }
+            }
+
+            def o = new Outer('baz')
+            assert o.message == 'baz'
+            o.test()
+            new Outer2().test()
+        """
+    }
+
 }
\ No newline at end of file
