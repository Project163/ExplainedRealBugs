diff --git a/src/main/groovy/lang/ExpandoMetaClass.java b/src/main/groovy/lang/ExpandoMetaClass.java
index 73996b4b95..afc41bf260 100644
--- a/src/main/groovy/lang/ExpandoMetaClass.java
+++ b/src/main/groovy/lang/ExpandoMetaClass.java
@@ -1311,6 +1311,14 @@ public class ExpandoMetaClass extends MetaClassImpl implements GroovyObject {
             return new PogoMetaClassSite(site, this);
         return super.createPogoCallCurrentSite(site, sender, args);
     }
+    
+    @Override
+    public MetaMethod retrieveConstructor(Object[] args) {
+        Class[] params = MetaClassHelper.convertToTypeArray(args);
+        MetaMethod method = pickMethod(GROOVY_CONSTRUCTOR, params);
+        if (method!=null) return method;
+        return super.retrieveConstructor(args);
+    }
 
     public CallSite createConstructorSite(CallSite site, Object[] args) {
         Class[] params = MetaClassHelper.convertToTypeArray(args);
diff --git a/src/main/groovy/lang/MetaClassImpl.java b/src/main/groovy/lang/MetaClassImpl.java
index 2c500cf090..058ae7e544 100644
--- a/src/main/groovy/lang/MetaClassImpl.java
+++ b/src/main/groovy/lang/MetaClassImpl.java
@@ -1501,7 +1501,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
      * @author <a href="mailto:blackdrag@gmx.org">Jochen "blackdrag" Theodorou</a> 
      * @since Groovy 2.1.0
      */
-    public final MetaMethod retrieveConstructor(Object[] arguments) {
+    public MetaMethod retrieveConstructor(Object[] arguments) {
         checkInitalised();
         if (arguments == null) arguments = EMPTY_ARGUMENTS;
         Class[] argClasses = MetaClassHelper.convertToTypeArray(arguments);
diff --git a/src/main/org/codehaus/groovy/vmplugin/v7/Selector.java b/src/main/org/codehaus/groovy/vmplugin/v7/Selector.java
index 2cc854faaa..2e63705c82 100644
--- a/src/main/org/codehaus/groovy/vmplugin/v7/Selector.java
+++ b/src/main/org/codehaus/groovy/vmplugin/v7/Selector.java
@@ -16,6 +16,7 @@
 package org.codehaus.groovy.vmplugin.v7;
 
 import groovy.lang.AdaptingMetaClass;
+import groovy.lang.ExpandoMetaClass;
 import groovy.lang.GroovyInterceptable;
 import groovy.lang.GroovyObject;
 import groovy.lang.GroovyRuntimeException;
@@ -41,6 +42,7 @@ import org.codehaus.groovy.GroovyBugError;
 import org.codehaus.groovy.reflection.CachedField;
 import org.codehaus.groovy.reflection.CachedMethod;
 import org.codehaus.groovy.reflection.ClassInfo;
+import org.codehaus.groovy.runtime.GeneratedClosure;
 import org.codehaus.groovy.runtime.NullObject;
 import org.codehaus.groovy.runtime.GroovyCategorySupport.CategoryMethod;
 import org.codehaus.groovy.runtime.dgmimpl.NumberNumberMetaMethod;
@@ -231,7 +233,6 @@ public abstract class Selector {
         public void chooseMeta(MetaClassImpl mci) {
             if (mci==null) return;
             if (LOG_ENABLED) LOG.info("getting constructor");
-
             Object[] newArgs = removeRealReceiver(args);
             method = mci.retrieveConstructor(newArgs);
             if (method instanceof MetaConstructor) {
@@ -278,7 +279,9 @@ public abstract class Selector {
                 }
                 handle = MethodHandles.foldArguments(con, handle.asType(foldTargetType));
             }
-            handle = MethodHandles.dropArguments(handle, 0, Class.class);
+            if (method instanceof MetaConstructor) {
+                handle = MethodHandles.dropArguments(handle, 0, Class.class);
+            }
         }
 
         /**
@@ -407,7 +410,9 @@ public abstract class Selector {
                 if (LOG_ENABLED) LOG.info("receiver is a class");
                 method = mci.retrieveStaticMethod(name, newArgs);
             } else {
-                method = mci.getMethodWithCaching(selectionBase, name, newArgs, false);
+                String changedName = name;
+                if (receiver instanceof GeneratedClosure && changedName.equals("call")) {changedName = "doCall";}
+                method = mci.getMethodWithCaching(selectionBase, changedName, newArgs, false);
             }
             if (LOG_ENABLED) LOG.info("retrieved method from meta class: "+method);
         }
@@ -794,7 +799,7 @@ public abstract class Selector {
                 getMetaClass();
                 if (LOG_ENABLED) LOG.info("meta class is "+mc);
                 setSelectionBase();
-                MetaClassImpl mci = getMetaClassImpl(mc);
+                MetaClassImpl mci = getMetaClassImpl(mc, callType != CALL_TYPES.GET);
                 chooseMeta(mci);
                 setHandleForMetaMethod();
                 setMetaClassCallHandleIfNedded(mci!=null);
@@ -850,11 +855,12 @@ public abstract class Selector {
      * MetaClassImpl, AdaptingMetaClass or ClosureMetaClass. If
      * none of these cases matches, this method returns null.
      */
-    private static MetaClassImpl getMetaClassImpl(MetaClass mc) {
+    private static MetaClassImpl getMetaClassImpl(MetaClass mc, boolean includeEMC) {
         Class mcc = mc.getClass();
         boolean valid = mcc == MetaClassImpl.class ||
                          mcc == AdaptingMetaClass.class ||
-                         mcc == ClosureMetaClass.class;
+                         mcc == ClosureMetaClass.class ||
+                         (includeEMC && mcc == ExpandoMetaClass.class);
         if (!valid) {
             if (LOG_ENABLED) LOG.info("meta class is neither MetaClassImpl, nor AdoptingMetaClass, nor ClosureMetaClass, normal method selection path disabled.");
             return null;
