diff --git a/src/main/org/codehaus/groovy/control/StaticImportVisitor.java b/src/main/org/codehaus/groovy/control/StaticImportVisitor.java
index e98e22d552..e055ebb184 100644
--- a/src/main/org/codehaus/groovy/control/StaticImportVisitor.java
+++ b/src/main/org/codehaus/groovy/control/StaticImportVisitor.java
@@ -49,8 +49,10 @@ import org.codehaus.groovy.ast.expr.VariableExpression;
 import org.codehaus.groovy.ast.stmt.Statement;
 import org.codehaus.groovy.syntax.Types;
 
+import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 
 import static org.codehaus.groovy.ast.tools.ClassNodeUtils.getPropNameForAccessor;
 import static org.codehaus.groovy.ast.tools.ClassNodeUtils.hasPossibleStaticMethod;
@@ -232,7 +234,7 @@ public class StaticImportVisitor extends ClassCodeExpressionTransformer {
                 ClassExpression ce = (ClassExpression) pe.getObjectExpression();
                 ClassNode type = ce.getType();
                 if (type.isEnum()) return exp;
-                Expression constant = findConstant(type.getField(pe.getPropertyAsString()));
+                Expression constant = findConstant(getField(type, pe.getPropertyAsString()));
                 if (constant != null) return constant;
             }
         } else if (exp instanceof ListExpression) {
@@ -568,13 +570,31 @@ public class StaticImportVisitor extends ClassCodeExpressionTransformer {
 
     private static Expression findStaticField(ClassNode staticImportType, String fieldName) {
         if (staticImportType.isPrimaryClassNode() || staticImportType.isResolved()) {
-            FieldNode field = staticImportType.getField(fieldName);
+            FieldNode field = getField(staticImportType, fieldName);
             if (field != null && field.isStatic())
                 return new PropertyExpression(new ClassExpression(staticImportType), fieldName);
         }
         return null;
     }
 
+    private static FieldNode getField(ClassNode classNode, String fieldName) {
+        ClassNode node = classNode;
+        Set<String> visited = new HashSet<String>();
+        while (node != null) {
+            FieldNode fn = node.getDeclaredField(fieldName);
+            if (fn != null) return fn;
+            ClassNode[] interfaces = node.getInterfaces();
+            for (ClassNode iNode : interfaces) {
+                if (visited.contains(iNode.getName())) continue;
+                FieldNode ifn = getField(iNode, fieldName);
+                visited.add(iNode.getName());
+                if (ifn != null) return ifn;
+            }
+            node = node.getSuperClass();
+        }
+        return null;
+    }
+
     private static Expression findStaticMethod(ClassNode staticImportType, String methodName, Expression args) {
         if (staticImportType.isPrimaryClassNode() || staticImportType.isResolved()) {
             if (staticImportType.hasPossibleStaticMethod(methodName, args)) {
diff --git a/src/test/groovy/bugs/Groovy6764Bug.groovy b/src/test/groovy/bugs/Groovy6764Bug.groovy
new file mode 100644
index 0000000000..c33c791d6e
--- /dev/null
+++ b/src/test/groovy/bugs/Groovy6764Bug.groovy
@@ -0,0 +1,48 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package groovy.bugs
+
+class Groovy6764Bug extends GroovyTestCase {
+    void testStaticImportViaInheritedInterface() {
+        assertScript '''
+            import static Constants.ANSWER as CA
+            import static Helper.ANSWER as HA
+
+            class Foo {
+                static method(arg1 = CA, arg2 = HA) {
+                    assert CA == 42
+                    assert HA == 42
+                    "$arg1 $arg2"
+                }
+                static Closure closure = { arg1 = CA, arg2 = HA ->
+                    assert CA == 42
+                    assert HA == 42
+                    "$arg1 $arg2"
+                }
+            }
+
+            interface ConstantsBase { int ANSWER = 42 }
+            interface Constants extends ConstantsBase {}
+            class Helper implements Constants { }
+
+            assert Foo.closure() == '42 42'
+            assert Foo.method() == '42 42'
+        '''
+    }
+}
