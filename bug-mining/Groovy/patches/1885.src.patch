diff --git a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java
index 2b588398d1..de6e94b306 100644
--- a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java
+++ b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java
@@ -377,20 +377,48 @@ public class StaticInvocationWriter extends InvocationWriter {
                     origMCE.getMethodAsString(),
                     origMCE.getArguments()
             );
-            newMCE.setMethodTarget(origMCE.getMethodTarget());
+            MethodNode methodTarget = origMCE.getMethodTarget();
+            newMCE.setMethodTarget(methodTarget);
             newMCE.setSafe(false);
+            newMCE.setImplicitThis(origMCE.isImplicitThis());
+            newMCE.setSourcePosition(origMCE);
             newMCE.visit(controller.getAcg());
             Label endof = compileStack.createLocalLabel("endof_" + counter);
             mv.visitJumpInsn(GOTO,endof);
             mv.visitLabel(ifnull);
             // else { null }
-            mv.visitInsn(ACONST_NULL);
+            ClassNode returnType = methodTarget.getReturnType();
+            if (ClassHelper.isPrimitiveType(returnType)
+                    && !ClassHelper.VOID_TYPE.equals(returnType)) {
+                pushZero(mv, returnType);
+            } else {
+                mv.visitInsn(ACONST_NULL);
+            }
             mv.visitLabel(endof);
         } else {
             super.makeCall(origin, receiver, message, arguments, adapter, safe, spreadSafe, implicitThis);
         }
     }
 
+    private static void pushZero(final MethodVisitor mv, final ClassNode type) {
+        boolean isInt = ClassHelper.int_TYPE.equals(type);
+        boolean isShort = ClassHelper.short_TYPE.equals(type);
+        boolean isByte = ClassHelper.byte_TYPE.equals(type);
+        if (isInt || isShort || isByte) {
+            mv.visitInsn(ICONST_0);
+        } else if (ClassHelper.long_TYPE.equals(type)) {
+            mv.visitInsn(LCONST_0);
+        } else if (ClassHelper.float_TYPE.equals(type)) {
+            mv.visitInsn(FCONST_0);
+        } else if (ClassHelper.double_TYPE.equals(type)) {
+            mv.visitInsn(DCONST_0);
+        } else if (ClassHelper.boolean_TYPE.equals(type)) {
+            mv.visitInsn(ICONST_0);
+        } else {
+            mv.visitLdcInsn(0);
+        }
+    }
+
     private class CheckcastReceiverExpression extends Expression {
         private final Expression receiver;
         private final MethodNode target;
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/BugsStaticCompileTest.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/BugsStaticCompileTest.groovy
index 97d2f3c979..3bc13392e9 100644
--- a/src/test/org/codehaus/groovy/classgen/asm/sc/BugsStaticCompileTest.groovy
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/BugsStaticCompileTest.groovy
@@ -254,5 +254,54 @@ class BugsStaticCompileTest extends BugsSTCTest {
         assert new Tool().relativePath(a,b) == 'bar/baz'
         '''
     }
+
+    // GROOVY-5613
+    void testNullSafeAssignment() {
+        assertScript '''
+        class A {
+            int x = -1
+        }
+        A a = new A()
+        @ASTTest(phase=INSTRUCTION_SELECTION, value={
+            assert node.getNodeMetaData(INFERRED_TYPE) == int_TYPE
+        })
+        def x = a?.x
+        '''
+    }
+    void testNullSafeAssignmentWithLong() {
+        assertScript '''
+        class A {
+            long x = -1
+        }
+        A a = new A()
+        @ASTTest(phase=INSTRUCTION_SELECTION, value={
+            assert node.getNodeMetaData(INFERRED_TYPE) == long_TYPE
+        })
+        def x = a?.x
+        '''
+    }
+    void testNullSafeAssignmentWithChar() {
+        assertScript '''
+        class A {
+            char x = 'a'
+        }
+        A a = new A()
+        @ASTTest(phase=INSTRUCTION_SELECTION, value={
+            assert node.getNodeMetaData(INFERRED_TYPE) == char_TYPE
+        })
+        def x = a?.x
+        assert x == 'a'
+        '''
+    }
+    void testCallStaticallyImportedMethodWithNullSafeArgument() {
+        assertScript '''import static java.lang.Math.abs
+        class A {
+            int x = -1
+        }
+        def a = new A()
+        def x = a?.x
+        assert abs(a?.x) == 1
+        '''
+    }
 }
 
