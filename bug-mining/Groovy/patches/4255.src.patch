diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index e132713b08..ee72e984bf 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -3611,34 +3611,36 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         }
 
         Parameter[] parameters = selectedMethod.getParameters();
+        final int nthParameter = parameters.length - 1;
 
-        List<Integer> methodReferenceParamIndexList = new LinkedList<>();
-        List<Expression> newArgumentExpressionList = new LinkedList<>();
+        List<Integer> methodReferencePositions = new LinkedList<>();
+        List<Expression> newArgumentExpressions = new LinkedList<>();
         for (int i = 0, n = argumentExpressions.size(); i < n; i += 1) {
             Expression argumentExpression = argumentExpressions.get(i);
             if (!(argumentExpression instanceof MethodReferenceExpression)) {
-                newArgumentExpressionList.add(argumentExpression);
-                continue;
-            }
-
-            Parameter param = parameters[i];
-            ClassNode paramType = param.getType();
-
-            if (!isFunctionalInterface(paramType.redirect())) {
-                addError("The argument is a method reference, but the parameter type is not a functional interface", argumentExpression);
-                newArgumentExpressionList.add(argumentExpression);
+                newArgumentExpressions.add(argumentExpression);
             } else {
-                newArgumentExpressionList.add(constructLambdaExpressionForMethodReference(paramType));
-                methodReferenceParamIndexList.add(i);
+                Parameter param = parameters[Math.min(i, nthParameter)]; // GROOVY-10336
+                ClassNode paramType = param.getType();
+                if (i >= nthParameter && paramType.isArray())
+                    paramType = paramType.getComponentType();
+
+                if (!isFunctionalInterface(paramType.redirect())) {
+                    addError("The argument is a method reference, but the parameter type is not a functional interface", argumentExpression);
+                    newArgumentExpressions.add(argumentExpression);
+                } else {
+                    methodReferencePositions.add(i);
+                    newArgumentExpressions.add(constructLambdaExpressionForMethodReference(paramType));
+                }
             }
         }
 
-        if (methodReferenceParamIndexList.isEmpty()) return; // GROOVY-10269
+        if (methodReferencePositions.isEmpty()) return; // GROOVY-10269
 
-        visitMethodCallArguments(receiver, args(newArgumentExpressionList), true, selectedMethod);
+        visitMethodCallArguments(receiver, args(newArgumentExpressions), true, selectedMethod);
 
-        for (int index : methodReferenceParamIndexList) {
-            Expression lambdaExpression = newArgumentExpressionList.get(index);
+        for (int index : methodReferencePositions) {
+            Expression lambdaExpression = newArgumentExpressions.get(index);
             Expression methodReferenceExpression = argumentExpressions.get(index);
             methodReferenceExpression.putNodeMetaData(CLOSURE_ARGUMENTS, lambdaExpression.getNodeMetaData(CLOSURE_ARGUMENTS));
         }
diff --git a/src/test/groovy/transform/stc/MethodReferenceTest.groovy b/src/test/groovy/transform/stc/MethodReferenceTest.groovy
index a5ad7aa404..da8a61f2bf 100644
--- a/src/test/groovy/transform/stc/MethodReferenceTest.groovy
+++ b/src/test/groovy/transform/stc/MethodReferenceTest.groovy
@@ -644,4 +644,22 @@ final class MethodReferenceTest {
 
         assert err =~ /The argument is a method reference, but the parameter type is not a functional interface/
     }
+
+    @Test // GROOVY-10336
+    void testNotFunctionalInterface2() {
+        def err = shouldFail shell, '''
+            class C {
+                Integer m() { 1 }
+            }
+            @CompileStatic
+            void test() {
+                Supplier<Long> outer = () -> {
+                    Closure<Long> inner = (Object o, Supplier<Integer> s) -> 2L
+                    inner(new Object(), new C()::m) // TODO: resolve call(Object,Supplier<Integer>)
+                }
+            }
+        '''
+
+        assert err =~ /The argument is a method reference, but the parameter type is not a functional interface/
+    }
 }
