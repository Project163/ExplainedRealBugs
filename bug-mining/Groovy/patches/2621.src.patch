diff --git a/src/main/org/codehaus/groovy/classgen/InnerClassVisitor.java b/src/main/org/codehaus/groovy/classgen/InnerClassVisitor.java
index fcfc420016..b4f66ee6c2 100644
--- a/src/main/org/codehaus/groovy/classgen/InnerClassVisitor.java
+++ b/src/main/org/codehaus/groovy/classgen/InnerClassVisitor.java
@@ -145,8 +145,6 @@ public class InnerClassVisitor extends InnerClassVisitorHelper implements Opcode
         VariableScope scope = innerClass.getVariableScope();
         if (scope == null) return;
 
-
-        boolean isStatic = scope.isInStaticContext();
         // expressions = constructor call arguments
         List<Expression> expressions = ((TupleExpression) call.getArguments()).getExpressions();
         // block = init code for the constructor we produce
@@ -182,7 +180,7 @@ public class InnerClassVisitor extends InnerClassVisitorHelper implements Opcode
         // this is saved in a field named this$0
         pCount = 0;
         expressions.add(pCount, VariableExpression.THIS_EXPRESSION);
-        ClassNode outerClassType = getClassNode(innerClass.getOuterClass(), isStatic).getPlainNodeReference();
+        ClassNode outerClassType = getClassNode(innerClass.getOuterClass(), isStaticThis(innerClass,scope)).getPlainNodeReference();
         Parameter thisParameter = new Parameter(outerClassType, "p" + pCount);
         parameters.add(pCount, thisParameter);
 
@@ -212,6 +210,14 @@ public class InnerClassVisitor extends InnerClassVisitorHelper implements Opcode
         innerClass.addConstructor(ACC_SYNTHETIC, parameters.toArray(new Parameter[0]), ClassNode.EMPTY_ARRAY, block);
     }
 
+    private boolean isStaticThis(InnerClassNode innerClass, VariableScope scope) {
+        boolean ret = scope.isInStaticContext() || innerClass.isStaticClass();
+        if (innerClass.getEnclosingMethod()!=null) {
+            ret = ret || innerClass.getEnclosingMethod().isStatic();
+        }
+        return ret;
+    }
+
     // this is the counterpart of addThisReference(). To non-static inner classes, outer this should be
     // passed as the first argument implicitly.
     private void passThisReference(ConstructorCallExpression call) {
diff --git a/src/test/gls/innerClass/InnerClassTest.groovy b/src/test/gls/innerClass/InnerClassTest.groovy
index 0845886aaa..4397ead0ec 100644
--- a/src/test/gls/innerClass/InnerClassTest.groovy
+++ b/src/test/gls/innerClass/InnerClassTest.groovy
@@ -458,7 +458,41 @@ import org.codehaus.groovy.classgen.Verifier
         assert a.x == 123
         '''
     }
-} 
+
+    // GROOVY-6810
+    void testThisReferenceForAICInOpenBlock() {
+        assertScript '''
+            import java.security.AccessController
+            import java.security.PrivilegedAction
+
+            static void injectVariables(final def instance, def variables) {
+                instance.class.declaredFields.each { field ->
+                    if (variables[field.name]) {
+                        AccessController.doPrivileged(new PrivilegedAction() {
+                            @Override
+                            public Object run() {
+                                boolean wasAccessible = field.isAccessible()
+                                try {
+                                    field.accessible = true
+                                    field.set(instance, variables[field.name])
+                                    return null; // return nothing...
+                                } catch (IllegalArgumentException | IllegalAccessException ex) {
+                                    throw new IllegalStateException("Cannot set field: " + field, ex)
+                                } finally {
+                                    field.accessible = wasAccessible
+                                }
+                            }
+                        })
+                    }
+                }
+            }
+
+            class Test {def p}
+            def t = new Test() 
+            injectVariables(t, ['p': 'q'])
+        '''
+    }
+}
 
 class MyOuterClass4028 {
     def foo() {
