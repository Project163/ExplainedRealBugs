diff --git a/src/main/org/codehaus/groovy/transform/sc/StaticCompilationVisitor.java b/src/main/org/codehaus/groovy/transform/sc/StaticCompilationVisitor.java
index 5cf0168b6b..0d411d59d7 100644
--- a/src/main/org/codehaus/groovy/transform/sc/StaticCompilationVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/sc/StaticCompilationVisitor.java
@@ -266,7 +266,7 @@ public class StaticCompilationVisitor extends StaticTypeCheckingVisitor {
             Expression objectExpression = pexp.getObjectExpression();
             ClassNode objectExpressionType = getType(objectExpression);
             if (objectExpressionType.implementsInterface(ClassHelper.LIST_TYPE)) {
-                objectExpression.putNodeMetaData(COMPONENT_TYPE, inferComponentType(objectExpressionType, ClassHelper.OBJECT_TYPE));
+                objectExpression.putNodeMetaData(COMPONENT_TYPE, inferComponentType(objectExpressionType, ClassHelper.int_TYPE));
             }
         }
         return exists;
diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 59c65552d0..e5208042be 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -1544,7 +1544,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 return;
             } else {
                 // type check call as if it was made on component type
-                ClassNode componentType = inferComponentType(expressionType, OBJECT_TYPE);
+                ClassNode componentType = inferComponentType(expressionType, int_TYPE);
                 MethodCallExpression subcall = new MethodCallExpression(
                         new CastExpression(componentType, EmptyExpression.INSTANCE),
                         name,
@@ -2136,20 +2136,6 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
     protected ClassNode inferComponentType(final ClassNode containerType, final ClassNode indexType) {
         final ClassNode componentType = containerType.getComponentType();
         if (componentType == null) {
-            // check if any generic information could help
-            GenericsType[] types = containerType.getGenericsTypes();
-            if (types != null && types.length == 1) {
-                GenericsType type = types[0];
-                if (type.isWildcard()) {
-                    ClassNode[] upperBounds = type.getUpperBounds();
-                    if (upperBounds.length==1) {
-                        return upperBounds[0];
-                    }
-                    ClassNode lowerBound = type.getLowerBound();
-                    if (lowerBound!=null) return lowerBound;
-                }
-                return type.getType();
-            }
             // GROOVY-5521
             // try to identify a getAt method
             ErrorCollector oldCollector = errorCollector;
@@ -2598,16 +2584,26 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 copy[i] = fullyResolve(returnTypeGeneric, resolvedPlaceholders);
             }
         }
+        GenericsType firstGenericsType = copy[0];
         if (returnType.equals(OBJECT_TYPE)) {
-            if (copy[0].getType().isGenericsPlaceHolder()) return OBJECT_TYPE;
-            return copy[0].getType();
+            if (firstGenericsType.getType().isGenericsPlaceHolder()) return OBJECT_TYPE;
+
+            if (firstGenericsType.isWildcard()) {
+                // ? extends Foo
+                // ? super Foo
+                if (firstGenericsType.getLowerBound()!=null) return firstGenericsType.getLowerBound();
+                ClassNode[] upperBounds = firstGenericsType.getUpperBounds();
+                if (upperBounds.length==1) return upperBounds[0];
+                return new UnionTypeClassNode(upperBounds);
+            }
+            return firstGenericsType.getType();
         }
         if (returnType.isArray()) {
             returnType = returnType.getComponentType().getPlainNodeReference();
             returnType.setGenericsTypes(copy);
             if (OBJECT_TYPE.equals(returnType)) {
                 // replace Object<Component> with Component
-                returnType = copy[0].getType();
+                returnType = firstGenericsType.getType();
             }
             returnType = returnType.makeArray();
         } else {
diff --git a/src/test/groovy/transform/stc/ArraysAndCollectionsSTCTest.groovy b/src/test/groovy/transform/stc/ArraysAndCollectionsSTCTest.groovy
index 01c9bb6b7b..b28b5c7192 100644
--- a/src/test/groovy/transform/stc/ArraysAndCollectionsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/ArraysAndCollectionsSTCTest.groovy
@@ -127,6 +127,40 @@ class ArraysAndCollectionsSTCTest extends StaticTypeCheckingTestCase {
         def bars = foos[0..1]
         println bars[0].substring(1)
         '''
+
+        // GROOVY-5608
+        assertScript '''
+            List<Integer> a = [1, 3, 5]
+
+            @ASTTest(phase = INSTRUCTION_SELECTION, value = {
+                def type = node.rightExpression.getNodeMetaData(INFERRED_TYPE)
+                assert type == make(List)
+                assert type.genericsTypes.length == 1
+                assert type.genericsTypes[0].type == Integer_TYPE
+            })
+            List<Integer> b = a[1..2]
+
+            List<Integer> c = (List<Integer>)a[1..2]
+         '''
+
+        // check that it also works for custom getAt methods
+        assertScript '''
+            class SpecialCollection {
+                List<Date> getAt(IntRange irange) {
+                    return [new Date(), new Date()+1]
+                }
+            }
+
+            def sc = new SpecialCollection()
+
+            @ASTTest(phase = INSTRUCTION_SELECTION, value = {
+                def type = node.rightExpression.getNodeMetaData(INFERRED_TYPE)
+                assert type == make(List)
+                assert type.genericsTypes.length == 1
+                assert type.genericsTypes[0].type == make(Date)
+            })
+            List<Date> dates = sc[1..3]
+        '''
     }
 
     void testListStarProperty() {
