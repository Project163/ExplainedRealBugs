diff --git a/src/main/groovy/util/Node.java b/src/main/groovy/util/Node.java
index 7c8afafa67..2f4bce6c30 100644
--- a/src/main/groovy/util/Node.java
+++ b/src/main/groovy/util/Node.java
@@ -127,12 +127,12 @@ public class Node implements Serializable {
     }
 
     public boolean append(Node child) {
-        child.parent = this;
+        child.setParent(this);
         return getParentList(this).add(child);
     }
 
     public boolean remove(Node child) {
-        child.parent = null;
+        child.setParent(null);
         return getParentList(this).remove(child);
     }
 
@@ -152,30 +152,54 @@ public class Node implements Serializable {
         return new Node(this, name, attributes, value);
     }
 
+    // TODO return replaced node rather than last appended?
+    // * @return the original now replaced node
+    /**
+     * Replaces the current node with nodes defined using builder-style notation via a Closure.
+     *
+     * @param c A Closure defining the new nodes using builder-style notation.
+     * @return the last appended node
+     */
     public Node replaceNode(Closure c) {
-        getParentList(parent).remove(this);
-        NodeBuilder b = new NodeBuilder();
-        Node newNode = (Node) b.invokeMethod("dummyNode", c);
-        List<Node> children = newNode.children();
-        Node result = this;
-        for (Node child : children) {
-            result = parent.appendNode(child.name(), child.attributes(), child.value());
+        if (parent() == null) {
+            throw new UnsupportedOperationException("Replacing the root node is not supported");
         }
+        Node result = appendNodes(c);
+        getParentList(parent()).remove(this);
+//        this.setParent(null);
+//        return this;
         return result;
     }
 
+    /**
+     * Adds sibling nodes (defined using builder-style notation via a Closure) after the current node.
+     *
+     * @param c A Closure defining the new sibling nodes to add using builder-style notation.
+     */
     public void plus(Closure c) {
-        List list = this.parent().children();
+        if (parent() == null) {
+            throw new UnsupportedOperationException("Adding sibling nodes to the root node is not supported");
+        }
+        appendNodes(c);
+    }
+
+    private Node appendNodes(Closure c) {
+        List list = parent().children();
         int afterIndex = list.indexOf(this);
         List leftOvers = new ArrayList(list.subList(afterIndex + 1, list.size()));
         list.subList(afterIndex + 1, list.size()).clear();
+        Node lastAppended = null;
+        for (Node child : buildChildrenFromClosure(c)) {
+            lastAppended = parent().appendNode(child.name(), child.attributes(), child.value());
+        }
+        parent().children().addAll(leftOvers);
+        return lastAppended;
+    }
+
+    private List<Node> buildChildrenFromClosure(Closure c) {
         NodeBuilder b = new NodeBuilder();
         Node newNode = (Node) b.invokeMethod("dummyNode", c);
-        List<Node> children = newNode.children();
-        for (Node child : children) {
-            parent.appendNode(child.name(), child.attributes(), child.value());
-        }
-        this.parent().children().addAll(leftOvers);
+        return newNode.children();
     }
 
     protected static void setMetaClass(final MetaClass metaClass, Class nodeClass) {
@@ -219,36 +243,37 @@ public class Node implements Serializable {
     public String text() {
         if (value instanceof String) {
             return (String) value;
-        } else if (value instanceof Collection) {
+        }
+        if (value instanceof Collection) {
             Collection coll = (Collection) value;
             String previousText = null;
-            StringBuffer buffer = null;
+            StringBuilder sb = null;
             for (Object child : coll) {
                 if (child instanceof String) {
                     String childText = (String) child;
                     if (previousText == null) {
                         previousText = childText;
                     } else {
-                        if (buffer == null) {
-                            buffer = new StringBuffer();
-                            buffer.append(previousText);
+                        if (sb == null) {
+                            sb = new StringBuilder();
+                            sb.append(previousText);
                         }
-                        buffer.append(childText);
+                        sb.append(childText);
                     }
                 }
             }
-            if (buffer != null) {
-                return buffer.toString();
+            if (sb != null) {
+                return sb.toString();
             } else {
                 if (previousText != null) {
                     return previousText;
                 }
+                return "";
             }
         }
-        return "";
+        return "" + value;
     }
 
-
     public Iterator iterator() {
         return children().iterator();
     }
@@ -290,6 +315,10 @@ public class Node implements Serializable {
         return parent;
     }
 
+    protected void setParent(Node parent) {
+        this.parent = parent;
+    }
+
     /**
      * Provides lookup of elements by non-namespaced name
      *
diff --git a/src/main/groovy/util/slurpersupport/Node.java b/src/main/groovy/util/slurpersupport/Node.java
index 6e34610352..ecd1de217f 100644
--- a/src/main/groovy/util/slurpersupport/Node.java
+++ b/src/main/groovy/util/slurpersupport/Node.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2010 the original author or authors.
+ * Copyright 2003-2012 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -88,7 +88,6 @@ public class Node implements Writable {
         });
     }
 
-
     protected void replaceBody(final Object newValue) {
         this.children.clear();
         this.children.add(newValue);
@@ -112,18 +111,15 @@ public class Node implements Writable {
     * @see org.codehaus.groovy.sandbox.util.slurpersupport.Node#text()
     */
     public String text() {
-        final StringBuffer buff = new StringBuffer();
-        final Iterator iter = this.children.iterator();
-        while (iter.hasNext()) {
-            final Object child = iter.next();
-
+        final StringBuilder sb = new StringBuilder();
+        for (Object child : this.children) {
             if (child instanceof Node) {
-                buff.append(((Node) child).text());
+                sb.append(((Node) child).text());
             } else {
-                buff.append(child);
+                sb.append(child);
             }
         }
-        return buff.toString();
+        return sb.toString();
     }
 
     /* (non-Javadoc)
@@ -154,7 +150,6 @@ public class Node implements Writable {
             private Object getNextElementNodes() {
                 while (iter.hasNext()) {
                     final Object node = iter.next();
-
                     if (node instanceof Node) {
                         return node;
                     }
@@ -169,9 +164,7 @@ public class Node implements Writable {
     */
     public Writer writeTo(final Writer out) throws IOException {
         if (this.replacementNodeStack.empty()) {
-            final Iterator iter = this.children.iterator();
-            while (iter.hasNext()) {
-                final Object child = iter.next();
+            for (Object child : this.children) {
                 if (child instanceof Writable) {
                     ((Writable) child).writeTo(out);
                 } else {
@@ -179,7 +172,6 @@ public class Node implements Writable {
                 }
             }
             return out;
-
         } else {
             return ((Writable) this.replacementNodeStack.peek()).writeTo(out);
         }
@@ -190,7 +182,6 @@ public class Node implements Writable {
             final Closure rest = new Closure(null) {
                 public Object doCall(final Object o) {
                     buildChildren(builder, namespaceMap, namespaceTagHints);
-
                     return null;
                 }
             };
@@ -210,18 +201,13 @@ public class Node implements Writable {
                     builder.invokeMethod(this.name, new Object[]{this.attributes, rest});
                 } else {
                     final Map attributesWithNamespaces = new HashMap(this.attributes);
-                    final Iterator attrs = this.attributes.keySet().iterator();
-
-                    while (attrs.hasNext()) {
-                        final Object key = attrs.next();
+                    for (Object key : this.attributes.keySet()) {
                         final Object attributeNamespaceURI = this.attributeNamespaces.get(key);
-
                         if (attributeNamespaceURI != null) {
                             attributesWithNamespaces.put(getTagFor(attributeNamespaceURI, current, pending, namespaceMap, namespaceTagHints, newTags, builder) +
                                     "$" + key, attributesWithNamespaces.remove(key));
                         }
                     }
-
                     builder.getProperty(getTagFor(this.namespaceURI, current, pending, namespaceMap, namespaceTagHints, newTags, builder));
                     builder.invokeMethod(this.name, new Object[]{attributesWithNamespaces, rest});
                 }
@@ -229,7 +215,6 @@ public class Node implements Writable {
                 // remove the new tags we had to define for this element
                 if (!newTags.isEmpty()) {
                     final Iterator iter = newTags.iterator();
-
                     do {
                         pending.remove(iter.next());
                     } while (iter.hasNext());
@@ -257,7 +242,6 @@ public class Node implements Writable {
 
                 if (tag == null || tag.length() == 0) { // otherwise make up a new tag and check it has not been used before
                     int suffix = 0;
-
                     do {
                         final String possibleTag = "tag" + suffix++;
 
@@ -279,9 +263,8 @@ public class Node implements Writable {
 
     private static String findNamespaceTag(final Map tagMap, final Object namespaceURI) {
         if (tagMap.containsValue(namespaceURI)) {
-            final Iterator entries = tagMap.entrySet().iterator();
-            while (entries.hasNext()) {
-                final Map.Entry entry = (Map.Entry) entries.next();
+            for (Object o : tagMap.entrySet()) {
+                final Map.Entry entry = (Map.Entry) o;
                 if (namespaceURI.equals(entry.getValue())) {
                     return (String) entry.getKey();
                 }
@@ -291,9 +274,7 @@ public class Node implements Writable {
     }
 
     private void buildChildren(final GroovyObject builder, final Map namespaceMap, final Map<String, String> namespaceTagHints) {
-        final Iterator iter = this.children.iterator();
-        while (iter.hasNext()) {
-            final Object child = iter.next();
+        for (Object child : this.children) {
             if (child instanceof Node) {
                 ((Node) child).build(builder, namespaceMap, namespaceTagHints);
             } else if (child instanceof Buildable) {
diff --git a/src/main/groovy/xml/XmlUtil.java b/src/main/groovy/xml/XmlUtil.java
index 016ee63f04..6d32ee8740 100644
--- a/src/main/groovy/xml/XmlUtil.java
+++ b/src/main/groovy/xml/XmlUtil.java
@@ -15,6 +15,7 @@
  */
 package groovy.xml;
 
+import groovy.lang.GroovyRuntimeException;
 import groovy.lang.Writable;
 import groovy.util.Node;
 import groovy.util.XmlNodePrinter;
@@ -253,7 +254,7 @@ public class XmlUtil {
             transformer.transform(source, target);
         }
         catch (TransformerException e) {
-            // ignore
+            throw new GroovyRuntimeException(e.getMessage());
         }
     }
 
diff --git a/src/main/groovy/xml/dom/DOMCategory.java b/src/main/groovy/xml/dom/DOMCategory.java
index 23295e6055..8514b71858 100644
--- a/src/main/groovy/xml/dom/DOMCategory.java
+++ b/src/main/groovy/xml/dom/DOMCategory.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2010 the original author or authors.
+ * Copyright 2003-2012 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -41,6 +41,8 @@ import java.util.List;
 import java.util.Map;
 
 /**
+ * Category class which adds GPath style operations to Java's DOM classes.
+ *
  * @author sam
  * @author paulk
  */
@@ -234,7 +236,7 @@ public class DOMCategory {
     }
 
     public static String text(NodeList nodeList) {
-        StringBuffer sb = new StringBuffer();
+        StringBuilder sb = new StringBuilder();
         for (int i = 0; i < nodeList.getLength(); i++) {
             sb.append(text(nodeList.item(i)));
         }
@@ -307,43 +309,42 @@ public class DOMCategory {
         return result;
     }
 
-    public static Element replaceNode(NodesHolder self, Closure c) {
+    public static Node replaceNode(NodesHolder self, Closure c) {
         if (self.getLength() <= 0 || self.getLength() > 1) {
             throw new GroovyRuntimeException("replaceNode() can only be used to replace a single element.");
         }
-        return replaceNode((Element) self.item(0), c);
+        return replaceNode(self.item(0), c);
     }
 
-    public static Element replaceNode(Element self, Closure c) {
-        // Use DOMBuilder to generate the replacement node.
-        DOMBuilder b = new DOMBuilder(self.getOwnerDocument());
-        Element newNode = (Element) b.invokeMethod("rootNode", c);
-
-        // The replacement node is the first child element of 'rootNode'.
-        Node n = newNode.getFirstChild();
-        while (n != null && n.getNodeType() != Node.ELEMENT_NODE) {
-            n = n.getNextSibling();
+    // TODO return replaced node rather than last appended?
+    public static Node replaceNode(Node self, Closure c) {
+        if (self.getParentNode() instanceof Document) {
+            throw new UnsupportedOperationException("Replacing the root node is not supported");
         }
-
-        if (n == null) throw new GroovyRuntimeException("Replacement node must be an element.");
-
-        // Now replace the required node and return the replacement element.
-        newNode = (Element) n;
-        self.getParentNode().replaceChild(newNode, self);
-        return newNode;
+        Node result = appendNodes(self, c);
+        self.getParentNode().removeChild(self);
+        return result;
+//        return self;
     }
 
     public static void plus(Element self, Closure c) {
+        if (self.getParentNode() instanceof Document) {
+            throw new UnsupportedOperationException("Adding sibling nodes to the root node is not supported");
+        }
+        appendNodes(self, c);
+    }
+
+    private static Node appendNodes(Node self, Closure c) {
         Node parent = self.getParentNode();
         Node beforeNode = self.getNextSibling();
-
         DOMBuilder b = new DOMBuilder(self.getOwnerDocument());
         Element newNodes = (Element) b.invokeMethod("rootNode", c);
-
         Iterator<Node> iter = XmlGroovyMethods.iterator(children(newNodes));
+        Node lastAppended = null;
         while (iter.hasNext()) {
-            parent.insertBefore(iter.next(), beforeNode);
+            lastAppended = parent.insertBefore(iter.next(), beforeNode);
         }
+        return lastAppended;
     }
 
     public static void plus(NodeList self, Closure c) {
@@ -442,7 +443,7 @@ public class DOMCategory {
     }
 
     private static String toString(NodeList self) {
-        StringBuffer sb = new StringBuffer();
+        StringBuilder sb = new StringBuilder();
         sb.append("[");
         Iterator it = XmlGroovyMethods.iterator(self);
         while (it.hasNext()) {
@@ -480,8 +481,8 @@ public class DOMCategory {
 
         public int getLength() {
             int length = 0;
-            for (int i = 0; i < nodeLists.size(); i++) {
-                NodeList nl = (NodeList) nodeLists.get(i);
+            for (Object nodeList : nodeLists) {
+                NodeList nl = (NodeList) nodeList;
                 length += nl.getLength();
             }
             return length;
@@ -489,8 +490,8 @@ public class DOMCategory {
 
         public Node item(int index) {
             int relativeIndex = index;
-            for (int i = 0; i < nodeLists.size(); i++) {
-                NodeList nl = (NodeList) nodeLists.get(i);
+            for (Object nodeList : nodeLists) {
+                NodeList nl = (NodeList) nodeList;
                 if (relativeIndex < nl.getLength()) {
                     return nl.item(relativeIndex);
                 }
diff --git a/src/test/groovy/util/NodeTest.groovy b/src/test/groovy/util/NodeTest.groovy
index 2eb6ceee0c..4733a53efd 100644
--- a/src/test/groovy/util/NodeTest.groovy
+++ b/src/test/groovy/util/NodeTest.groovy
@@ -195,13 +195,25 @@ public class NodeTest extends GroovyTestCase {
     public void testPlus() {
         Node root = new Node(null, 'root')
         Node first = new Node(root, 'first')
-
         root.first + { second('some text') }
-
         assert 2 == root.children().size()
         assert 'some text' == root.second.text()
     }
 
+    public void testUnsupportedReplaceForRootNode() {
+        Node root = new Node(null, 'root')
+        shouldFail(UnsupportedOperationException) {
+            root.replaceNode{}
+        }
+    }
+
+    public void testUnsupportedPlusOnRootNode() {
+        Node root = new Node(null, 'root')
+        shouldFail(UnsupportedOperationException) {
+            root.plus{}
+        }
+    }
+
     public void testPlusWithMixedContent() {
         Node root = new Node(null, 'root')
         Node beforeString = new Node(root, 'beforeString')
diff --git a/src/test/groovy/util/XmlParserTest.groovy b/src/test/groovy/util/XmlParserTest.groovy
index b58dde8566..d999d885a8 100644
--- a/src/test/groovy/util/XmlParserTest.groovy
+++ b/src/test/groovy/util/XmlParserTest.groovy
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2010 the original author or authors.
+ * Copyright 2003-2012 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -230,6 +230,7 @@ p() {
 
     void testReplacementsAndAdditions() {
         GpathSyntaxTestSupport.checkReplaceNode(getRoot)
+        GpathSyntaxTestSupport.checkReplaceMultipleNodes(getRoot)
         GpathSyntaxTestSupport.checkPlus(getRoot)
     }
 
diff --git a/src/test/groovy/util/XmlSlurperTest.groovy b/src/test/groovy/util/XmlSlurperTest.groovy
index 5da217f30a..f01f03dc44 100644
--- a/src/test/groovy/util/XmlSlurperTest.groovy
+++ b/src/test/groovy/util/XmlSlurperTest.groovy
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2010 the original author or authors.
+ * Copyright 2003-2012 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -84,23 +84,22 @@ class XmlSlurperTest extends GroovyTestCase {
 
     void testReplacementsAndAdditions() {
         GpathSyntaxTestSupport.checkReplaceNode(getRoot)
+        GpathSyntaxTestSupport.checkReplaceMultipleNodes(getRoot)
         GpathSyntaxTestSupport.checkPlus(getRoot)
     }
 
     void testMixedMarkup() {
         MixedMarkupTestSupport.checkMixedMarkup(getRoot)
     }
-    
+
     void testReplace() {
         def input = "<doc><sec>Hello<p>World</p></sec></doc>"
-        def replaceSlurper = new XmlSlurper().parseText(input) 
-        
-        replaceSlurper.sec.replaceNode{ node ->
-          t(){ delegate.mkp.yield node.getBody() }
+        def replaceSlurper = new XmlSlurper().parseText(input)
+        replaceSlurper.sec.replaceNode { node ->
+            t() { delegate.mkp.yield node.getBody() }
         }
-        
         def outputSlurper = new StreamingMarkupBuilder()
-        String output = outputSlurper.bind{ mkp.yield replaceSlurper }
+        String output = outputSlurper.bind { mkp.yield replaceSlurper }
         assert output == "<doc><t>Hello<p>World</p></t></doc>"
     }
 
diff --git a/src/test/groovy/xml/GpathSyntaxTestSupport.groovy b/src/test/groovy/xml/GpathSyntaxTestSupport.groovy
index 5a2195f1d8..7ff26696f3 100644
--- a/src/test/groovy/xml/GpathSyntaxTestSupport.groovy
+++ b/src/test/groovy/xml/GpathSyntaxTestSupport.groovy
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2010 the original author or authors.
+ * Copyright 2003-2012 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -15,7 +15,6 @@
  */
 package groovy.xml
 
-import groovy.util.slurpersupport.GPathResult
 import org.custommonkey.xmlunit.XMLUnit
 import org.custommonkey.xmlunit.Diff
 
@@ -312,16 +311,13 @@ class GpathSyntaxTestSupport {
     }
 
     static void checkReplaceNode(Closure getRoot) {
-        def root = getRoot('<a><b>B1</b><b>B2</b><c a1="4" a2="true"><x>500</x></c></a>')
+        def root = getRoot('<a><b>B1</b><b>B2</b><c a1="4" a2="true"><x>500</x></c><d/></a>')
         def r = root.c.replaceNode {
             n(type: 'string') {
                 hello('world')
             }
         }
-        String result
-        // TODO remove need for cast
-        if (isSlurper(root)) result = XmlUtil.serialize((GPathResult)root)
-        else result = XmlUtil.serialize(root)
+        String actual = XmlUtil.serialize(root)
         def expected = '''\
 <?xml version="1.0" encoding="UTF-8"?>
 <a>
@@ -330,10 +326,11 @@ class GpathSyntaxTestSupport {
   <n type="string">
     <hello>world</hello>
   </n>
+  <d/>
 </a>
 '''
         XMLUnit.ignoreWhitespace = true
-        def xmlDiff = new Diff(result, expected)
+        def xmlDiff = new Diff(actual, expected)
         assert xmlDiff.similar(), xmlDiff.toString()
 
         // XmlSlurper replacements are deferred so can't check here
@@ -342,22 +339,39 @@ class GpathSyntaxTestSupport {
             assert r.'@type' == 'string'
             assert r.hello.text() == 'world'
         }
+    }
 
-        // TODO behaviour when multiple nodes added?
-//        root.c.replaceNode {
-//            n(type: 'string') {
-//                hello('world')
-//            }
-//            n(type: 'int', 330)
-//        }
-
-        // TODO behavior when replaceNode() is operating on a node list?
-//        root.b.replaceNode {
-//            n(type: 'string') {
-//                hello('world')
-//            }
-//        }
+    static void checkReplaceMultipleNodes(Closure getRoot) {
+        def root = getRoot('<a><b>B1</b><b>B2</b><c a1="4" a2="true"><x>500</x></c><d/></a>')
+        def r = root.c.replaceNode {
+            n(type: 'string') {
+                hello('world')
+            }
+            n(type: 'int', 330)
+        }
+        String actual = XmlUtil.serialize(root)
+        def expected = '''\
+<?xml version="1.0" encoding="UTF-8"?>
+<a>
+  <b>B1</b>
+  <b>B2</b>
+  <n type="string">
+    <hello>world</hello>
+  </n>
+  <n type="int">330</n>
+  <d/>
+</a>
+'''
+        XMLUnit.ignoreWhitespace = true
+        def xmlDiff = new Diff(actual, expected)
+        assert xmlDiff.similar(), xmlDiff.toString()
 
+        // XmlSlurper replacements are deferred so can't check here
+        if (!isSlurper(root)) {
+            assert r.name() == 'n'
+            assert r.'@type' == 'int'
+            assert r.text() == '330'
+        }
     }
 
     static void checkPlus(Closure getRoot) {
@@ -373,10 +387,7 @@ class GpathSyntaxTestSupport {
         root.b[-1] + {
             b('B4')
         }
-        String result
-        // TODO remove need for cast
-        if (isSlurper(root)) result = XmlUtil.serialize((GPathResult)root)
-        else result = XmlUtil.serialize(root)
+        String actual = XmlUtil.serialize(root)
         def expected = '''\
 <?xml version="1.0" encoding="UTF-8"?>
 <a>
@@ -392,7 +403,7 @@ class GpathSyntaxTestSupport {
 </a>
 '''
         XMLUnit.ignoreWhitespace = true
-        def xmlDiff = new Diff(result, expected)
+        def xmlDiff = new Diff(actual, expected)
         assert xmlDiff.similar(), xmlDiff.toString()
     }
 
diff --git a/src/test/groovy/xml/dom/DOMCategoryTest.groovy b/src/test/groovy/xml/dom/DOMCategoryTest.groovy
index 5c1dc43e57..7d9e5a054f 100644
--- a/src/test/groovy/xml/dom/DOMCategoryTest.groovy
+++ b/src/test/groovy/xml/dom/DOMCategoryTest.groovy
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2010 the original author or authors.
+ * Copyright 2003-2012 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -32,6 +32,7 @@ class DOMCategoryTest extends GroovyTestCase {
     void testReplacementsAndAdditions() {
         use(DOMCategory) {
             GpathSyntaxTestSupport.checkReplaceNode(getRoot)
+            GpathSyntaxTestSupport.checkReplaceMultipleNodes(getRoot)
             GpathSyntaxTestSupport.checkPlus(getRoot)
         }
     }
