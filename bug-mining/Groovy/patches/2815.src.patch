diff --git a/src/main/org/codehaus/groovy/classgen/FinalVariableAnalyzer.java b/src/main/org/codehaus/groovy/classgen/FinalVariableAnalyzer.java
index e99afc22c9..e131840ba6 100644
--- a/src/main/org/codehaus/groovy/classgen/FinalVariableAnalyzer.java
+++ b/src/main/org/codehaus/groovy/classgen/FinalVariableAnalyzer.java
@@ -27,9 +27,12 @@ import org.codehaus.groovy.ast.expr.Expression;
 import org.codehaus.groovy.ast.expr.PostfixExpression;
 import org.codehaus.groovy.ast.expr.PrefixExpression;
 import org.codehaus.groovy.ast.expr.VariableExpression;
+import org.codehaus.groovy.ast.stmt.BlockStatement;
+import org.codehaus.groovy.ast.stmt.CatchStatement;
 import org.codehaus.groovy.ast.stmt.EmptyStatement;
 import org.codehaus.groovy.ast.stmt.IfStatement;
 import org.codehaus.groovy.ast.stmt.Statement;
+import org.codehaus.groovy.ast.stmt.TryCatchStatement;
 import org.codehaus.groovy.control.SourceUnit;
 import org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport;
 
@@ -50,7 +53,7 @@ public class FinalVariableAnalyzer extends ClassCodeVisitorSupport {
     private boolean inAssignment = false;
 
     private static enum VariableState {
-        is_uninitialized(true),
+        is_uninitialized(false),
         is_final(true),
         is_var(false);
 
@@ -88,11 +91,19 @@ public class FinalVariableAnalyzer extends ClassCodeVisitorSupport {
     }
 
     private Map<Variable, VariableState> pushState() {
-        HashMap<Variable, VariableState> state = new HashMap<Variable, VariableState>();
+        HashMap<Variable, VariableState> state = new StateMap();
         assignmentTracker.add(state);
         return state;
     }
 
+    private static Variable getTarget(Variable v) {
+        if (v instanceof VariableExpression) {
+            Variable t = ((VariableExpression) v).getAccessedVariable();
+            if (t==v) return t;
+            return getTarget(t);
+        }
+        return v;
+    }
     private Map<Variable, VariableState> popState() {
         return assignmentTracker.removeLast();
     }
@@ -115,10 +126,10 @@ public class FinalVariableAnalyzer extends ClassCodeVisitorSupport {
     }
 
     @Override
-    protected void visitConstructorOrMethod(final MethodNode node, final boolean isConstructor) {
+    public void visitBlockStatement(final BlockStatement block) {
         Set<VariableExpression> old = declaredFinalVariables;
         declaredFinalVariables = new HashSet<VariableExpression>();
-        super.visitConstructorOrMethod(node, isConstructor);
+        super.visitBlockStatement(block);
         if (callback!=null) {
             Map<Variable, VariableState> state = getState();
             for (VariableExpression declaredFinalVariable : declaredFinalVariables) {
@@ -153,12 +164,6 @@ public class FinalVariableAnalyzer extends ClassCodeVisitorSupport {
                         isDeclaration &&
                                 rightExpression == EmptyExpression.INSTANCE;
                 recordAssignment((Variable) leftExpression, isDeclaration, uninitialized, false, expression);
-                if (leftExpression instanceof VariableExpression) {
-                    Variable accessed = ((VariableExpression) leftExpression).getAccessedVariable();
-                    if (accessed != leftExpression) {
-                        recordAssignment(accessed, isDeclaration, uninitialized, false, expression);
-                    }
-                }
             }
         }
     }
@@ -233,19 +238,60 @@ public class FinalVariableAnalyzer extends ClassCodeVisitorSupport {
 
         // merge if/else branches
         Map<Variable, VariableState> curState = getState();
-        for (Map.Entry<Variable, VariableState> entry : ifState.entrySet()) {
-            Variable key = entry.getKey();
-            VariableState ifValue = entry.getValue();
-            VariableState merged = ifValue;
-            if (elseState.containsKey(key)) {
-                VariableState elseValue = elseState.get(key);
-                merged = (ifValue.isFinal && elseValue.isFinal) ? VariableState.is_final : VariableState.is_var;
+        Set<Variable> allVars = new HashSet<Variable>();
+        allVars.addAll(curState.keySet());
+        allVars.addAll(ifState.keySet());
+        allVars.addAll(elseState.keySet());
+        for (Variable var : allVars) {
+            VariableState beforeValue = curState.get(var);
+            VariableState ifValue = ifState.get(var);
+            VariableState elseValue = elseState.get(var);
+            // merge if and else values
+            VariableState mergedIfElse ;
+            mergedIfElse = ifValue!=null
+                        && elseValue!=null
+                        && ifValue.isFinal && elseValue.isFinal?VariableState.is_final:VariableState.is_var;
+            if (beforeValue == null) {
+                curState.put(var, mergedIfElse);
+            } else {
+                if (beforeValue == VariableState.is_uninitialized) {
+                    curState.put(var, mergedIfElse);
+                } else if (ifValue!=null || elseValue!=null) {
+                    curState.put(var, VariableState.is_var);
+                }
             }
-            VariableState oldState = curState.get(key);
-            if (oldState != null) {
-                merged = (merged.isFinal && oldState==VariableState.is_uninitialized) ? VariableState.is_final : VariableState.is_var;
+        }
+    }
+
+    @Override
+    public void visitTryCatchFinally(final TryCatchStatement statement) {
+        visitStatement(statement);
+        Map<Variable, VariableState> beforeTryCatch = new HashMap<Variable, VariableState>(getState());
+        statement.getTryStatement().visit(this);
+        for (CatchStatement catchStatement : statement.getCatchStatements()) {
+            catchStatement.visit(this);
+        }
+        Statement finallyStatement = statement.getFinallyStatement();
+        // we need to recall which final variables are unassigned so cloning the current state
+        Map<Variable, VariableState> afterTryCatchState = new HashMap<Variable, VariableState>(getState());
+        if (finallyStatement instanceof EmptyStatement) {
+            // dispatching to EmptyStatement will not call back visitor,
+            // must call our visitEmptyStatement explicitly
+            visitEmptyStatement((EmptyStatement) finallyStatement);
+        } else {
+            finallyStatement.visit(this);
+        }
+        // and now we must reset to uninitialized state variables which were only initialized during try/catch
+        Map<Variable, VariableState> afterFinally = new HashMap<Variable, VariableState>(getState());
+        for (Map.Entry<Variable, VariableState> entry : afterFinally.entrySet()) {
+            Variable var = entry.getKey();
+            VariableState afterFinallyState = entry.getValue();
+            VariableState beforeTryCatchState = beforeTryCatch.get(var);
+            if (afterFinallyState==VariableState.is_final
+                    && beforeTryCatchState !=VariableState.is_final
+                    && afterTryCatchState.get(var)!=beforeTryCatchState) {
+                getState().put(var, beforeTryCatchState==null?VariableState.is_uninitialized:beforeTryCatchState);
             }
-            curState.put(key, merged);
         }
     }
 
@@ -264,7 +310,7 @@ public class FinalVariableAnalyzer extends ClassCodeVisitorSupport {
         VariableState variableState = getState().get(var);
         if (variableState == null) {
             variableState = uninitialized ? VariableState.is_uninitialized : VariableState.is_final;
-            if (var instanceof Parameter) {
+            if (getTarget(var) instanceof Parameter) {
                 variableState = VariableState.is_var;
             }
         } else {
@@ -295,4 +341,16 @@ public class FinalVariableAnalyzer extends ClassCodeVisitorSupport {
          */
         void variableNotAlwaysInitialized(VariableExpression var);
     }
+
+    private static class StateMap extends HashMap<Variable, VariableState> {
+        @Override
+        public VariableState get(final Object key) {
+            return super.get(getTarget((Variable)key));
+        }
+
+        @Override
+        public VariableState put(final Variable key, final VariableState value) {
+            return super.put(getTarget(key), value);
+        }
+    }
 }
diff --git a/src/main/org/codehaus/groovy/classgen/Verifier.java b/src/main/org/codehaus/groovy/classgen/Verifier.java
index f3b2bc3e2f..3888785d1f 100644
--- a/src/main/org/codehaus/groovy/classgen/Verifier.java
+++ b/src/main/org/codehaus/groovy/classgen/Verifier.java
@@ -207,7 +207,13 @@ public class Verifier implements GroovyClassVisitor, Opcodes {
     }
 
     private void checkFinalVariables(ClassNode node) {
-        FinalVariableAnalyzer analyzer = new FinalVariableAnalyzer(null, new FinalVariableAnalyzer.VariableNotFinalCallback() {
+        FinalVariableAnalyzer analyzer = new FinalVariableAnalyzer(null, getFinalVariablesCallback());
+        analyzer.visitClass(node);
+
+    }
+
+    protected FinalVariableAnalyzer.VariableNotFinalCallback getFinalVariablesCallback() {
+        return new FinalVariableAnalyzer.VariableNotFinalCallback() {
             @Override
             public void variableNotFinal(Variable var, Expression bexp) {
                 if (var instanceof VariableExpression) {
@@ -225,9 +231,7 @@ public class Verifier implements GroovyClassVisitor, Opcodes {
             public void variableNotAlwaysInitialized(final VariableExpression var) {
                 throw new RuntimeParserException("The variable ["+var.getName()+"] may be uninitialized", var);
             }
-        });
-        analyzer.visitClass(node);
-
+        };
     }
 
     private void checkForDuplicateMethods(ClassNode cn) {
diff --git a/src/main/org/codehaus/groovy/tools/javac/JavaStubGenerator.java b/src/main/org/codehaus/groovy/tools/javac/JavaStubGenerator.java
index 5e108fa016..5ab1b88ca7 100644
--- a/src/main/org/codehaus/groovy/tools/javac/JavaStubGenerator.java
+++ b/src/main/org/codehaus/groovy/tools/javac/JavaStubGenerator.java
@@ -28,6 +28,7 @@ import org.codehaus.groovy.ast.expr.ClosureExpression;
 import org.codehaus.groovy.ast.stmt.BlockStatement;
 import org.codehaus.groovy.ast.stmt.ExpressionStatement;
 import org.codehaus.groovy.ast.stmt.Statement;
+import org.codehaus.groovy.classgen.FinalVariableAnalyzer;
 import org.codehaus.groovy.classgen.Verifier;
 import org.codehaus.groovy.control.ResolveVisitor;
 import org.codehaus.groovy.tools.Utilities;
@@ -138,6 +139,11 @@ public class JavaStubGenerator {
                     node.getObjectInitializerStatements().addAll(savedStatements);
                 }
 
+                @Override
+                protected FinalVariableAnalyzer.VariableNotFinalCallback getFinalVariablesCallback() {
+                    return null;
+                }
+
                 public void addCovariantMethods(ClassNode cn) {}
                 protected void addTimeStamp(ClassNode node) {}
                 protected void addInitialization(ClassNode node) {}
diff --git a/src/test/org/codehaus/groovy/classgen/FinalVariableAnalyzerTest.groovy b/src/test/org/codehaus/groovy/classgen/FinalVariableAnalyzerTest.groovy
index 581ec788e8..132cc2222b 100644
--- a/src/test/org/codehaus/groovy/classgen/FinalVariableAnalyzerTest.groovy
+++ b/src/test/org/codehaus/groovy/classgen/FinalVariableAnalyzerTest.groovy
@@ -74,8 +74,8 @@ class FinalVariableAnalyzerTest extends GroovyTestCase {
         '''
     }
 
-    void testUnassignedVarShouldBeConsideredFinal() {
-        assertFinals x:true, '''def x'''
+    void testUnassignedVarShouldNotBeConsideredFinal() {
+        assertFinals x:false, '''def x'''
     }
 
     void testVariableReassignedInClosureShouldNotBeFinal() {
@@ -134,8 +134,8 @@ class FinalVariableAnalyzerTest extends GroovyTestCase {
         ''')
     }
 
-    void testFinalVariableAssignedInIfBranchesShouldStillBeFinal() {
-        assertFinals x:true,'''
+    void testFinalVariableAssignedInIfBranchesShouldNotBeFinal() {
+        assertFinals x:false,'''
             int x
             if (t) {
                 x = 1
@@ -143,8 +143,8 @@ class FinalVariableAnalyzerTest extends GroovyTestCase {
         '''
     }
 
-    void testFinalVariableAssignedInElseBranchesShouldStillBeFinal() {
-        assertFinals x:true,'''
+    void testFinalVariableAssignedInElseBranchesShouldStillNotBeFinal() {
+        assertFinals x:false,'''
             int x
             if (t) {
                 // nothing
@@ -316,7 +316,7 @@ class FinalVariableAnalyzerTest extends GroovyTestCase {
         ''', true)
     }
 
-    void testShouldNotSayThatListIsNotInitialized() {
+    void testShouldNotSayThatVarIsNotInitialized() {
         assertScript '''
                 final List<String> list = ['a','b'].collect { it.toUpperCase() }
                 def result
@@ -328,6 +328,68 @@ class FinalVariableAnalyzerTest extends GroovyTestCase {
                 result
 
         '''
+        assertScript '''
+            private def setValueOfMethod() {
+                if (cache) {
+                    final int offset = 128;
+                }
+            }
+
+            1
+        '''
+    }
+
+    void testFinalVariableInitializedInTryCatchFinally() {
+        // x initialized in try block
+        assertFinals x:false, '''
+            int x
+            try {
+              x=1
+            } finally {
+
+            }
+        '''
+
+        // x initialized in catch block
+        assertFinals x:false, '''
+            int x
+            try {
+            } catch (e) {
+               x = 1
+            } finally {
+
+            }
+        '''
+
+        // x initialized in finally block
+        assertFinals x:true, '''
+            int x
+            try {
+            } catch(e) {
+            } finally {
+               x = 1
+            }
+        '''
+    }
+
+    void testVarInitializedInBothTryCatchAndFinallyBlocksShouldBeCompileTimeError() {
+        assertFinalCompilationErrors(['x'], '''
+            final x
+            try {
+                x = 1
+            } finally {
+                x = 2
+            }
+        ''')
+        assertFinalCompilationErrors(['x'], '''
+            final x
+            try {
+            } catch(e) {
+                x = 1
+            }finally {
+                x = 2
+            }
+        ''')
     }
 
     @CompileStatic
