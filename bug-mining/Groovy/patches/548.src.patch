diff --git a/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java b/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
index fbed52d6cf..98209c7ddb 100644
--- a/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
+++ b/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
@@ -1704,9 +1704,9 @@ public class AsmClassGenerator extends ClassGenerator {
         boolean isSuperMethodCall = usesSuper(call);
         boolean isThisExpression = isThisExpression(call.getObjectExpression());
 
-        // are we a local variable
+        // are we a local variable?
         if (methodName != null && isThisExpression && isFieldOrVariable(methodName) && !classNode.hasPossibleMethod(methodName, arguments)) {
-            // lets invoke the closure method
+            // let's invoke the closure method
             visitVariableExpression(new VariableExpression(methodName));
             if (arguments instanceof TupleExpression) {
                 arguments.visit(this);
diff --git a/src/main/org/codehaus/groovy/control/StaticImportVisitor.java b/src/main/org/codehaus/groovy/control/StaticImportVisitor.java
index 43269201eb..13425600cf 100644
--- a/src/main/org/codehaus/groovy/control/StaticImportVisitor.java
+++ b/src/main/org/codehaus/groovy/control/StaticImportVisitor.java
@@ -29,6 +29,7 @@ import java.util.*;
  */
 public class StaticImportVisitor extends ClassCodeExpressionTransformer {
     private ClassNode currentClass;
+    private MethodNode currentMethod;
     private SourceUnit source;
     private CompilationUnit compilationUnit;
     private boolean stillResolving;
@@ -48,6 +49,12 @@ public class StaticImportVisitor extends ClassCodeExpressionTransformer {
         super.visitClass(node);
     }
 
+    protected void visitConstructorOrMethod(MethodNode node, boolean isConstructor) {
+        this.currentMethod = node;
+        super.visitConstructorOrMethod(node, isConstructor);
+        this.currentMethod = null;
+    }
+
     public Expression transform(Expression exp) {
         if (exp == null) return null;
         if (exp.getClass() == VariableExpression.class) {
@@ -95,20 +102,32 @@ public class StaticImportVisitor extends ClassCodeExpressionTransformer {
     protected Expression transformMethodCallExpression(MethodCallExpression mce) {
         Expression args = transform(mce.getArguments());
         Expression method = transform(mce.getMethod());
-        if (mce.isImplicitThis()) {
+        Expression object = transform(mce.getObjectExpression());
+        boolean isExplicitThis = false;
+        if (object instanceof VariableExpression) {
+            VariableExpression ve = (VariableExpression) object;
+            isExplicitThis = !mce.isImplicitThis() && ve.getName().equals("this");
+            if (isExplicitThis && currentMethod != null && currentMethod.isStatic()) {
+                addError("Non-static variable 'this' cannot be referenced from the static method " + currentMethod.getName() + ".", mce);
+                return null;
+            }
+        }
+
+        if (mce.isImplicitThis() || isExplicitThis) {
             Expression ret = findStaticMethodImportFromModule(method, args);
             if (ret != null) {
                 return ret;
             }
-            if (inSpecialConstructorCall && method instanceof ConstantExpression) {
+            if (method instanceof ConstantExpression) {
                 ConstantExpression ce = (ConstantExpression) method;
                 Object value = ce.getValue();
                 if (value instanceof String) {
-                    return new StaticMethodCallExpression(currentClass, (String) value, args);
+                    String methodName = (String) value;
+                    if (inSpecialConstructorCall || currentClass.hasPossibleStaticMethod(methodName, args))
+                    return new StaticMethodCallExpression(currentClass, methodName, args);
                 }
             }
         }
-        Expression object = transform(mce.getObjectExpression());
 
         MethodCallExpression result = new MethodCallExpression(object, method, args);
         result.setSafe(mce.isSafe());
@@ -176,7 +195,7 @@ public class StaticImportVisitor extends ClassCodeExpressionTransformer {
         if (ve == VariableExpression.THIS_EXPRESSION || ve == VariableExpression.SUPER_EXPRESSION) return;
         Variable v = ve.getAccessedVariable();
         if (v != null && !(v instanceof DynamicVariable) && v.isInStaticContext()) return;
-        addError("the name " + ve.getName() + " doesn't refer to a declared variable or class. The static" +
+        addError("The name " + ve.getName() + " doesn't refer to a declared variable or class. The static" +
                 " scope requires that you declare variables before using them. If the variable should have" +
                 " been a class check the spelling.", ve);
     }
