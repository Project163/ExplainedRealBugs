diff --git a/src/main/groovy/lang/MetaClassImpl.java b/src/main/groovy/lang/MetaClassImpl.java
index c289c7917b..0be0e671e5 100644
--- a/src/main/groovy/lang/MetaClassImpl.java
+++ b/src/main/groovy/lang/MetaClassImpl.java
@@ -975,12 +975,17 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
                             try {
                                 return invokeMethodOnGroovyObject(methodName, originalArguments, owner);
                             } catch (MissingMethodException mme) {
+                                // proboboly needed here, but we need a test case to trip it first
                                 if (last == null) last = mme;
                             }
                             catch (InvokerInvocationException iie) {
                                 if (iie.getCause() instanceof MissingMethodException) {
                                     MissingMethodException mme = (MissingMethodException) iie.getCause();
-                                    if (last == null) last = mme;
+                                    if (methodName.equals(mme.getMethod())) {
+                                        if (last == null) last = mme;
+                                    } else {
+                                        throw iie;
+                                    }
                                 }
                                 else
                                   throw iie;
diff --git a/src/main/org/codehaus/groovy/runtime/metaclass/ClosureMetaClass.java b/src/main/org/codehaus/groovy/runtime/metaclass/ClosureMetaClass.java
index 1b27176cd2..b277b9c92b 100644
--- a/src/main/org/codehaus/groovy/runtime/metaclass/ClosureMetaClass.java
+++ b/src/main/org/codehaus/groovy/runtime/metaclass/ClosureMetaClass.java
@@ -404,7 +404,9 @@ public final class ClosureMetaClass extends MetaClassImpl {
                 first = mme;
             } catch (GroovyRuntimeException gre) {
                 Throwable th = unwrap(gre);
-                if (th instanceof MissingMethodException) {
+                if ((th instanceof MissingMethodException)
+                    && (methodName.equals(((MissingMethodException)th).getMethod())))
+                {
                     first = (MissingMethodException) th;
                 } else {
                     throw gre;
@@ -416,6 +418,7 @@ public final class ClosureMetaClass extends MetaClassImpl {
             try {
                 return go.invokeMethod(methodName, args);
             } catch (MissingMethodException mme) {
+                // patch needed here too, but we need a test case to trip it first
                 if (first == null) first = mme;
             } catch (GroovyRuntimeException gre) {
                 Throwable th = unwrap(gre);
diff --git a/src/test/groovy/ClosureMissingMethodTest.groovy b/src/test/groovy/ClosureMissingMethodTest.groovy
new file mode 100644
index 0000000000..505a88fd1e
--- /dev/null
+++ b/src/test/groovy/ClosureMissingMethodTest.groovy
@@ -0,0 +1,114 @@
+package groovy
+
+/**
+ * @author Danno Ferrin
+ * @version $Revision: ???? $
+ */
+class ClosureMissingMethodTest extends GroovyTestCase {
+
+  void testInScript() {
+      GroovyShell shell = new GroovyShell()
+      shell.evaluate("""
+          int count = 0
+
+          foo = {
+            println "inside foo"
+            count++
+            bar()
+          }
+          baz = {
+            println "inside baz"
+            foo()
+          }
+
+          try {
+              baz()
+              fail()
+          } catch (org.codehaus.groovy.runtime.InvokerInvocationException iie) {
+              assert iie.cause.method == 'bar'
+              assert count == 1
+          } catch (MissingMethodException mme) {
+              assert mme.method == 'bar'
+              assert count == 1
+          }
+      """);
+  }
+
+  void testInMethod() {
+      int count = 0
+
+      def foo = {
+          println "inside foo"
+          count++
+          bar()
+      }
+      def baz = {
+          println "inside baz"
+          foo()
+      }
+
+      try {
+          baz()
+          fail()
+      } catch (MissingMethodException mme) {
+          assert mme.method == 'bar'
+          assert count == 1
+      }
+  }
+
+  void testWithMetaClassInScript() {
+      GroovyShell shell = new GroovyShell()
+      shell.evaluate("""
+          int count = 0
+
+          foo = {
+            println "inside foo"
+            count++
+            bar()
+          }
+          baz = {
+            println "inside baz"
+            foo()
+          }
+          mc = new ExpandoMetaClass(baz.getClass())
+          mc.initialize()
+          baz.metaClass = mc
+
+          try {
+              baz()
+              fail()
+          } catch (org.codehaus.groovy.runtime.InvokerInvocationException iie) {
+              assert iie.cause.method == 'bar'
+              assert count == 1
+          } catch (MissingMethodException mme) {
+              assert mme.method == 'bar'
+              assert count == 1
+          }
+      """);
+  }
+
+  void testWithMetaClassInMethod() {
+      int count = 0
+
+      def foo = {
+          println "inside foo"
+          count++
+          bar()
+      }
+      def baz = {
+          println "inside baz"
+          foo()
+      }
+      MetaClass mc = new ExpandoMetaClass(baz.getClass())
+      mc.initialize()
+      baz.metaClass = mc
+
+      try {
+          baz()
+          fail()
+      } catch (MissingMethodException mme) {
+          assert mme.method == 'bar'
+          assert count == 1
+      }
+  }
+}
