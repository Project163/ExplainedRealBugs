diff --git a/src/main/groovy/util/ConfigObject.groovy b/src/main/groovy/util/ConfigObject.groovy
index 037a830b33..569a3c721f 100644
--- a/src/main/groovy/util/ConfigObject.groovy
+++ b/src/main/groovy/util/ConfigObject.groovy
@@ -101,7 +101,7 @@ class ConfigObject extends LinkedHashMap implements Writable {
      * @return The result of the merge
      */
     Map merge(ConfigObject other) {
-        return merge(this,other)
+        return doMerge(this,other)
     }
 
 
@@ -128,7 +128,7 @@ class ConfigObject extends LinkedHashMap implements Writable {
         return props
     }
 
-    private merge(Map config, Map other) {
+    private doMerge(Map config, Map other) {
         for(entry in other) {
 
             def configEntry = config[entry.key]
@@ -139,7 +139,7 @@ class ConfigObject extends LinkedHashMap implements Writable {
             else {
                 if(configEntry instanceof Map && configEntry.size() > 0 && entry.value instanceof Map) {
                     // recur
-                    merge(configEntry, entry.value)
+                    doMerge(configEntry, entry.value)
                }
                else {
                     config[entry.key] = entry.value
diff --git a/src/main/org/codehaus/groovy/classgen/ClassCompletionVerifier.java b/src/main/org/codehaus/groovy/classgen/ClassCompletionVerifier.java
index 68a0cfa39c..8276a73d36 100644
--- a/src/main/org/codehaus/groovy/classgen/ClassCompletionVerifier.java
+++ b/src/main/org/codehaus/groovy/classgen/ClassCompletionVerifier.java
@@ -300,8 +300,8 @@ public class ClassCompletionVerifier extends ClassCodeVisitorSupport {
 
     private void checkOverloadingPrivateAndPublic(MethodNode node) {
         if (isConstructor(node)) return;
-        boolean hasPrivate = false;
-        boolean hasPublic = false;
+        boolean hasPrivate = node.isPrivate();
+        boolean hasPublic = node.isPublic();
         for (MethodNode method : currentClass.getMethods(node.getName())) {
             if (method == node) continue;
             if (!method.getDeclaringClass().equals(node.getDeclaringClass())) continue;
diff --git a/src/test/groovy/bugs/Groovy5193Bug.groovy b/src/test/groovy/bugs/Groovy5193Bug.groovy
new file mode 100644
index 0000000000..e659e93291
--- /dev/null
+++ b/src/test/groovy/bugs/Groovy5193Bug.groovy
@@ -0,0 +1,33 @@
+package groovy.bugs
+
+import org.codehaus.groovy.control.MultipleCompilationErrorsException
+
+class Groovy5193Bug extends GroovyTestCase {
+    void testMixingMethodsWithPrivatePublicAccessInSameClassV1() {
+        try{
+            assertScript """
+				class Repository5193V1 {
+				  def find(String id) {}
+				  private <T> T find(Class<T> type, String id, boolean suppressNotFoundExceptions) { }
+				}
+            """
+            fail("compilation should have failed saying that mixing private and public/protected methods of the same name causes multimethods to be disabled and is forbidden.")
+        } catch(MultipleCompilationErrorsException ex) {
+            assertTrue ex.message.contains("Mixing private and public/protected methods of the same name causes multimethods to be disabled and is forbidden")
+        }
+    }
+
+	void testMixingMethodsWithPrivatePublicAccessInSameClassV2() {
+		try{
+			assertScript """
+				class Repository5193V2 {
+				  def find(String id) {}
+				  private <T> T find(Class<T> type, String id, boolean suppressNotFoundExceptions = true) { }
+				}
+			"""
+			fail("compilation should have failed saying that mixing private and public/protected methods of the same name causes multimethods to be disabled and is forbidden.")
+		} catch(MultipleCompilationErrorsException ex) {
+			assertTrue ex.message.contains("Mixing private and public/protected methods of the same name causes multimethods to be disabled and is forbidden")
+		}
+	}
+}
\ No newline at end of file
