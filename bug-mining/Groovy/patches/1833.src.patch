diff --git a/src/main/groovy/grape/GrapeIvy.groovy b/src/main/groovy/grape/GrapeIvy.groovy
index fd43d46b0e..576ef846d7 100644
--- a/src/main/groovy/grape/GrapeIvy.groovy
+++ b/src/main/groovy/grape/GrapeIvy.groovy
@@ -47,6 +47,7 @@ import org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl
 import java.util.jar.JarFile
 
 import org.codehaus.groovy.reflection.CachedClass
+import org.codehaus.groovy.reflection.ClassInfo
 
 /**
  * @author Danno Ferrin
@@ -288,9 +289,23 @@ class GrapeIvy implements GrapeEngine {
                     mcRegistry.registerExtensionModuleFromProperties(props, loader, metaMethods)
                     // add old methods to the map
                     metaMethods.each { CachedClass c, List<MetaMethod> methods ->
-                        c.addNewMopMethods(methods)
+                        // GROOVY-5543: if a module was loaded using grab, there are chances that subclasses
+                        // have their own ClassInfo, and we must change them as well!
+                        def classesToBeUpdated = ClassInfo.allClassInfo.findAll {
+                            boolean found = false
+                            CachedClass current = it.cachedClass
+                            while (!found && current != null) {
+                                if (current == c || current.interfaces.contains(c)) {
+                                    found = true
+                                }
+                                current = current.cachedSuperClass
+                            }
+                            found
+                        }.collect { it.cachedClass }
+                        classesToBeUpdated*.addNewMopMethods(methods)
                     }
                 }
+
             }
         }
     }
diff --git a/src/main/org/codehaus/groovy/reflection/ClassInfo.java b/src/main/org/codehaus/groovy/reflection/ClassInfo.java
index 8ab5c0faf2..97cee2a91e 100644
--- a/src/main/org/codehaus/groovy/reflection/ClassInfo.java
+++ b/src/main/org/codehaus/groovy/reflection/ClassInfo.java
@@ -103,6 +103,16 @@ public class ClassInfo extends ManagedConcurrentMap.Entry<Class,ClassInfo> {
         return (ClassInfo) globalClassSet.getOrPut(cls,null);
     }
 
+    public static Collection<ClassInfo> getAllClassInfo () {
+        ThreadLocalMapHandler handler = localMapRef.get();
+        SoftReference<LocalMap> ref=null;
+        if (handler!=null) ref = handler.get();
+        LocalMap map=null;
+        if (ref!=null) map = ref.get();
+        if (map!=null) return map.values();
+        return globalClassSet.values();
+    }
+
     public MetaClass getStrongMetaClass() {
         return strongMetaClass;
     }
diff --git a/src/main/org/codehaus/groovy/util/AbstractConcurrentMapBase.java b/src/main/org/codehaus/groovy/util/AbstractConcurrentMapBase.java
index 05b68e3ac0..0deb678e9b 100644
--- a/src/main/org/codehaus/groovy/util/AbstractConcurrentMapBase.java
+++ b/src/main/org/codehaus/groovy/util/AbstractConcurrentMapBase.java
@@ -15,6 +15,9 @@
  */
 package org.codehaus.groovy.util;
 
+import java.util.Collection;
+import java.util.LinkedList;
+
 public abstract class AbstractConcurrentMapBase {
     protected static final int MAXIMUM_CAPACITY = 1 << 30;
     static final int MAX_SEGMENTS = 1 << 16;
@@ -116,6 +119,38 @@ public abstract class AbstractConcurrentMapBase {
         return count;
     }
 
+    public Collection values() {
+        Collection result = new LinkedList();
+        int count = 0;
+        for (int i = 0; i < segments.length; i++) {
+            segments[i].lock();
+            try {
+                for (int j = 0; j < segments[i].table.length; j++) {
+                    Object o = segments[i].table [j];
+                    if (o != null) {
+                        if (o instanceof Entry) {
+                            Entry e = (Entry) o;
+                            if (e.isValid())
+                              result.add(e);
+                        }
+                        else {
+                            Object arr [] = (Object[]) o;
+                            for (int k = 0; k < arr.length; k++) {
+                                Entry info = (Entry) arr[k];
+                                if (info != null && info.isValid())
+                                    result.add(info);
+                            }
+                        }
+                    }
+                }
+            }
+            finally {
+                segments[i].unlock();
+            }
+        }
+        return result;
+    }
+
     public static class Segment extends LockableObject {
         volatile int count;
 
diff --git a/src/test/jars/module-test/module-test/1.0-test/module-test-1.0-test.jar b/src/test/jars/module-test/module-test/1.1-test/module-test-1.1-test.jar
similarity index 51%
rename from src/test/jars/module-test/module-test/1.0-test/module-test-1.0-test.jar
rename to src/test/jars/module-test/module-test/1.1-test/module-test-1.1-test.jar
index 07a8cb303e..0c24a24cff 100644
Binary files a/src/test/jars/module-test/module-test/1.0-test/module-test-1.0-test.jar and b/src/test/jars/module-test/module-test/1.1-test/module-test-1.1-test.jar differ
diff --git a/src/test/org/codehaus/groovy/runtime/m12n/ExtensionModuleTest.groovy b/src/test/org/codehaus/groovy/runtime/m12n/ExtensionModuleTest.groovy
index 10cdeaa04e..424f6a536b 100644
--- a/src/test/org/codehaus/groovy/runtime/m12n/ExtensionModuleTest.groovy
+++ b/src/test/org/codehaus/groovy/runtime/m12n/ExtensionModuleTest.groovy
@@ -1,9 +1,25 @@
 package org.codehaus.groovy.runtime.m12n
 
+import org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl
+import java.lang.reflect.Modifier
+
 /**
  * Unit tests for extension methods loading.
  */
 class ExtensionModuleTest extends GroovyTestCase {
+
+    @Override
+    protected void setUp() {
+        super.setUp()
+
+        // in order to test the @Grab behaviour, we need to replace the registry between each test
+        GroovySystem.getDeclaredField('META_CLASS_REGISTRY').with {
+            accessible = true
+            modifiers = modifiers & ~Modifier.FINAL
+            set(null, new MetaClassRegistryImpl())
+        }
+    }
+
     void testThatModuleHasBeenLoaded() {
         ExtensionModuleRegistry registry = GroovySystem.metaClassRegistry.moduleRegistry
         assert registry.modules
@@ -19,7 +35,7 @@ class ExtensionModuleTest extends GroovyTestCase {
     void testThatModuleCanBeLoadedWithGrab() {
         ExtensionModuleRegistry registry = GroovySystem.metaClassRegistry.moduleRegistry
         // ensure that the module isn't loaded
-        assert registry.modules.any { it.name == 'Test module for Grab' && it.version == '1.0-test' } == false
+        assert registry.modules.any { it.name == 'Test module for Grab' && it.version == '1.1-test' } == false
 
         // find jar resource
         def jarURL = this.class.getResource("/jars")
@@ -28,14 +44,14 @@ class ExtensionModuleTest extends GroovyTestCase {
         def resolver = "@GrabResolver(name='local',root='$jarURL')"
 
         assertScript resolver+'''
-        @Grab('module-test:module-test:1.0-test')
+        @Grab('module-test:module-test:1.1-test')
         import org.codehaus.groovy.runtime.m12n.*
 
         ExtensionModuleRegistry registry = GroovySystem.metaClassRegistry.moduleRegistry
         registry.modules.each { println "Found module ${it.name}" }
 
         // ensure that the module isn't loaded
-        assert registry.modules.any { it.name == 'Test module for Grab' && it.version == '1.0-test' }
+        assert registry.modules.any { it.name == 'Test module for Grab' && it.version == '1.1-test' }
 
         // the following methods are added by the Grab test module
         def str = 'This is a string'
@@ -44,4 +60,26 @@ class ExtensionModuleTest extends GroovyTestCase {
 
         '''
     }
+
+    void testExtensionModuleUsingGrabAndMap() {
+        ExtensionModuleRegistry registry = GroovySystem.metaClassRegistry.moduleRegistry
+        // ensure that the module isn't loaded
+        assert registry.modules.any { it.name == 'Test module for Grab' && it.version == '1.1-test' } == false
+
+        // find jar resource
+        def jarURL = this.class.getResource("/jars")
+        assert jarURL
+
+        def resolver = "@GrabResolver(name='local',root='$jarURL')"
+
+        assertScript resolver+'''
+        @Grab('module-test:module-test:1.1-test')
+        import org.codehaus.groovy.runtime.m12n.*
+
+        def map = [:]
+        assert 'foo'.taille() == 3
+        assert map.taille() == 0
+
+        '''
+    }
 }
