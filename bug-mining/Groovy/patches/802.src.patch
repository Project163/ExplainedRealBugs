diff --git a/src/main/org/codehaus/groovy/ast/ClassNode.java b/src/main/org/codehaus/groovy/ast/ClassNode.java
index 8ba3746b79..aa66d07b10 100644
--- a/src/main/org/codehaus/groovy/ast/ClassNode.java
+++ b/src/main/org/codehaus/groovy/ast/ClassNode.java
@@ -371,7 +371,17 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
      * this ClassNode
      */
     public List getAbstractMethods() {
-
+        List result = new ArrayList(3);
+        Map declaredMethods = getDeclaredMethodsMap();
+        for (Iterator it = declaredMethods.values().iterator(); it.hasNext();) {
+            MethodNode method = (MethodNode) it.next();
+            if (method.isAbstract()) {
+                result.add(method);
+            }
+        }
+        
+        
+/*
         HashSet abstractNodes = new HashSet();
         // let us collect the abstract super classes and stop at the
         // first non abstract super class. If such a class still
@@ -381,10 +391,9 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
         do {
             abstractNodes.add(parent);
             ClassNode[] interfaces = parent.getInterfaces();
-            List interfaceList = new ArrayList(Arrays.asList(interfaces));
+            LinkedList interfaceList = new LinkedList(Arrays.asList(interfaces));
             while (!interfaceList.isEmpty()) {
-                final ClassNode interfaceNode = (ClassNode) interfaceList.get(0);
-                interfaceList.remove(0);
+                ClassNode interfaceNode = (ClassNode) interfaceList.removeFirst();
                 abstractNodes.add(interfaceNode.redirect());
                 interfaceList.addAll(Arrays.asList(interfaceNode.getInterfaces()));
             }
@@ -394,18 +403,16 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
         List result = new ArrayList();
         for (Object o : getAllDeclaredMethods()) {
             MethodNode method = (MethodNode) o;
-            // add only abstract methods from abtract classes that
+            // add only abstract methods from abstract classes that
             // are not overwritten
-            if ( abstractNodes.contains(method.getDeclaringClass().redirect()) &&
-                 (method.getModifiers() & Opcodes.ACC_ABSTRACT) != 0
-               ) {
+            if (abstractNodes.contains(method.getDeclaringClass().redirect()) && method.isAbstract()) {
                 result.add(method);
             }
-        }
+        }*/
+        
         if (result.isEmpty()) {
             return null;
-        }
-        else {
+        } else {
             return result;
         }
     }
@@ -437,8 +444,7 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
         Map result = null;
         if (parent != null) {
             result = parent.getDeclaredMethodsMap();
-        }
-        else {
+        } else {
             result = new HashMap();
         }
 
diff --git a/src/main/org/codehaus/groovy/classgen/Verifier.java b/src/main/org/codehaus/groovy/classgen/Verifier.java
index 624fc67416..8f88aefa36 100644
--- a/src/main/org/codehaus/groovy/classgen/Verifier.java
+++ b/src/main/org/codehaus/groovy/classgen/Verifier.java
@@ -853,22 +853,29 @@ public class Verifier implements GroovyClassVisitor, Opcodes {
     
     protected void addCovariantMethods(ClassNode classNode) {
         Map methodsToAdd = new HashMap();
-        List declaredMethods = new ArrayList(classNode.getMethods());
         Map genericsSpec = new HashMap();
-        
-        // remove static methods from declaredMethods
+
+        List declaredMethods = classNode.getAllDeclaredMethods();
+        // remove all static, private and package private methods
+        // we remove also abstract methods if the current class is not abstract
+        // we do remove abstract methods, because covariation may automatically implement them
+        boolean isNotAbstract = (classNode.getModifiers() & ACC_ABSTRACT)==0;
         for (Iterator methodsIterator = declaredMethods.iterator(); methodsIterator.hasNext();) {
             MethodNode m = (MethodNode) methodsIterator.next();
-            if (m.isStatic()) methodsIterator.remove();
+            if (m.isStatic() || !(m.isPublic() || m.isProtected())) {
+                methodsIterator.remove();
+            } else if (isNotAbstract && m.isAbstract()) {
+                methodsIterator.remove();
+            }
         }
         
         addCovariantMethods(classNode, declaredMethods, methodsToAdd, genericsSpec);
 
-        Set declaredMethodsSet = new HashSet();
+        Map declaredMethodsMap = new HashMap();
         if (methodsToAdd.size()>0) {
             for (Iterator methodsIterator = declaredMethods.iterator(); methodsIterator.hasNext();) {
                 MethodNode m = (MethodNode) methodsIterator.next();
-                declaredMethodsSet.add(m.getTypeDescriptor());
+                declaredMethodsMap.put(m.getTypeDescriptor(),m);
             }
         }
         
@@ -876,7 +883,8 @@ public class Verifier implements GroovyClassVisitor, Opcodes {
             Map.Entry entry = (Map.Entry) it.next();
             MethodNode method = (MethodNode) entry.getValue();
             // we skip bridge methods implemented in current class already
-            if (declaredMethodsSet.contains(entry.getKey())) continue;
+            MethodNode mn = (MethodNode) declaredMethodsMap.get(entry.getKey());
+            if (mn!=null && mn.getDeclaringClass().equals(classNode)) continue;
             classNode.addMethod(method);
         }
     }
@@ -926,21 +934,24 @@ public class Verifier implements GroovyClassVisitor, Opcodes {
         ClassNode testmr = correctToGenericsSpec(genericsSpec,omr);
         if (!isAssignable(mr,testmr)){
             throw new RuntimeParserException(
-                    "the return type is incompatible with "+
+                    "The return type of "+
+                    overridingMethod.getTypeDescriptor()+
+                    " in "+overridingMethod.getDeclaringClass().getName()+
+                    " is incompatible with "+
                     oldMethod.getTypeDescriptor()+
                     " in "+oldMethod.getDeclaringClass().getName(),
                     overridingMethod);
         }
         if ((oldMethod.getModifiers()&ACC_FINAL)!=0) {
             throw new RuntimeParserException(
-                    "cannot override final method "+
+                    "Cannot override final method "+
                     oldMethod.getTypeDescriptor()+
                     " in "+oldMethod.getDeclaringClass().getName(),
                     overridingMethod);
         }
         if (oldMethod.isStatic() != overridingMethod.isStatic()){
             throw new RuntimeParserException(
-                    "cannot override method "+
+                    "Cannot override method "+
                     oldMethod.getTypeDescriptor()+
                     " in "+oldMethod.getDeclaringClass().getName()+
                     " with disparate static modifier",
diff --git a/src/test/gls/invocation/CovariantReturnTest.groovy b/src/test/gls/invocation/CovariantReturnTest.groovy
index 0a6e15aef4..7d07993131 100644
--- a/src/test/gls/invocation/CovariantReturnTest.groovy
+++ b/src/test/gls/invocation/CovariantReturnTest.groovy
@@ -100,4 +100,33 @@ public class CovariantReturnTest extends CompilableTestSupport {
     """
   }
 
+  void testCovariantMethodFromParentOverwritingMethodFromInterfaceInCurrentclass() {
+    assertScript """
+      interface I {
+        def foo()
+      } 
+      class A {
+        String foo(){""}
+      }
+      class B extends A implements I{}
+      def b = new B()
+      assert b.foo() == ""
+    """
+  
+    // basically the same as above, but with an example
+    // from an error report (GROOVY-2582)
+    // Properties has a method "String getProperty(String)", this class
+    // is also a GroovyObject, meaning a "Object getProperty(String)" method
+    // should be implemented. But this method should not be the usual automatically
+    // added getProperty, but a bridge to the getProperty method provided by Properties 
+    shouldCompile """
+      class Configuration extends java.util.Properties {}
+      assert Configuration.declaredMethods.findAll{it.name=="getProperty"}.size() == 1
+      def conf = new Configuration()
+      conf.setProperty("a","b")           
+      // the following assert would fail if standard getProperty method was added
+      // by the compiler 
+      assert conf.getProperty("a") == "b" 
+    """
+  }
 }
