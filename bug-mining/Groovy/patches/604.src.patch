diff --git a/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java b/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
index 11e4f25934..d8e4a001e4 100644
--- a/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
+++ b/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
@@ -28,6 +28,7 @@ import org.codehaus.groovy.runtime.MetaClassHelper;
 import org.codehaus.groovy.runtime.ScriptBytecodeAdapter;
 import org.codehaus.groovy.runtime.callsite.CallSite;
 import org.codehaus.groovy.syntax.RuntimeParserException;
+import org.codehaus.groovy.syntax.Token;
 import org.codehaus.groovy.syntax.Types;
 import org.objectweb.asm.AnnotationVisitor;
 import org.objectweb.asm.*;
@@ -3536,20 +3537,40 @@ public class AsmClassGenerator extends ClassGenerator {
                 // -> (x, [], 5), =, x[5] + 10
                 // -> methodCall(x, "putAt", [5, methodCall(x[5], "plus", 10)])
 
+                final Expression objExpr = leftBinExpr.getLeftExpression();
+                objExpr.visit(this);
+                final int objVar = compileStack.defineTemporaryVariable("$object", true);
+
+                final Expression indexExpr = leftBinExpr.getRightExpression();
+                indexExpr.visit(this);
+                final int indexVar = compileStack.defineTemporaryVariable("$index", true);
+
+                final BinaryExpression leftExpr = new BinaryExpression(
+                        new VariableExpression("$object"),
+                        Token.newSymbol(Types.LEFT_SQUARE_BRACKET, -1, -1),
+                        new VariableExpression("$index")
+                );
                 MethodCallExpression methodCall =
                         new MethodCallExpression(
-                                expression.getLeftExpression(),
+                                leftExpr,
                                 method,
                                 new ArgumentListExpression(expression.getRightExpression()));
 
-                Expression safeIndexExpr = createReusableExpression(leftBinExpr.getRightExpression());
+                methodCall.visit(this);
+                final int resultVar = compileStack.defineTemporaryVariable("$result", true);
 
                 visitMethodCallExpression(
                         new MethodCallExpression(
-                                leftBinExpr.getLeftExpression(),
+                                new VariableExpression("$object"),
                                 "putAt",
-                                new ArgumentListExpression(safeIndexExpr, methodCall)));
-                //cv.visitInsn(POP);
+                                new ArgumentListExpression(
+                                        new Expression[]{ new VariableExpression("$index"), new VariableExpression("$result")})));
+                mv.visitInsn(POP); //drop return value
+
+                mv.visitVarInsn(ALOAD, resultVar );
+                compileStack.removeVar(resultVar);
+                compileStack.removeVar(indexVar);
+                compileStack.removeVar(objVar);
                 return;
             }
         }
@@ -3583,13 +3604,20 @@ public class AsmClassGenerator extends ClassGenerator {
                 // -> (x, [], 5), =, 10
                 // -> methodCall(x, "putAt", [5, 10])
 
+                final Expression right = expression.getRightExpression();
+                right.visit(this);
+                final int rhsVar = compileStack.defineTemporaryVariable("$rhs", right.getType(), true);
+
                 visitMethodCallExpression(
                         new MethodCallExpression(
                                 leftBinExpr.getLeftExpression(),
                                 "putAt",
                                 new ArgumentListExpression(
-                                        new Expression[]{leftBinExpr.getRightExpression(), expression.getRightExpression()})));
-                // cv.visitInsn(POP); //this is realted to isPopRequired()
+                                        new Expression[]{leftBinExpr.getRightExpression(), new VariableExpression("$rhs")})));
+                mv.visitInsn(POP); //drop return value
+
+                mv.visitVarInsn(ALOAD, rhsVar);
+                compileStack.removeVar(rhsVar);
                 return;
             }
         }
diff --git a/src/main/org/codehaus/groovy/classgen/CompileStack.java b/src/main/org/codehaus/groovy/classgen/CompileStack.java
index 1c13427d05..0283d9055b 100644
--- a/src/main/org/codehaus/groovy/classgen/CompileStack.java
+++ b/src/main/org/codehaus/groovy/classgen/CompileStack.java
@@ -74,7 +74,7 @@ public class CompileStack implements Opcodes {
     // index for the next variable on stack
     private int nextVariableIndex = 1;
     // currently temporary variables in use
-    private final List temporaryVariables = new LinkedList();
+    private final LinkedList temporaryVariables = new LinkedList();
     // overall used variables for a method/constructor
     private final LinkedList usedVariables = new LinkedList();
     // map containing named labels of parenting blocks
@@ -212,6 +212,15 @@ public class CompileStack implements Opcodes {
         if (variableName.equals("this")) return Variable.THIS_VARIABLE;
         if (variableName.equals("super")) return Variable.SUPER_VARIABLE;
         Variable v = (Variable) stackVariables.get(variableName);
+        if (v == null) {
+            for (Iterator it = temporaryVariables.iterator(); it.hasNext(); ) {
+                Variable tvar = (Variable) it.next();
+                if (tvar.getName().equals(variableName)) {
+                    v = tvar;
+                    break;
+                }
+            }
+        }
         if (v==null && mustExist)  throw new GroovyBugError("tried to get a variable with the name "+variableName+" as stack variable, but a variable with this name was not created");
         return v;
     }
@@ -237,7 +246,7 @@ public class CompileStack implements Opcodes {
      */
     public int defineTemporaryVariable(String name, ClassNode node, boolean store) {
         Variable answer = defineVar(name,node,false);
-        temporaryVariables.add(answer);
+        temporaryVariables.addFirst(answer); // TRICK: we add at the beginning so when we find for remove or get we always have the last one
         usedVariables.removeLast();
         
         if (store) mv.visitVarInsn(ASTORE, currentVariableIndex);
diff --git a/src/test/groovy/MapTest.groovy b/src/test/groovy/MapTest.groovy
index 7fcd0a086b..1efa58eb02 100644
--- a/src/test/groovy/MapTest.groovy
+++ b/src/test/groovy/MapTest.groovy
@@ -86,7 +86,9 @@ class MapTest extends GroovyTestCase {
         
         def foo = m['def'] = 5
         assert m['def'] == 5
-        assert foo == null
+//  it is not valid any more
+//        assert foo == null
+        assert foo == 5
     }
 
     void testFindAll(){
diff --git a/src/test/groovy/bugs/Groovy2391Bug.groovy b/src/test/groovy/bugs/Groovy2391Bug.groovy
index 81b87cab6e..478cdc345d 100644
--- a/src/test/groovy/bugs/Groovy2391Bug.groovy
+++ b/src/test/groovy/bugs/Groovy2391Bug.groovy
@@ -10,5 +10,7 @@ class Groovy2391Bug extends GroovyTestCase{
       ArrayList.metaClass.initialize()
 
       assertEquals("Boom", [1,"Boom",3] as String)
+
+      GroovySystem.metaClassRegistry.removeMetaClass ArrayList
     }
 }
\ No newline at end of file
diff --git a/src/test/groovy/bugs/Groovy2556Bug.groovy b/src/test/groovy/bugs/Groovy2556Bug.groovy
new file mode 100644
index 0000000000..6d6843aff3
--- /dev/null
+++ b/src/test/groovy/bugs/Groovy2556Bug.groovy
@@ -0,0 +1,82 @@
+package groovy.bugs
+
+class Groovy2556Bug extends GroovyTestCase {
+    final String SOME_METHOD_VALUE = 'someMethodValue'
+    final String TEST_NAME = 'someName'
+
+    String s
+
+    Map names
+
+    void setUp() {
+        names = [:]
+    }
+
+    private count = 0
+
+    private getCount () {
+        count++;
+    }
+
+    void testCompile () {
+        new GroovyShell().parse ("""
+        def arr = [2:0]
+        assert 33 == (arr[2] += 33)
+        """).run ()
+    }
+
+    void testAssignmentWithString() {
+        assertEquals(SOME_METHOD_VALUE, someMethod())
+    }
+
+    void testAssignmentWithMap() {
+        assertEquals(TEST_NAME, addName(TEST_NAME))
+    }
+
+    void testAssignmentWithReturnMap() {
+        assertEquals(TEST_NAME, addNameWithReturn(TEST_NAME))
+    }
+
+    String someMethod() {
+        s = SOME_METHOD_VALUE
+    }
+
+    String addName(String name) {
+        names[name] = name
+    }
+
+    String addNameWithReturn(String name) {
+        return names[name] = name
+    }
+
+    void testArrayAssignment() {
+        def arr = [*0..4]
+        assert 33 == (arr[2] = 33)
+        assert 55 == (arr[2] += 22)
+    }
+
+    void testArrayAssignmentInClosure() {
+        def arr = [*0..4]
+        assert 55 == { arr[2] = 55 }.call()
+        assert 88 == { arr[2] += 33 }.call()
+    }
+
+    void testVarAssignment() {
+        def var = 1
+        assert 77 == ( var = 77)
+    }
+
+    void testVarAssignmentInClosure() {
+        def var = 1
+        assert 22 == { var = 22 }.call()
+        assert 55 == { var += 33 }.call()
+    }
+
+    void testReusableExpression() {
+        def arr = [*1..5]
+        assert 34 == (arr[getCount()] += 33)
+        assert 34 == arr [0]
+        assert 2 == arr [getCount()]
+    }
+}
+
