diff --git a/src/main/java/org/codehaus/groovy/transform/trait/TraitASTTransformation.java b/src/main/java/org/codehaus/groovy/transform/trait/TraitASTTransformation.java
index e9ea9b8db9..a42eaa6135 100644
--- a/src/main/java/org/codehaus/groovy/transform/trait/TraitASTTransformation.java
+++ b/src/main/java/org/codehaus/groovy/transform/trait/TraitASTTransformation.java
@@ -161,18 +161,15 @@ public class TraitASTTransformation extends AbstractASTTransformation implements
     private void replaceExtendsByImplements(final ClassNode cNode) {
         ClassNode superClass = cNode.getUnresolvedSuperClass();
         if (Traits.isTrait(superClass)) {
-            // move from super class to interface;
+            // move from super class to interface
             cNode.setSuperClass(ClassHelper.OBJECT_TYPE);
             cNode.setUnresolvedSuperClass(ClassHelper.OBJECT_TYPE);
             cNode.addInterface(superClass);
-            resolveScope(cNode);
         }
     }
 
     private void resolveScope(final ClassNode cNode) {
-        // we need to resolve again!
-        VariableScopeVisitor scopeVisitor = new VariableScopeVisitor(sourceUnit);
-        scopeVisitor.visitClass(cNode);
+        new VariableScopeVisitor(sourceUnit).visitClass(cNode);
     }
 
     private void checkNoConstructor(final ClassNode cNode) {
diff --git a/src/main/java/org/codehaus/groovy/transform/trait/TraitReceiverTransformer.java b/src/main/java/org/codehaus/groovy/transform/trait/TraitReceiverTransformer.java
index 3967ea34b5..c2b6792ce2 100644
--- a/src/main/java/org/codehaus/groovy/transform/trait/TraitReceiverTransformer.java
+++ b/src/main/java/org/codehaus/groovy/transform/trait/TraitReceiverTransformer.java
@@ -300,28 +300,35 @@ class TraitReceiverTransformer extends ClassCodeExpressionTransformer {
     private Expression transformMethodCallOnThis(final MethodCallExpression call) {
         Expression method = call.getMethod();
         Expression arguments = call.getArguments();
-        Expression objectExpr = call.getObjectExpression();
+        Expression thisExpr = call.getObjectExpression();
 
         if (method instanceof ConstantExpression) {
             String methodName = call.getMethodAsString();
             for (MethodNode methodNode : traitClass.getMethods(methodName)) {
                 if (methodName.equals(methodNode.getName()) && (methodNode.isStatic() || methodNode.isPrivate())) {
-                    ArgumentListExpression newArgs = createArgumentList(methodNode.isStatic() ? asClass(objectExpr) : weaved, arguments);
-                    MethodCallExpression newCall = callX(inClosure ? classX(traitHelperClass) : varX("this"), methodName, newArgs);
-                    newCall.setImplicitThis(true);
-                    newCall.setSafe(call.isSafe());
-                    newCall.setSourcePosition(call);
+                    MethodCallExpression newCall;
+                    if (!inClosure && methodNode.isStatic()) { // GROOVY-10312: $self or $static$self.staticMethod(...)
+                        newCall = callX(varX(weaved), methodName, transform(arguments));
+                        newCall.setImplicitThis(false);
+                        newCall.setSafe(false);
+                    } else {
+                        ArgumentListExpression newArgs = createArgumentList(methodNode.isStatic() ? asClass(varX("this")) : weaved, arguments);
+                        newCall = callX(inClosure ? classX(traitHelperClass) : thisExpr, methodName, newArgs);
+                        newCall.setImplicitThis(true);
+                        newCall.setSafe(call.isSafe());
+                    }
                     newCall.setSpreadSafe(call.isSpreadSafe());
+                    newCall.setSourcePosition(call);
                     return newCall;
                 }
             }
         }
 
-        MethodCallExpression newCall = callX(inClosure ? objectExpr : weaved, method, transform(arguments));
+        MethodCallExpression newCall = callX(inClosure ? thisExpr : weaved, method, transform(arguments));
         newCall.setImplicitThis(inClosure ? call.isImplicitThis() : false);
-        newCall.setSafe(call.isSafe());
-        newCall.setSourcePosition(call);
+        newCall.setSafe(inClosure ? call.isSafe() : false);
         newCall.setSpreadSafe(call.isSpreadSafe());
+        newCall.setSourcePosition(call);
         return newCall;
     }
 
diff --git a/src/test/org/codehaus/groovy/transform/traitx/TraitASTTransformationTest.groovy b/src/test/org/codehaus/groovy/transform/traitx/TraitASTTransformationTest.groovy
index 6aec616fad..dfef1af17e 100644
--- a/src/test/org/codehaus/groovy/transform/traitx/TraitASTTransformationTest.groovy
+++ b/src/test/org/codehaus/groovy/transform/traitx/TraitASTTransformationTest.groovy
@@ -3269,6 +3269,63 @@ final class TraitASTTransformationTest {
         '''
     }
 
+    @Test // GROOVY-10312
+    void testTraitAccessToInheritedStaticMethods2() {
+        assertScript '''
+            trait Foo {
+                static String staticMethod(String string) {
+                    return string
+                }
+            }
+            trait Bar extends Foo {
+                static String staticMethodWithDefaultArgument(String string = 'works') {
+                    staticMethod(string) // MissingMethodException
+                }
+            }
+
+            class Main implements Bar {
+                static test1() {
+                    String result = staticMethodWithDefaultArgument()
+                    assert result == 'works'
+                }
+                void test2() {
+                    String result = staticMethodWithDefaultArgument()
+                    assert result == 'works'
+                }
+            }
+
+            Main.test1()
+            new Main().test2()
+        '''
+    }
+
+    @Test // GROOVY-10312
+    void testTraitAccessToInheritedStaticMethods3() {
+        assertScript '''
+            trait Foo {
+                public static final String BANG = '!'
+
+                static String staticMethodWithDefaultArgument(String string = 'works') {
+                    string + this.BANG
+                }
+            }
+
+            class Main implements Foo {
+                static test1() {
+                    String result = staticMethodWithDefaultArgument()
+                    assert result == 'works!'
+                }
+                void test2() {
+                    String result = staticMethodWithDefaultArgument()
+                    assert result == 'works!'
+                }
+            }
+
+            Main.test1()
+            new Main().test2()
+        '''
+    }
+
     @Test // GROOVY-9386
     void testTraitPropertyInitializedByTap() {
         assertScript '''
