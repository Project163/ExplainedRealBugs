diff --git a/src/main/org/codehaus/groovy/reflection/ClassInfo.java b/src/main/org/codehaus/groovy/reflection/ClassInfo.java
index dc0178316e..5aaa72419a 100644
--- a/src/main/org/codehaus/groovy/reflection/ClassInfo.java
+++ b/src/main/org/codehaus/groovy/reflection/ClassInfo.java
@@ -16,6 +16,7 @@
 package org.codehaus.groovy.reflection;
 
 import groovy.lang.*;
+
 import org.codehaus.groovy.reflection.stdclasses.*;
 import org.codehaus.groovy.util.*;
 
@@ -146,11 +147,20 @@ public class ClassInfo extends ManagedConcurrentMap.Entry<Class,ClassInfo> {
     private MetaClass getMetaClassUnderLock() {
         MetaClass answer;
         answer = getMetaClassForClass();
-        if (answer != null) return answer;
-
         final MetaClassRegistry metaClassRegistry = GroovySystem.getMetaClassRegistry();
-        answer = metaClassRegistry.getMetaClassCreationHandler()
-                                  .create(get(), metaClassRegistry);
+        MetaClassRegistry.MetaClassCreationHandle mccHandle = metaClassRegistry.getMetaClassCreationHandler();
+        
+        if (answer != null) {
+            boolean enableGloballyOn = (mccHandle instanceof ExpandoMetaClassCreationHandle);
+            boolean cachedAnswerIsEMC = (answer instanceof ExpandoMetaClass);
+            // if EMC.enableGlobally() is OFF, return whatever the cached answer is.
+            // but if EMC.enableGlobally() is ON and the cached answer is not an EMC, come up with a fresh answer
+            if(!enableGloballyOn || cachedAnswerIsEMC) {
+                return answer;
+            }
+        }
+
+        answer = mccHandle.create(get(), metaClassRegistry);
         answer.initialize();
 
         if (GroovySystem.isKeepJavaMetaClasses()) {
diff --git a/src/test/groovy/bugs/Groovy3873Bug.groovy b/src/test/groovy/bugs/Groovy3873Bug.groovy
new file mode 100644
index 0000000000..13b0214a5a
--- /dev/null
+++ b/src/test/groovy/bugs/Groovy3873Bug.groovy
@@ -0,0 +1,16 @@
+package groovy.bugs
+
+class Groovy3873Bug extends GroovyTestCase {
+    void testAddingMethodsToMetaClassOfInterface() {
+        try {
+            ExpandoMetaClass.enableGlobally()
+            List.metaClass.methodMissing = { String name, args ->
+                true
+            }
+            def list = []
+            assert list.noSuchMethod()
+        } finally {
+            ExpandoMetaClass.disableGlobally()
+        }
+    }
+}
\ No newline at end of file
