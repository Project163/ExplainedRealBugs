diff --git a/src/main/org/codehaus/groovy/classgen/asm/CompileStack.java b/src/main/org/codehaus/groovy/classgen/asm/CompileStack.java
index 73973071dd..ba856bceca 100644
--- a/src/main/org/codehaus/groovy/classgen/asm/CompileStack.java
+++ b/src/main/org/codehaus/groovy/classgen/asm/CompileStack.java
@@ -257,7 +257,7 @@ public class CompileStack implements Opcodes {
      * @param store defines if the toplevel argument of the stack should be stored
      * @return the index used for this temporary variable
      */
-    public int defineTemporaryVariable(org.codehaus.groovy.ast.Variable var, boolean store) {
+    public int defineTemporaryVariable(Variable var, boolean store) {
         return defineTemporaryVariable(var.getName(), var.getType(),store);
     }
 
@@ -772,25 +772,26 @@ public class CompileStack implements Opcodes {
 
         MethodVisitor mv = controller.getMethodVisitor();
 
-        Label end = new Label();
-        mv.visitInsn(NOP);
-        mv.visitLabel(end);
-        Label newStart = new Label();
-
         for (BlockRecorder fb : blocks) {
             if (visitedBlocks.contains(fb)) continue;
 
+            Label end = new Label();
+            mv.visitInsn(NOP);
+            mv.visitLabel(end);
+
             fb.closeRange(end);
 
             // we exclude the finally block from the exception table
             // here to avoid double visiting of finally statements
             fb.excludedStatement.run();
 
+            Label newStart = new Label();
             fb.startRange(newStart);
+
+            mv.visitInsn(NOP);
+            mv.visitLabel(newStart);
         }
 
-        mv.visitInsn(NOP);
-        mv.visitLabel(newStart);
     }
 
     public void applyBlockRecorder() {
diff --git a/src/test/groovy/bugs/Groovy8085Bug.groovy b/src/test/groovy/bugs/Groovy8085Bug.groovy
new file mode 100644
index 0000000000..f1a9310c99
--- /dev/null
+++ b/src/test/groovy/bugs/Groovy8085Bug.groovy
@@ -0,0 +1,91 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package groovy.bugs
+
+class Groovy8085Bug extends GroovyTestCase {
+    void testTryCatchFinally() {
+        assertScript '''
+            try {
+                try {
+                    true
+                } finally {
+                    99 / 0
+                }
+            } catch (Exception e) {
+                System.out.println("catch!!!");
+            }
+        '''
+    }
+
+    void testTryCatchFinally2() {
+        assertScript '''
+            def visitSequence = []
+            try {
+                try {
+                    true
+                } finally {
+                    visitSequence << 'innerFinally'
+                    99 / 0
+                }
+            } catch (Exception e) {
+                visitSequence << 'outerCatch'
+                System.out.println("catch!!!");
+            } finally {
+                visitSequence << 'outerFinally'
+            }
+            
+            assert ['innerFinally', 'outerCatch', 'outerFinally'] == visitSequence
+        '''
+    }
+
+    void testTryCatchFinallyWithExplicitReturn() {
+        assertScript '''
+            try {
+                try {
+                    return true
+                } finally {
+                    99 / 0
+                }
+            } catch (Exception e) {
+                System.out.println("catch!!!");
+            }
+        '''
+    }
+
+    void testTryCatchFinallyWithExplicitReturn2() {
+        assertScript '''
+            def visitSequence = []
+            try {
+                try {
+                    return true
+                } finally {
+                    visitSequence << 'innerFinally'
+                    99 / 0
+                }
+            } catch (Exception e) {
+                visitSequence << 'outerCatch'
+                System.out.println("catch!!!");
+            } finally {
+                visitSequence << 'outerFinally'
+            }
+            
+            assert ['innerFinally', 'outerCatch', 'outerFinally'] == visitSequence
+        '''
+    }
+}
