diff --git a/src/main/groovy/lang/MetaClassRegistry.java b/src/main/groovy/lang/MetaClassRegistry.java
index 6ea284df95..410138c8fb 100644
--- a/src/main/groovy/lang/MetaClassRegistry.java
+++ b/src/main/groovy/lang/MetaClassRegistry.java
@@ -19,6 +19,7 @@ import org.codehaus.groovy.runtime.GeneratedClosure;
 import org.codehaus.groovy.runtime.metaclass.ClosureMetaClass;
 
 import java.lang.reflect.Constructor;
+import java.util.Iterator;
 
 /**
  * A MetaClassRegistry is an object that is responsible for managing the a cache of MetaClass instances. Each
@@ -29,13 +30,14 @@ import java.lang.reflect.Constructor;
  *
  * @author John Wilson
  * @author Graeme Rocher
+ * @author <a href="mailto:blackdrag@gmx.org">Jochen Theodorou</a>
  *
  */
 public interface MetaClassRegistry {
     /*
-     * The main function of the Registry
-     * If a Metaclass exists then return it
-     * otherwise create one, put it in the Registry and return it
+     * The main function of the registry
+     * If a meta class exists then return it
+     * otherwise create one, put it in the registry and return it
      */
     MetaClass getMetaClass(Class theClass);
     
@@ -60,10 +62,45 @@ public interface MetaClassRegistry {
     /**
      * Sets the MetaClassCreationHandle instance that is responsible for constructing instances
      *
-     * @param handle The hande instance
+     * @param handle The handle instance
      */
     void setMetaClassCreationHandle(MetaClassCreationHandle handle);
 
+    /**
+     * adds a ConstantMetaClassChangeListener
+     *
+     * @param listener - the update listener
+     */
+    void addMetaClassRegistryChangeEventListener(MetaClassRegistryChangeEventListener listener);
+
+    /**
+     * removes a ConstantMetaClassChangeListener
+     *
+     * @param listener - the update listener
+     */
+    void removeMetaClassRegistryChangeEventListener(MetaClassRegistryChangeEventListener listener);
+
+    /**
+     * gets all registered ConstantMetaClassChangeListener
+     *
+     * @returns an array containing all change listener
+     */
+    MetaClassRegistryChangeEventListener[] getMetaClassRegistryChangeEventListeners();
+
+    /**
+     * gets a snapshot of the current constant meta classes and returns it as Iterator.
+     * Modifications done using this Iterator will not cause a ConcurrentMoidificationExcpetion.
+     * If a MetaClass is removed using this Iterator, then the MetaClass will only
+     * be removed if the MetaClass was not replaced by another MetaClass in the meantime.
+     * If a MetaClass is added while using this Iterator, then it will be part of the Iteration.
+     * If a MetaClass replaces another constant meta class, then the Iteration might show two
+     * meta classes for the same class.<br/>
+     * This Iterator may not used in multiple threads.
+     *
+     * @return Iterator for the constant meta classes
+     */
+    Iterator iterator();    
+    
     /**
      * Class used as base for the creation of MetaClass implementations.
      * The Class defaults to MetaClassImpl, if the class loading fails to
diff --git a/src/main/groovy/lang/MetaClassRegistryChangeEvent.java b/src/main/groovy/lang/MetaClassRegistryChangeEvent.java
new file mode 100644
index 0000000000..26d65eed16
--- /dev/null
+++ b/src/main/groovy/lang/MetaClassRegistryChangeEvent.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2003-2007 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package groovy.lang;
+
+import java.util.EventObject;
+
+/**
+ * An event used to propagate meta class updates
+ * @author <a href="mailto:blackdrag@gmx.org">Jochen Theodorou</a>
+ */
+public class MetaClassRegistryChangeEvent extends EventObject {
+	private Class clazz;
+	private MetaClass metaClass;
+	
+	public MetaClassRegistryChangeEvent(Object source, Class clazz, MetaClass metaClass ) {
+		super(source);
+		this.clazz = clazz;
+		this.metaClass = metaClass;
+	}
+	
+	public Class getClassToUpdate() {
+		return clazz;
+	}
+	
+	public MetaClass getNewMetaClass() {
+		return metaClass;
+	}
+
+}
diff --git a/src/main/groovy/lang/MetaClassRegistryChangeEventListener.java b/src/main/groovy/lang/MetaClassRegistryChangeEventListener.java
new file mode 100644
index 0000000000..768cc5d9dd
--- /dev/null
+++ b/src/main/groovy/lang/MetaClassRegistryChangeEventListener.java
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2003-2007 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package groovy.lang;
+
+import java.util.EventListener;
+
+/**
+ * A listener called whenever a constant MetaClass is set, removed or replaced. 
+ *
+ * @see groovy.lang.MetaClassRegistry
+ * @see MetaClassRegistryChangeEvent.lang.ConstantMetaClassChange
+ *
+ * @author <a href="mailto:blackdrag@gmx.org">Jochen Theodorou</a>
+  *
+ */
+public interface MetaClassRegistryChangeEventListener extends EventListener{
+
+    /**
+     * Called when the a constant MetaClass is updated. If the new MetaClass is null, then the MetaClass
+     * is removed. Be careful, while this method is executed other updates may happen. If you want this
+     * method thread safe, you have to take care of that by yourself.
+     *
+     * @param cmcu - the change event
+     */
+    void updateConstantMetaClass(MetaClassRegistryChangeEvent cmcu);
+}
diff --git a/src/main/org/codehaus/groovy/runtime/metaclass/MetaClassRegistryImpl.java b/src/main/org/codehaus/groovy/runtime/metaclass/MetaClassRegistryImpl.java
index d5b2bab66b..65ba1ace2f 100644
--- a/src/main/org/codehaus/groovy/runtime/metaclass/MetaClassRegistryImpl.java
+++ b/src/main/org/codehaus/groovy/runtime/metaclass/MetaClassRegistryImpl.java
@@ -16,17 +16,21 @@
 package org.codehaus.groovy.runtime.metaclass;
 
 import groovy.lang.*;
+
 import org.codehaus.groovy.reflection.*;
 import org.codehaus.groovy.runtime.DefaultGroovyMethods;
 import org.codehaus.groovy.runtime.DefaultGroovyStaticMethods;
 import org.codehaus.groovy.vmplugin.VMPluginFactory;
 import org.codehaus.groovy.util.FastArray;
 
+import java.lang.ref.ReferenceQueue;
+import java.lang.ref.WeakReference;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Modifier;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.Iterator;
+import java.util.LinkedList;
 import java.util.Map;
 import java.util.concurrent.atomic.AtomicInteger;
 
@@ -50,6 +54,10 @@ public class MetaClassRegistryImpl implements MetaClassRegistry{
     private FastArray staticMethods = new FastArray();
 
     private AtomicInteger version = new AtomicInteger();
+    
+    private LinkedList changeListenerList = new LinkedList();
+    private LinkedList metaClassInfo = new LinkedList();
+    private ReferenceQueue queue = new ReferenceQueue();
 
     public static final int LOAD_DEFAULT = 0;
     public static final int DONT_LOAD_DEFAULT = 1;
@@ -99,6 +107,15 @@ public class MetaClassRegistryImpl implements MetaClassRegistry{
         final MetaClass emcMetaClass = metaClassCreationHandle.create(ExpandoMetaClass.class, this);
         emcMetaClass.initialize();
         ClassInfo.getClassInfo(ExpandoMetaClass.class).setStrongMetaClass(emcMetaClass);
+        
+
+        addMetaClassRegistryChangeEventListener(new MetaClassRegistryChangeEventListener(){
+            public void updateConstantMetaClass(MetaClassRegistryChangeEvent cmcu) {
+                synchronized (metaClassInfo) {
+                    metaClassInfo.add(new WeakReference(cmcu.getNewMetaClass(),queue));
+                }
+            }
+        });
    }
 
     /**
@@ -131,8 +148,7 @@ public class MetaClassRegistryImpl implements MetaClassRegistry{
                     final String className = "org.codehaus.groovy.runtime.dgm$" + i;
                     final Class aClass = Class.forName(className);
                     createMetaMethodFromClass(map, aClass);
-                }
-                catch(ClassNotFoundException e){
+                } catch (ClassNotFoundException e){
                     break;
                 }
             }
@@ -141,9 +157,7 @@ public class MetaClassRegistryImpl implements MetaClassRegistry{
             for (int i = 0; i != additionals.length; ++i ) {
                 createMetaMethodFromClass(map, additionals[i]);
             }
-        }
-        else
-        {
+        } else {
             for (int i = 0; i < methods.length; i++) {
                 CachedMethod method = methods[i];
                 final int mod = method.getModifiers();
@@ -187,18 +201,15 @@ public class MetaClassRegistryImpl implements MetaClassRegistry{
     }
 
     public final MetaClass getMetaClass(Class theClass) {
-
         final ClassInfo info = ClassInfo.getClassInfo(theClass);
 
         MetaClass answer = info.getMetaClassForClass();
-        if (answer != null)
-            return answer;
+        if (answer != null) return answer;
 
         info.lock();
         try {
             return getMetaClassUnderLock(theClass, info);
-        }
-        finally {
+        } finally {
             info.unlock();
         }
     }
@@ -206,8 +217,7 @@ public class MetaClassRegistryImpl implements MetaClassRegistry{
     private MetaClass getMetaClassUnderLock(Class theClass, ClassInfo info) {
         MetaClass answer;
         answer = info.getMetaClassForClass();
-        if (answer != null)
-            return answer;
+        if (answer != null) return answer;
 
         answer = metaClassCreationHandle.create(theClass, this);
         answer.initialize();
@@ -219,21 +229,34 @@ public class MetaClassRegistryImpl implements MetaClassRegistry{
         }
         return answer;
     }
-
-    public void removeMetaClass(Class theClass) {
+    
+    /**
+     * if oldMc is null, newMc will replace whatever meta class was used before.
+     * if oldMc is not null, then newMc will be used only if he stored mc is
+     * the same as oldMc
+     */
+    private void setMetaClass(Class theClass, MetaClass oldMc, MetaClass newMc) {
         version.incrementAndGet();
-
         final ClassInfo info = ClassInfo.getClassInfo(theClass);
-
+        
+        MetaClass mc = null;
         info.lock();
-        try {
-            info.setStrongMetaClass(null);
-        }
-        finally {
+        try {        	
+        	if (oldMc!=null) mc=info.getStrongMetaClass();
+        	// mc==null means that mc will be null too, so the 
+        	// condition is always fulfilled. 
+        	if (mc==oldMc) info.setStrongMetaClass(newMc);
+        } finally {
             info.unlock();
         }
-    }
 
+        if (oldMc==mc) fireConstantMetaClassUpdate(theClass,newMc);
+    }
+    
+    public void removeMetaClass(Class theClass) {
+    	setMetaClass(theClass, null, null);
+    }
+    
     public MetaClass getMetaClass(Object obj) {
         Class theClass = obj.getClass ();
         final ClassInfo info = ClassInfo.getClassInfo(theClass);
@@ -241,12 +264,9 @@ public class MetaClassRegistryImpl implements MetaClassRegistry{
         info.lock();
         try {
             final MetaClass instanceMetaClass = info.getPerInstanceMetaClass(obj);
-            if (instanceMetaClass != null)
-              return instanceMetaClass;
-
+            if (instanceMetaClass != null) return instanceMetaClass;
             return getMetaClassUnderLock(theClass, info);
-        }
-        finally {
+        } finally {
             info.unlock();
         }
     }
@@ -258,17 +278,7 @@ public class MetaClassRegistryImpl implements MetaClassRegistry{
      * @param theMetaClass
      */
     public void setMetaClass(Class theClass, MetaClass theMetaClass) {
-        version.incrementAndGet();
-
-        final ClassInfo info = ClassInfo.getClassInfo(theClass);
-
-        info.lock();
-        try {
-            info.setStrongMetaClass(theMetaClass);
-        }
-        finally {
-            info.unlock();
-        }
+        setMetaClass(theClass,null,theMetaClass);
     }
 
 
@@ -285,6 +295,8 @@ public class MetaClassRegistryImpl implements MetaClassRegistry{
         finally {
             info.unlock();
         }
+        
+        fireConstantMetaClassUpdate(theClass, theMetaClass);
     }
 
 
@@ -294,19 +306,21 @@ public class MetaClassRegistryImpl implements MetaClassRegistry{
 
     // the following is experimental code, not intended for stable use yet
     private MetaClassCreationHandle metaClassCreationHandle = new MetaClassCreationHandle();
+    
     /**
      * Gets a handle internally used to create MetaClass implementations
      * WARNING: experimental code, likely to change soon
      * @return the handle
-     */
+     */    
     public MetaClassCreationHandle getMetaClassCreationHandler() {
         return metaClassCreationHandle;
     }
+    
     /**
      * Sets a handle internally used to create MetaClass implementations.
      * When replacing the handle with a custom version, you should
-     * resuse the old handle to keep custom logic and to use the
-     * default logic as fallback.
+     * reuse the old handle to keep custom logic and to use the
+     * default logic as fall back.
      * WARNING: experimental code, likely to change soon
      * @param handle the handle
      */
@@ -317,7 +331,74 @@ public class MetaClassRegistryImpl implements MetaClassRegistry{
     }    
 
     /**
-     * Singleton of MetaClassRegistry. Shall we use threadlocal to store the instance?
+     * Adds a listener for constant meta classes.
+     * @param listener the listener
+     */
+    public void addMetaClassRegistryChangeEventListener(MetaClassRegistryChangeEventListener listener) {
+        synchronized (changeListenerList) {
+            changeListenerList.add(listener);
+        }
+    }
+
+    /**
+     * Removes a constant meta class listener.
+     * @param listener the listener
+     */
+    public void removeMetaClassRegistryChangeEventListener(MetaClassRegistryChangeEventListener listener) {
+    	synchronized (changeListenerList) {
+        	Object first = changeListenerList.getFirst();
+            changeListenerList.remove(listener);
+            // we want to keep the first entry!
+            if (changeListenerList.size()==0) changeListenerList.addFirst(first); 
+        }
+    }
+
+    
+    private void cleanMetaClassList() {
+        boolean hasCollectedEntries=false;
+        java.lang.ref.Reference r=null;
+        while ((r=queue.poll())!=null) {
+            r.clear();
+            hasCollectedEntries=true;
+        }
+
+        if (!hasCollectedEntries) return;
+
+        for (Iterator it = metaClassInfo.iterator(); it.hasNext();) {
+            WeakReference ref = (WeakReference) it.next();
+            if (ref.get()!=null) continue;
+            it.remove();
+            ref.clear();
+        }
+    }
+
+    /**
+     * Causes the execution of all registered listeners. This method is used mostly
+     * internal to kick of the listener notification. It can also be used by subclasses
+     * to achieve the same.
+     * 
+     * @param c the class
+     * @param newMc the new MetaClass
+     */
+    protected void fireConstantMetaClassUpdate(Class c, MetaClass newMc) {
+        MetaClassRegistryChangeEventListener[]  listener = getMetaClassRegistryChangeEventListeners();
+        MetaClassRegistryChangeEvent cmcu = new MetaClassRegistryChangeEvent(this,c,newMc);
+        for (int i=0; i<listener.length; i++) {
+            listener[i].updateConstantMetaClass(cmcu);
+        }
+    }
+
+    /**
+     * Gets an array of of all registered ConstantMetaClassListener instances.
+     */
+    public MetaClassRegistryChangeEventListener[] getMetaClassRegistryChangeEventListeners() {
+        synchronized (changeListenerList) {
+            return (MetaClassRegistryChangeEventListener[]) changeListenerList.toArray(new MetaClassRegistryChangeEventListener[0]);
+        }
+    }
+    
+    /**
+     * Singleton of MetaClassRegistry. 
      *
      * @param includeExtension
      */
@@ -327,8 +408,7 @@ public class MetaClassRegistryImpl implements MetaClassRegistry{
                 instanceInclude = new MetaClassRegistryImpl();
             }
             return instanceInclude;
-        }
-        else {
+        } else {
             if (instanceExclude == null) {
                 instanceExclude = new MetaClassRegistryImpl(DONT_LOAD_DEFAULT);
             }
@@ -343,4 +423,68 @@ public class MetaClassRegistryImpl implements MetaClassRegistry{
     public FastArray getStaticMethods() {
         return staticMethods;
     }
+    
+    /**
+     * Returns an iterator to iterate over all constant meta classes.
+     * This iterator can be seen as making a snapshot of the current state
+     * of the registry. The snapshot will include all meta classes that has
+     * been used unless they are already collected. Collected meta classes 
+     * will be skipped automatically, so you can expect that each element
+     * of the iteration is not null. Calling this method is thread safe, the
+     * usage of the iterator is not.
+     *  
+     * @return the iterator.
+     */    
+    public Iterator iterator() {
+        final WeakReference[] refs;
+        synchronized (metaClassInfo) {
+            cleanMetaClassList();
+            refs = (WeakReference[]) metaClassInfo.toArray(new WeakReference[0]);
+        }
+        
+        return new Iterator() {
+        	// index inn the ref array
+            private int index=0;
+            // the current meta class
+            private MetaClass currentMeta;
+            // used to ensure that hasNext has been called
+            private boolean hasNextCalled=false;
+            // the cached hasNext call value
+            private boolean hasNext=false;
+
+            public boolean hasNext() {
+            	if (hasNextCalled) return hasNext;
+            	hasNextCalled = true;
+            	hasNext=true;
+            	
+            	// currentMeta==null means the entry might have been
+            	// collected already, we skip these.
+                currentMeta=null;
+                while (currentMeta==null && index<refs.length) {
+                    currentMeta = (MetaClass) refs[index].get();
+                    index++;
+                }
+                hasNext=currentMeta!=null;
+                return hasNext;
+            }
+            
+            private void ensureNext() {
+            	// we ensure that hasNext has been called before 
+            	// next is called
+            	hasNext();
+            	hasNextCalled=false;            	
+            }
+            
+            public Object next() {
+            	ensureNext();
+                return currentMeta;
+            }
+            
+            public void remove() {
+            	ensureNext();
+            	setMetaClass(currentMeta.getTheClass(),currentMeta,null);
+                currentMeta=null;
+            }
+        };
+    }
 }
