diff --git a/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java b/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
index dfa66468a2..2535c16e17 100644
--- a/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
+++ b/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
@@ -5213,16 +5213,22 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      *
      * @param self  a List
      * @param range a Range indicating the items to get
-     * @return a sublist based on range borders or a new list if range is reversed
-     * @see java.util.List#subList(int,int)
+     * @return a new list instance based on range borders
+     *
      * @since 1.0
      */
     public static <T> List<T> getAt(List<T> self, Range range) {
         RangeInfo info = subListBorders(self.size(), range);
-        List<T> answer = self.subList(info.from, info.to);  // sublist is always exclusive, but Ranges are not
+
+        List<T> subList = self.subList(info.from, info.to);  // sublist is always exclusive, but Ranges are not
         if (info.reverse) {
-            answer = reverse(answer);
+            subList = reverse(subList);
         }
+
+        // trying to guess the concrete list type and create a new instance from it
+        List<T> answer = createSimilarList(self, subList.size());
+        answer.addAll(subList);
+
         return answer;
     }
 
@@ -5258,9 +5264,8 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      *
      * @param self  a ListWithDefault
      * @param range a Range indicating the items to get
-     * @return a new eager or lazy sublist based on range borders
      *
-     * @see java.util.List#subList(int,int)
+     * @return a new eager or lazy list instance based on range borders
      */
     public static <T> List<T> getAt(ListWithDefault<T> self, Range range) {
         RangeInfo info = subListBorders(self.size(), range);
@@ -5274,6 +5279,9 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
         List<T> answer = self.subList(info.from, info.to);  // sublist is always exclusive, but Ranges are not
         if (info.reverse) {
             answer =  ListWithDefault.newInstance(reverse(answer), self.isLazyDefaultValues(), self.getInitClosure());
+        } else {
+            // instead of using the SubList backed by the parent list, a new ArrayList instance is used
+            answer =  ListWithDefault.newInstance(new ArrayList<T>(answer), self.isLazyDefaultValues(), self.getInitClosure());
         }
 
         return answer;
@@ -5286,9 +5294,9 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      *
      * @param self  a ListWithDefault
      * @param range a Range indicating the items to get
-     * @return a sublist based on range borders or a new list if range is reversed
      *
-     * @see java.util.List#subList(int,int)
+     * @return a new list instance based on range borders
+     *
      */
     public static <T> List<T> getAt(ListWithDefault<T> self, EmptyRange range) {
         return ListWithDefault.newInstance(new ArrayList<T>(), self.isLazyDefaultValues(), self.getInitClosure());
@@ -5301,12 +5309,12 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      *
      * @param self  a List
      * @param range a Range indicating the items to get
-     * @return a sublist based on range borders or a new list if range is reversed
-     * @see java.util.List#subList(int,int)
+     * @return a new list instance based on range borders
+     *
      * @since 1.0
      */
     public static <T> List<T> getAt(List<T> self, EmptyRange range) {
-        return new ArrayList<T> ();
+        return createSimilarList(self, 0);
     }
 
     /**
diff --git a/src/test/groovy/ListTest.groovy b/src/test/groovy/ListTest.groovy
index 82e14f6c6c..8d9039e6e8 100644
--- a/src/test/groovy/ListTest.groovy
+++ b/src/test/groovy/ListTest.groovy
@@ -671,4 +671,109 @@ class ListTest extends GroovyTestCase {
         def sub = list[0..4]
         assert sub[5] == 42
     }
+
+    void testCollectionAccessCreatesListCopy() {
+        def list = [0,1,2,3]
+        def sublist = list[0,1]
+
+        assert sublist == [0,1]
+
+        sublist[0] = 42
+
+        assert sublist == [42, 1]
+        assert list == [0,1,2,3]
+    }
+
+    void testLazyListCollectionAccessCreatesListCopy() {
+        def list = [0,1,2,3].withDefault { 42 }
+        def sublist = list[0,1]
+
+        assert sublist == [0,1]
+
+        sublist[0] = 42
+
+        assert sublist == [42, 1]
+        assert list == [0,1,2,3]
+    }
+
+    void testRangeAccessCreatesListCopy() {
+        def list = [0,1,2,3]
+        def sublist = list[0..<2]
+
+        assert sublist == [0,1]
+
+        sublist[0] = 42
+
+        assert sublist == [42, 1]
+        assert list == [0,1,2,3]
+    }
+
+    void testLazyListRangeAccessCreatesListCopy() {
+        def list = [0,1,2,3].withDefault { 42 }
+        def sublist = list[0..<2]
+
+        assert sublist == [0,1]
+
+        sublist[0] = 42
+
+        assert sublist == [42, 1]
+        assert list == [0,1,2,3]
+    }
+
+    void testLazyListSubListCreatesListDelegateCopy() {
+        def list = [0,1,2,3].withDefault { 42 }
+        def sublist = list[0..1]
+
+        assert sublist instanceof ListWithDefault
+        assert sublist.size() == 2
+
+        sublist[0] = 42
+
+        assert list == [0,1,2,3]
+    }
+
+    void testReversedRangeAccessCreatesListCopy() {
+        def list = [0,1,2,3]
+        def sublist = list[1..0]
+
+        assert sublist == [1,0]
+
+        sublist[0] = 42
+
+        assert sublist == [42, 0]
+        assert list == [0,1,2,3]
+    }
+
+    void testReversedLazyListRangeAccessCreatesListCopy() {
+        def list = [0,1,2,3].withDefault { 42 }
+        def sublist = list[1..0]
+
+        assert sublist == [1,0]
+
+        sublist[0] = 42
+
+        assert sublist == [42, 0]
+        assert list == [0,1,2,3]
+    }
+
+    void testRangeAccessOnLinkedListCreatesLinkedListCopy() {
+        def list = new LinkedList([0,1,2,3])
+        def sublist = list[0..<2]
+
+        assert sublist == [0,1]
+        assert sublist instanceof LinkedList
+    }
+
+    void testReversedRangeAccessOnLinkedListCreatesLinkedListCopy() {
+        def list = new LinkedList([0,1,2,3])
+        def sublist = list[1..0]
+
+        assert sublist == [1,0]
+        assert sublist instanceof LinkedList
+    }
+
+    void testEmptyRangeAccessReturnsLinkedListCopy() {
+        def list = new LinkedList([0,1,2,3])
+        assert list[0..<0] instanceof LinkedList
+    }
 }
