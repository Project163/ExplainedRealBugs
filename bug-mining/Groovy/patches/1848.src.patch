diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 822a20ede2..13dce4ed58 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -640,20 +640,15 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             if (!(keyExpr instanceof ConstantExpression)) {
                 addStaticTypeError("Dynamic keys in map-style constructors are unsupported in static type checking", keyExpr);
             } else {
-                String property = keyExpr.getText();
-                ClassNode currentNode = receiverType;
-                PropertyNode propertyNode = null;
-                while (propertyNode == null && currentNode != null) {
-                    propertyNode = currentNode.getProperty(property);
-                    currentNode = currentNode.getSuperClass();
-                }
-                if (propertyNode == null) {
-                    addStaticTypeError("No such property: " + property +
+                AtomicReference<ClassNode> lookup = new AtomicReference<ClassNode>();
+                boolean hasProperty = existsProperty(new PropertyExpression(new VariableExpression("_", receiverType), keyExpr.getText()), false, new PropertyLookupVisitor(lookup));
+                if (!hasProperty) {
+                    addStaticTypeError("No such property: " + keyExpr.getText() +
                             " for class: " + receiverType.getName(), receiver);
-                } else if (propertyNode != null) {
+                } else {
                     ClassNode valueType = getType(entryExpression.getValueExpression());
-                    if (!isAssignableTo(propertyNode.getType(), valueType)) {
-                        addAssignmentError(propertyNode.getType(), valueType, entryExpression);
+                    if (!isAssignableTo(lookup.get(), valueType)) {
+                        addAssignmentError(lookup.get(), valueType, entryExpression);
                     }
                 }
             }
@@ -1122,26 +1117,40 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 call.isSuperCall() ? classNode.getSuperClass() : call.getType();
         Expression arguments = call.getArguments();
         ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(arguments));
-        MethodNode node = findMethodOrFail(call, receiver, "<init>", args);
+        MethodNode node = null;
+        if (args.length == 1 && implementsInterfaceOrIsSubclassOf(args[0], MAP_TYPE) && findMethod(receiver, "<init>", ClassNode.EMPTY_ARRAY).size()==1) {
+            // bean-style constructor
+            node = typeCheckMapConstructor(call, receiver, arguments);
+            if (node!=null) {
+                storeTargetMethod(call, node);
+                return;
+            }
+        }
+        node = findMethodOrFail(call, receiver, "<init>", args);
         if (node != null) {
             if (node.getParameters().length == 0 && args.length == 1 && implementsInterfaceOrIsSubclassOf(args[0], MAP_TYPE)) {
-                if (arguments instanceof TupleExpression) {
-                    TupleExpression texp = (TupleExpression) arguments;
-                    List<Expression> expressions = texp.getExpressions();
-                    if (expressions.size() == 1) {
-                        Expression expression = expressions.get(0);
-                        if (expression instanceof MapExpression) {
-                            MapExpression argList = (MapExpression) expression;
-                            checkGroovyConstructorMap(call, receiver, argList);
-                            node = new ConstructorNode(Opcodes.ACC_PUBLIC, new Parameter[]{new Parameter(MAP_TYPE, "map")}, ClassNode.EMPTY_ARRAY, EmptyStatement.INSTANCE);
-                            node.setDeclaringClass(receiver);
+                node = typeCheckMapConstructor(call, receiver, arguments);
+            }
+            if (node!=null) storeTargetMethod(call, node);
+        }
+    }
 
-                        }
-                    }
+    private MethodNode typeCheckMapConstructor(final ConstructorCallExpression call, final ClassNode receiver, final Expression arguments) {
+        MethodNode node = null;
+        if (arguments instanceof TupleExpression) {
+            TupleExpression texp = (TupleExpression) arguments;
+            List<Expression> expressions = texp.getExpressions();
+            if (expressions.size() == 1) {
+                Expression expression = expressions.get(0);
+                if (expression instanceof MapExpression) {
+                    MapExpression argList = (MapExpression) expression;
+                    checkGroovyConstructorMap(call, receiver, argList);
+                    node = new ConstructorNode(Opcodes.ACC_PUBLIC, new Parameter[]{new Parameter(MAP_TYPE, "map")}, ClassNode.EMPTY_ARRAY, EmptyStatement.INSTANCE);
+                    node.setDeclaringClass(receiver);
                 }
             }
-            storeTargetMethod(call, node);
         }
+        return node;
     }
 
     private ClassNode[] getArgumentTypes(ArgumentListExpression args) {
diff --git a/src/test/groovy/transform/stc/ConstructorsSTCTest.groovy b/src/test/groovy/transform/stc/ConstructorsSTCTest.groovy
index 7198f64cba..3f30d842e5 100644
--- a/src/test/groovy/transform/stc/ConstructorsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/ConstructorsSTCTest.groovy
@@ -240,5 +240,24 @@ class ConstructorsSTCTest extends StaticTypeCheckingTestCase {
         assert users.get(0).login == "login1"
         '''
     }
+
+    // GROOVY-5578
+    void testConstructJavaBeanFromMap() {
+        assertScript '''import groovy.transform.stc.MyBean
+
+        MyBean bean = new MyBean(name:'Cedric')
+        assert bean.name == 'Cedric'
+        '''
+    }
+    void testConstructJavaBeanFromMapAndSubclass() {
+        assertScript '''import groovy.transform.stc.MyBean
+        class MyBean2 extends MyBean {
+            int age
+        }
+        MyBean2 bean = new MyBean2(name:'Cedric', age:33)
+        assert bean.name == 'Cedric'
+        assert bean.age == 33
+        '''
+    }
 }
 
diff --git a/src/test/groovy/transform/stc/MyBean.java b/src/test/groovy/transform/stc/MyBean.java
new file mode 100644
index 0000000000..edab6b8d94
--- /dev/null
+++ b/src/test/groovy/transform/stc/MyBean.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright 2003-2012 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package groovy.transform.stc;
+
+/**
+ * A simple Java bean, used by unit test for GROOVY-5578
+ */
+public class MyBean {
+    private String name;
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(final String name) {
+        this.name = name;
+    }
+}
