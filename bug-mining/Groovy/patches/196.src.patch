diff --git a/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java b/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
index c7bf57203b..74d495d7af 100644
--- a/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
+++ b/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
@@ -1219,7 +1219,7 @@ PropertyValue pv = (PropertyValue) itr.next();
      * @param self  a List
      * @param range a Range
      * @return a sublist based on range borders or a new list if range is reversed
-     * @see java.util.List#subList(int, int) 
+     * @see java.util.List#subList(int, int)
      */
     public static List getAt(List self, IntRange range) {
         int size = self.size();
@@ -1239,6 +1239,10 @@ PropertyValue pv = (PropertyValue) itr.next();
         return answer;
     }
 
+    protected int[] subListBorders(){
+        
+    }
+
     /**
      * Allows a List to be used as the indices to be used on a List
      *
@@ -1489,6 +1493,30 @@ PropertyValue pv = (PropertyValue) itr.next();
         sublist.addAll(values);
     }
 
+    /**
+     * A helper method to allow lists to work with subscript operators
+     *
+     * @param self  a List
+     * @param range  the subset of the list to set
+     * @param values the value to put at the given sublist
+     */
+    public static void putAt(List self, IntRange range, List values) {
+        if (range.isReverse()){
+             // nothing
+        }  else {
+            List sublist = getAt(self, range);
+            System.out.println("sublist = " + sublist);
+            System.out.println("self = " + self);
+            sublist.clear();
+            System.out.println("sublist = " + sublist);
+            System.out.println("self = " + self);
+            sublist.addAll(values);
+            System.out.println("sublist = " + sublist);
+            System.out.println("self = " + self);
+        }
+    }
+
+
     /**
      * A helper method to allow lists to work with subscript operators
      *
diff --git a/src/test/groovy/ListTest.groovy b/src/test/groovy/ListTest.groovy
index eeecd4ec10..106abc0e33 100644
--- a/src/test/groovy/ListTest.groovy
+++ b/src/test/groovy/ListTest.groovy
@@ -235,7 +235,6 @@ class ListTest extends GroovyTestCase {
     // see also SubscriptTest
     void testGetAtRange(){
         def list = [0,1,2,3]
-        println list[0..3]
         assert list[0..3] == list           , 'full list'
         assert list[0..0] == [0]            , 'one element range'
         assert list[0..<0] == []            , 'empty range'
@@ -252,18 +251,78 @@ class ListTest extends GroovyTestCase {
         shouldFail (IndexOutOfBoundsException.class) { list[5..6] }
     }
 
-    // todo: provide analogouy testGetAtSplice
-
     void testPutAtSplice(){
+        // usual assignments
+        def list = [0,1,2,3]
+        list[1,2] = [11,12]
+        assert list == [0, 11, 12, 3 ]      , 'same length assignment'
+        list = [0,1,2,3]
+        list[1,1] = [11]
+        assert list == [0, 11, 2, 3 ]       , 'length 1 assignment'
+        list = [0,1,2,3]
+        list[1,0] = [ ]
+        assert list == [0, 1, 2, 3 ]        , 'length 0 assignment, empty splice'
         // assignments at bounds
+        list = [0,1,2,3]
+        list[0,0] = [10]
+        assert list == [10, 1, 2, 3 ]       , 'left border assignment'
+        list = [0,1,2,3]
+        list[3,3] = [13]
+        assert list == [0, 1, 2, 13 ]       , 'right border assignment'
         // assignments outside current bounds
-        // compacting assignments
-        // extending assignments
-        // empty splice
-        // negative splice
-        // reversed splice
+        list = [0,1,2,3]
+        list[-1,-1] = [-1]
+        assert list == [0, 1, 2, -1]        , 'left of left border'
+        list = [0,1,2,3]
+        shouldFail (IndexOutOfBoundsException.class) {
+            list[3,4] = [3,4]
+            assert list == [0, 1, 2, 3, 4]
+        }
+        // structural changes
+        list = [0,1,2,3]
+        list[1,2] = ['x']
+        assert list == [0, 'x', 3]          , 'compacting'
+        list = [0,1,2,3]
+        list[1,2] = ['x','x','x']
+        assert list == [0, 'x','x','x', 3]  , 'extending'
     }
 
     // todo: provide analogous testPutAtRange
 
+    void testPutAtRange(){
+        // usual assignments
+        def list = [0,1,2,3]
+        list[1..2] = [11,12]
+        println list
+        assert list == [0, 11, 12, 3 ]      , 'same length assignment'
+        list = [0,1,2,3]
+        list[1..1] = [11]
+        assert list == [0, 11, 2, 3 ]       , 'length 1 assignment'
+        list = [0,1,2,3]
+        list[0..<0] = [ ]
+        assert list == [0, 1, 2, 3 ]        , 'length 0 assignment, empty splice'
+        // assignments at bounds
+        list = [0,1,2,3]
+        list[0..0] = [10]
+        assert list == [10, 1, 2, 3 ]       , 'left border assignment'
+        list = [0,1,2,3]
+        list[3..3] = [13]
+        assert list == [0, 1, 2, 13 ]       , 'right border assignment'
+        // assignments outside current bounds
+        list = [0,1,2,3]
+        list[-1..-1] = [-1]
+        assert list == [0, 1, 2, -1]        , 'left of left border'
+        list = [0,1,2,3]
+        shouldFail (IndexOutOfBoundsException.class) {
+            list[3..4] = [3,4]
+            assert list == [0, 1, 2, 3, 4]
+        }
+        // structural changes
+        list = [0,1,2,3]
+        list[1..2] = ['x']
+        assert list == [0, 'x', 3]          , 'compacting'
+        list = [0,1,2,3]
+        list[1..2] = ['x','x','x']
+        assert list == [0, 'x','x','x', 3]  , 'extending'
+    }
 }
