diff --git a/src/main/java/groovy/lang/MetaMethod.java b/src/main/java/groovy/lang/MetaMethod.java
index 46f887e23b..9ce7b49123 100644
--- a/src/main/java/groovy/lang/MetaMethod.java
+++ b/src/main/java/groovy/lang/MetaMethod.java
@@ -319,15 +319,15 @@ public abstract class MetaMethod extends ParameterTypes implements Cloneable {
      * there is no guarantee that it will be called
      *
      * @param object The object the method is to be called at.
-     * @param argumentArray Arguments for the method invocation.
+     * @param arguments Arguments for the method invocation.
      * @return The return value of the invoked method.
      */
-    public Object doMethodInvoke(Object object, Object[] argumentArray) {
-        argumentArray = coerceArgumentsToClasses(argumentArray);
+    public Object doMethodInvoke(final Object object, Object[] arguments) {
+        arguments = coerceArgumentsToClasses(arguments);
         try {
-            return invoke(object, argumentArray);
+            return invoke(object, arguments);
         } catch (Exception e) {
-            throw processDoMethodInvokeException(e, object, argumentArray);
+            throw processDoMethodInvokeException(e, object, arguments);
         }
     }
 }
diff --git a/src/main/java/org/codehaus/groovy/reflection/ParameterTypes.java b/src/main/java/org/codehaus/groovy/reflection/ParameterTypes.java
index cdbbd6f414..b680c4a494 100644
--- a/src/main/java/org/codehaus/groovy/reflection/ParameterTypes.java
+++ b/src/main/java/org/codehaus/groovy/reflection/ParameterTypes.java
@@ -72,7 +72,7 @@ public class ParameterTypes {
         if (parameterTypes != null)
             return;
 
-        Class[] npt = nativeParamTypes == null ? getPT() : nativeParamTypes;
+        var npt = nativeParamTypes == null ? getPT() : nativeParamTypes;
         if (npt.length == 0) {
             nativeParamTypes = MetaClassHelper.EMPTY_TYPE_ARRAY;
             setParametersTypes(CachedClass.EMPTY_ARRAY);
@@ -94,18 +94,18 @@ public class ParameterTypes {
     }
 
     private synchronized void getNativeParameterTypes0() {
-        if (nativeParamTypes != null)
-            return;
-
-        Class[] npt;
-        if (parameterTypes != null) {
-            npt = new Class[parameterTypes.length];
-            for (int i = 0; i != parameterTypes.length; ++i) {
-                npt[i] = parameterTypes[i].getTheClass();
+        if (nativeParamTypes == null) {
+            Class[] npt;
+            if (parameterTypes == null) {
+                npt = getPT();
+            } else {
+                npt = new Class[parameterTypes.length];
+                for (int i = 0; i != parameterTypes.length; ++i) {
+                    npt[i] = parameterTypes[i].getTheClass();
+                }
             }
-        } else
-            npt = getPT();
-        nativeParamTypes = npt;
+            nativeParamTypes = npt;
+        }
     }
 
     protected Class[] getPT() {
@@ -117,60 +117,50 @@ public class ParameterTypes {
     }
 
     public boolean isVargsMethod(Object[] arguments) {
-        // Uncomment if at some point this method can be called before parameterTypes initialized
-        // getParameterTypes();
-        if (!isVargsMethod)
-            return false;
-
-        final int lenMinus1 = parameterTypes.length - 1;
-        // -1 because the varg part is optional
-        if (lenMinus1 == arguments.length) return true;
-        if (lenMinus1 > arguments.length) return false;
-        if (arguments.length > parameterTypes.length) return true;
-
-        // only case left is arguments.length == parameterTypes.length
-        Object last = arguments[arguments.length - 1];
-        if (last == null) return true;
-        Class clazz = last.getClass();
-        return !clazz.equals(parameterTypes[lenMinus1].getTheClass());
-
+        if (isVargsMethod) {
+            int aCount = arguments.length;
+            int pCount = parameterTypes.length;
+            if (aCount > pCount || aCount == pCount-1) { // too many or too few?
+                return true;
+            }
+            if (aCount == pCount) {
+                Object last = arguments[aCount-1]; // is null or different type?
+                return last == null || !getArgClass(last).equals(parameterTypes[pCount-1].getTheClass());
+            }
+        }
+        return false;
     }
 
-    public final Object[] coerceArgumentsToClasses(Object[] argumentArray) {
-        // Uncomment if at some point this method can be called before parameterTypes initialized
-        // getParameterTypes();
-        argumentArray = correctArguments(argumentArray);
-
-        final CachedClass[] pt = parameterTypes;
-        final int len = argumentArray.length;
-        for (int i = 0; i < len; i++) {
-            final Object argument = argumentArray[i];
+    public final Object[] coerceArgumentsToClasses(Object[] arguments) {
+        arguments = correctArguments(arguments);
+        // TODO: if isVargsMethod, coerce array items
+        for (int i = 0; i != arguments.length; ++i) {
+            var argument = arguments[i];
             if (argument != null) {
-                argumentArray[i] = pt[i].coerceArgument(argument);
+                if (argument instanceof Wrapper)
+                    argument = ((Wrapper) argument).unwrap();
+                arguments[i] = parameterTypes[i].coerceArgument(argument);
             }
         }
-        return argumentArray;
+        return arguments;
     }
 
-    public Object[] correctArguments(Object[] argumentArray) {
-        // correct argumentArray's length
-        if (argumentArray == null) {
-            return MetaClassHelper.EMPTY_ARRAY;
+    public Object[] correctArguments(Object[] arguments) {
+        if (arguments == null) {
+            arguments = MetaClassHelper.EMPTY_ARRAY;
         }
 
-        final CachedClass[] pt = getParameterTypes();
-        if (pt.length == 1 && argumentArray.length == 0) {
-            if (isVargsMethod)
-                return new Object[]{Array.newInstance(pt[0].getTheClass().getComponentType(), 0)};
-            else
-                return MetaClassHelper.ARRAY_WITH_NULL;
+        var pt = getParameterTypes();
+        if (pt.length == 1 && arguments.length == 0) {
+            if (!isVargsMethod) return MetaClassHelper.ARRAY_WITH_NULL;
+            return new Object[]{Array.newInstance(pt[0].getTheClass().getComponentType(), 0)};
         }
 
-        if (isVargsMethod && isVargsMethod(argumentArray)) {
-            return fitToVargs(argumentArray, pt);
+        if (isVargsMethod(arguments)) {
+            return fitToVargs(arguments, pt);
         }
 
-        return argumentArray;
+        return arguments;
     }
 
     /**
@@ -178,58 +168,54 @@ public class ParameterTypes {
      * and if the method is a vargs method. This method will then transform the given
      * arguments to make the method callable
      *
-     * @param argumentArrayOrig the arguments used to call the method
+     * @param arguments the arguments used to call the method
      * @param paramTypes        the types of the parameters the method takes
      */
-    private static Object[] fitToVargs(Object[] argumentArrayOrig, CachedClass[] paramTypes) {
-        Class vargsClassOrig = paramTypes[paramTypes.length - 1].getTheClass().getComponentType();
-        Class vargsClass = ReflectionCache.autoboxType(vargsClassOrig);
-        Object[] argumentArray = argumentArrayOrig.clone();
-        MetaClassHelper.unwrap(argumentArray);
-
-        if (argumentArray.length == paramTypes.length - 1) {
-            // the vargs argument is missing, so fill it with an empty array
-            Object[] newArgs = new Object[paramTypes.length];
-            System.arraycopy(argumentArray, 0, newArgs, 0, argumentArray.length);
-            Object vargs = Array.newInstance(vargsClass, 0);
-            newArgs[newArgs.length - 1] = vargs;
-            return newArgs;
-        } else if (argumentArray.length == paramTypes.length) {
+    private static Object[] fitToVargs(final Object[] arguments, final CachedClass[] paramTypes) {
+        int aCount = arguments.length, pCount = paramTypes.length;
+        var vaType = paramTypes[pCount-1].getTheClass();
+        Object[] unwrappedArguments = arguments.clone();
+        MetaClassHelper.unwrap(unwrappedArguments);
+
+        // get type of each vargs element -- arguments are not primitive
+        vaType = ReflectionCache.autoboxType(vaType.getComponentType());
+
+        if (aCount == pCount - 1) {
+            // one argument is missing, so fill it with an empty array
+            Object[] args = new Object[pCount];
+            System.arraycopy(unwrappedArguments, 0, args, 0, aCount);
+            args[aCount] = Array.newInstance(vaType, 0);
+            return args;
+        } else if (aCount == pCount) {
             // the number of arguments is correct, but if the last argument
-            // is no array we have to wrap it in an array. If the last argument
+            // is no array we have to wrap it in an array; if last argument
             // is null, then we don't have to do anything
-            Object lastArgument = argumentArray[argumentArray.length - 1];
-            if (lastArgument != null && !lastArgument.getClass().isArray()) {
-                // no array so wrap it
-                Object wrapped = makeCommonArray(argumentArray, paramTypes.length - 1, vargsClass);
-                Object[] newArgs = new Object[paramTypes.length];
-                System.arraycopy(argumentArray, 0, newArgs, 0, paramTypes.length - 1);
-                newArgs[newArgs.length - 1] = wrapped;
-                return newArgs;
+            var lastArgument = getArgClass(arguments[aCount - 1]);
+            if (lastArgument != null && !lastArgument.isArray()) {
+                Object[] args = new Object[pCount];
+                System.arraycopy(unwrappedArguments, 0, args, 0, pCount - 1);
+                args[pCount-1] = makeCommonArray(unwrappedArguments, pCount - 1, vaType);
+                return args;
             } else {
                 // we may have to box the argument!
-                return argumentArray;
+                return unwrappedArguments;
             }
-        } else if (argumentArray.length > paramTypes.length) {
-            // the number of arguments is too big, wrap all exceeding elements
-            // in an array, but keep the old elements that are no vargs
-            Object[] newArgs = new Object[paramTypes.length];
-            // copy arguments that are not a varg
-            System.arraycopy(argumentArray, 0, newArgs, 0, paramTypes.length - 1);
-            // create a new array for the vargs and copy them
-            Object vargs = makeCommonArray(argumentArray, paramTypes.length - 1, vargsClass);
-            newArgs[newArgs.length - 1] = vargs;
-            return newArgs;
+        } else if (aCount > pCount) {
+            // wrap tail arguments in an array
+            Object[] args = new Object[pCount];
+            System.arraycopy(unwrappedArguments, 0, args, 0, pCount - 1);
+            args[pCount-1] = makeCommonArray(unwrappedArguments, pCount - 1, vaType);
+            return args;
         } else {
             throw new GroovyBugError("trying to call a vargs method without enough arguments");
         }
     }
 
-    private static Object makeCommonArray(Object[] arguments, int offset, Class baseClass) {
-        Object[] result = (Object[]) Array.newInstance(baseClass, arguments.length - offset);
-        for (int i = offset; i < arguments.length; i++) {
+    private static Object makeCommonArray(Object[] arguments, int offset, Class<?> baseType) {
+        Object[] result = (Object[]) Array.newInstance(baseType, arguments.length - offset);
+        for (int i = offset; i != arguments.length; ++i) {
             Object v = arguments[i];
-            v = DefaultTypeTransformation.castToType(v, baseClass);
+            v = DefaultTypeTransformation.castToType(v, baseType);
             result[i - offset] = v;
         }
         return result;
@@ -251,8 +237,7 @@ public class ParameterTypes {
 
     private static boolean isValidExactMethod(Class[] arguments, CachedClass[] pt) {
         // let's check the parameter types match
-        int size = pt.length;
-        for (int i = 0; i < size; i++) {
+        for (int i = 0; i != pt.length; ++i) {
             if (!pt[i].isAssignableFrom(arguments[i])) {
                 return false;
             }
@@ -267,7 +252,7 @@ public class ParameterTypes {
         if (size != parameterTypes.length)
             return false;
 
-        for (int i = 0; i < size; i++) {
+        for (int i = 0; i != size; ++i) {
             final Object arg = args[i];
             if (arg != null && !parameterTypes[i].isAssignableFrom(arg.getClass())) {
                 return false;
@@ -283,8 +268,8 @@ public class ParameterTypes {
         if (size != parameterTypes.length)
             return false;
 
-        for (int i = 0; i < size; i++) {
-            final Class arg = args[i];
+        for (int i = 0; i != size; ++i) {
+            var arg = args[i];
             if (arg != null && !parameterTypes[i].isAssignableFrom(arg)) {
                 return false;
             }
@@ -304,7 +289,7 @@ public class ParameterTypes {
 
         // check direct match
         if (argumentTypes.length == parameterTypes.length) {
-            Class argumentType = argumentTypes[nthParameter];
+            var argumentType = argumentTypes[nthParameter];
             if (arrayType.isAssignableFrom(argumentType) || (argumentType.isArray()
                     && componentType.isAssignableFrom(argumentType.getComponentType()))) {
                 return true;
@@ -336,7 +321,7 @@ public class ParameterTypes {
             CachedClass componentType = ReflectionCache.getCachedClass(arrayType.getTheClass().getComponentType());
             // check direct match
             if (nArguments == parameterTypes.length) {
-                Class argumentType = getArgClass(arguments[nthParameter]);
+                var argumentType = getArgClass(arguments[nthParameter]);
                 if (arrayType.isAssignableFrom(argumentType) || (argumentType.isArray()
                         && componentType.isAssignableFrom(argumentType.getComponentType()))) {
                     return true;
@@ -362,16 +347,7 @@ public class ParameterTypes {
         return false;
     }
 
-    private static Class getArgClass(Object arg) {
-        Class cls;
-        if (arg == null) {
-            cls = null;
-        } else {
-            if (arg instanceof Wrapper) {
-                cls = ((Wrapper) arg).getType();
-            } else
-                cls = arg.getClass();
-        }
-        return cls;
+    private static Class<?> getArgClass(final Object arg) {
+        return arg == null ? null : (arg instanceof Wrapper ? ((Wrapper) arg).getType() : arg.getClass());
     }
 }
diff --git a/src/main/java/org/codehaus/groovy/runtime/metaclass/ClosureMetaClass.java b/src/main/java/org/codehaus/groovy/runtime/metaclass/ClosureMetaClass.java
index fc17726f63..53e952a416 100644
--- a/src/main/java/org/codehaus/groovy/runtime/metaclass/ClosureMetaClass.java
+++ b/src/main/java/org/codehaus/groovy/runtime/metaclass/ClosureMetaClass.java
@@ -183,14 +183,6 @@ public final class ClosureMetaClass extends MetaClassImpl {
         return CLOSURE_METACLASS.getMetaProperty(name);
     }
 
-    private static void unwrap(final Object[] arguments) {
-        for (int i = 0; i != arguments.length; i++) {
-            if (arguments[i] instanceof Wrapper) {
-                arguments[i] = ((Wrapper) arguments[i]).unwrap();
-            }
-        }
-    }
-
     private MetaMethod pickClosureMethod(final Class[] argClasses) {
         Object answer = chooser.chooseMethod(argClasses, false);
         return (MetaMethod) answer;
@@ -247,15 +239,14 @@ public final class ClosureMetaClass extends MetaClassImpl {
     }
 
     @Override
-    public Object invokeMethod(final Class sender, final Object object, final String methodName, final Object[] originalArguments, final boolean isCallToSuper, final boolean fromInsideClass) {
+    public Object invokeMethod(final Class sender, final Object object, final String methodName, final Object[] arguments, final boolean isCallToSuper, final boolean fromInsideClass) {
         checkInitalised();
         if (object == null) {
             throw new NullPointerException("Cannot invoke method: " + methodName + " on null object");
         }
 
-        final Object[] arguments = makeArguments(originalArguments, methodName);
-        final Class<?>[] argClasses = MetaClassHelper.convertToTypeArray(arguments);
-        unwrap(arguments);
+        final Object[] theArguments = arguments == null ? EMPTY_ARGUMENTS : arguments.clone();
+        final Class<?>[] argClasses = MetaClassHelper.convertToTypeArray(theArguments);
 
         MetaMethod method = null;
         final Closure<?> closure = (Closure<?>) object;
@@ -263,12 +254,15 @@ public final class ClosureMetaClass extends MetaClassImpl {
 
         if (CLOSURE_DO_CALL_METHOD.equals(methodName) || CLOSURE_CALL_METHOD.equals(methodName)) {
             method = pickClosureMethod(argClasses);
-            if (method == null && arguments.length == 1 && arguments[0] instanceof List) {
-                Object[] newArguments = ((List<?>) arguments[0]).toArray();
-                Class<?>[] newArgClasses = MetaClassHelper.convertToTypeArray(newArguments);
-                method = createTransformMetaMethod(pickClosureMethod(newArgClasses));
+            if (method == null && argClasses.length == 1 && List.class.isAssignableFrom(argClasses[0])) {
+                var list = (theArguments[0] instanceof Wrapper ? ((Wrapper) theArguments[0]).unwrap() : theArguments[0]);
+                if (list != null) {
+                    var newArguments = ((List<?>) list).toArray();
+                    var newArgClasses = MetaClassHelper.convertToTypeArray(newArguments);
+                    method = createTransformMetaMethod(pickClosureMethod(newArgClasses));
+                }
             }
-            if (method == null) throw new MissingMethodException(methodName, theClass, arguments, false);
+            if (method == null) throw new MissingMethodException(methodName, theClass, theArguments, false);
         }
 
         boolean shouldDefer = resolveStrategy == Closure.DELEGATE_ONLY && isInternalMethod(methodName);
@@ -276,7 +270,7 @@ public final class ClosureMetaClass extends MetaClassImpl {
             method = CLOSURE_METACLASS.pickMethod(methodName, argClasses);
         }
 
-        if (method != null) return method.doMethodInvoke(object, arguments);
+        if (method != null) return method.doMethodInvoke(object, theArguments);
 
         MissingMethodException last = null;
         Object callObject = object;
@@ -339,7 +333,7 @@ public final class ClosureMetaClass extends MetaClassImpl {
             if (metaClass instanceof ProxyMetaClass) {
                 return metaClass.invokeMethod(callObject, methodName, arguments);
             } else {
-                return method.doMethodInvoke(callObject, arguments);
+                return method.doMethodInvoke(callObject, theArguments);
             }
         } else {
             // no method was found; try to find a closure defined as a field of the class and run it
@@ -352,31 +346,26 @@ public final class ClosureMetaClass extends MetaClassImpl {
             if (value instanceof Closure) {  // This test ensures that value != this If you ever change this ensure that value != this
                 Closure<?> cl = (Closure<?>) value;
                 MetaClass delegateMetaClass = cl.getMetaClass();
-                return delegateMetaClass.invokeMethod(cl.getClass(), closure, CLOSURE_DO_CALL_METHOD, originalArguments, false, fromInsideClass);
+                return delegateMetaClass.invokeMethod(cl.getClass(), closure, CLOSURE_DO_CALL_METHOD, arguments, false, fromInsideClass);
             }
         }
 
-        throw last != null ? last : new MissingMethodException(methodName, theClass, arguments, false);
+        throw last != null ? last : new MissingMethodException(methodName, theClass, theArguments, false);
     }
 
     private static boolean isInternalMethod(final String methodName) {
         switch (methodName) {
-            case "curry":
-            case "ncurry":
-            case "rcurry":
-            case "leftShift":
-            case "rightShift":
-                return true;
-            default:
-                return false;
+          case "curry":
+          case "ncurry":
+          case "rcurry":
+          case "leftShift":
+          case "rightShift":
+            return true;
+          default:
+            return false;
         }
     }
 
-    private static Object[] makeArguments(final Object[] arguments, final String methodName) {
-        if (arguments == null) return EMPTY_ARGUMENTS;
-        return arguments;
-    }
-
     private static Throwable unwrap(final GroovyRuntimeException gre) {
         Throwable th = gre;
         if (th.getCause() != null && th.getCause() != gre) th = th.getCause();
diff --git a/src/main/java/org/codehaus/groovy/vmplugin/v8/Selector.java b/src/main/java/org/codehaus/groovy/vmplugin/v8/Selector.java
index f1a35520f9..076b3f3aca 100644
--- a/src/main/java/org/codehaus/groovy/vmplugin/v8/Selector.java
+++ b/src/main/java/org/codehaus/groovy/vmplugin/v8/Selector.java
@@ -39,9 +39,11 @@ import org.codehaus.groovy.reflection.CachedMethod;
 import org.codehaus.groovy.reflection.ClassInfo;
 import org.codehaus.groovy.reflection.GeneratedMetaMethod;
 import org.codehaus.groovy.reflection.stdclasses.CachedSAMClass;
+import org.codehaus.groovy.runtime.ArrayTypeUtils;
 import org.codehaus.groovy.runtime.GeneratedClosure;
 import org.codehaus.groovy.runtime.GroovyCategorySupport;
 import org.codehaus.groovy.runtime.GroovyCategorySupport.CategoryMethod;
+import org.codehaus.groovy.runtime.MetaClassHelper;
 import org.codehaus.groovy.runtime.NullObject;
 import org.codehaus.groovy.runtime.dgmimpl.NumberNumberMetaMethod;
 import org.codehaus.groovy.runtime.metaclass.ClosureMetaClass;
@@ -769,31 +771,31 @@ public abstract class Selector {
                 return;
             }
 
-            Class<?> lastParam = params[params.length - 1];
-            Object lastArg = unwrapIfWrapped(args[args.length - 1]);
-            if (params.length == args.length) {
-                // may need rewrap
-                if (lastArg == null) return;
-                if (lastParam.isInstance(lastArg)) return;
-                if (lastArg.getClass().isArray()) return;
-                // arg is not null and not assignment compatible
-                // so we really need to rewrap
-                handle = handle.asCollector(lastParam, 1);
-            } else if (params.length > args.length) {
+            int aCount = args.length;
+            int pCount = params.length;
+            var vaType = params[pCount-1];
+            if (aCount == pCount) {
+                var lastArg = MetaClassHelper.convertToTypeArray(args)[aCount-1]; // GROOVY-6146
+                if (lastArg != null && (!lastArg.isArray() || (ArrayTypeUtils.dimension(lastArg)
+                            != ArrayTypeUtils.dimension(vaType) && vaType != Object[].class))) {
+                    // we depend on the method selection having done a good job previously
+                    // arg is null with cast or not assignment compatible; wrap with array
+                    handle = handle.asCollector(vaType, 1);
+                    if (LOG_ENABLED) LOG.info("changed last argument to be collected for variadic parameter");
+                }
+            } else if (aCount < pCount) {
                 // we depend on the method selection having done a good
                 // job before already, so the only case for this here is, that
                 // we have no argument for the array, meaning params.length is
                 // args.length+1. In that case we have to fill in an empty array
-                handle = MethodHandles.insertArguments(handle, params.length - 1, Array.newInstance(lastParam.getComponentType(), 0));
-                if (LOG_ENABLED) LOG.info("added empty array for missing vargs part");
-            } else { //params.length < args.length
+                handle = MethodHandles.insertArguments(handle, pCount - 1, Array.newInstance(vaType.getComponentType(), 0));
+                if (LOG_ENABLED) LOG.info("added empty array for variadic parameter");
+            } else { // aCount > pCount
                 // we depend on the method selection having done a good
                 // job before already, so the only case for this here is, that
                 // all trailing arguments belong into the vargs array
-                handle = handle.asCollector(
-                        lastParam,
-                        args.length - params.length + 1);
-                if (LOG_ENABLED) LOG.info("changed surplus arguments to be collected for vargs call");
+                handle = handle.asCollector(vaType, aCount - pCount + 1);
+                if (LOG_ENABLED) LOG.info("changed surplus arguments to be collected for variadic parameter");
             }
         }
 
@@ -1046,9 +1048,8 @@ public abstract class Selector {
      * Unwraps the given object from a {@link Wrapper}. If not
      * wrapped, the given object is returned.
      */
-    private static Object unwrapIfWrapped(Object object) {
-        if (object instanceof Wrapper) return unwrap(object);
-        return object;
+    private static Object unwrapIfWrapped(final Object object) {
+        return object instanceof Wrapper ? unwrap(object) : object;
     }
 
     /**
diff --git a/src/test/groovy/VArgsTest.groovy b/src/test/groovy/VArgsTest.groovy
index c9bf5903d4..bc10843a70 100644
--- a/src/test/groovy/VArgsTest.groovy
+++ b/src/test/groovy/VArgsTest.groovy
@@ -18,214 +18,238 @@
  */
 package groovy
 
-import groovy.test.GroovyTestCase
-
-class VArgsTest extends GroovyTestCase {
-
-  def primitiveMethod(){0}
-  def primitiveMethod(int i) {1}  
-  def primitiveMethod(int i, int j) {2}
-  def primitiveMethod(int[] is) {10+is.length}
-
-  void testPrimitiveMethod() {
-    assert primitiveMethod()==0
-    assert primitiveMethod(1)==1
-    assert primitiveMethod(1,1)==2
-    assert primitiveMethod(1,1,1)==13 
-    assert primitiveMethod([1,2,2,2] as int[])==14
-  }  
-
-  def doubleMethod(double[] id) {20+id.length}
-
-  void testDoubleMethod() {
-    // with BigDecimal
-    assert doubleMethod()==20
-    assert doubleMethod(1.0G)==21
-    assert doubleMethod(1.0G,1.0G)==22
-    assert doubleMethod(1.0G,1.0G,1.0G)==23 
-    assert doubleMethod([1,2,2,2] as BigDecimal[])==24
-
-    // with double
-    assert doubleMethod()==20
-    assert doubleMethod(1.0d)==21
-    assert doubleMethod(1.0d,1.0d)==22
-    assert doubleMethod(1.0d,1.0d,1.0d)==23 
-    assert doubleMethod([1,2,2,2] as double[])==24
-  }
-
-  // test vargs with one fixed argument for primitives
-  def doubleMethod2(double a, double[] id) {31+id.length}
-
-  void testDoubleMethodWithOneFixedPrimitive() {
-    // with BigDecimal
-    assert doubleMethod2(1.0G)==31
-    assert doubleMethod2(1.0G,1.0G)==32
-    assert doubleMethod2(1.0G,1.0G,1.0G)==33 
-    assert doubleMethod2(1.0G, [1,2,2,2] as BigDecimal[])==35
-
-    // with double
-    assert doubleMethod2(1.0d)==31
-    assert doubleMethod2(1.0d,1.0d)==32
-    assert doubleMethod2(1.0d,1.0d,1.0d)==33 
-    assert doubleMethod2(1.0d,[1,2,2,2] as double[])==35
-  }
-
-
-  def objectMethod(){0}
-  def objectMethod(Object i) {1}  
-  def objectMethod(Object i, Object j) {2}
-  def objectMethod(Object[] is) {10+is.length}
-
-  void testObjectMethod() {
-    assert objectMethod()==0
-    assert objectMethod(1)==1
-    assert objectMethod(1,1)==2
-    assert objectMethod(1,1,1)==13
-    assert objectMethod([1,2,2,2] as Object[])==14
-  }
-
-  def gstringMethod(GString[] gstrings){gstrings.length}
-
-  void testGStringVargsMethod() {
-    def content = 1
-    def gstring ="$content"
-    assert gstringMethod() == 0
-    assert gstringMethod(gstring) == 1
-    assert gstringMethod(gstring,gstring,gstring) == 3
-    assert gstringMethod([gstring] as GString[]) == 1
-  }
-
-  def stringMethod(String[] strings) {strings.length}
-
-  void testStringMethod() {
-    def content = 1
-    def gstring ="$content"
-    assert stringMethod() == 0
-    assert stringMethod(gstring) == 1
-    assert stringMethod(gstring,gstring,gstring) == 3
-    assert stringMethod([gstring] as GString[]) == 1
-    assert stringMethod() == 0
-    assert stringMethod("a") == 1
-    assert stringMethod("a","a","a") == 3
-    assert stringMethod(["a"] as String[]) == 1
-  }
-
-  //tests related to GROOVY-1807
-
-  def overloadedMethod1(String s){1}
-  def overloadedMethod1(Object[] args){2}
-
-  void testOverloadedMethod1() {
-    assert overloadedMethod1() == 2
-  }
-
-  def overloadedMethod2(x,y){1}
-  def overloadedMethod2(x,Object... y){2}
-
-  void testOverloadedMethod2() {
-    assert overloadedMethod2(null) == 2
-    assert overloadedMethod2("foo") == 2
-  }
-
-  def normalVargsMethod(Object[] a){a.length}
-
-  void testArrayCoercion() {
-    assert normalVargsMethod([1,2,3] as int[]) == 3
-  }
-
-
-  // GROOVY-2204
-  def m2204a(Map kwargs=[:], arg1, arg2, Object[] args) {
-    "arg1: $arg1, arg2: $arg2, args: $args, kwargs: $kwargs"
-  }
-
-  def m2204b(Map kwargs=[:], arg1, arg2="1", Object[] args) {
-    "arg1: $arg1, arg2: $arg2, args: $args, kwargs: $kwargs"
-  }
-
-  void test2204a() {
-     assert m2204a('hello', 'world') == 'arg1: hello, arg2: world, args: [], kwargs: [:]'
-     assert m2204a('hello', 'world', 'from', 'list') == 'arg1: hello, arg2: world, args: [from, list], kwargs: [:]'
-     assert m2204a('hello', 'world', 'from', 'list', from: 'kwargs') == 'arg1: hello, arg2: world, args: [from, list], kwargs: [from:kwargs]'
-     assert m2204a('hello', 'world', from: 'kwargs') == 'arg1: hello, arg2: world, args: [], kwargs: [from:kwargs]'
-     assert m2204a([:], 'hello', 'world', [] as Object[]) == 'arg1: hello, arg2: world, args: [], kwargs: [:]'
-
-     assert m2204b('hello', 'world') == 'arg1: hello, arg2: 1, args: [world], kwargs: [:]'
-     assert m2204b('hello', 'world', 'from', 'list') == 'arg1: hello, arg2: 1, args: [world, from, list], kwargs: [:]'
-     assert m2204b('hello', 'world', 'from', 'list', from: 'kwargs') == 'arg1: hello, arg2: world, args: [from, list], kwargs: [from:kwargs]'
-     assert m2204b('hello', 'world', from: 'kwargs') == 'arg1: hello, arg2: world, args: [], kwargs: [from:kwargs]'
-  }
-
-
-  // GROOVY-2351
-
-  def m2351(Object... args)  {1}
-  def m2351(Integer... args) {2}
-
-  void test2351() {
-    assert m2351(1, 2, 3, 4, 5) == 2
-  }
-
-  // see MetaClassHelper#calculateParameterDistance
-
-  def fooAB(Object[] a) {1}     //-> case B
-  def fooAB(a,b,Object[] c) {2} //-> case A
-  void testAB() {
-    assert fooAB(new Object(),new Object()) == 2
-  }
-
-  def fooAC(Object[] a) {1}     //-> case B
-  def fooAC(a,b)        {2}     //-> case C
-  void testAC(){
-    assert fooAC(new Object(),new Object()) == 2
-  }
-
-  def fooAD(Object[] a) {1}     //-> case D
-  def fooAD(a,Object[] b) {2}   //-> case A
-  void testAD(){
-    assert fooAD(new Object()) == 2
-  }
-
-  def fooBC(Object[] a) {1}     //-> case B
-  def fooBC(a,b) {2}            //-> case C
-  void testBC() {  
-    assert fooBC(new Object(),new Object()) == 2
-  }
-
-  def fooBD(Object[] a)   {1}   //-> case B
-  def fooBD(a,Object[] b) {2}   //-> case D
-  void testBD(){
-    assert fooBD(new Object(),new Object()) == 2
-  }
-
-  // GROOVY-3019
-  def foo3019(Object a, int b) {1}
-  def foo3019(Integer a, int b, Object[] arr) {2}
-  void test3019() {
-    assert foo3019(new Integer(1),1)==1
-  }
-
-  // GROOVY-3547
-  void testCallObjectVarArgWithInt() {
-    assert foo3547(1).getClass() == Object[]
-  }
-
-  void testCallObjectVarArgWithStrings() {
-    assert foo3547("one", "two").getClass() == Object[]
-  }
-
-
-  void testCallSerializableVarArgWithString() {
-    assert bar3547("").getClass() == Serializable[]
-  }
-
-  def foo3547(Object... args) {
-    args
-  }
-
-  def bar3547(Serializable... args) {
-    args
-  }
-
-
-}  
+import org.junit.Test
+
+final class VArgsTest {
+
+    def intMethod() {0}
+    def intMethod(int i) {1}
+    def intMethod(int i, int j) {2}
+    def intMethod(int[] integers) {10+integers.length}
+
+    @Test
+    void testIntMethod() {
+        assert intMethod() == 0
+        assert intMethod(1) == 1
+        assert intMethod(1,1) == 2
+        assert intMethod(1,1,1) == 13
+        assert intMethod([1,2,2,2] as int[]) == 14
+    }
+
+    def doubleMethod(double[] doubles) {20+doubles.length}
+
+    @Test
+    void testDoubleMethod() {
+        // with BigDecimal
+        assert doubleMethod() == 20
+        assert doubleMethod(1.0G) == 21
+        assert doubleMethod(1.0G,1.0G) == 22
+        assert doubleMethod(1.0G,1.0G,1.0G) == 23
+        assert doubleMethod([1,2,2,2] as BigDecimal[]) == 24
+
+        // with double
+        assert doubleMethod() == 20
+        assert doubleMethod(1.0d) == 21
+        assert doubleMethod(1.0d,1.0d) == 22
+        assert doubleMethod(1.0d,1.0d,1.0d) == 23
+        assert doubleMethod([1,2,2,2] as double[]) == 24
+    }
+
+    // test vargs with one fixed argument for primitives
+    def doubleMethod2(double one, double[] zeroOrMore) {31+zeroOrMore.length}
+
+    @Test
+    void testDoubleMethodWithOneFixedPrimitive() {
+        // with BigDecimal
+        assert doubleMethod2(1.0G) == 31
+        assert doubleMethod2(1.0G,1.0G) == 32
+        assert doubleMethod2(1.0G,1.0G,1.0G) == 33
+        assert doubleMethod2(1.0G, [1,2,2,2] as BigDecimal[]) == 35
+
+        // with double
+        assert doubleMethod2(1.0d) == 31
+        assert doubleMethod2(1.0d,1.0d) == 32
+        assert doubleMethod2(1.0d,1.0d,1.0d) == 33
+        assert doubleMethod2(1.0d,[1,2,2,2] as double[]) == 35
+    }
+
+    def objectMethod() {0}
+    def objectMethod(Object one) {1}
+    def objectMethod(Object one, Object two) {2}
+    def objectMethod(Object[] zeroOrMore) {10+zeroOrMore.length}
+
+    @Test
+    void testObjectMethod() {
+        assert objectMethod() == 0
+        assert objectMethod(1) == 1
+        assert objectMethod(1,1) == 2
+        assert objectMethod(1,1,1) == 13
+        assert objectMethod([1,2,2,2] as Object[]) == 14
+    }
+
+    @Test
+    void testObjectArraysMethod() {
+        // both arguments are String[][]
+        assert Arrays.equals([].stream().toArray(String[]), new String[0][])
+    }
+
+    def gstringMethod(GString[] gstrings) {gstrings.length}
+
+    @Test
+    void testGStringVargsMethod() {
+        def content = 1
+        def gstring ="$content"
+        assert gstringMethod() == 0
+        assert gstringMethod(gstring) == 1
+        assert gstringMethod(gstring,gstring,gstring) == 3
+        assert gstringMethod([gstring] as GString[]) == 1
+    }
+
+    def stringMethod(String[] strings) {strings.length}
+
+    @Test
+    void testStringMethod() {
+        def content = 1
+        def gstring ="$content"
+        assert stringMethod() == 0
+        assert stringMethod(gstring) == 1
+        assert stringMethod(gstring,gstring,gstring) == 3
+        assert stringMethod([gstring] as GString[]) == 1
+        assert stringMethod() == 0
+        assert stringMethod("a") == 1
+        assert stringMethod("a","a","a") == 3
+        assert stringMethod(["a"] as String[]) == 1
+    }
+
+    // GROOVY-1807 tests
+
+    def overloadedMethod1(String s) {1}
+    def overloadedMethod1(Object[] args) {2}
+
+    @Test
+    void testOverloadedMethod1() {
+        assert overloadedMethod1() == 2
+    }
+
+    def overloadedMethod2(x,y) {1}
+    def overloadedMethod2(x,Object... y) {2}
+
+    @Test
+    void testOverloadedMethod2() {
+        assert overloadedMethod2(null) == 2
+        assert overloadedMethod2("foo") == 2
+    }
+
+    def normalVargsMethod(Object[] a) {a.length}
+
+    @Test
+    void testArrayCoercion() {
+        assert normalVargsMethod([1,2,3] as int[]) == 3
+    }
+
+    // GROOVY-2204
+    def m2204a(Map kwargs=[:], arg1, arg2, Object[] args) {
+        "arg1: $arg1, arg2: $arg2, args: $args, kwargs: $kwargs"
+    }
+
+    def m2204b(Map kwargs=[:], arg1, arg2="1", Object[] args) {
+        "arg1: $arg1, arg2: $arg2, args: $args, kwargs: $kwargs"
+    }
+
+    @Test
+    void test2204a() {
+        assert m2204a('hello', 'world') == 'arg1: hello, arg2: world, args: [], kwargs: [:]'
+        assert m2204a('hello', 'world', 'from', 'list') == 'arg1: hello, arg2: world, args: [from, list], kwargs: [:]'
+        assert m2204a('hello', 'world', 'from', 'list', from: 'kwargs') == 'arg1: hello, arg2: world, args: [from, list], kwargs: [from:kwargs]'
+        assert m2204a('hello', 'world', from: 'kwargs') == 'arg1: hello, arg2: world, args: [], kwargs: [from:kwargs]'
+        assert m2204a([:], 'hello', 'world', [] as Object[]) == 'arg1: hello, arg2: world, args: [], kwargs: [:]'
+
+        assert m2204b('hello', 'world') == 'arg1: hello, arg2: 1, args: [world], kwargs: [:]'
+        assert m2204b('hello', 'world', 'from', 'list') == 'arg1: hello, arg2: 1, args: [world, from, list], kwargs: [:]'
+        assert m2204b('hello', 'world', 'from', 'list', from: 'kwargs') == 'arg1: hello, arg2: world, args: [from, list], kwargs: [from:kwargs]'
+        assert m2204b('hello', 'world', from: 'kwargs') == 'arg1: hello, arg2: world, args: [], kwargs: [from:kwargs]'
+    }
+
+    // GROOVY-2351
+    def m2351(Object... args)  {1}
+    def m2351(Integer... args) {2}
+
+    @Test
+    void test2351() {
+        assert m2351(1, 2, 3, 4, 5) == 2
+    }
+
+    // see MetaClassHelper#calculateParameterDistance
+
+    def fooAB(Object[] a) {1}     //-> case B
+    def fooAB(a,b,Object[] c) {2} //-> case A
+
+    @Test
+    void testAB() {
+        assert fooAB(new Object(),new Object()) == 2
+    }
+
+    def fooAC(Object[] a) {1}     //-> case B
+    def fooAC(a,b)        {2}     //-> case C
+
+    @Test
+    void testAC() {
+        assert fooAC(new Object(),new Object()) == 2
+    }
+
+    def fooAD(Object[] a) {1}     //-> case D
+    def fooAD(a,Object[] b) {2}   //-> case A
+
+    @Test
+    void testAD() {
+        assert fooAD(new Object()) == 2
+    }
+
+    def fooBC(Object[] a) {1}     //-> case B
+    def fooBC(a,b) {2}            //-> case C
+
+    @Test
+    void testBC() {
+        assert fooBC(new Object(),new Object()) == 2
+    }
+
+    def fooBD(Object[] a)   {1}   //-> case B
+    def fooBD(a,Object[] b) {2}   //-> case D
+
+    @Test
+    void testBD(){
+        assert fooBD(new Object(),new Object()) == 2
+    }
+
+    // GROOVY-3019
+    def foo3019(Object a, int b) {1}
+    def foo3019(Integer a, int b, Object[] arr) {2}
+
+    @Test
+    void test3019() {
+        assert foo3019(new Integer(1),1)==1
+    }
+
+    @Test // GROOVY-3547
+    void testCallObjectVarArgWithInt() {
+        assert foo3547(1).getClass() == Object[]
+    }
+
+    @Test
+    void testCallObjectVarArgWithStrings() {
+        assert foo3547("one", "two").getClass() == Object[]
+    }
+
+    @Test
+    void testCallSerializableVarArgWithString() {
+        assert bar3547("").getClass() == Serializable[]
+    }
+
+    def foo3547(Object... args) {
+        args
+    }
+
+    def bar3547(Serializable... args) {
+        args
+    }
+}
diff --git a/src/test/groovy/VarargsMethodTest.groovy b/src/test/groovy/VarargsMethodTest.groovy
index c4a2964b12..b5a3096eab 100644
--- a/src/test/groovy/VarargsMethodTest.groovy
+++ b/src/test/groovy/VarargsMethodTest.groovy
@@ -81,10 +81,10 @@ final class VarargsMethodTest {
         assert varargsOnlyMethod(null, null) == 2
 
         // GROOVY-6146
+        assert varargsOnlyMethod((Object)null) == 1
+        assert varargsOnlyMethod(null as Object) == 1
         assert varargsOnlyMethod((Object[])null) == -1
         assert varargsOnlyMethod(null as Object[]) == -1
-        assert varargsOnlyMethod((Object)null) == -1 // TODO: 1
-        assert varargsOnlyMethod(null as Object) == -1 // TODO: 1
 
         // GROOVY-10099
         Object[] array = null
