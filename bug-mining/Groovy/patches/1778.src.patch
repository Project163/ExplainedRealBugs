diff --git a/src/main/groovy/util/logging/Commons.java b/src/main/groovy/util/logging/Commons.java
index c5091a8c1d..aa25d4afaa 100644
--- a/src/main/groovy/util/logging/Commons.java
+++ b/src/main/groovy/util/logging/Commons.java
@@ -59,12 +59,32 @@ public @interface Commons {
     Class<? extends LogASTTransformation.LoggingStrategy> loggingStrategy() default CommonsLoggingStrategy.class;
 
     public  static class CommonsLoggingStrategy implements LogASTTransformation.LoggingStrategy {
+
+        private static final ClassNode LOGGER_CLASSNODE;
+        private static final ClassNode LOGGERFACTORY_CLASSNODE;
+
+        static {
+            ClassNode tmp1 = null;
+            ClassNode tmp2 = null;
+
+            try {
+                tmp1 = ClassHelper.make(Class.forName("org.apache.commons.logging.Log"));
+                tmp2 = ClassHelper.make(Class.forName("org.apache.commons.logging.LogFactory"));
+            } catch (ClassNotFoundException e) {
+                tmp1 = ClassHelper.make("org.apache.commons.logging.Log");
+                tmp2 = ClassHelper.make("org.apache.commons.logging.LogFactory");
+            } finally {
+                LOGGER_CLASSNODE = tmp1;
+                LOGGERFACTORY_CLASSNODE = tmp2;
+            }
+        }
+
         public FieldNode addLoggerFieldToClass(ClassNode classNode, String logFieldName) {
             return classNode.addField(logFieldName,
                     Opcodes.ACC_FINAL | Opcodes.ACC_TRANSIENT | Opcodes.ACC_STATIC | Opcodes.ACC_PRIVATE,
-                    new ClassNode("org.apache.commons.logging.Log", Opcodes.ACC_PUBLIC, ClassHelper.OBJECT_TYPE),
+                    LOGGER_CLASSNODE,
                     new MethodCallExpression(
-                            new ClassExpression(new ClassNode("org.apache.commons.logging.LogFactory", Opcodes.ACC_PUBLIC, ClassHelper.OBJECT_TYPE)),
+                            new ClassExpression(LOGGERFACTORY_CLASSNODE),
                             "getLog",
                             new ClassExpression(classNode)));
         }
diff --git a/src/main/groovy/util/logging/Log.java b/src/main/groovy/util/logging/Log.java
index b3f98d017b..a094071a42 100644
--- a/src/main/groovy/util/logging/Log.java
+++ b/src/main/groovy/util/logging/Log.java
@@ -1,102 +1,105 @@
-/*
- * Copyright 2003-2010 the original author or authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package groovy.util.logging;
-
-import org.codehaus.groovy.ast.ClassHelper;
-import org.codehaus.groovy.ast.ClassNode;
-import org.codehaus.groovy.ast.FieldNode;
-import org.codehaus.groovy.ast.expr.*;
-import org.codehaus.groovy.transform.GroovyASTTransformationClass;
-import org.codehaus.groovy.transform.LogASTTransformation.LoggingStrategy;
-import org.objectweb.asm.Opcodes;
-
-import java.lang.annotation.ElementType;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.lang.annotation.Target;
-
-/**
- * This local transform adds a logging ability to your program using
- * java.util.logging. Every method call on a unbound variable named <i>log</i>
- * will be mapped to a call to the logger. For this a <i>log</i> field will be
- * inserted in the class. If the field already exists the usage of this transform
- * will cause a compilation error. The method name will be used to determine
- * what to call on the logger.
- * <pre>
- * log.name(exp)
- * </pre>is mapped to
- * <pre>
- * if (log.isLoggable(Level.NAME) {
- *    log.name(exp)
- * }</pre>
- * Here name is a place holder for info, fine, finer, finest, config, warning, severe.
- * NAME is name transformed to upper case. if anything else is used it will result in
- * an exception at runtime. If the expression exp is a constant or only a variable access
- * the method call will not be transformed. But this will still cause a call on the injected
- * logger.
- *
- * @author Guillaume Laforge
- * @author Jochen Theodorou
- * @author Dinko Srkoc
- * @author Hamlet D'Arcy
- * @author Raffaele Cigni
- * @author Alberto Vilches Raton
- * @since 1.8.0
- */
-@java.lang.annotation.Documented
-@Retention(RetentionPolicy.SOURCE)
-@Target({ElementType.TYPE})
-@GroovyASTTransformationClass("org.codehaus.groovy.transform.LogASTTransformation")
-public @interface Log {
-    String value() default "log";
-    Class<? extends LoggingStrategy> loggingStrategy() default JavaUtilLoggingStrategy.class;
-
-    /**
-     * This class contains the logic of how to weave a Java Util Logging logger into the host class.
-     */
-    public static class JavaUtilLoggingStrategy implements LoggingStrategy {
-        public FieldNode addLoggerFieldToClass(ClassNode classNode, String logFieldName) {
-            return classNode.addField(logFieldName,
-                        Opcodes.ACC_FINAL | Opcodes.ACC_TRANSIENT | Opcodes.ACC_STATIC | Opcodes.ACC_PRIVATE,
-                        new ClassNode("java.util.logging.Logger", Opcodes.ACC_PUBLIC, ClassHelper.OBJECT_TYPE),
-                        new MethodCallExpression(
-                                new ClassExpression(new ClassNode("java.util.logging.Logger", Opcodes.ACC_PUBLIC, ClassHelper.OBJECT_TYPE)),
-                                "getLogger",
-                                new ConstantExpression(classNode.getName())));
-        }
-
-        public boolean isLoggingMethod(String methodName) {
-            return methodName.matches("severe|warning|info|fine|finer|finest");
-        }
-
-        public Expression wrapLoggingMethodCall(Expression logVariable, String methodName, Expression originalExpression) {
-            ClassNode levelClass = new ClassNode("java.util.logging.Level", 0, ClassHelper.OBJECT_TYPE);
-            AttributeExpression logLevelExpression = new AttributeExpression(
-                    new ClassExpression(levelClass),
-                    new ConstantExpression(methodName.toUpperCase()));
-
-            ArgumentListExpression args = new ArgumentListExpression();
-            args.addExpression(logLevelExpression);
-            MethodCallExpression condition = new MethodCallExpression(logVariable, "isLoggable", args);
-
-            return new TernaryExpression(
-                    new BooleanExpression(condition),
-                    originalExpression,
-                    ConstantExpression.NULL);
-
-        }
-    }
-}
+/*
+ * Copyright 2003-2010 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package groovy.util.logging;
+
+import org.codehaus.groovy.ast.ClassHelper;
+import org.codehaus.groovy.ast.ClassNode;
+import org.codehaus.groovy.ast.FieldNode;
+import org.codehaus.groovy.ast.expr.*;
+import org.codehaus.groovy.transform.GroovyASTTransformationClass;
+import org.codehaus.groovy.transform.LogASTTransformation.LoggingStrategy;
+import org.objectweb.asm.Opcodes;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * This local transform adds a logging ability to your program using
+ * java.util.logging. Every method call on a unbound variable named <i>log</i>
+ * will be mapped to a call to the logger. For this a <i>log</i> field will be
+ * inserted in the class. If the field already exists the usage of this transform
+ * will cause a compilation error. The method name will be used to determine
+ * what to call on the logger.
+ * <pre>
+ * log.name(exp)
+ * </pre>is mapped to
+ * <pre>
+ * if (log.isLoggable(Level.NAME) {
+ *    log.name(exp)
+ * }</pre>
+ * Here name is a place holder for info, fine, finer, finest, config, warning, severe.
+ * NAME is name transformed to upper case. if anything else is used it will result in
+ * an exception at runtime. If the expression exp is a constant or only a variable access
+ * the method call will not be transformed. But this will still cause a call on the injected
+ * logger.
+ *
+ * @author Guillaume Laforge
+ * @author Jochen Theodorou
+ * @author Dinko Srkoc
+ * @author Hamlet D'Arcy
+ * @author Raffaele Cigni
+ * @author Alberto Vilches Raton
+ * @since 1.8.0
+ */
+@java.lang.annotation.Documented
+@Retention(RetentionPolicy.SOURCE)
+@Target({ElementType.TYPE})
+@GroovyASTTransformationClass("org.codehaus.groovy.transform.LogASTTransformation")
+public @interface Log {
+    String value() default "log";
+    Class<? extends LoggingStrategy> loggingStrategy() default JavaUtilLoggingStrategy.class;
+
+    /**
+     * This class contains the logic of how to weave a Java Util Logging logger into the host class.
+     */
+    public static class JavaUtilLoggingStrategy implements LoggingStrategy {
+
+        private static final ClassNode LOGGER_CLASSNODE = ClassHelper.make(java.util.logging.Logger.class);
+        private static final ClassNode LEVEL_CLASSNODE = ClassHelper.make(java.util.logging.Level.class);
+
+        public FieldNode addLoggerFieldToClass(ClassNode classNode, String logFieldName) {
+            return classNode.addField(logFieldName,
+                        Opcodes.ACC_FINAL | Opcodes.ACC_TRANSIENT | Opcodes.ACC_STATIC | Opcodes.ACC_PRIVATE,
+                        LOGGER_CLASSNODE,
+                        new MethodCallExpression(
+                                new ClassExpression(LOGGER_CLASSNODE),
+                                "getLogger",
+                                new ConstantExpression(classNode.getName())));
+        }
+
+        public boolean isLoggingMethod(String methodName) {
+            return methodName.matches("severe|warning|info|fine|finer|finest");
+        }
+
+        public Expression wrapLoggingMethodCall(Expression logVariable, String methodName, Expression originalExpression) {
+            AttributeExpression logLevelExpression = new AttributeExpression(
+                    new ClassExpression(LEVEL_CLASSNODE),
+                    new ConstantExpression(methodName.toUpperCase()));
+
+            ArgumentListExpression args = new ArgumentListExpression();
+            args.addExpression(logLevelExpression);
+            MethodCallExpression condition = new MethodCallExpression(logVariable, "isLoggable", args);
+
+            return new TernaryExpression(
+                    new BooleanExpression(condition),
+                    originalExpression,
+                    ConstantExpression.NULL);
+
+        }
+    }
+}
diff --git a/src/main/groovy/util/logging/Log4j.java b/src/main/groovy/util/logging/Log4j.java
index 43e4db86fb..2a6fe971f0 100644
--- a/src/main/groovy/util/logging/Log4j.java
+++ b/src/main/groovy/util/logging/Log4j.java
@@ -1,100 +1,118 @@
-/*
- * Copyright 2003-2010 the original author or authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package groovy.util.logging;
-
-import org.codehaus.groovy.ast.ClassHelper;
-import org.codehaus.groovy.ast.ClassNode;
-import org.codehaus.groovy.ast.FieldNode;
-import org.codehaus.groovy.ast.expr.*;
-import org.codehaus.groovy.transform.GroovyASTTransformationClass;
-import org.codehaus.groovy.transform.LogASTTransformation;
-import org.objectweb.asm.Opcodes;
-
-import java.lang.annotation.ElementType;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.lang.annotation.Target;
-
-/**
- * This local transform adds a logging ability to your program using
- * Log4j logging. Every method call on a unbound variable named <i>log</i>
- * will be mapped to a call to the logger. For this a <i>log</i> field will be
- * inserted in the class. If the field already exists the usage of this transform
- * will cause a compilation error. The method name will be used to determine
- * what to call on the logger.
- * <pre>
- * log.name(exp)
- * </pre>is mapped to
- * <pre>
- * if (log.isNameEnabled() {
- *    log.name(exp)
- * }</pre>
- * Here name is a place holder for info, debug, warning, error, etc.
- * If the expression exp is a constant or only a variable access the method call will
- * not be transformed. But this will still cause a call on the injected logger.
- *
- * @author Hamlet D'Arcy
- * @author Tomek Bujok
- * @since 1.8.0
- */
-@java.lang.annotation.Documented
-@Retention(RetentionPolicy.SOURCE)
-@Target({ElementType.TYPE})
-@GroovyASTTransformationClass("org.codehaus.groovy.transform.LogASTTransformation")
-public @interface Log4j {
-    String value() default "log";
-    Class<? extends LogASTTransformation.LoggingStrategy> loggingStrategy() default Log4jLoggingStrategy.class;
-
-    public static class Log4jLoggingStrategy implements LogASTTransformation.LoggingStrategy {
-        public FieldNode addLoggerFieldToClass(ClassNode classNode, String logFieldName) {
-            return classNode.addField(logFieldName,
-                    Opcodes.ACC_FINAL | Opcodes.ACC_TRANSIENT | Opcodes.ACC_STATIC | Opcodes.ACC_PRIVATE,
-                    new ClassNode("org.apache.log4j.Logger", Opcodes.ACC_PUBLIC, ClassHelper.OBJECT_TYPE),
-                    new MethodCallExpression(
-                            new ClassExpression(new ClassNode("org.apache.log4j.Logger", Opcodes.ACC_PUBLIC, ClassHelper.OBJECT_TYPE)),
-                            "getLogger",
-                            new ClassExpression(classNode)));
-        }
-
-        public boolean isLoggingMethod(String methodName) {
-            return methodName.matches("fatal|error|warn|info|debug|trace");
-        }
-
-        public Expression wrapLoggingMethodCall(Expression logVariable, String methodName, Expression originalExpression) {
-            final MethodCallExpression condition;
-            if (!"trace".equals(methodName)) {
-                ClassNode levelClass = new ClassNode("org.apache.log4j.Priority", 0, ClassHelper.OBJECT_TYPE);
-                AttributeExpression logLevelExpression = new AttributeExpression(
-                        new ClassExpression(levelClass),
-                        new ConstantExpression(methodName.toUpperCase()));
-                ArgumentListExpression args = new ArgumentListExpression();
-                args.addExpression(logLevelExpression);
-                condition = new MethodCallExpression(logVariable, "isEnabledFor", args);
-            } else {
-                // log4j api is inconsistent, so trace requires special handling
-                condition = new MethodCallExpression(
-                        logVariable,
-                        "is" + methodName.substring(0, 1).toUpperCase() + methodName.substring(1, methodName.length()) + "Enabled",
-                        ArgumentListExpression.EMPTY_ARGUMENTS);
-            }
-
-            return new TernaryExpression(
-                    new BooleanExpression(condition),
-                    originalExpression,
-                    ConstantExpression.NULL);
-        }
-    }
-}
+/*
+ * Copyright 2003-2010 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package groovy.util.logging;
+
+import org.codehaus.groovy.ast.ClassHelper;
+import org.codehaus.groovy.ast.ClassNode;
+import org.codehaus.groovy.ast.FieldNode;
+import org.codehaus.groovy.ast.expr.*;
+import org.codehaus.groovy.transform.GroovyASTTransformationClass;
+import org.codehaus.groovy.transform.LogASTTransformation;
+import org.objectweb.asm.Opcodes;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * This local transform adds a logging ability to your program using
+ * Log4j logging. Every method call on a unbound variable named <i>log</i>
+ * will be mapped to a call to the logger. For this a <i>log</i> field will be
+ * inserted in the class. If the field already exists the usage of this transform
+ * will cause a compilation error. The method name will be used to determine
+ * what to call on the logger.
+ * <pre>
+ * log.name(exp)
+ * </pre>is mapped to
+ * <pre>
+ * if (log.isNameEnabled() {
+ *    log.name(exp)
+ * }</pre>
+ * Here name is a place holder for info, debug, warning, error, etc.
+ * If the expression exp is a constant or only a variable access the method call will
+ * not be transformed. But this will still cause a call on the injected logger.
+ *
+ * @author Hamlet D'Arcy
+ * @author Tomek Bujok
+ * @since 1.8.0
+ */
+@java.lang.annotation.Documented
+@Retention(RetentionPolicy.SOURCE)
+@Target({ElementType.TYPE})
+@GroovyASTTransformationClass("org.codehaus.groovy.transform.LogASTTransformation")
+public @interface Log4j {
+    String value() default "log";
+    Class<? extends LogASTTransformation.LoggingStrategy> loggingStrategy() default Log4jLoggingStrategy.class;
+
+    public static class Log4jLoggingStrategy implements LogASTTransformation.LoggingStrategy {
+        private static final ClassNode LOGGER_CLASSNODE;
+        private static final ClassNode PRIORITY_CLASSNODE;
+
+        static {
+            ClassNode tmp1 = null;
+            ClassNode tmp2 = null;
+
+            try {
+                tmp1 = ClassHelper.make(Class.forName("org.apache.log4j.Logger"));
+                tmp2 = ClassHelper.make(Class.forName("org.apache.log4j.Priority"));
+            } catch (ClassNotFoundException e) {
+                tmp1 = ClassHelper.make("org.apache.log4j.Logger");
+                tmp2 = ClassHelper.make("org.apache.log4j.Priority");
+            } finally {
+                LOGGER_CLASSNODE = tmp1;
+                PRIORITY_CLASSNODE = tmp2;
+            }
+        }
+
+        public FieldNode addLoggerFieldToClass(ClassNode classNode, String logFieldName) {
+            return classNode.addField(logFieldName,
+                    Opcodes.ACC_FINAL | Opcodes.ACC_TRANSIENT | Opcodes.ACC_STATIC | Opcodes.ACC_PRIVATE,
+                    LOGGER_CLASSNODE,
+                    new MethodCallExpression(
+                            new ClassExpression(LOGGER_CLASSNODE),
+                            "getLogger",
+                            new ClassExpression(classNode)));
+        }
+
+        public boolean isLoggingMethod(String methodName) {
+            return methodName.matches("fatal|error|warn|info|debug|trace");
+        }
+
+        public Expression wrapLoggingMethodCall(Expression logVariable, String methodName, Expression originalExpression) {
+            final MethodCallExpression condition;
+            if (!"trace".equals(methodName)) {
+                AttributeExpression logLevelExpression = new AttributeExpression(
+                        new ClassExpression(PRIORITY_CLASSNODE),
+                        new ConstantExpression(methodName.toUpperCase()));
+                ArgumentListExpression args = new ArgumentListExpression();
+                args.addExpression(logLevelExpression);
+                condition = new MethodCallExpression(logVariable, "isEnabledFor", args);
+            } else {
+                // log4j api is inconsistent, so trace requires special handling
+                condition = new MethodCallExpression(
+                        logVariable,
+                        "is" + methodName.substring(0, 1).toUpperCase() + methodName.substring(1, methodName.length()) + "Enabled",
+                        ArgumentListExpression.EMPTY_ARGUMENTS);
+            }
+
+            return new TernaryExpression(
+                    new BooleanExpression(condition),
+                    originalExpression,
+                    ConstantExpression.NULL);
+        }
+    }
+}
diff --git a/src/main/groovy/util/logging/Slf4j.java b/src/main/groovy/util/logging/Slf4j.java
index f012a1988e..be37287b6f 100644
--- a/src/main/groovy/util/logging/Slf4j.java
+++ b/src/main/groovy/util/logging/Slf4j.java
@@ -1,90 +1,109 @@
-/*
- * Copyright 2003-2010 the original author or authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package groovy.util.logging;
-
-import java.lang.annotation.ElementType;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.lang.annotation.Target;
-
-import org.codehaus.groovy.ast.ClassHelper;
-import org.codehaus.groovy.ast.ClassNode;
-import org.codehaus.groovy.ast.FieldNode;
-import org.codehaus.groovy.ast.expr.*;
-import org.codehaus.groovy.transform.GroovyASTTransformationClass;
-import org.codehaus.groovy.transform.LogASTTransformation;
-import org.objectweb.asm.Opcodes;
-
-/**
- * This local transform adds a logging ability to your program using
- * LogBack logging. Every method call on a unbound variable named <i>log</i>
- * will be mapped to a call to the logger. For this a <i>log</i> field will be
- * inserted in the class. If the field already exists the usage of this transform
- * will cause a compilation error. The method name will be used to determine
- * what to call on the logger.
- * <pre>
- * log.name(exp)
- * </pre>is mapped to
- * <pre>
- * if (log.isNameLoggable() {
- *    log.name(exp)
- * }</pre>
- * Here name is a place holder for info, debug, warning, error, etc.
- * If the expression exp is a constant or only a variable access the method call will
- * not be transformed. But this will still cause a call on the injected logger.
- *
- * @author Hamlet D'Arcy
- * @author Alberto Mijares
- * @since 1.8.0
- */
-@java.lang.annotation.Documented
-@Retention(RetentionPolicy.SOURCE)
-@Target({ElementType.TYPE})
-@GroovyASTTransformationClass("org.codehaus.groovy.transform.LogASTTransformation")
-public @interface Slf4j {
-    String value() default "log";
-    Class<? extends LogASTTransformation.LoggingStrategy> loggingStrategy() default Slf4jLoggingStrategy.class;
-
-    public static class Slf4jLoggingStrategy implements LogASTTransformation.LoggingStrategy {
-        public FieldNode addLoggerFieldToClass(ClassNode classNode, String logFieldName) {
-            return classNode.addField(logFieldName,
-                    Opcodes.ACC_FINAL | Opcodes.ACC_TRANSIENT | Opcodes.ACC_STATIC | Opcodes.ACC_PRIVATE,
-                    new ClassNode("org.slf4j.Logger", Opcodes.ACC_PUBLIC, ClassHelper.OBJECT_TYPE),
-                    new MethodCallExpression(
-                            new ClassExpression(new ClassNode("org.slf4j.LoggerFactory", Opcodes.ACC_PUBLIC, ClassHelper.OBJECT_TYPE)),
-                            "getLogger",
-                            new ClassExpression(classNode)));
-
-        }
-
-        public boolean isLoggingMethod(String methodName) {
-            return methodName.matches("error|warn|info|debug|trace");
-        }
-
-        public Expression wrapLoggingMethodCall(Expression logVariable, String methodName, Expression originalExpression) {
-            MethodCallExpression condition = new MethodCallExpression(
-                    logVariable,
-                    "is" + methodName.substring(0, 1).toUpperCase() + methodName.substring(1, methodName.length()) + "Enabled",
-                    ArgumentListExpression.EMPTY_ARGUMENTS);
-
-            return new TernaryExpression(
-                    new BooleanExpression(condition),
-                    originalExpression,
-                    ConstantExpression.NULL);
-        }
-    }
-
-}
+/*
+ * Copyright 2003-2010 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package groovy.util.logging;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+import org.codehaus.groovy.ast.ClassHelper;
+import org.codehaus.groovy.ast.ClassNode;
+import org.codehaus.groovy.ast.FieldNode;
+import org.codehaus.groovy.ast.expr.*;
+import org.codehaus.groovy.transform.GroovyASTTransformationClass;
+import org.codehaus.groovy.transform.LogASTTransformation;
+import org.objectweb.asm.Opcodes;
+
+/**
+ * This local transform adds a logging ability to your program using
+ * LogBack logging. Every method call on a unbound variable named <i>log</i>
+ * will be mapped to a call to the logger. For this a <i>log</i> field will be
+ * inserted in the class. If the field already exists the usage of this transform
+ * will cause a compilation error. The method name will be used to determine
+ * what to call on the logger.
+ * <pre>
+ * log.name(exp)
+ * </pre>is mapped to
+ * <pre>
+ * if (log.isNameLoggable() {
+ *    log.name(exp)
+ * }</pre>
+ * Here name is a place holder for info, debug, warning, error, etc.
+ * If the expression exp is a constant or only a variable access the method call will
+ * not be transformed. But this will still cause a call on the injected logger.
+ *
+ * @author Hamlet D'Arcy
+ * @author Alberto Mijares
+ * @since 1.8.0
+ */
+@java.lang.annotation.Documented
+@Retention(RetentionPolicy.SOURCE)
+@Target({ElementType.TYPE})
+@GroovyASTTransformationClass("org.codehaus.groovy.transform.LogASTTransformation")
+public @interface Slf4j {
+    String value() default "log";
+    Class<? extends LogASTTransformation.LoggingStrategy> loggingStrategy() default Slf4jLoggingStrategy.class;
+
+    public static class Slf4jLoggingStrategy implements LogASTTransformation.LoggingStrategy {
+        private static final ClassNode LOGGER_CLASSNODE;
+        private static final ClassNode FACTORY_CLASSNODE;
+
+        static {
+            ClassNode tmp1 = null;
+            ClassNode tmp2 = null;
+
+            try {
+                tmp1 = ClassHelper.make(Class.forName("org.slf4j.Logger"));
+                tmp2 = ClassHelper.make(Class.forName("org.slf4j.LoggerFactory"));
+            } catch (ClassNotFoundException e) {
+                tmp1 = ClassHelper.make("org.slf4j.Logger");
+                tmp2 = ClassHelper.make("org.slf4j.LoggerFactory");
+            } finally {
+                LOGGER_CLASSNODE = tmp1;
+                FACTORY_CLASSNODE = tmp2;
+            }
+        }
+
+        public FieldNode addLoggerFieldToClass(ClassNode classNode, String logFieldName) {
+            return classNode.addField(logFieldName,
+                    Opcodes.ACC_FINAL | Opcodes.ACC_TRANSIENT | Opcodes.ACC_STATIC | Opcodes.ACC_PRIVATE,
+                    LOGGER_CLASSNODE,
+                    new MethodCallExpression(
+                            new ClassExpression(FACTORY_CLASSNODE),
+                            "getLogger",
+                            new ClassExpression(classNode)));
+
+        }
+
+        public boolean isLoggingMethod(String methodName) {
+            return methodName.matches("error|warn|info|debug|trace");
+        }
+
+        public Expression wrapLoggingMethodCall(Expression logVariable, String methodName, Expression originalExpression) {
+            MethodCallExpression condition = new MethodCallExpression(
+                    logVariable,
+                    "is" + methodName.substring(0, 1).toUpperCase() + methodName.substring(1, methodName.length()) + "Enabled",
+                    ArgumentListExpression.EMPTY_ARGUMENTS);
+
+            return new TernaryExpression(
+                    new BooleanExpression(condition),
+                    originalExpression,
+                    ConstantExpression.NULL);
+        }
+    }
+
+}
