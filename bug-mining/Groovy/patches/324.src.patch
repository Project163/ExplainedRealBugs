diff --git a/config/maven/groovy.pom b/config/maven/groovy.pom
index 3e1f2c6765..76edcf36aa 100644
--- a/config/maven/groovy.pom
+++ b/config/maven/groovy.pom
@@ -370,6 +370,10 @@
             <name>Tugdual Grall</name>
             <email></email>
         </contributor>
+        <contributor>
+            <name>Edwin Tellman</name>
+            <email></email>
+        </contributor>
     </contributors>
 
     <dependencies>
diff --git a/src/main/groovy/lang/EmptyRange.java b/src/main/groovy/lang/EmptyRange.java
index 1969c230b3..fcd44d37b0 100644
--- a/src/main/groovy/lang/EmptyRange.java
+++ b/src/main/groovy/lang/EmptyRange.java
@@ -7,89 +7,95 @@ import java.util.*;
 /**
  * Constructing Ranges like 0..<0
  * @author Dierk Koenig
+ * @author Edwin Tellman
  */
-public class EmptyRange implements Range {
+public class EmptyRange extends AbstractList implements Range {
+    
+    /**
+     * The value at which the range originates (may be <code>null</code>).
+     */
     protected Comparable at;
-    protected final List EMPTY_LIST = new ArrayList();
 
+    /**
+     * Creates a new {@link EmptyRange}.
+     * 
+     * @param at the value at which the range starts (may be <code>null</code>).
+     */
     public EmptyRange(Comparable at) {
        this.at = at;
     }
 
+    /**
+     * {@inheritDoc}
+     */
     public Comparable getFrom() {
         return at;
     }
 
+    /**
+     * {@inheritDoc}
+     */
     public Comparable getTo() {
         return at;
     }
 
+    /**
+     * Returns <code>false</code>
+     * 
+     * @return <code>false</code>
+     */
     public boolean isReverse() {
         return false;
     }
 
+    /**
+     * {@inheritDoc}
+     */
+    public boolean containsWithinBounds(Object o) {
+        return false;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
     public String inspect() {
-        return InvokerHelper.inspect(at)+"..<"+InvokerHelper.inspect(at);
+        return InvokerHelper.inspect(at) + "..<" + InvokerHelper.inspect(at);
     }
 
+    /**
+     * {@inheritDoc}
+     */
     public String toString() {
-        if (null == at) return "null..<null";
-        return at.toString()+"..<"+at.toString();
+        return (null == at) 
+            ? "null..<null"
+            : at.toString() + "..<" + at.toString();
     }
 
+    /**
+     * Returns 0
+     * 
+     * @return 0
+     */
     public int size() {
         return 0;
     }
 
-    public void clear() {
-    }
-
-    public boolean isEmpty() {
-        return true;
-    }
-
-    public Object[] toArray() {
-        return new Object[0];
-    }
-
-    public Object get(int index) {
-        return null;
-    }
-
-    public Object remove(int index) {
-        return null;
-    }
-
     /**
-     * @throws UnsupportedOperationException
+     * Throws <code>IndexOutOfBoundsException</code>.
+     * 
+     * @throws IndexOutOfBoundsException always
      */
-    public void add(int index, Object element) {
-        throw new UnsupportedOperationException("cannot add to Empty Ranges");
-    }
-
-    public int indexOf(Object o) {
-        return -1;
-    }
-
-    public int lastIndexOf(Object o) {
-        return -1;
+    public Object get(int index) {
+        throw new IndexOutOfBoundsException("can't get values from Empty Ranges");
     }
 
     /**
-     * @throws UnsupportedOperationException
+     * @throws UnsupportedOperationException always
      */
     public boolean add(Object o) {
         throw new UnsupportedOperationException("cannot add to Empty Ranges");
     }
 
-    public boolean contains(Object o) {
-        return false;
-    }
-
-    public boolean remove(Object o) {
-        return false;
-    }
-
     /**
      * @throws UnsupportedOperationException
      */
@@ -103,33 +109,33 @@ public class EmptyRange implements Range {
     public boolean addAll(Collection c) {
         throw new UnsupportedOperationException("cannot add to Empty Ranges");
     }
+    
+    /** 
+     * @throws UnsupportedOperationException
+     */
+    public boolean remove(Object o) {
+        throw new UnsupportedOperationException("cannot remove from Empty Ranges");
+    }
 
-    public boolean containsAll(Collection c) {
-        return false;
+    /** 
+     * @throws UnsupportedOperationException
+     */
+    public Object remove(int index) {
+        throw new UnsupportedOperationException("cannot remove from Empty Ranges");
     }
 
+    /**
+     * @throws UnsupportedOperationException
+     */
     public boolean removeAll(Collection c) {
-        return false;
+        throw new UnsupportedOperationException("cannot remove from Empty Ranges");
     }
 
+    /**
+     * @throws UnsupportedOperationException
+     */
     public boolean retainAll(Collection c) {
-        return false;
-    }
-
-    public Iterator iterator() {
-        return EMPTY_LIST.iterator();
-    }
-
-    public List subList(int fromIndex, int toIndex) {
-        return EMPTY_LIST.subList(fromIndex, toIndex);
-    }
-
-    public ListIterator listIterator() {
-        return EMPTY_LIST.listIterator();
-    }
-
-    public ListIterator listIterator(int index) {
-        return EMPTY_LIST.listIterator(index);
+        throw new UnsupportedOperationException("cannot retainAll in Empty Ranges");
     }
 
      /**
@@ -139,14 +145,16 @@ public class EmptyRange implements Range {
         throw new UnsupportedOperationException("cannot set in Empty Ranges");
     }
 
-    public Object[] toArray(Object a[]) {
-        return new Object[0];
-    }
-
+    /**
+     * {@inheritDoc}
+     */
     public void step(int step, Closure closure) {
     }
 
+    /**
+     * {@inheritDoc}
+     */
     public List step(int step) {
-        return EMPTY_LIST;
+        return new ArrayList();
     }
 }
diff --git a/src/main/groovy/lang/IntRange.java b/src/main/groovy/lang/IntRange.java
index 7af80de8a8..4351a70b2b 100644
--- a/src/main/groovy/lang/IntRange.java
+++ b/src/main/groovy/lang/IntRange.java
@@ -45,92 +45,217 @@
  */
 package groovy.lang;
 
+import org.codehaus.groovy.runtime.DefaultGroovyMethods;
+import org.codehaus.groovy.runtime.IteratorClosureAdapter;
+
+import javax.naming.OperationNotSupportedException;
+import java.math.BigInteger;
 import java.util.AbstractList;
+import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
-import java.math.BigInteger;
-
-import org.codehaus.groovy.runtime.IteratorClosureAdapter;
-import org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation;
 
 /**
- * Represents a list of Integer objects from a specified int up to and including
- * a given and to.
- * 
+ * Represents a list of Integer objects from a specified int up (or down) to and including
+ * a given to.<p>
+ * <p/>
+ * This class is a copy of {@link ObjectRange} optimized for <code>int</code>.  If you make any
+ * changes to this class, you might consider making parallel changes to {@link ObjectRange}.
+ *
  * @author <a href="mailto:james@coredevelopers.net">James Strachan</a>
  * @version $Revision$
  */
 public class IntRange extends AbstractList implements Range {
 
+    /**
+     * Iterates through each number in an <code>IntRange</code>.
+     */
+    private class IntRangeIterator implements Iterator {
+        /**
+         * Counts from 0 up to size - 1.
+         */
+        int index = 0;
+
+        /**
+         * The number of values in the range.
+         */
+        int size = size();
+
+        /**
+         * The next value to return.
+         */
+        int value = (reverse) ? to : from;
+
+        /**
+         * {@inheritDoc}
+         */
+        public boolean hasNext() {
+            return index < size;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        public Object next() {
+            if (index++ > 0) {
+                if (index > size) {
+                    return null;
+                } else {
+                    if (reverse) {
+                        --value;
+                    } else {
+                        ++value;
+                    }
+                }
+            }
+            return new Integer(value);
+        }
+
+        /**
+         * Not supported.
+         *
+         * @throws OperationNotSupportedException always
+         */
+        public void remove() {
+            IntRange.this.remove(index);
+        }
+    }
+
+    /**
+     * The first number in the range.  <code>from </code> is always less than or equal to <code>to</code>.
+     */
     private int from;
+
+    /**
+     * The last number in the range. <code>to</code> is always greater than or eqaul to <code>from</code>.
+     */
     private int to;
+
+    /**
+     * If <code>false</code>, counts up from <code>from</code> to <code>to</code>.  Otherwise, counts down
+     * from <code>to</code> to <code>from</code>.
+     */
     private boolean reverse;
 
+    /**
+     * Creates a new <code>IntRange</code>. If <code>from</code> is greater
+     * than <code>to</code>, a reverse range is created with
+     * <code>from</code> and <code>to</code> swapped.
+     *
+     * @param from the first number in the range.
+     * @param to   the last number in the range.
+     * @throws IllegalArgumentException if the range would contain more than
+     *                                  {@link Integer#MAX_VALUE} values.
+     */
     public IntRange(int from, int to) {
         if (from > to) {
             this.from = to;
             this.to = from;
             this.reverse = true;
-        }
-        else {
+        } else {
             this.from = from;
             this.to = to;
         }
+
+        // size() an integer so ranges can have no more than Integer.MAX_VALUE elements
+        if (this.to - this.from >= Integer.MAX_VALUE) {
+            throw new IllegalArgumentException("range must have no more than " + Integer.MAX_VALUE + " elements");
+        }
     }
 
+    /**
+     * Creates a new <code>IntRange</code>.
+     *
+     * @param from    the first value in the range.
+     * @param to      the last value in the range.
+     * @param reverse <code>true</code> if the range should count from
+     *                <code>to</code> to <code>from</code>.
+     * @throws IllegalArgumentException if <code>from</code> is greater than <code>to</code>.
+     */
     protected IntRange(int from, int to, boolean reverse) {
+        if (from > to) {
+            throw new IllegalArgumentException("'from' must be less than or equal to 'to'");
+        }
+
         this.from = from;
         this.to = to;
         this.reverse = reverse;
     }
 
+    /**
+     * Determines if this object is equal to another object. Delegates to
+     * {@link AbstractList#equals(Object)} if <code>that</code> is anthing
+     * other than an {@link IntRange}.
+     * <p/>
+     * <p/>
+     * It is not necessary to override <code>hashCode</code>, as
+     * {@link AbstractList#hashCode()} provides a suitable hash code.<p>
+     * <p/>
+     * Note that equals is generally handled by {@link DefaultGroovyMethods#equals(List,List)} instead of this
+     * method.
+     *
+     * @param that the object to compare
+     * @return <code>true</code> if the objects are equal
+     */
     public boolean equals(Object that) {
-        if (that instanceof IntRange) {
-            return equals((IntRange) that);
-        }
-        else if (that instanceof List) {
-            return equals((List) that);
-        }
-        return false;
-    }
-
-    public boolean equals(List that) {
-        int size = size();
-        if (that.size() == size) {
-            for (int i = 0; i < size; i++) {
-                if (!DefaultTypeTransformation.compareEqual(get(i), that.get(i))) {
-                    return false;
-                }
-            }
-            return true;
-        }
-        return false;
+        return that instanceof IntRange ? equals((IntRange) that) : super.equals(that);
     }
 
+    /**
+     * Compares an {@link IntRange} to another {@link IntRange}.
+     *
+     * @return <code>true</code> if the ranges are equal
+     */
     public boolean equals(IntRange that) {
-        return this.reverse == that.reverse && this.from == that.from && this.to == that.to;
+        return that != null && this.reverse == that.reverse && this.from == that.from && this.to == that.to;
     }
 
+    /**
+     * {@inheritDoc}
+     */
     public Comparable getFrom() {
         return new Integer(from);
     }
 
+    /**
+     * {@inheritDoc}
+     */
     public Comparable getTo() {
         return new Integer(to);
     }
 
+    /**
+     * Gets the 'from' value as an integer.
+     *
+     * @return the 'from' value as an integer.
+     */
     public int getFromInt() {
         return from;
     }
 
+    /**
+     * Gets the 'to' value as an integer.
+     *
+     * @return the 'to' value as an integer.
+     */
     public int getToInt() {
         return to;
     }
 
+    /**
+     * {@inheritDoc}
+     */
     public boolean isReverse() {
         return reverse;
     }
 
+    public boolean containsWithinBounds(Object o) {
+        return contains(o);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
     public Object get(int index) {
         if (index < 0) {
             throw new IndexOutOfBoundsException("Index: " + index + " should not be negative");
@@ -142,47 +267,23 @@ public class IntRange extends AbstractList implements Range {
         return new Integer(value);
     }
 
+    /**
+     * {@inheritDoc}
+     */
     public int size() {
         return to - from + 1;
     }
 
-    public int hashCode() {
-        return from ^ to + (reverse ? 1 : 0);
-    }
-
+    /**
+     * {@inheritDoc}
+     */
     public Iterator iterator() {
-        return new Iterator() {
-            private int index;
-            private int size = size();
-            private int value = reverse ? to : from;
-
-            public boolean hasNext() {
-                return index < size;
-            }
-
-            public Object next() {
-                if (index++ > 0) {
-                    if (index > size) {
-                        return null;
-                    }
-                    else {
-                        if (reverse) {
-                            --value;
-                        }
-                        else {
-                            ++value;
-                        }
-                    }
-                }
-                return new Integer(value);
-            }
-
-            public void remove() {
-                IntRange.this.remove(index);
-            }
-        };
+        return new IntRangeIterator();
     }
 
+    /**
+     * {@inheritDoc}
+     */
     public List subList(int fromIndex, int toIndex) {
         if (fromIndex < 0) {
             throw new IndexOutOfBoundsException("fromIndex = " + fromIndex);
@@ -193,27 +294,37 @@ public class IntRange extends AbstractList implements Range {
         if (fromIndex > toIndex) {
             throw new IllegalArgumentException("fromIndex(" + fromIndex + ") > toIndex(" + toIndex + ")");
         }
+
+        if (fromIndex == toIndex) {
+            return new EmptyRange(new Integer(from));
+        }
+
         return new IntRange(fromIndex + this.from, toIndex + this.from - 1, reverse);
     }
 
+    /**
+     * {@inheritDoc}
+     */
     public String toString() {
         return reverse ? "" + to + ".." + from : "" + from + ".." + to;
     }
-    
+
+    /**
+     * {@inheritDoc}
+     */
     public String inspect() {
         return toString();
     }
-    
+
+    /**
+     * {@inheritDoc}
+     */
     public boolean contains(Object value) {
         if (value instanceof Integer) {
             Integer integer = (Integer) value;
             int i = integer.intValue();
             return i >= from && i <= to;
         }
-        if (value instanceof IntRange) {
-            IntRange range = (IntRange) value;
-            return from<=range.from && range.to<=to;
-        }
         if (value instanceof BigInteger) {
             BigInteger bigint = (BigInteger) value;
             return bigint.compareTo(BigInteger.valueOf(from)) >= 0 &&
@@ -222,6 +333,20 @@ public class IntRange extends AbstractList implements Range {
         return false;
     }
 
+    /**
+     * {@inheritDoc}
+     */
+    public boolean containsAll(Collection other) {
+        if (other instanceof IntRange) {
+            final IntRange range = (IntRange) other;
+            return this.from <= range.from && range.to <= this.to;
+        }
+        return super.containsAll(other);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
     public void step(int step, Closure closure) {
         if (reverse) {
             step = -step;
@@ -232,8 +357,7 @@ public class IntRange extends AbstractList implements Range {
                 closure.call(new Integer(value));
                 value = value + step;
             }
-        }
-        else {
+        } else {
             int value = to;
             while (value >= from) {
                 closure.call(new Integer(value));
@@ -242,6 +366,9 @@ public class IntRange extends AbstractList implements Range {
         }
     }
 
+    /**
+     * {@inheritDoc}
+     */
     public List step(int step) {
         IteratorClosureAdapter adapter = new IteratorClosureAdapter(this);
         step(step, adapter);
diff --git a/src/main/groovy/lang/ObjectRange.java b/src/main/groovy/lang/ObjectRange.java
index ef733a45db..e44c892e89 100644
--- a/src/main/groovy/lang/ObjectRange.java
+++ b/src/main/groovy/lang/ObjectRange.java
@@ -48,30 +48,60 @@ package groovy.lang;
 import org.codehaus.groovy.runtime.InvokerHelper;
 import org.codehaus.groovy.runtime.IteratorClosureAdapter;
 import org.codehaus.groovy.runtime.ScriptBytecodeAdapter;
-import org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation;
 
+import java.math.BigDecimal;
+import java.math.BigInteger;
 import java.util.AbstractList;
 import java.util.Iterator;
 import java.util.List;
-import java.math.BigDecimal;
-import java.math.BigInteger;
 
 /**
  * Represents an inclusive list of objects from a value to a value using
- * comparators
+ * comparators.
+ * <p/>
+ * This class is similar to {@link IntRange}. If you make any changes to this
+ * class, you might consider making parallel changes to {@link IntRange}.
  *
  * @author <a href="mailto:james@coredevelopers.net">James Strachan</a>
  * @version $Revision$
  */
 public class ObjectRange extends AbstractList implements Range {
 
+    /**
+     * The first value in the range.
+     */
     private Comparable from;
+
+    /**
+     * The last value in the range.
+     */
     private Comparable to;
-    private int size;
+
+    /**
+     * The cached size, or -1 if not yet computed
+     */
+    private int size = -1;
+
+    /**
+     * <code>true</code> if the range counts backwards from <code>to</code> to <code>from</code>.
+     */
     private final boolean reverse;
 
+    /**
+     * Creates a new {@link ObjectRange}. Creates a reversed range if
+     * <code>from</code> < <code>to</code>.
+     *
+     * @param from the first value in the range.
+     * @param to   the last value in the range.
+     */
     public ObjectRange(Comparable from, Comparable to) {
-        this.size = -1;
+        if (from == null) {
+            throw new IllegalArgumentException("Must specify a non-null value for the 'from' index in a Range");
+        }
+        if (to == null) {
+            throw new IllegalArgumentException("Must specify a non-null value for the 'to' index in a Range");
+        }
+
         this.reverse = ScriptBytecodeAdapter.compareGreaterThan(from, to);
         if (this.reverse) {
             constructorHelper(to, from);
@@ -81,20 +111,19 @@ public class ObjectRange extends AbstractList implements Range {
     }
 
     public ObjectRange(Comparable from, Comparable to, boolean reverse) {
-        this.size = -1;
         constructorHelper(from, to);
 
         this.reverse = reverse;
     }
 
     private void constructorHelper(Comparable from, Comparable to) {
-        if (from == null) {
-            throw new IllegalArgumentException("Must specify a non-null value for the 'from' index in a Range");
-        }
-        if (to == null) {
-            throw new IllegalArgumentException("Must specify a non-null value for the 'to' index in a Range");
-        }
-        if (from.getClass() == to.getClass()) {
+        if (from instanceof Short && to instanceof Short) {
+            this.from = new Integer(((Short) from).intValue());
+            this.to = new Integer(((Short) to).intValue());
+        } else if (from instanceof Float && to instanceof Float) {
+            this.from = new Double(((Float) from).doubleValue());
+            this.to = new Double(((Float) to).doubleValue());
+        } else if (from.getClass() == to.getClass()) {
             this.from = from;
             this.to = to;
         } else {
@@ -121,51 +150,49 @@ public class ObjectRange extends AbstractList implements Range {
         }
     }
 
-    public int hashCode() {
-        /** @todo should code this the Josh Bloch way */
-        return from.hashCode() ^ to.hashCode() + (reverse ? 1 : 0);
-    }
-
+    /**
+     * {@inheritDoc}
+     */
     public boolean equals(Object that) {
-        if (that instanceof ObjectRange) {
-            return equals((ObjectRange) that);
-        } else if (that instanceof List) {
-            return equals((List) that);
-        }
-        return false;
+        return (that instanceof ObjectRange) ? equals((ObjectRange) that) : super.equals(that);
     }
 
+    /**
+     * Compares an {@link ObjectRange} to another {@link ObjectRange}.
+     *
+     * @return <code>true</code> if the ranges are equal
+     */
     public boolean equals(ObjectRange that) {
-        return this.reverse == that.reverse
-                && DefaultTypeTransformation.compareEqual(this.from, that.from)
-                && DefaultTypeTransformation.compareEqual(this.to, that.to);
-    }
-
-    public boolean equals(List that) {
-        int size = size();
-        if (that.size() == size) {
-            for (int i = 0; i < size; i++) {
-                if (!DefaultTypeTransformation.compareEqual(get(i), that.get(i))) {
-                    return false;
-                }
-            }
-            return true;
-        }
-        return false;
+        return that != null
+                && this.reverse == that.reverse
+                && this.from.equals(that.from)
+                && this.to.equals(that.to);
     }
 
+    /**
+     * {@inheritDoc}
+     */
     public Comparable getFrom() {
         return from;
     }
 
+    /**
+     * {@inheritDoc}
+     */
     public Comparable getTo() {
         return to;
     }
 
+    /**
+     * {@inheritDoc}
+     */
     public boolean isReverse() {
         return reverse;
     }
 
+    /**
+     * {@inheritDoc}
+     */
     public Object get(int index) {
         if (index < 0) {
             throw new IndexOutOfBoundsException("Index: " + index + " should not be negative");
@@ -173,7 +200,7 @@ public class ObjectRange extends AbstractList implements Range {
         if (index >= size()) {
             throw new IndexOutOfBoundsException("Index: " + index + " is too big for range: " + this);
         }
-        Object value;
+        Object value = null;
         if (reverse) {
             value = to;
 
@@ -189,10 +216,13 @@ public class ObjectRange extends AbstractList implements Range {
         return value;
     }
 
+    /**
+     * {@inheritDoc}
+     */
     public Iterator iterator() {
         return new Iterator() {
-            private int index;
-            private Object value = reverse ? to : from;
+            int index = 0;
+            Object value = (reverse) ? to : from;
 
             public boolean hasNext() {
                 return index < size();
@@ -219,23 +249,48 @@ public class ObjectRange extends AbstractList implements Range {
         };
     }
 
+    /**
+     * Checks whether a value is between the from and to values of a Range
+     *
+     * @param value the value of interest
+     * @return true if the value is within the bounds
+     */
+    public boolean containsWithinBounds(Object value) {
+        if (value instanceof Comparable) {
+            int result = from.compareTo(value);
+            return result == 0 || result < 0 && to.compareTo(value) >= 0;
+        }
+        return contains(value);
+    }
+
+
+    /**
+     * {@inheritDoc}
+     */
     public int size() {
         if (size == -1) {
-            if (from instanceof Integer && to instanceof Integer) {
-                // fast calculate the size
+            if (from instanceof Integer && to instanceof Integer
+                    || from instanceof Long && to instanceof Long) {
+                // let's fast calculate the size
                 size = 0;
-                int fromNum = ((Integer) from).intValue();
-                int toNum = ((Integer) to).intValue();
+                int fromNum = ((Number) from).intValue();
+                int toNum = ((Number) to).intValue();
+                size = toNum - fromNum + 1;
+            } else if (from instanceof Character && to instanceof Character) {
+                // let's fast calculate the size
+                size = 0;
+                char fromNum = ((Character) from).charValue();
+                char toNum = ((Character) to).charValue();
                 size = toNum - fromNum + 1;
             } else if (from instanceof BigDecimal || to instanceof BigDecimal) {
-                // fast calculate the size
+                // let's fast calculate the size
                 size = 0;
                 BigDecimal fromNum = new BigDecimal("" + from);
                 BigDecimal toNum = new BigDecimal("" + to);
                 BigInteger sizeNum = toNum.subtract(fromNum).add(new BigDecimal(1.0)).toBigInteger();
                 size = sizeNum.intValue();
             } else {
-                // lazily calculate the size
+                // let's lazily calculate the size
                 size = 0;
                 Object value = from;
                 while (to.compareTo(value) >= 0) {
@@ -247,47 +302,45 @@ public class ObjectRange extends AbstractList implements Range {
         return size;
     }
 
+    /**
+     * {@inheritDoc}
+     */
     public List subList(int fromIndex, int toIndex) {
         if (fromIndex < 0) {
             throw new IndexOutOfBoundsException("fromIndex = " + fromIndex);
         }
-        int size = size();
-        if (toIndex > size) {
+        if (toIndex > size()) {
             throw new IndexOutOfBoundsException("toIndex = " + toIndex);
         }
         if (fromIndex > toIndex) {
             throw new IllegalArgumentException("fromIndex(" + fromIndex + ") > toIndex(" + toIndex + ")");
         }
-        if (--toIndex >= size) {
-            return new ObjectRange((Comparable) get(fromIndex), getTo(), reverse);
-        } else {
-            return new ObjectRange((Comparable) get(fromIndex), (Comparable) get(toIndex), reverse);
+        if (fromIndex == toIndex) {
+            return new EmptyRange(from);
         }
+
+        return new ObjectRange((Comparable) get(fromIndex), (Comparable) get(--toIndex), reverse);
     }
 
+    /**
+     * {@inheritDoc}
+     */
     public String toString() {
-        return reverse ? "" + to + ".." + from : "" + from + ".." + to;
+        return (reverse) ? "" + to + ".." + from : "" + from + ".." + to;
     }
 
+    /**
+     * {@inheritDoc}
+     */
     public String inspect() {
         String toText = InvokerHelper.inspect(to);
         String fromText = InvokerHelper.inspect(from);
-        return reverse ? "" + toText + ".." + fromText : "" + fromText + ".." + toText;
-    }
-
-    public boolean contains(Object value) {
-        if (value instanceof Comparable) {
-            return contains((Comparable) value);
-        } else {
-            return super.contains(value);
-        }
-    }
-
-    public boolean contains(Comparable value) {
-        int result = from.compareTo(value);
-        return result == 0 || result < 0 && to.compareTo(value) >= 0;
+        return (reverse) ? "" + toText + ".." + fromText : "" + fromText + ".." + toText;
     }
 
+    /**
+     * {@inheritDoc}
+     */
     public void step(int step, Closure closure) {
         if (reverse) {
             step = -step;
@@ -312,16 +365,31 @@ public class ObjectRange extends AbstractList implements Range {
         }
     }
 
+    /**
+     * {@inheritDoc}
+     */
     public List step(int step) {
         IteratorClosureAdapter adapter = new IteratorClosureAdapter(this);
         step(step, adapter);
         return adapter.asList();
     }
 
+    /**
+     * Increments by one
+     *
+     * @param value the value to increment
+     * @return the incremented value
+     */
     protected Object increment(Object value) {
         return InvokerHelper.invokeMethod(value, "next", null);
     }
 
+    /**
+     * Decrements by one
+     *
+     * @param value the value to decrement
+     * @return the decremented value
+     */
     protected Object decrement(Object value) {
         return InvokerHelper.invokeMethod(value, "previous", null);
     }
diff --git a/src/main/groovy/lang/Range.java b/src/main/groovy/lang/Range.java
index c754a76b0e..74bb092c93 100644
--- a/src/main/groovy/lang/Range.java
+++ b/src/main/groovy/lang/Range.java
@@ -50,32 +50,63 @@ import java.util.List;
 /**
  * Represents the interface of a Range implementation which includes the
  * from and to values.
- * 
+ *
  * @author <a href="mailto:james@coredevelopers.net">James Strachan</a>
  * @version $Revision$
  */
 public interface Range extends List {
-
-    
     /**
-     * @return the lower value in the range
+     * Gets the lower value in the range.
+     *
+     * @return the lower value in the range.
      */
     Comparable getFrom();
 
     /**
+     * Gets the lower value in the range.
+     *
      * @return the upper value in the range
      */
     Comparable getTo();
 
     /**
-     * @return true if this is a reverse range, iterating backwards
+     * Indicates whether this is a reverse range which iterates backwards
      * starting from the to value and ending on the from value
+     *
+     * @return <code>true</code> if this is a reverse range
      */
     boolean isReverse();
 
     /**
-     * @return the verbose String representation of this Range as would be typed into a console
-     * to create the Range instance
+     * Indicates whether this is a reverse range which iterates backwards
+     * starting from the to value and ending on the from value
+     *
+     * @return <code>true</code> if the object is between the from and to values
+     */
+    boolean containsWithinBounds(Object o);
+
+    /**
+     * Steps through the range, calling a closure for each number.
+     *
+     * @param step    the amount by which to step. If negative, steps through the
+     *                range backwards.
+     * @param closure the {@link Closure} to call
+     */
+    public void step(int step, Closure closure);
+
+    /**
+     * Forms a list by stepping through the range by the indicated interval.
+     *
+     * @param step the amount by which to step. If negative, steps through the
+     *             range backwards.
+     * @return the list formed by stepping through the range by the indicated
+     *         interval.
+     */
+    public List step(int step);
+
+    /**
+     * @return the verbose {@link String} representation of this {@link Range} as would be typed into a console
+     *         to create the {@link Range} instance
      */
     String inspect();
 }
diff --git a/src/test/JavaSourceGroovyPackagesNonSecuritySuite.java b/src/test/JavaSourceGroovyPackagesNonSecuritySuite.java
index f8b1ecee8a..fb1422572e 100644
--- a/src/test/JavaSourceGroovyPackagesNonSecuritySuite.java
+++ b/src/test/JavaSourceGroovyPackagesNonSecuritySuite.java
@@ -1,7 +1,5 @@
 import groovy.inspect.InspectorTest;
 import groovy.lang.*;
-import groovy.security.SecurityTest;
-import groovy.security.SignedJarTest;
 import groovy.servlet.GroovyServletTest;
 import groovy.text.TemplateTest;
 import groovy.text.XmlTemplateEngineTest;
@@ -26,7 +24,6 @@ public class JavaSourceGroovyPackagesNonSecuritySuite {
         suite.addTestSuite(GStringTest.class);
         suite.addTestSuite(IntRangeTest.class);
         suite.addTestSuite(MetaClassTest.class);
-        suite.addTestSuite(RangeTest.class);
         suite.addTestSuite(ScriptIntegerDivideTest.class);
         suite.addTestSuite(ScriptPrintTest.class);
         suite.addTestSuite(ScriptTest.class);
@@ -40,6 +37,7 @@ public class JavaSourceGroovyPackagesNonSecuritySuite {
         suite.addTestSuite(MBeanTest.class);
         suite.addTestSuite(XmlTest.class);
         suite.addTestSuite(FactorySupportTest.class);
+        suite.addTest(new RangeTestSuite());
         return suite;
     }
 }
diff --git a/src/test/UberTestCaseGroovySourceSubPackages.java b/src/test/UberTestCaseGroovySourceSubPackages.java
index 1eb4d33730..e3e466cfd9 100644
--- a/src/test/UberTestCaseGroovySourceSubPackages.java
+++ b/src/test/UberTestCaseGroovySourceSubPackages.java
@@ -12,7 +12,7 @@ import junit.framework.TestCase;
 
 public class UberTestCaseGroovySourceSubPackages extends TestCase {
     public static Test suite() {
-        return AllTestSuite.suite("src/test", "groovy/**/*Test.groovy");
+        return AllTestSuite.suite("src/test", "groovy/*/**/*Test.groovy");
     }
 
 // no tests inside (should we have an AbstractGroovyTestCase???)
diff --git a/src/test/groovy/ListTest.groovy b/src/test/groovy/ListTest.groovy
index 9e6f27b2b2..1b8ecb75fd 100644
--- a/src/test/groovy/ListTest.groovy
+++ b/src/test/groovy/ListTest.groovy
@@ -373,10 +373,8 @@ class ListTest extends GroovyTestCase {
         list[-1..-1] = [-1]
         assert list == [0, 1, 2, -1]        , 'left of left border'
         list = [0,1,2,3]
-        shouldFail (IndexOutOfBoundsException.class) {
-            list[3..4] = [3,4]
-            assert list == [0, 1, 2, 3, 4]
-        }
+        list[3..4] = [3,4]
+        assert list == [0, 1, 2, 3, 4]
         // structural changes
         list = [0,1,2,3]
         list[1..2] = ['x']
diff --git a/src/test/groovy/lang/BigDecimalRangeTest.java b/src/test/groovy/lang/BigDecimalRangeTest.java
new file mode 100644
index 0000000000..6772b35b6d
--- /dev/null
+++ b/src/test/groovy/lang/BigDecimalRangeTest.java
@@ -0,0 +1,71 @@
+/*
+ $Id: BigDecimalRangeTest.java,v 1.1 2006/11/13 10:23:58 edwin Exp edwin $
+
+ Copyright 2003 (C) James Strachan and Bob Mcwhirter. All Rights Reserved.
+
+ Redistribution and use of this software and associated documentation
+ ("Software"), with or without modification, are permitted provided
+ that the following conditions are met:
+
+ 1. Redistributions of source code must retain copyright
+    statements and notices.  Redistributions must also contain a
+    copy of this document.
+
+ 2. Redistributions in binary form must reproduce the
+    above copyright notice, this list of conditions and the
+    following disclaimer in the documentation and/or other
+    materials provided with the distribution.
+
+ 3. The name "groovy" must not be used to endorse or promote
+    products derived from this Software without prior written
+    permission of The Codehaus.  For written permission,
+    please contact info@codehaus.org.
+
+ 4. Products derived from this Software may not be called "groovy"
+    nor may "groovy" appear in their names without prior written
+    permission of The Codehaus. "groovy" is a registered
+    trademark of The Codehaus.
+
+ 5. Due credit should be given to The Codehaus -
+    http://groovy.codehaus.org/
+
+ THIS SOFTWARE IS PROVIDED BY THE CODEHAUS AND CONTRIBUTORS
+ ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ THE CODEHAUS OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ OF THE POSSIBILITY OF SUCH DAMAGE.
+
+ */
+package groovy.lang;
+
+import java.math.BigDecimal;
+
+/**
+ * Tests {@link ObjectRange}s of {@link BigDecimal}s.
+ *
+ * @author Edwin Tellman
+ */
+public class BigDecimalRangeTest extends NumberRangeTest {
+
+    /**
+     * {@inheritDoc}
+     */
+    protected Range createRange(int from, int to) {
+        return new ObjectRange(new BigDecimal(from), new BigDecimal(to));
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    protected Comparable createValue(int value) {
+        return new BigDecimal(value);
+    }
+
+}
diff --git a/src/test/groovy/lang/CharacterRangeTest.java b/src/test/groovy/lang/CharacterRangeTest.java
new file mode 100644
index 0000000000..0722bf291b
--- /dev/null
+++ b/src/test/groovy/lang/CharacterRangeTest.java
@@ -0,0 +1,64 @@
+/**
+ *
+ */
+package groovy.lang;
+
+import junit.framework.TestCase;
+
+import java.util.Iterator;
+
+/**
+ * Provides a few unit tests for {@link ObjectRange}s of {@link Character}s.  More tests are needed.
+ *
+ * @author Edwin Tellman
+ */
+public class CharacterRangeTest extends TestCase {
+    /**
+     * The range to test.
+     */
+    private ObjectRange range = null;
+
+    /**
+     * The first character in the range.
+     */
+    private final Character FROM = new Character('a');
+
+    /**
+     * The last character in the range.
+     */
+    private final Character TO = new Character('d');
+
+    /**
+     * {@inheritDoc}
+     */
+    protected void setUp() throws Exception {
+        super.setUp();
+        range = new ObjectRange(FROM, TO);
+    }
+
+    /**
+     * Tests iterating through the range.
+     */
+    public void testIterate() {
+        Iterator iter = range.iterator();
+        assertEquals("wrong first value", FROM, iter.next());
+        for (int expected = FROM.charValue() + 1; expected <= TO.charValue(); expected++) {
+            assertEquals("wrong value", new Integer(expected), iter.next());
+        }
+    }
+
+    /**
+     * Tests getting the 'from' value.
+     */
+    public void testGetFrom() {
+        assertEquals("wrong 'from' value", FROM, range.getFrom());
+    }
+
+    /**
+     * Tests getting the 'to' value.
+     */
+    public void testGetTo() {
+        assertEquals("wrong 'to' value", TO, range.getTo());
+    }
+
+}
diff --git a/src/test/groovy/lang/EmptyRangeTest.java b/src/test/groovy/lang/EmptyRangeTest.java
new file mode 100644
index 0000000000..0ee010b510
--- /dev/null
+++ b/src/test/groovy/lang/EmptyRangeTest.java
@@ -0,0 +1,390 @@
+/**
+ *
+ */
+package groovy.lang;
+
+import groovy.util.GroovyTestCase;
+
+import java.util.*;
+
+/**
+ * Provides unit tests for the {@link EmptyRange} class.
+ *
+ * @author Edwin Tellman
+ */
+public class EmptyRangeTest extends GroovyTestCase {
+
+    /**
+     * The 'from' value for the {@link Range}.
+     */
+    private static final Integer AT = new Integer(17);
+
+    /**
+     * The {@link Range} to test.
+     */
+    private Range range = null;
+
+    /**
+     * {@inheritDoc}
+     */
+    protected void setUp() throws Exception {
+        super.setUp();
+
+        range = new EmptyRange(AT);
+    }
+
+    /**
+     * Test method for {@link groovy.lang.EmptyRange#getFrom()}.
+     */
+    public void testGetFrom() {
+        assertEquals("wrong 'from' value", AT, range.getFrom());
+    }
+
+    /**
+     * Test method for {@link groovy.lang.EmptyRange#getTo()}.
+     */
+    public void testGetTo() {
+        assertEquals("wrong 'from' value", AT, range.getTo());
+    }
+
+    /**
+     * Test method for {@link groovy.lang.EmptyRange#isReverse()}.
+     */
+    public void testIsReverse() {
+        assertFalse("empty range reversed", range.isReverse());
+    }
+
+    /**
+     * Test method for {@link groovy.lang.EmptyRange#inspect()}.
+     */
+    public void testInspect() {
+        assertEquals("wrong 'inspect' value", AT + "..<" + AT, range.inspect());
+    }
+
+    /**
+     * Test method for {@link groovy.lang.EmptyRange#inspect()()} with a range with a <code>null</code> 'at' value.
+     */
+    public void testInspectNullAt() {
+        final Range nullAtRange = new EmptyRange(null);
+        assertEquals("wrong inspect value", "null..<null", nullAtRange.inspect());
+    }
+
+    /**
+     * Test method for {@link groovy.lang.EmptyRange#toString()}.
+     */
+    public void testToString() {
+        assertEquals("wrong string value", AT + "..<" + AT, range.toString());
+    }
+
+    /**
+     * Test method for {@link groovy.lang.EmptyRange#toString()} with a range with a <code>null</code> 'at' value.
+     */
+    public void testToStringNullAt() {
+        final Range nullAtRange = new EmptyRange(null);
+        assertEquals("wrong string value", "null..<null", nullAtRange.toString());
+    }
+
+    /**
+     * Test method for {@link groovy.lang.EmptyRange#size()}.
+     */
+    public void testSize() {
+        assertEquals("wrong size", 0, range.size());
+    }
+
+    /**
+     * Test method for {@link groovy.lang.EmptyRange#clear()}.
+     */
+    public void testClear() {
+        range.clear();
+    }
+
+    /**
+     * Test method for {@link groovy.lang.EmptyRange#isEmpty()}.
+     */
+    public void testIsEmpty() {
+        assertTrue("range not empty", range.isEmpty());
+    }
+
+    /**
+     * Test method for {@link groovy.lang.EmptyRange#toArray()}.
+     */
+    public void testToArray() {
+        assertArrayEquals(new Object[0], range.toArray());
+    }
+
+    /**
+     * Test method for {@link groovy.lang.EmptyRange#get(int)}.
+     */
+    public void testGet() {
+        try {
+            range.get(0);
+            fail("got value from empty range");
+        }
+        catch (IndexOutOfBoundsException e) {
+            assertTrue("expected exception thrown", true);
+        }
+    }
+
+    /**
+     * Test method for {@link groovy.lang.EmptyRange#remove(int)}.
+     */
+    public void testRemoveInt() {
+        try {
+            range.remove(0);
+            fail("removed value from empty range");
+        }
+        catch (UnsupportedOperationException e) {
+            assertTrue("expected exception thrown", true);
+        }
+    }
+
+    /**
+     * Test method for {@link groovy.lang.EmptyRange#add(int,java.lang.Object)}.
+     */
+    public void testAddIntObject() {
+        try {
+            range.add(0, new Integer(12));
+            fail("added value to empty range");
+        }
+        catch (UnsupportedOperationException e) {
+            assertTrue("expected exception thrown", true);
+        }
+    }
+
+    /**
+     * Test method for {@link groovy.lang.EmptyRange#indexOf(java.lang.Object)}.
+     */
+    public void testIndexOf() {
+        assertEquals("found value in empty range", -1, range.indexOf(AT));
+        assertEquals("found null in empty range", -1, range.indexOf(null));
+        assertEquals("found string in empty range", -1, range.indexOf("hello"));
+    }
+
+    /**
+     * Test method for {@link groovy.lang.EmptyRange#lastIndexOf(java.lang.Object)}.
+     */
+    public void testLastIndexOf() {
+        assertEquals("found value in empty range", -1, range.lastIndexOf(AT));
+        assertEquals("found null in empty range", -1, range.lastIndexOf(null));
+        assertEquals("found string in empty range", -1, range.lastIndexOf("hello"));
+    }
+
+    /**
+     * Test method for {@link groovy.lang.EmptyRange#add(java.lang.Object)}.
+     */
+    public void testAddObject() {
+        try {
+            range.add(new Integer(12));
+            fail("added value to empty range");
+        }
+        catch (UnsupportedOperationException e) {
+            assertTrue("expected exception thrown", true);
+        }
+    }
+
+    /**
+     * Test method for {@link groovy.lang.EmptyRange#contains(java.lang.Object)}.
+     */
+    public void testContains() {
+        assertFalse("empty range contains a value", range.contains(AT));
+    }
+
+    /**
+     * Test method for {@link groovy.lang.EmptyRange#remove(java.lang.Object)}.
+     */
+    public void testRemoveObject() {
+        try {
+            range.remove(AT);
+            fail("removed value from empty range");
+        }
+        catch (UnsupportedOperationException e) {
+            assertTrue("expected exception thrown", true);
+        }
+    }
+
+    /**
+     * Test method for {@link groovy.lang.EmptyRange#addAll(int,java.util.Collection)}.
+     */
+    public void testAddAllIntCollection() {
+        try {
+            range.addAll(0, new ArrayList());
+            fail("added values to empty range");
+        }
+        catch (UnsupportedOperationException e) {
+            assertTrue("expected exception thrown", true);
+        }
+    }
+
+    /**
+     * Test method for {@link groovy.lang.EmptyRange#addAll(java.util.Collection)}.
+     */
+    public void testAddAllCollection() {
+        try {
+            range.addAll(new ArrayList());
+            fail("added values to empty range");
+        }
+        catch (UnsupportedOperationException e) {
+            assertTrue("expected exception thrown", true);
+        }
+    }
+
+    /**
+     * Test method for {@link groovy.lang.EmptyRange#containsAll(java.util.Collection)}.
+     */
+    public void testContainsAll() {
+        final List list = new ArrayList();
+        assertTrue("range contains all elements of an empty list", range.containsAll(list));
+
+        list.add(AT);
+        assertFalse("range contains all elements of single element list", range.containsAll(list));
+    }
+
+    /**
+     * Test method for {@link groovy.lang.EmptyRange#removeAll(java.util.Collection)}.
+     */
+    public void testRemoveAll() {
+        try {
+            range.removeAll(new ArrayList());
+            fail("removed values from an empty range");
+        }
+        catch (UnsupportedOperationException e) {
+            assertTrue("expected exception thrown", true);
+        }
+    }
+
+    /**
+     * Test method for {@link groovy.lang.EmptyRange#retainAll(java.util.Collection)}.
+     */
+    public void testRetainAll() {
+        try {
+            range.retainAll(new ArrayList());
+            fail("retained values in an empty range");
+        }
+        catch (UnsupportedOperationException e) {
+            assertTrue("expected exception thrown", true);
+        }
+    }
+
+    /**
+     * Test method for {@link groovy.lang.EmptyRange#iterator()}.
+     */
+    public void testIterator() {
+        final Iterator iterator = range.iterator();
+        assertFalse("iterator has next value", iterator.hasNext());
+
+        try {
+            iterator.next();
+            fail("got next value in an empty range");
+        }
+        catch (NoSuchElementException e) {
+            assertTrue("expected exception thrown", true);
+        }
+    }
+
+    /**
+     * Tests removing via an iterator.
+     */
+    public void testIteratorRemove() {
+        try {
+            final Iterator iterator = range.iterator();
+            iterator.remove();
+            fail("removed via iterator");
+        }
+        catch (IllegalStateException e) {
+            assertTrue("expected exception thrown", true);
+        }
+    }
+
+    /**
+     * Test method for {@link groovy.lang.EmptyRange#subList(int,int)}.
+     */
+    public void testSubList() {
+        final List list = range.subList(0, 0);
+        assertTrue("list not empty", list.isEmpty());
+        try {
+            range.subList(0, 1);
+            fail("got sub list in an empty range");
+        }
+        catch (IndexOutOfBoundsException e) {
+            assertTrue("expected exception thrown", true);
+        }
+    }
+
+    /**
+     * Test method for {@link groovy.lang.EmptyRange#listIterator()}.
+     */
+    public void testListIterator() {
+        final ListIterator iterator = range.listIterator();
+        assertFalse("iterator has next value", iterator.hasNext());
+        assertFalse("iterator has previous value", iterator.hasPrevious());
+
+        try {
+            iterator.next();
+            fail("got next value in an empty range");
+        }
+        catch (NoSuchElementException e) {
+            assertTrue("expected exception thrown", true);
+        }
+    }
+
+    /**
+     * Test method for {@link groovy.lang.EmptyRange#listIterator(int)}.
+     */
+    public void testListIteratorInt() {
+        final ListIterator iterator = range.listIterator(0);
+        assertFalse("iterator has next value", iterator.hasNext());
+        assertFalse("iterator has previous value", iterator.hasPrevious());
+
+        try {
+            range.listIterator(1);
+            fail("got list iterator at index 1");
+        }
+        catch (IndexOutOfBoundsException e) {
+            assertTrue("expected exception thrown", true);
+        }
+    }
+
+    /**
+     * Test method for {@link groovy.lang.EmptyRange#set(int,java.lang.Object)}.
+     */
+    public void testSet() {
+        try {
+            range.set(0, AT);
+            fail("got set value 0");
+        }
+        catch (UnsupportedOperationException e) {
+            assertTrue("expected exception thrown", true);
+        }
+    }
+
+    /**
+     * Test method for {@link groovy.lang.EmptyRange#toArray(java.lang.Object[])}.
+     */
+    public void testToArrayObjectArray() {
+        final Integer[] actual = (Integer[]) range.toArray(new Integer[0]);
+        assertArrayEquals(new Integer[0], actual);
+    }
+
+    /**
+     * Test method for {@link groovy.lang.EmptyRange#step(int,groovy.lang.Closure)}.
+     */
+    public void testStepIntClosure() {
+        final List callLog = new ArrayList();
+        final Closure closure = new NumberRangeTest.RecordingClosure(callLog);
+        range.step(1, closure);
+        assertEquals("wrong number of calls to closure", 0, callLog.size());
+    }
+
+    /**
+     * Test method for {@link groovy.lang.EmptyRange#step(int)}.
+     */
+    public void testStepInt() {
+        List result = range.step(1);
+        assertTrue("too many elements", result.isEmpty());
+
+        // make sure a new list is returned each time
+        result.add(new Integer(1));
+        result = range.step(1);
+        assertTrue("too many elements", result.isEmpty());
+    }
+}
diff --git a/src/test/groovy/lang/FloatRangeTest.java b/src/test/groovy/lang/FloatRangeTest.java
new file mode 100644
index 0000000000..0eb73e2140
--- /dev/null
+++ b/src/test/groovy/lang/FloatRangeTest.java
@@ -0,0 +1,69 @@
+/*
+ $Id: FloatRangeTest.java,v 1.1 2006/11/13 10:23:58 edwin Exp edwin $
+
+ Copyright 2003 (C) James Strachan and Bob Mcwhirter. All Rights Reserved.
+
+ Redistribution and use of this software and associated documentation
+ ("Software"), with or without modification, are permitted provided
+ that the following conditions are met:
+
+ 1. Redistributions of source code must retain copyright
+    statements and notices.  Redistributions must also contain a
+    copy of this document.
+
+ 2. Redistributions in binary form must reproduce the
+    above copyright notice, this list of conditions and the
+    following disclaimer in the documentation and/or other
+    materials provided with the distribution.
+
+ 3. The name "groovy" must not be used to endorse or promote
+    products derived from this Software without prior written
+    permission of The Codehaus.  For written permission,
+    please contact info@codehaus.org.
+
+ 4. Products derived from this Software may not be called "groovy"
+    nor may "groovy" appear in their names without prior written
+    permission of The Codehaus. "groovy" is a registered
+    trademark of The Codehaus.
+
+ 5. Due credit should be given to The Codehaus -
+    http://groovy.codehaus.org/
+
+ THIS SOFTWARE IS PROVIDED BY THE CODEHAUS AND CONTRIBUTORS
+ ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ THE CODEHAUS OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ OF THE POSSIBILITY OF SUCH DAMAGE.
+
+ */
+package groovy.lang;
+
+/**
+ * Tests {@link ObjectRange}s of {@link Float}s.
+ *
+ * @author Edwin Tellman
+ */
+public class FloatRangeTest extends NumberRangeTest {
+
+    /**
+     * {@inheritDoc}
+     */
+    protected Range createRange(int from, int to) {
+        return new ObjectRange(new Float(from), new Float(to));
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    protected Comparable createValue(int value) {
+        return new Double(value);
+    }
+
+}
diff --git a/src/test/groovy/lang/IntRangeTest.java b/src/test/groovy/lang/IntRangeTest.java
index d7aa724518..2e3fdaa80d 100644
--- a/src/test/groovy/lang/IntRangeTest.java
+++ b/src/test/groovy/lang/IntRangeTest.java
@@ -45,119 +45,58 @@
  */
 package groovy.lang;
 
-import junit.framework.TestCase;
-
-import java.math.BigInteger;
-import java.util.List;
-
 /**
+ * Provides unit tests for the <code>IntRange</code> class.
+ *
  * @author James Strachan
  * @version $Revision$
  */
-public class IntRangeTest extends TestCase {
-
-    public void testSize() {
-        IntRange r = createRange(0, 10);
-        assertEquals("Size of " + r, 11, r.size());
-        r = createRange(0, 1);
-        assertEquals("Size of " + r, 2, r.size());
-        r = createRange(0, 0);
-        assertEquals("Size of " + r, 1, r.size());
-    }
-
-    public void testProperties() {
-        IntRange r = createRange(0, 10);
-        assertEquals("from", 0, r.getFromInt());
-        assertEquals("to", 10, r.getToInt());
-    }
-
-    public void testGet() {
-        IntRange r = createRange(10, 20);
-        for (int i = 0; i <= 10; i++) {
-            Integer value = (Integer) r.get(i);
-            assertEquals("Item at index: " + i, i + 10, value.intValue());
-        }
-    }
-
-    public void testGetOutOfRange() {
-        IntRange r = createRange(10, 20);
+public class IntRangeTest extends NumberRangeTest {
 
+    public void testCreateTooBigRange() {
         try {
-            r.get(-1);
-            fail("Should have thrown IndexOut");
+            createRange(0, Integer.MAX_VALUE);
+            fail("too large range accepted");
         }
-        catch (IndexOutOfBoundsException e) {
-            // worked
+        catch (IllegalArgumentException e) {
+            assertTrue("expected exception thrown", true);
         }
+    }
+
+    /**
+     * Tests providing invalid arguments to the protected constructor.
+     */
+    public void testInvalidArgumentsToConstructor() {
         try {
-            r.get(11);
-            fail("Should have thrown IndexOut");
+            new IntRange(2, 1, true);
+            fail("invalid range created");
         }
-        catch (IndexOutOfBoundsException e) {
-            // worked
+        catch (IllegalArgumentException e) {
+            assertTrue("expected exception thrown", true);
         }
-
-    }
-
-    public void testContains() {
-        IntRange r = createRange(10, 20);
-        checkContains(r, 11, true);
-        checkContains(r, 10, true);
-        checkContains(r, 19, true);
-        checkContains(r, 20, true);
-        checkContains(r, 9, false);
-        checkContains(r, 21, false);
-        checkContains(r, 100, false);
-        checkContains(r, -1, false);
-    }
-
-    private void checkContains(IntRange r, int i, boolean expected) {
-        checkIntegerContains(r, i, expected);
-        checkBigIntegerContains(r, i, expected);
-    }
-
-    private void checkIntegerContains(IntRange r, int i, boolean expected) {
-        assertEquals("contains Integer " + i, expected, r.contains(new Integer(i)));
-    }
-
-    private void checkBigIntegerContains(IntRange r, int i, boolean expected) {
-        assertEquals("contains BigInteger " + i, expected, r.contains(BigInteger.valueOf(i)));
-    }
-
-    public void testSubList() {
-        IntRange r = createRange(10, 20);
-
-        List s = r.subList(2, 4);
-
-        IntRange sr = (IntRange) s;
-
-        assertEquals("from", 12, sr.getFromInt());
-        assertEquals("to", 13, sr.getToInt());
-        assertEquals("size", 2, sr.size());
     }
 
-    public void testHashCodeAndEquals() {
-        IntRange a = createRange(1, 11);
-        IntRange b = createRange(1, 11);
-        IntRange c = createRange(2, 11);
-
-        assertEquals("hashcode", a.hashCode(), b.hashCode());
-        assertTrue("hashcode", a.hashCode() != c.hashCode());
-
-        assertEquals("a and b", a, b);
-        assertFalse("a != c", a.equals(c));
+    /**
+     * Tests getting the to and from values as <code>int</code>s.
+     */
+    public void testGetToFromInt() {
+        final int from = 3, to = 7;
+        final IntRange range = new IntRange(from, to);
+        assertEquals("wrong 'from'", from, range.getFromInt());
+        assertEquals("wrong 'to'", to, range.getToInt());
     }
 
-    public void testIterator() {
+    /**
+     * {@inheritDoc}
+     */
+    protected Comparable createValue(int value) {
+        return new Integer(value);
     }
 
-    protected IntRange createRange(int from, int to) {
+    /**
+     * {@inheritDoc}
+     */
+    protected Range createRange(int from, int to) {
         return new IntRange(from, to);
     }
-
-    protected void assertEquals(String msg, int expected, Object value) {
-        assertEquals(msg, new Integer(expected), value);
-    }
-
-
 }
diff --git a/src/test/groovy/lang/IntegerRangeTest.java b/src/test/groovy/lang/IntegerRangeTest.java
new file mode 100644
index 0000000000..6b453b12ca
--- /dev/null
+++ b/src/test/groovy/lang/IntegerRangeTest.java
@@ -0,0 +1,70 @@
+/*
+ $Id: IntegerRangeTest.java,v 1.1 2006/11/13 10:23:58 edwin Exp edwin $
+
+ Copyright 2003 (C) James Strachan and Bob Mcwhirter. All Rights Reserved.
+
+ Redistribution and use of this software and associated documentation
+ ("Software"), with or without modification, are permitted provided
+ that the following conditions are met:
+
+ 1. Redistributions of source code must retain copyright
+    statements and notices.  Redistributions must also contain a
+    copy of this document.
+
+ 2. Redistributions in binary form must reproduce the
+    above copyright notice, this list of conditions and the
+    following disclaimer in the documentation and/or other
+    materials provided with the distribution.
+
+ 3. The name "groovy" must not be used to endorse or promote
+    products derived from this Software without prior written
+    permission of The Codehaus.  For written permission,
+    please contact info@codehaus.org.
+
+ 4. Products derived from this Software may not be called "groovy"
+    nor may "groovy" appear in their names without prior written
+    permission of The Codehaus. "groovy" is a registered
+    trademark of The Codehaus.
+
+ 5. Due credit should be given to The Codehaus -
+    http://groovy.codehaus.org/
+
+ THIS SOFTWARE IS PROVIDED BY THE CODEHAUS AND CONTRIBUTORS
+ ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ THE CODEHAUS OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ OF THE POSSIBILITY OF SUCH DAMAGE.
+
+ */
+package groovy.lang;
+
+
+/**
+ * Tests {@link ObjectRange}s of {@link Integer}s.
+ *
+ * @author Edwin Tellman
+ */
+public class IntegerRangeTest extends NumberRangeTest {
+
+    /**
+     * {@inheritDoc}
+     */
+    protected Range createRange(int from, int to) {
+        return new ObjectRange(new Integer(from), new Integer(to));
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    protected Comparable createValue(int value) {
+        return new Integer(value);
+    }
+
+}
diff --git a/src/test/groovy/lang/LongRangeTest.java b/src/test/groovy/lang/LongRangeTest.java
new file mode 100644
index 0000000000..e8e73c6aa7
--- /dev/null
+++ b/src/test/groovy/lang/LongRangeTest.java
@@ -0,0 +1,70 @@
+/*
+ $Id: LongRangeTest.java,v 1.1 2006/11/13 10:23:58 edwin Exp edwin $
+
+ Copyright 2003 (C) James Strachan and Bob Mcwhirter. All Rights Reserved.
+
+ Redistribution and use of this software and associated documentation
+ ("Software"), with or without modification, are permitted provided
+ that the following conditions are met:
+
+ 1. Redistributions of source code must retain copyright
+    statements and notices.  Redistributions must also contain a
+    copy of this document.
+
+ 2. Redistributions in binary form must reproduce the
+    above copyright notice, this list of conditions and the
+    following disclaimer in the documentation and/or other
+    materials provided with the distribution.
+
+ 3. The name "groovy" must not be used to endorse or promote
+    products derived from this Software without prior written
+    permission of The Codehaus.  For written permission,
+    please contact info@codehaus.org.
+
+ 4. Products derived from this Software may not be called "groovy"
+    nor may "groovy" appear in their names without prior written
+    permission of The Codehaus. "groovy" is a registered
+    trademark of The Codehaus.
+
+ 5. Due credit should be given to The Codehaus -
+    http://groovy.codehaus.org/
+
+ THIS SOFTWARE IS PROVIDED BY THE CODEHAUS AND CONTRIBUTORS
+ ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ THE CODEHAUS OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ OF THE POSSIBILITY OF SUCH DAMAGE.
+
+ */
+package groovy.lang;
+
+
+/**
+ * Tests {@link ObjectRange}s of {@link Long}s.
+ *
+ * @author Edwin Tellman
+ */
+public class LongRangeTest extends NumberRangeTest {
+
+    /**
+     * {@inheritDoc}
+     */
+    protected Range createRange(int from, int to) {
+        return new ObjectRange(new Long(from), new Long(to));
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    protected Comparable createValue(int value) {
+        return new Long(value);
+    }
+
+}
diff --git a/src/test/groovy/lang/NumberRangeTest.java b/src/test/groovy/lang/NumberRangeTest.java
new file mode 100644
index 0000000000..35f67469a6
--- /dev/null
+++ b/src/test/groovy/lang/NumberRangeTest.java
@@ -0,0 +1,760 @@
+/*
+ $Id: NumberRangeTest.java,v 1.2 2006/11/13 10:23:58 edwin Exp edwin $
+
+ Copyright 2003 (C) James Strachan and Bob Mcwhirter. All Rights Reserved.
+
+ Redistribution and use of this software and associated documentation
+ ("Software"), with or without modification, are permitted provided
+ that the following conditions are met:
+
+ 1. Redistributions of source code must retain copyright
+    statements and notices.  Redistributions must also contain a
+    copy of this document.
+
+ 2. Redistributions in binary form must reproduce the
+    above copyright notice, this list of conditions and the
+    following disclaimer in the documentation and/or other
+    materials provided with the distribution.
+
+ 3. The name "groovy" must not be used to endorse or promote
+    products derived from this Software without prior written
+    permission of The Codehaus.  For written permission,
+    please contact info@codehaus.org.
+
+ 4. Products derived from this Software may not be called "groovy"
+    nor may "groovy" appear in their names without prior written
+    permission of The Codehaus. "groovy" is a registered
+    trademark of The Codehaus.
+
+ 5. Due credit should be given to The Codehaus -
+    http://groovy.codehaus.org/
+
+ THIS SOFTWARE IS PROVIDED BY THE CODEHAUS AND CONTRIBUTORS
+ ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ THE CODEHAUS OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ OF THE POSSIBILITY OF SUCH DAMAGE.
+
+ */
+package groovy.lang;
+
+import junit.framework.TestCase;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+
+/**
+ * Provides unit tests for ranges of numbers.
+ *
+ * @author Edwin Tellman
+ */
+public abstract class NumberRangeTest extends TestCase {
+
+    /**
+     * Records the values passed to a closure.
+     */
+    protected static class RecordingClosure extends Closure {
+        /**
+         * Holds the values passed in
+         */
+        final List callLog;
+
+        /**
+         * Creates a new <code>RecordingClosure</code>
+         *
+         * @param callLog is filled with the values passed to <code>doCall</code>
+         */
+        RecordingClosure(final List callLog) {
+            super(null);
+            this.callLog = callLog;
+        }
+
+        /**
+         * Stores <code>params</code> in the <code>callLog</code>.
+         *
+         * @param params the parameters.
+         * @return null
+         */
+        public Object doCall(final Object params) {
+            callLog.add(params);
+            return null;
+        }
+    }
+
+    /**
+     * Creates a {@link Range} to test.
+     *
+     * @param from the first value in the range.
+     * @param to   the last value in the range.
+     * @return a {@link Range} to test
+     */
+    protected abstract Range createRange(final int from, final int to);
+
+    /**
+     * Creates a value in the range.
+     *
+     * @param value the value to create.
+     * @return a value in the range.
+     */
+    protected abstract Comparable createValue(final int value);
+
+    /**
+     * Tests <code>hashCode</code> and <code>equals</code> comparing one {@link IntRange} to another {@link IntRange}.
+     */
+    public final void testHashCodeAndEquals() {
+        Range a = createRange(1, 11);
+        Range b = createRange(1, 11);
+        Range c = createRange(2, 11);
+
+        assertEquals("hashcode", a.hashCode(), b.hashCode());
+        assertTrue("hashcode", a.hashCode() != c.hashCode());
+
+        assertEquals("a and b", a, b);
+        assertFalse("a != c", a.equals(c));
+    }
+
+    /**
+     * Tests using different classes for 'from' and 'to'.
+     */
+    public void testDifferentClassesForFromAndTo() {
+        final Integer from = new Integer(1);
+        final Comparable to = createValue(5);
+        final Range range = new ObjectRange(from, to);
+
+        assertEquals("wrong 'from' value", from, range.getFrom());
+        assertEquals("wrong 'to' value", to, range.getTo());
+    }
+
+    /**
+     * Tests a <code>null</code> 'from' value.
+     */
+    public void testNullFrom() {
+        try {
+            new ObjectRange(null, createValue(5));
+            fail("null 'from' accepted");
+        }
+        catch (IllegalArgumentException e) {
+            assertTrue("expected exception thrown", true);
+        }
+    }
+
+    /**
+     * Tests a <code>null</code> 'to' value.
+     */
+    public void testNullTo() {
+        try {
+            new ObjectRange(createValue(23), null);
+            fail("null 'to' accepted");
+        }
+        catch (IllegalArgumentException e) {
+            assertTrue("expected exception thrown", true);
+        }
+    }
+
+    /**
+     * Tests stepping through a range by two with a closure.
+     */
+    public void testStepByTwoWithClosure() {
+        final List callLog = new ArrayList();
+        final Closure closure = new RecordingClosure(callLog);
+
+        final Range range = createRange(0, 4);
+        range.step(2, closure);
+
+        assertEquals("wrong number of calls to closure", 3, callLog.size());
+        final Iterator iter = callLog.iterator();
+        for (int i = 0; i <= 4; i += 2) {
+            assertEquals("wrong argument passed to closure", createValue(i), iter.next());
+        }
+    }
+
+    /**
+     * Tests iterating over a one-element range.
+     */
+    public void testOneElementRange() {
+        final Range range = createRange(1, 1);
+        int next = 1;
+        for (Iterator iter = range.iterator(); iter.hasNext();) {
+            final Number number = (Number) iter.next();
+            assertEquals("wrong number", createValue(next++), number);
+        }
+        assertEquals("wrong number of elements in iteration", 2, next);
+    }
+
+    /**
+     * Tests stepping through a reversed range by two with a closure.
+     */
+    public void testReverseStepByTwoWithClosure() {
+        final List callLog = new ArrayList();
+        final Closure closure = new RecordingClosure(callLog);
+
+        final Range range = createRange(4, 0);
+        range.step(2, closure);
+
+        assertEquals("wrong number of calls to closure", 3, callLog.size());
+        final Iterator iter = callLog.iterator();
+        for (int i = 4; i >= 0; i -= 2) {
+            assertEquals("wrong argument passed to closure", createValue(i), iter.next());
+        }
+    }
+
+    /**
+     * Tests stepping through a range with a closure.
+     */
+    public void testStepByOneWithClosure() {
+        final List callLog = new ArrayList();
+        final Closure closure = new RecordingClosure(callLog);
+
+        final Range range = createRange(1, 5);
+        range.step(1, closure);
+
+        assertEquals("wrong number of calls to closure", 5, callLog.size());
+        final Iterator iter = callLog.iterator();
+        for (int i = 1; i <= 5; i++) {
+            assertEquals("wrong argument passed to closure", createValue(i), iter.next());
+        }
+    }
+
+    /**
+     * Tests stepping through a reversed range by one with a closure.
+     */
+    public void testReverseStepByOneWithClosure() {
+        final List callLog = new ArrayList();
+        final Closure closure = new RecordingClosure(callLog);
+
+        final Range range = createRange(5, 1);
+        range.step(1, closure);
+
+        assertEquals("wrong number of calls to closure", 5, callLog.size());
+        final Iterator iter = callLog.iterator();
+        for (int i = 5; i >= 1; i--) {
+            assertEquals("wrong argument passed to closure", createValue(i), iter.next());
+        }
+    }
+
+    /**
+     * Tests stepping backwards through a range with a closure.
+     */
+    public void testNegativeStepByOneWithClosure() {
+        final List callLog = new ArrayList();
+        final Closure closure = new RecordingClosure(callLog);
+
+        final Range range = createRange(1, 5);
+        range.step(-1, closure);
+
+        assertEquals("wrong number of calls to closure", 5, callLog.size());
+        final Iterator iter = callLog.iterator();
+        for (int i = 5; i >= 1; i--) {
+            assertEquals("wrong argument passed to closure", createValue(i), iter.next());
+        }
+    }
+
+    /**
+     * Tests stepping backwards through a reversed range with a closure.
+     */
+    public void testNegativeReverseStepByOneWithClosure() {
+        final List callLog = new ArrayList();
+        final Closure closure = new RecordingClosure(callLog);
+
+        final Range range = createRange(5, 1);
+        range.step(-1, closure);
+
+        assertEquals("wrong number of calls to closure", 5, callLog.size());
+        final Iterator iter = callLog.iterator();
+        for (int i = 1; i <= 5; i++) {
+            assertEquals("wrong argument passed to closure", createValue(i), iter.next());
+        }
+    }
+
+    /**
+     * Tests stepping backwards through a range with a step size greater than the range size.
+     */
+    public void testStepLargerThanRange() {
+        final List callLog = new ArrayList();
+        final Closure closure = new RecordingClosure(callLog);
+
+        final Range range = createRange(1, 5);
+
+        range.step(6, closure);
+        assertEquals("wrong number of calls to closure", 1, callLog.size());
+        assertEquals("wrong value", createValue(1), callLog.get(0));
+
+        final List stepList = range.step(6);
+        assertEquals("wrong number of values in result", 1, stepList.size());
+        assertEquals("wrong value", createValue(1), callLog.get(0));
+    }
+
+    /**
+     * Tests stepping through a range by one.
+     */
+    public void testStepByOne() {
+        final Range range = createRange(1, 5);
+        final List result = range.step(1);
+
+        assertEquals("wrong number of calls", 5, result.size());
+        final Iterator iter = result.iterator();
+        for (int i = 1; i <= 5; i++) {
+            assertEquals("incorrect value in result", createValue(i), iter.next());
+        }
+    }
+
+    /**
+     * Tests stepping through a range by two.
+     */
+    public void testStepByTwo() {
+        final Range range = createRange(1, 5);
+        final List result = range.step(2);
+
+        assertEquals("wrong number of calls", 3, result.size());
+        final Iterator iter = result.iterator();
+        for (int i = 1; i <= 5; i += 2) {
+            assertEquals("incorrect value in result", createValue(i), iter.next());
+        }
+    }
+
+    /**
+     * Tests getting the size.
+     */
+    public void testSize() {
+        Range range = createRange(0, 10);
+        assertEquals("Size of " + range, 11, range.size());
+        range = createRange(0, 1);
+        assertEquals("Size of " + range, 2, range.size());
+        range = createRange(0, 0);
+        assertEquals("Size of " + range, 1, range.size());
+    }
+
+    /**
+     * Tests asking for an index outside of the valid range
+     */
+    public void testGetOutOfRange() {
+        Range r = createRange(10, 20);
+
+        try {
+            r.get(-1);
+            fail("Should have thrown IndexOutOfBoundsException");
+        }
+        catch (IndexOutOfBoundsException e) {
+            assertTrue("expected exception thrown", true);
+        }
+        try {
+            r.get(11);
+            fail("Should have thrown IndexOutOfBoundsException");
+        }
+        catch (IndexOutOfBoundsException e) {
+            assertTrue("expected exception thrown", true);
+        }
+
+    }
+
+    /**
+     * Tests getting a sub list.
+     */
+    public void testSubList() {
+        Range range = createRange(0, 5);
+
+        List subList = range.subList(2, 4);
+        assertEquals("size", 2, subList.size());
+
+        assertTrue("sublist not a range", subList instanceof Range);
+        Range subListRange = (Range) subList;
+
+        assertEquals("from", createValue(2), subListRange.getFrom());
+        assertEquals("to", createValue(3), subListRange.getTo());
+
+        subList = range.subList(0, 6);
+        assertEquals("size", 6, subList.size());
+
+        assertTrue("sublist not a range", subList instanceof Range);
+        subListRange = (Range) subList;
+
+        assertEquals("from", createValue(0), subListRange.getFrom());
+        assertEquals("to", createValue(5), subListRange.getTo());
+    }
+
+    /**
+     * Tests creating a sub list with a negative "from" index.
+     */
+    public void testSubListNegativeFrom() {
+        try {
+            final Range range = createRange(1, 5);
+            range.subList(-1, 3);
+            fail("accepted sub list with negative index");
+        }
+        catch (IndexOutOfBoundsException e) {
+            assertTrue("expected exception thrown", true);
+        }
+    }
+
+    /**
+     * Tests creating a sub list with an out of range "to" index.
+     */
+    public void testSubListOutOfRangeTo() {
+        try {
+            final Range range = createRange(0, 3);
+            range.subList(0, 5);
+            fail("accepted sub list with invalid 'to'");
+        }
+        catch (IndexOutOfBoundsException e) {
+            assertTrue("expected exception thrown", true);
+        }
+    }
+
+    /**
+     * Tests creating a sub list with "from" grater than "to."
+     */
+    public void testSubListFromGreaterThanTo() {
+        try {
+            final Range range = createRange(1, 5);
+            range.subList(3, 2);
+            fail("accepted sub list with 'from' greater than 'to'");
+        }
+        catch (IllegalArgumentException e) {
+            assertTrue("expected exception thrown", true);
+        }
+    }
+
+    /**
+     * Tests creating an empty sub list.
+     */
+    public void testEmptySubList() {
+        final Range range = createRange(1, 5);
+
+        List subList = range.subList(0, 0);
+        assertEquals("wrong number of elements in sub list", 0, subList.size());
+
+        subList = range.subList(2, 2);
+        assertEquals("wrong number of elements in sub list", 0, subList.size());
+    }
+
+    /**
+     * Tests iterating over a non-reversed range.
+     */
+    public void testIterate() {
+        final Range range = createRange(1, 5);
+        int next = 1;
+        final Iterator iter = range.iterator();
+        while (iter.hasNext()) {
+            final Object value = iter.next();
+            assertEquals("wrong next value", createValue(next++), value);
+        }
+        assertEquals("wrong number of elements in iteration", 6, next);
+        assertNull("got element after iterator finished", iter.next());
+    }
+
+    /**
+     * Tests removing an element from the range using an iterator (not supported).
+     */
+    public void testRemoveFromIterator() {
+        final Range range = createRange(1, 5);
+
+        try {
+            final Iterator iter = range.iterator();
+            iter.remove();
+            fail("successfully removed an element using an iterator");
+        }
+        catch (UnsupportedOperationException e) {
+            assertTrue("expected exception thrown", true);
+        }
+    }
+
+    /**
+     * Tests iterating over a reversed range.
+     */
+    public void testIterateReversed() {
+        final Range range = createRange(5, 1);
+        int next = 5;
+        for (Iterator iter = range.iterator(); iter.hasNext();) {
+            assertEquals("wrong number", createValue(next--), iter.next());
+        }
+        assertEquals("wrong number of elements in iteration", 0, next);
+    }
+
+    /**
+     * Tests creating an <code>IntRange</code> with from > to.
+     */
+    public void testFromGreaterThanTo() {
+        final int from = 9;
+        final int to = 0;
+        final Range range = createRange(from, to);
+
+        assertTrue("range not reversed", range.isReverse());
+
+        // make sure to/from are swapped
+        assertEquals("from incorrect", createValue(to), range.getFrom());
+        assertEquals("to incorrect", createValue(from), range.getTo());
+
+        assertEquals("wrong size", 10, range.size());
+
+        assertEquals("wrong first element", createValue(9), range.get(0));
+        assertEquals("wrong last element", createValue(0), range.get(9));
+    }
+
+    /**
+     * Tests creating an <code>IntRange</code> with from == to.
+     */
+    public void testFromEqualsTo() {
+        final Range range = createRange(5, 5);
+
+        assertFalse("range reversed", range.isReverse());
+        assertEquals("wrong size", 1, range.size());
+    }
+
+    /**
+     * Tests creating an <code>IntRange</code> with from < to.
+     */
+    public void testFromLessThanTo() {
+        final int from = 1;
+        final int to = 4;
+        final Range range = createRange(from, to);
+
+        assertFalse("range reversed", range.isReverse());
+
+        assertEquals("to incorrect", createValue(from), range.getFrom());
+        assertEquals("from incorrect", createValue(to), range.getTo());
+
+        assertEquals("wrong size", 4, range.size());
+    }
+
+    /**
+     * Making a range equal a list is not actually possible, since list.equals(range) will not evaluate to
+     * <code>true</code> and <code>equals</code> should be symmetric.
+     */
+    public void testEqualsList() {
+        final List list = new ArrayList();
+        list.add(createValue(1));
+        list.add(createValue(2));
+
+        final Range range = createRange(1, 2);
+
+        // cast to Object to test routing through equals(Object)
+        assertTrue("range does not equal list", range.equals((Object) list));
+        assertTrue("list does not equal range", list.equals(range));
+        assertEquals("hash codes are not equal", range.hashCode(), list.hashCode());
+
+        // compare lists that are the same size but contain different elements
+        list.set(0, createValue(3));
+        assertFalse("range equals list", range.equals(list));
+        assertFalse("list equals range", list.equals(range));
+        assertFalse("hash codes are equal", range.hashCode() == list.hashCode());
+
+        // compare a list longer than the range
+        list.set(0, createValue(1));
+        list.add(createValue(3));
+        assertFalse("range equals list", range.equals(list));
+        assertFalse("list equals range", list.equals(range));
+        assertFalse("hash are equal", range.hashCode() == list.hashCode());
+
+        // compare a list shorter than the range
+        list.remove(2);
+        list.remove(1);
+        assertFalse("range equals list", range.equals(list));
+        assertFalse("list equals range", list.equals(range));
+        assertFalse("hash are equal", range.hashCode() == list.hashCode());
+    }
+
+    /**
+     * Tests comparing {@link Range} to an object that is not a {@link Range}.
+     */
+    public void testEqualsNonRange() {
+        final Range range = createRange(1, 5);
+        assertFalse("range equal to string", range.equals("hello"));
+    }
+
+    /**
+     * Tests comparing a {@link Range} cast to an {@link Object}
+     */
+    public void testEqualsRangeAsObject() {
+        final Range range1 = createRange(1, 5);
+        final Range range2 = createRange(1, 5);
+        assertTrue("ranges not equal", range1.equals((Object) range2));
+    }
+
+    /**
+     * Tests comparing two {@link Range}s to each other.
+     */
+    public void testEqualsRange() {
+        final Range range1 = createRange(1, 5);
+        Range range2 = createRange(1, 5);
+        assertTrue("ranges not equal", range1.equals((Object) range2));
+        assertTrue("ranges not equal", range2.equals((Object) range1));
+        assertEquals("hash codes not equal", range1.hashCode(), range2.hashCode());
+
+        range2 = createRange(0, 5);
+        assertFalse("ranges equal", range1.equals((Object) range2));
+        assertFalse("ranges equal", range2.equals((Object) range1));
+        assertFalse("hash codes equal", range1.hashCode() == range2.hashCode());
+
+        range2 = createRange(1, 6);
+        assertFalse("ranges equal", range1.equals((Object) range2));
+        assertFalse("ranges equal", range2.equals((Object) range1));
+        assertFalse("hash codes equal", range1.hashCode() == range2.hashCode());
+
+        range2 = createRange(0, 6);
+        assertFalse("ranges equal", range1.equals((Object) range2));
+        assertFalse("ranges equal", range2.equals((Object) range1));
+        assertFalse("hash codes equal", range1.hashCode() == range2.hashCode());
+
+        range2 = createRange(2, 4);
+        assertFalse("ranges equal", range1.equals((Object) range2));
+        assertFalse("ranges equal", range2.equals((Object) range1));
+        assertFalse("hash codes equal", range1.hashCode() == range2.hashCode());
+
+        range2 = createRange(5, 1);
+        assertFalse("ranges equal", range1.equals((Object) range2));
+        assertFalse("ranges equal", range2.equals((Object) range1));
+        assertFalse("hash codes equal", range1.hashCode() == range2.hashCode());
+    }
+
+    /**
+     * Tests <code>toString</code> and <code>inspect</code>
+     */
+    public void testToStringAndInspect() {
+        Range range = createRange(1, 5);
+        String expected = range.getFrom() + ".." + range.getTo();
+        assertEquals("wrong string representation", expected, range.toString());
+        assertEquals("wrong string representation", expected, range.inspect());
+
+        range = createRange(5, 1);
+        expected = range.getTo() + ".." + range.getFrom();
+        assertEquals("wrong string representation", expected, range.toString());
+        assertEquals("wrong string representation", expected, range.inspect());
+    }
+
+    /**
+     * Tests <code>getFrom</code> and <code>getTo</code>.
+     */
+    public void testGetFromAndTo() {
+        final int from = 1, to = 5;
+        final Range range = createRange(from, to);
+
+        assertEquals("wrong 'from' value", createValue(from), range.getFrom());
+        assertEquals("wrong 'to' value", createValue(to), range.getTo());
+    }
+
+    /**
+     * Tests comparing a {@link Range} to <code>null</code>.
+     */
+    public void testEqualsNull() {
+        final Range range = createRange(1, 5);
+        assertFalse("range equal to null", range.equals(null));
+        assertFalse("range equal to null Object", range.equals((Object) null));
+        assertFalse("range equal to null Range", range.equals((Range) null));
+        assertFalse("range equal to null List", range.equals((List) null));
+    }
+
+    /**
+     * Tests attempting to add a value to a range.
+     */
+    public void testAddValue() {
+        try {
+            final Range range = createRange(1, 5);
+            range.add(createValue(20));
+            fail("expected exception not thrown");
+        }
+        catch (UnsupportedOperationException e) {
+            assertTrue("expected exception thrown", true);
+        }
+    }
+
+    /**
+     * Tests attempting to remove a value from a range.
+     */
+    public void testRemoveValue() {
+        try {
+            final Range range = createRange(1, 5);
+            range.remove(0);
+            fail("expected exception not thrown");
+        }
+        catch (UnsupportedOperationException e) {
+            assertTrue("expected exception thrown", true);
+        }
+    }
+
+    private void doTestContains(int from, int to, Range range) {
+        // test integers
+        assertTrue("missing 'from' value", range.contains(createValue(from)));
+        assertTrue("missing 'to' value", range.contains(createValue(to)));
+        assertTrue("missing mid point", range.contains(createValue((from + to) / 2)));
+        assertFalse("contains out of range value", range.contains(createValue(from - 1)));
+        assertFalse("contains out of range value", range.contains(createValue(to + 1)));
+
+        // test ranges
+        assertTrue("missing same range", range.containsAll(createRange(from, to)));
+        assertTrue("missing same range", range.containsAll(createRange(to, from)));
+        assertTrue("missing strict subset", range.containsAll(createRange(from + 1, to - 1)));
+        assertTrue("missing subset", range.containsAll(createRange(from, to - 1)));
+        assertTrue("missing subset", range.containsAll(createRange(from + 1, to)));
+        assertFalse("contains non-subset", range.containsAll(createRange(from - 1, to)));
+        assertFalse("contains non-subset", range.containsAll(createRange(from, to + 1)));
+        assertFalse("contains non-subset", range.containsAll(createRange(from - 2, from - 1)));
+
+        // ranges don't contain other ranges
+        assertFalse("range contains sub-range", range.contains(createRange(from + 1, to - 1)));
+
+        // test list
+        final List list = new ArrayList();
+        list.add(createValue(from));
+        list.add(createValue(to));
+        assertTrue("missing strict subset", range.containsAll(list));
+
+        // test non-integer number
+        assertFalse("contains Float", range.contains(new Float((to + from) / 2.0 + 0.3)));
+    }
+
+    /**
+     * Tests whether the range contains a {@link Comparable} object which is not comparable with a {@link Number}.
+     */
+    public void testContainsIncompatibleComparable() {
+        final Range range = createRange(1, 5);
+        assertFalse("range contains string", range.contains("hello"));
+        assertFalse("range contains string", range.contains("1"));
+    }
+
+    /**
+     * Tests whether the range contains a non-comparable object.
+     */
+    public void testContainsNonComparable() {
+        final Range range = createRange(1, 5);
+        assertFalse("range contains hash map", range.contains(new HashMap()));
+    }
+
+    /**
+     * Tests whether a {@link Range} contains another {@link Range} or a specific integer.
+     */
+    public void testContains() {
+        final int from = 1, to = 5;
+        doTestContains(from, to, createRange(from, to));
+        doTestContains(from, to, createRange(to, from));
+    }
+
+    /**
+     * Tests <code>get</code> from a reversed range.
+     */
+    public void testGetFromReversedRange() {
+        final Range range = createRange(5, 1);
+
+        for (int i = 0; i < 5; i++) {
+            assertEquals("wrong element at position " + i, createValue(5 - i), range.get(i));
+        }
+    }
+
+    /**
+     * Tests getting values from the range.
+     */
+    public void testGet() {
+        final Range range = createRange(10, 20);
+        for (int i = 0; i <= 10; i++) {
+            assertEquals("Item at index: " + i, createValue(i + 10), range.get(i));
+        }
+    }
+}
diff --git a/src/test/groovy/lang/RangeTest.java b/src/test/groovy/lang/RangeTest.java
index 777231659e..5e78241577 100644
--- a/src/test/groovy/lang/RangeTest.java
+++ b/src/test/groovy/lang/RangeTest.java
@@ -140,7 +140,12 @@ public class RangeTest extends TestCase {
         r = createRange(new BigDecimal("2.1"), new BigDecimal("10.0"));
 
         assertTrue("contains 9.1", r.contains(new BigDecimal("9.1")));
-        assertTrue("contains 8.0", r.contains(new BigDecimal("8.0")));
+        assertFalse("contains 10.1", r.contains(new BigDecimal("10.1")));
+        assertFalse("contains 8.0", r.contains(new BigDecimal("8.0")));
+        assertTrue("containsWithinBounds 8.0", r.containsWithinBounds(new BigDecimal("8.0")));
+        assertTrue("containsWithinBounds 9.9999", r.containsWithinBounds(new BigDecimal("9.9999")));
+        assertTrue("containsWithinBounds 10.0", r.containsWithinBounds(new BigDecimal("10.0")));
+        assertFalse("containsWithinBounds 10.0001", r.containsWithinBounds(new BigDecimal("10.0001")));
     }
 
     public void testSubList() {
diff --git a/src/test/groovy/lang/RangeTestSuite.java b/src/test/groovy/lang/RangeTestSuite.java
new file mode 100644
index 0000000000..905c36b8aa
--- /dev/null
+++ b/src/test/groovy/lang/RangeTestSuite.java
@@ -0,0 +1,38 @@
+/**
+ *
+ */
+package groovy.lang;
+
+import junit.framework.TestSuite;
+import junit.textui.TestRunner;
+
+/**
+ * Calls all the range-related tests.
+ *
+ * @author Edwin Tellman
+ */
+public final class RangeTestSuite extends TestSuite {
+
+    /**
+     * Creates a new {@link RangeTestSuite}
+     */
+    public RangeTestSuite() {
+        addTestSuite(IntRangeTest.class);
+        addTestSuite(ShortRangeTest.class);
+        addTestSuite(IntegerRangeTest.class);
+        addTestSuite(LongRangeTest.class);
+        addTestSuite(FloatRangeTest.class);
+        addTestSuite(BigDecimalRangeTest.class);
+        addTestSuite(CharacterRangeTest.class);
+        addTestSuite(RangeTest.class);
+    }
+
+    /**
+     * Runs the tests in the {@link TestRunner}.
+     *
+     * @param argv not used
+     */
+    public static void main(String[] argv) {
+        junit.textui.TestRunner.run(new RangeTestSuite());
+    }
+}
diff --git a/src/test/groovy/lang/ShortRangeTest.java b/src/test/groovy/lang/ShortRangeTest.java
new file mode 100644
index 0000000000..ed7d36b459
--- /dev/null
+++ b/src/test/groovy/lang/ShortRangeTest.java
@@ -0,0 +1,70 @@
+/*
+ $Id: ShortRangeTest.java,v 1.1 2006/11/13 10:23:58 edwin Exp edwin $
+
+ Copyright 2003 (C) James Strachan and Bob Mcwhirter. All Rights Reserved.
+
+ Redistribution and use of this software and associated documentation
+ ("Software"), with or without modification, are permitted provided
+ that the following conditions are met:
+
+ 1. Redistributions of source code must retain copyright
+    statements and notices.  Redistributions must also contain a
+    copy of this document.
+
+ 2. Redistributions in binary form must reproduce the
+    above copyright notice, this list of conditions and the
+    following disclaimer in the documentation and/or other
+    materials provided with the distribution.
+
+ 3. The name "groovy" must not be used to endorse or promote
+    products derived from this Software without prior written
+    permission of The Codehaus.  For written permission,
+    please contact info@codehaus.org.
+
+ 4. Products derived from this Software may not be called "groovy"
+    nor may "groovy" appear in their names without prior written
+    permission of The Codehaus. "groovy" is a registered
+    trademark of The Codehaus.
+
+ 5. Due credit should be given to The Codehaus -
+    http://groovy.codehaus.org/
+
+ THIS SOFTWARE IS PROVIDED BY THE CODEHAUS AND CONTRIBUTORS
+ ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ THE CODEHAUS OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ OF THE POSSIBILITY OF SUCH DAMAGE.
+
+ */
+package groovy.lang;
+
+
+/**
+ * Tests {@link ObjectRange}s of {@link Short}s.
+ *
+ * @author $Author$
+ * @version $Revision$
+ */
+public class ShortRangeTest extends NumberRangeTest {
+
+    /**
+     * {@inheritDoc}
+     */
+    protected Range createRange(int from, int to) {
+        return new ObjectRange(new Short((short) from), new Short((short) to));
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    protected Comparable createValue(int value) {
+        return new Integer(value);
+    }
+}
