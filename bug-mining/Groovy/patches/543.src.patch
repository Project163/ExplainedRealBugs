diff --git a/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java b/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java
index 27fdf01b8e..8c796ea24c 100644
--- a/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java
+++ b/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java
@@ -305,6 +305,7 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
         int modifiers = Opcodes.ACC_PUBLIC;
         if (isType(MODIFIERS, node)) {
             modifiers = modifiers(node, annotations, modifiers);
+            checkNoInvalidModifier(classDef, "Interface", modifiers, Opcodes.ACC_SYNCHRONIZED, "synchronized");
             node = node.getNextSibling();
         }
         modifiers |= Opcodes.ACC_ABSTRACT | Opcodes.ACC_INTERFACE;
@@ -343,6 +344,7 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
         int modifiers = Opcodes.ACC_PUBLIC;
         if (isType(MODIFIERS, node)) {
             modifiers = modifiers(node, annotations, modifiers);
+            checkNoInvalidModifier(classDef, "Class", modifiers, Opcodes.ACC_SYNCHRONIZED, "synchronized");
             node = node.getNextSibling();
         }
 
@@ -490,10 +492,11 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
         int modifiers = Opcodes.ACC_PUBLIC;
         if (isType(MODIFIERS, node)) {
             modifiers = modifiers(node, annotations, modifiers);
+            checkNoInvalidModifier(methodDef, "Method", modifiers, Opcodes.ACC_VOLATILE, "volatile");
             node = node.getNextSibling();
         }
 
-        if (classNode!=null && (classNode.getModifiers() & Opcodes.ACC_INTERFACE) >0) {
+        if (isAnInterface()) {
             modifiers |= Opcodes.ACC_ABSTRACT;
         }
 
@@ -506,7 +509,7 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
         String name = identifier(node);
         if (classNode != null) {
             if (classNode.getNameWithoutPackage().equals(name)) {
-                if ((classNode.getModifiers() & Opcodes.ACC_INTERFACE) >0) {
+                if (isAnInterface()) {
                     throw new ASTRuntimeException(methodDef, "Constructor not permitted within an interface.");
                 }
                 throw new ASTRuntimeException(methodDef, "Invalid constructor format. Try remove the 'def' expression?");
@@ -548,7 +551,17 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
             output.addMethod(methodNode);
         }
     }
-    
+
+    private void checkNoInvalidModifier(AST node, String nodeType, int modifiers, int modifier, String modifierText) {
+        if ((modifiers & modifier) != 0) {
+            throw new ASTRuntimeException(node, nodeType + " has an incorrect modifier '" + modifierText + "'.");
+        }
+    }
+
+    private boolean isAnInterface() {
+        return classNode != null && (classNode.getModifiers() & Opcodes.ACC_INTERFACE) > 0;
+    }
+
     protected void staticInit(AST staticInit) {        
         BlockStatement code = (BlockStatement) statementList(staticInit);
         classNode.addStaticInitializerStatements(code.getStatements(),false);
@@ -655,7 +668,7 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
         configureAST(fieldNode, fieldDef);
 
         if (!hasVisibility(modifiers)) {
-            // lets set the modifiers on the field
+            // let's set the modifiers on the field
             int fieldModifiers = 0;
             int flags = Opcodes.ACC_STATIC | Opcodes.ACC_TRANSIENT | Opcodes.ACC_VOLATILE | Opcodes.ACC_FINAL;
 
@@ -664,7 +677,7 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
                 fieldModifiers |= Opcodes.ACC_PRIVATE;
             }
 
-            // lets pass along any other modifiers we need
+            // let's pass along any other modifiers we need
             fieldModifiers |= (modifiers & flags);
             fieldNode.setModifiers(fieldModifiers);
             
@@ -739,7 +752,7 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
         if (node != null) {
             assertNodeType(ASSIGN, node);
             Expression rightExpression = expression(node.getFirstChild());
-            if ((classNode.getModifiers() & Opcodes.ACC_INTERFACE) >0) {
+            if (isAnInterface()) {
                 throw new ASTRuntimeException(node, "Cannot specify default value for method parameter '" + name + " = " + rightExpression.getText() + "' inside an interface");
             }
             parameter = new Parameter(type, name, rightExpression);
@@ -1207,7 +1220,7 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
         Statement finallyStatement = EmptyStatement.INSTANCE;
         AST node = tryNode.getNextSibling();
 
-        // lets do the catch nodes
+        // let's do the catch nodes
         List catches = new ArrayList();
         for (; node != null && isType(LITERAL_catch, node); node = node.getNextSibling()) {
             catches.add(catchStatement(node));
@@ -1886,7 +1899,7 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
     }
 
     protected Expression dotExpression(AST node) {
-        // lets decide if this is a propery invocation or a method call
+        // let's decide if this is a propery invocation or a method call
         AST leftNode = node.getFirstChild();
         if (leftNode != null) {
             AST identifierNode = leftNode.getNextSibling();
@@ -2072,9 +2085,9 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
         }
         if (namedArguments) {
             if (!expressionList.isEmpty()) {
-                // lets remove any non-MapEntryExpression instances
+                // let's remove any non-MapEntryExpression instances
                 // such as if the last expression is a ClosureExpression
-                // so lets wrap the named method calls in a Map expression
+                // so let's wrap the named method calls in a Map expression
                 List argumentList = new ArrayList();
                 for (Iterator iter = expressionList.iterator(); iter.hasNext();) {
                     Expression expression = (Expression) iter.next();
@@ -2170,7 +2183,7 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
     protected Expression unaryMinusExpression(AST unaryMinusExpr) {
         AST node = unaryMinusExpr.getFirstChild();
 
-        // if we are a number literal then lets just parse it
+        // if we are a number literal then let's just parse it
         // as the negation operator on MIN_INT causes rounding to a long
         String text = node.getText();
         switch (node.getType()) {
diff --git a/src/main/org/codehaus/groovy/classgen/ClassCompletionVerifier.java b/src/main/org/codehaus/groovy/classgen/ClassCompletionVerifier.java
index e27cc92464..057c1ade48 100644
--- a/src/main/org/codehaus/groovy/classgen/ClassCompletionVerifier.java
+++ b/src/main/org/codehaus/groovy/classgen/ClassCompletionVerifier.java
@@ -91,11 +91,13 @@ public class ClassCompletionVerifier extends ClassCodeVisitorSupport {
     private void checkClassForOtherModifiers(ClassNode node) {
         checkClassForModifier(node, Modifier.isTransient(node.getModifiers()), "transient");
         checkClassForModifier(node, Modifier.isVolatile(node.getModifiers()), "volatile");
-        // don't check synchronized for synthetic fields
-        if ((node.getModifiers() & Opcodes.ACC_SYNTHETIC) == 0) {
-            checkClassForModifier(node, Modifier.isSynchronized(node.getModifiers()), "synchronized");
-        }
         checkClassForModifier(node, Modifier.isNative(node.getModifiers()), "native");
+        // don't check synchronized here as it overlaps with ACC_SUPER
+    }
+
+    private void checkMethodForModifier(MethodNode node, boolean condition, String modifierName) {
+        if (!condition) return;
+        addError("The " + getDescription(node) + " has an incorrect modifier " + modifierName + ".", node);
     }
 
     private void checkClassForModifier(ClassNode node, boolean condition, String modifierName) {
@@ -230,9 +232,20 @@ public class ClassCompletionVerifier extends ClassCodeVisitorSupport {
         checkAbstractDeclaration(node);
         checkRepetitiveMethod(node);
         checkOverloadingPrivateAndPublic(node);
+        checkMethodModifiers(node);
         super.visitMethod(node);
     }
 
+    private void checkMethodModifiers(MethodNode node) {
+        // don't check volatile here as it overlaps with ACC_BRIDGE
+        // additional modifiers not allowed for interfaces
+        if ((this.currentClass.getModifiers() & Opcodes.ACC_INTERFACE) != 0) {
+            checkMethodForModifier(node, Modifier.isStrict(node.getModifiers()), "strictfp");
+            checkMethodForModifier(node, Modifier.isSynchronized(node.getModifiers()), "synchronized");
+            checkMethodForModifier(node, Modifier.isNative(node.getModifiers()), "native");
+        }
+    }
+
     private void checkOverloadingPrivateAndPublic(MethodNode node) {
         if (isConstructor(node)) return;
         List methods = currentClass.getMethods(node.getName());
diff --git a/src/main/org/codehaus/groovy/classgen/ReflectorGenerator.java b/src/main/org/codehaus/groovy/classgen/ReflectorGenerator.java
index 4ba20fcfa6..99637dd61b 100644
--- a/src/main/org/codehaus/groovy/classgen/ReflectorGenerator.java
+++ b/src/main/org/codehaus/groovy/classgen/ReflectorGenerator.java
@@ -62,7 +62,7 @@ public class ReflectorGenerator implements Opcodes {
         this.cv = cv;
 
         classInternalName = BytecodeHelper.getClassInternalName(className);
-        cv.visit(ClassGenerator.asmJDKVersion, ACC_PUBLIC, classInternalName, null, "org/codehaus/groovy/runtime/Reflector", null);
+        cv.visit(ClassGenerator.asmJDKVersion, ACC_PUBLIC + ACC_SUPER, classInternalName, null, "org/codehaus/groovy/runtime/Reflector", null);
 
         cv.visitField(ACC_PUBLIC + ACC_STATIC, "accessor", "Ljava/lang/Object;", null, null);
 
diff --git a/src/test/groovy/VisibilityModifiersTest.groovy b/src/test/groovy/ModifiersTest.groovy
similarity index 59%
rename from src/test/groovy/VisibilityModifiersTest.groovy
rename to src/test/groovy/ModifiersTest.groovy
index 944196d5ef..2822ea854c 100644
--- a/src/test/groovy/VisibilityModifiersTest.groovy
+++ b/src/test/groovy/ModifiersTest.groovy
@@ -2,7 +2,7 @@ package groovy
 
 import gls.CompilableTestSupport
 
-class VisibilityModifiersTest extends CompilableTestSupport {
+class ModifiersTest extends CompilableTestSupport {
 
     public void testInterface() {
         // control
@@ -19,13 +19,29 @@ class VisibilityModifiersTest extends CompilableTestSupport {
         shouldNotCompile("synchronized class X {}")
     }
 
-    public void testMethod() {
+    public void testMethodsShouldOnlyHaveOneVisibility() {
         // control
         shouldCompile("class X { private method() {} }")
         // erroneous
         shouldNotCompile("class X { private public method() {} }")
     }
 
+    public void testMethodsShouldNotBeVolatile() {
+        // control
+        shouldCompile("class X { def method() {} }")
+        // erroneous
+        shouldNotCompile("class X { volatile method() {} }")
+    }
+
+    public void testInterfaceMethodsShouldNotBeSynchronizedNativeStrictfp() {
+        // control
+        shouldCompile("interface X { def method() }")
+        // erroneous
+        shouldNotCompile("interface X { native method() }")
+        shouldNotCompile("interface X { synchronized method() }")
+        shouldNotCompile("interface X { strictfp method() }")
+    }
+
     public void testVariableInClass() {
         // control
         shouldCompile("class X { protected name }")
diff --git a/src/test/org/codehaus/groovy/classgen/ClassCompletionVerifierTest.java b/src/test/org/codehaus/groovy/classgen/ClassCompletionVerifierTest.java
index f94c0e95c6..d1b8cf5b22 100644
--- a/src/test/org/codehaus/groovy/classgen/ClassCompletionVerifierTest.java
+++ b/src/test/org/codehaus/groovy/classgen/ClassCompletionVerifierTest.java
@@ -37,6 +37,14 @@ public class ClassCompletionVerifierTest extends TestSupport {
             "Repetitive method name/signature for method 'java.lang.Object xxx()' in class 'zzz'.";
     private static final String EXPECTED_DUPLICATE_METHOD_ERROR_INTERFACE_MESSAGE =
             "Repetitive method name/signature for method 'java.lang.Object xxx(java.lang.String)' in interface 'zzz'.";
+    private static final String EXPECTED_VOLATILE_METHOD_ERROR_MESSAGE =
+            "The method 'java.lang.Object vo()' has an incorrect modifier volatile.";
+    private static final String EXPECTED_STRICT_METHOD_ERROR_MESSAGE =
+            "The method 'java.lang.Object st()' has an incorrect modifier strictfp.";
+    private static final String EXPECTED_NATIVE_METHOD_ERROR_MESSAGE =
+            "The method 'java.lang.Object na()' has an incorrect modifier native.";
+    private static final String EXPECTED_SYNCHRONIZED_METHOD_ERROR_MESSAGE =
+            "The method 'java.lang.Object sy()' has an incorrect modifier synchronized.";
 
     protected void setUp() throws Exception {
         super.setUp();
@@ -70,10 +78,10 @@ public class ClassCompletionVerifierTest extends TestSupport {
     }
 
     public void testDetectsIncorrectOtherModifier() throws Exception {
-        checkVisitErrors("DodgyClass", ACC_TRANSIENT | ACC_VOLATILE | ACC_NATIVE | ACC_SYNCHRONIZED, true);
+        // can't check synchronized here as it doubles up with ACC_SUPER
+        checkVisitErrors("DodgyClass", ACC_TRANSIENT | ACC_VOLATILE | ACC_NATIVE, true);
         checkErrorMessage(EXPECTED_TRANSIENT_CLASS_ERROR_MESSAGE);
         checkErrorMessage(EXPECTED_VOLATILE_CLASS_ERROR_MESSAGE);
-        checkErrorMessage(EXPECTED_SYNCHRONIZED_CLASS_ERROR_MESSAGE);
         checkErrorMessage(EXPECTED_NATIVE_CLASS_ERROR_MESSAGE);
     }
 
@@ -94,6 +102,33 @@ public class ClassCompletionVerifierTest extends TestSupport {
         checkErrorMessage(EXPECTED_INTERFACE_STATIC_METHOD_ERROR_MESSAGE);
     }
 
+    public void testDetectsIncorrectMethodModifiersInInterface() throws Exception {
+        // TODO: can't check volatile here as it doubles up with bridge
+        ClassNode node = new ClassNode("zzz", ACC_ABSTRACT | ACC_INTERFACE, ClassHelper.OBJECT_TYPE);
+        node.addMethod(new MethodNode("st", ACC_STRICT, ClassHelper.OBJECT_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, null));
+        node.addMethod(new MethodNode("na", ACC_NATIVE, ClassHelper.OBJECT_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, null));
+        node.addMethod(new MethodNode("sy", ACC_SYNCHRONIZED, ClassHelper.OBJECT_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, null));
+        // constructors should not be treated as errors (they have no real meaning for interfaces anyway)
+        node.addMethod(new MethodNode("<clinit>", ACC_PUBLIC | ACC_STATIC, ClassHelper.OBJECT_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, null));
+        verifier.visitClass(node);
+        checkErrorCount(3);
+        checkErrorMessage(EXPECTED_STRICT_METHOD_ERROR_MESSAGE);
+        checkErrorMessage(EXPECTED_NATIVE_METHOD_ERROR_MESSAGE);
+        checkErrorMessage(EXPECTED_SYNCHRONIZED_METHOD_ERROR_MESSAGE);
+    }
+
+    public void testDetectsCorrectMethodModifiersInClass() throws Exception {
+        // TODO: can't check volatile here as it doubles up with bridge
+        ClassNode node = new ClassNode("zzz", ACC_PUBLIC, ClassHelper.OBJECT_TYPE);
+        node.addMethod(new MethodNode("st", ACC_STRICT, ClassHelper.OBJECT_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, null));
+        node.addMethod(new MethodNode("na", ACC_NATIVE, ClassHelper.OBJECT_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, null));
+        node.addMethod(new MethodNode("sy", ACC_SYNCHRONIZED, ClassHelper.OBJECT_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, null));
+        // constructors should not be treated as errors (they have no real meaning for interfaces anyway)
+        node.addMethod(new MethodNode("<clinit>", ACC_PUBLIC | ACC_STATIC, ClassHelper.OBJECT_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, null));
+        verifier.visitClass(node);
+        checkErrorCount(0);
+    }
+
     private void checkErrorCount(int count) {
         assertEquals(buildErrorMessage(count), count, source.getErrorCollector().getErrorCount());
     }
diff --git a/src/test/org/codehaus/groovy/classgen/PropertyTest.java b/src/test/org/codehaus/groovy/classgen/PropertyTest.java
index 215713dc3e..e99c9c1a9e 100644
--- a/src/test/org/codehaus/groovy/classgen/PropertyTest.java
+++ b/src/test/org/codehaus/groovy/classgen/PropertyTest.java
@@ -74,7 +74,7 @@ public class PropertyTest extends TestSupport {
     }
 
     public void testProperties() throws Exception {
-        ClassNode classNode = new ClassNode("Foo", ACC_PUBLIC, ClassHelper.OBJECT_TYPE);
+        ClassNode classNode = new ClassNode("Foo", ACC_PUBLIC + ACC_SUPER, ClassHelper.OBJECT_TYPE);
         classNode.addProperty(new PropertyNode("bar", ACC_PUBLIC, ClassHelper.STRING_TYPE, classNode, null, null, null));
 
         Class fooClass = loadClass(classNode);
@@ -90,7 +90,7 @@ public class PropertyTest extends TestSupport {
     }
 
     public void testInheritedProperties() throws Exception {
-        ClassNode classNode = new ClassNode("Foo", ACC_PUBLIC, ClassHelper.make(DummyBean.class));
+        ClassNode classNode = new ClassNode("Foo", ACC_PUBLIC + ACC_SUPER, ClassHelper.make(DummyBean.class));
         classNode.addProperty(new PropertyNode("bar", ACC_PUBLIC, ClassHelper.STRING_TYPE, classNode, null, null, null));
 
         Class fooClass = loadClass(classNode);
