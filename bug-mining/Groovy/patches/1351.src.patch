diff --git a/src/main/org/codehaus/groovy/tools/javac/JavaStubGenerator.java b/src/main/org/codehaus/groovy/tools/javac/JavaStubGenerator.java
index 18c1146cf7..ffa95d5839 100644
--- a/src/main/org/codehaus/groovy/tools/javac/JavaStubGenerator.java
+++ b/src/main/org/codehaus/groovy/tools/javac/JavaStubGenerator.java
@@ -20,6 +20,7 @@ import org.codehaus.groovy.ast.expr.ArgumentListExpression;
 import org.codehaus.groovy.ast.expr.ConstantExpression;
 import org.codehaus.groovy.ast.expr.ConstructorCallExpression;
 import org.codehaus.groovy.ast.expr.Expression;
+import org.codehaus.groovy.ast.expr.ListExpression;
 import org.codehaus.groovy.ast.expr.VariableExpression;
 import org.codehaus.groovy.ast.expr.PropertyExpression;
 import org.codehaus.groovy.ast.expr.ClosureExpression;
@@ -612,34 +613,45 @@ public class JavaStubGenerator
             boolean first = true;
             Map<String, Expression> members = annotation.getMembers();
             for (String key : members.keySet()) {
-                String val = "null";
-                Object memberValue = members.get(key);
-                if (memberValue instanceof ConstantExpression) {
-                    ConstantExpression ce = (ConstantExpression) memberValue;
-                    Object constValue = ce.getValue();
-                    if (constValue instanceof Number || constValue instanceof Boolean)
-                        val = constValue.toString();
-                    else
-                        val = "\"" + constValue + "\"";
-                } else if (memberValue instanceof PropertyExpression || memberValue instanceof VariableExpression) {
-                    // assume must be static class field or enum value or class that Java can resolve
-                    val = ((Expression) memberValue).getText();
-                } else if (memberValue instanceof ClosureExpression) {
-                    // annotation closure; replaced with this specific class literal to cover the
-                    // case where annotation type uses Class<? extends Closure> for the closure's type
-                    val = "groovy.lang.Closure.class";
-                }
-                if (first) {
-                    first = false;
-                } else {
-                    out.print(", ");
-                }
-                out.print(key + "=" + val);
+                if (first) first = false;
+                else out.print(", ");
+                out.print(key + "=" + getAnnotationValue(members.get(key)));
             }
             out.print(") ");
         }
     }
 
+    private String getAnnotationValue(Object memberValue) {
+        String val = "null";
+        if (memberValue instanceof ListExpression) {
+            StringBuilder sb = new StringBuilder("{");
+            boolean first = true;
+            ListExpression le = (ListExpression) memberValue;
+            for (Expression e : le.getExpressions()) {
+                if (first) first = false;
+                else sb.append(",");
+                sb.append(getAnnotationValue(e));
+            }
+            sb.append("}");
+            val = sb.toString();
+        } else if (memberValue instanceof ConstantExpression) {
+            ConstantExpression ce = (ConstantExpression) memberValue;
+            Object constValue = ce.getValue();
+            if (constValue instanceof Number || constValue instanceof Boolean)
+                val = constValue.toString();
+            else
+                val = "\"" + constValue + "\"";
+        } else if (memberValue instanceof PropertyExpression || memberValue instanceof VariableExpression) {
+            // assume must be static class field or enum value or class that Java can resolve
+            val = ((Expression) memberValue).getText();
+        } else if (memberValue instanceof ClosureExpression) {
+            // annotation closure; replaced with this specific class literal to cover the
+            // case where annotation type uses Class<? extends Closure> for the closure's type
+            val = "groovy.lang.Closure.class";
+        }
+        return val;
+    }
+
     private void printModifiers(PrintWriter out, int modifiers) {
         if ((modifiers & Opcodes.ACC_PUBLIC) != 0)
             out.print("public ");
diff --git a/src/test/org/codehaus/groovy/tools/stubgenerator/ArrayAnnotationsShouldAppearInStubsTest.groovy b/src/test/org/codehaus/groovy/tools/stubgenerator/ArrayAnnotationsShouldAppearInStubsTest.groovy
new file mode 100644
index 0000000000..f4c022aa98
--- /dev/null
+++ b/src/test/org/codehaus/groovy/tools/stubgenerator/ArrayAnnotationsShouldAppearInStubsTest.groovy
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2003-2010 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.codehaus.groovy.tools.stubgenerator
+
+/**
+ * Given that an import with an alias always has the fully qualified
+ * path we should always be able to substitute the fqn and hence don't
+ * need an import. Java code has no visibility to the alias.
+ *
+ * @author Paul King
+ */
+class ArrayAnnotationsShouldAppearInStubsTest extends StringSourcesStubTestCase {
+
+    Map<String, String> provideSources() {
+        [
+            'AnnotatedClass.groovy': '''
+                @ArrayAnnotation(["foo", "bar"])
+                class AnnotatedClass {
+                    @ArrayAnnotation([]) method1() {}
+                    @ArrayAnnotation(['baz']) method2() {}
+                }
+            ''',
+            'ArrayAnnotation.java': '''
+            public @interface ArrayAnnotation {
+                String[] value() default {};
+            }
+            '''
+        ]
+    }
+
+    void verifyStubs() {
+        classes['AnnotatedClass'].with {
+            assert annotations[0].getProperty('value').toString() == '{"foo", "bar"}'
+            assert methods['method1'].annotations[0].getProperty('value').toString() == '{}'
+            assert methods['method2'].annotations[0].getProperty('value').toString() == '{"baz"}'
+        }
+    }
+}
