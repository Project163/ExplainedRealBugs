diff --git a/project.xml b/project.xml
index 640ab96902..ec1c896430 100644
--- a/project.xml
+++ b/project.xml
@@ -496,8 +496,18 @@
     </dependency>    
     <dependency>
       <groupId>jmock</groupId>
-      <artifactId>jmock</artifactId>    
-      <version>1.0.1</version>
+      <artifactId>jmock</artifactId>
+      <version>SNAPSHOT</version>
+    </dependency>
+    <dependency>
+      <groupId>jmock</groupId>
+      <artifactId>jmock-cglib</artifactId>
+      <version>SNAPSHOT</version>
+    </dependency>
+    <dependency>
+        <groupId>cglib</groupId>
+        <artifactId>cglib</artifactId>
+        <version>nodep-2.1</version>
     </dependency>
 
     <!-- only used for testing/debugging-->
diff --git a/src/main/groovy/lang/GroovyClassLoader.java b/src/main/groovy/lang/GroovyClassLoader.java
index a103f5f308..a2e488e72d 100644
--- a/src/main/groovy/lang/GroovyClassLoader.java
+++ b/src/main/groovy/lang/GroovyClassLoader.java
@@ -34,27 +34,42 @@
  */
 package groovy.lang;
 
-import org.codehaus.groovy.ast.ClassNode;
-import org.codehaus.groovy.classgen.Verifier;
-import org.codehaus.groovy.control.CompilationFailedException;
-import org.codehaus.groovy.control.CompilationUnit;
-import org.codehaus.groovy.control.CompilerConfiguration;
-import org.codehaus.groovy.control.Phases;
-import org.objectweb.asm.ClassVisitor;
-import org.objectweb.asm.ClassWriter;
-
-import java.io.*;
+import java.io.BufferedInputStream;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
 import java.lang.reflect.Field;
 import java.net.MalformedURLException;
 import java.net.URL;
-import java.security.*;
+import java.security.AccessController;
+import java.security.CodeSource;
+import java.security.PrivilegedAction;
+import java.security.ProtectionDomain;
+import java.security.SecureClassLoader;
 import java.security.cert.Certificate;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
 import java.util.jar.Attributes;
 import java.util.jar.JarEntry;
 import java.util.jar.JarFile;
 import java.util.jar.Manifest;
 
+import org.codehaus.groovy.ast.ClassNode;
+import org.codehaus.groovy.classgen.Verifier;
+import org.codehaus.groovy.control.CompilationFailedException;
+import org.codehaus.groovy.control.CompilationUnit;
+import org.codehaus.groovy.control.CompilerConfiguration;
+import org.codehaus.groovy.control.Phases;
+import org.objectweb.asm.ClassVisitor;
+import org.objectweb.asm.ClassWriter;
+
 /**
  * A ClassLoader which can load Groovy classes
  *
@@ -83,7 +98,7 @@ public class GroovyClassLoader extends SecureClassLoader {
 
     private String[] searchPaths;
 
-    private List additionalPaths = new ArrayList();
+    private Set additionalPaths = new HashSet();
 
     public GroovyClassLoader() {
         this(Thread.currentThread().getContextClassLoader());
@@ -393,13 +408,12 @@ public class GroovyClassLoader extends SecureClassLoader {
        */
       protected String[] getClassPath() {
         if (null == searchPaths) {
-          final String classpath;
+          String classpath;
           if(null != config && null != config.getClasspath()) {
             //there's probably a better way to do this knowing the internals of
             //Groovy, but it works for now
-            final List paths = config.getClasspath();
-            final StringBuffer sb = new StringBuffer();
-            for(Iterator iter = paths.iterator(); iter.hasNext(); ) {
+            StringBuffer sb = new StringBuffer();
+            for(Iterator iter = config.getClasspath().iterator(); iter.hasNext(); ) {
               sb.append(iter.next().toString());
               sb.append(File.pathSeparatorChar);
             }
@@ -409,7 +423,7 @@ public class GroovyClassLoader extends SecureClassLoader {
           } else {
             classpath = System.getProperty("java.class.path", ".");
           }
-          final List pathList = new ArrayList();
+          List pathList = new ArrayList(additionalPaths);
           expandClassPath(pathList, null, classpath, false);
           searchPaths = new String[pathList.size()];
           searchPaths = (String[]) pathList.toArray(searchPaths);
diff --git a/src/main/org/codehaus/groovy/control/CompilationUnit.java b/src/main/org/codehaus/groovy/control/CompilationUnit.java
index 6ab4268eed..f2bb5b247f 100644
--- a/src/main/org/codehaus/groovy/control/CompilationUnit.java
+++ b/src/main/org/codehaus/groovy/control/CompilationUnit.java
@@ -53,16 +53,29 @@
 
 package org.codehaus.groovy.control;
 
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URL;
+import java.security.CodeSource;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
 
 import org.codehaus.groovy.GroovyBugError;
-
 import org.codehaus.groovy.ast.ASTNode;
-
 import org.codehaus.groovy.ast.ClassNode;
-
 import org.codehaus.groovy.ast.CompileUnit;
 import org.codehaus.groovy.ast.ModuleNode;
-import org.codehaus.groovy.classgen.*;
+import org.codehaus.groovy.classgen.AsmClassGenerator;
+import org.codehaus.groovy.classgen.ClassCompletionVerifier;
+import org.codehaus.groovy.classgen.ClassGenerator;
+import org.codehaus.groovy.classgen.GeneratorContext;
+import org.codehaus.groovy.classgen.JSRVariableScopeCodeVisitor;
+import org.codehaus.groovy.classgen.Verifier;
 import org.codehaus.groovy.control.io.InputStreamReaderSource;
 import org.codehaus.groovy.control.io.ReaderSource;
 import org.codehaus.groovy.control.messages.ExceptionMessage;
@@ -72,20 +85,9 @@ import org.codehaus.groovy.tools.GroovyClass;
 import org.objectweb.asm.ClassVisitor;
 import org.objectweb.asm.ClassWriter;
 
-
+import groovy.lang.GroovyClassLoader;
 import groovy.lang.GroovyRuntimeException;
 
-
-import java.io.*;
-import java.net.MalformedURLException;
-import java.net.URL;
-import java.security.CodeSource;
-import java.util.*;
-
-
-
-
-
 /**
  * Collects all compilation data as it is generated by the compiler system.
  * Allows additional source units to be added and compilation run again (to
@@ -95,7 +97,6 @@ import java.util.*;
  * @version $Id$
  */
 
-
 public class CompilationUnit extends ProcessingUnit {
 
 
@@ -173,36 +174,27 @@ public class CompilationUnit extends ProcessingUnit {
         this.classgenCallback = null;
     }
 
-
     /**
-     * Reconfigures the CompilationUnit.
+     * Configures its debugging mode and classloader classpath from a given compiler configuration.
+     * This cannot be done more than once due to limitations in {@link java.net.URLClassLoader URLClassLoader}.
      */
     public void configure(CompilerConfiguration configuration) {
         super.configure(configuration);
         this.debug = configuration.getDebug();
 
+        if (!this.configured && this.classLoader instanceof GroovyClassLoader) {
+            appendCompilerConfigurationClasspathToClassLoader(configuration, (GroovyClassLoader) this.classLoader);
+        }
 
-        //
-        // Configure our class loader's classpath, if it is of
-        // a configurable type.  We can't reconfigure it,
-        // unfortunately, due to limitations in URLClassLoader.
-        if (!this.configured && this.classLoader instanceof CompilerClassLoader) {
-            CompilerClassLoader loader = (CompilerClassLoader) this.classLoader;
-
+        this.configured = true;
+    }
 
-            Iterator iterator = configuration.getClasspath().iterator();
-            while (iterator.hasNext()) {
-                try {
-                    this.configured = true;
-                    loader.addPath((String) iterator.next());
-                } catch (MalformedURLException e) {
-                    throw new ConfigurationException(e);
-                }
-            }
+    private void appendCompilerConfigurationClasspathToClassLoader(CompilerConfiguration configuration, GroovyClassLoader classLoader) {
+        for (Iterator iterator = configuration.getClasspath().iterator(); iterator.hasNext(); ) {
+            classLoader.addClasspath((String) iterator.next());
         }
     }
 
-
     /**
      * Returns the CompileUnit that roots our AST.
      */
diff --git a/src/main/org/codehaus/groovy/control/CompilerClassLoader.java b/src/main/org/codehaus/groovy/control/CompilerClassLoader.java
deleted file mode 100644
index 805672d610..0000000000
--- a/src/main/org/codehaus/groovy/control/CompilerClassLoader.java
+++ /dev/null
@@ -1,81 +0,0 @@
-package org.codehaus.groovy.control;
-
-import java.io.File;
-import java.net.URL;
-import java.net.URLClassLoader;
-import java.net.MalformedURLException;
-import java.util.HashMap;
-import java.util.Map;
-
-public class CompilerClassLoader extends ClassLoader {
-
-    private static final URL[] EMPTY_URL_ARRAY = new URL[0];
-    private ClassLoader parent;
-    private InnerLoader inner;
-    private Map map;
-    
-    private class InnerLoader extends URLClassLoader{
-        public InnerLoader() {
-            super(EMPTY_URL_ARRAY);
-        }
-
-        public void addPath(String path) throws MalformedURLException{
-            addURL( new File( path ).toURL() );
-        }        
-        
-        protected Class loadClass(String name, boolean resolve) throws ClassNotFoundException {
-            Class c = (Class) map.get(name);
-            if (c!=null) return c;
-            try {
-                // we prefer to search on the given paths first
-                c = super.findClass(name);
-                map.put(name,c);
-                return c;
-            } catch (ClassNotFoundException cnfe) {
-                c = parent.loadClass(name);
-                map.put(name,c);
-                return c;
-            } 
-        }   
-        
-        public Class loadClass(String name) throws ClassNotFoundException {
-            return loadClass(name,false);
-        }
-        
-        protected Class findClass(String name) throws ClassNotFoundException {
-            return loadClass(name,false);
-        }
-        
-    }
-    
-    
-    
-    public CompilerClassLoader()
-    {
-        super(Thread.currentThread().getContextClassLoader());
-        parent = Thread.currentThread().getContextClassLoader();
-        // if no context class loader is set use the classloader of this class
-        if (parent==null) parent= this.getClass().getClassLoader();
-        inner = new InnerLoader();
-        map = new HashMap();
-        //super(EMPTY_URL_ARRAY);
-    }
-
-    public void addPath(String path)
-        throws MalformedURLException
-    {
-        inner.addPath(path);
-    }
-    
-    protected Class loadClass(String name, boolean resolve) throws ClassNotFoundException {
-        return inner.loadClass(name);
-    }
-    
-    public Class loadClass(String name) throws ClassNotFoundException {
-        return loadClass(name,false);
-    }
-    
-    protected Class findClass(String name) throws ClassNotFoundException {
-        return loadClass(name,false);
-    }
-}
diff --git a/src/main/org/codehaus/groovy/control/ProcessingUnit.java b/src/main/org/codehaus/groovy/control/ProcessingUnit.java
index 8a179ea069..0fe8b28414 100644
--- a/src/main/org/codehaus/groovy/control/ProcessingUnit.java
+++ b/src/main/org/codehaus/groovy/control/ProcessingUnit.java
@@ -92,8 +92,8 @@ public abstract class ProcessingUnit {
         this.phase = Phases.INITIALIZATION;
         ClassLoader parent = Thread.currentThread().getContextClassLoader();
         if (parent == null) parent = ProcessingUnit.class.getClassLoader();
-        configure((configuration == null ? new CompilerConfiguration() : configuration));
         this.classLoader = (classLoader == null ? new GroovyClassLoader(parent, configuration) : classLoader);
+        configure((configuration == null ? new CompilerConfiguration() : configuration));
         if (er==null) er = new ErrorCollector(getConfiguration());
         this.errorCollector = er;
     }
diff --git a/src/test/groovy/lang/GroovyClassLoaderTest.java b/src/test/groovy/lang/GroovyClassLoaderTest.java
new file mode 100644
index 0000000000..d0f87c1a84
--- /dev/null
+++ b/src/test/groovy/lang/GroovyClassLoaderTest.java
@@ -0,0 +1,41 @@
+/*
+ * $Id$
+ *
+ * Copyright (c) 2005 The Codehaus - http://groovy.codehaus.org
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *
+ * See the License for the specific language governing permissions and limitations under the License.
+ *
+ */
+
+
+package groovy.lang;
+
+import java.util.Arrays;
+
+import junit.framework.TestCase;
+
+public class GroovyClassLoaderTest extends TestCase {
+
+    private final GroovyClassLoader classLoader = new GroovyClassLoader();
+
+    public void testAddsAClasspathEntryOnlyIfItHasNotAlreadyBeenAdded() {
+        String newClasspathEntry = "/tmp";
+        int initialNumberOfClasspathEntries = classLoader.getClassPath().length;
+
+        classLoader.addClasspath(newClasspathEntry);
+        assertEquals("number of classpath entries", initialNumberOfClasspathEntries + 1, classLoader.getClassPath().length);
+        assertTrue("contains new classpath entry", Arrays.asList(classLoader.getClassPath()).contains(newClasspathEntry));
+
+        classLoader.addClasspath(newClasspathEntry);
+        assertEquals("number of classpath entries", initialNumberOfClasspathEntries + 1, classLoader.getClassPath().length);
+        assertTrue("contains new classpath entry", Arrays.asList(classLoader.getClassPath()).contains(newClasspathEntry));
+    }
+}
diff --git a/src/test/org/codehaus/groovy/control/CompilationUnitTest.java b/src/test/org/codehaus/groovy/control/CompilationUnitTest.java
new file mode 100644
index 0000000000..3a364d92a1
--- /dev/null
+++ b/src/test/org/codehaus/groovy/control/CompilationUnitTest.java
@@ -0,0 +1,43 @@
+/*
+ * $Id$
+ *
+ * Copyright (c) 2005 The Codehaus - http://groovy.codehaus.org
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *
+ * See the License for the specific language governing permissions and limitations under the License.
+ *
+ */
+
+
+package org.codehaus.groovy.control;
+
+import java.util.Iterator;
+
+import org.jmock.Mock;
+import org.jmock.cglib.MockObjectTestCase;
+
+import groovy.lang.GroovyClassLoader;
+
+public class CompilationUnitTest extends MockObjectTestCase {
+
+    public void testAppendsTheClasspathOfTheCompilerConfigurationToCurrentClassLoaderWhenInstantiated() {
+        CompilerConfiguration configuration = new CompilerConfiguration();
+        configuration.setClasspath(System.getProperty("java.class.path"));
+        new CompilationUnit(configuration, null, createGroovyClassLoaderWithExpectations(configuration));
+    }
+
+    private GroovyClassLoader createGroovyClassLoaderWithExpectations(CompilerConfiguration configuration) {
+        Mock mockGroovyClassLoader = mock(GroovyClassLoader.class);
+        for (Iterator iterator = configuration.getClasspath().iterator(); iterator.hasNext();) {
+            mockGroovyClassLoader.expects(once()).method("addClasspath").with(eq(iterator.next()));
+        }
+        return (GroovyClassLoader) mockGroovyClassLoader.proxy();
+    }
+}
