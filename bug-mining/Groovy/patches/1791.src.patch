diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
index 0bb54d5b2b..1b7c023e32 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
@@ -734,7 +734,7 @@ public abstract class StaticTypeCheckingSupport {
             }
             ref = ref.getSuperClass();
             if (ref == null) dist += 2;
-            dist++;
+            dist = (dist+1)<<1;
         }
         return dist;
     }
@@ -877,7 +877,8 @@ public abstract class StaticTypeCheckingSupport {
         ClassNode actualReceiver;
         Collection<MethodNode> choicesLeft = removeCovariants(methods);
         for (MethodNode m : choicesLeft) {
-            actualReceiver = receiver!=null?receiver:m.getDeclaringClass();
+            final ClassNode declaringClass = m.getDeclaringClass();
+            actualReceiver = receiver!=null?receiver: declaringClass;
             // todo : corner case
             /*
                 class B extends A {}
@@ -893,7 +894,7 @@ public abstract class StaticTypeCheckingSupport {
             if (params.length > args.length && ! isVargs(params)) {
                 // GROOVY-5231
                 int dist = allParametersAndArgumentsMatchWithDefaultParams(params, args);
-                if (dist>=0 && !actualReceiver.equals(m.getDeclaringClass())) dist+=getDistance(actualReceiver, m.getDeclaringClass());
+                if (dist>=0 && !actualReceiver.equals(declaringClass)) dist+=getDistance(actualReceiver, declaringClass);
                 if (dist>=0 && dist<bestDist) {
                     bestChoices.clear();
                     bestChoices.add(m);
@@ -906,7 +907,7 @@ public abstract class StaticTypeCheckingSupport {
                 int lastArgMatch = isVargs(params)?lastArgMatchesVarg(params, args):-1;
                 if (lastArgMatch>=0) lastArgMatch++; // ensure exact matches are preferred over vargs
                 int dist = allPMatch>=0?Math.max(allPMatch, lastArgMatch):lastArgMatch;
-                if (dist>=0 && !actualReceiver.equals(m.getDeclaringClass())) dist+=getDistance(actualReceiver, m.getDeclaringClass());
+                if (dist>=0 && !actualReceiver.equals(declaringClass)) dist+=getDistance(actualReceiver, declaringClass);
                 if (dist>=0 && dist<bestDist) {
                     bestChoices.clear();
                     bestChoices.add(m);
@@ -936,7 +937,7 @@ public abstract class StaticTypeCheckingSupport {
                         //      that case is handled above already
                         // (3) there is more than one argument for the vargs array
                         int dist = excessArgumentsMatchesVargsParameter(params, args);
-                        if (dist >= 0 && !actualReceiver.equals(m.getDeclaringClass())) dist++;
+                        if (dist >= 0 && !actualReceiver.equals(declaringClass)) dist++;
                         // varargs methods must not be preferred to methods without varargs
                         // for example :
                         // int sum(int x) should be preferred to int sum(int x, int... y)
diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index f1ed226c6c..a3b5e95c65 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -1324,7 +1324,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                     storeTargetMethod(call, directMethodCallCandidate);
 
                 } else {
-                    addAmbiguousOrDynamicErrorMessage(mn, name, args, call);
+                    addAmbiguousErrorMessage(mn, name, args, call);
                 }
             }
         } finally {
@@ -1558,6 +1558,9 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 if (mn.isEmpty()) {
                     addStaticTypeError("Cannot find matching method " + receiver.getText() + "#" + toMethodParametersString(name, args), call);
                 } else {
+                    if (areCategoryMethodCalls(mn, name, args)) {
+                        addCategoryMethodCallError(call);
+                    }
                     if (mn.size() == 1) {
                         MethodNode directMethodCallCandidate = mn.get(0);
                         // visit the method to obtain inferred return type
@@ -1587,7 +1590,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                         }
 
                     } else {
-                        addAmbiguousOrDynamicErrorMessage(mn, name, args, call);
+                        addAmbiguousErrorMessage(mn, name, args, call);
                     }
                 }
             }
@@ -1957,15 +1960,28 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         final List<MethodNode> methods = findMethod(receiver, name, args);
         if (methods.isEmpty()) {
             addStaticTypeError("Cannot find matching method " + receiver.getText() + "#" + toMethodParametersString(name, args), expr);
-        } else if (methods.size() == 1) {
-            return methods.get(0);
         } else {
-            addAmbiguousOrDynamicErrorMessage(methods, name, args, expr);
+            if (areCategoryMethodCalls(methods, name, args)) {
+                addCategoryMethodCallError(expr);
+            }
+            if (methods.size() == 1) {
+                return methods.get(0);
+            } else {
+                addAmbiguousErrorMessage(methods, name, args, expr);
+            }
         }
         return null;
     }
 
-    private void addAmbiguousOrDynamicErrorMessage(final List<MethodNode> foundMethods, final String name, final ClassNode[] args, final Expression expr) {
+    private void addAmbiguousErrorMessage(final List<MethodNode> foundMethods, final String name, final ClassNode[] args, final Expression expr) {
+        addStaticTypeError("Reference to method is ambiguous. Cannot choose between " + foundMethods, expr);
+    }
+
+    private void addCategoryMethodCallError(final Expression call) {
+        addStaticTypeError("Due to their dynamic nature, usage of categories is not possible with static type checking active", call);
+    }
+
+    private boolean areCategoryMethodCalls(final List<MethodNode> foundMethods, final String name, final ClassNode[] args) {
         boolean category = false;
         if ("use".equals(name) && args!=null && args.length==2 && args[1].equals(ClassHelper.CLOSURE_TYPE)) {
             category = true;
@@ -1975,11 +1991,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 }
             }
         }
-        if (category) {
-            addStaticTypeError("Due to their dynamic nature, usage of categories is not possible with static type checking active", expr);
-        } else {
-            addStaticTypeError("Reference to method is ambiguous. Cannot choose between " + foundMethods, expr);
-        }
+        return category;
     }
 
     private List<MethodNode> findMethod(
diff --git a/src/test/groovy/transform/stc/MethodCallsSTCTest.groovy b/src/test/groovy/transform/stc/MethodCallsSTCTest.groovy
index f5f482eed0..a348e62b42 100644
--- a/src/test/groovy/transform/stc/MethodCallsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/MethodCallsSTCTest.groovy
@@ -571,6 +571,12 @@ class MethodCallsSTCTest extends StaticTypeCheckingTestCase {
         ''', 'Non static method A#instanceMethod cannot be called from static context'
     }
 
+    void testShouldNotBeAmbiguousCall() {
+        assertScript '''
+            (0..10).find { int x -> x < 5 }
+        '''
+    }
+
     static class MyMethodCallTestClass {
 
         static int mul(int... args) { args.toList().inject(1) { x,y -> x*y } }
