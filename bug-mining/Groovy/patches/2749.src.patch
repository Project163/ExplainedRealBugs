diff --git a/src/main/org/codehaus/groovy/ast/ModuleNode.java b/src/main/org/codehaus/groovy/ast/ModuleNode.java
index a61dbe23de..533d54d2ab 100644
--- a/src/main/org/codehaus/groovy/ast/ModuleNode.java
+++ b/src/main/org/codehaus/groovy/ast/ModuleNode.java
@@ -24,6 +24,7 @@ import org.codehaus.groovy.ast.expr.VariableExpression;
 import org.codehaus.groovy.ast.stmt.BlockStatement;
 import org.codehaus.groovy.ast.stmt.ExpressionStatement;
 import org.codehaus.groovy.ast.stmt.Statement;
+import org.codehaus.groovy.classgen.GeneratorContext;
 import org.codehaus.groovy.control.SourceUnit;
 import org.codehaus.groovy.runtime.InvokerHelper;
 import org.codehaus.groovy.transform.BaseScriptASTTransformation;
@@ -242,7 +243,7 @@ public class ModuleNode extends ASTNode implements Opcodes {
         if (getDescription() == null) {
             throw new RuntimeException("Cannot generate main(String[]) class for statements when we have no file description");
         }
-        name += extractClassFromFileDescription();
+        name += GeneratorContext.encodeAsValidClassName(extractClassFromFileDescription());
 
         ClassNode classNode;
         if (isPackageInfo()) {
diff --git a/src/main/org/codehaus/groovy/classgen/GeneratorContext.java b/src/main/org/codehaus/groovy/classgen/GeneratorContext.java
index 309fcfc40b..a41087de04 100644
--- a/src/main/org/codehaus/groovy/classgen/GeneratorContext.java
+++ b/src/main/org/codehaus/groovy/classgen/GeneratorContext.java
@@ -15,6 +15,7 @@
  */
 package org.codehaus.groovy.classgen;
 
+import org.codehaus.groovy.GroovyBugError;
 import org.codehaus.groovy.ast.ClassHelper;
 import org.codehaus.groovy.ast.ClassNode;
 import org.codehaus.groovy.ast.CompileUnit;
@@ -53,15 +54,58 @@ public class GeneratorContext {
     public String getNextClosureInnerName(ClassNode owner, ClassNode enclosingClass, MethodNode enclosingMethod) {
         String methodName = "";
         if (enclosingMethod != null) {
-            methodName = enclosingMethod.getName() + "_";
+            methodName = enclosingMethod.getName();
 
             if (enclosingClass.isDerivedFrom(ClassHelper.CLOSURE_TYPE)) {
                 methodName = "";
+            } else {
+                methodName = "_"+encodeAsValidClassName(methodName);
             }
-            methodName = methodName.replace('<', '_');
-            methodName = methodName.replace('>', '_');
-            methodName = methodName.replaceAll(" ", "_");
         }
-        return "_" + methodName + "closure" + closureClassIdx++;
+        return methodName + "_closure" + closureClassIdx++;
     }
-}
+
+
+    private static final int MIN_ENCODING = ' ';
+    private static final int MAX_ENCODING = ']';
+    private static final boolean[] CHARACTERS_TO_ENCODE = new boolean[MAX_ENCODING-MIN_ENCODING+1];
+    static {
+        CHARACTERS_TO_ENCODE[' '-MIN_ENCODING] = true;
+        CHARACTERS_TO_ENCODE['!'-MIN_ENCODING] = true;
+        CHARACTERS_TO_ENCODE['/'-MIN_ENCODING] = true;
+        CHARACTERS_TO_ENCODE['.'-MIN_ENCODING] = true;
+        CHARACTERS_TO_ENCODE[';'-MIN_ENCODING] = true;
+        CHARACTERS_TO_ENCODE['$'-MIN_ENCODING] = true;
+        CHARACTERS_TO_ENCODE['<'-MIN_ENCODING] = true;
+        CHARACTERS_TO_ENCODE['>'-MIN_ENCODING] = true;
+        CHARACTERS_TO_ENCODE['['-MIN_ENCODING] = true;
+        CHARACTERS_TO_ENCODE[']'-MIN_ENCODING] = true;
+        CHARACTERS_TO_ENCODE[':'-MIN_ENCODING] = true;
+        CHARACTERS_TO_ENCODE['\\'-MIN_ENCODING] = true;
+    }
+
+    public static String encodeAsValidClassName(String name) {
+        final int l = name.length();
+        StringBuilder b = null;
+        int lastEscape = -1;
+        for(int i = 0; i < l; ++i) {
+            final int encodeIndex = name.charAt(i) - MIN_ENCODING;
+            if (encodeIndex >= 0 && encodeIndex < CHARACTERS_TO_ENCODE.length) {
+                if (CHARACTERS_TO_ENCODE[encodeIndex]) {
+                    if(b == null) {
+                        b = new StringBuilder(name.length() + 3);
+                        b.append(name, 0, i);
+                    } else {
+                        b.append(name, lastEscape + 1, i);
+                    }
+                    b.append('_');
+                    lastEscape = i;
+                }
+            }
+        }
+        if(b == null) return name.toString();
+        if (lastEscape == -1) throw new GroovyBugError("unexpected escape char control flow in "+name);
+        b.append(name, lastEscape + 1, l);
+        return b.toString();
+    }
+}
\ No newline at end of file
diff --git a/src/main/org/codehaus/groovy/runtime/callsite/CallSiteGenerator.java b/src/main/org/codehaus/groovy/runtime/callsite/CallSiteGenerator.java
index 64064c806d..769acad34f 100644
--- a/src/main/org/codehaus/groovy/runtime/callsite/CallSiteGenerator.java
+++ b/src/main/org/codehaus/groovy/runtime/callsite/CallSiteGenerator.java
@@ -16,6 +16,7 @@
 package org.codehaus.groovy.runtime.callsite;
 
 import org.codehaus.groovy.ast.ClassHelper;
+import org.codehaus.groovy.classgen.GeneratorContext;
 import org.codehaus.groovy.classgen.asm.BytecodeHelper;
 import org.codehaus.groovy.reflection.CachedClass;
 import org.codehaus.groovy.reflection.CachedMethod;
@@ -244,7 +245,7 @@ public class CallSiteGenerator {
 
     public static boolean isCompilable (CachedMethod method) {
         return (GroovySunClassLoader.sunVM != null || Modifier.isPublic(method.cachedClass.getModifiers()) && method.isPublic() && publicParams(method))
-                && !AndroidSupport.isRunningAndroid();
+                && !AndroidSupport.isRunningAndroid() && containsOnlyValidChars(method.getName());
     }
 
     private static boolean publicParams(CachedMethod method) {
@@ -255,4 +256,11 @@ public class CallSiteGenerator {
         return true;
     }
 
+    private static boolean containsOnlyValidChars(String name) {
+        // TODO: this might not do enough or too much
+        // But it is a good start without spreading logic everywhere
+        String encoded = GeneratorContext.encodeAsValidClassName(name);
+        return encoded.equals(name);
+    }
+
 }
diff --git a/src/test/groovy/lang/ScriptTest.java b/src/test/groovy/lang/ScriptTest.java
index 327d01952a..5c953febb4 100644
--- a/src/test/groovy/lang/ScriptTest.java
+++ b/src/test/groovy/lang/ScriptTest.java
@@ -78,4 +78,12 @@ public class ScriptTest extends TestSupport {
         shell.evaluate(script);
     }
 
+    // GROOVY-6344
+    public void testScriptNameMangling() {
+        String script = "this.getClass().getName()";
+        GroovyShell shell = new GroovyShell();
+        String name = (String) shell.evaluate(script,"a!b");
+        assertEquals("a_b", name);
+    }
+
 }
diff --git a/src/test/org/codehaus/groovy/ClosureAndInnerClassNodeStructureTest.groovy b/src/test/org/codehaus/groovy/ClosureAndInnerClassNodeStructureTest.groovy
index 730794667e..b5aaafce71 100644
--- a/src/test/org/codehaus/groovy/ClosureAndInnerClassNodeStructureTest.groovy
+++ b/src/test/org/codehaus/groovy/ClosureAndInnerClassNodeStructureTest.groovy
@@ -81,4 +81,17 @@ class ClosureAndInnerClassNodeStructureTest extends GroovyTestCase {
             assert simpleNames == ['_foo_closure1', '_closure2']
         '''
     }
+
+    //GROOVY-7119 && GROOVY-7120
+    void testIrregularMethodName() {
+        assertScript '''
+            class X {
+                def 'foo!bar'() {
+                    return {}
+                }
+            }
+            def str = new X().'foo!bar'().getClass().getName()
+            assert str == 'X$_foo_bar_closure1'
+        '''
+    }
 }
