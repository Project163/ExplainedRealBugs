diff --git a/src/main/groovy/lang/Closure.java b/src/main/groovy/lang/Closure.java
index e5af09a29c..30fc86c65b 100644
--- a/src/main/groovy/lang/Closure.java
+++ b/src/main/groovy/lang/Closure.java
@@ -122,6 +122,9 @@ public abstract class Closure extends GroovyObjectSupport implements Cloneable {
                 return InvokerHelper.getProperty(aDelegate, property);
             }
             catch (GroovyRuntimeException e2) {
+//                System.out.println("Caught: " + e2);
+//                e2.printStackTrace();
+                
                 if (owner != aDelegate) {
                     try {
                         // lets try invoke method on delegate
@@ -129,6 +132,8 @@ public abstract class Closure extends GroovyObjectSupport implements Cloneable {
                     }
                     catch (GroovyRuntimeException e3) {
                         // ignore, we'll throw e
+//                        System.out.println("Caught: " + e3);
+//                        e3.printStackTrace();
                     }
                 }
             }
diff --git a/src/main/groovy/lang/Reference.java b/src/main/groovy/lang/Reference.java
index 0555476fe3..499b5d453e 100644
--- a/src/main/groovy/lang/Reference.java
+++ b/src/main/groovy/lang/Reference.java
@@ -65,6 +65,7 @@ public class Reference extends GroovyObjectSupport {
     }
 
     public Object getProperty(String property) {
+        Object value = get();
         if (value != null) {
             return InvokerHelper.getProperty(value, property);
         }
@@ -72,6 +73,7 @@ public class Reference extends GroovyObjectSupport {
     }
 
     public void setProperty(String property, Object newValue) {
+        Object value = get();
         if (value != null) {
             InvokerHelper.setProperty(value, property, newValue);
         }
@@ -81,6 +83,7 @@ public class Reference extends GroovyObjectSupport {
     }
 
     public Object invokeMethod(String name, Object args) {
+        Object value = get();
         if (value != null) {
             try {
                 return InvokerHelper.invokeMethod(value, name, args);
diff --git a/src/main/groovy/xml/MarkupBuilder.java b/src/main/groovy/xml/MarkupBuilder.java
index 17ec1602a3..258eba6690 100644
--- a/src/main/groovy/xml/MarkupBuilder.java
+++ b/src/main/groovy/xml/MarkupBuilder.java
@@ -80,6 +80,7 @@ public class MarkupBuilder extends BuilderSupport {
     protected void setParent(Object parent, Object child) {
     }
 
+    /*
     public Object getProperty(String property) {
         if (property.equals("_")) {
             nospace = true;
@@ -90,6 +91,7 @@ public class MarkupBuilder extends BuilderSupport {
             return node;
         }
     }
+    */
 
     protected Object createNode(Object name) {
         toState(1, name);
diff --git a/src/main/org/codehaus/groovy/ast/ClassNode.java b/src/main/org/codehaus/groovy/ast/ClassNode.java
index 4b09b5e7c0..35a158da10 100644
--- a/src/main/org/codehaus/groovy/ast/ClassNode.java
+++ b/src/main/org/codehaus/groovy/ast/ClassNode.java
@@ -660,4 +660,8 @@ public class ClassNode extends MetadataNode implements Constants {
         this.script = script;
     }
 
-}
+    public String toString() {
+        return super.toString() + "[name: " + name + "]";
+    }
+
+   }
diff --git a/src/main/org/codehaus/groovy/ast/CodeVisitorSupport.java b/src/main/org/codehaus/groovy/ast/CodeVisitorSupport.java
index 7957ce36ca..51e84839be 100644
--- a/src/main/org/codehaus/groovy/ast/CodeVisitorSupport.java
+++ b/src/main/org/codehaus/groovy/ast/CodeVisitorSupport.java
@@ -272,6 +272,7 @@ public abstract class CodeVisitorSupport implements GroovyCodeVisitor {
     }
 
     public void visitPropertyExpression(PropertyExpression expression) {
+        expression.getObjectExpression().visit(this);
     }
 
     public void visitFieldExpression(FieldExpression expression) {
diff --git a/src/main/org/codehaus/groovy/ast/ConstructorNode.java b/src/main/org/codehaus/groovy/ast/ConstructorNode.java
index 0d191fe281..07172f187a 100644
--- a/src/main/org/codehaus/groovy/ast/ConstructorNode.java
+++ b/src/main/org/codehaus/groovy/ast/ConstructorNode.java
@@ -59,6 +59,7 @@ public class ConstructorNode extends MetadataNode {
     private int modifiers;
     private Parameter[] parameters;   
     private Statement code;
+    private VariableScope variableScope;
     
     public ConstructorNode(int modifiers, Statement code) {
         this(modifiers, Parameter.EMPTY_ARRAY, code);
@@ -86,4 +87,12 @@ public class ConstructorNode extends MetadataNode {
         return parameters;
     }
 
+    public VariableScope getVariableScope() {
+        return variableScope;
+    }
+
+    public void setVariableScope(VariableScope variableScope) {
+        this.variableScope = variableScope;
+    }
+    
 }
diff --git a/src/main/org/codehaus/groovy/ast/MethodNode.java b/src/main/org/codehaus/groovy/ast/MethodNode.java
index cbb7c44864..21a5f25dae 100644
--- a/src/main/org/codehaus/groovy/ast/MethodNode.java
+++ b/src/main/org/codehaus/groovy/ast/MethodNode.java
@@ -62,6 +62,7 @@ public class MethodNode extends MetadataNode implements Constants {
     private Parameter[] parameters;
     private Statement code;
     private boolean dynamicReturnType;
+    private VariableScope variableScope;
 
     public MethodNode(String name, int modifiers, String returnType, Parameter[] parameters, Statement code) {
         this.name = name;
@@ -107,6 +108,14 @@ public class MethodNode extends MetadataNode implements Constants {
         return returnType;
     }
 
+    public VariableScope getVariableScope() {
+        return variableScope;
+    }
+
+    public void setVariableScope(VariableScope variableScope) {
+        this.variableScope = variableScope;
+    }
+
     public boolean isDynamicReturnType() {
         return dynamicReturnType;
     }
@@ -114,4 +123,9 @@ public class MethodNode extends MetadataNode implements Constants {
     public boolean isStatic() {
         return (modifiers & ACC_STATIC) != 0;
     }
+    
+    public String toString() {
+        return super.toString() + "[name: " + name + "]";
+    }
+
 }
diff --git a/src/main/org/codehaus/groovy/ast/VariableScope.java b/src/main/org/codehaus/groovy/ast/VariableScope.java
new file mode 100644
index 0000000000..7e7a604e05
--- /dev/null
+++ b/src/main/org/codehaus/groovy/ast/VariableScope.java
@@ -0,0 +1,159 @@
+/*
+ $Id$
+
+ Copyright 2003 (C) James Strachan and Bob Mcwhirter. All Rights Reserved.
+
+ Redistribution and use of this software and associated documentation
+ ("Software"), with or without modification, are permitted provided
+ that the following conditions are met:
+
+ 1. Redistributions of source code must retain copyright
+    statements and notices.  Redistributions must also contain a
+    copy of this document.
+
+ 2. Redistributions in binary form must reproduce the
+    above copyright notice, this list of conditions and the
+    following disclaimer in the documentation and/or other
+    materials provided with the distribution.
+
+ 3. The name "groovy" must not be used to endorse or promote
+    products derived from this Software without prior written
+    permission of The Codehaus.  For written permission,
+    please contact info@codehaus.org.
+
+ 4. Products derived from this Software may not be called "groovy"
+    nor may "groovy" appear in their names without prior written
+    permission of The Codehaus. "groovy" is a registered
+    trademark of The Codehaus.
+
+ 5. Due credit should be given to The Codehaus -
+    http://groovy.codehaus.org/
+
+ THIS SOFTWARE IS PROVIDED BY THE CODEHAUS AND CONTRIBUTORS
+ ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ THE CODEHAUS OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ OF THE POSSIBILITY OF SUCH DAMAGE.
+
+ */
+package org.codehaus.groovy.ast;
+
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Set;
+
+/**
+ * Represents a variable scope. This is primarily used to determine variable sharing
+ * across method and closure boundaries.
+ * 
+ * @author <a href="mailto:james@coredevelopers.net">James Strachan</a>
+ * @version $Revision$
+ */
+public class VariableScope  {
+
+    private Set declaredVariables = new HashSet();
+    private Set referencedVariables = new HashSet();
+    private VariableScope parent;
+    private List children = new ArrayList();
+
+    public VariableScope() {
+    }
+
+    public VariableScope(VariableScope parent) {
+        this.parent = parent;
+        parent.children.add(this);
+    }
+
+    public Set getDeclaredVariables() {
+        return declaredVariables;
+    }
+
+    public Set getReferencedVariables() {
+        return referencedVariables;
+    }
+ 
+    /**
+     * @return all the child scopes
+     */
+    public List getChildren() {
+        return children;
+    }
+
+    /**
+     * Creates a composite variable scope combining all the variable references
+     * and declarations from all the child scopes not including this scope
+     * 
+     * @return
+     */
+    public VariableScope createCompositeChildScope() {
+        VariableScope answer = new VariableScope();
+        for (Iterator iter = children.iterator(); iter.hasNext(); ) {
+            answer.appendRecursive((VariableScope) iter.next());
+        }
+        answer.parent = this;
+        return answer;
+    }
+
+    /**
+     * Creates a scope including this scope and all nested scopes combined together
+     * 
+     * @return
+     */
+    public VariableScope createRecursiveChildScope() {
+        VariableScope answer = createCompositeChildScope();
+        answer.referencedVariables.addAll(referencedVariables);
+        answer.declaredVariables.addAll(declaredVariables);
+        return answer;
+    }
+
+    /**
+     * Creates a scope including this scope and all parent scopes combined together
+     * 
+     * @return
+     */
+    public VariableScope createRecursiveParentScope() {
+        VariableScope answer = new VariableScope();
+        VariableScope node = this;
+        do { 
+            answer.append(node);
+            node = node.parent;
+        }
+        while (node != null);
+        return answer;
+    }
+
+    /**
+     * Appends all of the references and declarations from the given scope
+     * to this one
+     * 
+     * @param scope
+     */
+    protected void append(VariableScope scope) {
+        referencedVariables.addAll(scope.referencedVariables);
+        declaredVariables.addAll(scope.declaredVariables);
+    }
+    
+    /**
+     * Appends all of the references and declarations from the given scope
+     * and all its children to this one
+     * 
+     * @param scope
+     */
+    protected void appendRecursive(VariableScope scope) {
+        append(scope);
+        
+        // now lets traverse the children
+        for (Iterator iter = scope.children.iterator(); iter.hasNext(); ) {
+            appendRecursive((VariableScope) iter.next());
+        }
+     }
+}
diff --git a/src/main/org/codehaus/groovy/ast/expr/ClosureExpression.java b/src/main/org/codehaus/groovy/ast/expr/ClosureExpression.java
index 65b3dd8a57..9aaf52d517 100644
--- a/src/main/org/codehaus/groovy/ast/expr/ClosureExpression.java
+++ b/src/main/org/codehaus/groovy/ast/expr/ClosureExpression.java
@@ -47,7 +47,8 @@ package org.codehaus.groovy.ast.expr;
 
 import org.codehaus.groovy.ast.GroovyCodeVisitor;
 import org.codehaus.groovy.ast.Parameter;
-import org.codehaus.groovy.ast.stmt.*;
+import org.codehaus.groovy.ast.VariableScope;
+import org.codehaus.groovy.ast.stmt.Statement;
 import org.codehaus.groovy.runtime.InvokerHelper;
 
 
@@ -62,6 +63,7 @@ public class ClosureExpression extends Expression {
     
     private Parameter[] parameters;
     private Statement code;
+    private VariableScope variableScope;
     
     public ClosureExpression(Parameter[] parameters, Statement code) {
         this.parameters = parameters;
@@ -91,4 +93,13 @@ public class ClosureExpression extends Expression {
     public boolean isParameterSpecified() {
         return parameters != null && parameters.length > 0;
     }
+    
+    public VariableScope getVariableScope() {
+        return variableScope;
+    }
+
+    public void setVariableScope(VariableScope variableScope) {
+        this.variableScope = variableScope;
+    }
+
 }
diff --git a/src/main/org/codehaus/groovy/classgen/ClassGenerator.java b/src/main/org/codehaus/groovy/classgen/ClassGenerator.java
index 3b53448ec2..ac99f6f79a 100644
--- a/src/main/org/codehaus/groovy/classgen/ClassGenerator.java
+++ b/src/main/org/codehaus/groovy/classgen/ClassGenerator.java
@@ -62,6 +62,7 @@ import org.codehaus.groovy.ast.MethodNode;
 import org.codehaus.groovy.ast.Parameter;
 import org.codehaus.groovy.ast.PropertyNode;
 import org.codehaus.groovy.ast.Type;
+import org.codehaus.groovy.ast.VariableScope;
 import org.codehaus.groovy.ast.expr.ArgumentListExpression;
 import org.codehaus.groovy.ast.expr.ArrayExpression;
 import org.codehaus.groovy.ast.expr.BinaryExpression;
@@ -212,6 +213,8 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
     private BlockScope scope;
     private BytecodeHelper helper = new BytecodeHelper(null);
 
+    private VariableScope variableScope;
+
     public ClassGenerator(
         GeneratorContext context,
         ClassVisitor classVisitor,
@@ -276,11 +279,13 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
 
         this.constructorNode = node;
         this.methodNode = null;
+        this.variableScope = null;
 
         String methodType = helper.getMethodDescriptor("void", node.getParameters());
         cv = cw.visitMethod(node.getModifiers(), "<init>", methodType, null, null);
         helper = new BytecodeHelper(cv);
 
+        findMutableVariables();
         resetVariableStack(node.getParameters());
 
         Statement code = node.getCode();
@@ -302,13 +307,13 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
         // return type: " + node.getReturnType());
         this.constructorNode = null;
         this.methodNode = node;
+        this.variableScope = null;
 
         String methodType = helper.getMethodDescriptor(node.getReturnType(), node.getParameters());
         cv = cw.visitMethod(node.getModifiers(), node.getName(), methodType, null, null);
         helper = new BytecodeHelper(cv);
 
-        findMutableVariables(node);
-
+        findMutableVariables();
         resetVariableStack(node.getParameters());
 
         outputReturn = false;
@@ -1058,7 +1063,6 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
         ConstructorNode node = (ConstructorNode) constructors.get(0);
         Parameter[] localVariableParams = node.getParameters();
 
-        //Parameter[] localVariableParams = getClosureSharedVariables(expression);
         for (int i = 2; i < localVariableParams.length; i++) {
             Parameter param = localVariableParams[i];
             String name = param.getName();
@@ -1586,7 +1590,19 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
                         variable.setProperty(true);
                     }
                     //variable = defineVariable(name, variableType, false);
-                    visitPropertyExpression(new PropertyExpression(VariableExpression.THIS_EXPRESSION, name));
+                    if (variable.isHolder() && passingClosureParams && useProperty) {
+                        // lets create a ScriptReference to pass into the closure
+                        cv.visitTypeInsn(NEW, "org/codehaus/groovy/runtime/ScriptReference");
+                        cv.visitInsn(DUP);
+                        
+                        cv.visitVarInsn(ALOAD, 0);
+                        cv.visitLdcInsn(name);
+                        
+                        cv.visitMethodInsn(INVOKESPECIAL, "org/codehaus/groovy/runtime/ScriptReference", "<init>", "(Lgroovy/lang/Script;Ljava/lang/String;)V");
+                    }
+                    else {
+                        visitPropertyExpression(new PropertyExpression(VariableExpression.THIS_EXPRESSION, name));
+                    }
                     // We need to store this in a local variable now since it
                     // has been looked at in this scope and possibly
                     // compared and it hasn't been referenced before.
@@ -1602,6 +1618,8 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
                 if (leftHandExpression) {
                     if (holder) {
                         int tempIndex = defineVariable(createVariableName("reference"), variableType, false).getIndex();
+                        
+                        
                         cv.visitVarInsn(ASTORE, tempIndex);
 
                         cv.visitVarInsn(ALOAD, index);
@@ -1952,7 +1970,15 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
         if (isInScriptBody()) {
             answer.setScriptBody(true);
         }
-        answer.addMethod("doCall", ACC_PUBLIC, "java.lang.Object", parameters, expression.getCode());
+        MethodNode method =
+            answer.addMethod("doCall", ACC_PUBLIC, "java.lang.Object", parameters, expression.getCode());
+        VariableScope scope = expression.getVariableScope();
+        if (scope == null) {
+            throw new RuntimeException("Must have a VariableScope by now! for expression: " + expression + " class: " + name);
+        }
+        else {
+            method.setVariableScope(scope);
+        }
         if (parameters.length > 1
             || (parameters.length == 1
                 && parameters[0].getType() != null
@@ -2492,17 +2518,61 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
         scope = new BlockScope(scope);
     }
 
+    protected VariableScope getVariableScope() {
+        if (variableScope == null) {
+            if (methodNode != null) {
+                // if we're a closure method we'll have our variable scope already created
+                variableScope = methodNode.getVariableScope();
+                if (variableScope == null) {
+                    variableScope = new VariableScope();
+                    methodNode.setVariableScope(variableScope);
+                    VariableScopeCodeVisitor visitor = new VariableScopeCodeVisitor(variableScope);
+                    visitor.setParameters(methodNode.getParameters());
+                    Statement code = methodNode.getCode();
+                    if (code != null) {
+                        code.visit(visitor);
+                    }
+                }
+            }
+            else if (constructorNode != null) {
+                variableScope = new VariableScope();
+                constructorNode.setVariableScope(variableScope);
+                VariableScopeCodeVisitor visitor = new VariableScopeCodeVisitor(variableScope);
+                visitor.setParameters(constructorNode.getParameters());
+                Statement code = constructorNode.getCode();
+                if (code != null) {
+                    code.visit(visitor);
+                }
+            }
+            else {
+                throw new RuntimeException("Can't create a variable scope outside of a method or constructor");
+            }
+            addFieldsToVisitor(variableScope);
+        }
+        return variableScope;
+    }
+
     /**
      * @return a list of parameters for each local variable which needs to be
      *         passed into a closure
      */
     protected Parameter[] getClosureSharedVariables(ClosureExpression expression) {
         List vars = new ArrayList();
-        if (!isInScriptBody()) {
-            VariableScopeCodeVisitor outerVisitor = new VariableScopeCodeVisitor(true);
-            VariableScopeCodeVisitor innerVisitor = new VariableScopeCodeVisitor();
-
+        //if (!isInScriptBody()) {
+            VariableScope outerScope = getVariableScope().createRecursiveParentScope();
+            VariableScope innerScope = expression.getVariableScope();
+            if (innerScope == null) {
+                System.out.println("No variable scope for: " + expression + " method: " + methodNode + " constructor: " + constructorNode);
+                innerScope = new VariableScope(getVariableScope());
+            }
+            else {
+                innerScope = innerScope.createRecursiveChildScope();
+            }
+            
+            //Set parameterSet = getParameterNameSet();
+            /*
             if (methodNode != null) {
+                
                 // we must be in a property
                 outerVisitor.setParameters(methodNode.getParameters());
                 methodNode.getCode().visit(outerVisitor);
@@ -2512,19 +2582,23 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
             }
             expression.getCode().visit(innerVisitor);
             addFieldsToVisitor(outerVisitor);
+            */
 
             // now any variables declared in the outer context that are referred to
             // in the inner context need to be copied
-            Set outerDecls = outerVisitor.getDeclaredVariables();
+            Set outerDecls = outerScope.getDeclaredVariables();
+
+            /*
             outerDecls.addAll(outerVisitor.getParameterSet());
-            Set outerRefs = outerVisitor.getReferencedVariables();
-            Set innerDecls = innerVisitor.getDeclaredVariables();
-            Set innerRefs = innerVisitor.getReferencedVariables();
+            */
+            Set outerRefs = outerScope.getReferencedVariables();
+            Set innerDecls = innerScope.getDeclaredVariables();
+            Set innerRefs = innerScope.getReferencedVariables();
 
             Set varSet = new HashSet();
             for (Iterator iter = innerRefs.iterator(); iter.hasNext();) {
                 String var = (String) iter.next();
-                if (outerDecls.contains(var) && (classNode.getField(var) == null || isInnerClass())) {
+                if (outerDecls.contains(var) && (classNode.getField(var) == null /*|| isInnerClass()*/)) {
                     String type = getVariableType(var);
                     vars.add(new Parameter(type, var));
                     varSet.add(var);
@@ -2533,33 +2607,36 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
             for (Iterator iter = outerRefs.iterator(); iter.hasNext();) {
                 String var = (String) iter.next();
                 if (innerDecls.contains(var)
-                    && (classNode.getField(var) == null || isInnerClass())
+                    && (classNode.getField(var) == null /* || isInnerClass()*/)
                     && !varSet.contains(var)) {
                     String type = getVariableType(var);
                     vars.add(new Parameter(type, var));
                 }
             }
-        }
+        //}
         Parameter[] answer = new Parameter[vars.size()];
         vars.toArray(answer);
         return answer;
     }
 
-    private boolean isInnerClass() {
-        return classNode instanceof InnerClassNode;
-    }
-
-    protected void findMutableVariables(MethodNode node) {
+    protected void findMutableVariables() {
+        /*
         VariableScopeCodeVisitor outerVisitor = new VariableScopeCodeVisitor(true);
         node.getCode().visit(outerVisitor);
-
+        
         addFieldsToVisitor(outerVisitor);
-
+        
         VariableScopeCodeVisitor innerVisitor = outerVisitor.getClosureVisitor();
-        Set outerDecls = outerVisitor.getDeclaredVariables();
-        Set outerRefs = outerVisitor.getReferencedVariables();
-        Set innerDecls = innerVisitor.getDeclaredVariables();
-        Set innerRefs = innerVisitor.getReferencedVariables();
+        */
+        VariableScope outerScope = getVariableScope();
+
+        // lets create a scope concatenating all the closure expressions
+        VariableScope innerScope = outerScope.createCompositeChildScope();
+
+        Set outerDecls = outerScope.getDeclaredVariables();
+        Set outerRefs = outerScope.getReferencedVariables();
+        Set innerDecls = innerScope.getDeclaredVariables();
+        Set innerRefs = innerScope.getReferencedVariables();
 
         mutableVars.clear();
 
@@ -2578,18 +2655,30 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
                 mutableVars.add(var);
             }
         }
+
+//                System.out.println();
+//                System.out.println("method: " + methodNode + " classNode: " + classNode);
+//                System.out.println("child scopes: " + outerScope.getChildren());
+//                System.out.println("outerDecls: " + outerDecls);
+//                System.out.println("outerRefs: " + outerRefs);
+//                System.out.println("innerDecls: " + innerDecls);
+//                System.out.println("innerRefs: " + innerRefs);
     }
 
-    protected void addFieldsToVisitor(VariableScopeCodeVisitor visitor) {
+    protected void addFieldsToVisitor(VariableScope scope) {
         for (Iterator iter = classNode.getFields().iterator(); iter.hasNext();) {
             FieldNode field = (FieldNode) iter.next();
             String name = field.getName();
 
-            visitor.getDeclaredVariables().add(name);
-            visitor.getReferencedVariables().add(name);
+            scope.getDeclaredVariables().add(name);
+            scope.getReferencedVariables().add(name);
         }
     }
 
+    private boolean isInnerClass() {
+        return classNode instanceof InnerClassNode;
+    }
+
     protected String getVariableType(String name) {
         Variable variable = (Variable) variableStack.get(name);
         if (variable != null) {
@@ -2598,13 +2687,6 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
         return null;
     }
 
-    /**
-     * @return the last ID used by the stack
-     */
-    protected int getLastStackId() {
-        return variableStack.size();
-    }
-
     protected void resetVariableStack(Parameter[] parameters) {
         idx = 0;
         variableStack.clear();
@@ -2652,7 +2734,7 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
                 else {
                     // using new variable inside a comparison expression
                     // so lets initialize it too
-                    if (answer.isHolder()) {
+                    if (answer.isHolder() && !isInScriptBody()) {
                         //cv.visitVarInsn(ASTORE, idx + 1);
 
                         cv.visitTypeInsn(NEW, "groovy/lang/Reference");
diff --git a/src/main/org/codehaus/groovy/classgen/VariableScopeCodeVisitor.java b/src/main/org/codehaus/groovy/classgen/VariableScopeCodeVisitor.java
index 6bece36ba1..6496abaeae 100644
--- a/src/main/org/codehaus/groovy/classgen/VariableScopeCodeVisitor.java
+++ b/src/main/org/codehaus/groovy/classgen/VariableScopeCodeVisitor.java
@@ -45,11 +45,11 @@
  */
 package org.codehaus.groovy.classgen;
 
-import java.util.HashSet;
 import java.util.Set;
 
 import org.codehaus.groovy.ast.CodeVisitorSupport;
 import org.codehaus.groovy.ast.Parameter;
+import org.codehaus.groovy.ast.VariableScope;
 import org.codehaus.groovy.ast.expr.BinaryExpression;
 import org.codehaus.groovy.ast.expr.ClosureExpression;
 import org.codehaus.groovy.ast.expr.Expression;
@@ -67,41 +67,21 @@ import org.codehaus.groovy.ast.stmt.ForStatement;
  */
 public class VariableScopeCodeVisitor extends CodeVisitorSupport {
 
-    private Set declaredVariables = new HashSet();
-    private Set referencedVariables = new HashSet();
-    private VariableScopeCodeVisitor closureVisitor;
-    private Set parameterSet = new HashSet();
-    private boolean outer;
+    private VariableScope scope;
 
-    public VariableScopeCodeVisitor() {
-    }
-
-    public VariableScopeCodeVisitor(boolean outer) {
-        this.outer = outer;
-    }
-
-    public Set getDeclaredVariables() {
-        return declaredVariables;
+    public VariableScopeCodeVisitor(VariableScope scope) {
+        this.scope = scope;
     }
 
     public Set getReferencedVariables() {
-        return referencedVariables;
+        return scope.getReferencedVariables();
     }
 
-    public Set getParameterSet() {
-        return parameterSet;
-    }
-
-    public VariableScopeCodeVisitor getClosureVisitor() {
-        if (closureVisitor == null) {
-            closureVisitor = new VariableScopeCodeVisitor();
-        }
-        return closureVisitor;
+    public Set getDeclaredVariables() {
+        return scope.getDeclaredVariables();
     }
 
-    public boolean isOuter() {
-        return outer;
-    }
+    
 
     public void visitBinaryExpression(BinaryExpression expression) {
         Expression leftExpression = expression.getLeftExpression();
@@ -121,13 +101,8 @@ public class VariableScopeCodeVisitor extends CodeVisitorSupport {
     }
 
     public void visitClosureExpression(ClosureExpression expression) {
-        VariableScopeCodeVisitor visitor = getClosureVisitor();
-        visitor.setParameters(expression.getParameters());
+        VariableScopeCodeVisitor visitor = createClosureVisitor(expression);
         expression.getCode().visit(visitor);
-        if (! outer) {
-            referencedVariables.addAll(visitor.referencedVariables);
-            declaredVariables.addAll(visitor.declaredVariables);
-        }
     }
     
     public void visitVariableExpression(VariableExpression expression) {
@@ -138,9 +113,10 @@ public class VariableScopeCodeVisitor extends CodeVisitorSupport {
             referencedVariables.add(variable);
         }
         */
-        referencedVariables.add(variable);
+        getReferencedVariables().add(variable);
     }
 
+
     public void visitPostfixExpression(PostfixExpression expression) {
         Expression exp = expression.getExpression();
         if (exp instanceof VariableExpression) {
@@ -163,16 +139,22 @@ public class VariableScopeCodeVisitor extends CodeVisitorSupport {
 
     public void visitMethodCallExpression(MethodCallExpression call) {
         if (call.isImplicitThis()) {
-            referencedVariables.add(call.getMethod());
+            getReferencedVariables().add(call.getMethod());
         }
         super.visitMethodCallExpression(call);
     }
 
     protected void setParameters(Parameter[] parameters) {
+        /*
         parameterSet.clear();
         for (int i = 0; i < parameters.length; i++) {
             parameterSet.add(parameters[i].getName());
         }
+        */
+        
+        for (int i = 0; i < parameters.length; i++) {
+            declareVariable(parameters[i].getName());
+        }
     }
 
     protected void declareVariable(VariableExpression varExp) {
@@ -184,11 +166,18 @@ public class VariableScopeCodeVisitor extends CodeVisitorSupport {
         /*
         if (!parameterSet.contains(variable)) {
             declaredVariables.add(variable);
-            referencedVariables.add(variable);
+            getReferencedVariables().add(variable);
         }
         */
-        declaredVariables.add(variable);
-        referencedVariables.add(variable);
+        getDeclaredVariables().add(variable);
+        getReferencedVariables().add(variable);
     }
 
+    protected VariableScopeCodeVisitor createClosureVisitor(ClosureExpression expression) {
+        VariableScope closureScope = new VariableScope(scope);
+        expression.setVariableScope(closureScope);
+        VariableScopeCodeVisitor answer = new VariableScopeCodeVisitor(closureScope);
+        answer.setParameters(expression.getParameters());
+        return answer;
+    }
 }
diff --git a/src/main/org/codehaus/groovy/runtime/ScriptReference.java b/src/main/org/codehaus/groovy/runtime/ScriptReference.java
new file mode 100644
index 0000000000..d36ab7aac4
--- /dev/null
+++ b/src/main/org/codehaus/groovy/runtime/ScriptReference.java
@@ -0,0 +1,74 @@
+/*
+ $Id$
+
+ Copyright 2003 (C) James Strachan and Bob Mcwhirter. All Rights Reserved.
+
+ Redistribution and use of this software and associated documentation
+ ("Software"), with or without modification, are permitted provided
+ that the following conditions are met:
+
+ 1. Redistributions of source code must retain copyright
+    statements and notices.  Redistributions must also contain a
+    copy of this document.
+
+ 2. Redistributions in binary form must reproduce the
+    above copyright notice, this list of conditions and the
+    following disclaimer in the documentation and/or other
+    materials provided with the distribution.
+
+ 3. The name "groovy" must not be used to endorse or promote
+    products derived from this Software without prior written
+    permission of The Codehaus.  For written permission,
+    please contact info@codehaus.org.
+
+ 4. Products derived from this Software may not be called "groovy"
+    nor may "groovy" appear in their names without prior written
+    permission of The Codehaus. "groovy" is a registered
+    trademark of The Codehaus.
+
+ 5. Due credit should be given to The Codehaus -
+    http://groovy.codehaus.org/
+
+ THIS SOFTWARE IS PROVIDED BY THE CODEHAUS AND CONTRIBUTORS
+ ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ THE CODEHAUS OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ OF THE POSSIBILITY OF SUCH DAMAGE.
+
+ */
+package org.codehaus.groovy.runtime;
+
+import groovy.lang.Reference;
+import groovy.lang.Script;
+
+/**
+ * Represents a reference to a variable in a script
+ * 
+ * @author <a href="mailto:james@coredevelopers.net">James Strachan</a>
+ * @version $Revision$
+ */
+public class ScriptReference extends Reference {
+
+    private Script script;
+    private String variable;
+
+    public ScriptReference(Script script, String variable) {
+        this.script = script;
+        this.variable = variable;
+    }
+
+    public Object get() {
+        return script.getBinding().getVariable(variable);
+    }
+
+    public void set(Object value) {
+        script.getBinding().setVariable(variable, value);
+    }
+}
diff --git a/src/test/groovy/bugs/ClosureParameterPassingBug.groovy b/src/test/groovy/bugs/ClosureParameterPassingBug.groovy
index 078852278a..60a92eaae2 100644
--- a/src/test/groovy/bugs/ClosureParameterPassingBug.groovy
+++ b/src/test/groovy/bugs/ClosureParameterPassingBug.groovy
@@ -7,6 +7,7 @@ class ClosureParameterPassingBug extends GroovyTestCase {
     void testBug() {
 		c = { x | 
 			c1 = { 
+				println x
 				println x[0] 
 			} 
 			
@@ -17,7 +18,6 @@ class ClosureParameterPassingBug extends GroovyTestCase {
     }
     
     
-/** @todo this reproduces John's bug...
     void testBugInScript() {
     	assertScript <<<EOF
 c = { x | 
@@ -32,6 +32,5 @@ c = { x |
 c([1]) 
 EOF    	
 	}
-*/
    
 }
\ No newline at end of file
diff --git a/src/test/groovy/bugs/Groovy239_Bug.groovy b/src/test/groovy/bugs/Groovy239_Bug.groovy
new file mode 100644
index 0000000000..091a0c487b
--- /dev/null
+++ b/src/test/groovy/bugs/Groovy239_Bug.groovy
@@ -0,0 +1,29 @@
+/**
+ * @author John Wilson
+ * @version $Revision$
+ */
+class Groovy239_Bug extends GroovyTestCase {
+    
+    void testBug() {
+		a = { it() }
+		b = { it() }
+		c = { it() }
+		
+		a.call() {
+			b.call() {
+				c.call() {
+				}
+			}
+		}
+		
+		/** @todo fixme!
+		a() {
+			b() {
+				c() {
+				}
+			}
+		}
+		*/
+	}
+   
+}
\ No newline at end of file
diff --git a/src/test/groovy/bugs/NestedClosure2Bug.groovy b/src/test/groovy/bugs/NestedClosure2Bug.groovy
new file mode 100644
index 0000000000..0148f58f07
--- /dev/null
+++ b/src/test/groovy/bugs/NestedClosure2Bug.groovy
@@ -0,0 +1,44 @@
+import org.codehaus.groovy.classgen.TestSupport
+
+/**
+ * @version $Revision$
+ */
+class NestedClosure2Bug extends TestSupport {
+     
+    void testBugOutsideOfScript() {
+    	a = 123
+    	b = 456
+    	closure = { 
+    		println b
+    		return {
+    			return { 
+    				return a
+    			}
+    		}
+    	}
+    	c2 = closure()
+    	c3 = c2()
+    	value = c3()
+    	
+    	assert value == 123
+    }
+    
+    void testBug() {
+    	assertScript """
+	    	a = 123
+	    	closure = { 
+	    		return {
+	    			return { 
+	    				return a
+	    			}
+	    		}
+	    	}
+	    	c2 = closure()
+	    	c3 = c2()
+	    	value = c3()
+	    	
+	    	assert value == 123
+"""
+	}
+		
+}
\ No newline at end of file
diff --git a/src/test/groovy/bugs/TedsClosureBug.groovy b/src/test/groovy/bugs/TedsClosureBug.groovy
new file mode 100644
index 0000000000..6e3f84924e
--- /dev/null
+++ b/src/test/groovy/bugs/TedsClosureBug.groovy
@@ -0,0 +1,74 @@
+import groovy.xml.MarkupBuilder
+
+
+/**
+ * @author Ted Leung
+ * @version $Revision$
+ */
+class TedsClosureBug extends GroovyTestCase {
+    
+    void testBug() {
+		f = new Feed()
+		
+		f.author = new Person(name:'Ted Leung',url:'http://www.sauria.com/blog', email:'twl@sauria.com')
+		
+		f.entries = [ new Entry(title:'one',summary:'first post'), new Entry(title:'two',summary:'the second post'), new Entry(title:'three', summary:'post the third'), new Entry(title:'four',summary:'the ponderous fourth post') ]
+		
+		//f.entries.each { println it.title }
+		
+		println f.author.name
+		
+		xml = new MarkupBuilder()
+		
+		a = xml.atom() {
+		  title("Ted Leung off the air")
+		  link("http://www.sauria.com/noblog")
+		  author() {
+		    person() {
+		      name(f.author.name)
+		      url(f.author.url)
+		      email(f.author.email)
+		    }
+		  }
+		  
+		  /** @todo fixme! 
+		  for (e in f.entries) {
+		    entry() {
+		      title(e.title())
+		      summary(e.summary())
+		    }
+		  }
+		  */
+		}
+	}   
+}
+
+
+class Feed {
+    String title
+    String link
+    Person author
+    String tagline
+    String generator
+    String copyright
+    String modified
+    List entries
+}
+
+class Entry {
+    String title
+    String link
+    String id
+    String summary
+    String content
+    Person author
+    String created
+    String issued
+    String modified
+}
+
+class Person {
+    String name
+    String url
+    String email
+}
diff --git a/src/test/org/codehaus/groovy/classgen/RunBugsTest.java b/src/test/org/codehaus/groovy/classgen/RunBugsTest.java
index d661d849ae..6de750f15e 100644
--- a/src/test/org/codehaus/groovy/classgen/RunBugsTest.java
+++ b/src/test/org/codehaus/groovy/classgen/RunBugsTest.java
@@ -114,13 +114,19 @@ public class RunBugsTest extends TestSupport {
         GroovyObject object = compile("src/test/groovy/bugs/OverloadInvokeMethodBug.groovy");
         object.invokeMethod("testBug", null);
     }
-    */
-    
-    
-    
     public void testClosureVariableBug() throws Exception {
         GroovyObject object = compile("src/test/groovy/bugs/ClosureVariableBug.groovy");
         object.invokeMethod("testBug", null);
     }
+    
+    public void testClosureParameterPassingBug() throws Exception {
+        GroovyObject object = compile("src/test/groovy/bugs/ClosureParameterPassingBug.groovy");
+        object.invokeMethod("testBug", null);
+    }
+    */
         
-   }
+    public void testNestedClosure2Bug() throws Exception {
+        GroovyObject object = compile("src/test/groovy/bugs/NestedClosure2Bug.groovy");
+        object.invokeMethod("testBug", null);
+    }
+}
diff --git a/src/test/org/codehaus/groovy/classgen/TestSupport.java b/src/test/org/codehaus/groovy/classgen/TestSupport.java
index 59bfb99bf8..4b53b265b5 100644
--- a/src/test/org/codehaus/groovy/classgen/TestSupport.java
+++ b/src/test/org/codehaus/groovy/classgen/TestSupport.java
@@ -55,7 +55,8 @@ import groovy.util.GroovyTestCase;
 import java.beans.BeanInfo;
 import java.beans.Introspector;
 import java.beans.PropertyDescriptor;
-import java.io.*;
+import java.io.ByteArrayInputStream;
+import java.io.File;
 import java.lang.reflect.Field;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
