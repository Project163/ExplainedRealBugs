diff --git a/subprojects/groovy-templates/src/main/groovy/groovy/text/StreamingTemplateEngine.java b/subprojects/groovy-templates/src/main/groovy/groovy/text/StreamingTemplateEngine.java
index 21557ae901..a902b05d81 100644
--- a/subprojects/groovy-templates/src/main/groovy/groovy/text/StreamingTemplateEngine.java
+++ b/subprojects/groovy-templates/src/main/groovy/groovy/text/StreamingTemplateEngine.java
@@ -22,10 +22,13 @@ import org.codehaus.groovy.control.ErrorCollector;
 import org.codehaus.groovy.control.MultipleCompilationErrorsException;
 import org.codehaus.groovy.control.messages.Message;
 import org.codehaus.groovy.control.messages.SyntaxErrorMessage;
+import org.codehaus.groovy.runtime.StackTraceUtils;
 import org.codehaus.groovy.syntax.SyntaxException;
 
 import java.io.IOException;
+import java.io.LineNumberReader;
 import java.io.Reader;
+import java.io.StringReader;
 import java.security.AccessController;
 import java.security.PrivilegedAction;
 import java.util.ArrayList;
@@ -35,10 +38,9 @@ import java.util.Map;
 /**
  * Processes template source files substituting variables and expressions into
  * placeholders in a template source text to produce the desired output using a
- * streaming approach. This engine has equivalent functionality to the
+ * closure based approach. This engine has equivalent functionality to the
  * {@link groovy.text.SimpleTemplateEngine} but creates the template using
- * writable closures making it more scalable for large templates or in streaming
- * scenarios.
+ * writable closures making it more scalable for large templates.
  * <p>
  * Specifically this template engine can handle strings larger than 64k which
  * still causes problems for the other groovy template engines.
@@ -53,34 +55,40 @@ import java.util.Map;
  * example providing the template as a string:
  * <pre>
  * def binding = [
- *     firstname : "Grace",
- *     lastname  : "Hopper",
- *     accepted  : true,
- *     title     : 'Groovy for COBOL programmers'
+ *   firstname : "Grace",
+ *   lastname  : "Hopper",
+ *   accepted  : false,
+ *   title     : 'Groovy for COBOL programmers'
  * ]
- * def engine = new groovy.text.StreamingTemplateEngine()
  * def text = '''\
- * Dear &lt;%= firstname %&gt; $lastname,
- * <p/>
- * We &lt;% if (accepted) print 'are pleased' else print 'regret' %&gt; \
+ * Dear <% out.print firstname %> ${lastname},
+ *
+ * We <% if (accepted) out.print 'are pleased' else out.print 'regret' %> \
  * to inform you that your paper entitled
  * '$title' was ${ accepted ? 'accepted' : 'rejected' }.
- * <p/>
+ *
  * The conference committee.
  * '''
- * def template = engine.createTemplate(text).make(binding)
- * println template.toString()
- * </pre> This example uses a mix of the JSP style and GString style
+ *
+ * def template = new groovy.text.StreamingTemplateEngine().createTemplate(text)
+ *
+ * print template.make(binding)
+ * </pre>
+ *
+ * This example uses a mix of the JSP style and GString style
  * placeholders but you can typically use just one style if you wish. Running
  * this example will produce this output:
  * <pre>
  * Dear Grace Hopper,
- * <p/>
+ *
  * We are pleased to inform you that your paper entitled
  * 'Groovy for COBOL programmers' was accepted.
- * <p/>
+ *
  * The conference committee.
- * </pre> The template engine can also be used as the engine for
+ * </pre>
+ * <br />
+ * <h3>StreamingTemplateEngine as a servlet engine</h3>
+ * The template engine can also be used as the engine for
  * {@link groovy.servlet.TemplateServlet} by placing the following in your
  * <code>web.xml</code> file (plus a corresponding servlet-mapping element):
  * <pre>
@@ -95,6 +103,35 @@ import java.util.Map;
  * </pre> In this case, your template source file should be HTML with the
  * appropriate embedded placeholders.
  *
+ * <h3>Debugging Template Code</h3>
+ * <p>The template engine makes an effort to throw descriptive exceptions with
+ * context lines, ie:
+ * <pre>
+ *  groovy.text.TemplateExecutionException: Template parse error at line 4:
+ *           3: We <% if (accepted) out.print 'are pleased' else out.print 'regret' %> to inform you that your paper entitled
+ *       --> 4: '$txitle' was ${ accepted ? 'accepted' : 'rejected' }.
+ *           5:
+ * at test.run(test.groovy:18)
+ *
+ * Caused by: groovy.lang.MissingPropertyException: No such property: txitle for class: groovy.tmp.templates.StreamingTemplateScript1
+ * ... 1 more
+ * </pre>
+ * and sanitize the exceptions to make things readable.
+ * </p>
+ * <p>When the exceptions are not enough, it might sometimes be useful to view the actual script source
+ * generated by the template engine. This would conceptually be equivalent to viewing the
+ * .java file generated for a jsp page. The source is not currently very readable and
+ * until we get a built in groovy code pretty printer, we will probably continue to opt for compactness
+ * rather than readability.</p>
+ *
+ * <p>With that being said, viewing the source might still have some value. For this reason the script
+ * source is accessible via the template.scriptSource property, i.e.:
+ * <pre>
+ *     prinltn template.scriptSource
+ * </pre>
+ * In the above example.
+ * </p>
+ *
  * @author mbjarland@gmail.com
  * @author Matias Bjarland
  */
@@ -120,28 +157,40 @@ public class StreamingTemplateEngine extends TemplateEngine {
         return new StreamingTemplate(reader, parentLoader);
     }
 
+    /**
+     * The class used to implement the Template interface for the StreamingTemplateEngine
+     *
+     */
     private static class StreamingTemplate implements Template {
+        /**
+         * The 'header' we use for the resulting groovy script source.
+         */
         private static final String SCRIPT_HEAD
                 = "package groovy.tmp.templates;"
                 + "def getTemplate() { "
-                + //the below params are:
-                //  _p - parent class, for handling exceptions
-                //  _s - sections, string sections list
-                //  _b - binding map
-                //  out - out stream
-                //the three first parameters will be curried in as we move along
-                "return { _p, _s, _b, out -> "
-                + "int _i = 0;"
-                + "try {"
-                + "delegate = new Binding(_b);";
+                    //the below params are:
+                    //  _p - parent class, for handling exceptions
+                    //  _s - sections, string sections list
+                    //  _b - binding map
+                    //  out - out stream
+                    //the three first parameters will be curried in as we move along
+                +   "return { _p, _s, _b, out -> "
+                +     "int _i = 0;"
+                +     "try {"
+                +       "delegate = new Binding(_b);";
 
+        /**
+         * The 'footer' we use for the resulting groovy script source
+         */
         private static final String SCRIPT_TAIL
-                = "} catch (Throwable e) { "
-                + "_p.error(_i, _s, e);"
-                + "}"
-                + "}.asWritable()"
+                =     "} catch (Throwable e) { "
+                +       "_p.error(_i, _s, e);"
+                +     "}"
+                +   "}.asWritable()"
                 + "}";
 
+        private StringBuilder templateSource;
+
         // we use a hard index instead of incrementing the _i variable due to previous
         // bug where the increment was not executed when hitting non-executed if branch
         private int index = 0;
@@ -180,8 +229,25 @@ public class StreamingTemplateEngine extends TemplateEngine {
                 this.row = p.row;
                 this.column = p.column;
             }
+
+            public String toString() {
+                return row + ":" + column;
+            }
         }
 
+        /**
+         * A StringSection represent a section in the template source
+         * with only string data (i.e. no branching, GString references, etc).
+         * As an example, the following template string:
+         *
+         * <pre>
+         * Alice why is a $bird like a writing desk
+         * </pre>
+         *
+         * Would produce a string section "Alice why is a " followed by
+         * a dollar identifier expression followed by another string
+         * section " like a writing desk".
+         */
         private static final class StringSection {
             StringBuilder data;
             Position firstSourcePosition;
@@ -199,6 +265,15 @@ public class StreamingTemplateEngine extends TemplateEngine {
             }
         }
 
+        /**
+         * Called to handle the ending of a string section.
+         *
+         * @param sections The list of string sections. The current section gets added to this section.
+         * @param currentSection The current string section.
+         * @param templateExpressions Template expressions
+         * @param lastSourcePosition The last read position in the source template stream.
+         * @param targetPosition The last written to position in the target script stream.
+         */
         private void finishStringSection(List<StringSection> sections, StringSection currentSection,
                                          StringBuilder templateExpressions,
                                          Position lastSourcePosition, Position targetPosition) {
@@ -214,7 +289,7 @@ public class StreamingTemplateEngine extends TemplateEngine {
         }
 
         public void error(int index, List<StringSection> sections, Throwable e) throws Throwable {
-            int i = Math.max(0, index - 1);
+            int i = Math.max(0, index);
             StringSection precedingSection = sections.get(i);
             int traceLine = -1;
             for (StackTraceElement element : e.getStackTrace()) {
@@ -226,29 +301,61 @@ public class StreamingTemplateEngine extends TemplateEngine {
 
             if (traceLine != -1) {
                 int actualLine = precedingSection.lastSourcePosition.row + traceLine - 1;
-                throw new TemplateExecutionException("Error at line " + actualLine + ", message: " + e.getMessage(), e);
+                String message = "Template parse error at line " + actualLine + ":\n" + getErrorContext(actualLine);
+                TemplateExecutionException unsanitized = new TemplateExecutionException(actualLine, message, StackTraceUtils.sanitize(e));
+                throw StackTraceUtils.sanitize(unsanitized);
             } else {
                 throw e;
             }
         }
 
+        private String getErrorContext(int actualLine) throws IOException {
+            int minLine = Math.max(0, actualLine -1);
+            int maxLine = actualLine + 1;
+
+            LineNumberReader r = new LineNumberReader(new StringReader(templateSource.toString()));
+            int lineNr;
+            StringBuilder result = new StringBuilder();
+            while ((lineNr = r.getLineNumber()+1) <= maxLine) {
+                String line = r.readLine();
+                if (lineNr < minLine) continue;
+
+                String nr = Integer.toString(lineNr);
+                if (lineNr == actualLine) {
+                    nr = " --> " + nr;
+                }
+
+                result.append(padLeft(nr, 10));
+                result.append(": ");
+                result.append(line);
+                result.append('\n');
+            }
+
+            return result.toString();
+        }
+
+        private String padLeft(String s, int len) {
+            StringBuilder b = new StringBuilder(s);
+            while (b.length() < len) b.insert(0, " ");
+            return b.toString();
+        }
+
         /**
-         * Turn the template into a writable Closure When executed the closure
+         * Turn the template into a writable Closure. When executed the closure
          * evaluates all the code embedded in the template and then writes a
          * GString containing the fixed and variable items to the writer passed
          * as a parameter
          * <p/>
          * For example:
-         * <p/>
+         * <pre>
          * '<%= "test" %> of expr and <% test = 1 %>${test} script.'
-         * <p/>
+         * </pre>
          * would compile into:
-         * <p/>
-         * { out -> out << "${"test"} of expr and "; test = 1 ; out << "${test}
-         * script."}.asWritable()
-         *
-         * @param source
-         * @param parentLoader
+         * <pre>
+         * { out -> out << "${"test"} of expr and "; test = 1 ; out << "${test} script."}.asWritable()
+         * </pre>
+         * @param source A reader into the template source data
+         * @param parentLoader A class loader we use
          * @throws CompilationFailedException
          * @throws ClassNotFoundException
          * @throws IOException
@@ -260,17 +367,22 @@ public class StreamingTemplateEngine extends TemplateEngine {
             Position targetPosition = new Position(1, 1);
             Position lastSourcePosition = new Position(1, 1);
             StringSection currentSection = new StringSection(sourcePosition);
+            templateSource = new StringBuilder();
 
-            //we use the lookahead to make sure that a template file ending in say "abcdef\\"
+            //we use the lookAhead to make sure that a template file ending in say "abcdef\\"
             //will give a result of "abcdef\\" even though we have special handling for \\
             StringBuilder lookAhead = new StringBuilder(10);
 
             append(target, targetPosition, SCRIPT_HEAD);
             try {
+                int skipRead = -1;
                 //noinspection InfiniteLoopStatement
                 while (true) {
                     lastSourcePosition.set(sourcePosition);
-                    int c = read(source, sourcePosition, lookAhead);
+
+                    int c = (skipRead != -1) ? skipRead : read(source, sourcePosition, lookAhead);
+                    skipRead = -1;
+
                     if (c == '\\') {
                         handleEscaping(source, sourcePosition, currentSection, lookAhead);
                         continue;
@@ -298,7 +410,12 @@ public class StreamingTemplateEngine extends TemplateEngine {
                         clear(lookAhead);
                         if (c == '{') {
                             finishStringSection(sections, currentSection, target, lastSourcePosition, targetPosition);
-                            parseGString(source, target, sourcePosition, targetPosition);
+                            parseDollarCurlyIdentifier(source, target, sourcePosition, targetPosition);
+                            currentSection = new StringSection(sourcePosition);
+                            continue;
+                        } else if (Character.isJavaIdentifierStart(c)) {
+                            finishStringSection(sections, currentSection, target, lastSourcePosition, targetPosition);
+                            skipRead = parseDollarIdentifier(c, source, target, sourcePosition, targetPosition);
                             currentSection = new StringSection(sourcePosition);
                             continue;
                         } else {
@@ -422,7 +539,7 @@ public class StreamingTemplateEngine extends TemplateEngine {
                 final GroovyObject object = (GroovyObject) groovyClass.newInstance();
                 Closure chicken = (Closure) object.invokeMethod("getTemplate", null);
                 //bind the two first parameters of the generated closure to this class and the sections list
-                result = chicken.curry(new Object[]{this, sections});
+                result = chicken.curry(this, sections);
             } catch (InstantiationException e) {
                 throw new ClassNotFoundException(e.getMessage());
             } catch (IllegalAccessException e) {
@@ -432,10 +549,96 @@ public class StreamingTemplateEngine extends TemplateEngine {
             return result;
         }
 
-        private void parseGString(final Reader reader,
-                                  final StringBuilder target,
-                                  final Position sourcePosition,
-                                  final Position targetPosition) throws IOException, FinishedReadingException {
+        /**
+         * Parses a non curly dollar preceded identifier of the type
+         * '$bird' in the following template example:
+         *
+         * <pre>
+         * Alice why is a $bird like a writing desk
+         * </pre>
+         *
+         * which would produce the following template data:
+         *
+         * <pre>
+         * out << "Alice why is a ";
+         * out << bird;
+         * out << " like a writing desk";
+         * </pre>
+         *
+         * This method is given the 'b' in 'bird' in argument c, checks if it is a valid
+         * java identifier start (we assume groovy did not mangle the java
+         * identifier rules). If so it proceeds to parse characters from the input
+         * until it encounters a non-java-identifier character. At that point
+         *
+         * @param c The first letter of the potential identifier, 'b' in the above example
+         * @param reader The reader reading from the template source
+         * @param target The target groovy script source we write to
+         * @param sourcePosition The reader position in the source stream
+         * @param targetPosition The writer position in the target stream
+         * @param lookAhead The lookAhead buffer is here used to store the first non-identifier
+         *                  character located after the identifier (the space after 'bird' in the
+         *                  example above).
+         * @return true if a valid dollar preceded identifier was found, false otherwise. More
+         *         specifically, returns true if the first character after the dollar sign is
+         *         a valid java identifier. Note that the dollar curly syntax is handled by
+         *         another method.
+         *
+         * @throws IOException
+         * @throws FinishedReadingException If we encountered the end of the source stream.
+         */
+        private int parseDollarIdentifier(int c ,
+                                          final Reader reader,
+                                          final StringBuilder target,
+                                          final Position sourcePosition,
+                                          final Position targetPosition) throws IOException, FinishedReadingException {
+            append(target, targetPosition, "out<<");
+            append(target, targetPosition, (char) c);
+
+            while (true) {
+                c = read(reader, sourcePosition);
+                if (!Character.isJavaIdentifierPart(c) || c == '$') {
+                    break;
+                }
+                append(target, targetPosition, (char) c);
+            }
+
+            append(target, targetPosition, ";");
+
+            return c;
+        }
+
+        /**
+         * Parses a dollar curly preceded identifier of the type
+         * '${bird}' in the following template example:
+         *
+         * <pre>
+         * Alice why is a ${bird} like a writing desk
+         * </pre>
+         *
+         * which would produce the following template data:
+         *
+         * <pre>
+         * out << "Alice why is a ";
+         * out << """${bird}""";
+         * out << " like a writing desk";
+         * </pre>
+         *
+         * This method is given the 'b' in 'bird' in argument c, checks if it is a valid
+         * java identifier start (we assume groovy did not mangle the java
+         * identifier rules). If so it proceeds to parse characters from the input
+         * until it encounters a non-java-identifier character. At that point
+         *
+         * @param reader The reader reading from the template source
+         * @param target The target groovy script source we write to
+         * @param sourcePosition The reader position in the source stream
+         * @param targetPosition The writer position in the target stream
+         * @throws IOException
+         * @throws FinishedReadingException
+         */
+        private void parseDollarCurlyIdentifier(final Reader reader,
+                                                final StringBuilder target,
+                                                final Position sourcePosition,
+                                                final Position targetPosition) throws IOException, FinishedReadingException {
             append(target, targetPosition, "out<<\"\"\"${");
 
             while (true) {
@@ -637,7 +840,7 @@ public class StreamingTemplateEngine extends TemplateEngine {
          * of our output is on a newline when it should not be.
          *
          * Instead of using a pushback reader, we just keep a private instance
-         * variable 'last'.
+         * variable 'lastRead'.
          */
         private int read(final Reader reader, Position position) throws IOException, FinishedReadingException {
             int c;
@@ -649,10 +852,10 @@ public class StreamingTemplateEngine extends TemplateEngine {
                 useLastRead = false;
                 lastRead = -1;
             } else {
-                c = reader.read();
+                c = read(reader);
                 if (c == '\r') {
-                    // IF CR FOLLOWED BY NEWLINE THEN JUST KEEP NEWLINE
-                    c = reader.read();
+                    // IF CRLF JUST KEEP LF
+                    c = read(reader);
                     if (c != '\n') {
                         // ELSE keep original char
                         // and pushback the one we just read
@@ -676,5 +879,11 @@ public class StreamingTemplateEngine extends TemplateEngine {
 
             return c;
         }
+
+        private int read(final Reader reader) throws IOException {
+            int c = reader.read();
+            templateSource.append((char) c);
+            return c;
+        }
     }
 }
diff --git a/subprojects/groovy-templates/src/main/groovy/groovy/text/TemplateExecutionException.java b/subprojects/groovy-templates/src/main/groovy/groovy/text/TemplateExecutionException.java
index 84c742eec1..c062cdafc8 100644
--- a/subprojects/groovy-templates/src/main/groovy/groovy/text/TemplateExecutionException.java
+++ b/subprojects/groovy-templates/src/main/groovy/groovy/text/TemplateExecutionException.java
@@ -19,19 +19,34 @@ package groovy.text;
  * A custom exception class to flag template execution errors
  */
 public class TemplateExecutionException extends Exception  {
-  public TemplateExecutionException() {
-    super();
-  }
+    private int lineNumber;
 
-  public TemplateExecutionException(String message) {
-    super(message);
-  }
+    public TemplateExecutionException(int lineNumber) {
+        super();
+        this.lineNumber = lineNumber;
+    }
 
-  public TemplateExecutionException(String message, Throwable cause) {
-    super(message, cause);
-  }
+    public TemplateExecutionException(int lineNumber, String message) {
+        super(message);
+        this.lineNumber = lineNumber;
+    }
 
-  public TemplateExecutionException(Throwable cause) {
-    super(cause);
-  }
+    public TemplateExecutionException(int lineNumber, String message, Throwable cause) {
+        super(message, cause);
+        this.lineNumber = lineNumber;
+    }
+
+    public TemplateExecutionException(int lineNumber, Throwable cause) {
+        super(cause);
+        this.lineNumber = lineNumber;
+    }
+
+    /**
+     * Returns the line number in the template source where the error occurred
+     *
+     * @return the one-based line number of the template parsing error.
+     */
+    public int getLineNumber() {
+        return lineNumber;
+    }
 }
diff --git a/subprojects/groovy-templates/src/test/groovy/groovy/text/StreamingTemplateEngineSpecification.groovy b/subprojects/groovy-templates/src/test/groovy/groovy/text/StreamingTemplateEngineSpecification.groovy
index 1951d0ebbc..d5f7faa560 100644
--- a/subprojects/groovy-templates/src/test/groovy/groovy/text/StreamingTemplateEngineSpecification.groovy
+++ b/subprojects/groovy-templates/src/test/groovy/groovy/text/StreamingTemplateEngineSpecification.groovy
@@ -4,24 +4,42 @@ import spock.lang.*
 
 import static StreamingTemplateEngineSpecification.EngineType.*
 
+/**
+ * http://code.google.com/p/spock/wiki/SpockBasics
+ *
+ * Author: Matias Bjarland
+ */
 class StreamingTemplateEngineSpecification extends Specification {
-
-  enum EngineType { 
+  enum EngineType {
     STREAMING('StreamingTemplateEngine'),
-    SIMPLE('SimpleTemplateEngine'), 
+    SIMPLE('SimpleTemplateEngine'),
     GSTRING('GStringTemplateEngine')
     String displayString
-    
+
     EngineType(displayString) {
       this.displayString = displayString
     }
-    
+
     String toString() {
-      displayString      
+      displayString
     }
   }
 
   @Shared Map defaultBinding = [alice: 'Alice', rabbit: 'Rabbit', queen: 'Queen', desk: 'writing desk']
+  @Shared String SIXTY_FOUR_K_OF_A
+
+  // run before the first feature method
+  def setupSpec() {
+    StringBuilder b = new StringBuilder()
+    def sixtyFourAs = "a"*64
+    (1..1024).each {
+      b.append(sixtyFourAs)
+    }
+    SIXTY_FOUR_K_OF_A = b.toString()
+  }
+  def cleanupSpec() {}   // run after the last feature method
+  def setup() {}          // run before every feature method
+  def cleanup() {}        // run after every feature method
 
   private String template(EngineType type, String data, Map binding=null) {
     TemplateEngine engine
@@ -29,10 +47,10 @@ class StreamingTemplateEngineSpecification extends Specification {
       case STREAMING:
         engine = new StreamingTemplateEngine()
         break
-      case SIMPLE: 
+      case SIMPLE:
         engine = new SimpleTemplateEngine()
         break
-      case GSTRING: 
+      case GSTRING:
         engine = new GStringTemplateEngine()
         break
     }
@@ -45,33 +63,70 @@ class StreamingTemplateEngineSpecification extends Specification {
     sw
   }
 
+  //TODO: Handle dollarExpressionSlashAtStart case better below
   @Unroll
   def "#testName - #engineType should evaluate '#data' to '#expectedResult' using binding '#binding'"() {
-    expect: 
+    expect:
       template(engineType, data, binding) == expectedResult
 
     where:
-      data                   | expectedResult      | engineType     | binding        | testName
-      ''                     | ''                  | STREAMING      | null           | 'emptyStringNoBinding'
-      ''                     | ''                  | STREAMING      | defaultBinding | 'emptyStringWithBinding'
-      'bob'                  | 'bob'               | STREAMING      | null           | 'noExpressionsNoBinding'
-      'bob'                  | 'bob'               | STREAMING      | defaultBinding | 'noExpressionsWithBinding'
-
-      '\\Hello World'        | '\\Hello World'     | STREAMING      | null           | 'noExpressionsNoBindingEscapingAtStart'
-      '\\Hello World'        | '\\Hello World'     | STREAMING      | defaultBinding | 'noExpressionsWithBindingEscapingAtStart'
-      '\\\\Hello World'      | '\\\\Hello World'   | STREAMING      | null           | 'noExpressionsNoBindingDoubleEscapingAtStart'
-      '\\\\Hello World'      | '\\\\Hello World'   | STREAMING      | defaultBinding | 'noExpressionsWithBindingDoubleEscapingAtStart'
-      '\\\\\\Hello World'    | '\\\\\\Hello World' | STREAMING      | null           | 'noExpressionsNoBindingTripleEscapingAtStart'
-      '\\\\\\Hello World'    | '\\\\\\Hello World' | STREAMING      | defaultBinding | 'noExpressionsWithBindingTripleEscapingAtStart'
-
-      'Hello World\\'        | 'Hello World\\'     | STREAMING      | null           | 'noExpressionsNoBindingEscapingAtEnd'
-      'Hello World\\'        | 'Hello World\\'     | STREAMING      | defaultBinding | 'noExpressionsWithBindingEscapingAtEnd'
-      'Hello World\\\\'      | 'Hello World\\\\'   | STREAMING      | null           | 'noExpressionsNoBindingDoubleEscapingAtEnd'
-      'Hello World\\\\'      | 'Hello World\\\\'   | STREAMING      | defaultBinding | 'noExpressionsWithBindingDoubleEscapingAtEnd'
-      'Hello World\\\\\\'    | 'Hello World\\\\\\' | STREAMING      | null           | 'noExpressionsNoBindingTripleEscapingAtEnd'
-      'Hello World\\\\\\'    | 'Hello World\\\\\\' | STREAMING      | defaultBinding | 'noExpressionsWithBindingTripleEscapingAtEnd'
+      data                     | expectedResult      | engineType     | binding        | testName
+      ''                       | ''                  | STREAMING      | null           | 'emptyStringNoBinding'
+      ''                       | ''                  | STREAMING      | defaultBinding | 'emptyStringWithBinding'
+      'bob'                    | 'bob'               | STREAMING      | null           | 'noExpressionsNoBinding'
+      'bob'                    | 'bob'               | STREAMING      | defaultBinding | 'noExpressionsWithBinding'
+
+      '\\Hello World'          | '\\Hello World'     | STREAMING      | null           | 'noExpressionsNoBindingEscapingAtStart'
+      '\\Hello World'          | '\\Hello World'     | STREAMING      | defaultBinding | 'noExpressionsWithBindingEscapingAtStart'
+      '\\\\Hello World'        | '\\\\Hello World'   | STREAMING      | null           | 'noExpressionsNoBindingDoubleEscapingAtStart'
+      '\\\\Hello World'        | '\\\\Hello World'   | STREAMING      | defaultBinding | 'noExpressionsWithBindingDoubleEscapingAtStart'
+      '\\\\\\Hello World'      | '\\\\\\Hello World' | STREAMING      | null           | 'noExpressionsNoBindingTripleEscapingAtStart'
+      '\\\\\\Hello World'      | '\\\\\\Hello World' | STREAMING      | defaultBinding | 'noExpressionsWithBindingTripleEscapingAtStart'
+
+      'Hello World\\'          | 'Hello World\\'     | STREAMING      | null           | 'noExpressionsNoBindingEscapingAtEnd'
+      'Hello World\\'          | 'Hello World\\'     | STREAMING      | defaultBinding | 'noExpressionsWithBindingEscapingAtEnd'
+      'Hello World\\\\'        | 'Hello World\\\\'   | STREAMING      | null           | 'noExpressionsNoBindingDoubleEscapingAtEnd'
+      'Hello World\\\\'        | 'Hello World\\\\'   | STREAMING      | defaultBinding | 'noExpressionsWithBindingDoubleEscapingAtEnd'
+      'Hello World\\\\\\'      | 'Hello World\\\\\\' | STREAMING      | null           | 'noExpressionsNoBindingTripleEscapingAtEnd'
+      'Hello World\\\\\\'      | 'Hello World\\\\\\' | STREAMING      | defaultBinding | 'noExpressionsWithBindingTripleEscapingAtEnd'
+
+      'Hello $alice'           | 'Hello Alice'       | STREAMING      | defaultBinding | 'dollarExpressionAtEnd'
+      '$alice Hello'           | 'Alice Hello'       | STREAMING      | defaultBinding | 'dollarExpressionAtBeginning'
+      '$alice'                 | 'Alice'             | STREAMING      | defaultBinding | 'dollarExpressionByItself'
+      'a $alice b'             | 'a Alice b'         | STREAMING      | defaultBinding | 'dollarExpressionInBetweenStrings'
+
+      '$rabbit$alice'          | 'RabbitAlice'       | STREAMING      | defaultBinding | 'dollarExpressionTwoAdjacentButDifferent'
+      '$alice$alice'           | 'AliceAlice'        | STREAMING      | defaultBinding | 'dollarExpressionTwoAdjacentAndIdentical'
+      '$rabbit $alice'         | 'Rabbit Alice'      | STREAMING      | defaultBinding | 'dollarExpressionTwoAdjacentButDifferentWithSpace'
+      '$alice $alice'          | 'Alice Alice'       | STREAMING      | defaultBinding | 'dollarExpressionTwoAdjacentAndIdenticalWithSpace'
+      '$'                      | '$'                 | STREAMING      | defaultBinding | 'literalDollarSignByItself'
+      '\\$'                    | '\\$'               | STREAMING      | defaultBinding | 'literalDollarSignEscapingAtStart'
+      '$\\'                    | '$\\'               | STREAMING      | defaultBinding | 'literalDollarSignEscapingAtEnd'
+      '\\$alice'               | '\\$alice'          | STREAMING      | defaultBinding | 'dollarExpressionSlashAtStart'
+      '\$alice'                | 'Alice'             | STREAMING      | defaultBinding | 'dollarExpressionEscapingAtStart'
+
+      '${rabbit}${alice}'      | 'RabbitAlice'       | STREAMING      | defaultBinding | 'curlyExpressionTwoAdjacentButDifferent'
+      '${alice}${alice}'       | 'AliceAlice'        | STREAMING      | defaultBinding | 'curlyExpressionTwoAdjacentAndIdentical'
+      '${rabbit} ${alice}'     | 'Rabbit Alice'      | STREAMING      | defaultBinding | 'curlyExpressionTwoAdjacentButDifferentWithSpace'
+      '${alice} ${alice}'      | 'Alice Alice'       | STREAMING      | defaultBinding | 'curlyExpressionTwoAdjacentAndIdenticalWithSpace'
+      '${}'                    | 'null'              | STREAMING      | defaultBinding | 'curlyExpressionEmptyEvaluatesToNull'
+
+      "<% out.print alice %>"    | 'Alice'           | STREAMING      | defaultBinding | 'scriptletOutPrintBinding'
+      "a<% out.print alice %>b"  | 'aAliceb'         | STREAMING      | defaultBinding | 'scriptletOutPrintBindingBetween'
+      "<% out.print 'bob' %>"    | 'bob'             | STREAMING      | defaultBinding | 'scriptletOutPrintConstant'
+      "a<% out.print 'bob' %>b"  | 'abobb'           | STREAMING      | defaultBinding | 'scriptletOutPrintConstantBetween'
+
+      "<%= alice %>"             | 'Alice'           | STREAMING      | defaultBinding | 'outExprPrintBinding'
+      "a<%= alice %>b"           | 'aAliceb'         | STREAMING      | defaultBinding | 'outExprPrintBindingBetween'
+      "<%= 'bob' %>"             | 'bob'             | STREAMING      | defaultBinding | 'outExprPrintConstant'
+      "a<%= 'bob' %>b"           | 'abobb'           | STREAMING      | defaultBinding | 'outExprPrintConstantBetween'
   }
 
+  /**
+   * Validate fix of handling of \r\n line endings as reported by Wilfried Middleton 2014.02.12
+   * https://github.com/mbjarland/groovy-streaming-template-engine/issues/1
+   * Note: This was before the template engine got merged into groovy-core
+   */
   def "should handle \\r\\n line feeds correctly"() {
     setup:
       String basic = '<%\r\n' +
@@ -92,6 +147,11 @@ class StreamingTemplateEngineSpecification extends Specification {
       gStringTemplate == streamingTemplate
   }
 
+  /**
+   * Validate fix of handling of if statements as reported by Wilfried Middleton 2014.02.12
+   * https://github.com/mbjarland/groovy-streaming-template-engine/issues/2
+   * Note: This was before the template engine got merged into groovy-core
+   */
   def "should handle simple embedded if statements"() {
     setup:
       String templateText = 'before "<% if (false) { %>should not be included<% } else { %>should be included<% } %>" after'
@@ -104,7 +164,12 @@ class StreamingTemplateEngineSpecification extends Specification {
       result == 'before "should be included" after'
   }
 
-  def "should handle complex embedded if statements"() {
+  /**
+   * Validate fix of handling of if statements as reported by Wilfried Middleton 2014.02.12
+   * https://github.com/mbjarland/groovy-streaming-template-engine/issues/2
+   * Note: This was before the template engine got merged into groovy-core
+   */
+  def "should handle complex embedded if statements same as GStringTemplateEngine"() {
     setup:
       String templateText = 'first line text\n' +
                             '<%\n' +
@@ -130,4 +195,108 @@ class StreamingTemplateEngineSpecification extends Specification {
     then:
       streamingResult == gStringResult
   }
+
+  def "should execute the javadoc example with correct output"() {
+    setup:
+      def binding = [firstname : "Grace",
+                     lastname  : "Hopper",
+                     accepted  : false,
+                     title     : 'Groovy for COBOL programmers']
+      def text = '''\
+        |Dear <% out.print firstname %> ${lastname},
+        |
+        |We <% if (accepted) out.print 'are pleased' else out.print 'regret' %> to inform you that your paper entitled
+        |'$title' was ${ accepted ? 'accepted' : 'rejected' }.
+        |
+        |The conference committee.
+        '''.stripMargin()
+
+      def expected = '''\
+        |Dear Grace Hopper,
+        |
+        |We regret to inform you that your paper entitled
+        |'Groovy for COBOL programmers' was rejected.
+        |
+        |The conference committee.
+        '''.stripMargin()
+
+    when:
+      String result = template(STREAMING, text, binding)
+
+    then:
+     result == expected
+  }
+
+  def "should execute the javadoc example same as GStringTemplateEngine"() {
+    setup:
+    def binding = [firstname : "Grace",
+                   lastname  : "Hopper",
+                   accepted  : false,
+                   title     : 'Groovy for COBOL programmers']
+    def text = '''\
+        |Dear <% out.print firstname %> ${lastname},
+        |
+        |We <% if (accepted) out.print 'are pleased' else out.print 'regret' %> to inform you that your paper entitled
+        |'$title' was ${ accepted ? 'accepted' : 'rejected' }.
+        |
+        |The conference committee.
+        '''.stripMargin()
+
+    when:
+      String streaming = template(STREAMING, text, binding)
+      String gString   = template(GSTRING, text, binding)
+
+    then:
+    streaming == gString
+  }
+
+  def "should throw exception with correct line number on template errors"() {
+    setup:
+      def binding = [firstname : "Grace",
+                     lastname  : "Hopper",
+                     accepted  : false,
+                     title     : 'Groovy for COBOL programmers']
+    def text = '''\
+        |Dear <% out.print firstname %> ${lastname},
+        |
+        |We <% if (accepted) out.print 'are pleased' else out.print 'regret' %> to inform you that your paper entitled
+        |'$txitle' was ${ accepted ? 'accepted' : 'rejected' }.
+        |
+        |The conference committee.
+        '''.stripMargin()
+
+    when:
+      String result = template(STREAMING, text, binding)
+
+    then:
+      def e = thrown(TemplateExecutionException)
+      e.lineNumber == 4
+  }
+
+  @Unroll
+  def "should evaluate adjacent expressions '#expression' to '#expected'"() {
+    expect:
+      template(STREAMING, expression, defaultBinding) == expected
+
+    where:
+      //Create all permutations of the different kinds of expressions and validate that they
+      //evaluate to expected results. We have encountered a few too many edge cases with failing
+      //adjacent evaluations...this should cover most of them
+      [expression, expected] << [
+        ['constant'               , 'constant'],
+        ['${alice}'               , 'Alice'],
+        ['$rabbit '               , 'Rabbit '],
+        ['<%= queen %>'           , 'Queen'],
+        ['<% out << desk %>'      , 'writing desk'],
+      ].permutations().collect { p ->
+        p.inject(['','']) { acc, val ->
+          println "VAL0: ${val[0]}"
+          println "VAL1: ${val[1]}"
+          acc[0] += val[0]
+          acc[1] += val[1]
+          acc
+        }
+      }
+  }
+
 }
