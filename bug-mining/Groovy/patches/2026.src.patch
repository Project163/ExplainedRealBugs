diff --git a/src/main/groovy/transform/Immutable.java b/src/main/groovy/transform/Immutable.java
index 252746437f..a45f01b8f6 100644
--- a/src/main/groovy/transform/Immutable.java
+++ b/src/main/groovy/transform/Immutable.java
@@ -150,4 +150,22 @@ public @interface Immutable {
      * @since 1.8.7
      */
     Class[] knownImmutableClasses() default {};
+
+    /**
+     * Allows you to provide {@code @Immutable} with a list of property names which
+     * are deemed immutable. By supplying a property's name in this list, you are vouching
+     * for its immutability and {@code @Immutable} will do no further checks.
+     * Example:
+     * <pre>
+     * {@code @groovy.transform.Immutable}(knownImmutables = ['address'])
+     * class Person {
+     *     String first, last
+     *     Address address
+     * }
+     * ...
+     * </pre>
+     *
+     * @since 2.0.6
+     */
+    String[] knownImmutables() default {};
 }
diff --git a/src/main/org/codehaus/groovy/transform/ImmutableASTTransformation.java b/src/main/org/codehaus/groovy/transform/ImmutableASTTransformation.java
index 74f2f7ad31..16003768d4 100644
--- a/src/main/org/codehaus/groovy/transform/ImmutableASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/ImmutableASTTransformation.java
@@ -27,7 +27,6 @@ import org.codehaus.groovy.ast.stmt.ExpressionStatement;
 import org.codehaus.groovy.ast.stmt.IfStatement;
 import org.codehaus.groovy.ast.stmt.Statement;
 import org.codehaus.groovy.ast.stmt.ThrowStatement;
-import org.codehaus.groovy.classgen.VariableScopeVisitor;
 import org.codehaus.groovy.control.CompilePhase;
 import org.codehaus.groovy.control.SourceUnit;
 import org.codehaus.groovy.runtime.DefaultGroovyMethods;
@@ -85,6 +84,7 @@ public class ImmutableASTTransformation extends AbstractASTTransformation {
     static final ClassNode MY_TYPE = ClassHelper.make(MY_CLASS);
     static final String MY_TYPE_NAME = "@" + MY_TYPE.getNameWithoutPackage();
     static final String MEMBER_KNOWN_IMMUTABLE_CLASSES = "knownImmutableClasses";
+    static final String MEMBER_KNOWN_IMMUTABLES = "knownImmutables";
 
     private static final ClassNode DATE_TYPE = ClassHelper.make(Date.class);
     private static final ClassNode CLONEABLE_TYPE = ClassHelper.make(Cloneable.class);
@@ -106,6 +106,7 @@ public class ImmutableASTTransformation extends AbstractASTTransformation {
 
         if (parent instanceof ClassNode) {
             final List<String> knownImmutableClasses = getKnownImmutableClasses(node);
+            final List<String> knownImmutables = getKnownImmutables(node);
 
             ClassNode cNode = (ClassNode) parent;
             String cName = cNode.getName();
@@ -124,7 +125,7 @@ public class ImmutableASTTransformation extends AbstractASTTransformation {
             for (FieldNode fNode : fList) {
                 ensureNotPublic(cName, fNode);
             }
-            createConstructors(cNode, knownImmutableClasses);
+            createConstructors(cNode, knownImmutableClasses, knownImmutables);
             createHashCode(cNode, true, false, false, null, null);
             createEquals(cNode, false, false, false, null, null);
             if (!hasAnnotation(cNode, ToStringASTTransformation.MY_TYPE)) {
@@ -184,13 +185,34 @@ public class ImmutableASTTransformation extends AbstractASTTransformation {
         return immutableClasses;
     }
 
+    private List<String> getKnownImmutables(AnnotationNode node) {
+        final ArrayList<String> immutables = new ArrayList<String>();
+
+        final Expression expression = node.getMember(MEMBER_KNOWN_IMMUTABLES);
+        if (expression == null) return immutables;
+
+        if (!(expression instanceof ListExpression)) {
+            addError("Use the Groovy list notation [el1, el2] to specify known immutable property names via \"" + MEMBER_KNOWN_IMMUTABLES + "\"", node);
+            return immutables;
+        }
+
+        final ListExpression listExpression = (ListExpression) expression;
+        for (Expression listItemExpression : listExpression.getExpressions()) {
+            if (listItemExpression instanceof ConstantExpression) {
+                immutables.add((String) ((ConstantExpression) listItemExpression).getValue());
+            }
+        }
+
+        return immutables;
+    }
+
     private void makeClassFinal(ClassNode cNode) {
         if ((cNode.getModifiers() & ACC_FINAL) == 0) {
             cNode.setModifiers(cNode.getModifiers() | ACC_FINAL);
         }
     }
 
-    private void createConstructors(ClassNode cNode, List<String> knownImmutableClasses) {
+    private void createConstructors(ClassNode cNode, List<String> knownImmutableClasses, List<String> knownImmutables) {
         if (!validateConstructors(cNode)) return;
 
         List<PropertyNode> list = getInstanceProperties(cNode);
@@ -198,7 +220,7 @@ public class ImmutableASTTransformation extends AbstractASTTransformation {
         if (specialHashMapCase) {
             createConstructorMapSpecial(cNode, list);
         } else {
-            createConstructorMap(cNode, list, knownImmutableClasses);
+            createConstructorMap(cNode, list, knownImmutableClasses, knownImmutables);
             createConstructorOrdered(cNode, list);
         }
     }
@@ -238,10 +260,10 @@ public class ImmutableASTTransformation extends AbstractASTTransformation {
         createConstructorMapCommon(cNode, body);
     }
 
-    private void createConstructorMap(ClassNode cNode, List<PropertyNode> list, List<String> knownImmutableClasses) {
+    private void createConstructorMap(ClassNode cNode, List<PropertyNode> list, List<String> knownImmutableClasses, List<String> knownImmutables) {
         final BlockStatement body = new BlockStatement();
         for (PropertyNode pNode : list) {
-            body.addStatement(createConstructorStatement(cNode, pNode, knownImmutableClasses));
+            body.addStatement(createConstructorStatement(cNode, pNode, knownImmutableClasses, knownImmutables));
         }
         // check for missing properties
         Expression checkArgs = new ArgumentListExpression(new VariableExpression("this"), new VariableExpression("args"));
@@ -261,7 +283,7 @@ public class ImmutableASTTransformation extends AbstractASTTransformation {
             body.addStatement(createConstructorStatementDefault(fNode));
         }
         final Parameter[] params = new Parameter[]{new Parameter(HASHMAP_TYPE, "args")};
-        doAddConstructor(cNode,new ConstructorNode(ACC_PUBLIC, params, ClassNode.EMPTY_ARRAY, new IfStatement(
+        doAddConstructor(cNode, new ConstructorNode(ACC_PUBLIC, params, ClassNode.EMPTY_ARRAY, new IfStatement(
                 equalsNullExpr(new VariableExpression("args")),
                 new EmptyStatement(),
                 body)));
@@ -330,18 +352,18 @@ public class ImmutableASTTransformation extends AbstractASTTransformation {
         return true;
     }
 
-    private Statement createConstructorStatement(ClassNode cNode, PropertyNode pNode, List<String> knownImmutableClasses) {
+    private Statement createConstructorStatement(ClassNode cNode, PropertyNode pNode, List<String> knownImmutableClasses, List<String> knownImmutables) {
         FieldNode fNode = pNode.getField();
         final ClassNode fieldType = fNode.getType();
         Statement statement = null;
         if (fieldType.isArray() || isOrImplements(fieldType, CLONEABLE_TYPE)) {
             statement = createConstructorStatementArrayOrCloneable(fNode);
+        } else if (isKnownImmutableClass(fieldType, knownImmutableClasses) || isKnownImmutable(pNode.getName(), knownImmutables)) {
+            statement = createConstructorStatementDefault(fNode);
         } else if (fieldType.isDerivedFrom(DATE_TYPE)) {
             statement = createConstructorStatementDate(fNode);
         } else if (isOrImplements(fieldType, COLLECTION_TYPE) || fieldType.isDerivedFrom(COLLECTION_TYPE) || isOrImplements(fieldType, MAP_TYPE) || fieldType.isDerivedFrom(MAP_TYPE)) {
             statement = createConstructorStatementCollection(fNode);
-        } else if (isKnownImmutable(fieldType, knownImmutableClasses)) {
-            statement = createConstructorStatementDefault(fNode);
         } else if (fieldType.isResolved()) {
             addError(createErrorMessage(cNode.getName(), fNode.getName(), fieldType.getName(), "compiling"), fNode);
         } else {
@@ -386,7 +408,7 @@ public class ImmutableASTTransformation extends AbstractASTTransformation {
                         assignStatement(fieldExpr, cloneCollectionExpr(collection))));
     }
 
-    private boolean isKnownImmutable(ClassNode fieldType, List<String> knownImmutableClasses) {
+    private boolean isKnownImmutableClass(ClassNode fieldType, List<String> knownImmutableClasses) {
         if (!fieldType.isResolved()) return false;
         return fieldType.isEnum() ||
                 ClassHelper.isPrimitiveType(fieldType) ||
@@ -395,6 +417,10 @@ public class ImmutableASTTransformation extends AbstractASTTransformation {
                 knownImmutableClasses.contains(fieldType.getName());
     }
 
+    private boolean isKnownImmutable(String fieldName, List<String> knownImmutables) {
+        return knownImmutables.contains(fieldName);
+    }
+
     private static boolean inImmutableList(String typeName) {
         return immutableList.contains(typeName);
     }
diff --git a/src/test/org/codehaus/groovy/transform/ImmutableTransformTest.groovy b/src/test/org/codehaus/groovy/transform/ImmutableTransformTest.groovy
index 4f4a4be4ab..a37ef1e5f4 100644
--- a/src/test/org/codehaus/groovy/transform/ImmutableTransformTest.groovy
+++ b/src/test/org/codehaus/groovy/transform/ImmutableTransformTest.groovy
@@ -526,4 +526,35 @@ class ImmutableTransformTest extends GroovyShellTestCase {
         assert msg.contains("doesn't know how to handle field 'address' of type 'Address'")
         assert msg.contains("@Immutable classes only support properties with effectively immutable types")
     }
+
+    // GROOVY-5828
+    void testKnownImmutableCollectionClass() {
+        assertScript '''
+            @groovy.transform.Immutable
+            class ItemsControl { List list }
+            def itemsControl = new ItemsControl(['Fee', 'Fi', 'Fo', 'Fum'])
+            assert itemsControl.list.class.name.contains('Unmodifiable')
+
+            // ok, Items not really immutable but pretend so for the purpose of this test
+            @groovy.transform.Immutable(knownImmutableClasses = [List])
+            class Items { List list }
+            def items = new Items(['Fee', 'Fi', 'Fo', 'Fum'])
+            assert !items.list.class.name.contains('Unmodifiable')
+        '''
+    }
+
+    // GROOVY-5828
+    void testKnownImmutables() {
+        assertScript '''
+            // ok, Items not really immutable but pretend so for the purpose of this test
+            @groovy.transform.Immutable(knownImmutables = ['list1'])
+            class Items {
+                List list1
+                List list2
+            }
+            def items = new Items(['Fee', 'Fi'], ['Fo', 'Fum'])
+            assert !items.list1.class.name.contains('Unmodifiable')
+            assert items.list2.class.name.contains('Unmodifiable')
+        '''
+    }
 }
