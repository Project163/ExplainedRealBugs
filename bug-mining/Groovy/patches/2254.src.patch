diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index e318848aaa..1bbead4aef 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -2345,13 +2345,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             typeCheckingContext.popTemporaryTypeInfo();
 
             // GROOVY-6099: restore assignement info as before the if branch
-            Set<Map.Entry<VariableExpression, List<ClassNode>>> entries = typeCheckingContext.ifElseForWhileAssignmentTracker.entrySet();
-            for (Map.Entry<VariableExpression, List<ClassNode>> entry : entries) {
-                VariableExpression var = entry.getKey();
-                List<ClassNode> items = entry.getValue();
-                ClassNode originValue = items.get(0);
-                storeType(var, originValue);
-            }
+            restoreTypeBeforeConditional();
 
             Statement elseBlock = ifElse.getElseBlock();
             if (elseBlock instanceof EmptyStatement) {
@@ -2366,6 +2360,32 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         }
     }
 
+    @Override
+    public void visitSwitch(final SwitchStatement statement) {
+        Map<VariableExpression, List<ClassNode>> oldTracker = pushAssignmentTracking();
+        try {
+            super.visitSwitch(statement);
+        } finally {
+            popAssignmentTracking(oldTracker);
+        }
+    }
+
+    @Override
+    public void visitCaseStatement(final CaseStatement statement) {
+        super.visitCaseStatement(statement);
+        restoreTypeBeforeConditional();
+    }
+
+    private void restoreTypeBeforeConditional() {
+        Set<Map.Entry<VariableExpression, List<ClassNode>>> entries = typeCheckingContext.ifElseForWhileAssignmentTracker.entrySet();
+        for (Map.Entry<VariableExpression, List<ClassNode>> entry : entries) {
+            VariableExpression var = entry.getKey();
+            List<ClassNode> items = entry.getValue();
+            ClassNode originValue = items.get(0);
+            storeType(var, originValue);
+        }
+    }
+
     protected Map<VariableExpression, ClassNode> popAssignmentTracking(final Map<VariableExpression, List<ClassNode>> oldTracker) {
         Map<VariableExpression, ClassNode> assignments = new HashMap<VariableExpression, ClassNode>();
         if (!typeCheckingContext.ifElseForWhileAssignmentTracker.isEmpty()) {
@@ -2512,7 +2532,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             if (oldDIT != null) {
                 exp.putNodeMetaData(StaticTypesMarker.DECLARATION_INFERRED_TYPE, cn==null?oldDIT : lowestUpperBound(oldDIT, cn));
             } else {
-                exp.putNodeMetaData(StaticTypesMarker.DECLARATION_INFERRED_TYPE, cn==null?oldValue : lowestUpperBound(oldValue, cn));
+                exp.putNodeMetaData(StaticTypesMarker.DECLARATION_INFERRED_TYPE, cn==null?null : lowestUpperBound(oldValue, cn));
             }
         }
         if (exp instanceof VariableExpression) {
diff --git a/src/test/groovy/transform/stc/TypeInferenceSTCTest.groovy b/src/test/groovy/transform/stc/TypeInferenceSTCTest.groovy
index a5678dc74f..5d9b47f494 100644
--- a/src/test/groovy/transform/stc/TypeInferenceSTCTest.groovy
+++ b/src/test/groovy/transform/stc/TypeInferenceSTCTest.groovy
@@ -569,5 +569,59 @@ class TypeInferenceSTCTest extends StaticTypeCheckingTestCase {
             convertValueToType('foo', String)
         '''
     }
+
+    void testSwitchCaseAnalysis() {
+        assertScript '''import org.codehaus.groovy.ast.tools.WideningCategories.LowestUpperBoundClassNode as LUB
+
+            def method(int x) {
+                def returnValue= new Date()
+                switch (x) {
+                    case 1:
+                        returnValue = 'string'
+                        break;
+                    case 2:
+                        returnValue = 1;
+                        break;
+                }
+                @ASTTest(phase=INSTRUCTION_SELECTION,value={
+                    def ift = node.getNodeMetaData(INFERRED_TYPE)
+                    assert ift instanceof LUB
+                    assert ift.name == 'java.io.Serializable'
+                })
+                def val = returnValue
+
+                returnValue
+            }
+        '''
+    }
+
+    void testGroovy6215() {
+        assertScript '''
+                def processNumber(int x) {
+                    def value = getValueForNumber(x)
+                    value
+                }
+
+                def getValueForNumber(int x) {
+                    def valueToReturn
+                    switch(x) {
+                        case 1:
+                            valueToReturn = 'One'
+                            break
+                        case 2:
+                            valueToReturn = []
+                            valueToReturn << 'Two'
+                            break
+                    }
+                    valueToReturn
+                }
+                def v1 = getValueForNumber(1)
+                def v2 = getValueForNumber(2)
+                def v3 = getValueForNumber(3)
+                assert v1 == 'One'
+                assert v2 == ['Two']
+                assert v3 == null
+        '''
+    }
 }
 
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/TypeInferenceStaticCompileTest.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/TypeInferenceStaticCompileTest.groovy
index 92eddc7a11..5f0042086b 100644
--- a/src/test/org/codehaus/groovy/classgen/asm/sc/TypeInferenceStaticCompileTest.groovy
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/TypeInferenceStaticCompileTest.groovy
@@ -53,7 +53,6 @@ class TypeInferenceStaticCompileTest extends TypeInferenceSTCTest {
 
     // GROOVY-
     void testGetAnnotationFail() {
-        try {
             assertScript '''import groovy.transform.*
     import java.lang.annotation.ElementType;
     import java.lang.annotation.Retention;
@@ -95,9 +94,6 @@ class TypeInferenceStaticCompileTest extends TypeInferenceSTCTest {
 
             assert Ann2.isAssignableFrom (doit(new A(), "field").class)
             '''
-        } finally {
-            println astTrees
-        }
     }
 }
 
