diff --git a/src/main/org/codehaus/groovy/classgen/ClassCompletionVerifier.java b/src/main/org/codehaus/groovy/classgen/ClassCompletionVerifier.java
index 78df2fe610..04f9cf9923 100644
--- a/src/main/org/codehaus/groovy/classgen/ClassCompletionVerifier.java
+++ b/src/main/org/codehaus/groovy/classgen/ClassCompletionVerifier.java
@@ -90,7 +90,16 @@ public class ClassCompletionVerifier extends ClassCodeVisitorSupport {
         for (MethodNode methodNode : node.getMethods()) {
             MethodNode mn = result.get(methodNode.getTypeDescriptor());
             if (mn!=null && methodNode.isStatic() && !methodNode.isStaticConstructor()) {
-                ClassNode cn = mn.getDeclaringClass().getOuterClass();
+                ClassNode declaringClass = mn.getDeclaringClass();
+                ClassNode cn = declaringClass.getOuterClass();
+                if (cn==null && declaringClass.isResolved()) {
+                    // in case of a precompiled class, the outerclass is unknown
+                    Class typeClass = declaringClass.getTypeClass();
+                    typeClass = typeClass.getEnclosingClass();
+                    if (typeClass!=null) {
+                        cn = ClassHelper.make(typeClass);
+                    }
+                }
                 if (cn==null || !Traits.isTrait(cn)) {
                     addError("Method '" + mn.getName() + "' is already defined in " + getDescription(node) + ". You cannot have " +
                             "both a static and a non static method with the same signature", methodNode);
diff --git a/src/main/org/codehaus/groovy/classgen/Verifier.java b/src/main/org/codehaus/groovy/classgen/Verifier.java
index 68968fa0e1..33b6fa057c 100644
--- a/src/main/org/codehaus/groovy/classgen/Verifier.java
+++ b/src/main/org/codehaus/groovy/classgen/Verifier.java
@@ -921,9 +921,11 @@ public class Verifier implements GroovyClassVisitor, Opcodes {
             }
         }
 
-        for (FieldNode fn : node.getFields()) {
-            addFieldInitialization(statements, staticStatements, fn, isEnum,
-                    initStmtsAfterEnumValuesInit, explicitStaticPropsInEnum);
+        if (!Traits.isTrait(node)) {
+            for (FieldNode fn : node.getFields()) {
+                addFieldInitialization(statements, staticStatements, fn, isEnum,
+                        initStmtsAfterEnumValuesInit, explicitStaticPropsInEnum);
+            }
         }
 
         statements.addAll(node.getObjectInitializerStatements());
@@ -1401,7 +1403,7 @@ public class Verifier implements GroovyClassVisitor, Opcodes {
     }
 
     private boolean moveOptimizedConstantsInitialization(final ClassNode node) {
-        if (node.isInterface()) return false;
+        if (node.isInterface() && !Traits.isTrait(node)) return false;
 
         final int mods = Opcodes.ACC_STATIC|Opcodes.ACC_SYNTHETIC| Opcodes.ACC_PUBLIC;
         String name = SWAP_INIT;
diff --git a/src/main/org/codehaus/groovy/transform/trait/TraitASTTransformation.java b/src/main/org/codehaus/groovy/transform/trait/TraitASTTransformation.java
index 04cdc3b187..f6025dec03 100644
--- a/src/main/org/codehaus/groovy/transform/trait/TraitASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/trait/TraitASTTransformation.java
@@ -27,8 +27,11 @@ import org.codehaus.groovy.ast.InnerClassNode;
 import org.codehaus.groovy.ast.MethodNode;
 import org.codehaus.groovy.ast.Parameter;
 import org.codehaus.groovy.ast.PropertyNode;
+import org.codehaus.groovy.ast.expr.ArgumentListExpression;
 import org.codehaus.groovy.ast.expr.BinaryExpression;
 import org.codehaus.groovy.ast.expr.CastExpression;
+import org.codehaus.groovy.ast.expr.ClassExpression;
+import org.codehaus.groovy.ast.expr.ConstantExpression;
 import org.codehaus.groovy.ast.expr.Expression;
 import org.codehaus.groovy.ast.expr.FieldExpression;
 import org.codehaus.groovy.ast.expr.MethodCallExpression;
@@ -42,12 +45,14 @@ import org.codehaus.groovy.classgen.Verifier;
 import org.codehaus.groovy.control.CompilationUnit;
 import org.codehaus.groovy.control.CompilePhase;
 import org.codehaus.groovy.control.SourceUnit;
+import org.codehaus.groovy.runtime.InvokerHelper;
 import org.codehaus.groovy.syntax.SyntaxException;
 import org.codehaus.groovy.syntax.Token;
 import org.codehaus.groovy.syntax.Types;
 import org.codehaus.groovy.transform.ASTTransformationCollectorCodeVisitor;
 import org.codehaus.groovy.transform.AbstractASTTransformation;
 import org.codehaus.groovy.transform.GroovyASTTransformation;
+import org.codehaus.groovy.transform.sc.StaticCompileTransformation;
 
 import java.lang.reflect.Modifier;
 import java.util.ArrayList;
@@ -68,6 +73,8 @@ import java.util.Set;
 @GroovyASTTransformation(phase = CompilePhase.SEMANTIC_ANALYSIS)
 public class TraitASTTransformation extends AbstractASTTransformation implements CompilationUnitAware {
 
+    private static final ClassNode INVOKERHELPER_CLASSNODE = ClassHelper.make(InvokerHelper.class);
+
     private SourceUnit unit;
     private CompilationUnit compilationUnit;
 
@@ -220,6 +227,10 @@ public class TraitASTTransformation extends AbstractASTTransformation implements
         );
         fixGenerics(initializer, cNode);
         helper.addMethod(initializer);
+        AnnotationNode an = new AnnotationNode(TraitComposer.COMPILESTATIC_CLASSNODE);
+        initializer.addAnnotation(an);
+        cNode.addTransform(StaticCompileTransformation.class, an);
+
         return initializer;
     }
 
@@ -357,11 +368,24 @@ public class TraitASTTransformation extends AbstractASTTransformation implements
             ExpressionStatement initCode = new ExpressionStatement(initialExpression);
             processBody(thisObject, selectedMethod, initCode, trait, fieldHelper, knownFields);
             BlockStatement code = (BlockStatement) selectedMethod.getCode();
-            MethodCallExpression mce = new MethodCallExpression(
-                    new CastExpression(createReceiverType(field.isStatic(), fieldHelper), thisObject),
-                    Traits.helperSetterName(field),
-                    initCode.getExpression()
-            );
+            MethodCallExpression mce;
+            if (field.isStatic()) {
+                mce = new MethodCallExpression(
+                        new ClassExpression(INVOKERHELPER_CLASSNODE),
+                        "invokeStaticMethod",
+                        new ArgumentListExpression(
+                                thisObject,
+                                new ConstantExpression(Traits.helperSetterName(field)),
+                                initCode.getExpression()
+                        )
+                );
+            } else {
+                mce = new MethodCallExpression(
+                        new CastExpression(createReceiverType(field.isStatic(), fieldHelper), thisObject),
+                        Traits.helperSetterName(field),
+                        initCode.getExpression()
+                );
+            }
             mce.setImplicitThis(false);
             mce.setSourcePosition(initialExpression);
             code.addStatement(new ExpressionStatement(mce));
diff --git a/src/main/org/codehaus/groovy/transform/trait/TraitComposer.java b/src/main/org/codehaus/groovy/transform/trait/TraitComposer.java
index fc4605aa0e..1a2b1ac8db 100644
--- a/src/main/org/codehaus/groovy/transform/trait/TraitComposer.java
+++ b/src/main/org/codehaus/groovy/transform/trait/TraitComposer.java
@@ -36,6 +36,7 @@ import org.codehaus.groovy.ast.expr.MethodCallExpression;
 import org.codehaus.groovy.ast.expr.StaticMethodCallExpression;
 import org.codehaus.groovy.ast.expr.VariableExpression;
 import org.codehaus.groovy.ast.stmt.BlockStatement;
+import org.codehaus.groovy.ast.stmt.EmptyStatement;
 import org.codehaus.groovy.ast.stmt.ExpressionStatement;
 import org.codehaus.groovy.ast.stmt.IfStatement;
 import org.codehaus.groovy.ast.stmt.ReturnStatement;
@@ -51,6 +52,7 @@ import org.codehaus.groovy.syntax.SyntaxException;
 import org.codehaus.groovy.syntax.Token;
 import org.codehaus.groovy.syntax.Types;
 import org.codehaus.groovy.transform.ASTTransformationCollectorCodeVisitor;
+import org.codehaus.groovy.transform.sc.StaticCompileTransformation;
 import org.objectweb.asm.Opcodes;
 
 import java.util.ArrayList;
@@ -183,11 +185,17 @@ public abstract class TraitComposer {
                         Traits.INIT_METHOD,
                         new ArgumentListExpression(new VariableExpression("this")))
         ));
+        MethodCallExpression staticInitCall = new MethodCallExpression(
+                new ClassExpression(helperClassNode),
+                Traits.STATIC_INIT_METHOD,
+                new ArgumentListExpression(new ClassExpression(cNode)));
+        MethodNode staticInitMethod = new MethodNode(
+                Traits.STATIC_INIT_METHOD, Opcodes.ACC_STATIC | Opcodes.ACC_PUBLIC, ClassHelper.VOID_TYPE,
+                new Parameter[] {new Parameter(ClassHelper.CLASS_Type,"clazz")}, ClassNode.EMPTY_ARRAY, EmptyStatement.INSTANCE);
+        staticInitMethod.setDeclaringClass(helperClassNode);
+        staticInitCall.setMethodTarget(staticInitMethod);
         cNode.addStaticInitializerStatements(Collections.<Statement>singletonList(new ExpressionStatement(
-                new MethodCallExpression(
-                        new ClassExpression(helperClassNode),
-                        Traits.STATIC_INIT_METHOD,
-                        new ArgumentListExpression(new VariableExpression("this")))
+                staticInitCall
         )), false);
         if (fieldHelperClassNode != null && !cNode.declaresInterface(fieldHelperClassNode)) {
             // we should implement the field helper interface too
@@ -257,7 +265,9 @@ public abstract class TraitComposer {
                             ClassNode.EMPTY_ARRAY,
                             body
                     );
-                    impl.addAnnotation(new AnnotationNode(COMPILESTATIC_CLASSNODE));
+                    AnnotationNode an = new AnnotationNode(COMPILESTATIC_CLASSNODE);
+                    impl.addAnnotation(an);
+                    cNode.addTransform(StaticCompileTransformation.class, an);
                     cNode.addMethod(impl);
                 }
             }
diff --git a/src/test/org/codehaus/groovy/transform/traitx/Groovy7196Bug.groovy b/src/test/org/codehaus/groovy/transform/traitx/Groovy7196Bug.groovy
new file mode 100644
index 0000000000..9d41ce8e60
--- /dev/null
+++ b/src/test/org/codehaus/groovy/transform/traitx/Groovy7196Bug.groovy
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2003-2014 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.codehaus.groovy.transform.traitx
+
+class Groovy7196Bug extends GroovyTestCase {
+    void testShouldNotThrowDuplicateMethodWithPrecompiledTrait() {
+        assertScript '''import org.codehaus.groovy.transform.traitx.Groovy7196SupportTrait
+            class SomeTestClass implements Groovy7196SupportTrait {}
+            assert SomeTestClass.org_codehaus_groovy_transform_traitx_Groovy7196SupportTrait__someString == 'ok'
+        '''
+    }
+    void testStaticFieldShouldBeInitialized() {
+        assert Groovy7196SupportTraitImpl.org_codehaus_groovy_transform_traitx_Groovy7196SupportTrait__someString == 'ok'
+    }
+}
diff --git a/src/test/org/codehaus/groovy/transform/traitx/Groovy7196SupportTrait.groovy b/src/test/org/codehaus/groovy/transform/traitx/Groovy7196SupportTrait.groovy
new file mode 100644
index 0000000000..64e7f5a0c6
--- /dev/null
+++ b/src/test/org/codehaus/groovy/transform/traitx/Groovy7196SupportTrait.groovy
@@ -0,0 +1,21 @@
+/*
+ * Copyright 2003-2014 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.codehaus.groovy.transform.traitx
+
+trait Groovy7196SupportTrait {
+    public static String someString = 'ok'
+}
diff --git a/src/test/org/codehaus/groovy/transform/traitx/Groovy7196SupportTraitImpl.groovy b/src/test/org/codehaus/groovy/transform/traitx/Groovy7196SupportTraitImpl.groovy
new file mode 100644
index 0000000000..962a480dbb
--- /dev/null
+++ b/src/test/org/codehaus/groovy/transform/traitx/Groovy7196SupportTraitImpl.groovy
@@ -0,0 +1,20 @@
+/*
+ * Copyright 2003-2014 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.codehaus.groovy.transform.traitx
+
+class Groovy7196SupportTraitImpl implements Groovy7196SupportTrait {
+}
