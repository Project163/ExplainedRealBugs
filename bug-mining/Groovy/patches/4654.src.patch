diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
index e02a2fa84b..dc93213ad2 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
@@ -722,7 +722,7 @@ public abstract class StaticTypeCheckingSupport {
             }
         } else if (left.isGenericsPlaceHolder()) { // must precede non-final types
             return right.getUnresolvedName().charAt(0) != '#' // RHS not adaptable
-                    ? left.getGenericsTypes()[0].isCompatibleWith(right) // GROOVY-7307, GROOVY-9952, et al.
+                    ? left.asGenericsType().isCompatibleWith(right) // GROOVY-7307, GROOVY-9952, GROOVY-11026
                     : implementsInterfaceOrSubclassOf(leftRedirect, rightRedirect); // GROOVY-10067, GROOVY-10342
 
         } else if (isBigDecimalType(leftRedirect) || Number_TYPE.equals(leftRedirect)) {
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 322a828627..6fefd6d8c7 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -2520,9 +2520,10 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 if (arguments != null && arguments.length > 0) {
                     ClassNode[] parameters = collateMethodReferenceParameterTypes(expression, candidates.get(0));
                     for (int i = 0; i < arguments.length; i += 1) {
-                        ClassNode at = arguments[i], pt = parameters[Math.min(i, parameters.length - 1)];
+                        ClassNode at = arguments[i];
+                        ClassNode pt = applyGenericsContext(gts, parameters[Math.min(i, parameters.length - 1)]);
                         if (!pt.equals(at) && (at.isInterface() ? pt.implementsInterface(at) : pt.isDerivedFrom(at)))
-                            arguments[i] = parameters[i]; // GROOVY-10734, GROOVY-10807: method refines expected type
+                            arguments[i] = pt; // GROOVY-10734, GROOVY-10807, GROPOVY-11026: expected type is refined
                     }
                 }
             } else if (!(expression instanceof MethodReferenceExpression)
diff --git a/src/test/groovy/transform/stc/MethodReferenceTest.groovy b/src/test/groovy/transform/stc/MethodReferenceTest.groovy
index f5510ae3f7..1fa2185903 100644
--- a/src/test/groovy/transform/stc/MethodReferenceTest.groovy
+++ b/src/test/groovy/transform/stc/MethodReferenceTest.groovy
@@ -472,6 +472,24 @@ final class MethodReferenceTest {
         '''
     }
 
+    @Test // instance::instanceMethod -- GROOVY-11026
+    void testBiFunctionII() {
+        assertScript shell, '''
+            @CompileDynamic
+            def <In,InOut> InOut m(BiFunction<In,InOut,InOut> beef) {
+                beef.apply(0,'boo')
+            }
+
+            @CompileStatic
+            String test(List<String> x) {
+                m(x::set) // NPE
+            }
+
+            String result = test(['foo','bar'])
+            assert result == 'foo'
+        '''
+    }
+
     @Test // instance::instanceMethod
     void testBinaryOperatorII() {
         assertScript shell, '''
@@ -493,7 +511,7 @@ final class MethodReferenceTest {
     }
 
     @Test // instance::instanceMethod
-    void testBinaryOperatorII_COMPATIBLE() {
+    void testBinaryOperatorII2() {
         assertScript shell, '''
             class Adder {
                 BigDecimal add(Number a, Number b) {
