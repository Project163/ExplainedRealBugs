diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
index d11aae46c2..cb164ad6c8 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
@@ -1624,43 +1624,36 @@ public abstract class StaticTypeCheckingSupport {
     static void applyGenericsConnections(final Map<GenericsTypeName, GenericsType> connections, final Map<GenericsTypeName, GenericsType> resolvedPlaceholders) {
         if (connections == null) return;
         int count = 0;
-        while (count < 10000) {
-            count += 1;
-            boolean checkForMorePlaceHolders = false;
+        while (count++ < 10000) {
+            boolean checkForMorePlaceholders = false;
             for (Map.Entry<GenericsTypeName, GenericsType> entry : resolvedPlaceholders.entrySet()) {
-                GenericsTypeName name = entry.getKey();
-                GenericsType replacement = connections.get(name);
-                if (replacement == null) {
-                    GenericsType value = entry.getValue();
-                    GenericsType newValue = applyGenericsContext(connections, value);
-                    entry.setValue(newValue);
-                    checkForMorePlaceHolders = checkForMorePlaceHolders || !equalIncludingGenerics(value, newValue);
-                    continue;
-                }
-                GenericsType original = entry.getValue();
-                if (!original.isWildcard() && !original.isPlaceholder()) {
-                    continue;
-                }
-                boolean placeholderReplacement = replacement.isPlaceholder();
-                if (placeholderReplacement) {
-                    GenericsType connectedType = resolvedPlaceholders.get(name);
-                    if (replacement == connectedType) continue;
-                }
-                // GROOVY-6787: Don't override the original if the replacement placeholder doesn't respect the bounds,
-                // otherwise the original bounds are lost which can result in accepting an incompatible type as an
-                // argument, for example.
-                ClassNode replacementType = extractType(replacement);
-                if (original.isCompatibleWith(replacementType)) {
-                    entry.setValue(replacement);
-                    if (placeholderReplacement) {
-                        checkForMorePlaceHolders = checkForMorePlaceHolders || !equalIncludingGenerics(original, replacement);
+                // entry could be T=T, T=T extends U, T=V, T=String, T=? extends String, etc.
+                GenericsType oldValue = entry.getValue();
+                if (oldValue.isPlaceholder()) { // T=T or V, not T=String or ? ...
+                    GenericsTypeName name = new GenericsTypeName(oldValue.getName());
+                    GenericsType newValue = connections.get(name); // find "V" in T=V
+                    if (newValue == oldValue) continue;
+                    if (newValue == null) {
+                        entry.setValue(newValue = applyGenericsContext(connections, oldValue));
+                        checkForMorePlaceholders = checkForMorePlaceholders || !equalIncludingGenerics(oldValue, newValue);
+                    } else if (!newValue.isPlaceholder() || newValue != resolvedPlaceholders.get(name)) {
+                        // GROOVY-6787: Don't override the original if the replacement doesn't respect the bounds otherwise
+                        // the original bounds are lost, which can result in accepting an incompatible type as an argument.
+                        ClassNode replacementType = extractType(newValue);
+                        if (oldValue.isCompatibleWith(replacementType)) {
+                            entry.setValue(newValue);
+                            if (newValue.isPlaceholder()) {
+                                checkForMorePlaceholders = checkForMorePlaceholders || !equalIncludingGenerics(oldValue, newValue);
+                            }
+                        }
                     }
                 }
             }
-            if (!checkForMorePlaceHolders) break;
+            if (!checkForMorePlaceholders) break;
         }
-        if (count >= 10000)
+        if (count >= 10000) {
             throw new GroovyBugError("unable to handle generics in " + resolvedPlaceholders + " with connections " + connections);
+        }
     }
 
     private static ClassNode extractType(final GenericsType gt) {
diff --git a/src/test/groovy/transform/stc/GenericsSTCTest.groovy b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
index 0f3e2e9346..469bb3cf1c 100644
--- a/src/test/groovy/transform/stc/GenericsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
@@ -1524,7 +1524,6 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
     // GROOVY-6455
     void testDelegateWithGenerics() {
         assertScript '''
-            @groovy.transform.CompileStatic
             class IntList {
                 @Delegate List<Integer> delegate = new ArrayList<Integer>()
             }
@@ -1808,13 +1807,11 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
         assertScript '''
             import groovy.transform.*
 
-            @CompileStatic
             @TupleConstructor(includeFields=true)
             abstract class A<N extends Number> {
                 protected final N number
             }
 
-            @CompileStatic
             class C<L extends Long> extends A<L> { // further restriction of type parameter
                 C(L longNumber) {
                     super(longNumber)
@@ -1834,13 +1831,11 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
         assertScript '''
             import groovy.transform.*
 
-            @CompileStatic
             @TupleConstructor
             abstract class A<N extends Number> {
                 final N number
             }
 
-            @CompileStatic
             class C<L extends Long> extends A<L> {
                 C(L longNumber) {
                     super(longNumber)
@@ -1859,7 +1854,6 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
         assertScript '''
             import groovy.transform.*
 
-            @CompileStatic
             @TupleConstructor(includeFields=true)
             abstract class A<N extends Number> {
                 protected final N number
@@ -1869,7 +1863,6 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
                 }
             }
 
-            @CompileStatic
             class C<L extends Long> extends A<L> {
                 C(L longNumber) {
                     super(longNumber)
@@ -1889,13 +1882,11 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
         assertScript '''
             import groovy.transform.*
 
-            @CompileStatic
             @TupleConstructor(includeFields=true)
             abstract class A<N extends Number> {
                 final N number
             }
 
-            @CompileStatic
             class C<L extends Long> extends A<L> {
                 C(L longNumber) {
                     super(longNumber)
@@ -1910,6 +1901,29 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
         '''
     }
 
+    // GROOVY-9635
+    void testCovariantReturnTypeInferredFromMethod3() {
+        assertScript '''
+            import java.util.function.Function
+
+            class C<R extends Number> {
+                def <V> V m(Function<C, V> f) { // R from C is confused with R->V from Function
+                    V result = f.apply(this)
+                    return result
+                }
+            }
+
+            def ret = new C().m(new Function<C, String>() {
+                @Override
+                String apply(C that) {
+                    return 'foo'
+                }
+            })
+
+            assert ret == 'foo'
+        '''
+    }
+
     void testReturnTypeChecking() {
         shouldFailWithMessages '''
             class Foo {
