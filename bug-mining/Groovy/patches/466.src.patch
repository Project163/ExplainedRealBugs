diff --git a/src/conf/groovy-starter.conf b/src/conf/groovy-starter.conf
index cb75070ee2..d72ab59735 100644
--- a/src/conf/groovy-starter.conf
+++ b/src/conf/groovy-starter.conf
@@ -10,12 +10,14 @@
 ## Note: do not add classes from java.lang here. No rt.jar and on some
 ##       platforms no tools.jar
 ##
-    
-    # Load required libraries
-    load ${groovy.home}/lib/*.jar
+## See http://groovy.codehaus.org/api/org/codehaus/groovy/tools/LoaderConfiguration.html
+## for the file format
+
+    # load required libraries
+    load !{groovy.home}/lib/*.jar
 
     # load user specific libraries
-    load ${user.home}/.groovy/lib/*.jar
+    load !{user.home}/.groovy/lib/*.jar
     
-    #tools.jar for ant tasks
-    #load ${tools.jar}
+    # tools.jar for ant tasks
+    load ${tools.jar}
diff --git a/src/main/org/codehaus/groovy/tools/LoaderConfiguration.java b/src/main/org/codehaus/groovy/tools/LoaderConfiguration.java
index d9f1830c37..40a9cb8c42 100644
--- a/src/main/org/codehaus/groovy/tools/LoaderConfiguration.java
+++ b/src/main/org/codehaus/groovy/tools/LoaderConfiguration.java
@@ -30,23 +30,30 @@ import java.util.regex.Pattern;
  * The stream can be for example a FileInputStream from a file with
  * the following format:
  * <p/>
+ * <pre>
  * # comment
  * main is classname
  * load path
  * load file
  * load pathWith${property}
+ * load pathWith!{required.property}
  * load path/*.jar
- * <p/>
+ * </pre>
  * <ul>
  * <li>All lines starting with "#" are ignored.</li>
  * <li>The "main is" part may only be once in the file. The String
- * afterwards is the name of a class if a main method. </li>
+ * afterwards is the name of a class with a main method. </li>
  * <li>The "load" command will add the given file or path to the
- * classpath in this configuration object.
+ * classpath in this configuration object. If the path does not 
+ * exist, the path will be ignored.
  * </li>
+ * <li>properties referenced using !{x} are required.</li>
+ * <li>properties referenced using ${x} are not required. If the 
+ * property does not exist the whole load instruction line will 
+ * be ignored.</li>
  * </ul>
  * <p/>
- * Defining the main class is optional if @see #setRequireMain(boolean) was
+ * Defining the main class is optional if setRequireMain(boolean) was
  * called with false, before reading the configuration.
  * You can use the wildcard "*" to filter the path, but only for files, not
  * directories. The  ${propertyname} is replaced by the value of the system's
@@ -108,16 +115,28 @@ public class LoaderConfiguration {
 
         if (requireMain && main == null) throw new IOException("missing main class definition in config file");
     }
-
+    
     /**
      * exapands the properties inside the given string to it's values
      */
     private String assignProperties(String str) {
         int propertyIndexStart = 0, propertyIndexEnd = 0;
+        boolean requireProperty = false;
         String result = "";
 
         while (propertyIndexStart < str.length()) {
-            propertyIndexStart = str.indexOf("${", propertyIndexStart);
+            {
+                int i1 = str.indexOf("${", propertyIndexStart);
+                int i2 = str.indexOf("!{", propertyIndexStart);
+                if (i1==-1) {
+                    propertyIndexStart = i2; 
+                } else if (i2==-1) {
+                    propertyIndexStart = i1;
+                } else {
+                    propertyIndexStart = Math.min(i1,i2);
+                }
+                requireProperty=propertyIndexStart==i2;
+            }
             if (propertyIndexStart == -1) break;
             result += str.substring(propertyIndexEnd, propertyIndexStart);
 
@@ -128,7 +147,11 @@ public class LoaderConfiguration {
             String propertyValue = System.getProperty(propertyKey);
             // assume properties contain paths
             if (propertyValue == null) {
-                throw new IllegalArgumentException("Variable $" + propertyKey + " in groovy-starter.conf references a non-existent System property! Try passing the property to the VM using -D" + propertyKey + "=myValue");
+                if (requireProperty) {
+                    throw new IllegalArgumentException("Variable " + propertyKey + " in groovy-starter.conf references a non-existent System property! Try passing the property to the VM using -D" + propertyKey + "=myValue in JAVA_OPTS");
+                } else {
+                    return null;
+                }
             }
             propertyValue = getSlashyPath(propertyValue);
             result += propertyValue;
@@ -152,6 +175,7 @@ public class LoaderConfiguration {
      * by using the * wildcard like in any shell
      */
     private void loadFilteredPath(String filter) {
+        if (filter==null) return;
         int starIndex = filter.indexOf(WILDCARD);
         if (starIndex == -1) {
             addFile(new File(filter));
@@ -161,7 +185,7 @@ public class LoaderConfiguration {
         String startDir = filter.substring(0, starIndex - 1);
         File root = new File(startDir);
 
-        filter = filter.replaceAll("\\.", "\\\\.");
+        filter = Pattern.quote(filter);
         filter = filter.replaceAll("\\" + WILDCARD, WILD_CARD_REGEX);
         Pattern pattern = Pattern.compile(filter);
 
diff --git a/src/test/org/codehaus/groovy/tools/LoaderConfigurationTest.groovy b/src/test/org/codehaus/groovy/tools/LoaderConfigurationTest.groovy
new file mode 100644
index 0000000000..7b8cb22156
--- /dev/null
+++ b/src/test/org/codehaus/groovy/tools/LoaderConfigurationTest.groovy
@@ -0,0 +1,90 @@
+package org.codehaus.groovy.tools
+
+class LoaderConfigurationTest extends GroovyTestCase {
+
+  void testComment() {
+    def txt = "# I am a comment"
+    
+    def config = new LoaderConfiguration()
+    config.requireMain = false
+    config.configure(new StringBufferInputStream(txt))
+    
+    assert config.classPathUrls.length == 0  
+  }
+  
+  void testNormalPath() {
+    // generate a load instruction with a valid path
+    def file = new File(".")
+    def txt = "load $file"
+    
+    def config = new LoaderConfiguration()
+    config.requireMain = false
+    config.configure(new StringBufferInputStream(txt))
+    
+    assert config.classPathUrls.length == 1
+    assert config.classPathUrls[0].sameFile(file.toURI().toURL())
+  }
+  
+  void testNonexistingPath() {
+    // generate a load instruction with a valid path
+    def file = getNonexistantFile(new File("."))
+
+    def txt = "load $file"
+    
+    def config = new LoaderConfiguration()
+    config.requireMain = false
+    config.configure(new StringBufferInputStream(txt))
+    
+    assert config.classPathUrls.length == 0
+  }  
+  
+  private File getNonexistantFile(File base) {
+    def number = "0"
+    while (base.exists()) {
+      base = new File(base,number)
+      number++
+    }
+    return base
+  }
+  
+  void testExistingProperty() {
+    def txt = 'load ${java.home}'
+    
+    def config = new LoaderConfiguration()
+    config.requireMain = false
+    config.configure(new StringBufferInputStream(txt))
+    
+    assert config.classPathUrls.length == 1
+    def url1 = config.classPathUrls[0]
+    def url2 = new File(System.getProperty("java.home")).toURI().toURL()
+    assert url1.sameFile(url2)
+  }  
+  
+  void testNonexistingProperty() {
+     String name = getNonexistingPropertyName("foo")
+     
+    def txt = 'load !{'+name+'}'
+    
+    def config = new LoaderConfiguration()
+    config.requireMain = false
+    shouldFail {
+        config.configure(new StringBufferInputStream(txt))
+    }
+    
+    txt = 'load ${'+name+'}'
+    
+    config = new LoaderConfiguration()
+    config.requireMain = false
+    config.configure(new StringBufferInputStream(txt))
+    
+    assert config.classPathUrls.length == 0
+  }
+  
+  
+  private getNonexistingPropertyName(String base) {
+    while (System.getProperty(base)!=null) {
+      base += "x"
+    }
+    return base
+  }
+}
\ No newline at end of file
