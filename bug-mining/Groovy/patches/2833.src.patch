diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index fdd5bce367..c361f03b2f 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -4340,51 +4340,59 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         if (isPrimitiveType(receiver) && !isPrimitiveType(declaringClass)) {
             receiver = getWrapper(receiver);
         }
-        ClassNode current = receiver;
-        while (true) {
-            boolean continueLoop = true;
-            //extract the place holders
-            Map<String, GenericsType> currentPlaceHolders = new HashMap<String, GenericsType>();
-            if (isGenericsPlaceHolderOrArrayOf(declaringClass) || declaringClass.equals(current)) {
-                extractGenericsConnections(currentPlaceHolders, current, declaringClass);
-                if (method!=null) addMethodLevelDeclaredGenerics(method, currentPlaceHolders);
-                continueLoop = false;
-            } else {
-                GenericsUtils.extractPlaceholders(current, currentPlaceHolders);
-            }
-
-            if (resolvedPlaceholders!=null) {
-                // merge maps 
-                Set<Map.Entry<String,GenericsType>> entries = currentPlaceHolders.entrySet();
-                for (Map.Entry<String,GenericsType> entry : entries) {
-                    GenericsType gt = entry.getValue();
-                    if (!gt.isPlaceholder()) continue;
-                    GenericsType referenced = resolvedPlaceholders.get(gt.getName());
-                    if (referenced==null) continue;
-                    entry.setValue(referenced);
+        final List<ClassNode> queue;
+        if (receiver instanceof UnionTypeClassNode) {
+            queue = Arrays.asList(((UnionTypeClassNode) receiver).getDelegates());
+        } else {
+            queue = Collections.singletonList(receiver);
+        }
+        for (ClassNode item : queue) {
+            ClassNode current = item;
+            while (current!=null) {
+                boolean continueLoop = true;
+                //extract the place holders
+                Map<String, GenericsType> currentPlaceHolders = new HashMap<String, GenericsType>();
+                if (isGenericsPlaceHolderOrArrayOf(declaringClass) || declaringClass.equals(current)) {
+                    extractGenericsConnections(currentPlaceHolders, current, declaringClass);
+                    if (method!=null) addMethodLevelDeclaredGenerics(method, currentPlaceHolders);
+                    continueLoop = false;
+                } else {
+                    GenericsUtils.extractPlaceholders(current, currentPlaceHolders);
                 }
-            }
-            resolvedPlaceholders = currentPlaceHolders;
 
-            // we are done if we are now in the declaring class
-            if (!continueLoop) break;
+                if (resolvedPlaceholders!=null) {
+                    // merge maps
+                    Set<Map.Entry<String,GenericsType>> entries = currentPlaceHolders.entrySet();
+                    for (Map.Entry<String,GenericsType> entry : entries) {
+                        GenericsType gt = entry.getValue();
+                        if (!gt.isPlaceholder()) continue;
+                        GenericsType referenced = resolvedPlaceholders.get(gt.getName());
+                        if (referenced==null) continue;
+                        entry.setValue(referenced);
+                    }
+                }
+                resolvedPlaceholders = currentPlaceHolders;
+
+                // we are done if we are now in the declaring class
+                if (!continueLoop) break;
 
-            current = getNextSuperClass(current, declaringClass);
-            if (current==null && CLASS_Type.equals(declaringClass)) {
-                // this can happen if the receiver is Class<Foo>, then
-                // the actual receiver is Foo and declaringClass is Class
-                current = declaringClass;
-            }
-            if (current==null) {
-                String descriptor = "<>";
-                if (method!=null) descriptor = method.getTypeDescriptor();
-                throw new GroovyBugError(
-                        "Declaring class for method call to '" +
-                        descriptor + "' declared in " + declaringClass.getName() +
-                        " was not matched with found receiver "+ receiver.getName() + "." +
-                        " This should not have happened!");
+                current = getNextSuperClass(current, declaringClass);
+                if (current==null && CLASS_Type.equals(declaringClass)) {
+                    // this can happen if the receiver is Class<Foo>, then
+                    // the actual receiver is Foo and declaringClass is Class
+                    current = declaringClass;
+                }
             }
         }
+        if (resolvedPlaceholders==null) {
+            String descriptor = "<>";
+            if (method!=null) descriptor = method.getTypeDescriptor();
+            throw new GroovyBugError(
+                    "Declaring class for method call to '" +
+                            descriptor + "' declared in " + declaringClass.getName() +
+                            " was not matched with found receiver "+ receiver.getName() + "." +
+                            " This should not have happened!");
+        }
         return resolvedPlaceholders;
     }
 
diff --git a/src/test/org/codehaus/groovy/transform/traitx/Groovy7275Bug.groovy b/src/test/org/codehaus/groovy/transform/traitx/Groovy7275Bug.groovy
new file mode 100644
index 0000000000..c8242e0c39
--- /dev/null
+++ b/src/test/org/codehaus/groovy/transform/traitx/Groovy7275Bug.groovy
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2003-2015 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.codehaus.groovy.transform.traitx
+
+class Groovy7275Bug extends GroovyTestCase {
+    void testShouldNotThrowCompileBug() {
+        assertScript '''
+
+import groovy.transform.SelfType
+import groovy.transform.CompileStatic
+
+class BitcoinClient {
+   Map<String,Object> getTransaction(String txid) {}
+}
+
+@SelfType(BitcoinClient)
+@CompileStatic
+trait BitcoinCLIAPI {
+
+    Map<String, Object> gettransaction(String txid) {
+       return getTransaction(txid)
+    }
+}
+
+BitcoinCLIAPI
+
+'''
+    }
+}
