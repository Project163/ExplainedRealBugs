diff --git a/src/main/java/groovy/lang/MetaClassImpl.java b/src/main/java/groovy/lang/MetaClassImpl.java
index 14ca8081fb..084632192a 100644
--- a/src/main/java/groovy/lang/MetaClassImpl.java
+++ b/src/main/java/groovy/lang/MetaClassImpl.java
@@ -20,6 +20,7 @@ package groovy.lang;
 
 import org.apache.groovy.internal.util.UncheckedThrow;
 import org.apache.groovy.lang.GroovyObjectHelper;
+import org.apache.groovy.runtime.ObjectUtil;
 import org.apache.groovy.util.BeanUtils;
 import org.apache.groovy.util.SystemUtil;
 import org.codehaus.groovy.GroovyBugError;
@@ -39,7 +40,6 @@ import org.codehaus.groovy.reflection.ReflectionCache;
 import org.codehaus.groovy.reflection.ReflectionUtils;
 import org.codehaus.groovy.reflection.android.AndroidSupport;
 import org.codehaus.groovy.runtime.ArrayTypeUtils;
-import org.codehaus.groovy.runtime.ArrayUtil;
 import org.codehaus.groovy.runtime.ConvertedClosure;
 import org.codehaus.groovy.runtime.CurriedClosure;
 import org.codehaus.groovy.runtime.DefaultGroovyMethods;
@@ -1128,15 +1128,12 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
                 }
             }
 
-            if (receiverClass.isArray()) {
-                if (methodName.equals("clone") && arguments.length == 0) {
-                    try {
-                        return (Object[]) ArrayUtil.getCloneArrayMethodHandle().invokeExact((Object[]) object);
-                    } catch (Throwable t) {
-                        throw new GroovyRuntimeException(t);
-                    }
+            if (methodName.equals("clone") && arguments.length == 0) {
+                try {
+                    return (Object) ObjectUtil.getCloneObjectMethodHandle().invokeExact((Object) object);
+                } catch (Throwable t) {
+                    throw new GroovyRuntimeException(t);
                 }
-                throw mme;
             }
 
             boolean spyFound = (lookup != null);
diff --git a/src/main/java/org/apache/groovy/runtime/ObjectUtil.java b/src/main/java/org/apache/groovy/runtime/ObjectUtil.java
new file mode 100644
index 0000000000..661a3012e8
--- /dev/null
+++ b/src/main/java/org/apache/groovy/runtime/ObjectUtil.java
@@ -0,0 +1,113 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package org.apache.groovy.runtime;
+
+import org.codehaus.groovy.GroovyBugError;
+import org.codehaus.groovy.runtime.ArrayUtil;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.reflect.Method;
+
+/**
+ * Util for object's operations with checks
+ * @since 4.0.5
+ */
+public class ObjectUtil {
+    /**
+     * Clone the specified object
+     *
+     * @param object the object to clone
+     * @return the cloned object
+     * @param <T> the object type
+     * @throws Throwable some exception or error
+     * @since 4.0.5
+     */
+    @SuppressWarnings("unchecked")
+    public static <T> T cloneObject(T object) throws Throwable {
+        if (null == object) return null;
+
+        final Class<?> clazz = object.getClass();
+        if (!(object instanceof Cloneable)) throw new CloneNotSupportedException(clazz.getName());
+
+        if (clazz.isArray()) {
+            if (clazz.getComponentType().isPrimitive()) {
+                if (byte[].class == clazz) {
+                    return (T) ArrayUtil.cloneArray((byte[]) object);
+                } else if (short[].class == clazz) {
+                    return (T) ArrayUtil.cloneArray((short[]) object);
+                } else if (int[].class == clazz) {
+                    return (T) ArrayUtil.cloneArray((int[]) object);
+                } else if (char[].class == clazz) {
+                    return (T) ArrayUtil.cloneArray((char[]) object);
+                } else if (long[].class == clazz) {
+                    return (T) ArrayUtil.cloneArray((long[]) object);
+                } else if (float[].class == clazz) {
+                    return (T) ArrayUtil.cloneArray((float[]) object);
+                } else if (double[].class == clazz) {
+                    return (T) ArrayUtil.cloneArray((double[]) object);
+                } else if (boolean[].class == clazz) {
+                    return (T) ArrayUtil.cloneArray((boolean[]) object);
+                }
+
+                throw new GroovyBugError(clazz.getName() + " is not an array of primitive type"); // should never happen
+            }
+            return (T) ArrayUtil.cloneArray((Object[]) object);
+        }
+
+        final Method cloneMethod = clazz.getMethod("clone");
+        final MethodHandle cloneMethodHandle = LOOKUP.in(clazz).unreflect(cloneMethod);
+
+        return (T) cloneMethodHandle.invokeWithArguments(object);
+    }
+
+    /**
+     * Returns the method handle of {@link ObjectUtil#cloneObject(Object)}
+     *
+     * @return the method handle
+     * @since 4.0.5
+     */
+    public static MethodHandle getCloneObjectMethodHandle() {
+        return MethodHandleHolder.CLONE_OBJECT_METHOD_HANDLE;
+    }
+
+    private static class MethodHandleHolder {
+        private static final MethodHandle CLONE_OBJECT_METHOD_HANDLE;
+        static {
+            final Class<ObjectUtil> objectUtilClass = ObjectUtil.class;
+            Method cloneObjectMethod;
+            try {
+                cloneObjectMethod = objectUtilClass.getDeclaredMethod("cloneObject", Object.class);
+            } catch (NoSuchMethodException e) {
+                throw new GroovyBugError("Failed to find `cloneObject` method in class `" + objectUtilClass.getName() + "`", e);
+            }
+
+            try {
+                CLONE_OBJECT_METHOD_HANDLE = LOOKUP.in(objectUtilClass).unreflect(cloneObjectMethod);
+            } catch (IllegalAccessException e) {
+                throw new GroovyBugError("Failed to create method handle for " + cloneObjectMethod);
+            }
+        }
+        private MethodHandleHolder() {}
+    }
+
+    private ObjectUtil() {}
+
+    private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();
+}
diff --git a/src/main/java/org/codehaus/groovy/runtime/ArrayUtil.java b/src/main/java/org/codehaus/groovy/runtime/ArrayUtil.java
index d35a4d80ea..1e80aa3b7d 100644
--- a/src/main/java/org/codehaus/groovy/runtime/ArrayUtil.java
+++ b/src/main/java/org/codehaus/groovy/runtime/ArrayUtil.java
@@ -18,12 +18,6 @@
  */
 package org.codehaus.groovy.runtime;
 
-import org.codehaus.groovy.GroovyBugError;
-
-import java.lang.invoke.MethodHandle;
-import java.lang.invoke.MethodHandles;
-import java.lang.reflect.Method;
-
 /**
 * This is a generated class used internally during the writing of bytecode within the CallSiteWriter logic.
 * This is not a class exposed to users, as is the case with almost all classes in the org.codehaus.groovy packages.
@@ -61,31 +55,32 @@ import java.lang.reflect.Method;
 public class ArrayUtil {
     private static final Object[] EMPTY = new Object[0];
 
-    public static MethodHandle getCloneArrayMethodHandle() {
-        return MethodHandleHolder.CLONE_ARRAY_METHOD_HANDLE;
+    public static <T> T[] cloneArray(T[] array) {
+        return array.clone();
     }
 
-    private static class MethodHandleHolder {
-        private static final MethodHandle CLONE_ARRAY_METHOD_HANDLE;
-        static {
-            final Class<ArrayUtil> arrayUtilClass = ArrayUtil.class;
-            Method cloneArrayMethod;
-            try {
-                cloneArrayMethod = arrayUtilClass.getDeclaredMethod("cloneArray", Object[].class);
-            } catch (NoSuchMethodException e) {
-                throw new GroovyBugError("Failed to find `cloneArray` method in class `" + arrayUtilClass.getName() + "`", e);
-            }
-
-            try {
-                CLONE_ARRAY_METHOD_HANDLE = MethodHandles.lookup().in(arrayUtilClass).unreflect(cloneArrayMethod);
-            } catch (IllegalAccessException e) {
-                throw new GroovyBugError("Failed to create method handle for " + cloneArrayMethod);
-            }
-        }
-        private MethodHandleHolder() {}
+    public static byte[] cloneArray(byte[] array) {
+        return array.clone();
     }
-
-    public static <T> T[] cloneArray(T[] array) {
+    public static short[] cloneArray(short[] array) {
+        return array.clone();
+    }
+    public static int[] cloneArray(int[] array) {
+        return array.clone();
+    }
+    public static char[] cloneArray(char[] array) {
+        return array.clone();
+    }
+    public static long[] cloneArray(long[] array) {
+        return array.clone();
+    }
+    public static float[] cloneArray(float[] array) {
+        return array.clone();
+    }
+    public static double[] cloneArray(double[] array) {
+        return array.clone();
+    }
+    public static boolean[] cloneArray(boolean[] array) {
         return array.clone();
     }
 
diff --git a/src/main/java/org/codehaus/groovy/runtime/InvokerHelper.java b/src/main/java/org/codehaus/groovy/runtime/InvokerHelper.java
index 40672f84c0..d292a08329 100644
--- a/src/main/java/org/codehaus/groovy/runtime/InvokerHelper.java
+++ b/src/main/java/org/codehaus/groovy/runtime/InvokerHelper.java
@@ -33,6 +33,8 @@ import groovy.lang.Script;
 import groovy.lang.SpreadMap;
 import groovy.lang.SpreadMapEvaluatingException;
 import groovy.lang.Tuple;
+import org.apache.groovy.internal.util.UncheckedThrow;
+import org.apache.groovy.runtime.ObjectUtil;
 import org.codehaus.groovy.reflection.ClassInfo;
 import org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl;
 import org.codehaus.groovy.runtime.metaclass.MissingMethodExecutionFailed;
@@ -586,10 +588,6 @@ public class InvokerHelper {
 
         // it's an instance; check if it's a Java one
         if (!(object instanceof GroovyObject)) {
-            if ("clone".equals(methodName) && object.getClass().isArray() && (null == arguments || arguments.getClass().isArray() && 0 == ((Object[]) arguments).length)) {
-                return ArrayUtil.cloneArray((Object[]) object);
-            }
-
             return invokePojoMethod(object, methodName, arguments);
         }
 
@@ -598,6 +596,14 @@ public class InvokerHelper {
     }
 
     static Object invokePojoMethod(Object object, String methodName, Object arguments) {
+        if ("clone".equals(methodName) && (null == arguments || arguments.getClass().isArray() && 0 == ((Object[]) arguments).length)) {
+            try {
+                return ObjectUtil.cloneObject(object);
+            } catch (Throwable t) {
+                UncheckedThrow.rethrow(t);
+            }
+        }
+
         MetaClass metaClass = InvokerHelper.getMetaClass(object);
         return metaClass.invokeMethod(object, methodName, asArray(arguments));
     }
diff --git a/src/main/java/org/codehaus/groovy/vmplugin/v8/Selector.java b/src/main/java/org/codehaus/groovy/vmplugin/v8/Selector.java
index ed502974c7..07f61adca7 100644
--- a/src/main/java/org/codehaus/groovy/vmplugin/v8/Selector.java
+++ b/src/main/java/org/codehaus/groovy/vmplugin/v8/Selector.java
@@ -32,13 +32,13 @@ import groovy.lang.MetaMethod;
 import groovy.lang.MetaProperty;
 import groovy.lang.MissingMethodException;
 import groovy.transform.Internal;
+import org.apache.groovy.runtime.ObjectUtil;
 import org.codehaus.groovy.GroovyBugError;
 import org.codehaus.groovy.reflection.CachedField;
 import org.codehaus.groovy.reflection.CachedMethod;
 import org.codehaus.groovy.reflection.ClassInfo;
 import org.codehaus.groovy.reflection.GeneratedMetaMethod;
 import org.codehaus.groovy.reflection.stdclasses.CachedSAMClass;
-import org.codehaus.groovy.runtime.ArrayUtil;
 import org.codehaus.groovy.runtime.GeneratedClosure;
 import org.codehaus.groovy.runtime.GroovyCategorySupport;
 import org.codehaus.groovy.runtime.GroovyCategorySupport.CategoryMethod;
@@ -680,11 +680,11 @@ public abstract class Selector {
             final Class<?> declaringClass = m.getDeclaringClass();
             if (declaringClass == Class.class && parameterCount == 1 && methodName.equals("forName")) {
                 return MethodHandles.insertArguments(CLASS_FOR_NAME, 1, true, sender.getClassLoader());
-            } else if (declaringClass == Object.class && parameterCount == 0 && methodName.equals("clone") && null != args && 1 == args.length && args[0].getClass().isArray()) {
-                return ArrayUtil.getCloneArrayMethodHandle();
-            } else {
-                return LOOKUP.unreflect(m);
+            } else if (declaringClass == Object.class && parameterCount == 0 && methodName.equals("clone") && null != args && 1 == args.length) {
+                return ObjectUtil.getCloneObjectMethodHandle();
             }
+
+            return LOOKUP.unreflect(m);
         }
 
         /**
diff --git a/src/test/groovy/bugs/Groovy9103.groovy b/src/test/groovy/bugs/Groovy9103.groovy
index 721344f0c6..9e58032556 100644
--- a/src/test/groovy/bugs/Groovy9103.groovy
+++ b/src/test/groovy/bugs/Groovy9103.groovy
@@ -21,8 +21,8 @@ package groovy.bugs
 import org.junit.Test
 
 import static groovy.test.GroovyAssert.assertScript
+import static groovy.test.GroovyAssert.shouldFail
 
-// TODO: add JVM option `--illegal-access=deny` when all warnings fixed
 final class Groovy9103 {
 
     @Test
@@ -78,4 +78,35 @@ final class Groovy9103 {
             assert nums == cloned
         '''
     }
+
+    @Test // GROOVY-10747
+    void testClone5() {
+        ['Object', 'Dolly'].each { typeName ->
+            assertScript """
+                class Dolly implements Cloneable {
+                    String name
+
+                    public ${typeName} clone() {
+                        return super.clone()
+                    }
+                }
+
+                def dolly = new Dolly(name: "The Sheep")
+                def cloned = dolly.clone()
+                assert cloned instanceof Dolly
+            """
+        }
+    }
+
+    @Test // GROOVY-10747
+    void testClone6() {
+        shouldFail(CloneNotSupportedException, '''
+            class Dolly {
+                String name
+            }
+
+            def dolly = new Dolly(name: "The Sheep")
+            dolly.clone()
+        ''')
+    }
 }
