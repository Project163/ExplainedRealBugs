diff --git a/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java b/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
index e4158af395..2b38c4f8f4 100644
--- a/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
+++ b/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
@@ -3351,19 +3351,7 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      * @return a new Map containing all entries from left and right
      */
     public static Map plus(Map left, Map right) {
-        Map map;
-        if (left instanceof TreeMap)
-            map = new TreeMap(left);
-        else if (left instanceof LinkedHashMap)
-            map = new LinkedHashMap(left);
-        else if (left instanceof Properties) {
-            map = new Properties();
-            map.putAll(left);
-        }
-        else if (left instanceof Hashtable)
-            map = new Hashtable(left);
-        else
-            map = new HashMap(left);
+        Map map = cloneSimilarMap(left);
         map.putAll(right);
         return map;
     }
@@ -3964,15 +3952,7 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      * @return the merged Collection
      */
     public static Collection plus(Collection left, Collection right) {
-        final Collection answer;
-        if (left instanceof SortedSet) {
-            answer = new TreeSet();
-        } else if (left instanceof Set) {
-            answer = new HashSet();
-        } else {
-            answer = new ArrayList(left.size() + right.size());
-        }
-        answer.addAll(left);
+        final Collection answer = cloneSimilarCollection(left, left.size() + right.size());
         answer.addAll(right);
         return answer;
     }
@@ -3988,15 +3968,7 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      * @return the resulting Collection
      */
     public static Collection plus(Collection left, Object right) {
-        final Collection answer;
-        if(left instanceof SortedSet) {
-            answer = new TreeSet();
-        } else if (left instanceof Set) {
-            answer = new HashSet();
-        } else {
-            answer = new ArrayList(left.size() + 1);
-        }
-        answer.addAll(left);
+        final Collection answer = cloneSimilarCollection(left, left.size() + 1);
         answer.add(right);
         return answer;
     }
@@ -4282,12 +4254,8 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      * @return the resulting set
      */
     public static Set minus(Set self, Collection operands) {
-        final Set ansSet;
-        if (self instanceof SortedSet) {
-            ansSet = new TreeSet(self);
-        } else {
-            ansSet = new HashSet(self);
-        }
+        final Set ansSet = createLikeSet(self);
+        ansSet.addAll(self);
         if (self.size() > 0) {
             ansSet.removeAll(operands);
         }
@@ -4302,12 +4270,7 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      * @return the resulting set
      */
     public static Set minus(Set self, Object operand) {
-        final Set ansSet;
-        if(self instanceof SortedSet) {
-            ansSet = new TreeSet();
-        } else {
-            ansSet = new HashSet();
-        }
+        final Set ansSet = createLikeSet(self);
         Comparator numberComparator = new NumberAwareComparator();
         for (Iterator it = self.iterator(); it.hasNext();) {
             Object o = it.next();
@@ -4657,40 +4620,6 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
         return self;
     }
 
-    /**
-     * Determines if all items of this array are of the same type.
-     * @param cols an array of collections
-     * @return true if the collections are all of the same type
-     */
-    private static boolean sameType(Collection[] cols) {
-        List all = new LinkedList();
-        for (int i = 0; i < cols.length; i++) {
-            all.addAll(cols[i]);
-        }
-        if (all.size() == 0)
-            return true;
-
-        Object first = all.get(0);
-
-        //trying to determine the base class of the collections
-        //special case for Numbers
-        Class baseClass;
-        if (first instanceof Number) {
-            baseClass = Number.class;
-        } else {
-            baseClass = first.getClass();
-        }
-
-        for (int i = 0; i < cols.length; i++) {
-            for (Iterator iter = cols[i].iterator(); iter.hasNext();) {
-                if (!baseClass.isInstance(iter.next())) {
-                    return false;
-                }
-            }
-        }
-        return true;
-    }
-
     // Primitive type array methods
     //-------------------------------------------------------------------------
 
diff --git a/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethodsSupport.java b/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethodsSupport.java
index 63fba23241..9de4e0d68e 100644
--- a/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethodsSupport.java
+++ b/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethodsSupport.java
@@ -19,6 +19,8 @@ import groovy.lang.IntRange;
 import groovy.lang.EmptyRange;
 import org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation;
 
+import java.util.*;
+
 /**
  * Support methods for DefaultGroovyMethods and PluginDefaultMethods.
  */
@@ -55,4 +57,78 @@ public class DefaultGroovyMethodsSupport {
             this.reverse = reverse;
         }
     }
+
+    protected static Collection cloneSimilarCollection(Collection left, int newCapacity) {
+        Collection answer;
+        if (left instanceof SortedSet) {
+            answer = new TreeSet();
+        } else if (left instanceof Set) {
+            answer = new HashSet();
+        } else {
+            answer = new ArrayList(newCapacity);
+        }
+        answer.addAll(left);
+        return answer;
+    }
+
+    protected static Map cloneSimilarMap(Map left) {
+        Map map;
+        if (left instanceof TreeMap)
+            map = new TreeMap(left);
+        else if (left instanceof LinkedHashMap)
+            map = new LinkedHashMap(left);
+        else if (left instanceof Properties) {
+            map = new Properties();
+            map.putAll(left);
+        } else if (left instanceof Hashtable)
+            map = new Hashtable(left);
+        else
+            map = new HashMap(left);
+        return map;
+    }
+
+    protected static Set createLikeSet(Set self) {
+        final Set ansSet;
+        if (self instanceof SortedSet) {
+            ansSet = new TreeSet();
+        } else {
+            ansSet = new HashSet();
+        }
+        return ansSet;
+    }
+
+    /**
+     * Determines if all items of this array are of the same type.
+     *
+     * @param cols an array of collections
+     * @return true if the collections are all of the same type
+     */
+    protected static boolean sameType(Collection[] cols) {
+        List all = new LinkedList();
+        for (int i = 0; i < cols.length; i++) {
+            all.addAll(cols[i]);
+        }
+        if (all.size() == 0)
+            return true;
+
+        Object first = all.get(0);
+
+        //trying to determine the base class of the collections
+        //special case for Numbers
+        Class baseClass;
+        if (first instanceof Number) {
+            baseClass = Number.class;
+        } else {
+            baseClass = first.getClass();
+        }
+
+        for (int i = 0; i < cols.length; i++) {
+            for (Iterator iter = cols[i].iterator(); iter.hasNext();) {
+                if (!baseClass.isInstance(iter.next())) {
+                    return false;
+                }
+            }
+        }
+        return true;
+    }
 }
