diff --git a/src/main/groovy/lang/ListWithDefault.java b/src/main/groovy/lang/ListWithDefault.java
index 0962c9eb0e..775ea29bfa 100644
--- a/src/main/groovy/lang/ListWithDefault.java
+++ b/src/main/groovy/lang/ListWithDefault.java
@@ -1,3 +1,18 @@
+/*
+ * Copyright 2003-2012 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package groovy.lang;
 
 import java.util.Collection;
@@ -6,11 +21,11 @@ import java.util.List;
 import java.util.ListIterator;
 
 /**
- * A wrapper for {@link List} which automatically grows by calling {@link #get(int)} or {@link #getAt(int)} with
- * an index greater or equal to {@code size()}.
+ * A wrapper for {@link List} which automatically grows the list when either {@link #get(int)} or
+ * {@link #getAt(int)} is called with an index greater than or equal to {@code size()}.
  *
  * @author Andre Steingress
- * @since TODO
+ * @since 1.8.7
  */
 public final class ListWithDefault<T> implements List<T> {
 
@@ -19,7 +34,7 @@ public final class ListWithDefault<T> implements List<T> {
 
     private final Closure initClosure;
 
-    private ListWithDefault(List<T> items, boolean lazyDefaultValues, Closure initClosure)  {
+    private ListWithDefault(List<T> items, boolean lazyDefaultValues, Closure initClosure) {
         this.delegate = items;
         this.lazyDefaultValues = lazyDefaultValues;
         this.initClosure = initClosure;
@@ -92,17 +107,29 @@ public final class ListWithDefault<T> implements List<T> {
 
     /**
      * Overwrites subscript operator handling by redirecting to {@link #get(int)}.
-     * 
+     *
      * @param index an index (might be greater or equal to {@code size()}, or smaller than 0)
      * @return the value at the given {@code index} or the default value
      */
-    public T getAt(int index)  {
+    public T getAt(int index) {
         return get(index);
     }
 
     /**
-     * Implements the "lazy list" approach. If the requested {@code index} is greater or equal to {@code size()}, the
-     * list will grow to the new size. This implementation breaks
+     * Returns the element at the given index but grows the list if needed. If the requested {@code index} is
+     * greater than or equal to {@code size()}, the list will grow to the new size and a default value calculated
+     * using the <code>initClosure</code> will be used to populate the missing value and returned.
+     * <p/>
+     * If <code>lazyDefaultValues</code> is <code>true</code> any gaps when growing the list are filled
+     * with nulls. Subsequent attempts to retrieve items from the list from those gap index values
+     * will, upon finding null, call the <code>initClosure</code> to populate the list for the
+     * given list value. Hence, when in this mode, nulls cannot be stored in this list.
+     * If <code>lazyDefaultValues</code> is <code>false</code> any gaps when growing the list are filled
+     * eagerly by calling the <code>initClosure</code> for all gap indexes during list growth.
+     * No calls to <code>initClosure</code> are made except during list growth and it is ok to
+     * store null values in the list when in this mode.
+     * <p/>
+     * This implementation breaks
      * the contract of {@link java.util.List#get(int)} as it a) possibly modifies the underlying list and b) does
      * NOT throw an {@link IndexOutOfBoundsException} when {@code index < 0 || index >= size()}.
      *
@@ -115,13 +142,13 @@ public final class ListWithDefault<T> implements List<T> {
         int normalisedIndex = normaliseIndex(index, size);
 
         // either index >= size or the normalised index is negative
-        if (normalisedIndex >= size || normalisedIndex < 0)  {
+        if (normalisedIndex >= size || normalisedIndex < 0) {
             final boolean prepend = (normalisedIndex < 0);
             // find out the number of gaps to fill with null/the default value
             final int gapCount = (prepend ? ((normalisedIndex + 1) * -1) : normalisedIndex - size);
 
             // fill all gaps
-            for (int i = 0; i < gapCount; i++)  {
+            for (int i = 0; i < gapCount; i++) {
                 final int idx = prepend ? 0 : size();
 
                 // if we lazily create default values, use 'null' as placeholder
@@ -140,7 +167,7 @@ public final class ListWithDefault<T> implements List<T> {
         }
 
         T item = delegate.get(normalisedIndex);
-        if (item == null)  {
+        if (item == null && lazyDefaultValues) {
             item = getDefaultValue(normalisedIndex);
             delegate.set(normalisedIndex, item);
         }
@@ -148,8 +175,9 @@ public final class ListWithDefault<T> implements List<T> {
         return item;
     }
 
+    @SuppressWarnings("unchecked")
     private T getDefaultValue(int idx) {
-        return (T) initClosure.call(new Object[] { idx });
+        return (T) initClosure.call(new Object[]{idx});
     }
 
     private int normaliseIndex(int index, int size) {
@@ -187,12 +215,22 @@ public final class ListWithDefault<T> implements List<T> {
         return delegate.listIterator(i);
     }
 
+    @Override
+    public boolean equals(Object obj) {
+        return delegate.equals(obj);
+    }
+
+    @Override
+    public int hashCode() {
+        return delegate.hashCode();
+    }
+
     /**
      * Returns a view of a portion of this list. This method returns a list with the same
      * lazy list settings as the original list.
      *
      * @param fromIndex low endpoint of the subList (inclusive)
-     * @param toIndex upper endpoint of the subList (exclusive)
+     * @param toIndex   upper endpoint of the subList (exclusive)
      * @return a view of a specified range within this list, keeping all lazy list settings
      */
     public List<T> subList(int fromIndex, int toIndex) {
diff --git a/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java b/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
index 6a44011a94..bd8f22740c 100644
--- a/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
+++ b/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
@@ -5270,7 +5270,7 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
     }
 
     /**
-     * Wraps a map using the delegate pattern with a wrapper that intercepts all calls
+     * Wraps a map using the decorator pattern with a wrapper that intercepts all calls
      * to <code>get(key)</code>. If an unknown key is found, a default value will be
      * stored into the Map before being returned. The default value stored will be the
      * result of calling the supplied Closure with the key as the parameter to the Closure.
@@ -5295,77 +5295,103 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
     }
 
     /**
-     * Wraps a list using the delegate pattern with a wrapper that intercepts all calls
-     * to <code>getAt(index)</code> and <code>get(index)</code>. If an index greater or equal
-     * than size is used, the list will grow automatically up to the specified index. Gaps
-     * will be filled by {@code null}.
-     *
-     * Example usage:
-     * <pre class="groovyTestCase">
-     * def list = [0,1].withDefault{ 42 }
-     * assert list[0] == 0
-     * assert list[1] == 1
-     *
-     * assert list[3] == 42   // default value
-     * assert list[2] == null // gap filled with null
-     * </pre>
+     * An alias for <code>withLazyDefault</code> which decorates a list allowing
+     * it to grow when called with index values outside the normal list bounds.
      *
      * @param self a List
-     * @param init a Closure which generates the default value and that is passed the target index
-     * @return the wrapped List
-     * @since TODO
+     * @param init a Closure with the target index as parameter which generates the default value
+     * @return the decorated List
+     * @see #withLazyDefault(java.util.List, groovy.lang.Closure)
+     * @see #withEagerDefault(java.util.List, groovy.lang.Closure)
+     * @since 1.8.7
      */
-    public static <T> List<T> withDefault(List<T> self, Closure init)  {
+    public static <T> List<T> withDefault(List<T> self, Closure init) {
         return withLazyDefault(self, init);
     }
 
     /**
-     * Wraps a list using the delegate pattern with a wrapper that intercepts all calls
-     * to <code>getAt(index)</code> and <code>get(index)</code>. If an index greater or equal
-     * than size is used, the list will grow automatically up to the specified index. Gaps
-     * will be filled by {@code null}.
-     *
+     * Decorates a list allowing it to grow when called with a non-existent index value.
+     * When called with such values, the list is grown in size and a default value
+     * is placed in the list by calling a supplied <code>init</code> Closure. Subsequent
+     * retrieval operations if finding a null value in the list assume it was set
+     * as null from an earlier growing operation and again call the <code>init</code> Closure
+     * to populate the retrieved value; consequently the list can't be used to store null values.
+     * <p/>
+     * How it works: The decorated list intercepts all calls
+     * to <code>getAt(index)</code> and <code>get(index)</code>. If an index greater than
+     * or equal to the current <code>size()</code> is used, the list will grow automatically
+     * up to the specified index. Gaps will be filled by {@code null}. If a default value
+     * should also be used to fill gaps instead of {@code null}, use <code>withEagerDefault</code>.
+     * If <code>getAt(index)</code> or <code>get(index)</code> are called and a null value
+     * is found, it is assumed that the null value was a consequence of an earlier grow list
+     * operation and the <code>init</code> Closure is called to populate the value.
+     * <p/>
      * Example usage:
      * <pre class="groovyTestCase">
-     * def list = [0,1].withDefault{ 42 }
+     * def list = [0, 1].withLazyDefault{ 42 }
      * assert list[0] == 0
      * assert list[1] == 1
-     *
      * assert list[3] == 42   // default value
-     * assert list[2] == null // gap filled with null
+     * assert list == [0, 1, null, 42] // gap filled with null
+     *
+     * // illustrate using the index when generating default values
+     * def list2 = [5].withLazyDefault{ index -> index * index }
+     * assert list2[3] == 9
+     * assert list2 == [5, null, null, 9]
+     * assert list2[2] == 4
+     * assert list2 == [5, null, 4, 9]
+     *
+     * // illustrate what happens with null values
+     * list2[2] = null
+     * assert list2[2] == 4
      * </pre>
      *
      * @param self a List
-     * @param init a Closure which generates the default value and that is passed the target index
-     * @return the wrapped List
-     * @since TODO
+     * @param init a Closure with the target index as parameter which generates the default value
+     * @return the decorated List
+     * @since 1.8.7
      */
-    public static <T> List<T> withLazyDefault(List<T> self, Closure init)  {
+    public static <T> List<T> withLazyDefault(List<T> self, Closure init) {
         return ListWithDefault.newInstance(self, true, init);
     }
 
     /**
-     * Wraps a list using the delegate pattern with a wrapper that intercepts all calls
-     * to <code>getAt(index)</code> and <code>get(index)</code>. If an index greater or equal
-     * than size is used, the list will grow automatically up to the specified index. Gaps
-     * will be filled by the closure generated default value.
-     *
+     * Decorates a list allowing it to grow when called with a non-existent index value.
+     * When called with such values, the list is grown in size and a default value
+     * is placed in the list by calling a supplied <code>init</code> Closure. Null values
+     * can be stored in the list.
+     * <p/>
+     * How it works: The decorated list intercepts all calls
+     * to <code>getAt(index)</code> and <code>get(index)</code>. If an index greater than
+     * or equal to the current <code>size()</code> is used, the list will grow automatically
+     * up to the specified index. Gaps will be filled by calling the <code>init</code> Closure.
+     * If generating a default value is a costly operation consider using <code>withLazyDefault</code>.
+     * <p/>
      * Example usage:
      * <pre class="groovyTestCase">
-     * def list = [0,1].withDefault(false), { 42 }
+     * def list = [0, 1].withEagerDefault{ 42 }
      * assert list[0] == 0
      * assert list[1] == 1
-     *
      * assert list[3] == 42   // default value
-     * assert list[2] == 42   // gap filled with default value
+     * assert list == [0, 1, 42, 42]   // gap filled with default value
+     *
+     * // illustrate using the index when generating default values
+     * def list2 = [5].withEagerDefault{ index -> index * index }
+     * assert list2[3] == 9
+     * assert list2 == [5, 1, 4, 9]
+     *
+     * // illustrate what happens with null values
+     * list2[2] = null
+     * assert list2[2] == null
+     * assert list2 == [5, 1, null, 9]
      * </pre>
      *
      * @param self a List
-     * @param init a Closure which generates the default value and that is passed the target index
+     * @param init a Closure with the target index as parameter which generates the default value
      * @return the wrapped List
-     * @since TODO
+     * @since 1.8.7
      */
-    public static <T> List<T> withEagerDefault(List<T> self, Closure init)  {
+    public static <T> List<T> withEagerDefault(List<T> self, Closure init) {
         return ListWithDefault.newInstance(self, false, init);
     }
 
diff --git a/src/test/groovy/ListTest.groovy b/src/test/groovy/ListTest.groovy
index 0e4b3b57e6..3f46ee168a 100644
--- a/src/test/groovy/ListTest.groovy
+++ b/src/test/groovy/ListTest.groovy
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2011 the original author or authors.
+ * Copyright 2003-2012 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -19,17 +19,12 @@ class ListTest extends GroovyTestCase {
 
     void testList() {
         def x = [10, 11]
-
         assert x.size() == 2
-
         x.add("cheese")
-
         assert x.size() == 3
-
         assert x.contains(10)
         assert x.contains(11)
         assert x.contains("cheese")
-
         assert x.get(0) == 10
         assert x.get(1) == 11
         assert x.get(2) == "cheese"
@@ -40,99 +35,82 @@ class ListTest extends GroovyTestCase {
         assert x[2] == "cheese"
 
         x[3] = 12
-
         assert x[3] == 12
-
-        if ( x.contains("cheese") ) {
-            // ignore
-        } else {
-            assert false , "x should contain cheese!"
-        }
-
-        if ( x.contains(10) ) {
-            // ignore
-        } else {
-            assert false , "x should contain 1!"
-        }
+        assert x.contains("cheese")
+        assert x.contains(10)
     }
-    
+
     void testEmptyList() {
         def x = []
-        
         assert x.size() == 0
-        
         x.add("cheese")
-
         assert x.get(0) == "cheese"
-
         assert x.size() == 1
-
         assert x[0] == "cheese"
     }
-    
+
     void testSubscript() {
         def x = []
         x[1] = 'cheese'
-        
         assert x[0] == null
         assert x[1] == 'cheese'
-        
+
         x[2] = 'gromit'
         x[3] = 'wallace'
-        
         assert x.size() == 4
-        
+
         x[-1] = 'nice'
-        
         assert x[3] == 'nice'
-        
+
         x[-2] = 'cheese'
-        
         assert x[2] == 'cheese'
     }
-    
+
     void testClosure() {
         def l = [1, 2, 3, "abc"]
-        def block = {i -> println(i) }
+        def result = ''
+        def block = { i -> result += i }
         l.each(block)
-        l.each {i-> println(i) }
+        assert result == '123abc'
+        l.each { i -> result += i }
+        assert result == '123abc123abc'
     }
-    
+
     void testMax() {
         def l = [1, 2, 5, 3, 7, 1]
         assert l.max() == 7
-        
+
         l = [7, 2, 3]
         assert l.max() == 7
-        
+
         l = [1, 2, 7]
         assert l.max() == 7
 
         // GROOVY-1006        
-        l = [1, 3.2, 4L, (short)7]
-        assert l.max() == (short)7
+        l = [1, 3.2, 4L, (short) 7]
+        assert l.max() == (short) 7
     }
-    
+
     void testMin() {
         def l = [6, 4, 5, 1, 7, 2]
         assert l.min() == 1
-        
+
         l = [7, 1, 3]
         assert l.min() == 1
-        
+
         l = [1, 2, 7]
         assert l.min() == 1
 
         // GROOVY-1006        
-        l = [(long)1, 3.2, 4L, (short)7]
-        assert l.min() == (long)1
+        l = [(long) 1, 3.2, 4L, (short) 7]
+        assert l.min() == (long) 1
     }
-    
+
     void testPlus() {
         def l1 = [6, 4, 5, 1, 7, 2]
-        def l2 = [6, 4, 5, 1, 7, [4,5]]
+        def l2 = [6, 4, 5, 1, 7, [4, 5]]
         def l3 = l1 + l2
-        assert l3 == [6, 4, 5, 1, 7, 2, 6, 4, 5, 1, 7, [4,5]]
+        assert l3 == [6, 4, 5, 1, 7, 2, 6, 4, 5, 1, 7, [4, 5]]
 
         l1 = [1, 5.2, 9]
         l2 = [3, 4L]
@@ -143,23 +121,19 @@ class ListTest extends GroovyTestCase {
     void testPlusOneElement() {
         def l1 = [6, 4, 5, 1, 7, 2]
         def l2 = "erererer"
-        assert l1 + l2 == [6, 4, 5, 1, 7, 2, "erererer"]            
+        assert l1 + l2 == [6, 4, 5, 1, 7, 2, "erererer"]
     }
 
     void testListAppend() {
         def list = [1, 2]
-        
         list << 3 << 4 << 5
-        
         assert list == [1, 2, 3, 4, 5]
-        
         def x = [] << 'a' << 'hello' << [2, 3] << 5
-        
         assert x == ['a', 'hello', [2, 3], 5]
     }
 
     void testTimes() {
-        def l = [4,7,8]
+        def l = [4, 7, 8]
         assert l * 3 == [4, 7, 8, 4, 7, 8, 4, 7, 8]
     }
 
@@ -167,55 +141,55 @@ class ListTest extends GroovyTestCase {
     void testMinus() {
         def l1 = [1, 1, 2, 2, 3, 3, 3, 4, 5, 3, 5]
         def l2 = [1, 2.0, 4L]
-        assert l1 - l2 == [3, 3, 3, 5, 3, 5] 
+        assert l1 - l2 == [3, 3, 3, 5, 3, 5]
     }
 
     // GROOVY-1006
     void testMinusDifferentTypes() {
         def l1 = [1, 1, "wrer", 2, 3, 3, "wrewer", 4, 5, "w", "w"]
         def l2 = [1, 2, "w"]
-        assert l1 - l2 == ["wrer", 3, 3, "wrewer", 4, 5] 
+        assert l1 - l2 == ["wrer", 3, 3, "wrewer", 4, 5]
     }
 
-    void testMinusEmptyCollection(){
+    void testMinusEmptyCollection() {
         // GROOVY-790
-        def list = [1,1]
+        def list = [1, 1]
         assert list - [] == list
 
         // GROOVY-1006    
-        list = [1,2,2,3,1]
+        list = [1, 2, 2, 3, 1]
         assert list - [] == list
     }
-     
+
     void testIntersect() {
         def l1 = [1, 1, "wrer", 2, 3, 3, "wrewer", 4, 5, "w", "w"]
         def l2 = [1, 2, "f", "w"]
-        assert l1.intersect(l2) == [1, 2, "w"] 
+        assert l1.intersect(l2) == [1, 2, "w"]
 
         // GROOVY-1006    
         l1 = [1, 1.0, "wrer", 2, 3, 3L, "wrewer", 4, 5, "w", "w"]
-        l2 = [(double)1, 2L, "f", "w"]
-        assert l1.intersect(l2) == [1, 2, "w"] 
+        l2 = [(double) 1, 2L, "f", "w"]
+        assert l1.intersect(l2) == [1, 2, "w"]
     }
-      
+
     // GROOVY-1006
     void testListEqual() {
-        assert [1, 2.0, 3L, (short)4] == [1, 2, 3, 4]
+        assert [1, 2.0, 3L, (short) 4] == [1, 2, 3, 4]
     }
-      
+
     // GROOVY-1006
     void testSortNumbersMixedType() {
-        assert [1, (short)3, 4L, 2.9, (float)5.2].sort() == [1, 2.9, (short)3, 4L, (float)5.2] 
+        assert [1, (short) 3, 4L, 2.9, (float) 5.2].sort() == [1, 2.9, (short) 3, 4L, (float) 5.2]
     }
-      
+
     // GROOVY-1006
     void testUnique() {
         def a = [1, 4L, 1.0]
         def b = a.unique()
         assert (b == a && a == [1, 4])
-        a =[1, "foo", (short)3, 4L, 1.0, (float)3.0]
+        a = [1, "foo", (short) 3, 4L, 1.0, (float) 3.0]
         b = a.unique()
-        assert (b == a && a == [1, "foo", (short)3, 4L])
+        assert (b == a && a == [1, "foo", (short) 3, 4L])
     }
 
     // incorporates GROOVY-2904 and GROOVY-3102
@@ -226,7 +200,7 @@ class ListTest extends GroovyTestCase {
     }
 
     void testFlattenListOfMaps() {
-        def orig = [[a:1, b:2], [c:3, d:4]]
+        def orig = [[a: 1, b: 2], [c: 3, d: 4]]
         def flat = orig.flatten()
         assert flat == orig
     }
@@ -246,10 +220,10 @@ class ListTest extends GroovyTestCase {
     }
 
     void testFlattenListOfMapsWithClosure() {
-        def orig = [[a:1, b:2], [c:3, d:4]]
-        def flat = orig.flatten{ it instanceof Map ? it.values() : it }
-        assert flat == [1, 2, 3 ,4]
-        flat = orig.flatten{ it instanceof Map ? it.keySet() : it }
+        def orig = [[a: 1, b: 2], [c: 3, d: 4]]
+        def flat = orig.flatten { it instanceof Map ? it.values() : it }
+        assert flat == [1, 2, 3, 4]
+        flat = orig.flatten { it instanceof Map ? it.keySet() : it }
         assert flat == ["a", "b", "c", "d"]
     }
 
@@ -257,14 +231,14 @@ class ListTest extends GroovyTestCase {
         def flat = [1, 3, 20..24, 33].flatten()
         assert flat == [1, 3, 20, 21, 22, 23, 24, 33]
     }
-    
+
     void testListsAndRangesCompare() {
         def l = [1, 2, 3]
         def r = 1..3
         assert r == l
         assert l == r
     }
-    
+
     void testRemove() {
         def l = ['a', 'b', 'c']
         l.remove(1)
@@ -273,25 +247,25 @@ class ListTest extends GroovyTestCase {
         assert l == ['c']
         assert l.size() == 1
     }
-    
+
     void testPop() {
         def l = []
         l << 'a' << 'b'
         def value = l.pop()
         assert value == 'b'
         assert l == ['a']
-        
+
         l.add('c')
         value = l.pop()
         assert value == 'c'
         value = l.pop()
         assert value == 'a'
         try {
-            value = l.pop()
+            l.pop()
             fail("Should have thrown an exception")
         }
         catch (NoSuchElementException e) {
-            println "Worked: caught expected exception: ${e}"
+            assert e.message.contains('Cannot pop() an empty List')
         }
     }
 
@@ -310,102 +284,99 @@ class ListTest extends GroovyTestCase {
             fail("[] should have evaluated to false, but didn't")
         }
         list = [1]
-        if (list) {
-            // OK
-        } else {
-            fail("[] should have evaluated to false, but didn't")
+        if (!list) {
+            fail("[1] should have evaluated to true, but didn't")
         }
     }
 
     // see also SubscriptTest
-    void testGetAtRange(){
-        def list = [0,1,2,3]
-        assert list[0..3] == list           , 'full list'
-        assert list[0..0] == [0]            , 'one element range'
-        assert list[0..<0] == []            , 'empty range'
-        assert list[3..0] == [3,2,1,0]      , 'reverse range'
-        assert list[3..<0] == [3,2,1]       , 'reverse exclusive range'
-        assert list[-2..-1] == [2,3]        , 'negative index range'
-        assert list[-2..<-1] == [2]         , 'negative index range exclusive'
-        assert list[-1..-2] == [3,2]        , 'negative index range reversed'
-        assert list[-1..<-2] == [3]         , 'negative index range reversed exclusive'  // aaaahhhhh !
-        assert list[0..-1] == list          , 'pos - neg value'
-        assert list[0..<-1] == [0]          , 'pos - neg value exclusive -> empty'
-        assert list[0..<-2] == list         , 'pos - neg value exclusive -> full'
-        // TODO reinstate this test
-        //shouldFail (NullPointerException.class)      { list[null] }
-        shouldFail (IndexOutOfBoundsException.class) { list[5..6] }
-    }
-
-    void testPutAtSplice(){
+    void testGetAtRange() {
+        def list = [0, 1, 2, 3]
+        assert list[0..3] == list         , 'full list'
+        assert list[0..0] == [0]          , 'one element range'
+        assert list[0..<0] == []          , 'empty range'
+        assert list[3..0] == [3, 2, 1, 0] , 'reverse range'
+        assert list[3..<0] == [3, 2, 1]   , 'reverse exclusive range'
+        assert list[-2..-1] == [2, 3]     , 'negative index range'
+        assert list[-2..<-1] == [2]       , 'negative index range exclusive'
+        assert list[-1..-2] == [3, 2]     , 'negative index range reversed'
+        assert list[-1..<-2] == [3]       , 'negative index range reversed exclusive'  // aaaahhhhh !
+        assert list[0..-1] == list        , 'pos - neg value'
+        assert list[0..<-1] == [0]        , 'pos - neg value exclusive -> empty'
+        assert list[0..<-2] == list       , 'pos - neg value exclusive -> full'
+        shouldFail(NullPointerException) { list[null] }
+        shouldFail(IndexOutOfBoundsException) { list[5..6] }
+    }
+
+    void testPutAtSplice() {
         // usual assignments
-        def list = [0,1,2,3]
-        list[1,2] = [11,12]
-        assert list == [0, 11, 12, 3 ]      , 'same length assignment'
-        list = [0,1,2,3]
-        shouldFail (java.lang.IllegalArgumentException.class) {
-            list[1,1] = [11]
+        def list = [0, 1, 2, 3]
+        list[1, 2] = [11, 12]
+        assert list == [0, 11, 12, 3], 'same length assignment'
+        list = [0, 1, 2, 3]
+        shouldFail(IllegalArgumentException) {
+            list[1, 1] = [11]
         }
-        list = [0,1,2,3]
-        shouldFail (java.lang.IllegalArgumentException.class) {
-            list[1,0] = [ ]
+        list = [0, 1, 2, 3]
+        shouldFail(IllegalArgumentException) {
+            list[1, 0] = []
         }
         // assignments outside current bounds
-        list = [0,1,2,3]
-        list[-1,-2] = [-1, -2]
-        assert list == [0, 1, -2, -1]        , 'left of left border'
-        list = [0,1,2,3]
+        list = [0, 1, 2, 3]
+        list[-1, -2] = [-1, -2]
+        assert list == [0, 1, -2, -1], 'left of left border'
+        list = [0, 1, 2, 3]
         list[3, 4] = [3, 4]
         assert list == [0, 1, 2, 3, 4]
     }
 
-    void testPutAtRange(){
+    void testPutAtRange() {
         // usual assignments
-        def list = [0,1,2,3]
-        list[1..2] = [11,12]
-        assert list == [0, 11, 12, 3 ]      , 'same length assignment'
-        list = [0,1,2,3]
+        def list = [0, 1, 2, 3]
+        list[1..2] = [11, 12]
+        assert list == [0, 11, 12, 3], 'same length assignment'
+        list = [0, 1, 2, 3]
         list[1..1] = [11]
-        assert list == [0, 11, 2, 3 ]       , 'length 1 assignment'
-        list = [0,1,2,3]
+        assert list == [0, 11, 2, 3], 'length 1 assignment'
+        list = [0, 1, 2, 3]
         list[0..<0] = []
-        assert list == [0, 1, 2, 3 ]        , 'length 0 assignment, empty splice'
+        assert list == [0, 1, 2, 3], 'length 0 assignment, empty splice'
         // assignments at bounds
-        list = [0,1,2,3]
+        list = [0, 1, 2, 3]
         list[0..0] = [10]
-        assert list == [10, 1, 2, 3 ]       , 'left border assignment'
-        list = [0,1,2,3]
+        assert list == [10, 1, 2, 3], 'left border assignment'
+        list = [0, 1, 2, 3]
         list[3..3] = [13]
-        assert list == [0, 1, 2, 13 ]       , 'right border assignment'
+        assert list == [0, 1, 2, 13], 'right border assignment'
         // assignments outside current bounds
-        list = [0,1,2,3]
+        list = [0, 1, 2, 3]
         list[-1..-1] = [-1]
-        assert list == [0, 1, 2, -1]        , 'left of left border'
-        list = [0,1,2,3]
-        list[3..4] = [3,4]
+        assert list == [0, 1, 2, -1], 'left of left border'
+        list = [0, 1, 2, 3]
+        list[3..4] = [3, 4]
         assert list == [0, 1, 2, 3, 4]
         // structural changes
-        list = [0,1,2,3]
+        list = [0, 1, 2, 3]
         list[1..2] = ['x']
-        assert list == [0, 'x', 3]          , 'compacting'
-        list = [0,1,2,3]
-        list[1..2] = ['x','x','x']
-        assert list == [0, 'x','x','x', 3]  , 'extending'
+        assert list == [0, 'x', 3], 'compacting'
+        list = [0, 1, 2, 3]
+        list[1..2] = ['x', 'x', 'x']
+        assert list == [0, 'x', 'x', 'x', 3], 'extending'
     }
 
-    void testCrazyPutAtRange(){
+    void testCrazyPutAtRange() {
         def list = []
-        list[0..<0] = [0,1,2,3]
-        assert list == [0, 1, 2, 3 ]        , 'fill by empty Range'
-        list = [0,1,2,3]
+        list[0..<0] = [0, 1, 2, 3]
+        assert list == [0, 1, 2, 3], 'fill by empty Range'
+        list = [0, 1, 2, 3]
         list[3..0] = []
-        assert list == []                   , 'delete by reverse Range'
-        list = [0,1,2,3]
+        assert list == [], 'delete by reverse Range'
+        list = [0, 1, 2, 3]
         list[-4..-1] = []
-        assert list == []                   , 'delete by negativ Range'
-        list = [0,1,2,3]
+        assert list == [], 'delete by negativ Range'
+        list = [0, 1, 2, 3]
         list[0..-1] = []
-        assert list == []                   , 'delete by pos-negativ Range'
+        assert list == [], 'delete by pos-negativ Range'
     }
 
     // GROOVY-1128
@@ -416,19 +387,19 @@ class ListTest extends GroovyTestCase {
 
     // GROOVY-1128
     void testAsImmutable() {
-        def immlist = [1,2,3].asImmutable()
-        assert immlist == [1,2,3]
-        def testlist = ['a','b','c','d','e']
-        assert testlist[immlist] == ['b','c','d']
+        def immlist = [1, 2, 3].asImmutable()
+        assert immlist == [1, 2, 3]
+        def testlist = ['a', 'b', 'c', 'd', 'e']
+        assert testlist[immlist] == ['b', 'c', 'd']
         assert immlist[0] == 1
         assert immlist[0..-1] == immlist
-        shouldFail(UnsupportedOperationException.class){
+        shouldFail(UnsupportedOperationException) {
             immlist << 1
         }
-        shouldFail(UnsupportedOperationException.class){
+        shouldFail(UnsupportedOperationException) {
             immlist[0..<0] = [0]
         }
-        shouldFail(UnsupportedOperationException.class){
+        shouldFail(UnsupportedOperationException) {
             immlist[0] = 1
         }
     }
@@ -439,51 +410,46 @@ class ListTest extends GroovyTestCase {
         assert l1[0] == 42
         assert l1[2] == 42
         assert l1 == [42, null, 42]
-
-        assert l1[1] == 42
-
         assert l1[-1] == 42
         assert l1[-3] == 42
+        assert l1[1] == 42
 
         def l2 = [].withLazyDefault { 42 }
         assert l2[-1] == 42
         assert l2.size() == 1
-        assert l2[0]  == 42
+        assert l2[0] == 42
 
         def l3 = [].withLazyDefault { it }
         assert l3[-1] == 0
-        assert l3[1]  == 1
-        assert l3[3]  == 3
+        assert l3[1] == 1
+        assert l3[3] == 3
 
-        def l5 = [0,1,null,3].withLazyDefault { 42 }
-        assert l5[0] == 0
+        def l4 = [0, 1, null, 3].withLazyDefault { 42 }
+        assert l4[0] == 0
+        assert l4[1] == 1
+        assert l4[3] == 3
+        assert l4 == [0, 1, null, 3]
+
+        def l5 = [].withLazyDefault { it }
+        assert l5[-1] == 0
         assert l5[1] == 1
         assert l5[3] == 3
-        assert l5 == [0,1,null,3]
-
-        def l8 = [].withLazyDefault { it }
-        assert l8[-1] == 0
-        assert l8[1]  == 1
-        assert l8[3]  == 3
-        assert l8[5]  == 5
-        assert l8 == [0,1,null,3,null,5]
+        assert l5[5] == 5
+        assert l5 == [0, 1, null, 3, null, 5]
 
-        def l9 = [].withLazyDefault { int index -> index }
-        assert l9[-1] == 0
-        assert l9[1]  == 1
-        assert l9[3]  == 3
-        assert l9[5]  == 5
-
-        assert l9[0..5] == [0, 1, null, 3, null, 5]
+        def l6 = [].withLazyDefault { int index -> index }
+        assert l6[-1] == 0
+        assert l6[1] == 1
+        assert l6[3] == 3
+        assert l6[5] == 5
+        assert l6[0..5] == [0, 1, null, 3, null, 5]
     }
 
     void testWithEagerDefault() {
-
         def l1 = [].withEagerDefault { 42 }
         assert l1[0] == 42
         assert l1[2] == 42
         assert l1 == [42, 42, 42]
-
         assert l1[1] == 42
         assert l1[-1] == 42
         assert l1[-3] == 42
@@ -491,59 +457,52 @@ class ListTest extends GroovyTestCase {
         def l2 = [].withEagerDefault { 42 }
         assert l2[-1] == 42
         assert l2.size() == 1
-        assert l2[0]  == 42
+        assert l2[0] == 42
 
         def l3 = [].withEagerDefault { it }
         assert l3[-1] == 0
-        assert l3[1]  == 1
-        assert l3[3]  == 3
-
-        assert l3 == [0,1,2,3]
-
-        def l5 = [0,1,null,3].withEagerDefault { 42 }
-        assert l5[0] == 0
+        assert l3[1] == 1
+        assert l3[3] == 3
+        assert l3 == [0, 1, 2, 3]
+
+        def l4 = [0, 1, null, 3].withEagerDefault { 42 }
+        assert l4[0] == 0
+        assert l4[1] == 1
+        assert l4[3] == 3
+        assert l4 == [0, 1, null, 3]
+
+        def l5 = [].withEagerDefault { it }
+        assert l5[-1] == 0
         assert l5[1] == 1
         assert l5[3] == 3
-        assert l5 == [0,1,null,3]
-
-        def l8 = [].withEagerDefault { it }
-        assert l8[-1] == 0
-        assert l8[1]  == 1
-        assert l8[3]  == 3
-        assert l8[5]  == 5
-        assert l8 == [0,1,2,3,4,5]
-
-        def l9 = [].withEagerDefault { int index -> index }
-        assert l9[-1] == 0
-        assert l9[1]  == 1
-        assert l9[3]  == 3
-        assert l9[5]  == 5
-
-        assert l9[0..5] == [0, 1, 2, 3, 4, 5]
+        assert l5[5] == 5
+        assert l5 == [0, 1, 2, 3, 4, 5]
 
+        def l6 = [].withEagerDefault { int index -> index }
+        assert l6[-1] == 0
+        assert l6[1] == 1
+        assert l6[3] == 3
+        assert l6[5] == 5
+        assert l6[0..5] == [0, 1, 2, 3, 4, 5]
     }
 
     void testWithDefaultReturnWithDefaultSubList() {
-
         def l1 = [].withLazyDefault { 42 }
         assert l1[2] == 42
-        assert l1.size() == 3
+        assert l1 == [null, null, 42]
 
         def l2 = l1.subList(0, 2)
-        assert l2.size() == 2
         assert l2 == [null, null]
         assert l2[2] == 42
         assert l2 == [null, null, 42]
     }
-    
-    void testWithDefaultRedirectsToWithLazyDefault()  {
-        
+
+    void testWithDefaultRedirectsToWithLazyDefault() {
         def l1 = [].withDefault { 42 }
         assert l1[2] == 42
         assert l1 == [null, null, 42]
-        
     }
-    
+
     void testWithDefaultNullAsDefaultValue() {
         def l1 = [].withEagerDefault { null }
         assert l1[0] == null
