diff --git a/src/main/org/codehaus/groovy/control/StaticImportVisitor.java b/src/main/org/codehaus/groovy/control/StaticImportVisitor.java
index 02cc386bec..97939896e1 100644
--- a/src/main/org/codehaus/groovy/control/StaticImportVisitor.java
+++ b/src/main/org/codehaus/groovy/control/StaticImportVisitor.java
@@ -35,6 +35,8 @@ public class StaticImportVisitor extends ClassCodeExpressionTransformer {
     private boolean inSpecialContructorCall;
     private boolean inClosure;
     private boolean inPropertyExpression;
+    private Expression foundMethod;
+    private Expression foundArgs;
 
     public StaticImportVisitor(CompilationUnit cu) {
         compilationUnit = cu;
@@ -63,6 +65,20 @@ public class StaticImportVisitor extends ClassCodeExpressionTransformer {
         if (exp.getClass() == ConstructorCallExpression.class) {
             return transformConstructorCallExpression((ConstructorCallExpression) exp);
         }
+        if (exp.getClass() == ArgumentListExpression.class) {
+            Expression result = exp.transformExpression(this);
+            if (inPropertyExpression) {
+                foundArgs = result;
+            }
+            return result;
+        }
+        if (exp.getClass() == ConstantExpression.class) {
+            Expression result = exp.transformExpression(this);
+            if (inPropertyExpression) {
+                foundMethod = result;
+            }
+            return result;
+        }
         return exp.transformExpression(this);
     }
 
@@ -105,14 +121,27 @@ public class StaticImportVisitor extends ClassCodeExpressionTransformer {
         return ce;
     }
 
+    // TODO: find a nicer way to do this - we are unravelling what ResolveVisitor ravelled
     protected Expression transformPropertyExpression(PropertyExpression pe) {
-        boolean ipe = inPropertyExpression;
+        boolean oldInPropertyExpression = inPropertyExpression;
+        Expression oldFoundArgs = foundArgs;
+        Expression oldFoundMethod = foundMethod;
         Expression objectExpression = pe.getObjectExpression();
         inPropertyExpression = true;
+        foundArgs = null;
+        foundMethod = null;
         objectExpression = objectExpression.transformExpression(this);
+        if (foundArgs != null && foundMethod != null) {
+            Expression result = findStaticMethodImportFromModule(foundMethod, foundArgs);
+            if (result != null) {
+                objectExpression = result;
+            }
+        }
         inPropertyExpression = false;
         Expression property = pe.getProperty().transformExpression(this);
-        inPropertyExpression = ipe;
+        inPropertyExpression = oldInPropertyExpression;
+        foundArgs = oldFoundArgs;
+        foundMethod = oldFoundMethod;
 
         boolean spreadSafe = pe.isSpreadSafe();
         pe = new PropertyExpression(objectExpression, property, pe.isSafe());
@@ -187,7 +216,10 @@ public class StaticImportVisitor extends ClassCodeExpressionTransformer {
         if (module == null || !(method instanceof ConstantExpression)) return null;
         Map aliases = module.getStaticImportAliases();
         ConstantExpression ce = (ConstantExpression) method;
-        final String name = (String) ce.getValue();
+        Object value = ce.getValue();
+        // skip non-Strings, e.g. Integer
+        if (!(value instanceof String)) return null;
+        final String name = (String) value;
         if (aliases.containsKey(name)) {
             ClassNode node = (ClassNode) aliases.get(name);
             Map fields = module.getStaticImportFields();
diff --git a/src/test/gls/scope/StaticScopeTest.groovy b/src/test/gls/scope/StaticScopeTest.groovy
index 8b705a2d24..2995405420 100644
--- a/src/test/gls/scope/StaticScopeTest.groovy
+++ b/src/test/gls/scope/StaticScopeTest.groovy
@@ -58,13 +58,32 @@ public class StaticScopeTest extends CompilableTestSupport {
     }
 
     public void testClosureInStaticScope() {
-        shouldCompile("""
+        shouldCompile """
         5.times { foo=2 }
-        """)
+        """
 
-        shouldCompile("""
+        shouldCompile """
         5.times { foo=it }
-        """)
+        """
+    }
+
+    public void testScriptMethodCall() {
+        assertScript """
+        import static java.util.Calendar.getInstance as now
+        def now = now().time
+        assert now.class == Date
+        """
+
+        // TODO: why does in-lining of now variable break? GROOVY-1809 issue?
+        assertScript """
+        import static java.util.Calendar.getInstance as now
+        assert now().time.getClass() == Date
+        """
+
+        shouldCompile """
+        import static java.lang.Math.*
+        cos(cos(cos(PI)))
+        """
     }
 
     public void testFullyQualifiedClassName() {
diff --git a/src/test/groovy/StaticImportTarget.groovy b/src/test/groovy/StaticImportTarget.groovy
index 158cf6d26b..b4b945b221 100644
--- a/src/test/groovy/StaticImportTarget.groovy
+++ b/src/test/groovy/StaticImportTarget.groovy
@@ -5,6 +5,6 @@ class StaticImportTarget {
         return message * times
     }
     def y(String message, int times) {
-        return message * times
+        return x(message, times)
     }
 }
diff --git a/src/test/groovy/StaticImportTest.groovy b/src/test/groovy/StaticImportTest.groovy
index f1eb92583d..c5104ce09a 100644
--- a/src/test/groovy/StaticImportTest.groovy
+++ b/src/test/groovy/StaticImportTest.groovy
@@ -1,6 +1,6 @@
 package groovy
 
-import static Boolean.FALSE as F
+import static java.lang.Boolean.FALSE as F
 import static java.text.DateFormat.MEDIUM as M
 import static java.text.DateFormat.MEDIUM
 import static java.awt.Color.*
@@ -8,29 +8,47 @@ import static junit.framework.Assert.format
 import static junit.framework.Assert.assertEquals
 import static StaticImportTarget.x
 import static java.lang.Math.*
+import static java.util.Calendar.getInstance as now
 
 class StaticImportTest extends GroovyTestCase {
-    void testNormalUsage() {
+    void testFieldWithAliasInExpression() {
         assert !F
     }
 
-    void testMath() {
+    void testMethodAndField() {
         assert cos(2 * PI) == 1.0
+    }
+
+    static myStaticMethod() {
+        cos(2 * PI)
+    }
+
+    void testMethodAndFieldInStaticContext() {
+        assert myStaticMethod() == 1.0
+    }
+
+    void testMethodAndFieldInClosure() {
         def closure = { cos(2 * PI) }
         assert closure() == 1.0
     }
 
-    void testAliasing() {
+    void testFieldAliasing() {
         assert MEDIUM == M
     }
 
-    void testWildCarding() {
+    void testMethodAliasing() {
+        // GROOVY-1809 making this not possible on one line?
+        def now = now().time
+        assert now.class == Date
+    }
+
+    void testWildCardAliasing() {
         assert LIGHT_GRAY == java.awt.Color.LIGHT_GRAY
     }
 
     private format(a, b, c, ignored) { format(a, b, c) }
 
-    void testMethodSelection() {
+    void testMethodDefCanUseStaticallyImportedMethodWithSameNameButDiffArgs() {
         assert format("different", "abc", "aBc", 3) == 'different expected:<abc> but was:<aBc>'
     }
 
