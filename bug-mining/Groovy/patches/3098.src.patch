diff --git a/src/main/org/codehaus/groovy/classgen/asm/InvocationWriter.java b/src/main/org/codehaus/groovy/classgen/asm/InvocationWriter.java
index 748586731c..55579834e7 100644
--- a/src/main/org/codehaus/groovy/classgen/asm/InvocationWriter.java
+++ b/src/main/org/codehaus/groovy/classgen/asm/InvocationWriter.java
@@ -334,6 +334,11 @@ public class InvocationWriter {
         } else {
             sender.visit(acg);
         }
+
+        String methodName = getMethodName(message);
+        if (adapter == invokeMethodOnSuper && methodName != null) {
+            controller.getSuperMethodNames().add(methodName);
+        }
         
         // receiver
         compileStack.pushImplicitThis(implicitThis);
diff --git a/src/main/org/codehaus/groovy/classgen/asm/MopWriter.java b/src/main/org/codehaus/groovy/classgen/asm/MopWriter.java
index 720382fea5..af65c9d20a 100644
--- a/src/main/org/codehaus/groovy/classgen/asm/MopWriter.java
+++ b/src/main/org/codehaus/groovy/classgen/asm/MopWriter.java
@@ -79,8 +79,8 @@ public class MopWriter {
             return;
         }
         Set<MopKey> currentClassSignatures = buildCurrentClassSignatureSet(classNode.getMethods());
-        visitMopMethodList(classNode.getMethods(), true, Collections.EMPTY_SET);
-        visitMopMethodList(classNode.getSuperClass().getAllDeclaredMethods(), false, currentClassSignatures);
+        visitMopMethodList(classNode.getMethods(), true, Collections.EMPTY_SET, Collections.EMPTY_LIST);
+        visitMopMethodList(classNode.getSuperClass().getAllDeclaredMethods(), false, currentClassSignatures, controller.getSuperMethodNames());
     }
 
     private static Set<MopKey> buildCurrentClassSignatureSet(List<MethodNode> methods) {
@@ -104,7 +104,7 @@ public class MopWriter {
      * @param isThis  if true, then we are creating a MOP method on "this", "super" else
      * @see #generateMopCalls(LinkedList, boolean)
      */
-    private void visitMopMethodList(List<MethodNode> methods, boolean isThis, Set<MopKey> useOnlyIfDeclaredHereToo) {
+    private void visitMopMethodList(List<MethodNode> methods, boolean isThis, Set<MopKey> useOnlyIfDeclaredHereToo, List<String> orNameMentionedHere) {
         HashMap<MopKey, MethodNode> mops = new HashMap<MopKey, MethodNode>();
         LinkedList<MethodNode> mopCalls = new LinkedList<MethodNode>();
         for (MethodNode mn : methods) {
@@ -123,7 +123,11 @@ public class MopWriter {
                 continue;
             }
             if (methodName.startsWith("<")) continue;
-            if (!useOnlyIfDeclaredHereToo.contains(new MopKey(methodName, mn.getParameters()))) continue;
+            if (!useOnlyIfDeclaredHereToo.contains(new MopKey(methodName, mn.getParameters())) &&
+                !orNameMentionedHere.contains(methodName))
+            {
+                continue;
+            }
             String name = getMopMethodName(mn, isThis);
             MopKey key = new MopKey(name, mn.getParameters());
             if (mops.containsKey(key)) continue;
diff --git a/src/main/org/codehaus/groovy/classgen/asm/WriterController.java b/src/main/org/codehaus/groovy/classgen/asm/WriterController.java
index e6246b44d7..6856c07169 100644
--- a/src/main/org/codehaus/groovy/classgen/asm/WriterController.java
+++ b/src/main/org/codehaus/groovy/classgen/asm/WriterController.java
@@ -19,10 +19,10 @@
 package org.codehaus.groovy.classgen.asm;
 
 import groovy.lang.GroovyRuntimeException;
-
 import java.lang.reflect.Constructor;
+import java.util.ArrayList;
+import java.util.List;
 import java.util.Map;
-
 import org.codehaus.groovy.GroovyBugError;
 import org.codehaus.groovy.ast.ClassHelper;
 import org.codehaus.groovy.ast.ClassNode;
@@ -83,6 +83,7 @@ public class WriterController {
     private int bytecodeVersion = Opcodes.V1_5;
     private int lineNumber = -1;
     private int helperMethodIndex = 0;
+    private List<String> superMethodNames = new ArrayList<String>();
 
     public void init(AsmClassGenerator asmClassGenerator, GeneratorContext gcon, ClassVisitor cv, ClassNode cn) {
         CompilerConfiguration config = cn.getCompileUnit().getConfig();
@@ -406,4 +407,8 @@ public class WriterController {
     public int getNextHelperMethodIndex() {
         return helperMethodIndex++;
     }
+
+    public List<String> getSuperMethodNames() {
+        return superMethodNames;
+    }
 }
diff --git a/src/test/gls/invocation/MethodSelectionTest.groovy b/src/test/gls/invocation/MethodSelectionTest.groovy
index 4fd533136b..ae131eacbc 100644
--- a/src/test/gls/invocation/MethodSelectionTest.groovy
+++ b/src/test/gls/invocation/MethodSelectionTest.groovy
@@ -430,6 +430,73 @@ public class MethodSelectionTest extends CompilableTestSupport {
           assert 3 == exp.takeBigInteger(new MyInteger("3"))
       '''
   }
+
+  // GROOVY-7655
+  void testOverloadAndSuper() {
+      assertScript '''
+        class A {
+            boolean aCalled = false
+            def myMethod( def item ) {
+                aCalled = true
+            }
+        }
+
+        class B extends A {
+            boolean bCalled = false
+            def myMethod( def item ) {
+                super.myMethod( item+"B" )
+                bCalled = true
+            }
+        }
+
+        class C extends B {
+            boolean cCalled = false
+            def cMethod( def item ) {
+                super.myMethod( item )
+                cCalled = true
+            }
+        }
+
+        def c = new C()
+        c.cMethod( "stuff" )
+
+        assert c.aCalled
+        assert c.bCalled
+        assert c.cCalled
+      '''
+      assertScript '''
+        class A {
+            boolean aCalled = false
+            def myMethod( def item ) {
+                aCalled = true
+            }
+        }
+
+        class B extends A {
+            boolean bCalled = false
+            def myMethod( def item ) {
+                super.myMethod( item+"B" )
+                bCalled = true
+            }
+        }
+
+        class C extends B { }
+        class D extends C {
+            boolean dCalled = false
+            def dMethod( def item ) {
+                super.myMethod( item )
+                dCalled = true
+            }
+        }
+
+        def d = new D()
+        d.dMethod( "stuff" )
+
+        assert d.aCalled
+        assert d.bCalled
+        assert d.dCalled
+      '''
+  }
 }
 
 class Foo3977 {
