diff --git a/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java b/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java
index f03e487f58..e37b1e9ea6 100644
--- a/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java
+++ b/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java
@@ -2299,7 +2299,7 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
         	if (right!=null) {
         		size = expression(right);
         	} else {
-        		size = ConstantExpression.EMTPY_EXPRESSION;
+        		size = ConstantExpression.EMPTY_EXPRESSION;
         	}
         	list = arraySizeExpression(node.getFirstChild());
         } else {
diff --git a/src/main/org/codehaus/groovy/ast/expr/AnnotationConstantExpression.java b/src/main/org/codehaus/groovy/ast/expr/AnnotationConstantExpression.java
index f782bd9432..0d5e64bfc7 100644
--- a/src/main/org/codehaus/groovy/ast/expr/AnnotationConstantExpression.java
+++ b/src/main/org/codehaus/groovy/ast/expr/AnnotationConstantExpression.java
@@ -20,11 +20,10 @@ import java.util.Map;
 import org.codehaus.groovy.ast.AnnotationNode;
 import org.codehaus.groovy.ast.GroovyCodeVisitor;
 
-
 /**
- * Represents an annotation "constant" that may appear in annotation attributes 
+ * Represents an annotation "constant" that may appear in annotation attributes
  * (mainly used as a marker).
- * 
+ *
  * @author <a href='mailto:the[dot]mindstorm[at]gmail[dot]com'>Alex Popescu</a>
  * @version $Revision: 3264 $
  */
@@ -33,11 +32,11 @@ public class AnnotationConstantExpression extends ConstantExpression {
         super(node);
         setType(node.getClassNode());
     }
-    
+
     public void visit(GroovyCodeVisitor visitor) {
         AnnotationNode node = (AnnotationNode) getValue();
         Map<String, Expression> attrs = node.getMembers();
-        for(Expression expr : attrs.values() ) {
+        for (Expression expr : attrs.values()) {
             expr.visit(visitor);
         }
     }
diff --git a/src/main/org/codehaus/groovy/ast/expr/ConstantExpression.java b/src/main/org/codehaus/groovy/ast/expr/ConstantExpression.java
index b6fbea9ecb..a1dc9b4075 100644
--- a/src/main/org/codehaus/groovy/ast/expr/ConstantExpression.java
+++ b/src/main/org/codehaus/groovy/ast/expr/ConstantExpression.java
@@ -36,11 +36,11 @@ public class ConstantExpression extends Expression {
 
     // the following fields are only used internally; there are no user-defined expressions of the same kind
     public static final ConstantExpression VOID = new ConstantExpression(Void.class);
-    public static final ConstantExpression EMTPY_EXPRESSION = new ConstantExpression(null);
+    public static final ConstantExpression EMPTY_EXPRESSION = new ConstantExpression(null);
     
     private Object value;
     private String constantName;
-    
+
     public ConstantExpression(Object value) {
         this.value = value;
         if (this.value != null)
diff --git a/src/main/org/codehaus/groovy/classgen/AnnotationVisitor.java b/src/main/org/codehaus/groovy/classgen/AnnotationVisitor.java
index bf9e2e31aa..f5e70449a9 100644
--- a/src/main/org/codehaus/groovy/classgen/AnnotationVisitor.java
+++ b/src/main/org/codehaus/groovy/classgen/AnnotationVisitor.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2007 the original author or authors.
+ * Copyright 2003-2009 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -26,22 +26,20 @@ import org.codehaus.groovy.control.messages.SyntaxErrorMessage;
 import org.codehaus.groovy.syntax.SyntaxException;
 import org.codehaus.groovy.vmplugin.VMPluginFactory;
 
-
 /**
  * An Annotation visitor responsible with:
  * - reading annotation metadata (@Retention, @Target, attribute types)
  * - verify that an <code>AnnotationNode</code> conforms to annotation meta
  * - enhancing an <code>AnnotationNode</code> AST to reflect real annotation meta
- * 
+ *
  * @author <a href='mailto:the[dot]mindstorm[at]gmail[dot]com'>Alex Popescu</a>
  */
 public class AnnotationVisitor {
     private SourceUnit source;
     private ErrorCollector errorCollector;
-    
     private AnnotationNode annotation;
     private ClassNode reportClass;
-    
+
     public AnnotationVisitor(SourceUnit source, ErrorCollector errorCollector) {
         this.source = source;
         this.errorCollector = errorCollector;
@@ -55,52 +53,50 @@ public class AnnotationVisitor {
         this.annotation = node;
         this.reportClass = node.getClassNode();
 
-        if(!isValidAnnotationClass(node.getClassNode())) {
+        if (!isValidAnnotationClass(node.getClassNode())) {
             addError("class " + node.getClassNode().getName() + " is not an annotation");
             return node;
         }
-        
+
         // check if values have been passed for all annotation attributes that don't have defaults
-        if(!checkIfMandatoryAnnotationValuesPassed(node)) {
-        	return node;
+        if (!checkIfMandatoryAnnotationValuesPassed(node)) {
+            return node;
         }
 
-        Map attributes = node.getMembers();
-        for(Iterator it = attributes.entrySet().iterator(); it.hasNext(); ) {
-            Map.Entry entry = (Map.Entry) it.next();
+        Map<String, Expression> attributes = node.getMembers();
+        for (Map.Entry entry : attributes.entrySet()) {
             String attrName = (String) entry.getKey();
             Expression attrExpr = (Expression) entry.getValue();
             ClassNode attrType = getAttributeType(node, attrName);
             visitExpression(attrName, attrExpr, attrType);
         }
-
         VMPluginFactory.getPlugin().configureAnnotation(node);
-
         return this.annotation;
     }
 
     private boolean checkIfMandatoryAnnotationValuesPassed(AnnotationNode node) {
-    	boolean ok = true;
-    	Map attributes = node.getMembers();
-    	List<MethodNode> methods = node.getClassNode().getMethods();
-    	for(MethodNode mn : methods) {
-    		String methodName = mn.getName();
-    		// if the annotation attribute has a default, getCode() returns a ReturnStatement with the default value
-    		if(mn.getCode() == null && !attributes.containsKey(methodName)) {
-    			addError("No explicit/default value found for annotation attribute '" + methodName + "' in annotation " + node.getClassNode(), node);
-    			ok = false;
-    		}
-    	}
-    	return ok;
+        boolean ok = true;
+        Map attributes = node.getMembers();
+        ClassNode classNode = node.getClassNode();
+        for (MethodNode mn : classNode.getMethods()) {
+            String methodName = mn.getName();
+            // if the annotation attribute has a default, getCode() returns a ReturnStatement with the default value
+            if (mn.getCode() == null && !attributes.containsKey(methodName)) {
+                addError("No explicit/default value found for annotation attribute '" + methodName + "' in annotation " + classNode, node);
+                ok = false;
+            }
+        }
+        return ok;
     }
 
     private ClassNode getAttributeType(AnnotationNode node, String attrName) {
-        List methods = node.getClassNode().getMethods(attrName);
+        ClassNode classNode = node.getClassNode();
+        List methods = classNode.getMethods(attrName);
         // if size is >1, then the method was overwritten or something, we ignore that
         // if it is an error, we have to test it at another place. But size==0 is
         // an error, because it means that no such attribute exists.
         if (methods.size() == 0) {
-            addError("'" + attrName + "'is not part of the annotation " + node.getClassNode(), node);
+            addError("'" + attrName + "'is not part of the annotation " + classNode, node);
             return ClassHelper.OBJECT_TYPE;
         }
         MethodNode method = (MethodNode) methods.get(0);
@@ -116,7 +112,7 @@ public class AnnotationVisitor {
             // check needed as @Test(attr = {"elem"}) passes through the parser
             if (attrExp instanceof ListExpression) {
                 ListExpression le = (ListExpression) attrExp;
-                visitListExpression(attrName, (ListExpression) attrExp, attrType.getComponentType());
+                visitListExpression(attrName, le, attrType.getComponentType());
             } else if (attrExp instanceof ClosureExpression) {
                 addError("Annotation list attributes must use Groovy notation [el1, el2]", attrExp);
             } else {
@@ -129,12 +125,12 @@ public class AnnotationVisitor {
                 visitExpression(attrName, listExp, attrType);
             }
         } else if (ClassHelper.isPrimitiveType(attrType)) {
-            visitConstantExpression(attrName, getConstantExpression(attrExp), ClassHelper.getWrapper(attrType));
+            visitConstantExpression(attrName, getConstantExpression(attrExp, attrType), ClassHelper.getWrapper(attrType));
         } else if (ClassHelper.STRING_TYPE.equals(attrType)) {
-            visitConstantExpression(attrName, getConstantExpression(attrExp), ClassHelper.STRING_TYPE);
+            visitConstantExpression(attrName, getConstantExpression(attrExp, attrType), ClassHelper.STRING_TYPE);
         } else if (ClassHelper.CLASS_Type.equals(attrType)) {
             if (!(attrExp instanceof ClassExpression)) {
-                addError("Only classes can be used for attribute '"+attrName+"'",attrExp);
+                addError("Only classes can be used for attribute '" + attrName + "'", attrExp);
             }
         } else if (attrType.isDerivedFrom(ClassHelper.Enum_Type)) {
             if (attrExp instanceof PropertyExpression) {
@@ -146,44 +142,51 @@ public class AnnotationVisitor {
             if (attrExp instanceof AnnotationConstantExpression) {
                 visitAnnotationExpression(attrName, (AnnotationConstantExpression) attrExp, attrType);
             } else {
-                addError("Expected annotation of type '"+attrType.getName()+"' for attribute "+attrName, attrExp);
+                addError("Expected annotation of type '" + attrType.getName() + "' for attribute " + attrName, attrExp);
             }
         } else {
-            addError("Unexpected type "+attrType.getName(),attrExp); 
+            addError("Unexpected type " + attrType.getName(), attrExp);
         }
     }
 
-    public void checkReturnType(ClassNode attrType,ASTNode node) {
-        if(attrType.isArray()) {
-             checkReturnType(attrType.getComponentType(),node);
+    public void checkReturnType(ClassNode attrType, ASTNode node) {
+        if (attrType.isArray()) {
+            checkReturnType(attrType.getComponentType(), node);
         } else if (ClassHelper.isPrimitiveType(attrType)) {
-             return;
+            return;
         } else if (ClassHelper.STRING_TYPE.equals(attrType)) {
-             return;
+            return;
         } else if (ClassHelper.CLASS_Type.equals(attrType)) {
-             return;
+            return;
         } else if (attrType.isDerivedFrom(ClassHelper.Enum_Type)) {
-             return;
+            return;
         } else if (isValidAnnotationClass(attrType)) {
             return;
         } else {
-            addError("Unexpected return type "+attrType.getName(),node);
+            addError("Unexpected return type " + attrType.getName(), node);
         }
     }
 
-    private ConstantExpression getConstantExpression(Expression exp) {
+    private ConstantExpression getConstantExpression(Expression exp, ClassNode attrType) {
         if (exp instanceof ConstantExpression) {
             return (ConstantExpression) exp;
         } else {
-            addError("expected a constant",exp);
-            return ConstantExpression.EMTPY_EXPRESSION;
+            String base = "expected '" + exp.getText() + "' to be an inline constant of type " + attrType.getName();
+            if (exp instanceof PropertyExpression) {
+                addError(base + " not a property expression", exp);
+            } else if (exp instanceof VariableExpression && ((VariableExpression)exp).getAccessedVariable() instanceof FieldNode) {
+                addError(base + " not a field expression", exp);
+            } else {
+                addError(base, exp);
+            }
+            return ConstantExpression.EMPTY_EXPRESSION;
         }
     }
-    
+
     /**
-     * @param attrName
-     * @param expression
-     * @param attrType
+     * @param attrName   the name
+     * @param expression the expression
+     * @param attrType   the type
      */
     protected void visitAnnotationExpression(String attrName, AnnotationConstantExpression expression, ClassNode attrType) {
         AnnotationNode annotationNode = (AnnotationNode) expression.getValue();
@@ -192,60 +195,56 @@ public class AnnotationVisitor {
     }
 
     protected void visitListExpression(String attrName, ListExpression listExpr, ClassNode elementType) {
-        List expressions = listExpr.getExpressions();
-        for (int i = 0; i < expressions.size(); i++) {
-            visitExpression(attrName, (Expression) expressions.get(i), elementType);
+        for (Expression expression : listExpr.getExpressions()) {
+            visitExpression(attrName, expression, elementType);
         }
     }
-    
+
     protected void visitConstantExpression(String attrName, ConstantExpression constExpr, ClassNode attrType) {
-        if(!constExpr.getType().isDerivedFrom(attrType)) {
+        if (!constExpr.getType().isDerivedFrom(attrType)) {
             addError("Attribute '" + attrName + "' should have type '" + attrType.getName() + "'; "
                     + "but found type '" + constExpr.getType().getName() + "'",
                     constExpr);
         }
     }
-    
+
     protected void visitEnumExpression(String attrName, PropertyExpression propExpr, ClassNode attrType) {
-        if(!propExpr.getObjectExpression().getType().isDerivedFrom(attrType)) {
-            addError("Attribute '" + attrName + "' should have type '" + attrType.getName() +"' (Enum), but found "
-                    + propExpr.getObjectExpression().getType().getName(), 
+        if (!propExpr.getObjectExpression().getType().isDerivedFrom(attrType)) {
+            addError("Attribute '" + attrName + "' should have type '" + attrType.getName() + "' (Enum), but found "
+                    + propExpr.getObjectExpression().getType().getName(),
                     propExpr);
         }
     }
-    
+
     protected void addError(String msg) {
-        addError(msg,this.annotation);
+        addError(msg, this.annotation);
     }
-    
+
     protected void addError(String msg, ASTNode expr) {
         this.errorCollector.addErrorAndContinue(
-          new SyntaxErrorMessage(new SyntaxException(msg 
-                  + " in @" + this.reportClass.getName() + '\n',
-                  expr.getLineNumber(), 
-                  expr.getColumnNumber()), this.source)
+                new SyntaxErrorMessage(new SyntaxException(
+                        msg + " in @" + this.reportClass.getName() + '\n',
+                        expr.getLineNumber(),
+                        expr.getColumnNumber()), this.source)
         );
     }
 
-    public void checkcircularReference(ClassNode searchClass, ClassNode attrType,Expression startExp) {
+    public void checkCircularReference(ClassNode searchClass, ClassNode attrType, Expression startExp) {
         if (!isValidAnnotationClass(attrType)) return;
         AnnotationConstantExpression ace = (AnnotationConstantExpression) startExp;
         AnnotationNode annotationNode = (AnnotationNode) ace.getValue();
         if (annotationNode.getClassNode().equals(searchClass)) {
-            addError ("Cirecular reference discovered in "+searchClass.getName(),startExp);
+            addError("Circular reference discovered in " + searchClass.getName(), startExp);
             return;
         }
         ClassNode cn = annotationNode.getClassNode();
-        List methods = cn.getMethods();
-        for(Iterator it=methods.iterator(); it.hasNext();) {
-            MethodNode method = (MethodNode) it.next();
+        for (MethodNode method : cn.getMethods()) {
             if (method.getReturnType().equals(searchClass)) {
-                addError ("Cirecular reference discovered in "+cn.getName(),startExp);
+                addError("Circular reference discovered in " + cn.getName(), startExp);
             }
-                        
             ReturnStatement code = (ReturnStatement) method.getCode();
-            if (code==null) continue;
-            checkcircularReference(searchClass,method.getReturnType(),code.getExpression());
+            if (code == null) continue;
+            checkCircularReference(searchClass, method.getReturnType(), code.getExpression());
         }
     }
 
diff --git a/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java b/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
index ca13814331..f653aa92d4 100644
--- a/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
+++ b/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
@@ -3132,7 +3132,7 @@ public class AsmClassGenerator extends ClassGenerator {
         if (sizeExpression != null) {
             for (Iterator iter = sizeExpression.iterator(); iter.hasNext();) {
                 Expression element = (Expression) iter.next();
-                if (element == ConstantExpression.EMTPY_EXPRESSION) break;
+                if (element == ConstantExpression.EMPTY_EXPRESSION) break;
                 dimensions++;
                 // let's convert to an int
                 visitAndAutoboxBoolean(element);
@@ -3461,24 +3461,22 @@ public class AsmClassGenerator extends ClassGenerator {
         } else if (targetNode instanceof ClassNode) {
             return ((ClassVisitor) visitor).visitAnnotation(annotationDescriptor, an.hasRuntimeRetention());
         }
-
         throwException("Cannot create an AnnotationVisitor. Please report Groovy bug");
-
         return null;
     }
 
     /**
      * Generate the annotation attributes.
+     * @param an the node with an annotation
+     * @param av the visitor to use
      */
     private void visitAnnotationAttributes(AnnotationNode an, AnnotationVisitor av) {
-        Map constantAttrs = new HashMap();
-        Map enumAttrs = new HashMap();
-        Map atAttrs = new HashMap();
-        Map arrayAttrs = new HashMap();
-
-        Iterator mIt = an.getMembers().keySet().iterator();
-        while (mIt.hasNext()) {
-            String name = (String) mIt.next();
+        Map<String, Object> constantAttrs = new HashMap<String, Object>();
+        Map<String, PropertyExpression> enumAttrs = new HashMap<String, PropertyExpression>();
+        Map<String, Object> atAttrs = new HashMap<String, Object>();
+        Map<String, ListExpression> arrayAttrs = new HashMap<String, ListExpression>();
+
+        for (String name : an.getMembers().keySet()) {
             Expression expr = an.getMember(name);
             if (expr instanceof AnnotationConstantExpression) {
                 atAttrs.put(name, ((AnnotationConstantExpression) expr).getValue());
@@ -3488,87 +3486,84 @@ public class AsmClassGenerator extends ClassGenerator {
                 constantAttrs.put(name,
                         Type.getType(BytecodeHelper.getTypeDescription(expr.getType())));
             } else if (expr instanceof PropertyExpression) {
-                enumAttrs.put(name, expr);
+                enumAttrs.put(name, (PropertyExpression) expr);
             } else if (expr instanceof ListExpression) {
-                arrayAttrs.put(name, expr);
+                arrayAttrs.put(name, (ListExpression) expr);
             }
         }
 
-        for (Iterator it = constantAttrs.entrySet().iterator(); it.hasNext();) {
-            Map.Entry entry = (Map.Entry) it.next();
+        for (Map.Entry entry : constantAttrs.entrySet()) {
             av.visit((String) entry.getKey(), entry.getValue());
         }
-        for (Iterator it = enumAttrs.entrySet().iterator(); it.hasNext();) {
-            Map.Entry entry = (Map.Entry) it.next();
+        for (Map.Entry entry : enumAttrs.entrySet()) {
             PropertyExpression propExp = (PropertyExpression) entry.getValue();
             av.visitEnum((String) entry.getKey(),
                     BytecodeHelper.getTypeDescription(propExp.getObjectExpression().getType()),
                     String.valueOf(((ConstantExpression) propExp.getProperty()).getValue()));
         }
-        for (Iterator it = atAttrs.entrySet().iterator(); it.hasNext();) {
-            Map.Entry entry = (Map.Entry) it.next();
+        for (Map.Entry entry : atAttrs.entrySet()) {
             AnnotationNode atNode = (AnnotationNode) entry.getValue();
             AnnotationVisitor av2 = av.visitAnnotation((String) entry.getKey(),
                     BytecodeHelper.getTypeDescription(atNode.getClassNode()));
             visitAnnotationAttributes(atNode, av2);
             av2.visitEnd();
         }
-
         visitArrayAttributes(an, arrayAttrs, av);
     }
 
-    private void visitArrayAttributes(AnnotationNode an, Map arrayAttr, AnnotationVisitor av) {
+    private void visitArrayAttributes(AnnotationNode an, Map<String, ListExpression> arrayAttr, AnnotationVisitor av) {
         if (arrayAttr.isEmpty()) return;
-
-        for (Iterator it = arrayAttr.entrySet().iterator(); it.hasNext();) {
-            Map.Entry entry = (Map.Entry) it.next();
-            String attrName = (String) entry.getKey();
-            ListExpression listExpr = (ListExpression) entry.getValue();
-            AnnotationVisitor av2 = av.visitArray(attrName);
-            List values = listExpr.getExpressions();
+        for (Map.Entry entry : arrayAttr.entrySet()) {
+            AnnotationVisitor av2 = av.visitArray((String) entry.getKey());
+            List<Expression> values = ((ListExpression) entry.getValue()).getExpressions();
             if (!values.isEmpty()) {
-                Expression expr = (Expression) values.get(0);
-                int arrayElementType = -1;
-                if (expr instanceof AnnotationConstantExpression) {
-                    arrayElementType = 1;
-                } else if (expr instanceof ConstantExpression) {
-                    arrayElementType = 2;
-                } else if (expr instanceof ClassExpression) {
-                    arrayElementType = 3;
-                } else if (expr instanceof PropertyExpression) {
-                    arrayElementType = 4;
+                int arrayElementType = determineCommonArrayType(values);
+                for (Expression exprChild : values) {
+                    visitAnnotationArrayElement(exprChild, arrayElementType, av2);
                 }
-                for (Iterator exprIt = listExpr.getExpressions().iterator(); exprIt.hasNext();) {
-                    switch (arrayElementType) {
-                        case 1:
-                            AnnotationNode atAttr =
-                                    (AnnotationNode) ((AnnotationConstantExpression) exprIt.next()).getValue();
-                            AnnotationVisitor av3 = av2.visitAnnotation(null,
-                                    BytecodeHelper.getTypeDescription(atAttr.getClassNode()));
-                            visitAnnotationAttributes(atAttr, av3);
-                            av3.visitEnd();
-                            break;
-                        case 2:
-                            av2.visit(null, ((ConstantExpression) exprIt.next()).getValue());
-                            break;
-                        case 3:
-                            av2.visit(null, Type.getType(
-                                    BytecodeHelper.getTypeDescription(((Expression) exprIt.next()).getType())));
-                            break;
-                        case 4:
-                            PropertyExpression propExpr = (PropertyExpression) exprIt.next();
-                            av2.visitEnum(null,
-                                    BytecodeHelper.getTypeDescription(propExpr.getObjectExpression().getType()),
-                                    String.valueOf(((ConstantExpression) propExpr.getProperty()).getValue()));
-                            break;
-                    }
-                }
-
             }
             av2.visitEnd();
         }
     }
 
+    private int determineCommonArrayType(List values) {
+        Expression expr = (Expression) values.get(0);
+        int arrayElementType = -1;
+        if (expr instanceof AnnotationConstantExpression) {
+            arrayElementType = 1;
+        } else if (expr instanceof ConstantExpression) {
+            arrayElementType = 2;
+        } else if (expr instanceof ClassExpression) {
+            arrayElementType = 3;
+        } else if (expr instanceof PropertyExpression) {
+            arrayElementType = 4;
+        }
+        return arrayElementType;
+    }
+
+    private void visitAnnotationArrayElement(Expression expr, int arrayElementType, AnnotationVisitor av) {
+        switch (arrayElementType) {
+            case 1:
+                AnnotationNode atAttr = (AnnotationNode) ((AnnotationConstantExpression) expr).getValue();
+                AnnotationVisitor av2 = av.visitAnnotation(null, BytecodeHelper.getTypeDescription(atAttr.getClassNode()));
+                visitAnnotationAttributes(atAttr, av2);
+                av2.visitEnd();
+                break;
+            case 2:
+                av.visit(null, ((ConstantExpression) expr).getValue());
+                break;
+            case 3:
+                av.visit(null, Type.getType(BytecodeHelper.getTypeDescription(expr.getType())));
+                break;
+            case 4:
+                PropertyExpression propExpr = (PropertyExpression) expr;
+                av.visitEnum(null,
+                        BytecodeHelper.getTypeDescription(propExpr.getObjectExpression().getType()),
+                        String.valueOf(((ConstantExpression) propExpr.getProperty()).getValue()));
+                break;
+        }
+    }
+
     // Implementation methods
     //-------------------------------------------------------------------------
     protected boolean addInnerClass(ClassNode innerClass) {
diff --git a/src/main/org/codehaus/groovy/classgen/ExtendedVerifier.java b/src/main/org/codehaus/groovy/classgen/ExtendedVerifier.java
index 5480564abf..dcc537904c 100644
--- a/src/main/org/codehaus/groovy/classgen/ExtendedVerifier.java
+++ b/src/main/org/codehaus/groovy/classgen/ExtendedVerifier.java
@@ -15,8 +15,6 @@
  */
 package org.codehaus.groovy.classgen;
 
-import java.util.Collection;
-import java.util.Iterator;
 import java.lang.annotation.Target;
 
 import org.codehaus.groovy.ast.*;
@@ -27,14 +25,13 @@ import org.codehaus.groovy.control.SourceUnit;
 import org.codehaus.groovy.control.messages.SyntaxErrorMessage;
 import org.codehaus.groovy.syntax.SyntaxException;
 
-
 /**
  * A specialized Groovy AST visitor meant to perform additional verifications upon the
  * current AST. Currently it does checks on annotated nodes and annotations itself.
- * 
+ * <p/>
  * Current limitations:
  * - annotations on local variables are not supported
- * 
+ *
  * @author <a href='mailto:the[dot]mindstorm[at]gmail[dot]com'>Alex Popescu</a>
  */
 public class ExtendedVerifier implements GroovyClassVisitor {
@@ -42,7 +39,7 @@ public class ExtendedVerifier implements GroovyClassVisitor {
 
     private SourceUnit source;
     private ClassNode currentClass;
-    
+
     public ExtendedVerifier(SourceUnit sourceUnit) {
         this.source = sourceUnit;
     }
@@ -73,27 +70,21 @@ public class ExtendedVerifier implements GroovyClassVisitor {
         }
 
         if (this.currentClass.isAnnotationDefinition()) {
-
             ErrorCollector errorCollector = new ErrorCollector(this.source.getConfiguration());
             AnnotationVisitor visitor = new AnnotationVisitor(this.source, errorCollector);
             visitor.setReportClass(currentClass);
-
-            visitor.checkReturnType(node.getReturnType(),node);
-            
-            if (node.getParameters().length>0) {
-                addError ("Annotation members may not have parameters.",node.getParameters()[0]);
+            visitor.checkReturnType(node.getReturnType(), node);
+            if (node.getParameters().length > 0) {
+                addError("Annotation members may not have parameters.", node.getParameters()[0]);
             }
-
-            if (node.getExceptions().length>0) {
-                addError ("Annotation members may not have a throws clause.",node.getExceptions()[0]);
+            if (node.getExceptions().length > 0) {
+                addError("Annotation members may not have a throws clause.", node.getExceptions()[0]);
             }
-            
             ReturnStatement code = (ReturnStatement) node.getCode();
-            if (code!=null) {
-                visitor.visitExpression(node.getName(),code.getExpression(),node.getReturnType());
-                visitor.checkcircularReference(currentClass,node.getReturnType(),code.getExpression());
+            if (code != null) {
+                visitor.visitExpression(node.getName(), code.getExpression(), node.getReturnType());
+                visitor.checkCircularReference(currentClass, node.getReturnType(), code.getExpression());
             }
-
             this.source.getErrorCollector().addCollectorContents(errorCollector);
         }
     }
@@ -105,53 +96,53 @@ public class ExtendedVerifier implements GroovyClassVisitor {
         if (node.getAnnotations().isEmpty()) {
             return;
         }
-
         this.currentClass.setAnnotated(true);
-
         if (!isAnnotationCompatible()) {
             addError("Annotations are not supported in the current runtime. " + JVM_ERROR_MESSAGE, node);
             return;
         }
-
-        Collection annotations = node.getAnnotations();
-        for (Iterator it = annotations.iterator(); it.hasNext();) {
-            AnnotationNode annotation = visitAnnotation((AnnotationNode) it.next());
-
-            boolean isTargetAnnotation = annotation.getClassNode().isResolved() &&
-                annotation.getClassNode().getTypeClass() == Target.class;
+        for (AnnotationNode unvisited : node.getAnnotations()) {
+            AnnotationNode visited = visitAnnotation(unvisited);
+            boolean isTargetAnnotation = visited.getClassNode().isResolved() &&
+                    visited.getClassNode().getTypeClass() == Target.class;
 
             // Check if the annotation target is correct, unless it's the target annotating an annotation definition
             // defining on which target elements the annotation applies
-            if (!isTargetAnnotation && !annotation.isTargetAllowed(target)) {
-                addError("Annotation @" + annotation.getClassNode().getName()
+            if (!isTargetAnnotation && !visited.isTargetAllowed(target)) {
+                addError("Annotation @" + visited.getClassNode().getName()
                         + " is not allowed on element " + AnnotationNode.targetToName(target),
-                        annotation);
+                        visited);
             }
         }
     }
 
     /**
      * Resolve metadata and details of the annotation.
+     *
+     * @param unvisited the node to visit
+     * @return the visited node
      */
-    private AnnotationNode visitAnnotation(AnnotationNode node) {
+    private AnnotationNode visitAnnotation(AnnotationNode unvisited) {
         ErrorCollector errorCollector = new ErrorCollector(this.source.getConfiguration());
         AnnotationVisitor visitor = new AnnotationVisitor(this.source, errorCollector);
-        AnnotationNode solvedAnnotation = visitor.visit(node);
+        AnnotationNode visited = visitor.visit(unvisited);
         this.source.getErrorCollector().addCollectorContents(errorCollector);
-        return solvedAnnotation;
+        return visited;
     }
 
     /**
      * Check if the current runtime allows Annotation usage.
+     *
+     * @return true if running on a 1.5+ runtime
      */
     protected boolean isAnnotationCompatible() {
-        return CompilerConfiguration.POST_JDK5.equals(this.source.getConfiguration().getTargetBytecode()); 
+        return CompilerConfiguration.POST_JDK5.equals(this.source.getConfiguration().getTargetBytecode());
     }
-    
+
     protected void addError(String msg, ASTNode expr) {
         this.source.getErrorCollector().addErrorAndContinue(
-            new SyntaxErrorMessage(
-                    new SyntaxException(msg + '\n', expr.getLineNumber(), expr.getColumnNumber()), this.source)
+                new SyntaxErrorMessage(
+                        new SyntaxException(msg + '\n', expr.getLineNumber(), expr.getColumnNumber()), this.source)
         );
     }
 
diff --git a/src/test/gls/annotations/AnnotationTest.groovy b/src/test/gls/annotations/AnnotationTest.groovy
index 44ca4576bd..f385fa5324 100644
--- a/src/test/gls/annotations/AnnotationTest.groovy
+++ b/src/test/gls/annotations/AnnotationTest.groovy
@@ -55,7 +55,7 @@ class AnnotationTest extends CompilableTestSupport {
     }
 
     /**
-     * The @OneToMany cascadeparameter takes an array of CascadeType.
+     * The @OneToMany cascade parameter takes an array of CascadeType.
      * To use this annotation in Java with this parameter, you do <code>@OneToMany(cascade = { CascadeType.ALL })</code>
      * In Groovy, you do <code>@OneToMany(cascade = [ CascadeType.ALL ])</code> (brackets instead of braces)
      * But when there's just one value in the array, the curly braces or brackets can be omitted:
@@ -96,6 +96,29 @@ class AnnotationTest extends CompilableTestSupport {
     """
   }
 
+  void testConstant() {
+    assertScript """
+    class Baz {
+        // static final int OTHER = 5
+        // below we would like to but can't use:
+        // constant field expressions, e.g. OTHER, or
+        // constant property expressions, e.g. Short.MAX_VALUE
+        @Foo(5) void run() {
+            assert Baz.class.getMethod('run').annotations[0].value() == 5
+        }
+    }
+
+    import java.lang.annotation.*
+    @Retention(RetentionPolicy.RUNTIME)
+    @Target(ElementType.METHOD)
+    @interface Foo {
+        int value() default -3
+    }
+
+    new Baz().run()
+    """
+  }
+
   void testArrayDefault() {
     shouldNotCompile """
 @interface X {
