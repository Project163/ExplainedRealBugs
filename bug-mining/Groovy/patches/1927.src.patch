diff --git a/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java b/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java
index 790c7636e8..d53cb4db8a 100644
--- a/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java
+++ b/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java
@@ -95,6 +95,7 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
 
     protected AST ast;
     private ClassNode classNode;
+    private MethodNode methodNode;
     private String[] tokenNames;
     private int innerClassCounter = 1;
     private boolean enumConstantBeingDef = false;
@@ -520,6 +521,7 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
             classNode = new InnerClassNode(outerClass, fullName, Opcodes.ACC_PUBLIC, ClassHelper.OBJECT_TYPE);
         }
         ((InnerClassNode) classNode).setAnonymous(true);
+        classNode.setEnclosingMethod(methodNode);
 
         assertNodeType(OBJBLOCK, node);
         objectBlock(node);
@@ -730,6 +732,7 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
     }
 
     protected void methodDef(AST methodDef) {
+        MethodNode oldNode = methodNode;
         List<AnnotationNode> annotations = new ArrayList<AnnotationNode>();
         AST node = methodDef.getFirstChild();
 
@@ -789,6 +792,9 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
 
         boolean hasAnnotationDefault = false;
         Statement code = null;
+        boolean syntheticPublic = ((modifiers & Opcodes.ACC_SYNTHETIC) != 0);
+        modifiers &= ~Opcodes.ACC_SYNTHETIC;
+        methodNode = new MethodNode(name, modifiers, returnType, parameters, exceptions, code);
         if ((modifiers & Opcodes.ACC_ABSTRACT) == 0) {
             if (node == null) {
                 throw new ASTRuntimeException(methodDef, "You defined a method without body. Try adding a body, or declare it abstract.");
@@ -803,10 +809,7 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
                 throw new ASTRuntimeException(methodDef, "Abstract methods do not define a body.");
             }
         }
-
-        boolean syntheticPublic = ((modifiers & Opcodes.ACC_SYNTHETIC) != 0);
-        modifiers &= ~Opcodes.ACC_SYNTHETIC;
-        MethodNode methodNode = new MethodNode(name, modifiers, returnType, parameters, exceptions, code);
+        methodNode.setCode(code);
         methodNode.addAnnotations(annotations);
         methodNode.setGenericsTypes(generics);
         methodNode.setAnnotationDefault(hasAnnotationDefault);
@@ -818,6 +821,7 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
         } else {
             output.addMethod(methodNode);
         }
+        methodNode = oldNode;
     }
 
     private void checkNoInvalidModifier(AST node, String nodeType, int modifiers, int modifier, String modifierText) {
@@ -868,11 +872,14 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
         }
 
         assertNodeType(SLIST, node);
-        Statement code = statementList(node);
-
         boolean syntheticPublic = ((modifiers & Opcodes.ACC_SYNTHETIC) != 0);
         modifiers &= ~Opcodes.ACC_SYNTHETIC;
-        ConstructorNode constructorNode = classNode.addConstructor(modifiers, parameters, exceptions, code);
+        ConstructorNode constructorNode = classNode.addConstructor(modifiers, parameters, exceptions, null);
+        MethodNode oldMethod = methodNode;
+        methodNode = constructorNode;
+        Statement code = statementList(node);
+        methodNode = oldMethod;
+        constructorNode.setCode(code);
         constructorNode.setSyntheticPublic(syntheticPublic);
         constructorNode.addAnnotations(annotations);
         configureAST(constructorNode, constructorDef);
diff --git a/src/main/org/codehaus/groovy/ast/InnerClassNode.java b/src/main/org/codehaus/groovy/ast/InnerClassNode.java
index 86f422421e..b4d179ab8e 100644
--- a/src/main/org/codehaus/groovy/ast/InnerClassNode.java
+++ b/src/main/org/codehaus/groovy/ast/InnerClassNode.java
@@ -15,6 +15,8 @@
  */
 package org.codehaus.groovy.ast;
 
+import org.codehaus.groovy.ast.stmt.Statement;
+
 import java.util.LinkedList;
 
 /**
@@ -78,4 +80,14 @@ public class InnerClassNode extends ClassNode {
     public void setAnonymous(boolean anonymous) {
         this.anonymous = anonymous;
     }
+
+    @Override
+    public void addConstructor(final ConstructorNode node) {
+        super.addConstructor(node);
+    }
+
+    @Override
+    public ConstructorNode addConstructor(final int modifiers, final Parameter[] parameters, final ClassNode[] exceptions, final Statement code) {
+        return super.addConstructor(modifiers, parameters, exceptions, code);
+    }
 }
diff --git a/src/main/org/codehaus/groovy/classgen/InnerClassVisitor.java b/src/main/org/codehaus/groovy/classgen/InnerClassVisitor.java
index e755ba2c4a..fcfc420016 100644
--- a/src/main/org/codehaus/groovy/classgen/InnerClassVisitor.java
+++ b/src/main/org/codehaus/groovy/classgen/InnerClassVisitor.java
@@ -102,7 +102,15 @@ public class InnerClassVisitor extends InnerClassVisitorHelper implements Opcode
     @Override
     protected void visitConstructorOrMethod(MethodNode node, boolean isConstructor) {
         this.currentMethod = node;
-        super.visitConstructorOrMethod(node, isConstructor);
+        visitAnnotations(node);
+        visitClassCodeContainer(node.getCode());
+        // GROOVY-5681: initial expressions should be visited too!
+        for (Parameter param : node.getParameters()) {
+            if (param.hasInitialExpression()) {
+                param.getInitialExpression().visit(this);
+            }
+            visitAnnotations(param);
+        }
         this.currentMethod = null;
     }
 
diff --git a/src/main/org/codehaus/groovy/classgen/Verifier.java b/src/main/org/codehaus/groovy/classgen/Verifier.java
index 6246e83965..e758a63af4 100644
--- a/src/main/org/codehaus/groovy/classgen/Verifier.java
+++ b/src/main/org/codehaus/groovy/classgen/Verifier.java
@@ -683,8 +683,19 @@ public class Verifier implements GroovyClassVisitor, Opcodes {
                 } else {
                     code = new ReturnStatement(expression);
                 }
-
                 MethodNode newMethod = new MethodNode(method.getName(), method.getModifiers(), method.getReturnType(), newParams, method.getExceptions(), code);
+                // GROOVY-5681
+                for (Expression argument : arguments.getExpressions()) {
+                    if (argument instanceof CastExpression) {
+                        argument = ((CastExpression) argument).getExpression();
+                    }
+                    if (argument instanceof ConstructorCallExpression) {
+                        ClassNode type = argument.getType();
+                        if (type instanceof InnerClassNode && ((InnerClassNode) type).isAnonymous()) {
+                            type.setEnclosingMethod(newMethod);
+                        }
+                    }
+                }
                 List<AnnotationNode> annotations = method.getAnnotations();
                 if(annotations != null) {
                     newMethod.addAnnotations(annotations);
diff --git a/src/test/gls/innerClass/InnerClassTest.groovy b/src/test/gls/innerClass/InnerClassTest.groovy
index 998f4aa665..29792e9f7d 100644
--- a/src/test/gls/innerClass/InnerClassTest.groovy
+++ b/src/test/gls/innerClass/InnerClassTest.groovy
@@ -409,6 +409,53 @@ class A {
         """
     }
 
+    // GROOVY-5679
+    // GROOVY-5681
+    void testEnclosingMethodIsSet() {
+        new GroovyShell().evaluate '''import groovy.transform.ASTTest
+        import static org.codehaus.groovy.control.CompilePhase.*
+        import org.codehaus.groovy.ast.InnerClassNode
+        import org.codehaus.groovy.ast.expr.ConstructorCallExpression
+import org.codehaus.groovy.classgen.Verifier
+
+        class A {
+            int x
+
+            /*@ASTTest(phase=SEMANTIC_ANALYSIS, value={
+                def cce = lookup('inner')[0].expression
+                def icn = cce.type
+                assert icn instanceof InnerClassNode
+                assert icn.enclosingMethod == node
+            })
+            A() { inner: new Runnable() { void run() {} } }
+
+            @ASTTest(phase=SEMANTIC_ANALYSIS, value={
+                def cce = lookup('inner')[0].expression
+                def icn = cce.type
+                assert icn instanceof InnerClassNode
+                assert icn.enclosingMethod == node
+            })
+            void foo() { inner: new Runnable() { void run() {} } }*/
+
+            @ASTTest(phase=CLASS_GENERATION, value={
+                def initialExpression = node.parameters[0].getNodeMetaData(Verifier.INITIAL_EXPRESSION)
+                assert initialExpression instanceof ConstructorCallExpression
+                def icn = initialExpression.type
+                assert icn instanceof InnerClassNode
+                assert icn.enclosingMethod != null
+                assert icn.enclosingMethod.name == 'bar'
+                assert icn.enclosingMethod.parameters.length == 0 // ensure the enclosing method is bar(), not bar(Object)
+            })
+            void bar(action=new Runnable() { void run() { x = 123 }}) {
+                action.run()
+            }
+
+        }
+        def a = new A()
+        a.bar()
+        assert a.x == 123
+        '''
+    }
 } 
 
 class MyOuterClass4028 {
