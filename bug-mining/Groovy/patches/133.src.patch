diff --git a/src/main/groovy/lang/GroovyClassLoader.java b/src/main/groovy/lang/GroovyClassLoader.java
index 417a978d74..631488bb79 100644
--- a/src/main/groovy/lang/GroovyClassLoader.java
+++ b/src/main/groovy/lang/GroovyClassLoader.java
@@ -34,22 +34,20 @@
  */
 package groovy.lang;
 
-import java.io.BufferedInputStream;
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.File;
-import java.io.IOException;
-import java.io.InputStream;
+import org.codehaus.groovy.ast.ClassNode;
+import org.codehaus.groovy.classgen.Verifier;
+import org.codehaus.groovy.control.CompilationFailedException;
+import org.codehaus.groovy.control.CompilationUnit;
+import org.codehaus.groovy.control.CompilerConfiguration;
+import org.codehaus.groovy.control.Phases;
+import org.objectweb.asm.ClassVisitor;
+import org.objectweb.asm.ClassWriter;
+
+import java.io.*;
 import java.lang.reflect.Field;
 import java.net.MalformedURLException;
 import java.net.URL;
-import java.security.AccessController;
-import java.security.CodeSource;
-import java.security.PrivilegedAction;
-import java.security.PrivilegedActionException;
-import java.security.PrivilegedExceptionAction;
-import java.security.ProtectionDomain;
-import java.security.SecureClassLoader;
+import java.security.*;
 import java.security.cert.Certificate;
 import java.util.ArrayList;
 import java.util.HashMap;
@@ -60,18 +58,9 @@ import java.util.jar.JarEntry;
 import java.util.jar.JarFile;
 import java.util.jar.Manifest;
 
-import org.codehaus.groovy.ast.ClassNode;
-import org.codehaus.groovy.classgen.Verifier;
-import org.codehaus.groovy.control.CompilationFailedException;
-import org.codehaus.groovy.control.CompilationUnit;
-import org.codehaus.groovy.control.CompilerConfiguration;
-import org.codehaus.groovy.control.Phases;
-import org.objectweb.asm.ClassVisitor;
-import org.objectweb.asm.ClassWriter;
-
 /**
  * A ClassLoader which can load Groovy classes
- * 
+ *
  * @author <a href="mailto:james@coredevelopers.net">James Strachan </a>
  * @author Guillaume Laforge
  * @author Steve Goetze
@@ -82,6 +71,10 @@ public class GroovyClassLoader extends SecureClassLoader {
 
     private Map cache = new HashMap();
 
+    public void removeFromCache(Class aClass) {
+        cache.remove(aClass);
+    }
+
     private class PARSING {
     };
 
@@ -111,7 +104,7 @@ public class GroovyClassLoader extends SecureClassLoader {
 
     /**
      * Loads the given class node returning the implementation Class
-     * 
+     *
      * @param classNode
      * @return
      */
@@ -121,7 +114,7 @@ public class GroovyClassLoader extends SecureClassLoader {
 
     /**
      * Loads the given class node returning the implementation Class
-     * 
+     *
      * @param classNode
      * @return
      */
@@ -129,8 +122,7 @@ public class GroovyClassLoader extends SecureClassLoader {
         CodeSource codeSource = null;
         try {
             codeSource = new CodeSource(new URL("file", "", newCodeBase), (java.security.cert.Certificate[]) null);
-        }
-        catch (MalformedURLException e) {
+        } catch (MalformedURLException e) {
             //swallow
         }
 
@@ -146,17 +138,15 @@ public class GroovyClassLoader extends SecureClassLoader {
             unit.compile(Phases.CLASS_GENERATION);
 
             return collector.generatedClass;
-        }
-        catch (CompilationFailedException e) {
+        } catch (CompilationFailedException e) {
             throw new RuntimeException(e);
         }
     }
 
     /**
      * Parses the given file into a Java class capable of being run
-     * 
-     * @param file
-     *            the file name to parse
+     *
+     * @param file the file name to parse
      * @return the main class defined in the given script
      */
     public Class parseClass(File file) throws CompilationFailedException, IOException {
@@ -165,11 +155,9 @@ public class GroovyClassLoader extends SecureClassLoader {
 
     /**
      * Parses the given text into a Java class capable of being run
-     * 
-     * @param text
-     *            the text of the script/class to parse
-     * @param fileName
-     *            the file name to use as the name of the class
+     *
+     * @param text     the text of the script/class to parse
+     * @param fileName the file name to use as the name of the class
      * @return the main class defined in the given script
      */
     public Class parseClass(String text, String fileName) throws CompilationFailedException, IOException {
@@ -178,9 +166,8 @@ public class GroovyClassLoader extends SecureClassLoader {
 
     /**
      * Parses the given text into a Java class capable of being run
-     * 
-     * @param text
-     *            the text of the script/class to parse
+     *
+     * @param text the text of the script/class to parse
      * @return the main class defined in the given script
      */
     public Class parseClass(String text) throws CompilationFailedException, IOException {
@@ -189,9 +176,8 @@ public class GroovyClassLoader extends SecureClassLoader {
 
     /**
      * Parses the given character stream into a Java class capable of being run
-     * 
-     * @param in
-     *            an InputStream
+     *
+     * @param in an InputStream
      * @return the main class defined in the given script
      */
     public Class parseClass(InputStream in) throws CompilationFailedException, IOException {
@@ -212,12 +198,17 @@ public class GroovyClassLoader extends SecureClassLoader {
         return parseClass(gcs);
     }
 
+
+    public Class parseClass(GroovyCodeSource codeSource) throws IOException, CompilationFailedException {
+        return parseClass(codeSource, true);
+    }
+
     /**
      * Parses the given code source into a Java class capable of being run
-     * 
+     *
      * @return the main class defined in the given script
      */
-    public Class parseClass(GroovyCodeSource codeSource) throws CompilationFailedException, IOException {
+    public Class parseClass(GroovyCodeSource codeSource, boolean shouldCache) throws CompilationFailedException, IOException {
         String name = codeSource.getName();
         Class answer = null;
         //ASTBuilder.resolveName can call this recursively -- for example when
@@ -227,8 +218,7 @@ public class GroovyClassLoader extends SecureClassLoader {
             answer = (Class) cache.get(name);
             if (answer != null) {
                 return (answer == PARSING.class ? null : answer);
-            }
-            else {
+            } else {
                 cache.put(name, PARSING.class);
             }
         }
@@ -248,13 +238,11 @@ public class GroovyClassLoader extends SecureClassLoader {
             // catch( CompilationFailedException e ) {
             //     throw new RuntimeException( e );
             // }
-        }
-        finally {
+        } finally {
             synchronized (cache) {
-                if (answer == null) {
+                if (answer == null || !shouldCache) {
                     cache.remove(name);
-                }
-                else {
+                } else {
                     cache.put(name, answer);
                 }
             }
@@ -285,8 +273,7 @@ public class GroovyClassLoader extends SecureClassLoader {
                     return findGroovyClass(name);
                 }
             });
-        }
-        catch (PrivilegedActionException pae) {
+        } catch (PrivilegedActionException pae) {
             throw (ClassNotFoundException) pae.getException();
         }
     }
@@ -337,20 +324,17 @@ public class GroovyClassLoader extends SecureClassLoader {
                             if (files[j].getName().equals(classname)) {
                                 try {
                                     return parseClass(files[j]);
-                                }
-                                catch (CompilationFailedException e) {
+                                } catch (CompilationFailedException e) {
                                     e.printStackTrace();
                                     throw new ClassNotFoundException("Syntax error in groovy file: " + files[j].getAbsolutePath(), e);
-                                }
-                                catch (IOException e) {
+                                } catch (IOException e) {
                                     e.printStackTrace();
                                     throw new ClassNotFoundException("Error reading groovy file: " + files[j].getAbsolutePath(), e);
                                 }
                             }
                         }
                     }
-                }
-                else {
+                } else {
                     try {
                         JarFile jarFile = new JarFile(path);
                         JarEntry entry = jarFile.getJarEntry(filename);
@@ -359,19 +343,16 @@ public class GroovyClassLoader extends SecureClassLoader {
                             Certificate[] certs = entry.getCertificates();
                             try {
                                 return parseClass(new GroovyCodeSource(new ByteArrayInputStream(bytes), filename, path, certs));
-                            }
-                            catch (CompilationFailedException e1) {
+                            } catch (CompilationFailedException e1) {
                                 e1.printStackTrace();
                                 throw new ClassNotFoundException("Syntax error in groovy file: " + filename, e1);
-                            }
-                            catch (IOException e1) {
+                            } catch (IOException e1) {
                                 e1.printStackTrace();
                                 throw new ClassNotFoundException("Error reading groovy file: " + filename, e1);
                             }
                         }
 
-                    }
-                    catch (IOException e) {
+                    } catch (IOException e) {
                         // Bad jar in classpath, ignore
                     }
                 }
@@ -392,8 +373,7 @@ public class GroovyClassLoader extends SecureClassLoader {
             while ((b = bis.read()) != -1) {
                 baos.write(b);
             }
-        }
-        catch (IOException ioe) {
+        } catch (IOException ioe) {
             throw new GroovyRuntimeException("Could not read the jar bytes for " + entry.getName());
         }
         return baos.toByteArray();
@@ -436,8 +416,7 @@ public class GroovyClassLoader extends SecureClassLoader {
 
                     if ("".equals(base)) {
                         path = new File(paths[i]);
-                    }
-                    else {
+                    } else {
                         path = new File(base, paths[i]);
                     }
 
@@ -455,13 +434,11 @@ public class GroovyClassLoader extends SecureClassLoader {
                                     if (manifestClassPath != null)
                                         expandClassPath(pathList, paths[i], manifestClassPath);
                                 }
-                            }
-                            catch (IOException e) {
+                            } catch (IOException e) {
                                 // Bad jar, ignore
                                 continue;
                             }
-                        }
-                        else {
+                        } else {
                             pathList.add(paths[i]);
                         }
                     }
@@ -578,8 +555,7 @@ public class GroovyClassLoader extends SecureClassLoader {
                     if (source != null && cls != null && isSourceNewer(source, cls)) {
                         cls = parseClass(source);
                     }
-                }
-                catch (Exception e) {
+                } catch (Exception e) {
                     e.printStackTrace();
                     synchronized (cache) {
                         cache.put(name, NOT_RESOLVED.class);
@@ -597,8 +573,7 @@ public class GroovyClassLoader extends SecureClassLoader {
         try {
             field = cls.getField(Verifier.__TIMESTAMP);
             o = (Long) field.get(null);
-        }
-        catch (Exception e) {
+        } catch (Exception e) {
             //throw new RuntimeException(e);
             return Long.MAX_VALUE;
         }
diff --git a/src/main/groovy/lang/GroovyShell.java b/src/main/groovy/lang/GroovyShell.java
index 6f54bf60f0..cf4893207d 100644
--- a/src/main/groovy/lang/GroovyShell.java
+++ b/src/main/groovy/lang/GroovyShell.java
@@ -45,26 +45,25 @@
  */
 package groovy.lang;
 
+import groovy.ui.GroovyMain;
+import org.codehaus.groovy.control.CompilationFailedException;
+import org.codehaus.groovy.control.CompilerConfiguration;
+import org.codehaus.groovy.runtime.InvokerHelper;
+
 import java.io.ByteArrayInputStream;
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
+import java.lang.reflect.Constructor;
 import java.security.AccessController;
 import java.security.PrivilegedAction;
 import java.security.PrivilegedActionException;
 import java.security.PrivilegedExceptionAction;
 import java.util.List;
-import java.lang.reflect.Constructor;
-import java.lang.reflect.InvocationTargetException;
-
-import org.codehaus.groovy.control.CompilationFailedException;
-import org.codehaus.groovy.control.CompilerConfiguration;
-import org.codehaus.groovy.runtime.InvokerHelper;
-import groovy.ui.GroovyMain;
 
 /**
  * Represents a groovy shell capable of running arbitrary groovy scripts
- * 
+ *
  * @author <a href="mailto:james@coredevelopers.net">James Strachan</a>
  * @author Guillaume Laforge
  * @version $Revision$
@@ -106,30 +105,30 @@ public class GroovyShell extends GroovyObjectSupport {
     }
 
     public GroovyShell(final ClassLoader parent, Binding binding, final CompilerConfiguration config) {
-        this.loader = 
-            	(GroovyClassLoader) AccessController.doPrivileged(new PrivilegedAction() {
-            		public Object run() {
-            			ClassLoader pcl = parent;
-            	        if (pcl == null) {
-            	        	pcl = Thread.currentThread().getContextClassLoader();
-            	            if (pcl == null) {
-            	            	pcl = GroovyShell.class.getClassLoader();
-            	            }
-            	        }
-            			return new GroovyClassLoader(pcl, (config == null) ? new CompilerConfiguration() : config);
-            		}
-            	});
+        this.loader =
+                (GroovyClassLoader) AccessController.doPrivileged(new PrivilegedAction() {
+                    public Object run() {
+                        ClassLoader pcl = parent;
+                        if (pcl == null) {
+                            pcl = Thread.currentThread().getContextClassLoader();
+                            if (pcl == null) {
+                                pcl = GroovyShell.class.getClassLoader();
+                            }
+                        }
+                        return new GroovyClassLoader(pcl, (config == null) ? new CompilerConfiguration() : config);
+                    }
+                });
         this.context = binding;
     }
 
     /**
-     * Creates a child shell using a new ClassLoader which uses the parent shell's 
+     * Creates a child shell using a new ClassLoader which uses the parent shell's
      * class loader as its parent
-     * 
+     *
      * @param shell is the parent shell used for the variable bindings and the parent class loader
      */
     public GroovyShell(GroovyShell shell) {
-    	this(shell.loader, shell.context);
+        this(shell.loader, shell.context);
     }
 
     public Binding getContext() {
@@ -148,29 +147,28 @@ public class GroovyShell extends GroovyObjectSupport {
         setVariable(property, newValue);
         try {
             super.setProperty(property, newValue);
-        }
-        catch (GroovyRuntimeException e) {
+        } catch (GroovyRuntimeException e) {
             // ignore, was probably a dynamic property
         }
     }
 
     /**
      * A helper method which runs the given script file with the given command line arguments
-     * 
+     *
      * @param scriptFile the file of the script to run
-     * @param list the command line arguments to pass in
+     * @param list       the command line arguments to pass in
      */
     public void run(File scriptFile, List list) throws CompilationFailedException, IOException {
         String[] args = new String[list.size()];
-        run(scriptFile, (String[])list.toArray(args));
+        run(scriptFile, (String[]) list.toArray(args));
     }
 
     /**
      * A helper method which runs the given cl script with the given command line arguments
-     * 
+     *
      * @param scriptText is the text content of the script
-     * @param fileName is the logical file name of the script (which is used to create the class name of the script)
-     * @param list the command line arguments to pass in
+     * @param fileName   is the logical file name of the script (which is used to create the class name of the script)
+     * @param list       the command line arguments to pass in
      */
     public void run(String scriptText, String fileName, List list) throws CompilationFailedException, IOException {
         String[] args = new String[list.size()];
@@ -180,16 +178,16 @@ public class GroovyShell extends GroovyObjectSupport {
 
     /**
      * Runs the given script file name with the given command line arguments
-     * 
+     *
      * @param scriptFile the file name of the script to run
-     * @param args the command line arguments to pass in
+     * @param args       the command line arguments to pass in
      */
     public void run(final File scriptFile, String[] args) throws CompilationFailedException, IOException {
         String scriptName = scriptFile.getName();
         int p = scriptName.lastIndexOf(".");
-        if ( p++ >= 0) {
+        if (p++ >= 0) {
             if (scriptName.substring(p).equals("java")) {
-                System.err.println( "error: cannot compile file with .java extension: " + scriptName );
+                System.err.println("error: cannot compile file with .java extension: " + scriptName);
                 throw new CompilationFailedException(0, null);
             }
         }
@@ -197,68 +195,68 @@ public class GroovyShell extends GroovyObjectSupport {
         // Get the current context classloader and save it on the stack
         final Thread thread = Thread.currentThread();
         ClassLoader currentClassLoader = thread.getContextClassLoader();
-        
+
         class DoSetContext implements PrivilegedAction {
-        	ClassLoader classLoader;
-        	public DoSetContext(ClassLoader loader) {
-        		classLoader = loader;
-        	}
-    		public Object run() {
-    			thread.setContextClassLoader(classLoader);
-    			return null;
-    		}
-    	};
-    	
-    	AccessController.doPrivileged(new DoSetContext(loader));
+            ClassLoader classLoader;
+
+            public DoSetContext(ClassLoader loader) {
+                classLoader = loader;
+            }
+
+            public Object run() {
+                thread.setContextClassLoader(classLoader);
+                return null;
+            }
+        }
+        ;
+
+        AccessController.doPrivileged(new DoSetContext(loader));
 
         // Parse the script, generate the class, and invoke the main method.  This is a little looser than
         // if you are compiling the script because the JVM isn't executing the main method.
-    	Class scriptClass;
-    	try {
-    		scriptClass = (Class) AccessController.doPrivileged( new PrivilegedExceptionAction() {
-    			public Object run() throws CompilationFailedException, IOException {
-    				return loader.parseClass(scriptFile);
-    			}
-    		});
-    	} catch (PrivilegedActionException pae) {
-    		Exception e = pae.getException();
-    		if (e instanceof CompilationFailedException) {
-    			throw (CompilationFailedException)e;
-    		}
-    		else if (e instanceof IOException) {
-    			throw (IOException) e;
-    		}
-    		else {
-    			throw (RuntimeException) pae.getException();
-    		}
-    	}
+        Class scriptClass;
+        try {
+            scriptClass = (Class) AccessController.doPrivileged(new PrivilegedExceptionAction() {
+                public Object run() throws CompilationFailedException, IOException {
+                    return loader.parseClass(scriptFile);
+                }
+            });
+        } catch (PrivilegedActionException pae) {
+            Exception e = pae.getException();
+            if (e instanceof CompilationFailedException) {
+                throw (CompilationFailedException) e;
+            } else if (e instanceof IOException) {
+                throw (IOException) e;
+            } else {
+                throw (RuntimeException) pae.getException();
+            }
+        }
 
         runMainOrTestOrRunnable(scriptClass, args);
 
         // Set the context classloader back to what it was.
-    	AccessController.doPrivileged(new DoSetContext(currentClassLoader));
+        AccessController.doPrivileged(new DoSetContext(currentClassLoader));
     }
 
     /**
      * if (theClass has a main method) {
-     *      run the main method
+     * run the main method
      * } else if (theClass instanceof GroovyTestCase) {
-     *      use the test runner to run it
+     * use the test runner to run it
      * } else if (theClass implements Runnable) {
-     *      if (theClass has a constructor with String[] params)
-     *          instanciate theClass with this constructor and run
-     *      else if (theClass has a no-args constructor)
-     *          instanciate theClass with the no-args constructor and run
+     * if (theClass has a constructor with String[] params)
+     * instanciate theClass with this constructor and run
+     * else if (theClass has a no-args constructor)
+     * instanciate theClass with the no-args constructor and run
      * }
      */
     private void runMainOrTestOrRunnable(Class scriptClass, String[] args) {
         try {
             // let's find a main method
-            scriptClass.getMethod("main", new Class[] { String[].class} );
+            scriptClass.getMethod("main", new Class[]{String[].class});
             // if that main method exist, invoke it
             InvokerHelper.invokeMethod(scriptClass, "main", new Object[]{args});
-        }
-        catch (NoSuchMethodException e) {
+        } catch (NoSuchMethodException e) {
             // As no main() method was found, let's see if it's a unit test
             // if it's a unit test extending GroovyTestCase, run it with JUnit's TextRunner
             if (isUnitTestCase(scriptClass)) {
@@ -272,28 +270,24 @@ public class GroovyShell extends GroovyObjectSupport {
                 Throwable reason = null;
                 try {
                     // first, fetch the constructor taking String[] as parameter
-                    constructor = scriptClass.getConstructor(new Class[] { (new String[] {}).getClass() });
+                    constructor = scriptClass.getConstructor(new Class[]{(new String[]{}).getClass()});
                     try {
                         // instanciate a runnable and run it
                         runnable = (Runnable) constructor.newInstance(new Object[]{args});
-                    }
-                    catch (Throwable t) {
+                    } catch (Throwable t) {
                         reason = t;
                     }
-                }
-                catch (NoSuchMethodException e1) {
+                } catch (NoSuchMethodException e1) {
                     try {
                         // otherwise, find the default constructor
                         constructor = scriptClass.getConstructor(new Class[]{});
                         try {
                             // instanciate a runnable and run it
                             runnable = (Runnable) constructor.newInstance(new Object[]{});
-                        }
-                        catch (Throwable t) {
+                        } catch (Throwable t) {
                             reason = t;
                         }
-                    }
-                    catch (NoSuchMethodException nsme) {
+                    } catch (NoSuchMethodException nsme) {
                         reason = nsme;
                     }
                 }
@@ -304,10 +298,10 @@ public class GroovyShell extends GroovyObjectSupport {
                 }
             } else {
                 throw new GroovyRuntimeException("This script or class could not be run. \n" +
-                                                 "It should either: \n" +
-                                                 "- have a main method, \n" +
-                                                 "- be a class extending GroovyTestCase, \n" +
-                                                 "- or implement the Runnable interface.");
+                        "It should either: \n" +
+                        "- have a main method, \n" +
+                        "- be a class extending GroovyTestCase, \n" +
+                        "- or implement the Runnable interface.");
             }
         }
     }
@@ -322,9 +316,8 @@ public class GroovyShell extends GroovyObjectSupport {
      */
     private void runTest(Class scriptClass) {
         try {
-            InvokerHelper.invokeStaticMethod("junit.textui.TestRunner", "run", new Object[] {scriptClass});
-        }
-        catch (Exception e) {
+            InvokerHelper.invokeStaticMethod("junit.textui.TestRunner", "run", new Object[]{scriptClass});
+        } catch (Exception e) {
             throw new GroovyRuntimeException("Failed to run the unit test. JUnit is not on the Classpath.");
         }
     }
@@ -346,12 +339,10 @@ public class GroovyShell extends GroovyObjectSupport {
                 if (testCaseClass.isAssignableFrom(scriptClass)) {
                     isUnitTestCase = true;
                 }
-            }
-            catch (ClassNotFoundException e) {
+            } catch (ClassNotFoundException e) {
                 // fall through
             }
-        }
-        catch (Exception e) {
+        } catch (Exception e) {
             // fall through
         }
         return isUnitTestCase;
@@ -359,10 +350,10 @@ public class GroovyShell extends GroovyObjectSupport {
 
     /**
      * Runs the given script text with command line arguments
-     * 
+     *
      * @param scriptText is the text content of the script
-     * @param fileName is the logical file name of the script (which is used to create the class name of the script)
-     * @param args the command line arguments to pass in
+     * @param fileName   is the logical file name of the script (which is used to create the class name of the script)
+     * @param args       the command line arguments to pass in
      */
     public void run(String scriptText, String fileName, String[] args) throws CompilationFailedException, IOException {
         run(new ByteArrayInputStream(scriptText.getBytes()), fileName, args);
@@ -370,17 +361,17 @@ public class GroovyShell extends GroovyObjectSupport {
 
     /**
      * Runs the given script with command line arguments
-     * 
-     * @param in the stream reading the script
+     *
+     * @param in       the stream reading the script
      * @param fileName is the logical file name of the script (which is used to create the class name of the script)
-     * @param args the command line arguments to pass in
+     * @param args     the command line arguments to pass in
      */
     public Object run(final InputStream in, final String fileName, String[] args) throws CompilationFailedException, IOException {
-    	GroovyCodeSource gcs = (GroovyCodeSource) AccessController.doPrivileged(new PrivilegedAction() {
-    		public Object run() {
-    			return new GroovyCodeSource(in, fileName, "/groovy/shell");
-    		}
-    	});
+        GroovyCodeSource gcs = (GroovyCodeSource) AccessController.doPrivileged(new PrivilegedAction() {
+            public Object run() {
+                return new GroovyCodeSource(in, fileName, "/groovy/shell");
+            }
+        });
         Class scriptClass = parseClass(gcs);
         runMainOrTestOrRunnable(scriptClass, args);
         return null;
@@ -396,6 +387,7 @@ public class GroovyShell extends GroovyObjectSupport {
 
     /**
      * Evaluates some script against the current Binding and returns the result
+     *
      * @param codeSource
      * @return
      * @throws CompilationFailedException
@@ -408,9 +400,9 @@ public class GroovyShell extends GroovyObjectSupport {
 
     /**
      * Evaluates some script against the current Binding and returns the result
-     * 
+     *
      * @param scriptText the text of the script
-     * @param fileName is the logical file name of the script (which is used to create the class name of the script)
+     * @param fileName   is the logical file name of the script (which is used to create the class name of the script)
      */
     public Object evaluate(String scriptText, String fileName) throws CompilationFailedException, ClassNotFoundException, IOException {
         return evaluate(new ByteArrayInputStream(scriptText.getBytes()), fileName);
@@ -421,12 +413,12 @@ public class GroovyShell extends GroovyObjectSupport {
      * The .class file created from the script is given the supplied codeBase
      */
     public Object evaluate(String scriptText, String fileName, String codeBase) throws CompilationFailedException, IOException {
-    	return evaluate(new GroovyCodeSource(new ByteArrayInputStream(scriptText.getBytes()), fileName, codeBase));
+        return evaluate(new GroovyCodeSource(new ByteArrayInputStream(scriptText.getBytes()), fileName, codeBase));
     }
 
     /**
      * Evaluates some script against the current Binding and returns the result
-     * 
+     *
      * @param file is the file of the script (which is used to create the class name of the script)
      */
     public Object evaluate(File file) throws CompilationFailedException, IOException {
@@ -453,52 +445,61 @@ public class GroovyShell extends GroovyObjectSupport {
 
     /**
      * Evaluates some script against the current Binding and returns the result
-     * 
-     * @param in the stream reading the script
+     *
+     * @param in       the stream reading the script
      * @param fileName is the logical file name of the script (which is used to create the class name of the script)
      */
     public Object evaluate(InputStream in, String fileName) throws CompilationFailedException, IOException {
-        Script script = parse(in, fileName);
-        return script.run();
+        Script script = null;
+        try {
+            script = parse(in, fileName);
+            return script.run();
+        } finally {
+            if (script != null) {
+                InvokerHelper.removeClass(script.getClass());
+            }
+        }
     }
 
     /**
      * Parses the given script and returns it ready to be run
-     * 
-     * @param in the stream reading the script
+     *
+     * @param in       the stream reading the script
      * @param fileName is the logical file name of the script (which is used to create the class name of the script)
      * @return the parsed script which is ready to be run via @link Script.run()
      */
     public Script parse(final InputStream in, final String fileName) throws CompilationFailedException, IOException {
-    	GroovyCodeSource gcs = (GroovyCodeSource) AccessController.doPrivileged(new PrivilegedAction() {
-    		public Object run() {
-    			return new GroovyCodeSource(in, fileName, "/groovy/shell");
-    		}
-    	});
-    	return parse(gcs);
+        GroovyCodeSource gcs = (GroovyCodeSource) AccessController.doPrivileged(new PrivilegedAction() {
+            public Object run() {
+                return new GroovyCodeSource(in, fileName, "/groovy/shell");
+            }
+        });
+        return parse(gcs);
     }
 
     /**
      * Parses the groovy code contained in codeSource and returns a java class.
      */
     private Class parseClass(final GroovyCodeSource codeSource) throws CompilationFailedException, IOException {
-    	return loader.parseClass(codeSource);
+        // Don't cache scripts
+        return loader.parseClass(codeSource, false);
     }
-    
+
     /**
      * Parses the given script and returns it ready to be run.  When running in a secure environment
      * (-Djava.security.manager) codeSource.getCodeSource() determines what policy grants should be
      * given to the script.
+     *
      * @param codeSource
      * @return
      */
     public Script parse(final GroovyCodeSource codeSource) throws CompilationFailedException, IOException {
-    	return InvokerHelper.createScript(parseClass(codeSource), context);
+        return InvokerHelper.createScript(parseClass(codeSource), context);
     }
-    
+
     /**
      * Parses the given script and returns it ready to be run
-     * 
+     *
      * @param file is the file of the script (which is used to create the class name of the script)
      */
     public Script parse(File file) throws CompilationFailedException, IOException {
@@ -517,7 +518,7 @@ public class GroovyShell extends GroovyObjectSupport {
     public Script parse(String scriptText, String fileName) throws CompilationFailedException, IOException {
         return parse(new ByteArrayInputStream(scriptText.getBytes()), fileName);
     }
-    
+
     /**
      * Parses the given script and returns it ready to be run
      *
diff --git a/src/main/groovy/lang/MetaClassRegistry.java b/src/main/groovy/lang/MetaClassRegistry.java
index a7c6dceac8..9fa6cde87a 100644
--- a/src/main/groovy/lang/MetaClassRegistry.java
+++ b/src/main/groovy/lang/MetaClassRegistry.java
@@ -45,37 +45,32 @@
  */
 package groovy.lang;
 
+import org.codehaus.groovy.runtime.DefaultGroovyMethods;
+import org.codehaus.groovy.runtime.DefaultGroovyStaticMethods;
+
 import java.beans.IntrospectionException;
 import java.lang.reflect.Constructor;
 import java.security.AccessController;
 import java.security.PrivilegedAction;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-
-import org.codehaus.groovy.runtime.DefaultGroovyMethods;
-import org.codehaus.groovy.runtime.DefaultGroovyStaticMethods;
+import java.util.*;
 
 /**
- * A registery of MetaClass instances which caches introspection & 
- * reflection information and allows methods to be dynamically added to 
+ * A registery of MetaClass instances which caches introspection &
+ * reflection information and allows methods to be dynamically added to
  * existing classes at runtime
- * 
+ *
  * @author <a href="mailto:james@coredevelopers.net">James Strachan</a>
  * @version $Revision$
  */
 public class MetaClassRegistry {
     private Map metaClasses = Collections.synchronizedMap(new HashMap());
     private boolean useAccessible;
-    private GroovyClassLoader loader =  
-    	(GroovyClassLoader) AccessController.doPrivileged(new PrivilegedAction() {
-    		public Object run() {
-    			return new GroovyClassLoader(getClass().getClassLoader()); 
-    		}
-    	});
+    private GroovyClassLoader loader =
+            (GroovyClassLoader) AccessController.doPrivileged(new PrivilegedAction() {
+                public Object run() {
+                    return new GroovyClassLoader(getClass().getClassLoader());
+                }
+            });
 
     public static final int LOAD_DEFAULT = 0;
     public static final int DONT_LOAD_DEFAULT = 1;
@@ -102,7 +97,7 @@ public class MetaClassRegistry {
 
     /**
      * @param useAccessible defines whether or not the {@link AccessibleObject.setAccessible()}
-     * method will be called to enable access to all methods when using reflection
+     *                      method will be called to enable access to all methods when using reflection
      */
     public MetaClassRegistry(boolean useAccessible) {
         this.useAccessible = useAccessible;
@@ -119,20 +114,23 @@ public class MetaClassRegistry {
             try {
                 answer = new MetaClass(this, theClass);
                 answer.checkInitialised();
-            }
-            catch (IntrospectionException e) {
-                throw new GroovyRuntimeException(
-                    "Could not introspect class: " + theClass.getName() + ". Reason: " + e,
-                    e);
+            } catch (IntrospectionException e) {
+                throw new GroovyRuntimeException("Could not introspect class: " + theClass.getName() + ". Reason: " + e,
+                        e);
             }
             metaClasses.put(theClass, answer);
         }
         return answer;
     }
 
+    public void removeMetaClass(Class theClass) {
+        metaClasses.remove(theClass);
+    }
+
+
     /**
      * Registers a new MetaClass in the registry to customize the type
-     * 
+     *
      * @param theClass
      * @param theMetaClass
      */
@@ -148,11 +146,11 @@ public class MetaClassRegistry {
      * A helper class to load meta class bytecode into the class loader
      */
     public Class loadClass(final String name, final byte[] bytecode) throws ClassNotFoundException {
-    	return (Class) AccessController.doPrivileged(new PrivilegedAction() {
-    		public Object run() {
-    			return loader.defineClass(name, bytecode, getClass().getProtectionDomain());
-    		}
-    	});
+        return (Class) AccessController.doPrivileged(new PrivilegedAction() {
+            public Object run() {
+                return loader.defineClass(name, bytecode, getClass().getProtectionDomain());
+            }
+        });
     }
 
     public Class loadClass(String name) throws ClassNotFoundException {
@@ -161,7 +159,6 @@ public class MetaClassRegistry {
 
     /**
      * Ensures that all the registered MetaClass instances are initalized
-     *
      */
     void checkInitialised() {
         // lets copy all the classes in the repository right now 
@@ -181,11 +178,9 @@ public class MetaClassRegistry {
         if (answer == null) {
             try {
                 answer = new MetaClass(this, theClass);
-            }
-            catch (IntrospectionException e) {
-                throw new GroovyRuntimeException(
-                    "Could not introspect class: " + theClass.getName() + ". Reason: " + e,
-                    e);
+            } catch (IntrospectionException e) {
+                throw new GroovyRuntimeException("Could not introspect class: " + theClass.getName() + ". Reason: " + e,
+                        e);
             }
             metaClasses.put(theClass, answer);
         }
@@ -214,21 +209,22 @@ public class MetaClassRegistry {
             return metaclass.retrieveConstructor(args);
         }
     }
-            /**
+
+    /**
      * Singleton of MetaClassRegistry. Shall we use threadlocal to store the instance?
+     *
      * @param includeExtension
      * @return
      */
     public static MetaClassRegistry getIntance(int includeExtension) {
         if (includeExtension != DONT_LOAD_DEFAULT) {
             if (instanceInclude == null) {
-                instanceInclude  = new MetaClassRegistry();
+                instanceInclude = new MetaClassRegistry();
             }
             return instanceInclude;
-        }
-        else {
+        } else {
             if (instanceExclude == null) {
-                instanceExclude  = new MetaClassRegistry(DONT_LOAD_DEFAULT);
+                instanceExclude = new MetaClassRegistry(DONT_LOAD_DEFAULT);
             }
             return instanceExclude;
         }
diff --git a/src/main/org/codehaus/groovy/runtime/Invoker.java b/src/main/org/codehaus/groovy/runtime/Invoker.java
index e8587906cb..63c0318e5f 100644
--- a/src/main/org/codehaus/groovy/runtime/Invoker.java
+++ b/src/main/org/codehaus/groovy/runtime/Invoker.java
@@ -45,12 +45,12 @@
  */
 package org.codehaus.groovy.runtime;
 
-import groovy.lang.GroovyObject;
-import groovy.lang.GroovyRuntimeException;
-import groovy.lang.MetaClass;
-import groovy.lang.MetaClassRegistry;
-import groovy.lang.Range;
-import groovy.lang.Tuple;
+import groovy.lang.*;
+import org.apache.xml.serialize.OutputFormat;
+import org.apache.xml.serialize.XMLSerializer;
+import org.w3c.dom.Element;
+import org.w3c.dom.Node;
+import org.w3c.dom.NodeList;
 
 import java.io.File;
 import java.io.IOException;
@@ -58,27 +58,13 @@ import java.io.StringWriter;
 import java.lang.reflect.Method;
 import java.security.AccessController;
 import java.security.PrivilegedAction;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Enumeration;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.NoSuchElementException;
+import java.util.*;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
-import org.apache.xml.serialize.OutputFormat;
-import org.apache.xml.serialize.XMLSerializer;
-import org.w3c.dom.Element;
-import org.w3c.dom.Node;
-import org.w3c.dom.NodeList;
-
 /**
  * A helper class to invoke methods or extract properties on arbitrary Java objects dynamically
- * 
+ *
  * @author <a href="mailto:james@coredevelopers.net">James Strachan</a>
  * @version $Revision$
  */
@@ -100,8 +86,8 @@ public class Invoker {
     }
 
     /**
-     * Invokes the given method on the object. 
-     * 
+     * Invokes the given method on the object.
+     *
      * @param object
      * @param methodName
      * @param arguments
@@ -128,15 +114,13 @@ public class Invoker {
         if (object instanceof GroovyObject) {
             GroovyObject groovy = (GroovyObject) object;
             return groovy.invokeMethod(methodName, arguments);
-        }
-        else {
+        } else {
             if (object instanceof Class) {
                 Class theClass = (Class) object;
 
                 MetaClass metaClass = metaRegistry.getMetaClass(theClass);
                 return metaClass.invokeStaticMethod(object, methodName, asArray(arguments));
-            }
-            else {
+            } else {
                 Class theClass = object.getClass();
 
                 MetaClass metaClass = metaRegistry.getMetaClass(theClass);
@@ -186,30 +170,25 @@ public class Invoker {
         }
         if (arguments instanceof Object[]) {
             return (Object[]) arguments;
-        }
-        else {
-            return new Object[] { arguments };
+        } else {
+            return new Object[]{arguments};
         }
     }
 
     public List asList(Object value) {
         if (value == null) {
             return Collections.EMPTY_LIST;
-        }
-        else if (value instanceof List) {
+        } else if (value instanceof List) {
             return (List) value;
-        }
-        else if (value.getClass().isArray()) {
+        } else if (value.getClass().isArray()) {
             return Arrays.asList((Object[]) value);
-        }
-        else if (value instanceof Enumeration) {
+        } else if (value instanceof Enumeration) {
             List answer = new ArrayList();
             for (Enumeration e = (Enumeration) value; e.hasMoreElements();) {
                 answer.add(e.nextElement());
             }
             return answer;
-        }
-        else {
+        } else {
             // lets assume its a collection of 1
             return Collections.singletonList(value);
         }
@@ -222,38 +201,30 @@ public class Invoker {
     public Collection asCollection(Object value) {
         if (value == null) {
             return Collections.EMPTY_LIST;
-        }
-        else if (value instanceof Collection) {
+        } else if (value instanceof Collection) {
             return (Collection) value;
-        }
-        else if (value instanceof Map) {
+        } else if (value instanceof Map) {
             Map map = (Map) value;
             return map.entrySet();
-        }
-        else if (value.getClass().isArray()) {
+        } else if (value.getClass().isArray()) {
             if (value.getClass().getComponentType().isPrimitive()) {
                 return InvokerHelper.primitiveArrayToList(value);
             }
             return Arrays.asList((Object[]) value);
-        }
-        else if (value instanceof MethodClosure) {
+        } else if (value instanceof MethodClosure) {
             MethodClosure method = (MethodClosure) value;
             IteratorClosureAdapter adapter = new IteratorClosureAdapter(method.getDelegate());
             method.call(adapter);
             return adapter.asList();
-        }
-        else if (value instanceof String) {
+        } else if (value instanceof String) {
             return DefaultGroovyMethods.toList((String) value);
-        }
-        else if (value instanceof File) {
+        } else if (value instanceof File) {
             try {
                 return DefaultGroovyMethods.readLines((File) value);
-            }
-            catch (IOException e) {
+            } catch (IOException e) {
                 throw new GroovyRuntimeException("Error reading file: " + value, e);
             }
-        }
-        else {
+        } else {
             // lets assume its a collection of 1
             return Collections.singletonList(value);
         }
@@ -270,19 +241,21 @@ public class Invoker {
             final NodeList nodeList = (NodeList) value;
             return new Iterator() {
                 private int current = 0;
+
                 public boolean hasNext() {
-                    	return current < nodeList.getLength();
+                    return current < nodeList.getLength();
                 }
-                public Object next() { 
-                    	Node node = nodeList.item(current++);
-                    	return node;
+
+                public Object next() {
+                    Node node = nodeList.item(current++);
+                    return node;
                 }
+
                 public void remove() {
                     throw new UnsupportedOperationException("Cannot remove() from an Enumeration");
                 }
             };
-        }
-        else if (value instanceof Enumeration) {
+        } else if (value instanceof Enumeration) {
             final Enumeration enumeration = (Enumeration) value;
             return new Iterator() {
                 private Object last;
@@ -300,12 +273,12 @@ public class Invoker {
                     throw new UnsupportedOperationException("Cannot remove() from an Enumeration");
                 }
             };
-        }
-        else if (value instanceof Matcher) {
+        } else if (value instanceof Matcher) {
             final Matcher matcher = (Matcher) value;
             return new Iterator() {
                 private boolean found = false;
                 private boolean done = false;
+
                 public boolean hasNext() {
                     if (done)
                         return false;
@@ -316,6 +289,7 @@ public class Invoker {
                     }
                     return found;
                 }
+
                 public Object next() {
                     if (!found) {
                         if (!hasNext()) {
@@ -325,29 +299,28 @@ public class Invoker {
                     found = false;
                     return matcher.group();
                 }
+
                 public void remove() {
                     throw new UnsupportedOperationException();
                 }
             };
-        }
-        else {
+        } else {
             try {
                 // lets try see if there's an iterator() method
                 final Method method = value.getClass().getMethod("iterator", EMPTY_TYPES);
-                 
-                if (method != null) {                  
-	            		AccessController.doPrivileged(new PrivilegedAction() {
-	    					public Object run() {
-	    						method.setAccessible(true);
-	    						return null;
-	    					}
-	    				});
-            		
+
+                if (method != null) {
+                    AccessController.doPrivileged(new PrivilegedAction() {
+                        public Object run() {
+                            method.setAccessible(true);
+                            return null;
+                        }
+                    });
+
                     return (Iterator) method.invoke(value, EMPTY_ARGUMENTS);
                 }
-            }
-            catch (Exception e) {
-            		//  ignore
+            } catch (Exception e) {
+                //  ignore
             }
         }
         return asCollection(value).iterator();
@@ -366,8 +339,7 @@ public class Invoker {
             }
             if (left instanceof Comparable) {
                 return compareTo(left, right) == 0;
-            }
-            else {
+            } else {
                 return left.equals(right);
             }
         }
@@ -388,8 +360,7 @@ public class Invoker {
         }
         if (left == null) {
             return -1;
-        }
-        else if (right == null) {
+        } else if (right == null) {
             return 1;
         }
         if (left instanceof Comparable) {
@@ -398,23 +369,19 @@ public class Invoker {
                     return asCharacter((Number) left).compareTo(asCharacter((String) right));
                 }
                 return DefaultGroovyMethods.compareTo((Number) left, asNumber(right));
-            }
-            else if (left instanceof Character) {
+            } else if (left instanceof Character) {
                 if (isValidCharacterString(right)) {
                     return ((Character) left).compareTo(asCharacter((String) right));
-                }
-                else if (right instanceof Number) {
+                } else if (right instanceof Number) {
                     return ((Character) left).compareTo(asCharacter((Number) right));
                 }
-            }
-            else if (right instanceof Number) {
+            } else if (right instanceof Number) {
                 if (isValidCharacterString(left)) {
                     return asCharacter((String) left).compareTo(asCharacter((Number) right));
                 }
                 return DefaultGroovyMethods.compareTo(asNumber(left), (Number) right);
-            }
-            else if (left instanceof String && right instanceof Character) {
-                return ((String)left).compareTo(right.toString());
+            } else if (left instanceof String && right instanceof Character) {
+                return ((String) left).compareTo(right.toString());
             }
             Comparable comparable = (Comparable) left;
             return comparable.compareTo(right);
@@ -439,54 +406,48 @@ public class Invoker {
     }
 
     /**
-	 * A helper method to format the arguments types as a comma-separated list
-	 */
-	public String toTypeString(Object[] arguments) {
-		if (arguments == null) {
-			return "null";
-		}
-	    StringBuffer argBuf = new StringBuffer();
-	    for (int i = 0; i < arguments.length; i++) {
-	    	if (i>0)
+     * A helper method to format the arguments types as a comma-separated list
+     */
+    public String toTypeString(Object[] arguments) {
+        if (arguments == null) {
+            return "null";
+        }
+        StringBuffer argBuf = new StringBuffer();
+        for (int i = 0; i < arguments.length; i++) {
+            if (i > 0)
                 argBuf.append(", ");
-			argBuf.append(arguments[i] != null ? arguments[i].getClass().getName() : "null");
-		}
-	    return argBuf.toString();
-	}
-    
+            argBuf.append(arguments[i] != null ? arguments[i].getClass().getName() : "null");
+        }
+        return argBuf.toString();
+    }
+
     protected String format(Object arguments, boolean verbose) {
         if (arguments == null) {
             return "null";
-        }
-        else if (arguments.getClass().isArray()) {
+        } else if (arguments.getClass().isArray()) {
             return format(asCollection(arguments), verbose);
-        }
-        else if (arguments instanceof Range) {
+        } else if (arguments instanceof Range) {
             Range range = (Range) arguments;
             if (verbose) {
                 return range.inspect();
-            }
-            else {
+            } else {
                 return range.toString();
             }
-        }
-        else if (arguments instanceof List) {
+        } else if (arguments instanceof List) {
             List list = (List) arguments;
             StringBuffer buffer = new StringBuffer("[");
             boolean first = true;
             for (Iterator iter = list.iterator(); iter.hasNext();) {
                 if (first) {
                     first = false;
-                }
-                else {
+                } else {
                     buffer.append(", ");
                 }
                 buffer.append(format(iter.next(), verbose));
             }
             buffer.append("]");
             return buffer.toString();
-        }
-        else if (arguments instanceof Map) {
+        } else if (arguments instanceof Map) {
             Map map = (Map) arguments;
             if (map.isEmpty()) {
                 return "[:]";
@@ -496,8 +457,7 @@ public class Invoker {
             for (Iterator iter = map.entrySet().iterator(); iter.hasNext();) {
                 if (first) {
                     first = false;
-                }
-                else {
+                } else {
                     buffer.append(", ");
                 }
                 Map.Entry entry = (Map.Entry) iter.next();
@@ -507,39 +467,35 @@ public class Invoker {
             }
             buffer.append("]");
             return buffer.toString();
-        }
-        else if (arguments instanceof Element) {
+        } else if (arguments instanceof Element) {
             Element node = (Element) arguments;
             OutputFormat format = new OutputFormat(node.getOwnerDocument());
             format.setOmitXMLDeclaration(true);
             format.setIndenting(true);
-            format.setLineWidth(0);             
+            format.setLineWidth(0);
             format.setPreserveSpace(true);
             StringWriter sw = new StringWriter();
-            XMLSerializer serializer = new XMLSerializer (sw, format);
+            XMLSerializer serializer = new XMLSerializer(sw, format);
             try {
                 serializer.asDOMSerializer();
                 serializer.serialize(node);
             } catch (IOException e) {
             }
             return sw.toString();
-        }
-        else if (arguments instanceof String) {
+        } else if (arguments instanceof String) {
             if (verbose) {
                 return "\"" + arguments + "\"";
-            }
-            else {
+            } else {
                 return (String) arguments;
             }
-        }
-        else {
+        } else {
             return arguments.toString();
         }
     }
 
     /**
      * Sets the property on the given object
-     * 
+     *
      * @param object
      * @param property
      * @param newValue
@@ -548,23 +504,20 @@ public class Invoker {
     public void setProperty(Object object, String property, Object newValue) {
         if (object == null) {
             throw new GroovyRuntimeException("Cannot set property on null object");
-        }
-        else if (object instanceof GroovyObject) {
+        } else if (object instanceof GroovyObject) {
             GroovyObject pogo = (GroovyObject) object;
             pogo.setProperty(property, newValue);
-        }
-        else if (object instanceof Map) {
+        } else if (object instanceof Map) {
             Map map = (Map) object;
             map.put(property, newValue);
-        }
-        else {
+        } else {
             metaRegistry.getMetaClass(object.getClass()).setProperty(object, property, newValue);
         }
     }
 
     /**
      * Looks up the given property of the given object
-     * 
+     *
      * @param object
      * @param property
      * @return
@@ -572,16 +525,13 @@ public class Invoker {
     public Object getProperty(Object object, String property) {
         if (object == null) {
             throw new NullPointerException("Cannot get property: " + property + " on null object");
-        }
-        else if (object instanceof GroovyObject) {
+        } else if (object instanceof GroovyObject) {
             GroovyObject pogo = (GroovyObject) object;
             return pogo.getProperty(property);
-        }
-        else if (object instanceof Map) {
+        } else if (object instanceof Map) {
             Map map = (Map) object;
             return map.get(property);
-        }
-        else {
+        } else {
             return metaRegistry.getMetaClass(object.getClass()).getProperty(object, property);
         }
     }
@@ -597,19 +547,16 @@ public class Invoker {
     public Number asNumber(Object value) {
         if (value instanceof Number) {
             return (Number) value;
-        }
-        else if (value instanceof String) {
+        } else if (value instanceof String) {
             String s = (String) value;
 
             if (s.length() == 1)
                 return new Integer(s.charAt(0));
             else
                 return Double.valueOf(s);
-        }
-        else if (value instanceof Character) {
+        } else if (value instanceof Character) {
             return new Integer(((Character) value).charValue());
-        }
-        else {
+        } else {
             throw new GroovyRuntimeException("Could not convert object: " + value + " into a Number");
         }
     }
@@ -621,16 +568,13 @@ public class Invoker {
     protected Class loadClass(String type) {
         try {
             return getClass().getClassLoader().loadClass(type);
-        }
-        catch (ClassNotFoundException e) {
+        } catch (ClassNotFoundException e) {
             try {
                 return Thread.currentThread().getContextClassLoader().loadClass(type);
-            }
-            catch (ClassNotFoundException e2) {
+            } catch (ClassNotFoundException e2) {
                 try {
                     return Class.forName(type);
-                }
-                catch (ClassNotFoundException e3) {
+                } catch (ClassNotFoundException e3) {
                 }
             }
             throw new GroovyRuntimeException("Could not load type: " + type, e);
@@ -639,8 +583,8 @@ public class Invoker {
 
     /**
      * Find the right hand regex within the left hand string and return a matcher.
-     * 
-     * @param left string to compare
+     *
+     * @param left  string to compare
      * @param right regular expression to compare the string to
      * @return
      */
@@ -648,19 +592,16 @@ public class Invoker {
         String stringToCompare;
         if (left instanceof String) {
             stringToCompare = (String) left;
-        }
-        else {
+        } else {
             stringToCompare = toString(left);
         }
         String regexToCompareTo;
         if (right instanceof String) {
             regexToCompareTo = (String) right;
-        }
-        else if (right instanceof Pattern) {
+        } else if (right instanceof Pattern) {
             Pattern pattern = (Pattern) right;
             return pattern.matcher(stringToCompare);
-        }
-        else {
+        } else {
             regexToCompareTo = toString(right);
         }
         Matcher matcher = Pattern.compile(regexToCompareTo).matcher(stringToCompare);
@@ -669,8 +610,8 @@ public class Invoker {
 
     /**
      * Find the right hand regex within the left hand string and return a matcher.
-     * 
-     * @param left string to compare
+     *
+     * @param left  string to compare
      * @param right regular expression to compare the string to
      * @return
      */
@@ -678,8 +619,7 @@ public class Invoker {
         Pattern pattern;
         if (right instanceof Pattern) {
             pattern = (Pattern) right;
-        }
-        else {
+        } else {
             pattern = Pattern.compile(toString(right));
         }
         String stringToCompare = toString(left);
@@ -690,7 +630,7 @@ public class Invoker {
 
     /**
      * Compile a regular expression from a string.
-     * 
+     *
      * @param regex
      * @return
      */
@@ -711,13 +651,11 @@ public class Invoker {
         if (type.equals(Character.class)) {
             if (object instanceof Number) {
                 return asCharacter((Number) object);
-            }
-            else {
+            } else {
                 String text = object.toString();
                 if (text.length() == 1) {
                     return new Character(text.charAt(0));
-                }
-                else {
+                } else {
                     throw new ClassCastException("Cannot cast: " + text + " to a Character");
                 }
             }
@@ -725,13 +663,11 @@ public class Invoker {
         if (Number.class.isAssignableFrom(type)) {
             if (object instanceof Character) {
                 return new Integer(((Character) object).charValue());
-            }
-            else if (object instanceof String) {
+            } else if (object instanceof String) {
                 String c = (String) object;
                 if (c.length() == 1) {
                     return new Integer(c.charAt(0));
-                }
-                else {
+                } else {
                     throw new ClassCastException("Cannot cast: '" + c + "' to an Integer");
                 }
             }
@@ -762,13 +698,12 @@ public class Invoker {
                     //throw a runtime exception if conversion would be out-of-range for the type.
                     if (!(n instanceof Double) && (answer.doubleValue() == Double.NEGATIVE_INFINITY
                             || answer.doubleValue() == Double.POSITIVE_INFINITY)) {
-                        throw new  GroovyRuntimeException("Automatic coercion of "+n.getClass().getName()
-                                +" value "+n+" to double failed.  Value is out of range.");
+                        throw new GroovyRuntimeException("Automatic coercion of " + n.getClass().getName()
+                                + " value " + n + " to double failed.  Value is out of range.");
                     }
                     return answer;
                 }
-            }
-            else {
+            } else {
                 if (Number.class.isAssignableFrom(type)) {
                     if (type == Byte.class) {
                         return new Byte(n.byteValue());
@@ -793,8 +728,8 @@ public class Invoker {
                         //throw a runtime exception if conversion would be out-of-range for the type.
                         if (!(n instanceof Double) && (answer.doubleValue() == Double.NEGATIVE_INFINITY
                                 || answer.doubleValue() == Double.POSITIVE_INFINITY)) {
-                            throw new  GroovyRuntimeException("Automatic coercion of "+n.getClass().getName()
-                                    +" value "+n+" to double failed.  Value is out of range.");
+                            throw new GroovyRuntimeException("Automatic coercion of " + n.getClass().getName()
+                                    + " value " + n + " to double failed.  Value is out of range.");
                         }
                         return answer;
                     }
@@ -809,24 +744,20 @@ public class Invoker {
     }
 
     public boolean asBool(Object object) {
-       if (object instanceof Boolean) {
+        if (object instanceof Boolean) {
             Boolean booleanValue = (Boolean) object;
             return booleanValue.booleanValue();
-        }
-        else if (object instanceof Matcher) {
+        } else if (object instanceof Matcher) {
             Matcher matcher = (Matcher) object;
             RegexSupport.setLastMatcher(matcher);
             return matcher.find();
-        }
-        else if (object instanceof Collection) {
+        } else if (object instanceof Collection) {
             Collection collection = (Collection) object;
             return !collection.isEmpty();
-        }
-        else if (object instanceof Number) {
+        } else if (object instanceof Number) {
             Number n = (Number) object;
             return n.doubleValue() != 0;
-        }
-        else {
+        } else {
             return object != null;
         }
     }
@@ -852,4 +783,7 @@ public class Invoker {
         return false;
     }
 
+    public void removeMetaClass(Class clazz) {
+        getMetaRegistry().removeMetaClass(clazz);
+    }
 }
diff --git a/src/main/org/codehaus/groovy/runtime/InvokerHelper.java b/src/main/org/codehaus/groovy/runtime/InvokerHelper.java
index ba252a193e..6fa099b2bc 100644
--- a/src/main/org/codehaus/groovy/runtime/InvokerHelper.java
+++ b/src/main/org/codehaus/groovy/runtime/InvokerHelper.java
@@ -45,36 +45,20 @@
  */
 package org.codehaus.groovy.runtime;
 
-import groovy.lang.Binding;
-import groovy.lang.GroovyObject;
-import groovy.lang.GroovyRuntimeException;
-import groovy.lang.IntRange;
-import groovy.lang.MetaClass;
-import groovy.lang.ObjectRange;
-import groovy.lang.Script;
-import groovy.lang.Tuple;
-import groovy.lang.Writable;
-
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.Reader;
-import java.io.Writer;
+import groovy.lang.*;
+
+import java.beans.Introspector;
+import java.io.*;
 import java.lang.reflect.Array;
 import java.math.BigDecimal;
 import java.math.BigInteger;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
+import java.util.*;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
 /**
  * A static helper class to make bytecode generation easier and act as a facade over the Invoker
- * 
+ *
  * @author <a href="mailto:james@coredevelopers.net">James Strachan</a>
  * @version $Revision$
  */
@@ -82,7 +66,7 @@ public class InvokerHelper {
     public static final Object[] EMPTY_ARGS = {
     };
 
-    private static final Object[] EMPTY_MAIN_ARGS = new Object[] { new String[0] };
+    private static final Object[] EMPTY_MAIN_ARGS = new Object[]{new String[0]};
 
     private static final Invoker singleton = new Invoker();
 
@@ -94,6 +78,11 @@ public class InvokerHelper {
         return getInstance().getMetaClass(object);
     }
 
+    public static void removeClass(Class clazz) {
+        getInstance().removeMetaClass(clazz);
+        Introspector.flushFromCaches(clazz);
+    }
+
     public static Invoker getInstance() {
         return singleton;
     }
@@ -196,12 +185,12 @@ public class InvokerHelper {
     public static void setGroovyObjectProperty(Object newValue, GroovyObject object, String property) {
         object.setProperty(property, newValue);
     }
-    
+
     public static Object getGroovyObjectProperty(GroovyObject object, String property) {
         return object.getProperty(property);
     }
-    
-    
+
+
     /**
      * This is so we don't have to reorder the stack when we call this method.
      * At some point a better name might be in order.
@@ -214,7 +203,8 @@ public class InvokerHelper {
 
     /**
      * Provides a hook for type coercion of the given object to the required type
-     * @param type of object to convert the given object to
+     *
+     * @param type   of object to convert the given object to
      * @param object the object to be converted
      * @return the original object or a new converted value
      */
@@ -238,33 +228,26 @@ public class InvokerHelper {
         if (value instanceof Integer) {
             Integer number = (Integer) value;
             return integerValue(-number.intValue());
-        }
-        else if (value instanceof Long) {
+        } else if (value instanceof Long) {
             Long number = (Long) value;
             return new Long(-number.longValue());
-        }
-        else if (value instanceof BigInteger) {
-            return ((BigInteger)value).negate();
-        }
-        else if (value instanceof BigDecimal) {
-            return ((BigDecimal)value).negate();
-        }
-        else if (value instanceof Double) {
+        } else if (value instanceof BigInteger) {
+            return ((BigInteger) value).negate();
+        } else if (value instanceof BigDecimal) {
+            return ((BigDecimal) value).negate();
+        } else if (value instanceof Double) {
             Double number = (Double) value;
             return new Double(-number.doubleValue());
-        }
-        else if (value instanceof Float) {
+        } else if (value instanceof Float) {
             Float number = (Float) value;
             return new Float(-number.floatValue());
-        }
-        else {
-            throw new GroovyRuntimeException(
-                    "Cannot negate type " + value.getClass().getName() + ", value "+value);
+        } else {
+            throw new GroovyRuntimeException("Cannot negate type " + value.getClass().getName() + ", value " + value);
         }
     }
 
     public static boolean isCase(Object switchValue, Object caseExpression) {
-        return asBool(invokeMethod(caseExpression, "isCase", new Object[] { switchValue }));
+        return asBool(invokeMethod(caseExpression, "isCase", new Object[]{switchValue}));
     }
 
     public static boolean compareIdentical(Object left, Object right) {
@@ -311,8 +294,7 @@ public class InvokerHelper {
         int answer = getInstance().compareTo(left, right);
         if (answer == 0) {
             return ZERO;
-        }
-        else {
+        } else {
             return answer > 0 ? ONE : MINUS_ONE;
         }
     }
@@ -342,15 +324,13 @@ public class InvokerHelper {
         if (!inclusive) {
             if (compareGreaterThan(from, to)) {
                 to = invokeMethod(to, "next", EMPTY_ARGS);
-            }
-            else {
+            } else {
                 to = invokeMethod(to, "previous", EMPTY_ARGS);
             }
         }
         if (from instanceof Integer && to instanceof Integer) {
             return new IntRange(asInt(from), asInt(to));
-        }
-        else {
+        } else {
             return new ObjectRange((Comparable) from, (Comparable) to);
         }
     }
@@ -362,8 +342,7 @@ public class InvokerHelper {
     public static void assertFailed(Object expression, Object message) {
         if (message == null || "".equals(message)) {
             throw new AssertionError("Expression: " + expression);
-        }
-        else {
+        } else {
             throw new AssertionError("" + message + ". Expression: " + expression);
         }
     }
@@ -380,8 +359,7 @@ public class InvokerHelper {
             Script script = null;
             if (object instanceof Script) {
                 script = (Script) object;
-            }
-            else {
+            } else {
                 // it could just be a class, so lets wrap it in a Script wrapper
                 // though the bindings will be ignored
                 script = new Script() {
@@ -394,17 +372,15 @@ public class InvokerHelper {
             }
             script.setBinding(context);
             return script;
-        }
-        catch (Exception e) {
-            throw new GroovyRuntimeException(
-                "Failed to create Script instance for class: " + scriptClass + ". Reason: " + e,
-                e);
+        } catch (Exception e) {
+            throw new GroovyRuntimeException("Failed to create Script instance for class: " + scriptClass + ". Reason: " + e,
+                    e);
         }
     }
 
     /**
      * Sets the properties on the given object
-     * 
+     *
      * @param object
      * @param map
      */
@@ -426,7 +402,7 @@ public class InvokerHelper {
 
     /**
      * Allows conversion of arrays into a mutable List
-     * 
+     *
      * @return the array as a List
      */
     protected static List primitiveArrayToList(Object array) {
@@ -444,16 +420,14 @@ public class InvokerHelper {
     public static void write(Writer out, Object object) throws IOException {
         if (object instanceof String) {
             out.write((String) object);
-        }
-        else if (object instanceof Writable) {
+        } else if (object instanceof Writable) {
             Writable writable = (Writable) object;
             writable.writeTo(out);
-        }
-        else if (object instanceof InputStream || object instanceof Reader) {
+        } else if (object instanceof InputStream || object instanceof Reader) {
             // Copy stream to stream
             Reader reader;
             if (object instanceof InputStream) {
-                reader = new InputStreamReader((InputStream)object);
+                reader = new InputStreamReader((InputStream) object);
             } else {
                 reader = (Reader) object;
             }
@@ -463,8 +437,7 @@ public class InvokerHelper {
                 out.write(chars, 0, i);
             }
             reader.close();
-        }
-        else {
+        } else {
             out.write(toString(object));
         }
     }
@@ -480,70 +453,69 @@ public class InvokerHelper {
     public static Object box(char value) {
         return new Character(value);
     }
-    
+
     public static Object box(short value) {
         return new Short(value);
     }
-    
+
     public static Object box(int value) {
         return integerValue(value);
     }
-    
+
     public static Object box(long value) {
         return new Long(value);
     }
-    
+
     public static Object box(float value) {
         return new Float(value);
     }
-    
+
     public static Object box(double value) {
         return new Double(value);
     }
-    
+
     public static byte byteUnbox(Object value) {
         Number n = (Number) asType(value, Byte.class);
         return n.byteValue();
     }
-    
+
     public static char charUnbox(Object value) {
         Character n = (Character) asType(value, Character.class);
         return n.charValue();
     }
-    
+
     public static short shortUnbox(Object value) {
         Number n = (Number) asType(value, Short.class);
         return n.shortValue();
     }
-    
+
     public static int intUnbox(Object value) {
         Number n = (Number) asType(value, Integer.class);
         return n.intValue();
     }
-    
+
     public static boolean booleanUnbox(Object value) {
         Boolean n = (Boolean) asType(value, Boolean.class);
         return n.booleanValue();
     }
-    
+
     public static long longUnbox(Object value) {
         Number n = (Number) asType(value, Long.class);
         return n.longValue();
     }
-    
+
     public static float floatUnbox(Object value) {
         Number n = (Number) asType(value, Float.class);
         return n.floatValue();
     }
-    
+
     public static double doubleUnbox(Object value) {
         Number n = (Number) asType(value, Double.class);
         return n.doubleValue();
     }
 
     /**
-     *
-     * @param a array of primitives
+     * @param a    array of primitives
      * @param type component type of the array
      * @return
      */
@@ -554,101 +526,86 @@ public class InvokerHelper {
         if (elemType.equals("int")) {
             // conservative coding
             if (a.getClass().getName().equals("[Ljava.lang.Integer;")) {
-                ans = (Integer[])a;
-            }
-            else {
-                int[] ia = (int[])a;
+                ans = (Integer[]) a;
+            } else {
+                int[] ia = (int[]) a;
                 ans = new Integer[ia.length];
                 for (int i = 0; i < ia.length; i++) {
                     int e = ia[i];
                     ans[i] = integerValue(e);
                 }
             }
-        }
-        else if(elemType.equals("char")) {
+        } else if (elemType.equals("char")) {
             if (a.getClass().getName().equals("[Ljava.lang.Character;")) {
-                ans = (Character[])a;
-            }
-            else {
-                char[] ia = (char[])a;
+                ans = (Character[]) a;
+            } else {
+                char[] ia = (char[]) a;
                 ans = new Character[ia.length];
                 for (int i = 0; i < ia.length; i++) {
                     char e = ia[i];
                     ans[i] = new Character(e);
                 }
             }
-        }
-        else if(elemType.equals("boolean")) {
+        } else if (elemType.equals("boolean")) {
             if (a.getClass().getName().equals("[Ljava.lang.Boolean;")) {
-                ans = (Boolean[])a;
-            }
-            else {
-                boolean[] ia = (boolean[])a;
+                ans = (Boolean[]) a;
+            } else {
+                boolean[] ia = (boolean[]) a;
                 ans = new Boolean[ia.length];
                 for (int i = 0; i < ia.length; i++) {
                     boolean e = ia[i];
                     ans[i] = new Boolean(e);
                 }
             }
-        }
-        else if(elemType.equals("byte")) {
+        } else if (elemType.equals("byte")) {
             if (a.getClass().getName().equals("[Ljava.lang.Byte;")) {
-                ans = (Byte[])a;
-            }
-            else {
-                byte[] ia = (byte[])a;
+                ans = (Byte[]) a;
+            } else {
+                byte[] ia = (byte[]) a;
                 ans = new Byte[ia.length];
                 for (int i = 0; i < ia.length; i++) {
                     byte e = ia[i];
                     ans[i] = new Byte(e);
                 }
             }
-        }
-        else if(elemType.equals("short")) {
+        } else if (elemType.equals("short")) {
             if (a.getClass().getName().equals("[Ljava.lang.Short;")) {
-                ans = (Short[])a;
-            }
-            else {
-                short[] ia = (short[])a;
+                ans = (Short[]) a;
+            } else {
+                short[] ia = (short[]) a;
                 ans = new Short[ia.length];
                 for (int i = 0; i < ia.length; i++) {
                     short e = ia[i];
                     ans[i] = new Short(e);
                 }
             }
-        }
-        else if(elemType.equals("float")) {
+        } else if (elemType.equals("float")) {
             if (a.getClass().getName().equals("[Ljava.lang.Float;")) {
-                ans = (Float[])a;
-            }
-            else {
-                float[] ia = (float[])a;
+                ans = (Float[]) a;
+            } else {
+                float[] ia = (float[]) a;
                 ans = new Float[ia.length];
                 for (int i = 0; i < ia.length; i++) {
                     float e = ia[i];
                     ans[i] = new Float(e);
                 }
             }
-        }
-        else if(elemType.equals("long")) {
+        } else if (elemType.equals("long")) {
             if (a.getClass().getName().equals("[Ljava.lang.Long;")) {
-                ans = (Long[])a;
-            }
-            else {
-                long[] ia = (long[])a;
+                ans = (Long[]) a;
+            } else {
+                long[] ia = (long[]) a;
                 ans = new Long[ia.length];
                 for (int i = 0; i < ia.length; i++) {
                     long e = ia[i];
                     ans[i] = new Long(e);
                 }
             }
-        }
-        else if(elemType.equals("double")) {
+        } else if (elemType.equals("double")) {
             if (a.getClass().getName().equals("[Ljava.lang.Double;")) {
-                ans = (Double[])a;
-            }
-            else {
-                double[] ia = (double[])a;
+                ans = (Double[]) a;
+            } else {
+                double[] ia = (double[]) a;
                 ans = new Double[ia.length];
                 for (int i = 0; i < ia.length; i++) {
                     double e = ia[i];
@@ -659,135 +616,129 @@ public class InvokerHelper {
         return ans;
     }
 
-    public static int[] convertToIntArray(Object a){
+    public static int[] convertToIntArray(Object a) {
         int[] ans = null;
 
         // conservative coding
         if (a.getClass().getName().equals("[I")) {
-            ans = (int[])a;
-        }
-        else {
-            Object[] ia = (Object[])a;
+            ans = (int[]) a;
+        } else {
+            Object[] ia = (Object[]) a;
             ans = new int[ia.length];
             for (int i = 0; i < ia.length; i++) {
-                ans[i] = ((Number)ia[i]).intValue();
+                ans[i] = ((Number) ia[i]).intValue();
             }
         }
         return ans;
     }
 
-    public static boolean[] convertToBooleanArray(Object a){
+    public static boolean[] convertToBooleanArray(Object a) {
         boolean[] ans = null;
 
         // conservative coding
         if (a.getClass().getName().equals("[Z")) {
-            ans = (boolean[])a;
-        }
-        else {
-            Object[] ia = (Object[])a;
+            ans = (boolean[]) a;
+        } else {
+            Object[] ia = (Object[]) a;
             ans = new boolean[ia.length];
             for (int i = 0; i < ia.length; i++) {
-                ans[i] = ((Boolean)ia[i]).booleanValue();
+                ans[i] = ((Boolean) ia[i]).booleanValue();
             }
         }
         return ans;
     }
-    public static byte[] convertToByteArray(Object a){
+
+    public static byte[] convertToByteArray(Object a) {
         byte[] ans = null;
 
         // conservative coding
         if (a.getClass().getName().equals("[B")) {
-            ans = (byte[])a;
-        }
-        else {
-            Object[] ia = (Object[])a;
+            ans = (byte[]) a;
+        } else {
+            Object[] ia = (Object[]) a;
             ans = new byte[ia.length];
             for (int i = 0; i < ia.length; i++) {
-                ans[i] = ((Number)ia[i]).byteValue();
+                ans[i] = ((Number) ia[i]).byteValue();
             }
         }
         return ans;
     }
-    public static short[] convertToShortArray(Object a){
+
+    public static short[] convertToShortArray(Object a) {
         short[] ans = null;
 
         // conservative coding
         if (a.getClass().getName().equals("[S")) {
-            ans = (short[])a;
-        }
-        else {
-            Object[] ia = (Object[])a;
+            ans = (short[]) a;
+        } else {
+            Object[] ia = (Object[]) a;
             ans = new short[ia.length];
             for (int i = 0; i < ia.length; i++) {
-                ans[i] = ((Number)ia[i]).shortValue();
+                ans[i] = ((Number) ia[i]).shortValue();
             }
         }
         return ans;
     }
 
-    public static char[] convertToCharArray(Object a){
+    public static char[] convertToCharArray(Object a) {
         char[] ans = null;
 
         // conservative coding
         if (a.getClass().getName().equals("[C")) {
-            ans = (char[])a;
-        }
-        else {
-            Object[] ia = (Object[])a;
+            ans = (char[]) a;
+        } else {
+            Object[] ia = (Object[]) a;
             ans = new char[ia.length];
             for (int i = 0; i < ia.length; i++) {
-                ans[i] = ((Character)ia[i]).charValue();
+                ans[i] = ((Character) ia[i]).charValue();
             }
         }
         return ans;
     }
 
-    public static long[] convertToLongArray(Object a){
+    public static long[] convertToLongArray(Object a) {
         long[] ans = null;
 
         // conservative coding
         if (a.getClass().getName().equals("[J")) {
-            ans = (long[])a;
-        }
-        else {
-            Object[] ia = (Object[])a;
+            ans = (long[]) a;
+        } else {
+            Object[] ia = (Object[]) a;
             ans = new long[ia.length];
             for (int i = 0; i < ia.length; i++) {
-                ans[i] = ((Number)ia[i]).longValue();
+                ans[i] = ((Number) ia[i]).longValue();
             }
         }
         return ans;
     }
 
-    public static float[] convertToFloatArray(Object a){
+    public static float[] convertToFloatArray(Object a) {
         float[] ans = null;
 
         // conservative coding
         if (a.getClass().getName().equals("[F")) {
-            ans = (float[])a;
-        }
-        else {
-            Object[] ia = (Object[])a;
+            ans = (float[]) a;
+        } else {
+            Object[] ia = (Object[]) a;
             ans = new float[ia.length];
             for (int i = 0; i < ia.length; i++) {
-                ans[i] = ((Number)ia[i]).floatValue();
+                ans[i] = ((Number) ia[i]).floatValue();
             }
         }
         return ans;
     }
 
-    public static double[] convertToDoubleArray(Object a){
+    public static double[] convertToDoubleArray(Object a) {
         double[] ans = null;
 
         // conservative coding
         if (a.getClass().getName().equals("[D")) {
-            ans = (double[])a;
-        }
-        else {
-            Object[] ia = (Object[])a;
+            ans = (double[]) a;
+        } else {
+            Object[] ia = (Object[]) a;
             ans = new double[ia.length];
             for (int i = 0; i < ia.length; i++) {
-                ans[i] = ((Number)ia[i]).doubleValue();
+                ans[i] = ((Number) ia[i]).doubleValue();
             }
         }
         return ans;
@@ -816,21 +767,22 @@ public class InvokerHelper {
 
     /**
      * get the Integer object from an int. Cached version is used for small ints.
+     *
      * @param v
      * @return
      */
     public static Integer integerValue(int v) {
         int index = v + INT_CACHE_OFFSET;
-        if (index >= 0 && index < INT_CACHE_LEN ) {
+        if (index >= 0 && index < INT_CACHE_LEN) {
             return SMALL_INTEGERS[index];
-        }
-        else {
+        } else {
             return new Integer(v);
         }
     }
 
     private static Integer[] SMALL_INTEGERS;
     private static int INT_CACHE_OFFSET = 128, INT_CACHE_LEN = 256;
+
     static {
         SMALL_INTEGERS = new Integer[INT_CACHE_LEN];
         for (int i = 0; i < SMALL_INTEGERS.length; i++) {
