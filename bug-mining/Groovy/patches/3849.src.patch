diff --git a/src/main/java/org/codehaus/groovy/ast/ClassNode.java b/src/main/java/org/codehaus/groovy/ast/ClassNode.java
index f6bf3e30bc..9eaf47c9c7 100644
--- a/src/main/java/org/codehaus/groovy/ast/ClassNode.java
+++ b/src/main/java/org/codehaus/groovy/ast/ClassNode.java
@@ -1241,71 +1241,65 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
     }
 
     /**
-     * Returns true if the given method has a possibly matching instance method with the given name and arguments.
+     * Determines if the type has a possibly-matching instance method with the given name and arguments.
      *
      * @param name      the name of the method of interest
      * @param arguments the arguments to match against
      * @return true if a matching method was found
      */
-    public boolean hasPossibleMethod(String name, Expression arguments) {
-        int count = 0;
-
+    public boolean hasPossibleMethod(final String name, final Expression arguments) {
+        int count;
         if (arguments instanceof TupleExpression) {
-            TupleExpression tuple = (TupleExpression) arguments;
-            // TODO this won't strictly be true when using list expansion in argument calls
-            count = tuple.getExpressions().size();
+            // TODO: this won't strictly be true when using list expansion in argument calls
+            count = ((TupleExpression) arguments).getExpressions().size();
+        } else {
+            count = 0;
         }
-        ClassNode node = this;
-        do {
-            for (MethodNode method : getMethods(name)) {
-                if (hasCompatibleNumberOfArgs(method, count) && !method.isStatic()) {
+
+        for (ClassNode cn = this; cn != null; cn = cn.getSuperClass()) {
+            for (MethodNode mn : getDeclaredMethods(name)) {
+                if (!mn.isStatic() && hasCompatibleNumberOfArgs(mn, count)) {
                     return true;
                 }
             }
-            node = node.getSuperClass();
         }
-        while (node != null);
 
         return false;
     }
 
-    public MethodNode tryFindPossibleMethod(String name, Expression arguments) {
-        int count = 0;
-
-        if (arguments instanceof TupleExpression) {
-            TupleExpression tuple = (TupleExpression) arguments;
-            // TODO this won't strictly be true when using list expansion in argument calls
-            count = tuple.getExpressions().size();
-        } else {
+    public MethodNode tryFindPossibleMethod(final String name, final Expression arguments) {
+        if (!(arguments instanceof TupleExpression)) {
             return null;
         }
 
-        MethodNode res = null;
-        ClassNode node = this;
+        // TODO: this won't strictly be true when using list expansion in argument calls
         TupleExpression args = (TupleExpression) arguments;
-        do {
-            for (MethodNode method : node.getMethods(name)) {
-                if (hasCompatibleNumberOfArgs(method, count)) {
+        int count = args.getExpressions().size();
+        MethodNode res = null;
+
+        for (ClassNode cn = this; cn != null; cn = cn.getSuperClass()) {
+            for (MethodNode mn : cn.getDeclaredMethods(name)) {
+                if (hasCompatibleNumberOfArgs(mn, count)) {
                     boolean match = true;
                     for (int i = 0; i < count; i += 1) {
-                        if (!hasCompatibleType(args, method, i)) {
+                        if (!hasCompatibleType(args, mn, i)) {
                             match = false;
                             break;
                         }
                     }
                     if (match) {
                         if (res == null) {
-                            res = method;
+                            res = mn;
                         } else {
                             if (res.getParameters().length != count)
                                 return null;
-                            if (node.equals(this))
+                            if (cn.equals(this))
                                 return null;
 
                             match = true;
                             for (int i = 0; i < count; i += 1) {
                                 // prefer super method if it matches better
-                                if (!hasExactMatchingCompatibleType(res, method, i)) {
+                                if (!hasExactMatchingCompatibleType(res, mn, i)) {
                                     match = false;
                                     break;
                                 }
@@ -1317,9 +1311,7 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
                     }
                 }
             }
-            node = node.getSuperClass();
         }
-        while (node != null);
 
         return res;
     }
