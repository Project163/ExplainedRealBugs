diff --git a/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java b/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
index 0155db486b..aed22d6dd6 100644
--- a/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
+++ b/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
@@ -3802,8 +3802,9 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
     }
 
     /**
-     * Converts the given collection to either a List, Set, or
-     * SortedSet.  If the given class is something else, the
+     * Converts the given collection to another type. A default concrete
+     * type is used for List, Set, or SortedSet. If the given type has
+     * a constructor taking a collection, that is used. Otherwise, the
      * call is deferred to {link #asType(Object,Class)}.  If this
      * collection is already of the given type, the same instance is
      * returned.
@@ -3814,15 +3815,26 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      * @see #asType(Object,Class)
      */
     public static Object asType(Collection col, Class clazz) {
+        if (col.getClass() == clazz) {
+            return col;
+        }
         if (clazz == List.class) {
             return asList(col);
-        } else if (clazz == Set.class) {
+        }
+        if (clazz == Set.class) {
             if (col instanceof Set) return col;
             return new HashSet(col);
-        } else if (clazz == SortedSet.class) {
+        }
+        if (clazz == SortedSet.class) {
             if (col instanceof SortedSet) return col;
             return new TreeSet(col);
         }
+        Object[] args = {col};
+        try {
+            return InvokerHelper.invokeConstructorOf(clazz, args);
+        } catch (Exception e) {
+            // ignore
+        }
         return asType((Object) col, clazz);
     }
 
diff --git a/src/main/org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformation.java b/src/main/org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformation.java
index 2343bfaeca..7c40af76ed 100644
--- a/src/main/org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformation.java
+++ b/src/main/org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformation.java
@@ -225,7 +225,7 @@ public class DefaultTypeTransformation {
                 if (type.isAssignableFrom(ArrayList.class) && (Modifier.isAbstract(modifiers) || Modifier.isInterface(modifiers))) {
                     answer = new ArrayList();
                 } else {
-                    // lets call the collections constructor
+                    // let's call the collections constructor
                     // passing in the list wrapper
                     try {
                         answer = (Collection) type.newInstance();
@@ -315,29 +315,24 @@ public class DefaultTypeTransformation {
         }
         Object[] args = null;
         if (object instanceof Collection) {
-            if (Set.class.isAssignableFrom(type) || List.class.isAssignableFrom(type)) {
-                args = new Object[1];
-                args [0] = object;
-            } else {
-                Collection coll = (Collection) object;
-                args = coll.toArray();
-            }
+            // let's try invoke the constructor with the list as arguments
+            // such as for creating a Dimension, Point, Color etc.
+            Collection collection = (Collection) object;
+            args = collection.toArray();
         } else if (object instanceof Object[]) {
             args = (Object[]) object;
         } else if (object instanceof Map) {
             // emulate named params constructor
             args = new Object[1];
-            args [0] = object;
+            args[0] = object;
         }
         if (args != null) {
-            // let's try invoke the constructor with the list as arguments
-            // such as for creating a Dimension, Point, Color etc.
             try {
                 return InvokerHelper.invokeConstructorOf(type, args);
             } catch (InvokerInvocationException iie){
                 throw iie;
             } catch (Exception e) {
-                // lets ignore exception and return the original object
+                // let's ignore exception and return the original object
                 // as the caller has more context to be able to throw a more
                 // meaningful exception
             }
