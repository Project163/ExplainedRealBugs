diff --git a/src/main/groovy/lang/Delegate.java b/src/main/groovy/lang/Delegate.java
index 341185816b..c62e29d87e 100644
--- a/src/main/groovy/lang/Delegate.java
+++ b/src/main/groovy/lang/Delegate.java
@@ -101,15 +101,16 @@ import java.lang.annotation.Target;
  * Otherwise these lines produce a groovy.lang.MissingPropertyException
  * or groovy.lang.MissingMethodException respectively as those two methods are
  * {@code @Deprecated} in {@code Date}.
- *
- * Technical notes:
+ * <p>
+ * <b>Technical notes</b>:
  * <ul>
  * <li>Static methods, synthetic methods or methods from the <code>GroovyObject</code> interface
  * are not candidates for delegation
- * <li>Non-abstract methods defined in the owner class or its superclasses take
- * precedence over methods with identical signatures from a {@code @Delegate} field
- * <li>Abstract methods defined in the owner class take
+ * <li>Non-abstract non-static methods defined in the owner class or its superclasses take
  * precedence over methods with identical signatures from a {@code @Delegate} field
+ * <li>All methods defined in the owner class (including static, abstract or private etc.)
+ * take precedence over methods with identical signatures from a {@code @Delegate} field
+ * <li>Recursive delegation to your own class is not allowed
  * </ul>
  *
  * @author Alex Tkachman
diff --git a/src/main/org/codehaus/groovy/transform/DelegateASTTransformation.java b/src/main/org/codehaus/groovy/transform/DelegateASTTransformation.java
index c1c18e2260..3e919145c5 100644
--- a/src/main/org/codehaus/groovy/transform/DelegateASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/DelegateASTTransformation.java
@@ -164,10 +164,11 @@ public class DelegateASTTransformation implements ASTTransformation, Opcodes {
             }
         }
 
-        // give precedence to non-abstract methods of self
+        // give precedence to methods of self (but not abstract or static superclass methods)
+        // also allows abstract or static self methods to be selected for overriding but they are ignored later
         MethodNode existingNode = null;
         for (MethodNode mn : ownMethods) {
-            if (mn.getTypeDescriptor().equals(candidate.getTypeDescriptor()) && !mn.isAbstract()) {
+            if (mn.getTypeDescriptor().equals(candidate.getTypeDescriptor()) && !mn.isAbstract() && !mn.isStatic()) {
                 existingNode = mn;
                 break;
             }
@@ -181,6 +182,7 @@ public class DelegateASTTransformation implements ASTTransformation, Opcodes {
                 newParams[i] = newParam;
                 args.addExpression(new VariableExpression(newParam));
             }
+            // addMethod will ignore attempts to override abstract or static methods with same signature on self
             owner.addMethod(candidate.getName(),
                     candidate.getModifiers() & (~ACC_ABSTRACT) & (~ACC_NATIVE),
                     nonGeneric(candidate.getReturnType()),
diff --git a/src/test/org/codehaus/groovy/transform/DelegateTransformTest.groovy b/src/test/org/codehaus/groovy/transform/DelegateTransformTest.groovy
index a145b68cd7..adf68abed4 100644
--- a/src/test/org/codehaus/groovy/transform/DelegateTransformTest.groovy
+++ b/src/test/org/codehaus/groovy/transform/DelegateTransformTest.groovy
@@ -176,6 +176,22 @@ class DelegateTransformTest extends CompilableTestSupport {
         """
     }
 
+    // GROOVY-4265
+    void testShouldPreferDelegatedOverStaticMethod() {
+        assertScript """
+            class A {
+                 static foo(){"A->foo()"}
+            }
+            class B extends A {
+                 @Delegate C c = new C()
+            }
+            class C {
+                 def foo(){"C->foo()"}
+            }
+            assert new B().foo() == 'C->foo()'
+        """
+    }
+
     void testDelegateToObjectShouldFail() {
         shouldNotCompile """
             class B {
