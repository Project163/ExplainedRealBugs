diff --git a/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java b/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java
index cb4d8b0d73..5c98d8d383 100644
--- a/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java
+++ b/src/main/java/org/apache/groovy/parser/antlr4/AstBuilder.java
@@ -150,6 +150,7 @@ import java.util.stream.Stream;
 import static groovy.lang.Tuple.tuple;
 import static org.apache.groovy.parser.antlr4.GroovyParser.*;
 import static org.apache.groovy.parser.antlr4.util.PositionConfigureUtils.configureAST;
+import static org.apache.groovy.parser.antlr4.util.PositionConfigureUtils.configureEndPosition;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.assignX;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.callX;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.closureX;
@@ -329,60 +330,51 @@ public class AstBuilder extends GroovyParserBaseVisitor<Object> {
 
     @Override
     public ImportNode visitImportDeclaration(final ImportDeclarationContext ctx) {
-        ImportNode importNode;
+        List<AnnotationNode> annotations = this.visitAnnotationsOpt(ctx.annotationsOpt());
 
         boolean hasStatic = asBoolean(ctx.STATIC());
-        boolean hasStar = asBoolean(ctx.MUL());
-        boolean hasAlias = asBoolean(ctx.alias);
+        boolean hasStar   = asBoolean(ctx.MUL());
+        boolean hasAlias  = asBoolean(ctx.alias);
 
-        List<AnnotationNode> annotationNodeList = this.visitAnnotationsOpt(ctx.annotationsOpt());
+        ImportNode importNode;
 
         if (hasStatic) {
             if (hasStar) { // e.g. import static java.lang.Math.*
                 String qualifiedName = this.visitQualifiedName(ctx.qualifiedName());
-                ClassNode type = makeClassNode(qualifiedName);
-                configureAST(type, ctx);
-
-                moduleNode.addStaticStarImport(type.getText(), type, annotationNodeList);
+                ClassNode importType = makeClassNode(qualifiedName);
+                configureAST(importType, ctx.qualifiedName());
 
+                moduleNode.addStaticStarImport(importType.getText(), importType, annotations);
                 importNode = last(moduleNode.getStaticStarImports().values());
             } else { // e.g. import static java.lang.Math.pow
                 List<? extends QualifiedNameElementContext> identifierList = ctx.qualifiedName().qualifiedNameElement();
                 int identifierListSize = identifierList.size();
-                String name = identifierList.get(identifierListSize - 1).getText();
-                ClassNode classNode =
-                        makeClassNode(
-                                identifierList.stream()
-                                        .limit(identifierListSize - 1)
-                                        .map(ParseTree::getText)
-                                        .collect(Collectors.joining(DOT_STR)));
-                String alias = hasAlias
-                        ? ctx.alias.getText()
-                        : name;
-                configureAST(classNode, ctx);
 
-                moduleNode.addStaticImport(classNode, name, alias, annotationNodeList);
+                String qualifiedName = identifierList.stream().limit(identifierListSize - 1).map(ParseTree::getText).collect(Collectors.joining(DOT_STR));
+                ClassNode importType = makeClassNode(qualifiedName);
+                configureAST(importType, ctx.qualifiedName()); // qualifiedName() includes member name
+                configureEndPosition(importType, identifierList.get(Math.max(0, identifierListSize - 2)).getStop());
 
+                String memberName = identifierList.get(identifierListSize - 1).getText();
+                String simpleName = hasAlias ? ctx.alias.getText() : memberName;
+
+                moduleNode.addStaticImport(importType, memberName, simpleName, annotations);
                 importNode = last(moduleNode.getStaticImports().values());
             }
         } else {
             if (hasStar) { // e.g. import java.util.*
                 String qualifiedName = this.visitQualifiedName(ctx.qualifiedName());
-
-                moduleNode.addStarImport(qualifiedName + DOT_STR, annotationNodeList);
-
+                moduleNode.addStarImport(qualifiedName + DOT_STR, annotations);
                 importNode = last(moduleNode.getStarImports());
             } else { // e.g. import java.util.Map
                 String qualifiedName = this.visitQualifiedName(ctx.qualifiedName());
-                String name = last(ctx.qualifiedName().qualifiedNameElement()).getText();
-                ClassNode classNode = makeClassNode(qualifiedName);
-                String alias = hasAlias
-                        ? ctx.alias.getText()
-                        : name;
-                configureAST(classNode, ctx);
+                ClassNode importType = makeClassNode(qualifiedName);
+                configureAST(importType, ctx.qualifiedName());
 
-                moduleNode.addImport(alias, classNode, annotationNodeList);
+                String simpleName = hasAlias ? ctx.alias.getText()
+                                             : last(ctx.qualifiedName().qualifiedNameElement()).getText();
 
+                moduleNode.addImport(simpleName, importType, annotations);
                 importNode = last(moduleNode.getImports());
             }
         }
diff --git a/src/main/java/org/codehaus/groovy/ast/ImportNode.java b/src/main/java/org/codehaus/groovy/ast/ImportNode.java
index 83ede6b8f0..bb07ad096c 100644
--- a/src/main/java/org/codehaus/groovy/ast/ImportNode.java
+++ b/src/main/java/org/codehaus/groovy/ast/ImportNode.java
@@ -97,23 +97,27 @@ public class ImportNode extends AnnotatedNode {
      */
     @Override
     public String getText() {
-        String typeName = getClassName();
-        if (isStar && !isStatic) {
-            return "import " + packageName + "*";
-        }
-        if (isStar) {
-            return "import static " + typeName + ".*";
-        }
-        if (isStatic) {
-            if (alias != null && !alias.isEmpty() && !alias.equals(fieldName)) {
-                return "import static " + typeName + "." + fieldName + " as " + alias;
+        String simpleName = getAlias();
+        String memberName = getFieldName();
+
+        if (!isStatic()) {
+            if (isStar()) {
+                return "import " + getPackageName() + "*";
+            } else if (simpleName == null || simpleName.isEmpty()
+                    || simpleName.equals(getType().getNameWithoutPackage())) {
+                return "import " + getClassName();
+            } else {
+                return "import " + getClassName() + " as " + simpleName;
+            }
+        } else {
+            if (isStar()) {
+                return "import static " + getClassName() + ".*";
+            } else if (simpleName == null || simpleName.isEmpty() || simpleName.equals(memberName)) {
+                return "import static " + getClassName() + "." + memberName;
+            } else {
+                return "import static " + getClassName() + "." + memberName + " as " + simpleName;
             }
-            return "import static " + typeName + "." + fieldName;
-        }
-        if (alias == null || alias.isEmpty()) {
-            return "import " + typeName;
         }
-        return "import " + typeName + " as " + alias;
     }
 
     public boolean isStar() {
diff --git a/src/main/java/org/codehaus/groovy/ast/ModuleNode.java b/src/main/java/org/codehaus/groovy/ast/ModuleNode.java
index 2c96b4735f..abf0f1dcfd 100644
--- a/src/main/java/org/codehaus/groovy/ast/ModuleNode.java
+++ b/src/main/java/org/codehaus/groovy/ast/ModuleNode.java
@@ -29,6 +29,7 @@ import org.codehaus.groovy.ast.stmt.Statement;
 import org.codehaus.groovy.classgen.GeneratorContext;
 import org.codehaus.groovy.control.SourceUnit;
 import org.codehaus.groovy.runtime.InvokerHelper;
+import org.codehaus.groovy.syntax.SyntaxException;
 import org.codehaus.groovy.transform.BaseScriptASTTransformation;
 
 import java.io.File;
@@ -154,12 +155,14 @@ public class ModuleNode extends ASTNode {
         return aliases.get(alias);
     }
 
-    public void addImport(final String alias, final ClassNode type) {
-        addImport(alias, type, Collections.emptyList());
+    public void addImport(final String name, final ClassNode type) {
+        addImport(name, type, Collections.emptyList());
     }
 
-    public void addImport(final String alias, final ClassNode type, final List<AnnotationNode> annotations) {
-        ImportNode importNode = new ImportNode(type, alias);
+    public void addImport(final String name, final ClassNode type, final List<AnnotationNode> annotations) {
+        checkUsage(name, type); // GROOVY-8254
+
+        ImportNode importNode = new ImportNode(type, name);
         importNode.addAnnotations(annotations);
         imports.add(importNode);
 
@@ -179,17 +182,23 @@ public class ModuleNode extends ASTNode {
         storeLastAddedImportNode(importNode);
     }
 
-    public void addStaticImport(final ClassNode type, final String fieldName, final String alias) {
-        addStaticImport(type, fieldName, alias, Collections.emptyList());
+    public void addStaticImport(final ClassNode type, final String memberName, final String simpleName) {
+        addStaticImport(type, memberName, simpleName, Collections.emptyList());
     }
 
-    public void addStaticImport(final ClassNode type, final String fieldName, final String alias, final List<AnnotationNode> annotations) {
-        ImportNode node = new ImportNode(type, fieldName, alias);
+    public void addStaticImport(final ClassNode type, final String memberName, final String simpleName, final List<AnnotationNode> annotations) {
+        ClassNode memberType = new ClassNode(type.getName() + '.' + memberName, 0, null) {
+            @Override public ClassNode getOuterClass() { return type; }
+        };
+        memberType.setSourcePosition(type);
+        checkUsage(simpleName, memberType);
+
+        ImportNode node = new ImportNode(type, memberName, simpleName);
         node.addAnnotations(annotations);
-        ImportNode prev = staticImports.put(alias, node);
+        ImportNode prev = staticImports.put(simpleName, node);
         if (prev != null) {
             staticImports.put(prev.toString(), prev);
-            staticImports.put(alias, staticImports.remove(alias));
+            staticImports.put(simpleName, staticImports.remove(simpleName));
         }
 
         storeLastAddedImportNode(node);
@@ -217,6 +226,7 @@ public class ModuleNode extends ASTNode {
         classes.add(node);
         node.setModule(this);
         addToCompileUnit(node);
+        checkUsage(node.getNameWithoutPackage(), node);
     }
 
     private void addToCompileUnit(final ClassNode node) {
@@ -226,6 +236,29 @@ public class ModuleNode extends ASTNode {
         }
     }
 
+    private void checkUsage(final String name, final ClassNode type) {
+        for (ClassNode node : classes) {
+            if (node.getNameWithoutPackage().equals(name) && !node.equals(type)) {
+                getContext().addErrorAndContinue(new SyntaxException("The name " + name + " is already declared", type));
+                return;
+            }
+        }
+
+        for (ImportNode node : imports) {
+            if (node.getAlias().equals(name) && !node.getType().equals(type)) {
+                getContext().addErrorAndContinue(new SyntaxException("The name " + name + " is already declared", type));
+                return;
+            }
+        }
+
+        {
+            ImportNode node = staticImports.get(name);
+            if (node != null && !node.getType().equals(type.getOuterClass())) {
+                getContext().addErrorAndContinue(new SyntaxException("The name " + name + " is already declared", type));
+            }
+        }
+    }
+
     public void addMethod(final MethodNode node) {
         methods.add(node);
     }
diff --git a/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java b/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
index 2bc618d443..1a42e3701b 100644
--- a/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
+++ b/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
@@ -681,30 +681,13 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
 
         String name = type.getName();
         boolean type_setName = false;
-        if (!type.hasPackageName()) {
-            if (testModuleImports) { // GROOVY-8254
-                ImportNode importNode = module.getImport(name);
-                if (importNode != null && importNode != currentImport && !importNode.getAlias().equals(importNode.getType().getNameWithoutPackage())) {
-                    type.setRedirect(importNode.getType());
-                    return true;
-                }
-                importNode = module.getStaticImports().get(name);
-                if (importNode != null && importNode != currentImport && !importNode.getAlias().equals(importNode.getFieldName())) {
-                    ClassNode tmp = new ConstructedNestedClass(importNode.getType(), importNode.getFieldName());
-                    if (resolve(tmp, false, false, true) && Modifier.isStatic(tmp.getModifiers())) {
-                        type.setRedirect(tmp.redirect());
-                        return true;
-                    }
-                }
-            }
-            // We add a package if there is none yet and the module has one. But we
-            // do not add that if the type is a ConstructedClassWithPackage. The code in ConstructedClassWithPackage
-            // hasPackageName() will return true if ConstructedClassWithPackage#className has no dots.
-            // but since the prefix may have them and the code there does ignore that fact.
-            if (module.hasPackageName() && !(type instanceof ConstructedClassWithPackage)) {
-                type.setName(module.getPackageName() + name);
-                type_setName = true;
-            }
+        // We add a package if there is none yet and the module has one. But we
+        // do not add that if the type is a ConstructedClassWithPackage. The code in ConstructedClassWithPackage
+        // hasPackageName() will return true if ConstructedClassWithPackage#className has no dots.
+        // but since the prefix may have them and the code there does ignore that fact.
+        if (!type.hasPackageName() && module.hasPackageName() && !(type instanceof ConstructedClassWithPackage)) {
+            type.setName(module.getPackageName() + name);
+            type_setName = true;
         }
         // check the module node for a class with the name
         for (ClassNode localClass : module.getClasses()) {
diff --git a/src/spec/doc/core-program-structure.adoc b/src/spec/doc/core-program-structure.adoc
index a4d9c766fd..d89d5143bf 100644
--- a/src/spec/doc/core-program-structure.adoc
+++ b/src/spec/doc/core-program-structure.adoc
@@ -82,7 +82,7 @@ This is done because the classes from these packages are most commonly used. By
 
 === Simple import
 
-A simple import is an import statement where you fully define the class name along with the package. For example the import statement ++import groovy.xml.MarkupBuilder++ in the code below is a simple import which directly refers to a class inside a package.
+A simple import is an import statement where you fully define the class name along with the package. For example the import statement `import groovy.xml.MarkupBuilder` in the code below is a simple import which directly refers to a class inside a package.
 
 [source,groovy]
 ----
@@ -91,7 +91,7 @@ include::../test/PackageTest.groovy[tags=import_statement,indent=0]
 
 === Star import
 
-Groovy, like Java, provides a special way to import all classes from a package using `*`, the so-called star import. `MarkupBuilder` is a class which is in package `groovy.xml`, alongside another class called `StreamingMarkupBuilder`. In case you need to use both classes, you can do:
+Groovy, like Java, provides a special way to import all classes from a package using `*`, the so-called on-demand or star import. `MarkupBuilder` is a class which is in package `groovy.xml`, alongside another class called `StreamingMarkupBuilder`. In case you need to use both classes, you can do:
 
 [source,groovy]
 ----
@@ -124,9 +124,9 @@ include::../test/PackageTest.groovy[tags=static_import_same_method_name_differen
 ----
 <1> static import of method
 <2> declaration of method with same name as method statically imported above, but with a different parameter type
-<3> compile error in java, but is valid groovy code
+<3> compile error in Java, but is valid Groovy code
 
-If you have the same types, the imported class takes precedence.
+If you have the same signature, the imported method takes precedence.
 
 === Static import aliasing
 
@@ -141,10 +141,9 @@ Now, that's clean!
 
 === Static star import
 
-A static star import is very similar to the regular star import. It will import all the static methods from the given class.
+A static star import is very similar to the regular star import. It will import all the static members from the given class.
 
-For example, lets say we need to calculate sines and cosines for our application.
-The class `java.lang.Math` has static methods named `sin` and `cos` which fit our need. With the help of a static star import, we can do:
+For example, let's say we need to calculate sines and cosines for our application. The class `java.lang.Math` has static methods named `sin` and `cos` which fit our need. With the help of a static star import, we can do:
 
 [source,groovy]
 ----
@@ -164,6 +163,34 @@ For example we can import `java.sql.Date` as `SQLDate` and use it in the same fi
 include::../test/PackageTest.groovy[tags=alias_import,indent=0]
 ----
 
+=== Namespace conflicts
+
+Similar to Java, it is an error in Groovy to specify multiple imports with the same name but different types:
+
+[source,groovy]
+----
+import java.awt.List
+import java.util.List // error: name already declared
+----
+
+And to declare an import and a top-level type with the same name:
+
+[source,groovy]
+----
+import java.util.List
+class List { } // error: name already declared
+----
+
+However, inner types can shadow names from the unit scope:
+
+[source,groovy]
+----
+import java.util.List
+class Main {
+    class List { } // allowed; "List" refers to this type within `Main`'s scope and `java.util.List` elsewhere
+}
+----
+
 == Scripts versus classes
 
 Groovy supports both scripts and classes. From Groovy 5,
diff --git a/src/spec/test/PackageTest.groovy b/src/spec/test/PackageTest.groovy
index 97ceb2816e..55c22a907d 100644
--- a/src/spec/test/PackageTest.groovy
+++ b/src/spec/test/PackageTest.groovy
@@ -1,5 +1,3 @@
-import groovy.test.GroovyTestCase
-
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one
  *  or more contributor license agreements.  See the NOTICE file
@@ -18,8 +16,14 @@ import groovy.test.GroovyTestCase
  *  specific language governing permissions and limitations
  *  under the License.
  */
-class PackageTest extends GroovyTestCase {
 
+import org.junit.Test
+
+import static groovy.test.GroovyAssert.assertScript
+
+final class PackageTest {
+
+    @Test
     void testPackages() {
         assertScript '''
             // tag::package_statement[]
@@ -27,11 +31,8 @@ class PackageTest extends GroovyTestCase {
             package com.yoursite
             // end::package_statement[]
 
-            class Foo {
-
-            }
-
-            def foo = new Foo()        
+            class Foo { }
+            def foo = new Foo()
 
             assert foo != null
             assert Foo.class.name == 'com.yoursite.Foo'
@@ -50,6 +51,7 @@ class PackageTest extends GroovyTestCase {
         '''
     }
 
+    @Test
     void testDefaultImports() {
         assertScript '''
             // tag::default_import[]
@@ -58,6 +60,7 @@ class PackageTest extends GroovyTestCase {
         '''
     }
 
+    @Test
     void testMultipleImportsFromSamePackage() {
         assertScript '''
             // tag::multiple_import[]
@@ -68,11 +71,12 @@ class PackageTest extends GroovyTestCase {
 
             assert markupBuilder != null
 
-            assert new StreamingMarkupBuilder() != null 
+            assert new StreamingMarkupBuilder() != null
             // end::multiple_import[]
         '''
     }
 
+    @Test
     void testStarImports() {
         assertScript '''
             // tag::star_import[]
@@ -83,49 +87,45 @@ class PackageTest extends GroovyTestCase {
             assert markupBuilder != null
 
             assert new StreamingMarkupBuilder() != null
-
             // end::star_import[]
         '''
     }
 
+    @Test
     void testStaticImports() {
         assertScript '''
             // tag::static_imports[]
-
-            import static Boolean.FALSE
+            import static java.lang.Boolean.FALSE
 
             assert !FALSE //use directly, without Boolean prefix!
-
             // end::static_imports[]
-
         '''
     }
 
-    void testStaticImportWithAs() {
+    @Test
+    void testStaticImportAlias() {
         assertScript '''
             // tag::static_importswithas[]
-
             import static Calendar.getInstance as now
 
             assert now().class == Calendar.getInstance().class
-
             // end::static_importswithas[]
         '''
     }
 
+    @Test
     void testStaticStarImport() {
         assertScript '''
             // tag::static_importswithstar[]
-
             import static java.lang.Math.*
 
             assert sin(0) == 0.0
             assert cos(0) == 1.0
-
             // end::static_importswithstar[]
         '''
     }
 
+    @Test
     void testStaticStarImportSameMethodNameDifferentParameterType() {
         assertScript '''
             // tag::static_import_same_method_name_different_parameter_type[]
@@ -146,6 +146,7 @@ class PackageTest extends GroovyTestCase {
         '''
     }
 
+    @Test
     void testAliasImport() {
         assertScript '''
             // tag::alias_import[]
diff --git a/src/test/gls/innerClass/InnerClassTest.groovy b/src/test/gls/innerClass/InnerClassTest.groovy
index 7e4e68fd83..96d14f67f5 100644
--- a/src/test/gls/innerClass/InnerClassTest.groovy
+++ b/src/test/gls/innerClass/InnerClassTest.groovy
@@ -49,7 +49,6 @@ final class InnerClassTest {
     void testAliasAIC() {
         assertScript '''import Foo as Bar
             class Foo {}
-            class Bar {}
 
             def regular = new Bar()
             def anonymous = new Bar() {}
@@ -58,7 +57,6 @@ final class InnerClassTest {
         '''
 
         assertScript '''import static Baz.Foo as Bar
-            class Bar {}
             class Baz {
                 static class Foo {}
             }
diff --git a/src/test/groovy/ImportTest.groovy b/src/test/groovy/ImportTest.groovy
index ab3750a792..4fd24eca3b 100644
--- a/src/test/groovy/ImportTest.groovy
+++ b/src/test/groovy/ImportTest.groovy
@@ -21,19 +21,17 @@ package groovy
 import org.junit.Test
 
 import static groovy.test.GroovyAssert.assertScript
+import static groovy.test.GroovyAssert.shouldFail
 
 final class ImportTest {
 
     @Test
-    void testImportAll() {
+    void testImportDefaults() {
         assertScript '''
-            def file = new File('foo')
+            Object file = new File('x')
             assert file instanceof File
         '''
-    }
 
-    @Test
-    void testImportByName() {
         assertScript '''
             def map = [foo:'bar']
             assert map instanceof Map
@@ -43,8 +41,106 @@ final class ImportTest {
             def list = [1, 2, 3]
             assert list instanceof List
         '''
+
+        assertScript '''
+            def decimal = new BigDecimal(0)
+            def integer = new BigInteger(0)
+        '''
+    }
+
+    // GROOVY-8254
+    @Test
+    void testImportConflicts() {
+        assertScript '''
+            import java.util.List
+            import java.util.List
+        '''
+
+        assertScript '''
+            import java.util.List
+            import java.util.List as List
+        '''
+
+        assertScript '''
+            import java.util.List
+            import java.util.List as MyList
+        '''
+
+        assertScript '''
+            import java.util.Map.Entry
+            import static java.util.Map.Entry
+            import static java.util.Map.Entry as Entry
+        '''
+
+        assertScript '''
+            import java.util.Map.Entry
+            class Main {
+                static class Entry { }
+                static main(array) { }
+            }
+        '''
+
+        assertScript '''package p
+            import p.Main // okay
+            class Main {
+                static main(array) { }
+            }
+        '''
+
+        def err = shouldFail '''
+            import java.net.Proxy
+            import groovy.util.Proxy
+        '''
+        assert err.message =~ /The name Proxy is already declared/
+
+        GroovyShell shell = GroovyShell.withConfig {
+            imports { normal 'java.net.Proxy' }
+        }
+        err = shouldFail shell, '''
+            import groovy.util.Proxy
+        '''
+        assert err.message =~ /The name Proxy is already declared/
+
+        err = shouldFail '''
+            import java.lang.Object as Foo
+            import java.lang.Number as Foo
+        '''
+        assert err.message =~ /The name Foo is already declared/
+
+        err = shouldFail '''
+            import java.util.Map.Entry
+            import java.lang.Object as Entry
+        '''
+        assert err.message =~ /The name Entry is already declared/
+
+        err = shouldFail '''
+            import java.lang.Object as Entry
+            import static java.util.Map.Entry
+        '''
+        assert err.message =~ /The name Entry is already declared/
+
+        err = shouldFail '''
+            import java.util.Map.Entry
+            class Entry { }
+        '''
+        assert err.message =~ /The name Entry is already declared/
+
+        err = shouldFail '''
+            import java.util.Map.Entry as Pair
+            class Pair { }
+        '''
+        assert err.message =~ /The name Pair is already declared/
+
+        shell = GroovyShell.withConfig {
+            imports { normal 'java.util.Map.Entry' }
+        }
+        err = shouldFail shell, '''
+            class Entry { }
+        '''
+        assert err.message =~ /The name Entry is already declared/
     }
 
+    // GROOVY-5103
     @Test
     void testImportStaticInnerClass() {
         assertScript '''
@@ -52,10 +148,19 @@ final class ImportTest {
             Entry entry = [foo:'bar'].entrySet().first()
         '''
 
-        // GROOVY-5103
+        assertScript '''
+            import static java.util.Map.Entry
+            Entry entry = [foo:'bar'].entrySet().first()
+        '''
+
         assertScript '''
             import java.util.Map.*
             Entry entry = [foo:'bar'].entrySet().first()
         '''
+
+        assertScript '''
+            import static java.util.Map.*
+            Entry entry = [foo:'bar'].entrySet().first()
+        '''
     }
 }
diff --git a/src/test/org/codehaus/groovy/ast/LineColumnCheck.txt b/src/test/org/codehaus/groovy/ast/LineColumnCheck.txt
index 4bc8d6f7f7..aa70b0ff25 100644
--- a/src/test/org/codehaus/groovy/ast/LineColumnCheck.txt
+++ b/src/test/org/codehaus/groovy/ast/LineColumnCheck.txt
@@ -223,19 +223,23 @@ class BaseClass implements IBase1, IBase2, IBase3 {}
 
 ###importStatement:::
 import java.io.File
-:::[ClassNode,(1:1),(1:20)]
+:::[ClassNode,(1:8),(1:20)]
 
 ###importStatementAliased:::
 import java.util.ArrayList as MyList
-:::[ClassNode,(1:1),(1:37)]
+:::[ClassNode,(1:8),(1:27)]
 
 ###staticImportStatementStar:::
 import static java.lang.Math.*
-:::[ClassNode,(1:1),(1:31)]
+:::[ClassNode,(1:15),(1:29)]
 
-###staticImportStatementAliases:::
+###staticImportStatementName:::
 import static java.lang.Math.cos
-:::[ClassNode,(1:1),(1:33)]
+:::[ClassNode,(1:15),(1:29)]
+
+###staticImportStatementAliased:::
+import static java.lang.Math.cos as cosine
+:::[ClassNode,(1:15),(1:29)]
 
 ###castExpressionClassNode:::
 String s = (String)i
diff --git a/src/test/org/codehaus/groovy/control/customizers/ImportCustomizerTest.groovy b/src/test/org/codehaus/groovy/control/customizers/ImportCustomizerTest.groovy
index 4f61d2ba36..1f224bd4ec 100644
--- a/src/test/org/codehaus/groovy/control/customizers/ImportCustomizerTest.groovy
+++ b/src/test/org/codehaus/groovy/control/customizers/ImportCustomizerTest.groovy
@@ -125,14 +125,15 @@ final class ImportCustomizerTest {
         scriptEngine.run(script.name, new Binding())
     }
 
-    @Test // GROOVY-8399
+    // GROOVY-8399
+    @Test
     void testAddImportsOnModuleWithMultipleClasses() {
         importCustomizer.addImports('java.text.SimpleDateFormat')
         def shell = new GroovyShell(configuration)
         shell.evaluate('''\
             @groovy.transform.ASTTest(phase=SEMANTIC_ANALYSIS, value={
                 def imports = node.module.imports*.text
-                assert imports == ['import java.text.SimpleDateFormat as SimpleDateFormat']
+                assert imports == ['import java.text.SimpleDateFormat']
             })
             class A {
                 static class AA {
@@ -150,7 +151,8 @@ final class ImportCustomizerTest {
         ''')
     }
 
-    @Test // GROOVY-8399
+    // GROOVY-8399
+    @Test
     void testAddStarImportsOnModuleWithMultipleClasses() {
         importCustomizer.addStarImports('java.text', 'groovy.transform')
         def shell = new GroovyShell(configuration)
@@ -175,5 +177,7 @@ final class ImportCustomizerTest {
         ''')
     }
 
+    //--------------------------------------------------------------------------
+
     protected static class Inner {}
 }
diff --git a/subprojects/groovy-console/src/test/groovy/groovy/console/ui/AstNodeToScriptAdapterTest.groovy b/subprojects/groovy-console/src/test/groovy/groovy/console/ui/AstNodeToScriptAdapterTest.groovy
index 4f25cd436f..b499ea4f83 100644
--- a/subprojects/groovy-console/src/test/groovy/groovy/console/ui/AstNodeToScriptAdapterTest.groovy
+++ b/subprojects/groovy-console/src/test/groovy/groovy/console/ui/AstNodeToScriptAdapterTest.groovy
@@ -563,7 +563,7 @@ final class AstNodeToScriptAdapterTest extends GroovyTestCase {
         assert result.contains('import java.lang.Double as BadaBing')
         assert result.contains('@java.lang.SuppressWarnings')
         assert result.contains("@java.lang.SuppressWarnings(value = 'some parameter')")
-        assert result.contains('import java.lang.String as String')
+        assert result.contains('import java.lang.String')
         assert result.contains('@java.lang.SuppressWarnings')
         assert result.contains('import java.util.concurrent.*')
     }
