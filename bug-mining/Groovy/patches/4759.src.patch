diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index c59193d500..ee48bfc698 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -5437,16 +5437,20 @@ out:                if (mn.size() != 1) {
                             } else { // argument instanceof MethodPointerExpression
                                 List<MethodNode> candidates = argument.getNodeMetaData(MethodNode.class);
                                 if (candidates != null && !candidates.isEmpty()) {
-                                    var methodPointer = (MethodPointerExpression) argument;
-                                    p = methodPointer.getNodeMetaData(CLOSURE_ARGUMENTS); // GROOVY-10975
-                                    if (p == null) p = collateMethodReferenceParameterTypes(methodPointer, candidates.get(0));
+                                    MethodPointerExpression methodPointer = (MethodPointerExpression) argument;
+                                    p = collateMethodReferenceParameterTypes(methodPointer, candidates.get(0));
                                     if (p.length > 0 && GenericsUtils.hasUnresolvedGenerics(returnType)) {
+                                        // GROOVY-11241: implicit receiver for "Optional::get" is resolved
+                                        if (!candidates.get(0).isStatic() && isClassClassNodeWrappingConcreteType(getType(methodPointer.getExpression()))) {
+                                            extractGenericsConnections(connections, q[0], p[0].redirect());
+                                        }
                                         for (int j = 0; j < q.length; j += 1) {
                                             // SAM parameters are like arguments in this case
                                             extractGenericsConnections(connections, q[j], p[j]);
                                         }
                                         // convert the method's generics into the SAM's generics
                                         returnType = applyGenericsContext(connections, returnType);
+                                        p          = applyGenericsContext(connections, p         );
 
                                         connections.clear();
                                     }
@@ -5597,6 +5601,16 @@ out:                if (mn.size() != 1) {
             System.arraycopy(target.getParameters(), 0, params, 1, n);
         } else {
             params = target.getParameters();
+            // GROOVY-10974, GROOVY-10975: propagate type args
+            if (!target.isStatic() && target.getDeclaringClass().getGenericsTypes() != null) {
+                ClassNode objectExprType = source.getExpression().getNodeMetaData(INFERRED_TYPE);
+                if (objectExprType == null && source.getExpression() instanceof VariableExpression) {
+                    Variable variable = ((VariableExpression) source.getExpression()).getAccessedVariable();
+                    if (variable instanceof ASTNode) objectExprType = ((ASTNode) variable).getNodeMetaData(INFERRED_TYPE);
+                }
+                Map<GenericsTypeName,GenericsType> spec = extractPlaceHolders(objectExprType, target.getDeclaringClass());
+                return applyGenericsContext(spec, extractTypesFromParameters(params));
+            }
         }
 
         return extractTypesFromParameters(params);
diff --git a/src/test/groovy/transform/stc/MethodReferenceTest.groovy b/src/test/groovy/transform/stc/MethodReferenceTest.groovy
index 8b20680dd6..7d05bd3ed9 100644
--- a/src/test/groovy/transform/stc/MethodReferenceTest.groovy
+++ b/src/test/groovy/transform/stc/MethodReferenceTest.groovy
@@ -34,7 +34,7 @@ final class MethodReferenceTest {
     }
 
     @Test // class::instanceMethod
-    void testFunctionCI() {
+    void testFunctionCI1() {
         assertScript shell, '''
             @CompileStatic
             void test() {
@@ -232,28 +232,115 @@ final class MethodReferenceTest {
         '''
     }
 
-    @Test // class::instanceMethod -- GROOVY-11241
+    @Test // class::instanceMethod -- GROOVY-9803
     void testFunctionCI9() {
+        assertScript shell, '''
+            class Try<X> { X x
+                static <Y> Try<Y> success(Y y) {
+                    new Try<Y>(x: y)
+                }
+                def <Z> Try<Z> map(Function<? super X, ? extends Z> f) {
+                    new Try<Z>(x: f.apply(x))
+                }
+            }
+
+            static <E> Set<E> asSet(E element) {
+                Collections.singleton(element)
+            }
+
+            @CompileStatic
+            Try<String> test() {
+                def try_of_str = Try.success('WORKS')
+                def try_of_opt = try_of_str.map(this::asSet)
+                    try_of_str = try_of_opt.map{it.first().toLowerCase()}
+            }
+
+            assert test().x == 'works'
+        '''
+    }
+
+    @Test // class::instanceMethod -- GROOVY-11241
+    void testFunctionCI10() {
         assertScript shell, '''
             @Grab('io.vavr:vavr:0.10.4')
             import io.vavr.control.*
 
-            Option<Integer> option() { Option.of(3) }
+            Option<Integer> option() { Option.of(42) }
+
+            @CompileStatic
+            Try<Integer> test() {
+                Try.of{ option() }.<Integer>mapTry(Option::get)
+                //                 ^^^^^^^^^
+            }
+
+            assert test().get() == 42
+        '''
+
+        assertScript shell, '''
+            class Try<X> { X x
+                static <Y> Try<Y> of(Supplier<? extends Y> s) {
+                    new Try<Y>(x: s.get())
+                }
+                def <Z> Try<Z> mapTry(Function<? super X, ? extends Z> f) {
+                    new Try<Z>(x: f.apply(x))
+                }
+            }
+
+            @CompileStatic
+            Try<String> test() {
+                def try_of = Try.of{Optional.of('works')}
+                def result = try_of.mapTry(Optional.&get) // Function<T,_> and Optional<T>
+                return result
+            }
+
+            assert test().x == 'works'
+        '''
+
+        assertScript shell, '''
+            @Grab('io.vavr:vavr:0.10.4')
+            import io.vavr.control.Try
+
+            class Option<X> {
+                private X x
+                def X get() { x }
+                static <Y> Option<Y> of(Y y) {
+                    new Option(x: y)
+                }
+            }
+
+            Option<Integer> option() { Option.of(42) }
 
             @CompileStatic
             Try<Integer> test() {
-              //Try.of { option() }.mapTry(Option::get)
                 def try_of = Try.of { option() }
                 def result = try_of.mapTry(Option::get)
-                result
+                result // cannot assign Try<Object> to: Try<Integer>
             }
 
-            test()
+            assert test().get() == 42
+        '''
+    }
+
+    @Test // class::instanceMethod -- GROOVY-11259
+    void testFunctionCI11() {
+        assertScript shell, '''
+            def consume(Set<String> keys){keys}
+            @CompileStatic
+            def test(Map<String, String> map) {
+                def keys = map.entrySet().stream()
+                    .map(Map.Entry::getKey).toSet()
+                consume(keys) // cannot call consume(Set<String>) with arguments [Set<Object>]
+            }
+
+            def set = test(foo:'bar', fizz:'buzz')
+            assert set.size() == 2
+            assert 'fizz' in set
+            assert 'foo' in set
         '''
     }
 
     @Test // class::instanceMethod -- GROOVY-9974
-    void testPredicateCI() {
+    void testPredicateCI1() {
         assertScript shell, '''
             @CompileStatic
             void test(List<String> strings = ['']) {
