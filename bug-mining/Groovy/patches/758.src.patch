diff --git a/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java b/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java
index b252fa993c..a7611e9df5 100644
--- a/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java
+++ b/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java
@@ -743,7 +743,7 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
             // in the case that there is already a field, we would
             // like to use that field, instead of the default field
             // for the property
-            FieldNode storedNode = classNode.getField(fieldNode.getName());
+            FieldNode storedNode = classNode.getDeclaredField(fieldNode.getName());
             if (storedNode!=null && !classNode.hasProperty(name)) {
             	fieldNode = storedNode;
             	// we remove it here, because addProperty will add it
diff --git a/src/main/org/codehaus/groovy/ast/ClassNode.java b/src/main/org/codehaus/groovy/ast/ClassNode.java
index 8e2b848e17..86e382b44d 100644
--- a/src/main/org/codehaus/groovy/ast/ClassNode.java
+++ b/src/main/org/codehaus/groovy/ast/ClassNode.java
@@ -392,8 +392,8 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
         } while (parent!=null && ((parent.getModifiers() & Opcodes.ACC_ABSTRACT) != 0));
 
         List result = new ArrayList();
-        for (Iterator methIt = getAllDeclaredMethods().iterator(); methIt.hasNext();) {
-            MethodNode method = (MethodNode) methIt.next();
+        for (Object o : getAllDeclaredMethods()) {
+            MethodNode method = (MethodNode) o;
             // add only abstract methods from abtract classes that
             // are not overwritten
             if ( abstractNodes.contains(method.getDeclaringClass().redirect()) &&
@@ -431,8 +431,8 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
         for (int i = 0; i < interfaces.length; i++) {
             ClassNode iface = interfaces[i];
             Map ifaceMethodsMap = iface.getDeclaredMethodsMap();
-            for (Iterator iter = ifaceMethodsMap.keySet().iterator(); iter.hasNext();) {
-                String methSig = (String) iter.next();
+            for (Object o : ifaceMethodsMap.keySet()) {
+                String methSig = (String) o;
                 if (!result.containsKey(methSig)) {
                     MethodNode methNode = (MethodNode) ifaceMethodsMap.get(methSig);
                     result.put(methSig, methNode);
@@ -441,8 +441,8 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
         }
 
         // And add in the methods implemented in this class.
-        for (Iterator iter = getMethods().iterator(); iter.hasNext();) {
-            MethodNode method = (MethodNode) iter.next();
+        for (Object o : getMethods()) {
+            MethodNode method = (MethodNode) o;
             String sig = method.getTypeDescriptor();
             result.put(sig, method);
         }
@@ -494,7 +494,6 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
         node.setDeclaringClass(redirect());
         FieldNode field = node.getField();
         addField(field);
-
         redirect().properties.add(node);
     }
 
@@ -504,17 +503,17 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
                                     Expression initialValueExpression,
                                     Statement getterBlock,
                                     Statement setterBlock) {
-    	for (Iterator iter = getProperties().iterator(); iter.hasNext();) {
-            PropertyNode pn = (PropertyNode) iter.next();
+        for (Object o : getProperties()) {
+            PropertyNode pn = (PropertyNode) o;
             if (pn.getName().equals(name)) {
                 if (pn.getInitialExpression() == null && initialValueExpression != null)
-                  pn.getField().setInitialValueExpression(initialValueExpression);
+                    pn.getField().setInitialValueExpression(initialValueExpression);
 
                 if (pn.getGetterBlock() == null && getterBlock != null)
-                  pn.setGetterBlock(getterBlock);
+                    pn.setGetterBlock(getterBlock);
 
                 if (pn.getSetterBlock() == null && setterBlock != null)
-                  pn.setSetterBlock(setterBlock);
+                    pn.setSetterBlock(setterBlock);
 
                 return pn;
             }
@@ -530,8 +529,8 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
     }
     
     public PropertyNode getProperty(String name) {
-    	for (Iterator iter = getProperties().iterator(); iter.hasNext();) {
-            PropertyNode pn = (PropertyNode) iter.next();
+    	for (Object o : getProperties()) {
+            PropertyNode pn = (PropertyNode) o;
             if (pn.getName().equals(name)) return pn;
         }
         return null;   	
@@ -653,10 +652,32 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
         }
     }
 
-    public FieldNode getField(String name) {
+    /**
+     * Finds a field matching the given name in this class.
+     *
+     * @param name the name of the field of interest
+     * @return the method matching the given name and parameters or null
+     */
+    public FieldNode getDeclaredField(String name) {
         return (FieldNode) redirect().fieldIndex.get(name);
     }
 
+    /**
+     * Finds a field matching the given name in this class or a parent class.
+     *
+     * @param name the name of the field of interest
+     * @return the method matching the given name and parameters or null
+     */
+    public FieldNode getField(String name) {
+        ClassNode node = this;
+        while (node != null) {
+            FieldNode fn = node.getDeclaredField(name);
+            if (fn != null) return fn;
+            node = node.getSuperClass();
+        }
+        return null;
+    }
+
     /**
      * @return the field node on the outer class or null if this is not an
      *         inner class
@@ -737,9 +758,12 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
      * @see #getDeclaredMethods(String)
      */
     public List getMethods(String name) {
-        List answer = new ArrayList(getDeclaredMethods(name));
-        ClassNode parent = getSuperClass();
-        if (parent!=null) answer.addAll(parent.getMethods(name));
+        List answer = new ArrayList();
+        ClassNode node = this;
+        while (node != null) {
+            answer.addAll(node.getDeclaredMethods(name));
+            node = node.getSuperClass();
+        }
         return answer;
     }
 
@@ -749,9 +773,8 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
      * @return the method matching the given name and parameters or null
      */
     public MethodNode getDeclaredMethod(String name, Parameter[] parameters) {
-        List list = getDeclaredMethods(name);
-        for (Iterator iter = list.iterator(); iter.hasNext();) {
-            MethodNode method = (MethodNode) iter.next();
+        for (Object o :  getDeclaredMethods(name)) {
+            MethodNode method = (MethodNode) o;
             if (parametersEqual(method.getParameters(), parameters)) {
                 return method;
             }
@@ -766,9 +789,8 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
      * @return the method matching the given name and parameters or null
      */
     public MethodNode getMethod(String name, Parameter[] parameters) {
-        List list = getMethods(name);
-        for (Iterator iter = list.iterator(); iter.hasNext();) {
-            MethodNode method = (MethodNode) iter.next();
+        for (Object o : getMethods(name)) {
+            MethodNode method = (MethodNode) o;
             if (parametersEqual(method.getParameters(), parameters)) {
                 return method;
             }
@@ -925,32 +947,31 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
     }
 
     public void visitContents(GroovyClassVisitor visitor) {
-
-        // now lets visit the contents of the class
-        for (Iterator iter = getProperties().iterator(); iter.hasNext();) {
-            PropertyNode pn = (PropertyNode) iter.next();
+        // now let's visit the contents of the class
+        for (Object o : getProperties()) {
+            PropertyNode pn = (PropertyNode) o;
             visitor.visitProperty(pn);
         }
 
-        for (Iterator iter = getFields().iterator(); iter.hasNext();) {
-            FieldNode fn = (FieldNode) iter.next();
+        for (Object o : getFields()) {
+            FieldNode fn = (FieldNode) o;
             visitor.visitField(fn);
         }
 
-        for (Iterator iter = getDeclaredConstructors().iterator(); iter.hasNext();) {
-            ConstructorNode cn = (ConstructorNode) iter.next();
+        for (Object o : getDeclaredConstructors()) {
+            ConstructorNode cn = (ConstructorNode) o;
             visitor.visitConstructor(cn);
         }
 
-        for (Iterator iter = getMethods().iterator(); iter.hasNext();) {
-            MethodNode mn = (MethodNode) iter.next();
+        for (Object o : getMethods()) {
+            MethodNode mn = (MethodNode) o;
             visitor.visitMethod(mn);
         }
     }
 
     public MethodNode getGetterMethod(String getterName) {
-        for (Iterator iter = getDeclaredMethods(getterName).iterator(); iter.hasNext();) {
-            MethodNode method = (MethodNode) iter.next();
+        for (Object o : getDeclaredMethods(getterName)) {
+            MethodNode method = (MethodNode) o;
             if (getterName.equals(method.getName())
                     && ClassHelper.VOID_TYPE!=method.getReturnType()
                     && method.getParameters().length == 0) {
@@ -963,8 +984,8 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
     }
 
     public MethodNode getSetterMethod(String setterName) {
-        for (Iterator iter = getDeclaredMethods(setterName).iterator(); iter.hasNext();) {
-            MethodNode method = (MethodNode) iter.next();
+        for (Object o : getDeclaredMethods(setterName)) {
+            MethodNode method = (MethodNode) o;
             if (setterName.equals(method.getName())
                     && ClassHelper.VOID_TYPE==method.getReturnType()
                     && method.getParameters().length == 1) {
@@ -1008,22 +1029,26 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
 
     public String toString() {
         String ret = getName();
-        if (genericsTypes!=null) {
+        if (genericsTypes != null) {
             ret += " <";
             for (int i = 0; i < genericsTypes.length; i++) {
-                if (i!=0) ret+=", ";
+                if (i != 0) ret += ", ";
                 ret += genericsTypes[i];
             }
             ret += ">";
         }
-        if (redirect!=null) {
-            ret += " -> "+redirect().toString();
+        if (redirect != null) {
+            ret += " -> " + redirect().toString();
         }
         return ret;
     }
 
     /**
-     * Returns true if the given method has a possibly matching method with the given name and arguments
+     * Returns true if the given method has a possibly matching instance method with the given name and arguments.
+     *
+     * @param name      the name of the method of interest
+     * @param arguments the arguments to match against
+     * @return true if a matching method was found
      */
     public boolean hasPossibleMethod(String name, Expression arguments) {
         int count = 0;
@@ -1035,8 +1060,8 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
         }
         ClassNode node = this;
         do {
-            for (Iterator iter = getDeclaredMethods(name).iterator(); iter.hasNext();) {
-                MethodNode method = (MethodNode) iter.next();
+            for (Object o : getMethods(name)) {
+                MethodNode method = (MethodNode) o;
                 if (method.getParameters().length == count) {
                     return true;
                 }
@@ -1054,43 +1079,40 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
             TupleExpression tuple = (TupleExpression) arguments;
             // TODO this won't strictly be true when using list expansion in argument calls
             count = tuple.getExpressions().size();
-        }
-        else
-          return null;
+        } else
+            return null;
 
         MethodNode res = null;
         ClassNode node = this;
         TupleExpression args = (TupleExpression) arguments;
         do {
-            for (Iterator iter = node.getDeclaredMethods(name).iterator(); iter.hasNext();) {
-                MethodNode method = (MethodNode) iter.next();
+            for (Object o : node.getMethods(name)) {
+                MethodNode method = (MethodNode) o;
                 if (method.getParameters().length == count) {
                     boolean match = true;
                     for (int i = 0; i != count; ++i)
-                      if (!args.getType().isDerivedFrom(method.getParameters()[i].getType())) {
-                          match = false;
-                          break;
-                      }
+                        if (!args.getType().isDerivedFrom(method.getParameters()[i].getType())) {
+                            match = false;
+                            break;
+                        }
 
                     if (match) {
                         if (res == null)
-                          res = method;
+                            res = method;
                         else {
-                          if (res.getParameters().length != count)
-                            return null;
-
-                          if (node.equals(this))
-                            return null;
-
-                          match = true;
-                          for (int i = 0; i != count; ++i)
-                            if (!res.getParameters()[i].getType().equals(method.getParameters()[i].getType())) {
-                                match = false;
-                                break;
-                            }
-
-                          if (!match)
-                            return null;
+                            if (res.getParameters().length != count)
+                                return null;
+                            if (node.equals(this))
+                                return null;
+
+                            match = true;
+                            for (int i = 0; i != count; ++i)
+                                if (!res.getParameters()[i].getType().equals(method.getParameters()[i].getType())) {
+                                    match = false;
+                                    break;
+                                }
+                            if (!match)
+                                return null;
                         }
                     }
                 }
@@ -1103,7 +1125,11 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
     }
 
     /**
-     * Returns true if the given method has a possibly matching static method with the given name and arguments
+     * Returns true if the given method has a possibly matching static method with the given name and arguments.
+     *
+     * @param name      the name of the method of interest
+     * @param arguments the arguments to match against
+     * @return true if a matching method was found
      */
     public boolean hasPossibleStaticMethod(String name, Expression arguments) {
         int count = 0;
@@ -1113,14 +1139,14 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
             // TODO this won't strictly be true when using list expansion in argument calls
             count = tuple.getExpressions().size();
         }
-        for (Iterator iter = getDeclaredMethods(name).iterator(); iter.hasNext();) {
-            MethodNode method = (MethodNode) iter.next();
+        for (Object o : getMethods(name)) {
+            MethodNode method = (MethodNode) o;
             if (method.getParameters().length == count && method.isStatic()) {
                 return true;
             }
             // handle varargs case
             if (method.isStatic() && method.getParameters().length > 0 &&
-                method.getParameters()[method.getParameters().length - 1].getType().isArray()) {
+                    method.getParameters()[method.getParameters().length - 1].getType().isArray()) {
                 if (count >= method.getParameters().length - 1) return true;
             }
         }
diff --git a/src/main/org/codehaus/groovy/ast/InnerClassNode.java b/src/main/org/codehaus/groovy/ast/InnerClassNode.java
index 6541b3fb1b..85cf1ed5fe 100644
--- a/src/main/org/codehaus/groovy/ast/InnerClassNode.java
+++ b/src/main/org/codehaus/groovy/ast/InnerClassNode.java
@@ -52,6 +52,6 @@ public class InnerClassNode extends ClassNode {
      * @return the field node on the outer class or null if this is not an inner class
      */
     public FieldNode getOuterField(String name) {
-        return outerClass.getField(name);
+        return outerClass.getDeclaredField(name);
     }
 }
diff --git a/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java b/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
index 750439bdf1..c3642b4c10 100644
--- a/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
+++ b/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
@@ -1587,7 +1587,7 @@ public class AsmClassGenerator extends ClassGenerator {
             // If it is no field and is not yet declared, then it is either a closure shared variable or
             // an already declared variable.
             if (!compileStack.containsVariable(name) && compileStack.getScope().isReferencedClassVariable(name)) {
-                visitFieldExpression(new FieldExpression(classNode.getField(name)));
+                visitFieldExpression(new FieldExpression(classNode.getDeclaredField(name)));
             } else {
                 Variable v = compileStack.getVariable(name, classNode.getSuperClass() != ClassHelper.CLOSURE_TYPE);
                 if (v == null) {
@@ -1595,7 +1595,7 @@ public class AsmClassGenerator extends ClassGenerator {
                     // inside a nested Closure and this variable
                     // was not used before
                     // then load it from the Closure field
-                    FieldNode field = classNode.getField(name);
+                    FieldNode field = classNode.getDeclaredField(name);
                     mv.visitVarInsn(ALOAD, 0);
                     mv.visitFieldInsn(GETFIELD, internalClassName, name, BytecodeHelper.getTypeDescription(field.getType()));
                     // and define it
@@ -1627,7 +1627,7 @@ public class AsmClassGenerator extends ClassGenerator {
      */
     protected void loadThisOrOwner() {
         if (isInnerClass()) {
-            visitFieldExpression(new FieldExpression(classNode.getField("owner")));
+            visitFieldExpression(new FieldExpression(classNode.getDeclaredField("owner")));
         } else {
             loadThis();
         }
@@ -2546,9 +2546,9 @@ public class AsmClassGenerator extends ClassGenerator {
             if (name != null) {
                 FieldNode field = null;
                 if (isSuperExpression(objectExpression)) {
-                    field = classNode.getSuperClass().getField(name);
+                    field = classNode.getSuperClass().getDeclaredField(name);
                 } else {
-                    field = classNode.getField(name);
+                    field = classNode.getDeclaredField(name);
                 }
                 if (field != null) {
                     visitFieldExpression(new FieldExpression(field));
@@ -2948,7 +2948,7 @@ public class AsmClassGenerator extends ClassGenerator {
             ClassRef ref = (ClassRef) iter.next();
             String staticFieldName = getStaticFieldName(ref.type);
             // generate a field node
-            FieldNode fn = classNode.getField(staticFieldName);
+            FieldNode fn = classNode.getDeclaredField(staticFieldName);
             if (fn != null) {
                 boolean type = fn.getType() == ClassHelper.CLASS_Type;
                 boolean modifiers = fn.getModifiers() == ACC_STATIC + ACC_SYNTHETIC;
@@ -3972,7 +3972,7 @@ public class AsmClassGenerator extends ClassGenerator {
                     return type;
                 }
             } else {
-                FieldNode field = classNode.getField(variableName);
+                FieldNode field = classNode.getDeclaredField(variableName);
                 if (field == null) {
                     field = classNode.getOuterField(variableName);
                 }
@@ -4107,14 +4107,14 @@ public class AsmClassGenerator extends ClassGenerator {
         FieldNode field = null;
         if (expression instanceof VariableExpression) {
             VariableExpression varExp = (VariableExpression) expression;
-            field = classNode.getField(varExp.getName());
+            field = classNode.getDeclaredField(varExp.getName());
         } else if (expression instanceof FieldExpression) {
             FieldExpression fieldExp = (FieldExpression) expression;
-            field = classNode.getField(fieldExp.getFieldName());
+            field = classNode.getDeclaredField(fieldExp.getFieldName());
         } else if (expression.getClass() == PropertyExpression.class) {
             PropertyExpression fieldExp = (PropertyExpression) expression;
             String possibleField = fieldExp.getPropertyAsString();
-            if (possibleField != null) field = classNode.getField(possibleField);
+            if (possibleField != null) field = classNode.getDeclaredField(possibleField);
         }
       return field != null && !field.isStatic();
     }
@@ -4221,7 +4221,7 @@ public class AsmClassGenerator extends ClassGenerator {
      * @return true if the given name is a local variable or a field
      */
     protected boolean isFieldOrVariable(String name) {
-        return compileStack.containsVariable(name) || classNode.getField(name) != null;
+        return compileStack.containsVariable(name) || classNode.getDeclaredField(name) != null;
     }
 
     /**
@@ -4288,7 +4288,7 @@ public class AsmClassGenerator extends ClassGenerator {
             if (variable != null) {
                 return variable.isHolder();
             }
-            FieldNode field = classNode.getField(varExp.getName());
+            FieldNode field = classNode.getDeclaredField(varExp.getName());
             if (field != null) {
                 return field.isHolder();
             }
diff --git a/src/main/org/codehaus/groovy/classgen/ClassCompletionVerifier.java b/src/main/org/codehaus/groovy/classgen/ClassCompletionVerifier.java
index 057c1ade48..0ccf6027d7 100644
--- a/src/main/org/codehaus/groovy/classgen/ClassCompletionVerifier.java
+++ b/src/main/org/codehaus/groovy/classgen/ClassCompletionVerifier.java
@@ -295,7 +295,7 @@ public class ClassCompletionVerifier extends ClassCodeVisitorSupport {
     }
 
     public void visitField(FieldNode node) {
-        if (currentClass.getField(node.getName()) != node) {
+        if (currentClass.getDeclaredField(node.getName()) != node) {
             addError("The " + getDescription(node) + " is declared multiple times.", node);
         }
         checkInterfaceFieldModifiers(node);
diff --git a/src/main/org/codehaus/groovy/classgen/Verifier.java b/src/main/org/codehaus/groovy/classgen/Verifier.java
index c0e747fa04..696e7dba38 100644
--- a/src/main/org/codehaus/groovy/classgen/Verifier.java
+++ b/src/main/org/codehaus/groovy/classgen/Verifier.java
@@ -94,12 +94,12 @@ public class Verifier implements GroovyClassVisitor, Opcodes {
     }
     
     private FieldNode getMetaClassField(ClassNode node) {
-        FieldNode ret = node.getField("metaClass");
+        FieldNode ret = node.getDeclaredField("metaClass");
         if (ret!=null) return ret;
         ClassNode current = node;
         while (current!=null && current!=ClassHelper.OBJECT_TYPE) {
             current = current.getSuperClass();
-            ret = current.getField("metaClass");
+            ret = current.getDeclaredField("metaClass");
             if (ret==null) continue;
             if (Modifier.isPrivate(ret.getModifiers())) continue;
             return ret;
@@ -138,7 +138,7 @@ public class Verifier implements GroovyClassVisitor, Opcodes {
         addDefaultParameterConstructors(node);
 
         String _myClassFieldName = "$myClass";
-        while (node.getField(_myClassFieldName) != null)
+        while (node.getDeclaredField(_myClassFieldName) != null)
           _myClassFieldName = _myClassFieldName + "$";
         final String myClassFieldName = _myClassFieldName;
 
@@ -148,7 +148,7 @@ public class Verifier implements GroovyClassVisitor, Opcodes {
 //        myClassField.setSynthetic(true);
 
         String _staticClassInfoFieldName = "$staticClassInfo";
-        while (node.getField(_staticClassInfoFieldName) != null)
+        while (node.getDeclaredField(_staticClassInfoFieldName) != null)
           _staticClassInfoFieldName = _staticClassInfoFieldName + "$";
         final String staticMetaClassFieldName = _staticClassInfoFieldName;
 
diff --git a/src/main/org/codehaus/groovy/control/OptimizerVisitor.java b/src/main/org/codehaus/groovy/control/OptimizerVisitor.java
index 68c1ad9dc7..cc961e5978 100644
--- a/src/main/org/codehaus/groovy/control/OptimizerVisitor.java
+++ b/src/main/org/codehaus/groovy/control/OptimizerVisitor.java
@@ -67,7 +67,7 @@ public class OptimizerVisitor extends ClassCodeExpressionTransformer {
         final String name = "$const$" + const2Var.size();
         //TODO: this part here needs a bit of rethinking. If it can happen that the field is defined already,
         //      then is this code still valid?
-        field = currentClass.getField(name);
+        field = currentClass.getDeclaredField(name);
         if (field==null) {
             field = new FieldNode(name,
                     Opcodes.ACC_PRIVATE|Opcodes.ACC_STATIC|Opcodes.ACC_SYNTHETIC| Opcodes.ACC_FINAL,
diff --git a/src/main/org/codehaus/groovy/control/StaticImportVisitor.java b/src/main/org/codehaus/groovy/control/StaticImportVisitor.java
index 017f2552db..57edf2c9d6 100644
--- a/src/main/org/codehaus/groovy/control/StaticImportVisitor.java
+++ b/src/main/org/codehaus/groovy/control/StaticImportVisitor.java
@@ -173,7 +173,7 @@ public class StaticImportVisitor extends ClassCodeExpressionTransformer {
         if (objectExpression instanceof ClassExpression && currentMethod != null && currentMethod.isStatic()) {
             ClassExpression ce = (ClassExpression) objectExpression;
             if (ce.getType().getName().equals(currentClass.getName())) {
-                FieldNode field = currentClass.getField(pe.getPropertyAsString());
+                FieldNode field = currentClass.getDeclaredField(pe.getPropertyAsString());
                 if (field != null && field.isStatic()) {
                     Expression expression = new FieldExpression(field);
                     expression.setSourcePosition(pe);
@@ -244,9 +244,8 @@ public class StaticImportVisitor extends ClassCodeExpressionTransformer {
             if (expression != null) return expression;
         }
         Map importedClasses = module.getStaticImportClasses();
-        Iterator it = importedClasses.keySet().iterator();
-        while (it.hasNext()) {
-            String className = (String) it.next();
+        for (Object o : importedClasses.keySet()) {
+            String className = (String) o;
             ClassNode node = (ClassNode) importedClasses.get(className);
             Expression expression = findStaticField(node, name);
             if (expression != null) return expression;
@@ -255,15 +254,14 @@ public class StaticImportVisitor extends ClassCodeExpressionTransformer {
     }
 
     private Expression findStaticField(ClassNode staticImportType, String fieldName) {
-        if (!staticImportType.isResolved() && !staticImportType.isPrimaryClassNode()) {
-            stillResolving = true;
-        }
         if (staticImportType.isPrimaryClassNode() || staticImportType.isResolved()) {
             staticImportType.getFields(); // force init
             FieldNode field = staticImportType.getField(fieldName);
             if (field != null && field.isStatic()) {
                 return new PropertyExpression(new ClassExpression(staticImportType), fieldName);
             }
+        } else {
+            stillResolving = true;
         }
         return null;
     }
@@ -285,9 +283,8 @@ public class StaticImportVisitor extends ClassCodeExpressionTransformer {
             if (expression != null) return expression;
         }
         Map importPackages = module.getStaticImportClasses();
-        Iterator it = importPackages.keySet().iterator();
-        while (it.hasNext()) {
-            String className = (String) it.next();
+        for (Object o : importPackages.keySet()) {
+            String className = (String) o;
             ClassNode starImportType = (ClassNode) importPackages.get(className);
             Expression expression = findStaticMethod(starImportType, name, args);
             if (expression != null) return expression;
diff --git a/src/test/groovy/StaticImportTest.groovy b/src/test/groovy/StaticImportTest.groovy
index b55e822c6a..b51a4adc68 100644
--- a/src/test/groovy/StaticImportTest.groovy
+++ b/src/test/groovy/StaticImportTest.groovy
@@ -10,6 +10,7 @@ import static StaticImportTarget.x
 import static java.lang.Math.*
 import static java.util.Calendar.getInstance as now
 import static groovy.API.*
+import static groovy.StaticImportChild.*
 
 class StaticImportTest extends GroovyTestCase {
     void testFieldWithAliasInExpression() {
@@ -80,6 +81,13 @@ class StaticImportTest extends GroovyTestCase {
         assert API.arrayMethod("two", 1, 2, 3) == 'arrayMethod(two, 1, 2, 3)'
         assert arrayMethod("three", 1, 2, 3) == 'arrayMethod(three, 1, 2, 3)'
     }
+
+    void testStaticImportFromParentClass() {
+        assert cmethod() == 'hello from child'
+        assert pmethod() == 'hello from parent'
+        assert cfield == 21
+        assert pfield == 42
+    }
 }
 
 class API {
@@ -91,3 +99,13 @@ class API {
         "arrayMethod(${s}, " + values.toList().join(", ") + ")"
     }
 }
+
+class StaticImportParent {
+  static pfield = 42
+  static pmethod() { 'hello from parent' }
+}
+
+class StaticImportChild extends StaticImportParent {
+  static cfield = 21
+  static cmethod() { 'hello from child' }
+}
