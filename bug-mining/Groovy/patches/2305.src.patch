diff --git a/src/main/groovy/transform/ConditionalInterrupt.groovy b/src/main/groovy/transform/ConditionalInterrupt.groovy
index 2e9b18bddb..2f6b55de86 100644
--- a/src/main/groovy/transform/ConditionalInterrupt.groovy
+++ b/src/main/groovy/transform/ConditionalInterrupt.groovy
@@ -24,7 +24,7 @@ import org.codehaus.groovy.transform.GroovyASTTransformationClass
 
 /**
  * Allows "interrupt-safe" executions of scripts by adding a custom check for interruption
- * on loops (for, while, do), the first statement of closures, and the first statement of methods.
+ * into loops (for, while, ...) and at the start of closures and methods.
  * <p>
  * This is especially useful when executing foreign scripts that you do not have control over. Inject this
  * transformation into a script that you need to interrupt based on some custom criteria.
@@ -35,7 +35,6 @@ import org.codehaus.groovy.transform.GroovyASTTransformationClass
  * as well. Annotated a class will cause (by default) all classes in the entire file ('Compilation Unit') to be
  * enhanced. You can fine tune what is enhanced using the annotation parameters.
  * <p>
- * Extensive usage examples can be found in the unit test for this class. A smaller example is presented here.
  * The following is sample usage of the annotation:
  * <pre>
  * <code>@ConditionalInterrupt({ counter++> 10})</code>
@@ -50,31 +49,30 @@ import org.codehaus.groovy.transform.GroovyASTTransformationClass
  *
  * scriptMethod()
  * </pre>
- * Which results in the following code being generated. Notice the checks and exceptions:
+ * Which results in the following code being generated (XXXXXX will be replaced with some runtime generated hashCode). Notice the checks and exceptions:
  * <pre>
  * public class script1291741477073 extends groovy.lang.Script {
+ *   Object counter = 0
  *
- *     Object counter = 0
+ *   public java.lang.Object run() {
+ *     counter = 0
+ *   }
  *
- *     public java.lang.Object run() {
- *         counter = 0
+ *   public java.lang.Object scriptMethod() {
+ *     if (this.conditionalTransformXXXXXX$condition()) {
+ *       throw new java.lang.InterruptedException('Execution interrupted. The following condition failed: { counter++> 10}')
  *     }
+ *     4.times({
+ *       if (this.conditionalTransformXXXXXX$condition()) {
+ *         throw new java.lang.InterruptedException('Execution interrupted. The following condition failed: { counter++> 10}')
+ *       }
+ *       this.println('executing script method...')
+ *     })
+ *   }
  *
- *     public java.lang.Object scriptMethod() {
- *         if (this.conditionalTransform$condition()) {
- *             throw new java.lang.InterruptedException('Execution interrupted. The following condition failed: { counter++> 10}')
- *         }
- *         4.times({
- *             if (this.conditionalTransform$condition()) {
- *                 throw new java.lang.InterruptedException('Execution interrupted. The following condition failed: { counter++> 10}')
- *             }
- *             this.println('executing script method...')
- *         })
- *     }
- *
- *     private java.lang.Object conditionalTransform$condition() {
- *         counter++ > 10
- *     }
+ *   private java.lang.Object conditionalTransformXXXXXX$condition() {
+ *     counter++ > 10
+ *   }
  * }
  * </pre>
  *
@@ -88,57 +86,67 @@ import org.codehaus.groovy.transform.GroovyASTTransformationClass
  * def counter = 0
  * <code>@ConditionalInterrupt({ counter++> 10})</code>
  * class MyClass {
- *     def myMethod() {
- *         4.times {
- *             println 'executing script method...'
- *         }
+ *   def myMethod() {
+ *     4.times {
+ *       println 'executing script method...'
  *     }
+ *   }
  * }
  *
  * new MyClass().myMethod()
  * </pre>
+ * Additional usage examples can be found in the unit test for this class.
  *
  * @see TimedInterrupt
  * @see ThreadInterrupt
  * @author Cedric Champeau
  * @author Hamlet D'Arcy
+ * @author Paul King
  * @since 1.8.0
  */
 @java.lang.annotation.Documented
 @Retention(RetentionPolicy.SOURCE)
-@Target([ ElementType.PACKAGE, ElementType.METHOD, ElementType.FIELD, ElementType.TYPE, ElementType.LOCAL_VARIABLE])
+@Target([ElementType.PACKAGE, ElementType.METHOD, ElementType.FIELD, ElementType.TYPE, ElementType.LOCAL_VARIABLE])
 @GroovyASTTransformationClass(["org.codehaus.groovy.transform.ConditionalInterruptibleASTTransformation"])
-public @interface ConditionalInterrupt {
-    /**
-     * By default, annotating anything in a source file ('Compilation Unit') will trigger this transformation
-     * for all classes and scripts in that file. If you add the Annotation to an import statement, then all
-     * scripts and Classes will be enhanced. If you want to change this behavior then set applyToAllClasses
-     * to false. If you annotate a type then only that type will be augmented, not other types or the surrounding
-     * script. If you annotate a script, then any enclosed types will not be augmented.
-     *
-     * @return
-     */
-    boolean applyToAllClasses() default true
-    /**
-     * By default an isInterrupted check is added to the start of all user-defined methods. To turn this off simply
-     * set this parameter to false.
-     *
-     * @return
-     */
-    boolean checkOnMethodStart() default true
+@interface ConditionalInterrupt {
+  /**
+   * Set this to false if you have multiple classes within one source file and only
+   * want a conditional check on some of the classes. Place annotations on the classes
+   * you want enhanced. Set to true (the default) for blanket coverage of conditional
+   * checks on all methods, loops and closures within all classes/script code.
+   *
+   * For even finer-grained control see {@code applyToAllMembers}.
+   *
+   * @see #applyToAllMembers()
+   */
+  boolean applyToAllClasses() default true
 
-    /**
-     * Sets the type of exception which is thrown.
-     *
-     * @return
-     */
-    Class thrown() default InterruptedException
+  /**
+   * Set this to false if you have multiple methods/closures within a class or script and only
+   * want conditional checks on some of them. Place annotations on the methods/closures that
+   * you want enhanced. When false, {@code applyToAllClasses} is automatically set to false.
+   *
+   * Set to true (the default) for blanket coverage of conditional checks on all methods, loops
+   * and closures within the class/script.
+   *
+   * @since 2.2.0
+   * @see #applyToAllClasses()
+   */
+  boolean applyToAllMembers() default true
 
-    /**
-     * Condition should be set as a closure expression. 
-     * @return
-     */
-    Class value()
+  /**
+   * By default a conditional check is added to the start of all user-defined methods. To turn this off simply
+   * set this parameter to false.
+   */
+  boolean checkOnMethodStart() default true
 
-}
+  /**
+   * Sets the type of exception which is thrown.
+   */
+  Class thrown() default InterruptedException
 
+  /**
+   * Conditional check - set as a closure expression.
+   */
+  Class value()
+}
diff --git a/src/main/groovy/transform/ThreadInterrupt.groovy b/src/main/groovy/transform/ThreadInterrupt.groovy
index 354e4cb83e..cee2809ea9 100644
--- a/src/main/groovy/transform/ThreadInterrupt.groovy
+++ b/src/main/groovy/transform/ThreadInterrupt.groovy
@@ -22,10 +22,9 @@ import java.lang.annotation.RetentionPolicy
 import java.lang.annotation.Target
 import org.codehaus.groovy.transform.GroovyASTTransformationClass
 
-
 /**
  * Allows "interrupt-safe" executions of scripts by adding Thread.currentThread().isInterrupted()
- * checks on loops (for, while, do), the first statement of closures, and the first statement of methods.
+ * checks into loops (for, while) and at the start of closures and methods.
  * <p>
  * This is especially useful when executing foreign scripts that you do not have control over. Inject this
  * transformation into a script that you need to interrupt.
@@ -36,23 +35,21 @@ import org.codehaus.groovy.transform.GroovyASTTransformationClass
  * in the entire file ('Compilation Unit') to be enhanced. You can fine tune what is enhanced using the annotation
  * parameters. 
  * <p>
- * Extensive usage examples can be found in the unit test for this class. A smaller example is presented here.
  * The following is sample usage of the annotation:
  *
  * <pre>
  * <code>@groovy.transform.ThreadInterrupt</code>
  * def scriptMethod() {
- *     4.times {
- *         println 'executing script method...'
- *     }
+ *   4.times {
+ *     println 'executing script method...'
+ *   }
  * }
  *
  * class MyClass {
- *
  *   def myMethod() {
- *       for (i in (1..10)) {
- *           println 'executing method...'
- *       }
+ *     for (i in (1..10)) {
+ *       println 'executing method...'
+ *     }
  *   }
  * }
  *
@@ -79,55 +76,69 @@ import org.codehaus.groovy.transform.GroovyASTTransformationClass
  * }
  * public class MyClass extends java.lang.Object {
  *
- *     public java.lang.Object myMethod() {
- *         if (java.lang.Thread.currentThread().isInterrupted()) {
- *             throw new java.lang.InterruptedException('Execution Interrupted')
- *         }
- *         for (java.lang.Object i : (1..10)) {
- *             if (java.lang.Thread.currentThread().isInterrupted()) {
- *                 throw new java.lang.InterruptedException('Execution Interrupted')
- *             }
- *             this.println('executing method...')
- *         }
+ *   public java.lang.Object myMethod() {
+ *     if (java.lang.Thread.currentThread().isInterrupted()) {
+ *       throw new java.lang.InterruptedException('Execution Interrupted')
  *     }
+ *     for (java.lang.Object i : (1..10)) {
+ *       if (java.lang.Thread.currentThread().isInterrupted()) {
+ *         throw new java.lang.InterruptedException('Execution Interrupted')
+ *       }
+ *       this.println('executing method...')
+ *     }
+ *   }
  * }
  *
  * this.scriptMethod()
  * new MyClass().myMethod()
  * </pre>
+ * Additional usage examples can be found in the unit test for this class.
  *
  * @see TimedInterrupt
  * @see ConditionalInterrupt
  * @author Cedric Champeau
  * @author Hamlet D'Arcy
+ * @author Paul King
  * @since 1.8.0
  */
 @Documented
 @Retention(RetentionPolicy.SOURCE)
-@Target([ ElementType.PACKAGE, ElementType.METHOD, ElementType.FIELD, ElementType.TYPE, ElementType.LOCAL_VARIABLE])
+@Target([ElementType.PACKAGE, ElementType.METHOD, ElementType.FIELD, ElementType.TYPE, ElementType.LOCAL_VARIABLE])
 @GroovyASTTransformationClass(["org.codehaus.groovy.transform.ThreadInterruptibleASTTransformation"])
-public @interface ThreadInterrupt {
-    /**
-     * By default, annotating anything in a source file ('Compilation Unit') will trigger this transformation
-     * for all classes and scripts in that file. If you add the Annotation to an import statement, then all
-     * scripts and Classes will be enhanced. If you want to change this behavior then set applyToAllClasses
-     * to false. If you annotate a type then only that type will be augmented, not other types or the surrounding
-     * script. If you annotate a script, then any enclosed types will not be augmented.
-     * @return
-     */
-    boolean applyToAllClasses() default true
+@interface ThreadInterrupt {
+  /**
+   * Set this to false if you have multiple classes within one source file and only
+   * want isInterrupted checks on some of the classes. Place annotations on the classes
+   * you want enhanced. Set to true (the default) for blanket coverage of isInterrupted
+   * checks on all methods, loops and closures within all classes/script code.
+   *
+   * For even finer-grained control see {@code applyToAllMembers}.
+   *
+   * @see #applyToAllMembers()
+   */
+  boolean applyToAllClasses() default true
+
+  /**
+   * Set this to false if you have multiple methods/closures within a class or script and only
+   * want isInterrupted checks on some of them. Place annotations on the methods/closures that
+   * you want enhanced. When false, {@code applyToAllClasses} is automatically set to false.
+   *
+   * Set to true (the default) for blanket coverage of isInterrupted checks on all methods, loops
+   * and closures within the class/script.
+   *
+   * @since 2.2.0
+   * @see #applyToAllClasses()
+   */
+  boolean applyToAllMembers() default true
 
-    /**
-     * By default an isInterrupted check is added to the start of all user-defined methods. To turn this off simply
-     * set this parameter to false.
-     * @return
-     */
-    boolean checkOnMethodStart() default true
+  /**
+   * By default an isInterrupted check is added to the start of all user-defined methods. To turn this off simply
+   * set this parameter to false.
+   */
+  boolean checkOnMethodStart() default true
 
-    /**
-     * Sets the type of exception which is thrown.
-     *
-     * @return
-     */
-    Class thrown() default InterruptedException
+  /**
+   * Sets the type of exception which is thrown.
+   */
+  Class thrown() default InterruptedException
 }
diff --git a/src/main/groovy/transform/TimedInterrupt.groovy b/src/main/groovy/transform/TimedInterrupt.groovy
index ab73e718a5..567f3ae1cf 100644
--- a/src/main/groovy/transform/TimedInterrupt.groovy
+++ b/src/main/groovy/transform/TimedInterrupt.groovy
@@ -26,8 +26,8 @@ import java.util.concurrent.TimeoutException
 import org.codehaus.groovy.transform.GroovyASTTransformationClass
 
 /**
- * Allows safe timed executions of scripts by adding elapsed time checks on loops (for, while, do)
- * to the first statement of closures and methods.
+ * Allows safe timed executions of scripts by adding elapsed time checks into loops (for, while)
+ * and at the start of closures and methods and throwing an exception if a timeout occurs.
  * <p>
  * This is especially useful when executing foreign scripts that you do not have control over.
  * Inject this transformation into a script that you want to timeout after a specified amount of time.
@@ -38,14 +38,13 @@ import org.codehaus.groovy.transform.GroovyASTTransformationClass
  * all classes in the entire file ('Compilation Unit') to be enhanced. You can fine tune what is
  * enhanced using the annotation parameters. Static methods and static fields are ignored.
  * <p>
- * Extensive usage examples can be found in the unit test for this class. A smaller example is presented
- * here. The following is sample usage of the annotation forcing the script to timeout after 1000 seconds:
+ * The following is sample usage of the annotation forcing the script to timeout after 5 minutes (300 seconds):
  *
  * <pre>
  * import groovy.transform.TimedInterrupt
  * import java.util.concurrent.TimeUnit
  *
- * {@code @TimedInterrupt}(value = 1000L, unit = TimeUnit.SECONDS)
+ * {@code @TimedInterrupt}(value = 300L, unit = TimeUnit.SECONDS)
  * class MyClass {
  *      def method() {
  *          println '...'
@@ -63,18 +62,19 @@ import org.codehaus.groovy.transform.GroovyASTTransformationClass
  *     final private java.util.Date timedInterruptXXXXXX$startTime
  *
  *     public MyClass() {
- *         timedInterruptXXXXXX$expireTime = System.nanoTime() + TimeUnit.NANOSECONDS.convert(1000, TimeUnit.SECONDS)
+ *         timedInterruptXXXXXX$expireTime = System.nanoTime() + TimeUnit.NANOSECONDS.convert(300, TimeUnit.SECONDS)
  *         timedInterruptXXXXXX$startTime = new java.util.Date()
  *     }
  *
  *     public java.lang.Object method() {
  *         if (timedInterruptXXXXXX$expireTime < System.nanoTime()) {
- *             throw new TimeoutException('Execution timed out after 1000 units. Start time: ' + timedInterruptXXXXXX$startTime)
+ *             throw new TimeoutException('Execution timed out after 300 units. Start time: ' + timedInterruptXXXXXX$startTime)
  *         }
  *         return this.println('...')
  *     }
  * }
  * </pre>
+ * See the unit test for this class for additional examples.
  *
  * @author Hamlet D'Arcy
  * @author Cedric Champeau
@@ -87,29 +87,28 @@ import org.codehaus.groovy.transform.GroovyASTTransformationClass
 @Retention(RetentionPolicy.SOURCE)
 @Target([ ElementType.PACKAGE, ElementType.METHOD, ElementType.FIELD, ElementType.TYPE, ElementType.LOCAL_VARIABLE])
 @GroovyASTTransformationClass(["org.codehaus.groovy.transform.TimedInterruptibleASTTransformation"])
-public @interface TimedInterrupt {
+@interface TimedInterrupt {
     /**
-     * In many scenarios, the use of this annotation is to guard against gross time
-     * delays when executing scripts. In such cases you can inject the annotation or
-     * use a single annotation on your class or on any eligible element in a script.
-     * This will trigger this transformation for all classes (including any script class)
-     * in that source file. If you want to change this behavior then set {@code applyToAllClasses}
-     * to false. This gives you more fine-grained control over what parts are enhanced and
-     * allows you to specify different timing constraints on different classes if needed.
-     * When set to false, if you annotate a type then only that type will be augmented, not
-     * other types or the surrounding script. If you annotate a script, then any enclosed
-     * types will not be augmented. For even finer-grained control see {@code applyToAllMembers}.
+     * Set this to false if you have multiple classes within one source file and only want
+     * timeout checks on some of the classes (or you want different time constraints on different classes).
+     * Place an annotation with appropriate parameters on each class you want enhanced.
+     * Set to true (the default) for blanket coverage of timeout checks on all methods, loops
+     * and closures within all classes/script code.
+     *
+     * For even finer-grained control see {@code applyToAllMembers}.
      *
      * @see #applyToAllMembers()
      */
     boolean applyToAllClasses() default true
 
     /**
-     * If set to false, it automatically sets {@code applyToAllClasses} to false. In addition,
-     * if you annotate a method (or Closure field), only that method (or Closure) will be enhanced.
-     * This is useful if you want to have different timing constraints on different methods. The implication
-     * is that if you don't set this to false, there is little value in having more than one Annotation
-     * in any one source file or within any one class.
+     * Set this to false if you have multiple methods/closures within a class or script and only
+     * want timeout checks on some of them (or you want different time constraints on different methods/closures).
+     * Place annotations with appropriate parameters on the methods/closures that you want enhanced.
+     * When false, {@code applyToAllClasses} is automatically set to false.
+     *
+     * Set to true (the default) for blanket coverage of timeout checks on all methods, loops
+     * and closures within the class/script.
      *
      * @since 2.2.0
      * @see #applyToAllClasses()
@@ -117,7 +116,7 @@ public @interface TimedInterrupt {
     boolean applyToAllMembers() default true
 
     /**
-     * By default an isInterrupted check is added to the start of all user-defined methods. To turn this off
+     * By default a time check is added to the start of all user-defined methods. To turn this off
      * simply set this parameter to false.
      */
     boolean checkOnMethodStart() default true
@@ -125,7 +124,7 @@ public @interface TimedInterrupt {
     /**
      * The maximum elapsed time the script will be allowed to run for. By default it is measure in seconds
      */
-    long value();
+    long value()
 
     /**
      * The TimeUnit of the value parameter. By default it is TimeUnit.SECONDS.
diff --git a/src/main/org/codehaus/groovy/transform/AbstractInterruptibleASTTransformation.java b/src/main/org/codehaus/groovy/transform/AbstractInterruptibleASTTransformation.java
index f2e54a675e..dbc0dc9c1c 100644
--- a/src/main/org/codehaus/groovy/transform/AbstractInterruptibleASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/AbstractInterruptibleASTTransformation.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2010 the original author or authors.
+ * Copyright 2008-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -33,16 +33,19 @@ import java.util.List;
  *
  * @author Cedric Champeau
  * @author Hamlet D'Arcy
+ * @author Paul King
  * @since 1.8.0
  */
 public abstract class AbstractInterruptibleASTTransformation extends ClassCodeVisitorSupport implements ASTTransformation, Opcodes {
 
     protected static final String CHECK_METHOD_START_MEMBER = "checkOnMethodStart";
-    protected static final String PROPAGATE_TO_COMPILE_UNIT = "applyToAllClasses";
+    private static final String APPLY_TO_ALL_CLASSES = "applyToAllClasses";
+    private static final String APPLY_TO_ALL_MEMBERS = "applyToAllMembers";
     protected static final String THROWN_EXCEPTION_TYPE = "thrown";
     protected SourceUnit source;
     protected boolean checkOnMethodStart;
     protected boolean applyToAllClasses;
+    protected boolean applyToAllMembers;
     protected ClassNode thrownExceptionType;
 
     protected SourceUnit getSourceUnit() {
@@ -63,13 +66,14 @@ public abstract class AbstractInterruptibleASTTransformation extends ClassCodeVi
 
     protected void setupTransform(AnnotationNode node) {
         checkOnMethodStart = getBooleanAnnotationParameter(node, CHECK_METHOD_START_MEMBER, true);
-        applyToAllClasses = getBooleanAnnotationParameter(node, PROPAGATE_TO_COMPILE_UNIT, true);
+        applyToAllMembers = getBooleanAnnotationParameter(node, APPLY_TO_ALL_MEMBERS, true);
+        applyToAllClasses = applyToAllMembers ? getBooleanAnnotationParameter(node, APPLY_TO_ALL_CLASSES, true) : false;
         thrownExceptionType = getClassAnnotationParameter(node, THROWN_EXCEPTION_TYPE, ClassHelper.make(InterruptedException.class));
     }
 
     public void visit(ASTNode[] nodes, SourceUnit source) {
         if (nodes.length != 2 || !(nodes[0] instanceof AnnotationNode) || !(nodes[1] instanceof AnnotatedNode)) {
-            internalError("Expecting [AnnotationNode, AnnotatedClass] but got: " + Arrays.asList(nodes));
+            internalError("Expecting [AnnotationNode, AnnotatedNode] but got: " + Arrays.asList(nodes));
         }
 
         this.source = source;
@@ -95,6 +99,15 @@ public abstract class AbstractInterruptibleASTTransformation extends ClassCodeVi
         } else if (annotatedNode instanceof ClassNode) {
             // only guard this particular class
             this.visitClass((ClassNode) annotatedNode);
+        } else if (!applyToAllMembers && annotatedNode instanceof MethodNode) {
+            this.visitMethod((MethodNode) annotatedNode);
+            this.visitClass(annotatedNode.getDeclaringClass());
+        } else if (!applyToAllMembers && annotatedNode instanceof FieldNode) {
+            this.visitField((FieldNode) annotatedNode);
+            this.visitClass(annotatedNode.getDeclaringClass());
+        } else if (!applyToAllMembers && annotatedNode instanceof DeclarationExpression) {
+            this.visitDeclarationExpression((DeclarationExpression) annotatedNode);
+            this.visitClass(annotatedNode.getDeclaringClass());
         } else {
             // only guard the script class
             if (tree != null) {
@@ -108,7 +121,6 @@ public abstract class AbstractInterruptibleASTTransformation extends ClassCodeVi
         }
     }
 
-
     protected static boolean getBooleanAnnotationParameter(AnnotationNode node, String parameterName, boolean defaultValue) {
         Expression member = node.getMember(parameterName);
         if (member != null) {
diff --git a/src/main/org/codehaus/groovy/transform/ConditionalInterruptibleASTTransformation.groovy b/src/main/org/codehaus/groovy/transform/ConditionalInterruptibleASTTransformation.groovy
index 2056ad41dc..bc9ff33738 100644
--- a/src/main/org/codehaus/groovy/transform/ConditionalInterruptibleASTTransformation.groovy
+++ b/src/main/org/codehaus/groovy/transform/ConditionalInterruptibleASTTransformation.groovy
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2010 the original author or authors.
+ * Copyright 2008-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,13 +13,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.codehaus.groovy.transform;
-
+package org.codehaus.groovy.transform
 
 import groovy.transform.ConditionalInterrupt
-import org.codehaus.groovy.control.CompilePhase
 import org.codehaus.groovy.ast.*
 import org.codehaus.groovy.ast.expr.*
+import org.codehaus.groovy.control.CompilePhase
 
 /**
  * Allows "interrupt-safe" executions of scripts by adding a custom conditional
@@ -27,124 +26,126 @@ import org.codehaus.groovy.ast.expr.*
  * statement on the beginning of method calls.
  *
  * @see groovy.transform.ConditionalInterrupt
- *
  * @author Cedric Champeau
  * @author Hamlet D'Arcy
- *
+ * @author Paul King
  * @since 1.8.0
  */
 @GroovyASTTransformation(phase = CompilePhase.CANONICALIZATION)
 public class ConditionalInterruptibleASTTransformation extends AbstractInterruptibleASTTransformation {
 
-    private static final ClassNode MY_TYPE = ClassHelper.make(ConditionalInterrupt)
-    private static final String CONDITION_METHOD = 'conditionalTransform$condition';
-
-    private ClosureExpression conditionNode
-    private MethodCallExpression conditionCallExpression
-    private ClassNode currentClass
-
-    protected ClassNode type() {
-        return MY_TYPE;
+  private static final ClassNode MY_TYPE = ClassHelper.make(ConditionalInterrupt)
+
+  private ClosureExpression conditionNode
+  private String conditionMethod
+  private MethodCallExpression conditionCallExpression
+  private ClassNode currentClass
+
+  protected ClassNode type() {
+    return MY_TYPE
+  }
+
+  protected void setupTransform(AnnotationNode node) {
+    super.setupTransform(node)
+    def member = node.getMember("value")
+    if (!member || !(member instanceof ClosureExpression)) internalError("Expected closure value for annotation parameter 'value'. Found $member")
+    conditionNode = member;
+    conditionMethod = 'conditionalTransform' + node.hashCode() + '$condition'
+    conditionCallExpression = new MethodCallExpression(new VariableExpression('this'), conditionMethod, new ArgumentListExpression())
+  }
+
+  protected String getErrorMessage() {
+    'Execution interrupted. The following condition failed: ' + convertClosureToSource(conditionNode)
+  }
+
+  void visitClass(ClassNode type) {
+    currentClass = type
+    def method = type.addMethod(conditionMethod, ACC_PRIVATE | ACC_SYNTHETIC, ClassHelper.OBJECT_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, conditionNode.code)
+    method.synthetic = true
+    if (applyToAllMembers) {
+      super.visitClass(type)
     }
-
-    protected void setupTransform(AnnotationNode node) {
-        super.setupTransform(node)
-        def member = node.getMember("value")
-        if (!member || !(member instanceof ClosureExpression)) internalError("Expected closure value for annotation parameter 'value'. Found $member")
-        conditionNode = member;
-        conditionCallExpression = new MethodCallExpression(new VariableExpression('this'), CONDITION_METHOD, new ArgumentListExpression())
-    }
-
-    protected String getErrorMessage() {
-        'Execution interrupted. The following condition failed: ' + convertClosureToSource(conditionNode)
+  }
+
+  protected Expression createCondition() {
+    conditionCallExpression
+  }
+
+  @Override
+  void visitAnnotations(AnnotatedNode node) {
+    // this transformation does not apply on annotation nodes
+    // visiting could lead to stack overflows
+  }
+
+  @Override
+  void visitField(FieldNode node) {
+    if (!node.isStatic() && !node.isSynthetic()) {
+      super.visitField node
     }
+  }
 
-    public void visitClass(ClassNode type) {
-        currentClass = type;
-        def method = type.addMethod(CONDITION_METHOD, ACC_PRIVATE | ACC_SYNTHETIC, ClassHelper.OBJECT_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, conditionNode.code);
-        method.synthetic = true
-        super.visitClass(type);
+  @Override
+  void visitProperty(PropertyNode node) {
+    if (!node.isStatic() && !node.isSynthetic()) {
+      super.visitProperty node
     }
-
-    protected Expression createCondition() {
-        conditionCallExpression
-    }
-
-    @Override
-    public void visitAnnotations(AnnotatedNode node) {
-        // this transformation does not apply on annotation nodes
-        // visiting could lead to stack overflows
-    }
-
-    @Override
-    void visitField(FieldNode node) {
-      if (!node.isStatic() && !node.isSynthetic()) {
-        super.visitField node
-      }
-    }
-
-    @Override
-    void visitProperty(PropertyNode node) {
-      if (!node.isStatic() && !node.isSynthetic()) {
-        super.visitProperty node
+  }
+
+  @Override
+  void visitClosureExpression(ClosureExpression closureExpr) {
+    if (closureExpr == conditionNode) return // do not visit the closure from the annotation itself
+    def code = closureExpr.code
+    closureExpr.code = wrapBlock(code)
+    super.visitClosureExpression closureExpr
+  }
+
+  @Override
+  void visitMethod(MethodNode node) {
+    if (node.name == conditionMethod && !node.isSynthetic()) return // do not visit the generated method
+    if (node.name == 'run' && currentClass.isScript() && node.parameters.length == 0) {
+      // the run() method should not have the statement added, otherwise the script binding won't be set before
+      // the condition is actually tested
+      super.visitMethod(node)
+    } else {
+      if (checkOnMethodStart && !node.isSynthetic() && !node.isStatic() && !node.isAbstract()) {
+        def code = node.code
+        node.code = wrapBlock(code);
       }
+      if (!node.isSynthetic() && !node.isStatic()) super.visitMethod(node)
     }
-
-    @Override
-    public void visitClosureExpression(ClosureExpression closureExpr) {
-        if (closureExpr == conditionNode) return // no not visit the closure from the annotation itself
-        def code = closureExpr.code
-        closureExpr.code = wrapBlock(code)
-        super.visitClosureExpression closureExpr
-    }
-
-    @Override
-    public void visitMethod(MethodNode node) {
-        if (node.name == CONDITION_METHOD && !node.isSynthetic()) return // do not visit the generated method
-        if (node.name == 'run' && currentClass.isScript() && node.parameters.length == 0) {
-            // the run() method should not have the statement added, otherwise the script binding won't be set before
-            // the condition is actually tested
-            super.visitMethod(node)
-        } else {
-            if (checkOnMethodStart && !node.isSynthetic() && !node.isStatic() && !node.isAbstract()) {
-                def code = node.code
-                node.code = wrapBlock(code);
-            }
-            if (!node.isSynthetic() && !node.isStatic()) super.visitMethod(node)
+  }
+
+  /**
+   * Converts a ClosureExpression into the String source.
+   * @param expression a closure
+   * @return the source the closure was created from
+   */
+  // TODO should this be moved to ClosureExpression? It also appears in AstBuilderTransformation
+  private String convertClosureToSource(ClosureExpression expression) {
+    if (expression == null) throw new IllegalArgumentException('Null: expression')
+
+    def lineRange = (expression.lineNumber..expression.lastLineNumber)
+
+    def source = lineRange.collect {
+      def line = source.source.getLine(it, null)
+      if (line == null) {
+        return "Error calculating source code for expression. Trying to read line $it from ${source.source.class}"
+      } else {
+        if (it == expression.lastLineNumber) {
+          line = line.substring(0, expression.lastColumnNumber - 1)
         }
-    }
-
-    /**
-     * Converts a ClosureExpression into the String source.
-     * @param expression    a closure
-     * @return              the source the closure was created from
-     */
-    // TODO should this be moved to ClosureExpression? It also appers in AstBuilderTransformation
-    private String convertClosureToSource(ClosureExpression expression) {
-        if (expression == null) throw new IllegalArgumentException('Null: expression')
-
-        def lineRange = (expression.lineNumber..expression.lastLineNumber)
-
-        def source = lineRange.collect {
-            def line = source.source.getLine(it, null)
-            if (line == null) {
-                return "Error calculating source code for expression. Trying to read line $it from ${source.source.class}"
-            } else {
-                if (it == expression.lastLineNumber) {
-                    line = line.substring(0, expression.lastColumnNumber - 1)
-                }
-                if (it == expression.lineNumber) {
-                    line = line.substring(expression.columnNumber - 1)
-                }
-            }
-            return line
-        }?.join('\n')?.trim()   //restoring line breaks is important b/c of lack of semicolons
-
-        if (!source.startsWith('{')) {
-            return 'Error converting ClosureExpression into source code. ' +
-                    "Closures must start with {. Found: $source"
+        if (it == expression.lineNumber) {
+          line = line.substring(expression.columnNumber - 1)
         }
+      }
+      return line
+    }?.join('\n')?.trim()   //restoring line breaks is important b/c of lack of semicolons
 
-        return source
+    if (!source.startsWith('{')) {
+      return 'Error converting ClosureExpression into source code. ' +
+          "Closures must start with {. Found: $source"
     }
+
+    return source
+  }
 }
diff --git a/src/test/groovy/GroovyMethodsTest.groovy b/src/test/groovy/GroovyMethodsTest.groovy
index 20b76997e6..bc3f0263f1 100644
--- a/src/test/groovy/GroovyMethodsTest.groovy
+++ b/src/test/groovy/GroovyMethodsTest.groovy
@@ -539,10 +539,10 @@ class GroovyMethodsTest extends GroovyTestCase {
 
     void testObjectSleep() {
         long start = System.currentTimeMillis()
-        long sleeptime = 200
+        long sleeptime = 500
         sleep sleeptime
         long slept = System.currentTimeMillis() - start
-        long epsilon = 24
+        long epsilon = 50
         assert (slept > sleeptime - epsilon) && (slept < sleeptime + epsilon):   \
                "should have slept for $sleeptime ms (+/- epsilon ms) but was $slept ms"
     }
diff --git a/src/test/groovy/transform/ConditionalInterruptTest.groovy b/src/test/groovy/transform/ConditionalInterruptTest.groovy
index 1d16053548..37ef62610c 100644
--- a/src/test/groovy/transform/ConditionalInterruptTest.groovy
+++ b/src/test/groovy/transform/ConditionalInterruptTest.groovy
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2010 the original author or authors.
+ * Copyright 2008-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -20,7 +20,7 @@ package groovy.transform
  */
 class ConditionalInterruptTest extends GroovyTestCase {
 
-    public void testMethodIsVisited_AndExceptionMessage() {
+    void testMethodIsVisited_AndExceptionMessage() {
 
         def c = new GroovyClassLoader().parseClass('''
             import groovy.transform.ConditionalInterrupt
@@ -39,7 +39,7 @@ class ConditionalInterruptTest extends GroovyTestCase {
         assert instance.visited
     }
 
-    public void testMethodIsVisited_AndCustomExceptionMessage() {
+    void testMethodIsVisited_AndCustomExceptionMessage() {
 
         def c = new GroovyClassLoader(this.class.classLoader).parseClass('''
             import groovy.transform.ConditionalInterrupt
@@ -58,9 +58,7 @@ class ConditionalInterruptTest extends GroovyTestCase {
         assert instance.visited
     }
 
-
-    public void testStaticMethodIsNotVisited() {
-
+    void testStaticMethodIsNotVisited() {
          def c = new GroovyClassLoader().parseClass('''
             import groovy.transform.ConditionalInterrupt
             @ConditionalInterrupt({ visited = true })
@@ -75,7 +73,7 @@ class ConditionalInterruptTest extends GroovyTestCase {
         assert !instance.visited
     }
 
-    public void testClosureFieldIsVisited() {
+    void testClosureFieldIsVisited() {
 
         def c = new GroovyClassLoader().parseClass('''
             import groovy.transform.ConditionalInterrupt
@@ -93,8 +91,7 @@ class ConditionalInterruptTest extends GroovyTestCase {
         assert instance.visited
     }
 
-    public void testWhileLoopVisited() {
-
+    void testWhileLoopVisited() {
         def c = new GroovyClassLoader().parseClass('''
             import groovy.transform.ConditionalInterrupt
             @ConditionalInterrupt({ count > 5 })
@@ -115,7 +112,7 @@ class ConditionalInterruptTest extends GroovyTestCase {
         assert 6 == instance.count
     }
 
-    public void testForLoopVisited() {
+    void testForLoopVisited() {
 
         def c = new GroovyClassLoader().parseClass('''
             import groovy.transform.ConditionalInterrupt
@@ -137,14 +134,14 @@ class ConditionalInterruptTest extends GroovyTestCase {
         assert 6 == instance.count
     }
 
-    public void testStaticClosureFieldNotVisited() {
+    void testStaticClosureFieldNotVisited() {
 
-         def c = new GroovyClassLoader().parseClass('''
+        def c = new GroovyClassLoader().parseClass('''
             import groovy.transform.ConditionalInterrupt
             @ConditionalInterrupt({ visited = true })
             class MyClass {
-              boolean visited = false
-              static def myMethod = { }
+                boolean visited = false
+                static def myMethod = { }
             }
         ''')
 
@@ -153,29 +150,29 @@ class ConditionalInterruptTest extends GroovyTestCase {
         assert !instance.visited
     }
 
-    public void testSharedContext() {
+    void testSharedContext() {
         def shell = new GroovyShell()
 
         def script = shell.parse('''
             import groovy.transform.ConditionalInterrupt
 
-class Helper {
-  static int i=0
-  static def shouldInterrupt() { i++>1 }
-}
+            class Helper {
+                static int i=0
+                static def shouldInterrupt() { i++>1 }
+            }
 
-@ConditionalInterrupt({ Helper.shouldInterrupt() })
-class MyClass {
-   def myMethod() { }
-}
+            @ConditionalInterrupt({ Helper.shouldInterrupt() })
+            class MyClass {
+                def myMethod() { }
+            }
 
-@ConditionalInterrupt({ Helper.shouldInterrupt() })
-class MyOtherClass {
-   def myOtherMethod() { new MyClass().myMethod() }
-}
+            @ConditionalInterrupt({ Helper.shouldInterrupt() })
+            class MyOtherClass {
+                def myOtherMethod() { new MyClass().myMethod() }
+            }
 
-new MyOtherClass().myOtherMethod()
-''', 'myScript')
+            new MyOtherClass().myOtherMethod()
+        ''', 'myScript')
         shouldFail(InterruptedException) {
             script.run()
         }
diff --git a/src/test/groovy/transform/ThreadInterruptTest.groovy b/src/test/groovy/transform/ThreadInterruptTest.groovy
index fe0790fe0a..fbaee0ce54 100644
--- a/src/test/groovy/transform/ThreadInterruptTest.groovy
+++ b/src/test/groovy/transform/ThreadInterruptTest.groovy
@@ -13,8 +13,7 @@ class ThreadInterruptTest extends GroovyTestCase {
         Thread.metaClass = null
     }
 
-
-    public void testDefaultParameters_Method() {
+    void testDefaultParameters_Method() {
 
         def c = new GroovyClassLoader().parseClass("""
             @groovy.transform.ThreadInterrupt
@@ -32,7 +31,7 @@ class ThreadInterruptTest extends GroovyTestCase {
         assert 1 == counter.interruptedCheckCount
     }
 
-    public void testNoMethodCheck_Method() {
+    void testNoMethodCheck_Method() {
 
         def c = new GroovyClassLoader().parseClass("""
             @groovy.transform.ThreadInterrupt(checkOnMethodStart = false)
@@ -49,7 +48,7 @@ class ThreadInterruptTest extends GroovyTestCase {
         // no exception means success
     }
 
-    public void testDefaultParameters_ForLoop() {
+    void testDefaultParameters_ForLoop() {
 
         def c = new GroovyClassLoader().parseClass("""
             @groovy.transform.ThreadInterrupt
@@ -71,7 +70,7 @@ class ThreadInterruptTest extends GroovyTestCase {
         assert 100 == counter.interruptedCheckCount
     }
 
-    public void testDefaultParameters_WhileLoop() {
+    void testDefaultParameters_WhileLoop() {
 
         def c = new GroovyClassLoader().parseClass("""
             @groovy.transform.ThreadInterrupt
@@ -94,7 +93,7 @@ class ThreadInterruptTest extends GroovyTestCase {
         assert 100 == counter.interruptedCheckCount
     }
 
-    public void testDefaultParameters_Closure() {
+    void testDefaultParameters_Closure() {
 
         def c = new GroovyClassLoader().parseClass("""
             @groovy.transform.ThreadInterrupt
@@ -116,7 +115,7 @@ class ThreadInterruptTest extends GroovyTestCase {
         assert 100 == counter.interruptedCheckCount
     }
 
-    public void testInterrupt_Method_AndTestExceptionMessage() {
+    void testInterrupt_Method_AndTestExceptionMessage() {
 
         def c = new GroovyClassLoader().parseClass("""
             @groovy.transform.ThreadInterrupt
@@ -133,7 +132,7 @@ class ThreadInterruptTest extends GroovyTestCase {
         }
     }
 
-    public void testInterrupt_ForLoop() {
+    void testInterrupt_ForLoop() {
 
         def c = new GroovyClassLoader().parseClass("""
             @groovy.transform.ThreadInterrupt
@@ -153,7 +152,7 @@ class ThreadInterruptTest extends GroovyTestCase {
         }
     }
 
-    public void testInterrupt_WhileLoop() {
+    void testInterrupt_WhileLoop() {
 
         def c = new GroovyClassLoader().parseClass("""
             @groovy.transform.ThreadInterrupt
@@ -174,7 +173,7 @@ class ThreadInterruptTest extends GroovyTestCase {
         }
     }
 
-    public void testInterrupt_Closure() {
+    void testInterrupt_Closure() {
 
         def c = new GroovyClassLoader().parseClass("""
             @groovy.transform.ThreadInterrupt
@@ -194,7 +193,7 @@ class ThreadInterruptTest extends GroovyTestCase {
         }
     }
 
-    public void testInterrupt_ClosureWithCustomExceptionType() {
+    void testInterrupt_ClosureWithCustomExceptionType() {
 
         def c = new GroovyClassLoader(this.class.classLoader).parseClass("""
             @groovy.transform.ThreadInterrupt(thrown=groovy.transform.CustomException)
@@ -214,7 +213,7 @@ class ThreadInterruptTest extends GroovyTestCase {
         }
     }
 
-    public void testEntireCompileUnitIsAffected() {
+    void testEntireCompileUnitIsAffected() {
 
         def script = '''
             def scriptMethod() {
@@ -241,7 +240,7 @@ class ThreadInterruptTest extends GroovyTestCase {
         assert 3 == counter.interruptedCheckCount
     }
 
-    public void testOnlyScriptAffected() {
+    void testOnlyScriptAffected() {
 
         def script = '''
             @groovy.transform.ThreadInterrupt(applyToAllClasses = false)
@@ -267,7 +266,7 @@ class ThreadInterruptTest extends GroovyTestCase {
         assert 2 == counter.interruptedCheckCount
     }
 
-    public void testAnnotationOnImport() {
+    void testAnnotationOnImport() {
 
         def script = '''
             @groovy.transform.ThreadInterrupt
@@ -287,7 +286,7 @@ class ThreadInterruptTest extends GroovyTestCase {
         assert 4 == counter.interruptedCheckCount
     }
 
-    public void testOnlyClassAffected() {
+    void testOnlyClassAffected() {
 
         def script = '''
             def scriptMethod() {
@@ -313,7 +312,7 @@ class ThreadInterruptTest extends GroovyTestCase {
         assert 1 == counter.interruptedCheckCount
     }
 
-    public void testThreadInterruptOnAbstractClass() {
+    void testThreadInterruptOnAbstractClass() {
         def script = '''
             @groovy.transform.ThreadInterrupt
             abstract class MyAbstractClass {
@@ -354,12 +353,10 @@ class CountingThread extends Thread {
         interruptedCheckCount++
         false
     }
-
 }
 
 class CustomException extends Exception {
-
-    public CustomException(final String message) {
+    CustomException(final String message) {
         super(message)
     }
 }
\ No newline at end of file
