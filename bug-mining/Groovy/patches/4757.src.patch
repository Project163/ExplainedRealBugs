diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 2cfb9d3889..4f4024f862 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -1523,31 +1523,30 @@ out:    if ((samParameterTypes.length == 1 && isOrImplements(samParameterTypes[0
         enclosingTypes.addAll(enclosingTypes.iterator().next().getOuterClasses());
 
         boolean staticOnlyAccess = isClassClassNodeWrappingConcreteType(objectExpressionType);
-        if (staticOnlyAccess && "this".equals(propertyName)) {
-            // handle "Outer.this" for any level of nesting
-            ClassNode outer = objectExpressionType.getGenericsTypes()[0].getType();
-
-            ClassNode found = null;
-            for (ClassNode enclosingType : enclosingTypes) {
-                if (!enclosingType.isStaticClass() && outer.equals(enclosingType.getOuterClass())) {
-                    found = enclosingType;
-                    break;
+        if (staticOnlyAccess) {
+            if ("this".equals(propertyName)) {
+                // handle "Outer.this" for any level of nesting
+                ClassNode outer = objectExpressionType.getGenericsTypes()[0].getType();
+
+                ClassNode found = null;
+                for (ClassNode enclosingType : enclosingTypes) {
+                    if (!enclosingType.isStaticClass() && outer.equals(enclosingType.getOuterClass())) {
+                        found = enclosingType;
+                        break;
+                    }
+                }
+                if (found != null) {
+                    storeType(pexp, outer);
+                    return true;
+                }
+            } else if ("super".equals(propertyName)) {
+                // GROOVY-8299: handle "Iface.super" for interface default methods
+                ClassNode enclosingType = typeCheckingContext.getEnclosingClassNode();
+                ClassNode accessor = objectExpressionType.getGenericsTypes()[0].getType();
+                if (accessor.isInterface() && enclosingType.implementsInterface(accessor)) {
+                    storeType(pexp, accessor);
+                    return true;
                 }
-            }
-            if (found != null) {
-                storeType(pexp, outer);
-                return true;
-            }
-        }
-
-        if (staticOnlyAccess && "super".equals(propertyName)) {
-            // handle "I.super" for default interface logic
-            ClassNode enclosingType = typeCheckingContext.getEnclosingClassNode();
-            ClassNode accessor = objectExpressionType.getGenericsTypes()[0].getType();
-            if (accessor.isInterface() && enclosingType.implementsInterface(accessor)) {
-                storeType(pexp, accessor);
-                return true;
-            } else {
                 return false;
             }
         }
@@ -3689,10 +3688,11 @@ out:                if (mn.size() != 1) {
                         if (!targetMethod.isStatic() && !(isClassType(declaringClass) || isObjectType(declaringClass)) // GROOVY-10939: Class or Object
                                 && isClassType(receiver) && chosenReceiver.getData() == null && !Boolean.TRUE.equals(call.getNodeMetaData(DYNAMIC_RESOLUTION))) {
                             addStaticTypeError("Non-static method " + prettyPrintTypeName(declaringClass) + "#" + targetMethod.getName() + " cannot be called from static context", call);
-                        } else if ((chosenReceiver.getType().isInterface() || targetMethod.isAbstract()) && isSuperExpression(objectExpression)) { // GROOVY-10341, GROOVY-8299
+                        } else if ((chosenReceiver.getType().isInterface() || targetMethod.isAbstract()) && isSuperExpression(objectExpression)) { // GROOVY-8299, GROOVY-10341
                             String target = toMethodParametersString(targetMethod.getName(), extractTypesFromParameters(targetMethod.getParameters()));
-                            if (Traits.hasDefaultImplementation(targetMethod) || targetMethod.isDefault()) { // GROOVY-10494
-                                addStaticTypeError("Default method " + target + " requires qualified super", call);
+                            if (targetMethod.isDefault() || Traits.hasDefaultImplementation(targetMethod)) { // GROOVY-10494
+                                if (objectExpression instanceof VariableExpression)
+                                  addStaticTypeError("Default method " + target + " requires qualified super", call);
                             } else {
                                 addStaticTypeError("Abstract method " + target + " cannot be called directly", call);
                             }
@@ -5239,6 +5239,10 @@ out:                if (mn.size() != 1) {
     }
 
     protected static boolean isSuperExpression(final Expression expression) {
+        if (expression instanceof PropertyExpression) { // GROOVY-11256
+            return "super".equals(((PropertyExpression) expression).getPropertyAsString())
+                && ((PropertyExpression) expression).getObjectExpression() instanceof ClassExpression;
+        }
         return expression instanceof VariableExpression && ((VariableExpression) expression).isSuperExpression();
     }
 
diff --git a/src/test/groovy/lang/DefaultInterfaceMethodsTest.groovy b/src/test/groovy/lang/DefaultInterfaceMethodsTest.groovy
index bc833b8069..82e3ab4ea3 100644
--- a/src/test/groovy/lang/DefaultInterfaceMethodsTest.groovy
+++ b/src/test/groovy/lang/DefaultInterfaceMethodsTest.groovy
@@ -18,37 +18,44 @@
  */
 package groovy.lang
 
-import groovy.test.GroovyTestCase
+import org.junit.Test
 
-/**
- * Test for the BenchmarkInterceptor
- */
-class DefaultInterfaceMethodsTest extends GroovyTestCase {
+import static groovy.test.GroovyAssert.assertScript
+
+final class DefaultInterfaceMethodsTest {
 
-    void testSimpleDeclarationAndCall() {
+    @Test
+    void testDefaultMethod() {
         assertScript '''
-            public interface InterfaceWithDefault {
-                default String hello() {
+            interface I {
+                default String m() {
                     return 'Hello'
                 }
             }
-            class UseDefault implements InterfaceWithDefault {}
-            assert new UseDefault().hello() == 'Hello'
+
+            class C implements I {
+            }
+
+            assert new C().m() == 'Hello'
         '''
     }
-    void testSimpleDeclarationAndOverride() {
+
+    @Test
+    void testDefaultMethodOverride() {
         assertScript '''
-            public interface InterfaceWithDefault {
-                default String hello() {
+            interface I {
+                default String m() {
                     return 'Hello'
                 }
             }
-            class OverrideDefault implements InterfaceWithDefault {
-                public String hello() {
+
+            class C implements I {
+                @Override String m() {
                     return 'Bon jour'
                 }
             }
-            assert new OverrideDefault().hello() == 'Bon jour'
+
+            assert new C().m() == 'Bon jour'
         '''
     }
 }
diff --git a/src/test/groovy/transform/stc/BugsSTCTest.groovy b/src/test/groovy/transform/stc/BugsSTCTest.groovy
index 137092e46c..38797c69c4 100644
--- a/src/test/groovy/transform/stc/BugsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/BugsSTCTest.groovy
@@ -1154,9 +1154,9 @@ class BugsSTCTest extends StaticTypeCheckingTestCase {
         '''
     }
 
-    // GROOVY-9909 tests changed for GROOVY-8299
+    // GROOVY-8299, GROOVY-9909
     void testInvokeDefaultMethodFromDirectInterface() {
-        shouldFailWithMessages('''
+        shouldFailWithMessages '''
             class C implements groovy.transform.stc.Groovy9909 {
                 @Override String m() {
                     'it ' + super.m() // default method
@@ -1164,7 +1164,25 @@ class BugsSTCTest extends StaticTypeCheckingTestCase {
             }
             String result = new C().m()
             assert result == 'it works'
-        ''',  "Default method m() requires qualified super")
+        ''',
+        'Default method m() requires qualified super'
+    }
+
+    // GROOVY-8299, GROOVY-11256
+    void testInvokeAbstractFromDirectInterface() {
+        shouldFailWithMessages '''
+            interface I {
+                def m()
+            }
+
+            class C implements I {
+                @Override m() {}
+                void test() {
+                    I.super.m()
+                }
+            }
+        ''',
+        'Abstract method m() cannot be called directly'
     }
 
     // GROOVY-8339, GROOVY-10109, GROOVY-10594
