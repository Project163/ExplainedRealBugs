diff --git a/src/main/java/org/codehaus/groovy/transform/stc/TraitTypeCheckingExtension.java b/src/main/java/org/codehaus/groovy/transform/stc/TraitTypeCheckingExtension.java
index 87a9483cb9..cb0e316409 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/TraitTypeCheckingExtension.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/TraitTypeCheckingExtension.java
@@ -25,125 +25,72 @@ import org.codehaus.groovy.ast.Parameter;
 import org.codehaus.groovy.ast.expr.ArgumentListExpression;
 import org.codehaus.groovy.ast.expr.MethodCall;
 import org.codehaus.groovy.ast.expr.MethodCallExpression;
-import org.codehaus.groovy.ast.expr.VariableExpression;
 import org.codehaus.groovy.transform.trait.TraitASTTransformation;
 import org.codehaus.groovy.transform.trait.Traits;
 
-import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collections;
-import java.util.LinkedHashSet;
 import java.util.List;
 
 import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.isClassClassNodeWrappingConcreteType;
 
 /**
- * A type checking extension that will take care of handling errors which are specific to traits. In particular, it will
- * handle the "super" method calls within a trait.
+ * An extension that handles field, super and static method calls within a trait.
  *
  * @since 2.3.0
  */
 public class TraitTypeCheckingExtension extends AbstractTypeCheckingExtension {
-    private static final List<MethodNode> NOTFOUND = Collections.emptyList();
 
-    /**
-     * Builds a type checking extension relying on a Groovy script (type checking DSL).
-     *
-     * @param typeCheckingVisitor the type checking visitor
-     */
     public TraitTypeCheckingExtension(final StaticTypeCheckingVisitor typeCheckingVisitor) {
         super(typeCheckingVisitor);
     }
 
-    @Override
-    public void setup() {
-    }
-
     @Override
     public List<MethodNode> handleMissingMethod(final ClassNode receiver, final String name, final ArgumentListExpression argumentList, final ClassNode[] argumentTypes, final MethodCall call) {
         String[] decomposed = Traits.decomposeSuperCallName(name);
         if (decomposed != null) {
-            return convertToDynamicCall(call, receiver, decomposed, argumentTypes);
-        }
-        if (call instanceof MethodCallExpression) {
-            MethodCallExpression mce = (MethodCallExpression) call;
-            if (mce.getReceiver() instanceof VariableExpression) {
-                VariableExpression var = (VariableExpression) mce.getReceiver();
+            String traitName = decomposed[0], methodName = decomposed[1];
+            List<ClassNode> implementedTraits = Traits.findTraits(receiver);
 
-                // GROOVY-7322
-                // static method call in trait?
-                ClassNode type = null;
-                if (isStaticTraitReceiver(receiver, var)) {
-                    type = receiver.getGenericsTypes()[0].getType();
-                } else if (isThisTraitReceiver(var)) {
-                    type = receiver;
-                }
-                if (Traits.isTrait(type) && !(type instanceof UnionTypeClassNode)) {
-                    List<ClassNode> candidates = new ArrayList<ClassNode>();
-                    candidates.add(type);
-                    while (!candidates.isEmpty()) {
-                        ClassNode next = candidates.remove(0);
-                        if (!Traits.isTrait(next)) continue;
-                        ClassNode helper = Traits.findHelper(next);
-                        Parameter[] params = new Parameter[argumentTypes.length + 1];
-                        params[0] = new Parameter(ClassHelper.CLASS_Type.getPlainNodeReference(), "staticSelf");
-                        for (int i = 1; i < params.length; i++) {
-                            params[i] = new Parameter(argumentTypes[i-1], "p" + i);
-                        }
-                        MethodNode method = helper.getDeclaredMethod(name, params);
-                        if (method != null) {
-                            return Collections.singletonList(makeDynamic(call, method.getReturnType()));
-                        }
-                        // GROOVY-8272 support inherited static methods
-                        candidates.addAll(Arrays.asList(next.getInterfaces()));
-                    }
+            ClassNode nextTrait = null;
+            for (int i = 0; i < implementedTraits.size() - 1; i += 1) {
+                ClassNode implementedTrait = implementedTraits.get(i);
+                if (implementedTrait.getName().equals(traitName)) {
+                    nextTrait = implementedTraits.get(i + 1);
                 }
             }
 
-            ClassNode dynamic = mce.getNodeMetaData(TraitASTTransformation.DO_DYNAMIC);
-            if (dynamic!=null) {
-                return Collections.singletonList(makeDynamic(call, dynamic));
+            ClassNode returnType = ClassHelper.OBJECT_TYPE;
+            if (nextTrait != null) {
+                List<MethodNode> candidates = typeCheckingVisitor.findMethod(nextTrait, methodName, argumentTypes);
+                if (candidates.size() == 1) {
+                    returnType = candidates.get(0).getReturnType();
+                }
             }
+
+            return Collections.singletonList(makeDynamic(call, returnType));
         }
-        return NOTFOUND;
-    }
 
-    private static boolean isStaticTraitReceiver(final ClassNode receiver, final VariableExpression var) {
-        return Traits.STATIC_THIS_OBJECT.equals(var.getName()) && isClassClassNodeWrappingConcreteType(receiver);
-    }
+        if (call instanceof MethodCallExpression) {
+            MethodCallExpression mce = (MethodCallExpression) call;
+            ClassNode dynamic = mce.getNodeMetaData(TraitASTTransformation.DO_DYNAMIC);
+            if (dynamic != null) return Collections.singletonList(makeDynamic(call, dynamic));
 
-    private static boolean isThisTraitReceiver(final VariableExpression var) {
-        return Traits.THIS_OBJECT.equals(var.getName());
-    }
+            // GROOVY-7322, GROOVY-8272, GROOVY-8587, GROOVY-8854: trait: this.m($static$self)
+            ClassNode targetClass = isClassClassNodeWrappingConcreteType(receiver)? receiver.getGenericsTypes()[0].getType(): receiver;
+            if (Traits.isTrait(targetClass.getOuterClass()) && argumentTypes.length > 0 && ClassHelper.isClassType(argumentTypes[0])) {
+                Parameter[] signature = java.util.Arrays.stream(argumentTypes).map(t -> new Parameter(t,"")).toArray(Parameter[]::new);
+                List<ClassNode> traits = Traits.findTraits(targetClass.getOuterClass());
+                traits.remove(targetClass.getOuterClass());
 
-    private List<MethodNode> convertToDynamicCall(MethodCall call, ClassNode receiver, String[] decomposed, ClassNode[] argumentTypes) {
-        String traitName = decomposed[0];
-        String name = decomposed[1];
-        LinkedHashSet<ClassNode> traitsAsList = Traits.collectAllInterfacesReverseOrder(receiver, new LinkedHashSet<ClassNode>());
-        ClassNode[] implementedTraits = traitsAsList.toArray(ClassNode.EMPTY_ARRAY);
-        ClassNode nextTrait = null;
-        for (int i = 0; i < implementedTraits.length - 1; i++) {
-            ClassNode implementedTrait = implementedTraits[i];
-            if (implementedTrait.getName().equals(traitName)) {
-                nextTrait = implementedTraits[i + 1];
+                for (ClassNode trait : traits) { // check super trait for static method
+                    MethodNode method = Traits.findHelper(trait).getDeclaredMethod(name, signature);
+                    if (method != null && method.isStatic()) {
+                        return Collections.singletonList(makeDynamic(call, method.getReturnType()));
+                    }
+                }
             }
         }
-        ClassNode[] newArgs = new ClassNode[argumentTypes.length];
-        System.arraycopy(argumentTypes, 0, newArgs, 0, newArgs.length);
-        ClassNode inferredReturnType = inferTraitMethodReturnType(nextTrait, name, newArgs);
-
-        return Collections.singletonList(makeDynamic(call, inferredReturnType));
-    }
 
-    private ClassNode inferTraitMethodReturnType(ClassNode nextTrait, String methodName, ClassNode[] paramTypes) {
-        ClassNode result = ClassHelper.OBJECT_TYPE;
-        if (nextTrait != null) {
-            List<MethodNode> candidates = typeCheckingVisitor.findMethod(nextTrait, methodName, paramTypes);
-            if (candidates.size() == 1) {
-                result = candidates.get(0).getReturnType();
-            }
-        }
-        return result;
+        return Collections.emptyList();
     }
-
 }
diff --git a/src/main/java/org/codehaus/groovy/transform/trait/TraitASTTransformation.java b/src/main/java/org/codehaus/groovy/transform/trait/TraitASTTransformation.java
index 7ac0461f46..f91c57e6d2 100644
--- a/src/main/java/org/codehaus/groovy/transform/trait/TraitASTTransformation.java
+++ b/src/main/java/org/codehaus/groovy/transform/trait/TraitASTTransformation.java
@@ -620,36 +620,36 @@ public class TraitASTTransformation extends AbstractASTTransformation implements
     }
 
     private MethodNode processMethod(final ClassNode traitClass, final ClassNode traitHelperClass, final MethodNode methodNode, final ClassNode fieldHelper, final Collection<String> knownFields) {
-        Parameter[] initialParams = methodNode.getParameters();
-        Parameter[] newParams = new Parameter[initialParams.length + 1];
-        newParams[0] = createSelfParameter(traitClass, methodNode.isStatic());
-        System.arraycopy(initialParams, 0, newParams, 1, initialParams.length);
-        final int mod = methodNode.isPrivate() ? ACC_PRIVATE : ACC_PUBLIC | (methodNode.isFinal() ? ACC_FINAL : 0);
+        Parameter[] methodParams = methodNode.getParameters();
+        Parameter[] helperParams = new Parameter[methodParams.length + 1];
+        helperParams[0] = createSelfParameter(traitClass,methodNode.isStatic());
+        System.arraycopy(methodParams, 0, helperParams, 1, methodParams.length);
+
         MethodNode mNode = new MethodNode(
                 methodNode.getName(),
-                mod | ACC_STATIC,
+                (methodNode.isPrivate() ? ACC_PRIVATE : ACC_PUBLIC) | (methodNode.isFinal() ? ACC_FINAL : 0) | ACC_STATIC,
                 methodNode.getReturnType(),
-                newParams,
+                helperParams,
                 methodNode.getExceptions(),
-                processBody(varX(newParams[0]), methodNode.getCode(), traitClass, traitHelperClass, fieldHelper, knownFields)
+                processBody(varX(helperParams[0]), methodNode.getCode(), traitClass, traitHelperClass, fieldHelper, knownFields)
         );
         for (AnnotationNode annotation : methodNode.getAnnotations()) {
             if (!annotation.getClassNode().equals(OVERRIDE_TYPE)) {
                 mNode.addAnnotation(annotation);
             }
         }
+        mNode.setGenericsTypes(methodNode.getGenericsTypes());
+        mNode.setSourcePosition(methodNode);
         if (methodNode.isAbstract()) {
             mNode.setModifiers(ACC_PUBLIC | ACC_ABSTRACT);
         } else {
             methodNode.addAnnotation(new AnnotationNode(Traits.IMPLEMENTED_CLASSNODE));
         }
-        mNode.setGenericsTypes(methodNode.getGenericsTypes());
-        mNode.setSourcePosition(methodNode);
-        methodNode.setCode(null);
-
         if (!methodNode.isPrivate() && !methodNode.isStatic()) {
             methodNode.setModifiers(ACC_PUBLIC | ACC_ABSTRACT);
         }
+        methodNode.setCode(null);
+
         return mNode;
     }
 
diff --git a/src/main/java/org/codehaus/groovy/transform/trait/TraitComposer.java b/src/main/java/org/codehaus/groovy/transform/trait/TraitComposer.java
index e13142502e..9520f59665 100644
--- a/src/main/java/org/codehaus/groovy/transform/trait/TraitComposer.java
+++ b/src/main/java/org/codehaus/groovy/transform/trait/TraitComposer.java
@@ -130,7 +130,7 @@ public abstract class TraitComposer {
         ClassNode staticFieldHelperClassNode = helpers.getStaticFieldHelper();
         Map<String, ClassNode> genericsSpec = GenericsUtils.createGenericsSpec(trait, GenericsUtils.createGenericsSpec(cNode));
 
-        for (MethodNode methodNode : helperClassNode.getAllDeclaredMethods()) {
+        for (MethodNode methodNode : helperClassNode.getMethods()) {
             String name = methodNode.getName();
             Parameter[] helperMethodParams = methodNode.getParameters();
             int nParams = helperMethodParams.length;
@@ -180,7 +180,7 @@ public abstract class TraitComposer {
             // implementation of methods
             List<MethodNode> declaredMethods = new LinkedList<>();
             int pos = 0; // keep direct getters at start but in declaration order
-            for (MethodNode declaredMethod : fieldHelperClassNode.getAllDeclaredMethods()) {
+            for (MethodNode declaredMethod : fieldHelperClassNode.getMethods()) {
                 if (declaredMethod.getName().endsWith(Traits.DIRECT_GETTER_SUFFIX)) {
                     declaredMethods.add(pos++, declaredMethod);
                 } else {
@@ -189,7 +189,7 @@ public abstract class TraitComposer {
             }
 
             if (staticFieldHelperClassNode != null) {
-                for (MethodNode declaredMethod : staticFieldHelperClassNode.getAllDeclaredMethods()) {
+                for (MethodNode declaredMethod : staticFieldHelperClassNode.getMethods()) {
                     if (declaredMethod.getName().endsWith(Traits.DIRECT_GETTER_SUFFIX)) {
                         declaredMethods.add(pos++, declaredMethod);
                     } else {
diff --git a/src/main/java/org/codehaus/groovy/transform/trait/TraitReceiverTransformer.java b/src/main/java/org/codehaus/groovy/transform/trait/TraitReceiverTransformer.java
index 51efa1e7ca..3e91cb7261 100644
--- a/src/main/java/org/codehaus/groovy/transform/trait/TraitReceiverTransformer.java
+++ b/src/main/java/org/codehaus/groovy/transform/trait/TraitReceiverTransformer.java
@@ -45,7 +45,6 @@ import org.codehaus.groovy.syntax.SyntaxException;
 import org.codehaus.groovy.syntax.Token;
 import org.codehaus.groovy.syntax.Types;
 
-import java.lang.reflect.Modifier;
 import java.util.Collection;
 
 import static org.codehaus.groovy.ast.tools.GeneralUtils.args;
@@ -99,13 +98,28 @@ class TraitReceiverTransformer extends ClassCodeExpressionTransformer {
         ClassNode weavedType = weaved.getOriginType();
         if (exp instanceof BinaryExpression) {
             return transformBinaryExpression((BinaryExpression) exp, weavedType);
+        } else if (exp instanceof MethodCallExpression) {
+            MethodCallExpression mce = (MethodCallExpression) exp;
+            String obj = mce.getObjectExpression().getText();
+            if (mce.isImplicitThis() || "this".equals(obj)) {
+                return transformMethodCallOnThis(mce); // this.m(p) --> this.m($self, p)
+            } else if ("super".equals(obj)) {
+                return transformSuperMethodCall(mce); // super.m(p) --> $self.Ttrait$super$m(p)
+            }
         } else if (exp instanceof StaticMethodCallExpression) {
             StaticMethodCallExpression call = (StaticMethodCallExpression) exp;
             if (call.getOwnerType().equals(traitClass)) {
+                // GROOVY-7191, GROOVY-8272, GROOVY-8854, GROOVY-10312: T.m(p) --> this.m($static$self, p)
+                Expression staticSelf = varX(weaved);
+                if (!ClassHelper.isClassType(weavedType)) {
+                    staticSelf = callX(staticSelf, "getClass");
+                    ((MethodCallExpression) staticSelf).setImplicitThis(false);
+                    staticSelf = castX(ClassHelper.CLASS_Type.getPlainNodeReference(), staticSelf);
+                }
                 MethodCallExpression mce = callX(
-                        varX(weaved),
+                        varX("this"),
                         call.getMethod(),
-                        transform(call.getArguments())
+                        createArgumentList(staticSelf, call.getArguments())
                 );
                 mce.setSafe(false);
                 mce.setSpreadSafe(false);
@@ -113,14 +127,6 @@ class TraitReceiverTransformer extends ClassCodeExpressionTransformer {
                 mce.setSourcePosition(exp);
                 return mce;
             }
-        } else if (exp instanceof MethodCallExpression) {
-            MethodCallExpression mce = (MethodCallExpression) exp;
-            String obj = mce.getObjectExpression().getText();
-            if (mce.isImplicitThis() || "this".equals(obj)) {
-                return transformMethodCallOnThis(mce);
-            } else if ("super".equals(obj)) {
-                return transformSuperMethodCall(mce);
-            }
         } else if (exp instanceof FieldExpression) {
             FieldNode fn = ((FieldExpression) exp).getField();
             return transformFieldReference(exp, fn, fn.isStatic());
@@ -129,7 +135,7 @@ class TraitReceiverTransformer extends ClassCodeExpressionTransformer {
             Variable accessedVariable = vexp.getAccessedVariable();
             if (accessedVariable instanceof FieldNode || accessedVariable instanceof PropertyNode) {
                 if (knownFields.contains(vexp.getName())) {
-                    boolean isStatic = Modifier.isStatic(accessedVariable.getModifiers());
+                    boolean isStatic = accessedVariable.isStatic();
                     return transformFieldReference(exp, accessedVariable instanceof FieldNode
                             ? (FieldNode) accessedVariable : ((PropertyNode) accessedVariable).getField(), isStatic);
                 } else {
@@ -311,7 +317,7 @@ class TraitReceiverTransformer extends ClassCodeExpressionTransformer {
                         newCall.setImplicitThis(false);
                         newCall.setSafe(false);
                     } else {
-                        ArgumentListExpression newArgs = createArgumentList(methodNode.isStatic() ? asClass(varX("this")) : weaved, arguments);
+                        ArgumentListExpression newArgs = createArgumentList(methodNode.isStatic() ? asClass(thisExpr) : weaved, arguments);
                         newCall = callX(inClosure ? classX(traitHelperClass) : thisExpr, methodName, newArgs);
                         newCall.setImplicitThis(true);
                         newCall.setSafe(call.isSafe());
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7322Bug.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7322Bug.groovy
deleted file mode 100644
index 628b965930..0000000000
--- a/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7322Bug.groovy
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one
- *  or more contributor license agreements.  See the NOTICE file
- *  distributed with this work for additional information
- *  regarding copyright ownership.  The ASF licenses this file
- *  to you under the Apache License, Version 2.0 (the
- *  "License"); you may not use this file except in compliance
- *  with the License.  You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing,
- *  software distributed under the License is distributed on an
- *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- *  KIND, either express or implied.  See the License for the
- *  specific language governing permissions and limitations
- *  under the License.
- */
-
-
-
-
-package org.codehaus.groovy.classgen.asm.sc.bugs
-
-import groovy.transform.stc.StaticTypeCheckingTestCase
-import org.codehaus.groovy.classgen.asm.sc.StaticCompilationTestSupport
-
-class Groovy7322Bug extends StaticTypeCheckingTestCase implements StaticCompilationTestSupport {
-    void testCallStaticTraitMethodFromTraitItself() {
-        assertScript '''
-            trait SomeTrait {
-
-                static someMethod() {
-                    List theNames = getNames()
-                    theNames
-                }
-
-                static List getNames() {
-                    ['Jeff', 'Betsy', 'Jake', 'Zack']
-                }
-            }
-
-            class SomeClass implements SomeTrait {}
-            assert SomeClass.someMethod() == ['Jeff', 'Betsy', 'Jake', 'Zack']
-        '''
-    }
-
-    // GROOVY-7191
-    void testCallStaticMethodFromInstanceMethodInTrait() {
-        assertScript '''
-            trait SomeTrait {
-                static int someStaticMethod(){ 1 }
-
-                int someInstanceMethod() {
-                    someStaticMethod()
-                }
-            }
-            class SomeClass implements SomeTrait {}
-            def o = new SomeClass()
-            assert o.someInstanceMethod() == 1
-        '''
-    }
-
-}
diff --git a/src/test/org/codehaus/groovy/transform/traitx/Groovy7255Bug.groovy b/src/test/org/codehaus/groovy/transform/traitx/Groovy7255Bug.groovy
deleted file mode 100644
index 7984486bf7..0000000000
--- a/src/test/org/codehaus/groovy/transform/traitx/Groovy7255Bug.groovy
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one
- *  or more contributor license agreements.  See the NOTICE file
- *  distributed with this work for additional information
- *  regarding copyright ownership.  The ASF licenses this file
- *  to you under the Apache License, Version 2.0 (the
- *  "License"); you may not use this file except in compliance
- *  with the License.  You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing,
- *  software distributed under the License is distributed on an
- *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- *  KIND, either express or implied.  See the License for the
- *  specific language governing permissions and limitations
- *  under the License.
- */
-package org.codehaus.groovy.transform.traitx
-
-import groovy.test.GroovyTestCase
-
-class Groovy7255Bug extends GroovyTestCase {
-    void testShouldAllowSettingStaticFieldInTraitUsingCompileStatic() {
-        assertScript '''
-@groovy.transform.CompileStatic
-trait SomeTrait {
-    static List stuff = [1,2,3]
-
-    static void initStuff(List l) {
-        stuff = stuff + l
-    }
-}
-
-class A implements SomeTrait {}
-A.initStuff([4,5,6])
-assert A.stuff == [1,2,3,4,5,6]
-'''
-    }
-}
diff --git a/src/test/org/codehaus/groovy/transform/traitx/TraitASTTransformationTest.groovy b/src/test/org/codehaus/groovy/transform/traitx/TraitASTTransformationTest.groovy
index 771667e063..1bba90274c 100644
--- a/src/test/org/codehaus/groovy/transform/traitx/TraitASTTransformationTest.groovy
+++ b/src/test/org/codehaus/groovy/transform/traitx/TraitASTTransformationTest.groovy
@@ -1657,109 +1657,80 @@ final class TraitASTTransformationTest {
 
     @Test
     void testPrivateMethodInTrait() {
-        assertScript shell, '''
-            trait DoingSecretThings {
-                private String secret() { 'secret' }
-                String foo() { secret() }
-            }
-            class Foo implements DoingSecretThings {}
-            def foo = new Foo()
-            assert foo.foo() == 'secret'
-        '''
-    }
+        for (mode in ['','@TypeChecked','@CompileStatic']) {
+            assertScript shell, """
+                $mode
+                trait T {
+                    private String secret() { 'secret' }
+                    String foo() { secret() }
+                }
+                $mode
+                class C implements T {
+                }
 
-    @Test
-    void testPrivateMethodInTraitAccessingPrivateField() {
-        assertScript shell, '''
-            trait DoingSecretThings {
-                private int x = 0
-                private int secret() { x+=1; x }
-                int foo() { secret() }
-            }
-            class Foo implements DoingSecretThings {}
-            def foo = new Foo()
-            assert foo.foo() == 1
-        '''
+                def c = new C()
+                assert c.foo() == 'secret'
+            """
+        }
     }
 
     @Test
-    void testPrivateMethodInTraitWithCompileStatic() {
-        assertScript shell, '''
-            @CompileStatic
-            trait DoingSecretThings {
-                private String secret() { 'secret' }
-                String foo() { secret() }
-            }
-            class Foo implements DoingSecretThings {}
-            def foo = new Foo()
-            assert foo.foo() == 'secret'
-        '''
-    }
+    void testPrivateMethodInTraitAccessingPrivateField() {
+        for (mode in ['','@TypeChecked','@CompileStatic']) {
+            assertScript shell, """
+                $mode
+                trait T {
+                    private int x = 0
+                    private int secret() { x += 1 }
+                    int foo() { secret() }
+                }
+                $mode
+                class C implements T {
+                }
 
-    @Test
-    void testPrivateMethodInTraitAccessingPrivateFieldCompileStatic() {
-        assertScript shell, '''
-            @CompileStatic
-            trait DoingSecretThings {
-                private int x = 0
-                private int secret() { x+=1; x }
-                int foo() { secret() }
-            }
-            class Foo implements DoingSecretThings {}
-            def foo = new Foo()
-            assert foo.foo() == 1
-            assert foo.foo() == 2
-        '''
+                def c = new C()
+                assert c.foo() == 1
+                assert c.foo() == 2
+            """
+        }
     }
 
     @Test
-    void testNoShadowingPrivateMethodInTraitAccessingPrivateFieldCompileStatic() {
-        assertScript shell, '''
-            @CompileStatic
-            trait DoingSecretThings {
-                private int x = 0
-                private int secret() { x+=1; x }
-                int foo() { secret() }
-            }
-            class Foo implements DoingSecretThings {
-                int secret() { 666 }
-            }
-            def foo = new Foo()
-            assert foo.foo() == 1
-            assert foo.foo() == 2
-        '''
-    }
+    void testPrivateMethodInTraitAccessingPrivateFieldNoShadowing() {
+        for (mode in ['','@TypeChecked','@CompileStatic']) {
+            assertScript shell, """
+                $mode
+                trait T {
+                    private int x = 0
+                    private int secret() { x += 1 }
+                    int foo() { secret() }
+                }
+                $mode
+                class C implements T {
+                    int secret() { 666 }
+                }
 
-    @Test
-    void testNoShadowingPrivateMethodInTraitAccessingPrivateField() {
-        assertScript shell, '''
-            trait DoingSecretThings {
-                private int x = 0
-                private int secret() { x+=1; x }
-                int foo() { secret() }
-            }
-            class Foo implements DoingSecretThings {
-                int secret() { 666 }
-            }
-            def foo = new Foo()
-            assert foo.foo() == 1
-            assert foo.foo() == 2
-        '''
+                def c = new C()
+                assert c.foo() == 1
+                assert c.foo() == 2
+            """
+        }
     }
 
     @Test
     void testMixPrivatePublicMethodsOfSameName() {
         def err = shouldFail shell, '''
-            trait DoingSecretThings {
+            trait T {
                 private String secret(String s) { s.toUpperCase() }
                 String secret() { 'public' }
                 String foo() { secret('secret') }
             }
-            class Foo implements DoingSecretThings {}
-            def foo = new Foo()
-            assert foo.foo() == 'SECRET'
-        '''
+            class C implements T {
+            }
 
+            def c = new C()
+            assert c.foo() == 'SECRET'
+        '''
         assert err =~ 'Mixing private and public/protected methods of the same name causes multimethods to be disabled'
     }
 
@@ -1770,13 +1741,14 @@ final class TraitASTTransformationTest {
                 void foo() { println 'A' }
             }
             trait B extends A {
-               void bar() {  println 'B'  }
+                void bar() { println 'B' }
             }
-
             interface C extends B {
                void baz()
             }
-            abstract class D implements C {}
+            abstract class D implements C {
+            }
+
             def d = { println 'BAZ' } as D
             d.foo()
             d.bar()
@@ -1941,88 +1913,197 @@ final class TraitASTTransformationTest {
 
     @Test
     void testTraitStaticMethod() {
-        assertScript shell, '''
-            trait StaticProvider {
-                static String foo() { 'static method' }
-            }
-            class Foo implements StaticProvider {}
-            assert Foo.foo() == 'static method'
-        '''
+        for (mode in ['','@TypeChecked','@CompileStatic']) {
+            assertScript shell, """
+                $mode
+                trait T {
+                    static String foo() { 'static method' }
+                }
+                $mode
+                class C implements T {
+                }
+                $mode
+                class D extends C {
+                }
 
-        assertScript shell, '''
-            trait StaticProvider {
-                static String foo() { bar() }
-                static String bar() { 'static method' }
-            }
-            class Foo implements StaticProvider {}
-            assert Foo.foo() == 'static method'
-        '''
+                assert C.foo() == 'static method'
+                assert D.foo() == 'static method'
+                assert new C().foo() == 'static method'
+                assert new D().foo() == 'static method'
+            """
+
+            // GROOVY-7322
+            assertScript shell, """
+                $mode
+                trait T {
+                    static String bar() { 'static method' }
+                    static String foo() { bar() }
+                }
+                $mode
+                class C implements T {
+                }
+                $mode
+                class D extends C {
+                }
+
+                assert C.foo() == 'static method'
+                assert D.foo() == 'static method'
+                assert new C().foo() == 'static method'
+                assert new D().foo() == 'static method'
+            """
+
+            // GROOVY-7191
+            assertScript shell, """
+                $mode
+                trait T {
+                    static Number bar() { 1 }
+                           Number foo() { bar() }
+                }
+                $mode
+                class C implements T {
+                }
+                $mode
+                class D extends C {
+                }
+
+                assert new C().foo() == 1
+                assert new D().foo() == 1
+            """
+
+            // GROOVY-8854
+            assertScript shell, """
+                $mode
+                trait T {
+                    boolean passes
+                    void audit() {
+                        if (checkCondition()) {
+                            passes = true
+                        }
+                    }
+                    private static boolean checkCondition() {
+                        true
+                    }
+                }
+                $mode
+                class C implements T {
+                    String name
+                }
+                $mode
+                class D extends C {
+                }
+
+                def c = new C(name:'name')
+                c.audit(); assert c.passes
+
+                def d = new D(name:'name')
+                d.audit(); assert d.passes
+            """
+        }
     }
 
     @Test
     void testTraitStaticField() {
-        assertScript shell, '''
-            trait StaticFieldProvider {
-                public static int VAL = 123
-            }
-            class Foo implements StaticFieldProvider {}
-            assert Foo.StaticFieldProvider__VAL == 123
-        '''
+        for (mode in ['','@TypeChecked','@CompileStatic']) {
+            assertScript shell, """
+                $mode
+                trait T {
+                    public static int VAL = 123
+                }
+                $mode
+                class C implements T {
+                }
 
-        assertScript shell, '''
-            trait StaticFieldProvider {
-                public static int VAL = 123
-                public static void update(int x) { VAL = x }
-            }
-            class Foo implements StaticFieldProvider {}
-            assert Foo.StaticFieldProvider__VAL == 123
-            Foo.update(456)
-            assert Foo.StaticFieldProvider__VAL == 456
-        '''
+                assert C.T__VAL == 123
+            """
+
+            assertScript shell, """
+                $mode
+                trait T {
+                    public static int VAL = 123
+                    public static void update(int x) { VAL = x }
+                }
+                $mode
+                class C implements T {
+                }
+
+                assert C.T__VAL == 123
+                C.update(456)
+                assert C.T__VAL == 456
+            """
+        }
     }
 
     @Test
     void testTraitStaticProperty() {
-        assertScript shell, '''
-            trait StaticPropertyProvider {
-                static int VAL = 123
-                public static void update(int x) { VAL = x }
-            }
-            class Foo implements StaticPropertyProvider {
-            }
-            assert Foo.VAL == 123
-            Foo.update(456)
-            assert Foo.VAL == 456
-        '''
+        for (mode in ['','@TypeChecked','@CompileStatic']) {
+            assertScript shell, """
+                $mode
+                trait T {
+                    static int VAL = 123
+                    public static void update(int x) { VAL = x }
+                }
+                $mode
+                class C implements T {
+                }
 
-        assertScript shell, '''
-            trait T {
-                static p = 1
-            }
-            class C implements T {
-                static m() {
-                    setP(2)
-                    setP(getP() + 1)
-                    return getP()
+                assert C.VAL == 123
+                C.update(456)
+                assert C.VAL == 456
+            """
+
+            // GROOVY-7255
+            assertScript shell, """
+                $mode
+                trait T {
+                    static List stuff = [1,2,3]
+
+                    static initStuff(List list) {
+                        stuff = stuff + list
+                    }
+                }
+                $mode
+                class C implements T {
                 }
-            }
-            assert C.m() == 3
-        '''
 
-        // GROOVY-9678
-        assertScript shell, '''
-            trait T {
-                static p = 1
-            }
-            class C implements T {
-                static m() {
-                    p = 2
-                    p += 1
-                    return p
+                C.initStuff([4,5,6])
+                assert C.stuff == [1,2,3,4,5,6]
+            """
+
+            assertScript shell, """
+                $mode
+                trait T {
+                    static int p = 1
                 }
-            }
-            assert C.m() == 3
-        '''
+                $mode
+                class C implements T {
+                    static int m() {
+                        setP(2)
+                        setP(getP() + 1)
+                        return getP()
+                    }
+                }
+
+                assert C.m() == 3
+            """
+
+            // GROOVY-9678
+            assertScript shell, """
+                $mode
+                trait T {
+                    static int p = 1
+                }
+                $mode
+                class C implements T {
+                    static int m() {
+                        p = 2
+                        p += 1
+                        return p
+                    }
+                }
+
+                assert C.m() == 3
+            """
+        }
     }
 
     @Test
@@ -3235,27 +3316,30 @@ final class TraitASTTransformationTest {
     // GROOVY-8731
     @Test
     void testStaticMethodsIgnoredWhenExistingInstanceMethodsFound() {
-        assertScript shell, '''
-            trait StaticFooBarBaz {
-                static int foo() { 100 }
-                static int baz() { 200 }
-                static int bar() { 300 }
-            }
-
-            trait InstanceBar {
-                int bar() { -10 }
-            }
-
-            class FooBarBaz implements StaticFooBarBaz, InstanceBar {
-                int baz() { -20 }
-            }
+        for (mode in ['','@TypeChecked','@CompileStatic']) {
+            assertScript shell, """
+                $mode
+                trait StaticFooBarBaz {
+                    static int foo() { 100 }
+                    static int baz() { 200 }
+                    static int bar() { 300 }
+                }
+                $mode
+                trait InstanceBar {
+                    int bar() { -10 }
+                }
+                $mode
+                class FooBarBaz implements StaticFooBarBaz, InstanceBar {
+                    int baz() { -20 }
+                }
 
-            assert FooBarBaz.foo() == 100
-            new FooBarBaz().with {
-                assert bar() == -10
-                assert baz() == -20
-            }
-        '''
+                assert FooBarBaz.foo() == 100
+                new FooBarBaz().with {
+                    assert bar() == -10
+                    assert baz() == -20
+                }
+            """
+        }
     }
 
     // GROOVY-6716
@@ -3399,107 +3483,121 @@ final class TraitASTTransformationTest {
 
     // GROOVY-8954
     @Test
-    void testTraitWithPropertyAlsoFromInterfaceSC() {
-        assertScript shell, '''
-            interface DomainProp {
-                boolean isNullable()
-            }
-
-            abstract class OrderedProp implements DomainProp { }
-
-            trait Nullable {
-                boolean nullable = true
-            }
-
-            @CompileStatic
-            abstract class CustomProp extends OrderedProp implements Nullable { }
+    void testTraitWithPropertyAlsoFromInterface() {
+        for (mode in ['','@TypeChecked','@CompileStatic']) {
+            assertScript shell, """
+                $mode
+                interface DomainProp {
+                    boolean isNullable()
+                }
+                $mode
+                abstract class OrderedProp implements DomainProp {
+                }
+                $mode
+                trait Nullable {
+                    boolean nullable = true
+                }
+                $mode
+                abstract class CustomProp extends OrderedProp implements Nullable {
+                }
 
-            assert new CustomProp() {}
-        '''
+                assert new CustomProp() {}
+            """
+        }
     }
 
     // GROOVY-8272
     @Test
     void testTraitAccessToInheritedStaticMethods() {
-        assertScript shell, '''
-            @CompileStatic
-            trait Foo {
-                static String go() {
-                    'Go!'
+        for (mode in ['','@TypeChecked','@CompileStatic']) {
+            assertScript shell, """
+                $mode
+                trait Foo {
+                    static String go() {
+                        'Go!'
+                    }
                 }
-            }
-
-            @CompileStatic
-            trait Bar extends Foo {
-                String doIt() {
-                    go().toUpperCase()
+                $mode
+                trait Bar extends Foo {
+                    String test() {
+                        go().toUpperCase()
+                    }
+                }
+                $mode
+                class Main implements Bar {
                 }
-            }
-
-            class Main implements Bar {}
 
-            assert new Main().doIt() == 'GO!'
-        '''
+                assert new Main().test() == 'GO!'
+            """
+        }
     }
 
     // GROOVY-10312
     @Test
     void testTraitAccessToInheritedStaticMethods2() {
-        assertScript shell, '''
-            trait Foo {
-                static String staticMethod(String string) {
-                    return string
-                }
-            }
-            trait Bar extends Foo {
-                static String staticMethodWithDefaultArgument(String string = 'works') {
-                    staticMethod(string) // MissingMethodException
+        for (mode in ['','@TypeChecked','@CompileStatic']) {
+            assertScript shell, """
+                $mode
+                trait Foo {
+                    static String staticMethod(String string) {
+                        return string
+                    }
                 }
-            }
-
-            class Main implements Bar {
-                static test1() {
-                    String result = staticMethodWithDefaultArgument()
-                    assert result == 'works'
+                $mode
+                trait Bar extends Foo {
+                    static String staticMethodWithDefaultArgument(String string = 'works') {
+                        staticMethod(string) // MissingMethodException
+                    }
                 }
-                void test2() {
-                    String result = staticMethodWithDefaultArgument()
-                    assert result == 'works'
+                $mode
+                class Main implements Bar {
+                    static test1() {
+                        String result = staticMethodWithDefaultArgument()
+                        assert result == 'works'
+                    }
+                    void test2() {
+                        String result = staticMethodWithDefaultArgument()
+                        assert result == 'works'
+                    }
                 }
-            }
 
-            Main.test1()
-            new Main().test2()
-        '''
+                Main.test1()
+                new Main().test2()
+            """
+        }
     }
 
     // GROOVY-10312
     @Test
     void testTraitAccessToInheritedStaticMethods3() {
-        assertScript shell, '''
-            interface Foo {
-                public static final String BANG = '!'
-            }
-            trait Bar implements Foo {
-                static String staticMethodWithDefaultArgument(String string = 'works') {
-                    string + BANG
+        for (mode in ['','@TypeChecked','@CompileStatic']) {
+            assertScript shell, """
+                $mode
+                interface Foo {
+                    public static final String BANG = '!'
                 }
-            }
-
-            class Main implements Bar {
-                static test1() {
-                    String result = staticMethodWithDefaultArgument()
-                    assert result == 'works!'
+                $mode
+                trait Bar implements Foo {
+                    static String staticMethodWithDefaultArgument(String string = 'works') {
+                        string + BANG
+                    }
                 }
-                void test2() {
-                    String result = staticMethodWithDefaultArgument()
-                    assert result == 'works!'
+                $mode
+                class Main implements Bar {
+                    static test1() {
+                        String result = staticMethodWithDefaultArgument()
+                        assert result == 'works!'
+                    }
+                    void test2() {
+                        String result = staticMethodWithDefaultArgument()
+                        assert result == 'works!'
+                    }
                 }
-            }
 
-            Main.test1()
-            new Main().test2()
-        '''
+                Main.test1()
+                new Main().test2()
+            """
+        }
     }
 
     // GROOVY-9386
