diff --git a/src/main/groovy/util/GroovyScriptEngine.java b/src/main/groovy/util/GroovyScriptEngine.java
index 14701cfcc0..16fb3e7dc2 100644
--- a/src/main/groovy/util/GroovyScriptEngine.java
+++ b/src/main/groovy/util/GroovyScriptEngine.java
@@ -180,18 +180,18 @@ public class GroovyScriptEngine implements ResourceConnector {
             
             StringSetMap cache = localCache.get();
             cache.makeTransitiveHull();
-            long time = System.currentTimeMillis();
+            long now = System.currentTimeMillis();
             Set<String> entryNames = new HashSet<String>();
-            for (Map.Entry<String,Set<String>> entry: cache.entrySet()) {
+            for (Map.Entry<String, Set<String>> entry: cache.entrySet()) {
                 String className = entry.getKey();
                 Class clazz = getClassCacheEntry(className);
-                if (clazz==null) continue;
-                
+                if (clazz == null) continue;
+
                 String entryName = getPath(clazz);
                 if(entryNames.contains(entryName)) continue;
                 entryNames.add(entryName);
-                Set<String> value = convertToPaths(entry.getValue()); 
-                ScriptCacheEntry cacheEntry = new ScriptCacheEntry(clazz,time,value);
+                Set<String> value = convertToPaths(entry.getValue());
+                ScriptCacheEntry cacheEntry = new ScriptCacheEntry(clazz, now, value);
                 scriptCache.put(entryName,cacheEntry);
             }
             cache.clear();
@@ -211,7 +211,7 @@ public class GroovyScriptEngine implements ResourceConnector {
             Set<String> ret = new HashSet<String>();
             for (String className : orig) {
                 Class clazz = getClassCacheEntry(className);
-                if (clazz==null) continue;
+                if (clazz == null) continue;
                 ret.add(getPath(clazz));
             }
             return ret;
@@ -445,7 +445,7 @@ public class GroovyScriptEngine implements ResourceConnector {
         String path = conn.getURL().getPath();
         ScriptCacheEntry entry = scriptCache.get(path);
         Class clazz = null;
-        if (entry != null) clazz=entry.scriptClass;
+        if (entry != null) clazz = entry.scriptClass;
         try {
             if (isSourceNewer(entry)) {
                 try {
@@ -524,20 +524,20 @@ public class GroovyScriptEngine implements ResourceConnector {
 
     protected boolean isSourceNewer(ScriptCacheEntry entry) throws ResourceException  {
         if (entry == null) return true;
-        long time = System.currentTimeMillis();
-        
-        for (String scriptName:entry.dependencies) {
+        long now = System.currentTimeMillis();
+
+        for (String scriptName: entry.dependencies) {
             ScriptCacheEntry depEntry = scriptCache.get(scriptName);
-            long entryChangeTime = depEntry.lastModified + config.getMinimumRecompilationInterval();
-            if (entryChangeTime > time) continue;
+            long nextPossibleRecompilationTime = depEntry.lastModified + config.getMinimumRecompilationInterval();
+            if (nextPossibleRecompilationTime > now) continue;
 
             URLConnection conn = rc.getResourceConnection(scriptName);
             long lastMod = conn.getLastModified();
             // getResourceConnection() opening the inputstream, let's ensure all streams are closed
             forceClose(conn);
 
-            if (entryChangeTime > lastMod) {
-                ScriptCacheEntry newEntry = new ScriptCacheEntry(depEntry.scriptClass, time, depEntry.dependencies);
+            if (nextPossibleRecompilationTime < lastMod) {
+                ScriptCacheEntry newEntry = new ScriptCacheEntry(depEntry.scriptClass, lastMod, depEntry.dependencies);
                 scriptCache.put(scriptName, newEntry);
                 continue;
             }
diff --git a/src/test/groovy/util/GroovyScriptEngineTest.groovy b/src/test/groovy/util/GroovyScriptEngineTest.groovy
index de60c75464..43e1faeafc 100644
--- a/src/test/groovy/util/GroovyScriptEngineTest.groovy
+++ b/src/test/groovy/util/GroovyScriptEngineTest.groovy
@@ -212,16 +212,52 @@ class GroovyScriptEngineTest extends GroovyTestCase {
         println "testGSELoadingAScriptThatHasMultipleClasses - Run 2"
         gse.run("Groovy4234Helper.groovy", new Binding())
     }
-    
-	/*
-	 * The script passes the className of the class it's supposed to
-	 * instantiate to this method, expecting a newly instantiated object
-	 * in return.  The reason this is not done in the script is that
-	 * we want to ensure that no unforeseen problems occur if 
-	 * the instantiation is not actually done inside the script,
-	 * since real-world usages will likely require delegating that
-	 * job.
-	 */
+
+    // GROOVY-2811 and GROOVY-4286
+    void testReloadingInterval() {
+        def f = File.createTempFile("gse", ".groovy", new File("./target"))
+        try {
+            def scriptName = f.name
+
+            def gse = new GroovyScriptEngine(f.parentFile.name)
+            gse.config.minimumRecompilationInterval = 500
+
+            def binding = new Binding([:])
+
+            f << "1"
+            sleep 200
+            // first time, the script is compiled and cached
+            assert gse.run(scriptName, binding) == 1
+
+            f.delete()
+            f << "2"
+            sleep 1000
+            // the file was updated, and we waited for more than the minRecompilationInterval
+            assert gse.run(scriptName, binding) == 2
+
+            f.delete()
+            f << "3"
+            sleep 100
+            // still the old result, as we didn't wait more than the minRecompilationInterval
+            assert gse.run(scriptName, binding) == 2
+
+            sleep 1000
+            // we've waited enough, so we get the new output
+            assert gse.run(scriptName, binding) == 3
+        } finally {
+            f.delete()
+        }
+    }
+
+    /*
+      * The script passes the className of the class it's supposed to
+      * instantiate to this method, expecting a newly instantiated object
+      * in return.  The reason this is not done in the script is that
+      * we want to ensure that no unforeseen problems occur if
+      * the instantiation is not actually done inside the script,
+      * since real-world usages will likely require delegating that
+      * job.
+      */
 	public Object instantiate(String className, ClassLoader classLoader){
 		Class clazz = null;
 		try {
@@ -266,4 +302,4 @@ class MyDimension {
     int hashCode() { width + 13 * height }
 }
 
-abstract class CustomBaseClass extends Script {}
\ No newline at end of file
+abstract class CustomBaseClass extends Script {}
