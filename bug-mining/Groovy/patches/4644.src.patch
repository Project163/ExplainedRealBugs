diff --git a/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java b/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
index 99f6eb15c9..1ade174470 100644
--- a/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
+++ b/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
@@ -775,7 +775,8 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
                     currentClass.getCompileUnit().addClassNodeToCompile(type, lr.getSourceUnit());
                     throw new Interrupt(compilationUnit); // GROOVY-10300, et al.: restart resolve
                 } else {
-                    type.setRedirect(lr.getClassNode());
+                    ClassNode cn = lr.getClassNode();
+                    if (cn != ClassNodeResolver.NO_CLASS) type.setRedirect(cn);
                 }
                 return true;
             }
@@ -997,13 +998,6 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
         visitAnnotations(ve);
         Variable v = ve.getAccessedVariable();
 
-        if(!(v instanceof DynamicVariable) && !checkingVariableTypeInDeclaration) {
-            /*
-             *  GROOVY-4009: when a normal variable is simply being used, there is no need to try to
-             *  resolve its type. Variable type resolve should proceed only if the variable is being declared.
-             */
-            return ve;
-        }
         if (v instanceof DynamicVariable) {
             String name = ve.getName();
             ClassNode t = ClassHelper.make(name);
@@ -1033,6 +1027,10 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
                 ce.setSourcePosition(ve);
                 return ce;
             }
+        } else if (!checkingVariableTypeInDeclaration) {
+            // GROOVY-4009: When a normal variable is simply being used, there is no need to try to
+            // resolve its type. Variable type resolve should proceed only if the variable is being declared.
+            return ve;
         }
         resolveOrFail(ve.getType(), ve);
         ClassNode origin = ve.getOriginType();
diff --git a/src/main/java/org/codehaus/groovy/tools/javac/JavaAwareCompilationUnit.java b/src/main/java/org/codehaus/groovy/tools/javac/JavaAwareCompilationUnit.java
index 687533d002..a1fcad450f 100644
--- a/src/main/java/org/codehaus/groovy/tools/javac/JavaAwareCompilationUnit.java
+++ b/src/main/java/org/codehaus/groovy/tools/javac/JavaAwareCompilationUnit.java
@@ -24,10 +24,12 @@ import org.codehaus.groovy.ast.GroovyClassVisitor;
 import org.codehaus.groovy.ast.ModuleNode;
 import org.codehaus.groovy.classgen.GeneratorContext;
 import org.codehaus.groovy.control.AnnotationConstantsVisitor;
+import org.codehaus.groovy.control.ClassNodeResolver;
 import org.codehaus.groovy.control.CompilationFailedException;
 import org.codehaus.groovy.control.CompilationUnit;
 import org.codehaus.groovy.control.CompilerConfiguration;
 import org.codehaus.groovy.control.Phases;
+import org.codehaus.groovy.control.ResolveVisitor;
 import org.codehaus.groovy.control.SourceUnit;
 import org.codehaus.groovy.transform.ASTTransformationCollectorCodeVisitor;
 
@@ -65,7 +67,7 @@ public class JavaAwareCompilationUnit extends CompilationUnit {
     }
 
     public JavaAwareCompilationUnit(final CompilerConfiguration configuration, final GroovyClassLoader groovyClassLoader, final GroovyClassLoader transformClassLoader) {
-        super(configuration, null, groovyClassLoader, transformClassLoader);
+        super(configuration, /*codeSource*/null, groovyClassLoader, transformClassLoader);
 
         {
             Map<String, Object> options = this.configuration.getJointCompilationOptions();
@@ -79,7 +81,22 @@ public class JavaAwareCompilationUnit extends CompilationUnit {
 
         addPhaseOperation((final SourceUnit source, final GeneratorContext context, final ClassNode classNode) -> {
             if (!javaSources.isEmpty()) {
-                new JavaAwareResolveVisitor(this).startResolving(classNode, source);
+                ResolveVisitor resolveVisitor = new JavaAwareResolveVisitor(this);
+                resolveVisitor.setClassNodeResolver(new ClassNodeResolver() {
+                    @Override
+                    public LookupResult resolveName(final String name, final CompilationUnit unit) {
+                        LookupResult result = super.resolveName(name, unit);
+                        if (result == null) { // GROOVY-8184, GROOVY-10571: look for java source
+                            String spec = File.separator + name.replace('.', File.separatorChar) + ".java";
+                            if (javaSources.stream().anyMatch(path -> path.endsWith(spec))) {
+                                result = new LookupResult(null, NO_CLASS); // truthy value
+                            }
+                        }
+                        return result;
+                    }
+                });
+                resolveVisitor.startResolving(classNode, source);
+                // then resolve constants in annotation instances
                 new AnnotationConstantsVisitor().visitClass(classNode, source);
             }
         }, Phases.CONVERSION);
@@ -128,6 +145,14 @@ public class JavaAwareCompilationUnit extends CompilationUnit {
         }
     }
 
+    private void addJavaOrGroovySource(final File file) {
+        if (file.getName().endsWith(".java")) {
+            addJavaSource(file);
+        } else {
+            addSource(file);
+        }
+    }
+
     private void addJavaSource(final File file) {
         javaSources.add(file.getAbsolutePath());
     }
@@ -146,14 +171,6 @@ public class JavaAwareCompilationUnit extends CompilationUnit {
         }
     }
 
-    private void addJavaOrGroovySource(final File file) {
-        if (file.getName().endsWith(".java")) {
-            addJavaSource(file);
-        } else {
-            addSource(file);
-        }
-    }
-
     public JavaCompilerFactory getCompilerFactory() {
         return compilerFactory;
     }
diff --git a/src/main/java/org/codehaus/groovy/tools/javac/JavaAwareResolveVisitor.java b/src/main/java/org/codehaus/groovy/tools/javac/JavaAwareResolveVisitor.java
index 5cd7ea96eb..b7740e8170 100644
--- a/src/main/java/org/codehaus/groovy/tools/javac/JavaAwareResolveVisitor.java
+++ b/src/main/java/org/codehaus/groovy/tools/javac/JavaAwareResolveVisitor.java
@@ -44,12 +44,11 @@ public class JavaAwareResolveVisitor extends ResolveVisitor {
 
     @Override
     protected void visitClassCodeContainer(final Statement stmt) {
-        // do nothing here, leave it to the normal resolving
+        // do nothing here; leave it to the normal resolving
     }
 
     @Override
     public void addError(final String error, final ASTNode node) {
-        if (error.startsWith("unable to resolve")) // GROOVY-10607
-            getSourceUnit().getAST().putNodeMetaData("require.imports", Boolean.TRUE);
+        // do nothing here; leave it to the normal resolving
     }
 }
diff --git a/src/main/java/org/codehaus/groovy/tools/javac/JavaStubGenerator.java b/src/main/java/org/codehaus/groovy/tools/javac/JavaStubGenerator.java
index e2596e8620..5e46f81bb0 100644
--- a/src/main/java/org/codehaus/groovy/tools/javac/JavaStubGenerator.java
+++ b/src/main/java/org/codehaus/groovy/tools/javac/JavaStubGenerator.java
@@ -1056,21 +1056,6 @@ public class JavaStubGenerator {
         }
 
         out.println();
-
-        // non-static imports required if any unresolved nodes encountered -- Java type(s)?
-        if (!Boolean.TRUE.equals(currentModule.getNodeMetaData("require.imports"))) return;
-
-        for (ImportNode i : currentModule.getImports()) {
-            if (i.getType().hasPackageName() && (i.getAlias() == null
-                    || i.getAlias().equals(i.getType().getNameWithoutPackage())))
-                out.println("import " + i.getType().getName().replace('$', '.') + ";");
-        }
-
-        for (ImportNode si : currentModule.getStarImports()) {
-            out.println("import " + si.getPackageName() + "*;");
-        }
-
-        out.println();
     }
 
     public void clean() {
diff --git a/src/test/org/codehaus/groovy/tools/stubgenerator/Groovy10571.groovy b/src/test/org/codehaus/groovy/tools/stubgenerator/Groovy10571.groovy
index a761a6ba32..3703c58de3 100644
--- a/src/test/org/codehaus/groovy/tools/stubgenerator/Groovy10571.groovy
+++ b/src/test/org/codehaus/groovy/tools/stubgenerator/Groovy10571.groovy
@@ -18,8 +18,6 @@
  */
 package org.codehaus.groovy.tools.stubgenerator
 
-import groovy.test.NotYetImplemented
-
 final class Groovy10571 extends StringSourcesStubTestCase {
 
     @Override
@@ -66,9 +64,4 @@ final class Groovy10571 extends StringSourcesStubTestCase {
         assert stub.contains('Object.class')
         assert stub.contains('B.class')//bug
     }
-
-    @Override @NotYetImplemented
-    void testRun() {
-        super.testRun()
-    }
 }
diff --git a/src/test/org/codehaus/groovy/tools/stubgenerator/Groovy10607.groovy b/src/test/org/codehaus/groovy/tools/stubgenerator/Groovy10607.groovy
index 7ab59b6232..60fc1b8d86 100644
--- a/src/test/org/codehaus/groovy/tools/stubgenerator/Groovy10607.groovy
+++ b/src/test/org/codehaus/groovy/tools/stubgenerator/Groovy10607.groovy
@@ -32,7 +32,7 @@ final class Groovy10607 extends StringSourcesStubTestCase {
                 package q
                 import p.*
                 class Foo {
-                    def baz(Bar b) {
+                    def m(Bar bar) {
                     }
                 }
             ''',
@@ -49,6 +49,6 @@ final class Groovy10607 extends StringSourcesStubTestCase {
     @Override
     void verifyStubs() {
         String stub = stubJavaSourceFor('q.Foo')
-        assert stub.contains('import p.*;')
+        assert stub.contains(' java.lang.Object m(p.Bar bar) { return null; }')
     }
 }
diff --git a/src/test/org/codehaus/groovy/tools/stubgenerator/Groovy8184.groovy b/src/test/org/codehaus/groovy/tools/stubgenerator/Groovy8184.groovy
new file mode 100644
index 0000000000..c4c540b6b1
--- /dev/null
+++ b/src/test/org/codehaus/groovy/tools/stubgenerator/Groovy8184.groovy
@@ -0,0 +1,54 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package org.codehaus.groovy.tools.stubgenerator
+
+final class Groovy8184 extends StringSourcesStubTestCase {
+
+    @Override
+    Map<String, String> provideSources() {
+        [
+            'C8184.java': '''
+                class C8184 {
+                }
+            ''',
+            'G.groovy': '''
+                @Category(C8184)
+                class G {
+                    def m() { this }
+                }
+            ''',
+            'J.java': '''
+                public class J {
+                    Object m() throws Exception {
+                        return G.class.getDeclaredMethod("m", C8184.class);
+                    }
+                }
+            ''',
+        ]
+    }
+
+    @Override
+    void verifyStubs() {
+        String stub = stubJavaSourceFor('G')
+        assert stub.contains("@groovy.lang.Category(value=C8184.class)")
+
+        Object pojo = loader.loadClass('J').getDeclaredConstructor().newInstance()
+        assert pojo.m() != null
+    }
+}
