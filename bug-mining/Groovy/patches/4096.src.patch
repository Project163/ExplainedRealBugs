diff --git a/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesMethodReferenceExpressionWriter.java b/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesMethodReferenceExpressionWriter.java
index 5cd9c99578..626eb25147 100644
--- a/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesMethodReferenceExpressionWriter.java
+++ b/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesMethodReferenceExpressionWriter.java
@@ -30,13 +30,16 @@ import org.codehaus.groovy.ast.expr.ArrayExpression;
 import org.codehaus.groovy.ast.expr.ClassExpression;
 import org.codehaus.groovy.ast.expr.ConstantExpression;
 import org.codehaus.groovy.ast.expr.Expression;
+import org.codehaus.groovy.ast.expr.MethodCallExpression;
 import org.codehaus.groovy.ast.expr.MethodReferenceExpression;
 import org.codehaus.groovy.ast.tools.GeneralUtils;
 import org.codehaus.groovy.classgen.asm.BytecodeHelper;
 import org.codehaus.groovy.classgen.asm.MethodReferenceExpressionWriter;
 import org.codehaus.groovy.classgen.asm.WriterController;
 import org.codehaus.groovy.syntax.RuntimeParserException;
+import org.codehaus.groovy.transform.sc.StaticCompilationMetadataKeys;
 import org.codehaus.groovy.transform.stc.ExtensionMethodNode;
+import org.codehaus.groovy.transform.stc.StaticTypesMarker;
 import org.objectweb.asm.Opcodes;
 
 import java.util.ArrayList;
@@ -55,7 +58,6 @@ import static org.codehaus.groovy.ast.tools.ParameterUtils.parametersCompatible;
 import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.filterMethodsByVisibility;
 import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.findDGMMethodsForClassNode;
 import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.isAssignableTo;
-import static org.codehaus.groovy.transform.stc.StaticTypesMarker.CLOSURE_ARGUMENTS;
 
 /**
  * Writer responsible for generating method reference in statically compiled mode.
@@ -87,9 +89,8 @@ public class StaticTypesMethodReferenceExpressionWriter extends MethodReferenceE
         ClassNode typeOrTargetRefType = isClassExpression ? typeOrTargetRef.getType()
                 : controller.getTypeChooser().resolveType(typeOrTargetRef, classNode);
 
-        ClassNode[] methodReferenceParamTypes = methodReferenceExpression.getNodeMetaData(CLOSURE_ARGUMENTS);
+        ClassNode[] methodReferenceParamTypes = methodReferenceExpression.getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);
         Parameter[] parametersWithExactType = createParametersWithExactType(abstractMethod, methodReferenceParamTypes);
-
         String methodRefName = methodReferenceExpression.getMethodName().getText();
         boolean isConstructorReference = isConstructorReference(methodRefName);
 
@@ -174,7 +175,9 @@ public class StaticTypesMethodReferenceExpressionWriter extends MethodReferenceE
         ArgumentListExpression args = args(parameters);
         args.getExpressions().add(0, ConstantExpression.NULL);
 
-        Expression returnValue = callX(classX(mn.getDeclaringClass()), mn.getName(), args);
+        MethodCallExpression returnValue = callX(classX(mn.getDeclaringClass()), mn.getName(), args);
+        returnValue.putNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET, mn);
+        returnValue.setMethodTarget(mn);
 
         MethodNode delegateMethod = addGeneratedMethod(controller.getClassNode(),
                 "dgsm$$" + mn.getParameters()[0].getType().getName().replace('.', '$') + "$$" + mn.getName(),
@@ -185,6 +188,8 @@ public class StaticTypesMethodReferenceExpressionWriter extends MethodReferenceE
                 block(returnS(returnValue))
         );
 
+        delegateMethod.putNodeMetaData(StaticCompilationMetadataKeys.STATIC_COMPILE_NODE, Boolean.TRUE);
+
         return delegateMethod;
     }
 
@@ -209,6 +214,11 @@ public class StaticTypesMethodReferenceExpressionWriter extends MethodReferenceE
                 block(returnS(returnValue))
         );
 
+        // TODO: if StaticTypesMarker.DIRECT_METHOD_CALL_TARGET or
+        // OptimizingStatementWriter.StatementMeta.class metadatas
+        // can bet set for the ctorX above, then this can be TRUE:
+        delegateMethod.putNodeMetaData(StaticCompilationMetadataKeys.STATIC_COMPILE_NODE, Boolean.FALSE);
+
         return delegateMethod;
     }
 
diff --git a/src/test/groovy/transform/stc/MethodReferenceTest.groovy b/src/test/groovy/transform/stc/MethodReferenceTest.groovy
index e88c3b3686..a09ccb7030 100644
--- a/src/test/groovy/transform/stc/MethodReferenceTest.groovy
+++ b/src/test/groovy/transform/stc/MethodReferenceTest.groovy
@@ -299,11 +299,12 @@ final class MethodReferenceTest {
     }
 
     @Test // arrayClass::new
-    void testIntFunctionCN() {
+    void testFunctionCN() {
         assertScript shell, '''
             @CompileStatic
             void p() {
-                assert new Integer[] { 1, 2, 3 } == [1, 2, 3].stream().toArray(Integer[]::new)
+                def result = [1, 2, 3].stream().toArray(Integer[]::new)
+                assert result == new Integer[] { 1, 2, 3 }
             }
 
             p()
@@ -311,11 +312,12 @@ final class MethodReferenceTest {
     }
 
     @Test // class::new
-    void testFunctionCN() {
+    void testFunctionCN2() {
         assertScript shell, '''
             @CompileStatic
             void p() {
-                assert [1, 2, 3] == ["1", "2", "3"].stream().map(Integer::new).collect(Collectors.toList())
+                def result = ["1", "2", "3"].stream().map(Integer::new).collect(Collectors.toList())
+                assert result == [1, 2, 3]
             }
 
             p()
@@ -323,18 +325,49 @@ final class MethodReferenceTest {
     }
 
     @Test // class::new -- GROOVY-10033
-    void testFunctionCN2() {
+    void testFunctionCN3() {
         assertScript shell, '''
+            @CompileStatic
             class C {
-                C(Function<String,String> f) {
+                C(Function<String,Integer> f) {
+                    def i = f.apply('42')
+                    assert i == 42
+                }
+                static test() {
+                    new C(Integer::new)
+                }
+            }
+            C.test()
+        '''
+    }
+
+    @Test // class::new -- GROOVY-10033
+    void testFunctionCN4() {
+        assertScript shell, '''
+            class A {
+                A(Function<A,B> f) {
+                    B b = f.apply(this)
+                    assert b instanceof X.Y
+                }
+            }
+            class B {
+                B(A a) {
+                    assert a != null
                 }
             }
             @CompileStatic
-            void p() {
-                new C(String::toLowerCase)
+            class X extends A {
+              public X() {
+                super(Y::new)
+              }
+              private static class Y extends B {
+                Y(A a) {
+                  super(a)
+                }
+              }
             }
 
-            p()
+            new X()
         '''
     }
 
