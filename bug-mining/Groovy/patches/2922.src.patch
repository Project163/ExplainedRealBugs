diff --git a/src/main/groovy/transform/TupleConstructor.java b/src/main/groovy/transform/TupleConstructor.java
index b809792d7a..66a89a22c0 100644
--- a/src/main/groovy/transform/TupleConstructor.java
+++ b/src/main/groovy/transform/TupleConstructor.java
@@ -79,8 +79,9 @@ public @interface TupleConstructor {
      * List of field and/or property names to include within the constructor.
      * Must not be used if 'excludes' is used. For convenience, a String with comma separated names
      * can be used in addition to an array (using Groovy's literal list notation) of String values.
+     * The default value is a special marker value indicating that no includes are defined.
      */
-    String[] includes() default {};
+    String[] includes() default {Undefined.STRING};
 
     /**
      * Include fields in the constructor.
diff --git a/src/main/org/codehaus/groovy/transform/AbstractASTTransformation.java b/src/main/org/codehaus/groovy/transform/AbstractASTTransformation.java
index d67b971f56..0817dbd086 100644
--- a/src/main/org/codehaus/groovy/transform/AbstractASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/AbstractASTTransformation.java
@@ -131,7 +131,42 @@ public abstract class AbstractASTTransformation implements Opcodes, ASTTransform
         return defaultValue;
     }
 
+    public List<String> getMemberStringList(AnnotationNode anno, String name) {
+        Expression expr = anno.getMember(name);
+        if (expr == null) {
+            return null;
+        }
+        if (expr instanceof ListExpression) {
+            List<String> list = new ArrayList<String>();
+            final ListExpression listExpression = (ListExpression) expr;
+            if (isUndefinedMarkerList(listExpression)) {
+                return null;
+            }
+            for (Expression itemExpr : listExpression.getExpressions()) {
+                if (itemExpr != null && itemExpr instanceof ConstantExpression) {
+                    Object value = ((ConstantExpression) itemExpr).getValue();
+                    if (value != null) list.add(value.toString());
+                }
+            }
+            return list;
+        }
+        return tokenize(getMemberStringValue(anno, name));
+    }
+
+    private static boolean isUndefinedMarkerList(ListExpression listExpression) {
+        if (listExpression.getExpressions().size() != 1) return false;
+        Expression itemExpr = listExpression.getExpression(0);
+        if (itemExpr != null && itemExpr instanceof ConstantExpression) {
+            Object value = ((ConstantExpression) itemExpr).getValue();
+            System.out.println("value = " + value);
+            if (isUndefined(value.toString())) return true;
+        }
+        return false;
+    }
+
+    //@Deprecated
     public List<String> getMemberList(AnnotationNode anno, String name) {
+        // TODO mark deprecated once all bundled AST transforms have been switched over to use getMemberStringList
         List<String> list;
         Expression expr = anno.getMember(name);
         if (expr != null && expr instanceof ListExpression) {
@@ -197,6 +232,10 @@ public abstract class AbstractASTTransformation implements Opcodes, ASTTransform
         return name.contains("$");
     }
 
+    public static boolean shouldSkipUndefinedAware(String name, List<String> excludes, List<String> includes) {
+        return (excludes != null && excludes.contains(name)) || deemedInternalName(name) || (includes != null && !includes.contains(name));
+    }
+
     public static boolean shouldSkip(String name, List<String> excludes, List<String> includes) {
         return (excludes != null && excludes.contains(name)) || deemedInternalName(name) || (includes != null && !includes.isEmpty() && !includes.contains(name));
     }
@@ -260,6 +299,14 @@ public abstract class AbstractASTTransformation implements Opcodes, ASTTransform
         return true;
     }
 
+    protected boolean checkIncludeExcludeUndefinedAware(AnnotationNode node, List<String> excludes, List<String> includes, String typeName) {
+        if (includes != null && excludes != null && !excludes.isEmpty()) {
+            addError("Error during " + typeName + " processing: Only one of 'includes' and 'excludes' should be supplied not both.", node);
+            return false;
+        }
+        return true;
+    }
+
     protected void checkIncludeExclude(AnnotationNode node, List<String> excludes, List<String> includes, List<ClassNode> excludeTypes, List<ClassNode> includeTypes, String typeName) {
         int found = 0;
         if (includes != null && !includes.isEmpty()) found++;
diff --git a/src/main/org/codehaus/groovy/transform/TupleConstructorASTTransformation.java b/src/main/org/codehaus/groovy/transform/TupleConstructorASTTransformation.java
index 9c1420ed21..08be539377 100644
--- a/src/main/org/codehaus/groovy/transform/TupleConstructorASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/TupleConstructorASTTransformation.java
@@ -110,9 +110,9 @@ public class TupleConstructorASTTransformation extends AbstractASTTransformation
             boolean force = memberHasValue(anno, "force", true);
             boolean defaults = !memberHasValue(anno, "defaults", false);
             boolean useSetters = memberHasValue(anno, "useSetters", true);
-            List<String> excludes = getMemberList(anno, "excludes");
-            List<String> includes = getMemberList(anno, "includes");
-            if (!checkIncludeExclude(anno, excludes, includes, MY_TYPE_NAME)) return;
+            List<String> excludes = getMemberStringList(anno, "excludes");
+            List<String> includes = getMemberStringList(anno, "includes");
+            if (!checkIncludeExcludeUndefinedAware(anno, excludes, includes, MY_TYPE_NAME)) return;
             if (!checkPropertyList(cNode, includes, "includes", anno, MY_TYPE_NAME, includeFields)) return;
             if (!checkPropertyList(cNode, excludes, "excludes", anno, MY_TYPE_NAME, includeFields)) return;
             // if @Immutable is found, let it pick up options and do work so we'll skip
@@ -155,7 +155,7 @@ public class TupleConstructorASTTransformation extends AbstractASTTransformation
         final BlockStatement body = new BlockStatement();
         for (FieldNode fNode : superList) {
             String name = fNode.getName();
-            if (shouldSkip(name, excludes, includes)) continue;
+            if (shouldSkipUndefinedAware(name, excludes, includes)) continue;
             params.add(createParam(fNode, name, defaults, xform));
             boolean hasSetter = cNode.getProperty(name) != null && !fNode.isFinal();
             if (callSuper) {
@@ -173,7 +173,7 @@ public class TupleConstructorASTTransformation extends AbstractASTTransformation
         }
         for (FieldNode fNode : list) {
             String name = fNode.getName();
-            if (shouldSkip(name, excludes, includes)) continue;
+            if (shouldSkipUndefinedAware(name, excludes, includes)) continue;
             Parameter nextParam = createParam(fNode, name, defaults, xform);
             params.add(nextParam);
             boolean hasSetter = cNode.getProperty(name) != null && !fNode.isFinal();
diff --git a/src/test/org/codehaus/groovy/transform/TupleConstructorTransformTest.groovy b/src/test/org/codehaus/groovy/transform/TupleConstructorTransformTest.groovy
index d8fa6d9cf1..feb39c55a4 100644
--- a/src/test/org/codehaus/groovy/transform/TupleConstructorTransformTest.groovy
+++ b/src/test/org/codehaus/groovy/transform/TupleConstructorTransformTest.groovy
@@ -86,4 +86,15 @@ class TupleConstructorTransformTest extends GroovyShellTestCase {
         assert message.contains("Error during @TupleConstructor processing: 'excludes' property 'sirName' does not exist.")
     }
 
+    void testIncludesWithEmptyList_groovy7523() {
+        assertScript '''
+            @groovy.transform.TupleConstructor(includes=[])
+            class Cat {
+                String name
+                int age
+            }
+            assert Cat.declaredConstructors.size() == 1
+        '''
+    }
+
 }
\ No newline at end of file
