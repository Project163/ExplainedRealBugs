diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 12909a5e6c..34dd1d5401 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -98,7 +98,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             if (typeCheckingContext.getEnclosingClosure()!=null) {
                 addClosureReturnType(getType(returnStatement.getExpression()));
             } else if (typeCheckingContext.getEnclosingMethod() != null) {
-                MethodNode enclosingMethod = typeCheckingContext.getEnclosingMethod();
+                /*MethodNode enclosingMethod = typeCheckingContext.getEnclosingMethod();
                 ClassNode mrt = enclosingMethod.getReturnType();
                 if (!returnType.implementsInterface(mrt) && !returnType.isDerivedFrom(mrt)) {
                     // there's an implicit type conversion, like Object -> String
@@ -107,7 +107,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 }
                 ClassNode previousType = getInferredReturnType(enclosingMethod);
                 ClassNode inferred = previousType == null ? returnType : lowestUpperBound(returnType, previousType);
-                storeInferredReturnType(enclosingMethod, inferred);
+                storeInferredReturnType(enclosingMethod, inferred);*/
             } else {
                 throw new GroovyBugError("Unexpected return statement at "
                         + returnStatement.getLineNumber()+":"+returnStatement.getColumnNumber()
@@ -482,7 +482,6 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 }
             }
             boolean isEmptyDeclaration = expression instanceof DeclarationExpression && rightExpression instanceof EmptyExpression;
-            if (!isEmptyDeclaration) storeType(expression, resultType);
             if (!isEmptyDeclaration && isAssignment(op)) {
                 if (rightExpression instanceof ConstructorCallExpression) {
                     inferDiamondType((ConstructorCallExpression) rightExpression, lType);
@@ -508,7 +507,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                         List<ClassNode> types = typeCheckingContext.ifElseForWhileAssignmentTracker.get(var);
                         if (types == null) {
                             types = new LinkedList<ClassNode>();
-                            ClassNode type = (ClassNode) var.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);
+                            ClassNode type = var.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);
                             types.add(type);
                             typeCheckingContext.ifElseForWhileAssignmentTracker.put(var, types);
                         }
@@ -538,6 +537,9 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             } else if (op == KEYWORD_INSTANCEOF) {
                 pushInstanceOfTypeInfo(leftExpression, rightExpression);
             }
+            if (!isEmptyDeclaration) {
+                storeType(expression, resultType);
+            }
         } finally {
             typeCheckingContext.popEnclosingBinaryExpression();
         }
@@ -792,14 +794,6 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 addAssignmentError(leftExpressionType, inferredRightExpressionType, assignmentExpression.getRightExpression());
             }
         } else {
-            // if closure expression on RHS, then copy the inferred closure return type
-            if (rightExpression instanceof ClosureExpression) {
-                ClassNode type = getInferredReturnType(rightExpression);
-                if (type != null) {
-                    storeInferredReturnType(leftExpression, type);
-                }
-            }
-
             addPrecisionErrors(leftRedirect, leftExpressionType, inferredRightExpressionType, rightExpression);
             addListAssignmentConstructorErrors(leftRedirect, leftExpressionType, inferredRightExpressionType, rightExpression, assignmentExpression);
             addMapAssignmentConstructorErrors(leftRedirect, leftExpression, rightExpression);
@@ -1647,8 +1641,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         if (!enclosingClosure.getReturnTypes().isEmpty()) {
             ClassNode returnType = lowestUpperBound(enclosingClosure.getReturnTypes());
             storeInferredReturnType(expression, returnType);
-            ClassNode inferredType = CLOSURE_TYPE.getPlainNodeReference();
-            inferredType.setGenericsTypes(new GenericsType[]{new GenericsType(wrapTypeIfNecessary(returnType))});
+            ClassNode inferredType = wrapClosureType(returnType);
             storeType(enclosingClosure.getClosureExpression(), inferredType);
         }
 
@@ -1662,6 +1655,12 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         typeCheckingContext.isInStaticContext = oldStaticContext;
     }
 
+    private ClassNode wrapClosureType(final ClassNode returnType) {
+        ClassNode inferredType = CLOSURE_TYPE.getPlainNodeReference();
+        inferredType.setGenericsTypes(new GenericsType[]{new GenericsType(wrapTypeIfNecessary(returnType))});
+        return inferredType;
+    }
+
     protected DelegationMetadata getDelegationMetadata(final ClosureExpression expression) {
         return (DelegationMetadata) expression.getNodeMetaData(StaticTypesMarker.DELEGATION_METADATA);
     }
@@ -1746,11 +1745,13 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                     parameter.getInitialExpression().visit(this);
                 }
             }
+/*
             ClassNode rtype = getInferredReturnType(node);
             if (rtype == null) {
                 storeInferredReturnType(node, node.getReturnType());
             }
             addTypeCheckingInfoAnnotation(node);
+*/
         } finally {
             typeCheckingContext.isInStaticContext = osc;
         }
@@ -1848,16 +1849,6 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 mn = disambiguateMethods(mn, call);
                 if (mn.size() == 1) {
                     MethodNode directMethodCallCandidate = mn.get(0);
-                    // visit the method to obtain inferred return type
-                    typeCheckingContext.pushEnclosingClassNode(directMethodCallCandidate.getDeclaringClass());
-                    for (ClassNode node : typeCheckingContext.source.getAST().getClasses()) {
-                        if (isClassInnerClassOrEqualTo(typeCheckingContext.getEnclosingClassNode(), node)) {
-                            silentlyVisitMethodNode(directMethodCallCandidate);
-                            break;
-                        }
-                    }
-                    pickInferredTypeFromMethodAnnotation(directMethodCallCandidate);
-                    typeCheckingContext.popEnclosingClassNode();
                     ClassNode returnType = getType(directMethodCallCandidate);
                     if (returnType.isUsingGenerics() && !returnType.isEnum()) {
                         visitMethodCallArguments(argumentList, true, (MethodNode)call.getNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET));
@@ -1904,19 +1895,6 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         }
     }
 
-    protected void pickInferredTypeFromMethodAnnotation(final MethodNode node) {
-        if (getInferredReturnType(node) == null
-                && !node.getAnnotations(TYPECHECKING_INFO_NODE).isEmpty()) {
-            List<AnnotationNode> annotations = node.getAnnotations(TYPECHECKING_INFO_NODE);
-            AnnotationNode head = annotations.get(0);
-            int version = Integer.valueOf(head.getMember("version").getText());
-            String signature = head.getMember("inferredType").getText();
-            SignatureCodec codec = SignatureCodecFactory.getCodec(version, getSourceUnit().getClassLoader());
-            ClassNode result = codec.decode(signature);
-            storeInferredReturnType(node, result);
-        }
-    }
-
     /**
      * visit a method call target, to infer the type. Don't report errors right
      * away, that will be done by a later visitMethod call
@@ -2147,24 +2125,19 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                             Parameter[] parameters = (Parameter[]) data;
                             typeCheckClosureCall(callArguments, args, parameters);
                         }
-                        ClassNode type = getInferredReturnType(((ASTNode) variable));
-                        if (type == null) {
-                            // if variable was declared as a closure and inferred type is unknown, we
-                            // may face a recursive call. In that case, we will use the type of the
-                            // generic return type of the closure declaration
-                            if (variable.getType().equals(CLOSURE_TYPE)) {
-                                GenericsType[] genericsTypes = variable.getType().getGenericsTypes();
-                                if (genericsTypes != null/* && !genericsTypes[0].isPlaceholder()*/) {
-                                    if (!genericsTypes[0].isPlaceholder()) {
-                                        type = genericsTypes[0].getType();
-                                    }
-                                } else {
-                                    type = OBJECT_TYPE;
+                        ClassNode type = getType(((ASTNode) variable));
+                        if (type!=null && type.equals(CLOSURE_TYPE)) {
+                            GenericsType[] genericsTypes = type.getGenericsTypes();
+                            if (genericsTypes != null) {
+                                if (!genericsTypes[0].isPlaceholder()) {
+                                    type = genericsTypes[0].getType();
                                 }
+                            } else {
+                                type = OBJECT_TYPE;
                             }
                         }
                         if (type != null) {
-                            storeType(call, (ClassNode) type);
+                            storeType(call, type);
                         }
                     }
                 } else if (objectExpression instanceof ClosureExpression) {
@@ -2260,17 +2233,6 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                                 chosenReceiver = owners.get(0);
                             }
                         }
-                        // visit the method to obtain inferred return type
-                        typeCheckingContext.pushEnclosingClassNode(directMethodCallCandidate.getDeclaringClass());
-                        for (ClassNode node : typeCheckingContext.source.getAST().getClasses()) {
-                            if (isClassInnerClassOrEqualTo(typeCheckingContext.getEnclosingClassNode(), node)) {
-                                // visit is authorized because the classnode belongs to the same source unit
-                                silentlyVisitMethodNode(directMethodCallCandidate);
-                                break;
-                            }
-                        }
-                        pickInferredTypeFromMethodAnnotation(directMethodCallCandidate);
-                        typeCheckingContext.popEnclosingClassNode();
 
                         ClassNode returnType = null;
 
@@ -2667,6 +2629,9 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
     }
 
     protected void storeType(Expression exp, ClassNode cn) {
+        if (exp instanceof DeclarationExpression && CLOSURE_TYPE.equals(cn)) {
+            System.out.println("exp = " + exp.getText());
+        }
         if (exp instanceof VariableExpression && ((VariableExpression) exp).isClosureSharedVariable() && isPrimitiveType(cn)) {
             cn = getWrapper(cn);
         } else if (exp instanceof MethodCallExpression && ((MethodCallExpression) exp).isSafe() && isPrimitiveType(cn)) {
@@ -3259,6 +3224,9 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 return getType(target);
             }
         }
+        if (exp instanceof Parameter) {
+            return ((Parameter) exp).getOriginType();
+        }
         return exp instanceof VariableExpression ? ((VariableExpression) exp).getOriginType() : ((Expression) exp).getType();
     }
 
@@ -3272,6 +3240,9 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
      * @return the old value of the inferred type
      */
     protected ClassNode storeInferredReturnType(final ASTNode node, final ClassNode type) {
+        if (!(node instanceof ClosureExpression)) {
+            throw new IllegalArgumentException("Storing inferred return type is only allowed on closures but found "+node.getClass());
+        }
         return (ClassNode) node.putNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE, type);
     }
 
diff --git a/src/test/groovy/transform/stc/BugsSTCTest.groovy b/src/test/groovy/transform/stc/BugsSTCTest.groovy
index d051cbaadc..94d4897c30 100644
--- a/src/test/groovy/transform/stc/BugsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/BugsSTCTest.groovy
@@ -74,7 +74,7 @@ class BugsSTCTest extends StaticTypeCheckingTestCase {
 
                 5.times {
                     @ASTTest(phase=INSTRUCTION_SELECTION, value= {
-                        assert node.getNodeMetaData(DECLARATION_INFERRED_TYPE) == long_TYPE
+                        assert node.getNodeMetaData(INFERRED_TYPE) == Long_TYPE
                     })
                     def t0 = curr()
                     100000.times {
@@ -88,7 +88,7 @@ class BugsSTCTest extends StaticTypeCheckingTestCase {
     void testGroovy5487ReturnNull() {
         assertScript '''
         @ASTTest(phase=INSTRUCTION_SELECTION, value= {
-            assert node.getNodeMetaData(INFERRED_RETURN_TYPE) == make(List)
+            assert node.getNodeMetaData(INFERRED_RETURN_TYPE) == null // null since 2.1.9
         })
         List getList() {
             null
@@ -99,7 +99,7 @@ class BugsSTCTest extends StaticTypeCheckingTestCase {
     void testGroovy5487ReturnNullWithExplicitReturn() {
         assertScript '''
         @ASTTest(phase=INSTRUCTION_SELECTION, value= {
-            assert node.getNodeMetaData(INFERRED_RETURN_TYPE) == make(List)
+            assert node.getNodeMetaData(INFERRED_RETURN_TYPE) == null // null since 2.1.9
         })
         List getList() {
             return null
@@ -110,7 +110,7 @@ class BugsSTCTest extends StaticTypeCheckingTestCase {
     void testGroovy5487ReturnNullWithEmptyBody() {
         assertScript '''
         @ASTTest(phase=INSTRUCTION_SELECTION, value= {
-            assert node.getNodeMetaData(INFERRED_RETURN_TYPE) == make(List)
+            assert node.getNodeMetaData(INFERRED_RETURN_TYPE) == null // null since 2.1.9
         })
         List getList() {
         }
diff --git a/src/test/groovy/transform/stc/ClosuresSTCTest.groovy b/src/test/groovy/transform/stc/ClosuresSTCTest.groovy
index 886ac1ca98..4e723d1457 100644
--- a/src/test/groovy/transform/stc/ClosuresSTCTest.groovy
+++ b/src/test/groovy/transform/stc/ClosuresSTCTest.groovy
@@ -319,6 +319,9 @@ class ClosuresSTCTest extends StaticTypeCheckingTestCase {
         assertScript """
             interface SAM { def foo(); }
 
+            @ASTTest(phase=INSTRUCTION_SELECTION, value={
+                assert node.getNodeMetaData(INFERRED_TYPE).name == 'SAM'
+            })
             SAM s = {1}
             assert s.foo() == 1
             def t = (SAM) {2}
diff --git a/src/test/groovy/transform/stc/GenericsSTCTest.groovy b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
index c9ce82bdba..e05deca46c 100644
--- a/src/test/groovy/transform/stc/GenericsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
@@ -422,7 +422,7 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
                 }
             }
             new Test()
-        ''', 'Cannot find matching method java.io.Serializable#toInteger()'
+        ''', 'Cannot find matching method java.lang.Object#getAt(int)'
     }
 
     void testAssignmentOfNewInstance() {
diff --git a/src/test/groovy/transform/stc/LoopsSTCTest.groovy b/src/test/groovy/transform/stc/LoopsSTCTest.groovy
index b413c3e8e7..a88227e353 100644
--- a/src/test/groovy/transform/stc/LoopsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/LoopsSTCTest.groovy
@@ -171,13 +171,6 @@ class LoopsSTCTest extends StaticTypeCheckingTestCase {
 
         class MyTraverser implements Traverser {
 
-            @ASTTest(phase=INSTRUCTION_SELECTION, value={
-                def irt = node.getNodeMetaData(INFERRED_RETURN_TYPE)
-                assert irt == make(List)
-                assert irt.isUsingGenerics()
-                assert irt.genericsTypes.length == 1
-                assert irt.genericsTypes[0].type.name == 'Node'
-            })
             Iterable<Node> nodes() {
                 []
             }
@@ -187,7 +180,7 @@ class LoopsSTCTest extends StaticTypeCheckingTestCase {
             def forStmt = lookup('loop')[0]
             assert forStmt instanceof ForStatement
             def collectionType = forStmt.collectionExpression.getNodeMetaData(INFERRED_TYPE)
-            assert collectionType == make(List)
+            assert collectionType == make(Iterable)
             assert collectionType.isUsingGenerics()
             assert collectionType.genericsTypes.length == 1
             assert collectionType.genericsTypes[0].type.name == 'Node'
diff --git a/src/test/groovy/transform/stc/MiscSTCTest.groovy b/src/test/groovy/transform/stc/MiscSTCTest.groovy
index 6ff8147002..c96b9d2d38 100644
--- a/src/test/groovy/transform/stc/MiscSTCTest.groovy
+++ b/src/test/groovy/transform/stc/MiscSTCTest.groovy
@@ -182,15 +182,6 @@ class MiscSTCTest extends StaticTypeCheckingTestCase {
         '''
     }
 
-    void testMethodReturnTypeInferenceShouldWorkBecauseInSameSourceUnit() {
-        assertScript '''
-            class A {
-                static def foo() { '123' }
-            }
-            A.foo().toInteger()
-        '''
-    }
-
     void testMethodReturnTypeInferenceShouldNotWorkBecauseNotSameSourceUnit() {
         shouldFailWithMessages '''
             import groovy.transform.stc.MiscSTCTest.MiscSTCTestSupport as A
diff --git a/src/test/groovy/transform/stc/PrecompiledClassSTCTest.groovy b/src/test/groovy/transform/stc/PrecompiledClassSTCTest.groovy
deleted file mode 100644
index 2572d0fdaf..0000000000
--- a/src/test/groovy/transform/stc/PrecompiledClassSTCTest.groovy
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Copyright 2003-2010 the original author or authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package groovy.transform.stc
-
-import groovy.transform.TypeChecked
-
-/**
- * Unit tests for static type checking : check precompiled type info.
- *
- * @author Cedric Champeau
- */
-class PrecompiledClassSTCTest extends StaticTypeCheckingTestCase {
-    static class Precompiled {
-
-        @TypeChecked
-        static def foo() {
-            new Date()
-        }
-
-        static def bar() {
-            new Date()
-        }
-    } 
-    
-    void testShouldPickInferredTypeFromMethodAnnotation() {
-        assertScript '''import static groovy.transform.stc.PrecompiledClassSTCTest.Precompiled.*
-
-            def date = foo()
-            long time = date.getTime()
-        '''
-    }
-
-    void testShouldNotPickInferredTypeFromMethodAnnotation() {
-        shouldFailWithMessages '''import static groovy.transform.stc.PrecompiledClassSTCTest.Precompiled.*
-
-            def date = bar()
-            date.getTime()
-        ''', 'Cannot find matching method java.lang.Object#getTime()'
-    }
-}
-
diff --git a/src/test/groovy/transform/stc/ReturnsSTCTest.groovy b/src/test/groovy/transform/stc/ReturnsSTCTest.groovy
index 48b0bb7de5..323c1f5d71 100644
--- a/src/test/groovy/transform/stc/ReturnsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/ReturnsSTCTest.groovy
@@ -157,13 +157,6 @@ class ReturnsSTCTest extends StaticTypeCheckingTestCase {
         ''', 'Cannot return value of type java.lang.Object on method returning type double'
     }
 
-    void testReturnTypeInference() {
-        assertScript '''
-            def foo() { 1 }
-            int x = foo()
-        '''
-    }
-
     void testRecursiveTypeInferrence() {
         assertScript '''
             def fib(int i) {
@@ -173,23 +166,13 @@ class ReturnsSTCTest extends StaticTypeCheckingTestCase {
         '''
     }
 
-    void testMethodTypeInferrence() {
-        assertScript '''
-            def square(int i) { i*i }
-            int squarePlusOne(int i) {
-                1+square(i)
-            }
-            assert squarePlusOne(2)==5
-        '''
-    }
-
     void testFindMethodWithInferredReturnType() {
         assertScript '''
             def square(int i) { i*i }
             int foo(int i) {
-                square(i)
+                (Integer)square(i)
             }
-            assert foo(square(2))==16
+            assert foo((Integer)square(2))==16
         '''
     }
 
diff --git a/src/test/groovy/transform/stc/TypeCheckingExtensionsTest.groovy b/src/test/groovy/transform/stc/TypeCheckingExtensionsTest.groovy
index ecdcf45c01..83ba071936 100644
--- a/src/test/groovy/transform/stc/TypeCheckingExtensionsTest.groovy
+++ b/src/test/groovy/transform/stc/TypeCheckingExtensionsTest.groovy
@@ -386,9 +386,6 @@ class TypeCheckingExtensionsTest extends StaticTypeCheckingTestCase {
         extension = null
         assertScript '''
         @groovy.transform.stc.MyType(String)
-        @ASTTest(phase=INSTRUCTION_SELECTION,value={
-            assert node.getNodeMetaData(INFERRED_RETURN_TYPE) == int_TYPE
-        })
         int foo() { 1 }
         '''
 
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/BugsStaticCompileTest.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/BugsStaticCompileTest.groovy
index 2ede41ca91..93609250fc 100644
--- a/src/test/org/codehaus/groovy/classgen/asm/sc/BugsStaticCompileTest.groovy
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/BugsStaticCompileTest.groovy
@@ -891,7 +891,7 @@ import groovy.transform.TypeCheckingMode
                 assert x == Closure.DELEGATE_FIRST
             '''
         } finally {
-            println astTrees
+//            println astTrees
         }
     }
 
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/MethodCallsStaticCompilationTest.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/MethodCallsStaticCompilationTest.groovy
index 1fc2878420..c88da4e57e 100644
--- a/src/test/org/codehaus/groovy/classgen/asm/sc/MethodCallsStaticCompilationTest.groovy
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/MethodCallsStaticCompilationTest.groovy
@@ -117,7 +117,7 @@ public class MethodCallsStaticCompilationTest extends MethodCallsSTCTest {
 
     void testPlusStaticMethodCall() {
         assertScript '''
-            static foo() { 1 }
+            static int foo() { 1 }
             assert 1+foo() == 2
         '''
     }
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/ReturnsStaticCompileTest.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/ReturnsStaticCompileTest.groovy
index d829599b69..ff8e6b0e05 100644
--- a/src/test/org/codehaus/groovy/classgen/asm/sc/ReturnsStaticCompileTest.groovy
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/ReturnsStaticCompileTest.groovy
@@ -31,5 +31,46 @@ class ReturnsStaticCompileTest extends ReturnsSTCTest {
         extraSetup()
     }
 
+    void testReturnTypeInferenceWithInheritance() {
+        assertScript '''
+interface Greeter {
+   public void sayHello()
+}
+
+class HelloGreeter implements Greeter {
+   public void sayHello() {
+       println "Hello world!"
+   }
+}
+
+class A {
+   Greeter createGreeter() {
+       new HelloGreeter()
+   }
+
+   void sayHello() {
+      // also fails: def greeter = createGreeter()
+      // successfull: def greeter = (Greeter)createGreeter()
+      Greeter greeter = createGreeter()
+      greeter.sayHello()
+   }
+}
+
+class HelloThereGreeter implements Greeter {
+   public void sayHello() {
+       println "Hello there!"
+   }
+}
+
+class B extends A {
+   Greeter createGreeter() {
+       new HelloThereGreeter()
+   }
+}
+
+
+new B().sayHello()'''
+    }
+
 }
 
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/StaticCompilationTest.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/StaticCompilationTest.groovy
index 60c1fd27d4..7b562e8a84 100644
--- a/src/test/org/codehaus/groovy/classgen/asm/sc/StaticCompilationTest.groovy
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/StaticCompilationTest.groovy
@@ -10,7 +10,6 @@ class StaticCompilationTest extends AbstractBytecodeTestCase {
         ''')
         assert bytecode.hasStrictSequence(
                 ['public m()V',
-                        '@Lgroovy/transform/TypeChecked$TypeCheckingInfo',
                         'L0',
                         'RETURN']
         )
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/TypeInferenceStaticCompileTest.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/TypeInferenceStaticCompileTest.groovy
index 5f0042086b..792caf6fae 100644
--- a/src/test/org/codehaus/groovy/classgen/asm/sc/TypeInferenceStaticCompileTest.groovy
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/TypeInferenceStaticCompileTest.groovy
@@ -47,7 +47,7 @@ class TypeInferenceStaticCompileTest extends TypeInferenceSTCTest {
         try {
             super.testShouldNotThrowIncompatibleArgToFunVerifyError()
         } finally {
-            println astTrees
+//            println astTrees
         }
     }
 
