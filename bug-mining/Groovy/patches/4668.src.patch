diff --git a/src/main/java/org/apache/groovy/ast/tools/ClassNodeUtils.java b/src/main/java/org/apache/groovy/ast/tools/ClassNodeUtils.java
index b3eb22ed49..b3a1abac91 100644
--- a/src/main/java/org/apache/groovy/ast/tools/ClassNodeUtils.java
+++ b/src/main/java/org/apache/groovy/ast/tools/ClassNodeUtils.java
@@ -47,10 +47,11 @@ import java.util.function.Predicate;
 
 import static org.apache.groovy.ast.tools.AnnotatedNodeUtils.isGenerated;
 import static org.apache.groovy.ast.tools.AnnotatedNodeUtils.markAsGenerated;
-import static org.codehaus.groovy.ast.ClassHelper.isPrimitiveType;
 import static org.codehaus.groovy.ast.ClassHelper.isObjectType;
 import static org.codehaus.groovy.ast.ClassHelper.isPrimitiveBoolean;
+import static org.codehaus.groovy.ast.ClassHelper.isPrimitiveType;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.isOrImplements;
+import static org.codehaus.groovy.runtime.ArrayGroovyMethods.asBoolean;
 import static org.codehaus.groovy.runtime.ArrayTypeUtils.dimension;
 import static org.codehaus.groovy.runtime.ArrayTypeUtils.elementType;
 import static org.objectweb.asm.Opcodes.ACC_SYNTHETIC;
@@ -88,7 +89,7 @@ public class ClassNodeUtils {
     }
 
     /**
-     * Return an existing method if one exists or else create a new method and mark it as {@code @Generated}.
+     * Returns an existing method if one exists or else create a new method and mark it as {@code @Generated}.
      *
      * @see ClassNode#addMethod(String, int, ClassNode, Parameter[], ClassNode[], Statement)
      */
@@ -106,7 +107,7 @@ public class ClassNodeUtils {
     }
 
     /**
-     * Add a method and mark it as {@code @Generated}.
+     * Adds a method and mark it as {@code @Generated}.
      *
      * @see ClassNode#addMethod(MethodNode)
      */
@@ -116,7 +117,7 @@ public class ClassNodeUtils {
     }
 
     /**
-     * Add a method and mark it as {@code @Generated}.
+     * Adds a method and mark it as {@code @Generated}.
      *
      * @see ClassNode#addMethod(MethodNode)
      */
@@ -126,7 +127,7 @@ public class ClassNodeUtils {
     }
 
     /**
-     * Add an inner class that is marked as {@code @Generated}.
+     * Adds an inner class that is marked as {@code @Generated}.
      *
      * @see org.codehaus.groovy.ast.ModuleNode#addClass(ClassNode)
      */
@@ -136,7 +137,7 @@ public class ClassNodeUtils {
     }
 
     /**
-     * Add a method that is marked as {@code @Generated}.
+     * Adds a method that is marked as {@code @Generated}.
      *
      * @see ClassNode#addConstructor(int, Parameter[], ClassNode[], Statement)
      */
@@ -147,7 +148,7 @@ public class ClassNodeUtils {
     }
 
     /**
-     * Add a method that is marked as {@code @Generated}.
+     * Adds a method that is marked as {@code @Generated}.
      *
      * @see ClassNode#addConstructor(ConstructorNode)
      */
@@ -157,7 +158,7 @@ public class ClassNodeUtils {
     }
 
     /**
-     * Add methods from the super class.
+     * Adds methods from the super class.
      *
      * @param cNode The ClassNode
      * @return A map of methods
@@ -283,7 +284,7 @@ public class ClassNodeUtils {
     }
 
     /**
-     * Return true if we have a static accessor
+     * Returns true if we have a static accessor
      */
     public static boolean hasPossibleStaticProperty(final ClassNode cNode, final String methodName) {
         // assume explicit static method call checked first so we can assume a simple check here
@@ -309,7 +310,7 @@ public class ClassNodeUtils {
     }
 
     /**
-     * Detect whether the given accessor name starts with "get", "set" or "is" followed by at least one character.
+     * Detects whether the given accessor name starts with "get", "set" or "is" followed by at least one character.
      *
      * @param accessorName the accessor name of interest, e.g. getAge
      * @return true if a valid prefix is found
@@ -331,7 +332,7 @@ public class ClassNodeUtils {
     }
 
     /**
-     * Detect whether a static property with the given name is within the class
+     * Detects whether a static property with the given name is within the class
      * or a super class.
      *
      * @param cNode the ClassNode of interest
@@ -350,7 +351,7 @@ public class ClassNodeUtils {
     }
 
     /**
-     * Detect whether a given ClassNode is an inner class (non-static).
+     * Detects whether a given ClassNode is an inner class (non-static).
      *
      * @param cNode the ClassNode of interest
      * @return true if the given node is a (non-static) inner class, else false
@@ -360,7 +361,7 @@ public class ClassNodeUtils {
     }
 
     /**
-     * Check if the source ClassNode is compatible with the target ClassNode
+     * Checks if the source ClassNode is compatible with the target ClassNode
      */
     public static boolean isCompatibleWith(ClassNode source, ClassNode target) {
         if (source.equals(target)) return true;
@@ -385,7 +386,7 @@ public class ClassNodeUtils {
     }
 
     /**
-     * Determine if an explicit (non-generated) constructor is in the class.
+     * Determines if an explicit (non-generated) constructor is in the class.
      *
      * @param xform if non-null, add an error if an explicit constructor is found
      * @param cNode the type of the containing class
@@ -409,7 +410,7 @@ public class ClassNodeUtils {
     }
 
     /**
-     * Determine if the given ClassNode values have the same package name.
+     * Determines if the given ClassNode values have the same package name.
      *
      * @param first a ClassNode
      * @param second a ClassNode
@@ -422,6 +423,8 @@ public class ClassNodeUtils {
 
     /**
      * Searches the class for a field that matches specified name.
+     *
+     * @since 3.0.0
      */
     public static FieldNode getField(final ClassNode classNode, final String fieldName) {
         return getField(classNode, fieldName, fieldNode -> true);
@@ -429,8 +432,10 @@ public class ClassNodeUtils {
 
     /**
      * Searches the class for a field that matches specified name and test.
+     *
+     * @since 4.0.0
      */
-    public static FieldNode getField(final ClassNode classNode, final String fieldName, final Predicate<FieldNode> acceptability) {
+    public static FieldNode getField(final ClassNode classNode, final String fieldName, final Predicate<? super FieldNode> acceptability) {
         Queue<ClassNode> todo = new ArrayDeque<>(Collections.singletonList(classNode));
         Set<ClassNode> done = new HashSet<>();
         ClassNode next;
@@ -450,6 +455,37 @@ public class ClassNodeUtils {
         return null;
     }
 
+    /**
+     * Searches the class for a method that matches specified name and test.
+     *
+     * @since 5.0.0
+     */
+    public static MethodNode getMethod(final ClassNode classNode, final String methodName, final Predicate<? super MethodNode> acceptability) {
+        for (ClassNode next = classNode; next != null; next = next.getSuperClass()) {
+            for (MethodNode methodNode : next.getDeclaredMethods(methodName)) {
+                if (acceptability.test(methodNode)) return methodNode;
+            }
+        }
+
+        if (classNode.isAbstract() && asBoolean(classNode.getInterfaces())) { // GROOVY-11071
+            Queue<ClassNode> todo = new ArrayDeque<>(Arrays.asList(classNode.getInterfaces()));
+            Set<ClassNode> done = new HashSet<>();
+            done.add(classNode);
+            ClassNode next;
+
+            while ((next = todo.poll()) != null) {
+                if (done.add(next)) {
+                    for (MethodNode methodNode : next.getDeclaredMethods(methodName)) {
+                        if (acceptability.test(methodNode)) return methodNode;
+                    }
+                    Collections.addAll(todo, next.getInterfaces());
+                }
+            }
+        }
+
+        return null;
+    }
+
     public static boolean isSubtype(ClassNode maybeSuperclassOrInterface, ClassNode candidateChild) {
         return maybeSuperclassOrInterface.isInterface() || candidateChild.isInterface()
                 ? isOrImplements(candidateChild, maybeSuperclassOrInterface)
diff --git a/src/main/java/org/codehaus/groovy/ast/ClassNode.java b/src/main/java/org/codehaus/groovy/ast/ClassNode.java
index dbb847e354..ae44899316 100644
--- a/src/main/java/org/codehaus/groovy/ast/ClassNode.java
+++ b/src/main/java/org/codehaus/groovy/ast/ClassNode.java
@@ -1097,7 +1097,7 @@ public class ClassNode extends AnnotatedNode {
         if (compileUnit != null) compileUnit = cu;
     }
 
-    @Deprecated
+    @Deprecated(forRemoval = true, since = "4.0.0")
     protected boolean parametersEqual(Parameter[] a, Parameter[] b) {
         return ParameterUtils.parametersEqual(a, b);
     }
diff --git a/src/main/java/org/codehaus/groovy/ast/tools/ParameterUtils.java b/src/main/java/org/codehaus/groovy/ast/tools/ParameterUtils.java
index 89a5458c2f..19bd6dafd5 100644
--- a/src/main/java/org/codehaus/groovy/ast/tools/ParameterUtils.java
+++ b/src/main/java/org/codehaus/groovy/ast/tools/ParameterUtils.java
@@ -35,10 +35,16 @@ public class ParameterUtils {
         return (parameters[parameters.length - 1].getType().isArray());
     }
 
+    /**
+     * @since 2.5.0
+     */
     public static boolean parametersEqual(final Parameter[] a, final Parameter[] b) {
         return parametersEqual(a, b, false);
     }
 
+    /**
+     * @since 3.0.0
+     */
     public static boolean parametersEqualWithWrapperType(final Parameter[] a, final Parameter[] b) {
         return parametersEqual(a, b, true);
     }
diff --git a/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java b/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
index 7c255989b6..e6c2a67cf9 100644
--- a/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
+++ b/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
@@ -54,8 +54,11 @@ import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
 import java.util.Map;
+import java.util.function.BiPredicate;
+import java.util.function.Predicate;
 
 import static org.apache.groovy.ast.tools.ClassNodeUtils.getField;
+import static org.apache.groovy.ast.tools.ClassNodeUtils.getMethod;
 import static org.apache.groovy.ast.tools.ExpressionUtils.isThisExpression;
 import static org.apache.groovy.util.BeanUtils.capitalize;
 import static org.codehaus.groovy.ast.ClassHelper.CLASS_Type;
@@ -74,7 +77,6 @@ import static org.codehaus.groovy.ast.ClassHelper.isBigDecimalType;
 import static org.codehaus.groovy.ast.ClassHelper.isBigIntegerType;
 import static org.codehaus.groovy.ast.ClassHelper.isClassType;
 import static org.codehaus.groovy.ast.ClassHelper.isGeneratedFunction;
-import static org.codehaus.groovy.ast.ClassHelper.isObjectType;
 import static org.codehaus.groovy.ast.ClassHelper.isPrimitiveType;
 import static org.codehaus.groovy.ast.ClassHelper.isStringType;
 import static org.codehaus.groovy.ast.ClassHelper.isWrapperInteger;
@@ -573,8 +575,8 @@ public class StaticTypesCallSiteWriter extends CallSiteWriter {
 
     @Override
     public void makeSingleArgumentCall(final Expression receiver, final String message, final Expression arguments, final boolean safe) {
-        TypeChooser typeChooser = controller.getTypeChooser();
         ClassNode classNode = controller.getClassNode();
+        TypeChooser typeChooser = controller.getTypeChooser();
         ClassNode rType = typeChooser.resolveType(receiver, classNode);
         ClassNode aType = typeChooser.resolveType(arguments, classNode);
         if (trySubscript(receiver, message, arguments, rType, aType, safe)) {
@@ -607,7 +609,8 @@ public class StaticTypesCallSiteWriter extends CallSiteWriter {
             } else if ("power".equals(message)) {
                 writePowerCall(receiver, arguments, rType, aType);
                 return true;
-            } else if ("remainder".equals(message) || "leftShift".equals(message) || "rightShift".equals(message) || "rightShiftUnsigned".equals(message)
+            } else if ("remainder".equals(message) || "leftShift".equals(message)
+                    || "rightShift".equals(message) || "rightShiftUnsigned".equals(message)
                     || "and".equals(message) || "or".equals(message) || "xor".equals(message)) {
                 writeOperatorCall(receiver, arguments, message);
                 return true;
@@ -619,28 +622,8 @@ public class StaticTypesCallSiteWriter extends CallSiteWriter {
             if (rType.isArray() && getWrapper(aType).isDerivedFrom(Number_TYPE) && !safe) {
                 writeArrayGet(receiver, arguments, rType, aType);
                 return true;
-            } else {
-                // check if a getAt method can be found on the receiver
-                ClassNode current = isClassClassNodeWrappingConcreteType(rType) ? rType.getGenericsTypes()[0].getType() : rType;
-                MethodNode getAtNode = null;
-                while (current != null && !isObjectType(current) && getAtNode == null) {
-                    getAtNode = current.getDeclaredMethod("getAt", new Parameter[]{new Parameter(aType, "index")});
-                    if (getAtNode == null) {
-                        getAtNode = getCompatibleMethod(current, "getAt", aType);
-                    }
-                    if (getAtNode == null && isPrimitiveType(aType)) {
-                        getAtNode = current.getDeclaredMethod("getAt", new Parameter[]{new Parameter(getWrapper(aType), "index")});
-                        if (getAtNode == null) {
-                            getAtNode = getCompatibleMethod(current, "getAt", getWrapper(aType));
-                        }
-                    } else if (getAtNode == null && aType.isDerivedFrom(Number_TYPE)) {
-                        getAtNode = current.getDeclaredMethod("getAt", new Parameter[]{new Parameter(getUnwrapper(aType), "index")});
-                        if (getAtNode == null) {
-                            getAtNode = getCompatibleMethod(current, "getAt", getUnwrapper(aType));
-                        }
-                    }
-                    current = current.getSuperClass();
-                }
+            } else { // check the receiver for a getAt method
+                MethodNode getAtNode = findGetAt(rType, aType);
                 if (getAtNode != null) {
                     MethodCallExpression call = callX(receiver, "getAt", arguments);
                     call.setImplicitThis(false);
@@ -650,21 +633,7 @@ public class StaticTypesCallSiteWriter extends CallSiteWriter {
                     call.visit(controller.getAcg());
                     return true;
                 }
-
-                // make sure Map#getAt and List#getAt handled with the bracket syntax are properly compiled
-                ClassNode[] args = {aType};
-                List<MethodNode> nodes = findDGMMethodsByNameAndArguments(controller.getSourceUnit().getClassLoader(), rType, message, args);
-                if (nodes.size() == 1 || (nodes.size() > 1 && (isOrImplements(rType, MAP_TYPE) || isOrImplements(rType, LIST_TYPE)))) {
-                    MethodCallExpression call = callX(receiver, message, arguments);
-                    call.setImplicitThis(false);
-                    call.setMethodTarget(nodes.get(0));
-                    call.setSafe(safe);
-                    call.setSourcePosition(arguments);
-                    call.visit(controller.getAcg());
-                    return true;
-                }
-                if (isOrImplements(rType, MAP_TYPE)) {
-                    // fallback to Map#get
+                if (isOrImplements(rType, MAP_TYPE)) { // fallback to Map#get
                     MethodCallExpression call = callX(receiver, "get", arguments);
                     call.setImplicitThis(false);
                     call.setMethodTarget(MAP_GET_METHOD);
@@ -678,19 +647,45 @@ public class StaticTypesCallSiteWriter extends CallSiteWriter {
         return false;
     }
 
-    private MethodNode getCompatibleMethod(final ClassNode current, final String getAt, final ClassNode aType) {
-        // TODO this really should find "best" match or find all matches and complain about ambiguity if more than one
-        // TODO handle getAt with more than one parameter
-        // TODO handle default getAt methods on Java 8 interfaces
-        for (MethodNode methodNode : current.getDeclaredMethods("getAt")) {
-            if (methodNode.getParameters().length == 1) {
-                ClassNode paramType = methodNode.getParameters()[0].getType();
-                if (aType.isDerivedFrom(paramType) || aType.declaresInterface(paramType)) {
-                    return methodNode;
-                }
+    private MethodNode findGetAt(final ClassNode rType, final ClassNode aType) {
+        // TODO: find "best" match or find all matches and deal with ambiguity
+        // TODO: handle getAt with more than one parameter
+
+        ClassNode classNode = rType;
+        Predicate<MethodNode> compatible = methodNode -> (methodNode.getParameters().length == 1);
+        if (isClassClassNodeWrappingConcreteType(rType)) { // GROOVY-9415
+            classNode = rType.getGenericsTypes()[0].getType();
+            compatible = compatible.and(MethodNode::isStatic);
+        }
+
+        MethodNode getAt = findGetAt(classNode, compatible, aType, true);
+        if (getAt == null) getAt = findGetAt(classNode, compatible, aType, false);
+        if (getAt == null) { // make sure Map#getAt and List#getAt handled with the bracket syntax are properly compiled
+            List<MethodNode> nodes = findDGMMethodsByNameAndArguments(controller.getSourceUnit().getClassLoader(), rType, "getAt", new ClassNode[]{aType});
+            if (nodes.size() == 1 || (nodes.size() > 1 && (isOrImplements(rType, MAP_TYPE) || isOrImplements(rType, LIST_TYPE)))) {
+                getAt = nodes.get(0);
             }
         }
-        return null;
+        return getAt;
+    }
+
+    private MethodNode findGetAt(final ClassNode rType, final Predicate<MethodNode> mTest, final ClassNode aType, final boolean exact) {
+        BiPredicate<MethodNode, ClassNode> pType = (methodNode, argumentType) -> {
+            ClassNode parameterType = methodNode.getParameters()[0].getType();
+            if (exact) {
+                return argumentType.equals(parameterType);
+            } else {
+                return parameterType.isInterface() ? argumentType.implementsInterface(parameterType) : argumentType.isDerivedFrom(parameterType);
+            }
+        };
+
+        MethodNode getAt = getMethod(rType, "getAt", mTest.and(mNode -> pType.test(mNode, aType)));
+        if (getAt == null && isPrimitiveType(aType)) {
+            getAt = getMethod(rType, "getAt", mTest.and(mNode -> pType.test(mNode, getWrapper(aType))));
+        } else if (getAt == null && aType.isDerivedFrom(Number_TYPE)) {
+            getAt = getMethod(rType, "getAt", mTest.and(mNode -> pType.test(mNode, getUnwrapper(aType))));
+        }
+        return getAt;
     }
 
     private void writeArrayGet(final Expression receiver, final Expression arguments, final ClassNode rType, final ClassNode aType) {
diff --git a/src/test/groovy/transform/stc/BugsSTCTest.groovy b/src/test/groovy/transform/stc/BugsSTCTest.groovy
index e79c87af8e..9c50a07d80 100644
--- a/src/test/groovy/transform/stc/BugsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/BugsSTCTest.groovy
@@ -972,6 +972,25 @@ class BugsSTCTest extends StaticTypeCheckingTestCase {
         '''
     }
 
+    // GROOVY-11071
+    void testIfaceGetAtAndSquareBracketIndexing() {
+        assertScript '''
+            interface MapLike<SELF extends MapLike<SELF,K,V>,K,V> {
+                V getAt(K key)
+            }
+            interface MyMap extends MapLike<MyMap,KeyType,Object> {
+            }
+            class KeyType {
+            }
+
+            try {
+                MyMap myMap = null
+                myMap[new KeyType()].toString()
+            } catch (NullPointerException expected) {
+            }
+        '''
+    }
+
     // GROOVY-10741
     void testMethodPointerPropertyReference() {
         assertScript '''
