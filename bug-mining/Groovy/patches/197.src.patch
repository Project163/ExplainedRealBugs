diff --git a/src/main/groovy/lang/Closure.java b/src/main/groovy/lang/Closure.java
index adb86259d5..76bd5d3ee0 100644
--- a/src/main/groovy/lang/Closure.java
+++ b/src/main/groovy/lang/Closure.java
@@ -145,19 +145,8 @@ public abstract class Closure extends GroovyObjectSupport implements Cloneable,
         if ("doCall".equals(method) || "call".equals(method)) {
             if (arguments instanceof Object[]) {
                 Object[] objs = (Object[]) arguments;
-                if ((objs != null) && (objs.length > 1) && (objs[0] instanceof Object[])) {
-                   boolean allNull = true;
-                   for (int j = 1; j < objs.length; j++) {
-                       if (objs[j] != null) {
-                           allNull = false;
-                           break;
-                       }
-                   }
-                   if (allNull)
-                       return callViaReflection((Object[]) (objs[0]));
-                }
             }
-            return callSpecial(arguments);
+            return callSpecial(new ParameterArray(arguments));
         } else if ("curry".equals(method)) {
             return curry((Object[]) arguments);
         } else {
@@ -257,7 +246,7 @@ public abstract class Closure extends GroovyObjectSupport implements Cloneable,
      * @return the value if applicable or null if there is no return statement in the closure
      */
     public Object call() {
-        return call(emptyArray);
+        return call(noParameters);
     }
     
     /**
@@ -272,9 +261,14 @@ public abstract class Closure extends GroovyObjectSupport implements Cloneable,
         if (this.curriedParams.length != 0) {
             final Object args[];
 
-            if (arguments instanceof Object[]) {
-                args = (Object[]) arguments;
-            } else {
+            if (arguments instanceof ParameterArray) {
+                Object paramObj  = ((ParameterArray) arguments).get();
+                if (paramObj instanceof Object[])
+                    args = (Object[]) paramObj;
+                else
+                    args = new Object[] { paramObj };
+            }
+            else {
                 args = new Object[]{arguments};
             }
 
@@ -283,10 +277,15 @@ public abstract class Closure extends GroovyObjectSupport implements Cloneable,
             System.arraycopy(this.curriedParams, 0, params, 0, this.curriedParams.length);
             System.arraycopy(args, 0, params, this.curriedParams.length, args.length);
         } else {
-            if (arguments instanceof Object[]) {
-                params = (Object[]) arguments;
-            } else {
-                return doCall(arguments);
+            if (arguments instanceof ParameterArray) {
+                Object paramObj  = ((ParameterArray) arguments).get();
+                if (paramObj instanceof Object[])
+                    params = (Object[]) paramObj;
+                else
+                    params = new Object[] { paramObj };
+            }
+            else {
+                params = new Object[]{arguments};
             }
         }
 
@@ -325,10 +324,6 @@ public abstract class Closure extends GroovyObjectSupport implements Cloneable,
 
         if (params.length == 0) {
             return doCall();
-        } else if (params.length == 1) {
-            return doCall(params[0]);
-        } else if (params.length == 2) {
-            return doCall(params[0], params[1]);
         } else {
             return callViaReflection(params);
         }
@@ -340,9 +335,14 @@ public abstract class Closure extends GroovyObjectSupport implements Cloneable,
         if (this.curriedParams.length > 0) {
             final Object args[];
 
-            if (arguments instanceof Object[]) {
-                args = (Object[]) arguments;
-            } else {
+            if (arguments instanceof ParameterArray) {
+                Object paramObj  = ((ParameterArray) arguments).get();
+                if (paramObj instanceof Object[])
+                    args = (Object[]) paramObj;
+                else
+                    args = new Object[] { paramObj };
+            }
+            else {
                 args = new Object[]{arguments};
             }
 
@@ -350,31 +350,20 @@ public abstract class Closure extends GroovyObjectSupport implements Cloneable,
 
             System.arraycopy(this.curriedParams, 0, params, 0, this.curriedParams.length);
             System.arraycopy(args, 0, params, this.curriedParams.length, args.length);
-        } else {
+        }
+        else {
             Object[] tmpParams = null;
-            if (arguments instanceof Object[]) {
-                tmpParams = (Object[]) arguments;
-
-                if ((tmpParams != null) && (tmpParams.length > 1)) {
-                    boolean allNull = true;
-                    for (int j = 1; j < tmpParams.length; j++) {
-                        if (tmpParams[j] != null) {
-                            allNull = false;
-                            break;
-                        }
-                    }
-                    if (allNull) {
-                        if (tmpParams[0] instanceof Object[])
-                            tmpParams = (Object[]) (tmpParams[0]);
-                        else
-                            throw new IncorrectClosureArgumentsException(this, new Object[] { tmpParams[0] }, this.parameterTypes);
-                    }
-                }
-                params = tmpParams;
-
-            } else {
-                return doCall(arguments);
+            if (arguments instanceof ParameterArray) {
+                Object paramObj  = ((ParameterArray) arguments).get();
+                if (paramObj instanceof Object[])
+                    tmpParams = (Object[]) paramObj;
+                else
+                    tmpParams = new Object[] { paramObj };
             }
+            else {
+                tmpParams = new Object[]{arguments};
+            }
+            params = tmpParams;
         }
 
         final int lastParam = this.numberOfParameters - 1;
@@ -412,10 +401,6 @@ public abstract class Closure extends GroovyObjectSupport implements Cloneable,
 
         if (params.length == 0) {
             return doCall();
-        } else if (params.length == 1) {
-            return doCall(params[0]);
-        } else if (params.length == 2) {
-            return doCall(params[0], params[1]);
         } else {
             return callViaReflection(params);
         }
@@ -470,7 +455,11 @@ public abstract class Closure extends GroovyObjectSupport implements Cloneable,
     private Object callViaReflection(final Object params[]) {
         try {
             // invoke the closure
-            return ((Method) callsMap.get(new Integer(params.length))).invoke(this, params);
+            if (callsMap.get(new Integer(params.length)) != null) {
+                return ((Method) callsMap.get(new Integer(params.length))).invoke(this, params);
+            }
+            else
+                return this.doCallMethod.invoke(this, params);
         } catch (final IllegalArgumentException e) {
             throw new IncorrectClosureArgumentsException(this, params, this.parameterTypes);
         } catch (final IllegalAccessException e) {
@@ -576,7 +565,7 @@ public abstract class Closure extends GroovyObjectSupport implements Cloneable,
      * @see groovy.lang.Writable#writeTo(java.io.Writer)
      */
         public Writer writeTo(Writer out) throws IOException {
-            Closure.this.call(out);
+            Closure.this.call(new ParameterArray(out));
 
             return out;
         }
diff --git a/src/main/groovy/lang/MetaClass.java b/src/main/groovy/lang/MetaClass.java
index 386da320db..8fbe0753c3 100644
--- a/src/main/groovy/lang/MetaClass.java
+++ b/src/main/groovy/lang/MetaClass.java
@@ -316,7 +316,7 @@ public class MetaClass {
                 if (value instanceof Closure && object!=this) {
                     Closure closure = (Closure) value;
                     closure.setDelegate(this);
-                    return closure.call(arguments);
+                    return closure.call(new ParameterArray(arguments));
                 }
                 else {
                     throw new MissingMethodException(methodName, theClass, arguments);
@@ -988,6 +988,7 @@ public class MetaClass {
                     throw new MissingPropertyException(property, theClass, e2);
                 }
             }
+            
         }
         catch (GroovyRuntimeException e) {
             throw new MissingPropertyException(property, theClass, e);
@@ -2466,6 +2467,7 @@ public class MetaClass {
         catch (Exception e) {
             // lets ignore, lets generate it && load it
         }
+        finally {
 
         ClassWriter cw = new ClassWriter(true);
         generator.generate(cw, name);
@@ -2479,6 +2481,7 @@ public class MetaClass {
         catch (Exception e) {
             throw new GroovyRuntimeException("Could not load the reflector for class: " + name + ". Reason: " + e, e);
         }
+        }
     }
 
     protected Class loadReflectorClass(final String name, final byte[] bytecode) throws ClassNotFoundException {
diff --git a/src/main/groovy/lang/ParameterArray.java b/src/main/groovy/lang/ParameterArray.java
new file mode 100644
index 0000000000..c1da1162e4
--- /dev/null
+++ b/src/main/groovy/lang/ParameterArray.java
@@ -0,0 +1,78 @@
+/*
+ $Id$
+
+ Copyright 2003 (C) James Strachan and Bob Mcwhirter. All Rights Reserved.
+
+ Redistribution and use of this software and associated documentation
+ ("Software"), with or without modification, are permitted provided
+ that the following conditions are met:
+
+ 1. Redistributions of source code must retain copyright
+    statements and notices.  Redistributions must also contain a
+    copy of this document.
+
+ 2. Redistributions in binary form must reproduce the
+    above copyright notice, this list of conditions and the
+    following disclaimer in the documentation and/or other
+    materials provided with the distribution.
+
+ 3. The name "groovy" must not be used to endorse or promote
+    products derived from this Software without prior written
+    permission of The Codehaus.  For written permission,
+    please contact info@codehaus.org.
+
+ 4. Products derived from this Software may not be called "groovy"
+    nor may "groovy" appear in their names without prior written
+    permission of The Codehaus. "groovy" is a registered
+    trademark of The Codehaus.
+
+ 5. Due credit should be given to The Codehaus -
+    http://groovy.codehaus.org/
+
+ THIS SOFTWARE IS PROVIDED BY THE CODEHAUS AND CONTRIBUTORS
+ ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+ NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ THE CODEHAUS OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ OF THE POSSIBILITY OF SUCH DAMAGE.
+
+ */
+package groovy.lang;
+
+/**
+ * Distinguish a parameter array from Object[].
+ *
+ * @author Pilho Kim
+ * @version $Revision$
+ */
+public class ParameterArray {
+
+    private Object parameters;
+
+    public ParameterArray(Object data) {
+        parameters = packArray(data);
+    }
+
+    private Object packArray(Object object) {
+        if (object instanceof Object[])
+            return (Object[]) object;
+        else
+            return object;
+    }
+
+    public Object get() {
+        return parameters;
+    }
+
+    public String toString() {
+        if (parameters == null)
+            return "<null parameter>";
+        return parameters.toString();
+    }
+}
diff --git a/src/main/groovy/mock/ClosureConstraintMatcher.java b/src/main/groovy/mock/ClosureConstraintMatcher.java
index 03f938e89e..1edfe74dfb 100644
--- a/src/main/groovy/mock/ClosureConstraintMatcher.java
+++ b/src/main/groovy/mock/ClosureConstraintMatcher.java
@@ -1,6 +1,7 @@
 package groovy.mock;
 
 import groovy.lang.Closure;
+import groovy.lang.ParameterArray;
 
 import com.mockobjects.constraint.Constraint;
 
@@ -20,7 +21,7 @@ public class ClosureConstraintMatcher implements Constraint {
 
     public boolean eval(Object object) {
         try {
-            closure.call(object);
+            closure.call(new ParameterArray(object));
             return true;
         }
         catch (AssertionError e) {
diff --git a/src/main/groovy/text/GStringTemplateEngine.java b/src/main/groovy/text/GStringTemplateEngine.java
index 9e669ca931..abf5e9bb7e 100644
--- a/src/main/groovy/text/GStringTemplateEngine.java
+++ b/src/main/groovy/text/GStringTemplateEngine.java
@@ -254,7 +254,7 @@ public class GStringTemplateEngine extends TemplateEngine {
                * @see groovy.lang.Writable#writeTo(java.io.Writer)
                */
                public Writer writeTo(final Writer writer) throws IOException {
-                   delegatedClosure.call(new Object[] {new PrintWriter(writer)});
+                   delegatedClosure.call(new ParameterArray(new PrintWriter(writer)));
 
                    return writer;
                }
diff --git a/src/main/groovy/util/ClosureComparator.java b/src/main/groovy/util/ClosureComparator.java
index aa2af0fda2..d96f211530 100644
--- a/src/main/groovy/util/ClosureComparator.java
+++ b/src/main/groovy/util/ClosureComparator.java
@@ -46,6 +46,7 @@
 package groovy.util;
 
 import groovy.lang.Closure;
+import groovy.lang.ParameterArray;
 
 import java.util.Comparator;
 
@@ -66,7 +67,7 @@ public class ClosureComparator implements Comparator {
     }
 
     public int compare(Object object1, Object object2) {
-        Object value = closure.call(new Object[] {object1, object2});
+        Object value = closure.call(new ParameterArray(new Object[] {object1, object2}));
         return InvokerHelper.asInt(value);
     }
 }
diff --git a/src/main/groovy/util/Expando.java b/src/main/groovy/util/Expando.java
index 82bf9eff5e..940563fd7a 100644
--- a/src/main/groovy/util/Expando.java
+++ b/src/main/groovy/util/Expando.java
@@ -45,6 +45,7 @@
  */
 package groovy.util;
 
+import groovy.lang.ParameterArray;
 import groovy.lang.Closure;
 import groovy.lang.GroovyObjectSupport;
 import groovy.lang.GroovyRuntimeException;
@@ -63,6 +64,7 @@ import java.util.Iterator;
  * 
  * @author <a href="mailto:james@coredevelopers.net">James Strachan</a>
  * @author Hein Meling
+ * @author Pilho Kim
  * @version $Revision$
  */
 public class Expando extends GroovyObjectSupport {
@@ -85,18 +87,18 @@ public class Expando extends GroovyObjectSupport {
         }
         return expandoProperties;
     }
-	
-	public List getProperties() {
-		// run through all our current properties and create MetaProperty objects
-		List ret = new ArrayList();
-		Iterator itr = getExpandoProperties().entrySet().iterator();
-		while(itr.hasNext()) {
-			Entry entry = (Entry) itr.next();
-			ret.add(new MetaExpandoProperty(entry));
-		}
+
+    public List getProperties() {
+        // run through all our current properties and create MetaProperty objects
+        List ret = new ArrayList();
+        Iterator itr = getExpandoProperties().entrySet().iterator();
+        while(itr.hasNext()) {
+            Entry entry = (Entry) itr.next();
+            ret.add(new MetaExpandoProperty(entry));
+        }
 		
-		return ret;
-	}
+        return ret;
+    }
 
     public Object getProperty(String property) {
         try {
@@ -121,12 +123,12 @@ public class Expando extends GroovyObjectSupport {
             return super.invokeMethod(name, args);
         }
         catch (GroovyRuntimeException e) {
-        	// br should get a "native" property match first. getProperty includes such fall-back logic
+            // br should get a "native" property match first. getProperty includes such fall-back logic
             Object value = this.getProperty(name);
             if (value instanceof Closure) {
                 Closure closure = (Closure) value;
                 closure.setDelegate(this);
-                return closure.call(args);
+                return closure.call(new ParameterArray(args));
             }
             else {
                 throw e;
@@ -134,7 +136,7 @@ public class Expando extends GroovyObjectSupport {
         }
         
     }
-
+    
     /**
      * This allows toString to be overridden by a closure <i>field</i> method attached
      * to the expando object.
diff --git a/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java b/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java
index 2c507c78fe..88425c330c 100644
--- a/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java
+++ b/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java
@@ -549,14 +549,15 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
         VariableExpression leftExpression = new VariableExpression(name, type);
         configureAST(leftExpression, paramNode);
 
-        Expression rightExpression = null;
+        Parameter parameter = null;
         if (node != null) {
             assertNodeType(ASSIGN, node);
-
-            rightExpression = expression(node.getFirstChild());
+            Expression rightExpression = expression(node.getFirstChild());
+            parameter = new Parameter(type, name, rightExpression);
         }
+        else
+            parameter = new Parameter(type, name);
 
-        Parameter parameter = new Parameter(type, name, rightExpression);
         // TODO
         //configureAST(parameter,paramNode);
         //parameter.addAnnotations(annotations);
diff --git a/src/main/org/codehaus/groovy/ast/MethodNode.java b/src/main/org/codehaus/groovy/ast/MethodNode.java
index 4b371d1dfd..3a7e1eb3e9 100644
--- a/src/main/org/codehaus/groovy/ast/MethodNode.java
+++ b/src/main/org/codehaus/groovy/ast/MethodNode.java
@@ -61,6 +61,7 @@ public class MethodNode extends AnnotatedNode implements Opcodes {
     private int modifiers;
     private String returnType;
     private Parameter[] parameters;
+    private boolean hasDefaultValue = false;
     private Statement code;
     private boolean dynamicReturnType;
     private VariableScope variableScope;
@@ -71,6 +72,15 @@ public class MethodNode extends AnnotatedNode implements Opcodes {
         this.parameters = parameters;
         this.code = code;
 
+        if (parameters != null && parameters.length > 0) {
+            for (int i = 0; i < parameters.length; i++) {
+                if (parameters[i].hasDefaultValue()) {
+                    this.hasDefaultValue = true;
+                    break;
+                }
+            }
+        }
+
         if (returnType == null || returnType.length() == 0) {
             this.returnType = "java.lang.Object";
             this.dynamicReturnType = true;
@@ -199,6 +209,10 @@ public class MethodNode extends AnnotatedNode implements Opcodes {
         return (modifiers & ACC_STATIC) != 0;
     }
 
+    public boolean hasDefaultValue() {
+        return this.hasDefaultValue;
+    }
+
     public String toString() {
         return super.toString() + "[name: " + name + "]";
     }
diff --git a/src/main/org/codehaus/groovy/ast/Parameter.java b/src/main/org/codehaus/groovy/ast/Parameter.java
index b2a950c79b..0c007ab111 100644
--- a/src/main/org/codehaus/groovy/ast/Parameter.java
+++ b/src/main/org/codehaus/groovy/ast/Parameter.java
@@ -66,19 +66,30 @@ public class Parameter {
     private boolean dynamicType;
     private Expression defaultValue;
     private String realType;
+    final private boolean hasDefaultValue;
 
     public Parameter(String name) {
-        this(null, name);
+        this.name = null;
+        this.hasDefaultValue = false;
+        this.type = "java.lang.Object";
+        this.dynamicType = true;
     }
 
     public Parameter(String type, String name) {
-        this(type, name, null);
+        this.name = MethodNode.ensureJavaTypeNameSyntax(name);
+        this.type = type;
+        this.hasDefaultValue = false;
+        if (type == null || type.length() == 0) {
+            this.type = "java.lang.Object";
+            this.dynamicType = true;
+        }
     }
 
     public Parameter(String type, String name, Expression defaultValue) {
         this.name = MethodNode.ensureJavaTypeNameSyntax(name);
         this.type = type;
         this.defaultValue = defaultValue;
+        this.hasDefaultValue = true;
         if (type == null || type.length() == 0) {
             this.type = "java.lang.Object";
             this.dynamicType = true;
@@ -86,7 +97,7 @@ public class Parameter {
     }
 
     public String toString() {
-        return super.toString() + "[name:" + name + ((type == null) ? "" : " type: " + type) + "]";
+        return super.toString() + "[name:" + name + ((type == null) ? "" : " type: " + type) + ", hasDefaultValue: " + this.hasDefaultValue() + "]";
     }
 
     public String getName() {
@@ -105,6 +116,10 @@ public class Parameter {
         return dynamicType;
     }
     
+    public boolean hasDefaultValue() {
+        return this.hasDefaultValue;
+    }
+    
     /**
      * @return the default value expression for this parameter or null if
      * no default value is specified
diff --git a/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java b/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
index 00585e416e..11e01882a4 100644
--- a/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
+++ b/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
@@ -3458,7 +3458,7 @@ public class AsmClassGenerator extends ClassGenerator {
         Parameter[] parameters = expression.getParameters();
         if (parameters == null || parameters.length == 0) {
             // lets create a default 'it' parameter
-            parameters = new Parameter[] { new Parameter("it")};
+            parameters = new Parameter[] { new Parameter("java.lang.Object", "it", ConstantExpression.NULL)};
         }
 
         Parameter[] localVariableParams = getClosureSharedVariables(expression);
diff --git a/src/main/org/codehaus/groovy/classgen/Verifier.java b/src/main/org/codehaus/groovy/classgen/Verifier.java
index 69389670f3..f9d249baed 100644
--- a/src/main/org/codehaus/groovy/classgen/Verifier.java
+++ b/src/main/org/codehaus/groovy/classgen/Verifier.java
@@ -394,18 +394,92 @@ public class Verifier implements GroovyClassVisitor, Opcodes {
         List methods = new ArrayList(node.getMethods());
         for (Iterator iter = methods.iterator(); iter.hasNext();) {
             MethodNode method = (MethodNode) iter.next();
-            Parameter[] parameters = method.getParameters();
-            int size = parameters.length;
-            for (int i = 0; i < size; i++) {
-                Parameter parameter = parameters[i];
-                Expression exp = parameter.getDefaultValue();
-                if (exp != null) {
-                    addDefaultParameterMethod(node, method, parameters, i);
+            if (method.hasDefaultValue()) {
+                Parameter[] parameters = method.getParameters();
+                int counter = 0;
+                ArrayList paramValues = new ArrayList();
+                int size = parameters.length;
+                for (int i = size - 1; i >= 0; i--) {
+                    Parameter parameter = parameters[i];
+                    if (parameter != null && parameter.hasDefaultValue()) {
+                        paramValues.add(new Integer(i));
+                        paramValues.add(parameter.getDefaultValue());
+                        counter++;
+                    }
+                }
+
+                for (int j = 1; j <= counter; j++) {
+                    Parameter[] newParams =  new Parameter[parameters.length - j];
+                    ArgumentListExpression arguments = new ArgumentListExpression();
+                    int index = 0;
+                    int k = 1;
+                    for (int i = 0; i < parameters.length; i++) {
+                        if (k > counter - j && parameters[i] != null && parameters[i].hasDefaultValue()) {
+                            arguments.addExpression(parameters[i].getDefaultValue());
+                            k++;
+                        }
+                        else if (parameters[i] != null && parameters[i].hasDefaultValue()) {
+                            newParams[index++] = parameters[i];
+                            arguments.addExpression(new VariableExpression(parameters[i].getName()));
+                            k++;
+                        }
+                        else {
+                            newParams[index++] = parameters[i];
+                            arguments.addExpression(new VariableExpression(parameters[i].getName()));
+                        }
+                    }
+
+                    MethodCallExpression expression = new MethodCallExpression(VariableExpression.THIS_EXPRESSION, method.getName(), arguments);
+                    Statement code = null;
+                    if (method.isVoidMethod()) {
+                        code = new ExpressionStatement(expression);
+                    }
+                    else {
+                        code = new ReturnStatement(expression);
+                    }
+                    node.addMethod(method.getName(), method.getModifiers(), method.getReturnType(), newParams, code);
                 }
             }
         }
     }
 
+    /**
+     * Adds a new method which defaults the values for all the parameters starting 
+     * from and including the given index
+     * 
+     * @param node the class to add the method
+     * @param method the given method to add a helper of
+     * @param parameters the parameters of the method to add a helper for
+     * @param index the index of the first default value expression parameter to use
+     */
+    protected void addDefaultParameterMethod(ClassNode node, MethodNode method, Parameter[] parameters, int depth, ArrayList values) {
+        // lets create a method using this expression
+        Parameter[] newParams = new Parameter[parameters.length - depth];
+        int index = 0;
+        ArgumentListExpression arguments = new ArgumentListExpression();
+        for (int i = 0; i < parameters.length; i++) {
+            if (parameters[i] != null && parameters[i].hasDefaultValue()) {
+                newParams[index++] = parameters[i];
+                arguments.addExpression(new VariableExpression(parameters[i].getName()));
+            }
+            else {
+                arguments.addExpression(parameters[i].getDefaultValue());
+            }
+        }
+
+        MethodCallExpression expression =
+            new MethodCallExpression(VariableExpression.THIS_EXPRESSION, method.getName(), arguments);
+        Statement code = null;
+        if (method.isVoidMethod()) {
+            code = new ExpressionStatement(expression);
+        }
+        else {
+            code = new ReturnStatement(expression);
+        }
+
+        node.addMethod(method.getName(), method.getModifiers(), method.getReturnType(), newParams, code);
+    }
+
     /**
      * Adds a new method which defaults the values for all the parameters starting 
      * from and including the given index
diff --git a/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java b/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
index 3311802d96..ceda3c98a4 100644
--- a/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
+++ b/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
@@ -383,6 +383,13 @@ PropertyValue pv = (PropertyValue) itr.next();
         }
     }
 
+    private static Object packArray(Object object) {
+        if (object instanceof Object[])
+            return new Object[] {object};
+        else
+            return object;
+    }
+
     // Collection based methods
     //-------------------------------------------------------------------------
 
@@ -418,7 +425,7 @@ PropertyValue pv = (PropertyValue) itr.next();
      */
     public static void each(Object self, Closure closure) {
         for (Iterator iter = InvokerHelper.asIterator(self); iter.hasNext();) {
-            closure.call(iter.next());
+            closure.callSpecial(iter.next());
         }
     }
 
@@ -443,7 +450,7 @@ PropertyValue pv = (PropertyValue) itr.next();
      */
     public static void each(Collection self, Closure closure) {
         for (Iterator iter = self.iterator(); iter.hasNext();) {
-            closure.call(iter.next());
+            closure.callSpecial(iter.next());
         }
     }
 
@@ -474,7 +481,7 @@ PropertyValue pv = (PropertyValue) itr.next();
      */
     public static boolean every(Object self, Closure closure) {
         for (Iterator iter = InvokerHelper.asIterator(self); iter.hasNext();) {
-            if (!InvokerHelper.asBool(closure.call(iter.next()))) {
+            if (!InvokerHelper.asBool(closure.callSpecial(iter.next()))) {
                 return false;
             }
         }
@@ -490,7 +497,7 @@ PropertyValue pv = (PropertyValue) itr.next();
      */
     public static boolean any(Object self, Closure closure) {
         for (Iterator iter = InvokerHelper.asIterator(self); iter.hasNext();) {
-            if (InvokerHelper.asBool(closure.call(iter.next()))) {
+            if (InvokerHelper.asBool(closure.callSpecial(iter.next()))) {
                 return true;
             }
         }
@@ -570,7 +577,7 @@ PropertyValue pv = (PropertyValue) itr.next();
      */
     public static Collection collect(Object self, Collection collection, Closure closure) {
         for (Iterator iter = InvokerHelper.asIterator(self); iter.hasNext();) {
-            collection.add(closure.call(iter.next()));
+            collection.add(closure.callSpecial(iter.next()));
         }
         return collection;
     }
@@ -598,7 +605,7 @@ PropertyValue pv = (PropertyValue) itr.next();
      */
     public static Collection collect(Collection self, Collection collection, Closure closure) {
         for (Iterator iter = self.iterator(); iter.hasNext();) {
-            collection.add(closure.call(iter.next()));
+            collection.add(closure.callSpecial(iter.next()));
             if (closure.getDirective() == Closure.DONE) {
                 break;
             }
@@ -616,7 +623,7 @@ PropertyValue pv = (PropertyValue) itr.next();
      */
     public static Collection collect(Map self, Collection collection, Closure closure) {
         for (Iterator iter = self.entrySet().iterator(); iter.hasNext();) {
-            collection.add(closure.call(iter.next()));
+            collection.add(closure.callSpecial(iter.next()));
         }
         return collection;
     }
@@ -644,7 +651,7 @@ PropertyValue pv = (PropertyValue) itr.next();
     public static Object find(Object self, Closure closure) {
         for (Iterator iter = InvokerHelper.asIterator(self); iter.hasNext();) {
             Object value = iter.next();
-            if (InvokerHelper.asBool(closure.call(value))) {
+            if (InvokerHelper.asBool(closure.callSpecial(value))) {
                 return value;
             }
         }
@@ -661,7 +668,7 @@ PropertyValue pv = (PropertyValue) itr.next();
     public static Object find(Collection self, Closure closure) {
         for (Iterator iter = self.iterator(); iter.hasNext();) {
             Object value = iter.next();
-            if (InvokerHelper.asBool(closure.call(value))) {
+            if (InvokerHelper.asBool(closure.callSpecial(value))) {
                 return value;
             }
         }
@@ -678,7 +685,7 @@ PropertyValue pv = (PropertyValue) itr.next();
     public static Object find(Map self, Closure closure) {
         for (Iterator iter = self.entrySet().iterator(); iter.hasNext();) {
             Object value = iter.next();
-            if (InvokerHelper.asBool(closure.call(value))) {
+            if (InvokerHelper.asBool(closure.callSpecial(value))) {
                 return value;
             }
         }
@@ -696,7 +703,7 @@ PropertyValue pv = (PropertyValue) itr.next();
         List answer = new ArrayList();
         for (Iterator iter = InvokerHelper.asIterator(self); iter.hasNext();) {
             Object value = iter.next();
-            if (InvokerHelper.asBool(closure.call(value))) {
+            if (InvokerHelper.asBool(closure.callSpecial(value))) {
                 answer.add(value);
             }
         }
@@ -745,7 +752,7 @@ PropertyValue pv = (PropertyValue) itr.next();
     // internal helper method
     protected static Object callClosureForMapEntry(Closure closure, Map.Entry entry) {
         if (closure.getParameterTypes().length == 2) {
-            return closure.call(new Object[]{entry.getKey(), entry.getValue()});
+            return closure.call(new ParameterArray(new Object[]{entry.getKey(), entry.getValue()}));
         }
         return closure.call(entry);
     }
@@ -767,7 +774,7 @@ PropertyValue pv = (PropertyValue) itr.next();
             Object item = iter.next();
             params[0] = value;
             params[1] = item;
-            value = closure.call(params);
+            value = closure.call(new ParameterArray(params));
         }
         return value;
     }
@@ -2101,7 +2108,7 @@ PropertyValue pv = (PropertyValue) itr.next();
     public static void reverseEach(List self, Closure closure) {
         List reversed = reverse(self);
         for (Iterator iter = reversed.iterator(); iter.hasNext();) {
-            closure.call(iter.next());
+            closure.callSpecial(iter.next());
         }
     }
 
@@ -3919,7 +3926,7 @@ PropertyValue pv = (PropertyValue) itr.next();
                 try {
                     Object obj = ois.readObject();
                     // we allow null objects in the object stream
-                    closure.call(obj);
+                    closure.call(new ParameterArray(obj));
                 } catch (EOFException e) {
                     break;
                 }
@@ -5049,7 +5056,7 @@ PropertyValue pv = (PropertyValue) itr.next();
         InputStream input = socket.getInputStream();
         OutputStream output = socket.getOutputStream();
         try {
-            closure.call(new Object[]{input, output});
+            closure.call(new ParameterArray(new Object[]{input, output}));
         } finally {
             try {
                 input.close();
diff --git a/src/main/org/codehaus/groovy/sandbox/markup/BaseMarkupBuilder.java b/src/main/org/codehaus/groovy/sandbox/markup/BaseMarkupBuilder.java
index ad4a3c9e9e..a396644440 100644
--- a/src/main/org/codehaus/groovy/sandbox/markup/BaseMarkupBuilder.java
+++ b/src/main/org/codehaus/groovy/sandbox/markup/BaseMarkupBuilder.java
@@ -45,6 +45,7 @@ OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
 import groovy.lang.Closure;
+import groovy.lang.ParameterArray;
 
 import java.util.Collections;
 import java.util.HashMap;
@@ -120,9 +121,9 @@ public class BaseMarkupBuilder extends Builder {
 			this.prefix = "";
 			
 			if (tagMap.containsKey(name)) {
-				return ((Closure)tagMap.get(name)).call(new Object[]{this, this.pendingNamespaces, this.namespaces, this.namespaceSpecificTags, prefix, attrs, body, this.out});
+				return ((Closure)tagMap.get(name)).call(new ParameterArray(new Object[]{this, this.pendingNamespaces, this.namespaces, this.namespaceSpecificTags, prefix, attrs, body, this.out}));
 			} else {
-				return defaultTagClosure.call(new Object[]{name, this, this.pendingNamespaces, this.namespaces, this.namespaceSpecificTags, prefix, attrs, body, this.out});		
+				return defaultTagClosure.call(new ParameterArray(new Object[]{name, this, this.pendingNamespaces, this.namespaces, this.namespaceSpecificTags, prefix, attrs, body, this.out}));		
 			}
 		}
 		
diff --git a/src/test/groovy/DefaultParamTest.groovy b/src/test/groovy/DefaultParamTest.groovy
index de000e854d..0281284aab 100644
--- a/src/test/groovy/DefaultParamTest.groovy
+++ b/src/test/groovy/DefaultParamTest.groovy
@@ -28,6 +28,19 @@ class DefaultParamTest extends GroovyTestCase {
     	assert value == "defA-defB-defC"
     }
 
+    void testDefaultTypedParametersAnother() {
+    	def value = doTypedSomethingAnother("X", "Y", "Z")
+    	assert value == "X-Y-Z"
+    	
+    	value = doTypedSomethingAnother("X", "Z")
+    	assert value == "X-defB-Z"
+    	
+    	value = doTypedSomethingAnother("Z")
+    	assert value == "defA-defB-Z"
+    	
+    	shouldFail{ value = doTypedSomethingAnother() }
+    }
+
 
     def doSomething(a, b = 'defB', c = 'defC') {
         println "Called with a: ${a}, b ${b}, c ${c}"
@@ -40,4 +53,10 @@ class DefaultParamTest extends GroovyTestCase {
 
         return a + "-" + b + "-" + c
     }
+
+    String doTypedSomethingAnother(String a = 'defA', String b = 'defB', String c) {
+        println "Called typed method with a: ${a}, b ${b}, c ${c}"
+
+        return a + "-" + b + "-" + c
+    }
 }
\ No newline at end of file
diff --git a/src/test/org/codehaus/groovy/classgen/ForTest.java b/src/test/org/codehaus/groovy/classgen/ForTest.java
index 484c0fa39b..996c24220e 100644
--- a/src/test/org/codehaus/groovy/classgen/ForTest.java
+++ b/src/test/org/codehaus/groovy/classgen/ForTest.java
@@ -49,22 +49,52 @@ package org.codehaus.groovy.classgen;
 import org.codehaus.groovy.ast.*;
 import org.codehaus.groovy.ast.expr.VariableExpression;
 import org.codehaus.groovy.ast.stmt.ForStatement;
+import org.codehaus.groovy.ast.stmt.BlockStatement;
 import org.codehaus.groovy.ast.stmt.Statement;
 import org.codehaus.groovy.runtime.InvokerHelper;
 import org.codehaus.groovy.runtime.InvokerInvocationException;
 
 /**
  * @author <a href="mailto:james@coredevelopers.net">James Strachan</a>
+ * @author Pilho Kim
  * @version $Revision$
  */
 public class ForTest extends TestSupport {
 
+    public void testNonLoop() throws Exception {
+        ClassNode classNode = new ClassNode("Foo", ACC_PUBLIC, "java.lang.Object");
+        classNode.addConstructor(new ConstructorNode(ACC_PUBLIC, null));
+
+        Parameter[] parameters = {new Parameter("Object", "coll")};
+
+        Statement statement = createPrintlnStatement(new VariableExpression("coll"));
+        classNode.addMethod(new MethodNode("oneParamDemo", ACC_PUBLIC, "void", parameters, statement));
+
+        Class fooClass = loadClass(classNode);
+        assertTrue("Loaded a new class", fooClass != null);
+
+        Object bean = fooClass.newInstance();
+        assertTrue("Managed to create bean", bean != null);
+
+        System.out.println("################ Now about to invoke a method without looping");
+        Object value = new Integer(10000);
+
+        try {
+            InvokerHelper.invokeMethod(bean, "oneParamDemo", new Object[] {value});
+        } catch (InvokerInvocationException e) {
+            System.out.println("Caught: " + e.getCause());
+            e.getCause().printStackTrace();
+            fail("Should not have thrown an exception");
+        }
+        System.out.println("################ Done");
+    }
+
+
     public void testLoop() throws Exception {
         ClassNode classNode = new ClassNode("Foo", ACC_PUBLIC, "java.lang.Object");
         classNode.addConstructor(new ConstructorNode(ACC_PUBLIC, null));
-        classNode.addProperty(new PropertyNode("bar", ACC_PUBLIC, "java.lang.String", "Foo", null, null, null));
 
-        Parameter[] parameters = {new Parameter("coll")};
+        Parameter[] parameters = {new Parameter("Object[]", "coll")};
 
         Statement loopStatement = createPrintlnStatement(new VariableExpression("i"));
 
@@ -77,8 +107,7 @@ public class ForTest extends TestSupport {
         Object bean = fooClass.newInstance();
         assertTrue("Managed to create bean", bean != null);
 
-        System.out.println("################ Now about to invoke method");
-
+        System.out.println("################ Now about to invoke a method with looping");
         Object[] array = {new Integer(1234), "abc", "def"};
 
         try {
@@ -90,4 +119,36 @@ public class ForTest extends TestSupport {
         }
         System.out.println("################ Done");
     }
+
+    public void testManyParam() throws Exception {
+        ClassNode classNode = new ClassNode("Foo", ACC_PUBLIC, "java.lang.Object");
+        classNode.addConstructor(new ConstructorNode(ACC_PUBLIC, null));
+
+        Parameter[] parameters = { new Parameter("Object", "coll1"), new Parameter("Object", "coll2"), new Parameter("Object", "coll3") };
+
+        BlockStatement statement = new BlockStatement();
+        statement.addStatement(createPrintlnStatement(new VariableExpression("coll1")));
+        statement.addStatement(createPrintlnStatement(new VariableExpression("coll2")));
+        statement.addStatement(createPrintlnStatement(new VariableExpression("coll3")));
+
+        classNode.addMethod(new MethodNode("manyParamDemo", ACC_PUBLIC, "void", parameters, statement));
+
+        Class fooClass = loadClass(classNode);
+        assertTrue("Loaded a new class", fooClass != null);
+
+        Object bean = fooClass.newInstance();
+        assertTrue("Managed to create bean", bean != null);
+
+        System.out.println("################ Now about to invoke a method with many parameters");
+        Object[] array = {new Integer(1000*1000), "foo-", "bar~"};
+
+        try {
+            InvokerHelper.invokeMethod(bean, "manyParamDemo", array);
+        } catch (InvokerInvocationException e) {
+            System.out.println("Caught: " + e.getCause());
+            e.getCause().printStackTrace();
+            fail("Should not have thrown an exception");
+        }
+        System.out.println("################ Done");
+    }
 }
