diff --git a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java
index f6b0b10c13..14a2ea4e9c 100644
--- a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java
+++ b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java
@@ -45,6 +45,7 @@ import java.util.Map;
 import java.util.concurrent.atomic.AtomicInteger;
 
 import static org.codehaus.groovy.ast.ClassHelper.CLOSURE_TYPE;
+import static org.codehaus.groovy.ast.ClassHelper.getWrapper;
 import static org.codehaus.groovy.transform.sc.StaticCompilationMetadataKeys.PRIVATE_BRIDGE_METHODS;
 import static org.objectweb.asm.Opcodes.*;
 
@@ -416,17 +417,15 @@ public class StaticInvocationWriter extends InvocationWriter {
             newMCE.setImplicitThis(origMCE.isImplicitThis());
             newMCE.setSourcePosition(origMCE);
             newMCE.visit(controller.getAcg());
+            ClassNode returnType = operandStack.getTopOperand();
+            if (ClassHelper.isPrimitiveType(returnType) && !ClassHelper.VOID_TYPE.equals(returnType)) {
+                operandStack.box();
+            }
             Label endof = compileStack.createLocalLabel("endof_" + counter);
             mv.visitJumpInsn(GOTO, endof);
             mv.visitLabel(ifnull);
             // else { null }
-            ClassNode returnType = methodTarget.getReturnType();
-            if (ClassHelper.isPrimitiveType(returnType)
-                    && !ClassHelper.VOID_TYPE.equals(returnType)) {
-                pushZero(mv, returnType);
-            } else {
-                mv.visitInsn(ACONST_NULL);
-            }
+            mv.visitInsn(ACONST_NULL);
             mv.visitLabel(endof);
         } else {
             if ((adapter == AsmClassGenerator.getGroovyObjectField
diff --git a/src/main/org/codehaus/groovy/transform/sc/transformers/BooleanExpressionTransformer.java b/src/main/org/codehaus/groovy/transform/sc/transformers/BooleanExpressionTransformer.java
index 186372e58d..b1a87d40b5 100644
--- a/src/main/org/codehaus/groovy/transform/sc/transformers/BooleanExpressionTransformer.java
+++ b/src/main/org/codehaus/groovy/transform/sc/transformers/BooleanExpressionTransformer.java
@@ -103,31 +103,33 @@ public class BooleanExpressionTransformer {
                     controller.getOperandStack().replace(ClassHelper.boolean_TYPE);
                     return;
                 }
-                if (type.equals(ClassHelper.int_TYPE) || type.equals(ClassHelper.byte_TYPE)
-                        || type.equals(ClassHelper.short_TYPE) || type.equals(ClassHelper.char_TYPE)) {
-                    // int on stack
+                ClassNode top = type;
+                if (ClassHelper.isPrimitiveType(top)) {
                     expression.visit(visitor);
-                    return;
-                } else if (type.equals(ClassHelper.long_TYPE)) {
-                    expression.visit(visitor);
-                    MethodVisitor mv = controller.getMethodVisitor();
-                    mv.visitInsn(L2I);
-                    controller.getOperandStack().replace(ClassHelper.boolean_TYPE);
-                    return;
-                } else if (type.equals(ClassHelper.float_TYPE)) {
-                    expression.visit(visitor);
-                    MethodVisitor mv = controller.getMethodVisitor();
-                    mv.visitInsn(F2I);
-                    controller.getOperandStack().replace(ClassHelper.boolean_TYPE);
-                    return;
-                } else if (type.equals(ClassHelper.double_TYPE)) {
-                    expression.visit(visitor);
-                    MethodVisitor mv = controller.getMethodVisitor();
-                    mv.visitInsn(D2I);
-                    controller.getOperandStack().replace(ClassHelper.boolean_TYPE);
-                    return;
+                    // in case of null safe invocation, it is possible that what was supposed to be a primitive type
+                    // becomes the "null" constant, so we need to recheck
+                    top = controller.getOperandStack().getTopOperand();
+                    if (ClassHelper.isPrimitiveType(top)) {
+                        if (top.equals(ClassHelper.int_TYPE) || top.equals(ClassHelper.byte_TYPE)
+                                || top.equals(ClassHelper.short_TYPE) || top.equals(ClassHelper.char_TYPE)) {
+                            // int on stack
+                        } else if (top.equals(ClassHelper.long_TYPE)) {
+                            MethodVisitor mv = controller.getMethodVisitor();
+                            mv.visitInsn(L2I);
+                            controller.getOperandStack().replace(ClassHelper.boolean_TYPE);
+                        } else if (top.equals(ClassHelper.float_TYPE)) {
+                            MethodVisitor mv = controller.getMethodVisitor();
+                            mv.visitInsn(F2I);
+                            controller.getOperandStack().replace(ClassHelper.boolean_TYPE);
+                        } else if (top.equals(ClassHelper.double_TYPE)) {
+                            MethodVisitor mv = controller.getMethodVisitor();
+                            mv.visitInsn(D2I);
+                            controller.getOperandStack().replace(ClassHelper.boolean_TYPE);
+                        }
+                        return;
+                    }
                 }
-                List<MethodNode> asBoolean = findDGMMethodsByNameAndArguments(controller.getSourceUnit().getClassLoader(), type, "asBoolean", ClassNode.EMPTY_ARRAY);
+                List<MethodNode> asBoolean = findDGMMethodsByNameAndArguments(controller.getSourceUnit().getClassLoader(), top, "asBoolean", ClassNode.EMPTY_ARRAY);
                 if (asBoolean.size() == 1) {
                     MethodNode node = asBoolean.get(0);
                     if (node instanceof ExtensionMethodNode) {
@@ -140,10 +142,10 @@ public class BooleanExpressionTransformer {
                             // For (2), we check that we are in one of those cases
                             // (a) a final class
                             // (b) a private inner class without subclass
-                            if (Modifier.isFinal(type.getModifiers())
-                                    || (type instanceof InnerClassNode
-                                    && Modifier.isPrivate(type.getModifiers())
-                                    && !isExtended(type, type.getOuterClass().getInnerClasses()))
+                            if (Modifier.isFinal(top.getModifiers())
+                                    || (top instanceof InnerClassNode
+                                    && Modifier.isPrivate(top.getModifiers())
+                                    && !isExtended(top, top.getOuterClass().getInnerClasses()))
                                     ) {
                                 CompareToNullExpression expr = new CompareToNullExpression(
                                         expression, false
diff --git a/src/main/org/codehaus/groovy/transform/sc/transformers/CompareToNullExpression.java b/src/main/org/codehaus/groovy/transform/sc/transformers/CompareToNullExpression.java
index ac569c2fb9..9eb350f6a2 100644
--- a/src/main/org/codehaus/groovy/transform/sc/transformers/CompareToNullExpression.java
+++ b/src/main/org/codehaus/groovy/transform/sc/transformers/CompareToNullExpression.java
@@ -54,24 +54,24 @@ public class CompareToNullExpression extends BinaryExpression implements Opcodes
         if (visitor instanceof AsmClassGenerator) {
             AsmClassGenerator acg = (AsmClassGenerator) visitor;
             WriterController controller = acg.getController();
-            ClassNode objectType = controller.getTypeChooser().resolveType(objectExpression, controller.getClassNode());
             MethodVisitor mv = controller.getMethodVisitor();
-            if (ClassHelper.isPrimitiveType(objectType)) {
-                // we're in a primitive == null comparison, which *always* return false
+            objectExpression.visit(acg);
+            ClassNode top = controller.getOperandStack().getTopOperand();
+            if (ClassHelper.isPrimitiveType(top)) {
+                controller.getOperandStack().pop();
                 mv.visitInsn(ICONST_0);
                 controller.getOperandStack().push(ClassHelper.boolean_TYPE);
-            } else {
-                objectExpression.visit(acg);
-                Label zero = new Label();
-                mv.visitJumpInsn(equalsNull?IFNONNULL:IFNULL, zero);
-                mv.visitInsn(ICONST_1);
-                Label end = new Label();
-                mv.visitJumpInsn(GOTO, end);
-                mv.visitLabel(zero);
-                mv.visitInsn(ICONST_0);
-                mv.visitLabel(end);
-                controller.getOperandStack().replace(ClassHelper.boolean_TYPE);
+                return;
             }
+            Label zero = new Label();
+            mv.visitJumpInsn(equalsNull ? IFNONNULL : IFNULL, zero);
+            mv.visitInsn(ICONST_1);
+            Label end = new Label();
+            mv.visitJumpInsn(GOTO, end);
+            mv.visitLabel(zero);
+            mv.visitInsn(ICONST_0);
+            mv.visitLabel(end);
+            controller.getOperandStack().replace(ClassHelper.boolean_TYPE);
         } else {
             super.visit(visitor);
         }
diff --git a/src/main/org/codehaus/groovy/transform/sc/transformers/MethodCallExpressionTransformer.java b/src/main/org/codehaus/groovy/transform/sc/transformers/MethodCallExpressionTransformer.java
index 9a71538ada..6d49f0fca9 100644
--- a/src/main/org/codehaus/groovy/transform/sc/transformers/MethodCallExpressionTransformer.java
+++ b/src/main/org/codehaus/groovy/transform/sc/transformers/MethodCallExpressionTransformer.java
@@ -32,28 +32,6 @@ public class MethodCallExpressionTransformer {
 
     Expression transformMethodCallExpression(final MethodCallExpression expr) {
         Expression objectExpression = expr.getObjectExpression();
-        if (expr.isSafe()) {
-            MethodCallExpression notSafe = new MethodCallExpression(
-                    objectExpression,
-                    expr.getMethod(),
-                    expr.getArguments()
-            );
-            notSafe.copyNodeMetaData(expr);
-            notSafe.setSpreadSafe(expr.isSpreadSafe());
-            notSafe.setSourcePosition(expr);
-            notSafe.setMethodTarget(expr.getMethodTarget());
-            notSafe.setImplicitThis(expr.isImplicitThis());
-            TernaryExpression texpr = new TernaryExpression(
-                    new BooleanExpression(new BinaryExpression(
-                            objectExpression,
-                            Token.newSymbol("!=", objectExpression.getLineNumber(), objectExpression.getColumnNumber()),
-                            ConstantExpression.NULL
-                    )),
-                    notSafe,
-                    ConstantExpression.NULL);
-            return staticCompilationTransformer.transform(texpr);
-
-        }
         ClassNode type = staticCompilationTransformer.getTypeChooser().resolveType(objectExpression, staticCompilationTransformer.getClassNode());
         if (type != null && type.isArray()) {
             String method = expr.getMethodAsString();
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/BugsStaticCompileTest.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/BugsStaticCompileTest.groovy
index cd6e241ebd..200f150b77 100644
--- a/src/test/org/codehaus/groovy/classgen/asm/sc/BugsStaticCompileTest.groovy
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/BugsStaticCompileTest.groovy
@@ -768,6 +768,40 @@ import groovy.transform.TypeCheckingMode
         '''
     }
 
+    // GROOVY-6101
+    void testShouldNotGenerateInvalidClassWithNullSafeInvocationOnMethodReturningPrimitiveType() {
+        assertScript '''
+        class Piece {
+            int x() { 333 }
+        }
 
+        void foo() {
+            Piece[] pieces = [new Piece(), null] as Piece[]
+            int sum = 0
+            for (int i=0;i<pieces.length;i++) {
+                if (pieces[i]?.x()) {
+                    sum += pieces[i].x()
+                }
+            }
+            assert sum == 333
+        }
+        foo()
+        '''
+    }
+
+    // GROOVY-6101 fix side effect
+    void testMakeSureOptimizationKeepsSideEffect() {
+        assertScript '''
+            class Foo {
+                boolean hasSideEffect = false
+                int x() { hasSideEffect=true; 333 }
+            }
+            Foo foo = new Foo()
+            if (foo.x()==null) {
+                println 'ok'
+            }
+            assert foo.hasSideEffect
+         '''
+    }
 }
 
