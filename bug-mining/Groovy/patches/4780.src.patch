diff --git a/src/main/java/org/codehaus/groovy/ast/ClassNode.java b/src/main/java/org/codehaus/groovy/ast/ClassNode.java
index 9d1b65316d..2fe66e16fe 100644
--- a/src/main/java/org/codehaus/groovy/ast/ClassNode.java
+++ b/src/main/java/org/codehaus/groovy/ast/ClassNode.java
@@ -51,6 +51,7 @@ import static java.util.Objects.requireNonNull;
 import static java.util.stream.Collectors.toList;
 import static org.apache.groovy.ast.tools.MethodNodeUtils.getCodeAsBlock;
 import static org.codehaus.groovy.transform.RecordTypeASTTransformation.recordNative;
+import static org.codehaus.groovy.transform.trait.Traits.isTrait;
 import static org.objectweb.asm.Opcodes.ACC_ABSTRACT;
 import static org.objectweb.asm.Opcodes.ACC_ANNOTATION;
 import static org.objectweb.asm.Opcodes.ACC_ENUM;
@@ -397,9 +398,13 @@ public class ClassNode extends AnnotatedNode {
         if (!lazyInitDone && !isResolved()) {
             throw new GroovyBugError("ClassNode#getSuperClass for " + getName() + " called before class resolving");
         }
-        ClassNode sn = redirect().getUnresolvedSuperClass();
-        if (sn != null) sn = sn.redirect();
-        return sn;
+        var sc = redirect().getUnresolvedSuperClass();
+        if (sc != null) {
+            sc = sc.redirect();
+            if (isPrimaryClassNode() && (sc.isInterface() || isTrait(sc)))
+                sc = ClassHelper.OBJECT_TYPE; // GROOVY-8272, GROOVY-11299
+        }
+        return sc;
     }
 
     public void setSuperClass(final ClassNode superClass) {
diff --git a/src/main/java/org/codehaus/groovy/control/StaticImportVisitor.java b/src/main/java/org/codehaus/groovy/control/StaticImportVisitor.java
index 99bfaf6a83..999f945231 100644
--- a/src/main/java/org/codehaus/groovy/control/StaticImportVisitor.java
+++ b/src/main/java/org/codehaus/groovy/control/StaticImportVisitor.java
@@ -65,12 +65,12 @@ import static org.apache.groovy.ast.tools.ClassNodeUtils.isInnerClass;
 import static org.apache.groovy.ast.tools.ClassNodeUtils.isValidAccessorName;
 import static org.apache.groovy.ast.tools.ClassNodeUtils.samePackageName;
 import static org.apache.groovy.ast.tools.ExpressionUtils.isSuperExpression;
-import static org.apache.groovy.ast.tools.ExpressionUtils.isThisOrSuper;
 import static org.apache.groovy.ast.tools.ExpressionUtils.transformInlineConstants;
 import static org.apache.groovy.util.BeanUtils.capitalize;
 import static org.codehaus.groovy.ast.tools.ClosureUtils.getParametersSafe;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.getGetterName;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.getSetterName;
+import static org.codehaus.groovy.transform.trait.Traits.isTrait;
 
 /**
  * Visitor to resolve constants and method calls from static imports.
@@ -271,43 +271,42 @@ public class StaticImportVisitor extends ClassCodeExpressionTransformer {
             return result;
         }
 
-        if (method instanceof ConstantExpression && ((ConstantExpression) method).getValue() instanceof String && (mce.isImplicitThis() || isThisOrSuper(object))) {
-            String methodName = (String) ((ConstantExpression) method).getValue();
+        if (method instanceof ConstantExpression && ((ConstantExpression) method).getValue() instanceof String
+                && mce.isImplicitThis() && !isTrait(currentClass)) { // GROOVY-7191, GROOVY-8272, GROOVY-10312
+            String name = mce.getMethodAsString();
 
-            boolean foundInstanceMethod = !staticWrtCurrent && currentClass.hasPossibleMethod(methodName, args);
+            boolean foundInstanceMethod = !staticWrtCurrent && currentClass.hasPossibleMethod(name, args);
 
             Predicate<ClassNode> hasPossibleStaticMember = cn -> {
-                if (hasPossibleStaticMethod(cn, methodName, args, true)) {
+                if (hasPossibleStaticMethod(cn, name, args, true)) {
                     return true;
                 }
-                // GROOVY-9587: don't check for property for non-empty call args
+                // GROOVY-9587: skip property check for non-empty call arguments
                 if (args instanceof TupleExpression && ((TupleExpression) args).getExpressions().isEmpty()
-                        && hasPossibleStaticProperty(cn, methodName)) {
+                        && hasPossibleStaticProperty(cn, name)) {
                     return true;
                 }
                 return false;
             };
 
-            if (mce.isImplicitThis()) {
-                if (isInnerClass(currentClass)) {
-                    if (inSpecialConstructorCall && !foundInstanceMethod) {
-                        // check for reference to outer class method in this(...) or super(...)
-                        if (currentClass.getOuterClass().hasPossibleMethod(methodName, args)) {
-                            object = new PropertyExpression(new ClassExpression(currentClass.getOuterClass()), new ConstantExpression("this"));
-                        } else if (hasPossibleStaticMember.test(currentClass.getOuterClass())) {
-                            Expression result = new StaticMethodCallExpression(currentClass.getOuterClass(), methodName, args);
-                            result.setSourcePosition(mce);
-                            return result;
-                        }
-                    }
-                } else if (inSpecialConstructorCall || (!inClosure && !foundInstanceMethod && !methodName.equals("call"))) {
-                    // check for reference to static method in this(...) or super(...) or when call not resolved
-                    if (hasPossibleStaticMember.test(currentClass)) {
-                        Expression result = new StaticMethodCallExpression(currentClass, methodName, args);
+            if (isInnerClass(currentClass)) {
+                if (inSpecialConstructorCall && !foundInstanceMethod) {
+                    // check for reference to outer class method in this(...) or super(...)
+                    if (currentClass.getOuterClass().hasPossibleMethod(name, args)) {
+                        object = new PropertyExpression(new ClassExpression(currentClass.getOuterClass()), new ConstantExpression("this"));
+                    } else if (hasPossibleStaticMember.test(currentClass.getOuterClass())) {
+                        Expression result = new StaticMethodCallExpression(currentClass.getOuterClass(), name, args);
                         result.setSourcePosition(mce);
                         return result;
                     }
                 }
+            } else if (inSpecialConstructorCall || (!inClosure && !foundInstanceMethod && !name.equals("call"))) {
+                // check for reference to static method in this(...) or super(...) or when call not resolved
+                if (hasPossibleStaticMember.test(currentClass)) {
+                    Expression result = new StaticMethodCallExpression(currentClass, name, args);
+                    result.setSourcePosition(mce);
+                    return result;
+                }
             }
         }
 
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/TraitTypeCheckingExtension.java b/src/main/java/org/codehaus/groovy/transform/stc/TraitTypeCheckingExtension.java
index cb0e316409..f0b2b9157e 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/TraitTypeCheckingExtension.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/TraitTypeCheckingExtension.java
@@ -72,10 +72,10 @@ public class TraitTypeCheckingExtension extends AbstractTypeCheckingExtension {
 
         if (call instanceof MethodCallExpression) {
             MethodCallExpression mce = (MethodCallExpression) call;
-            ClassNode dynamic = mce.getNodeMetaData(TraitASTTransformation.DO_DYNAMIC);
-            if (dynamic != null) return Collections.singletonList(makeDynamic(call, dynamic));
+            ClassNode returnType = mce.getNodeMetaData(TraitASTTransformation.DO_DYNAMIC);
+            if (returnType != null) return Collections.singletonList(makeDynamic(call, returnType));
 
-            // GROOVY-7322, GROOVY-8272, GROOVY-8587, GROOVY-8854: trait: this.m($static$self)
+            // GROOVY-7322, GROOVY-8272, GROOVY-8587, GROOVY-8854, GROOVY-10312: trait: this.m($static$self)
             ClassNode targetClass = isClassClassNodeWrappingConcreteType(receiver)? receiver.getGenericsTypes()[0].getType(): receiver;
             if (Traits.isTrait(targetClass.getOuterClass()) && argumentTypes.length > 0 && ClassHelper.isClassType(argumentTypes[0])) {
                 Parameter[] signature = java.util.Arrays.stream(argumentTypes).map(t -> new Parameter(t,"")).toArray(Parameter[]::new);
diff --git a/src/main/java/org/codehaus/groovy/transform/trait/TraitReceiverTransformer.java b/src/main/java/org/codehaus/groovy/transform/trait/TraitReceiverTransformer.java
index 3e91cb7261..7784ec31be 100644
--- a/src/main/java/org/codehaus/groovy/transform/trait/TraitReceiverTransformer.java
+++ b/src/main/java/org/codehaus/groovy/transform/trait/TraitReceiverTransformer.java
@@ -37,7 +37,6 @@ import org.codehaus.groovy.ast.expr.Expression;
 import org.codehaus.groovy.ast.expr.FieldExpression;
 import org.codehaus.groovy.ast.expr.MethodCallExpression;
 import org.codehaus.groovy.ast.expr.PropertyExpression;
-import org.codehaus.groovy.ast.expr.StaticMethodCallExpression;
 import org.codehaus.groovy.ast.expr.TupleExpression;
 import org.codehaus.groovy.ast.expr.VariableExpression;
 import org.codehaus.groovy.control.SourceUnit;
@@ -101,31 +100,10 @@ class TraitReceiverTransformer extends ClassCodeExpressionTransformer {
         } else if (exp instanceof MethodCallExpression) {
             MethodCallExpression mce = (MethodCallExpression) exp;
             String obj = mce.getObjectExpression().getText();
-            if (mce.isImplicitThis() || "this".equals(obj)) {
-                return transformMethodCallOnThis(mce); // this.m(p) --> this.m($self, p)
-            } else if ("super".equals(obj)) {
-                return transformSuperMethodCall(mce); // super.m(p) --> $self.Ttrait$super$m(p)
-            }
-        } else if (exp instanceof StaticMethodCallExpression) {
-            StaticMethodCallExpression call = (StaticMethodCallExpression) exp;
-            if (call.getOwnerType().equals(traitClass)) {
-                // GROOVY-7191, GROOVY-8272, GROOVY-8854, GROOVY-10312: T.m(p) --> this.m($static$self, p)
-                Expression staticSelf = varX(weaved);
-                if (!ClassHelper.isClassType(weavedType)) {
-                    staticSelf = callX(staticSelf, "getClass");
-                    ((MethodCallExpression) staticSelf).setImplicitThis(false);
-                    staticSelf = castX(ClassHelper.CLASS_Type.getPlainNodeReference(), staticSelf);
-                }
-                MethodCallExpression mce = callX(
-                        varX("this"),
-                        call.getMethod(),
-                        createArgumentList(staticSelf, call.getArguments())
-                );
-                mce.setSafe(false);
-                mce.setSpreadSafe(false);
-                mce.setImplicitThis(false);
-                mce.setSourcePosition(exp);
-                return mce;
+            if ("super".equals(obj)) {
+                return transformSuperMethodCall(mce); // super.m(x) --> $self.Ttrait$super$m(x)
+            } else if ("this".equals(obj)) {
+                return transformMethodCallOnThis(mce); // this.m(x) --> $self.m(x) or this.m($self, x)
             }
         } else if (exp instanceof FieldExpression) {
             FieldNode fn = ((FieldExpression) exp).getField();
@@ -303,32 +281,25 @@ class TraitReceiverTransformer extends ClassCodeExpressionTransformer {
     }
 
     private Expression transformMethodCallOnThis(final MethodCallExpression call) {
-        Expression method = call.getMethod();
+        Expression method    = call.getMethod();
         Expression arguments = call.getArguments();
-        Expression thisExpr = call.getObjectExpression();
+        Expression thisExpr  = call.getObjectExpression();
 
         if (method instanceof ConstantExpression) {
-            String methodName = call.getMethodAsString();
-            for (MethodNode methodNode : traitClass.getMethods(methodName)) {
-                if (methodName.equals(methodNode.getName()) && (methodNode.isStatic() || methodNode.isPrivate())) {
-                    MethodCallExpression newCall;
-                    if (!inClosure && methodNode.isStatic()) { // GROOVY-10312: $self or $static$self.staticMethod(...)
-                        newCall = callX(varX(weaved), methodName, transform(arguments));
-                        newCall.setImplicitThis(false);
-                        newCall.setSafe(false);
-                    } else {
-                        ArgumentListExpression newArgs = createArgumentList(methodNode.isStatic() ? asClass(thisExpr) : weaved, arguments);
-                        newCall = callX(inClosure ? classX(traitHelperClass) : thisExpr, methodName, newArgs);
-                        newCall.setImplicitThis(true);
-                        newCall.setSafe(call.isSafe());
-                    }
-                    newCall.setSpreadSafe(call.isSpreadSafe());
-                    newCall.setSourcePosition(call);
-                    return newCall;
-                }
+            // GROOVY-7213, GROOVY-7214, GROOVY-8282, GROOVY-8859, GROOVY-10106, GROOVY-10312
+            MethodNode methodNode = findConcreteMethod(traitClass, call.getMethodAsString());
+            if (methodNode != null) {
+                // this.m(x) --> (this or T$Trait$Helper).m($self or $static$self or (Class)$self.getClass(), x)
+                Expression selfClassOrObject = methodNode.isStatic() && !ClassHelper.isClassType(weaved.getOriginType()) ? castX(ClassHelper.CLASS_Type.getPlainNodeReference(), callX(weaved, "getClass")) : weaved;
+                MethodCallExpression newCall = callX(!inClosure ? thisExpr : classX(traitHelperClass), method, createArgumentList(selfClassOrObject, arguments));
+                newCall.setGenericsTypes(call.getGenericsTypes());
+                newCall.setSpreadSafe(call.isSpreadSafe());
+                newCall.setSourcePosition(call);
+                return newCall;
             }
         }
 
+        // this.m(x) --> ($self or $static$self).m(x)
         MethodCallExpression newCall = callX(inClosure ? thisExpr : weaved, method, transform(arguments));
         newCall.setImplicitThis(inClosure ? call.isImplicitThis() : false);
         newCall.setSafe(inClosure ? call.isSafe() : false);
@@ -337,6 +308,29 @@ class TraitReceiverTransformer extends ClassCodeExpressionTransformer {
         return newCall;
     }
 
+    private static MethodNode findConcreteMethod(final ClassNode traitClass, final String methodName) {
+        for (MethodNode methodNode : traitClass.getDeclaredMethods(methodName)) {
+            if (methodNode.isPrivate() || methodNode.isStatic()) {
+                return methodNode;
+            }
+        }
+
+        // GROOVY-8272, GROOVY-10312: public static method from super trait
+        var traits = Traits.findTraits(traitClass); traits.remove(traitClass);
+
+        for (ClassNode superTrait : traits) {
+            for (MethodNode methodNode : Traits.findHelper(superTrait).getDeclaredMethods(methodName)) {
+                if (methodNode.isPublic() && methodNode.isStatic()
+                        // exclude public method with body as it's included in trait interface
+                        && ClassHelper.isClassType(methodNode.getParameters()[0].getType())) {
+                    return methodNode;
+                }
+            }
+        }
+
+        return null;
+    }
+
     private ArgumentListExpression createArgumentList(final Expression self, final Expression arguments) {
         ArgumentListExpression newArgs = new ArgumentListExpression();
         newArgs.addExpression(self);
diff --git a/src/test/org/codehaus/groovy/transform/traitx/Groovy7214Bug.groovy b/src/test/org/codehaus/groovy/transform/traitx/Groovy7214Bug.groovy
deleted file mode 100644
index 68f6c96ad8..0000000000
--- a/src/test/org/codehaus/groovy/transform/traitx/Groovy7214Bug.groovy
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one
- *  or more contributor license agreements.  See the NOTICE file
- *  distributed with this work for additional information
- *  regarding copyright ownership.  The ASF licenses this file
- *  to you under the Apache License, Version 2.0 (the
- *  "License"); you may not use this file except in compliance
- *  with the License.  You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing,
- *  software distributed under the License is distributed on an
- *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- *  KIND, either express or implied.  See the License for the
- *  specific language governing permissions and limitations
- *  under the License.
- */
-package org.codehaus.groovy.transform.traitx
-
-import groovy.test.GroovyTestCase
-
-class Groovy7214Bug extends GroovyTestCase {
-    void testShouldAllowPrivateStaticMethodCallInTrait() {
-        assertScript '''
-            trait SomeTrait {
-                private static int magic = 0
-
-                static getSomeValue() {
-                    someHelperMethod()
-                    magic
-                }
-
-                private static someHelperMethod() {
-                    magic = 42
-                }
-            }
-            class SomeClass implements SomeTrait {}
-
-            assert SomeClass.someValue == 42'''
-    }
-}
diff --git a/src/test/org/codehaus/groovy/transform/traitx/TraitASTTransformationTest.groovy b/src/test/org/codehaus/groovy/transform/traitx/TraitASTTransformationTest.groovy
index 3b4e555a80..1b9aaf6ac5 100644
--- a/src/test/org/codehaus/groovy/transform/traitx/TraitASTTransformationTest.groovy
+++ b/src/test/org/codehaus/groovy/transform/traitx/TraitASTTransformationTest.groovy
@@ -1687,6 +1687,26 @@ final class TraitASTTransformationTest {
                 assert c.foo() == 1
                 assert c.foo() == 2
             """
+
+            // GROOVY-7214
+            assertScript shell, """
+                $mode
+                trait T {
+                    private static int x = 0
+                    private static initX() {
+                        x = 42
+                    }
+                    static getValue() {
+                        initX()
+                        x
+                    }
+                }
+                $mode
+                class C implements T {
+                }
+
+                assert C.value == 42
+            """
         }
     }
 
@@ -2933,7 +2953,7 @@ final class TraitASTTransformationTest {
             @SelfType(T)
             trait B implements A {
                 void methodB() {
-                    methodA() // Cannot find matching method <UnionType:T+B>#methodA()
+                    methodA() // Cannot find matching method (T & B)#methodA()
                 }
             }
             class C extends T implements B {
