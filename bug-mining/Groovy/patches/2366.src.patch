diff --git a/src/main/org/codehaus/groovy/classgen/asm/InvocationWriter.java b/src/main/org/codehaus/groovy/classgen/asm/InvocationWriter.java
index ef9ffa662e..152103dcff 100644
--- a/src/main/org/codehaus/groovy/classgen/asm/InvocationWriter.java
+++ b/src/main/org/codehaus/groovy/classgen/asm/InvocationWriter.java
@@ -34,7 +34,8 @@ public class InvocationWriter {
     public static final MethodCallerMultiAdapter invokeMethod = MethodCallerMultiAdapter.newStatic(ScriptBytecodeAdapter.class, "invokeMethod", true, false);
     public static final MethodCallerMultiAdapter invokeStaticMethod = MethodCallerMultiAdapter.newStatic(ScriptBytecodeAdapter.class, "invokeStaticMethod", true, true);
     public static final MethodCaller invokeClosureMethod = MethodCaller.newStatic(ScriptBytecodeAdapter.class, "invokeClosure");
-
+    private static final MethodNode CLASS_FOR_NAME_STRING = ClassHelper.CLASS_Type.getDeclaredMethod("forName", new Parameter[]{new Parameter(ClassHelper.STRING_TYPE,"name")}); 
+    
     private WriterController controller;
     
     public InvocationWriter(WriterController wc) {
@@ -199,6 +200,8 @@ public class InvocationWriter {
         MethodCallerMultiAdapter adapter,
         boolean implicitThis, boolean containsSpreadExpression
     ) {
+        if (makeClassForNameCall(origin, receiver, message, arguments)) return true;
+
         // optimization path
         boolean fittingAdapter =   adapter == invokeMethodOnCurrent ||
                                     adapter == invokeStaticMethod;
@@ -323,6 +326,7 @@ public class InvocationWriter {
     ) {
         // direct method call paths
         boolean containsSpreadExpression = AsmClassGenerator.containsSpreadExpression(arguments);
+
         if (makeDirectCall(origin, receiver, message, arguments, adapter, implicitThis, containsSpreadExpression)) return;
 
         // normal path
@@ -332,6 +336,20 @@ public class InvocationWriter {
         makeUncachedCall(origin, sender, receiver, message, arguments, adapter, safe, spreadSafe, implicitThis, containsSpreadExpression);
     }
 
+    /**
+     * if Class.forName(x) is recognized, make a direct method call
+     */
+    protected boolean makeClassForNameCall(Expression origin, Expression receiver, Expression message, Expression arguments) {
+        if (! (receiver instanceof ClassExpression)) return false;
+        ClassExpression ce = (ClassExpression) receiver;
+        if (!ClassHelper.CLASS_Type.equals(ce.getType())) return false;
+        String msg = getMethodName(message);
+        if (!"forName".equals(msg)) return false;
+        ArgumentListExpression ae = makeArgumentList(arguments);
+        if (ae.getExpressions().size()!=1) return false;
+        return writeDirectMethodCall(CLASS_FOR_NAME_STRING,false, receiver, ae);
+    }
+
     public static ArgumentListExpression makeArgumentList(Expression arguments) {
         ArgumentListExpression ae;
         if (arguments instanceof ArgumentListExpression) {
diff --git a/src/test/org/codehaus/groovy/classgen/asm/DirectMethodCallTest.groovy b/src/test/org/codehaus/groovy/classgen/asm/DirectMethodCallTest.groovy
index 6c87798e61..c4a3480c1f 100644
--- a/src/test/org/codehaus/groovy/classgen/asm/DirectMethodCallTest.groovy
+++ b/src/test/org/codehaus/groovy/classgen/asm/DirectMethodCallTest.groovy
@@ -23,4 +23,15 @@ class DirectMethodCallTest extends AbstractBytecodeTestCase {
               "INVOKEVIRTUAL java/lang/Integer.toString ()Ljava/lang/String;"
       ])
   }
+  
+  //GROOVY-6384
+  void testClassForNameAutomaticDirectCall() {
+      ['"Foo"',1,null,"println(x)"].each { arg ->
+          assert compile (method:"run", """
+              Class.forName($arg)
+          """).hasSequence([
+              "INVOKESTATIC java/lang/Class.forName (Ljava/lang/String;)Ljava/lang/Class;"
+          ])
+      }
+  }
 }
