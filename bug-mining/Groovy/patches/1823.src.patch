diff --git a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
index 2ccec49913..7eb793c75c 100644
--- a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
+++ b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
@@ -18,19 +18,19 @@ package org.codehaus.groovy.classgen.asm.sc;
 import org.codehaus.groovy.GroovyBugError;
 import org.codehaus.groovy.ast.*;
 import org.codehaus.groovy.ast.expr.*;
+import org.codehaus.groovy.classgen.BytecodeExpression;
 import org.codehaus.groovy.classgen.asm.*;
 import org.codehaus.groovy.runtime.MetaClassHelper;
 import org.codehaus.groovy.syntax.SyntaxException;
 import org.codehaus.groovy.transform.sc.StaticCompilationMetadataKeys;
 import org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport;
 import org.codehaus.groovy.transform.stc.StaticTypesMarker;
+import org.objectweb.asm.Label;
 import org.objectweb.asm.MethodVisitor;
 import org.objectweb.asm.Opcodes;
 
-import java.io.FileWriter;
-import java.io.IOException;
-import java.io.PrintWriter;
 import java.lang.reflect.Modifier;
+import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
 import java.util.Map;
@@ -95,13 +95,13 @@ public class StaticTypesCallSiteWriter extends CallSiteWriter implements Opcodes
         if (!isStaticProperty) {
             if (receiverType.implementsInterface(ClassHelper.MAP_TYPE)) {
                 // for maps, replace map.foo with map.get('foo')
-                receiver.visit(controller.getAcg()); // load receiver
-                mv.visitLdcInsn(methodName); // load property name
-                mv.visitMethodInsn(INVOKEINTERFACE, "java/util/Map", "get", "(Ljava/lang/Object;)Ljava/lang/Object;");
-                controller.getOperandStack().replace(ClassHelper.OBJECT_TYPE);
+                writeMapDotProperty(receiver, methodName, mv);
+                return;
+            }
+            if (receiverType.implementsInterface(ClassHelper.LIST_TYPE)) {
+                writeListDotProperty(receiver, methodName, mv);
                 return;
             }
-
         }
 
         if (receiverType.isArray() && methodName.equals("length")) {
@@ -151,6 +151,84 @@ public class StaticTypesCallSiteWriter extends CallSiteWriter implements Opcodes
         controller.getOperandStack().push(ClassHelper.OBJECT_TYPE);
     }
 
+    private void writeMapDotProperty(final Expression receiver, final String methodName, final MethodVisitor mv) {
+        receiver.visit(controller.getAcg()); // load receiver
+        mv.visitLdcInsn(methodName); // load property name
+        mv.visitMethodInsn(INVOKEINTERFACE, "java/util/Map", "get", "(Ljava/lang/Object;)Ljava/lang/Object;");
+        controller.getOperandStack().replace(ClassHelper.OBJECT_TYPE);
+    }
+
+    private void writeListDotProperty(final Expression receiver, final String methodName, final MethodVisitor mv) {
+        ClassNode componentType = (ClassNode) receiver.getNodeMetaData(StaticCompilationMetadataKeys.COMPONENT_TYPE);
+        if (componentType==null) {
+            componentType = ClassHelper.OBJECT_TYPE;
+        }
+        // for lists, replace list.foo with:
+        // def result = new ArrayList(list.size())
+        // for (e in list) { result.add (e.foo) }
+        // result
+        CompileStack compileStack = controller.getCompileStack();
+        Variable tmpList = new VariableExpression("tmpList", ClassHelper.make(ArrayList.class));
+        int var = compileStack.defineTemporaryVariable(tmpList, false);
+        Variable iterator = new VariableExpression("iterator", ClassHelper.Iterator_TYPE);
+        int it = compileStack.defineTemporaryVariable(iterator, false);
+        Variable nextVar = new VariableExpression("next", componentType);
+        final int next = compileStack.defineTemporaryVariable(nextVar, false);
+
+        mv.visitTypeInsn(NEW, "java/util/ArrayList");
+        mv.visitInsn(DUP);
+        receiver.visit(controller.getAcg());
+        mv.visitMethodInsn(INVOKEINTERFACE, "java/util/List", "size", "()I");
+        controller.getOperandStack().remove(1);
+        mv.visitMethodInsn(INVOKESPECIAL, "java/util/ArrayList", "<init>", "(I)V");
+        mv.visitVarInsn(ASTORE, var);
+        Label l1 = new Label();
+        mv.visitLabel(l1);
+        receiver.visit(controller.getAcg());
+        mv.visitMethodInsn(INVOKEINTERFACE, "java/util/List", "iterator", "()Ljava/util/Iterator;");
+        controller.getOperandStack().remove(1);
+        mv.visitVarInsn(ASTORE, it);
+        Label l2 = new Label();
+        mv.visitLabel(l2);
+        mv.visitVarInsn(ALOAD, it);
+        mv.visitMethodInsn(INVOKEINTERFACE, "java/util/Iterator", "hasNext", "()Z");
+        Label l3 = new Label();
+        mv.visitJumpInsn(IFEQ, l3);
+        mv.visitVarInsn(ALOAD, it);
+        mv.visitMethodInsn(INVOKEINTERFACE, "java/util/Iterator", "next", "()Ljava/lang/Object;");
+        mv.visitTypeInsn(CHECKCAST, BytecodeHelper.getClassInternalName(componentType));
+        mv.visitVarInsn(ASTORE, next);
+        Label l4 = new Label();
+        mv.visitLabel(l4);
+        mv.visitVarInsn(ALOAD, var);
+        final ClassNode finalComponentType = componentType;
+        PropertyExpression pexp = new PropertyExpression(new BytecodeExpression() {
+            @Override
+            public void visit(final MethodVisitor mv) {
+                mv.visitVarInsn(ALOAD, next);
+            }
+
+            @Override
+            public ClassNode getType() {
+                return finalComponentType;
+            }
+        }, methodName);
+        pexp.visit(controller.getAcg());
+        controller.getOperandStack().box();
+        controller.getOperandStack().remove(1);
+        mv.visitMethodInsn(INVOKEINTERFACE, "java/util/List", "add", "(Ljava/lang/Object;)Z");
+        mv.visitInsn(POP);
+        Label l5 = new Label();
+        mv.visitLabel(l5);
+        mv.visitJumpInsn(GOTO, l2);
+        mv.visitLabel(l3);
+        mv.visitVarInsn(ALOAD, var);
+        controller.getOperandStack().push(ClassHelper.make(ArrayList.class));
+        controller.getCompileStack().removeVar(next);
+        controller.getCompileStack().removeVar(it);
+        controller.getCompileStack().removeVar(var);
+    }
+
     @SuppressWarnings("unchecked")
     private boolean makeGetPrivateFieldWithBridgeMethod(final Expression receiver, final ClassNode receiverType, final String fieldName, final boolean implicitThis) {
         FieldNode field = receiverType.getField(fieldName);
diff --git a/src/main/org/codehaus/groovy/transform/sc/StaticCompilationMetadataKeys.java b/src/main/org/codehaus/groovy/transform/sc/StaticCompilationMetadataKeys.java
index 57e49762e7..cba14b1ac7 100644
--- a/src/main/org/codehaus/groovy/transform/sc/StaticCompilationMetadataKeys.java
+++ b/src/main/org/codehaus/groovy/transform/sc/StaticCompilationMetadataKeys.java
@@ -25,5 +25,6 @@ public enum StaticCompilationMetadataKeys {
     BINARY_EXP_TARGET, // use to tell which method should be used in a binary expression
     PRIVATE_BRIDGE_METHODS, // private bridge methods are methods used by an outer class to access an inner class method
     PRIVATE_FIELDS_ACCESSORS, // private constants methods are methods used by an outer class to access an outer class constant
-    WITH_CLOSURE // used to mark some closures as being "with" calls, so "owner" can be replaced with "delegate"
+    WITH_CLOSURE, // used to mark some closures as being "with" calls, so "owner" can be replaced with "delegate"
+    COMPONENT_TYPE // for list.property expressions, we need the inferred component type
 }
diff --git a/src/main/org/codehaus/groovy/transform/sc/StaticCompilationVisitor.java b/src/main/org/codehaus/groovy/transform/sc/StaticCompilationVisitor.java
index ae0cab2fdb..5cf0168b6b 100644
--- a/src/main/org/codehaus/groovy/transform/sc/StaticCompilationVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/sc/StaticCompilationVisitor.java
@@ -258,4 +258,17 @@ public class StaticCompilationVisitor extends StaticTypeCheckingVisitor {
         }
         return methodNode;
     }
+
+    @Override
+    protected boolean existsProperty(final PropertyExpression pexp, final boolean checkForReadOnly, final ClassCodeVisitorSupport visitor) {
+        boolean exists = super.existsProperty(pexp, checkForReadOnly, visitor);
+        if (exists) {
+            Expression objectExpression = pexp.getObjectExpression();
+            ClassNode objectExpressionType = getType(objectExpression);
+            if (objectExpressionType.implementsInterface(ClassHelper.LIST_TYPE)) {
+                objectExpression.putNodeMetaData(COMPONENT_TYPE, inferComponentType(objectExpressionType, ClassHelper.OBJECT_TYPE));
+            }
+        }
+        return exists;
+    }
 }
diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 9f7dc90b6b..ce605fbfb1 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -739,7 +739,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
      * @param visitor          if not null, when the property node is found, visit it with the provided visitor
      * @return true if the property is defined in any of the possible receiver classes
      */
-    private boolean existsProperty(final PropertyExpression pexp, final boolean checkForReadOnly, final ClassCodeVisitorSupport visitor) {
+    protected boolean existsProperty(final PropertyExpression pexp, final boolean checkForReadOnly, final ClassCodeVisitorSupport visitor) {
         Expression objectExpression = pexp.getObjectExpression();
         ClassNode clazz = getType(objectExpression);
         if (clazz.isArray() && "length".equals(pexp.getPropertyAsString())) {
@@ -2021,7 +2021,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         return Number_TYPE;
     }
 
-    private ClassNode inferComponentType(final ClassNode containerType, final ClassNode indexType) {
+    protected ClassNode inferComponentType(final ClassNode containerType, final ClassNode indexType) {
         final ClassNode componentType = containerType.getComponentType();
         if (componentType == null) {
             // check if any generic information could help
diff --git a/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy b/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy
index ab75bca85e..6ba19234f6 100644
--- a/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy
+++ b/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy
@@ -260,6 +260,28 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
         '''
     }
 
+    void testListDotProperty() {
+        assertScript '''class Elem { int value }
+            List<Elem> list = new LinkedList<Elem>()
+            list.add(new Elem(value:123))
+            list.add(new Elem(value:456))
+            assert list.value == [ 123, 456 ]
+            list.add(new Elem(value:789))
+            assert list.value == [ 123, 456, 789 ]
+        '''
+
+        assertScript '''class Elem { String value }
+            List<Elem> list = new LinkedList<Elem>()
+            list.add(new Elem(value:'123'))
+            list.add(new Elem(value:'456'))
+            assert list.value == [ '123', '456' ]
+            list.add(new Elem(value:'789'))
+            assert list.value == [ '123', '456', '789' ]
+        '''
+    }
+
+
+
     public static class BaseClass {
         int x
     }
