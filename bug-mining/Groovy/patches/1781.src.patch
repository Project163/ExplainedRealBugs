diff --git a/src/main/org/codehaus/groovy/ast/ClassNode.java b/src/main/org/codehaus/groovy/ast/ClassNode.java
index f0f76f5db8..d1f671bfa1 100644
--- a/src/main/org/codehaus/groovy/ast/ClassNode.java
+++ b/src/main/org/codehaus/groovy/ast/ClassNode.java
@@ -677,7 +677,7 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
         if (redirect!=null) return redirect().equals(o);
         if (!(o instanceof ClassNode)) return false;
         ClassNode cn = (ClassNode) o;
-        return (cn.getName().equals(getName()));
+        return (cn.getText().equals(getText()));
     }
 
     public int hashCode() {
@@ -1451,4 +1451,9 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
     public boolean isRedirectNode() {
         return redirect!=null;
     }
+
+    @Override
+    public String getText() {
+        return getName();
+    }
 }
diff --git a/src/main/org/codehaus/groovy/ast/tools/WideningCategories.java b/src/main/org/codehaus/groovy/ast/tools/WideningCategories.java
index cb2e346f44..28e8f16dac 100644
--- a/src/main/org/codehaus/groovy/ast/tools/WideningCategories.java
+++ b/src/main/org/codehaus/groovy/ast/tools/WideningCategories.java
@@ -20,7 +20,6 @@ import static org.codehaus.groovy.ast.ClassHelper.*;
 import org.codehaus.groovy.ast.ClassNode;
 import org.codehaus.groovy.ast.GenericsType;
 import org.codehaus.groovy.ast.MethodNode;
-import org.codehaus.groovy.vmplugin.VMPluginFactory;
 
 import java.util.*;
 
@@ -271,6 +270,13 @@ public class WideningCategories {
         }
         if (a.equals(OBJECT_TYPE) || b.equals(OBJECT_TYPE)) {
             // one of the objects is at the top of the hierarchy
+            GenericsType[] gta = a.getGenericsTypes();
+            GenericsType[] gtb = b.getGenericsTypes();
+            if (gta !=null && gtb !=null && gta.length==1 && gtb.length==1) {
+                if (gta[0].getName().equals(gtb[0].getName())) {
+                    return a;
+                }
+            }
             return OBJECT_TYPE;
         }
         if (a.equals(VOID_TYPE) || b.equals(VOID_TYPE)) {
@@ -361,18 +367,12 @@ public class WideningCategories {
         ClassNode sb = b.getUnresolvedSuperClass();
 
         // extract implemented interfaces before "going up"
-        ClassNode[] interfacesFromA = a.getInterfaces();
-        ClassNode[] interfacesFromB = b.getInterfaces();
-        if (interfacesFromA.length>0 || interfacesFromB.length>0) {
-            if (interfacesImplementedByA==null) {
-                interfacesImplementedByA = new ArrayList<ClassNode>();
-            }
-            if (interfacesImplementedByB==null) {
-                interfacesImplementedByB = new ArrayList<ClassNode>();
-            }
-            Collections.addAll(interfacesImplementedByA, interfacesFromA);
-            Collections.addAll(interfacesImplementedByB, interfacesFromB);
-        }
+        Set<ClassNode> ifa = new HashSet<ClassNode>();
+        extractInterfaces(a, ifa);
+        Set<ClassNode> ifb = new HashSet<ClassNode>();
+        extractInterfaces(b, ifb);
+        interfacesImplementedByA = interfacesImplementedByA==null?new LinkedList<ClassNode>(ifa):interfacesImplementedByA;
+        interfacesImplementedByB = interfacesImplementedByB==null?new LinkedList<ClassNode>(ifb):interfacesImplementedByB;
 
         // check if no superclass is defined
         // meaning that we reached the top of the object hierarchy
@@ -389,6 +389,12 @@ public class WideningCategories {
         return lowestUpperBound(sa, sb, interfacesImplementedByA, interfacesImplementedByB);
     }
 
+    private static void extractInterfaces(ClassNode node, Set<ClassNode> interfaces) {
+        if (node==null) return;
+        Collections.addAll(interfaces, node.getInterfaces());
+        extractInterfaces(node.getSuperClass(), interfaces);
+    }
+    
     /**
      * Given the list of interfaces implemented by two class nodes, returns the list of the most specific common
      * implemented interfaces.
@@ -463,17 +469,30 @@ public class WideningCategories {
             return interfaces.iterator().next();
         }
         LowestUpperBoundClassNode type;
-        ClassNode[] interfaceArray = interfaces.toArray(new ClassNode[interfaces.size()]);
-        Arrays.sort(interfaceArray, INTERFACE_CLASSNODE_COMPARATOR);
+        ClassNode superClass;
+        String name;
         if (baseType1.equals(baseType2)) {
             if (OBJECT_TYPE.equals(baseType1)) {
-                type = new LowestUpperBoundClassNode("Virtual$Object", OBJECT_TYPE, interfaceArray);
+                superClass = baseType1;
+                name = "Virtual$Object";
             } else {
-                type = new LowestUpperBoundClassNode("Virtual$"+baseType1.getName(), baseType1, interfaceArray);
+                superClass = baseType1;
+                name = "Virtual$"+baseType1.getName();
             }
         } else {
-            type = new LowestUpperBoundClassNode("CommonAssignOf$"+baseType1.getName()+"$"+baseType2.getName(), OBJECT_TYPE, interfaceArray);
+            superClass = OBJECT_TYPE;
+            name = "CommonAssignOf$"+baseType1.getName()+"$"+baseType2.getName();
         }
+        Iterator<ClassNode> itcn = interfaces.iterator();
+        while (itcn.hasNext()) {
+            ClassNode next = itcn.next();
+            if (superClass.isDerivedFrom(next) || superClass.implementsInterface(next)) {
+                itcn.remove();
+            }
+        }
+        ClassNode[] interfaceArray = interfaces.toArray(new ClassNode[interfaces.size()]);
+        Arrays.sort(interfaceArray, INTERFACE_CLASSNODE_COMPARATOR);
+        type = new LowestUpperBoundClassNode(name, superClass, interfaceArray);
         return type;
     }
 
@@ -489,32 +508,58 @@ public class WideningCategories {
      *
      */
     public static class LowestUpperBoundClassNode extends ClassNode {
+        private static final Comparator<ClassNode> CLASS_NODE_COMPARATOR = new Comparator<ClassNode>() {
+            public int compare(final ClassNode o1, final ClassNode o2) {
+                String n1 = o1 instanceof LowestUpperBoundClassNode?((LowestUpperBoundClassNode)o1).name:o1.getName();
+                String n2 = o2 instanceof LowestUpperBoundClassNode?((LowestUpperBoundClassNode)o2).name:o2.getName();
+                return n1.compareTo(n2);
+            }
+        };
         private final ClassNode compileTimeClassNode;
-        protected final String name;
-		
+        private final String name;
+        private final String text;
+
         public LowestUpperBoundClassNode(String name, ClassNode upper, ClassNode... interfaces) {
             super(name, ACC_PUBLIC|ACC_FINAL, upper, interfaces, null);
+            boolean usesGenerics;
+            Arrays.sort(interfaces, CLASS_NODE_COMPARATOR);
             compileTimeClassNode = upper.equals(OBJECT_TYPE) && interfaces.length>0?interfaces[0]:upper;
             this.name = name;
-            if (upper.isUsingGenerics()) {
-                setGenericsTypes(upper.getGenericsTypes());
-            }
+            usesGenerics = upper.isUsingGenerics();
+            List<GenericsType[]> genericsTypesList = new LinkedList<GenericsType[]>();
+            genericsTypesList.add(upper.getGenericsTypes());
 			for (ClassNode anInterface : interfaces) {
+                usesGenerics |= anInterface.isUsingGenerics();
+                genericsTypesList.add(anInterface.getGenericsTypes());
 				for (MethodNode methodNode : anInterface.getMethods()) {
 					addMethod(methodNode.getName(), methodNode.getModifiers(), methodNode.getReturnType(), methodNode.getParameters(), methodNode.getExceptions(), methodNode.getCode());
 				}
 			}
+            setUsingGenerics(usesGenerics);
+            if (usesGenerics) {
+                List<GenericsType> asArrayList = new ArrayList<GenericsType>();
+                for (GenericsType[] genericsTypes : genericsTypesList) {
+                    if (genericsTypes!=null) {
+                        Collections.addAll(asArrayList, genericsTypes);
+                    }
+                }
+                setGenericsTypes(asArrayList.toArray(new GenericsType[asArrayList.size()]));
+            }
+            StringBuilder sb = new StringBuilder();
+            if (!upper.equals(OBJECT_TYPE)) sb.append(upper.getName());
+            for (ClassNode anInterface : interfaces) {
+                if (sb.length()>0) {
+                    sb.append(" or ");
+                }
+                sb.append(anInterface.getName());
+            }
+            this.text = sb.toString();
         }
 
         public String getLubName() {
             return this.name;
         }
 
-        @Override
-        public String getNameWithoutPackage() {
-            return compileTimeClassNode.getNameWithoutPackage();
-        }
-
         @Override
         public String getName() {
             return compileTimeClassNode.getName();
@@ -525,10 +570,19 @@ public class WideningCategories {
             return compileTimeClassNode.getTypeClass();
         }
 
-		/*public ClassNode[] getInterfaces() {
-			return interfaces;
-		}*/
-	}
+        @Override
+        public int hashCode() {
+            int result = super.hashCode();
+//            result = 31 * result + (compileTimeClassNode != null ? compileTimeClassNode.hashCode() : 0);
+            result = 31 * result + (name != null ? name.hashCode() : 0);
+            return result;
+        }
+
+        @Override
+        public String getText() {
+            return text;
+        }
+    }
 
     /**
      * Compares two class nodes, but including their generics types.
diff --git a/src/main/org/codehaus/groovy/classgen/asm/OperandStack.java b/src/main/org/codehaus/groovy/classgen/asm/OperandStack.java
index ac3c8d2eb3..64e9da29a4 100644
--- a/src/main/org/codehaus/groovy/classgen/asm/OperandStack.java
+++ b/src/main/org/codehaus/groovy/classgen/asm/OperandStack.java
@@ -27,6 +27,7 @@ import org.codehaus.groovy.ast.expr.CastExpression;
 import org.codehaus.groovy.ast.expr.ClassExpression;
 import org.codehaus.groovy.ast.expr.ConstantExpression;
 import org.codehaus.groovy.ast.expr.Expression;
+import org.codehaus.groovy.ast.tools.WideningCategories;
 import org.codehaus.groovy.classgen.ClassGeneratorException;
 import org.codehaus.groovy.runtime.ScriptBytecodeAdapter;
 import org.objectweb.asm.Label;
@@ -353,7 +354,7 @@ public class OperandStack {
             BytecodeHelper.doCastToPrimitive(mv, top, targetType);
         } else {
             top = stack.get(size-1);
-            if (!top.isDerivedFrom(targetType) && !top.implementsInterface(targetType)) {
+            if (!implementsInterfaceOrSubclassOf(top, targetType)) {
                 BytecodeHelper.doCast(mv,targetType);
             }
         }
@@ -361,7 +362,7 @@ public class OperandStack {
     }
 
     private void castToTypeIfNecessary(final ClassNode sourceType, final ClassNode targetType) {
-        if (!sourceType.isDerivedFrom(targetType) && !sourceType.implementsInterface(targetType)) {
+        if (!implementsInterfaceOrSubclassOf(sourceType, targetType)) {
             MethodVisitor mv = controller.getMethodVisitor();
             (new ClassExpression(targetType)).visit(controller.getAcg());
             remove(1);
@@ -369,6 +370,26 @@ public class OperandStack {
         }
     }
 
+    /**
+     * Determines if the source class implements an interface or subclasses the target type.
+     * This method takes the {@link org.codehaus.groovy.ast.tools.WideningCategories.LowestUpperBoundClassNode lowest
+     * upper bound class node} type into account, allowing to remove unnecessary casts.
+     * @param source
+     * @param targetType
+     * @return
+     */
+    private static boolean implementsInterfaceOrSubclassOf(final ClassNode source, final ClassNode targetType) {
+        if (source.isDerivedFrom(targetType) || source.implementsInterface(targetType)) return true;
+        if (targetType instanceof WideningCategories.LowestUpperBoundClassNode) {
+            WideningCategories.LowestUpperBoundClassNode lub = (WideningCategories.LowestUpperBoundClassNode) targetType;
+            if (implementsInterfaceOrSubclassOf(source, lub.getSuperClass())) return true;
+            for (ClassNode classNode : lub.getInterfaces()) {
+                if (source.implementsInterface(classNode)) return true;
+            }
+        }
+        return false;
+    }
+
     private boolean convertFromInt(ClassNode target) {
         int convertCode = 0;
         if (target==ClassHelper.char_TYPE){
diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 463f28c6ca..5011a448e2 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -518,7 +518,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 ClassNode elemType = getType(listExpression);
                 ClassNode tupleType = getType(tupleExpression);
                 if (!isAssignableTo(elemType, tupleType)) {
-                    addStaticTypeError("Cannot assign value of type " + elemType.getName() + " to variable of type " + tupleType.getName(), rightExpression);
+                    addStaticTypeError("Cannot assign value of type " + elemType.getText() + " to variable of type " + tupleType.getText(), rightExpression);
                     break; // avoids too many errors
                 }
             }
@@ -530,7 +530,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             addStaticTypeError("Cannot set read-only property: " + ((PropertyExpression) leftExpression).getPropertyAsString(), leftExpression);
         }
         if (!compatible) {
-            addStaticTypeError("Cannot assign value of type " + inferredRightExpressionType.getName() + " to variable of type " + leftExpressionType.getName(), assignmentExpression);
+            addAssignmentError(leftExpressionType, inferredRightExpressionType, assignmentExpression);
         } else {
             // if closure expression on RHS, then copy the inferred closure return type
             if (rightExpression instanceof ClosureExpression) {
@@ -554,13 +554,13 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 if (rightRedirect.isArray()) {
                     ClassNode rightComponentType = rightRedirect.getComponentType();
                     if (!checkCompatibleAssignmentTypes(leftComponentType, rightComponentType)) {
-                        addStaticTypeError("Cannot assign value of type " + rightComponentType + " into array of type " + leftExpressionType, assignmentExpression);
+                        addStaticTypeError("Cannot assign value of type " + rightComponentType.getText() + " into array of type " + leftExpressionType.getText(), assignmentExpression);
                     }
                 } else if (rightExpression instanceof ListExpression) {
                     for (Expression element : ((ListExpression) rightExpression).getExpressions()) {
                         ClassNode rightComponentType = element.getType().redirect();
                         if (!checkCompatibleAssignmentTypes(leftComponentType, rightComponentType)) {
-                            addStaticTypeError("Cannot assign value of type " + rightComponentType + " into array of type " + leftExpressionType, assignmentExpression);
+                            addStaticTypeError("Cannot assign value of type " + rightComponentType.getText() + " into array of type " + leftExpressionType.getText(), assignmentExpression);
                         }
                     }
                 }
@@ -575,7 +575,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 checkGroovyStyleConstructor(leftRedirect, args);
             } else if (!implementsInterfaceOrIsSubclassOf(inferredRightExpressionType, leftRedirect)
                     && implementsInterfaceOrIsSubclassOf(inferredRightExpressionType, LIST_TYPE)) {
-                addStaticTypeError("Cannot assign value of type " + inferredRightExpressionType.getName() + " to variable of type " + leftExpressionType.getName(), assignmentExpression);
+                addAssignmentError(leftExpressionType, inferredRightExpressionType, assignmentExpression);
             }
 
             // if left type is not a list but right type is a map, then we're in the case of a groovy
@@ -607,6 +607,10 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         }
     }
 
+    private void addAssignmentError(final ClassNode leftType, final ClassNode rightType, final Expression assignmentExpression) {
+        addStaticTypeError("Cannot assign value of type " + rightType.getText() + " to variable of type " + leftType.getText(), assignmentExpression);
+    }
+
     private void checkGroovyConstructorMap(final Expression receiver, final ClassNode receiverType, final MapExpression mapExpression) {
         for (MapEntryExpression entryExpression : mapExpression.getMapEntryExpressions()) {
             Expression keyExpr = entryExpression.getKeyExpression();
@@ -626,7 +630,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 } else if (propertyNode != null) {
                     ClassNode valueType = getType(entryExpression.getValueExpression());
                     if (!isAssignableTo(propertyNode.getType(), valueType)) {
-                        addStaticTypeError("Cannot assign value of type " + valueType.getName() + " to field of type " + propertyNode.getType().getName(), entryExpression);
+                        addAssignmentError(propertyNode.getType(), valueType, entryExpression);
                     }
                 }
             }
@@ -1013,6 +1017,14 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                     && !type.equals(VOID_TYPE)
                     && !checkCompatibleAssignmentTypes(methodNode.getReturnType(), type)) {
                 addStaticTypeError("Cannot return value of type " + type + " on method returning type " + methodNode.getReturnType(), statement.getExpression());
+            } else if (!methodNode.isVoidMethod()) {
+                ClassNode previousType = (ClassNode) methodNode.getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);
+                ClassNode inferred = previousType == null ? type : lowestUpperBound(type, previousType);
+                if (implementsInterfaceOrIsSubclassOf(inferred, methodNode.getReturnType())) {
+                    methodNode.putNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE, inferred);
+                } else {
+                    methodNode.putNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE, methodNode.getReturnType());
+                }
             }
         }
         return type;
@@ -1251,7 +1263,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 }
             }
             if (mn.isEmpty()) {
-                addStaticTypeError("Cannot find matching method " + receiver.getName() + "#" + toMethodParametersString(name, args), call);
+                addStaticTypeError("Cannot find matching method " + receiver.getText() + "#" + toMethodParametersString(name, args), call);
             } else {
                 if (mn.size() == 1) {
                     MethodNode directMethodCallCandidate = mn.get(0);
@@ -1268,7 +1280,8 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                     classNode = currentClassNode;
                     ClassNode returnType = getType(directMethodCallCandidate);
                     if (returnType.isUsingGenerics() && !returnType.isEnum()) {
-                        returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);
+                        ClassNode irtg = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);
+                        returnType = irtg!=null && implementsInterfaceOrIsSubclassOf(irtg, returnType)?irtg:returnType;
                     }
                     storeType(call, returnType);
                     storeTargetMethod(call, directMethodCallCandidate);
@@ -1481,7 +1494,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                     }
                 }
                 if (mn.isEmpty()) {
-                    addStaticTypeError("Cannot find matching method " + receiver.getName() + "#" + toMethodParametersString(name, args), call);
+                    addStaticTypeError("Cannot find matching method " + receiver.getText() + "#" + toMethodParametersString(name, args), call);
                 } else {
                     if (mn.size() == 1) {
                         MethodNode directMethodCallCandidate = mn.get(0);
@@ -1499,7 +1512,8 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                         classNode = currentClassNode;
                         ClassNode returnType = getType(directMethodCallCandidate);
                         if (isUsingGenericsOrIsArrayUsingGenerics(returnType)) {
-                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);
+                            ClassNode irtg = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);
+                            returnType = irtg!=null && implementsInterfaceOrIsSubclassOf(irtg, returnType)?irtg:returnType;
                         }
                         storeType(call, returnType);
                         storeTargetMethod(call, directMethodCallCandidate);
@@ -1850,7 +1864,16 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             // check if any generic information could help
             GenericsType[] types = containerType.getGenericsTypes();
             if (types != null && types.length == 1) {
-                return types[0].getType();
+                GenericsType type = types[0];
+                if (type.isWildcard()) {
+                    ClassNode[] upperBounds = type.getUpperBounds();
+                    if (upperBounds.length==1) {
+                        return upperBounds[0];
+                    }
+                    ClassNode lowerBound = type.getLowerBound();
+                    if (lowerBound!=null) return lowerBound;
+                }
+                return type.getType();
             }
             return OBJECT_TYPE;
         } else {
@@ -1863,7 +1886,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             ClassNode receiver, String name, ClassNode... args) {
         final List<MethodNode> methods = findMethod(receiver, name, args);
         if (methods.isEmpty()) {
-            addStaticTypeError("Cannot find matching method " + receiver.getName() + "#" + toMethodParametersString(name, args), expr);
+            addStaticTypeError("Cannot find matching method " + receiver.getText() + "#" + toMethodParametersString(name, args), expr);
         } else if (methods.size() == 1) {
             return methods.get(0);
         } else {
diff --git a/src/main/org/codehaus/groovy/transform/stc/UnionTypeClassNode.java b/src/main/org/codehaus/groovy/transform/stc/UnionTypeClassNode.java
index 9dabe63d89..c6b39dcb83 100644
--- a/src/main/org/codehaus/groovy/transform/stc/UnionTypeClassNode.java
+++ b/src/main/org/codehaus/groovy/transform/stc/UnionTypeClassNode.java
@@ -38,9 +38,18 @@ class UnionTypeClassNode extends ClassNode {
     private final ClassNode[] delegates;
     
     public UnionTypeClassNode(ClassNode... classNodes) {
-        super("<UnionType"+classNodes+">", 0, ClassHelper.OBJECT_TYPE);
+        super("<UnionType"+asArrayDescriptor(classNodes)+">", 0, ClassHelper.OBJECT_TYPE);
         delegates = classNodes==null?new ClassNode[0] : classNodes;
     }
+    
+    private static String asArrayDescriptor(ClassNode... nodes) {
+        StringBuilder sb = new StringBuilder();
+        for (ClassNode node : nodes) {
+            if (sb.length()>0) sb.append("+");
+            sb.append(node.getText());
+        }
+        return sb.toString();
+    }
 
     public ClassNode[] getDelegates() {
         return delegates;
@@ -134,12 +143,6 @@ class UnionTypeClassNode extends ClassNode {
         return false;
     }
 
-    @Override
-    public boolean equals(final Object o) {
-        if (!(o instanceof UnionTypeClassNode)) return false;
-        return Arrays.equals(delegates, ((UnionTypeClassNode)o).delegates);
-    }
-
     @Override
     public List<MethodNode> getAbstractMethods() {
         List<MethodNode> allMethods = new LinkedList<MethodNode>();
diff --git a/src/test/groovy/transform/stc/ClosuresSTCTest.groovy b/src/test/groovy/transform/stc/ClosuresSTCTest.groovy
index 36b7205e28..c19d1db850 100644
--- a/src/test/groovy/transform/stc/ClosuresSTCTest.groovy
+++ b/src/test/groovy/transform/stc/ClosuresSTCTest.groovy
@@ -83,7 +83,7 @@ class ClosuresSTCTest extends StaticTypeCheckingTestCase {
                 }
             }
             byte res = cl(0) // should throw an error because return type inference should be a Number
-        ''', 'Cannot assign value of type java.lang.Number to variable of type byte'
+        ''', 'Cannot assign value of type java.lang.Number or java.lang.Comparable to variable of type byte'
     }
 
     void testClosureWithoutParam() {
diff --git a/src/test/groovy/transform/stc/ConstructorsSTCTest.groovy b/src/test/groovy/transform/stc/ConstructorsSTCTest.groovy
index fd30dd2c6e..fb5bfdddf1 100644
--- a/src/test/groovy/transform/stc/ConstructorsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/ConstructorsSTCTest.groovy
@@ -148,7 +148,7 @@ class ConstructorsSTCTest extends StaticTypeCheckingTestCase {
                 int y
             }
             A a = [x:'100', y:200]
-        ''', 'Cannot assign value of type java.lang.String to field of type int'
+        ''', 'Cannot assign value of type java.lang.String to variable of type int'
     }
 
     void testConstructFromValuedMapAndDynamicKey() {
diff --git a/src/test/groovy/transform/stc/GenericsSTCTest.groovy b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
index 6056f00cdd..6bc038ea0b 100644
--- a/src/test/groovy/transform/stc/GenericsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
@@ -207,7 +207,7 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
     void testCompatibleGenericAssignmentWithInferrence() {
         shouldFailWithMessages '''
             List<String> elements = ['a','b', 1]
-        ''', 'Incompatible generic argument types. Cannot assign java.util.List <java.lang.Comparable> to: java.util.List <String>'
+        ''', 'Incompatible generic argument types. Cannot assign java.util.List <java.io.Serializable> to: java.util.List <String>'
     }
 
     void testGenericAssignmentWithSubClass() {
@@ -406,6 +406,31 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
         '''
     }
 
+    void testShouldComplainAboutToInteger() {
+        shouldFailWithMessages '''
+            class Test {
+                static test2() {
+                    if (new Random().nextBoolean()) {
+                        def a = new ArrayList<String>()
+                        a << "a" << "b" << "c"
+                        return a
+                    } else {
+                        def b = new LinkedList<Number>()
+                        b << 1 << 2 << 3
+                        return b
+                    }
+                }
+
+                static test() {
+                    def result = test2()
+                    result[0].toInteger()
+                    //result[0].toString()
+                }
+            }
+            new Test()
+        ''', 'Cannot find matching method java.io.Serializable#toInteger()'
+    }
+
     void testAssignmentOfNewInstance() {
         Expression expr = null
         config.addCompilationCustomizers(
diff --git a/src/test/groovy/transform/stc/STCAssignmentTest.groovy b/src/test/groovy/transform/stc/STCAssignmentTest.groovy
index 4aadf37a9d..074d05bd6c 100644
--- a/src/test/groovy/transform/stc/STCAssignmentTest.groovy
+++ b/src/test/groovy/transform/stc/STCAssignmentTest.groovy
@@ -313,7 +313,7 @@ class STCAssignmentTest extends StaticTypeCheckingTestCase {
     void testTernaryOperatorAssignementShouldFailBecauseOfIncompatibleGenericTypes() {
         shouldFailWithMessages '''
             List<Integer> foo = true?new LinkedList<String>():new LinkedList<Integer>();
-        ''', 'Incompatible generic argument types. Cannot assign java.util.LinkedList <? extends java.lang.Comparable> to: java.util.List <Integer>'
+        ''', 'Incompatible generic argument types. Cannot assign java.util.LinkedList <? extends java.io.Serializable <? extends java.io.Serializable>> to: java.util.List <Integer>'
     }
 
     void testCastStringToChar() {
diff --git a/src/test/groovy/transform/stc/TypeInferenceSTCTest.groovy b/src/test/groovy/transform/stc/TypeInferenceSTCTest.groovy
index eeee167f9d..df0268fd47 100644
--- a/src/test/groovy/transform/stc/TypeInferenceSTCTest.groovy
+++ b/src/test/groovy/transform/stc/TypeInferenceSTCTest.groovy
@@ -23,6 +23,7 @@ import org.codehaus.groovy.classgen.GeneratorContext
 import org.codehaus.groovy.ast.ClassNode
 import org.codehaus.groovy.ast.ClassHelper
 import org.codehaus.groovy.transform.stc.StaticTypesMarker
+import org.codehaus.groovy.ast.tools.WideningCategories
 
 /**
  * Unit tests for static type checking : type inference.
@@ -419,7 +420,9 @@ class TypeInferenceSTCTest extends StaticTypeCheckingTestCase {
                 o = 'String'
             }
         '''
-        assert method.code.statements[0].expression.leftExpression.getNodeMetaData(StaticTypesMarker.DECLARATION_INFERRED_TYPE) == ClassHelper.make(Comparable)
+        def inft = method.code.statements[0].expression.leftExpression.getNodeMetaData(StaticTypesMarker.DECLARATION_INFERRED_TYPE)
+        assert inft instanceof WideningCategories.LowestUpperBoundClassNode
+        assert inft.interfaces as Set == [ClassHelper.make(Comparable), ClassHelper.make(Serializable)] as Set
 
         assertScript '''
             void method() {
@@ -437,7 +440,10 @@ class TypeInferenceSTCTest extends StaticTypeCheckingTestCase {
                 o = 2
             }
         '''
-        assert method.code.statements[0].expression.leftExpression.getNodeMetaData(StaticTypesMarker.DECLARATION_INFERRED_TYPE) == ClassHelper.Number_TYPE
+        inft = method.code.statements[0].expression.leftExpression.getNodeMetaData(StaticTypesMarker.DECLARATION_INFERRED_TYPE)
+        assert inft instanceof WideningCategories.LowestUpperBoundClassNode
+        assert inft.superClass == ClassHelper.Number_TYPE
+        assert inft.interfaces == [ClassHelper.make(Comparable)]
 
         assertScript '''
             void method() {
diff --git a/src/test/org/codehaus/groovy/ast/tools/WideningCategoriesTest.groovy b/src/test/org/codehaus/groovy/ast/tools/WideningCategoriesTest.groovy
index 9209ec4fbc..bc20240d64 100644
--- a/src/test/org/codehaus/groovy/ast/tools/WideningCategoriesTest.groovy
+++ b/src/test/org/codehaus/groovy/ast/tools/WideningCategoriesTest.groovy
@@ -183,8 +183,8 @@ class WideningCategoriesTest extends GenericsTestCase {
     void testDistinctPrimitiveTypes() {
         ClassNode a = int_TYPE // primitive int
         ClassNode b = long_TYPE // primitive long
-        assert lowestUpperBound(a,b) == Number_TYPE
-        assert lowestUpperBound(b,a) == Number_TYPE
+        assert lowestUpperBound(a,b).superClass == Number_TYPE
+        assert lowestUpperBound(b,a).interfaces == [make(Comparable)]
     }
 
     void testIdenticalPrimitiveTypes() {
@@ -210,7 +210,8 @@ class WideningCategoriesTest extends GenericsTestCase {
         assert lub == make(List)
         assert lub.genericsTypes.length == 1
         assert lub.genericsTypes[0].wildcard
-        assert lub.genericsTypes[0].upperBounds[0] == Number_TYPE
+        assert lub.genericsTypes[0].upperBounds[0].superClass == Number_TYPE
+        assert lub.genericsTypes[0].upperBounds[0].interfaces == [ make(Comparable) ]
     }
 
     void testLUBWithTwoInterfacesAndSingleCommonInterface() {
@@ -265,7 +266,7 @@ class WideningCategoriesTest extends GenericsTestCase {
         assert lub.unresolvedSuperClass.genericsTypes[0].wildcard // ? extends Number
         ClassNode genericType = lub.unresolvedSuperClass.genericsTypes[0].upperBounds[0]
         assert genericType instanceof LowestUpperBoundClassNode // a virtual class which extends Number and implements Comparable<itself>
-        assert genericType == make(Number)
+        assert genericType.superClass == make(Number)
         assert genericType.interfaces == [make(Comparable)]
         assert lub.interfaces == [make(Serializable)]
     }
