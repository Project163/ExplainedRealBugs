diff --git a/src/main/java/org/apache/groovy/parser/antlr4/ModifierManager.java b/src/main/java/org/apache/groovy/parser/antlr4/ModifierManager.java
index eac264ee78..4d86449b8d 100644
--- a/src/main/java/org/apache/groovy/parser/antlr4/ModifierManager.java
+++ b/src/main/java/org/apache/groovy/parser/antlr4/ModifierManager.java
@@ -65,21 +65,19 @@ class ModifierManager {
 
     private void validate(List<ModifierNode> modifierNodeList) {
         Map<ModifierNode, Integer> modifierNodeCounter = new LinkedHashMap<>(modifierNodeList.size());
-        int visibilityModifierCnt = 0;
+        int visibilityModifierCount = 0;
 
         for (ModifierNode modifierNode : modifierNodeList) {
-            Integer cnt = modifierNodeCounter.get(modifierNode);
-
-            if (null == cnt) {
+            var count = modifierNodeCounter.get(modifierNode);
+            if (count == null) {
                 modifierNodeCounter.put(modifierNode, 1);
-            } else if (1 == cnt && !modifierNode.isRepeatable()) {
+            } else if (count == 1 && !modifierNode.isRepeatable()) {
                 throw astBuilder.createParsingFailedException("Cannot repeat modifier[" + modifierNode.getText() + "]", modifierNode);
             }
 
             if (modifierNode.isVisibilityModifier()) {
-                visibilityModifierCnt++;
-
-                if (visibilityModifierCnt > 1) {
+                visibilityModifierCount += 1;
+                if (visibilityModifierCount > 1) {
                     throw astBuilder.createParsingFailedException("Cannot specify modifier[" + modifierNode.getText() + "] when access scope has already been defined", modifierNode);
                 }
             }
diff --git a/src/main/java/org/codehaus/groovy/classgen/ClassCompletionVerifier.java b/src/main/java/org/codehaus/groovy/classgen/ClassCompletionVerifier.java
index be87e1df61..fcdf7bdbeb 100644
--- a/src/main/java/org/codehaus/groovy/classgen/ClassCompletionVerifier.java
+++ b/src/main/java/org/codehaus/groovy/classgen/ClassCompletionVerifier.java
@@ -49,6 +49,7 @@ import org.codehaus.groovy.control.SourceUnit;
 import org.codehaus.groovy.syntax.Types;
 import org.codehaus.groovy.transform.trait.Traits;
 
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.LinkedHashSet;
@@ -65,7 +66,6 @@ import static java.lang.reflect.Modifier.isTransient;
 import static java.lang.reflect.Modifier.isVolatile;
 import static org.objectweb.asm.Opcodes.ACC_ABSTRACT;
 import static org.objectweb.asm.Opcodes.ACC_FINAL;
-import static org.objectweb.asm.Opcodes.ACC_INTERFACE;
 import static org.objectweb.asm.Opcodes.ACC_NATIVE;
 import static org.objectweb.asm.Opcodes.ACC_PRIVATE;
 import static org.objectweb.asm.Opcodes.ACC_PROTECTED;
@@ -118,7 +118,6 @@ public class ClassCompletionVerifier extends ClassCodeVisitorSupport {
                 checkInterfaceMethodVisibility(node);
                 checkAbstractMethodVisibility(node);
                 checkClassForExtendingFinalOrSealed(node);
-                checkMethodsForIncorrectModifiers(node);
                 checkMethodsForIncorrectName(node);
                 checkMethodsForWeakerAccess(node);
                 checkMethodsForOverridingFinal(node);
@@ -251,38 +250,24 @@ public class ClassCompletionVerifier extends ClassCodeVisitorSupport {
     }
 
     private void checkClassForIncorrectModifiers(final ClassNode node) {
-        checkClassForAbstractAndFinal(node);
-        checkClassForOtherModifiers(node);
-    }
-
-    private void checkClassForAbstractAndFinal(final ClassNode node) {
-        if (!node.isAbstract() || !isFinal(node.getModifiers())) return;
-        if (node.isInterface()) {
-            addError("The " + getDescription(node) + " must not be final. It is by definition abstract.", node);
-        } else {
-            addError("The " + getDescription(node) + " must not be both final and abstract.", node);
+        if (node.isAbstract() && isFinal(node.getModifiers())) {
+            addError("The " + getDescription(node) + " cannot be " + (node.isInterface() ? "final. It is by nature abstract" : "both abstract and final") + ".", node);
         }
-    }
 
-    private void checkClassForOtherModifiers(final ClassNode node) {
-        checkClassForModifier(node, isTransient(node.getModifiers()), "transient");
-        checkClassForModifier(node, isVolatile(node.getModifiers()), "volatile");
-        checkClassForModifier(node, isNative(node.getModifiers()), "native");
+        List<String> modifiers = new ArrayList<>();
+
         if (!(node instanceof InnerClassNode)) {
-            checkClassForModifier(node, isStatic(node.getModifiers()), "static");
-            checkClassForModifier(node, isPrivate(node.getModifiers()), "private");
+            if (isPrivate(node.getModifiers())) modifiers.add("private");
+            if (isStatic(node.getModifiers())) modifiers.add("static");
         }
-        // don't check synchronized here as it overlaps with ACC_SUPER
-    }
-
-    private void checkMethodForModifier(final MethodNode node, final boolean condition, final String modifierName) {
-        if (!condition) return;
-        addError("The " + getDescription(node) + " has an incorrect modifier " + modifierName + ".", node);
-    }
+        // do not check for synchronized here; it overlaps with ACC_SUPER
+        if (isTransient(node.getModifiers())) modifiers.add("transient");
+        if (isVolatile(node.getModifiers())) modifiers.add("volatile");
+        if (isNative(node.getModifiers())) modifiers.add("native");
 
-    private void checkClassForModifier(final ClassNode node, final boolean condition, final String modifierName) {
-        if (!condition) return;
-        addError("The " + getDescription(node) + " has an incorrect modifier " + modifierName + ".", node);
+        for (String modifier : modifiers) {
+            addError("The " + getDescription(node) + " has invalid modifier " + modifier + ".", node);
+        }
     }
 
     private static String getDescription(final ClassNode node) {
@@ -409,16 +394,6 @@ public class ClassCompletionVerifier extends ClassCodeVisitorSupport {
         }
     }
 
-    private void checkMethodsForIncorrectModifiers(final ClassNode cn) {
-        if (!cn.isInterface()) return;
-        for (MethodNode method : cn.getMethods()) {
-            if (method.isFinal()) {
-                addError("The " + getDescription(method) + " from " + getDescription(cn) +
-                        " must not be final. It is by definition abstract.", method);
-            }
-        }
-    }
-
     private void checkMethodsForWeakerAccess(final ClassNode cn) {
         for (MethodNode method : cn.getMethods()) {
             checkMethodForWeakerAccessPrivileges(method, cn);
@@ -483,7 +458,7 @@ public class ClassCompletionVerifier extends ClassCodeVisitorSupport {
         checkAbstractDeclaration(node);
         checkRepetitiveMethod(node);
         checkOverloadingPrivateAndPublic(node);
-        checkMethodModifiers(node);
+        checkMethodForIncorrectModifiers(node);
         checkGenericsUsage(node, node.getParameters());
         checkGenericsUsage(node, node.getReturnType());
         for (Parameter param : node.getParameters()) {
@@ -494,18 +469,27 @@ public class ClassCompletionVerifier extends ClassCodeVisitorSupport {
         super.visitMethod(node);
     }
 
-    private void checkMethodModifiers(final MethodNode node) {
-        // don't check volatile here as it overlaps with ACC_BRIDGE
-        // additional modifiers not allowed for interfaces
-        if ((this.currentClass.getModifiers() & ACC_INTERFACE) != 0) {
-            checkMethodForModifier(node, isStrict(node.getModifiers()), "strictfp");
-            checkMethodForModifier(node, isSynchronized(node.getModifiers()), "synchronized");
-            checkMethodForModifier(node, isNative(node.getModifiers()), "native");
+    private void checkMethodForIncorrectModifiers(final MethodNode node) {
+        if (node.isAbstract() && (node.isStatic() || (node.isFinal() && !currentClass.isInterface()))) { // GROOVY-11508
+            addError("The " + getDescription(node) + " can only be one of abstract, static, " + (currentClass.isInterface() ? "default" : "final") + ".", node);
         }
-        // transient overlaps with varargs but we don't add varargs until AsmClassGenerator
-        // but we might have varargs set from e.g. @Delegate of a varargs method so skip generated
+
+        List<String> modifiers = new ArrayList<>();
+
+        if (currentClass.isInterface()) {
+            if (isFinal(node.getModifiers())) modifiers.add("final");
+            if (isNative(node.getModifiers())) modifiers.add("native");
+            if (isStrict(node.getModifiers())) modifiers.add("strictfp");
+            if (isSynchronized(node.getModifiers())) modifiers.add("synchronized");
+        }
+        // transient overlaps with varargs but we do not add varargs until AsmClassGenerator
+        // but we might have varargs set from @Delegate of varargs method, so skip generated
         if (!AnnotatedNodeUtils.isGenerated(node)) {
-            checkMethodForModifier(node, isTransient(node.getModifiers()), "transient");
+            if (isTransient(node.getModifiers())) modifiers.add("transient");
+        }
+
+        for (String modifier : modifiers) {
+            addError("The " + getDescription(node) + " has invalid modifier " + modifier + ".", node);
         }
     }
 
diff --git a/src/test/org/codehaus/groovy/classgen/ClassCompletionVerifierTest.java b/src/test/org/codehaus/groovy/classgen/ClassCompletionVerifierTest.java
index fa2aa61ba8..b263b0c197 100644
--- a/src/test/org/codehaus/groovy/classgen/ClassCompletionVerifierTest.java
+++ b/src/test/org/codehaus/groovy/classgen/ClassCompletionVerifierTest.java
@@ -51,9 +51,11 @@ public final class ClassCompletionVerifierTest {
 
     @Test
     public void shouldDetectAbstractPrivateMethod() {
-        ClassNode node = new ClassNode("X", ACC_ABSTRACT, ClassHelper.OBJECT_TYPE);
-        node.addMethod(new MethodNode("y", ACC_PRIVATE | ACC_ABSTRACT, ClassHelper.VOID_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, null));
+        var node = new ClassNode("X", ACC_ABSTRACT, ClassHelper.OBJECT_TYPE);
+        node.addMethod("y", ACC_PRIVATE | ACC_ABSTRACT, ClassHelper.VOID_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, null);
+
         verifier.visitClass(node);
+
         checkErrorMessage("The method 'y' must not be private as it is declared abstract in class 'X'.");
     }
 
@@ -62,7 +64,7 @@ public final class ClassCompletionVerifierTest {
         checkVisitErrors("FinalClass", ACC_FINAL, false);
         checkVisitErrors("AbstractClass", ACC_ABSTRACT, false);
         checkVisitErrors("AbstractFinalClass", ACC_ABSTRACT | ACC_FINAL, true);
-        checkErrorMessage("The class 'AbstractFinalClass' must not be both final and abstract.");
+        checkErrorMessage("The class 'AbstractFinalClass' cannot be both abstract and final.");
     }
 
     @Test
@@ -76,10 +78,12 @@ public final class ClassCompletionVerifierTest {
     }
 
     private void tryDetectDuplicateMethods(int modifiers, String expectedErrorMessage, Parameter... params) {
-        ClassNode node = new ClassNode("zzz", modifiers, ClassHelper.OBJECT_TYPE);
+        var node = new ClassNode("zzz", modifiers, ClassHelper.OBJECT_TYPE);
         node.addMethod(new MethodNode("xxx", ACC_PUBLIC, ClassHelper.OBJECT_TYPE, params, ClassNode.EMPTY_ARRAY, null));
         node.addMethod(new MethodNode("xxx", ACC_PUBLIC, ClassHelper.OBJECT_TYPE, params, ClassNode.EMPTY_ARRAY, null));
+
         verifier.visitClass(node);
+
         checkErrorCount(2);
         checkErrorMessage(expectedErrorMessage);
     }
@@ -88,57 +92,69 @@ public final class ClassCompletionVerifierTest {
     public void shouldDetectIncorrectOtherModifier() {
         // can't check synchronized here as it doubles up with ACC_SUPER
         checkVisitErrors("DodgyClass", ACC_TRANSIENT | ACC_VOLATILE | ACC_NATIVE, true);
-        checkErrorMessage("The class 'DodgyClass' has an incorrect modifier transient.");
-        checkErrorMessage("The class 'DodgyClass' has an incorrect modifier volatile.");
-        checkErrorMessage("The class 'DodgyClass' has an incorrect modifier native.");
+        checkErrorMessage("The class 'DodgyClass' has invalid modifier transient.");
+        checkErrorMessage("The class 'DodgyClass' has invalid modifier volatile.");
+        checkErrorMessage("The class 'DodgyClass' has invalid modifier native.");
     }
 
     @Test
     public void shouldDetectFinalAbstractInterface() {
         checkVisitErrors("FinalInterface", ACC_ABSTRACT | ACC_FINAL | ACC_INTERFACE, true);
-        checkErrorMessage("The interface 'FinalInterface' must not be final. It is by definition abstract.");
+        checkErrorMessage("The interface 'FinalInterface' cannot be final. It is by nature abstract.");
     }
 
     @Test
     public void shouldDetectFinalMethodsInInterface() {
-        ClassNode node = new ClassNode("zzz", ACC_ABSTRACT | ACC_INTERFACE, ClassHelper.OBJECT_TYPE);
-        node.addMethod(new MethodNode("xxx", ACC_PUBLIC | ACC_FINAL, ClassHelper.OBJECT_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, null));
+        var node = new ClassNode("zzz", ACC_ABSTRACT | ACC_INTERFACE, ClassHelper.OBJECT_TYPE);
+        node.addMethod("xxx", ACC_FINAL | ACC_PUBLIC             , ClassHelper.OBJECT_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, null);
+        node.addMethod("yyy", ACC_FINAL | ACC_PUBLIC | ACC_STATIC, ClassHelper.OBJECT_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, null);
+        node.addMethod("zzz", ACC_FINAL | ACC_PRIVATE            , ClassHelper.OBJECT_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, null);
         addStaticConstructor(node);
+
         verifier.visitClass(node);
-        checkErrorCount(1);
-        checkErrorMessage("The method 'java.lang.Object xxx()' from interface 'zzz' must not be final. It is by definition abstract.");
+
+        checkErrorCount(3);
+        checkErrorMessage("The method 'java.lang.Object xxx()' has invalid modifier final.");
+        checkErrorMessage("The method 'java.lang.Object yyy()' has invalid modifier final.");
+        checkErrorMessage("The method 'java.lang.Object zzz()' has invalid modifier final.");
     }
 
     @Test
     public void shouldDetectIncorrectMethodModifiersInInterface() {
-        ClassNode node = new ClassNode("zzz", ACC_ABSTRACT | ACC_INTERFACE, ClassHelper.OBJECT_TYPE);
-        node.addMethod(new MethodNode("st", ACC_PUBLIC | ACC_STRICT       , ClassHelper.OBJECT_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, null));
-        node.addMethod(new MethodNode("na", ACC_PUBLIC | ACC_NATIVE       , ClassHelper.OBJECT_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, null));
-        node.addMethod(new MethodNode("sy", ACC_PUBLIC | ACC_SYNCHRONIZED , ClassHelper.OBJECT_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, null));
-        node.addMethod(new MethodNode("tr", ACC_PUBLIC | ACC_TRANSIENT    , ClassHelper.OBJECT_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, null));
+        var node = new ClassNode("zzz", ACC_ABSTRACT | ACC_INTERFACE, ClassHelper.OBJECT_TYPE);
+        node.addMethod("na", ACC_PUBLIC | ACC_NATIVE               , ClassHelper.OBJECT_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, null);
+        node.addMethod("st", ACC_PUBLIC | ACC_STRICT               , ClassHelper.OBJECT_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, null);
+        node.addMethod("sy", ACC_PUBLIC | ACC_SYNCHRONIZED         , ClassHelper.OBJECT_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, null);
+        node.addMethod("tr", ACC_PUBLIC | ACC_TRANSIENT            , ClassHelper.OBJECT_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, null);
+        node.addMethod("xx", ACC_PUBLIC | ACC_STATIC | ACC_ABSTRACT, ClassHelper.OBJECT_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, null);
         // can't check volatile here as it doubles up with bridge
         addStaticConstructor(node);
+
         verifier.visitClass(node);
-        checkErrorCount(4);
-        checkErrorMessage("The method 'java.lang.Object st()' has an incorrect modifier strictfp.");
-        checkErrorMessage("The method 'java.lang.Object na()' has an incorrect modifier native.");
-        checkErrorMessage("The method 'java.lang.Object sy()' has an incorrect modifier synchronized.");
-        checkErrorMessage("The method 'java.lang.Object tr()' has an incorrect modifier transient.");
+
+        checkErrorCount(5);
+        checkErrorMessage("The method 'java.lang.Object na()' has invalid modifier native.");
+        checkErrorMessage("The method 'java.lang.Object st()' has invalid modifier strictfp.");
+        checkErrorMessage("The method 'java.lang.Object sy()' has invalid modifier synchronized.");
+        checkErrorMessage("The method 'java.lang.Object tr()' has invalid modifier transient.");
+        checkErrorMessage("The method 'java.lang.Object xx()' can only be one of abstract, static, default.");
     }
 
     @Test
     public void shouldDetectIncorrectMemberVisibilityInInterface() {
-        ClassNode node = new ClassNode("zzz", ACC_ABSTRACT | ACC_INTERFACE, ClassHelper.OBJECT_TYPE);
-        node.addMethod(new MethodNode("pro1", ACC_ABSTRACT | ACC_PROTECTED, ClassHelper.OBJECT_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, null));
-        node.addMethod(new MethodNode("pro2", ACC_STATIC   | ACC_PROTECTED, ClassHelper.OBJECT_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, null));
-        node.addMethod(new MethodNode("pro3",                ACC_PROTECTED, ClassHelper.OBJECT_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, block()));
-        node.addMethod(new MethodNode("pp_1", ACC_ABSTRACT                , ClassHelper.OBJECT_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, null));
-        node.addMethod(new MethodNode("pp_2", ACC_STATIC                  , ClassHelper.OBJECT_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, null));
+        var node = new ClassNode("zzz", ACC_ABSTRACT | ACC_INTERFACE, ClassHelper.OBJECT_TYPE);
+        node.addMethod("pro1", ACC_ABSTRACT | ACC_PROTECTED, ClassHelper.OBJECT_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, null);
+        node.addMethod("pro2", ACC_STATIC   | ACC_PROTECTED, ClassHelper.OBJECT_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, null);
+        node.addMethod("pro3",                ACC_PROTECTED, ClassHelper.OBJECT_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, block());
+        node.addMethod("pp_1", ACC_ABSTRACT                , ClassHelper.OBJECT_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, null);
+        node.addMethod("pp_2", ACC_STATIC                  , ClassHelper.OBJECT_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, null);
         node.addField("prof", ACC_PROTECTED, ClassHelper.OBJECT_TYPE, null);
         node.addField("prif", ACC_PRIVATE  , ClassHelper.OBJECT_TYPE, null);
         node.addField("pp_f", 0            , ClassHelper.OBJECT_TYPE, null);
         addStaticConstructor(node);
+
         verifier.visitClass(node);
+
         checkErrorCount(8);
         checkErrorMessage("The field 'prof' is not 'public static final' but is defined in interface 'zzz'");
         checkErrorMessage("The field 'prif' is not 'public static final' but is defined in interface 'zzz'");
@@ -153,39 +169,53 @@ public final class ClassCompletionVerifierTest {
     @Test
     public void shouldDetectCorrectMethodModifiersInClass() {
         // can't check volatile here as it doubles up with bridge
-        ClassNode node = new ClassNode("zzz", ACC_PUBLIC, ClassHelper.OBJECT_TYPE);
-        node.addMethod(new MethodNode("st", ACC_STRICT, ClassHelper.OBJECT_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, null));
-        node.addMethod(new MethodNode("na", ACC_NATIVE, ClassHelper.OBJECT_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, null));
-        node.addMethod(new MethodNode("sy", ACC_SYNCHRONIZED, ClassHelper.OBJECT_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, null));
+        var node = new ClassNode("zzz", ACC_PUBLIC, ClassHelper.OBJECT_TYPE);
+        node.addMethod("st", ACC_STRICT, ClassHelper.OBJECT_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, null);
+        node.addMethod("na", ACC_NATIVE, ClassHelper.OBJECT_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, null);
+        node.addMethod("sy", ACC_SYNCHRONIZED, ClassHelper.OBJECT_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, null);
         addStaticConstructor(node);
+
         verifier.visitClass(node);
+
         checkErrorCount(0);
     }
 
     @Test
     public void shouldDetectIncorrectMethodModifiersInClass() {
+        var node = new ClassNode("zzz", ACC_ABSTRACT | ACC_PUBLIC, ClassHelper.OBJECT_TYPE);
+        node.addMethod("tr", ACC_TRANSIENT            , ClassHelper.VOID_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, null);
+        node.addMethod("xx", ACC_ABSTRACT | ACC_FINAL , ClassHelper.VOID_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, null);
+        node.addMethod("yy", ACC_ABSTRACT | ACC_STATIC, ClassHelper.VOID_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, null);
+        node.addMethod("zz", ACC_FINAL    | ACC_STATIC, ClassHelper.VOID_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, null);
         // can't check volatile here as it doubles up with bridge
-        ClassNode node = new ClassNode("zzz", ACC_PUBLIC, ClassHelper.OBJECT_TYPE);
-        node.addMethod(new MethodNode("tr", ACC_TRANSIENT, ClassHelper.OBJECT_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, null));
         addStaticConstructor(node);
+
         verifier.visitClass(node);
-        checkErrorCount(1);
-        checkErrorMessage("The method 'java.lang.Object tr()' has an incorrect modifier transient.");
+
+        checkErrorCount(3);
+        checkErrorMessage("The method 'void tr()' has invalid modifier transient.");
+        checkErrorMessage("The method 'void xx()' can only be one of abstract, static, final.");
+        checkErrorMessage("The method 'void yy()' can only be one of abstract, static, final.");
+      //checkErrorMessage("The method 'void zz()' can only be one of abstract, static, final.");
     }
 
     @Test
     public void shouldDetectInvalidFieldModifiers() {
-        ClassNode node = new ClassNode("foo", ACC_PUBLIC, ClassHelper.OBJECT_TYPE);
+        var node = new ClassNode("foo", ACC_PUBLIC, ClassHelper.OBJECT_TYPE);
         node.addField("bar", ACC_FINAL | ACC_VOLATILE, ClassHelper.STRING_TYPE, null);
+
         verifier.visitClass(node);
+
         checkErrorCount(1);
         checkErrorMessage("Illegal combination of modifiers, final and volatile, for field 'bar'");
     }
 
     @Test
     public void shouldDetectClassExtendsInterface() {
-        ClassNode node = new ClassNode("C", ACC_PUBLIC, ClassHelper.SERIALIZABLE_TYPE);
+        var node = new ClassNode("C", ACC_PUBLIC, ClassHelper.SERIALIZABLE_TYPE);
+
         verifier.visitClass(node);
+
         checkErrorCount(1);
         checkErrorMessage("You are not allowed to extend the interface 'java.io.Serializable', use implements instead.");
     }
@@ -193,8 +223,10 @@ public final class ClassCompletionVerifierTest {
     @Test
     public void shouldDetectClassImplementsNonInterface() {
         ClassNode[] impl = {ClassHelper.OBJECT_TYPE, ClassHelper.SERIALIZABLE_TYPE, ClassHelper.ELEMENT_TYPE_TYPE};
-        ClassNode node = new ClassNode("C", ACC_PUBLIC, ClassHelper.OBJECT_TYPE, impl, null);
+        var node = new ClassNode("C", ACC_PUBLIC, ClassHelper.OBJECT_TYPE, impl, null);
+
         verifier.visitClass(node);
+
         checkErrorCount(2);
         checkErrorMessage("You are not allowed to implement the class 'java.lang.Object', use extends instead.");
         checkErrorMessage("You are not allowed to implement the enum 'java.lang.annotation.ElementType', use extends instead.");
@@ -202,8 +234,10 @@ public final class ClassCompletionVerifierTest {
 
     @Test
     public void shouldAcceptInterfaceExtendsInterface() {
-        ClassNode node = new ClassNode("I", ACC_PUBLIC | ACC_INTERFACE, ClassHelper.LIST_TYPE.getPlainNodeReference());
+        var node = new ClassNode("I", ACC_PUBLIC | ACC_INTERFACE, ClassHelper.LIST_TYPE.getPlainNodeReference());
+
         verifier.visitClass(node);
+
         checkErrorCount(0);
     }
 
