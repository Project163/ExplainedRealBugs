diff --git a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java
index 435ac44c7d..5394c09908 100644
--- a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java
+++ b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java
@@ -23,7 +23,6 @@ import org.codehaus.groovy.ast.InnerClassNode;
 import org.codehaus.groovy.ast.MethodNode;
 import org.codehaus.groovy.ast.Parameter;
 import org.codehaus.groovy.ast.expr.*;
-import org.codehaus.groovy.ast.stmt.EmptyStatement;
 import org.codehaus.groovy.ast.stmt.ExpressionStatement;
 import org.codehaus.groovy.ast.stmt.ForStatement;
 import org.codehaus.groovy.classgen.AsmClassGenerator;
@@ -31,6 +30,7 @@ import org.codehaus.groovy.classgen.asm.*;
 import org.codehaus.groovy.runtime.InvokerHelper;
 import org.codehaus.groovy.syntax.SyntaxException;
 import org.codehaus.groovy.syntax.Token;
+import org.codehaus.groovy.transform.sc.StaticCompilationVisitor;
 import org.codehaus.groovy.transform.stc.ExtensionMethodNode;
 import org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport;
 import org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor;
@@ -38,7 +38,6 @@ import org.codehaus.groovy.transform.stc.StaticTypesMarker;
 import org.objectweb.asm.Label;
 import org.objectweb.asm.MethodVisitor;
 
-import java.util.ArrayList;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
@@ -67,14 +66,6 @@ public class StaticInvocationWriter extends InvocationWriter {
                     new Parameter(ClassHelper.OBJECT_TYPE, "args")
             }
     );
-    private static final ClassNode ARRAYLIST_CLASSNODE = ClassHelper.make(ArrayList.class);
-    private static final MethodNode ARRAYLIST_CONSTRUCTOR;
-    private static final MethodNode ARRAYLIST_ADD_METHOD = ARRAYLIST_CLASSNODE.getMethod("add", new Parameter[]{new Parameter(ClassHelper.OBJECT_TYPE, "o")});
-
-    static {
-        ARRAYLIST_CONSTRUCTOR = new ConstructorNode(ACC_PUBLIC, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, EmptyStatement.INSTANCE);
-        ARRAYLIST_CONSTRUCTOR.setDeclaringClass(ARRAYLIST_CLASSNODE);
-    }
 
     private final AtomicInteger labelCounter = new AtomicInteger();
 
@@ -315,10 +306,10 @@ public class StaticInvocationWriter extends InvocationWriter {
             // create an empty arraylist
             VariableExpression result = new VariableExpression(
                     "spreadresult" + counter,
-                    ARRAYLIST_CLASSNODE
+                    StaticCompilationVisitor.ARRAYLIST_CLASSNODE
             );
-            ConstructorCallExpression cce = new ConstructorCallExpression(ARRAYLIST_CLASSNODE, ArgumentListExpression.EMPTY_ARGUMENTS);
-            cce.setNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET, ARRAYLIST_CONSTRUCTOR);
+            ConstructorCallExpression cce = new ConstructorCallExpression(StaticCompilationVisitor.ARRAYLIST_CLASSNODE, ArgumentListExpression.EMPTY_ARGUMENTS);
+            cce.setNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET, StaticCompilationVisitor.ARRAYLIST_CONSTRUCTOR);
             DeclarationExpression declr = new DeclarationExpression(
                     result,
                     Token.newSymbol("=", origin.getLineNumber(), origin.getColumnNumber()),
@@ -348,7 +339,7 @@ public class StaticInvocationWriter extends InvocationWriter {
                     "add",
                     newMCE
             );
-            add.setMethodTarget(ARRAYLIST_ADD_METHOD);
+            add.setMethodTarget(StaticCompilationVisitor.ARRAYLIST_ADD_METHOD);
             // for (e in receiver) { result.add(e?.method(arguments) }
             ForStatement stmt = new ForStatement(
                     iterator,
diff --git a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesBinaryExpressionMultiTypeDispatcher.java b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesBinaryExpressionMultiTypeDispatcher.java
index e756af6903..2899ce8e2e 100644
--- a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesBinaryExpressionMultiTypeDispatcher.java
+++ b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesBinaryExpressionMultiTypeDispatcher.java
@@ -18,16 +18,24 @@ package org.codehaus.groovy.classgen.asm.sc;
 import org.codehaus.groovy.ast.*;
 import org.codehaus.groovy.ast.expr.*;
 import org.codehaus.groovy.ast.stmt.EmptyStatement;
+import org.codehaus.groovy.ast.stmt.ExpressionStatement;
+import org.codehaus.groovy.ast.stmt.ForStatement;
 import org.codehaus.groovy.classgen.AsmClassGenerator;
 import org.codehaus.groovy.classgen.asm.*;
 import org.codehaus.groovy.runtime.MetaClassHelper;
+import org.codehaus.groovy.syntax.Token;
 import org.codehaus.groovy.transform.sc.StaticCompilationVisitor;
+import org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport;
 import org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor;
 import org.codehaus.groovy.transform.stc.StaticTypesMarker;
+import org.objectweb.asm.Label;
 import org.objectweb.asm.MethodVisitor;
 import org.objectweb.asm.Opcodes;
 
+import java.util.concurrent.atomic.AtomicInteger;
+
 import static org.codehaus.groovy.ast.ClassHelper.int_TYPE;
+import static org.codehaus.groovy.transform.sc.StaticCompilationVisitor.*;
 
 /**
  * A specialized version of the multi type binary expression dispatcher which is aware of static compilation.
@@ -36,6 +44,10 @@ import static org.codehaus.groovy.ast.ClassHelper.int_TYPE;
  * @author Cedric Champeau
  */
 public class StaticTypesBinaryExpressionMultiTypeDispatcher extends BinaryExpressionMultiTypeDispatcher implements Opcodes {
+
+    private final AtomicInteger labelCounter = new AtomicInteger();
+
+
     public StaticTypesBinaryExpressionMultiTypeDispatcher(WriterController wc) {
         super(wc);
     }
@@ -74,9 +86,84 @@ public class StaticTypesBinaryExpressionMultiTypeDispatcher extends BinaryExpres
                         pexp instanceof AttributeExpression)) return;
             }
         }
+        // GROOVY-5620: Spread safe/Null safe operator on LHS is not supported
+        if (expression.getLeftExpression() instanceof PropertyExpression
+                && ((PropertyExpression) expression.getLeftExpression()).isSpreadSafe()
+                && StaticTypeCheckingSupport.isAssignment(expression.getOperation().getType())) {
+            // rewrite it so that it can be statically compiled
+            transformSpreadOnLHS(expression);
+            return;
+        }
         super.evaluateEqual(expression, defineVariable);
     }
 
+    private void transformSpreadOnLHS(BinaryExpression origin) {
+        PropertyExpression spreadExpression = (PropertyExpression) origin.getLeftExpression();
+        Expression value = origin.getRightExpression();
+        WriterController controller = getController();
+        MethodVisitor mv = controller.getMethodVisitor();
+        CompileStack compileStack = controller.getCompileStack();
+        TypeChooser typeChooser = controller.getTypeChooser();
+        OperandStack operandStack = controller.getOperandStack();
+        ClassNode classNode = controller.getClassNode();
+        int counter = labelCounter.incrementAndGet();
+        Expression receiver = spreadExpression.getObjectExpression();
+
+        // create an empty arraylist
+        VariableExpression result = new VariableExpression(
+                this.getClass().getSimpleName()+"$spreadresult" + counter,
+                ARRAYLIST_CLASSNODE
+        );
+        ConstructorCallExpression cce = new ConstructorCallExpression(ARRAYLIST_CLASSNODE, ArgumentListExpression.EMPTY_ARGUMENTS);
+        cce.setNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET, ARRAYLIST_CONSTRUCTOR);
+        DeclarationExpression declr = new DeclarationExpression(
+                result,
+                Token.newSymbol("=", spreadExpression.getLineNumber(), spreadExpression.getColumnNumber()),
+                cce
+        );
+        declr.visit(controller.getAcg());
+        // if (receiver != null)
+        receiver.visit(controller.getAcg());
+        Label ifnull = compileStack.createLocalLabel("ifnull_" + counter);
+        mv.visitJumpInsn(IFNULL, ifnull);
+        operandStack.remove(1); // receiver consumed by if()
+        Label nonull = compileStack.createLocalLabel("nonull_" + counter);
+        mv.visitLabel(nonull);
+        ClassNode componentType = StaticTypeCheckingVisitor.inferLoopElementType(typeChooser.resolveType(receiver, classNode));
+        Parameter iterator = new Parameter(componentType, "for$it$" + counter);
+        VariableExpression iteratorAsVar = new VariableExpression(iterator);
+        PropertyExpression pexp = spreadExpression instanceof AttributeExpression?
+                new AttributeExpression(iteratorAsVar, spreadExpression.getProperty(), true):
+                new PropertyExpression(iteratorAsVar, spreadExpression.getProperty(), true);
+        pexp.setImplicitThis(spreadExpression.isImplicitThis());
+        pexp.setSourcePosition(spreadExpression);
+        BinaryExpression assignment = new BinaryExpression(
+                pexp,
+                origin.getOperation(),
+                value
+        );
+        MethodCallExpression add = new MethodCallExpression(
+                result,
+                "add",
+                assignment
+        );
+        add.setMethodTarget(ARRAYLIST_ADD_METHOD);
+        // for (e in receiver) { result.add(e?.method(arguments) }
+        ForStatement stmt = new ForStatement(
+                iterator,
+                receiver,
+                new ExpressionStatement(add)
+        );
+        stmt.visit(controller.getAcg());
+        // else { empty list }
+        mv.visitLabel(ifnull);
+
+        // end of if/else
+        // return result list
+        result.visit(controller.getAcg());
+
+    }
+
     private boolean makeSetProperty(final Expression receiver, final Expression message, final Expression arguments, final boolean safe, final boolean spreadSafe, final boolean implicitThis, final boolean isAttribute) {
         WriterController controller = getController();
         TypeChooser typeChooser = controller.getTypeChooser();
diff --git a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
index fca7dd3929..a515ceb89e 100644
--- a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
+++ b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
@@ -409,6 +409,9 @@ public class StaticTypesCallSiteWriter extends CallSiteWriter implements Opcodes
                 }
                 receiver.visit(controller.getAcg());
                 if (implicitThis) compileStack.popImplicitThis();
+                if (!controller.getOperandStack().getTopOperand().isDerivedFrom(field.getOwner())) {
+                    mv.visitTypeInsn(CHECKCAST, BytecodeHelper.getClassInternalName(field.getOwner()));
+                }
                 mv.visitFieldInsn(GETFIELD, BytecodeHelper.getClassInternalName(field.getOwner()), fieldName, BytecodeHelper.getTypeDescription(field.getOriginType()));
             }
             controller.getOperandStack().replace(field.getOriginType());
diff --git a/src/main/org/codehaus/groovy/transform/sc/StaticCompilationVisitor.java b/src/main/org/codehaus/groovy/transform/sc/StaticCompilationVisitor.java
index c030884c5e..c2536e21b6 100644
--- a/src/main/org/codehaus/groovy/transform/sc/StaticCompilationVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/sc/StaticCompilationVisitor.java
@@ -19,17 +19,13 @@ import groovy.transform.CompileStatic;
 import groovy.transform.TypeChecked;
 import org.codehaus.groovy.ast.*;
 import org.codehaus.groovy.ast.expr.*;
+import org.codehaus.groovy.ast.stmt.EmptyStatement;
 import org.codehaus.groovy.ast.stmt.ExpressionStatement;
 import org.codehaus.groovy.ast.stmt.ForStatement;
 import org.codehaus.groovy.ast.stmt.Statement;
-import org.codehaus.groovy.classgen.asm.InvocationWriter;
-import org.codehaus.groovy.classgen.asm.TypeChooser;
-import org.codehaus.groovy.classgen.asm.WriterControllerFactory;
+import org.codehaus.groovy.classgen.asm.*;
 import org.codehaus.groovy.classgen.asm.sc.StaticTypesTypeChooser;
-import org.codehaus.groovy.control.ErrorCollector;
 import org.codehaus.groovy.control.SourceUnit;
-import org.codehaus.groovy.control.messages.SyntaxErrorMessage;
-import org.codehaus.groovy.syntax.SyntaxException;
 import org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport;
 import org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor;
 import org.codehaus.groovy.transform.stc.StaticTypesMarker;
@@ -41,6 +37,7 @@ import java.util.*;
 
 import static org.codehaus.groovy.transform.sc.StaticCompilationMetadataKeys.*;
 import static org.codehaus.groovy.transform.stc.StaticTypesMarker.DIRECT_METHOD_CALL_TARGET;
+import static org.objectweb.asm.Opcodes.ACC_PUBLIC;
 
 /**
  * This visitor is responsible for amending the AST with static compilation metadata or transform the AST so that
@@ -57,7 +54,16 @@ public class StaticCompilationVisitor extends StaticTypeCheckingVisitor {
     private static final ClassNode TYPECHECKED_CLASSNODE = ClassHelper.make(TypeChecked.class);
     private static final ClassNode COMPILESTATIC_CLASSNODE = ClassHelper.make(CompileStatic.class);
     private static final ClassNode[] TYPECHECKED_ANNOTATIONS = {TYPECHECKED_CLASSNODE, COMPILESTATIC_CLASSNODE};
-    
+
+    public static final ClassNode ARRAYLIST_CLASSNODE = ClassHelper.make(ArrayList.class);
+    public static final MethodNode ARRAYLIST_CONSTRUCTOR;
+    public static final MethodNode ARRAYLIST_ADD_METHOD = ARRAYLIST_CLASSNODE.getMethod("add", new Parameter[]{new Parameter(ClassHelper.OBJECT_TYPE, "o")});
+
+    static {
+        ARRAYLIST_CONSTRUCTOR = new ConstructorNode(ACC_PUBLIC, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, EmptyStatement.INSTANCE);
+        ARRAYLIST_CONSTRUCTOR.setDeclaringClass(StaticCompilationVisitor.ARRAYLIST_CLASSNODE);
+    }
+
     private final TypeChooser typeChooser = new StaticTypesTypeChooser();
 
     private ClassNode classNode;
@@ -278,18 +284,6 @@ public class StaticCompilationVisitor extends StaticTypeCheckingVisitor {
     @Override
     public void visitBinaryExpression(final BinaryExpression expression) {
         super.visitBinaryExpression(expression);
-        if (StaticTypeCheckingSupport.isAssignment(expression.getOperation().getType())) {
-            Expression left = expression.getLeftExpression();
-            if (left instanceof PropertyExpression && ((PropertyExpression) left).isSpreadSafe()) {
-                ErrorCollector errorCollector = getSourceUnit().getErrorCollector();
-                errorCollector.addErrorAndContinue(
-                        new SyntaxErrorMessage(
-                                new SyntaxException("Spread-safe operator is not available with @CompileStatic" + '\n',
-                                        expression.getLineNumber(),
-                                        expression.getColumnNumber()), getSourceUnit()
-                ));
-            }
-        }
     }
 
 }
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/FieldsAndPropertiesStaticCompileTest.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/FieldsAndPropertiesStaticCompileTest.groovy
index c66408f56e..edaf84a2ab 100644
--- a/src/test/org/codehaus/groovy/classgen/asm/sc/FieldsAndPropertiesStaticCompileTest.groovy
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/FieldsAndPropertiesStaticCompileTest.groovy
@@ -330,29 +330,23 @@ class FieldsAndPropertiesStaticCompileTest extends FieldsAndPropertiesSTCTest {
         '''
     }
 
-    @NotYetImplemented
     void testUseAttributeExternalSpread() {
-        try {
-            assertScript '''
-                class A {
-                    boolean setterCalled = false
-                    public int x
-                    void setX(int a) {
-                        setterCalled = true
-                        x = a
-                    }
+        assertScript '''
+            class A {
+                boolean setterCalled = false
+                public int x
+                void setX(int a) {
+                    setterCalled = true
+                    x = a
                 }
-                List<A> a = [new A(), new A()]
-                a*.@x = 100
-//              assert a[0].x == 100
-//              assert a[0].isSetterCalled() == false
-            '''
-        } finally {
-            println astTrees
-        }
+            }
+            List<A> a = [new A(), new A()]
+            a*.@x = 100
+          println a[0].x == 100
+          println a[0].isSetterCalled() == false
+        '''
     }
 
-    @NotYetImplemented
     void testUseAttributeExternalSpreadSafeWithNull() {
         assertScript '''
             class A {
@@ -363,7 +357,7 @@ class FieldsAndPropertiesStaticCompileTest extends FieldsAndPropertiesSTCTest {
                     x = a
                 }
             }
-            List<A> a = [new A(), new A()]
+            List<A> a = [new A(), null]
             a*.@x = 100
             assert a[0].x == 100
             assert a[0].isSetterCalled() == false
@@ -371,7 +365,6 @@ class FieldsAndPropertiesStaticCompileTest extends FieldsAndPropertiesSTCTest {
         '''
     }
 
-    @NotYetImplemented
     void testUseAttributeExternalSpreadUsingSetter() {
         assertScript '''
             class A {
@@ -389,7 +382,6 @@ class FieldsAndPropertiesStaticCompileTest extends FieldsAndPropertiesSTCTest {
         '''
     }
 
-    @NotYetImplemented
     void testUseAttributeExternalSpreadSafeWithNullUsingSetter() {
         assertScript '''
             class A {
@@ -400,7 +392,7 @@ class FieldsAndPropertiesStaticCompileTest extends FieldsAndPropertiesSTCTest {
                     x = a
                 }
             }
-            List<A> a = [new A(), new A()]
+            List<A> a = [new A(), null]
             a*.x = 100
             assert a[0].x == 100
             assert a[0].isSetterCalled() == true
