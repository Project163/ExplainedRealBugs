diff --git a/src/main/groovy/lang/DelegatingMetaClass.java b/src/main/groovy/lang/DelegatingMetaClass.java
index cb14597041..e66e32e93f 100644
--- a/src/main/groovy/lang/DelegatingMetaClass.java
+++ b/src/main/groovy/lang/DelegatingMetaClass.java
@@ -36,7 +36,10 @@ public class DelegatingMetaClass implements MetaClass, MutableMetaClass {
     public DelegatingMetaClass(final Class theClass) {
         this(GroovySystem.getMetaClassRegistry().getMetaClass(theClass));
     }
-    
+
+    public boolean isModified() {
+        return this.delegate instanceof MutableMetaClass && ((MutableMetaClass) this.delegate).isModified();
+    }
     /* (non-Javadoc)
      * @see groovy.lang.MetaClass#addNewInstanceMethod(java.lang.reflect.Method)
      */
@@ -200,17 +203,6 @@ public class DelegatingMetaClass implements MetaClass, MutableMetaClass {
         return this.delegate.getTheClass();
     }
 
-    /**
-     *
-     * @param at the new objects class
-     * @param arguments the args for the constructor call
-     * @return the constructed object
-     * @deprecated use invokeConstructor instead
-     */
-    public Object invokeConstructorAt(Class at, Object[] arguments) {
-        return this.delegate.invokeConstructorAt(at, arguments);
-    }
-
     public Object invokeMethod(Class sender, Object receiver, String methodName, Object[] arguments, boolean isCallToSuper, boolean fromInsideClass) {
         return this.delegate.invokeMethod(sender, receiver, methodName, arguments, isCallToSuper, fromInsideClass);
     }
@@ -219,6 +211,10 @@ public class DelegatingMetaClass implements MetaClass, MutableMetaClass {
         return this.delegate.invokeMissingMethod(instance, methodName, arguments);
     }
 
+    public Object invokeMissingProperty(Object instance, String propertyName, Object optionalValue, boolean isGetter) {
+        return this.delegate.invokeMissingProperty(instance, propertyName, optionalValue, isGetter);
+    }
+
     public boolean isGroovyObject() {
         return GroovyObject.class.isAssignableFrom(this.delegate.getTheClass());
     }
diff --git a/src/main/groovy/lang/ExpandoMetaClass.java b/src/main/groovy/lang/ExpandoMetaClass.java
index 61c6ed8a7f..e72af66636 100644
--- a/src/main/groovy/lang/ExpandoMetaClass.java
+++ b/src/main/groovy/lang/ExpandoMetaClass.java
@@ -73,7 +73,7 @@ import java.util.*;
  * @author Graeme Rocher
  * @since 1.1
  */
-public class  ExpandoMetaClass extends MetaClassImpl implements GroovyObject {
+public class ExpandoMetaClass extends MetaClassImpl implements GroovyObject {
 
 	private static final String META_CLASS = "metaClass";
 	private static final String CLASS = "class";
@@ -92,7 +92,7 @@ public class  ExpandoMetaClass extends MetaClassImpl implements GroovyObject {
     private static final String GROOVY_CONSTRUCTOR = "<init>";
 
     // These two properties are used when no ExpandoMetaClassCreationHandle is present
-    private static final Map CLASS_INHERITANCE_MAPPING = new ConcurrentReaderHashMap();
+
     private boolean hasCreationHandle;
     private MetaClass myMetaClass;
     private boolean allowChangesAfterInit;
@@ -111,6 +111,199 @@ public class  ExpandoMetaClass extends MetaClassImpl implements GroovyObject {
     private ClosureMetaMethod setPropertyMethod;
     private ClosureStaticMetaMethod invokeStaticMethodMethod;
 
+    /**
+	 * Constructs a new ExpandoMetaClass instance for the given class
+	 *
+	 * @param theClass The class that the MetaClass applies to
+	 */
+	public ExpandoMetaClass(Class theClass) {
+		super(GroovySystem.getMetaClassRegistry(), theClass);
+		this.myMetaClass = InvokerHelper.getMetaClass(this);
+
+	}
+
+	/**
+	 * Constructs a new ExpandoMetaClass instance for the given class optionally placing the MetaClass
+	 * in the MetaClassRegistry automatically
+	 *
+	 * @param theClass The class that the MetaClass applies to
+	 * @param register True if the MetaClass should be registered inside the MetaClassRegistry. This defaults to true and ExpandoMetaClass will effect all instances if changed
+	 */
+	public ExpandoMetaClass(Class theClass, boolean register) {
+		this(theClass);
+	    this.inRegistry = register;
+	}
+
+
+    /**
+     * Overrides the default missing method behaviour and adds the capability to look up a method from super class
+     *
+     * @see MetaClassImpl#invokeMissingMethod(Object, String, Object[])  
+     */
+    public Object invokeMissingMethod(Object instance, String methodName, Object[] arguments) {
+        Class superClass = instance instanceof Class ? (Class)instance : instance.getClass();
+        while(superClass != Object.class) {
+            final MetaMethod method = findMethodInClassHeirarchy(methodName, arguments, superClass);
+            if(method != null) {
+                addSuperMethodIfNotOverriden(method);
+                return method.invoke(instance, arguments);
+            }
+            superClass = superClass.getSuperclass();
+        }
+        // still not method here, so see if there is an invokeMethod method up the heirarchy
+        final Object[] invokeMethodArgs = {methodName, arguments};
+        final MetaMethod method = findMethodInClassHeirarchy(INVOKE_METHOD_METHOD, invokeMethodArgs, theClass );
+        if(method!=null && method instanceof ClosureMetaMethod) {
+            this.invokeMethodMethod = (ClosureMetaMethod)method;
+            return method.invoke(instance, invokeMethodArgs);
+        }
+
+        return super.invokeMissingMethod(instance, methodName, arguments);
+    }
+
+    /**
+     * Overrides the default missing method behaviour and adds the capability to look up a method from the super class in the case
+     * where it has been overriden
+     *
+     * @param instance The instance of the object
+     * @param propertyName The property name
+     * @param optionalValue The property value in the case of a setter
+     * @param isGetter True if it is a getter
+     * @return The return value if of a getProperty call or a MissingPropertyException is thrown
+     */
+    public Object invokeMissingProperty(Object instance, String propertyName, Object optionalValue, boolean isGetter) {
+        Class theClass = instance instanceof Class ? (Class)instance : instance.getClass();
+        Class superClass = theClass;
+        while(superClass != Object.class) {
+            final MetaBeanProperty property = findPropertyInClassHierarchy(propertyName, superClass);
+            if(property != null) {
+                addMetaBeanProperty(property);
+                if(!isGetter) {
+                    property.setProperty(instance, optionalValue);
+                    return null;
+                }
+                else {
+                    return property.getProperty(instance);
+                }
+            }
+            superClass = superClass.getSuperclass();
+        }
+        // got here to property not found, look for getProperty or setProperty overrides
+        if(isGetter) {
+            final Object[] getPropertyArgs = {propertyName};
+            final MetaMethod method = findMethodInClassHeirarchy(GET_PROPERTY_METHOD, getPropertyArgs, theClass);
+            if(method != null && method instanceof ClosureMetaMethod) {
+                this.getPropertyMethod = (ClosureMetaMethod)method;
+                return method.invoke(instance,getPropertyArgs);
+            }
+        }
+        else {
+            final Object[] setPropertyArgs = {propertyName, optionalValue};
+            final MetaMethod method = findMethodInClassHeirarchy(SET_PROPERTY_METHOD, setPropertyArgs, theClass);
+            if(method != null && method instanceof ClosureMetaMethod) {
+                this.setPropertyMethod = (ClosureMetaMethod)method;
+                return method.invoke(instance, setPropertyArgs);
+            }
+        }
+        return super.invokeMissingProperty(instance, propertyName, optionalValue, isGetter);
+    }
+
+    private MetaBeanProperty findPropertyInClassHierarchy(String propertyName, Class theClass) {
+        MetaBeanProperty property= null;
+        final Class superClass = theClass.getSuperclass();
+        MetaClass metaClass = this.registry.getMetaClass(superClass);
+        if(metaClass instanceof MutableMetaClass) {
+            property = getMetaPropertyFromMutableMetaClass(propertyName,metaClass);
+            if(property == null) {
+                if(superClass != Object.class) {
+                    property = findPropertyInClassHierarchy(propertyName, superClass);
+                }
+                if(property == null) {
+                    final Class[] interfaces = theClass.getInterfaces();
+                    property = searchInterfacesForMetaProperty(propertyName, interfaces);
+                }
+            }
+        }
+        return property;
+
+    }
+
+    private MetaBeanProperty searchInterfacesForMetaProperty(String propertyName, Class[] interfaces) {
+        MetaBeanProperty property = null;
+        for (int i = 0; i < interfaces.length; i++) {
+            Class anInterface = interfaces[i];
+            MetaClass metaClass = this.registry.getMetaClass(anInterface);
+            if(metaClass instanceof MutableMetaClass) {
+                property = getMetaPropertyFromMutableMetaClass(propertyName,metaClass);
+                if(property != null) break;
+            }
+            Class[] superInterfaces = anInterface.getInterfaces();
+            if(superInterfaces.length > 0) {
+                property = searchInterfacesForMetaProperty(propertyName, superInterfaces);
+                if(property!=null) break;
+            }
+
+        }
+        return property;
+    }
+
+    private MetaBeanProperty getMetaPropertyFromMutableMetaClass(String propertyName, MetaClass metaClass) {
+        final boolean isModified = ((MutableMetaClass) metaClass).isModified();
+        final MetaProperty metaProperty = metaClass.getMetaProperty(propertyName);
+        if(metaProperty instanceof MetaBeanProperty)
+            return isModified ? (MetaBeanProperty)metaProperty : null;
+        else
+            return null;
+
+    }
+
+    private MetaMethod findMethodInClassHeirarchy(String methodName, Object[] arguments, Class theClass) {
+        MetaMethod method = null;
+        final Class superClass = theClass.getSuperclass();
+        MetaClass metaClass = this.registry.getMetaClass(superClass);
+        if(metaClass instanceof MutableMetaClass) {
+            method = getMetaMethodFromMutableMetaClass(methodName, arguments, metaClass);
+            if(method == null) {
+                if(superClass != Object.class) {
+                    method = findMethodInClassHeirarchy(methodName, arguments, superClass);
+                }
+                if(method == null) {                    
+                    final Class[] interfaces = theClass.getInterfaces();
+                    method = searchInterfacesForMetaMethod(methodName, arguments, interfaces);
+                }
+            }
+        }
+        return method;
+    }
+
+    private MetaMethod searchInterfacesForMetaMethod(String methodName, Object[] arguments, Class[] interfaces) {
+        MetaMethod method = null;
+        for (int i = 0; i < interfaces.length; i++) {
+            Class anInterface = interfaces[i];
+            MetaClass metaClass = this.registry.getMetaClass(anInterface);
+            if(metaClass instanceof MutableMetaClass) {
+                method = getMetaMethodFromMutableMetaClass(methodName, arguments, metaClass);
+                if(method != null) break;
+            }
+            Class[] superInterfaces = anInterface.getInterfaces();
+            if(superInterfaces.length > 0) {
+                method = searchInterfacesForMetaMethod(methodName,arguments, superInterfaces);
+                if(method!=null) break;
+            }
+
+        }
+        return method;
+    }
+
+    private MetaMethod getMetaMethodFromMutableMetaClass(String methodName, Object[] arguments, MetaClass metaClass) {
+        final boolean isModified = ((MutableMetaClass) metaClass).isModified();
+        return isModified ? metaClass.getMetaMethod(methodName, arguments) : null;
+    }
+
+    public boolean isModified() {
+        return this.modified;
+    }
+
     /**
      * For simulating closures in Java
      */
@@ -147,7 +340,6 @@ public class  ExpandoMetaClass extends MetaClassImpl implements GroovyObject {
 	 */
 	public synchronized void initialize() {
         if (!this.initialized) {
-            inheritSelfTrackedExpandoMethods();
             super.initialize();
             this.initialized = true;
             this.initCalled = true;
@@ -162,40 +354,12 @@ public class  ExpandoMetaClass extends MetaClassImpl implements GroovyObject {
 		return this.initialized;
 	}
 
-	/**
-	 * If their is no ExpandoMetaClassCreationHandle the EMC will attempt to track inheritance
-	 * methods itself. In this case inherited methods will only work if both the parent and the child
-	 * have an EMC. The best way to get method inheritance working properly is to register a
-	 * ExpandoMetaClassCreationHandle, which may have a performance drawback (Disclaimer: not measured)
-	 */
-	private void inheritSelfTrackedExpandoMethods() {
-        if(!(GroovySystem.getMetaClassRegistry().getMetaClassCreationHandler() instanceof ExpandoMetaClassCreationHandle)) {
-            List superClasses = getSuperClasses();
-            for (Iterator i = superClasses.iterator(); i.hasNext();) {
-                Class c = (Class) i.next();
-                Map methodMap = (Map) CLASS_INHERITANCE_MAPPING.get(c);
-                if(methodMap!=null) {
-                    for (Iterator j = methodMap.values().iterator(); j.hasNext();) {
-                        List methods = (List) j.next();
-                        for (Iterator k = methods.iterator(); k.hasNext();) {
-                            MetaMethod metaMethodFromSuper = (MetaMethod) k.next();
-                            if(!metaMethodFromSuper.isStatic()) {
-                                addSuperMethodIfNotOverriden(metaMethodFromSuper);
-                            }
-                        }
-                    }
-                }
-            }
-        }
-	}
-
-
 
 	private void addSuperMethodIfNotOverriden(final MetaMethod metaMethodFromSuper) {
 		performOperationOnMetaClass(new Callable() {
 			public void call() {
 
-				MetaMethod existing = null;
+                MetaMethod existing = null;
 				try {
 					existing = pickMethod(metaMethodFromSuper.getName(), metaMethodFromSuper.getParameterTypes());}
 				catch ( GroovyRuntimeException e) { 
@@ -207,6 +371,8 @@ public class  ExpandoMetaClass extends MetaClassImpl implements GroovyObject {
 				}
 				else {
                     boolean isGroovyMethod = getMetaMethods().contains(existing);
+
+
                     if(isGroovyMethod) {
                         addMethodWithKey(metaMethodFromSuper);
                     }
@@ -215,7 +381,7 @@ public class  ExpandoMetaClass extends MetaClassImpl implements GroovyObject {
 
                         addMethodWithKey(metaMethodFromSuper);
                     }
-				}
+                }
 
 			}
 
@@ -230,7 +396,7 @@ public class  ExpandoMetaClass extends MetaClassImpl implements GroovyObject {
                     MethodKey key = new DefaultMethodKey(getJavaClass(),name, localMethod.getParameterTypes(),false );
                     cacheInstanceMethod(key, localMethod);
 
-                    checkIfGroovyObjectMethod(localMethod, name, cloned);
+                    checkIfGroovyObjectMethod(localMethod, name);
                     expandoMethods.put(key,localMethod);
 
                 }
@@ -238,28 +404,7 @@ public class  ExpandoMetaClass extends MetaClassImpl implements GroovyObject {
 		});
 	}
 
-    /**
-	 * Constructs a new ExpandoMetaClass instance for the given class
-	 *
-	 * @param theClass The class that the MetaClass applies to
-	 */
-	public ExpandoMetaClass(Class theClass) {
-		super(GroovySystem.getMetaClassRegistry(), theClass);
-		this.myMetaClass = InvokerHelper.getMetaClass(this);
 
-	}
-
-	/**
-	 * Constructs a new ExpandoMetaClass instance for the given class optionally placing the MetaClass
-	 * in the MetaClassRegistry automatically
-	 *
-	 * @param theClass The class that the MetaClass applies to
-	 * @param register True if the MetaClass should be registered inside the MetaClassRegistry. This defaults to true and ExpandoMetaClass will effect all instances if changed
-	 */
-	public ExpandoMetaClass(Class theClass, boolean register) {
-		this(theClass);
-	    this.inRegistry = true;
-	}
 
 	/**
 	 * Instances of this class are returned when using the << left shift operator.
@@ -530,7 +675,7 @@ public class  ExpandoMetaClass extends MetaClassImpl implements GroovyObject {
 			performOperationOnMetaClass(new Callable() {
 				public void call() {
 					ClosureMetaMethod metaMethod = new ClosureMetaMethod(methodName, theClass,callable);
-                    checkIfGroovyObjectMethod(metaMethod, methodName, callable);
+                    checkIfGroovyObjectMethod(metaMethod, methodName);
                     MethodKey key = new DefaultMethodKey(theClass,methodName, metaMethod.getParameterTypes(),false );
 
 
@@ -547,9 +692,6 @@ public class  ExpandoMetaClass extends MetaClassImpl implements GroovyObject {
 						registerBeanPropertyForMethod(metaMethod, propertyName, false, false);
 					}
 					performRegistryCallbacks();
-					if(!hasCreationHandle) {
-						registerWithInheritenceManager(theClass, metaMethod);
-					}
 				}
 
 			});
@@ -560,15 +702,14 @@ public class  ExpandoMetaClass extends MetaClassImpl implements GroovyObject {
      *
      * @param metaMethod The metaMethod instance
      * @param methodName The method name
-     * @param callable The closure from the meta method
      *
      * @see groovy.lang.GroovyObject
      */
-    private void checkIfGroovyObjectMethod(ClosureMetaMethod metaMethod, String methodName, Closure callable) {
+    private void checkIfGroovyObjectMethod(ClosureMetaMethod metaMethod, String methodName) {
         if(isGetPropertyMethod(methodName)) {
             getPropertyMethod = metaMethod;
         }
-        else if(isInvokeMethod(methodName, callable)) {
+        else if(isInvokeMethod(methodName, metaMethod)) {
             invokeMethodMethod = metaMethod;
         }
         else if(isSetPropertyMethod(methodName, metaMethod)) {
@@ -584,7 +725,7 @@ public class  ExpandoMetaClass extends MetaClassImpl implements GroovyObject {
         return GET_PROPERTY_METHOD.equals(methodName);
     }
 
-    private boolean isInvokeMethod(String methodName, Closure metaMethod) {
+    private boolean isInvokeMethod(String methodName, ClosureMetaMethod metaMethod) {
         return INVOKE_METHOD_METHOD.equals(methodName) && metaMethod.getParameterTypes().length == 2;
     }
 
@@ -618,23 +759,8 @@ public class  ExpandoMetaClass extends MetaClassImpl implements GroovyObject {
 			hasCreationHandle  = true;
 			if(!creationHandler.hasModifiedMetaClass(this))
 				creationHandler.registerModifiedMetaClass(this);
-			creationHandler.notifyOfMetaClassChange(this);
-		}
-	}
-
 
-	private static void registerWithInheritenceManager(Class theClass, ClosureMetaMethod metaMethod) {
-		Map methodMap = (Map) CLASS_INHERITANCE_MAPPING.get(theClass);
-		if(methodMap == null) {
-			methodMap = new HashMap();
-			CLASS_INHERITANCE_MAPPING.put(theClass, methodMap);
-		}
-		List methodList = (List)methodMap.get(metaMethod.getName());
-		if(methodList == null) {
-			methodList = new LinkedList();
-			methodMap.put(metaMethod.getName(), methodList);
-		}
-		methodList.add(metaMethod);
+        }
 	}
 
 
@@ -721,6 +847,8 @@ public class  ExpandoMetaClass extends MetaClassImpl implements GroovyObject {
                 List metaMethods = superExpando.getExpandoMethods();
                 for (Iterator j = metaMethods.iterator(); j.hasNext();) {
                     MetaMethod metaMethod = (MetaMethod) j.next();
+                    if(metaMethod.isStatic()) continue; // don't inherit static methodsw
+                    
                     addSuperMethodIfNotOverriden(metaMethod);
                 }
                 Collection metaProperties = superExpando.getExpandoProperties();
diff --git a/src/main/groovy/lang/ExpandoMetaClassCreationHandle.java b/src/main/groovy/lang/ExpandoMetaClassCreationHandle.java
index c20946887c..6050e5419f 100644
--- a/src/main/groovy/lang/ExpandoMetaClassCreationHandle.java
+++ b/src/main/groovy/lang/ExpandoMetaClassCreationHandle.java
@@ -17,7 +17,6 @@ package groovy.lang;
 
 import groovy.lang.MetaClassRegistry.MetaClassCreationHandle;
 import org.codehaus.groovy.runtime.metaclass.ConcurrentReaderHashMap;
-import org.codehaus.groovy.runtime.metaclass.MemoryAwareConcurrentReadMap;
 
 import java.util.*;
 
@@ -40,7 +39,7 @@ import java.util.*;
 public class ExpandoMetaClassCreationHandle extends MetaClassCreationHandle {
 
 	private final Map modifiedExpandos = new ConcurrentReaderHashMap();
-	private final MemoryAwareConcurrentReadMap parentClassToChildMap = new MemoryAwareConcurrentReadMap();
+
 
 	/* (non-Javadoc)
 	 * @see groovy.lang.MetaClassRegistry.MetaClassCreationHandle#create(java.lang.Class, groovy.lang.MetaClassRegistry)
@@ -50,11 +49,9 @@ public class ExpandoMetaClassCreationHandle extends MetaClassCreationHandle {
 			ExpandoMetaClass emc = new ExpandoMetaClass(theClass);
 			emc.setAllowChangesAfterInit(true);
 			Set modifiedSuperExpandos = retrieveModifiedSuperExpandos(emc);
-
             emc.refreshInheritedMethods(modifiedSuperExpandos);
 			emc.initialize();
 
-            registerTrackedExpando(emc);
 			return emc;
 		}
 		else {
@@ -62,50 +59,10 @@ public class ExpandoMetaClassCreationHandle extends MetaClassCreationHandle {
 		}
 	}
 
-	private void registerTrackedExpando(ExpandoMetaClass emc) {
-        LinkedList superClassList = emc.getSuperClasses();
-        Class[] superClasses = (Class[])superClassList.toArray(new Class[superClassList.size()]);
-        for (int i = 0; i < superClasses.length; i++) {
-            Class c = superClasses[i];
-            registerWithParentToChildMap(emc, c);
-        }
-        Class[] interfaces = emc.getJavaClass().getInterfaces();
-        for (int i = 0; i < interfaces.length; i++) {
-            registerWithParentToChildMap(emc, interfaces[i]);
-        }
-
-    }
-
-    private void registerWithParentToChildMap(ExpandoMetaClass emc, Class c) {
-        synchronized(this) {
-            Set children = (Set)parentClassToChildMap.get(c);
-            if(children == null) {
-                children = new HashSet();
-                    parentClassToChildMap.put(c, children);
-                }
-
-            children.add(emc);
-        }
-    }
-
-    /**
-     * Notifies child classes or interface implementors when a parent class or interface changes
-     *
-     * @param changed The changed MetaClass
+    /*
+     * Looks for modified super class ExpandoMetaClass instances for the given child ExpandoMetaClass
      */
-    public void notifyOfMetaClassChange(ExpandoMetaClass changed) {
-		Set subMetas = retrieveKnownSubclasses(changed);
-		if(subMetas != null) {
-			for (Iterator i = subMetas.iterator(); i.hasNext();) {
-				ExpandoMetaClass child = (ExpandoMetaClass) i.next();
-
-				Set modifiedSuperExpandos = retrieveModifiedSuperExpandos(child);
-				child.refreshInheritedMethods(modifiedSuperExpandos);
-			}
-		}
-	}
-
-	private Set retrieveModifiedSuperExpandos(ExpandoMetaClass child) {
+    private Set retrieveModifiedSuperExpandos(ExpandoMetaClass child) {
 		Set modifiedSupers = new HashSet();
 		List superClasses = child.getSuperClasses();
 		for (Iterator i = superClasses.iterator(); i.hasNext();) {
@@ -121,6 +78,9 @@ public class ExpandoMetaClassCreationHandle extends MetaClassCreationHandle {
         return modifiedSupers;
 	}
 
+    /*
+     * Searches through a given array of interfaces for modified ExpandoMetaClass instances for each interface
+     */
     private void populateSupersFromInterfaces(Set modifiedSupers, Class[] interfaces) {
         for (int i = 0; i < interfaces.length; i++) {
             Class anInterface = interfaces[i];
@@ -133,9 +93,6 @@ public class ExpandoMetaClassCreationHandle extends MetaClassCreationHandle {
         }
     }
 
-    private Set retrieveKnownSubclasses(ExpandoMetaClass changed) {
-		return (Set)parentClassToChildMap.get(changed.getJavaClass());
-	}
 
     /**
      * Registers a modified ExpandoMetaClass with the creation handle
diff --git a/src/main/groovy/lang/MetaClass.java b/src/main/groovy/lang/MetaClass.java
index 195e70cc6e..29c82874fa 100644
--- a/src/main/groovy/lang/MetaClass.java
+++ b/src/main/groovy/lang/MetaClass.java
@@ -16,10 +16,10 @@
 
 package groovy.lang;
 
-import java.util.List;
-
 import org.codehaus.groovy.ast.ClassNode;
 
+import java.util.List;
+
 /**
  * A MetaClass within Groovy defines the behaviour of any given Groovy or Java class. The MetaClass
  * interface defines two parts. The client API, which is defined via the extend MetaObjectProtocol interface
@@ -39,10 +39,10 @@ public interface MetaClass extends MetaObjectProtocol {
 
 
     /**
-     * Invokes a method on the given receiver for the specified arguments. The sender is the class that invoked the method on the object.
+     * <p>Invokes a method on the given receiver for the specified arguments. The sender is the class that invoked the method on the object.
      * The MetaClass will attempt to establish the method to invoke based on the name and arguments provided.
      *
-     * The isCallToSuper and fromInsideClass help the Groovy runtime perform optimisations on the call to go directly
+     * <p>The isCallToSuper and fromInsideClass help the Groovy runtime perform optimisations on the call to go directly
      * to the super class if necessary
      *
      * @param sender The java.lang.Class instance that invoked the method
@@ -50,7 +50,7 @@ public interface MetaClass extends MetaObjectProtocol {
      * @param methodName The name of the method
      * @param arguments The arguments to the method
      * @param isCallToSuper Whether the method is a call to a super class method
-     * @param fromInsideClass ??
+     * @param fromInsideClass Whether the call was invoked from the inside or the outside of the class
      *
      * @return The return value of the method
      */
@@ -58,10 +58,10 @@ public interface MetaClass extends MetaObjectProtocol {
 
 
     /**
-     * Retrieves a property on the given receiver for the specified arguments. The sender is the class that is requesting the property from the object.
+     * <p>Retrieves a property on the given receiver for the specified arguments. The sender is the class that is requesting the property from the object.
      * The MetaClass will attempt to establish the method to invoke based on the name and arguments provided.
      *
-     * The isCallToSuper and fromInsideClass help the Groovy runtime perform optimisations on the call to go directly
+     * <p>The isCallToSuper and fromInsideClass help the Groovy runtime perform optimisations on the call to go directly
      * to the super class if necessary
      *
      * @param sender The java.lang.Class instance that requested the property
@@ -75,10 +75,10 @@ public interface MetaClass extends MetaObjectProtocol {
      Object getProperty(Class sender, Object receiver, String property, boolean isCallToSuper, boolean fromInsideClass);
 
     /**
-     * Retrieves a property on the given receiver for the specified arguments. The sender is the class that is requesting the property from the object.
+     * <p>Retrieves a property on the given receiver for the specified arguments. The sender is the class that is requesting the property from the object.
      * The MetaClass will attempt to establish the method to invoke based on the name and arguments provided.
      *
-     * The isCallToSuper and fromInsideClass help the Groovy runtime perform optimisations on the call to go directly
+     * <p>The isCallToSuper and fromInsideClass help the Groovy runtime perform optimisations on the call to go directly
      * to the super class if necessary
      *
      * @param sender The java.lang.Class instance that is mutating the property
@@ -91,30 +91,56 @@ public interface MetaClass extends MetaObjectProtocol {
      */
      void setProperty(Class sender, Object receiver, String property, Object value, boolean isCallToSuper, boolean fromInsideClass);
 
-    /*
+    /**
      *
-     * Do we need this method?
+     * <p>Attempts to invoke the methodMissing method otherwise throws a MissingMethodException
      *
+     * @see groovy.lang.MissingMethodException
+     *
+     * @param instance The instance to invoke methodMissing on
+     * @param methodName The name of the method
+     * @param arguments The arguments to the method
+     * @return The results of methodMissing or throws MissingMethodException
      */
      Object invokeMissingMethod(Object instance, String methodName, Object[] arguments);
-    
-    
-    /*
-     *  Why does this take only one boolean parameter?
+
+    /**
+     * Invokes the propertyMissing method otherwise throws a MissingPropertyException
+     *
+     * @param instance The instance of the class
+     * @param propertyName The name of the property
+     * @param optionalValue The value of the property which could be null in the case of a getter
+     * @param isGetter Whether the missing property event was the result of a getter or a setter
      * 
+     * @return The result of the propertyMissing method or throws MissingPropertyException
+     */
+     Object invokeMissingProperty(Object instance, String propertyName, Object optionalValue, boolean isGetter);
+
+
+    /**
+     * Retrieves the value of an attribute (field). This method is to support the Groovy runtime and not for general client API usage.
+     *
+     * @param sender The class of the object that requested the attribute
+     * @param receiver The instance
+     * @param messageName The name of the attribute
+     * @param useSuper Whether to look-up on the super class or not
+     * @return The attribute value
      */
      Object getAttribute(Class sender, Object receiver, String messageName, boolean useSuper);
-    
+
+    /**
+     * Sets the value of an attribute (field). This method is to support the Groovy runtime and not for general client API usage.
+     *
+     * @param sender The class of the object that requested the attribute
+     * @param receiver The instance
+     * @param messageName The name of the attribute
+     * @param messageValue The value of the attribute
+     * @param useSuper Whether to look-up on the super class or not
+     * @param fromInsideClass Whether the call happened from the inside or the outside of a class
+     */
      void setAttribute(Class sender, Object receiver, String messageName, Object messageValue, boolean useSuper, boolean fromInsideClass);
     
 
-     /*
-      * 
-      * do we need this?
-      * 
-      * surely the MetaClass can do lazy initialisation on the first call of 
-      * one of its MetaClass methods?
-      */
     /**
      * complete the initlialisation process. After this method
      * is called no methods should be added to the meta class.
@@ -126,41 +152,51 @@ public interface MetaClass extends MetaObjectProtocol {
      * method.
      */
      void initialize();
-    
+
+
+    /**
+     * Retrives a list of MetaProperty instances that the MetaClass has
+     *
+     * @see MetaProperty
+     *
+     * @return A list of MetaProperty instances
+     */
      List getProperties();
-     
+
+    /**
+     * Retrieves a list of MetaMethods held by the class
+     *
+     * @return A list of MetaMethods
+     *
+     */
      List getMethods();
      
-     /*
-      * 
-      * This is the problematic method used by SQL
-      * We really need to find a way to either do this properly or to remove it
+     /**
+      * Obtains a reference to the original AST for the MetaClass if it is available at runtime
+      *
+      * @return The original AST or null if it cannot be returned
       */
      ClassNode getClassNode();
      
      
-     /*
-      * 
-      * Why have this and getMethods() what's the difference?
+     /**
+      * Retrieves a list of MetaMethod instances held by this class
+      * @return A list of MetaMethod instances
       */
      List getMetaMethods();
     
-    /**
-     * Warning, this method will be removed
-     * @deprecated use invokeConstructor instead
-     */
-     Object invokeConstructorAt(Class at, Object[] arguments);
-     
-     /*
-      * 
-      * What is this for?
-      * 
-      */
-     int selectConstructorAndTransformArguments(int numberOfCosntructors, Object[] arguments);
-     
-     /*
-      * Do we need this?
+
+     /**
+      *
+      * Internal method to support Groovy runtime. Not for client usage.
+      *
+      * @param numberOfConstructors The number of constructors
+      * @param arguments The arguments
+      *
+      * @return
       */
+     int selectConstructorAndTransformArguments(int numberOfConstructors, Object[] arguments);
+
     /**
      * Selects a method by name and argument classes. This method
      * does not search for an exact match, it searches for a compatible
@@ -168,7 +204,7 @@ public interface MetaClass extends MetaObjectProtocol {
      * bye the implementation of this MetaClass. pickMethod may or may
      * not used during the method selection process when invoking a method
      * thereis no warranty for that.
-     * 
+     *
      * @return a matching MetaMethod or null
      * @throws GroovyRuntimeException if there is more than one matching method
      * @param methodName the name of the method to pick
diff --git a/src/main/groovy/lang/MetaClassImpl.java b/src/main/groovy/lang/MetaClassImpl.java
index 09b5c757a6..97496b19d1 100644
--- a/src/main/groovy/lang/MetaClassImpl.java
+++ b/src/main/groovy/lang/MetaClassImpl.java
@@ -454,7 +454,11 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
        return answer;
    }
 
-   public void addNewInstanceMethod(Method method) {
+    public boolean isModified() {
+        return false;  // MetaClassImpl not designed for modification, just return false
+    }
+
+    public void addNewInstanceMethod(Method method) {
        NewInstanceMetaMethod newMethod = new NewInstanceMetaMethod(createMetaMethod(method));
        if (! newGroovyMethodsList.contains(newMethod)){
            newGroovyMethodsList.add(newMethod);
@@ -502,6 +506,10 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
        return invokeMissingMethod(instance, methodName, arguments, null);
    }
 
+    public Object invokeMissingProperty(Object instance, String propertyName, Object optionalValue, boolean isGetter) {
+        throw new MissingPropertyException(propertyName, theClass);
+    }
+
     private Object invokeMissingMethod(Object instance, String methodName, Object[] arguments, RuntimeException original) {
         MetaMethod method = getMetaMethod(METHOD_MISSING, METHOD_MISSING_ARGS);
         if(method!=null) {
@@ -1077,7 +1085,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
        //----------------------------------------------------------------------
        // error due to missing method/field
        //----------------------------------------------------------------------
-       throw new MissingPropertyException(name, theClass);   
+       return invokeMissingProperty(object, name, null, true);
    }
 
    private MetaMethod getCategoryMethodGetter(Class sender, String name, boolean useLongVersion) {
@@ -1659,7 +1667,8 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
        if (mp!=null) {
            throw new ReadOnlyPropertyException(name,theClass);
        }
-       throw new MissingPropertyException(name, theClass);   
+
+       invokeMissingProperty(object, name, newValue, false);
    }
    
    private MetaProperty getMetaProperty(Class clazz, String name, boolean useSuper, boolean useStatic) {
diff --git a/src/main/groovy/lang/MutableMetaClass.java b/src/main/groovy/lang/MutableMetaClass.java
index ab66b753e6..f23d8104ba 100644
--- a/src/main/groovy/lang/MutableMetaClass.java
+++ b/src/main/groovy/lang/MutableMetaClass.java
@@ -41,6 +41,12 @@ import java.lang.reflect.Method;
  */
 public interface MutableMetaClass extends MetaClass {
 
+    /**
+     * Return whether the MetaClass has been modified or not
+     * @return True if it has
+     */
+    boolean isModified();
+
     /**
      * adds a new instance method to this MetaClass. Instance
      * methods are able to overwrite the original methods of the
diff --git a/src/test/groovy/lang/ExpandoMetaClassCreationHandleTest.groovy b/src/test/groovy/lang/ExpandoMetaClassCreationHandleTest.groovy
index 9c4372d762..d96e8b9e68 100644
--- a/src/test/groovy/lang/ExpandoMetaClassCreationHandleTest.groovy
+++ b/src/test/groovy/lang/ExpandoMetaClassCreationHandleTest.groovy
@@ -21,10 +21,9 @@ package groovy.lang;
 
 class ExpandoMetaClassCreationHandleTest extends GroovyTestCase {
 
-	def registry
+	def registry = GroovySystem.metaClassRegistry
 
 	void setUp() {
-	    registry = GroovySystem.metaClassRegistry
         ExpandoMetaClass.enableGlobally()
 	}
 
@@ -125,16 +124,19 @@ class ExpandoMetaClassCreationHandleTest extends GroovyTestCase {
 
     void testOverrideInvokeMethodViaInterface() {
 	    registry.removeMetaClass(Foo.class)
+	    registry.removeMetaClass(Object.class)
+	    registry.removeMetaClass(IBar.class)
 	    registry.removeMetaClass(Test1.class)
 
 	    def metaClass = registry.getMetaClass(Foo.class)
 
+
 	    metaClass.invokeMethod = { String name, args ->
            def mm = delegate.metaClass.getMetaMethod(name, args)
-
             mm ? mm.invoke(delegate, args) : "bar!!"
 	    }
 
+
 	    def t = new Test1()
 
         assertEquals "bar!!", t.doStuff()
@@ -217,7 +219,38 @@ class ExpandoMetaClassCreationHandleTest extends GroovyTestCase {
 
 
 
+     void testAddMethodToChildThenParent() {
+         registry.removeMetaClass(Test1)
+         registry.removeMetaClass(EMCInheritTest)
+
+         EMCInheritTest.metaClass.foo = {-> "hello!" }
+
+         def emc = new EMCInheritTest()
+
+         assertEquals "hello!", emc.foo()
+
+         Test1.metaClass.foo = {-> "uck" }
+         emc = new EMCInheritTest()
+         // make sure original foo wasn't overridden
+         assertEquals "hello!", emc.foo()
+     }
 
+     void testAddMethodMissingToChildThenParent() {
+         registry.removeMetaClass(Test1)
+         registry.removeMetaClass(EMCInheritTest)
+
+         EMCInheritTest.metaClass.methodMissing = {String name, args-> "hello!" }
+
+         def emc = new EMCInheritTest()
+
+         assertEquals "hello!", emc.foo()
+
+         Test1.metaClass.methodMissing = {String name, args-> "uck" }
+         emc = new EMCInheritTest()
+         // make sure original foo wasn't overridden
+         assertEquals "hello!", emc.bar()
+
+     }
 
 
 }
@@ -229,4 +262,7 @@ interface Foo extends IBar {
 class Test1 implements Foo {
     String name = "Fred"
       def invokeMe() { "foo" }
+}
+class EMCInheritTest extends Test1 {
+
 }
\ No newline at end of file
diff --git a/src/test/groovy/lang/ExpandoMetaClassTest.groovy b/src/test/groovy/lang/ExpandoMetaClassTest.groovy
index 30d680646e..4312cbff04 100644
--- a/src/test/groovy/lang/ExpandoMetaClassTest.groovy
+++ b/src/test/groovy/lang/ExpandoMetaClassTest.groovy
@@ -138,22 +138,6 @@ class ExpandoMetaClassTest extends GroovyTestCase {
         assert t.valid
     }
 
-    void testInheritedInjectedMethods() {
-        def metaClass = new ExpandoMetaClass(Test.class)
-        metaClass.allowChangesAfterInit = true
-
-        metaClass.testMe << {->
-            "testme"
-        }
-        metaClass.initialize()
-
-        def c = new Child()
-        def childMeta = new ExpandoMetaClass(Child.class)
-        childMeta.initialize()
-        c.metaClass = childMeta
-
-        assertEquals "testme", c.testMe()
-    }
 
     void testAllowAdditionOfProperties() {
         def metaClass = new ExpandoMetaClass(Test.class)
