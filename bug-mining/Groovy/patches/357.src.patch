diff --git a/build.xml b/build.xml
index 1b1083702d..c7b7c992dd 100644
--- a/build.xml
+++ b/build.xml
@@ -265,7 +265,7 @@ $Date$
     </target>
 
     <target name="-reportTestFailed" depends="test,-coverageReport" if="testFailed">
-        <echo>Test failed, not processing further targets.</echo>
+        <fail message="Test failed, not processing further targets."/>
     </target>
 
     <target name="-coverageInstrument" depends="-initCoverage,-coberturaInit" if="_forceCoverage_">
diff --git a/src/main/groovy/text/GStringTemplateEngine.java b/src/main/groovy/text/GStringTemplateEngine.java
index 4f14162189..7144cac9f6 100644
--- a/src/main/groovy/text/GStringTemplateEngine.java
+++ b/src/main/groovy/text/GStringTemplateEngine.java
@@ -29,11 +29,9 @@ import java.util.Map;
 
 import org.codehaus.groovy.control.CompilationFailedException;
 
-
 /**
-* @author tug@wilson.co.uk
-*
-*/
+ * @author tug@wilson.co.uk
+ */
 public class GStringTemplateEngine extends TemplateEngine {
     /* (non-Javadoc)
      * @see groovy.text.TemplateEngine#createTemplate(java.io.Reader)
@@ -49,15 +47,15 @@ public class GStringTemplateEngine extends TemplateEngine {
          * Turn the template into a writable Closure
          * When executed the closure evaluates all the code embedded in the
          * template and then writes a GString containing the fixed and variable items
-         * to the writer passed as a paramater
-         *
+         * to the writer passed as a parameter
+         * <p/>
          * For example:
-         *
+         * <p/>
          * '<%= "test" %> of expr and <% test = 1 %>${test} script.'
-         *
+         * <p/>
          * would compile into:
-         *
-         * { |out| out << "${"test"} of expr and "; test = 1 ; out << "${test} script."}.asWritable()
+         * <p/>
+         * { out -> out << "${"test"} of expr and "; test = 1 ; out << "${test} script."}.asWritable()
          *
          * @param reader
          * @throws CompilationFailedException
@@ -65,44 +63,39 @@ public class GStringTemplateEngine extends TemplateEngine {
          * @throws IOException
          */
         public GStringTemplate(final Reader reader) throws CompilationFailedException, ClassNotFoundException, IOException {
-        final StringBuffer templateExpressions = new StringBuffer("package groovy.tmp.templates\n def getTemplate() { return { out -> delegate = new Binding(delegate); out << \"\"\"");
-        boolean writingString = true;
-       
-            while(true) {
-                int c = reader.read();
-
-                    if (c == -1) break;
+            final StringBuffer templateExpressions = new StringBuffer("package groovy.tmp.templates\n def getTemplate() { return { out -> delegate = new Binding(delegate); out << \"\"\"");
+            boolean writingString = true;
 
+            while (true) {
+                int c = reader.read();
+                if (c == -1) break;
                 if (c == '<') {
                     c = reader.read();
-
                     if (c == '%') {
                         c = reader.read();
-
                         if (c == '=') {
-                                parseExpression(reader, writingString, templateExpressions);
-                                writingString = true;
-                                continue;
+                            parseExpression(reader, writingString, templateExpressions);
+                            writingString = true;
+                            continue;
                         } else {
-                                parseSection(c, reader, writingString, templateExpressions);
-                                writingString = false;
-                                continue;
+                            parseSection(c, reader, writingString, templateExpressions);
+                            writingString = false;
+                            continue;
                         }
                     } else {
                         appendCharacter('<', templateExpressions, writingString);
                         writingString = true;
                     }
                 } else if (c == '"') {
-                        appendCharacter('\\', templateExpressions, writingString);
-                        writingString = true;
-                   }
-
-                    appendCharacter((char)c, templateExpressions, writingString);
+                    appendCharacter('\\', templateExpressions, writingString);
                     writingString = true;
+                }
+                appendCharacter((char) c, templateExpressions, writingString);
+                writingString = true;
             }
 
             if (writingString) {
-                    templateExpressions.append("\"\"\"");
+                templateExpressions.append("\"\"\"");
             }
 
             templateExpressions.append("}.asWritable()}");
@@ -111,17 +104,17 @@ public class GStringTemplateEngine extends TemplateEngine {
 
             final ClassLoader parentLoader = getClass().getClassLoader();
             final GroovyClassLoader loader =
-                (GroovyClassLoader) AccessController.doPrivileged(new PrivilegedAction() {
-                    public Object run() {
-                        return new GroovyClassLoader(parentLoader);
-                    }
-                });
+                    (GroovyClassLoader) AccessController.doPrivileged(new PrivilegedAction() {
+                        public Object run() {
+                            return new GroovyClassLoader(parentLoader);
+                        }
+                    });
             final Class groovyClass = loader.parseClass(new GroovyCodeSource(templateExpressions.toString(), "C", "x"));
 
             try {
                 final GroovyObject object = (GroovyObject) groovyClass.newInstance();
 
-                this.template = (Closure)object.invokeMethod("getTemplate", null);
+                this.template = (Closure) object.invokeMethod("getTemplate", null);
             } catch (InstantiationException e) {
                 throw new ClassNotFoundException(e.getMessage());
             } catch (IllegalAccessException e) {
@@ -131,12 +124,10 @@ public class GStringTemplateEngine extends TemplateEngine {
 
         private static void appendCharacter(final char c,
                                             final StringBuffer templateExpressions,
-                                            final boolean writingString)
-        {
+                                            final boolean writingString) {
             if (!writingString) {
                 templateExpressions.append("out << \"\"\"");
             }
-
             templateExpressions.append(c);
         }
 
@@ -155,30 +146,24 @@ public class GStringTemplateEngine extends TemplateEngine {
                                          final Reader reader,
                                          final boolean writingString,
                                          final StringBuffer templateExpressions)
-            throws IOException
-        {
+                throws IOException {
             if (writingString) {
                 templateExpressions.append("\"\"\"; ");
             }
-            templateExpressions.append((char)pendingC);
-
-                while (true) {
-                    int c = reader.read();
-
-                    if (c == -1) break;
+            templateExpressions.append((char) pendingC);
 
-                    if (c =='%') {
-                        c = reader.read();
-
-                        if (c == '>') break;
-                        
-                        templateExpressions.append('%');
-                    }
-
-                    templateExpressions.append((char)c);
+            while (true) {
+                int c = reader.read();
+                if (c == -1) break;
+                if (c == '%') {
+                    c = reader.read();
+                    if (c == '>') break;
+                    templateExpressions.append('%');
                 }
+                templateExpressions.append((char) c);
+            }
 
-                templateExpressions.append(";\n ");
+            templateExpressions.append(";\n ");
         }
 
         /**
@@ -190,45 +175,37 @@ public class GStringTemplateEngine extends TemplateEngine {
          * @throws IOException
          */
         private static void parseExpression(final Reader reader,
-                                          final boolean writingString,
-                                          final StringBuffer templateExpressions)
-            throws IOException
-        {
+                                            final boolean writingString,
+                                            final StringBuffer templateExpressions)
+                throws IOException {
             if (!writingString) {
                 templateExpressions.append("out << \"\"\"");
             }
 
             templateExpressions.append("${");
 
-                while (true) {
-                    int c = reader.read();
-
-                    if (c == -1) break;
-
-                    if (c =='%') {
-                        c = reader.read();
-
-                        if (c == '>') break;
-                        
-                        templateExpressions.append('%');
-                    }
-
-                    templateExpressions.append((char)c);
+            while (true) {
+                int c = reader.read();
+                if (c == -1) break;
+                if (c == '%') {
+                    c = reader.read();
+                    if (c == '>') break;
+                    templateExpressions.append('%');
                 }
+                templateExpressions.append((char) c);
+            }
 
             templateExpressions.append('}');
         }
 
         public Writable make() {
-           return make(null);
-       }
-
-       public Writable make(final Map map) {
-       final Closure template = (Closure)this.template.clone();
-           
-           template.setDelegate(map);
-           
-           return (Writable)template;
-       }
+            return make(null);
+        }
+
+        public Writable make(final Map map) {
+            final Closure template = (Closure) this.template.clone();
+            template.setDelegate(map);
+            return (Writable) template;
+        }
     }
 }
diff --git a/src/test/groovy/lang/ExpandoMetaClassTest.groovy b/src/test/groovy/lang/ExpandoMetaClassTest.groovy
index 37ad564ed5..b34d8dc85f 100644
--- a/src/test/groovy/lang/ExpandoMetaClassTest.groovy
+++ b/src/test/groovy/lang/ExpandoMetaClassTest.groovy
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2005 the original author or authors.
+ * Copyright 2004-2007 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -15,7 +15,6 @@
  */
 package groovy.lang
 
-
 /**
  * @author Graeme Rocher
  */
@@ -23,513 +22,480 @@ package groovy.lang
 class ExpandoMetaClassTest extends GroovyTestCase {
 
     void testStaticBeanStyleProperties() {
-
         def mc = new ExpandoMetaClass(TestInvokeMethod.class, true)
         mc.initialize()
         mc.allowChangesAfterInit = true
         GroovySystem.metaClassRegistry.setMetaClass(TestInvokeMethod.class, mc)
 
-        mc.'static'.getHello = {-> "bar!" }
-        
+        mc.'static'.getHello = {-> "bar!"}
+
         assertEquals "bar!", TestInvokeMethod.hello
     }
 
-    void testOverrideInvokeStaticMethod() {        
+    void testOverrideInvokeStaticMethod() {
         def mc = new ExpandoMetaClass(TestInvokeMethod.class, true)
         mc.initialize()
         mc.allowChangesAfterInit = true
-        GroovySystem.metaClassRegistry.setMetaClass(TestInvokeMethod.class, mc) 
-         
+        GroovySystem.metaClassRegistry.setMetaClass(TestInvokeMethod.class, mc)
 
-          mc.'static'.invokeMethod = { String methodName, args ->
-                def metaMethod = mc.getStaticMetaMethod(methodName, args)
-                def result = null
-                if(metaMethod) result = metaMethod.invoke(delegate, args)
-                else {
-                    result = "foo!"
-                }
-                result
-          }
+        mc.'static'.invokeMethod = {String methodName, args ->
+            def metaMethod = mc.getStaticMetaMethod(methodName, args)
+            def result = null
+            if (metaMethod) result = metaMethod.invoke(delegate, args)
+            else {
+                result = "foo!"
+            }
+            result
+        }
 
-          assertEquals "bar!", TestInvokeMethod.myStaticMethod()
-          assertEquals "foo!", TestInvokeMethod.dynamicMethod()
+        assertEquals "bar!", TestInvokeMethod.myStaticMethod()
+        assertEquals "foo!", TestInvokeMethod.dynamicMethod()
     }
 
     void testOverrideInvokeMethod() {
-	   	def mc = new ExpandoMetaClass(TestInvokeMethod.class)
+        def mc = new ExpandoMetaClass(TestInvokeMethod.class)
         mc.initialize()
         mc.allowChangesAfterInit = true
 
         assert mc.hasMetaMethod("invokeMe", [String] as Class[])
 
-        mc.invokeMethod = { String name, args ->
+        mc.invokeMethod = {String name, args ->
             def mm = delegate.metaClass.getMetaMethod(name, args)
-
             mm ? mm.invoke(delegate, args) : "bar!!"
         }
 
-		def t = new TestInvokeMethod()
-	   	t.metaClass = mc
-
+        def t = new TestInvokeMethod()
+        t.metaClass = mc
 
         assertEquals "bar!!", t.doStuff()
         assertEquals "Foo!! hello", t.invokeMe("hello")
-
     }
 
     void testOverrideSetProperty() {
-	   	def mc = new ExpandoMetaClass(TestGetProperty.class)
+        def mc = new ExpandoMetaClass(TestGetProperty.class)
         mc.initialize()
         mc.allowChangesAfterInit = true
 
         assert mc.hasMetaProperty("name")
 
-
         def testValue = null
-        mc.setProperty = { String name, value ->
+        mc.setProperty = {String name, value ->
             def mp = delegate.metaClass.getMetaProperty(name)
 
-            if(mp) { mp.setProperty(delegate, value) } else { testValue = value }
+            if (mp) {mp.setProperty(delegate, value)} else {testValue = value}
         }
 
-
-		def t = new TestGetProperty()
-	   	t.metaClass = mc
+        def t = new TestGetProperty()
+        t.metaClass = mc
 
         t.name = "Bob"
         assertEquals "Bob", t.name
 
         t.foo = "bar"
-        assertEquals "bar",testValue
-
+        assertEquals "bar", testValue
     }
 
     void testOverrideGetProperty() {
-	   	def mc = new ExpandoMetaClass(TestGetProperty.class)
+        def mc = new ExpandoMetaClass(TestGetProperty.class)
         mc.initialize()
         mc.allowChangesAfterInit = true
 
         assert mc.hasMetaProperty("name")
 
-        mc.getProperty = { String name ->
+        mc.getProperty = {String name ->
             def mp = delegate.metaClass.getMetaProperty(name)
 
             mp ? mp.getProperty(delegate) : "foo $name"
         }
 
+        def t = new TestGetProperty()
+        t.metaClass = mc
 
-		def t = new TestGetProperty()
-	   	t.metaClass = mc
-
-	   	assertEquals "foo bar", t.getProperty("bar")
-	   	assertEquals "foo bar", t.bar
-	   	assertEquals "Fred", t.getProperty("name")
-	   	assertEquals "Fred", t.name
-
+        assertEquals "foo bar", t.getProperty("bar")
+        assertEquals "foo bar", t.bar
+        assertEquals "Fred", t.getProperty("name")
+        assertEquals "Fred", t.name
     }
 
-	void testBooleanGetterWithClosure() {
-	   	def metaClass = new ExpandoMetaClass(Test.class)
+    void testBooleanGetterWithClosure() {
+        def metaClass = new ExpandoMetaClass(Test.class)
         metaClass.initialize()
         metaClass.allowChangesAfterInit = true
-		metaClass.isValid = {-> true }
+        metaClass.isValid = {-> true}
 
-		def t = new Test()
-	   	t.metaClass = metaClass
+        def t = new Test()
+        t.metaClass = metaClass
 
         assert t.isValid()
         assert t.valid
     }
 
+    void testInheritedInjectedMethods() {
+        def metaClass = new ExpandoMetaClass(Test.class)
+        metaClass.allowChangesAfterInit = true
 
-	void testInheritedInjectedMethods() {
-		 def metaClass = new ExpandoMetaClass(Test.class)
-		 metaClass.allowChangesAfterInit = true
-
-		 metaClass.testMe << {->
-			 "testme"
-		 }
-		 metaClass.initialize()
-
-		 def c = new Child()
-		 def childMeta = new ExpandoMetaClass(Child.class)
-		 childMeta.initialize()
-		 c.metaClass = childMeta
-
-		 assertEquals "testme", c.testMe()
-
-	}
-
-	void testAllowAdditionOfProperties() {
-		 def metaClass = new ExpandoMetaClass(Test.class)
-		 metaClass.allowChangesAfterInit = true
-
-		 metaClass.getOne << {->
-			 "testme"
-		 }
-		 metaClass.initialize()
-		 try {
-			 metaClass.getTwo << {->
-				 "testagain"
-			 }
-		 }
-		 catch(RuntimeException e) {
-			 fail("Should have allowed addition of new method")
-		 }
-
-		 def t = new Test()
-		 t.metaClass = metaClass
-
-		 assertEquals "testme", t.one
-		 assertEquals "testagain", t.two
-
-	}
-
-	void testAllowAdditionOfMethods() {
-		 def metaClass = new ExpandoMetaClass(Test.class)
-		 metaClass.allowChangesAfterInit = true
-
-		 metaClass.myMethod << {->
-			 "testme"
-		 }
-		 metaClass.initialize()
-		 try {
-			 metaClass.mySecondMethod << {->
-				 "testagain"
-			 }
-		 }
-		 catch(RuntimeException e) {
-			 fail("Should have allowed addition of new method")
-		 }
-
-		 def t = new Test()
-		 t.metaClass = metaClass
-
-		 assertEquals "testme", t.myMethod()
-		 assertEquals "testagain", t.mySecondMethod()
-	}
-
-
-
-	void testForbiddenAdditionOfMethods() {
-		 def metaClass = new ExpandoMetaClass(Test.class)
-
-		 metaClass.myMethod << {
-			 "testme"
-		 }
-		 metaClass.initialize()
-
-		 def t = new Test()
-
+        metaClass.testMe << {->
+            "testme"
+        }
+        metaClass.initialize()
 
+        def c = new Child()
+        def childMeta = new ExpandoMetaClass(Child.class)
+        childMeta.initialize()
+        c.metaClass = childMeta
 
-		 try {
-			 metaClass.mySecondMethod << {
-				 "testagain"
-			 }
-			 fail("Should have thrown exception")
-		 }
-		 catch(RuntimeException e) {
-			 // expected
-		 }
-	}
+        assertEquals "testme", c.testMe()
+    }
 
+    void testAllowAdditionOfProperties() {
+        def metaClass = new ExpandoMetaClass(Test.class)
+        metaClass.allowChangesAfterInit = true
 
-	void testPropertyGetterWithClosure() {
-	   	 def metaClass = new ExpandoMetaClass(Test.class)
+        metaClass.getOne << {->
+            "testme"
+        }
+        metaClass.initialize()
+        try {
+            metaClass.getTwo << {->
+                "testagain"
+            }
+        }
+        catch (RuntimeException e) {
+            fail("Should have allowed addition of new method")
+        }
 
-		 metaClass.getSomething = {-> "testme" }
+        def t = new Test()
+        t.metaClass = metaClass
 
-	   	metaClass.initialize()
+        assertEquals "testme", t.one
+        assertEquals "testagain", t.two
+    }
 
-		 def t = new Test()
-	   	 t.metaClass = metaClass
+    void testAllowAdditionOfMethods() {
+        def metaClass = new ExpandoMetaClass(Test.class)
+        metaClass.allowChangesAfterInit = true
 
-		 assertEquals "testme", t.getSomething()
-		 assertEquals "testme", t.something
+        metaClass.myMethod << {->
+            "testme"
+        }
+        metaClass.initialize()
+        try {
+            metaClass.mySecondMethod << {->
+                "testagain"
+            }
+        }
+        catch (RuntimeException e) {
+            fail("Should have allowed addition of new method")
+        }
 
+        def t = new Test()
+        t.metaClass = metaClass
 
-	}
+        assertEquals "testme", t.myMethod()
+        assertEquals "testagain", t.mySecondMethod()
+    }
 
-	void testPropertySetterWithClosure() {
-	   	 def metaClass = new ExpandoMetaClass(Test.class)
+    void testForbiddenAdditionOfMethods() {
+        def metaClass = new ExpandoMetaClass(Test.class)
 
-	   	 def testSet = null
-		 metaClass.setSomething = {String txt-> testSet = txt }
+        metaClass.myMethod << {
+            "testme"
+        }
+        metaClass.initialize()
 
-	   	metaClass.initialize()
+        def t = new Test()
 
-		 def t = new Test()
-	   	 t.metaClass = metaClass
+        try {
+            metaClass.mySecondMethod << {
+                "testagain"
+            }
+            fail("Should have thrown exception")
+        }
+        catch (RuntimeException e) {
+            // expected
+        }
+    }
 
-	   	 t.something = "testme"
-		 assertEquals "testme", testSet
+    void testPropertyGetterWithClosure() {
+        def metaClass = new ExpandoMetaClass(Test.class)
 
-		 t.setSomething("test2")
-		 assertEquals "test2", testSet
+        metaClass.getSomething = {-> "testme"}
 
-	}
+        metaClass.initialize()
 
-	void testNewMethodOverloading() {
-	   	 def metaClass = new ExpandoMetaClass(Test.class)
+        def t = new Test()
+        t.metaClass = metaClass
 
-		metaClass.overloadMe << { String txt -> txt } << { Integer i -> i }
+        assertEquals "testme", t.getSomething()
+        assertEquals "testme", t.something
+    }
 
-	   	metaClass.initialize()
+    void testPropertySetterWithClosure() {
+        def metaClass = new ExpandoMetaClass(Test.class)
 
-		 def t = new Test()
-	   	 t.metaClass = metaClass
+        def testSet = null
+        metaClass.setSomething = {String txt -> testSet = txt}
 
-	   	 assertEquals "test", t.overloadMe("test")
-	   	 assertEquals 10, t.overloadMe(10)
+        metaClass.initialize()
 
-	}
+        def t = new Test()
+        t.metaClass = metaClass
 
-	void testOverloadExistingMethodAfterInitialize() {
-		 def t = new Test()
+        t.something = "testme"
+        assertEquals "testme", testSet
 
-		 assertEquals "test", t.doSomething("test")
+        t.setSomething("test2")
+        assertEquals "test2", testSet
+    }
 
-	   	 def metaClass = new ExpandoMetaClass(Test.class)
-		 metaClass.allowChangesAfterInit = true
-		 metaClass.initialize()
+    void testNewMethodOverloading() {
+        def metaClass = new ExpandoMetaClass(Test.class)
 
-		 metaClass.doSomething = { Integer i -> i +1}
+        metaClass.overloadMe << {String txt -> txt} << {Integer i -> i}
 
-	   	 t.metaClass = metaClass
+        metaClass.initialize()
 
-	   	assertEquals "test", t.doSomething("test")
-	   	 assertEquals 11, t.doSomething(10)
+        def t = new Test()
+        t.metaClass = metaClass
 
-	}
+        assertEquals "test", t.overloadMe("test")
+        assertEquals 10, t.overloadMe(10)
+    }
 
+    void testOverloadExistingMethodAfterInitialize() {
+        def t = new Test()
 
-	void testOverloadExistingMethodBeforeInitialize() {
-		 def t = new Test()
+        assertEquals "test", t.doSomething("test")
 
-		 assertEquals "test", t.doSomething("test")
+        def metaClass = new ExpandoMetaClass(Test.class)
+        metaClass.allowChangesAfterInit = true
+        metaClass.initialize()
 
-	   	 def metaClass = new ExpandoMetaClass(Test.class)
-		 metaClass.allowChangesAfterInit = true
+        metaClass.doSomething = {Integer i -> i + 1}
 
+        t.metaClass = metaClass
 
-		 metaClass.doSomething = { Integer i -> i +1}
+        assertEquals "test", t.doSomething("test")
+        assertEquals 11, t.doSomething(10)
+    }
 
-		 metaClass.initialize()
+    void testOverloadExistingMethodBeforeInitialize() {
+        def t = new Test()
 
-	   	 t.metaClass = metaClass
+        assertEquals "test", t.doSomething("test")
 
-	     assertEquals "test", t.doSomething("test")
-	   	 assertEquals 11, t.doSomething(10)
+        def metaClass = new ExpandoMetaClass(Test.class)
+        metaClass.allowChangesAfterInit = true
 
-	}
 
+        metaClass.doSomething = {Integer i -> i + 1}
 
-	void testNewPropertyMethod() {
-	   	 def metaClass = new ExpandoMetaClass(Test.class)
+        metaClass.initialize()
 
-		 metaClass.something = "testme"
+        t.metaClass = metaClass
 
-	   	metaClass.initialize()
+        assertEquals "test", t.doSomething("test")
+        assertEquals 11, t.doSomething(10)
+    }
 
-		 def t = new Test()
-	   	 t.metaClass = metaClass
+    void testNewPropertyMethod() {
+        def metaClass = new ExpandoMetaClass(Test.class)
 
-		 assertEquals "testme", t.getSomething()
-		 assertEquals "testme", t.something
+        metaClass.something = "testme"
 
-		 t.something = "test2"
-		 assertEquals "test2", t.something
-		 assertEquals "test2", t.getSomething()
+        metaClass.initialize()
 
-		 def t2 = new Test()
-	   	 t2.metaClass = metaClass
-	   	 // now check that they're not sharing the same property!
-	   	 assertEquals "testme", t2.something
-	   	 assertEquals "test2", t.something
+        def t = new Test()
+        t.metaClass = metaClass
 
-	   	 t2.setSomething("test3")
+        assertEquals "testme", t.getSomething()
+        assertEquals "testme", t.something
 
-	   	 assertEquals "test3", t2.something
-	}
+        t.something = "test2"
+        assertEquals "test2", t.something
+        assertEquals "test2", t.getSomething()
 
-	void testCheckFailOnExisting() {
-		def metaClass = new ExpandoMetaClass(Test.class)
-		 try {
-			 metaClass.existing << { ->
-				 "should fail. already exists!"
-			 }
-			 fail("Should have thrown exception when method already exists")
-		 }
-		 catch(Exception e) {
-			 // expected
-		 }
+        def t2 = new Test()
+        t2.metaClass = metaClass
+        // now check that they're not sharing the same property!
+        assertEquals "testme", t2.something
+        assertEquals "test2", t.something
 
-	}
+        t2.setSomething("test3")
 
-	void testCheckFailOnExistingConstructor() {
-		def metaClass = new ExpandoMetaClass(Test.class)
-		 try {
-			 metaClass.constructor << { ->
-				 "should fail. already exists!"
-			 }
-			 fail("Should have thrown exception when method already exists")
-		 }
-		 catch(Exception e) {
-			 // expected
-		 }
+        assertEquals "test3", t2.something
+    }
 
-	}
+    void testCheckFailOnExisting() {
+        def metaClass = new ExpandoMetaClass(Test.class)
+        try {
+            metaClass.existing << {->
+                "should fail. already exists!"
+            }
+            fail("Should have thrown exception when method already exists")
+        }
+        catch (Exception e) {
+            // expected
+        }
+    }
 
-	void testCheckFailOnExistingStaticMethod() {
-		def metaClass = new ExpandoMetaClass(Test.class)
-		 try {
-			 metaClass.'static'.existingStatic << { ->
-				 "should fail. already exists!"
-			 }
-			 fail("Should have thrown exception when method already exists")
-		 }
-		 catch(Exception e) {
-			 // expected
-		 }
+    void testCheckFailOnExistingConstructor() {
+        def metaClass = new ExpandoMetaClass(Test.class)
+        try {
+            metaClass.constructor << {->
+                "should fail. already exists!"
+            }
+            fail("Should have thrown exception when method already exists")
+        }
+        catch (Exception e) {
+            // expected
+        }
+    }
 
-	}
+    void testCheckFailOnExistingStaticMethod() {
+        def metaClass = new ExpandoMetaClass(Test.class)
+        try {
+            metaClass.'static'.existingStatic << {->
+                "should fail. already exists!"
+            }
+            fail("Should have thrown exception when method already exists")
+        }
+        catch (Exception e) {
+            // expected
+        }
+    }
 
     void testNewStaticMethod() {
-    	 def metaClass = new ExpandoMetaClass(Test.class, true)
-
-    	 metaClass.'static'.myStaticMethod << { String txt ->
-    		 "testme"
-    	 }
-    	 metaClass.initialize()
+        def metaClass = new ExpandoMetaClass(Test.class, true)
 
-    	 assertEquals "testme", Test.myStaticMethod("blah")
+        metaClass.'static'.myStaticMethod << {String txt ->
+            "testme"
+        }
+        metaClass.initialize()
 
+        assertEquals "testme", Test.myStaticMethod("blah")
     }
 
     void testReplaceStaticMethod() {
-	   	 def metaClass = new ExpandoMetaClass(Test.class, true)
+        def metaClass = new ExpandoMetaClass(Test.class, true)
 
-		 metaClass.'static'.existingStatic = { ->
-			 "testme"
-		 }
-		 metaClass.initialize()
+        metaClass.'static'.existingStatic = {->
+            "testme"
+        }
+        metaClass.initialize()
 
-		 assertEquals "testme", Test.existingStatic()
+        assertEquals "testme", Test.existingStatic()
 
     }
 
     void testNewZeroArgumentStaticMethod() {
-	   	 def metaClass = new ExpandoMetaClass(Test.class, true)
+        def metaClass = new ExpandoMetaClass(Test.class, true)
 
-		 metaClass.'static'.myStaticMethod = { ->
-			 "testme"
-		 }
-	   	metaClass.initialize()
+        metaClass.'static'.myStaticMethod = {->
+            "testme"
+        }
+        metaClass.initialize()
 
-		 assertEquals "testme", Test.myStaticMethod()
+        assertEquals "testme", Test.myStaticMethod()
     }
 
-	void testNewInstanceMethod() {
-		 def metaClass = new ExpandoMetaClass(Test.class)
-
-		 metaClass.myMethod << {
-			 "testme"
-		 }
-		 metaClass.initialize()
-
-		 def t = new Test()
-
-		 t.metaClass = metaClass
-
-		 assertEquals "testme", t.myMethod()
-
-	}
-
-
-	void testNewConstructor() {
-	   	 def metaClass = new ExpandoMetaClass(Test.class, true)
-
-		 metaClass.constructor << { String txt ->
-			 def t = Test.class.newInstance()
-			 t.name = txt
-			 return t
-		 }
-
-	   	metaClass.initialize()
+    void testNewInstanceMethod() {
+        def metaClass = new ExpandoMetaClass(Test.class)
 
-		 def t = new Test("testme")
-		 assert t
-		 assertEquals "testme", t.name
+        metaClass.myMethod << {
+            "testme"
+        }
+        metaClass.initialize()
 
-		 GroovySystem.metaClassRegistry.removeMetaClass(Test.class)
+        def t = new Test()
 
-	}
+        t.metaClass = metaClass
 
-	void testReplaceConstructor() {
-	   	 def metaClass = new ExpandoMetaClass(Test.class, true)
+        assertEquals "testme", t.myMethod()
+    }
 
-		 metaClass.constructor = { ->
-			 "testme"
-		 }
+    void testNewConstructor() {
+        def metaClass = new ExpandoMetaClass(Test.class, true)
 
-	   	metaClass.initialize()
+        metaClass.constructor << {String txt ->
+            def t = Test.class.newInstance()
+            t.name = txt
+            return t
+        }
 
-		 def t = new Test()
-		 assert t
-		 assertEquals "testme", t
+        metaClass.initialize()
 
-		 GroovySystem.metaClassRegistry.removeMetaClass(Test.class)
+        def t = new Test("testme")
+        assert t
+        assertEquals "testme", t.name
 
-	}
+        GroovySystem.metaClassRegistry.removeMetaClass(Test.class)
+    }
 
+    void testReplaceConstructor() {
+        def metaClass = new ExpandoMetaClass(Test.class, true)
 
+        metaClass.constructor = {->
+            "testme"
+        }
 
-	void testReplaceInstanceMethod() {
-		 def metaClass = new ExpandoMetaClass(Test.class)
+        metaClass.initialize()
 
-		 metaClass.existing2 = { Object i ->
-			 "testme"
-		 }
-		 metaClass.initialize()
+        def t = new Test()
+        assert t
+        assertEquals "testme", t
 
-		 def t = new Test()
-		 t.metaClass = metaClass
+        GroovySystem.metaClassRegistry.removeMetaClass(Test.class)
+    }
 
-		 def var = 1
-		 assertEquals "testme", t.existing2(var)
-	}
+    void testReplaceInstanceMethod() {
+        def metaClass = new ExpandoMetaClass(Test.class)
 
-	void testBorrowMethodFromAnotherClass() {
-		 def metaClass = new ExpandoMetaClass(Test.class)
+        metaClass.existing2 = {Object i ->
+            "testme"
+        }
+        metaClass.initialize()
 
-		 def a = new Another()
-		 metaClass.borrowMe = a.&another
-		 metaClass.initialize()
+        def t = new Test()
+        t.metaClass = metaClass
 
-		 def t = new Test()
-		 t.metaClass = metaClass
+        def var = 1
+        assertEquals "testme", t.existing2(var)
+    }
 
+    void testBorrowMethodFromAnotherClass() {
+        def metaClass = new ExpandoMetaClass(Test.class)
 
-		 assertEquals "mine blah!", t.borrowMe("blah")
+        def a = new Another()
+        metaClass.borrowMe = a.&another
+        metaClass.borrowMeToo = a.&noArgs
+        metaClass.initialize()
 
-	}
+        def t = new Test()
+        t.metaClass = metaClass
 
-	void testBorrowByName() {
-		 def metaClass = new ExpandoMetaClass(Test.class)
+        assertEquals "mine blah!", t.borrowMe("blah")
+        // GROOVY-1993
+//        assertEquals "no args here!", t.borrowMeToo()
+    }
 
-		 def a = new Another()
-		 metaClass.borrowMe = a.&'another'
-		 metaClass.initialize()
+    void testBorrowByName() {
+        println 'testBorrowByName'
+        def metaClass = new ExpandoMetaClass(Test.class)
 
-		 def t = new Test()
-		 t.metaClass = metaClass
+        def a = new Another()
+        metaClass.borrowMe = a.&'another'
+        metaClass.borrowMeToo = a.&'noArgs'
+        metaClass.initialize()
 
+        def t = new Test()
+        t.metaClass = metaClass
 
-		 assertEquals "mine blah!", t.borrowMe("blah")
+        assertEquals "mine blah!", t.borrowMe("blah")
+        // GROOVY-1993
+//        assertEquals "no args here!", t.borrowMeToo()
+    }
 
-	}
-	
     void testAddIdenticalPropertyToChildAndParent() {
         ExpandoMetaClass.enableGlobally()
         doMethods(SuperClass.class)
@@ -539,69 +505,74 @@ class ExpandoMetaClassTest extends GroovyTestCase {
         def parent = new SuperClass()
 
         assert parent.errors == null
-        parent.errors = [3,2,1,0]
+        parent.errors = [3, 2, 1, 0]
         assert parent.errors.size() == 4
 
         assert child.errors == null
-        child.errors = [1,2,3]
+        child.errors = [1, 2, 3]
         assert child.errors.size() == 3
         //TODO disable ExpandoMetaClass
     }
 
-    def doMethods(clazz){
-
+    def doMethods(clazz) {
         def metaClass = clazz.metaClass
 
-        metaClass.setErrors = { errors ->
-          thingo = errors
+        metaClass.setErrors = {errors ->
+            thingo = errors
         }
 
-        metaClass.getErrors = { ->
-          return thingo
+        metaClass.getErrors = {->
+            return thingo
         }
-
     }
 
 }
 class SuperClass {
-  def thingo
+    def thingo
 }
 
 class ChildClass extends SuperClass {
 
 }
+
 class TestInvokeMethod {
-    def invokeMe(String boo) { "Foo!! $boo" }
+    def invokeMe(String boo) {"Foo!! $boo"}
 
-    static myStaticMethod() { "bar!" }
+    static myStaticMethod() {"bar!"}
 }
+
 class TestGetProperty {
     String name = "Fred"
 }
+
 class Test {
-	String name
+    String name
 
-	def existing2(obj) {
-		"hello2!"
-	}
-	def existing() {
-		"hello!"
-	}
+    def existing2(obj) {
+        "hello2!"
+    }
+    def existing() {
+        "hello!"
+    }
 
-	def doSomething(Object txt) { txt }
+    def doSomething(Object txt) {txt}
 
-	static existingStatic() {
-		"I exist"
-	}
+    static existingStatic() {
+        "I exist"
+    }
 }
+
 class Another {
-   def another(txt) {
-	   "mine ${txt}!"
-   }
+    def another(txt) {
+        "mine ${txt}!"
+    }
+    def noArgs() {
+        "no args here!"
+    }
 }
-class Child extends Test {
 
-	def aChildMethod() {
-		"hello children"
-	}
+class Child extends Test {
+    def aChildMethod() {
+        "hello children"
+    }
 }
\ No newline at end of file
