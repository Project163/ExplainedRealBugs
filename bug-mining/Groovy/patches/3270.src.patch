diff --git a/subprojects/groovy-sql/src/main/java/groovy/sql/BatchingStatementWrapper.java b/subprojects/groovy-sql/src/main/java/groovy/sql/BatchingStatementWrapper.java
index edb521296c..8e6c4e1a37 100644
--- a/subprojects/groovy-sql/src/main/java/groovy/sql/BatchingStatementWrapper.java
+++ b/subprojects/groovy-sql/src/main/java/groovy/sql/BatchingStatementWrapper.java
@@ -83,8 +83,10 @@ public class BatchingStatementWrapper extends GroovyObjectSupport {
     }
 
     public int[] executeBatch() throws SQLException {
-        int[] lastResult = delegate.executeBatch();
-        processResult(lastResult);
+        if (shouldCallDelegate()) {
+            int[] lastResult = delegate.executeBatch();
+            processResult(lastResult);
+        }
         int[] result = new int[results.size()];
         for (int i = 0; i < results.size(); i++) {
             result[i] = results.get(i);
@@ -93,6 +95,17 @@ public class BatchingStatementWrapper extends GroovyObjectSupport {
         return result;
     }
 
+    private boolean shouldCallDelegate() {
+        if (batchCount > 0) {
+            return true;
+        } else if (results.isEmpty()) {
+            log.warning("Nothing has been added to batch. This might cause the JDBC driver to throw an exception.");
+            return true;
+        }
+        // Nothing added since last delegate execution. No need to call the delegate this time.
+        return false;
+    }
+
     protected void processResult(int[] lastResult) {
         boolean foundError = false;
         for (int i : lastResult) {
diff --git a/subprojects/groovy-sql/src/test/groovy/groovy/sql/SqlBatchTest.groovy b/subprojects/groovy-sql/src/test/groovy/groovy/sql/SqlBatchTest.groovy
index 02a6d65918..6916113bb8 100644
--- a/subprojects/groovy-sql/src/test/groovy/groovy/sql/SqlBatchTest.groovy
+++ b/subprojects/groovy-sql/src/test/groovy/groovy/sql/SqlBatchTest.groovy
@@ -18,6 +18,8 @@
  */
 package groovy.sql
 
+import groovy.test.GroovyAssert
+
 import javax.sql.DataSource
 
 import static groovy.sql.SqlTestConstants.*
@@ -119,6 +121,44 @@ class SqlBatchTest extends GroovyTestCase {
         // FINE: Successfully executed batch with 1 command(s)
     }
 
+    void testWithBatchHavingSizeSameSizeAsStatements() {
+        def numRows = sql.rows("SELECT * FROM PERSON").size()
+        assert numRows == 3
+        def myOthers = ['f4':'l4','f5':'l5','f6':'l6','f7':'l7']
+        def result = sql.withBatch(myOthers.size(), "insert into PERSON (id, firstname, lastname) values (?, ?, ?)") { ps ->
+            myOthers.eachWithIndex { k, v, index ->
+                def id = index + numRows + 1
+                ps.addBatch(id, k, v)
+            }
+        }
+        assert result == [1] * myOthers.size()
+        assert sql.rows("SELECT * FROM PERSON").size() == numRows + myOthers.size()
+        // end result the same as if no batching was in place but logging should show:
+        // FINE: Successfully executed batch with 4 command(s)
+    }
+
+    void testWithBatchNothingAddedToBatch() {
+        def numRows = sql.rows("SELECT * FROM PERSON").size()
+        assert numRows == 3
+
+        def result = sql.withBatch { ps ->
+            // Add nothing
+        }
+        assert result == [] as int[]
+    }
+
+    void testWithBatchWithPreparedStatementNothingAddedToBatch() {
+        def numRows = sql.rows("SELECT * FROM PERSON").size()
+        assert numRows == 3
+
+        // If you create a PreparedStatement you have to use it - or else HSQL throws an exception
+        GroovyAssert.shouldFail {
+            sql.withBatch(3, "insert into PERSON (id, firstname, lastname) values (?, ?, ?)") { ps ->
+                // Add nothing - not a good practice at all...
+            }
+        }
+    }
+
     void testWithBatchInsideWithTransaction() {
         def numRows = sql.rows("SELECT * FROM PERSON").size()
         assert numRows == 3
