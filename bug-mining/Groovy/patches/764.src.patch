diff --git a/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java b/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java
index 95d54658f8..7a4d66da1c 100644
--- a/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java
+++ b/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java
@@ -1105,6 +1105,7 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
     
             collectionExpression = expression(collectionNode);
             forParameter = new Parameter(type,variable);
+            configureAST(forParameter,variableNode);
         }
 
         final AST node = inNode.getNextSibling();
@@ -2022,7 +2023,7 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
     }
 
     protected Expression dotExpression(AST node) {
-        // let's decide if this is a propery invocation or a method call
+        // let's decide if this is a property invocation or a method call
         AST leftNode = node.getFirstChild();
         if (leftNode != null) {
             AST identifierNode = leftNode.getNextSibling();
diff --git a/src/main/org/codehaus/groovy/antlr/GroovySourceAST.java b/src/main/org/codehaus/groovy/antlr/GroovySourceAST.java
index 1573feed36..e5eb6916a4 100644
--- a/src/main/org/codehaus/groovy/antlr/GroovySourceAST.java
+++ b/src/main/org/codehaus/groovy/antlr/GroovySourceAST.java
@@ -29,7 +29,7 @@ import java.util.ArrayList;
  * @author Mike Spille
  * @author Jeremy Rayner <groovy@ross-rayner.com>
  */
-public class GroovySourceAST extends CommonAST implements Comparable {
+public class GroovySourceAST extends CommonAST implements Comparable, SourceInfo {
     private int line;
     private int col;
     private int lineLast;
@@ -58,6 +58,11 @@ public class GroovySourceAST extends CommonAST implements Comparable {
         super.initialize(t);
         line = t.getLine();
         col = t.getColumn();
+        if (t instanceof SourceInfo) {
+            SourceInfo info = (SourceInfo) t;
+            lineLast = info.getLineLast();
+            colLast  = info.getColumnLast(); 
+        }
     }
 
     public void setLast(Token last) {
diff --git a/src/main/org/codehaus/groovy/antlr/GroovySourceToken.java b/src/main/org/codehaus/groovy/antlr/GroovySourceToken.java
new file mode 100644
index 0000000000..8af57374e6
--- /dev/null
+++ b/src/main/org/codehaus/groovy/antlr/GroovySourceToken.java
@@ -0,0 +1,98 @@
+package org.codehaus.groovy.antlr;
+
+import antlr.Token;
+
+/*
+ * Copyright 2003-2007 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/**
+ * This is a Token sub class to track line information 
+ * 
+ * @author Jochen Theodorou
+ */
+public class GroovySourceToken extends Token implements SourceInfo{
+    protected int line;
+    protected String text = "";
+    protected int col;
+    protected int lineLast;
+    protected int colLast;
+
+    
+    /**
+     * Constructor using a token type
+     * 
+     * @param t the type
+     */
+    public GroovySourceToken(int t) {
+        super(t);
+    }
+    
+    public int getLine() {
+        return line;
+    }
+
+    /**
+     * get the source token text
+     * @return the source token text
+     */
+    public String getText() {
+        return text;
+    }
+
+    public void setLine(int l) {
+        line = l;
+    }
+
+    /**
+     * set the source token text
+     * @param s the text
+     */
+    public void setText(String s) {
+        text = s;
+    }
+
+    public String toString() {
+        return 
+            "[\"" + getText() + "\",<" + type + ">,"+
+            "line=" + line + ",col=" + col + 
+            ",lineLast=" + lineLast + ",colLast=" + colLast +
+            "]";
+    }
+
+    public int getColumn() {
+        return col;
+    }
+
+    public void setColumn(int c) {
+        col = c;
+    }
+    
+    public int getLineLast() {
+        return lineLast;
+    }
+
+    public void setLineLast(int lineLast) {
+        this.lineLast = lineLast;
+    }
+
+    public int getColumnLast() {
+        return colLast;
+    }
+
+    public void setColumnLast(int colLast) {
+        this.colLast = colLast;
+    }
+}
diff --git a/src/main/org/codehaus/groovy/antlr/SourceInfo.java b/src/main/org/codehaus/groovy/antlr/SourceInfo.java
new file mode 100644
index 0000000000..755f5a4877
--- /dev/null
+++ b/src/main/org/codehaus/groovy/antlr/SourceInfo.java
@@ -0,0 +1,44 @@
+package org.codehaus.groovy.antlr;
+
+public interface SourceInfo {
+    /**
+     * get start line
+     * @return the starting line
+     */
+    public int getLine();
+    /**
+     * set start line
+     * @param l the line
+     */
+    public void setLine(int l);
+    /**
+     * get starting column
+     * @return the starting column
+     */
+    public int getColumn();
+    /**
+     * set start column
+     * @param c the column
+     */
+    public void setColumn(int c);
+    /**
+     * get ending line
+     * @return the ending line
+     */
+    public int getLineLast();
+    /**
+     * set ending line
+     * @param lineLast the line
+     */
+    public void setLineLast(int lineLast);
+    /**
+     * get ending column
+     * @return the ending column
+     */
+    public int getColumnLast();
+    /**
+     * set ending column
+     * @param colLast the column
+     */
+    public void setColumnLast(int colLast);
+}
diff --git a/src/main/org/codehaus/groovy/antlr/groovy.g b/src/main/org/codehaus/groovy/antlr/groovy.g
index 015e60a4a7..83138dd0bd 100644
--- a/src/main/org/codehaus/groovy/antlr/groovy.g
+++ b/src/main/org/codehaus/groovy/antlr/groovy.g
@@ -204,7 +204,6 @@ options {
     codeGenBitsetTestThreshold = 3;
     defaultErrorHandler = false;      // Don't generate parser error handlers
     buildAST = true;
-//  ASTLabelType = "GroovyAST";
 }
 
 tokens {
@@ -266,11 +265,7 @@ tokens {
      *
      * todo - change antlr.ASTFactory to do this instead...
      */
-    public AST create(int type, String txt, Token first, Token last) {
-        return create(type, txt, astFactory.create(first), last);
-    }
-    
-    public AST create(int type, String txt, AST first, Token last) {
+    public AST create(int type, String txt, AST first) {
         AST t = astFactory.create(type,txt);
         if ( t != null && first != null) {
             // first copy details from first token
@@ -278,15 +273,32 @@ tokens {
             // then ensure that type and txt are specific to this new node
             t.initialize(type,txt);
         }
-
-        if ((t instanceof GroovySourceAST) && last != null) {
+        return t;
+    }
+    
+    private AST attachLast(AST t, Object last) {
+    	if ((t instanceof GroovySourceAST) && (last instanceof SourceInfo)) {
+            SourceInfo lastInfo = (SourceInfo) last;
             GroovySourceAST node = (GroovySourceAST)t;
-            node.setLast(last);
+            node.setColumnLast(lastInfo.getColumn());
+            node.setLineLast(lastInfo.getLine());
             // This is a good point to call node.setSnippet(),
             // but it bulks up the AST too much for production code.
         }
         return t;
     }
+     
+    public AST create(int type, String txt, Token first, Token last) {
+        return attachLast(create(type, txt, astFactory.create(first)), last);
+    }
+    
+    public AST create(int type, String txt, AST first, Token last) {
+        return attachLast(create(type, txt, first), last);
+    }
+    
+    public AST create(int type, String txt, AST first, AST last) {
+        return attachLast(create(type, txt, first), last);
+    }
     
     /** 
     *   Clones the token
@@ -2809,15 +2821,18 @@ stringConstructorValuePart
 // the arguments are all labeled (or SPREAD_MAP_ARG) or all unlabeled (and not SPREAD_MAP_ARG).
 listOrMapConstructorExpression
         { boolean hasLabels = false; }
-    :   lcon:LBRACK^
-        argList                 { hasLabels |= argListHasLabels;  }  // any argument label implies a map
+    :   lcon:LBRACK!
+        args:argList                 { hasLabels |= argListHasLabels;  }  // any argument label implies a map
         RBRACK!
-        { #lcon.setType(hasLabels ? MAP_CONSTRUCTOR : LIST_CONSTRUCTOR); }
+        {   int type = hasLabels ? MAP_CONSTRUCTOR : LIST_CONSTRUCTOR;
+        	#listOrMapConstructorExpression = #(create(type,"[",lcon,LT(1)),args); 
+        }
     |
         /* Special case:  [:] is an empty map constructor. */
         emcon:LBRACK^ COLON! RBRACK!   {#emcon.setType(MAP_CONSTRUCTOR);}
     ;
 
+
 /*OBS*
 /** Match a, a.b.c refs, a.b.c(...) refs, a.b.c[], a.b.c[].class,
  *  and a.b.c.class refs. Also this(...) and super(...). Match
@@ -3217,21 +3232,15 @@ options {
     protected ArrayList parenLevelStack = new ArrayList();
     protected int lastSigTokenType = EOF;  // last returned non-whitespace token
 
-    public void setTokenObjectClass(String name) {
-        // we overwrite this  method here, because we want to force the usage
-        // of our token class from our package through our class loader. 
-        // It must be our claassloader, because for OSGI environments the class
-        // may not be accessible otherwise.
-        if (CommonToken.class.getName().equals(name)) {
-            tokenObjectClass = CommonToken.class;
-        } else {
-            throw new GroovyBugError(
-                "We forced setTokenObjectClass to use only "+
-                CommonToken.class.getName()+". "+name+
-                " is not supported!\nIf you need "+
-                "a different class, please first change "+
-                "setTokenObjectClass(String) in groovy.g");
-        }
+    public void setTokenObjectClass(String name) {/*ignore*/}
+    
+    protected Token makeToken(int t) {
+        GroovySourceToken tok = new GroovySourceToken(t);
+        tok.setColumn(inputState.getTokenStartColumn());
+        tok.setLine(inputState.getTokenStartLine());
+        tok.setColumnLast(inputState.getColumn());
+        tok.setLineLast(inputState.getLine());
+        return tok;
     }
     
     protected void pushParenLevel() {
@@ -3239,6 +3248,7 @@ options {
         parenLevel = 0;
         stringCtorState = 0;
     }
+    
     protected void popParenLevel() {
         int npl = parenLevelStack.size();
         if (npl == 0)  return;
diff --git a/src/test/org/codehaus/groovy/ast/LineColumnCheck.txt b/src/test/org/codehaus/groovy/ast/LineColumnCheck.txt
index 8ac132b077..cf7070cb5e 100644
--- a/src/test/org/codehaus/groovy/ast/LineColumnCheck.txt
+++ b/src/test/org/codehaus/groovy/ast/LineColumnCheck.txt
@@ -3,9 +3,9 @@ public class Test {
 	public attribute = 6, second = 9
 	String prop = "property"
 }
-:::[FieldNode,(2:2),(2:22)][ConstantExpression,(2:21),(2:24)];
-[FieldNode,(2:24),(2:34)][ConstantExpression,(2:33),(3:2)];
-[FieldNode,(3:2),(3:26)][ConstantExpression,(3:16),(0:0)]
+:::[FieldNode,(2:2),(2:22)][ConstantExpression,(2:21),(2:22)];
+[FieldNode,(2:24),(2:34)][ConstantExpression,(2:33),(2:34)];
+[FieldNode,(3:2),(3:26)][ConstantExpression,(3:16),(3:26)]
 
 ###ifelse:::
 if (expression) {
@@ -118,8 +118,8 @@ switch (expression) {
 	case 2 : log = 2
 }
 :::[SwitchStatement,(1:1),(4:2)];
-[CaseStatement,(2:2),(2:7)];[BlockStatement,(2:11),(3:2)];
-[CaseStatement,(3:2),(3:7)];[BlockStatement,(3:11),(4:1)]
+[CaseStatement,(2:2),(2:6)];[BlockStatement,(2:11),(3:2)];
+[CaseStatement,(3:2),(3:6)];[BlockStatement,(3:11),(4:1)]
 
 ###switchCaseDefault:::
 switch (expression) {
@@ -128,8 +128,8 @@ switch (expression) {
 	default : log = 6
 }
 :::[SwitchStatement,(1:1),(5:2)];
-[CaseStatement,(2:2),(2:7)];[BlockStatement,(2:11),(3:2)];[BreakStatement,(2:21),(2:26)];
-[CaseStatement,(3:2),(3:7)];[BlockStatement,(3:11),(4:2)];[BreakStatement,(3:21),(3:26)];
+[CaseStatement,(2:2),(2:6)];[BlockStatement,(2:11),(3:2)];[BreakStatement,(2:21),(2:26)];
+[CaseStatement,(3:2),(3:6)];[BlockStatement,(3:11),(4:2)];[BreakStatement,(3:21),(3:26)];
 [BlockStatement,(4:12),(5:1)]
 
 ###synchronizedStatement:::
@@ -154,7 +154,7 @@ assert (expression)
 ###assertStatementAdv:::
 assert (expression) , "AssertTest"
 :::[AssertStatement,(1:1),(1:35)][BooleanExpression,(1:8),(1:21)];
-[VariableExpression,(1:8),(1:21)][ConstantExpression,(1:23),(0:0)]
+[VariableExpression,(1:8),(1:21)][ConstantExpression,(1:23),(1:35)]
 
 ###throwStatement:::
 throw new Exception("exception")
@@ -181,20 +181,20 @@ for (def i = 1; i < 42; i++)
 
 ###oneLineMultiDef:::
 Integer i = 0, j = 42, k = 6
-:::[ExpressionStatement,(1:1),(1:14)][ClassNode,(1:1),(1:9)][DeclarationExpression,(1:1),(1:14)];
-[VariableExpression,(1:9),(1:11)][ConstantExpression,(1:13),(1:16)];
-[ExpressionStatement,(1:16),(1:22)][ClassNode,(1:1),(1:16)][DeclarationExpression,(1:16),(1:22)];
-[VariableExpression,(1:16),(1:18)][ConstantExpression,(1:20),(1:24)];
-[ExpressionStatement,(1:24),(1:29)][ClassNode,(1:1),(1:24)][DeclarationExpression,(1:24),(1:29)];
-[VariableExpression,(1:24),(1:26)][ConstantExpression,(1:28),(0:0)]
+:::[ExpressionStatement,(1:1),(1:14)][ClassNode,(1:1),(1:8)][DeclarationExpression,(1:1),(1:14)];
+[VariableExpression,(1:9),(1:10)][ConstantExpression,(1:13),(1:14)];
+[ExpressionStatement,(1:16),(1:22)][ClassNode,(1:1),(1:8)][DeclarationExpression,(1:16),(1:22)];
+[VariableExpression,(1:16),(1:17)][ConstantExpression,(1:20),(1:22)];
+[ExpressionStatement,(1:24),(1:29)][ClassNode,(1:1),(1:8)][DeclarationExpression,(1:24),(1:29)];
+[VariableExpression,(1:24),(1:25)][ConstantExpression,(1:28),(1:29)]
 
 ###oneLineDef:::
 Integer onLine = 42
 def ii = 17
-:::[ExpressionStatement,(1:1),(1:20)][ClassNode,(1:1),(1:9)][DeclarationExpression,(1:1),(1:20)];
-[VariableExpression,(1:9),(1:16)][ConstantExpression,(1:18),(2:1)];
+:::[ExpressionStatement,(1:1),(1:20)][ClassNode,(1:1),(1:8)][DeclarationExpression,(1:1),(1:20)];
+[VariableExpression,(1:9),(1:15)][ConstantExpression,(1:18),(1:20)];
 [ExpressionStatement,(2:1),(2:12)][ClassNode,(-1:-1),(-1:-1)][DeclarationExpression,(2:1),(2:12)];
-[VariableExpression,(2:5),(2:8)][ConstantExpression,(2:10),(0:0)]
+[VariableExpression,(2:5),(2:7)][ConstantExpression,(2:10),(2:12)]
 
 ###parenthisedExpressionVariable:::
 myMap = [(key):value]
@@ -220,13 +220,13 @@ class Test {
 
 ###methodCallExpressionInAssignment:::
 sub = "groovy".substring(3)
-:::[MethodCallExpression,(1:7),(1:28)][ConstantExpression,(1:7),(1:16)];
-[ConstantExpression,(1:16),(1:26)][ArgumentListExpression,(1:26),(1:27)];
+:::[MethodCallExpression,(1:7),(1:28)][ConstantExpression,(1:7),(1:15)];
+[ConstantExpression,(1:16),(1:25)][ArgumentListExpression,(1:26),(1:27)];
 [ConstantExpression,(1:26),(1:27)]
 
 ###constructorCallExpressionInAssignment:::
 txt = new String("groovy")
-:::[ConstructorCallExpression,(1:7),(1:27)][ClassNode,(1:11),(1:18)][ArgumentListExpression,(1:18),(1:26)];
+:::[ConstructorCallExpression,(1:7),(1:27)][ClassNode,(1:11),(1:17)][ArgumentListExpression,(1:18),(1:26)];
 [ConstantExpression,(1:18),(1:26)]
 
 ###methodCallExpressionAppendedBlockInAssignment:::
@@ -237,33 +237,33 @@ var = f{closure}
 ###methodCallExpressionArgsAndAppendedBlock:::
 a = f(x){y}
 :::[MethodCallExpression,(1:5),(1:12)];
-[ConstantExpression,(1:5),(1:7)][ArgumentListExpression,(1:7),(1:8)][VariableExpression,(1:7),(1:8)];
+[ConstantExpression,(1:5),(1:6)][ArgumentListExpression,(1:7),(1:8)][VariableExpression,(1:7),(1:8)];
 [ClosureExpression,(1:9),(1:12)]
 
 ###ArrayExpressionD1:::
 def array = new int[1]
-:::[ArrayExpression,(1:13),(1:23)][ClassNode,(1:17),(1:20)][ConstantExpression,(1:21),(0:0)]
+:::[ArrayExpression,(1:13),(1:23)][ClassNode,(1:17),(1:20)][ConstantExpression,(1:21),(1:22)]
 
 ###ArrayExpressionD2:::
 def array = new int[1][2]
-:::[ArrayExpression,(1:13),(1:26)][ClassNode,(1:17),(1:23)];
-[ConstantExpression,(1:21),(1:24)][ConstantExpression,(1:24),(0:0)]
+:::[ArrayExpression,(1:13),(1:26)][ClassNode,(1:17),(1:20)];
+[ConstantExpression,(1:21),(1:22)][ConstantExpression,(1:24),(1:25)]
 
 ###methodCallExpressionChain:::
 b = getClass().getName().substring(42)
 :::[MethodCallExpression,(1:5),(1:39)][MethodCallExpression,(1:5),(1:25)];
 [MethodCallExpression,(1:5),(1:15)];
-[ConstantExpression,(1:5),(1:14)][ArgumentListExpression,(1:14),(1:14)];
-[ConstantExpression,(1:16),(1:24)][ArgumentListExpression,(1:24),(1:24)];
-[ConstantExpression,(1:26),(1:36)][ArgumentListExpression,(1:36),(1:38)];
+[ConstantExpression,(1:5),(1:13)][ArgumentListExpression,(1:14),(1:14)];
+[ConstantExpression,(1:16),(1:23)][ArgumentListExpression,(1:24),(1:24)];
+[ConstantExpression,(1:26),(1:35)][ArgumentListExpression,(1:36),(1:38)];
 [ConstantExpression,(1:36),(1:38)]
 
 ###methodCallExpressionNested:::
 b = outerMethod(obj.innerMethod(abc))
 :::[MethodCallExpression,(1:5),(1:38)];
-[ConstantExpression,(1:5),(1:17)][ArgumentListExpression,(1:17),(1:37)];
-[MethodCallExpression,(1:17),(1:37)][VariableExpression,(1:17),(1:21)];
-[ConstantExpression,(1:21),(1:33)][ArgumentListExpression,(1:33),(1:36)];
+[ConstantExpression,(1:5),(1:16)][ArgumentListExpression,(1:17),(1:37)];
+[MethodCallExpression,(1:17),(1:37)][VariableExpression,(1:17),(1:20)];
+[ConstantExpression,(1:21),(1:32)][ArgumentListExpression,(1:33),(1:36)];
 [VariableExpression,(1:33),(1:36)]
 
 ###indexPropertyArgsWithObj:::
@@ -288,7 +288,7 @@ def i = Integer.parseInt("42")
 
 ###throwsClauseName:::
 def method() throws Exception {}
-:::[ClassNode,(1:21),(1:31)]
+:::[ClassNode,(1:21),(1:30)]
 
 ###throwsClauseQualifiedName:::
 def method() throws java.lang.Exception {}
@@ -301,19 +301,19 @@ def method() throws java.lang.Exception, java.lang.RuntimeException {}
 ###extendsClassNode:::
 class BaseClass {}
 class ExtendedBaseClass extends BaseClass {}
-:::[ClassNode,(2:33),(2:43)]
+:::[ClassNode,(2:33),(2:42)]
 
 ###implementsClassNode1:::
 interface IBase {}
 class BaseClass implements IBase {}
-:::[ClassNode,(2:28),(2:34)]
+:::[ClassNode,(2:28),(2:33)]
 
 ###implementsClassNode3:::
 interface IBase1 {}
 interface IBase2 {}
 interface IBase3 {}
 class BaseClass implements IBase1, IBase2, IBase3 {}
-:::[ClassNode,(4:28),(4:36)][ClassNode,(4:36),(4:44)][ClassNode,(4:44),(4:51)]
+:::[ClassNode,(4:28),(4:34)][ClassNode,(4:36),(4:42)][ClassNode,(4:44),(4:50)]
 
 ###importStatement:::
 import java.io.File
@@ -333,13 +333,13 @@ import static java.lang.Math.cos
 
 ###declarationWithFullQualifiedTypeName:::
 java.lang.String s = "Groovy"
-:::[ClassNode,(1:1),(1:18)][DeclarationExpression,(1:1),(1:30)][VariableExpression,(1:18),(1:20)]
+:::[ClassNode,(1:1),(1:18)][DeclarationExpression,(1:1),(1:30)][VariableExpression,(1:18),(1:19)]
 
 ###typeArgument:::
 Map<String,Object> map
 :::[ClassNode,(1:1),(1:4)];
-[GenericsType,(1:5),(1:11)][ClassNode,(1:5),(1:12)];
-[GenericsType,(1:12),(1:18)][ClassNode,(1:12),(1:20)]
+[GenericsType,(1:5),(1:11)][ClassNode,(1:5),(1:11)];
+[GenericsType,(1:12),(1:18)][ClassNode,(1:12),(1:18)]
 
 ###typeArgumentFullQualifiedTypeName:::
 Map<java.lang.String,java.lang.Object> map
@@ -363,18 +363,18 @@ Collection<? extends String,? super File> c
 
 ###typeArgumentNested:::
 class C<Y,T extends Map<String,Map<Y,Integer>>> {}
-:::[ClassNode,(1:1),(1:51)][GenericsType,(1:9),(1:10)][ClassNode,(1:9),(1:11)];
-[GenericsType,(1:11),(1:49)][ClassNode,(1:11),(1:13)][ClassNode,(1:21),(1:49)];
-[GenericsType,(1:25),(1:31)][ClassNode,(1:25),(1:32)][GenericsType,(1:32),(1:49)][ClassNode,(1:32),(1:35)];
-[GenericsType,(1:36),(1:37)][ClassNode,(1:36),(1:38)][GenericsType,(1:38),(1:45)][ClassNode,(1:38),(1:49)]
+:::[ClassNode,(1:1),(1:51)][GenericsType,(1:9),(1:10)][ClassNode,(1:9),(1:10)];
+[GenericsType,(1:11),(1:49)][ClassNode,(1:11),(1:12)][ClassNode,(1:21),(1:49)];
+[GenericsType,(1:25),(1:31)][ClassNode,(1:25),(1:31)][GenericsType,(1:32),(1:49)][ClassNode,(1:32),(1:35)];
+[GenericsType,(1:36),(1:37)][ClassNode,(1:36),(1:37)][GenericsType,(1:38),(1:45)][ClassNode,(1:38),(1:45)]
 
 ###typeArugmentInConstructorCall:::
 ArrayList<String> list = new ArrayList<String>()
-:::[ClassNode,(1:30),(1:39)][GenericsType,(1:40),(1:46)][ClassNode,(1:40),(1:48)]
+:::[ClassNode,(1:30),(1:39)][GenericsType,(1:40),(1:46)][ClassNode,(1:40),(1:46)]
 
 ###castExpressionClassNode:::
 String s = (String)i
-:::[ClassNode,(1:13),(1:20)]
+:::[ClassNode,(1:13),(1:19)]
 
 ###castExpressionFullQualifiedClassNode:::
 String s = (java.lang.String)i
@@ -382,7 +382,7 @@ String s = (java.lang.String)i
 
 ###AsCastExpressionClassNode:::
 String s = i as String
-:::[ClassNode,(1:17),(0:0)]
+:::[ClassNode,(1:17),(1:23)]
 
 ###AsCastExpressionFullQualifiedClassNode:::
 String s = i as java.lang.String
@@ -406,25 +406,25 @@ TestClass.prop.prop = 42
 
 ###MethodPointerExpression:::
 def selection = list.find (entry.&validate)
-:::[MethodPointerExpression,(1:28),(1:43)][VariableExpression,(1:28),(1:35)][ConstantExpression,(1:35),(0:0)]
+:::[MethodPointerExpression,(1:28),(1:43)][VariableExpression,(1:28),(1:33)][ConstantExpression,(1:35),(1:43)]
 
 ###Spread_DOT:::
 def onlyAccess = list*.access
-:::[PropertyExpression,(1:18),(1:30)][VariableExpression,(1:18),(1:24)][ConstantExpression,(1:24),(0:0)]
+:::[PropertyExpression,(1:18),(1:30)][VariableExpression,(1:18),(1:22)][ConstantExpression,(1:24),(1:30)]
 
 ###Optional_DOT:::
 def property = obj?.prop
-:::[PropertyExpression,(1:16),(1:25)][VariableExpression,(1:16),(1:21)][ConstantExpression,(1:21),(0:0)]
+:::[PropertyExpression,(1:16),(1:25)][VariableExpression,(1:16),(1:19)][ConstantExpression,(1:21),(1:25)]
 
 ###PropertyExpressionStaticImportClasses:::
 import static java.lang.Math.* 
 def num = Math.PI
-:::[PropertyExpression,(2:11),(2:18)][ClassExpression,(2:11),(2:16)][ConstantExpression,(2:16),(0:0)]
+:::[PropertyExpression,(2:11),(2:18)][ClassExpression,(2:11),(2:15)][ConstantExpression,(2:16),(2:18)]
 
 ###PropertyExpressionStaticImportAliases:::
 import static java.lang.Math.PI as PIPI 
 def num = Math.PIPI
-:::[PropertyExpression,(2:11),(2:20)][ClassExpression,(2:11),(2:16)][ConstantExpression,(2:16),(0:0)]
+:::[PropertyExpression,(2:11),(2:20)][ClassExpression,(2:11),(2:15)][ConstantExpression,(2:16),(2:20)]
 
 ###AttributeExpression1:::
 class Bean {
@@ -432,7 +432,7 @@ class Bean {
 }
 def bean = new Bean(value:42)
 def vlaue = bean.@value
-:::[AttributeExpression,(5:13),(5:24)][VariableExpression,(5:13),(5:18)][ConstantExpression,(5:19),(0:0)]
+:::[AttributeExpression,(5:13),(5:24)][VariableExpression,(5:13),(5:17)][ConstantExpression,(5:19),(5:24)]
 
 ###AttributeExpression2:::
 class Bean {
@@ -440,4 +440,4 @@ class Bean {
 }
 Bean bean = new Bean(value:42)
 def attr = attributeAccess.@'value'
-:::[AttributeExpression,(5:12),(5:36)][VariableExpression,(5:12),(5:28)][ConstantExpression,(5:29),(0:0)]
\ No newline at end of file
+:::[AttributeExpression,(5:12),(5:36)][VariableExpression,(5:12),(5:27)][ConstantExpression,(5:29),(5:36)]
\ No newline at end of file
diff --git a/src/test/org/codehaus/groovy/ast/LineColumnChecker.java b/src/test/org/codehaus/groovy/ast/LineColumnChecker.java
index 8eff57ae11..83a5e3beb9 100644
--- a/src/test/org/codehaus/groovy/ast/LineColumnChecker.java
+++ b/src/test/org/codehaus/groovy/ast/LineColumnChecker.java
@@ -78,7 +78,7 @@ public class LineColumnChecker extends ASTTest {
 		//comment out next line to view the output of the visitor
 		//System.out.println(name + ": " + was);
 		for (int i = 0; i < expected.length; i++) {
-			assertTrue(expected[i] + " not found in" + was, was.indexOf(expected[i].trim()) != -1);
+			assertTrue("'"+ expected[i] + "' not found in '" + was + "'", was.indexOf(expected[i].trim()) != -1);
 		}
 	}
 }
diff --git a/src/test/org/codehaus/groovy/ast/source/Groovy3049Test.groovy b/src/test/org/codehaus/groovy/ast/source/Groovy3049Test.groovy
new file mode 100644
index 0000000000..c04db162d8
--- /dev/null
+++ b/src/test/org/codehaus/groovy/ast/source/Groovy3049Test.groovy
@@ -0,0 +1,59 @@
+package org.codehaus.groovy.ast.source
+
+
+class Groovy3049Test extends SourceBaseTestCase {
+    def script = '''
+        println new URL("http://google.com").getT
+            
+        name = "xxx"
+        "User ${name}"
+    '''        
+    
+
+    void testLine2() {
+        def statements = statements()
+        
+        // println((new URL("http://google.com")).getT)
+        def printlnCall = statements[0].expression 
+        assert sourceInfo(printlnCall) == [2,9, 2,50]
+        
+        // println
+        assert sourceInfo(printlnCall.method) == [2,9, 2,16]
+        
+        // (new URL("http://google.com")).getT
+        def propertyExpression = printlnCall.arguments.expressions[0]
+        assert sourceInfo(propertyExpression) == [2,17, 2,50]
+        
+        // .getT
+        assert sourceInfo(propertyExpression.property) == [2,46, 2,50]
+        
+        // new URL("http://google.com")
+        def newExpression = propertyExpression.objectExpression
+        assert sourceInfo(newExpression) == [2,17, 2,45]
+        
+        // "http://google.com"
+        assert sourceInfo(newExpression.arguments.expressions[0]) ==[2,25, 2,44] 
+   }
+   
+   void testLine4() {
+        def statements = statements()
+        
+        // name = "xxx"
+        def assignment = statements[1].expression
+        assert sourceInfo(assignment) == [4,9, 4,21]
+        
+        // name
+        assert sourceInfo(assignment.leftExpression) == [4,9, 4,13]
+        
+        // "xxx"
+        assert sourceInfo(assignment.rightExpression) == [4,16, 4,21]
+   }
+   
+   void testLine5() {
+        def statements = statements()
+        
+        // "User ${name}"
+        def gstring = statements[2].expression
+        assert sourceInfo(gstring) == [5,9, 5,23]
+   }
+}
\ No newline at end of file
diff --git a/src/test/org/codehaus/groovy/ast/source/Groovy3050Test.groovy b/src/test/org/codehaus/groovy/ast/source/Groovy3050Test.groovy
new file mode 100644
index 0000000000..7a1c11f825
--- /dev/null
+++ b/src/test/org/codehaus/groovy/ast/source/Groovy3050Test.groovy
@@ -0,0 +1,51 @@
+package org.codehaus.groovy.ast.source
+
+
+class Groovy3050Test extends SourceBaseTestCase {
+    def script = '''
+        (5..8).a
+        [1,2].a
+    '''        
+    
+
+    void testLine2() {
+        def statements = statements()
+        
+        // (5..8).a
+        def propExpression = statements[0].expression 
+        assert sourceInfo(propExpression) == [2,9, 2,17]
+        
+        // a
+        assert sourceInfo(propExpression.property) == [2,16, 2,17]
+        
+        // (5..8)
+        def range = propExpression.objectExpression
+        assert sourceInfo(range) == [2,9, 2,15]
+        
+        // 5
+        //assert sourceInfo(range.from) == [2,10, 2,11]
+        
+        // 8
+        //assert sourceInfo(range.to) == [2,13, 2,13]
+   }
+   
+    void testLine3() {
+        def statements = statements()
+        // [1,2].a
+        def propExpression = statements[1].expression
+        assert sourceInfo(propExpression) == [3,9, 3,16]
+        
+        // a
+        assert sourceInfo(propExpression.property) == [3,15, 3,16]
+        
+        // [1,2]
+        def list = propExpression.objectExpression
+        assert sourceInfo(list) == [3,9, 3,14]
+        
+        // 1
+        assert sourceInfo(list.expressions[0]) == [3,10, 3,11]
+        
+        // 2
+        assert sourceInfo(list.expressions[1]) == [3,12, 3,13]
+   }
+}
\ No newline at end of file
diff --git a/src/test/org/codehaus/groovy/ast/source/Groovy3051Test.groovy b/src/test/org/codehaus/groovy/ast/source/Groovy3051Test.groovy
new file mode 100644
index 0000000000..40dac26d7d
--- /dev/null
+++ b/src/test/org/codehaus/groovy/ast/source/Groovy3051Test.groovy
@@ -0,0 +1,66 @@
+package org.codehaus.groovy.ast.source
+
+
+class Groovy3051Test extends SourceBaseTestCase {
+    def script = '''
+        for(Object item in [1:1,2:2]) {}
+        for(Object item in [1,2]) {}
+    '''        
+    
+
+    void testLine2() {
+        def statements = statements()
+        
+        // for(Object item in [1:1,2:2]) {}
+        def forStatement = statements[0] 
+        assert sourceInfo(forStatement) == [2,9, 2,41]
+        
+        // Object item
+        def variable = forStatement.variable
+        assert sourceInfo(variable) == [2,20, 2,24]
+        assert sourceInfo(variable.type) == [2,13, 2,19]
+        
+        // [1:1,2:2]
+        def map = forStatement.collectionExpression
+        assert sourceInfo(map) == [2,28, 2,37]
+        
+        def entries = map.mapEntryExpressions
+        
+        // 1:1
+        assert sourceInfo(entries[0].keyExpression) == [2,29, 2,30]
+        assert sourceInfo(entries[0].valueExpression) == [2,31, 2,32]
+        
+        // 2:2
+        assert sourceInfo(entries[1].keyExpression) == [2,33, 2,34]
+        assert sourceInfo(entries[1].valueExpression) == [2,35, 2,36]
+        
+        // {}
+        assert sourceInfo(forStatement.loopBlock) == [2,39, 2,41]
+   }
+
+   void testLine3() {
+        def statements = statements()
+        
+        // for(Object item in [1,2]) {}
+        def forStatement = statements[1] 
+        assert sourceInfo(forStatement) == [3,9, 3,37]
+        
+        // Object item
+        def variable = forStatement.variable
+        assert sourceInfo(variable) == [3,20, 3,24]
+        assert sourceInfo(variable.type) == [3,13, 3,19]
+        
+        // [1,2]
+        def list = forStatement.collectionExpression
+        assert sourceInfo(list) == [3,28, 3,33]
+        
+        // 1
+        assert sourceInfo(list.expressions[0]) == [3,29, 3,30]
+        
+        // 2
+        assert sourceInfo(list.expressions[1]) == [3,31, 3,32]
+        
+        // {}
+        assert sourceInfo(forStatement.loopBlock) == [3,35, 3,37]
+   }
+}
\ No newline at end of file
diff --git a/src/test/org/codehaus/groovy/ast/source/SourceBaseTestCase.groovy b/src/test/org/codehaus/groovy/ast/source/SourceBaseTestCase.groovy
new file mode 100644
index 0000000000..4952d13987
--- /dev/null
+++ b/src/test/org/codehaus/groovy/ast/source/SourceBaseTestCase.groovy
@@ -0,0 +1,34 @@
+package org.codehaus.groovy.ast.source
+
+import org.codehaus.groovy.control.*
+import org.codehaus.groovy.control.io.*
+import org.codehaus.groovy.ast.stmt.*
+
+class SourceBaseTestCase extends GroovyTestCase {
+
+    private classNode
+    public classNode() {
+      if (classNode!=null) return node
+      def cu = new CompilationUnit(null,null,this.class.classLoader)
+      def source = new StringReaderSource(script,cu.configuration)
+      def su = cu.addSource(new SourceUnit("Script_"+this.name, source, cu.configuration, cu.classLoader, cu.errorCollector))
+      cu.compile(Phases.CONVERSION)
+      classNode = cu.firstClassNode
+      return classNode
+    }
+    
+    def sourceInfo(expression) {
+      return [  expression.lineNumber,
+                expression.columnNumber,
+                expression.lastLineNumber,
+                expression.lastColumnNumber 
+             ]
+    }
+    
+    def statements(String method="run") {
+      def ret = classNode().getMethod(method).code
+      if (ret instanceof BlockStatement) return ret.statements
+      if (ret==null) return null
+      return [ret]
+    }
+}
\ No newline at end of file
