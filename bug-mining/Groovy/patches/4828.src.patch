diff --git a/src/main/java/org/codehaus/groovy/transform/stc/DelegationMetadata.java b/src/main/java/org/codehaus/groovy/transform/stc/DelegationMetadata.java
index fe700bc1e5..020c992167 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/DelegationMetadata.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/DelegationMetadata.java
@@ -21,10 +21,9 @@ package org.codehaus.groovy.transform.stc;
 import org.codehaus.groovy.ast.ClassNode;
 
 /**
- * Delegation metadata is used to store the delegation strategy and delegate type of
- * closures.
- *
- * As closures can be organized in a hierarchy, a delegation metadata may have a parent.
+ * Stores the delegation strategy and delegate type of closures.
+ * <p>
+ * As closures can be nested, a delegation metadata may have a parent.
  */
 class DelegationMetadata {
     private final DelegationMetadata parent;
@@ -33,7 +32,7 @@ class DelegationMetadata {
 
     public DelegationMetadata(final ClassNode type, final int strategy, final DelegationMetadata parent) {
         this.strategy = strategy;
-        this.type = type;
+        this.type = StaticTypeCheckingVisitor.wrapTypeIfNecessary(type); // non-primitive
         this.parent = parent;
     }
 
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/Receiver.java b/src/main/java/org/codehaus/groovy/transform/stc/Receiver.java
index 20369269fe..0f8279b647 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/Receiver.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/Receiver.java
@@ -21,38 +21,53 @@ package org.codehaus.groovy.transform.stc;
 import org.codehaus.groovy.ast.ClassHelper;
 import org.codehaus.groovy.ast.ClassNode;
 
+import static java.util.Objects.requireNonNull;
+
 public class Receiver<T> {
-    private final ClassNode type;
-    private final T data;
 
     public static <T> Receiver<T> make(final ClassNode type) {
-        return new Receiver<T>(type == null ? ClassHelper.OBJECT_TYPE.getPlainNodeReference() : type);
+        return new Receiver<>(type == null ? ClassHelper.OBJECT_TYPE.getPlainNodeReference() : type);
     }
 
+    private final ClassNode type;
+    private final boolean object;
+    private final T data;
+
     public Receiver(final ClassNode type) {
-        this.type = type;
-        this.data = null;
+        this(type, true, null);
     }
 
     public Receiver(final ClassNode type, final T data) {
+        this(type, true, data);
+    }
+
+    public Receiver(final ClassNode type, final boolean object, final T data) {
+        this.type = requireNonNull(type);
+        this.object = object;
         this.data = data;
-        this.type = type;
     }
 
+    //--------------------------------------------------------------------------
+
     public T getData() {
         return data;
     }
 
+    /**
+     * Indicates if receiver is an object instance or a class (static) reference.
+     *
+     * @since 5.0.0
+     */
+    public boolean isObject() {
+        return object;
+    }
+
     public ClassNode getType() {
         return type;
     }
 
     @Override
-    public String toString() {
-        String sb = "Receiver" +
-                "{type=" + type +
-                ", data=" + data +
-                '}';
-        return sb;
+    public final String toString() {
+        return "Receiver{data=" + data + ", type=" + (object ? "" : "*") + type.toString(false) + "}";
     }
 }
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index b5619cc1a9..a9e578ee4b 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -1546,9 +1546,8 @@ out:    if ((samParameterTypes.length == 1 && isOrImplements(samParameterTypes[0
         if (propertyName == null) return false;
 
         Expression objectExpression = pexp.getObjectExpression();
-        ClassNode objectExpressionType = getType(objectExpression);
         if (objectExpression instanceof ConstructorCallExpression) {
-            ClassNode rawType = objectExpressionType.getPlainNodeReference();
+            ClassNode rawType = getType(objectExpression).getPlainNodeReference();
             inferDiamondType((ConstructorCallExpression) objectExpression, rawType);
         }
         // enclosing excludes classes that skip STC
@@ -1556,11 +1555,10 @@ out:    if ((samParameterTypes.length == 1 && isOrImplements(samParameterTypes[0
         enclosingTypes.add(typeCheckingContext.getEnclosingClassNode());
         enclosingTypes.addAll(enclosingTypes.iterator().next().getOuterClasses());
 
-        boolean staticOnlyAccess = isClassClassNodeWrappingConcreteType(objectExpressionType);
-        if (staticOnlyAccess) {
+        if (objectExpression instanceof ClassExpression) {
             if (propertyName.equals("this")) {
                 // handle "Outer.this" for any level of nesting
-                ClassNode outer = objectExpressionType.getGenericsTypes()[0].getType();
+                ClassNode outer = getType(objectExpression).getGenericsTypes()[0].getType();
 
                 ClassNode found = null;
                 for (ClassNode enclosingType : enclosingTypes) {
@@ -1576,9 +1574,9 @@ out:    if ((samParameterTypes.length == 1 && isOrImplements(samParameterTypes[0
             } else if (propertyName.equals("super")) {
                 // GROOVY-8299: handle "Iface.super" for interface default methods
                 ClassNode enclosingType = typeCheckingContext.getEnclosingClassNode();
-                ClassNode accessor = objectExpressionType.getGenericsTypes()[0].getType();
-                if (accessor.isInterface() && enclosingType.implementsInterface(accessor)) {
-                    storeType(pexp, accessor);
+                ClassNode accessingType = getType(objectExpression).getGenericsTypes()[0].getType();
+                if (accessingType.isInterface() && enclosingType.implementsInterface(accessingType)) {
+                    storeType(pexp, accessingType);
                     return true;
                 }
                 return false;
@@ -1609,9 +1607,8 @@ out:    if ((samParameterTypes.length == 1 && isOrImplements(samParameterTypes[0
             }
 
             // in case of a lookup on java.lang.Class, look for instance methods on Class
-            // as well; in case of static property access Class<Type> and Type are listed
-            boolean staticOnly = isClassClassNodeWrappingConcreteType(receiverType) ? false
-                                   : (receiver.getData() == null ? staticOnlyAccess : false);
+            // in case of static property access, Type (static) and Class<Type> are tried
+            boolean staticOnly = !receiver.isObject();
 
             List<MethodNode> setters = new ArrayList<>(4);
             for (MethodNode method : findMethodsWithGenerated(wrapTypeIfNecessary(receiverType), setterName)) {
@@ -1743,7 +1740,7 @@ out:    if ((samParameterTypes.length == 1 && isOrImplements(samParameterTypes[0
                 for (MethodNode method : findDGMMethodsForClassNode(loader, dgmReceiver, isserName)) {
                     if (isPrimitiveBoolean(method.getReturnType())) methods.add(method);
                 }
-                if (staticOnlyAccess && receiver.getData() == null && !isClassType(receiver.getType())) {
+                if (!receiver.isObject()) {
                     // GROOVY-10820: ensure static extension when property accessed in static manner
                     methods.removeIf(method -> !((ExtensionMethodNode) method).isStaticExtension());
                 }
@@ -1794,8 +1791,8 @@ out:    if ((samParameterTypes.length == 1 && isOrImplements(samParameterTypes[0
             }
         }
 
-        if (pexp.isImplicitThis() || !staticOnlyAccess) {
-            for (Receiver<String> receiver : receivers) {
+        for (Receiver<String> receiver : receivers) {
+            if (receiver.isObject()) {
                 ClassNode receiverType = receiver.getType();
                 ClassNode propertyType = getTypeForMapPropertyExpression(receiverType, pexp);
                 if (propertyType == null)
@@ -1818,7 +1815,7 @@ out:    if ((samParameterTypes.length == 1 && isOrImplements(samParameterTypes[0
 
         if (pexp.isImplicitThis() && isThisExpression(objectExpression)) {
             Iterator<ClassNode> iter = enclosingTypes.iterator(); // first enclosing is "this" type
-            boolean staticOnly = Modifier.isStatic(iter.next().getModifiers()) || staticOnlyAccess;
+            boolean staticOnly = Modifier.isStatic(iter.next().getModifiers()) || typeCheckingContext.isInStaticContext;
             while (iter.hasNext()) {
                 ClassNode outer = iter.next();
                 // GROOVY-7994, GROOVY-11198: try "this.propertyName" as "Outer.propertyName" or "Outer.this.propertyName"
@@ -3585,8 +3582,8 @@ out:    if ((samParameterTypes.length == 1 && isOrImplements(samParameterTypes[0
     }
 
     private static void addDelegateReceiver(final List<Receiver<String>> receivers, final ClassNode delegate, final String path) {
-        if (isClassClassNodeWrappingConcreteType(delegate)) { // add Type from Class<Type>
-            addDelegateReceiver(receivers, delegate.getGenericsTypes()[0].getType(), path);
+        if (isClassClassNodeWrappingConcreteType(delegate)) { // GROOVY-11393: Type from Class<Type>
+            receivers.add(new Receiver<>(delegate.getGenericsTypes()[0].getType(), false, path));
         }
         if (receivers.stream().map(Receiver::getType).noneMatch(delegate::equals)) {
             receivers.add(new Receiver<>(delegate, path));
@@ -3735,23 +3732,20 @@ out:    if ((samParameterTypes.length == 1 && isOrImplements(samParameterTypes[0
                     for (Receiver<String> currentReceiver : receivers) {
                         mn = findMethod(currentReceiver.getType().getPlainNodeReference(), name, args);
                         if (!mn.isEmpty()) {
-                            first = mn.get(0); // capture for error string
-                            // for "this" in a static context, only static methods are compatible
-                            if (currentReceiver.getData() == null && !isClassType(currentReceiver.getType())) {
-                                boolean staticThis = (isThisObjectExpression || call.isImplicitThis()) && typeCheckingContext.isInStaticContext;
-                                boolean staticThat = isClassClassNodeWrappingConcreteType(receiver); // GROOVY-10819, GROOVY-10820
-                                mn = allowStaticAccessToMember(mn, staticThis || staticThat);
-                            }
-                        }
-                        if (!mn.isEmpty()) {
+                            first = mn.get(0); // capture for error reporting
                             chosenReceiver = currentReceiver;
-                            break;
+                            // GROOVY-10819, GROOVY-10820, GROOVY-11393, et al.:
+                            // for a static receiver, only static methods are compatible
+                            mn = allowStaticAccessToMember(mn, !currentReceiver.isObject());
+                            if (!mn.isEmpty()) {
+                                break;
+                            }
                         }
                     }
                     if (mn.isEmpty()) {
                         mn = extension.handleMissingMethod(receiver, name, argumentList, args, call);
-                        if (mn.isEmpty()) {
-                            if (first != null) mn.add(first); // non-static method error?
+                        if (mn == null || mn.isEmpty()) {
+                            if (first != null) mn = List.of(first); // instance method
                             else addNoMatchingMethodError(receiver, name, args, call);
                         }
                     }
@@ -3788,7 +3782,7 @@ out:                if (mn.size() != 1) {
                             chosenReceiver = Receiver.make(declaringClass.getPlainNodeReference());
                         }
                         if (!targetMethod.isStatic() && !(isClassType(declaringClass) || isObjectType(declaringClass)) // GROOVY-10939: Class or Object
-                                && isClassType(receiver) && chosenReceiver.getData() == null && !Boolean.TRUE.equals(call.getNodeMetaData(DYNAMIC_RESOLUTION))) {
+                                && !chosenReceiver.isObject() && !Boolean.TRUE.equals(call.getNodeMetaData(DYNAMIC_RESOLUTION))) {
                             addStaticTypeError("Non-static method " + prettyPrintTypeName(declaringClass) + "#" + targetMethod.getName() + " cannot be called from static context", call);
                         } else if ((chosenReceiver.getType().isInterface() || targetMethod.isAbstract()) && isSuperExpression(objectExpression)) { // GROOVY-8299, GROOVY-10341
                             String target = toMethodParametersString(targetMethod.getName(), extractTypesFromParameters(targetMethod.getParameters()));
@@ -3948,8 +3942,8 @@ out:                if (mn.size() != 1) {
      * Given an object expression (a message receiver expression), generate list
      * of possible types.
      *
-     * @param objectExpression the receiver expression
-     * @return the list of types the receiver may be
+     * @param objectExpression the message receiver
+     * @return types and qualifiers of the receiver
      */
     protected List<Receiver<String>> makeOwnerList(final Expression objectExpression) {
         ClassNode receiver = getType(objectExpression);
@@ -3958,23 +3952,19 @@ out:                if (mn.size() != 1) {
                 && objectExpression instanceof VariableExpression
                 && ((Variable) objectExpression).getName().equals("owner")
                 && /*isNested:*/typeCheckingContext.delegationMetadata.getParent() != null) {
-            List<Receiver<String>> enclosingClass = Collections.singletonList(
-                    Receiver.make(typeCheckingContext.getEnclosingClassNode()));
-            addReceivers(owners, enclosingClass, typeCheckingContext.delegationMetadata.getParent(), "owner.");
+            owners.add(new Receiver<>(receiver, "owner")); // if nested, Closure is the first owner
+            List<Receiver<String>> thisType = new ArrayList<>(2); // and the enclosing class is the
+            addDelegateReceiver(thisType, makeThis(), null);      // end of the closure owner chain
+            addReceivers(owners, thisType, typeCheckingContext.delegationMetadata.getParent(), "owner.");
         } else {
             List<ClassNode> temporaryTypes = getTemporaryTypesForExpression(objectExpression);
             int temporaryTypesCount = (temporaryTypes != null ? temporaryTypes.size() : 0);
             if (temporaryTypesCount > 0) { // GROOVY-8965, GROOVY-10180, GROOVY-10668
                 owners.add(Receiver.make(lowestUpperBound(temporaryTypes)));
             }
-            if (typeCheckingContext.lastImplicitItType != null
-                    && objectExpression instanceof VariableExpression
-                    && ((Variable) objectExpression).getName().equals("it")) {
-                owners.add(Receiver.make(typeCheckingContext.lastImplicitItType));
-            }
             if (isClassClassNodeWrappingConcreteType(receiver)) {
                 ClassNode staticType = receiver.getGenericsTypes()[0].getType();
-                owners.add(Receiver.make(staticType)); // Type from Class<Type>
+                owners.add(new Receiver<>(staticType, false, null)); // Type from Class<Type>
                 addTraitType(staticType, owners); // T in Class<T$Trait$Helper>
                 owners.add(Receiver.make(receiver)); // Class<Type>
             } else {
diff --git a/src/test/groovy/transform/stc/ClosuresSTCTest.groovy b/src/test/groovy/transform/stc/ClosuresSTCTest.groovy
index dd97c2b9b8..6d541f7d8f 100644
--- a/src/test/groovy/transform/stc/ClosuresSTCTest.groovy
+++ b/src/test/groovy/transform/stc/ClosuresSTCTest.groovy
@@ -320,14 +320,14 @@ class ClosuresSTCTest extends StaticTypeCheckingTestCase {
     }
 
     // GROOVY-5145
-    void testCollect() {
+    void testCollect1() {
         assertScript '''
             List<String> strings = [1,2,3].collect { it.toString() }
         '''
     }
 
     // GROOVY-5145
-    void testCollectWithSubclass() {
+    void testCollect2() {
         assertScript '''
             class StringClosure extends Closure<String> {
                 StringClosure() { super(null,null) }
@@ -337,6 +337,94 @@ class ClosuresSTCTest extends StaticTypeCheckingTestCase {
         '''
     }
 
+    void testWithIntReturnType() {
+        assertScript '''
+            class Test {
+               static int a(String s) {
+                    s.toCharArray().with {
+                        length
+                    }
+                }
+            }
+            assert Test.a( 'Daniel' ) == 6
+        '''
+    }
+
+    void testWithLongReturnType() {
+        assertScript '''
+            class Test {
+               static long a() {
+                    Long.with {
+                        MAX_VALUE
+                    }
+                }
+            }
+            assert Test.a() == Long.MAX_VALUE
+        '''
+    }
+
+    void testWithStringReturnType() {
+        assertScript '''
+            class Test {
+              static String a( String s ) {
+                s.with { String it -> it.toLowerCase() }
+              }
+            }
+            assert Test.a( 'TIM' ) == 'tim'
+        '''
+    }
+
+    // GROOVY-5907
+    void testWithGenericReturnType() {
+        assertScript '''
+            class Test {
+              static List<String> a( String s ) {
+                s.with { String it -> [ "$it".toString() ] }
+              }
+            }
+            assert Test.a( 'tim' ) == [ 'tim' ]
+        '''
+    }
+
+    void testWithNestedMemberAccess() {
+        assertScript '''
+            class Foo {
+                String foo = 'foo'
+                String foom() { 'foom' }
+            }
+            class Bar {
+                String bar = 'bar'
+                String barm() { 'barm' }
+            }
+            class Baz {
+                String baz = 'baz'
+                String bazm() { 'bazm' }
+            }
+            String other() { 'other' }
+            new Foo().with {
+                assert foo == 'foo'
+                assert foom() == 'foom'
+                assert other() == 'other'
+                new Bar().with {
+                    assert foo == 'foo'
+                    assert bar == 'bar'
+                    assert foom() == 'foom'
+                    assert barm() == 'barm'
+                    assert other() == 'other'
+                    new Baz().with {
+                        assert foo == 'foo'
+                        assert bar == 'bar'
+                        assert baz == 'baz'
+                        assert foom() == 'foom'
+                        assert barm() == 'barm'
+                        assert bazm() == 'bazm'
+                        assert other() == 'other'
+                    }
+                }
+            }
+        '''
+    }
+
     void testClosureSharedVariable1() {
         assertScript '''
             def x = '123';
@@ -825,7 +913,6 @@ class ClosuresSTCTest extends StaticTypeCheckingTestCase {
                 new B().with(block)
             }
         '''
-
         assertScript declarations + '''
             outer {
                 inner {
@@ -835,7 +922,6 @@ class ClosuresSTCTest extends StaticTypeCheckingTestCase {
                 }
             }
         '''
-
         assertScript declarations + '''
             outer {
                 inner {
@@ -858,6 +944,36 @@ class ClosuresSTCTest extends StaticTypeCheckingTestCase {
         '''
     }
 
+    // GROOVY-11393
+    void testClassClosureDelegateProperty() {
+        String foo = '''
+            class Foo {
+                static getBar() { 'bar' }
+                Object getBaz() { 'baz' }
+            }
+        '''
+        assertScript foo + '''
+            Foo.with {
+                assert name == 'Foo'
+                assert getName() == 'Foo'
+            }
+        '''
+        assertScript foo + '''
+            Foo.with {
+                assert bar == 'bar'
+                assert getBar() == 'bar'
+            }
+        '''
+        shouldFailWithMessages foo + '''
+            Foo.with {
+                print baz
+                print getBaz()
+            }
+        ''',
+        'The variable [baz] is undeclared', // TODO: instance method error
+        'Non-static method Foo#getBaz cannot be called from static context'
+    }
+
     // GROOVY-9652
     void testDelegatePropertyAndCharCompareOptimization() {
         ['String', 'Character', 'char'].each { type ->
diff --git a/src/test/groovy/transform/stc/WithSTCStandaloneTest.groovy b/src/test/groovy/transform/stc/WithSTCStandaloneTest.groovy
deleted file mode 100644
index 48cba59f4b..0000000000
--- a/src/test/groovy/transform/stc/WithSTCStandaloneTest.groovy
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one
- *  or more contributor license agreements.  See the NOTICE file
- *  distributed with this work for additional information
- *  regarding copyright ownership.  The ASF licenses this file
- *  to you under the Apache License, Version 2.0 (the
- *  "License"); you may not use this file except in compliance
- *  with the License.  You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing,
- *  software distributed under the License is distributed on an
- *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- *  KIND, either express or implied.  See the License for the
- *  specific language governing permissions and limitations
- *  under the License.
- */
-
-package groovy.transform.stc
-
-import groovy.test.GroovyTestCase
-
-/**
- * Unit tests for static type checking : with method.
- */
-class WithSTCStandaloneTest extends GroovyTestCase {
-    void testMethodAndPropertyAccessWithinNestedWithStatements() {
-        assertScript '''
-            import groovy.transform.CompileStatic
-
-            class Foo {
-                String foo = 'foo'
-                String foom() { 'foom' }
-            }
-
-            class Bar {
-                String bar = 'bar'
-                String barm() { 'barm' }
-            }
-
-            class Baz {
-                String baz = 'baz'
-                String bazm() { 'bazm' }
-            }
-
-            def other() { 'other' }
-
-            @CompileStatic
-            def main() {
-                new Foo().with {
-                    assert other() == 'other'
-                    assert foom() == 'foom'
-                    assert foo == 'foo'
-                    new Bar().with {
-                        assert foo == 'foo'
-                        assert bar == 'bar'
-                        assert barm() == 'barm'
-                        assert other() == 'other'
-                        assert foom() == 'foom'
-                        new Baz().with {
-                            assert foo == 'foo'
-                            assert bar == 'bar'
-                            assert baz == 'baz'
-                            assert barm() == 'barm'
-                            assert other() == 'other'
-                            assert foom() == 'foom'
-                            assert bazm() == 'bazm'
-                        }
-                    }
-                }
-            }
-
-            main()
-        '''
-    }
-}
diff --git a/src/test/groovy/transform/stc/WithSTCTest.groovy b/src/test/groovy/transform/stc/WithSTCTest.groovy
deleted file mode 100644
index de3c4d156d..0000000000
--- a/src/test/groovy/transform/stc/WithSTCTest.groovy
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one
- *  or more contributor license agreements.  See the NOTICE file
- *  distributed with this work for additional information
- *  regarding copyright ownership.  The ASF licenses this file
- *  to you under the Apache License, Version 2.0 (the
- *  "License"); you may not use this file except in compliance
- *  with the License.  You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing,
- *  software distributed under the License is distributed on an
- *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- *  KIND, either express or implied.  See the License for the
- *  specific language governing permissions and limitations
- *  under the License.
- */
-
-package groovy.transform.stc
-
-/**
- * Unit tests for static type checking : with method.
- */
-class WithSTCTest extends StaticTypeCheckingTestCase {
-
-    // GROOVY-5907
-    void testGenericReturnType() {
-        assertScript '''
-            class Test {
-              static List<String> a( String s ) {
-                s.with { String it -> [ "$it".toString() ] }
-              }
-            }
-
-            assert Test.a( 'tim' ) == [ 'tim' ]
-        '''
-    }
-
-    void testStringReturnType() {
-        assertScript '''
-            class Test {
-              static String a( String s ) {
-                s.with { String it -> it.toLowerCase() }
-              }
-            }
-
-            assert Test.a( 'TIM' ) == 'tim'
-        '''
-    }
-
-    void testIntReturnType() {
-        assertScript '''
-            class Test {
-               static int a(String s) {
-                    s.toCharArray().with {
-                        length
-                    }
-                }
-            }
-
-            assert Test.a( 'Daniel' ) == 6
-        '''
-    }
-
-    void testLongReturnType() {
-        assertScript '''
-            class Test {
-               static long a() {
-                    Long.with {
-                        MAX_VALUE
-                    }
-                }
-            }
-
-            assert Test.a() == Long.MAX_VALUE
-        '''
-    }
-}
-
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/WithStaticCompileTest.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/WithStaticCompileTest.groovy
deleted file mode 100644
index 1decdfb35b..0000000000
--- a/src/test/org/codehaus/groovy/classgen/asm/sc/WithStaticCompileTest.groovy
+++ /dev/null
@@ -1,29 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one
- *  or more contributor license agreements.  See the NOTICE file
- *  distributed with this work for additional information
- *  regarding copyright ownership.  The ASF licenses this file
- *  to you under the Apache License, Version 2.0 (the
- *  "License"); you may not use this file except in compliance
- *  with the License.  You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing,
- *  software distributed under the License is distributed on an
- *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- *  KIND, either express or implied.  See the License for the
- *  specific language governing permissions and limitations
- *  under the License.
- */
-package org.codehaus.groovy.classgen.asm.sc
-
-import groovy.transform.stc.WithSTCTest
-
-/**
- * Unit tests for static compilation : with method.
- */
-class WithStaticCompileTest extends WithSTCTest implements StaticCompilationTestSupport {
-
-}
-
