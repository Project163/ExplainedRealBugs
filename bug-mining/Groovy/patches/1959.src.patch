diff --git a/src/main/groovy/util/GroovyScriptEngine.java b/src/main/groovy/util/GroovyScriptEngine.java
index 39ac3a57e8..782cee36dd 100644
--- a/src/main/groovy/util/GroovyScriptEngine.java
+++ b/src/main/groovy/util/GroovyScriptEngine.java
@@ -20,6 +20,8 @@ import groovy.lang.GroovyClassLoader;
 import groovy.lang.GroovyCodeSource;
 import groovy.lang.GroovyResourceLoader;
 import groovy.lang.Script;
+
+import org.codehaus.groovy.GroovyBugError;
 import org.codehaus.groovy.ast.ClassNode;
 import org.codehaus.groovy.ast.InnerClassNode;
 import org.codehaus.groovy.classgen.GeneratorContext;
@@ -47,6 +49,7 @@ import java.net.URLConnection;
 import java.security.AccessController;
 import java.security.CodeSource;
 import java.security.PrivilegedAction;
+import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
@@ -71,6 +74,7 @@ public class GroovyScriptEngine implements ResourceConnector {
     private static class LocalData {
         CompilationUnit cu;
         StringSetMap dependencyCache = new StringSetMap();
+        Map<String,String> precompiledEntries = new HashMap();
     }
     private static WeakReference<ThreadLocal<LocalData>> localData = new WeakReference<ThreadLocal<LocalData>>(null);
     private static synchronized ThreadLocal<LocalData> getLocalData() {
@@ -144,11 +148,13 @@ public class GroovyScriptEngine implements ResourceConnector {
             LocalData local = getLocalData().get();
             local.cu = cu;
             final StringSetMap cache = local.dependencyCache;
+            final Map<String,String> precompiledEntries = local.precompiledEntries;
 
             // "." is used to transfer compilation dependencies, which will be
             // recollected later during compilation
             for (String depSourcePath : cache.get(".")) {
                 try {
+                    cache.get(depSourcePath);
                     cu.addSource(getResourceConnection(depSourcePath).getURL());
                 } catch (ResourceException e) {
                     /* ignore */
@@ -157,6 +163,7 @@ public class GroovyScriptEngine implements ResourceConnector {
 
             // remove all old entries including the "." entry
             cache.clear();
+            
             cu.addPhaseOperation(new CompilationUnit.PrimaryClassNodeOperation() {
                 @Override
                 public void call(final SourceUnit source, GeneratorContext context, ClassNode classNode)
@@ -164,7 +171,7 @@ public class GroovyScriptEngine implements ResourceConnector {
                     // GROOVY-4013: If it is an inner class, tracking its dependencies doesn't really
                     // serve any purpose and also interferes with the caching done to track dependencies
                     if (classNode instanceof InnerClassNode) return;
-                    DependencyTracker dt = new DependencyTracker(source, cache);
+                    DependencyTracker dt = new DependencyTracker(source, cache, precompiledEntries);
                     dt.visitClass(classNode);
                 }
             }, Phases.CLASS_GENERATION);
@@ -183,14 +190,15 @@ public class GroovyScriptEngine implements ResourceConnector {
                             ScriptCacheEntry entry = scriptCache.get(path);
                             Class clazz = null;
                             if (entry != null) clazz = entry.scriptClass;
-                            try {
-                                if (GroovyScriptEngine.this.isSourceNewer(entry)) {
-                                    //String encoding = conn.getContentEncoding() != null ? conn.getContentEncoding() : "UTF-8";
+                            if (GroovyScriptEngine.this.isSourceNewer(entry)) {
+                                try {
                                     SourceUnit su = compilationUnit.addSource(url);
                                     return new LookupResult(su, null);
+                                } finally {
+                                    forceClose(conn);
                                 }
-                            } finally {
-                                forceClose(conn);
+                            } else {
+                                precompiledEntries.put(origName, path);
                             }
                             if (clazz!=null) {
                                 ClassNode cn = new ClassNode(clazz);
@@ -239,17 +247,17 @@ public class GroovyScriptEngine implements ResourceConnector {
             Class answer = super.parseClass(codeSource, false);
 
             cache.makeTransitiveHull();
-            long time = System.currentTimeMillis();
+            long time = getCurrentTime();
             Set<String> entryNames = new HashSet<String>();
             for (Map.Entry<String, Set<String>> entry : cache.entrySet()) {
                 String className = entry.getKey();
                 Class clazz = getClassCacheEntry(className);
                 if (clazz == null) continue;
 
-                String entryName = getPath(clazz);
+                String entryName = getPath(clazz, localData.precompiledEntries);
                 if (entryNames.contains(entryName)) continue;
                 entryNames.add(entryName);
-                Set<String> value = convertToPaths(entry.getValue());
+                Set<String> value = convertToPaths(entry.getValue(), localData.precompiledEntries);
                 ScriptCacheEntry cacheEntry = new ScriptCacheEntry(clazz, time, time, value, false);
                 scriptCache.put(entryName, cacheEntry);
             }
@@ -257,19 +265,26 @@ public class GroovyScriptEngine implements ResourceConnector {
             localTh.set(null);
             return answer;
         }
-        private String getPath(Class clazz) {
+        private String getPath(Class clazz, Map<String,String> precompiledEntries) {
             CompilationUnit cu = getLocalData().get().cu;
             String name = clazz.getName();
             ClassNode classNode = cu.getClassNode(name);
-            return classNode.getModule().getContext().getName();
+            if (classNode == null) {
+                // this is a precompiled class!
+                String path = precompiledEntries.get(name);
+                if (path == null) throw new GroovyBugError("Precompiled class "+name+" should be available in precompiled entries map, but was not.");
+                return path;
+            } else {
+                return classNode.getModule().getContext().getName();
+            }
         }
 
-        private Set<String> convertToPaths(Set<String> orig) {
+        private Set<String> convertToPaths(Set<String> orig, Map<String,String> precompiledEntries) {
             Set<String> ret = new HashSet<String>();
             for (String className : orig) {
                 Class clazz = getClassCacheEntry(className);
                 if (clazz == null) continue;
-                ret.add(getPath(clazz));
+                ret.add(getPath(clazz, precompiledEntries));
             }
             return ret;
         }
@@ -495,7 +510,8 @@ public class GroovyScriptEngine implements ResourceConnector {
             if (isSourceNewer(entry)) {
                 try {
                     String encoding = conn.getContentEncoding() != null ? conn.getContentEncoding() : "UTF-8";
-                    clazz = groovyLoader.parseClass(IOGroovyMethods.getText(conn.getInputStream(), encoding), path);
+                    String content = IOGroovyMethods.getText(conn.getInputStream(), encoding);
+                    clazz = groovyLoader.parseClass(content, path);
                 } catch (IOException e) {
                     throw new ResourceException(e);
                 }
@@ -564,16 +580,17 @@ public class GroovyScriptEngine implements ResourceConnector {
     protected boolean isSourceNewer(ScriptCacheEntry entry) throws ResourceException {
         if (entry == null) return true;
 
+        long mainEntryLastCheck = entry.lastCheck;
         long now = 0;
 
         for (String scriptName : entry.dependencies) {
             ScriptCacheEntry depEntry = scriptCache.get(scriptName);
             if (depEntry.sourceNewer) return true;
 
-            if (now==0) {
-                now = System.currentTimeMillis();
-            }
-
+            // check if maybe dependency was recompiled, but this one here not
+            if (mainEntryLastCheck<depEntry.lastModified) return true;
+            
+            if (now==0) now = getCurrentTime();
             long nextSourceCheck = depEntry.lastCheck + config.getMinimumRecompilationInterval();
             if (nextSourceCheck > now) continue;
 
@@ -618,4 +635,8 @@ public class GroovyScriptEngine implements ResourceConnector {
         if (config == null) throw new NullPointerException("configuration cannot be null");
         this.config = config;
     }
+
+    protected long getCurrentTime() {
+        return System.currentTimeMillis();
+    }
 }
\ No newline at end of file
diff --git a/src/main/org/codehaus/groovy/tools/gse/DependencyTracker.java b/src/main/org/codehaus/groovy/tools/gse/DependencyTracker.java
index 8a1ed46d7f..857aa14510 100644
--- a/src/main/org/codehaus/groovy/tools/gse/DependencyTracker.java
+++ b/src/main/org/codehaus/groovy/tools/gse/DependencyTracker.java
@@ -15,6 +15,8 @@
  */
 package org.codehaus.groovy.tools.gse;
 
+import java.util.HashMap;
+import java.util.Map;
 import java.util.Set;
 
 import org.codehaus.groovy.ast.AnnotatedNode;
@@ -34,17 +36,31 @@ import org.codehaus.groovy.control.SourceUnit;
 
 public class DependencyTracker extends ClassCodeVisitorSupport {
     private Set<String> current;
+    private Map<String, ?> precompiledDependencies;
     private SourceUnit source;
     private StringSetMap cache;
 
     public DependencyTracker(SourceUnit source, StringSetMap cache) {
+        this(source, cache, new HashMap());
+    }
+    
+    public DependencyTracker(SourceUnit source, StringSetMap cache, Map<String, ?> precompiledEntries) {
         this.source = source;
         this.cache = cache;
+        this.precompiledDependencies = precompiledEntries;
     }
 
     private void addToCache(ClassNode node){
-        if (!node.isPrimaryClassNode()) return;
+        if (node == null) return;
+        String name = node.getName();
+        if (!precompiledDependencies.containsKey(name)  &&
+            !node.isPrimaryClassNode())
+        {
+            return;
+        }
         current.add(node.getName());
+        addToCache(node.getSuperClass());
+        addToCache(node.getInterfaces());
     }
     
     private void addToCache(ClassNode[] nodes){
@@ -57,8 +73,6 @@ public class DependencyTracker extends ClassCodeVisitorSupport {
         Set<String> old = current;
         current = cache.get(node.getName());
         addToCache(node);
-        addToCache(node.getSuperClass());
-        addToCache(node.getInterfaces());
         super.visitClass(node);
         current =  old;
     }
diff --git a/src/test/groovy/util/GroovyScriptEngineReloadingTest.groovy b/src/test/groovy/util/GroovyScriptEngineReloadingTest.groovy
index 1ff29d5e69..cc5fb1a95b 100644
--- a/src/test/groovy/util/GroovyScriptEngineReloadingTest.groovy
+++ b/src/test/groovy/util/GroovyScriptEngineReloadingTest.groovy
@@ -1,35 +1,60 @@
 package groovy.util
 
 import java.util.concurrent.ConcurrentHashMap
+import org.codehaus.groovy.control.CompilerConfiguration;
 
 /**
  *
  * @author Guillaume Laforge
  * @author David Lee
  * @author Jochen Theodorou
+ * @author Chuck Tassoni
  */
 class GroovyScriptEngineReloadingTest extends GroovyTestCase {
     GroovyScriptEngine gse;
 
     void setUp() {
         MapFileSystem.instance.registerMapFileSystem()
-        gse = new GroovyScriptEngine([MapUrlConnection.URL_SCHEME] as String[])
+        makeGSE(null);
     }
 
-    private void execute(intervall, expected) {
+   private void makeGSE(ClassLoader parent) {
+       if (parent == null) {
+           gse = new GroovyScriptEngine([MapUrlConnection.URL_SCHEME] as String[]) {
+               long time=1000;
+               protected long getCurrentTime() {
+                   return time;
+               }
+           }
+       } else {
+           gse = new GroovyScriptEngine([MapUrlConnection.URL_SCHEME] as String[], parent) {
+               long time=1000;
+               protected long getCurrentTime() {
+                   return time;
+               }
+           }
+       }
+   }
+    
+    private void sleep(int i) {
+        gse.@time += i;
+    }
+
+    private void execute(intervall, sleepTime, expected) {
         gse.config.minimumRecompilationInterval = intervall
+        sleep intervall
 
         Binding binding = new Binding()
         int val = 0
         binding.setVariable("val", val)
-        MapFileSystem.instance.modFile("s_1", "val = 1", new Date().time)
+        MapFileSystem.instance.modFile("s_1", "val = 1", gse.@time)
         gse.run("s_1", binding)
 
         assert binding.getVariable("val") == 1
 
-        sleep 1000
+        sleep sleepTime
 
-        MapFileSystem.instance.modFile("s_1", "val = 2", new Date().time)
+        MapFileSystem.instance.modFile("s_1", "val = 2", gse.@time)
         gse.run("s_1", binding)
 
         assert binding.getVariable("val") == expected
@@ -38,17 +63,19 @@ class GroovyScriptEngineReloadingTest extends GroovyTestCase {
 
     // test to ensure new source is no picked up
     void testIsSourceNewer() {
-        execute(0, 2)
+        execute(1000, 2000, 2)
+        execute(1000, 5000, 2)
+        execute(1000, 10000, 2)
     }
-
     // test to ensure new source is ignored till minimumRecompilationIntervall is passed
     void testRecompilationIntervall() {
-        execute (100000, 1)
-        execute (100000, 1)
+        execute (100000, 10000, 1)
+        execute (100000, 10000, 1)
+        execute (100000, 200000, 2)
     }
 
     public void testReloadWith2ScriptsDependentOnSameBeanAndReloadForSecond() {
-        gse.config.minimumRecompilationInterval = 0
+        gse.config.minimumRecompilationInterval = 1
         writeBean(1)
         writeScript(1)
 
@@ -57,14 +84,17 @@ class GroovyScriptEngineReloadingTest extends GroovyTestCase {
 
         writeBean(2)
         writeScript(2)
-        sleep(1000)
+        val1 = gse.run("script1.groovy", "")
+        assert val1 =='1', "script1 should have returned 1"
+
+        sleep 10000
 
         def val2 = gse.run("script2.groovy", "")
         assert val2 =='2', "script2 should have returned 2"
-    }    
+    }
 
     public void testReloadWith2ScriptsDependentOnSameBean() {
-        gse.config.minimumRecompilationInterval = 0
+        gse.config.minimumRecompilationInterval = 1
         writeBean(1)
         writeScript(1)
         writeScript(2)
@@ -76,7 +106,7 @@ class GroovyScriptEngineReloadingTest extends GroovyTestCase {
         assert val2 == '1', "script1 should have returned 1"
 
         writeBean(2)
-        sleep(1000)
+        sleep 10000
 
         def val3 = gse.run("script1.groovy", "")
         assert val3 == '2', "script1 should have returned 2 after bean was modified but returned $val3"
@@ -86,7 +116,7 @@ class GroovyScriptEngineReloadingTest extends GroovyTestCase {
     }
 
     public void testReloadWhenModifyingAllScripts() {
-        gse.config.minimumRecompilationInterval = 0
+        gse.config.minimumRecompilationInterval = 1
         writeBean(1)
         writeScript(1)
         writeScript(2)
@@ -97,17 +127,22 @@ class GroovyScriptEngineReloadingTest extends GroovyTestCase {
         def val2 = gse.run("script1.groovy", "")
         assert val2 == '1', "script1 should have returned 1"
 
-        // Modify Bean to return new value
-        writeBean(2)
         // write Scripts stay the same, timestamps updated
         writeScript(1)
         writeScript(2)
+        sleep 10000
+        
+        val1 = gse.run("script2.groovy", "")
+        assert val1 == '1', "script2 should have returned 1"
+        val2 = gse.run("script1.groovy", "")
+        assert val2 == '1', "script1 should have returned 1"
 
-        sleep(1000)
+        // Modify Bean to return new value
+        writeBean(2)
+        sleep 10000
 
         def val3 = gse.run("script1.groovy", "")
         assert val3 == '2', "script1 should have returned 2 after bean was modified but returned $val3"
-
         def val4 = gse.run("script2.groovy", "")
         assert val4 == '2', "script2 should have returned 2 after bean was modified but returned $val4"
     }
@@ -117,7 +152,7 @@ class GroovyScriptEngineReloadingTest extends GroovyTestCase {
             def b = new Bean()
             return b.getVal()
         """
-        MapFileSystem.instance.modFile("script${name}.groovy", s, new Date().time)
+        MapFileSystem.instance.modFile("script${name}.groovy", s, gse.@time)
     }
 
     public void writeBean(int d) throws IOException {
@@ -128,131 +163,341 @@ class GroovyScriptEngineReloadingTest extends GroovyTestCase {
                 def getVal(){"$d"}
             }
         """
-        MapFileSystem.instance.modFile("Bean.groovy", s, new Date().time)
+        MapFileSystem.instance.modFile("Bean.groovy", s, gse.@time)
     }
-}
-
-class MapFileEntry {
-    String content
-    long lutime
 
-    public MapFileEntry(String content, long lutime) {
-        this.content = content
-        this.lutime = lutime
+    public void testDynamicInstantiation() throws Exception {
+       MapFileSystem.instance.modFile("script.groovy",
+           """
+               def obj = dynaInstantiate.instantiate(className, getClass().getClassLoader())
+               obj.modifyWidth(dim, addThis)
+               returnedMessage = obj.message
+           """,0)
+       
+        MapFileSystem.instance.modFile("com/company/MakeMeSuper.groovy",
+          """
+              package com.company
+              import com.company.util.*
+              class MakeMeSuper{
+                 private HelperIntf helper = new Helper()
+                 def getMessage(){
+                         helper.getMessage()
+                 }
+              }
+          """,0)
+
+        MapFileSystem.instance.modFile("com/company/MakeMe.groovy",
+          """
+              package com.company
+              class MakeMe extends MakeMeSuper{
+                 def modifyWidth(dim, addThis){
+                    dim.width += addThis
+                 }
+              }
+          """,0)
+
+        MapFileSystem.instance.modFile("com/company/util/HelperIntf.groovy",
+          """
+              package com.company.util
+              interface HelperIntf{
+                 public String getMessage();
+              }
+          """,0)
+
+        MapFileSystem.instance.modFile("com/company/util/Helper.groovy",
+          """
+              package com.company.util
+              class Helper implements HelperIntf{
+                 public String getMessage(){
+                       'worked'
+                 }
+              }
+           """,0)
+
+       //Code run in the script will modify this dimension object.
+       MyDimension dim = new MyDimension();
+
+       Binding binding = new Binding();
+       binding.setVariable("dim", dim);
+       binding.setVariable("dynaInstantiate", this);
+
+       binding.setVariable("className", "com.company.MakeMe");
+
+       int addThis = 3;
+       binding.setVariable("addThis", addThis);
+
+       gse.run("script.groovy", binding);
+
+       //The script instantiated com.company.MakeMe via our own
+       //instantiate method.  The instantiated object modified the
+       //width of our Dimension object, adding the value of our
+       //'addThis' variable to it.
+       assertEquals(new MyDimension(addThis, 0), dim);
+
+       assertEquals('worked', binding.getVariable("returnedMessage"))
     }
-}
-
-@Singleton
-class MapFileSystem {
 
-    public final ConcurrentHashMap<String, MapFileEntry> fileCache = new ConcurrentHashMap<String, MapFileEntry>()
-    private boolean registered = false
-
-    void registerMapFileSystem() {
-        if (!registered) {
-            try {
+   /**
+    * The script passes the className of the class it's supposed to
+    * instantiate to this method, expecting a newly instantiated object
+    * in return.  The reason this is not done in the script is that
+    * we want to ensure that no unforeseen problems occur if
+    * the instantiation is not actually done inside the script,
+    * since real-world usages will likely require delegating that
+    * job.
+    */
+   public Object instantiate(String className, ClassLoader classLoader) {
+       Class clazz = null;
+       try {
+           clazz = Class.forName(className, true, classLoader);
+       } catch (ClassNotFoundException ex) {
+           throw new RuntimeException("Class.forName failed for  " + className, ex);
+       }
+       try {
+           return clazz.newInstance();
+       } catch (Exception ex) {
+           throw new RuntimeException("Could not instantiate object of class " + className, ex);
+       }
+   }
+
+   /**
+    * Test for GROOVY-3281, to ensure details passed through CompilerConfiguration are inherited by GSE.
+    */
+   void testCompilerConfigurationInheritance() {
+       CompilerConfiguration cc = new CompilerConfiguration();
+       cc.scriptBaseClass = CustomBaseClass.name
+
+       GroovyClassLoader cl = new GroovyClassLoader(this.class.getClassLoader(), cc)
+       makeGSE(cl);
+       
+       MapFileSystem.instance.modFile(
+           "groovyScriptEngineSampleScript.groovy",
+           'println "Hello Guillaume, is it a Groovy day?"',0)
+       def aScript = gse.createScript("groovyScriptEngineSampleScript.groovy", new Binding())
+
+       assert aScript instanceof CustomBaseClass
+   }
+
+   /** GROOVY-3893 */
+   void testGSEWithNoScriptRoots() {
+       shouldFail ResourceException, {
+           String[] emptyScriptRoots = []
+           GroovyScriptEngine gse = new GroovyScriptEngine(emptyScriptRoots)
+           gse.run("unknownScriptName", "")
+       }
+   }
+
+   /** GROOVY-4013 */
+   void testGSENoCachingOfInnerClasses() {
+       MapFileSystem.instance.modFile("Groovy4013Helper.groovy",
+           """
+               import java.awt.event.*
+               import java.awt.*
+               class Groovy4013Helper
+               {
+                  def initPanel()
+                  {
+                       def b = new Button('click me')
+                       b.addActionListener( new ActionListener(){
+                           public void actionPerformed(ActionEvent e) {}
+                       })
+                  }
+               }
+           """,0)
+
+       def klazz = gse.loadScriptByName('Groovy4013Helper.groovy')
+       assert klazz.name == 'Groovy4013Helper'
+
+       klazz = gse.loadScriptByName('Groovy4013Helper.groovy')
+       assert klazz.name == 'Groovy4013Helper' // we should still get the outer class, not inner one
+   }
+
+   /** GROOVY-4234 */
+   void testGSERunningAScriptThatHasMultipleClasses() {
+        MapFileSystem.instance.modFile("Groovy4234Helper.groovy",
+          """
+              class Foo4234 {
+                  static main(args){
+                      //println "Running Foo4234 -> main()"
+                  }
+              }
+              class Bar4234 { }
+          """,0)
+
+       //println "testGSELoadingAScriptThatHasMultipleClasses - Run 1"
+       gse.run("Groovy4234Helper.groovy", new Binding())
+
+       //println "testGSELoadingAScriptThatHasMultipleClasses - Run 2"
+       gse.run("Groovy4234Helper.groovy", new Binding())
+   }
+
+   /** GROOVY-2811 and GROOVY-4286  */
+   void testReloadingInterval() {
+       gse.config.minimumRecompilationInterval = 2000
+       def binding = new Binding([:])
+       def scriptName = "gse.groovy"
+
+       MapFileSystem.instance.modFile(scriptName, "1", 0)
+       sleep 1000
+       // first time, the script is compiled and cached
+       assert gse.run(scriptName, binding) == 1
+
+       MapFileSystem.instance.modFile(scriptName, "12", gse.@time)
+       sleep 3000
+       // the file was updated, and we waited for more than the minRecompilationInterval
+       assert gse.run(scriptName, binding) == 12
+
+       MapFileSystem.instance.modFile(scriptName, "123", gse.@time)
+       sleep 1000
+       // still the old result, as we didn't wait more than the minRecompilationInterval
+       assert gse.run(scriptName, binding) == 12
+
+       sleep 2000
+       // we've waited enough, so we get the new output
+       assert gse.run(scriptName, binding) == 123
+   }
+
+    
+    class MapFileEntry {
+        String content
+        long lutime
+    
+        public MapFileEntry(String content, long lutime) {
+            this.content = content
+            this.lutime = lutime
+        }
+    }
+    
+    @Singleton
+    class MapFileSystem {
+    
+        public final ConcurrentHashMap<String, MapFileEntry> fileCache = new ConcurrentHashMap<String, MapFileEntry>()
+        private boolean registered = false
+    
+        void registerMapFileSystem() {
+            if (!registered) {
                 URL.setURLStreamHandlerFactory(new MapUrlFactory())
                 registered = true
-            } catch (Error e) { }
+            }
         }
-    }
-
-    void modFile(String name, String content, long lutime) {
-        if (fileCache.containsKey(name)) {
-            MapFileEntry sce = fileCache.get(name)
-            sce.content = content
-            sce.lutime = lutime
-        } else {
-            fileCache.put(name, new MapFileEntry(content, lutime))
+    
+        void modFile(String name, String content, long lutime) {
+            if (fileCache.containsKey(name)) {
+                MapFileEntry sce = fileCache.get(name)
+                sce.content = content
+                sce.lutime = lutime
+            } else {
+                fileCache.put(name, new MapFileEntry(content, lutime))
+            }
+        }
+    
+        String getFilesrc(String name) {
+            return fileCache.get(name).content
+        }
+    
+        boolean fileExists(String name) {
+            return fileCache.containsKey(name)
         }
     }
-
-    String getFilesrc(String name) {
-        return fileCache.get(name).content
-    }
-
-    boolean fileExists(String name) {
-        return fileCache.containsKey(name)
-    }
-}
-
-class MapUrlHandler extends URLStreamHandler {
-
-    MapUrlHandler() {
-        super()
-    }
-
-    protected URLConnection openConnection(URL u) throws IOException {
-        return new MapUrlConnection(u)
-    }
-
-    protected void parseURL(URL u, String spec, int start, int limit) {
-        super.parseURL(u, spec, start, limit)
-    }
-}
-
-class MapUrlConnection extends URLConnection {
-    String getContentEncoding() {
-        return CHARSET
-    }
-
-    Object getContent() throws IOException {
-        return super.content
+    
+    class MapUrlHandler extends URLStreamHandler {
+    
+        MapUrlHandler() {
+            super()
+        }
+    
+        protected URLConnection openConnection(URL u) throws IOException {
+            return new MapUrlConnection(u)
+        }
+    
+        protected void parseURL(URL u, String spec, int start, int limit) {
+            super.parseURL(u, spec, start, limit)
+        }
     }
-
-    public static final String CHARSET = "UTF-8"
-    public static final String URL_HOST = "local"
-    public static final String URL_SCHEME = "map://" + URL_HOST + "/"
-
-    public static final String PROTOCOL = "map"
-
-    private String name
-
-    InputStream getInputStream() throws IOException {
-        // System.out.println(name+"\t"+MapFileSystem.fileCache.get(name).content);
-        if (MapFileSystem.instance.fileCache.containsKey(name)) {
-            String content = MapFileSystem.instance.fileCache.get(name).content
-            return new ByteArrayInputStream(content.getBytes(CHARSET))
-        } else {
-            throw new IOException("file not found" + name)
+    
+    class MapUrlConnection extends URLConnection {
+        String getContentEncoding() {
+            return CHARSET
+        }
+    
+        Object getContent() throws IOException {
+            return super.content
         }
+    
+        public static final String CHARSET = "UTF-8"
+        public static final String URL_HOST = "local"
+        public static final String PROTOCOL = "map"
+        public static final String URL_SCHEME = PROTOCOL+"://" + URL_HOST + "/"
+
+        private String name
+    
+        InputStream getInputStream() throws IOException {
+            // System.out.println(name+"\t"+MapFileSystem.fileCache.get(name).content);
+            if (MapFileSystem.instance.fileCache.containsKey(name)) {
+                String content = MapFileSystem.instance.fileCache.get(name).content
+                return new ByteArrayInputStream(content.getBytes(CHARSET))
+            } else {
+                throw new IOException("file not found" + name)
+            }
+        }
+    
+        long getLastModified() {
+            long lastmodified = 0
+            if (MapFileSystem.instance.fileCache.containsKey(name)) {
+                lastmodified = MapFileSystem.instance.fileCache.get(name).lutime
+            }
+            // System.out.println(name+"\t"+lastmodified);
+            return lastmodified
+        }
+    
+        URL getURL() {
+            return super.getURL()
+        }
+    
+        MapUrlConnection(URL url) {
+            super(url)
+            name = url.getFile()
+            if (name.startsWith("/")) {
+                name = name.substring(1)
+            }
+        }
+    
+        void connect() throws IOException { }
     }
-
-    long getLastModified() {
-        long lastmodified = 0
-        if (MapFileSystem.instance.fileCache.containsKey(name)) {
-            lastmodified = MapFileSystem.instance.fileCache.get(name).lutime
+    
+    class MapUrlFactory implements URLStreamHandlerFactory {
+    
+        MapUrlFactory() {
+            super()
+        }
+    
+        URLStreamHandler createURLStreamHandler(String protocol) {
+            if (MapUrlConnection.PROTOCOL.equals(protocol)) {
+                return new MapUrlHandler()
+            } else {
+                return null
+            }
         }
-        // System.out.println(name+"\t"+lastmodified);
-        return lastmodified
     }
 
-    URL getURL() {
-        return super.getURL()
-    }
+    static class MyDimension {
+       int width
+       int height
 
-    MapUrlConnection(URL url) {
-        super(url)
-        name = url.getFile()
-        if (name.startsWith("/")) {
-            name = name.substring(1)
-        }
-    }
+       MyDimension(int x, int y) {
+           width = x
+           height = y
+       }
 
-    void connect() throws IOException { }
-}
+       MyDimension() {
+           width = 0
+           height = 0
+       }
 
-class MapUrlFactory implements URLStreamHandlerFactory {
+       boolean equals(o) { o.width == width && o.height == height }
 
-    MapUrlFactory() {
-        super()
+       int hashCode() { width + 13 * height }
     }
 
-    URLStreamHandler createURLStreamHandler(String protocol) {
-        if (MapUrlConnection.PROTOCOL.equals(protocol)) {
-            return new MapUrlHandler()
-        } else {
-            return null
-        }
-    }
+    static abstract class CustomBaseClass extends Script {}
 }
diff --git a/src/test/groovy/util/GroovyScriptEngineTest.groovy b/src/test/groovy/util/GroovyScriptEngineTest.groovy
deleted file mode 100644
index 4f1375b392..0000000000
--- a/src/test/groovy/util/GroovyScriptEngineTest.groovy
+++ /dev/null
@@ -1,301 +0,0 @@
-/*
- * Copyright 2003-2010 the original author or authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package groovy.util
-
-import org.codehaus.groovy.control.CompilerConfiguration;
-
-/**
- * @author Chuck Tassoni
- */
-class GroovyScriptEngineTest extends GroovyTestCase {
-
-    private File srcDir;
-    private File script
-    private File com
-    private File company
-    private File util
-    private File makeMeSuper
-    private File makeMe
-    private File helperIntf
-    private File helper
-    private File bug4013
-    private File bug4234
-
-    /**
-     * Here we have inheritance and delegation-- where the delegate implements an
-     * interface-- all used by a dynamically instantiated class named 'MakeMe'.
-     */
-    public void setUp() {
-        srcDir = new File(new File('./target'), 'dynamicSrcRootToBeDeleted')
-        srcDir.mkdir();
-
-        script = new File(srcDir, 'script.groovy')
-        script.delete()
-        script << """
-            def obj = dynaInstantiate.instantiate(className, getClass().getClassLoader())
-            obj.modifyWidth(dim, addThis)
-            returnedMessage = obj.message
-        """
-
-        com = new File(srcDir, 'com')
-        com.mkdir()
-        company = new File(com, 'company')
-        company.mkdir()
-
-        makeMeSuper = new File(company, "MakeMeSuper.groovy")
-        makeMeSuper.delete()
-        makeMeSuper << """
-            package com.company
-            import com.company.util.*
-            class MakeMeSuper{
-               private HelperIntf helper = new Helper()
-               def getMessage(){
-                       helper.getMessage()
-               }
-            }    
-         """
-
-        makeMe = new File(company, "MakeMe.groovy")
-        makeMe.delete()
-        makeMe << """
-            package com.company
-
-            class MakeMe extends MakeMeSuper{
-               def modifyWidth(dim, addThis){
-                  dim.width += addThis
-               }
-            }    
-         """
-
-        util = new File(company, 'util')
-        util.mkdir()
-
-        helperIntf = new File(util, "HelperIntf.groovy")
-        helperIntf.delete()
-        helperIntf << """
-            package com.company.util
-            interface HelperIntf{
-               public String getMessage();
-            }    
-         """
-
-        helper = new File(util, "Helper.groovy")
-        helper.delete()
-        helper << """
-            package com.company.util
-            class Helper implements HelperIntf{
-               public String getMessage(){
-                     'worked'
-               }
-            }    
-         """
-
-        bug4013 = new File(srcDir, "Groovy4013Helper.groovy")
-        bug4013.delete()
-        bug4013 << """
-            import java.awt.event.*
-            import java.awt.*
-            
-            class Groovy4013Helper
-            {
-               def initPanel()
-               {
-                    def b = new Button('click me')
-                    b.addActionListener( new ActionListener(){
-                        public void actionPerformed(ActionEvent e) {}
-                    })
-               }
-            }
-         """
-
-        bug4234 = new File(srcDir, "Groovy4234Helper.groovy")
-        bug4234.delete()
-        bug4234 << """
-            class Foo4234 {
-                static main(args){
-                    println "Running Foo4234 -> main()"
-                }
-            }
-            
-            class Bar4234 { }
-         """
-    }
-
-    public void tearDown() {
-        srcDir.deleteDir()
-    }
-
-    public void testDynamicInstantiation() throws Exception {
-        //Code run in the script will modify this dimension object.
-        MyDimension dim = new MyDimension();
-
-        String[] roots = new String[1]
-        roots[0] = srcDir.getAbsolutePath()
-        GroovyScriptEngine gse = new GroovyScriptEngine(roots);
-        Binding binding = new Binding();
-        binding.setVariable("dim", dim);
-        binding.setVariable("dynaInstantiate", this);
-
-        binding.setVariable("className", "com.company.MakeMe");
-
-        int addThis = 3;
-        binding.setVariable("addThis", addThis);
-
-        gse.run("script.groovy", binding);
-
-        //The script instantiated com.company.MakeMe via our own
-        //instantiate method.  The instantiated object modified the
-        //width of our Dimension object, adding the value of our
-        //'addThis' variable to it.
-        assertEquals(new MyDimension(addThis, 0), dim);
-
-        assertEquals('worked', binding.getVariable("returnedMessage"))
-    }
-
-    /**
-     * Test for GROOVY-3281, to ensure details passed through CompilerConfiguration are inherited by GSE.
-     */
-    void testCompilerConfigurationInheritance() {
-        CompilerConfiguration cc = new CompilerConfiguration();
-        cc.scriptBaseClass = CustomBaseClass.name
-
-        GroovyClassLoader cl = new GroovyClassLoader(this.class.getClassLoader(), cc)
-        GroovyScriptEngine engine = new GroovyScriptEngine("src/test/groovy/util", cl)
-        def aScript = engine.createScript("groovyScriptEngineSampleScript.groovy", new Binding())
-
-        assert aScript instanceof CustomBaseClass
-    }
-
-    /** GROOVY-3893 */
-    void testGSEWithNoScriptRoots() {
-        shouldFail ResourceException, {
-            String[] emptyScriptRoots = []
-            GroovyScriptEngine gse = new GroovyScriptEngine(emptyScriptRoots)
-            gse.run("unknownScriptName", "")
-        }
-    }
-
-    /** GROOVY-4013 */
-    void testGSENoCachingOfInnerClasses() {
-        def klazz, gse
-
-        String[] roots = new String[1]
-        roots[0] = srcDir.getAbsolutePath()
-
-        gse = new GroovyScriptEngine(roots)
-
-        klazz = gse.loadScriptByName('Groovy4013Helper.groovy')
-        assert klazz.name == 'Groovy4013Helper'
-
-        klazz = gse.loadScriptByName('Groovy4013Helper.groovy')
-        assert klazz.name == 'Groovy4013Helper' // we should still get the outer class, not inner one
-    }
-
-    /** GROOVY-4234 */
-    void testGSERunningAScriptThatHasMultipleClasses() {
-        def klazz, gse
-
-        String[] roots = new String[1]
-        roots[0] = srcDir.getAbsolutePath()
-
-        gse = new GroovyScriptEngine(roots)
-
-        println "testGSELoadingAScriptThatHasMultipleClasses - Run 1"
-        gse.run("Groovy4234Helper.groovy", new Binding())
-
-        println "testGSELoadingAScriptThatHasMultipleClasses - Run 2"
-        gse.run("Groovy4234Helper.groovy", new Binding())
-    }
-
-    /** GROOVY-2811 and GROOVY-4286  */
-    void testReloadingInterval() {
-        def f = File.createTempFile("gse", ".groovy", new File("./target"))
-        try {
-            def scriptName = f.name
-
-            def gse = new GroovyScriptEngine(f.parentFile.name)
-            gse.config.minimumRecompilationInterval = 500
-
-            def binding = new Binding([:])
-
-            f << "1"
-            sleep 200
-            // first time, the script is compiled and cached
-            assert gse.run(scriptName, binding) == 1
-
-            f << "2"
-            sleep 1000
-            // the file was updated, and we waited for more than the minRecompilationInterval
-            assert gse.run(scriptName, binding) == 12
-
-            f << "3"
-            sleep 100
-            // still the old result, as we didn't wait more than the minRecompilationInterval
-            assert gse.run(scriptName, binding) == 12
-
-            sleep 1000
-            // we've waited enough, so we get the new output
-            assert gse.run(scriptName, binding) == 123
-        } finally {
-            f.delete()
-        }
-    }
-
-    /**
-     * The script passes the className of the class it's supposed to
-     * instantiate to this method, expecting a newly instantiated object
-     * in return.  The reason this is not done in the script is that
-     * we want to ensure that no unforeseen problems occur if
-     * the instantiation is not actually done inside the script,
-     * since real-world usages will likely require delegating that
-     * job.
-     */
-    public Object instantiate(String className, ClassLoader classLoader) {
-        Class clazz = null;
-        try {
-            clazz = Class.forName(className, true, classLoader);
-        } catch (ClassNotFoundException ex) {
-            throw new RuntimeException("Class.forName failed for  " + className, ex);
-        }
-        try {
-            return clazz.newInstance();
-        } catch (Exception ex) {
-            throw new RuntimeException("Could not instantiate object of class " + className, ex);
-        }
-
-    }
-}
-
-class MyDimension {
-    int width
-    int height
-
-    MyDimension(int x, int y) {
-        width = x
-        height = y
-    }
-
-    MyDimension() {
-        width = 0
-        height = 0
-    }
-
-    boolean equals(o) { o.width == width && o.height == height }
-
-    int hashCode() { width + 13 * height }
-}
-
-abstract class CustomBaseClass extends Script {}
diff --git a/src/test/groovy/util/groovyScriptEngineSampleScript.groovy b/src/test/groovy/util/groovyScriptEngineSampleScript.groovy
deleted file mode 100644
index 9cc01db55f..0000000000
--- a/src/test/groovy/util/groovyScriptEngineSampleScript.groovy
+++ /dev/null
@@ -1 +0,0 @@
-println "Hello Guillaume, is it a Groovy day?"
\ No newline at end of file
