diff --git a/src/main/groovy/grape/GrabAnnotationTransformation.java b/src/main/groovy/grape/GrabAnnotationTransformation.java
index 022b0830fd..035d87e897 100644
--- a/src/main/groovy/grape/GrabAnnotationTransformation.java
+++ b/src/main/groovy/grape/GrabAnnotationTransformation.java
@@ -21,6 +21,7 @@ import groovy.lang.Grapes;
 import org.codehaus.groovy.ast.*;
 import org.codehaus.groovy.ast.expr.*;
 import org.codehaus.groovy.ast.stmt.ExpressionStatement;
+import org.codehaus.groovy.ast.stmt.Statement;
 import org.codehaus.groovy.control.CompilePhase;
 import org.codehaus.groovy.control.SourceUnit;
 import org.codehaus.groovy.transform.ASTTransformation;
@@ -29,12 +30,8 @@ import org.codehaus.groovy.transform.GroovyASTTransformation;
 import java.util.*;
 
 /**
- * Created by IntelliJ IDEA.
- * User: Danno
- * Date: Jan 18, 2008
- * Time: 9:48:57 PM
+ * Transformation for declarative dependency management.
  */
-
 @GroovyASTTransformation(phase=CompilePhase.CONVERSION)
 public class GrabAnnotationTransformation extends ClassCodeVisitorSupport implements ASTTransformation {
     private static final String GRAB_CLASS_NAME = Grab.class.getName();
@@ -66,8 +63,8 @@ public class GrabAnnotationTransformation extends ClassCodeVisitorSupport implem
 
         allowShortGrab = true;
         allowShortGrapes = true;
-        grabAliases = new HashSet();
-        grapesAliases = new HashSet();
+        grabAliases = new HashSet<String>();
+        grapesAliases = new HashSet<String>();
         for (ImportNode im : mn.getImports()) {
             String alias = im.getAlias();
             String className = im.getClassName();
@@ -87,7 +84,7 @@ public class GrabAnnotationTransformation extends ClassCodeVisitorSupport implem
             }
         }
 
-        List<Map<String,Object>> grabMaps = new ArrayList();
+        List<Map<String,Object>> grabMaps = new ArrayList<Map<String,Object>>();
 
         for (ClassNode classNode : sourceUnit.getAST().getClasses()) {
             grabAnnotations = new ArrayList<AnnotationNode>();
@@ -130,11 +127,15 @@ public class GrabAnnotationTransformation extends ClassCodeVisitorSupport implem
             if (!grabAnnotations.isEmpty()) {
                 grabAnnotationLoop:
                 for (AnnotationNode node : grabAnnotations) {
-                    Map<String, Object> grabMap = new HashMap();
-                    for (String s : new String[]{"group", "module", "version"}) {
-                        if (node.getMember(s) == null) {
+                    Map<String, Object> grabMap = new HashMap<String, Object>();
+                    for (String s : new String[]{"group", "module", "version", "classifier"}) {
+                        Expression member = node.getMember(s);
+                        if (member == null && !s.equals("classifier")) {
                             addError("The missing attribute \"" + s + "\" is required in @" + node.getClassNode().getNameWithoutPackage() + " annotations", node);
                             continue grabAnnotationLoop;
+                        } else if (member != null && !(member instanceof ConstantExpression)) {
+                            addError("Attribute \"" + s + "\" has value " + member.getText() + " but should be an inline constant in @" + node.getClassNode().getNameWithoutPackage() + " annotations", node);
+                            continue grabAnnotationLoop;
                         }
                     }
                     grabMap.put("group", ((ConstantExpression)node.getMember("group")).getValue());
@@ -147,8 +148,7 @@ public class GrabAnnotationTransformation extends ClassCodeVisitorSupport implem
                     if ((node.getMember("initClass") == null)
                         || (node.getMember("initClass") == ConstantExpression.TRUE))
                     {
-                        List grabInitializers = new ArrayList();
-
+                        List<Statement> grabInitializers = new ArrayList<Statement>();
 
                         // add Grape.grab([group:group, module:module, version:version, classifier:classifier])
                         MapExpression me = new MapExpression();
@@ -173,7 +173,7 @@ public class GrabAnnotationTransformation extends ClassCodeVisitorSupport implem
 
         }
         if (!grabMaps.isEmpty()) {
-            Map basicArgs = new HashMap();
+            Map<String, Object> basicArgs = new HashMap<String, Object>();
             basicArgs.put("classLoader", sourceUnit.getClassLoader());
 
             try {
@@ -187,18 +187,10 @@ public class GrabAnnotationTransformation extends ClassCodeVisitorSupport implem
         }
     }
 
-    protected void visitConstructorOrMethod(MethodNode node, boolean isConstructor) {
-        super.visitConstructorOrMethod(node, isConstructor);
-
-        // this should be pushed into the super class...
-        for (Parameter param : node.getParameters()) {
-            visitAnnotations(param);
-        }
-    }
-
     /**
-     * Adds the annotation to the internal target list if a match is found
-     * @param node
+     * Adds the annotation to the internal target list if a match is found.
+     *
+     * @param node the AST node we are processing
      */
     public void visitAnnotations(AnnotatedNode node) {
         super.visitAnnotations(node);
diff --git a/src/main/groovy/grape/Grape.java b/src/main/groovy/grape/Grape.java
index 8a3ab3e41d..1c597337a2 100644
--- a/src/main/groovy/grape/Grape.java
+++ b/src/main/groovy/grape/Grape.java
@@ -21,9 +21,7 @@ import java.util.Map;
 import java.net.URI;
 
 /**
- * User: Danno.Ferrin
- * Date: Sep 30, 2008
- * Time: 9:36:46 PM
+ * Facade to GrapeEngine.
  */
 public class Grape {
 
@@ -123,24 +121,24 @@ public class Grape {
         }
     }
 
-    public static void grab(Map dependency) {
+    public static void grab(Map<String, Object> dependency) {
         if (enableGrapes) {
             GrapeEngine instance = getInstance();
             if (instance != null) {
                 if (!dependency.containsKey("autoDownload")) {
-                    dependency.put("autoDownload" , Boolean.valueOf(enableAutoDownload));
+                    dependency.put("autoDownload" , enableAutoDownload);
                 }
                 instance.grab(dependency);
             }
         }
     }
 
-    public static void grab(Map args, Map... dependencies) {
+    public static void grab(Map<String, Object> args, Map... dependencies) {
         if (enableGrapes) {
             GrapeEngine instance = getInstance();
             if (instance != null) {
                 if (!args.containsKey("autoDownload")) {
-                    args.put("autoDownload" , Boolean.valueOf(enableAutoDownload));
+                    args.put("autoDownload" , enableAutoDownload);
                 }
                 instance.grab(args, dependencies);
             }
@@ -162,13 +160,13 @@ public class Grape {
         }
     }
 
-    public static URI[] resolve(Map args, Map... dependencies) {
+    public static URI[] resolve(Map<String, Object> args, Map... dependencies) {
         URI[] uris = null;
         if (enableGrapes) {
             GrapeEngine instance = getInstance();
             if (instance != null) {
                 if (!args.containsKey("autoDownload")) {
-                    args.put("autoDownload" , Boolean.valueOf(enableAutoDownload));
+                    args.put("autoDownload" , enableAutoDownload);
                 }
                 uris = instance.resolve(args, dependencies);
             }
diff --git a/src/main/org/codehaus/groovy/ast/ClassCodeVisitorSupport.java b/src/main/org/codehaus/groovy/ast/ClassCodeVisitorSupport.java
index e57c496b56..100df29889 100644
--- a/src/main/org/codehaus/groovy/ast/ClassCodeVisitorSupport.java
+++ b/src/main/org/codehaus/groovy/ast/ClassCodeVisitorSupport.java
@@ -69,16 +69,18 @@ public abstract class ClassCodeVisitorSupport extends CodeVisitorSupport impleme
     protected void visitConstructorOrMethod(MethodNode node, boolean isConstructor) {
         visitAnnotations(node);
         Statement code = node.getCode();
-        
         visitClassCodeContainer(code);
+        for (Parameter param : node.getParameters()) {
+            visitAnnotations(param);
+        }
     }
     
     public void visitConstructor(ConstructorNode node) {
-        visitConstructorOrMethod(node,true);        
+        visitConstructorOrMethod(node, true);
     }
 
     public void visitMethod(MethodNode node) {
-        visitConstructorOrMethod(node,false);
+        visitConstructorOrMethod(node, false);
     }
 
     public void visitField(FieldNode node) {
diff --git a/src/main/org/codehaus/groovy/ast/FieldNode.java b/src/main/org/codehaus/groovy/ast/FieldNode.java
index 460dfb7655..c85c4468d2 100644
--- a/src/main/org/codehaus/groovy/ast/FieldNode.java
+++ b/src/main/org/codehaus/groovy/ast/FieldNode.java
@@ -101,6 +101,20 @@ public class FieldNode extends AnnotatedNode implements Opcodes, Variable {
         return (modifiers & ACC_STATIC) != 0;
     }
 
+    /**
+     * @return true if the field is an enum
+     */
+    public boolean isEnum() {
+        return (modifiers & ACC_ENUM) != 0;
+    }
+
+    /**
+     * @return true if the field is final
+     */
+    public boolean isFinal() {
+        return (modifiers & ACC_FINAL) != 0;
+    }
+
     /**
      * @return true if the field is public
      */
diff --git a/src/main/org/codehaus/groovy/classgen/AnnotationVisitor.java b/src/main/org/codehaus/groovy/classgen/AnnotationVisitor.java
index f5e70449a9..b51c5f0102 100644
--- a/src/main/org/codehaus/groovy/classgen/AnnotationVisitor.java
+++ b/src/main/org/codehaus/groovy/classgen/AnnotationVisitor.java
@@ -231,6 +231,10 @@ public class AnnotationVisitor {
 
     public void checkCircularReference(ClassNode searchClass, ClassNode attrType, Expression startExp) {
         if (!isValidAnnotationClass(attrType)) return;
+        if (!(startExp instanceof AnnotationConstantExpression)) {
+            addError("Found '" + startExp.getText() + "' when expecting an Annotation Constant", startExp);
+            return;
+        }
         AnnotationConstantExpression ace = (AnnotationConstantExpression) startExp;
         AnnotationNode annotationNode = (AnnotationNode) ace.getValue();
         if (annotationNode.getClassNode().equals(searchClass)) {
diff --git a/src/main/org/codehaus/groovy/control/ResolveVisitor.java b/src/main/org/codehaus/groovy/control/ResolveVisitor.java
index 50a4ad7f0e..53091ed17a 100644
--- a/src/main/org/codehaus/groovy/control/ResolveVisitor.java
+++ b/src/main/org/codehaus/groovy/control/ResolveVisitor.java
@@ -34,6 +34,7 @@ import java.net.MalformedURLException;
 import java.net.URL;
 import java.net.URLConnection;
 import java.util.*;
+import java.lang.reflect.Field;
 
 /**
  * Visitor to resolve Types and convert VariableExpression to
@@ -935,8 +936,7 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
         AnnotationNode an = (AnnotationNode) ace.getValue();
         ClassNode type = an.getClassNode();
         resolveOrFail(type, ", unable to find class for annotation", an);
-        for (Iterator iter = an.getMembers().entrySet().iterator(); iter.hasNext();) {
-            Map.Entry member = (Map.Entry) iter.next();
+        for (Map.Entry member : an.getMembers().entrySet()) {
             Expression memberValue = (Expression) member.getValue();
             member.setValue(transform(memberValue));
         }
@@ -954,17 +954,64 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
             if (an.isBuiltIn()) continue;
             ClassNode type = an.getClassNode();
             resolveOrFail(type, ",  unable to find class for annotation", an);
-            for (Iterator iter = an.getMembers().entrySet().iterator(); iter.hasNext();) {
-                Map.Entry member = (Map.Entry) iter.next();
+            for (Map.Entry member : an.getMembers().entrySet()) {
                 Expression memberValue = (Expression) member.getValue();
                 Expression newValue = transform(memberValue);
+                newValue = transformConstantAttributeExpression(newValue);
                 member.setValue(newValue);
-                if (newValue instanceof PropertyExpression) {
-                    PropertyExpression pe = (PropertyExpression) newValue;
-                    if (!(pe.getObjectExpression() instanceof ClassExpression)) {
-                        addError("unable to find class for enum",pe.getObjectExpression());
+                checkAnnotationMemberValue(newValue);
+            }
+        }
+    }
+
+    // resolve constant-looking expressions statically (do here as gets transformed away later)
+    private Expression transformConstantAttributeExpression(Expression exp) {
+        if (exp instanceof PropertyExpression) {
+            PropertyExpression pe = (PropertyExpression) exp;
+            if (pe.getObjectExpression() instanceof ClassExpression) {
+                ClassExpression ce = (ClassExpression) pe.getObjectExpression();
+                ClassNode type = ce.getType();
+                if (type.isEnum())
+                    return exp;
+
+                FieldNode fn = type.getField(pe.getPropertyAsString());
+                if (fn != null && !fn.isEnum() && fn.isStatic() && fn.isFinal()) {
+                    if (fn.getInitialValueExpression() instanceof ConstantExpression) {
+                        return fn.getInitialValueExpression();
                     }
                 }
+
+                try {
+                    if (type.isResolved()) {
+                        Field field = type.getTypeClass().getField(pe.getPropertyAsString());
+                        if (field != null) {
+                            return new ConstantExpression(field.get(null));
+                        }
+                    }
+                } catch(Exception e) {/*ignore*/}
+            }
+        } else if (exp instanceof ListExpression) {
+            ListExpression le = (ListExpression) exp;
+            ListExpression result = new ListExpression();
+            for (Expression e : le.getExpressions()) {
+                result.addExpression(transformConstantAttributeExpression(e));
+            }
+            return result;
+        }
+
+        return exp;
+    }
+
+    private void checkAnnotationMemberValue(Expression newValue) {
+        if (newValue instanceof PropertyExpression) {
+            PropertyExpression pe = (PropertyExpression) newValue;
+            if (!(pe.getObjectExpression() instanceof ClassExpression)) {
+                addError("unable to find class '" + pe.getText() + "' for annotation attribute constant", pe.getObjectExpression());
+            }
+        } else if (newValue instanceof ListExpression) {
+            ListExpression le = (ListExpression) newValue;
+            for (Expression e : le.getExpressions()) {
+                checkAnnotationMemberValue(e);
             }
         }
     }
diff --git a/src/main/org/codehaus/groovy/control/StaticImportVisitor.java b/src/main/org/codehaus/groovy/control/StaticImportVisitor.java
index b415682a26..1b5877868f 100644
--- a/src/main/org/codehaus/groovy/control/StaticImportVisitor.java
+++ b/src/main/org/codehaus/groovy/control/StaticImportVisitor.java
@@ -21,6 +21,7 @@ import org.codehaus.groovy.ast.stmt.Statement;
 import org.objectweb.asm.Opcodes;
 
 import java.util.*;
+import java.lang.reflect.Field;
 
 /**
  * Visitor to resolve constants and method calls from static Imports
@@ -39,6 +40,7 @@ public class StaticImportVisitor extends ClassCodeExpressionTransformer {
     private boolean inPropertyExpression;
     private Expression foundConstant;
     private Expression foundArgs;
+    private boolean inAnnotation;
 
     public StaticImportVisitor(CompilationUnit cu) {
         compilationUnit = cu;
@@ -56,6 +58,14 @@ public class StaticImportVisitor extends ClassCodeExpressionTransformer {
         this.currentMethod = null;
     }
 
+    @Override
+    public void visitAnnotations(AnnotatedNode node) {
+        boolean oldInAnnotation = inAnnotation;
+        inAnnotation = true;
+        super.visitAnnotations(node);
+        inAnnotation = oldInAnnotation;
+    }
+
     public Expression transform(Expression exp) {
         if (exp == null) return null;
         if (exp.getClass() == VariableExpression.class) {
@@ -80,11 +90,25 @@ public class StaticImportVisitor extends ClassCodeExpressionTransformer {
             }
             return result;
         }
-        if (exp.getClass() == ConstantExpression.class) {
+        if (exp instanceof ConstantExpression) {
             Expression result = exp.transformExpression(this);
             if (inPropertyExpression) {
                 foundConstant = result;
             }
+            if (inAnnotation && exp instanceof AnnotationConstantExpression) {
+                ConstantExpression ce = (ConstantExpression) result;
+                if (ce.getValue() instanceof AnnotationNode) {
+                    // replicate a little bit of AnnotationVisitor here
+                    // because we can't wait until later to do this
+                    AnnotationNode an = (AnnotationNode) ce.getValue();
+                    Map<String, Expression> attributes = an.getMembers();
+                    for (Map.Entry entry : attributes.entrySet()) {
+                        Expression attrExpr = transform((Expression) entry.getValue());
+                        entry.setValue(attrExpr);
+                    }
+
+                }
+            }
             return result;
         }
         return exp.transformExpression(this);
@@ -96,6 +120,9 @@ public class StaticImportVisitor extends ClassCodeExpressionTransformer {
             Expression result = findStaticFieldImportFromModule(v.getName());
             if (result != null) {
             	result.setSourcePosition(ve);
+                if (inAnnotation) {
+                    result = transformConstantAttributeExpression(result);
+                }
             	return result;
             }
             if (!inPropertyExpression || inSpecialConstructorCall) addStaticVariableError(ve);
@@ -103,6 +130,41 @@ public class StaticImportVisitor extends ClassCodeExpressionTransformer {
         return ve;
     }
 
+    // resolve constant-looking expressions statically (do here as gets transformed away later)
+    private Expression transformConstantAttributeExpression(Expression exp) {
+        if (exp instanceof PropertyExpression) {
+            PropertyExpression pe = (PropertyExpression) exp;
+            if (pe.getObjectExpression() instanceof ClassExpression) {
+                ClassExpression ce = (ClassExpression) pe.getObjectExpression();
+                ClassNode type = ce.getType();
+                if (type.isEnum()) return exp;
+                FieldNode fn = type.getField(pe.getPropertyAsString());
+                if (fn != null && !fn.isEnum() && fn.isStatic() && fn.isFinal()) {
+                    if (fn.getInitialValueExpression() instanceof ConstantExpression) {
+                        return fn.getInitialValueExpression();
+                    }
+                }
+                try {
+                    if (type.isResolved()) {
+                        Field field = type.getTypeClass().getField(pe.getPropertyAsString());
+                        if (field != null) {
+                            return new ConstantExpression(field.get(null));
+                        }
+                    }
+                } catch(Exception e) {/*ignore*/}
+            }
+        } else if (exp instanceof ListExpression) {
+            ListExpression le = (ListExpression) exp;
+            ListExpression result = new ListExpression();
+            for (Expression e : le.getExpressions()) {
+                result.addExpression(transformConstantAttributeExpression(e));
+            }
+            return result;
+        }
+
+        return exp;
+    }
+
     protected Expression transformMethodCallExpression(MethodCallExpression mce) {
         Expression args = transform(mce.getArguments());
         Expression method = transform(mce.getMethod());
diff --git a/src/test/gls/annotations/AnnotationTest.groovy b/src/test/gls/annotations/AnnotationTest.groovy
index 09ace08dc4..35a9d27cb5 100644
--- a/src/test/gls/annotations/AnnotationTest.groovy
+++ b/src/test/gls/annotations/AnnotationTest.groovy
@@ -362,6 +362,40 @@ class Foo {}
       println "testGetterCallWithSingletonAnnotation Done" 
   }
 
+    void testAttributePropertyConstants() {
+        assertScript """
+        import java.lang.annotation.*
+        import static Constants.*
+
+        @Retention(RetentionPolicy.RUNTIME)
+        @Target(ElementType.FIELD)
+        @interface Anno {
+            double value() default 0.0d
+            String[] array() default []
+        }
+
+        class Constants {
+            static final String FOO = "foo"
+            static final String BAR = "bar"
+            static final APPROX_PI = 3.14d
+        }
+
+        class ClassWithAnnotationUsingConstant {
+            @Anno(array = [Constants.FOO, BAR, groovy.inspect.Inspector.GROOVY])
+            public annotatedStrings
+
+            @Anno(Math.PI)
+            public annotatedMath1
+            @Anno(APPROX_PI)
+            public annotatedMath2
+        }
+
+        assert ClassWithAnnotationUsingConstant.getDeclaredField('annotatedStrings').annotations[0].array() == ['foo', 'bar', "GROOVY"]
+        assert ClassWithAnnotationUsingConstant.getDeclaredField('annotatedMath1').annotations[0].value() == Math.PI
+        assert ClassWithAnnotationUsingConstant.getDeclaredField('annotatedMath2').annotations[0].value() == Constants.APPROX_PI
+      """
+    }
+
     void testRuntimeRetentionAtAllLevels() {
         assertScript """
         import java.lang.annotation.*
