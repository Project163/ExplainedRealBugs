diff --git a/src/main/java/org/codehaus/groovy/ast/expr/BinaryExpression.java b/src/main/java/org/codehaus/groovy/ast/expr/BinaryExpression.java
index 785caa7a99..6935a49718 100644
--- a/src/main/java/org/codehaus/groovy/ast/expr/BinaryExpression.java
+++ b/src/main/java/org/codehaus/groovy/ast/expr/BinaryExpression.java
@@ -24,6 +24,8 @@ import org.codehaus.groovy.ast.Variable;
 import org.codehaus.groovy.syntax.Token;
 import org.codehaus.groovy.syntax.Types;
 
+import static java.util.Objects.requireNonNull;
+
 /**
  * Represents two expressions and an operation
  */
@@ -34,18 +36,13 @@ public class BinaryExpression extends Expression {
     private final Token operation;
     private boolean safe = false;
 
-    public BinaryExpression(Expression leftExpression,
-                            Token operation,
-                            Expression rightExpression) {
+    public BinaryExpression(final Expression leftExpression, final Token operation, final Expression rightExpression) {
         this.leftExpression = leftExpression;
-        this.operation = operation;
         this.rightExpression = rightExpression;
+        this.operation = requireNonNull(operation);
     }
 
-    public BinaryExpression(Expression leftExpression,
-                            Token operation,
-                            Expression rightExpression,
-                            boolean safe) {
+    public BinaryExpression(final Expression leftExpression, final Token operation, final Expression rightExpression, final boolean safe) {
         this(leftExpression, operation, rightExpression);
         this.safe = safe;
     }
diff --git a/src/main/java/org/codehaus/groovy/ast/expr/DeclarationExpression.java b/src/main/java/org/codehaus/groovy/ast/expr/DeclarationExpression.java
index 074a0b4fa0..987a7085b8 100644
--- a/src/main/java/org/codehaus/groovy/ast/expr/DeclarationExpression.java
+++ b/src/main/java/org/codehaus/groovy/ast/expr/DeclarationExpression.java
@@ -46,41 +46,44 @@ import static org.apache.groovy.ast.tools.ClassNodeUtils.formatTypeName;
 public class DeclarationExpression extends BinaryExpression {
 
     /**
-     * Creates a DeclarationExpression for VariableExpressions like "def x" or "String y = 'foo'".
+     * Creates a declaration like "def v" or "int w = 0".
+     *
      * @param left
      *      the left hand side of a variable declaration
      * @param operation
-     *      the operation, typically an assignment operator
+     *      the operation, assumed to be assignment operator
      * @param right
-     *      the right hand side of a declaration
+     *      the right hand side of a declaration; {@link EmptyExpression} for no initial value
      */
-    public DeclarationExpression(VariableExpression left, Token operation, Expression right) {
-        super(left,operation,right);
+    public DeclarationExpression(final VariableExpression left, final Token operation, final Expression right) {
+        this((Expression) left, operation, right);
     }
 
     /**
-     * Creates a DeclarationExpression for Expressions like "def (x, y) = [1, 2]"
+     * Creates a declaration like "def v" or "int w = 0" or "def (x, y) = [1, 2]".
+     *
      * @param left
-     *      the left hand side of a declaration. Must be either a VariableExpression or
-     *      a TupleExpression with at least one element.
+     *      the left hand side of a declaration -- either a {@link VariableExpression} or
+     *      a {@link TupleExpression} with at least one element
      * @param operation
-     *       the operation, typically an assignment operator
+     *       the operation, assumed to be assignment operator
      * @param right
      *       the right hand side of a declaration
      */
-    public DeclarationExpression(Expression left, Token operation, Expression right) {
-        super(left,operation,right);
+    public DeclarationExpression(final Expression left, final Token operation, final Expression right) {
+        super(left, Token.newSymbol("=", operation.getStartLine(), operation.getStartColumn()), right);
         check(left);
     }
 
-    private static void check(Expression left) {
+    private static void check(final Expression left) {
         if (left instanceof VariableExpression) {
-            //nothing
+            // all good
         } else if (left instanceof TupleExpression) {
             TupleExpression tuple = (TupleExpression) left;
-            if (tuple.getExpressions().isEmpty()) throw new GroovyBugError("one element required for left side");
+            if (tuple.getExpressions().isEmpty())
+                throw new GroovyBugError("one element required for left side");
         } else {
-            throw new GroovyBugError("illegal left expression for declaration: "+left);
+            throw new GroovyBugError("illegal left expression for declaration: " + left);
         }
     }
 
diff --git a/src/main/java/org/codehaus/groovy/syntax/Token.java b/src/main/java/org/codehaus/groovy/syntax/Token.java
index 9e029e210c..b7ceec03ee 100644
--- a/src/main/java/org/codehaus/groovy/syntax/Token.java
+++ b/src/main/java/org/codehaus/groovy/syntax/Token.java
@@ -27,47 +27,45 @@ import org.codehaus.groovy.GroovyBugError;
  * @see Types
  */
 public class Token extends CSTNode {
-    public static final Token NULL = new Token();
+
     public static final Token EOF = new Token(Types.EOF, "", -1, -1);
+    public static final Token NULL = new Token(Types.UNKNOWN, "", -1, -1);
 
-    //---------------------------------------------------------------------------
-    // TOKEN INITIALIZATION AND SUCH
+    //--------------------------------------------------------------------------
 
-    private int type = Types.UNKNOWN;  // the actual type identified by the lexer
-    private int meaning = Types.UNKNOWN;  // an interpretation applied to the token after the fact
+    /** the actual type identified by the lexer */
+    private final int type;
+    /** an interpretation applied to the token after the fact */
+    private int meaning;
 
-    private String text = "";             // the text of the token
-    private int startLine = -1;             // the source line on which the token begins
-    private int startColumn = -1;             // the source column on which the token begins
+    /** the text of the token */
+    private String text;
+    /** the source line on which the token begins */
+    private final int startLine;
+    /** the source column on which the token begins */
+    private final int startColumn;
 
     /**
      * Initializes the Token with the specified information.
      */
-    public Token(int type, String text, int startLine, int startColumn) {
+    public Token(final int type, final String text, final int startLine, final int startColumn) {
+        this.text = text;
         this.type = type;
         this.meaning = type;
-        this.text = text;
         this.startLine = startLine;
         this.startColumn = startColumn;
     }
 
-    /**
-     * Initializes the NULL Token.
-     */
-    private Token() {
-    }
-
     /**
      * Returns a copy of this Token.
      */
     public Token dup() {
         Token token = new Token(this.type, this.text, this.startLine, this.startColumn);
         token.setMeaning(this.meaning);
-
         return token;
     }
 
-    //---------------------------------------------------------------------------
+    //--------------------------------------------------------------------------
     // NODE IDENTIFICATION AND MEANING
 
     /**
@@ -85,7 +83,7 @@ public class Token extends CSTNode {
      * convenience.
      */
     @Override
-    public CSTNode setMeaning(int meaning) {
+    public CSTNode setMeaning(final int meaning) {
         this.meaning = meaning;
         return this;
     }
@@ -99,7 +97,7 @@ public class Token extends CSTNode {
         return type;
     }
 
-    //---------------------------------------------------------------------------
+    //--------------------------------------------------------------------------
     // MEMBER ACCESS
 
     /**
@@ -176,7 +174,7 @@ public class Token extends CSTNode {
         return startColumn;
     }
 
-    //---------------------------------------------------------------------------
+    //--------------------------------------------------------------------------
     // OPERATIONS
 
     /**
@@ -218,73 +216,69 @@ public class Token extends CSTNode {
         return created;
     }
 
-    //---------------------------------------------------------------------------
+    //--------------------------------------------------------------------------
     // TOKEN FACTORIES
 
     /**
      * Creates a token that represents a keyword.  Returns null if the
      * specified text isn't a keyword.
      */
-    public static Token newKeyword(String text, int startLine, int startColumn) {
-
+    public static Token newKeyword(final String text, final int startLine, final int startColumn) {
         int type = Types.lookupKeyword(text);
         if (type != Types.UNKNOWN) {
             return new Token(type, text, startLine, startColumn);
         }
-
         return null;
     }
 
     /**
      * Creates a token that represents a double-quoted string.
      */
-    public static Token newString(String text, int startLine, int startColumn) {
+    public static Token newString(final String text, final int startLine, final int startColumn) {
         return new Token(Types.STRING, text, startLine, startColumn);
     }
 
     /**
      * Creates a token that represents an identifier.
      */
-    public static Token newIdentifier(String text, int startLine, int startColumn) {
+    public static Token newIdentifier(final String text, final int startLine, final int startColumn) {
         return new Token(Types.IDENTIFIER, text, startLine, startColumn);
     }
 
     /**
      * Creates a token that represents an integer.
      */
-    public static Token newInteger(String text, int startLine, int startColumn) {
+    public static Token newInteger(final String text, final int startLine, final int startColumn) {
         return new Token(Types.INTEGER_NUMBER, text, startLine, startColumn);
     }
 
     /**
      * Creates a token that represents a decimal number.
      */
-    public static Token newDecimal(String text, int startLine, int startColumn) {
+    public static Token newDecimal(final String text, final int startLine, final int startColumn) {
         return new Token(Types.DECIMAL_NUMBER, text, startLine, startColumn);
     }
 
     /**
      * Creates a token that represents a symbol, using a library for the text.
      */
-    public static Token newSymbol(int type, int startLine, int startColumn) {
+    public static Token newSymbol(final int type, final int startLine, final int startColumn) {
         return new Token(type, Types.getText(type), startLine, startColumn);
     }
 
     /**
      * Creates a token that represents a symbol, using a library for the type.
      */
-    public static Token newSymbol(String type, int startLine, int startColumn) {
-        return new Token(Types.lookupSymbol(type), type, startLine, startColumn);
+    public static Token newSymbol(final String text, final int startLine, final int startColumn) {
+        return new Token(Types.lookupSymbol(text), text, startLine, startColumn);
     }
 
     /**
      * Creates a token with the specified meaning.
      */
-    public static Token newPlaceholder(int type) {
+    public static Token newPlaceholder(final int meaning) {
         Token token = new Token(Types.UNKNOWN, "", -1, -1);
-        token.setMeaning(type);
-
+        token.setMeaning(meaning);
         return token;
     }
-
 }
