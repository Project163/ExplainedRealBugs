diff --git a/src/main/org/codehaus/groovy/runtime/ConversionHandler.java b/src/main/org/codehaus/groovy/runtime/ConversionHandler.java
index e12ecd58b9..6791cb0932 100644
--- a/src/main/org/codehaus/groovy/runtime/ConversionHandler.java
+++ b/src/main/org/codehaus/groovy/runtime/ConversionHandler.java
@@ -17,12 +17,16 @@
 package org.codehaus.groovy.runtime;
 
 import groovy.lang.GroovyRuntimeException;
+import org.codehaus.groovy.vmplugin.VMPlugin;
+import org.codehaus.groovy.vmplugin.VMPluginFactory;
 
 import java.io.Serializable;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
 import java.lang.reflect.Proxy;
+import java.util.concurrent.ConcurrentHashMap;
 
 /**
  * This class is a general adapter to map a call to a Java interface
@@ -34,6 +38,10 @@ import java.lang.reflect.Proxy;
 public abstract class ConversionHandler implements InvocationHandler, Serializable {
     private Object delegate;
     private static final long serialVersionUID = 1162833717190835227L;
+    private ConcurrentHashMap handleCache;
+    {
+        if (VMPluginFactory.getPlugin().getVersion()>=7) handleCache = new ConcurrentHashMap();
+    }
 
     /**
      * Creates a ConversionHandler with an delegate.
@@ -58,15 +66,19 @@ public abstract class ConversionHandler implements InvocationHandler, Serializab
     /**
      * This method is a default implementation for the invoke method given in
      * InvocationHandler. Any call to a method with a declaring class that is
-     * not Object, excluding toString(), is redirected to invokeCustom.
+     * not Object, excluding toString() and default methods is redirected to invokeCustom.
+     * <p>
      * Methods like equals and hashcode are called on the class itself instead
      * of the delegate because they are considered fundamental methods that should
      * not be overwritten. The toString() method gets special treatment as it is
      * deemed to be a method that you might wish to override when called from Groovy.
-     * <p>
+     * Interface default methods from Java 8 on the other hand are considered being
+     * default implementations you don't normally want to change. So they are called
+     * directly too
+     * </p><p>
      * In many scenarios, it is better to overwrite the invokeCustom method where
      * the core Object related methods are filtered out.
-     *
+     *</p>
      * @param proxy  the proxy
      * @param method the method
      * @param args   the arguments
@@ -76,6 +88,16 @@ public abstract class ConversionHandler implements InvocationHandler, Serializab
      * @see InvocationHandler#invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])
      */
     public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
+        VMPlugin plugin = VMPluginFactory.getPlugin();
+        if (plugin.getVersion()>=7 && isDefaultMethod(method)) {
+            Object handle = handleCache.get(method);
+            if (handle == null) {
+                handle = plugin.getInvokeSpecialHandle(method, proxy);
+                handleCache.put(method, handle);
+            }
+            return plugin.invokeHandle(handle, args);
+        }
+
         if (!checkMethod(method)) {
             try {
                 return invokeCustom(proxy, method, args);
@@ -83,6 +105,7 @@ public abstract class ConversionHandler implements InvocationHandler, Serializab
                 throw ScriptBytecodeAdapter.unwrap(gre);
             }
         }
+
         try {
             return method.invoke(this, args);
         } catch (InvocationTargetException ite) {
@@ -90,6 +113,11 @@ public abstract class ConversionHandler implements InvocationHandler, Serializab
         }
     }
 
+    protected boolean isDefaultMethod(Method method) {
+        return ((method.getModifiers() & (Modifier.ABSTRACT | Modifier.PUBLIC | Modifier.STATIC)) ==
+                Modifier.PUBLIC) && method.getDeclaringClass().isInterface();
+    }
+
     protected boolean checkMethod(Method method) {
         return isCoreObjectMethod(method);
     }
diff --git a/src/main/org/codehaus/groovy/vmplugin/VMPlugin.java b/src/main/org/codehaus/groovy/vmplugin/VMPlugin.java
index 7b71da81ac..37e8dcdc87 100644
--- a/src/main/org/codehaus/groovy/vmplugin/VMPlugin.java
+++ b/src/main/org/codehaus/groovy/vmplugin/VMPlugin.java
@@ -17,6 +17,8 @@ package org.codehaus.groovy.vmplugin;
 
 import org.codehaus.groovy.ast.*;
 
+import java.lang.reflect.Method;
+
 /**
  * Interface to access VM version based actions.
  * This interface is for internal use only!
@@ -30,4 +32,28 @@ public interface VMPlugin {
     void configureAnnotation(AnnotationNode an);
     void configureClassNode(CompileUnit compileUnit, ClassNode classNode);
     void invalidateCallSites();
+    /**
+     * Returns a handle with bound receiver to invokeSpecial the given method.
+     * This method will require at least Java 7, but since the source has to compile
+     * on older Java versions as well it is not marked to return a MethodHandle and
+     * uses Object instead
+     * @return  null in case of jdk<7, otherwise a handel that takes the method call
+     *          arguments for the invokespecial call
+     */
+    Object getInvokeSpecialHandle(Method m, Object receiver);
+
+    /**
+     * Invokes a handle produced by #getInvokeSpecialdHandle
+     * @param handle the handle
+     * @param args arguments for the method call, can be empty but not null
+     * @return the result of the method call
+     */
+    Object invokeHandle(Object handle, Object[] args) throws Throwable;
+
+    /**
+     * Gives the version the plguin is made for
+     * @return 5 for jdk5, 6 for jdk6, 7 for jdk7 or higher
+     */
+    int getVersion();
+
 }
diff --git a/src/main/org/codehaus/groovy/vmplugin/v5/Java5.java b/src/main/org/codehaus/groovy/vmplugin/v5/Java5.java
index 7c8dcb2dcf..bc28d3403b 100644
--- a/src/main/org/codehaus/groovy/vmplugin/v5/Java5.java
+++ b/src/main/org/codehaus/groovy/vmplugin/v5/Java5.java
@@ -452,5 +452,20 @@ public class Java5 implements VMPlugin {
     }
 
     public void invalidateCallSites() {}
+
+    @Override
+    public Object getInvokeSpecialHandle(Method m, Object receiver){
+        throw new GroovyBugError("getInvokeSpecialHandle requires at least JDK 7");
+    }
+
+    @Override
+    public int getVersion() {
+        return 5;
+    }
+
+    @Override
+    public Object invokeHandle(Object handle, Object[] args) throws Throwable {
+        throw new GroovyBugError("invokeHandle requires at least JDK 7");
+    }
 }
 
diff --git a/src/main/org/codehaus/groovy/vmplugin/v6/Java6.java b/src/main/org/codehaus/groovy/vmplugin/v6/Java6.java
index 52fb8c8c94..3471bb23ae 100644
--- a/src/main/org/codehaus/groovy/vmplugin/v6/Java6.java
+++ b/src/main/org/codehaus/groovy/vmplugin/v6/Java6.java
@@ -23,4 +23,9 @@ import org.codehaus.groovy.vmplugin.v5.Java5;
  * @author Jochen Theodorou
  */
 public class Java6 extends Java5 {
+
+    @Override
+    public int getVersion() {
+        return 6;
+    }
 }
diff --git a/src/main/org/codehaus/groovy/vmplugin/v7/Java7.java b/src/main/org/codehaus/groovy/vmplugin/v7/Java7.java
index 21b63490d3..619c1f6df3 100644
--- a/src/main/org/codehaus/groovy/vmplugin/v7/Java7.java
+++ b/src/main/org/codehaus/groovy/vmplugin/v7/Java7.java
@@ -16,8 +16,17 @@
 
 package org.codehaus.groovy.vmplugin.v7;
 
+import org.codehaus.groovy.GroovyBugError;
 import org.codehaus.groovy.vmplugin.v6.Java6;
 
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.security.AccessController;
+import java.security.PrivilegedAction;
+
 /**
  * Java 7 based functions. Currently just a stub but you can
  * add your own methods to your own version and place it on the classpath
@@ -26,8 +35,59 @@ import org.codehaus.groovy.vmplugin.v6.Java6;
  * @author Jochen Theodorou
  */
 public class Java7 extends Java6 {
+    private final static Constructor<MethodHandles.Lookup> LOOKUP_Constructor;
+    static {
+        try {
+            LOOKUP_Constructor = MethodHandles.Lookup.class.getDeclaredConstructor(Class.class, int.class);
+        } catch (NoSuchMethodException e) {
+            throw new GroovyBugError(e);
+        }
+        if (!LOOKUP_Constructor.isAccessible()) {
+            AccessController.doPrivileged(new PrivilegedAction() {
+                @Override
+                public Object run() {
+                    LOOKUP_Constructor.setAccessible(true);
+                    return null;
+                }
+            });
+        }
+    }
+
     @Override
     public void invalidateCallSites() {
     	IndyInterface.invalidateSwitchPoints();
     }
+
+    @Override
+    public int getVersion() {
+        return 7;
+    }
+
+    @Override
+    public Object getInvokeSpecialHandle(final Method method, final Object receiver) {
+        if (!method.isAccessible()) {
+            AccessController.doPrivileged(new PrivilegedAction() {
+                @Override
+                public Object run() {
+                    method.setAccessible(true);
+                    return null;
+                }
+            });
+        }
+        Class declaringClass = method.getDeclaringClass();
+        try {
+            return LOOKUP_Constructor.
+                    newInstance(declaringClass, MethodHandles.Lookup.PRIVATE).
+                    unreflectSpecial(method, declaringClass).
+                    bindTo(receiver);
+        } catch (ReflectiveOperationException e) {
+            throw new GroovyBugError(e);
+        }
+    }
+
+    @Override
+    public Object invokeHandle(Object handle, Object[] args) throws Throwable {
+        MethodHandle mh = (MethodHandle) handle;
+        return mh.invokeWithArguments(args);
+    }
 }
diff --git a/src/test/org/codehaus/groovy/runtime/InterfaceConversionTest.groovy b/src/test/org/codehaus/groovy/runtime/InterfaceConversionTest.groovy
index 3c4dcf641c..8984dc960b 100644
--- a/src/test/org/codehaus/groovy/runtime/InterfaceConversionTest.groovy
+++ b/src/test/org/codehaus/groovy/runtime/InterfaceConversionTest.groovy
@@ -35,6 +35,20 @@ class InterfaceConversionTest extends GroovyTestCase {
         assert m2.a() == 1
         assert m2.b(null) == 2
     }
+
+    //GROOVY-7104
+    void testDefaultInterfaceMethodCallOnProxy() {
+        try {
+            // checks for Java 8
+            Class.forName("java.util.function.Consumer", false, this.class.classLoader);
+        } catch (e) {
+            return
+        }
+        Comparator c1 = {a,b -> a<=>b}
+        assert c1.compare("a","b") == -1
+        def c2 = c1.reversed()
+        assert c2.compare("a","b") == 1
+    }
 }
 
 interface InterfaceConversionTestFoo {
