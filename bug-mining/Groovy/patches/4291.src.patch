diff --git a/src/main/java/org/codehaus/groovy/classgen/AsmClassGenerator.java b/src/main/java/org/codehaus/groovy/classgen/AsmClassGenerator.java
index 44b1dd5ab3..32c9ce5b4d 100644
--- a/src/main/java/org/codehaus/groovy/classgen/AsmClassGenerator.java
+++ b/src/main/java/org/codehaus/groovy/classgen/AsmClassGenerator.java
@@ -151,8 +151,6 @@ import static org.codehaus.groovy.ast.tools.GeneralUtils.attrX;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.callX;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.classX;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.fieldX;
-import static org.codehaus.groovy.ast.tools.GeneralUtils.getGetterName;
-import static org.codehaus.groovy.ast.tools.GeneralUtils.getSetterName;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.maybeFallsThrough;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.propX;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.thisPropX;
@@ -239,8 +237,8 @@ public class AsmClassGenerator extends ClassGenerator {
     // properties
     public  static final MethodCallerMultiAdapter setProperty = MethodCallerMultiAdapter.newStatic(ScriptBytecodeAdapter.class, "setProperty", false, false);
     private static final MethodCallerMultiAdapter getProperty = MethodCallerMultiAdapter.newStatic(ScriptBytecodeAdapter.class, "getProperty", false, false);
-  //private static final MethodCallerMultiAdapter setPropertyOnSuper = MethodCallerMultiAdapter.newStatic(ScriptBytecodeAdapter.class, "setPropertyOnSuper", false, false);
-  //private static final MethodCallerMultiAdapter getPropertyOnSuper = MethodCallerMultiAdapter.newStatic(ScriptBytecodeAdapter.class, "getPropertyOnSuper", false, false);
+    private static final MethodCallerMultiAdapter setPropertyOnSuper = MethodCallerMultiAdapter.newStatic(ScriptBytecodeAdapter.class, "setPropertyOnSuper", false, false);
+    private static final MethodCallerMultiAdapter getPropertyOnSuper = MethodCallerMultiAdapter.newStatic(ScriptBytecodeAdapter.class, "getPropertyOnSuper", false, false);
     private static final MethodCallerMultiAdapter setGroovyObjectProperty = MethodCallerMultiAdapter.newStatic(ScriptBytecodeAdapter.class, "setGroovyObjectProperty", false, false);
     private static final MethodCallerMultiAdapter getGroovyObjectProperty = MethodCallerMultiAdapter.newStatic(ScriptBytecodeAdapter.class, "getGroovyObjectProperty", false, false);
 
@@ -1128,50 +1126,6 @@ public class AsmClassGenerator extends ClassGenerator {
         }
     }
 
-    private boolean tryPropertyOfSuperClass(final PropertyExpression pexp, final String propertyName) {
-        ClassNode classNode = controller.getClassNode();
-
-        if (!controller.getCompileStack().isLHS()) {
-            String methodName = getGetterName(propertyName); // TODO: "is"
-            callX(pexp.getObjectExpression(), methodName).visit(this);
-            return true;
-        }
-
-        FieldNode fieldNode = classNode.getSuperClass().getField(propertyName);
-
-        if (fieldNode == null) {
-            throw new RuntimeParserException("Failed to find field[" + propertyName + "] of " + classNode.getName() + "'s super class", pexp);
-        }
-        if (fieldNode.isFinal()) {
-            throw new RuntimeParserException("Cannot modify final field[" + propertyName + "] of " + classNode.getName() + "'s super class", pexp);
-        }
-
-        MethodNode setter = classNode.getSuperClass().getSetterMethod(getSetterName(propertyName));
-        MethodNode getter = classNode.getSuperClass().getGetterMethod(getGetterName(propertyName));
-
-        if (fieldNode.isPrivate() && (setter == null || getter == null || !setter.getDeclaringClass().equals(getter.getDeclaringClass()))) {
-            throw new RuntimeParserException("Cannot access private field[" + propertyName + "] of " + classNode.getName() + "'s super class", pexp);
-        }
-
-        OperandStack operandStack = controller.getOperandStack();
-        operandStack.doAsType(fieldNode.getType());
-
-        MethodVisitor mv = controller.getMethodVisitor();
-        mv.visitVarInsn(ALOAD, 0);
-        operandStack.push(classNode);
-
-        operandStack.swap();
-
-        String owner = BytecodeHelper.getClassInternalName(classNode.getSuperClass().getName());
-        String desc = BytecodeHelper.getTypeDescription(fieldNode.getType());
-        if (fieldNode.isPublic() || fieldNode.isProtected()) {
-            mv.visitFieldInsn(PUTFIELD, owner, propertyName, desc);
-        } else {
-            mv.visitMethodInsn(INVOKESPECIAL, owner, setter.getName(), BytecodeHelper.getMethodDescriptor(setter), false);
-        }
-        return true;
-    }
-
     private boolean checkStaticOuterField(final PropertyExpression pexp, final String propertyName) {
         for (final ClassNode outer : controller.getClassNode().getOuterClasses()) {
             FieldNode field = outer.getDeclaredField(propertyName);
@@ -1207,7 +1161,7 @@ public class AsmClassGenerator extends ClassGenerator {
     }
 
     private boolean isGroovyObject(final Expression objectExpression) {
-        if (ExpressionUtils.isThisExpression(objectExpression)) return true;
+        if (isThisOrSuper(objectExpression)) return true; //GROOVY-8693
         if (objectExpression instanceof ClassExpression) return false;
 
         ClassNode objectExpressionType = controller.getTypeChooser().resolveType(objectExpression, controller.getClassNode());
@@ -1243,10 +1197,6 @@ public class AsmClassGenerator extends ClassGenerator {
                     fieldNode = classNode.getSuperClass().getDeclaredField(name);
                     // GROOVY-4497: do not visit super class field if it is private
                     if (fieldNode != null && fieldNode.isPrivate()) fieldNode = null;
-
-                    if (fieldNode == null) {
-                        visited = tryPropertyOfSuperClass(expression, name);
-                    }
                 }
 
                 if (fieldNode != null) {
@@ -1262,9 +1212,9 @@ public class AsmClassGenerator extends ClassGenerator {
 
             MethodCallerMultiAdapter adapter;
             if (controller.getCompileStack().isLHS()) {
-                adapter = useMetaObjectProtocol ? setGroovyObjectProperty : setProperty;
+                adapter = ExpressionUtils.isSuperExpression(objectExpression) ? setPropertyOnSuper : useMetaObjectProtocol ? setGroovyObjectProperty : setProperty;
             } else {
-                adapter = useMetaObjectProtocol ? getGroovyObjectProperty : getProperty;
+                adapter = ExpressionUtils.isSuperExpression(objectExpression) ? getPropertyOnSuper : useMetaObjectProtocol ? getGroovyObjectProperty : getProperty;
             }
             visitAttributeOrProperty(expression, adapter);
         }
diff --git a/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java b/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java
index 20a5483a71..5c72843666 100644
--- a/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java
+++ b/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java
@@ -75,6 +75,10 @@ import static org.apache.groovy.ast.tools.ClassNodeUtils.samePackageName;
 import static org.apache.groovy.ast.tools.ExpressionUtils.isNullConstant;
 import static org.apache.groovy.ast.tools.ExpressionUtils.isSuperExpression;
 import static org.apache.groovy.ast.tools.ExpressionUtils.isThisOrSuper;
+import static org.codehaus.groovy.ast.ClassHelper.isGStringType;
+import static org.codehaus.groovy.ast.ClassHelper.isObjectType;
+import static org.codehaus.groovy.ast.ClassHelper.isPrimitiveVoid;
+import static org.codehaus.groovy.ast.ClassHelper.isStringType;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.args;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.callX;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.classX;
@@ -84,10 +88,6 @@ import static org.codehaus.groovy.ast.tools.GeneralUtils.nullX;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.propX;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.stmt;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.varX;
-import static org.codehaus.groovy.ast.ClassHelper.isGStringType;
-import static org.codehaus.groovy.ast.ClassHelper.isObjectType;
-import static org.codehaus.groovy.ast.ClassHelper.isPrimitiveVoid;
-import static org.codehaus.groovy.ast.ClassHelper.isStringType;
 import static org.codehaus.groovy.transform.trait.Traits.isTrait;
 import static org.objectweb.asm.Opcodes.ACONST_NULL;
 import static org.objectweb.asm.Opcodes.ALOAD;
@@ -127,12 +127,12 @@ public class StaticInvocationWriter extends InvocationWriter {
     @Override
     protected boolean makeDirectCall(final Expression origin, final Expression receiver, final Expression message, final Expression arguments, final MethodCallerMultiAdapter adapter, final boolean implicitThis, final boolean containsSpreadExpression) {
         if (origin instanceof MethodCallExpression && isSuperExpression(receiver)) {
-            ClassNode superClass = receiver.getNodeMetaData(StaticCompilationMetadataKeys.PROPERTY_OWNER);
-            if (superClass != null && !controller.getCompileStack().isLHS()) {
-                // GROOVY-7300
-                MethodCallExpression mce = (MethodCallExpression) origin;
-                MethodNode node = superClass.getDeclaredMethod(mce.getMethodAsString(), Parameter.EMPTY_ARRAY);
-                mce.setMethodTarget(node);
+            MethodCallExpression mce = (MethodCallExpression) origin;
+            if (mce.getMethodTarget() == null && !controller.getCompileStack().isLHS()) { // GROOVY-7300
+                ClassNode owner = receiver.getNodeMetaData(StaticCompilationMetadataKeys.PROPERTY_OWNER);
+                if (owner != null) {
+                    mce.setMethodTarget(owner.getDeclaredMethod(mce.getMethodAsString(), Parameter.EMPTY_ARRAY));
+                }
             }
         }
         return super.makeDirectCall(origin, receiver, message, arguments, adapter, implicitThis, containsSpreadExpression);
diff --git a/src/main/java/org/codehaus/groovy/transform/sc/transformers/StaticCompilationTransformer.java b/src/main/java/org/codehaus/groovy/transform/sc/transformers/StaticCompilationTransformer.java
index e2a5a7902e..0a8f8a7571 100644
--- a/src/main/java/org/codehaus/groovy/transform/sc/transformers/StaticCompilationTransformer.java
+++ b/src/main/java/org/codehaus/groovy/transform/sc/transformers/StaticCompilationTransformer.java
@@ -32,6 +32,7 @@ import org.codehaus.groovy.ast.expr.ConstructorCallExpression;
 import org.codehaus.groovy.ast.expr.Expression;
 import org.codehaus.groovy.ast.expr.ListExpression;
 import org.codehaus.groovy.ast.expr.MethodCallExpression;
+import org.codehaus.groovy.ast.expr.PropertyExpression;
 import org.codehaus.groovy.ast.expr.RangeExpression;
 import org.codehaus.groovy.ast.expr.StaticMethodCallExpression;
 import org.codehaus.groovy.ast.expr.VariableExpression;
@@ -41,10 +42,13 @@ import org.codehaus.groovy.control.SourceUnit;
 import org.codehaus.groovy.runtime.ScriptBytecodeAdapter;
 import org.codehaus.groovy.syntax.Types;
 import org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor;
+import org.codehaus.groovy.transform.stc.StaticTypesMarker;
 
 import java.util.Iterator;
 import java.util.Map;
 
+import static org.apache.groovy.ast.tools.ExpressionUtils.isSuperExpression;
+
 /**
  * Some expressions use symbols as aliases to method calls (&lt;&lt;, +=, ...). In static compilation,
  * if such a method call is found, we transform the original binary expression into a method
@@ -105,15 +109,9 @@ public class StaticCompilationTransformer extends ClassCodeExpressionTransformer
     }
 
     @Override
-    public Expression transform(Expression expr) {
-        if (expr instanceof StaticMethodCallExpression) {
-            return staticMethodCallExpressionTransformer.transformStaticMethodCallExpression((StaticMethodCallExpression) expr);
-        }
+    public Expression transform(final Expression expr) {
         if (expr instanceof BinaryExpression) {
-            return binaryExpressionTransformer.transformBinaryExpression((BinaryExpression)expr);
-        }
-        if (expr instanceof MethodCallExpression) {
-            return methodCallExpressionTransformer.transformMethodCallExpression((MethodCallExpression) expr);
+            return binaryExpressionTransformer.transformBinaryExpression((BinaryExpression) expr);
         }
         if (expr instanceof ClosureExpression) {
             return closureExpressionTransformer.transformClosureExpression((ClosureExpression) expr);
@@ -121,20 +119,44 @@ public class StaticCompilationTransformer extends ClassCodeExpressionTransformer
         if (expr instanceof ConstructorCallExpression) {
             return constructorCallTransformer.transformConstructorCall((ConstructorCallExpression) expr);
         }
+        if (expr instanceof MethodCallExpression) {
+            return methodCallExpressionTransformer.transformMethodCallExpression((MethodCallExpression) expr);
+        }
+        if (expr instanceof StaticMethodCallExpression) {
+            return staticMethodCallExpressionTransformer.transformStaticMethodCallExpression((StaticMethodCallExpression) expr);
+        }
         if (expr instanceof BooleanExpression) {
-            return booleanExpressionTransformer.transformBooleanExpression((BooleanExpression)expr);
+            return booleanExpressionTransformer.transformBooleanExpression((BooleanExpression) expr);
         }
         if (expr instanceof VariableExpression) {
-            return variableExpressionTransformer.transformVariableExpression((VariableExpression)expr);
+            return variableExpressionTransformer.transformVariableExpression((VariableExpression) expr);
+        }
+        if (expr instanceof PropertyExpression && isSuperExpression(((PropertyExpression) expr).getObjectExpression())) { // TODO: all obj exp
+            // TODO: delegate to propertyExpressionTransformer.transformPropertyExpression((PropertyExpression) expr);
+            MethodNode dmct = expr.getNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET);
+            // NOTE: BinaryExpressionTransformer handles the setter
+            if (dmct != null && dmct.getParameters().length == 0) {
+                PropertyExpression pe = (PropertyExpression) expr;
+
+                MethodCallExpression mce = new MethodCallExpression(transform(pe.getObjectExpression()), dmct.getName(), MethodCallExpression.NO_ARGUMENTS);
+                mce.setImplicitThis(pe.isImplicitThis());
+                mce.setSpreadSafe(pe.isSpreadSafe());
+                mce.setType(dmct.getReturnType());
+                mce.setMethodTarget(dmct);
+                mce.setSourcePosition(pe);
+                mce.copyNodeMetaData(pe);
+                mce.setSafe(pe.isSafe());
+                return mce;
+            }
         }
         if (expr instanceof RangeExpression) {
-            return rangeExpressionTransformer.transformRangeExpression(((RangeExpression)expr));
+            return rangeExpressionTransformer.transformRangeExpression(((RangeExpression) expr));
         }
         if (expr instanceof ListExpression) {
             return listExpressionTransformer.transformListExpression((ListExpression) expr);
         }
         if (expr instanceof CastExpression) {
-            return castExpressionTransformer.transformCastExpression(((CastExpression)expr));
+            return castExpressionTransformer.transformCastExpression(((CastExpression) expr));
         }
         return super.transform(expr);
     }
@@ -142,7 +164,7 @@ public class StaticCompilationTransformer extends ClassCodeExpressionTransformer
     /**
      * Called by helpers when super.transform() is needed.
      */
-    final Expression superTransform(Expression expr) {
+    final Expression superTransform(final Expression expr) {
         return super.transform(expr);
     }
 
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 5d7b4022e5..3e2a1da14d 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -3812,7 +3812,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 && directMethodCallCandidate.isStatic()
                 && directMethodCallCandidate.getDeclaringClass().isInterface()
                 && !(directMethodCallCandidate instanceof ExtensionMethodNode)) {
-            typeCheckingContext.getEnclosingClassNode().putNodeMetaData(MINIMUM_BYTECODE_VERSION, CompilerConfiguration.DEFAULT.getBytecodeVersion());
+            typeCheckingContext.getEnclosingClassNode().putNodeMetaData(MINIMUM_BYTECODE_VERSION, CompilerConfiguration.JDK8);
         }
 
         checkOrMarkPrivateAccess(call, directMethodCallCandidate);
diff --git a/src/test/groovy/PropertyTest.groovy b/src/test/groovy/PropertyTest.groovy
index 7d3119c25a..b4957a222e 100644
--- a/src/test/groovy/PropertyTest.groovy
+++ b/src/test/groovy/PropertyTest.groovy
@@ -172,6 +172,43 @@ class PropertyTest extends GroovyTestCase {
         assert c.xpropViaMethod == 'bar4foo x prop'
     }
 
+    // GROOVY-1736, GROOVY-9609
+    void testGetSuperProperties2() {
+        for (vis in ['', 'public', 'protected', '@groovy.transform.PackageScope']) {
+            assertScript """
+                abstract class A {
+                    $vis def getX() { 'A' }
+                }
+                class C extends A {
+                    def getX() { super.x + 'C' } // no stack overflow
+                    def m() {
+                        '' + x + this.x + super.x // TODO: test safe and spread
+                    }
+                }
+                String result = new C().m()
+                assert result == 'ACACA'
+            """
+        }
+    }
+
+    // GROOVY-6097
+    void testGetSuperProperties3() {
+        for (vis in ['', 'public', 'protected', '@groovy.transform.PackageScope']) {
+            assertScript """
+                abstract class A {
+                    $vis boolean isX() { true }
+                }
+                class C extends A {
+                    def m() {
+                        '' + x + this.x + super.x // hardwired to "super.getX()"
+                    }
+                }
+                String result = new C().m()
+                assert result == 'truetruetrue'
+            """
+        }
+    }
+
     void testSetSuperProperties() {
         def c = new Child()
         assert c.superField == 'bar'
diff --git a/src/test/groovy/bugs/Groovy10133.groovy b/src/test/groovy/bugs/Groovy10133.groovy
index b474b4e288..31d4ea8f3f 100644
--- a/src/test/groovy/bugs/Groovy10133.groovy
+++ b/src/test/groovy/bugs/Groovy10133.groovy
@@ -45,7 +45,7 @@ final class Groovy10133 {
                 void test2() {
                     assert x
                     assert this.x
-                    assert !super.x // GROOVY-6097
+                    assert super.x // GROOVY-6097
                 }
             }
 
@@ -109,11 +109,7 @@ final class Groovy10133 {
                 void test2() {
                     assert x
                     assert this.x
-                    try {
-                        assert super.x // GROOVY-6097
-                        assert false : 'remove catch'
-                    } catch (MissingMethodException mme) {
-                    }
+                    assert super.x // GROOVY-6097
                 }
             }
 
@@ -188,7 +184,7 @@ final class Groovy10133 {
                 void test2() {
                     assert x
                     assert this.x
-                    assert !super.x // GROOVY-6097
+                    assert super.x // GROOVY-6097
                 }
             }
 
diff --git a/src/test/groovy/bugs/Groovy6097.groovy b/src/test/groovy/bugs/Groovy6097.groovy
index 767093bf93..bbbc33a53f 100644
--- a/src/test/groovy/bugs/Groovy6097.groovy
+++ b/src/test/groovy/bugs/Groovy6097.groovy
@@ -18,16 +18,16 @@
  */
 package groovy.bugs
 
-import groovy.test.NotYetImplemented
 import groovy.transform.CompileStatic
 import org.junit.Test
 
 import static groovy.test.GroovyAssert.assertScript
+import static groovy.test.GroovyAssert.shouldFail
 
 @CompileStatic
 final class Groovy6097 {
 
-    @NotYetImplemented @Test
+    @Test
     void testSuperIsser1() {
         assertScript '''
             class A {
@@ -46,9 +46,9 @@ final class Groovy6097 {
         '''
     }
 
-    @NotYetImplemented @Test
+    @Test // GROOVY-9382, GROOVY-10133
     void testSuperIsser2() {
-        assertScript '''
+        def err = shouldFail '''
             class A {
                 Boolean isBool() { Boolean.TRUE }
             }
@@ -63,9 +63,10 @@ final class Groovy6097 {
 
             new B()
         '''
+        assert err =~ /MissingPropertyException: No such property: bool for class: B/
     }
 
-    @NotYetImplemented @Test
+    @Test
     void testSuperIsser3() {
         assertScript '''
             class A {
@@ -86,7 +87,7 @@ final class Groovy6097 {
         '''
     }
 
-    @NotYetImplemented @Test
+    @Test
     void testSuperIsser4() {
         assertScript '''
             class A {
diff --git a/src/test/groovy/bugs/Groovy8474Bug.groovy b/src/test/groovy/bugs/Groovy8474.groovy
similarity index 56%
rename from src/test/groovy/bugs/Groovy8474Bug.groovy
rename to src/test/groovy/bugs/Groovy8474.groovy
index e7c4ed7fcc..a9211085b4 100644
--- a/src/test/groovy/bugs/Groovy8474Bug.groovy
+++ b/src/test/groovy/bugs/Groovy8474.groovy
@@ -18,309 +18,296 @@
  */
 package groovy.bugs
 
-import groovy.test.GroovyTestCase
+import org.junit.Test
 
-class Groovy8474Bug extends GroovyTestCase {
+import static groovy.test.GroovyAssert.assertScript
+import static groovy.test.GroovyAssert.shouldFail
+
+final class Groovy8474 {
+
+    @Test
     void testSettingSuperProperty() {
         assertScript '''
             class T {
-              String group
+                String group
             }
-
             class S extends T {
-              S() {
-                super.group = 'Hello'
-              }
+                S() {
+                    super.group = 'Hello'
+                }
             }
-
             assert 'Hello' == new S().group
         '''
     }
 
+    @Test
     void testSettingSuperProperty2() {
         assertScript '''
             class T {
-              String group
-              String group2
-              String group3
+                String group
+                String group2
+                String group3
             }
-
             class S extends T {
-              S() {
-                super.group = 'Hello'
-                super.group2 = 'Hello2'
-                super.group3 = 'Hello3'
-              }
+                S() {
+                    super.group = 'Hello'
+                    super.group2 = 'Hello2'
+                    super.group3 = 'Hello3'
+                }
             }
-
             assert 'Hello' == new S().group
             assert 'Hello2' == new S().group2
             assert 'Hello3' == new S().group3
         '''
     }
 
+    @Test
     void testSettingSuperProperty3() {
         assertScript '''
             class K {
                 String group
             }
             class T extends K {
-
             }
             class S extends T {
-              S() {
-                super.group = 'Hello'
-              }
+                S() {
+                    super.group = 'Hello'
+                }
             }
-
             assert 'Hello' == new S().group
         '''
     }
 
+    @Test
     void testSettingSuperProperty4() {
         assertScript '''
             class K {
-              private String name
-              public String getName() {
-                name
-              }
-              public void setName(String name) {
-                this.name = name
-              }
+                private String name
+                public String getName() {
+                    name
+                }
+                public void setName(String name) {
+                    this.name = name
+                }
             }
             class T extends K {
-              String group
+                String group
             }
             class S extends T {
-              S() {
-                super.group = 'Hello'
-                super.name = 'World'
-              }
-
-              public String helloWorld() {
-                "$group, $name"
-              }
+                S() {
+                    super.group = 'Hello'
+                    super.name = 'World'
+                }
+                public String helloWorld() {
+                    "$group, $name"
+                }
             }
-
             assert 'Hello, World' == new S().helloWorld()
         '''
     }
 
+    @Test
     void testSettingSuperProperty5() {
         assertScript '''
             class T {
-              Integer group
+                Integer group
             }
-
             class S extends T {
-              S() {
-                super.group = 1
-              }
+                S() {
+                    super.group = 1
+                }
             }
-
             assert 1 == new S().group
         '''
     }
 
+    @Test
     void testSettingSuperProperty6() {
         assertScript '''
             class T {
-              Long group
+                Long group
             }
-
             class S extends T {
-              S() {
-                super.group = 1
-              }
+                S() {
+                    super.group = 1
+                }
             }
-
             assert 1 == new S().group
         '''
     }
 
+    @Test
     void testSettingSuperProperty7() {
         assertScript '''
             class T {
-              Long group
+                Long group
             }
-
             class S extends T {
-              S() {
-                super.group = Long.MAX_VALUE
-              }
+                S() {
+                    super.group = Long.MAX_VALUE
+                }
             }
-
             assert Long.MAX_VALUE == new S().group
         '''
     }
 
+    @Test
     void testSettingSuperProperty8() {
         assertScript '''
             class T {
-              int group
+                int group
             }
-
             class S extends T {
-              S() {
-                super.group = Integer.MAX_VALUE
-              }
+                S() {
+                    super.group = Integer.MAX_VALUE
+                }
             }
-
             assert Integer.MAX_VALUE == new S().group
         '''
     }
 
+    @Test
     void testSettingSuperProperty9() {
         assertScript '''
             class T {
-              long group
+                long group
             }
-
             class S extends T {
-              S() {
-                super.group = Long.MAX_VALUE
-              }
+                S() {
+                    super.group = Long.MAX_VALUE
+                }
             }
-
             assert Long.MAX_VALUE == new S().group
         '''
     }
 
+    @Test
     void testSettingSuperProperty10() {
         assertScript '''
             class T {
-              int group
+                int group
             }
-
             class S extends T {
-              S() {
-                super.group = 1
-              }
+                S() {
+                    super.group = 1
+                }
             }
-
             assert 1 == new S().group
         '''
     }
 
+    @Test
     void testSettingSuperProperty11() {
         assertScript '''
             class T {
-              long group
+                long group
             }
-
             class S extends T {
-              S() {
-                super.group = 123456789123456789
-              }
+                S() {
+                    super.group = 123456789123456789
+                }
             }
-
             assert 123456789123456789 == new S().group
         '''
     }
 
+    @Test
     void testSettingSuperProperty12() {
         assertScript '''
             class T {
-              boolean group
+                boolean group
             }
-
             class S extends T {
-              S() {
-                super.group = true
-              }
+                S() {
+                    super.group = true
+                }
             }
-
             assert true == new S().group
         '''
     }
 
+    @Test
     void testSettingSuperProtectedField() {
         assertScript '''
             class T {
-              protected String group
+                protected String group
             }
-
             class S extends T {
-              S() {
-                super.group = 'Hello'
-              }
+                S() {
+                    super.group = 'Hello'
+                }
             }
-
             assert 'Hello' == new S().group
         '''
     }
 
+    @Test
     void testSettingSuperProtectedField2() {
         assertScript '''
             class T {
-              protected String group
-              protected String group2
-              protected String group3
+                protected String group
+                protected String group2
+                protected String group3
             }
-
             class S extends T {
-              S() {
-                super.group = 'Hello'
-                super.group2 = 'Hello2'
-                super.group3 = 'Hello3'
-              }
+                S() {
+                    super.group = 'Hello'
+                    super.group2 = 'Hello2'
+                    super.group3 = 'Hello3'
+                }
             }
-
             assert 'Hello' == new S().group
             assert 'Hello2' == new S().group2
             assert 'Hello3' == new S().group3
         '''
     }
 
+    @Test
     void testSettingSuperProtectedField3() {
         assertScript '''
             class K {
                 protected String group
             }
             class T extends K {
-
             }
-
             class S extends T {
-              S() {
-                super.group = 'Hello'
-              }
+                S() {
+                    super.group = 'Hello'
+                }
             }
-
             assert 'Hello' == new S().group
         '''
     }
 
+    @Test
     void testSettingSuperPublicField() {
         assertScript '''
             class T {
-              public String group
+                public String group
             }
-
             class S extends T {
-              S() {
-                super.group = 'Hello'
-              }
+                S() {
+                    super.group = 'Hello'
+                }
             }
-
             assert 'Hello' == new S().group
         '''
     }
 
+    @Test
     void testSettingSuperPublicField2() {
         assertScript '''
             class T {
-              public String group
-              public String group2
-              public String group3
+                public String group
+                public String group2
+                public String group3
             }
-
             class S extends T {
-              S() {
-                super.group = 'Hello'
-                super.group2 = 'Hello2'
-                super.group3 = 'Hello3'
-              }
+                S() {
+                    super.group = 'Hello'
+                    super.group2 = 'Hello2'
+                    super.group3 = 'Hello3'
+                }
             }
 
             assert 'Hello' == new S().group
@@ -329,115 +316,107 @@ class Groovy8474Bug extends GroovyTestCase {
         '''
     }
 
+    @Test
     void testSettingSuperPublicField3() {
         assertScript '''
             class K {
                 public String group
             }
             class T extends K {
-
             }
-
             class S extends T {
-              S() {
-                super.group = 'Hello'
-              }
+                S() {
+                    super.group = 'Hello'
+                }
             }
-
             assert 'Hello' == new S().group
         '''
     }
 
+    @Test
     void testSettingSuperPrivateProperty() {
-        def errMsg = shouldFail '''
+        def err = shouldFail '''
             class T {
-              private String group
+                private String group
             }
-
             class S extends T {
-              S() {
-                super.group = 'Hello'
-              }
+                S() {
+                    super.group = 'Hello'
+                }
             }
         '''
-        assert errMsg.contains('Cannot access private field')
+        //assert err =~ 'Cannot access private field'
     }
 
+    @Test
     void testSettingSuperPrivateProperty2() {
-        def errMsg = shouldFail '''
+        def err = shouldFail '''
             class T {
-              private String group
-
-              public String getGroup() {
-                return group
-              }
+                private String group
+                public String getGroup() {
+                    return group
+                }
             }
-
             class S extends T {
-              S() {
-                super.group = 'Hello'
-              }
+                S() {
+                    super.group = 'Hello'
+                }
             }
         '''
-
-        assert errMsg.contains('Cannot access private field')
+        //assert err =~ 'Cannot access private field'
     }
 
+    @Test
     void testSettingSuperPrivateProperty3() {
-        def errMsg = shouldFail '''
+        def err = shouldFail '''
             class T {
-              private String group
-
-              public void setGroup(String group) {
-                this.group = group
-              }
+                private String group
+                public void setGroup(String group) {
+                    this.group = group
+                }
             }
-
             class S extends T {
-              S() {
-                super.group = 'Hello'
-              }
+                S() {
+                    super.group = 'Hello'
+                }
             }
         '''
-
-        assert errMsg.contains('Cannot access private field')
+        //assert err =~ 'Cannot access private field'
     }
 
+    @Test
     void testSettingSuperPrivateProperty4() {
-        def errMsg = shouldFail '''
+        def err = shouldFail '''
             class K {
-              private String group
-
-              public void setGroup(String group) {
-                this.group = group
-              }
+                private String group
+                public void setGroup(String group) {
+                    this.group = group
+                }
             }
             class T extends K {
-              public String getGroup() {
-                return group
-              }
+                public String getGroup() {
+                    return group
+                }
             }
-
             class S extends T {
-              S() {
-                super.group = 'Hello'
-              }
+                S() {
+                    super.group = 'Hello'
+                }
             }
         '''
-
-        assert errMsg.contains('Cannot access private field')
+        //assert err =~ 'Cannot access private field'
     }
 
+    @Test
     void testSettingSuperFinalProperty() {
-        shouldFail '''
+        def err = shouldFail '''
             class T {
-              protected final String group = 'Hi'
+                protected final String group = 'Hi'
             }
-
             class S extends T {
-              S() {
-                super.group = 'Hello'
-              }
+                S() {
+                    super.group = 'Hello'
+                }
             }
         '''
     }
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7300.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7300.groovy
index 58908dd36e..ba2f4a5a9a 100644
--- a/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7300.groovy
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7300.groovy
@@ -33,7 +33,7 @@ final class Groovy7300 extends StaticTypeCheckingTestCase implements StaticCompi
                 @Override
                 def getX() { super.x }
             }
-            assert new B().getX() == 1 // TODO: Why use A#x and not A#getX?
+            assert new B().getX() == 2
         '''
     }
 
