diff --git a/src/main/groovy/lang/Closure.java b/src/main/groovy/lang/Closure.java
index 595acae5f8..43c7e4915c 100644
--- a/src/main/groovy/lang/Closure.java
+++ b/src/main/groovy/lang/Closure.java
@@ -88,21 +88,29 @@ public abstract class Closure extends GroovyObjectSupport implements Cloneable,
 
         Class closureClass = this.getClass();
 
+        Method tmpCallMethod = null;
+
         while (true) {
             final Method methods[] = closureClass.getDeclaredMethods();
 
-            int i = 0;
-
-            while (!methods[i].getName().equals("doCall") && ++i != methods.length) ;
+            int tmpCounter = -1;
+            for (int i = 0; i < methods.length; i++) {
+                 if ("doCall".equals(methods[i].getName()) && methods[i].getParameterTypes().length > tmpCounter) {
+                     tmpCallMethod = methods[i];
+                     tmpCounter = methods[i].getParameterTypes().length;
+                }
+            }
 
-            if (i < methods.length) {
-                this.doCallMethod = methods[i];
+            if (tmpCallMethod != null)
                 break;
-            }
 
             closureClass = closureClass.getSuperclass();
         }
 
+        this.doCallMethod = tmpCallMethod;
+        this.parameterTypes = this.doCallMethod.getParameterTypes();
+        this.numberOfParameters = this.parameterTypes.length;
+
         AccessController.doPrivileged(new PrivilegedAction() {
             public Object run() {
                 Closure.this.doCallMethod.setAccessible(true);
@@ -110,11 +118,7 @@ public abstract class Closure extends GroovyObjectSupport implements Cloneable,
             }
         });
 
-        this.parameterTypes = this.doCallMethod.getParameterTypes();
-
-        this.numberOfParameters = this.parameterTypes.length;
-
-        if (this.numberOfParameters != 0) {
+        if (this.numberOfParameters > 0) {
             this.supportsVarargs = this.parameterTypes[this.numberOfParameters - 1].equals(Object[].class);
         } else {
             this.supportsVarargs = false;
@@ -123,8 +127,24 @@ public abstract class Closure extends GroovyObjectSupport implements Cloneable,
 
     public Object invokeMethod(String method, Object arguments) {
         if ("doCall".equals(method) || "call".equals(method)) {
-            return call(arguments);
+            if (arguments == null) {
+                return call(arguments);
+            }
+            else {
+                 if (arguments instanceof Object[]) {
+                    if (((Object[])arguments).length <= 1)
+                          return call(arguments);
+                    else
+                         if (((Object[])arguments)[0] instanceof Object[])
+                             return callViaReflection((Object[]) ((Object[])arguments)[0]);
+                         else
+                             return callViaReflection((Object[]) arguments);
+                }
+                else
+                    return call(arguments);
+            }
         } else if ("curry".equals(method)) {
+                        System.out.println("Loop 2:");
             return curry((Object[]) arguments);
         } else {
             try {
@@ -296,6 +316,76 @@ public abstract class Closure extends GroovyObjectSupport implements Cloneable,
         }
     }
 
+    /**
+     * Invokes the closure, returning any value if applicable.
+     *
+     * @param arguments could be a single value or a List of values
+     * @return the value if applicable or null if there is no return statement in the closure
+     */
+    protected Object callWithArray(final Object[]args) {
+        final Object params[];
+
+        System.out.println("callWithArray([] args= " + args);
+        System.out.println("args.length = " + args.length);
+
+        if (this.curriedParams.length != 0) {
+            params = new Object[this.curriedParams.length + args.length];
+            System.arraycopy(this.curriedParams, 0, params, 0, this.curriedParams.length);
+            System.arraycopy(args, 0, params, this.curriedParams.length, args.length);
+        } else {
+            /// params = new Object[args.length];
+            /// System.arraycopy(args, 0, params, 0, args.length);
+            params = args;
+        }
+
+        final int lastParam = this.numberOfParameters - 1;
+        System.out.println("[Step 1] params.length = " + params.length + ", lastParam = " + lastParam);
+        System.out.println("         this.supportsVarargs = " + this.supportsVarargs);
+
+        if (this.supportsVarargs && !(this.numberOfParameters == params.length && (params[lastParam] == null || params[lastParam].getClass() == Object[].class))) {
+            final Object actualParameters[] = new Object[this.numberOfParameters];
+
+            //
+            // We have a closure which supports variable arguments and we haven't got actual
+            // parameters which have exactly the right number of parameters and ends with a null or an Object[]
+            //
+           System.out.println("[Step 2] params.length = " + params.length + ", lastParam = " + lastParam);
+            if (params.length < lastParam) {
+                //
+                // Not enough parameters throw exception
+                //
+                // Note we allow there to be one fewer actual parameter than the number of formal parameters
+                // in this case we pass an zero length Object[] as the last parameter
+                //
+                throw new IncorrectClosureArgumentsException(this, params, this.parameterTypes);
+            } else {
+                final Object rest[] = new Object[params.length - lastParam];	 // array used to pass the rest of the paraters
+
+                // fill the parameter array up to but not including the last one
+                System.arraycopy(params, 0, actualParameters, 0, lastParam);
+
+                // put the rest of the parameters in the overflow araay
+                System.arraycopy(params, lastParam, rest, 0, rest.length);
+
+                // pass the overflow array as the last parameter
+                actualParameters[lastParam] = rest;
+
+                return callViaReflection(actualParameters);
+            }
+        }
+
+        if (params.length == 0) {
+            return doCall();
+        } else if (params.length == 1) {
+            return doCall(params[0]);
+        } else if (params.length == 2) {
+            return doCall(params[0], params[1]);
+        } else {
+            return callViaReflection(params);
+            /// return doCall(new Object[] { params });
+        }
+    }
+
     protected static Object throwRuntimeException(Throwable throwable) {
         if (throwable instanceof RuntimeException) {
             throw (RuntimeException) throwable;
@@ -314,7 +404,10 @@ public abstract class Closure extends GroovyObjectSupport implements Cloneable,
      * @return the result of calling the closure
      */
     protected Object doCall(final Object p1) {
-        return callViaReflection(new Object[]{p1});
+        if (p1 instanceof Object[])
+            return callViaReflection((Object[]) p1);
+        else
+            return callViaReflection(new Object[] {p1});
     }
     
     /**
@@ -343,9 +436,23 @@ public abstract class Closure extends GroovyObjectSupport implements Cloneable,
         return callViaReflection(new Object[]{p1, p2});
     }
 
+    private Method retrieveMethod(int paramCount) {
+        Method ans = this.doCallMethod;
+        Class closureClass = this.getClass();
+        final Method methods[] = closureClass.getDeclaredMethods();
+        for (int j = 0; j < methods.length; j++) {
+            System.out.println(j + ": " + methods[j].getName() + " " + methods[j].getParameterTypes().length);
+            // if ("doCall".equals(methods[j].getName()) && paramCount == methods[j].getParameterTypes().length) {
+            if ("call".equals(methods[j].getName()) && paramCount == methods[j].getParameterTypes().length) {
+                 ans = methods[j];
+                 break;
+            }
+        }
+        return ans;
+    }
+
     private Object callViaReflection(final Object params[]) {
         try {
-            // invoke the closure
             return this.doCallMethod.invoke(this, params);
         } catch (final IllegalArgumentException e) {
             throw new IncorrectClosureArgumentsException(this, params, this.parameterTypes);
@@ -461,6 +568,7 @@ public abstract class Closure extends GroovyObjectSupport implements Cloneable,
          * @see groovy.lang.GroovyObject#invokeMethod(java.lang.String, java.lang.Object)
          */
         public Object invokeMethod(String method, Object arguments) {
+            System.out.println("Another Loop 1:");
             if ("clone".equals(method)) {
                 return clone();
             } else if ("curry".equals(method)) {
diff --git a/src/test/groovy/BitwiseOperationsTest.groovy b/src/test/groovy/BitwiseOperationsTest.groovy
index 5e644763bf..ff9c8f02d6 100644
--- a/src/test/groovy/BitwiseOperationsTest.groovy
+++ b/src/test/groovy/BitwiseOperationsTest.groovy
@@ -152,38 +152,38 @@ class BitwiseOperationsTest extends GroovyTestCase {
     }
 
     void testBitwiseOrInClosure() {
-        def c1 = { x, y -> x | y }
+        def c1 = { x, y -> return x | y }
         assert c1(14, 5) == 15          // 0x0000000E | 0x00000005 = 0x0000000F
         assert c1(0x0D, 0xFE) == 255    // 0x0000000D | 0x000000FE = 0x000000FF
 
-        def c2 = { x, y -> x | y }
+        def c2 = { x, y -> return x | y }
         assert c2(14, 5) == 15          // 0x0000000E | 0x00000005 = 0x0000000F
         assert c2(0x0D, 0xFE) == 255    // 0x0000000D | 0x000000FE = 0x000000FF
     }
 
     void testAmbiguityOfBitwiseOr() {
-        def c1 = { x, y -> x | y }
+        def c1 = { x, y -> return x | y }
         assert c1(14, 5) == 15          // 0x0000000E | 0x00000005 = 0x0000000F
         assert c1(0x0D, 0xFE) == 255    // 0x0000000D | 0x000000FE = 0x000000FF
 
-        def c2 = { x, y -> x | y }
+        def c2 = { x, y -> return x | y }
         assert c2(14, 5) == 15          // 0x0000000E | 0x00000005 = 0x0000000F
         assert c2(0x0D, 0xFE) == 255    // 0x0000000D | 0x000000FE = 0x000000FF
 
         def x = 3
         def y = 5
-        c1 = { x -> y }      // -> is a closure delimiter
-        c2 = { x & y }      // & is a bitAnd
-        def c3 = { x ^ y }      // & is a bitXor
+        c1 = { x -> return y }         // -> is a closure delimiter
+        c2 = { return n x & y }        // & is a bitAnd
+        def c3 = { return x ^ y }      // & is a bitXor
         def c11 = {
-             x -> y          // -> is a closure delimiter
+             x -> return y             // -> is a closure delimiter
         }
         def c12 = {
-             (x | y)        // | is a bitOr
+             return (x | y)            // | is a bitOr
         }
-        def c13 = { x -> y      // -> is a closure delimiter
+        def c13 = { x -> return y      // -> is a closure delimiter
         }
-        def c14 = {-> x | y     // last | is a bitOr
+        def c14 = {-> return x | y     // last | is a bitOr
         }
 
         assert c1() == 5
@@ -196,18 +196,18 @@ class BitwiseOperationsTest extends GroovyTestCase {
 
         x = 0x03
 
-        def d1 = { x -> x }      // -> is a closure delimiter
-        def d2 = { x & x }      // & is a bitAnd
-        def d3 = { x ^ x }      // & is a bitXor
+        def d1 = { x -> return x }      // -> is a closure delimiter
+        def d2 = { return x & x }       // & is a bitAnd
+        def d3 = { return x ^ x }       // & is a bitXor
         def d11 = {
-             x -> x          // -> is a closure delimiter
+             x -> return x              // -> is a closure delimiter
         }
         def d12 = {
-             (x | x)        // | is a bitOr
+             return (x | x)            // | is a bitOr
         }
-        def d13 = {x -> x      // -> is a closure delimiter
+        def d13 = {x -> return x       // -> is a closure delimiter
         }
-        def d14 = {-> x | x     // last | is a bitOr
+        def d14 = {-> return x | x     // last | is a bitOr
         }
         assert d1(0xF0) == 0xF0
         assert d2(0xF0) == 0x03
