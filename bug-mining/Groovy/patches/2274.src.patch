diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 0859fc713a..fdd74ee4b7 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -1283,69 +1283,68 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
     public void visitPostfixExpression(final PostfixExpression expression) {
         super.visitPostfixExpression(expression);
         Expression inner = expression.getExpression();
-        ClassNode exprType = getType(inner);
-        int type = expression.getOperation().getType();
-        String name = type == PLUS_PLUS ? "next" : type == MINUS_MINUS ? "previous" : null;
-        if (isPrimitiveType(exprType) || isPrimitiveType(getUnwrapper(exprType))) {
-            if (type == PLUS_PLUS || type == MINUS_MINUS) {
-                if (!isPrimitiveType(exprType)) {
-                    MethodNode node = findMethodOrFail(inner, exprType, name);
-                    if (node != null) {
-                        storeTargetMethod(expression, node);
-                        storeType(expression,  inferReturnTypeGenerics(exprType, node, ArgumentListExpression.EMPTY_ARGUMENTS));
-                        return;
-                    }
-                }
-                storeType(expression, exprType);
-                return;
-            }
-            addUnsupportedPreOrPostfixExpressionError(expression);
-            return;
-        }
-        // not a primitive type. We must find a method which is called next
-        if (name == null) {
-            addUnsupportedPreOrPostfixExpressionError(expression);
-            return;
-        }
-        MethodNode node = findMethodOrFail(inner, exprType, name);
-        if (node != null) {
-            storeTargetMethod(expression, node);
-            storeType(expression,  inferReturnTypeGenerics(exprType, node, ArgumentListExpression.EMPTY_ARGUMENTS));
-        }
+        int op = expression.getOperation().getType();
+        visitPrefixOrPostifExpression(expression, inner, op);
     }
 
     @Override
     public void visitPrefixExpression(final PrefixExpression expression) {
         super.visitPrefixExpression(expression);
         Expression inner = expression.getExpression();
-        ClassNode exprType = getType(inner);
         int type = expression.getOperation().getType();
-        String name = type == PLUS_PLUS ? "next" : type == MINUS_MINUS ? "previous" : null;
+        visitPrefixOrPostifExpression(expression, inner, type);
+    }
+
+    private static ClassNode getMathWideningClassNode(ClassNode type) {
+        if (byte_TYPE.equals(type) || short_TYPE.equals(type) || int_TYPE.equals(type)) {
+            return int_TYPE;
+        }
+        if (Byte_TYPE.equals(type) || Short_TYPE.equals(type) || Integer_TYPE.equals(type)) {
+            return Integer_TYPE;
+        }
+        if (float_TYPE.equals(type)) return double_TYPE;
+        if (Float_TYPE.equals(type)) return Double_TYPE;
+        return type;
+    }
+
+    private void visitPrefixOrPostifExpression(final Expression origin, final Expression innerExpression, final int operationType) {
+        boolean isPostfix = origin instanceof PostfixExpression;
+        ClassNode exprType = getType(innerExpression);
+        String name = operationType == PLUS_PLUS ? "next" : operationType == MINUS_MINUS ? "previous" : null;
         if (isPrimitiveType(exprType) || isPrimitiveType(getUnwrapper(exprType))) {
-            if (type == PLUS_PLUS || type == MINUS_MINUS) {
+            if (operationType == PLUS_PLUS || operationType == MINUS_MINUS) {
                 if (!isPrimitiveType(exprType)) {
-                    MethodNode node = findMethodOrFail(inner, exprType, name);
+                    MethodNode node = findMethodOrFail(innerExpression, exprType, name);
                     if (node != null) {
-                        storeTargetMethod(expression, node);
+                        storeTargetMethod(origin, node);
+                        storeType(origin,
+                                isPostfix?exprType:getMathWideningClassNode(exprType));
+                        return;
                     }
-                    storeType(expression,  inferReturnTypeGenerics(exprType, node, ArgumentListExpression.EMPTY_ARGUMENTS));
-                    return;
                 }
-                storeType(expression, exprType);
+                storeType(origin, exprType);
                 return;
             }
-            addUnsupportedPreOrPostfixExpressionError(expression);
+            addUnsupportedPreOrPostfixExpressionError(origin);
             return;
+        } else if (implementsInterfaceOrIsSubclassOf(exprType, Number_TYPE) && (operationType == PLUS_PLUS || operationType == MINUS_MINUS)) {
+            // special case for numbers, improve type checking as we can expect ++ and -- to return the same type
+            MethodNode node = findMethodOrFail(innerExpression, exprType, name);
+            if (node != null) {
+                storeTargetMethod(origin, node);
+                storeType(origin, getMathWideningClassNode(exprType));
+                return;
+            }
         }
-        // not a primitive type. We must find a method which is called next or previous
+        // not a primitive type. We must find a method which is called next
         if (name == null) {
-            addUnsupportedPreOrPostfixExpressionError(expression);
+            addUnsupportedPreOrPostfixExpressionError(origin);
             return;
         }
-        MethodNode node = findMethodOrFail(inner, exprType, name);
+        MethodNode node = findMethodOrFail(innerExpression, exprType, name);
         if (node != null) {
-            storeTargetMethod(expression, node);
-            storeType(expression,  inferReturnTypeGenerics(exprType, node, ArgumentListExpression.EMPTY_ARGUMENTS));
+            storeTargetMethod(origin, node);
+            storeType(origin,  isPostfix?exprType:inferReturnTypeGenerics(exprType, node, ArgumentListExpression.EMPTY_ARGUMENTS));
         }
     }
 
diff --git a/src/test/groovy/transform/stc/TypeInferenceSTCTest.groovy b/src/test/groovy/transform/stc/TypeInferenceSTCTest.groovy
index 5d9b47f494..a62484c35a 100644
--- a/src/test/groovy/transform/stc/TypeInferenceSTCTest.groovy
+++ b/src/test/groovy/transform/stc/TypeInferenceSTCTest.groovy
@@ -623,5 +623,53 @@ class TypeInferenceSTCTest extends StaticTypeCheckingTestCase {
                 assert v3 == null
         '''
     }
+
+    void testNumberPrefixPlusPlusInference() {
+        [Byte:'Integer',
+         Character: 'Character',
+         Short: 'Integer',
+         Integer: 'Integer',
+         Long: 'Long',
+         Float: 'Double',
+         Double: 'Double',
+         BigDecimal: 'BigDecimal',
+         BigInteger: 'BigInteger'
+        ].each { orig, dest ->
+            assertScript """
+            $orig b = 65 as $orig
+            @ASTTest(phase=INSTRUCTION_SELECTION, value={
+                def rit = node.rightExpression.getNodeMetaData(INFERRED_TYPE)
+                assert rit == make($dest)
+            })
+            def pp = ++b
+            println '++${orig} -> ' + pp.class + ' ' + pp
+            assert pp.class == ${dest}
+            """
+        }
+    }
+
+    void testNumberPostfixPlusPlusInference() {
+        [Byte:'Byte',
+         Character: 'Character',
+         Short: 'Short',
+         Integer: 'Integer',
+         Long: 'Long',
+         Float: 'Float',
+         Double: 'Double',
+         BigDecimal: 'BigDecimal',
+         BigInteger: 'BigInteger'
+        ].each { orig, dest ->
+            assertScript """
+            $orig b = 65 as $orig
+            @ASTTest(phase=INSTRUCTION_SELECTION, value={
+                def rit = node.rightExpression.getNodeMetaData(INFERRED_TYPE)
+                assert rit == make($dest)
+            })
+            def pp = b++
+            println '${orig}++ -> ' + pp.class + ' ' + pp
+            assert pp.class == ${dest}
+            """
+        }
+    }
 }
 
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/BugsStaticCompileTest.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/BugsStaticCompileTest.groovy
index 652c1d54ba..fcc59a615f 100644
--- a/src/test/org/codehaus/groovy/classgen/asm/sc/BugsStaticCompileTest.groovy
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/BugsStaticCompileTest.groovy
@@ -936,5 +936,33 @@ import groovy.transform.TypeCheckingMode
         assert isCaseNullCS(2,1) == false
         '''
     }
+
+    // GROOVY-6242
+    void testGetAtBigInt() {
+        assertScript '''
+class Sequence {
+    public Sequence() {}
+    static BigInteger getAt(final int index) { 1G }
+    static BigInteger getAt(final BigInteger index) { getAt(index as int) }
+}
+
+class Iterator implements java.util.Iterator {
+    private BigInteger currentIndex = 0G
+    private final Sequence sequence
+    Iterator(final Sequence s) { sequence = s }
+    boolean hasNext() { return true }
+    @ASTTest(phase=INSTRUCTION_SELECTION,value={
+        def expr = node.code.statements[0].expression
+        def indexType = expr.rightExpression.getNodeMetaData(INFERRED_TYPE)
+        assert indexType == make(BigInteger)
+    })
+    BigInteger next() { sequence[currentIndex++] }
+    void remove() { throw new UnsupportedOperationException() }
+}
+
+def it = new Iterator(new Sequence())
+assert it.next() == 1G
+'''
+    }
 }
 
