diff --git a/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java b/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java
index 1071f25ee3..62278ae9d5 100644
--- a/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java
+++ b/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java
@@ -1124,7 +1124,7 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
                 return closureExpression(node);
 
             case SUPER_CTOR_CALL:
-                return superMethodCallExpression(node);
+                return specialConstructorCallExpression(node,ClassNode.SUPER);
 
             case METHOD_CALL:
                 return methodCallExpression(node);
@@ -1133,7 +1133,7 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
                 return constructorCallExpression(node.getFirstChild());
 
             case CTOR_CALL:
-                return constructorCallExpression(node);
+                return specialConstructorCallExpression(node,ClassNode.THIS);
 
             case QUESTION:
                 return ternaryExpression(node);
@@ -1686,15 +1686,12 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
         }
         return methodCallExpression(node);
     }
-
-    protected Expression superMethodCallExpression(AST methodCallNode) {
+    
+    protected Expression specialConstructorCallExpression(AST methodCallNode, ClassNode special) {
         AST node = methodCallNode.getFirstChild();
-
-        String name = "super";
-        Expression objectExpression = VariableExpression.SUPER_EXPRESSION;
-
         Expression arguments = arguments(node);
-        MethodCallExpression expression = new MethodCallExpression(objectExpression, name, arguments);
+        
+        ConstructorCallExpression expression = new ConstructorCallExpression(special, arguments);
         configureAST(expression, methodCallNode);
         return expression;
     }
diff --git a/src/main/org/codehaus/groovy/ast/ClassNode.java b/src/main/org/codehaus/groovy/ast/ClassNode.java
index c5224a9df4..977f661e29 100644
--- a/src/main/org/codehaus/groovy/ast/ClassNode.java
+++ b/src/main/org/codehaus/groovy/ast/ClassNode.java
@@ -79,7 +79,10 @@ import java.util.Map;
 public class ClassNode extends AnnotatedNode implements Opcodes {
 
 	public static ClassNode[] EMPTY_ARRAY = new ClassNode[0];
-	
+    
+    public static ClassNode THIS = new ClassNode(Object.class);
+    public static ClassNode SUPER = new ClassNode(Object.class);
+    
     private String name;
     private int modifiers;
     private ClassNode[] interfaces;
diff --git a/src/main/org/codehaus/groovy/ast/MethodNode.java b/src/main/org/codehaus/groovy/ast/MethodNode.java
index 708c28912d..7d30c0b870 100644
--- a/src/main/org/codehaus/groovy/ast/MethodNode.java
+++ b/src/main/org/codehaus/groovy/ast/MethodNode.java
@@ -45,6 +45,9 @@
  */
 package org.codehaus.groovy.ast;
 
+import java.util.List;
+
+import org.codehaus.groovy.ast.stmt.BlockStatement;
 import org.codehaus.groovy.ast.stmt.Statement;
 import org.objectweb.asm.Opcodes;
 
@@ -185,4 +188,14 @@ public class MethodNode extends AnnotatedNode implements Opcodes {
     public ClassNode[] getExceptions() {
         return exceptions;
     }
+    
+    public Statement getFirstStatement(){
+        if (code == null) return null;
+        if (code instanceof BlockStatement) {
+            List list = ((BlockStatement) code).getStatements();
+            if (list.size()>0) return (Statement) list.get(0);
+            return null;
+        }
+        return code;
+    }
 }
diff --git a/src/main/org/codehaus/groovy/ast/expr/ConstructorCallExpression.java b/src/main/org/codehaus/groovy/ast/expr/ConstructorCallExpression.java
index 23b344207b..0a9ae91f68 100644
--- a/src/main/org/codehaus/groovy/ast/expr/ConstructorCallExpression.java
+++ b/src/main/org/codehaus/groovy/ast/expr/ConstructorCallExpression.java
@@ -45,9 +45,6 @@
  */
 package org.codehaus.groovy.ast.expr;
 
-import java.lang.reflect.Constructor;
-
-import org.codehaus.groovy.ast.ClassHelper;
 import org.codehaus.groovy.ast.ClassNode;
 import org.codehaus.groovy.ast.GroovyCodeVisitor;
 
@@ -55,19 +52,13 @@ import org.codehaus.groovy.ast.GroovyCodeVisitor;
  * A constructor call
  * 
  * @author <a href="mailto:james@coredevelopers.net">James Strachan</a>
+ * @author Jochen Theodorou
  * @version $Revision$
  */
 public class ConstructorCallExpression extends Expression {
 
     private Expression arguments;
 
-    public Constructor getConstructor() {
-        return constructor;
-    }
-
-    private Constructor constructor = null;
-
-
     public ConstructorCallExpression(ClassNode type, Expression arguments) {
         super.setType(type);
         this.arguments = arguments;
@@ -78,7 +69,8 @@ public class ConstructorCallExpression extends Expression {
     }
     
     public Expression transformExpression(ExpressionTransformer transformer) {
-        Expression ret =  new ConstructorCallExpression(getType(), transformer.transform(arguments));
+        Expression args = transformer.transform(arguments);
+        Expression ret = new ConstructorCallExpression(getType(), args);
         ret.setSourcePosition(this);
         return ret;
     }
@@ -94,9 +86,16 @@ public class ConstructorCallExpression extends Expression {
     public String toString() {
         return super.toString() + "[type: " + getType() + " arguments: " + arguments + "]";
     }
-
-    public void setConstructor(Constructor ctor) {
-        constructor = ctor;
-        super.setType(ClassHelper.make(ctor.getDeclaringClass()));
+    
+    public boolean isSuperCall() {
+        return getType()==ClassNode.SUPER;
+    }
+    
+    public boolean isSpecialCall(){
+        return isThisCall() || isSuperCall();
+    }
+    
+    public boolean isThisCall() {
+        return getType()==ClassNode.THIS;
     }
 }
diff --git a/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java b/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
index c9b289cbd6..254a9c873b 100644
--- a/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
+++ b/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
@@ -381,11 +381,10 @@ public class AsmClassGenerator extends ClassGenerator {
         helper = new BytecodeHelper(cv);
         if (!node.isAbstract()) { 
             Statement code = node.getCode();
-            if (isConstructor && (code == null || !firstStatementIsSuperInit(code))) {
+            if (isConstructor && (code == null || !firstStatementIsSpecialConstructorCall(node))) {
                 // invokes the super class constructor
-                //cv.visitLabel(new Label());
                 cv.visitVarInsn(ALOAD, 0);
-                cv.visitMethodInsn(INVOKESPECIAL, internalBaseClassName, "<init>", "()V");
+                cv.visitMethodInsn(INVOKESPECIAL, BytecodeHelper.getClassInternalName(classNode.getSuperClass()), "<init>", "()V");
             }
             
             compileStack.init(node.getVariableScope(),node.getParameters(),cv, BytecodeHelper.getTypeDescription(classNode));
@@ -409,6 +408,16 @@ public class AsmClassGenerator extends ClassGenerator {
         }
     }
 
+    private boolean firstStatementIsSpecialConstructorCall(MethodNode node) {
+        Statement code = node.getFirstStatement();
+        if (code == null || !(code instanceof ExpressionStatement)) return false;
+
+        Expression expression = ((ExpressionStatement)code).getExpression();
+        if (!(expression instanceof ConstructorCallExpression)) return false;
+        ConstructorCallExpression cce = (ConstructorCallExpression) expression;
+        return cce.isSpecialCall();
+    }
+
     public void visitConstructor(ConstructorNode node) {
         this.constructorNode = node;
         this.methodNode = null;
@@ -1489,97 +1498,71 @@ public class AsmClassGenerator extends ClassGenerator {
          */
         boolean superMethodCall = MethodCallExpression.isSuperMethodCall(call);
         String method = call.getMethod();
-        if (superMethodCall && method.equals("<init>")) {
-            /** todo handle method types! */
-            cv.visitVarInsn(ALOAD, 0);
-            if (isInClosureConstructor()) { // br use the second param to init the super class (Closure)
-                cv.visitVarInsn(ALOAD, 2);
-                cv.visitMethodInsn(INVOKESPECIAL, internalBaseClassName, "<init>", "(Ljava/lang/Object;)V");
+        // are we a local variable
+        if (isThisExpression(call.getObjectExpression()) && isFieldOrVariable(method) && ! classNode.hasPossibleMethod(method, arguments)) {
+            /*
+             * if (arguments instanceof TupleExpression) { TupleExpression
+             * tupleExpression = (TupleExpression) arguments; int size =
+             * tupleExpression.getExpressions().size(); if (size == 1) {
+             * arguments = (Expression)
+             * tupleExpression.getExpressions().get(0); } }
+             */
+            
+            // lets invoke the closure method
+            visitVariableExpression(new VariableExpression(method));
+            arguments.visit(this);
+            invokeClosureMethod.call(cv);
+        } else {
+            if (superMethodCall) {
+                MethodNode superMethodNode = findSuperMethod(call);
+                
+                cv.visitVarInsn(ALOAD, 0);
+                
+                loadArguments(superMethodNode.getParameters(), arguments);
+                
+                String descriptor = BytecodeHelper.getMethodDescriptor(superMethodNode.getReturnType(), superMethodNode.getParameters());
+                cv.visitMethodInsn(INVOKESPECIAL, BytecodeHelper.getClassInternalName(superMethodNode.getDeclaringClass()), method, descriptor);
             }
             else {
-                cv.visitVarInsn(ALOAD, 1);
-                cv.visitMethodInsn(INVOKESPECIAL, internalBaseClassName, "<init>", "(Ljava/lang/Object;)V");
-            }
-        }
-        else {
-            // are we a local variable
-            if (isThisExpression(call.getObjectExpression()) && isFieldOrVariable(method) && ! classNode.hasPossibleMethod(method, arguments)) {
-                /*
-                 * if (arguments instanceof TupleExpression) { TupleExpression
-                 * tupleExpression = (TupleExpression) arguments; int size =
-                 * tupleExpression.getExpressions().size(); if (size == 1) {
-                 * arguments = (Expression)
-                 * tupleExpression.getExpressions().get(0); } }
-                 */
-
-                // lets invoke the closure method
-                visitVariableExpression(new VariableExpression(method));
-                arguments.visit(this);
-                invokeClosureMethod.call(cv);
-            } else {
-                if (superMethodCall) {
-                    if (method.equals("super") || method.equals("<init>")) {
-                        ConstructorNode superConstructorNode = findSuperConstructor(call);
-
-                        cv.visitVarInsn(ALOAD, 0);
-
-                        loadArguments(superConstructorNode.getParameters(), arguments);
-
-                        String descriptor = BytecodeHelper.getMethodDescriptor(ClassHelper.VOID_TYPE, superConstructorNode.getParameters());
-                        cv.visitMethodInsn(INVOKESPECIAL, BytecodeHelper.getClassInternalName(classNode.getSuperClass()), "<init>", descriptor);
-                    }
-                    else {
-                        MethodNode superMethodNode = findSuperMethod(call);
-
-                        cv.visitVarInsn(ALOAD, 0);
-
-                        loadArguments(superMethodNode.getParameters(), arguments);
-
-                        String descriptor = BytecodeHelper.getMethodDescriptor(superMethodNode.getReturnType(), superMethodNode.getParameters());
-                        cv.visitMethodInsn(INVOKESPECIAL, BytecodeHelper.getClassInternalName(superMethodNode.getDeclaringClass()), method, descriptor);
+                Expression objectExpression = call.getObjectExpression();
+                boolean objectExpressionIsMethodName = false;
+                if (method.equals("call")) {
+                    if (objectExpression instanceof GStringExpression) {
+                        objectExpressionIsMethodName=true;
+                        objectExpression = new CastExpression(ClassHelper.STRING_TYPE, objectExpression);
+                    } else if (objectExpression instanceof ConstantExpression) {
+                        Object value = ((ConstantExpression) objectExpression).getValue();
+                        if ( value != null && value instanceof String) objectExpressionIsMethodName=true;
                     }
                 }
-                else {
-                    Expression objectExpression = call.getObjectExpression();
-                    boolean objectExpressionIsMethodName = false;
-                    if (method.equals("call")) {
-                        if (objectExpression instanceof GStringExpression) {
-                            objectExpressionIsMethodName=true;
-                            objectExpression = new CastExpression(ClassHelper.STRING_TYPE, objectExpression);
-                        } else if (objectExpression instanceof ConstantExpression) {
-                            Object value = ((ConstantExpression) objectExpression).getValue();
-                            if ( value != null && value instanceof String) objectExpressionIsMethodName=true;
-                        }
-                    }
-                    
-                    if (emptyArguments(arguments) && !call.isSafe() && !call.isSpreadSafe()) {
+                
+                if (emptyArguments(arguments) && !call.isSafe() && !call.isSpreadSafe()) {
+                    prepareMethodcallObjectAndName(objectExpression, objectExpressionIsMethodName,method);
+                    invokeNoArgumentsMethod.call(cv);
+                } else {
+                    if (argumentsUseStack(arguments)) {
+                        
+                        arguments.visit(this);
+                        
+                        int paramIdx = compileStack.defineTemporaryVariable(method + "_arg",true);
+                        
                         prepareMethodcallObjectAndName(objectExpression, objectExpressionIsMethodName,method);
-                        invokeNoArgumentsMethod.call(cv);
+                        
+                        cv.visitVarInsn(ALOAD, paramIdx);
+                        compileStack.removeVar(paramIdx);
                     } else {
-                        if (argumentsUseStack(arguments)) {
-
-                            arguments.visit(this);
-
-                            int paramIdx = compileStack.defineTemporaryVariable(method + "_arg",true);
-
-                            prepareMethodcallObjectAndName(objectExpression, objectExpressionIsMethodName,method);
-
-                            cv.visitVarInsn(ALOAD, paramIdx);
-                            compileStack.removeVar(paramIdx);
-                        } else {
-                            prepareMethodcallObjectAndName(objectExpression, objectExpressionIsMethodName,method);
-                            arguments.visit(this);
-                        }
-
-                        if (call.isSpreadSafe()) {
-                            invokeMethodSpreadSafeMethod.call(cv);
-                        }
-                        else if (call.isSafe()) {
-                            invokeMethodSafeMethod.call(cv);
-                        }
-                        else {
-                            invokeMethodMethod.call(cv);
-                        }
+                        prepareMethodcallObjectAndName(objectExpression, objectExpressionIsMethodName,method);
+                        arguments.visit(this);
+                    }
+                    
+                    if (call.isSpreadSafe()) {
+                        invokeMethodSpreadSafeMethod.call(cv);
+                    }
+                    else if (call.isSafe()) {
+                        invokeMethodSafeMethod.call(cv);
+                    }
+                    else {
+                        invokeMethodMethod.call(cv);
                     }
                 }
             }
@@ -1629,12 +1612,11 @@ public class AsmClassGenerator extends ClassGenerator {
     /**
      * Attempts to find the constructor in a super class
      */
-    protected ConstructorNode findSuperConstructor(MethodCallExpression call) {
+    protected ConstructorNode findConstructor(ConstructorCallExpression call, ClassNode searchNode) {
         TupleExpression argExpr = (TupleExpression) call.getArguments();
         int argCount = argExpr.getExpressions().size();
-        ClassNode superClassNode = classNode.getSuperClass();
-        if (superClassNode != null) {
-            List constructors = superClassNode.getDeclaredConstructors();
+        if (searchNode != null) {
+            List constructors = searchNode.getDeclaredConstructors();
             for (Iterator iter = constructors.iterator(); iter.hasNext(); ) {
                 ConstructorNode constructor = (ConstructorNode) iter.next();
                 if (constructor.getParameters().length == argCount) {
@@ -1686,6 +1668,18 @@ public class AsmClassGenerator extends ClassGenerator {
         onLineNumber(call, "visitConstructorCallExpression: \"" + call.getType().getName() + "\":");
         this.leftHandExpression = false;
 
+        if (call.isSpecialCall()){
+            ClassNode callNode = classNode;
+            if (call.isSuperCall()) callNode = callNode.getSuperClass();
+            ConstructorNode constructorNode = findConstructor(call, callNode);
+            cv.visitVarInsn(ALOAD, 0);
+            loadArguments(constructorNode.getParameters(), call.getArguments());
+
+            String descriptor = BytecodeHelper.getMethodDescriptor(ClassHelper.VOID_TYPE, constructorNode.getParameters());
+            cv.visitMethodInsn(INVOKESPECIAL, BytecodeHelper.getClassInternalName(callNode), "<init>", descriptor);
+            return;
+        }
+        
         Expression arguments = call.getArguments();
         if (arguments instanceof TupleExpression) {
             TupleExpression tupleExpression = (TupleExpression) arguments;
@@ -2164,34 +2158,11 @@ public class AsmClassGenerator extends ClassGenerator {
 //                    return false;
             }
         }
-        return true;
-    }
-
-    protected boolean firstStatementIsSuperInit(Statement code) {
-        ExpressionStatement expStmt = null;
-        if (code instanceof ExpressionStatement) {
-            expStmt = (ExpressionStatement) code;
-        }
-        else if (code instanceof BlockStatement) {
-            BlockStatement block = (BlockStatement) code;
-            if (!block.getStatements().isEmpty()) {
-                Object expr = block.getStatements().get(0);
-                if (expr instanceof ExpressionStatement) {
-                    expStmt = (ExpressionStatement) expr;
-                }
-            }
-        }
-        if (expStmt != null) {
-            Expression expr = expStmt.getExpression();
-            if (expr instanceof MethodCallExpression) {
-            	MethodCallExpression call = (MethodCallExpression) expr;
-                if (MethodCallExpression.isSuperMethodCall(call)) {
-                    // not sure which one is constantly used as the super class ctor call. To cover both for now
-                	return call.getMethod().equals("<init>") || call.getMethod().equals("super");
-                }
-            }
+        if (expression instanceof ConstructorCallExpression) {
+            ConstructorCallExpression cce = (ConstructorCallExpression) expression;
+            return !cce.isSpecialCall();
         }
-        return false;
+        return true;
     }
 
     protected void createSyntheticStaticFields() {
@@ -2543,9 +2514,8 @@ public class AsmClassGenerator extends ClassGenerator {
         block.getVariableScope().getReferencedLocalVariables().put("_outerInstance",outer);
         block.addStatement(
             new ExpressionStatement(
-                new MethodCallExpression(
-                    new VariableExpression("super"),
-                    "<init>",
+                new ConstructorCallExpression(
+                    VariableExpression.SUPER_EXPRESSION,
                     outer)));
         block.addStatement(
             new ExpressionStatement(
diff --git a/src/main/org/codehaus/groovy/classgen/Verifier.java b/src/main/org/codehaus/groovy/classgen/Verifier.java
index 70535911e2..71b5b44b74 100644
--- a/src/main/org/codehaus/groovy/classgen/Verifier.java
+++ b/src/main/org/codehaus/groovy/classgen/Verifier.java
@@ -70,6 +70,7 @@ import org.codehaus.groovy.ast.expr.BinaryExpression;
 import org.codehaus.groovy.ast.expr.BooleanExpression;
 import org.codehaus.groovy.ast.expr.ClosureExpression;
 import org.codehaus.groovy.ast.expr.ConstantExpression;
+import org.codehaus.groovy.ast.expr.ConstructorCallExpression;
 import org.codehaus.groovy.ast.expr.Expression;
 import org.codehaus.groovy.ast.expr.FieldExpression;
 import org.codehaus.groovy.ast.expr.MethodCallExpression;
@@ -567,10 +568,15 @@ public class Verifier implements GroovyClassVisitor, Opcodes {
     }
 
     protected void addFieldInitialization(ClassNode node, ConstructorNode constructorNode) {
+        ConstructorCallExpression first = getFirstIfSpecialConstructorCall(constructorNode);
+
+        // in case of this(...) let the other constructor do the intit
+        if (first!=null && first.isThisCall()) return;
+        
         List statements = new ArrayList();
         List staticStatements = new ArrayList();
         for (Iterator iter = node.getFields().iterator(); iter.hasNext();) {
-            addFieldInitialization(statements, staticStatements, constructorNode, (FieldNode) iter.next());
+            addFieldInitialization(statements, staticStatements, (FieldNode) iter.next());
         }
         if (!statements.isEmpty()) {
             Statement code = constructorNode.getCode();
@@ -584,11 +590,11 @@ public class Verifier implements GroovyClassVisitor, Opcodes {
                 otherStatements.add(code);
             }
             if (!otherStatements.isEmpty()) {
-                Statement first = (Statement) otherStatements.get(0);
-                if (isSuperMethodCall(first)) {
+                if (first!=null) {
+                    // it is super(..) since this(..) is already covered
                     otherStatements.remove(0);
                     statements.add(0, first);
-                }
+                } 
                 statements.addAll(otherStatements);
             }
             constructorNode.setCode(new BlockStatement(statements, block.getVariableScope()));
@@ -599,10 +605,20 @@ public class Verifier implements GroovyClassVisitor, Opcodes {
         }
     }
 
+    private ConstructorCallExpression getFirstIfSpecialConstructorCall(ConstructorNode node) {
+        Statement code = node.getFirstStatement();
+        if (code == null || !(code instanceof ExpressionStatement)) return null;
+
+        Expression expression = ((ExpressionStatement)code).getExpression();
+        if (!(expression instanceof ConstructorCallExpression)) return null;
+        ConstructorCallExpression cce = (ConstructorCallExpression) expression;
+        if (cce.isSpecialCall()) return cce;
+        return null;
+    }
+
     protected void addFieldInitialization(
         List list,
         List staticList,
-        ConstructorNode constructorNode,
         FieldNode fieldNode) {
         Expression expression = fieldNode.getInitialExpression();
         if (expression != null) {
@@ -621,17 +637,6 @@ public class Verifier implements GroovyClassVisitor, Opcodes {
         }
     }
 
-    protected boolean isSuperMethodCall(Statement first) {
-        if (first instanceof ExpressionStatement) {
-            ExpressionStatement exprStmt = (ExpressionStatement) first;
-            Expression expr = exprStmt.getExpression();
-            if (expr instanceof MethodCallExpression) {
-                return MethodCallExpression.isSuperMethodCall((MethodCallExpression) expr);
-            }
-        }
-        return false;
-    }
-
     /**
      * Capitalizes the start of the given bean property name
      */
diff --git a/src/main/org/codehaus/groovy/control/ResolveVisitor.java b/src/main/org/codehaus/groovy/control/ResolveVisitor.java
index 310bd3a2db..ed470b2f4a 100644
--- a/src/main/org/codehaus/groovy/control/ResolveVisitor.java
+++ b/src/main/org/codehaus/groovy/control/ResolveVisitor.java
@@ -655,10 +655,7 @@ public class ResolveVisitor extends CodeVisitorSupport implements ExpressionTran
     protected Expression transformConstructorCallExpression(ConstructorCallExpression cce){
     	ClassNode type = cce.getType();
     	resolveOrFail(type,cce);
-    	Expression args = cce.getArguments();
-    	args = transform(args);
-    	Expression expr = new ConstructorCallExpression(type,args);
-        expr.setSourcePosition(cce);
+    	Expression expr = cce.transformExpression(this);
         return expr;
     }
     
