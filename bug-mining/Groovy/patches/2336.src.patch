diff --git a/src/main/groovy/transform/TimedInterrupt.groovy b/src/main/groovy/transform/TimedInterrupt.groovy
index c24052a275..ab73e718a5 100644
--- a/src/main/groovy/transform/TimedInterrupt.groovy
+++ b/src/main/groovy/transform/TimedInterrupt.groovy
@@ -14,31 +14,32 @@
  * limitations under the License.
  */
 
-package groovy.transform;
+package groovy.transform
 
+import java.lang.annotation.Documented
 import java.lang.annotation.ElementType
 import java.lang.annotation.Retention
 import java.lang.annotation.RetentionPolicy
 import java.lang.annotation.Target
-import org.codehaus.groovy.transform.GroovyASTTransformationClass
 import java.util.concurrent.TimeUnit
 import java.util.concurrent.TimeoutException
+import org.codehaus.groovy.transform.GroovyASTTransformationClass
 
 /**
- * Allows safe timed executions of scripts by adding elapsed time checks on loops (for, while, do), the first statement
- * of closures, and the first statement of methods.
+ * Allows safe timed executions of scripts by adding elapsed time checks on loops (for, while, do)
+ * to the first statement of closures and methods.
  * <p>
- * This is especially useful when executing foreign scripts that you do not have control over. Inject this
- * transformation into a script that you want to timeout after a specified amount of timet.
+ * This is especially useful when executing foreign scripts that you do not have control over.
+ * Inject this transformation into a script that you want to timeout after a specified amount of time.
  * <p>
  * Annotating anything in a script will cause for loops, while loops, methods, and closures to make an
  * elapsed time check and throw a TimeoutException if the check yields true. The annotation by default
- * will apply to any classes defined in the script as well. Annotated a class will cause (by default) all classes
- * in the entire file ('Compilation Unit') to be enhanced. You can fine tune what is enhanced using the annotation
- * parameters. Static methods and static fields are ignored.
+ * will apply to any classes defined in the script as well. Annotating a class will cause (by default)
+ * all classes in the entire file ('Compilation Unit') to be enhanced. You can fine tune what is
+ * enhanced using the annotation parameters. Static methods and static fields are ignored.
  * <p>
- * Extensive usage examples can be found in the unit test for this class. A smaller example is presented here.
- * The following is sample usage of the annotation forcing the script to timeout after 1000 seconds:
+ * Extensive usage examples can be found in the unit test for this class. A smaller example is presented
+ * here. The following is sample usage of the annotation forcing the script to timeout after 1000 seconds:
  *
  * <pre>
  * import groovy.transform.TimedInterrupt
@@ -46,7 +47,6 @@ import java.util.concurrent.TimeoutException
  *
  * {@code @TimedInterrupt}(value = 1000L, unit = TimeUnit.SECONDS)
  * class MyClass {
- *
  *      def method() {
  *          println '...'
  *      }
@@ -58,18 +58,18 @@ import java.util.concurrent.TimeoutException
  * import java.util.concurrent.TimeoutException
  *
  * public class MyClass {
- *
- *     final private long TimedInterrupt$expireTime
- *     final private java.util.Date TimedInterrupt$startTime
+ *     // XXXXXX below is a placeholder for a hashCode value at runtime
+ *     final private long timedInterruptXXXXXX$expireTime
+ *     final private java.util.Date timedInterruptXXXXXX$startTime
  *
  *     public MyClass() {
- *         TimedInterrupt$expireTime = System.nanoTime() + TimeUnit.NANOSECONDS.convert(1000, TimeUnit.SECONDS)
- *         TimedInterrupt$startTime = new java.util.Date()
+ *         timedInterruptXXXXXX$expireTime = System.nanoTime() + TimeUnit.NANOSECONDS.convert(1000, TimeUnit.SECONDS)
+ *         timedInterruptXXXXXX$startTime = new java.util.Date()
  *     }
  *
  *     public java.lang.Object method() {
- *         if (TimedInterrupt$expireTime < System.nanoTime()) {
- *             throw new TimeoutException('Execution timed out after 1000 units. Start time: ' + TimedInterrupt$startTime)
+ *         if (timedInterruptXXXXXX$expireTime < System.nanoTime()) {
+ *             throw new TimeoutException('Execution timed out after 1000 units. Start time: ' + timedInterruptXXXXXX$startTime)
  *         }
  *         return this.println('...')
  *     }
@@ -77,47 +77,64 @@ import java.util.concurrent.TimeoutException
  * </pre>
  *
  * @author Hamlet D'Arcy
- * @see groovy.transform.ThreadInterrupt
- * @see groovy.transform.ConditionalInterrupt
+ * @author Cedric Champeau
+ * @author Paul King
+ * @see ThreadInterrupt
+ * @see ConditionalInterrupt
  * @since 1.8.0
  */
-@java.lang.annotation.Documented
+@Documented
 @Retention(RetentionPolicy.SOURCE)
-@Target([ ElementType.METHOD, ElementType.TYPE])
+@Target([ ElementType.PACKAGE, ElementType.METHOD, ElementType.FIELD, ElementType.TYPE, ElementType.LOCAL_VARIABLE])
 @GroovyASTTransformationClass(["org.codehaus.groovy.transform.TimedInterruptibleASTTransformation"])
 public @interface TimedInterrupt {
     /**
-     * By default, annotating anything in a source file ('Compilation Unit') will trigger this transformation
-     * for all classes and scripts in that file. If you add the Annotation to an import statement, then all
-     * scripts and Classes will be enhanced. If you want to change this behavior then set applyToAllClasses
-     * to false. If you annotate a type then only that type will be augmented, not other types or the surrounding
-     * script. If you annotate a script, then any enclosed types will not be augmented.
-     * @return
+     * In many scenarios, the use of this annotation is to guard against gross time
+     * delays when executing scripts. In such cases you can inject the annotation or
+     * use a single annotation on your class or on any eligible element in a script.
+     * This will trigger this transformation for all classes (including any script class)
+     * in that source file. If you want to change this behavior then set {@code applyToAllClasses}
+     * to false. This gives you more fine-grained control over what parts are enhanced and
+     * allows you to specify different timing constraints on different classes if needed.
+     * When set to false, if you annotate a type then only that type will be augmented, not
+     * other types or the surrounding script. If you annotate a script, then any enclosed
+     * types will not be augmented. For even finer-grained control see {@code applyToAllMembers}.
+     *
+     * @see #applyToAllMembers()
      */
-    boolean applyToAllClasses() default true;
+    boolean applyToAllClasses() default true
+
+    /**
+     * If set to false, it automatically sets {@code applyToAllClasses} to false. In addition,
+     * if you annotate a method (or Closure field), only that method (or Closure) will be enhanced.
+     * This is useful if you want to have different timing constraints on different methods. The implication
+     * is that if you don't set this to false, there is little value in having more than one Annotation
+     * in any one source file or within any one class.
+     *
+     * @since 2.2.0
+     * @see #applyToAllClasses()
+     */
+    boolean applyToAllMembers() default true
+
     /**
-     * By default an isInterrupted check is added to the start of all user-defined methods. To turn this off simply
-     * set this parameter to false.
-     * @return
+     * By default an isInterrupted check is added to the start of all user-defined methods. To turn this off
+     * simply set this parameter to false.
      */
-    boolean checkOnMethodStart() default true;
+    boolean checkOnMethodStart() default true
 
     /**
      * The maximum elapsed time the script will be allowed to run for. By default it is measure in seconds
-     * @return
      */
     long value();
 
     /**
      * The TimeUnit of the value parameter. By default it is TimeUnit.SECONDS.
-     * @return
      */
-    TimeUnit unit() default TimeUnit.SECONDS;
+    TimeUnit unit() default TimeUnit.SECONDS
 
     /**
      * The type of exception thrown when timeout is reached.
-     * @return
      */
-    Class thrown() default TimeoutException;
+    Class thrown() default TimeoutException
 }
 
diff --git a/src/main/org/codehaus/groovy/transform/TimedInterruptibleASTTransformation.groovy b/src/main/org/codehaus/groovy/transform/TimedInterruptibleASTTransformation.groovy
index 5a59e21151..53438ebe03 100644
--- a/src/main/org/codehaus/groovy/transform/TimedInterruptibleASTTransformation.groovy
+++ b/src/main/org/codehaus/groovy/transform/TimedInterruptibleASTTransformation.groovy
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2012 the original author or authors.
+ * Copyright 2008-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -13,31 +13,30 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-package org.codehaus.groovy.transform;
-
+package org.codehaus.groovy.transform
 
 import groovy.transform.TimedInterrupt
-import java.util.concurrent.TimeUnit
-import java.util.concurrent.TimeoutException
+import org.codehaus.groovy.ast.*
+import org.codehaus.groovy.ast.expr.*
+import org.codehaus.groovy.ast.stmt.*
 import org.codehaus.groovy.control.CompilePhase
 import org.codehaus.groovy.control.SourceUnit
 import org.codehaus.groovy.syntax.Token
 import org.codehaus.groovy.syntax.Types
 import org.objectweb.asm.Opcodes
-import org.codehaus.groovy.ast.*
-import org.codehaus.groovy.ast.expr.*
-import org.codehaus.groovy.ast.stmt.*
+
+import java.util.concurrent.TimeUnit
+import java.util.concurrent.TimeoutException
 
 /**
  * Allows "interrupt-safe" executions of scripts by adding timer expiration
- * checks on loops (for, while, do) and first statement of closures. By default, also adds an interrupt check
- * statement on the beginning of method calls.
- *
- * @see groovy.transform.ThreadInterrupt
+ * checks on loops (for, while, do) and first statement of closures. By default,
+ * also adds an interrupt check statement on the beginning of method calls.
  *
  * @author Cedric Champeau
  * @author Hamlet D'Arcy
- *
+ * @author Paul King
+ * @see groovy.transform.ThreadInterrupt
  * @since 1.8.0
  */
 @GroovyASTTransformation(phase = CompilePhase.CANONICALIZATION)
@@ -45,12 +44,13 @@ public class TimedInterruptibleASTTransformation implements ASTTransformation {
 
   private static final ClassNode MY_TYPE = ClassHelper.make(TimedInterrupt.class)
   private static final String CHECK_METHOD_START_MEMBER = 'checkOnMethodStart'
-  private static final String PROPAGATE_TO_COMPILE_UNIT = 'applyToAllClasses'
+  private static final String APPLY_TO_ALL_CLASSES = 'applyToAllClasses'
+  private static final String APPLY_TO_ALL_MEMBERS = 'applyToAllMembers'
   private static final String THROWN_EXCEPTION_TYPE = "thrown"
 
   public void visit(ASTNode[] nodes, SourceUnit source) {
     if (nodes.length != 2 || !(nodes[0] instanceof AnnotationNode) || !(nodes[1] instanceof AnnotatedNode)) {
-      internalError("Expecting [AnnotationNode, AnnotatedClass] but got: ${Arrays.asList(nodes)}")
+      internalError("Expecting [AnnotationNode, AnnotatedNode] but got: ${Arrays.asList(nodes)}")
     }
 
     AnnotationNode node = nodes[0]
@@ -61,31 +61,45 @@ public class TimedInterruptibleASTTransformation implements ASTTransformation {
     }
 
     def checkOnMethodStart = getConstantAnnotationParameter(node, CHECK_METHOD_START_MEMBER, Boolean.TYPE, true)
-    def applyToAllClasses = getConstantAnnotationParameter(node, PROPAGATE_TO_COMPILE_UNIT, Boolean.TYPE, true)
+    def applyToAllMembers = getConstantAnnotationParameter(node, APPLY_TO_ALL_MEMBERS, Boolean.TYPE, true)
+    def applyToAllClasses = applyToAllMembers ? getConstantAnnotationParameter(node, APPLY_TO_ALL_CLASSES, Boolean.TYPE, true) : false
     def maximum = getConstantAnnotationParameter(node, 'value', Long.TYPE, Long.MAX_VALUE)
     def thrown = AbstractInterruptibleASTTransformation.getClassAnnotationParameter(node, THROWN_EXCEPTION_TYPE, ClassHelper.make(TimeoutException))
 
     Expression unit = node.getMember('unit') ?: new PropertyExpression(new ClassExpression(ClassHelper.make(TimeUnit)), "SECONDS")
 
     // should be limited to the current SourceUnit or propagated to the whole CompilationUnit
+    // DO NOT inline visitor creation in code below. It has state that must not persist between calls
     if (applyToAllClasses) {
       // guard every class and method defined in this script
       source.getAST()?.classes?.each { ClassNode it ->
-        // DO NOT inline this code. It has state that must not persist between calls
-        def visitor = new TimedInterruptionVisitor(source, checkOnMethodStart, applyToAllClasses, maximum, unit, thrown)
+        def visitor = new TimedInterruptionVisitor(source, checkOnMethodStart, applyToAllClasses, applyToAllMembers, maximum, unit, thrown, node.hashCode())
         visitor.visitClass(it)
       }
     } else if (annotatedNode instanceof ClassNode) {
       // only guard this particular class
-      // DO NOT inline this code. It has state that must not persist between calls
-      def visitor = new TimedInterruptionVisitor(source, checkOnMethodStart, applyToAllClasses, maximum, unit, thrown)
+      def visitor = new TimedInterruptionVisitor(source, checkOnMethodStart, applyToAllClasses, applyToAllMembers, maximum, unit, thrown, node.hashCode())
       visitor.visitClass annotatedNode
+    } else if (!applyToAllMembers && annotatedNode instanceof MethodNode) {
+      // only guard this particular method (plus initCode for class)
+      def visitor = new TimedInterruptionVisitor(source, checkOnMethodStart, applyToAllClasses, applyToAllMembers, maximum, unit, thrown, node.hashCode())
+      visitor.visitMethod annotatedNode
+      visitor.visitClass annotatedNode.declaringClass
+    } else if (!applyToAllMembers && annotatedNode instanceof FieldNode) {
+      // only guard this particular field (plus initCode for class)
+      def visitor = new TimedInterruptionVisitor(source, checkOnMethodStart, applyToAllClasses, applyToAllMembers, maximum, unit, thrown, node.hashCode())
+      visitor.visitField annotatedNode
+      visitor.visitClass annotatedNode.declaringClass
+    } else if (!applyToAllMembers && annotatedNode instanceof DeclarationExpression) {
+      // only guard this particular declaration (plus initCode for class)
+      def visitor = new TimedInterruptionVisitor(source, checkOnMethodStart, applyToAllClasses, applyToAllMembers, maximum, unit, thrown, node.hashCode())
+      visitor.visitDeclarationExpression annotatedNode
+      visitor.visitClass annotatedNode.declaringClass
     } else {
       // only guard the script class
       source.getAST()?.classes?.each { ClassNode it ->
         if (it.isScript()) {
-          // DO NOT inline this code. It has state that must not persist between calls
-          def visitor = new TimedInterruptionVisitor(source, checkOnMethodStart, applyToAllClasses, maximum, unit, thrown)
+          def visitor = new TimedInterruptionVisitor(source, checkOnMethodStart, applyToAllClasses, applyToAllMembers, maximum, unit, thrown, node.hashCode())
           visitor.visitClass(it)
         }
       }
@@ -96,9 +110,10 @@ public class TimedInterruptibleASTTransformation implements ASTTransformation {
     def member = node.getMember(parameterName)
     if (member) {
       if (member instanceof ConstantExpression) {
+        // TODO not sure this try offers value - testing Groovy annotation type handing - throw GroovyBugError or remove?
         try {
           return member.value.asType(type)
-        } catch (e) {
+        } catch (ignore) {
           internalError("Expecting boolean value for ${parameterName} annotation parameter. Found $member")
         }
       } else {
@@ -113,55 +128,53 @@ public class TimedInterruptibleASTTransformation implements ASTTransformation {
   }
 
   private static class TimedInterruptionVisitor extends ClassCodeVisitorSupport {
-
     final private SourceUnit source
     final private boolean checkOnMethodStart
     final private boolean applyToAllClasses
+    final private boolean applyToAllMembers
     private FieldNode expireTimeField = null
     private FieldNode startTimeField = null
     private final Expression unit
     private final maximum
     private final ClassNode thrown
+    private final String basename
 
-    TimedInterruptionVisitor(source, checkOnMethodStart, applyToAllClasses, maximum, unit, thrown) {
+    TimedInterruptionVisitor(source, checkOnMethodStart, applyToAllClasses, applyToAllMembers, maximum, unit, thrown, hash) {
       this.source = source
       this.checkOnMethodStart = checkOnMethodStart
       this.applyToAllClasses = applyToAllClasses
+      this.applyToAllMembers = applyToAllMembers
       this.unit = unit
       this.maximum = maximum
       this.thrown = thrown
+      this.basename = 'timedInterrupt' + hash
     }
 
     /**
      * @return Returns the interruption check statement.
      */
-    final def createInterruptStatement() {
-
+    final createInterruptStatement() {
       new IfStatement(
-              new BooleanExpression(
+          new BooleanExpression(
+              new BinaryExpression(
+                  new PropertyExpression(new VariableExpression("this"), basename + '$expireTime'),
+                  new Token(Types.COMPARE_LESS_THAN, '<', -1, -1),
+                  new StaticMethodCallExpression(ClassHelper.make(System), 'nanoTime', ArgumentListExpression.EMPTY_ARGUMENTS)
+              )
+          ),
+          new ThrowStatement(
+              new ConstructorCallExpression(thrown,
+                  new ArgumentListExpression(
                       new BinaryExpression(
-                              new PropertyExpression(new VariableExpression("this"), 'TimedInterrupt$expireTime'),
-                              new Token(Types.COMPARE_LESS_THAN, '<', -1, -1),
-                              new StaticMethodCallExpression(
-                                      ClassHelper.make(System),
-                                      'nanoTime',
-                                      ArgumentListExpression.EMPTY_ARGUMENTS)
+                          new ConstantExpression('Execution timed out after ' + maximum + ' units. Start time: '),
+                          new Token(Types.PLUS, '+', -1, -1),
+                          new PropertyExpression(new VariableExpression("this"), basename + '$startTime'),
                       )
-              ),
-              new ThrowStatement(
-                      new ConstructorCallExpression(thrown,
-                              new ArgumentListExpression(
-                                      new BinaryExpression(
-                                              new ConstantExpression(
-                                                      'Execution timed out after ' + maximum + ' units. Start time: '),
-                                              new Token(Types.PLUS, '+', -1, -1),
-                                              new PropertyExpression(new VariableExpression("this"), 'TimedInterrupt$startTime'),
-                                      )
 
-                              )
-                      )
-              ),
-              EmptyStatement.INSTANCE
+                  )
+              )
+          ),
+          EmptyStatement.INSTANCE
       )
     }
 
@@ -171,7 +184,7 @@ public class TimedInterruptibleASTTransformation implements ASTTransformation {
      * @return a {@link BlockStatement block statement}    which first element is for checking interruption, and the
      * second one the statement to be wrapped.
      */
-    private def wrapBlock(statement) {
+    private wrapBlock(statement) {
       def stmt = new BlockStatement();
       stmt.addStatement(createInterruptStatement());
       stmt.addStatement(statement);
@@ -180,31 +193,27 @@ public class TimedInterruptibleASTTransformation implements ASTTransformation {
 
     @Override
     void visitClass(ClassNode node) {
-
-      expireTimeField = node.addField('TimedInterrupt$expireTime',
-              Opcodes.ACC_FINAL | Opcodes.ACC_PRIVATE,
-              ClassHelper.long_TYPE,
-              new BinaryExpression(
-                      new StaticMethodCallExpression(ClassHelper.make(System), 'nanoTime', ArgumentListExpression.EMPTY_ARGUMENTS),
-                      new Token(Types.PLUS, '+', -1, -1),
-                      new MethodCallExpression(
-                              new PropertyExpression(
-                                      new ClassExpression(ClassHelper.make(TimeUnit)),
-                                      'NANOSECONDS'
-                              ),
-                              'convert',
-                              new ArgumentListExpression(
-                                      new ConstantExpression(maximum, true),
-                                      unit
-                              )
-                      )
+      if (node.getDeclaredField(basename + '$expireTime')) {
+        return
+      }
+      expireTimeField = node.addField(basename + '$expireTime',
+          Opcodes.ACC_FINAL | Opcodes.ACC_PRIVATE,
+          ClassHelper.long_TYPE,
+          new BinaryExpression(
+              new StaticMethodCallExpression(ClassHelper.make(System), 'nanoTime', ArgumentListExpression.EMPTY_ARGUMENTS),
+              new Token(Types.PLUS, '+', -1, -1),
+              new MethodCallExpression(
+                  new PropertyExpression(new ClassExpression(ClassHelper.make(TimeUnit)), 'NANOSECONDS'),
+                  'convert',
+                  new ArgumentListExpression(new ConstantExpression(maximum, true), unit)
               )
+          )
       );
       expireTimeField.synthetic = true
-      startTimeField = node.addField('TimedInterrupt$startTime',
-              Opcodes.ACC_FINAL | Opcodes.ACC_PRIVATE,
-              ClassHelper.make(Date),
-              new ConstructorCallExpression(ClassHelper.make(Date), ArgumentListExpression.EMPTY_ARGUMENTS)
+      startTimeField = node.addField(basename + '$startTime',
+          Opcodes.ACC_FINAL | Opcodes.ACC_PRIVATE,
+          ClassHelper.make(Date),
+          new ConstructorCallExpression(ClassHelper.make(Date), ArgumentListExpression.EMPTY_ARGUMENTS)
       )
       startTimeField.synthetic = true
 
@@ -213,11 +222,13 @@ public class TimedInterruptibleASTTransformation implements ASTTransformation {
       node.fields.remove(startTimeField)
       node.fields.add(0, startTimeField)
       node.fields.add(0, expireTimeField)
-      super.visitClass node
+      if (applyToAllMembers) {
+        super.visitClass node
+      }
     }
 
     @Override
-    public void visitClosureExpression(ClosureExpression closureExpr) {
+    void visitClosureExpression(ClosureExpression closureExpr) {
       def code = closureExpr.code
       if (code instanceof BlockStatement) {
         code.statements.add(0, createInterruptStatement())
@@ -245,31 +256,31 @@ public class TimedInterruptibleASTTransformation implements ASTTransformation {
      * Shortcut method which avoids duplicating code for every type of loop.
      * Actually wraps the loopBlock of different types of loop statements.
      */
-    private def visitLoop(loopStatement) {
+    private visitLoop(loopStatement) {
       def statement = loopStatement.loopBlock
       loopStatement.loopBlock = wrapBlock(statement)
     }
 
     @Override
-    public void visitForLoop(ForStatement forStatement) {
+    void visitForLoop(ForStatement forStatement) {
       visitLoop(forStatement)
       super.visitForLoop(forStatement)
     }
 
     @Override
-    public void visitDoWhileLoop(final DoWhileStatement doWhileStatement) {
+    void visitDoWhileLoop(final DoWhileStatement doWhileStatement) {
       visitLoop(doWhileStatement)
       super.visitDoWhileLoop(doWhileStatement)
     }
 
     @Override
-    public void visitWhileLoop(final WhileStatement whileStatement) {
+    void visitWhileLoop(final WhileStatement whileStatement) {
       visitLoop(whileStatement)
       super.visitWhileLoop(whileStatement)
     }
 
     @Override
-    public void visitMethod(MethodNode node) {
+    void visitMethod(MethodNode node) {
       if (checkOnMethodStart && !node.isSynthetic() && !node.isStatic() && !node.isAbstract()) {
         def code = node.code
         node.code = wrapBlock(code);
@@ -284,4 +295,3 @@ public class TimedInterruptibleASTTransformation implements ASTTransformation {
     }
   }
 }
-
diff --git a/src/test/groovy/transform/TimedInterruptTest.groovy b/src/test/groovy/transform/TimedInterruptTest.groovy
index 1e974a39f2..5b6d80d2c4 100644
--- a/src/test/groovy/transform/TimedInterruptTest.groovy
+++ b/src/test/groovy/transform/TimedInterruptTest.groovy
@@ -1,3 +1,18 @@
+/*
+ * Copyright 2008-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
 package groovy.transform
 
 import groovy.mock.interceptor.StubFor
@@ -10,464 +25,267 @@ import org.codehaus.groovy.transform.TimedInterruptibleASTTransformation
  */
 class TimedInterruptTest extends GroovyTestCase {
 
-    public void testClassMethodIsVisited() {
-
-        def c = new GroovyClassLoader().parseClass('''
-            import groovy.transform.TimedInterrupt
-            import java.util.concurrent.TimeUnit
-
-            @TimedInterrupt(value = 1L)
-            class MyClass {
-              def myMethod() { }
-            }
-        ''')
-
-        def system = new StubFor(System)
-
-        // start time initialized to the Long of the Beast
-        system.demand.nanoTime() { 666L }
-
-        def instance
-        system.use {
-            instance = c.newInstance()
-        }
-        assert instance.TimedInterrupt$expireTime == 1000000666L //one second in future
-
-        system.demand.nanoTime() { 1000000666L }
-        system.use {
-            instance.myMethod()
-        }
-
-        // one nanosecond later, but still in the neighborhood of the beast
-        system.demand.nanoTime() { 1000000667L }
-        system.use {
-            def e = shouldFail(TimeoutException) {
-                instance.myMethod()
-            }
-            assert e.contains('Execution timed out after 1 units')
-        }
+  void testClassMethodIsVisited() {
+    def c = new GroovyClassLoader().parseClass('''
+      import groovy.transform.TimedInterrupt
+      import java.util.concurrent.TimeUnit
+
+      @TimedInterrupt(value = 1L)
+      class MyClass {
+        def myMethod() { }
+      }
+    ''')
+    assertPassesNormalFailsSlowExecution(c)
+  }
+
+  void testClassMethodIsVisitedAndCustomExceptionThrown() {
+    def c = new GroovyClassLoader(this.class.classLoader).parseClass('''
+      import groovy.transform.TimedInterrupt
+      import java.util.concurrent.TimeUnit
+
+      @TimedInterrupt(thrown=groovy.transform.CustomException,value = 1L)
+      class MyClass {
+        def myMethod() { }
+      }
+    ''')
+    assertPassesNormalFailsSlowExecution(c, 1000000666L, '1', 'myMethod', CustomException)
+  }
+
+  void testScriptMethodIsVisited() {
+    def c = new GroovyClassLoader().parseClass('''
+      import groovy.transform.TimedInterrupt
+      import java.util.concurrent.TimeUnit
+
+      @TimedInterrupt(value = 1L)
+      def myMethod() { }
+    ''')
+    assertPassesNormalFailsSlowExecution(c)
+  }
+
+  void testStaticMethodIsNotVisited() {
+    def c = new GroovyClassLoader().parseClass('''
+      import groovy.transform.TimedInterrupt
+      import java.util.concurrent.TimeUnit
+
+      @TimedInterrupt(value = 1L)
+      class MyClass {
+        static def myMethod() { }
+      }
+    ''')
+    assertPassesSlowExecution(c)
+  }
+
+  void testClosureFieldIsVisited() {
+    def c = new GroovyClassLoader().parseClass('''
+      import groovy.transform.TimedInterrupt
+      import java.util.concurrent.TimeUnit
+
+      @TimedInterrupt(value = 1L)
+      class MyClass {
+        def myMethod = { }
+      }
+    ''')
+    assertPassesNormalFailsSlowExecution(c)
+  }
+
+  void testClosureInScriptIsVisited_CheckOnMethodStartIsFalse() {
+    def c = new GroovyClassLoader().parseClass('''
+      import groovy.transform.TimedInterrupt
+      import java.util.concurrent.TimeUnit
+
+      @TimedInterrupt(checkOnMethodStart = false, value = 1L)
+      def myMethod = { }
+      myMethod()
+    ''')
+    assertPassesNormalFailsSlowExecution(c, 1000000666L, '1', 'run')
+  }
+
+  void testWhileInScriptIsVisited_CheckOnMethodStartIsFalse() {
+    def c = new GroovyClassLoader().parseClass('''
+      @TimedInterrupt(checkOnMethodStart = false, value = 1L)
+      import groovy.transform.TimedInterrupt
+      import java.util.concurrent.TimeUnit
+
+      int x = 1
+      while (x < 2) { x = 2 }
+    ''')
+    assertPassesNormalFailsSlowExecution(c, 1000000666L, '1', 'run')
+  }
+
+  void testForInScriptIsVisited_CheckOnMethodStartIsFalse() {
+    def c = new GroovyClassLoader().parseClass('''
+      @TimedInterrupt(checkOnMethodStart = false, value = 1L)
+      import groovy.transform.TimedInterrupt
+      import java.util.concurrent.TimeUnit
+
+      def x = [1]
+      for (def o : x) { o++ }
+    ''')
+    assertPassesNormalFailsSlowExecution(c, 1000000666L, '1', 'run')
+  }
+
+  void testStaticClosureFieldNotVisited() {
+    def c = new GroovyClassLoader().parseClass('''
+      import groovy.transform.TimedInterrupt
+      import java.util.concurrent.TimeUnit
+
+      @TimedInterrupt(value = 1L)
+      class MyClass {
+        static def myMethod = { }
+      }
+    ''')
+    assertPassesSlowExecution(c)
+  }
+
+  void testAnnotationParameters() {
+    def c = new GroovyClassLoader().parseClass('''
+      import groovy.transform.TimedInterrupt
+      import java.util.concurrent.TimeUnit
+
+      @TimedInterrupt(value = 18000000L, unit = TimeUnit.MILLISECONDS)
+      def myMethod() { }
+    ''')
+    assertPassesNormalFailsSlowExecution(c, 18000000000666, '18000000') //5 hours in future
+  }
+
+  // TODO not sure all these tests are pulling their weight - testing Groovy annotation type handing not subject
+  void testErrorHandling() {
+    shouldFail(MultipleCompilationErrorsException) {
+      new GroovyClassLoader().parseClass('''
+        import groovy.transform.TimedInterrupt
+        @TimedInterrupt(value = "5")
+        def myMethod() { }
+      ''')
     }
 
-    public void testClassMethodIsVisitedAndCustomExceptionThrown() {
-
-        def c = new GroovyClassLoader(this.class.classLoader).parseClass('''
-            import groovy.transform.TimedInterrupt
-            import java.util.concurrent.TimeUnit
-
-            @TimedInterrupt(thrown=groovy.transform.CustomException,value = 1L)
-            class MyClass {
-              def myMethod() { }
-            }
-        ''')
-
-        def system = new StubFor(System)
-
-        // start time initialized to the Long of the Beast
-        system.demand.nanoTime() { 666L }
-
-        def instance
-        system.use {
-            instance = c.newInstance()
-        }
-        assert instance.TimedInterrupt$expireTime == 1000000666L //one second in future
-
-        system.demand.nanoTime() { 1000000666L }
-        system.use {
-            instance.myMethod()
-        }
-
-        // one nanosecond later, but still in the neighborhood of the beast
-        system.demand.nanoTime() { 1000000667L }
-        system.use {
-            def e = shouldFail(CustomException) {
-                instance.myMethod()
-            }
-            assert e.contains('Execution timed out after 1 units')
-        }
+    shouldFail(MultipleCompilationErrorsException) {
+      new GroovyClassLoader().parseClass('''
+        import groovy.transform.TimedInterrupt
+        @TimedInterrupt(value = foo())
+        def myMethod() { }
+      ''')
     }
 
-
-    public void testScriptMethodIsVisited() {
-
-        def c = new GroovyClassLoader().parseClass('''
-            import groovy.transform.TimedInterrupt
-            import java.util.concurrent.TimeUnit
-
-            @TimedInterrupt(value = 1L)
-            def myMethod() { }
-        ''')
-
-        def system = new StubFor(System)
-
-        // start time initialized to the Long of the Beast
-        system.demand.nanoTime() { 666L }
-
-        def instance
-        system.use {
-            instance = c.newInstance()
-        }
-        assert instance.TimedInterrupt$expireTime == 1000000666L //one second in future
-
-        system.demand.nanoTime() { 1000000666L }
-        system.use {
-            instance.myMethod()
-        }
-
-        // one nanosecond later, but still in the neighborhood of the beast
-        system.demand.nanoTime() { 1000000667L }
-        system.use {
-            def e = shouldFail(TimeoutException) {
-                instance.myMethod()
-            }
-            assert e.contains('Execution timed out after 1 units')
-        }
+    shouldFail(MultipleCompilationErrorsException) {
+      new GroovyClassLoader().parseClass('''
+        import groovy.transform.TimedInterrupt
+        @TimedInterrupt(value = 5L, applyToAllClasses = 5)
+        def myMethod() { }
+      ''')
     }
 
-
-    public void testStaticMethodIsNotVisited() {
-
-        def c = new GroovyClassLoader().parseClass('''
-            import groovy.transform.TimedInterrupt
-            import java.util.concurrent.TimeUnit
-
-            @TimedInterrupt(value = 1L)
-            class MyClass {
-              static def myMethod() { }
-            }
-        ''')
-
-        def system = new StubFor(System)
-
-        // start time initialized to the Long of the Beast
-        system.demand.nanoTime() { 666L }
-
-        def instance
-        system.use {
-            instance = c.newInstance()
-        }
-
-        // one nanosecond later, but still in the neighborhood of the beast
-        system.demand.nanoTime() { 1000000667L }
-        system.use {
-            instance.myMethod()
-        }
+    shouldFail(MultipleCompilationErrorsException) {
+      new GroovyClassLoader().parseClass('''
+        import groovy.transform.TimedInterrupt
+        @TimedInterrupt(value = 5L, applyToAllClasses = foo())
+        def myMethod() { }
+      ''')
     }
 
-    public void testClosureFieldIsVisited() {
-
-        def c = new GroovyClassLoader().parseClass('''
-            import groovy.transform.TimedInterrupt
-            import java.util.concurrent.TimeUnit
-
-            @TimedInterrupt(value = 1L)
-            class MyClass {
-              def myMethod = { }
-            }
-        ''')
-
-        def system = new StubFor(System)
-
-        // start time initialized to the Long of the Beast
-        system.demand.nanoTime() { 666L }
-
-        def instance
-        system.use {
-            instance = c.newInstance()
-        }
-        assert instance.TimedInterrupt$expireTime == 1000000666L //one second in future
-
-        system.demand.nanoTime() { 1000000666L }
-        system.use {
-            instance.myMethod()
-        }
-
-        // one nanosecond later, but still in the neighborhood of the beast
-        system.demand.nanoTime() { 1000000667L }
-        system.use {
-            def e = shouldFail(TimeoutException) {
-                instance.myMethod()
-            }
-            assert e.contains('Execution timed out after 1 units')
-        }
+    shouldFail(MultipleCompilationErrorsException) {
+      new GroovyClassLoader().parseClass('''
+        import groovy.transform.TimedInterrupt
+        @TimedInterrupt(value = 5L, checkOnMethodStart = 5)
+        def myMethod() { }
+      ''')
     }
 
-    public void testClosureInScriptIsVisited_CheckOnMethodStartIsFalse() {
-
-        def c = new GroovyClassLoader().parseClass('''
-            import groovy.transform.TimedInterrupt
-            import java.util.concurrent.TimeUnit
-
-            @TimedInterrupt(checkOnMethodStart = false, value = 1L)
-            def myMethod = {
-
-            }
-            myMethod()
-        ''')
-
-        def system = new StubFor(System)
-
-        // start time initialized to the Long of the Beast
-        system.demand.nanoTime() { 666L }
-
-        def instance
-        system.use {
-            instance = c.newInstance()
-        }
-        assert instance.TimedInterrupt$expireTime == 1000000666L //one second in future
-
-        system.demand.nanoTime() { 1000000666L }
-        system.use {
-            instance.run()
-        }
-
-        // one nanosecond later, but still in the neighborhood of the beast
-        system.demand.nanoTime() { 1000000667L }
-        system.use {
-            def e = shouldFail(TimeoutException) {
-                instance.run()
-            }
-            assert e.contains('Execution timed out after 1 units')
-        }
+    shouldFail(MultipleCompilationErrorsException) {
+      new GroovyClassLoader().parseClass('''
+        import groovy.transform.TimedInterrupt
+        @TimedInterrupt(value = 5L, checkOnMethodStart = foo())
+        def myMethod() { }
+      ''')
     }
 
-    public void testWhileInScriptIsVisited_CheckOnMethodStartIsFalse() {
-
-        def c = new GroovyClassLoader().parseClass('''
-            @TimedInterrupt(checkOnMethodStart = false, value = 1L)
-            import groovy.transform.TimedInterrupt
-            import java.util.concurrent.TimeUnit
-
-            int x = 1
-            while (x < 2) { x = 2 }
-        ''')
-
-        def system = new StubFor(System)
-
-        // start time initialized to the Long of the Beast
-        system.demand.nanoTime() { 666L }
-
-        def instance
-        system.use {
-            instance = c.newInstance()
-        }
-        assert instance.TimedInterrupt$expireTime == 1000000666L //one second in future
-
-        system.demand.nanoTime() { 1000000666L }
-        system.use {
-            instance.run()
-        }
-
-        // one nanosecond later, but still in the neighborhood of the beast
-        system.demand.nanoTime() { 1000000667L }
-        system.use {
-            def e = shouldFail(TimeoutException) {
-                instance.run()
-            }
-            assert e.contains('Execution timed out after 1 units')
-        }
+    shouldFail(MultipleCompilationErrorsException) {
+      new GroovyClassLoader().parseClass('''
+        import groovy.transform.TimedInterrupt
+        @TimedInterrupt(value = 5L, unit = 5)
+        def myMethod() { }
+      ''')
     }
 
-    public void testForInScriptIsVisited_CheckOnMethodStartIsFalse() {
-
-        def c = new GroovyClassLoader().parseClass('''
-            @TimedInterrupt(checkOnMethodStart = false, value = 1L)
-            import groovy.transform.TimedInterrupt
-            import java.util.concurrent.TimeUnit
-
-            def x = [1]
-            for (def o : x) { o++ }
-        ''')
-
-        def system = new StubFor(System)
-
-        // start time initialized to the Long of the Beast
-        system.demand.nanoTime() { 666L }
-
-        def instance
-        system.use {
-            instance = c.newInstance()
-        }
-        assert instance.TimedInterrupt$expireTime == 1000000666L //one second in future
-
-        system.demand.nanoTime() { 1000000666L }
-        system.use {
-            instance.run()
-        }
-
-        // one nanosecond later, but still in the neighborhood of the beast
-        system.demand.nanoTime() { 1000000667L }
-        system.use {
-            def e = shouldFail(TimeoutException) {
-                instance.run()
-            }
-            assert e.contains('Execution timed out after 1 units')
-        }
+    shouldFail(MultipleCompilationErrorsException) {
+      new GroovyClassLoader().parseClass('''
+        import groovy.transform.TimedInterrupt
+        @TimedInterrupt(value = 5L, unit = foo())
+        def myMethod() { }
+      ''')
     }
-
-    public void testStaticClosureFieldNotVisited() {
-
-        def c = new GroovyClassLoader().parseClass('''
-            import groovy.transform.TimedInterrupt
-            import java.util.concurrent.TimeUnit
-
-            @TimedInterrupt(value = 1L)
-            class MyClass {
-              static def myMethod = { }
-            }
-        ''')
-
-        def system = new StubFor(System)
-
-        // start time initialized to the Long of the Beast
-        system.demand.nanoTime() { 666L }
-
-        def instance
-        system.use {
-            instance = c.newInstance()
-        }
-
-        // one nanosecond later, but still in the neighborhood of the beast
-        system.demand.nanoTime() { 1000000667L }
-        system.use {
-            instance.myMethod()
-        }
+  }
+
+  void testTimedInterruptOnAbstractClass() {
+    def script = '''
+      @groovy.transform.TimedInterrupt(value = 1L)
+      abstract class MyAbstractClass {
+        abstract void myMethod()
+      }
+
+      class Concrete extends MyAbstractClass {
+        void myMethod() {
+          99.times {
+            // do something
+          }
+        }
+      }
+      new Concrete()
+    '''
+
+    def system = new StubFor(System)
+
+    // start time initialized to the Long of the Beast
+    system.demand.nanoTime(4) { 666L } // 2 times to cover full instantiation
+    system.demand.nanoTime() { 1000000667L }
+
+    system.use {
+      def instance = new GroovyShell(TimedInterruptibleASTTransformation.getClassLoader()).evaluate(script)
+      // may get false positives if multiple annotations with the same expireTime defined in test script
+      assert instance.dump().matches('.*timedInterrupt\\S+\\$expireTime=1000000666 .*')
+
+      shouldFail(TimeoutException) {
+        instance.myMethod()
+      }
     }
-
-    public void testAnnotationParameters() {
-
-        def c = new GroovyClassLoader().parseClass('''
-            import groovy.transform.TimedInterrupt
-            import java.util.concurrent.TimeUnit
-
-            @TimedInterrupt(value = 18000000L, unit = TimeUnit.MILLISECONDS)
-            def myMethod() { }
-        ''')
-
-        def system = new StubFor(System)
-
-        // start time initialized to the Long of the Beast
-        system.demand.nanoTime() { 666L }
-
-        def instance
-        system.use {
-            instance = c.newInstance()
-        }
-        assert instance.TimedInterrupt$expireTime == 18000000000666 //5 hours in future
-
-        system.demand.nanoTime() { 18000000000666L }
-        system.use {
-            instance.myMethod()
-        }
-
-        // one nanosecond later, but still in the neighborhood of the beast
-        system.demand.nanoTime() { 18000000000667L }
-        system.use {
-            def e = shouldFail(TimeoutException) {
-                instance.myMethod()
-            }
-            assert e.contains('Execution timed out after 18000000 units')
-        }
+  }
+
+  private void assertPassesNormalFailsSlowExecution(c, long expireTime=1000000666L, units='1', methodName='myMethod', exception=TimeoutException) {
+    def system = new StubFor(System)
+    // start time initialized to the Long of the Beast
+    system.demand.nanoTime() { 666L }
+    def instance
+    system.use {
+      instance = c.newInstance()
     }
+    // may get false positives if multiple annotations with the same expireTime defined in test script
+    assert instance.dump().matches('.*timedInterrupt\\S+\\$expireTime=' + expireTime + ' .*')
 
-    public void testErrorHandling() {
-        shouldFail(MultipleCompilationErrorsException) {
-            new GroovyClassLoader().parseClass('''
-                import groovy.transform.TimedInterrupt
-                @TimedInterrupt(value = "5")
-                def myMethod() { }
-            ''')
-        }
-
-        shouldFail(MultipleCompilationErrorsException) {
-            new GroovyClassLoader().parseClass('''
-                import groovy.transform.TimedInterrupt
-                @TimedInterrupt(value = foo())
-                def myMethod() { }
-            ''')
-        }
-
-        shouldFail(MultipleCompilationErrorsException) {
-            new GroovyClassLoader().parseClass('''
-                import groovy.transform.TimedInterrupt
-                @TimedInterrupt(value = 5L, applyToAllClasses = 5)
-                def myMethod() { }
-            ''')
-        }
-
-        shouldFail(MultipleCompilationErrorsException) {
-            new GroovyClassLoader().parseClass('''
-                import groovy.transform.TimedInterrupt
-                @TimedInterrupt(value = 5L, applyToAllClasses = foo())
-                def myMethod() { }
-            ''')
-        }
-
-        shouldFail(MultipleCompilationErrorsException) {
-            new GroovyClassLoader().parseClass('''
-                import groovy.transform.TimedInterrupt
-                @TimedInterrupt(value = 5L, checkOnMethodStart = 5)
-                def myMethod() { }
-            ''')
-        }
-
-        shouldFail(MultipleCompilationErrorsException) {
-            new GroovyClassLoader().parseClass('''
-                import groovy.transform.TimedInterrupt
-                @TimedInterrupt(value = 5L, checkOnMethodStart = foo())
-                def myMethod() { }
-            ''')
-        }
-
-        shouldFail(MultipleCompilationErrorsException) {
-            new GroovyClassLoader().parseClass('''
-                import groovy.transform.TimedInterrupt
-                @TimedInterrupt(value = 5L, unit = 5)
-                def myMethod() { }
-            ''')
-        }
-
-        shouldFail(MultipleCompilationErrorsException) {
-            new GroovyClassLoader().parseClass('''
-                import groovy.transform.TimedInterrupt
-                @TimedInterrupt(value = 5L, unit = foo())
-                def myMethod() { }
-            ''')
-        }
+    system.demand.nanoTime() { expireTime }
+    system.use {
+      instance."$methodName"()
     }
 
-    public void testTimedInterruptOnAbstractClass() {
-        def script = '''
-            @groovy.transform.TimedInterrupt(value = 1L)
-            abstract class MyAbstractClass {
-                abstract void myMethod()
-            }
-
-            class Concrete extends MyAbstractClass {
-                void myMethod() {
-                    99.times {
-                        // do something
-                    }
-                }
-            }
-
-            new Concrete()
-        '''
-
-        def system = new StubFor(System)
-
-        // start time initialized to the Long of the Beast
-        system.demand.nanoTime(4) { 666L } // 4 times to cover full instantiation
-
-        system.use {
-            def instance = new GroovyShell(TimedInterruptibleASTTransformation.getClassLoader()).evaluate(script)
-            assert instance.TimedInterrupt$expireTime == 1000000666L //5 hours in future
-            system.demand.nanoTime() { 1000000667L }
-
-            shouldFail(TimeoutException) {
-                instance.myMethod()
-            }
-        }
-
+    // one nanosecond too slow
+    system.demand.nanoTime() { expireTime + 1 }
+    system.use {
+      def e = shouldFail(exception) {
+        instance."$methodName"()
+      }
+      assert e.contains('Execution timed out after ' + units + ' units')
     }
-
+  }
+
+  private void assertPassesSlowExecution(c) {
+    def system = new StubFor(System)
+    // start time initialized to the Long of the Beast
+    system.demand.nanoTime() { 666L }
+    def instance
+    system.use {
+      instance = c.newInstance()
+    }
+    system.demand.nanoTime() { 1000000667L }
+    system.use {
+      instance.myMethod()
+    }
+  }
 }
