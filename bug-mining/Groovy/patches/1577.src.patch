diff --git a/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java b/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java
index 5d8025bf0b..ff682b0ae5 100644
--- a/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java
+++ b/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java
@@ -696,7 +696,7 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
                 // we have to handle an enum that defines a class for a constant
                 // for example the constant having overwriting a method. we need 
                 // to configure the inner class 
-                innerClass.setSuperClass(classNode);
+                innerClass.setSuperClass(classNode.getPlainNodeReference());
                 innerClass.setModifiers(classNode.getModifiers() | Opcodes.ACC_FINAL);
                 // we use a ClassExpression for transportation o EnumVisitor
                 init = new ClassExpression(innerClass);
diff --git a/src/main/org/codehaus/groovy/antlr/EnumHelper.java b/src/main/org/codehaus/groovy/antlr/EnumHelper.java
index d495e7740a..d09773614b 100644
--- a/src/main/org/codehaus/groovy/antlr/EnumHelper.java
+++ b/src/main/org/codehaus/groovy/antlr/EnumHelper.java
@@ -58,7 +58,7 @@ public class EnumHelper {
             list.addExpression(init);
             init = list;
         }
-        FieldNode fn = new FieldNode(name,modifiers,enumClass,enumClass,init);
+        FieldNode fn = new FieldNode(name,modifiers,enumClass.getPlainNodeReference(),enumClass,init);
         enumClass.addField(fn);
     }
 }
diff --git a/src/main/org/codehaus/groovy/ast/ClassHelper.java b/src/main/org/codehaus/groovy/ast/ClassHelper.java
index fb2e28caa4..8ae44c3843 100644
--- a/src/main/org/codehaus/groovy/ast/ClassHelper.java
+++ b/src/main/org/codehaus/groovy/ast/ClassHelper.java
@@ -337,7 +337,7 @@ public class ClassHelper {
     }
 
     public static ClassNode makeReference() {
-        return make(Reference.class);
+        return REFERENCE_TYPE.getPlainNodeReference();
     }
 
     public static boolean isCachedType(ClassNode type) {
diff --git a/src/main/org/codehaus/groovy/ast/ClassNode.java b/src/main/org/codehaus/groovy/ast/ClassNode.java
index 100d911686..35de19841d 100644
--- a/src/main/org/codehaus/groovy/ast/ClassNode.java
+++ b/src/main/org/codehaus/groovy/ast/ClassNode.java
@@ -33,8 +33,6 @@ import org.objectweb.asm.Opcodes;
 import java.lang.reflect.Array;
 import java.util.*;
 
-import groovy.lang.GroovyObject;
-
 /**
  * Represents a class in the AST.<br/>
  * A ClassNode should be created using the methods in ClassHelper.
@@ -1363,7 +1361,7 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
         if (ClassHelper.isPrimitiveType(this)) return this;
         ClassNode n = new ClassNode(getName(),getModifiers(),getSuperClass(),null,null);
         n.isPrimaryNode = false;
-        n.setRedirect(this.redirect);
+        n.setRedirect(redirect());
         n.componentType = redirect().getComponentType();
         return n;
     }
@@ -1437,4 +1435,8 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
         }
         return transformInstances;
     }
+    
+    public boolean isRedirectNode() {
+        return redirect!=null;
+    }
 }
diff --git a/src/main/org/codehaus/groovy/ast/expr/ClosureExpression.java b/src/main/org/codehaus/groovy/ast/expr/ClosureExpression.java
index d6b7a57279..6f8cb46f9c 100644
--- a/src/main/org/codehaus/groovy/ast/expr/ClosureExpression.java
+++ b/src/main/org/codehaus/groovy/ast/expr/ClosureExpression.java
@@ -36,7 +36,7 @@ public class ClosureExpression extends Expression {
     public ClosureExpression(Parameter[] parameters, Statement code) {
         this.parameters = parameters;
         this.code = code;
-        super.setType(ClassHelper.CLOSURE_TYPE);
+        super.setType(ClassHelper.CLOSURE_TYPE.getPlainNodeReference());
     }
     
     public void visit(GroovyCodeVisitor visitor) {
diff --git a/src/main/org/codehaus/groovy/ast/expr/MethodPointerExpression.java b/src/main/org/codehaus/groovy/ast/expr/MethodPointerExpression.java
index 3c6a0347e8..4c7ffde1ea 100644
--- a/src/main/org/codehaus/groovy/ast/expr/MethodPointerExpression.java
+++ b/src/main/org/codehaus/groovy/ast/expr/MethodPointerExpression.java
@@ -76,7 +76,7 @@ public class MethodPointerExpression extends Expression {
     }
 
     public ClassNode getType() {
-        return ClassHelper.CLOSURE_TYPE;
+        return ClassHelper.CLOSURE_TYPE.getPlainNodeReference();
     }
 
     public boolean isDynamic() {
diff --git a/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java b/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
index 4f336be9f4..8fa4ee3ae7 100644
--- a/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
+++ b/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
@@ -24,7 +24,6 @@ import org.codehaus.groovy.ast.expr.*;
 import org.codehaus.groovy.ast.stmt.*;
 import org.codehaus.groovy.classgen.asm.*;
 
-import org.codehaus.groovy.control.CompilerConfiguration;
 import org.codehaus.groovy.control.SourceUnit;
 import org.codehaus.groovy.runtime.MetaClassHelper;
 import org.codehaus.groovy.runtime.ScriptBytecodeAdapter;
@@ -1283,7 +1282,7 @@ public class AsmClassGenerator extends ClassGenerator {
         ClassNode icl =  controller.getInterfaceClassLoadingClass();
         addInnerClass(icl);
         for (String staticFieldName : referencedClasses.keySet()) {            // generate a field node
-            icl.addField(staticFieldName, ACC_STATIC + ACC_SYNTHETIC, ClassHelper.CLASS_Type, new ClassExpression(referencedClasses.get(staticFieldName)));
+            icl.addField(staticFieldName, ACC_STATIC + ACC_SYNTHETIC, ClassHelper.CLASS_Type.getPlainNodeReference(), new ClassExpression(referencedClasses.get(staticFieldName)));
         }
     }
 
@@ -1293,7 +1292,7 @@ public class AsmClassGenerator extends ClassGenerator {
             // generate a field node
             FieldNode fn = controller.getClassNode().getDeclaredField(staticFieldName);
             if (fn != null) {
-                boolean type = fn.getType() == ClassHelper.CLASS_Type;
+                boolean type = fn.getType().redirect() == ClassHelper.CLASS_Type;
                 boolean modifiers = fn.getModifiers() == ACC_STATIC + ACC_SYNTHETIC;
                 if (!type || !modifiers) {
                     String text = "";
diff --git a/src/main/org/codehaus/groovy/classgen/ClassCompletionVerifier.java b/src/main/org/codehaus/groovy/classgen/ClassCompletionVerifier.java
index 8faf838e62..2cf3f4843a 100644
--- a/src/main/org/codehaus/groovy/classgen/ClassCompletionVerifier.java
+++ b/src/main/org/codehaus/groovy/classgen/ClassCompletionVerifier.java
@@ -61,11 +61,13 @@ public class ClassCompletionVerifier extends ClassCodeVisitorSupport {
             checkMethodsForWeakerAccess(node);
             checkMethodsForOverridingFinal(node);
             checkNoAbstractMethodsNonabstractClass(node);
+            checkGenericsUsage(node, node.getUnresolvedInterfaces());
+            checkGenericsUsage(node, node.getUnresolvedSuperClass());
         }
         super.visitClass(node);
         currentClass = oldClass;
     }
-
+    
     private void checkInterfaceMethodVisibility(ClassNode node) {
         if (!node.isInterface()) return;
         for (MethodNode method : node.getMethods()) {
@@ -268,6 +270,8 @@ public class ClassCompletionVerifier extends ClassCodeVisitorSupport {
         checkRepetitiveMethod(node);
         checkOverloadingPrivateAndPublic(node);
         checkMethodModifiers(node);
+        checkGenericsUsage(node, node.getParameters());
+        checkGenericsUsage(node, node.getReturnType());
         super.visitMethod(node);
     }
 
@@ -342,11 +346,13 @@ public class ClassCompletionVerifier extends ClassCodeVisitorSupport {
             addError("The " + getDescription(node) + " is declared multiple times.", node);
         }
         checkInterfaceFieldModifiers(node);
+        checkGenericsUsage(node, node.getType());
         super.visitField(node);
     }
 
     public void visitProperty(PropertyNode node) {
         checkDuplicateProperties(node);
+        checkGenericsUsage(node, node.getType());
         super.visitProperty(node);
     }
 
@@ -442,6 +448,7 @@ public class ClassCompletionVerifier extends ClassCodeVisitorSupport {
     public void visitConstructor(ConstructorNode node) {
         inConstructor = true;
         inStaticConstructor = node.isStaticConstructor();
+        checkGenericsUsage(node, node.getParameters());
         super.visitConstructor(node);
     }
 
@@ -514,4 +521,51 @@ public class ClassCompletionVerifier extends ClassCodeVisitorSupport {
         }
     }
 
+    private void checkGenericsUsage(ASTNode ref, ClassNode[] nodes) {
+        for (ClassNode node : nodes) {
+            checkGenericsUsage(ref, node);
+        }
+    }
+    
+    private void checkGenericsUsage(ASTNode ref, Parameter[] params) {
+        for (Parameter p : params) {
+            checkGenericsUsage(ref, p.getType());
+        }
+    }
+    
+    private void checkGenericsUsage(ASTNode ref, ClassNode node) {
+        if (node.isArray()) {
+            checkGenericsUsage(ref, node.getComponentType());
+        } else if (!node.isRedirectNode() && node.isUsingGenerics()) {
+            addError(   
+                    "A transform used a generics containing ClassNode "+ node + " " +
+                    "for "+getRefDescriptor(ref) + 
+                    "directly. You are not suppposed to do this. " +
+                    "Please create a new ClassNode refering to the old ClassNode " +
+                    "and use the new ClassNode instead of the old one. Otherwise " +
+                    "the compiler will create wrong descriptors and potential " +
+                    "NullPointerException in TypeResolver in OpenJDK. If this is " +
+                    "not your own doing, please report this bug to the writer of the" +
+                    "transform.",
+                    ref);
+        }
+    }
+
+    private String getRefDescriptor(ASTNode ref) {
+        if (ref instanceof FieldNode) {
+            FieldNode f = (FieldNode) ref;
+            return "the field "+f.getName()+" ";
+        } else if (ref instanceof PropertyNode) {
+            PropertyNode p = (PropertyNode) ref;
+            return "the property "+p.getName()+" ";
+        } else if (ref instanceof ConstructorNode) {
+            return "the constructor "+ref.getText()+" ";
+        } else if (ref instanceof MethodNode) {
+            return "the method "+ref.getText()+" ";
+        } else if (ref instanceof ClassNode) {
+            return "the super class "+ref+" ";
+        }
+        return "<unknown with class "+ref.getClass()+"> ";
+    }
+
 }
diff --git a/src/main/org/codehaus/groovy/classgen/EnumVisitor.java b/src/main/org/codehaus/groovy/classgen/EnumVisitor.java
index f3cc62a975..e5bfbed341 100644
--- a/src/main/org/codehaus/groovy/classgen/EnumVisitor.java
+++ b/src/main/org/codehaus/groovy/classgen/EnumVisitor.java
@@ -69,15 +69,17 @@ public class EnumVisitor extends ClassCodeVisitorSupport{
         FieldNode minValue = null, maxValue = null, values = null;
        
         if(!isAic) {
+            ClassNode enumRef = enumClass.getPlainNodeReference();
+            
             // create values field
-            values = new FieldNode("$VALUES",PRIVATE_FS|Opcodes.ACC_SYNTHETIC,enumClass.makeArray(),enumClass,null);
+            values = new FieldNode("$VALUES",PRIVATE_FS|Opcodes.ACC_SYNTHETIC,enumRef.makeArray(),enumClass,null);
             values.setSynthetic(true);
             
             addMethods(enumClass, values);
             
             // create MIN_VALUE and MAX_VALUE fields
-            minValue = new FieldNode("MIN_VALUE", PUBLIC_FS, enumClass, enumClass, null);
-            maxValue = new FieldNode("MAX_VALUE", PUBLIC_FS, enumClass, enumClass, null);
+            minValue = new FieldNode("MIN_VALUE", PUBLIC_FS, enumRef, enumClass, null);
+            maxValue = new FieldNode("MAX_VALUE", PUBLIC_FS, enumRef, enumClass, null);
 
         }
         addInit(enumClass, minValue, maxValue, values, isAic);
@@ -94,10 +96,12 @@ public class EnumVisitor extends ClassCodeVisitorSupport{
             if (m.getName().equals("previous") && m.getParameters().length == 0) hasPrevious = true;
             if (hasNext && hasPrevious) break;
         }
+        
+        ClassNode enumRef = enumClass.getPlainNodeReference();
 
         {
             // create values() method
-            MethodNode valuesMethod = new MethodNode("values",PUBLIC_FS,enumClass.makeArray(),new Parameter[0],ClassNode.EMPTY_ARRAY,null);
+            MethodNode valuesMethod = new MethodNode("values",PUBLIC_FS,enumRef.makeArray(),new Parameter[0],ClassNode.EMPTY_ARRAY,null);
             valuesMethod.setSynthetic(true);
             BlockStatement code = new BlockStatement();
             MethodCallExpression cloneCall = new MethodCallExpression(new FieldExpression(values), "clone", MethodCallExpression.NO_ARGUMENTS);
@@ -116,7 +120,7 @@ public class EnumVisitor extends ClassCodeVisitorSupport{
             //     }
             Token assign = Token.newSymbol(Types.ASSIGN, -1, -1);
             Token ge = Token.newSymbol(Types.COMPARE_GREATER_THAN_EQUAL, -1, -1);
-            MethodNode nextMethod = new MethodNode("next", Opcodes.ACC_PUBLIC | Opcodes.ACC_SYNTHETIC, enumClass, new Parameter[0], ClassNode.EMPTY_ARRAY, null);
+            MethodNode nextMethod = new MethodNode("next", Opcodes.ACC_PUBLIC | Opcodes.ACC_SYNTHETIC, enumRef, new Parameter[0], ClassNode.EMPTY_ARRAY, null);
             nextMethod.setSynthetic(true);
             BlockStatement code = new BlockStatement();
             BlockStatement ifStatement = new BlockStatement();
@@ -175,7 +179,7 @@ public class EnumVisitor extends ClassCodeVisitorSupport{
             //    }
             Token assign = Token.newSymbol(Types.ASSIGN, -1, -1);
             Token lt = Token.newSymbol(Types.COMPARE_LESS_THAN, -1, -1);
-            MethodNode nextMethod = new MethodNode("previous", Opcodes.ACC_PUBLIC | Opcodes.ACC_SYNTHETIC, enumClass, new Parameter[0], ClassNode.EMPTY_ARRAY, null);
+            MethodNode nextMethod = new MethodNode("previous", Opcodes.ACC_PUBLIC | Opcodes.ACC_SYNTHETIC, enumRef, new Parameter[0], ClassNode.EMPTY_ARRAY, null);
             nextMethod.setSynthetic(true);
             BlockStatement code = new BlockStatement();
             BlockStatement ifStatement = new BlockStatement();
@@ -230,11 +234,11 @@ public class EnumVisitor extends ClassCodeVisitorSupport{
             nextMethod.setCode(code);
             enumClass.addMethod(nextMethod);
         }
-
+        
         {
             // create valueOf
             Parameter stringParameter = new Parameter(ClassHelper.STRING_TYPE,"name");
-            MethodNode valueOfMethod = new MethodNode("valueOf",PS,enumClass,new Parameter[]{stringParameter},ClassNode.EMPTY_ARRAY,null);
+            MethodNode valueOfMethod = new MethodNode("valueOf",PS,enumRef,new Parameter[]{stringParameter},ClassNode.EMPTY_ARRAY,null);
             ArgumentListExpression callArguments = new ArgumentListExpression();
             callArguments.addExpression(new ClassExpression(enumClass));
             callArguments.addExpression(new VariableExpression("name"));
@@ -266,9 +270,10 @@ public class EnumVisitor extends ClassCodeVisitorSupport{
         // code:
         // def $INIT(Object[] para) {
         //  return this(*para)
-        // }            
+        // }
+        ClassNode enumRef = enumClass.getPlainNodeReference();
         Parameter[] parameter = new Parameter[]{new Parameter(ClassHelper.OBJECT_TYPE.makeArray(), "para")};
-        MethodNode initMethod = new MethodNode("$INIT",PUBLIC_FS | Opcodes.ACC_SYNTHETIC,enumClass,parameter,ClassNode.EMPTY_ARRAY,null);
+        MethodNode initMethod = new MethodNode("$INIT",PUBLIC_FS | Opcodes.ACC_SYNTHETIC,enumRef,parameter,ClassNode.EMPTY_ARRAY,null);
         initMethod.setSynthetic(true);
         ConstructorCallExpression cce = new ConstructorCallExpression(
                 ClassNode.THIS,
diff --git a/src/main/org/codehaus/groovy/classgen/InnerClassVisitor.java b/src/main/org/codehaus/groovy/classgen/InnerClassVisitor.java
index b92ae7825f..6702caf596 100644
--- a/src/main/org/codehaus/groovy/classgen/InnerClassVisitor.java
+++ b/src/main/org/codehaus/groovy/classgen/InnerClassVisitor.java
@@ -64,7 +64,7 @@ public class InnerClassVisitor extends InnerClassVisitorHelper implements Opcode
                 node instanceof InnerClassNode) {
             innerClass = (InnerClassNode) node;
             if (!isStatic(innerClass) && innerClass.getVariableScope() == null) {
-                thisField = innerClass.addField("this$0", PUBLIC_SYNTHETIC, node.getOuterClass(), null);
+                thisField = innerClass.addField("this$0", PUBLIC_SYNTHETIC, node.getOuterClass().getPlainNodeReference(), null);
             }
 
             if (innerClass.getVariableScope() == null &&
@@ -122,7 +122,7 @@ public class InnerClassVisitor extends InnerClassVisitorHelper implements Opcode
         Parameter[] params = node.getParameters();
         Parameter[] newParams = new Parameter[params.length + 1];
         System.arraycopy(params, 0, newParams, 1, params.length);
-        Parameter thisPara = new Parameter(classNode.getOuterClass(), getUniqueName(params, node));
+        Parameter thisPara = new Parameter(classNode.getOuterClass().getPlainNodeReference(), getUniqueName(params, node));
         newParams[0] = thisPara;
         node.setParameters(newParams);
 
@@ -281,7 +281,7 @@ public class InnerClassVisitor extends InnerClassVisitorHelper implements Opcode
         // this is saved in a field named this$0
         pCount = 0;
         expressions.add(pCount, VariableExpression.THIS_EXPRESSION);
-        ClassNode outerClassType = getClassNode(innerClass.getOuterClass(), isStatic);
+        ClassNode outerClassType = getClassNode(innerClass.getOuterClass(), isStatic).getPlainNodeReference();
         Parameter thisParameter = new Parameter(outerClassType, "p" + pCount);
         parameters.add(pCount, thisParameter);
 
diff --git a/src/main/org/codehaus/groovy/classgen/asm/ClosureWriter.java b/src/main/org/codehaus/groovy/classgen/asm/ClosureWriter.java
index e44e7a0ce4..31a994cf5e 100644
--- a/src/main/org/codehaus/groovy/classgen/asm/ClosureWriter.java
+++ b/src/main/org/codehaus/groovy/classgen/asm/ClosureWriter.java
@@ -181,7 +181,7 @@ public class ClosureWriter {
         Parameter[] localVariableParams = getClosureSharedVariables(expression);
         removeInitialValues(localVariableParams);
 
-        InnerClassNode answer = new InnerClassNode(classNode, name, mods, ClassHelper.CLOSURE_TYPE); // closures are local inners and not public
+        InnerClassNode answer = new InnerClassNode(classNode, name, mods, ClassHelper.CLOSURE_TYPE.getPlainNodeReference()); 
         answer.setEnclosingMethod(controller.getMethodNode());
         answer.setSynthetic(true);
         answer.setUsingGenerics(outerClass.isUsingGenerics());
diff --git a/src/main/org/codehaus/groovy/transform/SingletonASTTransformation.java b/src/main/org/codehaus/groovy/transform/SingletonASTTransformation.java
index b2e79ca1ad..cb0cc60849 100644
--- a/src/main/org/codehaus/groovy/transform/SingletonASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/SingletonASTTransformation.java
@@ -64,16 +64,16 @@ public class SingletonASTTransformation implements ASTTransformation, Opcodes {
     }
 
     private void createNonLazy(ClassNode classNode) {
-        final FieldNode fieldNode = classNode.addField("instance", ACC_PUBLIC|ACC_FINAL|ACC_STATIC, classNode, new ConstructorCallExpression(classNode, new ArgumentListExpression()));
+        final FieldNode fieldNode = classNode.addField("instance", ACC_PUBLIC|ACC_FINAL|ACC_STATIC, classNode.getPlainNodeReference(), new ConstructorCallExpression(classNode, new ArgumentListExpression()));
         createConstructor(classNode, fieldNode);
 
         final BlockStatement body = new BlockStatement();
         body.addStatement(new ReturnStatement(new VariableExpression(fieldNode)));
-        classNode.addMethod("getInstance", ACC_STATIC|ACC_PUBLIC, classNode, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, body);
+        classNode.addMethod("getInstance", ACC_STATIC|ACC_PUBLIC, classNode.getPlainNodeReference(), Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, body);
     }
 
     private void createLazy(ClassNode classNode) {
-        final FieldNode fieldNode = classNode.addField("instance", ACC_PRIVATE|ACC_STATIC|ACC_VOLATILE, classNode, null);
+        final FieldNode fieldNode = classNode.addField("instance", ACC_PRIVATE|ACC_STATIC|ACC_VOLATILE, classNode.getPlainNodeReference(), null);
         createConstructor(classNode, fieldNode);
 
         final BlockStatement body = new BlockStatement();
@@ -90,7 +90,7 @@ public class SingletonASTTransformation implements ASTTransformation, Opcodes {
                     )
             )
         ));
-        classNode.addMethod("getInstance", ACC_STATIC|ACC_PUBLIC, classNode, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, body);
+        classNode.addMethod("getInstance", ACC_STATIC|ACC_PUBLIC, classNode.getPlainNodeReference(), Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, body);
     }
 
     private void createConstructor(ClassNode classNode, FieldNode field) {
