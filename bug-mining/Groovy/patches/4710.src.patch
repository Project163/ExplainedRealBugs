diff --git a/src/main/java/org/codehaus/groovy/classgen/asm/sc/AbstractFunctionalInterfaceWriter.java b/src/main/java/org/codehaus/groovy/classgen/asm/sc/AbstractFunctionalInterfaceWriter.java
index df110a1abb..8359e9e1b2 100644
--- a/src/main/java/org/codehaus/groovy/classgen/asm/sc/AbstractFunctionalInterfaceWriter.java
+++ b/src/main/java/org/codehaus/groovy/classgen/asm/sc/AbstractFunctionalInterfaceWriter.java
@@ -72,10 +72,39 @@ public interface AbstractFunctionalInterfaceWriter {
     }
 
     default Object[] createBootstrapMethodArguments(final String abstractMethodDesc, final int insn, final ClassNode methodOwner, final MethodNode methodNode, final Parameter[] parameters, final boolean serializable) {
-        ClassNode returnType = !abstractMethodDesc.endsWith(")V") ? methodNode.getReturnType() : ClassHelper.VOID_TYPE; // GROOVY-10933
+        ClassNode returnType = methodNode.getReturnType();
+        switch (Type.getReturnType(abstractMethodDesc).getSort()) {
+          case Type.BOOLEAN:
+            if (returnType.isGenericsPlaceHolder()) returnType = ClassHelper.Boolean_TYPE; // GROOVY-10975
+            break;
+          case Type.BYTE:
+            if (returnType.isGenericsPlaceHolder()) returnType = ClassHelper.Byte_TYPE;
+            break;
+          case Type.CHAR:
+            if (returnType.isGenericsPlaceHolder()) returnType = ClassHelper.Character_TYPE;
+            break;
+          case Type.DOUBLE:
+            if (returnType.isGenericsPlaceHolder()) returnType = ClassHelper.Double_TYPE;
+            break;
+          case Type.FLOAT:
+            if (returnType.isGenericsPlaceHolder()) returnType = ClassHelper.Float_TYPE;
+            break;
+          case Type.INT:
+            if (returnType.isGenericsPlaceHolder()) returnType = ClassHelper.Integer_TYPE;
+            break;
+          case Type.LONG:
+            if (returnType.isGenericsPlaceHolder()) returnType = ClassHelper.Long_TYPE;
+            break;
+          case Type.SHORT:
+            if (returnType.isGenericsPlaceHolder()) returnType = ClassHelper.Short_TYPE;
+            break;
+          case Type.VOID:
+            returnType = ClassHelper.VOID_TYPE; // GROOVY-10933
+        }
+
         Object[] arguments = !serializable ? new Object[3] : new Object[]{null, null, null, 5, 0};
 
-        arguments[0] = Type.getType(abstractMethodDesc);
+        arguments[0] = Type.getMethodType(abstractMethodDesc);
 
         arguments[1] = new Handle(
                 insn, // H_INVOKESTATIC or H_INVOKEVIRTUAL or H_INVOKEINTERFACE (GROOVY-9853)
@@ -84,7 +113,7 @@ public interface AbstractFunctionalInterfaceWriter {
                 getMethodDescriptor(methodNode),
                 methodOwner.isInterface());
 
-        arguments[2] = Type.getType(getMethodDescriptor(returnType, parameters));
+        arguments[2] = Type.getMethodType(getMethodDescriptor(returnType, parameters));
 
         return arguments;
     }
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 50d127b3f4..72b3635bef 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -5391,9 +5391,10 @@ out:                if (mn.size() != 1) {
                             } else { // argument instanceof MethodPointerExpression
                                 List<MethodNode> candidates = argument.getNodeMetaData(MethodNode.class);
                                 if (candidates != null && !candidates.isEmpty()) {
-                                    MethodPointerExpression methodPointer = (MethodPointerExpression) argument;
-                                    p = collateMethodReferenceParameterTypes(methodPointer, candidates.get(0));
-                                    if (p.length > 0) {
+                                    var methodPointer = (MethodPointerExpression) argument;
+                                    p = methodPointer.getNodeMetaData(CLOSURE_ARGUMENTS); // GROOVY-10975
+                                    if (p == null) p = collateMethodReferenceParameterTypes(methodPointer, candidates.get(0));
+                                    if (p.length > 0 && GenericsUtils.hasUnresolvedGenerics(returnType)) {
                                         for (int j = 0; j < q.length; j += 1) {
                                             // SAM parameters are like arguments in this case
                                             extractGenericsConnections(connections, q[j], p[j]);
diff --git a/src/test/groovy/transform/stc/MethodReferenceTest.groovy b/src/test/groovy/transform/stc/MethodReferenceTest.groovy
index 58ecb3dbe6..ea9ad8ba7a 100644
--- a/src/test/groovy/transform/stc/MethodReferenceTest.groovy
+++ b/src/test/groovy/transform/stc/MethodReferenceTest.groovy
@@ -531,6 +531,20 @@ final class MethodReferenceTest {
         '''
     }
 
+    @Test // instance::instanceMethod -- GROOVY-10975
+    void testComparatorII() {
+        assertScript shell, '''
+            @CompileStatic
+            void test() {
+                Collection<Integer> c = [1]
+                Map<Integer,Integer> m = [1:1]
+                new Hashtable(Collections.min(c, m::put))
+            }
+
+            test()
+        '''
+    }
+
     @Test // instance::instanceMethod -- GROOVY-11026
     void testBiFunctionII() {
         assertScript shell, '''
