diff --git a/src/main/org/codehaus/groovy/ast/tools/GenericsUtils.java b/src/main/org/codehaus/groovy/ast/tools/GenericsUtils.java
index fca8515f77..64d2e405a5 100644
--- a/src/main/org/codehaus/groovy/ast/tools/GenericsUtils.java
+++ b/src/main/org/codehaus/groovy/ast/tools/GenericsUtils.java
@@ -272,7 +272,7 @@ public class GenericsUtils {
         return makeClassSafe0(type, gtypes);
     }
 
-    public static MethodNode correctToGenericsSpec(Map genericsSpec, MethodNode mn) {
+    public static MethodNode correctToGenericsSpec(Map<String,ClassNode> genericsSpec, MethodNode mn) {
         ClassNode correctedType = correctToGenericsSpecRecurse(genericsSpec, mn.getReturnType());
         Parameter[] origParameters = mn.getParameters();
         Parameter[] newParameters = new Parameter[origParameters.length];
@@ -283,10 +283,10 @@ public class GenericsUtils {
         return new MethodNode(mn.getName(), mn.getModifiers(), correctedType, newParameters, mn.getExceptions(), mn.getCode());
     }
 
-    public static ClassNode correctToGenericsSpecRecurse(Map genericsSpec, ClassNode type) {
+    public static ClassNode correctToGenericsSpecRecurse(Map<String,ClassNode> genericsSpec, ClassNode type) {
         if (type.isGenericsPlaceHolder()) {
-            String name = type.getUnresolvedName();
-            type = (ClassNode) genericsSpec.get(name);
+            String name = type.getGenericsTypes()[0].getName();
+            type = genericsSpec.get(name);
         }
         if (type == null) type = ClassHelper.OBJECT_TYPE;
         GenericsType[] oldgTypes = type.getGenericsTypes();
@@ -297,7 +297,7 @@ public class GenericsUtils {
                 GenericsType oldgType = oldgTypes[i];
                 if (oldgType.isPlaceholder() ) {
                     if (genericsSpec.get(oldgType.getName())!=null) {
-                        newgTypes[i] = new GenericsType((ClassNode) genericsSpec.get(oldgType.getName()));
+                        newgTypes[i] = new GenericsType(genericsSpec.get(oldgType.getName()));
                     } else {
                         newgTypes[i] = new GenericsType(ClassHelper.OBJECT_TYPE);
                     }
@@ -323,27 +323,27 @@ public class GenericsUtils {
         return makeClassSafeWithGenerics(type, newgTypes);
     }
 
-    public static ClassNode correctToGenericsSpec(Map genericsSpec, GenericsType type) {
+    public static ClassNode correctToGenericsSpec(Map<String, ClassNode> genericsSpec, GenericsType type) {
         ClassNode ret = null;
         if (type.isPlaceholder()) {
             String name = type.getName();
-            ret = (ClassNode) genericsSpec.get(name);
+            ret = genericsSpec.get(name);
         }
         if (ret == null) ret = type.getType();
         return ret;
     }
 
-    public static ClassNode correctToGenericsSpec(Map genericsSpec, ClassNode type) {
+    public static ClassNode correctToGenericsSpec(Map<String,ClassNode> genericsSpec, ClassNode type) {
         if (type.isGenericsPlaceHolder()) {
             String name = type.getGenericsTypes()[0].getName();
-            type = (ClassNode) genericsSpec.get(name);
+            type = genericsSpec.get(name);
         }
         if (type == null) type = ClassHelper.OBJECT_TYPE;
         return type;
     }
 
-    public static Map createGenericsSpec(ClassNode current, Map oldSpec) {
-        Map ret = new HashMap(oldSpec);
+    public static Map<String,ClassNode> createGenericsSpec(ClassNode current, Map<String,ClassNode> oldSpec) {
+        Map<String,ClassNode> ret = new HashMap<String,ClassNode>(oldSpec);
         // ret contains the type specs, what we now need is the type spec for the
         // current class. To get that we first apply the type parameters to the
         // current class and then use the type names of the current class to reset
diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
index d59f9b759b..448a67d424 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
@@ -637,11 +637,6 @@ public abstract class StaticTypeCheckingSupport {
             return true;
         }
 
-        //SAM check
-        if (rightRedirect.isDerivedFrom(CLOSURE_TYPE) && isSAMType(leftRedirect)) {
-            return true;
-        }
-
         return false;
     }
 
@@ -1242,7 +1237,8 @@ public abstract class StaticTypeCheckingSupport {
         if (parameterType.isUsingGenerics() && argumentType.isUsingGenerics()) {
             GenericsType gt = GenericsUtils.buildWildcardType(parameterType);
             if (!gt.isCompatibleWith(argumentType)) {
-                return false;
+                boolean samCoercion = isSAMType(parameterType) && argumentType.equals(CLOSURE_TYPE);
+                if (!samCoercion) return false;
             }
         } else if (parameterType.isArray() && argumentType.isArray()) {
             // verify component type
@@ -1402,86 +1398,208 @@ public abstract class StaticTypeCheckingSupport {
         }
         return !failure;
     }
-
-    public static ClassNode resolveClassNodeGenerics(final Map<String, GenericsType> resolvedPlaceholders, final Map<String, GenericsType> placeholdersFromContext, ClassNode currentType) {
+    
+    public static ClassNode resolveClassNodeGenerics(Map<String, GenericsType> resolvedPlaceholders, final Map<String, GenericsType> placeholdersFromContext, ClassNode currentType) {
+        ClassNode target = currentType.redirect();
+        resolvedPlaceholders = new HashMap<String, GenericsType>(resolvedPlaceholders);
         applyContextGenerics(resolvedPlaceholders,placeholdersFromContext);
-        currentType = applyGenerics(currentType, resolvedPlaceholders);
 
-        // GROOVY-5748
-        if (currentType.isGenericsPlaceHolder()) {
-            GenericsType resolved = resolvedPlaceholders.get(currentType.getUnresolvedName());
-            if (resolved!=null && !resolved.isPlaceholder() && !resolved.isWildcard()) {
-                return resolved.getType();
+        Map<String, GenericsType> connections  = new HashMap<String, GenericsType>();
+        extractGenericsConnections(connections, currentType,target);
+        applyGenericsConnections(connections, resolvedPlaceholders);
+        currentType = applyGenericsContext(resolvedPlaceholders, currentType);
+        return currentType;
+    }
+
+    static void applyGenericsConnections(
+            Map<String, GenericsType> connections,
+            Map<String, GenericsType> resolvedPlaceholders
+    ) {
+        if (connections==null) return;
+        int count = 0;
+        while (count<10000) {
+            count++;
+            boolean checkForMorePlaceHolders=false;
+            for (Map.Entry<String, GenericsType> entry: resolvedPlaceholders.entrySet()){
+                String name = entry.getKey();
+                GenericsType replacement = connections.get(name);
+                if (replacement==null) {
+                    GenericsType value = entry.getValue();
+                    GenericsType newValue = applyGenericsContext(connections, value);
+                    entry.setValue(newValue);
+                    checkForMorePlaceHolders = checkForMorePlaceHolders || !equalIncludingGenerics(value,newValue);
+                    continue;
+                }
+                GenericsType original = entry.getValue(); 
+                if (!original.isWildcard() && !original.isPlaceholder()) {
+                    continue;
+                } else if (!replacement.isPlaceholder()) {
+                    entry.setValue(replacement);
+                    continue;
+                }
+                GenericsType connectedType = resolvedPlaceholders.get(replacement.getName());
+                if (replacement==connectedType) continue;
+                //TODO: connectedType==null should not happen
+                if (connectedType==null) {
+                    continue;
+                } else {
+                    entry.setValue(replacement);
+                    checkForMorePlaceHolders = checkForMorePlaceHolders || !equalIncludingGenerics(original,replacement);
+                }
             }
+            if (!checkForMorePlaceHolders) break;
+        }
+        if  (count>=10000) throw new GroovyBugError("unable to handle generics in "+resolvedPlaceholders+" with connections "+connections);
+    }
+
+    private static boolean equalIncludingGenerics(GenericsType orig, GenericsType copy) {
+        if (orig==copy) return true;
+        if (orig.isPlaceholder()!=copy.isPlaceholder()) return false;
+        if (orig.isWildcard()!=copy.isWildcard()) return false;
+        if (!equalIncludingGenerics(orig.getType(), copy.getType())) return false;
+        ClassNode lower1 = orig.getLowerBound();
+        ClassNode lower2 = copy.getLowerBound();
+        if ((lower1==null || lower2 ==null) && lower1!=lower2) return false;
+        if (lower1==lower2) return true;
+        if (!equalIncludingGenerics(lower1,lower2)) return false;
+        ClassNode[] upper1 = orig.getUpperBounds();
+        ClassNode[] upper2 = copy.getUpperBounds();
+        if ((upper1==null || upper2==null) && upper1!=upper2) return false;
+        if (upper1==upper2) return true;
+        if (upper1.length!=upper2.length) return false;
+        for (int i=0; i<upper1.length; i++) {
+            if (!equalIncludingGenerics(upper1[i],upper2[i])) return false;
+        }
+        return true;
+    }
+
+    private static boolean equalIncludingGenerics(ClassNode orig, ClassNode copy) {
+        if (orig==copy) return true;
+        if (orig.isGenericsPlaceHolder()!=copy.isGenericsPlaceHolder()) return false;
+        if (!orig.equals(copy)) return false;
+        GenericsType[] gt1 = orig.getGenericsTypes();
+        GenericsType[] gt2 = orig.getGenericsTypes();
+        if ((gt1==null || gt2==null) && gt1!=gt2) return false;
+        if (gt1==gt2) return true;
+        if (gt1.length!=gt2.length) return false;
+        for (int i=0; i<gt1.length; i++) {
+            if (!equalIncludingGenerics(gt1[i],gt2[i])) return false;
         }
+        return true;
+    }
 
-        GenericsType[] returnTypeGenerics = getGenericsWithoutArray(currentType);
-        if (returnTypeGenerics==null || returnTypeGenerics.length==0) return currentType;
-        GenericsType[] copy = new GenericsType[returnTypeGenerics.length];
-        for (int i = 0; i < copy.length; i++) {
-            GenericsType returnTypeGeneric = returnTypeGenerics[i];
-            if (returnTypeGeneric.isPlaceholder() || returnTypeGeneric.isWildcard()) {
-                String name = returnTypeGeneric.getName();
-                /*if (returnTypeGeneric.isWildcard()) {
-                    ClassNode lowerBound = returnTypeGeneric.getLowerBound();
-                    if (lowerBound !=null && lowerBound.isGenericsPlaceHolder()) {
-                        name = lowerBound.getUnresolvedName();
-                    } else {
-                        ClassNode[] upperBounds = returnTypeGeneric.getUpperBounds();
-                        if (upperBounds!=null) {
-                            for (ClassNode upperBound : upperBounds) {
-                                if (upperBound.isGenericsPlaceHolder()) {
-                                    name = upperBound.getUnresolvedName();
-                                    break; // todo: what if more than one match?
-                                }
-                            }
-                        }
-                    }
-                }*/
-                GenericsType resolved = resolvedPlaceholders.get(name);
-                /*if (resolved == null && placeholdersFromContext!=null) {
-                    resolved = placeholdersFromContext.get(name);
-                }*/
-                if (resolved == null) resolved = returnTypeGeneric;
-                copy[i] = fullyResolve(resolved, resolvedPlaceholders);
+    /**
+     * use supplied type to make a connection from usage to declaration
+     * The method operates in two modes. 
+     * * For type !instanceof target a structural compare will be done 
+     *   (for example Dummy<T> and List<R> to get T=R) 
+     * * If type equals target, a structural match is done as well 
+     *   (for example Colection<U> and Collection<E> to get U=E)
+     * * otherwise we climb the hierarchy to find a case of type equals target
+     *   to then execute the structural match, while applying possibly existing
+     *   generics contexts on the way (for example for IntRange and Collection<E>
+     *   to get E=Integer, since IntRange is an AbstractList<Integer>)
+     * Should the target not have any generics this method does nothing.
+     */
+    static void extractGenericsConnections(Map<String, GenericsType> connections, ClassNode type, ClassNode target) {
+        if (target==null || type==target || !isUsingGenericsOrIsArrayUsingGenerics(target)) return;
+        if (type.isArray() && target.isArray()) {
+            extractGenericsConnections(connections, type.getComponentType(), target.getComponentType());
+        } else if (target.isGenericsPlaceHolder() || type.equals(target) || !implementsInterfaceOrIsSubclassOf(type, target)) {
+            // structural match route
+            if (target.isGenericsPlaceHolder()) {
+                connections.put(target.getGenericsTypes()[0].getName(),new GenericsType(type));
             } else {
-                copy[i] = fullyResolve(returnTypeGeneric, resolvedPlaceholders);
+                extractGenericsConnections(connections, type.getGenericsTypes(), target.getGenericsTypes());
             }
-        }
-        GenericsType firstGenericsType = copy[0];
-        if (currentType.equals(OBJECT_TYPE)) {
-            if (firstGenericsType.getType().isGenericsPlaceHolder()) return OBJECT_TYPE;
-
-            if (firstGenericsType.isWildcard()) {
-                // ? extends Foo
-                // ? super Foo
-                // ?
-                if (firstGenericsType.getLowerBound() != null) return firstGenericsType.getLowerBound();
-                ClassNode[] upperBounds = firstGenericsType.getUpperBounds();
-                if (upperBounds==null) { // case "?"
-                    return OBJECT_TYPE;
+        } else {
+            // have first to find matching super class or interface
+            Map <String,ClassNode> genSpec = GenericsUtils.createGenericsSpec(type,Collections.EMPTY_MAP);
+            ClassNode superClass = getNextSuperClass(type,target);
+            if (superClass!=null){
+                ClassNode corrected;
+                if (missesGenericsTypes(type)) {
+                    corrected = superClass.getPlainNodeReference();
+                } else {
+                    corrected = GenericsUtils.correctToGenericsSpecRecurse(genSpec, superClass);
                 }
-                if (upperBounds.length == 1) return upperBounds[0];
-                return new UnionTypeClassNode(upperBounds);
+                extractGenericsConnections(connections, corrected, target);
+            } else {
+                // if we reach here, we have an unhandled case 
+                throw new GroovyBugError("The type "+type+" seems not to normally extend "+target+". Sorry, I cannot handle this.");
             }
-            return firstGenericsType.getType();
-        }
-        if (currentType.isArray()) {
-            currentType = currentType.getComponentType().getPlainNodeReference();
-            currentType.setGenericsTypes(copy);
-            if (OBJECT_TYPE.equals(currentType)) {
-                // replace Object<Component> with Component
-                currentType = firstGenericsType.getType();
+        }
+    }
+
+    static ClassNode getNextSuperClass(ClassNode clazz, ClassNode goalClazz) {
+        if (clazz.isArray()) {
+            ClassNode cn = getNextSuperClass(clazz.getComponentType(),goalClazz.getComponentType());
+            if (cn!=null) cn = cn.makeArray();
+            return cn;
+        }
+
+        if (!goalClazz.isInterface()) {
+            if (clazz.isInterface()) {
+                if (OBJECT_TYPE.equals(clazz)) return null;
+                return OBJECT_TYPE;
+            } else {
+                return clazz.getUnresolvedSuperClass();
             }
-            currentType = currentType.makeArray();
-        } else {
-            currentType = currentType.getPlainNodeReference();
-            currentType.setGenericsTypes(copy);
         }
-        if (currentType.equals(Annotation_TYPE) && currentType.getGenericsTypes() != null && !currentType.getGenericsTypes()[0].isPlaceholder()) {
-            return currentType.getGenericsTypes()[0].getType();
+
+        ClassNode[] interfaces = clazz.getUnresolvedInterfaces();
+        for (int i=0; i<interfaces.length; i++) {
+            if (implementsInterfaceOrIsSubclassOf(interfaces[i],goalClazz)) {
+                return interfaces[i];
+            }
+        }
+        //none of the interfaces here match, so continue with super class
+        return clazz.getUnresolvedSuperClass();
+    }
+
+    private static void extractGenericsConnections(Map<String, GenericsType> connections, GenericsType[] usage, GenericsType[] declaration) {
+        // if declaration does not provide generics, there is no connection to make 
+        if (usage==null || declaration==null || declaration.length==0) return;
+        if (usage.length!=declaration.length) return;
+
+        // both have generics
+        for (int i=0; i<usage.length; i++) {
+            GenericsType ui = usage[i];
+            GenericsType di = declaration[i];
+            if (di.isPlaceholder()) {
+                connections.put(di.getName(), ui);
+            } else if (di.isWildcard()){
+                if (ui.isWildcard()) {
+                    extractGenericsConnections(connections, ui.getLowerBound(), di.getLowerBound());
+                    extractGenericsConnections(connections, ui.getUpperBounds(), di.getUpperBounds());
+                } else {
+                    ClassNode cu = ui.getType();
+                    extractGenericsConnections(connections, cu, di.getLowerBound());
+                    ClassNode[] upperBounds = di.getUpperBounds();
+                    if (upperBounds!=null) {
+                        for (ClassNode cn : upperBounds) {
+                            extractGenericsConnections(connections, cu, cn);
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    private static void extractGenericsConnections(Map<String, GenericsType> connections, ClassNode[] usage, ClassNode[] declaration) {
+        if (usage==null || declaration==null || declaration.length==0) return;
+        // both have generics
+        for (int i=0; i<usage.length; i++) {
+            ClassNode ui = usage[i];
+            ClassNode di = declaration[i];
+            if (di.isGenericsPlaceHolder()) {
+                GenericsType gt = new GenericsType(di);
+                gt.setPlaceholder(di.isGenericsPlaceHolder());
+                connections.put(ui.getGenericsTypes()[0].getName(), gt);
+            } else if (di.isUsingGenerics()){
+                extractGenericsConnections(connections, ui.getGenericsTypes(), di.getGenericsTypes());
+            }
         }
-        return currentType;
     }
 
     static GenericsType[] getGenericsWithoutArray(ClassNode type) {
@@ -1489,17 +1607,95 @@ public abstract class StaticTypeCheckingSupport {
         return type.getGenericsTypes();
     }
 
-    private static ClassNode applyGenerics(ClassNode type, Map<String, GenericsType> resolvedPlaceholders) {
-        if (type.isGenericsPlaceHolder()) {
-            String name = type.getUnresolvedName();
-            GenericsType gt = resolvedPlaceholders.get(name);
-            if (gt!=null && gt.isPlaceholder()) {
-                //TODO: have to handle more cases here
-                if (gt.getUpperBounds()!=null) return gt.getUpperBounds()[0];
-                return type;
-            }
+    static Map<String, GenericsType> applyGenericsContextToParameterClass(
+            Map<String, GenericsType> spec, ClassNode parameterUsage
+    ) {
+        GenericsType[] gts = parameterUsage.getGenericsTypes();
+        if (gts==null) return Collections.EMPTY_MAP;
+
+        GenericsType[] newGTs = applyGenericsContext(spec, gts);
+        ClassNode newTarget = parameterUsage.redirect().getPlainNodeReference();
+        newTarget.setGenericsTypes(newGTs);
+        return GenericsUtils.extractPlaceholders(newTarget);
+    }
+    
+    private static GenericsType[] applyGenericsContext(
+            Map<String, GenericsType> spec, GenericsType[] gts
+    ) {
+        if (gts==null) return null;
+        GenericsType[] newGTs = new GenericsType[gts.length];
+        for (int i=0; i<gts.length; i++) {
+            GenericsType gt = gts[i];
+            newGTs[i] = applyGenericsContext(spec, gt);
         }
-        return type;
+        return newGTs;
+    }
+
+    private static GenericsType applyGenericsContext(
+            Map<String, GenericsType> spec, GenericsType gt
+    ) {
+        if (gt.isPlaceholder()) {
+            String name = gt.getName();
+            GenericsType specType = spec.get(name);
+            if (specType!=null) return specType;
+            if (gt.getLowerBound()!=null || gt.getUpperBounds()!=null) {
+                GenericsType newType = new GenericsType(gt.getType(), applyGenericsContext(spec, gt.getUpperBounds()), applyGenericsContext(spec, gt.getLowerBound()));
+                newType.setPlaceholder(true);
+                return newType;
+            } else {
+                return gt;
+            }
+        } else if (gt.isWildcard()) {
+            GenericsType newGT = new GenericsType(gt.getType(), applyGenericsContext(spec, gt.getUpperBounds()), applyGenericsContext(spec, gt.getLowerBound()));
+            newGT.setWildcard(true);
+            return newGT;
+        }
+        ClassNode type = gt.getType();
+        if (type.getGenericsTypes()==null) return gt;
+        ClassNode newType = type.getPlainNodeReference();
+        newType.setGenericsPlaceHolder(type.isGenericsPlaceHolder());
+        newType.setGenericsTypes(applyGenericsContext(spec, type.getGenericsTypes()));
+        GenericsType newGT = new GenericsType(newType);
+        return newGT;
+    }
+
+    private static ClassNode[] applyGenericsContext(
+            Map<String, GenericsType> spec, ClassNode[] bounds
+    ) {
+        if (bounds==null) return null;
+        ClassNode[] newBounds = new ClassNode[bounds.length];
+        for(int i=0; i<bounds.length; i++) {
+            newBounds[i] = applyGenericsContext(spec,bounds[i]);
+        }
+        return newBounds;
+    }
+
+    static ClassNode applyGenericsContext(
+            Map<String, GenericsType> spec, ClassNode bound
+    ) {
+        if (bound==null) return null;
+        if (bound.isArray()) {
+            return applyGenericsContext(spec,bound.getComponentType()).makeArray();
+        }
+        if (!bound.isUsingGenerics()) return bound;
+        ClassNode newBound = bound.getPlainNodeReference();
+        newBound.setGenericsTypes(applyGenericsContext(spec, bound.getGenericsTypes()));
+        if (bound.isGenericsPlaceHolder()) {
+            GenericsType[] gt= newBound.getGenericsTypes();
+            boolean hasBounds = gt[0].getLowerBound()!=null || gt[0].getUpperBounds()!=null;
+            if (hasBounds || !gt[0].isPlaceholder()) return getCombinedBoundType(gt[0]);
+            newBound.setGenericsPlaceHolder(true);
+        }
+        return newBound;
+    }
+
+    private static ClassNode getCombinedBoundType(GenericsType genericsType) {
+        //TODO: this method should really return some kind of meta ClassNode
+        // representing the combination of all bounds. The code here, just picks
+        // something out to be able to proceed and is not actually correct
+        if (genericsType.getLowerBound()!=null) return genericsType.getLowerBound();
+        if (genericsType.getUpperBounds()!=null) return genericsType.getUpperBounds()[0];
+        return genericsType.getType();
     }
 
     private static void applyContextGenerics(Map<String, GenericsType> resolvedPlaceholders, Map<String, GenericsType> placeholdersFromContext) {
diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 283b34c717..4d8c9fd08b 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -21,6 +21,7 @@ import groovy.transform.stc.ClosureSignatureHint;
 import groovy.transform.TypeChecked;
 import groovy.transform.TypeCheckingMode;
 import groovy.transform.stc.FromAbstractTypeMethods;
+
 import org.codehaus.groovy.GroovyBugError;
 import org.codehaus.groovy.ast.*;
 import org.codehaus.groovy.ast.expr.*;
@@ -49,7 +50,6 @@ import static org.codehaus.groovy.ast.ClassHelper.*;
 import static org.codehaus.groovy.ast.tools.WideningCategories.*;
 import static org.codehaus.groovy.syntax.Types.*;
 import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.*;
-import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.isClassClassNodeWrappingConcreteType;
 
 /**
  * The main class code visitor responsible for static type checking. It will perform various inspections like checking
@@ -2003,139 +2003,211 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             }
         } else if (isSAMType(param.getOriginType())) {
             // SAM coercion
-            doInferClosureParameterTypes(receiver, arguments, expression, selectedMethod, new ClassExpression(ClassHelper.make(FromAbstractTypeMethods.class)), new ConstantExpression(param.getOriginType().getName()));
+            inferSAMType(param, receiver, selectedMethod, InvocationWriter.makeArgumentList(arguments), expression);
         }
     }
 
-    private void doInferClosureParameterTypes(final ClassNode receiver, final Expression arguments, final ClosureExpression expression, final MethodNode selectedMethod, final Expression hintClass, final Expression options) {
+    
+    private void inferSAMType(Parameter param, ClassNode receiver, MethodNode methodWithSAMParameter, ArgumentListExpression originalMethodCallArguments, ClosureExpression openBlock) {
+        // In a method call with SAM coercion the inference is to be
+        // understood as a two phase process. We have the normal method call
+        // to the target method with the closure argument and we have the 
+        // SAM method that will be called inside the normal target method. 
+        // To infer correctly we have to "simulate" this process. We know the
+        // call to the closure will be done through the SAM type, so the SAM
+        // type generics deliver information about the Closure. At the same
+        // time the SAM class is used in the target method parameter, 
+        // providing a connection from the SAM type and the target method
+        // declaration class.
+
+        // First we try to get as much information about the declaration
+        // class through the receiver
+        Map<String,GenericsType> targetMethodDeclarationClassConnections = new HashMap<String,GenericsType>();
+        extractGenericsConnections(targetMethodDeclarationClassConnections, receiver, receiver.redirect());
+        // then we use the method with the SAM parameter to get more information about the declaration
+        Parameter[] parametersOfMethodContainingSAM = methodWithSAMParameter.getParameters();
+        for (int i=0; i<parametersOfMethodContainingSAM.length; i++) {
+            Expression callArg = originalMethodCallArguments.getExpression(i);
+            // we look at the closure later in detail, so skip it here
+            if (callArg==openBlock) continue;
+            ClassNode parameterType = parametersOfMethodContainingSAM[i].getType();
+            extractGenericsConnections(targetMethodDeclarationClassConnections, getType(callArg), parameterType);
+        }
+
+        // To make a connection to the SAM class we use that new information
+        // to replace the generics in the SAM type parameter of the target
+        // method and than that to make the connections to the SAM type generics
+        ClassNode paramTypeWithReceiverInformation = applyGenericsContext(targetMethodDeclarationClassConnections, param.getOriginType());
+        Map<String,GenericsType> SAMTypeConnections = new HashMap<String,GenericsType>();
+        ClassNode classForSAM = paramTypeWithReceiverInformation.redirect();
+        extractGenericsConnections(SAMTypeConnections, paramTypeWithReceiverInformation, classForSAM);
+
+        // should the open block provide final information we apply that
+        // to the corresponding parameters of the SAM type method
+        MethodNode methodForSAM = findSAM(classForSAM);
+        ClassNode[] parameterTypesForSAM = extractTypesFromParameters(methodForSAM.getParameters());
+        ClassNode[] blockParameterTypes = (ClassNode[]) openBlock.getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);
+        if (blockParameterTypes==null) {
+            Parameter[] p = openBlock.getParameters();
+            if (p.length==0 && parameterTypesForSAM.length!=0) {
+                // implicit it
+                blockParameterTypes = parameterTypesForSAM;
+            } else {
+                blockParameterTypes = extractTypesFromParameters(p);
+            }
+        }
+        for (int i=0; i<blockParameterTypes.length; i++) { //TODO: equal length guaranteed?
+            extractGenericsConnections(SAMTypeConnections, blockParameterTypes[i], parameterTypesForSAM[i]);
+        }
+
+        // and finally we apply the generics information to the parameters and 
+        // store the type of parameter and block type as meta information
+        for (int i=0; i<blockParameterTypes.length; i++) { //TODO: equal length guaranteed?
+            ClassNode resolvedParameter =
+                    applyGenericsContext(SAMTypeConnections, parameterTypesForSAM[i]);
+            blockParameterTypes[i] = resolvedParameter;
+        }
+        openBlock.putNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS, blockParameterTypes);
+    }
+
+    private List<ClassNode[]> getSignaturesFromHint(final ClosureExpression expression, final MethodNode selectedMethod, final Expression hintClass, final Expression options) {
+        // initialize hints
+        List<ClassNode[]> closureSignatures = null;
         try {
-            Parameter[] closureParams = expression.getParameters();
             CompilationUnit compilationUnit = typeCheckingContext.getCompilationUnit();
+            @SuppressWarnings("resource")
             GroovyClassLoader transformLoader = compilationUnit!=null?compilationUnit.getTransformLoader():getSourceUnit().getClassLoader();
             @SuppressWarnings("unchecked")
             Class<? extends ClosureSignatureHint> hint = (Class<? extends ClosureSignatureHint>) transformLoader.loadClass(hintClass.getText());
             ClosureSignatureHint hintInstance = hint.newInstance();
-            List<ClassNode[]> closureSignatures = hintInstance.getClosureSignatures(
+            closureSignatures = hintInstance.getClosureSignatures(
                     selectedMethod instanceof ExtensionMethodNode ?((ExtensionMethodNode) selectedMethod).getExtensionMethodNode():selectedMethod,
                     typeCheckingContext.source,
                     typeCheckingContext.compilationUnit,
                     convertToStringArray(options), expression);
-            List<ClassNode[]> candidates = new LinkedList<ClassNode[]>();
-            for (ClassNode[] signature : closureSignatures) {
-                // in order to compute the inferred types of the closure parameters, we're using the following trick:
-                // 1. create a dummy MethodNode for which the return type is a class node for which the generic types are the types returned by the hint
-                // 2. call inferReturnTypeGenerics
-                // 3. fetch inferred types from the result of inferReturnTypeGenerics
-                // In practice, it could be done differently but it has the main advantage of reusing
-                // existing code, hence reducing the amount of code to debug in case of failure.
-                final int id = System.identityHashCode(expression);
-                ClassNode dummyResultNode = new ClassNode("cl$" + id, 0, OBJECT_TYPE).getPlainNodeReference();
-                final GenericsType[] genericTypes = new GenericsType[signature.length];
-                for (int i = 0; i < signature.length; i++) {
-                    genericTypes[i] = new GenericsType(signature[i]);
-                }
-                dummyResultNode.setGenericsTypes(genericTypes);
-                MethodNode dummyMN = selectedMethod instanceof ExtensionMethodNode ? ((ExtensionMethodNode) selectedMethod).getExtensionMethodNode() : selectedMethod;
-                dummyMN = new MethodNode(
+        } catch (ClassNotFoundException e) {
+            throw new GroovyBugError(e);
+        } catch (InstantiationException e) {
+            throw new GroovyBugError(e);
+        } catch (IllegalAccessException e) {
+            throw new GroovyBugError(e);
+        }
+        return closureSignatures;
+    }
+
+    private void doInferClosureParameterTypes(final ClassNode receiver, final Expression arguments, final ClosureExpression expression, final MethodNode selectedMethod, final Expression hintClass, final Expression options) {
+        List<ClassNode[]> closureSignatures = getSignaturesFromHint(expression,selectedMethod,hintClass,options);
+        List<ClassNode[]> candidates = new LinkedList<ClassNode[]>();
+        for (ClassNode[] signature : closureSignatures) {
+            // in order to compute the inferred types of the closure parameters, we're using the following trick:
+            // 1. create a dummy MethodNode for which the return type is a class node for which the generic types are the types returned by the hint
+            // 2. call inferReturnTypeGenerics
+            // 3. fetch inferred types from the result of inferReturnTypeGenerics
+            // In practice, it could be done differently but it has the main advantage of reusing
+            // existing code, hence reducing the amount of code to debug in case of failure.
+            final int id = System.identityHashCode(expression);
+            ClassNode dummyResultNode = new ClassNode("cl$" + id, 0, OBJECT_TYPE).getPlainNodeReference();
+            final GenericsType[] genericTypes = new GenericsType[signature.length];
+            for (int i = 0; i < signature.length; i++) {
+                genericTypes[i] = new GenericsType(signature[i]);
+            }
+            dummyResultNode.setGenericsTypes(genericTypes);
+            MethodNode dummyMN = selectedMethod instanceof ExtensionMethodNode ? ((ExtensionMethodNode) selectedMethod).getExtensionMethodNode() : selectedMethod;
+            dummyMN = new MethodNode(
+                    dummyMN.getName(),
+                    dummyMN.getModifiers(),
+                    dummyResultNode,
+                    dummyMN.getParameters(),
+                    dummyMN.getExceptions(),
+                    EmptyStatement.INSTANCE
+                    );
+            dummyMN.setDeclaringClass(selectedMethod.getDeclaringClass());
+            dummyMN.setGenericsTypes(selectedMethod.getGenericsTypes());
+            if (selectedMethod instanceof ExtensionMethodNode) {
+                ExtensionMethodNode orig = (ExtensionMethodNode) selectedMethod;
+                dummyMN = new ExtensionMethodNode(
+                        dummyMN,
                         dummyMN.getName(),
                         dummyMN.getModifiers(),
                         dummyResultNode,
-                        dummyMN.getParameters(),
-                        dummyMN.getExceptions(),
-                        EmptyStatement.INSTANCE
-                );
-                dummyMN.setDeclaringClass(selectedMethod.getDeclaringClass());
-                dummyMN.setGenericsTypes(selectedMethod.getGenericsTypes());
-                if (selectedMethod instanceof ExtensionMethodNode) {
-                    ExtensionMethodNode orig = (ExtensionMethodNode) selectedMethod;
-                    dummyMN = new ExtensionMethodNode(
-                            dummyMN,
-                            dummyMN.getName(),
-                            dummyMN.getModifiers(),
-                            dummyResultNode,
-                            orig.getParameters(),
-                            orig.getExceptions(),
-                            EmptyStatement.INSTANCE,
-                            orig.isStaticExtension()
-                    );
-                    dummyMN.setDeclaringClass(orig.getDeclaringClass());
-                    dummyMN.setGenericsTypes(orig.getGenericsTypes());
-                }
-                ClassNode classNode = inferReturnTypeGenerics(receiver, dummyMN, arguments);
-                ClassNode[] inferred = new ClassNode[classNode.getGenericsTypes().length];
-                for (int i = 0; i < classNode.getGenericsTypes().length; i++) {
-                    GenericsType genericsType = classNode.getGenericsTypes()[i];
-                    ClassNode value = createUsableClassNodeFromGenericsType(genericsType);
-                    inferred[i] = value;
-                }
-                if (signature.length == closureParams.length // same number of arguments
-                        || (signature.length == 1 && closureParams.length == 0) // implicit it
-                        || (closureParams.length > signature.length && inferred[inferred.length - 1].isArray())) { // vargs
-                    candidates.add(inferred);
-                }
+                        orig.getParameters(),
+                        orig.getExceptions(),
+                        EmptyStatement.INSTANCE,
+                        orig.isStaticExtension()
+                        );
+                dummyMN.setDeclaringClass(orig.getDeclaringClass());
+                dummyMN.setGenericsTypes(orig.getGenericsTypes());
             }
-            if (candidates.size()>1) {
-                Iterator<ClassNode[]> candIt = candidates.iterator();
-                while (candIt.hasNext()) {
-                    ClassNode[] inferred = candIt.next();
-                    final int length = closureParams.length;
-                    for (int i = 0; i < length; i++) {
-                        Parameter closureParam = closureParams[i];
-                        final ClassNode originType = closureParam.getOriginType();
-                        ClassNode inferredType;
-                        if (i<inferred.length-1 || inferred.length==closureParams.length) {
-                            inferredType = inferred[i];
-                        } else { // vargs?
-                            ClassNode lastArgInferred = inferred[inferred.length-1];
-                            if (lastArgInferred.isArray()) {
-                                inferredType = lastArgInferred.getComponentType();
-                            } else {
-                                candIt.remove();
-                                continue;
-                            }
-                        }
-                        if (!typeCheckMethodArgumentWithGenerics(originType, inferredType, i== length -1)) {
+            ClassNode classNode = inferReturnTypeGenerics(receiver, dummyMN, arguments);
+            ClassNode[] inferred = new ClassNode[classNode.getGenericsTypes().length];
+            for (int i = 0; i < classNode.getGenericsTypes().length; i++) {
+                GenericsType genericsType = classNode.getGenericsTypes()[i];
+                ClassNode value = createUsableClassNodeFromGenericsType(genericsType);
+                inferred[i] = value;
+            }
+            Parameter[] closureParams = expression.getParameters();
+            if (signature.length == closureParams.length // same number of arguments
+                    || (signature.length == 1 && closureParams.length == 0) // implicit it
+                    || (closureParams.length > signature.length && inferred[inferred.length - 1].isArray())) { // vargs
+                candidates.add(inferred);
+            }
+        }
+        Parameter[] closureParams = expression.getParameters();
+        if (candidates.size()>1) {
+            Iterator<ClassNode[]> candIt = candidates.iterator();
+            while (candIt.hasNext()) {
+                ClassNode[] inferred = candIt.next();
+                final int length = closureParams.length;
+                for (int i = 0; i < length; i++) {
+                    Parameter closureParam = closureParams[i];
+                    final ClassNode originType = closureParam.getOriginType();
+                    ClassNode inferredType;
+                    if (i<inferred.length-1 || inferred.length==closureParams.length) {
+                        inferredType = inferred[i];
+                    } else { // vargs?
+                        ClassNode lastArgInferred = inferred[inferred.length-1];
+                        if (lastArgInferred.isArray()) {
+                            inferredType = lastArgInferred.getComponentType();
+                        } else {
                             candIt.remove();
+                            continue;
                         }
                     }
-                }
-                if (candidates.size()>1) {
-                    addError("Ambiguous prototypes for closure. More than one target method matches. Please use explicit argument types.", expression);
+                    if (!typeCheckMethodArgumentWithGenerics(originType, inferredType, i== length -1)) {
+                        candIt.remove();
+                    }
                 }
             }
-            if (candidates.size()==1) {
-                ClassNode[] inferred = candidates.get(0);
-                if (closureParams.length==0 && inferred.length==1) {
-                    expression.putNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS, inferred);
-                } else {
-                    final int length = closureParams.length;
-                    for (int i = 0; i < length; i++) {
-                        Parameter closureParam = closureParams[i];
-                        final ClassNode originType = closureParam.getOriginType();
-                        ClassNode inferredType = OBJECT_TYPE;
-                        if (i<inferred.length-1 || inferred.length==closureParams.length) {
-                            inferredType = inferred[i];
-                        } else { // vargs?
+            if (candidates.size()>1) {
+                addError("Ambiguous prototypes for closure. More than one target method matches. Please use explicit argument types.", expression);
+            }
+        }
+        if (candidates.size()==1) {
+            ClassNode[] inferred = candidates.get(0);
+            if (closureParams.length==0 && inferred.length==1) {
+                expression.putNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS, inferred);
+            } else {
+                final int length = closureParams.length;
+                for (int i = 0; i < length; i++) {
+                    Parameter closureParam = closureParams[i];
+                    final ClassNode originType = closureParam.getOriginType();
+                    ClassNode inferredType = OBJECT_TYPE;
+                    if (i<inferred.length-1 || inferred.length==closureParams.length) {
+                        inferredType = inferred[i];
+                    } else { // vargs?
                             ClassNode lastArgInferred = inferred[inferred.length-1];
                             if (lastArgInferred.isArray()) {
                                 inferredType = lastArgInferred.getComponentType();
                             } else {
                                 addError("Incorrect number of parameters. Expected "+inferred.length+" but found "+closureParams.length, expression);
                             }
-                        }
-                        if (!typeCheckMethodArgumentWithGenerics(originType, inferredType, i== length -1)) {
-                            addError("Expected parameter of type "+ inferredType.toString(false)+" but got "+originType.toString(false), closureParam.getType());
-                        }
-                        typeCheckingContext.controlStructureVariables.put(closureParam, inferredType);
                     }
+                    if (!typeCheckMethodArgumentWithGenerics(originType, inferredType, i== length -1)) {
+                        addError("Expected parameter of type "+ inferredType.toString(false)+" but got "+originType.toString(false), closureParam.getType());
+                    }
+                    typeCheckingContext.controlStructureVariables.put(closureParam, inferredType);
                 }
             }
-        } catch (ClassNotFoundException e) {
-            throw new GroovyBugError(e);
-        } catch (InstantiationException e) {
-            throw new GroovyBugError(e);
-        } catch (IllegalAccessException e) {
-            throw new GroovyBugError(e);
         }
     }
 
@@ -2989,6 +3061,10 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 // ex : def foos = ['a','b','c']
                 return right;
             }
+            if (rightRedirect.isDerivedFrom(CLOSURE_TYPE) && isSAMType(leftRedirect)) {
+                return inferSAMTypeGenericsInAssignment(left, findSAM(left),right,(ClosureExpression)expr.getRightExpression());
+            }
+            
             if (leftExpression instanceof VariableExpression) {
                 ClassNode initialType = getOriginalDeclarationType(leftExpression).redirect();
                 if (isPrimitiveType(right) && initialType.isDerivedFrom(Number_TYPE)) {
@@ -3094,6 +3170,31 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         return null;
     }
 
+    private ClassNode inferSAMTypeGenericsInAssignment(ClassNode samUsage, MethodNode sam, ClassNode closureType, ClosureExpression closureExpression) {
+        // if the sam type or closure type do not provide generics information, 
+        // we cannot infer anything, thus we simply return the provided samUsage
+        GenericsType[] samGt = samUsage.getGenericsTypes();
+        GenericsType[] closureGt = closureType.getGenericsTypes();
+        if (samGt==null || closureGt==null) return samUsage;
+
+        // extract the generics from the return type
+        Map<String,GenericsType> connections = new HashMap<String,GenericsType>();
+        extractGenericsConnections(connections,closureType,sam.getReturnType());
+
+        // next we get the block parameter types and set the generics 
+        // information just like before
+        // TODO: add vargs handling
+        Parameter[] closureParams = closureExpression.getParameters();
+        Parameter[] methodParams = sam.getParameters();
+        for (int i=0; i<closureParams.length; i++) {
+            ClassNode fromClosure = closureParams[i].getType();
+            ClassNode fromMethod = methodParams[i].getType();
+            extractGenericsConnections(connections,fromClosure,fromMethod);
+        }
+        ClassNode result = applyGenericsContext(connections, samUsage.redirect());
+        return result;
+    }
+
     protected static ClassNode getGroupOperationResultType(ClassNode a, ClassNode b) {
         if (isBigIntCategory(a) && isBigIntCategory(b)) return BigInteger_TYPE;
         if (isBigDecCategory(a) && isBigDecCategory(b)) return BigDecimal_TYPE;
@@ -3650,6 +3751,9 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
         Map<String, GenericsType> resolvedPlaceholders = resolvePlaceHoldersFromDeclaration(receiver, getDeclaringClass(method, arguments), method, method.isStatic());
         if (resolvedPlaceholders.isEmpty()) return returnType;
+        Map<String, GenericsType> placeholdersFromContext = extractGenericsParameterMapOfThis(typeCheckingContext.getEnclosingMethod());
+        applyGenericsConnections(placeholdersFromContext,resolvedPlaceholders);
+
         // then resolve receivers from method arguments
         Parameter[] parameters = method.getParameters();
         boolean isVargs = isVargs(parameters);
@@ -3660,76 +3764,33 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             for (int i = 0; i < paramLength; i++) {
                 boolean lastArg = i == paramLength - 1;
                 ClassNode type = parameters[i].getType();
-                if (!type.isUsingGenerics() && type.isArray()) type = type.getComponentType();
-                if (type.isUsingGenerics()) {
-                    ClassNode actualType = getType(expressions.get(i));
+                ClassNode actualType = getType(expressions.get(i));
+                while (!type.isUsingGenerics() && type.isArray() && actualType.isArray()) {
+                    type = type.getComponentType();
+                    actualType = actualType.getComponentType();
+                }
+                if (isUsingGenericsOrIsArrayUsingGenerics(type)) {
                     if (implementsInterfaceOrIsSubclassOf(actualType, CLOSURE_TYPE) && !implementsInterfaceOrIsSubclassOf(type, CLOSURE_TYPE)) {
                         // implicit closure coercion in action!
-                        Map<String,GenericsType> pholders = new HashMap<String, GenericsType>(resolvedPlaceholders);
+                        Map<String,GenericsType> pholders = applyGenericsContextToParameterClass(resolvedPlaceholders, type);
                         actualType = convertClosureTypeToSAMType(expressions.get(i), actualType, type, pholders);
                     }
                     if (isVargs && lastArg && actualType.isArray()) {
                         actualType = actualType.getComponentType();
                     }
-                    actualType = wrapTypeIfNecessary(actualType);
-                    Map<String, GenericsType> typePlaceholders = GenericsUtils.extractPlaceholders(type);
-                    if (OBJECT_TYPE.equals(type)) {
-                        // special case for handing Object<E> -> Object
-                        for (String key : typePlaceholders.keySet()) {
-                            resolvedPlaceholders.put(key, new GenericsType(actualType.isArray() ? actualType.getComponentType() : actualType));
-                        }
-                    } else {
-                        while (actualType!=null && !actualType.equals(type)) {
-                            Set<ClassNode> interfaces = actualType.getAllInterfaces();
-                            boolean intf = false;
-                            for (ClassNode anInterface : interfaces) {
-                                if (anInterface.equals(type)) {
-                                    intf = true;
-                                    actualType = GenericsUtils.parameterizeType(actualType, anInterface);
-                                    break;
-                                }
-                            }
-                            if (!intf) actualType = actualType.getUnresolvedSuperClass();
-                        }
-                        if (actualType!=null) {
-                            Map<String, GenericsType> actualTypePlaceholders = GenericsUtils.extractPlaceholders(actualType);
-                            for (Map.Entry<String, GenericsType> typeEntry : actualTypePlaceholders.entrySet()) {
-                                String key = typeEntry.getKey();
-                                GenericsType value = typeEntry.getValue();
-                                GenericsType alias = typePlaceholders.get(key);
-                                if (alias != null) {
-                                    if (alias.isPlaceholder()) {
-                                        if (!resolvedPlaceholders.containsKey(alias.getName()) || resolvedPlaceholders.get(alias.getName()).isPlaceholder()) {
-                                            resolvedPlaceholders.put(alias.getName(), value);
-                                        }
-                                    } else if (alias.isWildcard()) {
-                                        ClassNode[] upperBounds = alias.getUpperBounds();
-                                        if (upperBounds!=null) {
-                                            for (ClassNode upperBound : upperBounds) {
-                                                if (upperBound.isGenericsPlaceHolder()) {
-                                                    resolvedPlaceholders.put(upperBound.getUnresolvedName(), value);
-                                                }
-                                            }
-                                        }
-                                        ClassNode lowerBound = alias.getLowerBound();
-                                        if (lowerBound!=null && lowerBound.isGenericsPlaceHolder()) {
-                                            String placeholderName = lowerBound.getUnresolvedName();
-                                            GenericsType genericsType = resolvedPlaceholders.get(placeholderName);
-                                            if (genericsType!=null) {
-                                                resolvedPlaceholders.put(key, genericsType);
-                                            }
-                                        }
-                                    }
-                                }
-                            }
-                        }
+                    if (isVargs && lastArg && type.isArray()) {
+                        type = type.getComponentType();
                     }
+                    actualType = wrapTypeIfNecessary(actualType);
 
+                    Map<String, GenericsType> connections  = new HashMap<String, GenericsType>();
+                    extractGenericsConnections(connections, actualType,type);
+                    applyGenericsConnections(connections, resolvedPlaceholders);
                 }
             }
         }
 
-        return resolveGenericsWithContext(resolvedPlaceholders, returnType);
+        return applyGenericsContext(resolvedPlaceholders, returnType);
     }
 
     /**
@@ -3742,81 +3803,68 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
      */
     private static ClassNode convertClosureTypeToSAMType(final Expression expression, final ClassNode closureType, final ClassNode samType, final Map<String,GenericsType> placeholders) {
         if (!samType.isUsingGenerics()) return samType;
-        MethodNode sam = findSAM(samType);
-        if (sam==null) {
-            // should never happen
-            return samType;
-        }
-
-        // the return type of the SAM method exactly corresponds to the inferred return type
-        ClassNode samReturnType = sam.getReturnType();
-
-        // now we can play!
-        // imagine that a closure returns an Integer, like in { -> 1 }
-        // and a SAM type defined like this: interface<T> SAM { T apply() }
-        // then if the closure is coerced to SAM, we can infer that we have a SAM<Integer>
-        // we can also have interface<T> SAM { void apply(T t) }
-        // so we build a list of couples(actualType, expectedType) to test
-        List<ClassNode[]> itemsToCheck = new LinkedList<ClassNode[]>();
 
-        if (closureType.isUsingGenerics()) {
-            ClassNode closureReturnType = closureType.getGenericsTypes()[0].getType();
-            itemsToCheck.add(new ClassNode[]{closureReturnType, samReturnType});
-        }
-        if (expression instanceof ClosureExpression) {
-            Parameter[] closureParams = ((ClosureExpression) expression).getParameters();
-            ClassNode[] closureParamTypes = extractTypesFromParameters(closureParams);
-            if (expression.getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS)!=null) {
-                closureParamTypes = expression.getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);
-            }
-            final Parameter[] parameters = sam.getParameters();
-            for (int i = 0; i < parameters.length; i++) {
-                final Parameter parameter = parameters[i];
-                if (closureParamTypes.length>i) {
-                    itemsToCheck.add(new ClassNode[]{closureParamTypes[i], parameter.getOriginType()});
-                }
-            }
-        }
-        for (ClassNode[] classNodes : itemsToCheck) {
-            ClassNode found = classNodes[0];
-            ClassNode expected = classNodes[1];
-            if (!isAssignableTo(found, expected)) {
-                // probably facing a type mismatch
-                continue;
-            }
-            ClassNode generifiedReturnType = GenericsUtils.parameterizeType(found, expected);
-            while (expected.isArray()) {
-                expected = expected.getComponentType();
-                generifiedReturnType = generifiedReturnType.getComponentType();
-            }
-            if (expected.isGenericsPlaceHolder()) {
-                placeholders.put(expected.getGenericsTypes()[0].getName(), new GenericsType(generifiedReturnType));
-            } else {
-                GenericsType[] samReturnTypeGenericsTypes = expected.getGenericsTypes();
-                GenericsType[] generifiedReturnTypeGenericsTypes = generifiedReturnType.getGenericsTypes();
-
-                for (int i = 0; i < samReturnTypeGenericsTypes.length; i++) {
-                    final GenericsType type = samReturnTypeGenericsTypes[i];
-                    if (type.isPlaceholder()) {
-                        String name = type.getName();
-                        placeholders.put(name, generifiedReturnTypeGenericsTypes[i]);
-                    }
-                }
-            }
-        }
-
-        ClassNode result = samType.getPlainNodeReference();
-        GenericsType[] genericsTypes = samType.redirect().getGenericsTypes();
-        GenericsType[] copy = new GenericsType[genericsTypes.length];
-        for (int i = 0; i < genericsTypes.length; i++) {
-            GenericsType genericsType = genericsTypes[i];
-            if (genericsType.isPlaceholder() && placeholders.containsKey(genericsType.getName())) {
-                copy[i] = placeholders.get(genericsType.getName());
-            } else {
-                copy[i] = genericsType;
-            }
-        }
-        result.setGenericsTypes(copy);
+        // use the generics information from the Closure to further specify the type
+        MethodNode sam = findSAM(samType);
+        if (closureType.isUsingGenerics() && sam!=null) {
+           //correct SAM type for generics
+           //sam = applyGenericsContext(placeholders, sam);
+
+           // the return type of the SAM method exactly corresponds to the inferred return type
+           ClassNode samReturnType = sam.getReturnType();
+           ClassNode closureReturnType = expression.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);
+           if (closureReturnType!=null && closureReturnType.isUsingGenerics()) {
+               ClassNode unwrapped = closureReturnType.getGenericsTypes()[0].getType();
+               extractGenericsConnections(placeholders, unwrapped, samReturnType);
+           } else if (samReturnType.isGenericsPlaceHolder()) {
+               placeholders.put(samReturnType.getGenericsTypes()[0].getName(), closureType.getGenericsTypes()[0]);
+           }
+
+           // now repeat the same for each parameter given in the ClosureExpression
+           if (expression instanceof ClosureExpression) {
+               List<ClassNode[]> genericsToConnect = new LinkedList<ClassNode[]>();
+               Parameter[] closureParams = ((ClosureExpression) expression).getParameters();
+               ClassNode[] closureParamTypes = extractTypesFromParameters(closureParams);
+               if (expression.getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS)!=null) {
+                   closureParamTypes = expression.getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);
+               }
+               final Parameter[] parameters = sam.getParameters();
+               for (int i = 0; i < parameters.length; i++) {
+                   final Parameter parameter = parameters[i];
+                   if (parameter.getOriginType().isUsingGenerics() && closureParamTypes.length>i) {
+                       genericsToConnect.add(new ClassNode[]{closureParamTypes[i], parameter.getOriginType()});
+                   }
+               }
+               for (ClassNode[] classNodes : genericsToConnect) {
+                   ClassNode found = classNodes[0];
+                   ClassNode expected = classNodes[1];
+                   if (!isAssignableTo(found, expected)) {
+                       // probably facing a type mismatch
+                       continue;
+                   }
+                   ClassNode generifiedType = GenericsUtils.parameterizeType(found, expected);
+                   while (expected.isArray()) {
+                       expected = expected.getComponentType();
+                       generifiedType = generifiedType.getComponentType();
+                   }
+                   if (expected.isGenericsPlaceHolder()) {
+                       placeholders.put(expected.getGenericsTypes()[0].getName(), new GenericsType(generifiedType));
+                   } else {
+                       GenericsType[] expectedGenericsTypes = expected.getGenericsTypes();
+                       GenericsType[] foundGenericsTypes = generifiedType.getGenericsTypes();
+
+                       for (int i = 0; i < expectedGenericsTypes.length; i++) {
+                           final GenericsType type = expectedGenericsTypes[i];
+                           if (type.isPlaceholder()) {
+                               String name = type.getName();
+                               placeholders.put(name, foundGenericsTypes[i]);
+                           }
+                       }
+                   }
+               }
+           }
+        }
+        ClassNode result = applyGenericsContext(placeholders,samType.redirect());
         return result;
     }
 
@@ -3860,32 +3908,6 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         GenericsUtils.extractPlaceholders(dummy, resolvedPlaceholders);
     }
 
-    private static ClassNode getNextSuperClass(ClassNode clazz, ClassNode goalClazz) {
-        if (clazz.isArray()) {
-            ClassNode cn = getNextSuperClass(clazz.getComponentType(),goalClazz.getComponentType());
-            if (cn!=null) cn = cn.makeArray();
-            return cn;
-        }
-
-        if (!goalClazz.isInterface()) {
-            if (clazz.isInterface()) {
-                if (OBJECT_TYPE.equals(clazz)) return null;
-                return OBJECT_TYPE;
-            } else {
-                return clazz.getUnresolvedSuperClass();
-            }
-        }
-
-        ClassNode[] interfaces = clazz.getUnresolvedInterfaces();
-        for (int i=0; i<interfaces.length; i++) {
-            if (implementsInterfaceOrIsSubclassOf(interfaces[i],goalClazz)) {
-                return interfaces[i];
-            }
-        }
-        //none of the interfaces here match, so continue with super class
-        return clazz.getUnresolvedSuperClass();
-    }
-
     private static Map<String, GenericsType> extractPlaceHolders(MethodNode method, ClassNode receiver, ClassNode declaringClass) {
         if (declaringClass.equals(OBJECT_TYPE)) {
             Map<String, GenericsType> resolvedPlaceholders = new HashMap<String, GenericsType>();
diff --git a/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy b/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy
index 8e822344e0..d592c3335a 100644
--- a/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy
+++ b/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy
@@ -563,7 +563,7 @@ class FooWorker {
     }
 }
 
-new FooWorker().doSomething()''', 'Incompatible generic argument types. Cannot assign java.util.ArrayList <Integer> to: java.util.List <java.lang.String>'
+new FooWorker().doSomething()''', 'Incompatible generic argument types. Cannot assign java.util.ArrayList <Integer> to: java.util.List <String>'
     }
 
     public static interface InterfaceWithField {
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy6671Bug.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy6671Bug.groovy
index 47f520ee7c..ad8cd07913 100644
--- a/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy6671Bug.groovy
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy6671Bug.groovy
@@ -16,7 +16,6 @@
 
 package org.codehaus.groovy.classgen.asm.sc.bugs
 
-import groovy.transform.NotYetImplemented
 import groovy.transform.stc.StaticTypeCheckingTestCase
 import org.codehaus.groovy.classgen.asm.sc.StaticCompilationTestSupport
 
@@ -60,7 +59,6 @@ def h2 = h1.convert {
 '''
     }
 
-    @NotYetImplemented
     void testGenericsInferenceWithPlaceholderNameClash() {
         assertScript '''
 interface Converter<F, T> {
