diff --git a/src/main/java/org/codehaus/groovy/reflection/CachedClass.java b/src/main/java/org/codehaus/groovy/reflection/CachedClass.java
index 5f2942ec71..5457a63431 100644
--- a/src/main/java/org/codehaus/groovy/reflection/CachedClass.java
+++ b/src/main/java/org/codehaus/groovy/reflection/CachedClass.java
@@ -31,6 +31,8 @@ import org.codehaus.groovy.util.FastArray;
 import org.codehaus.groovy.util.LazyReference;
 import org.codehaus.groovy.util.ReferenceBundle;
 
+import java.lang.reflect.AccessibleObject;
+import java.lang.reflect.Member;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
@@ -50,27 +52,41 @@ public class CachedClass {
 
     private static ReferenceBundle softBundle = ReferenceBundle.getSoftBundle();
 
+    @SuppressWarnings("removal") // TODO: perform the action as not privileged
+    private static <T> T doPrivileged(java.security.PrivilegedAction<T> action) {
+        return java.security.AccessController.doPrivileged(action);
+    }
+
+    private static <M extends AccessibleObject & Member> boolean isAccessibleOrCanSetAccessible(M m) {
+        if (isProtected(m.getModifiers()) && isPublic(m.getDeclaringClass().getModifiers())) {
+            return true;
+        }
+        return ReflectionUtils.checkCanSetAccessible(m, CachedClass.class);
+    }
+
     private final LazyReference<CachedField[]> fields = new LazyReference<CachedField[]>(softBundle) {
         private static final long serialVersionUID = 5450437842165410025L;
 
         @Override
         public CachedField[] initValue() {
             return doPrivileged(() -> Arrays.stream(getTheClass().getDeclaredFields())
-                .filter(f -> ReflectionUtils.checkCanSetAccessible(f, CachedClass.class))
-                .map(CachedField::new).toArray(CachedField[]::new));
+                .filter(CachedClass::isAccessibleOrCanSetAccessible)
+                .map(CachedField::new).toArray(CachedField[]::new)
+            );
         }
     };
 
-    private LazyReference<CachedConstructor[]> constructors = new LazyReference<CachedConstructor[]>(softBundle) {
+    private final LazyReference<CachedConstructor[]> constructors = new LazyReference<CachedConstructor[]>(softBundle) {
         private static final long serialVersionUID = -5834446523983631635L;
 
         @Override
         public CachedConstructor[] initValue() {
             return doPrivileged(() -> Arrays.stream(getTheClass().getDeclaredConstructors())
                 .filter(c -> !c.isSynthetic()) // GROOVY-9245: exclude inner class ctors
-                .filter(c -> ReflectionUtils.checkCanSetAccessible(c, CachedClass.class) || (isProtected(c.getModifiers()) && isPublic(c.getDeclaringClass().getModifiers())))
+                .filter(CachedClass::isAccessibleOrCanSetAccessible)
                 .map(c -> new CachedConstructor(CachedClass.this, c))
-                .toArray(CachedConstructor[]::new));
+                .toArray(CachedConstructor[]::new)
+            );
         }
     };
 
@@ -82,7 +98,7 @@ public class CachedClass {
             CachedMethod[] declaredMethods = doPrivileged(() -> {
                 try {
                     return Arrays.stream(getTheClass().getDeclaredMethods())
-                        .filter(m -> ReflectionUtils.checkCanSetAccessible(m, CachedClass.class) || (isProtected(m.getModifiers()) && isPublic(m.getDeclaringClass().getModifiers())))
+                        .filter(CachedClass::isAccessibleOrCanSetAccessible)
                         .map(m -> new CachedMethod(CachedClass.this, m))
                         .toArray(CachedMethod[]::new);
                 } catch (LinkageError e) {
@@ -116,26 +132,6 @@ public class CachedClass {
         }
     };
 
-    private LazyReference<CachedClass> cachedSuperClass = new LazyReference<CachedClass>(softBundle) {
-        private static final long serialVersionUID = -4663740963306806058L;
-
-        @Override
-        public CachedClass initValue() {
-            if (!isArray) {
-                return ReflectionCache.getCachedClass(getTheClass().getSuperclass());
-            } else if (cachedClass.getComponentType().isPrimitive() || cachedClass.getComponentType() == Object.class) {
-                return ReflectionCache.OBJECT_CLASS;
-            } else {
-                return ReflectionCache.OBJECT_ARRAY_CLASS;
-            }
-        }
-    };
-
-    @SuppressWarnings("removal") // TODO: a future Groovy version should perform the action not as a privileged action
-    private static <T> T doPrivileged(java.security.PrivilegedAction<T> action) {
-        return java.security.AccessController.doPrivileged(action);
-    }
-
     private final LazyReference<CallSiteClassLoader> callSiteClassLoader = new LazyReference<CallSiteClassLoader>(softBundle) {
         private static final long serialVersionUID = 4410385968428074090L;
 
@@ -207,6 +203,23 @@ public class CachedClass {
         }
     };
 
+    private final LazyReference<CachedClass> superClass = new LazyReference<CachedClass>(softBundle) {
+        private static final long serialVersionUID = -4663740963306806058L;
+
+        @Override
+        public CachedClass initValue() {
+            if (!isArray) {
+                return ReflectionCache.getCachedClass(getTheClass().getSuperclass());
+            } else if (cachedClass.getComponentType().isPrimitive() || cachedClass.getComponentType() == Object.class) {
+                return ReflectionCache.OBJECT_CLASS;
+            } else {
+                return ReflectionCache.OBJECT_ARRAY_CLASS;
+            }
+        }
+    };
+
+    //--------------------------------------------------------------------------
+
     private final Class<?> cachedClass;
     public ClassInfo classInfo;
     public final boolean isArray;
@@ -237,7 +250,7 @@ public class CachedClass {
     }
 
     public CachedClass getCachedSuperClass() {
-        return cachedSuperClass.get();
+        return superClass.get();
     }
 
     public Set<CachedClass> getInterfaces() {
@@ -476,6 +489,21 @@ public class CachedClass {
         return hierarchy.get();
     }
 
+    /**
+     * compatibility method
+     * @return this
+     */
+    public CachedClass getCachedClass() {
+        return this;
+    }
+
+    @Override
+    public String toString() {
+        return cachedClass.toString();
+    }
+
+    //--------------------------------------------------------------------------
+
     public static class CachedMethodComparatorByName implements Comparator<CachedMethod> {
         public static final Comparator INSTANCE = new CachedMethodComparatorByName();
 
@@ -496,17 +524,4 @@ public class CachedClass {
                 return ((String) o1).compareTo(((CachedMethod) o2).getName());
         }
     }
-
-    @Override
-    public String toString() {
-        return cachedClass.toString();
-    }
-
-    /**
-     * compatibility method
-     * @return this
-     */
-    public CachedClass getCachedClass () {
-        return this;
-    }
 }
diff --git a/src/main/java/org/codehaus/groovy/reflection/ReflectionUtils.java b/src/main/java/org/codehaus/groovy/reflection/ReflectionUtils.java
index f88205fd0a..ed3d09da18 100644
--- a/src/main/java/org/codehaus/groovy/reflection/ReflectionUtils.java
+++ b/src/main/java/org/codehaus/groovy/reflection/ReflectionUtils.java
@@ -32,7 +32,6 @@ import java.security.PrivilegedAction;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
-import java.util.HashSet;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Optional;
@@ -46,34 +45,30 @@ import java.util.function.Function;
  */
 @SuppressWarnings("rawtypes")
 public class ReflectionUtils {
-    private static final VMPlugin VM_PLUGIN = VMPluginFactory.getPlugin();
+
+    private static final Class<?>[] EMPTY_CLASS_ARRAY = {};
 
     /** The packages in the call stack that are only part of the Groovy MOP. */
-    private static final Set<String> IGNORED_PACKAGES;
-    private static final Class<?>[] EMPTY_CLASS_ARRAY = new Class<?>[0];
+    private static final Set<String> IGNORED_PACKAGES = Set.of(
+        "groovy.lang",
+        "sun.reflect",
+        "java.security",
+        "java.lang.invoke",
+      //"java.lang.reflect",
+        "org.codehaus.groovy.reflection",
+        "org.codehaus.groovy.runtime",
+        "org.codehaus.groovy.runtime.callsite",
+        "org.codehaus.groovy.runtime.metaclass",
+        "org.codehaus.groovy.vmplugin.v5",
+        "org.codehaus.groovy.vmplugin.v6",
+        "org.codehaus.groovy.vmplugin.v7",
+        "org.codehaus.groovy.vmplugin.v8",
+        "org.codehaus.groovy.vmplugin.v9",
+        "org.codehaus.groovy.vmplugin.v10",
+        "org.codehaus.groovy.vmplugin.v16"
+    );
 
-    static {
-        Set<String> set = new HashSet<>();
-
-        set.add("groovy.lang");
-        set.add("sun.reflect");
-        set.add("java.security");
-        set.add("java.lang.invoke");
-      //set.add("java.lang.reflect");
-        set.add("org.codehaus.groovy.reflection");
-        set.add("org.codehaus.groovy.runtime");
-        set.add("org.codehaus.groovy.runtime.callsite");
-        set.add("org.codehaus.groovy.runtime.metaclass");
-        set.add("org.codehaus.groovy.vmplugin.v5");
-        set.add("org.codehaus.groovy.vmplugin.v6");
-        set.add("org.codehaus.groovy.vmplugin.v7");
-        set.add("org.codehaus.groovy.vmplugin.v8");
-        set.add("org.codehaus.groovy.vmplugin.v9");
-        set.add("org.codehaus.groovy.vmplugin.v10");
-        set.add("org.codehaus.groovy.vmplugin.v16");
-
-        IGNORED_PACKAGES = Collections.unmodifiableSet(set);
-    }
+    private static final VMPlugin VM_PLUGIN = VMPluginFactory.getPlugin();
 
     private static final ClassContextHelper HELPER = new ClassContextHelper();
 
diff --git a/src/main/java/org/codehaus/groovy/vmplugin/v8/Selector.java b/src/main/java/org/codehaus/groovy/vmplugin/v8/Selector.java
index eb1f0d27ad..8851bc0da3 100644
--- a/src/main/java/org/codehaus/groovy/vmplugin/v8/Selector.java
+++ b/src/main/java/org/codehaus/groovy/vmplugin/v8/Selector.java
@@ -60,7 +60,6 @@ import java.lang.invoke.MethodType;
 import java.lang.invoke.MutableCallSite;
 import java.lang.reflect.Array;
 import java.lang.reflect.Constructor;
-import java.lang.reflect.Field;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.util.ArrayList;
@@ -283,7 +282,7 @@ public abstract class Selector {
     }
 
     private static class PropertySelector extends MethodSelector {
-        private boolean insertName = false;
+        private boolean insertName;
 
         public PropertySelector(MutableCallSite callSite, Class<?> sender, String methodName, CallType callType, boolean safeNavigation, boolean thisCall, boolean spreadCall, Object[] arguments) {
             super(callSite, sender, methodName, callType, safeNavigation, thisCall, spreadCall, arguments);
@@ -333,23 +332,15 @@ public abstract class Selector {
 
             var mp = mci.getEffectiveGetMetaProperty(selectionBase, receiver, name, false);
             if (mp instanceof MethodMetaProperty) {
-                MethodMetaProperty mmp = (MethodMetaProperty) mp;
-                method = mmp.getMetaMethod();
-                insertName = true;
-            } else if (mp instanceof CachedField) {
-                CachedField cf = (CachedField) mp;
-                Field f = cf.getCachedField();
+                method = ((MethodMetaProperty) mp).getMetaMethod();
+                insertName = true; // pass "name" field as argument
+            } else if (mp instanceof CachedField && !Modifier.isStatic(mp.getModifiers())) {
                 try {
-                    handle = LOOKUP.unreflectGetter(f);
-                    if (cf.isStatic()) {
-                        // normally we would do the following
-                        // handle = MethodHandles.dropArguments(handle, 0, Class.class);
-                        // but because there is a bug in invokedynamic in all jdk7 versions
-                        // maybe use Unsafe.ensureClassInitialized
-                        handle = META_PROPERTY_GETTER.bindTo(mp);
-                    }
-                } catch (IllegalAccessException iae) {
-                    throw new GroovyBugError(iae);
+                    MethodHandles.Lookup lookup = Modifier.isPublic(mp.getModifiers()) ? LOOKUP
+                      : ((Java8) VMPluginFactory.getPlugin()).newLookup(sender); // GROOVY-9596
+                    handle = lookup.unreflectGetter(((CachedField) mp).getCachedField());
+                } catch (IllegalAccessException e) {
+                    throw new GroovyBugError(e);
                 }
             } else {
                 handle = META_PROPERTY_GETTER.bindTo(mp);
@@ -599,14 +590,15 @@ public abstract class Selector {
             Object[] newArgs = removeRealReceiver(args);
             if (receiver instanceof Class) {
                 if (LOG_ENABLED) LOG.info("receiver is a class");
-                if (!mci.hasCustomStaticInvokeMethod()) method = mci.retrieveStaticMethod(name, newArgs);
-            } else {
+                if (!mci.hasCustomStaticInvokeMethod())
+                    method = mci.retrieveStaticMethod(name, newArgs);
+            }
+            else if (!mci.hasCustomInvokeMethod()) {
                 String name = this.name;
                 if (name.equals("call") && receiver instanceof GeneratedClosure) {
                     name = "doCall";
                 }
-                if (!mci.hasCustomInvokeMethod())
-                    method = mci.getMethodWithCaching(selectionBase, name, newArgs, false);
+                method = mci.getMethodWithCaching(selectionBase, name, newArgs, false);
             }
             if (LOG_ENABLED) LOG.info("retrieved method from meta class: " + method);
         }
diff --git a/src/test/groovy/IllegalAccessTests.groovy b/src/test/groovy/IllegalAccessTests.groovy
index 41ecd15c64..0a617ee4e0 100644
--- a/src/test/groovy/IllegalAccessTests.groovy
+++ b/src/test/groovy/IllegalAccessTests.groovy
@@ -231,14 +231,14 @@ final class IllegalAccessTests {
             }
             assert reader.readLine() == '1234567890'
         '''
-if (!isAtLeastJdk('16.0')) // TODO
+
         assertScript '''
             class MyFilterReader extends FilterReader {
                 MyFilterReader(Reader reader) {
                     super(new BufferedReader(reader))
                 }
                 String nextLine() {
-                    ((BufferedReader) in).readLine()?.trim()
+                    in.readLine()?.trim()
                 }
             }
 
