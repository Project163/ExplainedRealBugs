diff --git a/src/main/org/codehaus/groovy/transform/sc/StaticCompilationVisitor.java b/src/main/org/codehaus/groovy/transform/sc/StaticCompilationVisitor.java
index d492a6c0a7..70ed8af7fc 100644
--- a/src/main/org/codehaus/groovy/transform/sc/StaticCompilationVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/sc/StaticCompilationVisitor.java
@@ -366,20 +366,54 @@ public class StaticCompilationVisitor extends StaticTypeCheckingVisitor {
             public void visitField(final FieldNode node) {
                 if (visitor!=null) visitor.visitField(node);
                 ClassNode declaringClass = node.getDeclaringClass();
-                if (declaringClass!=null) rType.set(declaringClass);
+                if (declaringClass!=null) {
+                    if (StaticTypeCheckingSupport.implementsInterfaceOrIsSubclassOf(declaringClass, ClassHelper.LIST_TYPE)) {
+                        boolean spread = declaringClass.getDeclaredField(node.getName()) != node;
+                        pexp.setSpreadSafe(spread);
+                    }
+                    rType.set(declaringClass);
+                }
             }
 
             public void visitMethod(final MethodNode node) {
                 if (visitor!=null) visitor.visitMethod(node);
                 ClassNode declaringClass = node.getDeclaringClass();
-                if (declaringClass!=null) rType.set(declaringClass);
+                if (declaringClass!=null){
+                    if (StaticTypeCheckingSupport.implementsInterfaceOrIsSubclassOf(declaringClass, ClassHelper.LIST_TYPE)) {
+                        List<MethodNode> properties = declaringClass.getDeclaredMethods(node.getName());
+                        boolean spread = true;
+                        for (MethodNode mn : properties) {
+                            if (node==mn) {
+                                spread = false;
+                                break;
+                            }
+                        }
+                        // it's no real property but a property of the component
+                        pexp.setSpreadSafe(spread);
+                    }
+                    rType.set(declaringClass);
+                }
             }
 
             @Override
             public void visitProperty(final PropertyNode node) {
                 if (visitor!=null) visitor.visitProperty(node);
                 ClassNode declaringClass = node.getDeclaringClass();
-                if (declaringClass!=null) rType.set(declaringClass);
+                if (declaringClass!=null) {
+                    if (StaticTypeCheckingSupport.implementsInterfaceOrIsSubclassOf(declaringClass, ClassHelper.LIST_TYPE)) {
+                        List<PropertyNode> properties = declaringClass.getProperties();
+                        boolean spread = true;
+                        for (PropertyNode propertyNode : properties) {
+                            if (propertyNode==node) {
+                                spread = false;
+                                break;
+                            }
+                        }
+                        // it's no real property but a property of the component
+                        pexp.setSpreadSafe(spread);
+                    }
+                    rType.set(declaringClass);
+                }
             }
         };
         boolean exists = super.existsProperty(pexp, checkForReadOnly, receiverMemoizer);
diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 8a0175148d..02d883a3f6 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -1351,7 +1351,8 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         AtomicReference<ClassNode> result = new AtomicReference<ClassNode>();
         if (existsProperty(subExp, true, new PropertyLookupVisitor(result))) {
             intf = LIST_TYPE.getPlainNodeReference();
-            intf.setGenericsTypes(new GenericsType[] { new GenericsType(getWrapper(result.get()))});
+            ClassNode itemType = result.get();
+            intf.setGenericsTypes(new GenericsType[] { new GenericsType(wrapTypeIfNecessary(itemType))});
             return intf;
         }
         return null;
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7324Bug.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7324Bug.groovy
new file mode 100644
index 0000000000..f12fdaf187
--- /dev/null
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7324Bug.groovy
@@ -0,0 +1,74 @@
+/*
+ * Copyright 2003-2015 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+
+package org.codehaus.groovy.classgen.asm.sc.bugs
+
+import groovy.transform.stc.StaticTypeCheckingTestCase
+import org.codehaus.groovy.classgen.asm.sc.StaticCompilationTestSupport
+
+class Groovy7324Bug extends StaticTypeCheckingTestCase implements StaticCompilationTestSupport {
+    void testInferenceOfListDotOperator() {
+        assertScript '''class Account {
+    String id
+}
+
+class GCAccount {
+    List<Account> sfAccounts
+}
+
+class User {
+    List<GCAccount> gcAccounts
+}
+
+void foo() {
+    def accounts = (1..10).collect { new Account(id: "Id $it") }
+    def user1 = new User(gcAccounts: [new GCAccount(sfAccounts: accounts[0..2]), new GCAccount(sfAccounts: accounts[3..4])])
+    def user2 = new User(gcAccounts: [new GCAccount(sfAccounts: accounts[5..7]), new GCAccount(sfAccounts: accounts[8..9])])
+    def users = [user1,user2]
+    def ids = users.gcAccounts.sfAccounts.id.flatten()
+    println ids
+}
+
+foo()
+        '''
+    }
+
+    void testInferenceOfSpreadDotOperator() {
+        assertScript '''class Account {
+    String id
+}
+
+class GCAccount {
+    List<Account> sfAccounts
+}
+
+class User {
+    List<GCAccount> gcAccounts
+}
+
+void foo() {
+    def accounts = (1..10).collect { new Account(id: "Id $it") }
+    def user = new User(gcAccounts: [new GCAccount(sfAccounts: accounts[0..2]), new GCAccount(sfAccounts: accounts[3..4])])
+    def ids = user.gcAccounts*.sfAccounts*.id.flatten()
+    println ids
+}
+
+foo()
+        '''
+    }
+}
