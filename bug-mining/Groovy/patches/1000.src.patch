diff --git a/src/main/org/codehaus/groovy/classgen/AnnotationVisitor.java b/src/main/org/codehaus/groovy/classgen/AnnotationVisitor.java
index 66839f1235..5b3c60f2bc 100644
--- a/src/main/org/codehaus/groovy/classgen/AnnotationVisitor.java
+++ b/src/main/org/codehaus/groovy/classgen/AnnotationVisitor.java
@@ -16,6 +16,8 @@
 package org.codehaus.groovy.classgen;
 
 import java.util.*;
+import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;
 
 import org.codehaus.groovy.ast.*;
 import org.codehaus.groovy.ast.stmt.ReturnStatement;
@@ -66,7 +68,8 @@ public class AnnotationVisitor {
         Map<String, Expression> attributes = node.getMembers();
         for (Map.Entry entry : attributes.entrySet()) {
             String attrName = (String) entry.getKey();
-            Expression attrExpr = (Expression) entry.getValue();
+            Expression attrExpr = transformInlineConstants((Expression) entry.getValue());
+            entry.setValue(attrExpr);
             ClassNode attrType = getAttributeType(node, attrName);
             visitExpression(attrName, attrExpr, attrType);
         }
@@ -74,6 +77,36 @@ public class AnnotationVisitor {
         return this.annotation;
     }
 
+    private Expression transformInlineConstants(Expression exp) {
+        if (exp instanceof PropertyExpression) {
+            PropertyExpression pe = (PropertyExpression) exp;
+            if (pe.getObjectExpression() instanceof ClassExpression) {
+                ClassExpression ce = (ClassExpression) pe.getObjectExpression();
+                ClassNode type = ce.getType();
+                if (type.isEnum() || !type.isResolved())
+                    return exp;
+
+                try {
+                    type.getFields();
+                    Field field = type.getTypeClass().getField(pe.getPropertyAsString());
+                    if (field != null && Modifier.isStatic(field.getModifiers()) && Modifier.isFinal(field.getModifiers())) {
+                        return new ConstantExpression(field.get(null));
+                    }
+                } catch(Exception e) {
+                    // ignore, leave property expression in place and we'll report later
+                }
+            }
+        } else if (exp instanceof ListExpression) {
+            ListExpression le = (ListExpression) exp;
+            ListExpression result = new ListExpression();
+            for (Expression e : le.getExpressions()) {
+                result.addExpression(transformInlineConstants(e));
+            }
+            return result;
+        }
+        return exp;
+    }
+
     private boolean checkIfMandatoryAnnotationValuesPassed(AnnotationNode node) {
         boolean ok = true;
         Map attributes = node.getMembers();
diff --git a/src/main/org/codehaus/groovy/control/ResolveVisitor.java b/src/main/org/codehaus/groovy/control/ResolveVisitor.java
index 53091ed17a..1bc98558d2 100644
--- a/src/main/org/codehaus/groovy/control/ResolveVisitor.java
+++ b/src/main/org/codehaus/groovy/control/ResolveVisitor.java
@@ -34,7 +34,6 @@ import java.net.MalformedURLException;
 import java.net.URL;
 import java.net.URLConnection;
 import java.util.*;
-import java.lang.reflect.Field;
 
 /**
  * Visitor to resolve Types and convert VariableExpression to
@@ -957,7 +956,7 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
             for (Map.Entry member : an.getMembers().entrySet()) {
                 Expression memberValue = (Expression) member.getValue();
                 Expression newValue = transform(memberValue);
-                newValue = transformConstantAttributeExpression(newValue);
+                newValue = transformInlineConstants(newValue);
                 member.setValue(newValue);
                 checkAnnotationMemberValue(newValue);
             }
@@ -965,7 +964,7 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
     }
 
     // resolve constant-looking expressions statically (do here as gets transformed away later)
-    private Expression transformConstantAttributeExpression(Expression exp) {
+    private Expression transformInlineConstants(Expression exp) {
         if (exp instanceof PropertyExpression) {
             PropertyExpression pe = (PropertyExpression) exp;
             if (pe.getObjectExpression() instanceof ClassExpression) {
@@ -980,25 +979,28 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
                         return fn.getInitialValueExpression();
                     }
                 }
-
-                try {
-                    if (type.isResolved()) {
-                        Field field = type.getTypeClass().getField(pe.getPropertyAsString());
-                        if (field != null) {
-                            return new ConstantExpression(field.get(null));
-                        }
-                    }
-                } catch(Exception e) {/*ignore*/}
             }
         } else if (exp instanceof ListExpression) {
             ListExpression le = (ListExpression) exp;
             ListExpression result = new ListExpression();
             for (Expression e : le.getExpressions()) {
-                result.addExpression(transformConstantAttributeExpression(e));
+                result.addExpression(transformInlineConstants(e));
             }
             return result;
-        }
+        } else if (exp instanceof AnnotationConstantExpression) {
+            ConstantExpression ce = (ConstantExpression) exp;
+            if (ce.getValue() instanceof AnnotationNode) {
+                // replicate a little bit of AnnotationVisitor here
+                // because we can't wait until later to do this
+                AnnotationNode an = (AnnotationNode) ce.getValue();
+                Map<String, Expression> attributes = an.getMembers();
+                for (Map.Entry entry : attributes.entrySet()) {
+                    Expression attrExpr = transformInlineConstants((Expression) entry.getValue());
+                    entry.setValue(attrExpr);
+                }
 
+            }
+        }
         return exp;
     }
 
diff --git a/src/main/org/codehaus/groovy/control/StaticImportVisitor.java b/src/main/org/codehaus/groovy/control/StaticImportVisitor.java
index 1b5877868f..60d75727d6 100644
--- a/src/main/org/codehaus/groovy/control/StaticImportVisitor.java
+++ b/src/main/org/codehaus/groovy/control/StaticImportVisitor.java
@@ -21,7 +21,6 @@ import org.codehaus.groovy.ast.stmt.Statement;
 import org.objectweb.asm.Opcodes;
 
 import java.util.*;
-import java.lang.reflect.Field;
 
 /**
  * Visitor to resolve constants and method calls from static Imports
@@ -121,7 +120,7 @@ public class StaticImportVisitor extends ClassCodeExpressionTransformer {
             if (result != null) {
             	result.setSourcePosition(ve);
                 if (inAnnotation) {
-                    result = transformConstantAttributeExpression(result);
+                    result = transformInlineConstants(result);
                 }
             	return result;
             }
@@ -131,7 +130,7 @@ public class StaticImportVisitor extends ClassCodeExpressionTransformer {
     }
 
     // resolve constant-looking expressions statically (do here as gets transformed away later)
-    private Expression transformConstantAttributeExpression(Expression exp) {
+    private Expression transformInlineConstants(Expression exp) {
         if (exp instanceof PropertyExpression) {
             PropertyExpression pe = (PropertyExpression) exp;
             if (pe.getObjectExpression() instanceof ClassExpression) {
@@ -144,20 +143,12 @@ public class StaticImportVisitor extends ClassCodeExpressionTransformer {
                         return fn.getInitialValueExpression();
                     }
                 }
-                try {
-                    if (type.isResolved()) {
-                        Field field = type.getTypeClass().getField(pe.getPropertyAsString());
-                        if (field != null) {
-                            return new ConstantExpression(field.get(null));
-                        }
-                    }
-                } catch(Exception e) {/*ignore*/}
             }
         } else if (exp instanceof ListExpression) {
             ListExpression le = (ListExpression) exp;
             ListExpression result = new ListExpression();
             for (Expression e : le.getExpressions()) {
-                result.addExpression(transformConstantAttributeExpression(e));
+                result.addExpression(transformInlineConstants(e));
             }
             return result;
         }
diff --git a/src/test/gls/annotations/AnnotationTest.groovy b/src/test/gls/annotations/AnnotationTest.groovy
index 35a9d27cb5..bd29da43c8 100644
--- a/src/test/gls/annotations/AnnotationTest.groovy
+++ b/src/test/gls/annotations/AnnotationTest.groovy
@@ -375,13 +375,16 @@ class Foo {}
         }
 
         class Constants {
-            static final String FOO = "foo"
-            static final String BAR = "bar"
-            static final APPROX_PI = 3.14d
+            public static final String BAR = "bar"
+            public static final APPROX_PI = 3.14d
+        }
+
+        interface IConstants {
+            String FOO = "foo"
         }
 
         class ClassWithAnnotationUsingConstant {
-            @Anno(array = [Constants.FOO, BAR, groovy.inspect.Inspector.GROOVY])
+            @Anno(array = [IConstants.FOO, BAR, groovy.inspect.Inspector.GROOVY])
             public annotatedStrings
 
             @Anno(Math.PI)
@@ -396,6 +399,45 @@ class Foo {}
       """
     }
 
+    void testNestedAttributePropertyConstants() {
+        assertScript """
+        import java.lang.annotation.*
+        import static Constants.*
+
+        @Retention(RetentionPolicy.RUNTIME)
+        @Target(ElementType.FIELD)
+        @interface Outer {
+            Inner value()
+            String[] array() default []
+        }
+
+        @Retention(RetentionPolicy.RUNTIME)
+        @Target(ElementType.FIELD)
+        @interface Inner {
+            String[] value() default []
+        }
+
+        class Constants {
+            public static final String BAR = "bar"
+            public static final String BAZ = "baz"
+        }
+
+        interface IConstants {
+            String FOO = "foo"
+            String FOOBAR = "foobar"
+        }
+
+        class ClassWithNestedAnnotationUsingConstant {
+            @Outer(value = @Inner([IConstants.FOOBAR, BAR, groovy.inspect.Inspector.GROOVY]),
+                   array = [IConstants.FOO, groovy.inspect.Inspector.GROOVY, BAZ])
+            public outer
+        }
+
+        assert ClassWithNestedAnnotationUsingConstant.getDeclaredField('outer').annotations[0].array() == ['foo', 'GROOVY', 'baz']
+        assert ClassWithNestedAnnotationUsingConstant.getDeclaredField('outer').annotations[0].value().value() == ['foobar', 'bar', 'GROOVY']
+      """
+    }
+
     void testRuntimeRetentionAtAllLevels() {
         assertScript """
         import java.lang.annotation.*
