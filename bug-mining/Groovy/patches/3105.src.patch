diff --git a/src/main/groovy/lang/MetaClassImpl.java b/src/main/groovy/lang/MetaClassImpl.java
index b32763b0ea..32988a9b3a 100644
--- a/src/main/groovy/lang/MetaClassImpl.java
+++ b/src/main/groovy/lang/MetaClassImpl.java
@@ -1025,7 +1025,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
     }
 
 
-   /**
+    /**
      * <p>Invokes a method on the given receiver for the specified arguments. The sender is the class that invoked the method on the object.
      * The MetaClass will attempt to establish the method to invoke based on the name and arguments provided.
      *
@@ -2371,7 +2371,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
         for (CachedClass klass : superClasses) {
             SingleKeyHashMap propertyIndex = classPropertyIndex.getNotNull(klass);
             if (last != null) {
-                copyNonPrivateFields(last, propertyIndex);
+                copyNonPrivateFields(last, propertyIndex, klass);
             }
             last = propertyIndex;
             addFields(klass, propertyIndex);
@@ -2386,14 +2386,31 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
     }
 
     private static void copyNonPrivateFields(SingleKeyHashMap from, SingleKeyHashMap to) {
+        copyNonPrivateFields(from, to, null);
+    }
+
+    private static void copyNonPrivateFields(SingleKeyHashMap from, SingleKeyHashMap to, CachedClass klass) {
         for (ComplexKeyHashMap.EntryIterator iter = from.getEntrySetIterator(); iter.hasNext();) {
             SingleKeyHashMap.Entry entry = (SingleKeyHashMap.Entry) iter.next();
             CachedField mfp = (CachedField) entry.getValue();
-            if (!Modifier.isPublic(mfp.getModifiers()) && !Modifier.isProtected(mfp.getModifiers())) continue;
+            if (!inheritedOrPublic(mfp) && !packageLocal(mfp, klass)) continue;
             to.put(entry.getKey(), mfp);
         }
     }
 
+    private static boolean inheritedOrPublic(CachedField mfp) {
+        return Modifier.isPublic(mfp.getModifiers()) || Modifier.isProtected(mfp.getModifiers());
+    }
+
+    private static boolean packageLocal(CachedField mfp, CachedClass klass) {
+        if ((mfp.getModifiers() & (Modifier.PRIVATE | Modifier.PUBLIC | Modifier.PROTECTED)) != 0 || klass == null)
+            return false;
+        Package fieldPackage = mfp.field.getDeclaringClass().getPackage();
+        Package classPackage = klass.getTheClass().getPackage();
+        return (fieldPackage == null && classPackage == null) ||
+                fieldPackage != null && classPackage != null && fieldPackage.getName().equals(classPackage.getName());
+    }
+
     private void applyStrayPropertyMethods(LinkedList<CachedClass> superClasses, Index classPropertyIndex, boolean isThis) {
         // now look for any stray getters that may be used to define a property
         for (CachedClass klass : superClasses) {
diff --git a/src/test/groovy/bugs/Groovy5396Bug.groovy b/src/test/groovy/bugs/Groovy5396Bug.groovy
new file mode 100644
index 0000000000..8157ad4b24
--- /dev/null
+++ b/src/test/groovy/bugs/Groovy5396Bug.groovy
@@ -0,0 +1,38 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package groovy.bugs
+
+class Groovy5396Bug extends GroovyTestCase {
+    void testClassAccessToPackageLocalPropertyInSuper() {
+        assertScript """
+            class GroovyBase extends AbstractBase {
+                GroovyBase(int n) { super(n) }
+                int mult(int n) { n * base }
+            }
+
+            abstract class AbstractBase {
+                @groovy.transform.PackageScope int base
+                AbstractBase(int base) { this.base = base }
+                abstract int mult(int n)
+            }
+
+            assert new GroovyBase(10).mult(3) == 30
+        """
+    }
+}
\ No newline at end of file
