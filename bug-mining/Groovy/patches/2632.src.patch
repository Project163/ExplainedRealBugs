diff --git a/src/main/org/codehaus/groovy/classgen/InnerClassVisitor.java b/src/main/org/codehaus/groovy/classgen/InnerClassVisitor.java
index b4f66ee6c2..04cec9b414 100644
--- a/src/main/org/codehaus/groovy/classgen/InnerClassVisitor.java
+++ b/src/main/org/codehaus/groovy/classgen/InnerClassVisitor.java
@@ -23,6 +23,7 @@ import org.codehaus.groovy.ast.MethodNode;
 import org.codehaus.groovy.ast.Parameter;
 import org.codehaus.groovy.ast.PropertyNode;
 import org.codehaus.groovy.ast.VariableScope;
+import org.codehaus.groovy.ast.expr.ClosureExpression;
 import org.codehaus.groovy.ast.expr.ConstructorCallExpression;
 import org.codehaus.groovy.ast.expr.Expression;
 import org.codehaus.groovy.ast.expr.PropertyExpression;
@@ -47,6 +48,7 @@ public class InnerClassVisitor extends InnerClassVisitorHelper implements Opcode
     private MethodNode currentMethod;
     private FieldNode currentField;
     private boolean processingObjInitStatements = false;
+    private boolean inClosure = false;
 
     public InnerClassVisitor(CompilationUnit cu, SourceUnit su) {
         sourceUnit = su;
@@ -79,6 +81,14 @@ public class InnerClassVisitor extends InnerClassVisitorHelper implements Opcode
             node.setUnresolvedSuperClass(ClassHelper.OBJECT_TYPE);
         }
     }
+    
+    @Override
+    public void visitClosureExpression(ClosureExpression expression) {
+        boolean inClosureOld = inClosure;
+        inClosure = true;
+        super.visitClosureExpression(expression);
+        inClosure = inClosureOld;
+    }
 
     @Override
     protected void visitObjectInitializerStatements(ClassNode node) {
@@ -180,7 +190,10 @@ public class InnerClassVisitor extends InnerClassVisitorHelper implements Opcode
         // this is saved in a field named this$0
         pCount = 0;
         expressions.add(pCount, VariableExpression.THIS_EXPRESSION);
-        ClassNode outerClassType = getClassNode(innerClass.getOuterClass(), isStaticThis(innerClass,scope)).getPlainNodeReference();
+        boolean isStatic = isStaticThis(innerClass,scope);
+        ClassNode outerClassType = getClassNode(innerClass.getOuterClass(), isStatic);
+        if (!isStatic && inClosure) outerClassType = ClassHelper.CLOSURE_TYPE;
+        outerClassType = outerClassType.getPlainNodeReference();
         Parameter thisParameter = new Parameter(outerClassType, "p" + pCount);
         parameters.add(pCount, thisParameter);
 
@@ -211,9 +224,14 @@ public class InnerClassVisitor extends InnerClassVisitorHelper implements Opcode
     }
 
     private boolean isStaticThis(InnerClassNode innerClass, VariableScope scope) {
-        boolean ret = scope.isInStaticContext() || innerClass.isStaticClass();
-        if (innerClass.getEnclosingMethod()!=null) {
+        if (inClosure) return false;
+        boolean ret = innerClass.isStaticClass();
+        if (    innerClass.getEnclosingMethod()!=null) {
             ret = ret || innerClass.getEnclosingMethod().isStatic();
+        } else if (currentField!=null) {
+            ret = ret || currentField.isStatic();
+        } else if (currentMethod!=null && "<clinit>".equals(currentMethod.getName())) {
+            ret = true;
         }
         return ret;
     }
diff --git a/src/main/org/codehaus/groovy/classgen/asm/InvocationWriter.java b/src/main/org/codehaus/groovy/classgen/asm/InvocationWriter.java
index ebd7b61f03..fac5cc89c9 100644
--- a/src/main/org/codehaus/groovy/classgen/asm/InvocationWriter.java
+++ b/src/main/org/codehaus/groovy/classgen/asm/InvocationWriter.java
@@ -542,7 +542,14 @@ public class InvocationWriter {
         String ownerDescriptor = prepareConstructorCall(cn);
         
         List<Expression> args = makeArgumentList(call.getArguments()).getExpressions();
-        Parameter[] params = cn.getParameters(); 
+        Parameter[] params = cn.getParameters();
+        // if a this appears as parameter here, then it should be
+        // not static, unless we are in a static method. But since 
+        // ACG#visitVariableExpression does the opposite for this case, we
+        // push here an explicit this. This should not have any negative effect
+        // sine visiting a method call or property with implicit this will push
+        // a new value for this again.
+        controller.getCompileStack().pushImplicitThis(true);
         for (int i=0; i<params.length; i++) {
             Parameter p = params[i];
             Expression arg = args.get(i);
@@ -554,7 +561,7 @@ public class InvocationWriter {
             }
             os.doGroovyCast(p.getType());
         }
-        
+        controller.getCompileStack().popImplicitThis();
         finnishConstructorCall(cn, ownerDescriptor, args.size());
         return true;
     }
diff --git a/src/test/groovy/ClosureMethodCallTest.groovy b/src/test/groovy/ClosureMethodCallTest.groovy
index e6ab0accb6..282ee0248d 100644
--- a/src/test/groovy/ClosureMethodCallTest.groovy
+++ b/src/test/groovy/ClosureMethodCallTest.groovy
@@ -56,4 +56,22 @@ class ClosureMethodCallTest extends GroovyTestCase {
         def closure = System.out.&println
         closure("Hello world")
     }
+    
+    //GROOVY-6819
+    void test() {
+        assertScript '''
+            class Foo {
+                static justcallme(Closure block) {
+                    block()
+                }
+                static foo() {2}
+                static bar(Closure block) {
+                    this.justcallme {
+                        this.foo()
+                    }
+                }
+            }
+            assert Foo.bar() {} == 2
+        '''
+    }
 }
diff --git a/src/test/groovy/transform/stc/AnonymousInnerClassSTCTest.groovy b/src/test/groovy/transform/stc/AnonymousInnerClassSTCTest.groovy
index 411cff25dc..a113841f88 100644
--- a/src/test/groovy/transform/stc/AnonymousInnerClassSTCTest.groovy
+++ b/src/test/groovy/transform/stc/AnonymousInnerClassSTCTest.groovy
@@ -127,4 +127,23 @@ class AnonymousInnerClassSTCTest extends StaticTypeCheckingTestCase {
                 s.size()
             }'''
     }
+    
+    void testAICInAICInStaticMethod() {
+        assertScript '''
+            class A {
+                public static foo() {
+                    return new Object() {
+                        public String toString() {
+                            return new Object() {
+                                public String toString() {
+                                    "ii"
+                                }
+                            }.toString()+" i"
+                        }
+                    }.toString()
+                }
+            }
+            assert A.foo() == "ii i"
+        '''
+    }
 }
