diff --git a/src/main/org/codehaus/groovy/classgen/ExtendedVerifier.java b/src/main/org/codehaus/groovy/classgen/ExtendedVerifier.java
index 586e911188..a4012937dd 100644
--- a/src/main/org/codehaus/groovy/classgen/ExtendedVerifier.java
+++ b/src/main/org/codehaus/groovy/classgen/ExtendedVerifier.java
@@ -25,8 +25,18 @@ import org.codehaus.groovy.control.ErrorCollector;
 import org.codehaus.groovy.control.SourceUnit;
 import org.codehaus.groovy.control.messages.SyntaxErrorMessage;
 import org.codehaus.groovy.syntax.SyntaxException;
+import org.codehaus.groovy.transform.AbstractASTTransformation;
 import org.objectweb.asm.Opcodes;
 
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import static org.codehaus.groovy.classgen.Verifier.correctToGenericsSpec;
+import static org.codehaus.groovy.transform.AbstractASTTransformation.correctToGenericsSpecRecurse;
+
 /**
  * A specialized Groovy AST visitor meant to perform additional verifications upon the
  * current AST. Currently it does checks on annotated nodes and annotations itself.
@@ -136,8 +146,7 @@ public class ExtendedVerifier extends ClassCodeVisitorSupport implements GroovyC
                         visited);
             }
             visitDeprecation(node, visited);
-            // TODO GROOVY-5011
-//            visitOverride(node, visited);
+            visitOverride(node, visited);
         }
     }
 
@@ -156,36 +165,69 @@ public class ExtendedVerifier extends ClassCodeVisitorSupport implements GroovyC
         }
     }
 
-    /*
     // TODO GROOVY-5011 handle case of @Override on a property
     private void visitOverride(AnnotatedNode node, AnnotationNode visited) {
         ClassNode annotationClassNode = visited.getClassNode();
         if (annotationClassNode.isResolved() && annotationClassNode.getName().equals("java.lang.Override")) {
             if (node instanceof MethodNode) {
-                MethodNode mn = (MethodNode) node;
+                MethodNode origMethod = (MethodNode) node;
                 ClassNode cNode = node.getDeclaringClass();
-                ClassNode sNode = cNode;
+                Map genericsSpec = Verifier.createGenericsSpec(cNode, new HashMap());
+                ClassNode next = cNode;
                 outer:
-                while (sNode != null) {
-                    if (sNode != cNode && sNode.getDeclaredMethod(mn.getName(), mn.getParameters()) != null) break;
-                    for (ClassNode anInterface : sNode.getInterfaces()) {
-                        ClassNode iNode = anInterface;
-                        while (iNode != null) {
-                            if (iNode.getDeclaredMethod(mn.getName(), mn.getParameters()) != null) break outer;
-                            iNode = iNode.getSuperClass();
+                while (next != null) {
+                    MethodNode mn = AbstractASTTransformation.correctToGenericsSpec(genericsSpec, origMethod);
+                    if (next != cNode) {
+                        ClassNode correctedNext = correctToGenericsSpecRecurse(genericsSpec, next);
+                        MethodNode found = getDeclaredMethodCorrected(genericsSpec, mn, correctedNext);
+                        if (found != null) break;
+                    }
+                    List<ClassNode> ifaces = new ArrayList<ClassNode>();
+                    ifaces.addAll(Arrays.asList(next.getInterfaces()));
+                    Map updatedGenericsSpec = new HashMap(genericsSpec);
+                    while (!ifaces.isEmpty()) {
+                        ClassNode origInterface = ifaces.remove(0);
+                        if (!origInterface.equals(ClassHelper.OBJECT_TYPE)) {
+                            updatedGenericsSpec = Verifier.createGenericsSpec(origInterface, updatedGenericsSpec);
+                            ClassNode iNode = correctToGenericsSpecRecurse(updatedGenericsSpec, origInterface);
+                            MethodNode found2 = getDeclaredMethodCorrected(updatedGenericsSpec, mn, iNode);
+                            if (found2 != null) break outer;
+                            ifaces.addAll(Arrays.asList(iNode.getInterfaces()));
                         }
                     }
-                    sNode = sNode.getSuperClass();
+                    next = next.getSuperClass();
                 }
-                if (sNode == null) {
-                    addError("Method '" + mn.getName() + "' from class '" + cNode.getName() + "' does not override " +
+                if (next == null) {
+                    addError("Method '" + origMethod.getName() + "' from class '" + cNode.getName() + "' does not override " +
                             "method from its superclass or interfaces but is annotated with @Override.", visited);
                 }
             }
         }
     }
-    */
 
+    private MethodNode getDeclaredMethodCorrected(Map genericsSpec, MethodNode mn, ClassNode correctedNext) {
+        for (MethodNode orig :  correctedNext.getDeclaredMethods(mn.getName())) {
+            MethodNode method = AbstractASTTransformation.correctToGenericsSpec(genericsSpec, orig);
+            if (parametersEqual(method.getParameters(), mn.getParameters())) {
+                return method;
+            }
+        }
+        return null;
+    }
+
+    private static boolean parametersEqual(Parameter[] a, Parameter[] b) {
+        if (a.length == b.length) {
+            boolean answer = true;
+            for (int i = 0; i < a.length; i++) {
+                if (!a[i].getType().equals(b[i].getType())) {
+                    answer = false;
+                    break;
+                }
+            }
+            return answer;
+        }
+        return false;
+    }
     /**
      * Resolve metadata and details of the annotation.
      *
diff --git a/src/main/org/codehaus/groovy/transform/AbstractASTTransformation.java b/src/main/org/codehaus/groovy/transform/AbstractASTTransformation.java
index 2639f5a82a..7bc23cf831 100644
--- a/src/main/org/codehaus/groovy/transform/AbstractASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/AbstractASTTransformation.java
@@ -235,7 +235,7 @@ public abstract class AbstractASTTransformation implements Opcodes, ASTTransform
         return makeClassSafe0(type, gtypes);
     }
 
-    static MethodNode correctToGenericsSpec(Map genericsSpec, MethodNode mn) {
+    public static MethodNode correctToGenericsSpec(Map genericsSpec, MethodNode mn) {
         ClassNode correctedType = correctToGenericsSpecRecurse(genericsSpec, mn.getReturnType());
         Parameter[] origParameters = mn.getParameters();
         Parameter[] newParameters = new Parameter[origParameters.length];
@@ -246,7 +246,7 @@ public abstract class AbstractASTTransformation implements Opcodes, ASTTransform
         return new MethodNode(mn.getName(), mn.getModifiers(), correctedType, newParameters, mn.getExceptions(), mn.getCode());
     }
 
-    static ClassNode correctToGenericsSpecRecurse(Map genericsSpec, ClassNode type) {
+    public static ClassNode correctToGenericsSpecRecurse(Map genericsSpec, ClassNode type) {
         if (type.isGenericsPlaceHolder()) {
             String name = type.getGenericsTypes()[0].getName();
             type = (ClassNode) genericsSpec.get(name);
diff --git a/src/test/groovy/OverrideTest.groovy b/src/test/groovy/OverrideTest.groovy
new file mode 100644
index 0000000000..6ea59b1d71
--- /dev/null
+++ b/src/test/groovy/OverrideTest.groovy
@@ -0,0 +1,98 @@
+/*
+ * Copyright 2003-2014 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package groovy
+
+class OverrideTest extends GroovyTestCase {
+    void testHappyPath() {
+        assertScript """
+            abstract class Parent<T> {
+                abstract method()
+                void methodTakeT(T t) { }
+                T methodMakeT() { return null }
+            }
+
+            interface Intf<U> {
+                def method4()
+                void method5(U u)
+                U method6()
+            }
+
+            interface IntfString extends Intf<String> {}
+
+            class OverrideAnnotationTest extends Parent<Integer> implements IntfString {
+                @Override method() {}
+                // TODO should complain about arg not being Integer
+                @Override void methodTakeT(arg) {}
+                @Override Integer methodMakeT() {}
+                @Override method4() {}
+                @Override void method5(String arg) {}
+                @Override String method6() {}
+            }
+
+            new OverrideAnnotationTest()
+        """
+    }
+
+    void testSpuriousMethod() {
+        def message = shouldFail """
+            interface Intf<U> {
+                def method()
+            }
+
+            interface IntfString extends Intf<String> {}
+
+            class HasSpuriousMethod implements IntfString {
+                @Override method() {}
+                @Override someOtherMethod() {}
+            }
+        """
+        assert message.contains("Method 'someOtherMethod' from class 'HasSpuriousMethod' does not override method from its superclass or interfaces but is annotated with @Override.")
+    }
+
+    void testBadReturnType() {
+        def message = shouldFail """
+            interface Intf<U> {
+                def method()
+                U method6()
+            }
+
+            interface IntfString extends Intf<String> {}
+
+            class HasMethodWithBadReturnType implements IntfString {
+                @Override method() {}
+                @Override methodReturnsObject() {}
+            }
+        """
+        assert message.contains("Method 'methodReturnsObject' from class 'HasMethodWithBadReturnType' does not override method from its superclass or interfaces but is annotated with @Override.")
+    }
+
+    void testBadArgType() {
+        def message = shouldFail """
+            interface Intf<U> {
+                def method()
+                void method6(U u)
+            }
+
+            interface IntfString extends Intf<String> {}
+
+            class HasMethodWithBadArgType implements IntfString {
+                @Override method() {}
+                @Override void methodTakesObject(arg) {}
+            }
+        """
+        assert message.contains("Method 'methodTakesObject' from class 'HasMethodWithBadArgType' does not override method from its superclass or interfaces but is annotated with @Override.")
+    }
+}
