diff --git a/src/main/java/org/codehaus/groovy/util/ListHashMap.java b/src/main/java/org/codehaus/groovy/util/ListHashMap.java
index ec2d8b049c..8fe48a18d8 100644
--- a/src/main/java/org/codehaus/groovy/util/ListHashMap.java
+++ b/src/main/java/org/codehaus/groovy/util/ListHashMap.java
@@ -18,39 +18,37 @@
  */
 package org.codehaus.groovy.util;
 
-import java.util.ArrayList;
 import java.util.Collection;
-import java.util.HashMap;
-import java.util.List;
+import java.util.Collections;
 import java.util.Map;
 import java.util.Set;
 
 /**
- * This class represents a {@link Map} that is optimized for a small number of
- * entries.  For a number of entries up to {@code listSize} the entries
- * are stored in arrays.  After {@code listSize} entries are exceeded
- * storage switches internally to a {@link Map} and converts back
- * to being array based when its size is less than or equal to {@code listSize}.
- *
+ * Represents a {@link Map} that is optimized for a small number of entries. For
+ * a number of entries up to {@code listSize} the entries are stored in arrays.
+ * After {@code listSize} entries are exceeded storage switches internally to a
+ * {@link Map} and converts back to being array based when its size is less than
+ * or equal to {@code listSize}.
+ * <p>
  * Null keys or values are not supported.
- *
- * This class is not thread safe.
+ * <p>
+ * This class is not thread-safe!
  */
 public class ListHashMap<K,V> implements Map<K,V> {
-    private final Object[] listKeys;
-    private final Object[] listValues;
-    private int size = 0;
+
+    private final K[] keys;
+    private final V[] values;
     private Map<K,V> innerMap;
-    private final int maxListFill;
+    private volatile int size;
 
     public ListHashMap() {
         this(3);
     }
 
-    public ListHashMap(int listSize){
-        this.listKeys = new Object[listSize];
-        this.listValues = new Object[listSize];
-        maxListFill = listSize;
+    @SuppressWarnings("unchecked")
+    public ListHashMap(int listSize) {
+        keys = (K[]) new Object[listSize];
+        values = (V[]) new Object[listSize];
     }
 
     @Override
@@ -61,106 +59,96 @@ public class ListHashMap<K,V> implements Map<K,V> {
     }
 
     private void clearArrays() {
-        for (int i=0; i<maxListFill; i++) {
-            listValues[i] = null;
-            listKeys[i] = null;
+        for (int i = 0, n = keys.length; i < n; i += 1) {
+            values[i] = null;
+            keys[i] = null;
         }
     }
 
     @Override
     public boolean containsKey(Object key) {
-        if (size == 0) {
-            return false;
-        }
-        if (innerMap == null) {
-            for (int i=0; i<size; i++) {
-                if (listKeys[i].equals(key)) return true;
+        if (key != null) {
+            if (innerMap != null) {
+                return innerMap.containsKey(key);
+            }
+            for (int i = 0; i < size; i += 1) {
+                if (key.equals(keys[i])) return true;
             }
-            return false;
-        } else {
-            return innerMap.containsKey(key);
         }
+        return false;
     }
 
     @Override
     public boolean containsValue(Object value) {
-        if (size == 0) {
-            return false;
-        }
-        if (innerMap == null) {
-            for (int i=0; i<size; i++) {
-                if (listValues[i].equals(value)) return true;
+        if (value != null) {
+            if (innerMap != null) {
+                return innerMap.containsValue(value);
+            }
+            for (int i = 0; i < size; i += 1) {
+                if (value.equals(values[i])) return true;
             }
-            return false;
-        } else {
-            return innerMap.containsValue(value);
-        }
-    }
-
-    private Map<K,V> makeMap() {
-        Map<K,V> m = new HashMap();
-        for (int i=0; i<size; i++) {
-            m.put((K) listKeys[i], (V) listValues[i]);
         }
-        return m;
+        return false;
     }
 
     @Override
-    @SuppressWarnings("unchecked")
-    public Set<java.util.Map.Entry<K, V>> entrySet() {
-        Map m = innerMap!=null?innerMap:makeMap();
-        return m.entrySet();
+    public Set<Entry<K,V>> entrySet() {
+        return (innerMap != null ? Collections.unmodifiableMap(innerMap) : toMap()).entrySet();
     }
 
     @Override
     public V get(Object key) {
-        if (size == 0)
-            return null;
-        if (innerMap != null)
-            return innerMap.get(key);
-        for (int i = 0; i < size; ++i) {
-            if (key.equals(listKeys[i]))
-                return (V) listValues[i];
+        if (key != null) {
+            if (innerMap != null) {
+                return innerMap.get(key);
+            }
+            for (int i = 0; i < size; i += 1) {
+                if (key.equals(keys[i])) return values[i];
+            }
         }
         return null;
     }
 
     @Override
     public boolean isEmpty() {
-        return size == 0;
+        return (size == 0);
     }
 
     @Override
     public Set<K> keySet() {
-        Map m = innerMap!=null?innerMap:makeMap();
-        return m.keySet();
+        return (innerMap != null ? Collections.unmodifiableMap(innerMap) : toMap()).keySet();
     }
 
     @Override
-    @SuppressWarnings("unchecked")
     public V put(K key, V value) {
-        if (innerMap==null) {
-            for (int i=0; i<size; i++) {
-                if (listKeys[i].equals(key)) {
-                    V old = (V) listValues[i];
-                    listValues[i] = value;
+        if (key != null) {
+            if (value == null) {
+                return remove(key);
+            }
+            if (innerMap != null) {
+                V old = innerMap.put(key, value);
+                size = innerMap.size();
+                return old;
+            }
+            for (int i = 0; i < size; i += 1) {
+                if (key.equals(keys[i])) {
+                    V old = values[i];
+                    values[i] = value;
                     return old;
                 }
             }
-            if (size<maxListFill) {
-                listKeys[size] = key;
-                listValues[size] = value;
-                size++;
-                return null;
-            } else {
-                innerMap = makeMap();
-                // Switched over to Map so need to clear array references
+            if (size < keys.length) {
+                values[size] = value;
+                keys[size] = key;
+            } else { // evolve
+                Map<K,V> map = toMap();
+                map.put(key, value);
+                innerMap = map;
                 clearArrays();
             }
+            size += 1;
         }
-        V val = (V) innerMap.put(key, value);
-        size = innerMap.size();
-        return val;
+        return null;
     }
 
     @Override
@@ -172,41 +160,38 @@ public class ListHashMap<K,V> implements Map<K,V> {
 
     @Override
     public V remove(Object key) {
-        if (innerMap==null) {
-            for (int i=0; i<size; i++) {
-                if (listKeys[i].equals(key)) {
-                    V old = (V) listValues[i];
-                    size--;
-                    // If last element is not being removed shift the last element into this slot
-                    if (i < size) {
-                        listValues[i] = listValues[size];
-                        listKeys[i] = listKeys[size];
+        if (key != null) {
+            if (innerMap != null) {
+                V value = innerMap.remove(key);
+                if (value != null) {
+                    size = innerMap.size();
+                    if (size <= keys.length) { // devolve
+                        size = 0; Set<Entry<K,V>> entries = innerMap.entrySet(); innerMap = null;
+                        for (Entry<? extends K, ? extends V> entry : entries) {
+                            values[size] = entry.getValue();
+                            keys[size] = entry.getKey();
+                            size += 1;
+                        }
                     }
-                    listValues[size] = null;
-                    listKeys[size] = null;
-                    return old;
                 }
+                return value;
             }
-            return null;
-        } else {
-            V old = innerMap.remove(key);
-            size = innerMap.size();
-            if (size<=maxListFill) {
-                mapToList();
+            for (int i = 0; i < size; i += 1) {
+                if (key.equals(keys[i])) {
+                    V value = values[i];
+                    size -= 1;
+                    // if last element is not being removed, shift the last element into this slot
+                    if (i < size) {
+                        values[i] = values[size];
+                        keys[i] = keys[size];
+                    }
+                    values[size] = null;
+                    keys[size] = null;
+                    return value;
+                }
             }
-            return old;
-        }
-    }
-
-    private void mapToList() {
-        int i = 0;
-        for (Entry<? extends K,? extends V> entry : innerMap.entrySet()) {
-            listKeys[i] = entry.getKey();
-            listValues[i] = entry.getValue();
-            i++;
         }
-        size = innerMap.size();
-        innerMap = null;
+        return null;
     }
 
     @Override
@@ -214,17 +199,16 @@ public class ListHashMap<K,V> implements Map<K,V> {
         return size;
     }
 
-    @Override
-    public Collection<V> values() {
-        if (innerMap == null) {
-            List<V> list = new ArrayList<V>(size);
-            for (int i = 0; i < size; i++) {
-                list.add((V) listValues[i]);
-            }
-            return list;
-        } else {
-            return innerMap.values();
+    private Map<K,V> toMap() {
+        Map<K,V> m = new java.util.HashMap<>();
+        for (int i = 0; i < size; i += 1) {
+            m.put(keys[i], values[i]);
         }
+        return m;
     }
 
+    @Override
+    public Collection<V> values() {
+        return (innerMap != null ? Collections.unmodifiableMap(innerMap) : toMap()).values();
+    }
 }
diff --git a/src/test/org/codehaus/groovy/util/ListHashMapTest.groovy b/src/test/org/codehaus/groovy/util/ListHashMapTest.groovy
index 5f82a55ef0..3e28bfc75d 100644
--- a/src/test/org/codehaus/groovy/util/ListHashMapTest.groovy
+++ b/src/test/org/codehaus/groovy/util/ListHashMapTest.groovy
@@ -18,168 +18,191 @@
  */
 package org.codehaus.groovy.util
 
-import groovy.test.GroovyTestCase
+import org.junit.Test
 
-class ListHashMapTest extends GroovyTestCase {
+final class ListHashMapTest {
 
-    private final ListHashMap list = new ListHashMap(2)
+    private final ListHashMap lhm = new ListHashMap(2)
 
-    void testEmptyWhenCreated() {
-        assert list.isEmpty()
-        assert list.@maxListFill == 2
+    @Test
+    void testEmptyAtFirst() {
+        assert lhm.isEmpty()
+        assert lhm.size() == 0
+        assert lhm.@keys.length == 2
     }
 
+    @Test
     void testInsertElement() {
-        list.put("a", "a")
-        assert list.size() == 1
-        assert list.@innerMap == null
+        lhm.put('a', 'a')
+        assert lhm.size() == 1
+        assert lhm.@innerMap == null
     }
 
+    @Test
     void testInsertTwoElements() {
-        list.put("a", "a")
-        list.put("b", "b")
-        assert list.size() == 2
-        assert list.@innerMap == null
+        lhm.put('a', 'a')
+        lhm.put('b', 'b')
+        assert lhm.size() == 2
+        assert lhm.@innerMap == null
     }
 
+    @Test
     void testInsertWithSameKey() {
-        list.put("a", "a")
-        list.put("a", "b")
-        assert list.size() == 1
-        assert list.@innerMap == null
-        assert list.get("a") == "b"
+        assert lhm.put('a', 'a') == null
+        assert lhm.put('a', 'b') == 'a'
+        assert lhm.size() == 1
+        assert lhm.get('a') == 'b'
+        assert lhm.@innerMap == null
     }
 
+    @Test
     void testSwitchToInnerMap() {
-        list.put("a", "a")
-        list.put("b", "b")
-        list.put("c", "c")
-        assert list.size() == 3
-        assert list.@innerMap != null
-        assert list.@innerMap.size() == 3
+        assert lhm.put('a', 'a') == null
+        assert lhm.put('b', 'b') == null
+        assert lhm.put('c', 'c') == null
+        assert lhm.size() == 3
+        assert lhm.@innerMap != null
+        assert lhm.@innerMap.size() == 3
     }
 
+    @Test
     void testSwitchToInnerMapThenFallbackToList() {
-        list.put("a", "a")
-        list.put("b", "b")
-        list.put("c", "c")
-        assert list.size() == 3
-        assert list.@innerMap != null
-        assert list.@innerMap.size() == 3
-        list.remove("c")
-        assert list.size() == 2
-        assert list.@innerMap == null
-        assert list.keySet() == ['a','b'] as Set
+        testSwitchToInnerMap()
+        assert lhm.remove('c') == 'c'
+        assert lhm.size() == 2
+        assert lhm.@innerMap == null
+        assert lhm.keySet() == ['a','b'] as Set
     }
 
+    @Test
     void testPutNullValue() {
-        list.put("a", null)
-        assert list.size() == 1
-        assert list.a == null
+        lhm.put('a', 'xx')
+        lhm.put('a', null)
+        assert lhm.a == null
+        assert lhm.isEmpty()
     }
 
+    @Test
     void testRemoveNullValue() {
-        list.put("a", null)
-        assert list.size() == 1
-        assert list.a == null
-        list.remove("a")
-        assert list.size() == 0
+        testPutNullValue()
+        assert lhm.remove('a') == null
+        assert lhm.isEmpty()
     }
 
+    @Test
     void testPutAll() {
-        list.putAll([a: '1', b: '2', c: '3'])
-        assert list.size() == 3
-        assert list.@innerMap != null
-        assert list.@innerMap.size() == 3
-        assert list.keySet() == ['a','b','c'] as Set
-        assert list.values()  as Set == ['1','2','3'] as Set
+        lhm.putAll(a: '1', b: '2', c: '3')
+        assert lhm.size() == 3
+        assert lhm.@innerMap != null
+        assert lhm.@innerMap.size() == 3
+        assert lhm.keySet() == ['a','b','c'] as Set
+        assert lhm.values()  as Set == ['1','2','3'] as Set
     }
 
+    @Test
     void testPutAllTwice() {
-        list.putAll([a: '1', b: '2', c: '3'])
-        list.putAll([a: '1', b: '2', c: '3'])
-        assert list.size() == 3
-        assert list.@innerMap != null
-        assert list.@innerMap.size() == 3
-        assert list.keySet()  == ['a','b','c'] as Set
-        assert list.values() as Set  == ['1','2','3'] as Set
+        testPutAll()
+        testPutAll()
     }
 
+    @Test
     void testRemoveAll() {
-        list.putAll([a: '1', b: '2', c: '3'])
-        assert list.size() == 3
-        assert list.@innerMap != null
-        assert list.@innerMap.size() == 3
-        assert list.keySet() == ['a','b','c'] as Set
-        assert list.values() as Set == ['1','2','3'] as Set
-        list.remove('a')
-        list.remove('b')
-        list.remove('c')
-        assert list.isEmpty()
-        assert list.@innerMap == null
+        testPutAll()
+        assert lhm.remove('a') == '1'
+        assert lhm.remove('b') == '2'
+        assert lhm.remove('c') == '3'
+        assert lhm.isEmpty()
+        assert lhm.@innerMap == null
     }
 
+    @Test
     void testRemoveFirstShiftsKeyValuesAndClearsArraySlot() {
-        list.putAll([a: '1', b: '2'])
-        assert list.size() == 2
-        assert list.@innerMap == null
-        list.remove('a')
-        assert list.size() == 1
-        assert list.@listKeys[0] == 'b'
-        assert list.@listValues[0] == '2'
-        assert list.@listKeys[1] == null
-        assert list.@listValues[1] == null
-
-        list.put('c', '3')
-        assert list.size() == 2
-        assert list.@listKeys[0] == 'b'
-        assert list.@listValues[0] == '2'
-        assert list.@listKeys[1] == 'c'
-        assert list.@listValues[1] == '3'
-    }
-
+        lhm.putAll(a: '1', b: '2')
+        assert lhm.size() == 2
+        assert lhm.@innerMap == null
+
+        lhm.remove('a')
+        assert lhm.size() == 1
+        assert lhm.@keys[0] == 'b'
+        assert lhm.@values[0] == '2'
+        assert lhm.@keys[1] == null
+        assert lhm.@values[1] == null
+
+        lhm.put('c', '3')
+        assert lhm.size() == 2
+        assert lhm.@keys[0] == 'b'
+        assert lhm.@values[0] == '2'
+        assert lhm.@keys[1] == 'c'
+        assert lhm.@values[1] == '3'
+    }
+
+    @Test
     void testRemoveLastClearsLastArraySlot() {
-        list.putAll([a: '1', b: '2'])
-        assert list.size() == 2
-        assert list.@innerMap == null
-        list.remove('b')
-        assert list.size() == 1
-        assert list.@listKeys[0] == 'a'
-        assert list.@listValues[0] == '1'
-        assert list.@listKeys[1] == null
-        assert list.@listValues[1] == null
-
-        list.put('c', '3')
-        assert list.size() == 2
-        assert list.@listKeys[0] == 'a'
-        assert list.@listValues[0] == '1'
-        assert list.@listKeys[1] == 'c'
-        assert list.@listValues[1] == '3'
+        lhm.putAll(a: '1', b: '2')
+        assert lhm.size() == 2
+        assert lhm.@innerMap == null
+
+        lhm.remove('b')
+        assert lhm.size() == 1
+        assert lhm.@keys[0] == 'a'
+        assert lhm.@values[0] == '1'
+        assert lhm.@keys[1] == null
+        assert lhm.@values[1] == null
+
+        lhm.put('c', '3')
+        assert lhm.size() == 2
+        assert lhm.@keys[0] == 'a'
+        assert lhm.@values[0] == '1'
+        assert lhm.@keys[1] == 'c'
+        assert lhm.@values[1] == '3'
+    }
+
+    @Test
+    void testSwitchToInnerMapClearsArrays() {
+        lhm.putAll(a: '1', b: '2')
+        assert lhm.size() == 2
+        assert lhm.@keys[0] == 'a'
+        assert lhm.@keys[1] == 'b'
+        assert lhm.@innerMap == null
+
+        lhm.put('c', '3')
+        assert lhm.size() == 3
+        assert lhm.@innerMap != null
+        assert lhm.@keys[0] == null
+        assert lhm.@keys[1] == null
+        assert lhm.@values[0] == null
+        assert lhm.@values[1] == null
+    }
+
+    @Test
+    void testContainsKey() {
+        lhm.putAll(a: '1', b: '2')
+        assert lhm.containsKey('b')
+        assert !lhm.containsKey('c')
     }
 
-    void testSwitchToInnerMapClearsArrays() {
-        list.putAll([a: '1', b: '2'])
-        assert list.size() == 2
-        assert list.@innerMap == null
-        assert list.@listKeys[0] == 'a'
-        assert list.@listKeys[1] == 'b'
+    @Test
+    void testContainsValue() {
+        lhm.putAll(a: '1', b: '2')
+        assert lhm.containsValue('2')
+        assert !lhm.containsValue('3')
+    }
 
-        list.put('c', '3')
-        assert list.size() == 3
-        assert list.@innerMap != null
-        assert list.@listKeys[0] == null
-        assert list.@listKeys[1] == null
-        assert list.@listValues[0] == null
-        assert list.@listValues[1] == null
+    @Test(expected = UnsupportedOperationException)
+    void testCannotModifyInnerMapViaKeySet() {
+        testSwitchToInnerMap()
+        lhm.keySet().clear()
     }
 
-    void testContainsKey() {
-        list.putAll([a: '1', b: '2'])
-        assert list.containsKey('b')
+    @Test(expected = UnsupportedOperationException)
+    void testCannotModifyInnerMapViaEntrySet() {
+        testSwitchToInnerMap()
+        lhm.entrySet().clear()
     }
 
-    void testContainsValue() {
-        list.putAll([a: '1', b: '2'])
-        assert list.containsValue('2')
+    @Test(expected = UnsupportedOperationException)
+    void testCannotModifyInnerMapViaValueCol() {
+        testSwitchToInnerMap()
+        lhm.values().clear()
     }
 }
