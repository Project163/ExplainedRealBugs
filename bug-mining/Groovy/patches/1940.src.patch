diff --git a/src/main/org/codehaus/groovy/ast/tools/GenericsUtils.java b/src/main/org/codehaus/groovy/ast/tools/GenericsUtils.java
index 873798104d..6ec55a9499 100644
--- a/src/main/org/codehaus/groovy/ast/tools/GenericsUtils.java
+++ b/src/main/org/codehaus/groovy/ast/tools/GenericsUtils.java
@@ -159,6 +159,11 @@ public class GenericsUtils {
     public static ClassNode parameterizeType(final ClassNode hint, final ClassNode target) {
         ClassNode interfaceFromClassNode = null;
         if (hint.equals(target)) interfaceFromClassNode = hint;
+        if (ClassHelper.OBJECT_TYPE.equals(target) && target.isUsingGenerics() && target.getGenericsTypes()!=null
+                && target.getGenericsTypes()[0].isPlaceholder()) {
+            // Object<T>
+            return ClassHelper.getWrapper(hint);
+        }
         if (interfaceFromClassNode==null) {
             ClassNode[] interfaces = hint.getInterfaces();
             for (ClassNode node : interfaces) {
diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 57e3eeb4dd..15b4be5110 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -2917,13 +2917,55 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             // we cannot check generic type arguments if there are default parameters!
             return;
         }
+        Map<String, ClassNode> resolvedMethodGenerics = new HashMap<String, ClassNode>();
         ClassNode[] ptypes = new ClassNode[candidateMethod.getParameters().length];
+        final GenericsType[] methodNodeGenericsTypes = candidateMethod.getGenericsTypes();
+        final boolean shouldCheckMethodGenericTypes = methodNodeGenericsTypes!=null && methodNodeGenericsTypes.length>0;
         for (int i = 0; i < arguments.length; i++) {
             int pindex = Math.min(i, parameters.length - 1);
             ClassNode type = parameters[pindex].getType();
             type = fullyResolveType(type, classGTs);
             ptypes[pindex] = type;
             failure |= !typeCheckMethodArgumentWithGenerics(type, arguments[i], i >= parameters.length - 1);
+            if (shouldCheckMethodGenericTypes && !failure) {
+                // GROOVY-5692
+                // for example: public <T> foo(T arg0, List<T> arg1)
+                // we must check that T for arg0 and arg1 are the same
+                // so that if you call foo(String, List<Integer>) the compiler fails
+
+                // For that, we store the information for each argument, and for a new argument, we will
+                // check that is is the same as the previous one
+                GenericsType[] typeGenericsTypes = type.getGenericsTypes();
+                if (type.isUsingGenerics() && typeGenericsTypes !=null) {
+                    for (int gtIndex = 0, typeGenericsTypesLength = typeGenericsTypes.length; gtIndex < typeGenericsTypesLength; gtIndex++) {
+                        final GenericsType typeGenericsType = typeGenericsTypes[gtIndex];
+                        if (typeGenericsType.isPlaceholder()) {
+                            for (GenericsType methodNodeGenericsType : methodNodeGenericsTypes) {
+                                String placeholderName = methodNodeGenericsType.getName();
+                                if (methodNodeGenericsType.isPlaceholder() && placeholderName.equals(typeGenericsType.getName())) {
+                                    // match!
+                                    ClassNode parameterized = GenericsUtils.parameterizeType(arguments[i], type);
+                                    // retrieve the type of the generics placeholder we're looking for
+                                    // For example, if we have List<T> in the signature and List<String> as an argument
+                                    // we want to align T with String
+                                    // but first test is for Object<T> -> String which explains we don't use the generics types
+                                    ClassNode alignedType = parameterized;
+                                    if (parameterized.isUsingGenerics() && parameterized.getGenericsTypes()!=null) {
+                                        alignedType = parameterized.getGenericsTypes()[gtIndex].getType();
+                                    }
+                                    if (resolvedMethodGenerics.containsKey(placeholderName)) {
+                                        failure |= !resolvedMethodGenerics.get(placeholderName).equals(alignedType);
+                                    } else {
+                                        resolvedMethodGenerics.put(placeholderName, alignedType);
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+
+
+            }
         }
         if (failure) {
             addStaticTypeError("Cannot call " + receiver.getName() + "#" +
diff --git a/src/test/groovy/transform/stc/GenericsSTCTest.groovy b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
index a0d1632b9f..7e70c52757 100644
--- a/src/test/groovy/transform/stc/GenericsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
@@ -853,6 +853,23 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
         '''
     }
 
+    void testIncompatibleGenericsForTwoArguments() {
+        shouldFailWithMessages '''
+            public <T> void printEqual(T arg1, T arg2) {
+                println arg1 == arg2
+            }
+            printEqual(1, 'foo')
+        ''', '#printEqual(java.lang.Object <T>, java.lang.Object <T>) with arguments [int, java.lang.String]'
+    }
+    void testIncompatibleGenericsForTwoArgumentsUsingEmbeddedPlaceholder() {
+        shouldFailWithMessages '''
+            public <T> void printEqual(T arg1, List<T> arg2) {
+                println arg1 == arg2
+            }
+            printEqual(1, ['foo'])
+        ''', '#printEqual(java.lang.Object <T>, java.util.List <T>) with arguments [int, java.util.List <java.lang.String>]'
+    }
+
     static class MyList extends LinkedList<String> {}
 
     public static class ClassA<T> {
