diff --git a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java
index 633bbaa35e..eeabf19c4d 100644
--- a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java
+++ b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java
@@ -180,7 +180,11 @@ public class StaticInvocationWriter extends InvocationWriter {
                     Map<MethodNode, MethodNode> bridges = (Map<MethodNode, MethodNode>) declaringClass.redirect().getNodeMetaData(PRIVATE_BRIDGE_METHODS);
                     MethodNode bridge = bridges.get(target);
                     if (bridge != null) {
-                        return writeDirectMethodCall(bridge, implicitThis, receiver, args);
+                        ArgumentListExpression newArgs = new ArgumentListExpression(target.isStatic()?new ConstantExpression(null):receiver);
+                        for (Expression expression : args.getExpressions()) {
+                            newArgs.addExpression(expression);
+                        }
+                        return writeDirectMethodCall(bridge, implicitThis, receiver, newArgs);
                     }
                 }
                 if (declaringClass != classNode) {
diff --git a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
index fcbc7d1020..fd7229a24b 100644
--- a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
+++ b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
@@ -294,7 +294,8 @@ public class StaticTypesCallSiteWriter extends CallSiteWriter implements Opcodes
             if (accessors!=null) {
                 MethodNode methodNode = accessors.get(fieldName);
                 if (methodNode!=null) {
-                    MethodCallExpression mce = new MethodCallExpression(receiver, methodNode.getName(), ArgumentListExpression.EMPTY_ARGUMENTS);
+                    MethodCallExpression mce = new MethodCallExpression(receiver, methodNode.getName(),
+                            new ArgumentListExpression(field.isStatic()?new ConstantExpression(null):receiver));
                     mce.setMethodTarget(methodNode);
                     mce.setSafe(safe);
                     mce.setImplicitThis(implicitThis);
diff --git a/src/main/org/codehaus/groovy/transform/sc/StaticCompilationVisitor.java b/src/main/org/codehaus/groovy/transform/sc/StaticCompilationVisitor.java
index 8615a6fa45..aa8ceb745d 100644
--- a/src/main/org/codehaus/groovy/transform/sc/StaticCompilationVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/sc/StaticCompilationVisitor.java
@@ -134,18 +134,18 @@ public class StaticCompilationVisitor extends StaticTypeCheckingVisitor {
         }
         int acc = -1;
         privateConstantAccessors = new HashMap<String, MethodNode>();
-        final String seed = String.valueOf(System.currentTimeMillis());
+        final int access = Opcodes.ACC_STATIC | Opcodes.ACC_PUBLIC | Opcodes.ACC_SYNTHETIC;
         for (FieldNode fieldNode : node.getFields()) {
-            int access = fieldNode.getModifiers();
             if (accessedFields.contains(fieldNode)) {
+
                 acc++;
-                access = (access - Opcodes.ACC_PRIVATE + Opcodes.ACC_SYNTHETIC) + Opcodes.ACC_FINAL;
-                Expression receiver = fieldNode.isStatic()?new ClassExpression(node):new VariableExpression("this", node);
+                Parameter param = new Parameter(node, "$that");
+                Expression receiver = fieldNode.isStatic()?new ClassExpression(node):new VariableExpression(param);
                 Statement stmt = new ExpressionStatement(new PropertyExpression(
                         receiver,
                         fieldNode.getName()
                 ));
-                MethodNode accessor = node.addMethod("pfaccess$"+seed+acc, access, fieldNode.getOriginType(), Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, stmt);
+                MethodNode accessor = node.addMethod("pfaccess$"+acc, access, fieldNode.getOriginType(), new Parameter[]{param}, ClassNode.EMPTY_ARRAY, stmt);
                 privateConstantAccessors.put(fieldNode.getName(), accessor);
             }
         }
@@ -170,30 +170,32 @@ public class StaticCompilationVisitor extends StaticTypeCheckingVisitor {
             return;
         }
         privateBridgeMethods = new HashMap<MethodNode, MethodNode>();
-        final String seed = String.valueOf(System.currentTimeMillis());
         int i=-1;
+        final int access = Opcodes.ACC_STATIC | Opcodes.ACC_PUBLIC | Opcodes.ACC_SYNTHETIC;
         for (MethodNode method : methods) {
-            int access = method.getModifiers();
             if (accessedMethods.contains(method)) {
                 i++;
-                access = (access - Opcodes.ACC_PRIVATE + Opcodes.ACC_SYNTHETIC) + Opcodes.ACC_FINAL;
+                Parameter[] methodParameters = method.getParameters();
+                Parameter[] newParams = new Parameter[methodParameters.length+1];
+                System.arraycopy(methodParameters, 0, newParams, 1, methodParameters.length);
+                newParams[0] = new Parameter(node, "$that");
                 Expression arguments;
                 if (method.getParameters()==null || method.getParameters().length==0) {
                     arguments = ArgumentListExpression.EMPTY_ARGUMENTS;
                 } else {
                     List<Expression> args = new LinkedList<Expression>();
-                    for (Parameter parameter : method.getParameters()) {
+                    for (Parameter parameter : methodParameters) {
                         args.add(new VariableExpression(parameter));
                     }
                     arguments = new ArgumentListExpression(args);
                 }
-                Expression receiver = method.isStatic()?new ClassExpression(node):new VariableExpression("this", node);
+                Expression receiver = method.isStatic()?new ClassExpression(node):new VariableExpression(newParams[0]);
                 MethodCallExpression mce = new MethodCallExpression(receiver, method.getName(), arguments);
+                mce.setMethodTarget(method);
 
                 ExpressionStatement returnStatement = new ExpressionStatement(mce);
-                MethodNode bridge = node.addMethod("access$"+seed+i, access, method.getReturnType(), method.getParameters(), method.getExceptions(), returnStatement);
+                MethodNode bridge = node.addMethod("access$"+i, access, method.getReturnType(), newParams, method.getExceptions(), returnStatement);
                 privateBridgeMethods.put(method, bridge);
-                mce.setMethodTarget(method);
                 bridge.addAnnotation(new AnnotationNode(COMPILESTATIC_CLASSNODE));
             }
         }
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/MethodCallsStaticCompilationTest.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/MethodCallsStaticCompilationTest.groovy
index 50f2ceeec5..9810e587c1 100644
--- a/src/test/org/codehaus/groovy/classgen/asm/sc/MethodCallsStaticCompilationTest.groovy
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/MethodCallsStaticCompilationTest.groovy
@@ -47,12 +47,16 @@ public class MethodCallsStaticCompilationTest extends MethodCallsSTCTest {
     }
 
     void testCallToPrivateInnerClassMethod() {
+        try {
         assertScript '''
                 class A {
                     static class B { private static void foo() {} }
                    public static void main(args) { B.foo() }
                 }
             '''
+        } finally {
+            println astTrees
+        }
     }
 
     void testCallToPrivateOuterClassMethod() {
