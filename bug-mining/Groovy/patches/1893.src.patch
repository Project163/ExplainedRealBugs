diff --git a/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java b/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
index cd3d7e7b8c..d479e5668c 100644
--- a/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
+++ b/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
@@ -53,9 +53,9 @@ public class AsmClassGenerator extends ClassGenerator {
 
     // fields and properties
     static final MethodCallerMultiAdapter setField = MethodCallerMultiAdapter.newStatic(ScriptBytecodeAdapter.class, "setField", false, false);
-    static final MethodCallerMultiAdapter getField = MethodCallerMultiAdapter.newStatic(ScriptBytecodeAdapter.class, "getField", false, false);
+    public static final MethodCallerMultiAdapter getField = MethodCallerMultiAdapter.newStatic(ScriptBytecodeAdapter.class, "getField", false, false);
     static final MethodCallerMultiAdapter setGroovyObjectField = MethodCallerMultiAdapter.newStatic(ScriptBytecodeAdapter.class, "setGroovyObjectField", false, false);
-    static final MethodCallerMultiAdapter getGroovyObjectField = MethodCallerMultiAdapter.newStatic(ScriptBytecodeAdapter.class, "getGroovyObjectField", false, false);
+    public static final MethodCallerMultiAdapter getGroovyObjectField = MethodCallerMultiAdapter.newStatic(ScriptBytecodeAdapter.class, "getGroovyObjectField", false, false);
     static final MethodCallerMultiAdapter setFieldOnSuper = MethodCallerMultiAdapter.newStatic(ScriptBytecodeAdapter.class, "setFieldOnSuper", false, false);
     static final MethodCallerMultiAdapter getFieldOnSuper = MethodCallerMultiAdapter.newStatic(ScriptBytecodeAdapter.class, "getFieldOnSuper", false, false);
 
diff --git a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java
index 0caa1e28a6..435ac44c7d 100644
--- a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java
+++ b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java
@@ -27,13 +27,7 @@ import org.codehaus.groovy.ast.stmt.EmptyStatement;
 import org.codehaus.groovy.ast.stmt.ExpressionStatement;
 import org.codehaus.groovy.ast.stmt.ForStatement;
 import org.codehaus.groovy.classgen.AsmClassGenerator;
-import org.codehaus.groovy.classgen.asm.BytecodeHelper;
-import org.codehaus.groovy.classgen.asm.CompileStack;
-import org.codehaus.groovy.classgen.asm.InvocationWriter;
-import org.codehaus.groovy.classgen.asm.MethodCallerMultiAdapter;
-import org.codehaus.groovy.classgen.asm.OperandStack;
-import org.codehaus.groovy.classgen.asm.TypeChooser;
-import org.codehaus.groovy.classgen.asm.WriterController;
+import org.codehaus.groovy.classgen.asm.*;
 import org.codehaus.groovy.runtime.InvokerHelper;
 import org.codehaus.groovy.syntax.SyntaxException;
 import org.codehaus.groovy.syntax.Token;
@@ -406,6 +400,18 @@ public class StaticInvocationWriter extends InvocationWriter {
             }
             mv.visitLabel(endof);
         } else {
+            if ((adapter == AsmClassGenerator.getGroovyObjectField
+                    || adapter == AsmClassGenerator.getField ) && origin instanceof AttributeExpression) {
+                String pname = ((PropertyExpression) origin).getPropertyAsString();
+                CallSiteWriter callSiteWriter = controller.getCallSiteWriter();
+                if (pname!=null && callSiteWriter instanceof StaticTypesCallSiteWriter) {
+                    StaticTypesCallSiteWriter stcsw = (StaticTypesCallSiteWriter) callSiteWriter;
+                    TypeChooser typeChooser = controller.getTypeChooser();
+                    if (stcsw.makeGetField(receiver, typeChooser.resolveType(receiver, controller.getClassNode()), pname, false, true)) {
+                        return;
+                    }
+                }
+            }
             super.makeCall(origin, receiver, message, arguments, adapter, safe, spreadSafe, implicitThis);
         }
     }
diff --git a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesBinaryExpressionMultiTypeDispatcher.java b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesBinaryExpressionMultiTypeDispatcher.java
index bc3338ae7f..e756af6903 100644
--- a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesBinaryExpressionMultiTypeDispatcher.java
+++ b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesBinaryExpressionMultiTypeDispatcher.java
@@ -24,6 +24,7 @@ import org.codehaus.groovy.runtime.MetaClassHelper;
 import org.codehaus.groovy.transform.sc.StaticCompilationVisitor;
 import org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor;
 import org.codehaus.groovy.transform.stc.StaticTypesMarker;
+import org.objectweb.asm.MethodVisitor;
 import org.objectweb.asm.Opcodes;
 
 import static org.codehaus.groovy.ast.ClassHelper.int_TYPE;
@@ -66,50 +67,85 @@ public class StaticTypesBinaryExpressionMultiTypeDispatcher extends BinaryExpres
                 if (makeSetProperty(
                         pexp.getObjectExpression(),
                         pexp.getProperty(),
-                        new ArgumentListExpression(expression.getRightExpression()),
+                        expression.getRightExpression(),
                         pexp.isSafe(),
                         pexp.isSpreadSafe(),
-                        pexp.isImplicitThis()
-                )) return;
+                        pexp.isImplicitThis(),
+                        pexp instanceof AttributeExpression)) return;
             }
         }
         super.evaluateEqual(expression, defineVariable);
     }
 
-    private boolean makeSetProperty(final Expression receiver, final Expression message, final Expression arguments, final boolean safe, final boolean spreadSafe, final boolean implicitThis) {
+    private boolean makeSetProperty(final Expression receiver, final Expression message, final Expression arguments, final boolean safe, final boolean spreadSafe, final boolean implicitThis, final boolean isAttribute) {
         WriterController controller = getController();
         TypeChooser typeChooser = controller.getTypeChooser();
         ClassNode receiverType = typeChooser.resolveType(receiver, controller.getClassNode());
         String property = message.getText();
-        String setter = "set"+ MetaClassHelper.capitalize(property);
-        MethodNode setterMethod = receiverType.getSetterMethod(setter);
-        if (setterMethod==null) {
-            PropertyNode propertyNode = receiverType.getProperty(property);
-            if (propertyNode!=null) {
-                setterMethod = new MethodNode(
+        if (isAttribute) {
+            ClassNode current = receiverType;
+            FieldNode fn = null;
+            while (fn==null && current!=null) {
+                fn = current.getDeclaredField(property);
+                if (fn==null){
+                    current = current.getSuperClass();
+                }
+            }
+            if (fn!=null && receiverType!=current && !fn.isPublic()) {
+                // check that direct access is allowed
+                if (!fn.isProtected()) {
+                    return false;
+                }
+                String pkg1 = receiverType.getPackageName();
+                String pkg2 = current.getPackageName();
+                if (pkg1!=pkg2 && !pkg1.equals(pkg2)) {
+                    return false;
+                }
+                OperandStack operandStack = controller.getOperandStack();
+                MethodVisitor mv = controller.getMethodVisitor();
+                if (!fn.isStatic()) {
+                    receiver.visit(controller.getAcg());
+                }
+                arguments.visit(controller.getAcg());
+                operandStack.doGroovyCast(fn.getOriginType());
+                mv.visitFieldInsn(fn.isStatic() ? PUTSTATIC : PUTFIELD,
+                        BytecodeHelper.getClassInternalName(fn.getOwner()),
+                        property,
+                        BytecodeHelper.getTypeDescription(fn.getOriginType()));
+                operandStack.remove(fn.isStatic()?1:2);
+                return true;
+            }
+        } else {
+            String setter = "set" + MetaClassHelper.capitalize(property);
+            MethodNode setterMethod = receiverType.getSetterMethod(setter);
+            if (setterMethod == null) {
+                PropertyNode propertyNode = receiverType.getProperty(property);
+                if (propertyNode != null) {
+                    setterMethod = new MethodNode(
+                            setter,
+                            ACC_PUBLIC,
+                            ClassHelper.VOID_TYPE,
+                            new Parameter[]{new Parameter(propertyNode.getOriginType(), "value")},
+                            ClassNode.EMPTY_ARRAY,
+                            EmptyStatement.INSTANCE
+                    );
+                    setterMethod.setDeclaringClass(receiverType);
+                }
+            }
+            if (setterMethod != null) {
+                MethodCallExpression call = new MethodCallExpression(
+                        receiver,
                         setter,
-                        ACC_PUBLIC,
-                        ClassHelper.VOID_TYPE,
-                        new Parameter[] { new Parameter(propertyNode.getOriginType(), "value")},
-                        ClassNode.EMPTY_ARRAY,
-                        EmptyStatement.INSTANCE
+                        arguments
                 );
-                setterMethod.setDeclaringClass(receiverType);
+                call.setImplicitThis(implicitThis);
+                call.setSafe(safe);
+                call.setSpreadSafe(spreadSafe);
+                call.setMethodTarget(setterMethod);
+                call.visit(controller.getAcg());
+                return true;
             }
         }
-        if (setterMethod!=null) {
-            MethodCallExpression call = new MethodCallExpression(
-                    receiver,
-                    setter,
-                    arguments
-            );
-            call.setImplicitThis(implicitThis);
-            call.setSafe(safe);
-            call.setSpreadSafe(spreadSafe);
-            call.setMethodTarget(setterMethod);
-            call.visit(controller.getAcg());
-            return true;
-        }
         return false;
     }
 
diff --git a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
index e7eeb7dcf5..fca7dd3929 100644
--- a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
+++ b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
@@ -126,8 +126,8 @@ public class StaticTypesCallSiteWriter extends CallSiteWriter implements Opcodes
             expr.visit(controller.getAcg());
             return;
         }
-        if (makeGetField(receiver, receiverType, methodName, implicitThis, samePackages(receiverType.getPackageName(), classNode.getPackageName()))) return;
         if (makeGetPropertyWithGetter(receiver, receiverType, methodName, safe, implicitThis)) return;
+        if (makeGetField(receiver, receiverType, methodName, implicitThis, samePackages(receiverType.getPackageName(), classNode.getPackageName()))) return;
         if (receiverType.isEnum()) {
             mv.visitFieldInsn(GETSTATIC, BytecodeHelper.getClassInternalName(receiverType), methodName, BytecodeHelper.getTypeDescription(receiverType));
             controller.getOperandStack().push(receiverType);
@@ -139,8 +139,8 @@ public class StaticTypesCallSiteWriter extends CallSiteWriter implements Opcodes
         }
         if (isClassReceiver) {
             // we are probably looking for a property of the class
-            if (makeGetField(receiver, ClassHelper.CLASS_Type, methodName, false, true)) return;
             if (makeGetPropertyWithGetter(receiver, ClassHelper.CLASS_Type, methodName, safe, implicitThis)) return;
+            if (makeGetField(receiver, ClassHelper.CLASS_Type, methodName, false, true)) return;
         }
         if (makeGetPrivateFieldWithBridgeMethod(receiver, receiverType, methodName, safe, implicitThis)) return;
 
@@ -321,9 +321,9 @@ public class StaticTypesCallSiteWriter extends CallSiteWriter implements Opcodes
             property = "delegate";
         }
         
-        if (makeGetField(receiver, receiverType, property, implicitThis, samePackages(receiverType.getPackageName(), classNode.getPackageName()))) return;
         if (makeGetPropertyWithGetter(receiver, receiverType, property, safe, implicitThis)) return;
-        
+        if (makeGetField(receiver, receiverType, property, implicitThis, samePackages(receiverType.getPackageName(), classNode.getPackageName()))) return;
+
         MethodCallExpression call = new MethodCallExpression(
                 receiver,
                 "getProperty",
@@ -392,13 +392,12 @@ public class StaticTypesCallSiteWriter extends CallSiteWriter implements Opcodes
         return false;
     }
 
-    private boolean makeGetField(final Expression receiver, final ClassNode receiverType, final String fieldName, final boolean implicitThis, final boolean samePackage) {
+    boolean makeGetField(final Expression receiver, final ClassNode receiverType, final String fieldName, final boolean implicitThis, final boolean samePackage) {
         FieldNode field = receiverType.getField(fieldName);
-        // is direct access possible ?
+        // direct access is allowed if we are in the same class as the declaring class
+        // or we are in an inner class
         if (field !=null 
-                && (field.isPublic() 
-                    || (samePackage && field.isProtected())
-                    || Modifier.isPrivate(field.getModifiers()) && field.getOwner().redirect()==controller.getClassNode().redirect())) {
+                && isDirectAccessAllowed(field, controller.getClassNode(), samePackage)) {
             CompileStack compileStack = controller.getCompileStack();
             MethodVisitor mv = controller.getMethodVisitor();
             if (field.isStatic()) {
@@ -429,6 +428,23 @@ public class StaticTypesCallSiteWriter extends CallSiteWriter implements Opcodes
                 );
     }
 
+    private static boolean isDirectAccessAllowed(FieldNode a, ClassNode receiver, boolean isSamePackage) {
+        ClassNode declaringClass = a.getDeclaringClass().redirect();
+        ClassNode receiverType = receiver.redirect();
+
+        // first, direct access from within the class or inner class nodes
+        if (declaringClass.equals(receiverType)) return true;
+        if (receiverType instanceof InnerClassNode) {
+            while (receiverType!=null && receiverType instanceof InnerClassNode) {
+                if (declaringClass.equals(receiverType)) return true;
+                receiverType = receiverType.getOuterClass();
+            }
+        }
+
+        // no getter
+        return a.isPublic() || (a.isProtected() && isSamePackage);
+    }
+
     @Override
     public void makeSiteEntry() {
     }
diff --git a/src/main/org/codehaus/groovy/transform/sc/StaticCompilationVisitor.java b/src/main/org/codehaus/groovy/transform/sc/StaticCompilationVisitor.java
index 0d411d59d7..c030884c5e 100644
--- a/src/main/org/codehaus/groovy/transform/sc/StaticCompilationVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/sc/StaticCompilationVisitor.java
@@ -26,7 +26,10 @@ import org.codehaus.groovy.classgen.asm.InvocationWriter;
 import org.codehaus.groovy.classgen.asm.TypeChooser;
 import org.codehaus.groovy.classgen.asm.WriterControllerFactory;
 import org.codehaus.groovy.classgen.asm.sc.StaticTypesTypeChooser;
+import org.codehaus.groovy.control.ErrorCollector;
 import org.codehaus.groovy.control.SourceUnit;
+import org.codehaus.groovy.control.messages.SyntaxErrorMessage;
+import org.codehaus.groovy.syntax.SyntaxException;
 import org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport;
 import org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor;
 import org.codehaus.groovy.transform.stc.StaticTypesMarker;
@@ -271,4 +274,22 @@ public class StaticCompilationVisitor extends StaticTypeCheckingVisitor {
         }
         return exists;
     }
+
+    @Override
+    public void visitBinaryExpression(final BinaryExpression expression) {
+        super.visitBinaryExpression(expression);
+        if (StaticTypeCheckingSupport.isAssignment(expression.getOperation().getType())) {
+            Expression left = expression.getLeftExpression();
+            if (left instanceof PropertyExpression && ((PropertyExpression) left).isSpreadSafe()) {
+                ErrorCollector errorCollector = getSourceUnit().getErrorCollector();
+                errorCollector.addErrorAndContinue(
+                        new SyntaxErrorMessage(
+                                new SyntaxException("Spread-safe operator is not available with @CompileStatic" + '\n',
+                                        expression.getLineNumber(),
+                                        expression.getColumnNumber()), getSourceUnit()
+                ));
+            }
+        }
+    }
+
 }
diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 17b69e964c..84ff20dae6 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -590,7 +590,16 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             }
             return;
         }
-        boolean compatible = checkCompatibleAssignmentTypes(leftRedirect, inferredRightExpressionType, rightExpression);
+        // imagine we have: list*.foo = 100
+        // then the assignment must be checked against [100], not 100
+        ClassNode wrappedRHS = inferredRightExpressionType;
+        if (leftExpression instanceof PropertyExpression && ((PropertyExpression) leftExpression).isSpreadSafe()) {
+            wrappedRHS = LIST_TYPE.getPlainNodeReference();
+            wrappedRHS.setGenericsTypes(new GenericsType[]{
+                    new GenericsType(getWrapper(inferredRightExpressionType))
+            });
+        }
+        boolean compatible = checkCompatibleAssignmentTypes(leftRedirect, wrappedRHS, rightExpression);
         // if leftRedirect is of READONLY_PROPERTY_RETURN type, then it means we are on a missing property
         if (leftExpression.getNodeMetaData(StaticTypesMarker.READONLY_PROPERTY) != null && (leftExpression instanceof PropertyExpression)) {
             addStaticTypeError("Cannot set read-only property: " + ((PropertyExpression) leftExpression).getPropertyAsString(), leftExpression);
@@ -660,16 +669,16 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
             // last, check generic type information to ensure that inferred types are compatible
             if (leftExpressionType.isUsingGenerics() && !leftExpressionType.isEnum()) {
-                boolean incomplete = hasRHSIncompleteGenericTypeInfo(inferredRightExpressionType);
+                boolean incomplete = hasRHSIncompleteGenericTypeInfo(wrappedRHS);
                 if (!incomplete) {
                     GenericsType gt = GenericsUtils.buildWildcardType(leftExpressionType);
-                    if (!UNKNOWN_PARAMETER_TYPE.equals(inferredRightExpressionType) && !gt.isCompatibleWith(inferredRightExpressionType)) {
-                        if (isParameterizedWithString(leftExpressionType) && isParameterizedWithGStringOrGStringString(inferredRightExpressionType)) {
+                    if (!UNKNOWN_PARAMETER_TYPE.equals(wrappedRHS) && !gt.isCompatibleWith(wrappedRHS)) {
+                        if (isParameterizedWithString(leftExpressionType) && isParameterizedWithGStringOrGStringString(wrappedRHS)) {
                             addStaticTypeError("You are trying to use a GString in place of a String in a type which explicitly declares accepting String. " +
                                     "Make sure to call toString() on all GString values.", assignmentExpression.getRightExpression());
                         } else {
                             addStaticTypeError("Incompatible generic argument types. Cannot assign "
-                                + inferredRightExpressionType.toString(false)
+                                + wrappedRHS.toString(false)
                                 + " to: " + leftExpressionType.toString(false), assignmentExpression.getRightExpression());
                         }
                     }
@@ -837,17 +846,15 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                             return true;
                         }
                     }
-                    if (!isAttributeExpression) {
-                        FieldNode field = current.getDeclaredField(propertyName);
-                        if (field != null) {
-                            if (visitor != null) visitor.visitField(field);
-                            storeType(pexp, field.getOriginType());
-                            return true;
-                        }
+                    FieldNode field = current.getDeclaredField(propertyName);
+                    if (field != null) {
+                        if (visitor != null) visitor.visitField(field);
+                        storeType(pexp, field.getOriginType());
+                        return true;
                     }
                     // if the property expression is an attribute expression (o.@attr), then
                     // we stop now, otherwise we must check the parent class
-                    if (!isAttributeExpression && current.getSuperClass()!=null) {
+                    if (/*!isAttributeExpression && */current.getSuperClass()!=null) {
                         queue.add(current.getSuperClass());
                     }
                 }
@@ -1004,7 +1011,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 componentType = forLoopVariableType;
             }
             if (!checkCompatibleAssignmentTypes(forLoopVariableType, componentType)) {
-                addStaticTypeError("Cannot loop with element of type " + forLoopVariableType + " with collection of type " + collectionType, forLoop);
+                addStaticTypeError("Cannot loop with element of type " + forLoopVariableType.toString(false) + " with collection of type " + collectionType.toString(false), forLoop);
             }
             if (forLoopVariableType!=DYNAMIC_TYPE) {
                 // user has specified a type, prefer it over the inferred type
@@ -2277,6 +2284,9 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                     }
                     if (property != null) {
                         MethodNode node = new MethodNode(name, Opcodes.ACC_PUBLIC, property.getType(), Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, EmptyStatement.INSTANCE);
+                        if (property.isStatic()) {
+                            node.setModifiers(Opcodes.ACC_PUBLIC + Opcodes.ACC_STATIC);
+                        }
                         node.setDeclaringClass(receiver);
                         return Collections.singletonList(
                                 node);
@@ -2299,6 +2309,9 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                             MethodNode node = new MethodNode(name, Opcodes.ACC_PUBLIC, VOID_TYPE, new Parameter[]{
                                     new Parameter(type, "arg")
                             }, ClassNode.EMPTY_ARRAY, EmptyStatement.INSTANCE);
+                            if (property.isStatic()) {
+                                node.setModifiers(Opcodes.ACC_PUBLIC + Opcodes.ACC_STATIC);
+                            }
                             node.setDeclaringClass(receiver);
                             return Collections.singletonList(node);
                         }
diff --git a/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy b/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy
index 6c352aad3a..6dd9683e2a 100644
--- a/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy
+++ b/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy
@@ -126,18 +126,6 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
         '''
     }
 
-    void testAttributeWithInheritance() {
-        shouldFailWithMessages '''
-            class A {
-                int x
-            }
-            class B extends A {
-            }
-            B b = new B()
-            b.@x = 2
-        ''', 'No such property: x for class: B'
-    }
-
     void testFieldTypeWithInheritance() {
         shouldFailWithMessages '''
             class A {
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/FieldsAndPropertiesStaticCompileTest.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/FieldsAndPropertiesStaticCompileTest.groovy
index b91f306d4e..c66408f56e 100644
--- a/src/test/org/codehaus/groovy/classgen/asm/sc/FieldsAndPropertiesStaticCompileTest.groovy
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/FieldsAndPropertiesStaticCompileTest.groovy
@@ -16,6 +16,7 @@
 package org.codehaus.groovy.classgen.asm.sc
 
 import groovy.transform.stc.FieldsAndPropertiesSTCTest
+import groovy.transform.NotYetImplemented
 
 @Mixin(StaticCompilationTestSupport)
 class FieldsAndPropertiesStaticCompileTest extends FieldsAndPropertiesSTCTest {
@@ -75,4 +76,336 @@ class FieldsAndPropertiesStaticCompileTest extends FieldsAndPropertiesSTCTest {
         }
     }
 
+    void testUseDirectWriteFieldFromWithinClass() {
+        assertScript '''
+            class A {
+                int x
+                A() {
+                    x = 5
+                }
+            }
+            new A()
+        '''
+        // one PUTFIELD in constructor + one PUTFIELD in setX
+        assert (astTrees['A'][1] =~ 'PUTFIELD A.x').collect().size() == 2
+    }
+
+    void testUseDirectWriteFieldFromWithinClassWithPrivateField() {
+        assertScript '''
+            class A {
+                private int x
+                A() {
+                    x = 5
+                }
+            }
+            new A()
+        '''
+        // one PUTFIELD in constructor
+        assert (astTrees['A'][1] =~ 'PUTFIELD A.x').collect().size() == 1
+    }
+
+    void testUseDirectWriteFieldFromWithinClassWithProtectedField() {
+        assertScript '''
+            class A {
+                protected int x
+                A() {
+                    x = 5
+                }
+            }
+            new A()
+        '''
+        // one PUTFIELD in constructor
+        assert (astTrees['A'][1] =~ 'PUTFIELD A.x').collect().size() == 1
+    }
+
+    void testUseDirectWriteFieldAccess() {
+        assertScript '''
+                class A {
+                        boolean setterCalled = false
+
+                        protected int x
+                        public void setX(int a) {
+                            setterCalled = true
+                            x = a
+                        }
+                }
+                class B extends A {
+                    void directAccess() {
+                        this.@x = 2
+                    }
+                }
+                B b = new B()
+                b.directAccess()
+                assert b.isSetterCalled() == false
+                assert b.x == 2
+            '''
+        assert astTrees['B'][1].contains('PUTFIELD A.x')
+    }
+
+    void testUseDirectWriteStaticFieldAccess() {
+        assertScript '''
+            class A {
+                    static boolean setterCalled = false
+
+                    static protected int x
+                    public static void setX(int a) {
+                        setterCalled = true
+                        x = a
+                    }
+            }
+            class B extends A {
+                static void directAccess() {
+                    this.@x = 2
+                }
+            }
+            B.directAccess()
+            assert B.isSetterCalled() == false
+            assert B.x == 2
+                '''
+        assert astTrees['B'][1].contains('PUTSTATIC A.x')
+    }
+
+    void testUseSetterFieldAccess() {
+        assertScript '''
+                class A {
+                        boolean setterCalled = false
+
+                        protected int x
+                        public void setX(int a) {
+                            setterCalled = true
+                            x = a
+                        }
+                }
+                class B extends A {
+                    void setterAccess() {
+                        this.x = 2
+                    }
+                }
+                B b = new B()
+                b.setterAccess()
+                assert b.isSetterCalled() == true
+                assert b.x == 2
+            '''
+        assert astTrees['B'][1].contains('INVOKEVIRTUAL A.setX')
+    }
+
+    void testDirectReadFieldFromSameClass() {
+        assertScript '''
+            class A {
+                int x
+                public int getXX() {
+                    x // should do direct access
+                }
+            }
+            A a = new A()
+            assert a.getX() == a.getXX()
+        '''
+        // one GETFIELD in getX() + one GETFIELD in getXX
+        assert (astTrees['A'][1] =~ 'GETFIELD A.x').collect().size() == 2
+    }
+
+    void testDirectFieldFromSuperClassShouldUseGetter() {
+        assertScript '''
+            class A {
+                int x
+            }
+            class B extends A {
+                public int getXX() { x }
+            }
+            B a = new B()
+            assert a.getX() == a.getXX()
+        '''
+        // no GETFIELD in getXX
+        assert (astTrees['B'][1] =~ 'GETFIELD A.x').collect().size() == 0
+        // getX in getXX
+        assert (astTrees['B'][1] =~ 'INVOKEVIRTUAL A.getX').collect().size() == 1
+    }
+
+    void testUseDirectReadFieldAccess() {
+        assertScript '''
+                class A {
+                        boolean getterCalled = false
+
+                        protected int x
+                        public int getX() {
+                            getterCalled = true
+                            x
+                        }
+                }
+                class B extends A {
+                    void m() {
+                        this.@x
+                    }
+                }
+                B b = new B()
+                b.m()
+                assert b.isGetterCalled() == false
+            '''
+        assert astTrees['B'][1].contains('GETFIELD A.x')
+    }
+
+    void testUseGetterFieldAccess() {
+        assertScript '''
+                    class A {
+                            boolean getterCalled = false
+
+                            protected int x
+                            public int getX() {
+                                getterCalled = true
+                                x
+                            }
+                    }
+                    class B extends A {
+                        void usingGetter() {
+                            this.x
+                        }
+                    }
+                    B b = new B()
+                    b.usingGetter()
+                    assert b.isGetterCalled() == true
+                '''
+        assert astTrees['B'][1].contains('INVOKEVIRTUAL A.getX')
+    }
+
+    void testUseAttributeExternal() {
+        assertScript '''
+            class A {
+                boolean setterCalled = false
+                public int x
+                void setX(int a) {
+                    setterCalled = true
+                    x = a
+                }
+            }
+            A a = new A()
+            a.@x = 100
+            assert a.x == 100
+            assert a.isSetterCalled() == false
+        '''
+    }
+    void testUseAttributeExternalSafe() {
+        assertScript '''
+            class A {
+                boolean setterCalled = false
+                public int x
+                void setX(int a) {
+                    setterCalled = true
+                    x = a
+                }
+            }
+            A a = new A()
+            a?.@x = 100
+            assert a.x == 100
+            assert a.isSetterCalled() == false
+        '''
+    }
+    void testUseAttributeExternalSafeWithNull() {
+        assertScript '''
+            class A {
+                boolean setterCalled = false
+                public int x
+                void setX(int a) {
+                    setterCalled = true
+                    x = a
+                }
+            }
+            A a = null
+            a?.@x = 100
+        '''
+    }
+    void testUseGetterExternal() {
+        assertScript '''
+            class A {
+                boolean setterCalled = false
+                public int x
+                void setX(int a) {
+                    setterCalled = true
+                    x = a
+                }
+            }
+            A a = new A()
+            a.x = 100
+            assert a.x == 100
+            assert a.isSetterCalled() == true
+        '''
+    }
+
+    @NotYetImplemented
+    void testUseAttributeExternalSpread() {
+        try {
+            assertScript '''
+                class A {
+                    boolean setterCalled = false
+                    public int x
+                    void setX(int a) {
+                        setterCalled = true
+                        x = a
+                    }
+                }
+                List<A> a = [new A(), new A()]
+                a*.@x = 100
+//              assert a[0].x == 100
+//              assert a[0].isSetterCalled() == false
+            '''
+        } finally {
+            println astTrees
+        }
+    }
+
+    @NotYetImplemented
+    void testUseAttributeExternalSpreadSafeWithNull() {
+        assertScript '''
+            class A {
+                boolean setterCalled = false
+                public int x
+                void setX(int a) {
+                    setterCalled = true
+                    x = a
+                }
+            }
+            List<A> a = [new A(), new A()]
+            a*.@x = 100
+            assert a[0].x == 100
+            assert a[0].isSetterCalled() == false
+            assert a[1] == null
+        '''
+    }
+
+    @NotYetImplemented
+    void testUseAttributeExternalSpreadUsingSetter() {
+        assertScript '''
+            class A {
+                boolean setterCalled = false
+                public int x
+                void setX(int a) {
+                    setterCalled = true
+                    x = a
+                }
+            }
+            List<A> a = [new A(), new A()]
+            a*.x = 100
+            assert a[0].x == 100
+            assert a[0].isSetterCalled() == true
+        '''
+    }
+
+    @NotYetImplemented
+    void testUseAttributeExternalSpreadSafeWithNullUsingSetter() {
+        assertScript '''
+            class A {
+                boolean setterCalled = false
+                public int x
+                void setX(int a) {
+                    setterCalled = true
+                    x = a
+                }
+            }
+            List<A> a = [new A(), new A()]
+            a*.x = 100
+            assert a[0].x == 100
+            assert a[0].isSetterCalled() == true
+            assert a[1] == null
+        '''
+    }
+
 }
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/StaticCompileFieldAccessTest.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/StaticCompileFieldAccessTest.groovy
index 6aa6b7878b..b10b44882e 100644
--- a/src/test/org/codehaus/groovy/classgen/asm/sc/StaticCompileFieldAccessTest.groovy
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/StaticCompileFieldAccessTest.groovy
@@ -136,7 +136,7 @@ class StaticCompileFieldAccessTest extends AbstractBytecodeTestCase {
 
             @groovy.transform.CompileStatic
             int m(java.awt.Point a) {
-                return a.x
+                return a.@x
             }
             assert m(a) == 100
         ''')
@@ -149,6 +149,25 @@ class StaticCompileFieldAccessTest extends AbstractBytecodeTestCase {
         clazz.newInstance().run()
     }
 
+    void testReturnFieldFromNonGroovyObjectUsingGetter() {
+        compile(method:'m', '''
+            java.awt.Point a = [100,200]
+
+            @groovy.transform.CompileStatic
+            double usingGetter(java.awt.Point a) {
+                return a.x
+            }
+            assert usingGetter(a) == 100
+        ''')
+       assert sequence.hasStrictSequence([
+                'ALOAD',
+                'INVOKEVIRTUAL java/awt/Point.getX ()D',
+                'DRETURN'
+        ])
+
+        clazz.newInstance().run()
+    }
+
     void testReturnPropertyFromNonGroovyObject() {
         compile(method:'m', '''
             Object a = 'hello'
