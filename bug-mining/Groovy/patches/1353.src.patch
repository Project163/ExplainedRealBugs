diff --git a/src/main/org/codehaus/groovy/classgen/Verifier.java b/src/main/org/codehaus/groovy/classgen/Verifier.java
index eadae4a93c..0dcbbc1701 100644
--- a/src/main/org/codehaus/groovy/classgen/Verifier.java
+++ b/src/main/org/codehaus/groovy/classgen/Verifier.java
@@ -753,6 +753,12 @@ public class Verifier implements GroovyClassVisitor, Opcodes {
                     otherStatements.remove(0);
                     statements.add(0, firstStatement);
                 } 
+                Statement stmtThis$0 = getImplicitThis$0StmtIfInnerClass(otherStatements);
+                if(stmtThis$0 != null) {
+                	// since there can be field init statements that depend on method/property dispatching
+                	// that uses this$0, it needs to bubble up just after the constructor call.
+                	statements.add(1, stmtThis$0);
+                }
                 statements.addAll(otherStatements);
             }
             BlockStatement newBlock = new BlockStatement(statements, block.getVariableScope());
@@ -777,6 +783,34 @@ public class Verifier implements GroovyClassVisitor, Opcodes {
         }
     }
     
+    /*
+     *  when InnerClassVisitor adds this.this$0 = $p$n, it adds it as a BlockStatement having that 
+     *  ExpressionStatemnt 
+     */
+    private Statement getImplicitThis$0StmtIfInnerClass(List<Statement> otherStatements) {
+    	if(!(classNode instanceof InnerClassNode)) return null;
+    	for(Statement stmt : otherStatements) {
+    		if(stmt instanceof BlockStatement) {
+    			List<Statement> stmts = ((BlockStatement) stmt).getStatements();
+    			for(Statement bstmt : stmts) {
+    				if(bstmt instanceof ExpressionStatement) {
+    					Expression expr = ((ExpressionStatement)bstmt).getExpression();
+    					if(expr instanceof BinaryExpression) {
+    						Expression lExpr = ((BinaryExpression)expr).getLeftExpression();
+    						if(lExpr instanceof FieldExpression) {
+    							if("this$0".equals(((FieldExpression) lExpr).getFieldName())) {
+    								stmts.remove(bstmt); // remove from here and let the caller reposition it
+    								return bstmt;
+    							}
+    						}
+    					}
+    				}
+    			}
+    		}
+    	}
+    	return null;
+    }
+    
     private ConstructorCallExpression getFirstIfSpecialConstructorCall(Statement code) {
         if (code == null || !(code instanceof ExpressionStatement)) return null;
 
diff --git a/src/test/groovy/bugs/Groovy4416Bug.groovy b/src/test/groovy/bugs/Groovy4416Bug.groovy
new file mode 100644
index 0000000000..03dd56f293
--- /dev/null
+++ b/src/test/groovy/bugs/Groovy4416Bug.groovy
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2003-2010 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package groovy.bugs
+
+class Groovy4416Bug extends GroovyTestCase {
+    void testImplicitThisPassingInNonStaticInnerClassesBug() {
+        assertScript """
+            class Dummy4416 {
+               static final PROPERTY_VALUE = "property_value"
+               def foo(){"foo()"}
+               class Bean {
+                   String property1 = PROPERTY_VALUE
+                   String property2 = foo()
+               }
+               def bean = new Bean()
+            }
+            def b = new Dummy4416().bean
+            
+            assert b.property1 == "property_value"
+            assert b.property2 == "foo()"
+        """
+    }
+}
