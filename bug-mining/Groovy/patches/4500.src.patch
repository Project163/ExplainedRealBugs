diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index ebaf96fb9b..da69f7e525 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -2462,10 +2462,13 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             }
 
             if (!candidates.isEmpty()) {
+                int nParameters = candidates.stream().mapToInt(m -> m.getParameters().length).reduce((i,j) -> i == j ? i : -1).getAsInt();
                 Map<GenericsTypeName, GenericsType> gts = GenericsUtils.extractPlaceholders(receiverType);
                 candidates.stream().map(candidate -> applyGenericsContext(gts, candidate.getReturnType()))
                         .reduce(WideningCategories::lowestUpperBound).ifPresent(returnType -> {
-                            storeType(expression, wrapClosureType(returnType));
+                            ClassNode closureType = wrapClosureType(returnType);
+                            closureType.putNodeMetaData(CLOSURE_ARGUMENTS, nParameters); // GROOVY-10714
+                            storeType(expression, closureType);
                         });
                 expression.putNodeMetaData(MethodNode.class, candidates);
             } else if (!(expression instanceof MethodReferenceExpression)) {
diff --git a/src/test/groovy/transform/stc/MethodReferenceTest.groovy b/src/test/groovy/transform/stc/MethodReferenceTest.groovy
index fc9f07d58c..8758987fc3 100644
--- a/src/test/groovy/transform/stc/MethodReferenceTest.groovy
+++ b/src/test/groovy/transform/stc/MethodReferenceTest.groovy
@@ -827,6 +827,38 @@ final class MethodReferenceTest {
         assert err.message.contains('Failed to find the expected method[toLowerCaseX(java.lang.String)] in the type[java.lang.String]')
     }
 
+    @Test // GROOVY-10714
+    void testMethodSelection() {
+        assertScript shell, '''
+            class C {
+                String which
+                void m(int i) { which = 'int' }
+                void m(Number n) { which = 'Number' }
+            }
+            interface I {
+                I andThen(Consumer<? super Number> c)
+                I andThen(BiConsumer<? super Number, ?> bc)
+            }
+            @CompileStatic
+            void test(I i, C c) {
+                i = i.andThen(c::m) // "andThen" is ambiguous unless parameters of "m" overloads are taken into account
+            }
+
+            C x= new C()
+            test(new I() {
+                I andThen(Consumer<? super Number> c) {
+                    c.accept(42)
+                    return this
+                }
+                I andThen(BiConsumer<? super Number, ?> bc) {
+                    bc.accept(42, null)
+                    return this
+                }
+            }, x)
+            assert x.which == 'Number'
+        '''
+    }
+
     @Test // GROOVY-10269
     void testNotFunctionalInterface() {
         def err = shouldFail shell, '''
