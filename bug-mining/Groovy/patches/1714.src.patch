diff --git a/src/main/groovy/util/Node.java b/src/main/groovy/util/Node.java
index f5d7a2f098..7c8afafa67 100644
--- a/src/main/groovy/util/Node.java
+++ b/src/main/groovy/util/Node.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2010 the original author or authors.
+ * Copyright 2003-2012 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -61,7 +61,7 @@ public class Node implements Serializable {
      * the newly created node as a child of the parent.
      *
      * @param parent the parent node or null if no parent
-     * @param name the name of the node
+     * @param name   the name of the node
      */
     public Node(Node parent, Object name) {
         this(parent, name, new NodeList());
@@ -72,8 +72,8 @@ public class Node implements Serializable {
      * if a parent is supplied, adds the newly created node as a child of the parent.
      *
      * @param parent the parent node or null if no parent
-     * @param name the name of the node
-     * @param value the Node value, e.g. some text but in general any Object
+     * @param name   the name of the node
+     * @param value  the Node value, e.g. some text but in general any Object
      */
     public Node(Node parent, Object name, Object value) {
         this(parent, name, new HashMap(), value);
@@ -84,8 +84,8 @@ public class Node implements Serializable {
      * attributes specified in the <code>attributes</code> Map. If a parent is supplied,
      * the newly created node is added as a child of the parent.
      *
-     * @param parent the parent node or null if no parent
-     * @param name the name of the node
+     * @param parent     the parent node or null if no parent
+     * @param name       the name of the node
      * @param attributes a Map of name-value pairs
      */
     public Node(Node parent, Object name, Map attributes) {
@@ -97,10 +97,10 @@ public class Node implements Serializable {
      * with attributes specified in the <code>attributes</code> Map. If a parent is supplied,
      * the newly created node is added as a child of the parent.
      *
-     * @param parent the parent node or null if no parent
-     * @param name the name of the node
+     * @param parent     the parent node or null if no parent
+     * @param name       the name of the node
      * @param attributes a Map of name-value pairs
-     * @param value the Node value, e.g. some text but in general any Object
+     * @param value      the Node value, e.g. some text but in general any Object
      */
     public Node(Node parent, Object name, Map attributes, Object value) {
         this.parent = parent;
@@ -165,18 +165,16 @@ public class Node implements Serializable {
     }
 
     public void plus(Closure c) {
-        List<Node> list = this.parent().children();
+        List list = this.parent().children();
         int afterIndex = list.indexOf(this);
-        List<Node> leftOvers = new ArrayList<Node>(list.subList(afterIndex + 1, list.size()));
+        List leftOvers = new ArrayList(list.subList(afterIndex + 1, list.size()));
         list.subList(afterIndex + 1, list.size()).clear();
-
         NodeBuilder b = new NodeBuilder();
         Node newNode = (Node) b.invokeMethod("dummyNode", c);
         List<Node> children = newNode.children();
         for (Node child : children) {
             parent.appendNode(child.name(), child.attributes(), child.value());
         }
-
         this.parent().children().addAll(leftOvers);
     }
 
@@ -225,8 +223,7 @@ public class Node implements Serializable {
             Collection coll = (Collection) value;
             String previousText = null;
             StringBuffer buffer = null;
-            for (Iterator iter = coll.iterator(); iter.hasNext();) {
-                Object child = iter.next();
+            for (Object child : coll) {
                 if (child instanceof String) {
                     String childText = (String) child;
                     if (previousText == null) {
@@ -324,8 +321,7 @@ public class Node implements Serializable {
      */
     public NodeList getAt(QName name) {
         NodeList answer = new NodeList();
-        for (Iterator iter = children().iterator(); iter.hasNext();) {
-            Object child = iter.next();
+        for (Object child : children()) {
             if (child instanceof Node) {
                 Node childNode = (Node) child;
                 Object childNodeName = childNode.name();
@@ -345,8 +341,7 @@ public class Node implements Serializable {
      */
     private NodeList getByName(String name) {
         NodeList answer = new NodeList();
-        for (Iterator iter = children().iterator(); iter.hasNext();) {
-            Object child = iter.next();
+        for (Object child : children()) {
             if (child instanceof Node) {
                 Node childNode = (Node) child;
                 Object childNodeName = childNode.name();
@@ -378,7 +373,7 @@ public class Node implements Serializable {
 
     private List depthFirstRest() {
         List answer = new NodeList();
-        for (Iterator iter = InvokerHelper.asIterator(value); iter.hasNext();) {
+        for (Iterator iter = InvokerHelper.asIterator(value); iter.hasNext(); ) {
             Object child = iter.next();
             if (child instanceof Node) {
                 Node childNode = (Node) child;
@@ -407,10 +402,9 @@ public class Node implements Serializable {
         List answer = new NodeList();
         List nextLevelChildren = getDirectChildren();
         while (!nextLevelChildren.isEmpty()) {
-            List working = new NodeList(nextLevelChildren);
+            List<Node> working = new NodeList(nextLevelChildren);
             nextLevelChildren = new NodeList();
-            for (Iterator iter = working.iterator(); iter.hasNext();) {
-                Node childNode = (Node) iter.next();
+            for (Node childNode : working) {
                 answer.add(childNode);
                 List children = childNode.getDirectChildren();
                 nextLevelChildren.addAll(children);
@@ -421,7 +415,7 @@ public class Node implements Serializable {
 
     private List getDirectChildren() {
         List answer = new NodeList();
-        for (Iterator iter = InvokerHelper.asIterator(value); iter.hasNext();) {
+        for (Iterator iter = InvokerHelper.asIterator(value); iter.hasNext(); ) {
             Object child = iter.next();
             if (child instanceof Node) {
                 Node childNode = (Node) child;
diff --git a/src/test/groovy/util/NodeTest.groovy b/src/test/groovy/util/NodeTest.groovy
index ddd03dca43..2eb6ceee0c 100644
--- a/src/test/groovy/util/NodeTest.groovy
+++ b/src/test/groovy/util/NodeTest.groovy
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2008 the original author or authors.
+ * Copyright 2003-2012 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -19,7 +19,7 @@ import groovy.xml.QName
 
 /**
  * Tests the use of the structured Attribute type
- * 
+ *
  * @author <a href="mailto:james@coredevelopers.net">James Strachan</a>
  * @author Paul King
  * @version $Revision$
@@ -39,7 +39,7 @@ public class NodeTest extends GroovyTestCase {
     public void testAttributeWithAttributes() {
         Map attributes = new HashMap();
         attributes.put("a", "xyz");
-        
+
         Node attribute = new Node(null, "foo", attributes);
         assertEquals("name", "foo", attribute.name());
         assertEquals("attributes", 1, attribute.attributes().size());
@@ -62,12 +62,12 @@ public class NodeTest extends GroovyTestCase {
     public void testAttributeWithAttributesAndChildren() {
         Map attributes = new HashMap();
         attributes.put("a", "xyz");
-        
+
         List children = new ArrayList();
         children.add(new Node(null, "person", "James"));
         children.add(new Node(null, "person", "Bob"));
         children.add("someText");
-        
+
         Node attribute = new Node(null, "foo", attributes, children);
         assertEquals("name", "foo", attribute.name());
         assertEquals("attributes", 1, attribute.attributes().size());
@@ -80,7 +80,7 @@ public class NodeTest extends GroovyTestCase {
     public void testAttributeWithAttributesAndChildrenWithMixedText() {
         Map attributes = new HashMap();
         attributes.put("a", "xyz");
-        
+
         List children = new ArrayList();
         children.add("someText");
         Node node1 = new Node(null, "person", "James");
@@ -89,26 +89,26 @@ public class NodeTest extends GroovyTestCase {
         Node node2 = new Node(null, "person", "Bob");
         children.add(node2);
         children.add("moreText");
-        
+
         Node attribute = new Node(null, "foo", attributes, children);
         assertEquals("name", "foo", attribute.name());
         assertEquals("attributes", 1, attribute.attributes().size());
         assertEquals("value", 5, attribute.children().size());
         assertEquals("text", "someTextmoreTextmoreText", attribute.text());
-        
+
         // let's test get
         List list = (List) attribute.get("person");
         assertEquals("Expected list size: " + list, 2, list.size());
-        
+
         assertEquals("Node1", node1, list.get(0));
         assertEquals("Node2", node2, list.get(1));
 
         dump(attribute);
     }
-    
+
     public void testNavigationUsingQNames() throws Exception {
         QName name1 = new QName("http://something", "foo", "f");
-        
+
         Node node = new Node(null, null, new ArrayList());
         Node child = new Node(null, new QName("http://something", "foo", "f"), new HashMap(), new ArrayList());
         child.attributes().put("cheese", "Edam");
@@ -116,7 +116,7 @@ public class NodeTest extends GroovyTestCase {
         grandChild.attributes().put("drink", "Beer");
         grandChild.children().add("I am a youngling");
         child.children().add(grandChild);
-        
+
         node.children().add(child);
 
         // let's look up by QName
@@ -124,7 +124,7 @@ public class NodeTest extends GroovyTestCase {
         assertTrue("Should return a list: " + value, value instanceof NodeList);
         NodeList list = (NodeList) value;
         assertEquals("Size", 1, list.size());
-        
+
         Node answer = (Node) list.get(0);
         // check node
         assertNotNull("Node is null!", answer);
@@ -150,23 +150,23 @@ public class NodeTest extends GroovyTestCase {
 
         assert foo.bar.size() == 4
         assert foo.children().size() == 4
-        assert foo.children().collect{ it.@id.toInteger() } == [1, 2, 3, 4]
+        assert foo.children().collect { it.@id.toInteger() } == [1, 2, 3, 4]
 
         def bar2 = foo.bar.find {it.@id == '2'}
         bar2.parent().remove(bar2)
-        assert ! bar2.parent()
+        assert !bar2.parent()
         assert foo.bar.size() == 3
         assert foo.children().size() == 3
-        assert foo.children().collect{ it.@id.toInteger() } == [1, 3, 4]
-        assert ! foo.bar.contains(bar2)
+        assert foo.children().collect { it.@id.toInteger() } == [1, 3, 4]
+        assert !foo.bar.contains(bar2)
 
         def bar3 = foo.children().get(1)
         foo.remove(bar3)
-        assert ! bar3.parent()
+        assert !bar3.parent()
         assert foo.bar.size() == 2
         assert foo.children().size() == 2
-        assert foo.children().collect{ it.@id.toInteger() } == [1, 4]
-        assert ! foo.bar.contains(bar3)
+        assert foo.children().collect { it.@id.toInteger() } == [1, 4]
+        assert !foo.bar.contains(bar3)
     }
 
     public void testMove() {
@@ -180,15 +180,15 @@ public class NodeTest extends GroovyTestCase {
 
         assert foo.bar.size() == 2
         assert foo.children().size() == 3
-        assert foo.children().collect{ it.@id?.toInteger() }.grep{it} == [1, 2]
+        assert foo.children().collect { it.@id?.toInteger() }.grep {it} == [1, 2]
 
         def bar2 = foo.bar.find {it.@id == '2'}
         bar2.parent().remove(bar2)
         def baz = foo.baz[0]
-        assert ! bar2.parent()
+        assert !bar2.parent()
         baz.append(bar2)
         assert bar2.parent() == baz
-        assert foo.children().collect{ it.@id?.toInteger() }.grep{it} == [1]
+        assert foo.children().collect { it.@id?.toInteger() }.grep {it} == [1]
         assert foo.baz.bar[0] == bar2
     }
 
