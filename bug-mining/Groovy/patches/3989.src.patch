diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index cf250c7a70..a87bd4b131 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -334,9 +334,9 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         @Override
         public void returnStatementAdded(final ReturnStatement returnStatement) {
             if (isNullConstant(returnStatement.getExpression())) return;
-            checkReturnType(returnStatement);
+            ClassNode returnType = checkReturnType(returnStatement);
             if (typeCheckingContext.getEnclosingClosure() != null) {
-                addClosureReturnType(getType(returnStatement.getExpression()));
+                addClosureReturnType(returnType);
             } else if (typeCheckingContext.getEnclosingMethod() == null) {
                 throw new GroovyBugError("Unexpected return statement at " + returnStatement.getLineNumber() + ":" + returnStatement.getColumnNumber() + " " + returnStatement.getText());
             }
@@ -628,7 +628,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                     }
                 }
             }
-        } else if (enclosingClosure == null) {
+        } else {
             VariableExpression localVariable;
             if (accessedVariable instanceof Parameter) {
                 Parameter parameter = (Parameter) accessedVariable;
@@ -2116,26 +2116,25 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
     protected ClassNode checkReturnType(final ReturnStatement statement) {
         Expression expression = statement.getExpression();
-        ClassNode type = getType(expression);
-
+        ClassNode type;
+        if (expression instanceof VariableExpression && hasInferredReturnType(expression)) {
+            type = expression.getNodeMetaData(INFERRED_RETURN_TYPE);
+        } else {
+            type = getType(expression);
+        }
         if (typeCheckingContext.getEnclosingClosure() != null) {
             return type;
         }
-        // handle instanceof cases
-        if ((expression instanceof VariableExpression) && hasInferredReturnType(expression)) {
-            type = expression.getNodeMetaData(INFERRED_RETURN_TYPE);
-        }
         MethodNode enclosingMethod = typeCheckingContext.getEnclosingMethod();
-        if (enclosingMethod != null && typeCheckingContext.getEnclosingClosure() == null) {
-            if (!enclosingMethod.isVoidMethod()
-                    && !type.equals(void_WRAPPER_TYPE)
+        if (enclosingMethod != null && !enclosingMethod.isVoidMethod()) {
+            if (!isNullConstant(expression)
                     && !type.equals(VOID_TYPE)
-                    && !checkCompatibleAssignmentTypes(enclosingMethod.getReturnType(), type, null, false)
-                    && !(isNullConstant(expression))) {
+                    && !type.equals(void_WRAPPER_TYPE)
+                    && !checkCompatibleAssignmentTypes(enclosingMethod.getReturnType(), type, null, false)) {
                 if (!extension.handleIncompatibleReturnType(statement, type)) {
                     addStaticTypeError("Cannot return value of type " + prettyPrintType(type) + " on method returning type " + prettyPrintType(enclosingMethod.getReturnType()), expression);
                 }
-            } else if (!enclosingMethod.isVoidMethod()) {
+            } else {
                 ClassNode previousType = getInferredReturnType(enclosingMethod);
                 ClassNode inferred = previousType == null ? type : lowestUpperBound(type, previousType);
                 if (implementsInterfaceOrIsSubclassOf(inferred, enclosingMethod.getReturnType())) {
@@ -2147,7 +2146,6 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                     } else {
                         checkTypeGenerics(enclosingMethod.getReturnType(), inferred, expression);
                     }
-                    return type;
                 } else {
                     return enclosingMethod.getReturnType();
                 }
diff --git a/src/test/groovy/bugs/Groovy9790.groovy b/src/test/groovy/bugs/Groovy9790.groovy
index 5bd071bc4f..85b17a447d 100644
--- a/src/test/groovy/bugs/Groovy9790.groovy
+++ b/src/test/groovy/bugs/Groovy9790.groovy
@@ -26,47 +26,48 @@ import static groovy.test.GroovyAssert.shouldFail
 
 @CompileStatic
 final class Groovy9790 {
+
     @Test
-    void "test GROOVY-9790 - 1"() {
+    void testLambdaWithPrimitive() {
         assertScript '''
-            import java.util.stream.IntStream
-
             @groovy.transform.CompileStatic
-            def x() {
-                IntStream.range(0, 2).forEach((Integer i) -> { assert 0 <= i && i < 2})
+            void test() {
+                java.util.stream.IntStream.range(0, 2).forEach(
+                    (int i) -> { assert i >= 0 && i < 2 }
+                )
             }
 
-            x()
+            test()
         '''
     }
 
     @Test
-    void "test GROOVY-9790 - 2"() {
+    void testLambdaWithWrapperType() {
         assertScript '''
-            import java.util.stream.IntStream
-
             @groovy.transform.CompileStatic
-            def x() {
-                IntStream.range(0, 2).forEach((int i) -> { assert 0 <= i && i < 2})
+            void test() {
+                java.util.stream.IntStream.range(0, 2).forEach(
+                    (Integer i) -> { assert i >= 0 && i < 2 }
+                )
             }
 
-            x()
+            test()
         '''
     }
 
     @Test
-    void "test GROOVY-9790 - 3"() {
+    void testLambdaWithIncompatibleType() {
         def err = shouldFail '''
-            import java.util.stream.IntStream
-
             @groovy.transform.CompileStatic
-            def x() {
-                IntStream.range(0, 2).forEach((String i) -> { return i })
+            void test() {
+                java.util.stream.IntStream.range(0, 2).forEach(
+                    (String s) -> { assert s == null }
+                )
             }
 
-            x()
+            test()
         '''
 
-        assert err.toString().contains('The inferred type[int] is not compatible with the parameter type[java.lang.String]\n. At [6:48]')
+        assert err.toString().contains('The inferred type[int] is not compatible with the parameter type[java.lang.String]')
     }
 }
diff --git a/src/test/groovy/transform/stc/ClosuresSTCTest.groovy b/src/test/groovy/transform/stc/ClosuresSTCTest.groovy
index 0e1ad4b396..287465be1b 100644
--- a/src/test/groovy/transform/stc/ClosuresSTCTest.groovy
+++ b/src/test/groovy/transform/stc/ClosuresSTCTest.groovy
@@ -70,25 +70,27 @@ class ClosuresSTCTest extends StaticTypeCheckingTestCase {
         ''', 'Closure argument types: [int, int] do not match with parameter types: [java.lang.String, int]'
     }
 
-    void testClosureReturnTypeInferrence() {
+    void testClosureReturnTypeInference1() {
         assertScript '''
             def closure = { int x, int y -> return x+y }
             int total = closure(2,3)
         '''
+    }
 
+    void testClosureReturnTypeInference2() {
         shouldFailWithMessages '''
             def closure = { int x, int y -> return x+y }
             int total = closure('2',3)
         ''', 'Closure argument types: [int, int] do not match with parameter types: [java.lang.String, int]'
     }
 
-    void testClosureReturnTypeInferrenceWithoutDef() {
+    void testClosureReturnTypeInference3() {
         assertScript '''
             int total = { int x, int y -> return x+y }(2,3)
         '''
     }
 
-    void testClosureReturnTypeInference() {
+    void testClosureReturnTypeInference4() {
         shouldFailWithMessages '''
             def cl = { int x ->
                 if (x==0) {
@@ -101,9 +103,17 @@ class ClosuresSTCTest extends StaticTypeCheckingTestCase {
         ''', 'Possible loss of precision from long to byte'
     }
 
-    void testClosureWithoutParam() {
+    // GROOVY-9907
+    void testClosureReturnTypeInference5() {
         assertScript '''
-            { -> println 'Hello' }()
+            Integer foo(x) {
+                if (x instanceof Integer) {
+                    def bar = { -> return x }
+                    return bar.call()
+                }
+                return 0
+            }
+            assert foo(1) == 1
         '''
     }
 
