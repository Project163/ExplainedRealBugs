diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 3d914a8be0..591c2bc54c 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -745,25 +745,15 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 if (ensureValidSetter(expression, leftExpression, rightExpression, setterInfo)) {
                     return;
                 }
+                lType = getType(leftExpression);
             } else {
                 lType = getType(leftExpression);
-                boolean isFunctionalInterface = isFunctionalInterface(lType);
-                if (isFunctionalInterface && rightExpression instanceof MethodReferenceExpression) {
-                    LambdaExpression lambdaExpression = constructLambdaExpressionForMethodReference(lType);
-                    if (op == ASSIGN) {
-                        inferParameterAndReturnTypesOfClosureOnRHS(lType, lambdaExpression);
-                    }
-                    rightExpression.putNodeMetaData(CONSTRUCTED_LAMBDA_EXPRESSION, lambdaExpression);
-                    rightExpression.putNodeMetaData(CLOSURE_ARGUMENTS, Arrays.stream(lambdaExpression.getParameters()).map(Parameter::getType).toArray(ClassNode[]::new));
-
-                } else if (op == ASSIGN && isFunctionalInterface && rightExpression instanceof ClosureExpression) {
-                    inferParameterAndReturnTypesOfClosureOnRHS(lType, (ClosureExpression) rightExpression);
+                if (op == ASSIGN && isFunctionalInterface(lType)) {
+                    processFunctionalInterfaceAssignment(lType, rightExpression);
                 }
-
                 rightExpression.visit(this);
             }
 
-            if (lType == null) lType = getType(leftExpression);
             ClassNode rType = isNullConstant(rightExpression) && !isPrimitiveType(lType)
                     ? UNKNOWN_PARAMETER_TYPE // null to primitive type is handled elsewhere
                     : getInferredTypeFromTempInfo(rightExpression, getType(rightExpression));
@@ -911,6 +901,18 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         }
     }
 
+    private void processFunctionalInterfaceAssignment(final ClassNode lhsType, final Expression rhsExpression) {
+        if (rhsExpression instanceof ClosureExpression) {
+            inferParameterAndReturnTypesOfClosureOnRHS(lhsType, (ClosureExpression) rhsExpression);
+        } else if (rhsExpression instanceof MethodReferenceExpression) {
+            LambdaExpression lambdaExpression = constructLambdaExpressionForMethodReference(lhsType);
+
+            inferParameterAndReturnTypesOfClosureOnRHS(lhsType, lambdaExpression);
+            rhsExpression.putNodeMetaData(CONSTRUCTED_LAMBDA_EXPRESSION, lambdaExpression);
+            rhsExpression.putNodeMetaData(CLOSURE_ARGUMENTS, Arrays.stream(lambdaExpression.getParameters()).map(Parameter::getType).toArray(ClassNode[]::new));
+        }
+    }
+
     private void inferParameterAndReturnTypesOfClosureOnRHS(final ClassNode lhsType, final ClosureExpression rhsExpression) {
         Tuple2<ClassNode[], ClassNode> typeInfo = GenericsUtils.parameterizeSAM(lhsType);
         Parameter[] closureParameters = getParametersSafe(rhsExpression);
@@ -1822,7 +1824,9 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         try {
             typeCheckingContext.isInStaticContext = node.isInStaticContext();
             currentProperty = node;
-            super.visitProperty(node);
+            visitAnnotations(node);
+            visitClassCodeContainer(node.getGetterBlock());
+            visitClassCodeContainer(node.getSetterBlock());
         } finally {
             currentProperty = null;
             typeCheckingContext.isInStaticContext = osc;
@@ -1835,19 +1839,22 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         try {
             typeCheckingContext.isInStaticContext = node.isInStaticContext();
             currentField = node;
-            super.visitField(node);
+            visitAnnotations(node);
             Expression init = node.getInitialExpression();
             if (init != null) {
-                FieldExpression left = new FieldExpression(node);
-                BinaryExpression bexp = assignX(left, init, node);
-                ClassNode lType = getType(node), rType = getType(init);
-                typeCheckAssignment(bexp, left, lType, init, getResultType(lType, ASSIGN, rType, bexp));
-
+                ClassNode lType = getType(node);
+                if (isFunctionalInterface(lType)) { // GROOVY-9977
+                    processFunctionalInterfaceAssignment(lType, init);
+                }
+                init.visit(this);
+                ClassNode rType = getType(init);
                 if (init instanceof ConstructorCallExpression) {
                     inferDiamondType((ConstructorCallExpression) init, lType);
-                } else if (init instanceof ClosureExpression && isFunctionalInterface(lType)) {
-                    inferParameterAndReturnTypesOfClosureOnRHS(lType, (ClosureExpression) init);
                 }
+
+                FieldExpression left = new FieldExpression(node);
+                BinaryExpression bexp = assignX(left, init, node);
+                typeCheckAssignment(bexp, left, lType, init, getResultType(lType, ASSIGN, rType, bexp));
             }
         } finally {
             currentField = null;
diff --git a/src/test/groovy/transform/stc/LambdaTest.groovy b/src/test/groovy/transform/stc/LambdaTest.groovy
index 33c60786d2..618f18f5f8 100644
--- a/src/test/groovy/transform/stc/LambdaTest.groovy
+++ b/src/test/groovy/transform/stc/LambdaTest.groovy
@@ -293,6 +293,43 @@ final class LambdaTest {
         '''
     }
 
+    @Test
+    void testComparator1() {
+        assertScript '''
+            @groovy.transform.CompileStatic class T {
+                Comparator<Integer> c = (Integer a, Integer b) -> Integer.compare(a, b)
+            }
+            def t = new T()
+            assert t.c.compare(0,0) == 0
+        '''
+
+        def err = shouldFail '''
+            @groovy.transform.CompileStatic class T {
+                Comparator<Integer> c = (int a, int b) -> Integer.compare(a, b)
+            }
+        '''
+        assert err =~ /Cannot assign java.util.Comparator <int> to: java.util.Comparator <Integer>/
+    }
+
+    @Test // GROOVY-9977
+    void testComparator2() {
+        assertScript '''
+            @groovy.transform.CompileStatic
+            class T {
+                Comparator<Integer> c = (a, b) -> Integer.compare(a, b)
+
+                static void m1() {
+                    Comparator<Integer> x = (a, b) -> Integer.compare(a, b)
+                }
+                void m2() {
+                    Comparator<Integer> y = (a, b) -> Integer.compare(a, b)
+                }
+            }
+            def t = new T()
+            assert t.c.compare(0,0) == 0
+        '''
+    }
+
     @Test
     void testFunctionWithLocalVariables() {
         assertScript '''
