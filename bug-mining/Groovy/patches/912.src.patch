diff --git a/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java b/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
index b165dbb9e8..dd94406a40 100644
--- a/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
+++ b/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
@@ -12217,7 +12217,19 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
     }
 
     /**
-     * @see MetaObjectProtocol#respondsTo(Object,String, Object[])
+     * <p>Returns an object satisfying Groovy truth if the implementing MetaClass responds to
+     * a method with the given name and arguments types.
+     *
+     * <p>Note that this method's return value is based on realised methods and does not take into account
+     * objects or classes that implement invokeMethod or methodMissing
+     *
+     * <p>This method is "safe" in that it will always return a value and never throw an exception
+     *
+     * @param self The object to inspect
+     * @param name The name of the method of interest
+     * @param argTypes The argument types to match against
+     * @return A List of MetaMethods matching the argument types which will be empty if no matching methods exist
+     * @see MetaObjectProtocol#respondsTo(Object, String, Object[])
      * @since 1.6.0
      */
     public static List respondsTo(Object self, String name, Object[] argTypes) {
@@ -12225,19 +12237,38 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
     }
 
     /**
-     * @see MetaObjectProtocol#respondsTo(Object,String, Object[])
-     * @since 1.6.0
+     * <p>Returns an object satisfying Groovy truth if the implementing MetaClass responds to
+     * a method with the given name regardless of the arguments.
+     *
+     * <p>Note that this method's return value is based on realised methods and does not take into account
+     * objects or classes that implement invokeMethod or methodMissing
+     *
+     * <p>This method is "safe" in that it will always return a value and never throw an exception
+     *
+     * @param self The object to inspect
+     * @param name The name of the method of interest
+     * @return A List of MetaMethods matching the given name or an empty list if no matching methods exist
+     * @see MetaObjectProtocol#respondsTo(Object, String)
+     * @since 1.6.1
      */
-    public List respondsTo(final Object self, final String name) {
+    public static List respondsTo(Object self, String name) {
         return InvokerHelper.getMetaClass(self).respondsTo(self, name);
     }
 
     /**
-     * @see MetaObjectProtocol#hasProperty(Object,String)
-     * @since 1.6.0
+     * <p>Returns true of the implementing MetaClass has a property of the given name
+     *
+     * <p>Note that this method will only return true for realised properties and does not take into
+     * account implementation of getProperty or propertyMissing
+     *
+     * @param self The object to inspect
+     * @param name The name of the property of interest
+     * @return The found MetaProperty or null if it doesn't exist
+     * @see MetaObjectProtocol#hasProperty(Object, String)
+     * @since 1.6.1
      */
-    public MetaProperty hasProperty(Object self, String name) {
-        return InvokerHelper.getMetaClass(self).getMetaProperty(name);
+    public static MetaProperty hasProperty(Object self, String name) {
+        return InvokerHelper.getMetaClass(self).hasProperty(self, name);
     }
 
 }
diff --git a/src/test/groovy/inspect/InspectorTest.java b/src/test/groovy/inspect/InspectorTest.java
index 9fdfda508f..c1f646265b 100644
--- a/src/test/groovy/inspect/InspectorTest.java
+++ b/src/test/groovy/inspect/InspectorTest.java
@@ -90,8 +90,8 @@ public class InspectorTest extends MockObjectTestCase implements Serializable {
                 "inspect", "is", "isCase", "identity", "getAt", "putAt", "dump", "getMetaPropertyValues", "getProperties",
                 "use", "use", "use", "printf", "printf", "eachWithIndex", "every", "every", "any", "any", "grep", "collect", "collect", "findAll",
                 "split", "findIndexOf", "findIndexOf", "findLastIndexOf", "findLastIndexOf", "findIndexValues", "findIndexValues",
-                "iterator", "addShutdownHook", "sprintf", "sprintf", "with", "inject", "getMetaClass", "setMetaClass", "metaClass", "respondsTo",
-                "toString"
+                "iterator", "addShutdownHook", "sprintf", "sprintf", "with", "inject", "getMetaClass", "setMetaClass", "metaClass",
+                "respondsTo", "respondsTo", "hasProperty", "toString"
         };
         assertEquals("Incorrect number of methods found examining: " + getNamesFor(metaMethods), names.length, metaMethods.length);
         assertNameEquals(names, metaMethods);
diff --git a/src/test/groovy/lang/RespondsToTest.groovy b/src/test/groovy/lang/RespondsToTest.groovy
index f4434580ae..d89f983531 100644
--- a/src/test/groovy/lang/RespondsToTest.groovy
+++ b/src/test/groovy/lang/RespondsToTest.groovy
@@ -63,23 +63,47 @@ class RespondsToTest extends GroovyTestCase {
         assert t.metaClass.respondsTo(t, "foo", String)
         assert t.metaClass.respondsTo(t, "bar", String)
         assert t.metaClass.respondsTo(t, "stuff")
-        //assert t.metaClass.respondsTo(t, "two") // THIS DOESN'T WORK! Should responds to deal with closure properties?
+        //assert t.metaClass.respondsTo(t, "two") // THIS DOESN'T WORK! Should respondsTo deal with closure properties?
+//        assert t.metaClass.respondsTo(t, "newtwo") // THIS DOESN'T WORK! Should respondsTo deal with closure properties?
         assert t.metaClass.respondsTo(t, "getFive")
         assert t.metaClass.respondsTo(t, "setFive")
         assert t.metaClass.respondsTo(t, "setFive", String)
         assert t.metaClass.respondsTo(t, "newM")
         assert !t.metaClass.respondsTo(t, "one", String, Integer)
+        // and again for DGM variations
+        assert t.respondsTo("one")
+        assert t.respondsTo("three")
+        assert t.respondsTo("one", String)
+        assert t.respondsTo("foo", String)
+        assert t.respondsTo("bar", String)
+        assert t.respondsTo("stuff")
+        //assert t.respondsTo("two") // THIS DOESN'T WORK! Should respondsTo deal with closure properties?
+//        assert t.respondsTo("newtwo") // THIS DOESN'T WORK! Should respondsTo deal with closure properties?
+        assert t.respondsTo("getFive")
+        assert t.respondsTo("setFive")
+        assert t.respondsTo("setFive", String)
+        assert t.respondsTo("newM")
+        assert !t.respondsTo("one", String, Integer)
     }
 
     void testHasProperty() {
         RTTest2.metaClass.getNewProp = {-> "new" }
         def t = new RTTest2()
         assert t.metaClass.hasProperty(t, "two")
+        assert t.metaClass.hasProperty(t, "newtwo")
         assert t.metaClass.hasProperty(t, "five")
         assert t.metaClass.hasProperty(t, "six")
         assert t.metaClass.hasProperty(t, "seven")
         assert t.metaClass.hasProperty(t, "eight")
         assert t.metaClass.hasProperty(t, "newProp")
+        // and again for DGM variations
+        assert t.hasProperty("two")
+        assert t.hasProperty("newtwo")
+        assert t.hasProperty("five")
+        assert t.hasProperty("six")
+        assert t.hasProperty("seven")
+        assert t.hasProperty("eight")
+        assert t.hasProperty("newProp")
     }
 }
 
@@ -119,6 +143,8 @@ class RTTest1 {
 class RTTest2 extends RTTest1 {
     String six
 
+    def newtwo = { "newthree" }
+
     def bar(String name) { "foo" }
 
     static stuff() { "goodie" }
