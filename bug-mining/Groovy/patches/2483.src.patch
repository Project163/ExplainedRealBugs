diff --git a/src/main/org/codehaus/groovy/transform/stc/TypeCheckingContext.java b/src/main/org/codehaus/groovy/transform/stc/TypeCheckingContext.java
index c38298dd62..03ff56c47c 100644
--- a/src/main/org/codehaus/groovy/transform/stc/TypeCheckingContext.java
+++ b/src/main/org/codehaus/groovy/transform/stc/TypeCheckingContext.java
@@ -307,6 +307,10 @@ public class TypeCheckingContext {
         this.compilationUnit = compilationUnit;
     }
 
+    public SourceUnit getSource() {
+        return source;
+    }
+
     /**
      * Represents the context of an enclosing closure. An enclosing closure wraps
      * a closure expression and the list of return types found in the closure body.
diff --git a/subprojects/groovy-templates/build.gradle b/subprojects/groovy-templates/build.gradle
index 0f49741f1c..107e8f4393 100644
--- a/subprojects/groovy-templates/build.gradle
+++ b/subprojects/groovy-templates/build.gradle
@@ -4,3 +4,10 @@ dependencies {
     groovy project(':')
     testCompile project(':groovy-test')
 }
+
+task backportJar(type:Jar) {
+    appendix = 'markup-backport'
+    dependsOn classes
+    from sourceSets.main.output
+    include 'groovy/text/markup/**'
+}
\ No newline at end of file
diff --git a/subprojects/groovy-templates/src/main/java/groovy/text/GStringTemplateEngine.java b/subprojects/groovy-templates/src/main/groovy/groovy/text/GStringTemplateEngine.java
similarity index 100%
rename from subprojects/groovy-templates/src/main/java/groovy/text/GStringTemplateEngine.java
rename to subprojects/groovy-templates/src/main/groovy/groovy/text/GStringTemplateEngine.java
diff --git a/subprojects/groovy-templates/src/main/java/groovy/text/SimpleTemplateEngine.java b/subprojects/groovy-templates/src/main/groovy/groovy/text/SimpleTemplateEngine.java
similarity index 100%
rename from subprojects/groovy-templates/src/main/java/groovy/text/SimpleTemplateEngine.java
rename to subprojects/groovy-templates/src/main/groovy/groovy/text/SimpleTemplateEngine.java
diff --git a/subprojects/groovy-templates/src/main/java/groovy/text/Template.java b/subprojects/groovy-templates/src/main/groovy/groovy/text/Template.java
similarity index 100%
rename from subprojects/groovy-templates/src/main/java/groovy/text/Template.java
rename to subprojects/groovy-templates/src/main/groovy/groovy/text/Template.java
diff --git a/subprojects/groovy-templates/src/main/java/groovy/text/TemplateEngine.java b/subprojects/groovy-templates/src/main/groovy/groovy/text/TemplateEngine.java
similarity index 100%
rename from subprojects/groovy-templates/src/main/java/groovy/text/TemplateEngine.java
rename to subprojects/groovy-templates/src/main/groovy/groovy/text/TemplateEngine.java
diff --git a/subprojects/groovy-templates/src/main/java/groovy/text/XmlTemplateEngine.java b/subprojects/groovy-templates/src/main/groovy/groovy/text/XmlTemplateEngine.java
similarity index 100%
rename from subprojects/groovy-templates/src/main/java/groovy/text/XmlTemplateEngine.java
rename to subprojects/groovy-templates/src/main/groovy/groovy/text/XmlTemplateEngine.java
diff --git a/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/AutoNewLineTransformer.java b/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/AutoNewLineTransformer.java
new file mode 100644
index 0000000000..cb7eb044d0
--- /dev/null
+++ b/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/AutoNewLineTransformer.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright 2003-2014 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package groovy.text.markup;
+
+import org.codehaus.groovy.ast.ASTNode;
+import org.codehaus.groovy.ast.ClassCodeVisitorSupport;
+import org.codehaus.groovy.ast.VariableScope;
+import org.codehaus.groovy.ast.expr.ArgumentListExpression;
+import org.codehaus.groovy.ast.expr.ClosureExpression;
+import org.codehaus.groovy.ast.expr.Expression;
+import org.codehaus.groovy.ast.expr.MethodCallExpression;
+import org.codehaus.groovy.ast.expr.TupleExpression;
+import org.codehaus.groovy.ast.expr.VariableExpression;
+import org.codehaus.groovy.ast.stmt.BlockStatement;
+import org.codehaus.groovy.ast.stmt.ExpressionStatement;
+import org.codehaus.groovy.ast.stmt.Statement;
+import org.codehaus.groovy.control.SourceUnit;
+
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * This transformer is responsible for adding calls to the <i>newLine</i> method
+ * depending on the layout of the source code, inside builder like blocks.
+ *
+ * @author Cedric Champeau
+ */
+class AutoNewLineTransformer extends ClassCodeVisitorSupport {
+    private final SourceUnit unit;
+    private boolean inBuilderMethod;
+
+    public AutoNewLineTransformer(final SourceUnit unit) {
+        this.unit = unit;
+    }
+
+    @Override
+    protected SourceUnit getSourceUnit() {
+        return unit;
+    }
+
+    @Override
+    public void visitMethodCallExpression(final MethodCallExpression call) {
+        boolean old = inBuilderMethod;
+        inBuilderMethod = false;
+        if (call.isImplicitThis() && call.getArguments() instanceof TupleExpression) {
+            List<Expression> expressions = ((TupleExpression) call.getArguments()).getExpressions();
+            if (!expressions.isEmpty()) {
+                Expression lastArg = expressions.get(expressions.size() - 1);
+                if (lastArg instanceof ClosureExpression) {
+                    call.getObjectExpression().visit(this);
+                    call.getMethod().visit(this);
+                    for (Expression expression : expressions) {
+                        inBuilderMethod =  (expression == lastArg);
+                        expression.visit(this);
+                    }
+                }
+            }
+        } else {
+            super.visitMethodCallExpression(call);
+        }
+        inBuilderMethod = old;
+    }
+
+    @Override
+    public void visitClosureExpression(final ClosureExpression expression) {
+        super.visitClosureExpression(expression);
+        if (inBuilderMethod) {
+            Statement oldCode = expression.getCode();
+            BlockStatement block = oldCode instanceof BlockStatement?
+                    ((BlockStatement)oldCode):
+                    new BlockStatement(Arrays.asList(oldCode), new VariableScope());
+            List<Statement> statements = block.getStatements();
+            if (!statements.isEmpty()) {
+                Statement first = statements.get(0);
+                Statement last = statements.get(statements.size()-1);
+                if (expression.getLineNumber()<first.getLineNumber()) {
+                    // there's a new line between { -> ... and the first statement
+                    statements.add(0,createNewLine(expression));
+                }
+                if (expression.getLastLineNumber()>last.getLastLineNumber()) {
+                    // there's a new line between { -> ... and the first statement
+                    statements.add(createNewLine(expression));
+                }
+            }
+            expression.setCode(block);
+        }
+    }
+
+    private Statement createNewLine(final ASTNode node) {
+        MethodCallExpression mce = new MethodCallExpression(
+                new VariableExpression("this"),
+                "newLine",
+                ArgumentListExpression.EMPTY_ARGUMENTS
+        );
+        mce.setImplicitThis(true);
+        mce.setSourcePosition(node);
+        ExpressionStatement stmt = new ExpressionStatement(mce);
+        stmt.setSourcePosition(node);
+        return stmt;
+    }
+}
diff --git a/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/BaseTemplate.java b/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/BaseTemplate.java
new file mode 100644
index 0000000000..303fd14048
--- /dev/null
+++ b/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/BaseTemplate.java
@@ -0,0 +1,393 @@
+/*
+ * Copyright 2003-2014 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package groovy.text.markup;
+
+import groovy.lang.Closure;
+import groovy.lang.Writable;
+import org.codehaus.groovy.runtime.ResourceGroovyMethods;
+
+import java.io.IOException;
+import java.io.Writer;
+import java.net.URL;
+import java.util.Collections;
+import java.util.Map;
+
+import static groovy.xml.XmlUtil.escapeXml;
+
+/**
+ * <p>All templates compiled through {@link groovy.text.markup.MarkupTemplateEngine} extend this abstract class,
+ * which provides a number of utility methods to generate markup. An instance of this class can be obtained
+ * after calling {@link groovy.text.Template#make()} or {@link groovy.text.Template#make(java.util.Map)})} on
+ * a template generated by {@link groovy.text.markup.MarkupTemplateEngine#createTemplate(java.io.Reader)}.</p>
+ *
+ * <p>It is advised to use a distinct template instance for each thread (or more simply, each rendered document)
+ * for thread safety and avoiding mixing models.</p>
+ *
+ * <p>For the application needs, it is possible to provide more helper methods by extending this class and
+ * configuring the base template class using the {@link groovy.text.markup.TemplateConfiguration#setBaseTemplateClass(Class)}
+ * method.</p>
+ *
+ * @author Cedric Champeau
+ */
+public abstract class BaseTemplate implements Writable {
+    private final static Map EMPTY_MODEL = Collections.emptyMap();
+
+    private final Map model;
+    private final Map<String,String> modelTypes;
+    private final MarkupTemplateEngine engine;
+    private final TemplateConfiguration configuration;
+
+    private Writer out;
+    private boolean doWriteIndent;
+
+    public BaseTemplate(final MarkupTemplateEngine templateEngine, final Map model, final Map<String,String> modelTypes, final TemplateConfiguration configuration) {
+        this.model = model==null?EMPTY_MODEL:model;
+        this.engine = templateEngine;
+        this.configuration = configuration;
+        this.modelTypes = modelTypes;
+    }
+
+    public Map getModel() {
+        return model;
+    }
+
+    public abstract Object run();
+
+    /**
+     * Renders the object provided as parameter using its {@link Object#toString()} method,
+     * The contents is rendered as is, unescaped. This means that depending on what the
+     * {@link Object#toString()} method call returns, you might create invalid markup.
+     * @param obj the object to be rendered unescaped
+     * @return this template instance
+     * @throws IOException
+     */
+    public BaseTemplate yieldUnescaped(Object obj) throws IOException {
+        writeIndent();
+        out.write(obj.toString());
+        return this;
+    }
+
+    /**
+     * Renders the object provided as parameter using its {@link Object#toString()} method,
+     * The contents is rendered after being escaped for XML, enforcing valid XML output.
+     * @param obj the object to be rendered
+     * @return this template instance
+     * @throws IOException
+     */
+    public BaseTemplate yield(Object obj) throws IOException {
+        writeIndent();
+        out.write(escapeXml(obj.toString()));
+        return this;
+    }
+
+    /**
+     * Renders the supplied object using its {@link Object#toString} method inside a
+     * comment markup block (&lt;!-- ... --&gt;). The object is rendered as is, unescaped.
+     * @param cs the object to be rendered inside an XML comment block.
+     * @return this template instance.
+     * @throws IOException
+     */
+    public BaseTemplate comment(Object cs) throws IOException {
+        writeIndent();
+        out.write("<!--");
+        out.write(cs.toString());
+        out.write("-->");
+        return this;
+    }
+
+    /**
+     * Renders an XML declaration header. If the declaration encoding is set in the
+     * {@link TemplateConfiguration#getDeclarationEncoding() template configuration},
+     * then the encoding is rendered into the declaration.
+     * @return this template instance
+     * @throws IOException
+     */
+    public BaseTemplate xmlDeclaration() throws IOException {
+        out.write("<?xml ");
+        writeAttribute("version", "1.0");
+        if (configuration.getDeclarationEncoding() != null) {
+            writeAttribute("encoding", configuration.getDeclarationEncoding());
+        }
+        out.write("?>\n");
+        return this;
+    }
+
+    /**
+     * <p>Renders processing instructions. The supplied map contains all elements to be
+     * rendered as processing instructions. The key is the name of the element, the value
+     * is either a map of attributes, or an object to be rendered directly. For example:</p>
+     * <code>
+     *     pi("xml-stylesheet":[href:"mystyle.css", type:"text/css"])
+     * </code>
+     *
+     * <p>will be rendered as:</p>
+     *
+     * <pre>
+     *     &lt;?xml-stylesheet href='mystyle.css' type='text/css'?&gt;
+     * </pre>
+     *
+     * @param attrs
+     * @return
+     * @throws IOException
+     */
+    public BaseTemplate pi(Map<?, ?> attrs) throws IOException {
+        for (Map.Entry<?, ?> entry : attrs.entrySet()) {
+            Object target = entry.getKey();
+            Object instruction = entry.getValue();
+            out.write("<?");
+            out.write(target.toString());
+            if (instruction instanceof Map) {
+                writeAttributes((Map) instruction);
+            } else {
+                out.write(target.toString());
+                out.write(" ");
+                out.write(instruction.toString());
+            }
+            out.write("?>\n");
+        }
+        return this;
+    }
+
+    private void writeAttribute(String attName, String value) throws IOException {
+        out.write(attName);
+        out.write("=");
+        writeQt();
+        out.write(escapeQuotes(value));
+        writeQt();
+    }
+
+    private void writeQt() throws IOException {
+        if (configuration.isUseDoubleQuotes()) {
+            out.write('"');
+        } else {
+            out.write('\'');
+        }
+    }
+
+    private void writeIndent() throws IOException {
+        if (out instanceof DelegatingIndentWriter && doWriteIndent) {
+            ((DelegatingIndentWriter)out).writeIndent();
+            doWriteIndent = false;
+        }
+    }
+
+    private String escapeQuotes(String str) {
+        String quote = configuration.isUseDoubleQuotes() ? "\"" : "'";
+        String escape = configuration.isUseDoubleQuotes() ? "&quote;" : "&apos;";
+        return str.replace(quote, escape);
+    }
+
+    /**
+     * This is the main method responsible for writing a tag and its attributes.
+     * The arguments may be:
+     * <ul>
+     *     <li>a closure</li> in which case the closure is rendered inside the tag body
+     *     <li>a string</li>, in which case the string is rendered as the tag body
+     *     <li>a map of attributes</li> in which case the attributes are rendered inside the opening tag
+     * </ul>
+     * <p>or a combination of (attributes,string), (attributes,closure)</p>
+     * @param tagName the name of the tag
+     * @param args tag generation arguments.
+     * @return
+     * @throws IOException
+     */
+    public Object methodMissing(String tagName, Object args) throws IOException {
+        Object o = model.get(tagName);
+        if (o instanceof Closure) {
+            if (args instanceof Object[]) {
+                yieldUnescaped(((Closure) o).call((Object[])args));
+                return this;
+            }
+            yieldUnescaped(((Closure) o).call(args));
+            return this;
+        } else if (args instanceof Object[]) {
+            final Writer wrt = out;
+            TagData tagData = new TagData(args).invoke();
+            Object body = tagData.getBody();
+            writeIndent();
+            wrt.write('<');
+            wrt.write(tagName);
+            writeAttributes(tagData.getAttributes());
+            if (body != null) {
+                wrt.write('>');
+                writeBody(body);
+                writeIndent();
+                wrt.write("</");
+                wrt.write(tagName);
+                wrt.write('>');
+            } else {
+                if (configuration.isExpandEmptyElements()) {
+                    wrt.write("></");
+                    wrt.write(tagName);
+                    wrt.write('>');
+                } else {
+                    wrt.write("/>");
+                }
+            }
+        }
+        return this;
+    }
+
+    private void writeBody(final Object body) throws IOException {
+        boolean indent = out instanceof DelegatingIndentWriter;
+        if (body instanceof Closure) {
+            if (indent) {
+                ((DelegatingIndentWriter)(out)).next();
+            }
+            ((Closure) body).call();
+            if (indent) {
+                ((DelegatingIndentWriter)(out)).previous();
+            }
+        } else {
+            out.write(body.toString());
+        }
+    }
+
+    private void writeAttributes(final Map<?, ?> attributes) throws IOException {
+        if (attributes == null) {
+            return;
+        }
+        final Writer wrt = out;
+        for (Map.Entry entry : attributes.entrySet()) {
+            wrt.write(' ');
+            String attName = entry.getKey().toString();
+            String value = entry.getValue() == null ? "" : entry.getValue().toString();
+            writeAttribute(attName, value);
+        }
+    }
+
+    /**
+     * Includes another template inside this template.
+     * @param templatePath the path to the included resource.
+     * @throws IOException
+     * @throws ClassNotFoundException
+     */
+    public void includeGroovy(String templatePath) throws IOException, ClassNotFoundException {
+        URL resource = getIncludedResource(templatePath);
+        engine.createTemplate(resource, modelTypes).make(model).writeTo(out);
+    }
+
+    private URL getIncludedResource(final String templatePath) throws IOException {
+        URL resource = engine.getTemplateLoader().getResource(templatePath);
+        if (resource == null) {
+            throw new IOException("Unable to load template:" + templatePath);
+        }
+        return resource;
+    }
+
+    /**
+     * Includes contents of another file, not as a template but as escaped text.
+     * @param templatePath
+     * @throws IOException
+     */
+    public void includeEscaped(String templatePath) throws IOException {
+        URL resource = getIncludedResource(templatePath);
+        yield(ResourceGroovyMethods.getText(resource, engine.getCompilerConfiguration().getSourceEncoding()));
+    }
+
+    /**
+     * Includes contents of another file, not as a template but as unescaped text.
+     * @param templatePath
+     * @throws IOException
+     */
+    public void includeUnescaped(String templatePath) throws IOException {
+        URL resource = getIncludedResource(templatePath);
+        yieldUnescaped(ResourceGroovyMethods.getText(resource, engine.getCompilerConfiguration().getSourceEncoding()));
+    }
+
+    /**
+     * Escapes the string representation of the supplied object if it derives from {@link java.lang.CharSequence},
+     * otherwise returns the object itself.
+     * @param contents an object to be escaped for XML
+     * @return  an escaped string, or the object itself
+     */
+    public Object tryEscape(Object contents) {
+        if (contents instanceof CharSequence) {
+            return escapeXml(contents.toString());
+        }
+        return contents;
+    }
+
+    /**
+     * Convenience method to return the current writer instance.
+     * @return
+     */
+    public Writer getOut() {
+        return out;
+    }
+
+    /**
+     * Adds a new line to the output. The new line string can be configured by
+     * {@link groovy.text.markup.TemplateConfiguration#setNewLineString(String)}
+     * @throws IOException
+     */
+    public void newLine() throws IOException {
+        yieldUnescaped(configuration.getNewLineString());
+        doWriteIndent = true;
+    }
+
+    /**
+     * Main method used to render a template.
+     * @param out the Writer to which this Writable should output its data.
+     * @return a writer instance
+     * @throws IOException
+     */
+    public Writer writeTo(final Writer out) throws IOException {
+        try {
+            this.out = createWriter(out);
+            run();
+            return out;
+        } finally {
+            this.out.flush();
+            this.out = null;
+        }
+    }
+
+    private Writer createWriter(final Writer out) {
+        return configuration.isAutoIndent() && !(out instanceof DelegatingIndentWriter)?new DelegatingIndentWriter(out, configuration.getAutoIndentString()):out;
+    }
+
+    private class TagData {
+        private final Object[] array;
+        private Map attributes;
+        private Object body;
+
+        public TagData(final Object args) {
+            this.array = (Object[])args;
+        }
+
+        public Map getAttributes() {
+            return attributes;
+        }
+
+        public Object getBody() {
+            return body;
+        }
+
+        public TagData invoke() {
+            attributes = null;
+            body = null;
+            for (Object o : array) {
+                if (o instanceof Map) {
+                    attributes = (Map) o;
+                } else {
+                    body = o;
+                }
+            }
+            return this;
+        }
+    }
+}
diff --git a/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/DelegatingIndentWriter.java b/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/DelegatingIndentWriter.java
new file mode 100644
index 0000000000..283a75ac12
--- /dev/null
+++ b/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/DelegatingIndentWriter.java
@@ -0,0 +1,107 @@
+/*
+ * Copyright 2003-2014 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package groovy.text.markup;
+
+import java.io.IOException;
+import java.io.Writer;
+
+/**
+ * A writer which delegates to another writer and supports an
+ * additional indenting level.
+ *
+ * @author Cedric Champeau
+ */
+public class DelegatingIndentWriter extends Writer {
+    public final static String SPACES = "    ";
+    public final static String TAB = "\t";
+
+    private final Writer delegate;
+    private final String indentString;
+    private int level;
+
+    public DelegatingIndentWriter(final Writer delegate) {
+        this(delegate, SPACES);
+    }
+
+    public DelegatingIndentWriter(final Writer delegate, final String indentString) {
+        this.delegate = delegate;
+        this.indentString = indentString;
+    }
+
+    @Override
+    public void write(final int c) throws IOException {
+        delegate.write(c);
+    }
+
+    @Override
+    public void write(final char[] cbuf) throws IOException {
+        delegate.write(cbuf);
+    }
+
+    @Override
+    public void write(final char[] cbuf, final int off, final int len) throws IOException {
+        delegate.write(cbuf, off, len);
+    }
+
+    @Override
+    public void write(final String str) throws IOException {
+        delegate.write(str);
+    }
+
+    @Override
+    public void write(final String str, final int off, final int len) throws IOException {
+        delegate.write(str, off, len);
+    }
+
+    @Override
+    public Writer append(final CharSequence csq) throws IOException {
+        return delegate.append(csq);
+    }
+
+    @Override
+    public Writer append(final CharSequence csq, final int start, final int end) throws IOException {
+        return delegate.append(csq, start, end);
+    }
+
+    @Override
+    public Writer append(final char c) throws IOException {
+        return delegate.append(c);
+    }
+
+    @Override
+    public void flush() throws IOException {
+        delegate.flush();
+    }
+
+    @Override
+    public void close() throws IOException {
+        delegate.close();
+    }
+
+    public int next() {
+        return ++level;
+    }
+
+    public int previous() {
+        return --level;
+    }
+
+    public void writeIndent() throws IOException {
+        for (int i=0;i<level;i++) {
+            delegate.write(indentString);
+        }
+    }
+}
diff --git a/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/IncludeType.java b/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/IncludeType.java
new file mode 100644
index 0000000000..b437180d97
--- /dev/null
+++ b/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/IncludeType.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright 2003-2014 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package groovy.text.markup;
+
+/**
+ * An enumeration used internally to map include types to {@link groovy.text.markup.BaseTemplate} method
+ * calls.
+ *
+ * @author Cedric Champeau
+ */
+enum IncludeType {
+    template("includeGroovy"), // includes another Groovy template
+    escaped("includeEscaped"), // includes raw content, escaped before rendering
+    unescaped("includeUnescaped");
+
+    private final String methodName;
+
+    IncludeType(final String methodName) {
+        this.methodName = methodName;
+    }
+
+    public String getMethodName() {
+        return methodName;
+    }
+}
diff --git a/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/MarkupBuilderCodeTransformer.java b/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/MarkupBuilderCodeTransformer.java
new file mode 100644
index 0000000000..83869badd0
--- /dev/null
+++ b/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/MarkupBuilderCodeTransformer.java
@@ -0,0 +1,170 @@
+/*
+ * Copyright 2003-2014 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package groovy.text.markup;
+
+import org.codehaus.groovy.ast.ClassCodeExpressionTransformer;
+import org.codehaus.groovy.ast.ClassHelper;
+import org.codehaus.groovy.ast.DynamicVariable;
+import org.codehaus.groovy.ast.expr.ArgumentListExpression;
+import org.codehaus.groovy.ast.expr.ArrayExpression;
+import org.codehaus.groovy.ast.expr.ClosureExpression;
+import org.codehaus.groovy.ast.expr.ConstantExpression;
+import org.codehaus.groovy.ast.expr.Expression;
+import org.codehaus.groovy.ast.expr.MapEntryExpression;
+import org.codehaus.groovy.ast.expr.MapExpression;
+import org.codehaus.groovy.ast.expr.MethodCallExpression;
+import org.codehaus.groovy.ast.expr.TupleExpression;
+import org.codehaus.groovy.ast.expr.VariableExpression;
+import org.codehaus.groovy.control.SourceUnit;
+
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+/**
+ * <p>This AST transformer is responsible for modifying a source template into something
+ * which can be compiled as a {@link groovy.text.markup.BaseTemplate} subclass.</p>
+ *
+ * <p>It performs the following operations:</p>
+ *
+ * <ul>
+ *     <li>replace dynamic variables with <i>getModel().get(dynamicVariable)</i> calls</li>
+ *     <li>optionally wrap <i>getModel().get(...)</i> calls into <i>tryEscape</i> calls for automatic escaping</li>
+ *     <li>replace <i>include XXX:'...'</i> calls with the appropriate <i>includeXXXX</i> method calls</li>
+ *     <li>replace <i>':tagName'()</i> calls into <i>methodMissing('tagName', ...)</i> calls</li>
+ * </ul>
+ *
+ * @author Cedric Champeau
+ */
+class MarkupBuilderCodeTransformer extends ClassCodeExpressionTransformer {
+
+    private final SourceUnit unit;
+    private final boolean autoEscape;
+
+    public MarkupBuilderCodeTransformer(final SourceUnit unit, final boolean autoEscape) {
+        this.unit = unit;
+        this.autoEscape = autoEscape;
+    }
+
+    @Override
+    protected SourceUnit getSourceUnit() {
+        return unit;
+    }
+
+    @Override
+    public Expression transform(final Expression exp) {
+        if (exp instanceof MethodCallExpression) {
+            return transformMethodCall((MethodCallExpression) exp);
+        }
+        if (exp instanceof ClosureExpression) {
+            ClosureExpression cl = (ClosureExpression) exp;
+            cl.getCode().visit(this);
+        }
+        if (exp instanceof VariableExpression) {
+            VariableExpression var = (VariableExpression) exp;
+            if (var.getAccessedVariable() instanceof DynamicVariable) {
+                MethodCallExpression callGetModel = new MethodCallExpression(
+                        new VariableExpression("this"),
+                        "getModel",
+                        ArgumentListExpression.EMPTY_ARGUMENTS
+                );
+                callGetModel.setImplicitThis(true);
+                callGetModel.setSourcePosition(exp);
+                String varName = var.getName();
+                if ("model".equals(varName) || "unescaped".equals(varName)) {
+                    return callGetModel;
+                }
+                MethodCallExpression mce = new MethodCallExpression(
+                        callGetModel,
+                        "get",
+                        new ArgumentListExpression(new ConstantExpression(varName))
+                );
+                mce.setSourcePosition(exp);
+                mce.setImplicitThis(false);
+                MethodCallExpression yield = new MethodCallExpression(
+                        new VariableExpression("this"),
+                        "tryEscape",
+                        new ArgumentListExpression(mce)
+                );
+                yield.setImplicitThis(true);
+                yield.setSourcePosition(exp);
+                return autoEscape?yield:mce;
+            }
+        }
+        return super.transform(exp);
+    }
+
+    private Expression transformMethodCall(final MethodCallExpression exp) {
+        String name = exp.getMethodAsString();
+        if (exp.isImplicitThis() && "include".equals(name)) {
+            return tryTransformInclude(exp);
+        } else if (exp.isImplicitThis() && name.startsWith(":")) {
+            List<Expression> args;
+            if (exp.getArguments() instanceof ArgumentListExpression) {
+                args = ((ArgumentListExpression) exp.getArguments()).getExpressions();
+            } else {
+                args = Collections.singletonList(exp.getArguments());
+            }
+            Expression newArguments = transform(new ArgumentListExpression(new ConstantExpression(name.substring(1)), new ArrayExpression(ClassHelper.OBJECT_TYPE, args)));
+            MethodCallExpression call = new MethodCallExpression(
+                    new VariableExpression("this"),
+                    "methodMissing",
+                    newArguments
+            );
+            call.setImplicitThis(true);
+            call.setSafe(exp.isSafe());
+            call.setSpreadSafe(exp.isSpreadSafe());
+            call.setSourcePosition(exp);
+            return call;
+        }
+        return super.transform(exp);
+    }
+
+    private Expression tryTransformInclude(final MethodCallExpression exp) {
+        Expression arguments = exp.getArguments();
+        if (arguments instanceof TupleExpression) {
+            List<Expression> expressions = ((TupleExpression) arguments).getExpressions();
+            if (expressions.size() == 1 && expressions.get(0) instanceof MapExpression) {
+                MapExpression map = (MapExpression) expressions.get(0);
+                List<MapEntryExpression> entries = map.getMapEntryExpressions();
+                if (entries.size() == 1) {
+                    MapEntryExpression mapEntry = entries.get(0);
+                    Expression keyExpression = mapEntry.getKeyExpression();
+                    try {
+                        IncludeType includeType = IncludeType.valueOf(keyExpression.getText().toLowerCase());
+                        MethodCallExpression call = new MethodCallExpression(
+                                exp.getObjectExpression(),
+                                includeType.getMethodName(),
+                                new ArgumentListExpression(
+                                        mapEntry.getValueExpression()
+                                )
+                        );
+                        call.setImplicitThis(true);
+                        call.setSafe(exp.isSafe());
+                        call.setSpreadSafe(exp.isSpreadSafe());
+                        call.setSourcePosition(exp);
+                        return call;
+                    } catch (IllegalArgumentException e) {
+                        // not a valid import type, do not modify the code
+                    }
+                }
+
+            }
+        }
+        return super.transform(exp);
+    }
+}
diff --git a/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/MarkupTemplateEngine.java b/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/MarkupTemplateEngine.java
new file mode 100644
index 0000000000..7aabf520db
--- /dev/null
+++ b/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/MarkupTemplateEngine.java
@@ -0,0 +1,164 @@
+/*
+ * Copyright 2003-2014 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package groovy.text.markup;
+
+import groovy.lang.GroovyClassLoader;
+import groovy.lang.GroovyCodeSource;
+import groovy.lang.Writable;
+import groovy.text.Template;
+import groovy.text.TemplateEngine;
+import groovy.transform.CompileStatic;
+import org.codehaus.groovy.ast.ClassHelper;
+import org.codehaus.groovy.ast.ClassNode;
+import org.codehaus.groovy.classgen.GeneratorContext;
+import org.codehaus.groovy.control.CompilationFailedException;
+import org.codehaus.groovy.control.CompilePhase;
+import org.codehaus.groovy.control.CompilerConfiguration;
+import org.codehaus.groovy.control.SourceUnit;
+import org.codehaus.groovy.control.customizers.ASTTransformationCustomizer;
+import org.codehaus.groovy.control.customizers.CompilationCustomizer;
+import org.codehaus.groovy.runtime.DefaultGroovyMethods;
+
+import java.io.IOException;
+import java.io.Reader;
+import java.io.StringReader;
+import java.net.URL;
+import java.util.Collections;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicLong;
+
+/**
+ * A template engine which leverages {@link groovy.xml.StreamingMarkupBuilder} to generate XML/XHTML.
+ *
+ * @author Cedric Champeau
+ */
+public class MarkupTemplateEngine extends TemplateEngine {
+
+    final static ClassNode MARKUPTEMPLATEENGINE_CLASSNODE = ClassHelper.make(MarkupTemplateEngine.class);
+
+    private final static AtomicLong counter = new AtomicLong();
+
+    private final TemplateGroovyClassLoader groovyClassLoader;
+    private final CompilerConfiguration compilerConfiguration;
+    private final TemplateConfiguration templateConfiguration;
+
+    public MarkupTemplateEngine() {
+        this(MarkupTemplateEngine.class.getClassLoader(), new TemplateConfiguration());
+    }
+
+    public MarkupTemplateEngine(ClassLoader parentLoader, TemplateConfiguration tplConfig) {
+        compilerConfiguration = new CompilerConfiguration();
+        templateConfiguration = tplConfig;
+        compilerConfiguration.addCompilationCustomizers(new TemplateASTTransformer(tplConfig));
+        compilerConfiguration.addCompilationCustomizers(
+                new ASTTransformationCustomizer(Collections.singletonMap("extensions","groovy.text.markup.MarkupTemplateTypeCheckingExtension"),CompileStatic.class));
+        if (templateConfiguration.isAutoNewLine()) {
+            compilerConfiguration.addCompilationCustomizers(
+                    new CompilationCustomizer(CompilePhase.CONVERSION) {
+                        @Override
+                        public void call(final SourceUnit source, final GeneratorContext context, final ClassNode classNode) throws CompilationFailedException {
+                            new AutoNewLineTransformer(source).visitClass(classNode);
+                        }
+                    }
+            );
+        }
+        groovyClassLoader = new TemplateGroovyClassLoader(parentLoader, compilerConfiguration);
+    }
+
+    public Template createTemplate(final Reader reader) throws CompilationFailedException, ClassNotFoundException, IOException {
+        return new MarkupTemplateMaker(reader, null);
+    }
+
+    public Template createTypeCheckedModelTemplate(final String source, Map<String,String> modelTypes) throws CompilationFailedException, ClassNotFoundException, IOException {
+        return new MarkupTemplateMaker(new StringReader(source), modelTypes);
+    }
+
+    public Template createTypeCheckedModelTemplate(final Reader reader, Map<String,String> modelTypes) throws CompilationFailedException, ClassNotFoundException, IOException {
+        return new MarkupTemplateMaker(reader, modelTypes);
+    }
+
+    @Override
+    public Template createTemplate(final URL resource) throws CompilationFailedException, ClassNotFoundException, IOException {
+        return new MarkupTemplateMaker(resource, null);
+    }
+
+    public Template createTemplate(final URL resource, Map<String,String> modelTypes) throws CompilationFailedException, ClassNotFoundException, IOException {
+        return new MarkupTemplateMaker(resource, modelTypes);
+    }
+
+    public GroovyClassLoader getTemplateLoader() {
+        return groovyClassLoader;
+    }
+
+    public CompilerConfiguration getCompilerConfiguration() {
+        return compilerConfiguration;
+    }
+
+    public TemplateConfiguration getTemplateConfiguration() {
+        return templateConfiguration;
+    }
+
+    /**
+     * Implements the {@link groovy.text.Template} interface by caching a compiled template script
+     * and keeping a reference to the optional map of types of the model elements.
+     */
+    private class MarkupTemplateMaker implements Template {
+        final Class<BaseTemplate> templateClass;
+        final Map<String,String> modeltypes;
+
+        @SuppressWarnings("unchecked")
+        public MarkupTemplateMaker(final Reader reader, Map<String, String> modelTypes) {
+            templateClass = groovyClassLoader.parseClass(new GroovyCodeSource(reader, "GeneratedMarkupTemplate" + counter.getAndIncrement(), ""), modelTypes);
+            this.modeltypes = modelTypes;
+        }
+
+        @SuppressWarnings("unchecked")
+        public MarkupTemplateMaker(final URL resource, Map<String, String> modelTypes) throws IOException {
+            templateClass = groovyClassLoader.parseClass(new GroovyCodeSource(resource), modelTypes);
+            this.modeltypes = modelTypes;
+        }
+
+        public Writable make() {
+            return make(Collections.emptyMap());
+        }
+
+        public Writable make(final Map binding) {
+            return DefaultGroovyMethods.newInstance(templateClass, new Object[]{MarkupTemplateEngine.this, binding, modeltypes, templateConfiguration});
+        }
+    }
+
+    /**
+     * A specialized GroovyClassLoader which will support passing values to the type checking extension thanks
+     * to a thread local.
+     */
+    static class TemplateGroovyClassLoader extends GroovyClassLoader {
+        final static ThreadLocal<Map<String,String>> modelTypes = new ThreadLocal<Map<String, String>>();
+
+        public TemplateGroovyClassLoader(final ClassLoader parentLoader, final CompilerConfiguration compilerConfiguration) {
+            super(parentLoader, compilerConfiguration);
+        }
+
+        public Class parseClass(final GroovyCodeSource codeSource, Map<String,String> hints) throws CompilationFailedException {
+            modelTypes.set(hints);
+            try {
+                return super.parseClass(codeSource);
+            } finally {
+                modelTypes.set(null);
+            }
+        }
+    }
+
+}
diff --git a/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/MarkupTemplateTypeCheckingExtension.groovy b/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/MarkupTemplateTypeCheckingExtension.groovy
new file mode 100644
index 0000000000..56f812ab20
--- /dev/null
+++ b/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/MarkupTemplateTypeCheckingExtension.groovy
@@ -0,0 +1,213 @@
+/*
+ * Copyright 2003-2014 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package groovy.text.markup
+
+import groovy.transform.CompileStatic
+import org.codehaus.groovy.antlr.AntlrParserPlugin
+import org.codehaus.groovy.antlr.parser.GroovyLexer
+import org.codehaus.groovy.antlr.parser.GroovyRecognizer
+import org.codehaus.groovy.ast.*
+import org.codehaus.groovy.ast.expr.*
+import org.codehaus.groovy.ast.stmt.EmptyStatement
+import org.codehaus.groovy.control.ResolveVisitor
+import org.codehaus.groovy.control.SourceUnit
+import org.codehaus.groovy.control.messages.SyntaxErrorMessage
+import org.codehaus.groovy.syntax.ParserException
+import org.codehaus.groovy.syntax.Reduction
+import org.codehaus.groovy.syntax.SyntaxException
+import org.codehaus.groovy.transform.stc.GroovyTypeCheckingExtensionSupport
+import org.codehaus.groovy.transform.stc.TypeCheckingContext
+
+import java.util.concurrent.atomic.AtomicReference
+
+import static org.codehaus.groovy.ast.ClassHelper.OBJECT_TYPE
+
+/**
+ * <p>A static compilation type checking extension, responsible for transforming unresolved method
+ * calls into direct calls to {@link BaseTemplate#methodMissing(java.lang.String, java.lang.Object)}
+ * for faster rendering.</p>
+ * <p>This extension also supports optional type checking of the model</p>
+ *
+ * @author Cedric Champeau
+ */
+class MarkupTemplateTypeCheckingExtension extends GroovyTypeCheckingExtensionSupport.TypeCheckingDSL {
+
+    @Override
+    Object run() {
+        def modelTypesClassNodes
+
+        setup {
+            def modelTypes = MarkupTemplateEngine.TemplateGroovyClassLoader.modelTypes.get()
+            if (modelTypes!=null) {
+                modelTypesClassNodes = [:]
+                modelTypes.each { k, v ->
+                    modelTypesClassNodes[k] = buildNodeFromString(v, context)
+                }
+            } else {
+                // push a new error collector, we want type checking errors to be silent
+                context.pushErrorCollector()
+            }
+        }
+
+        beforeVisitMethod {
+            newScope {
+                builderCalls = []
+            }
+        }
+        methodNotFound { receiver, name, argList, argTypes, call ->
+            if (call.lineNumber > 0) {
+                if (call.implicitThis) {
+                    currentScope.builderCalls << call
+                    return makeDynamic(call, OBJECT_TYPE)
+                }
+                if (modelTypesClassNodes==null) {
+                    // unchecked mode
+                    return makeDynamic(call, OBJECT_TYPE)
+                }
+            }
+        }
+
+        onMethodSelection { call, node ->
+            if (isMethodCallExpression(call) && call.objectExpression.text=='this.getModel()' && modelTypesClassNodes!=null) {
+                def args = getArguments(call).expressions
+                if (args.size()==1 && isConstantExpression(args[0])) {
+                    def type = modelTypesClassNodes[args[0].text]
+                    if (type) {
+                        storeType(call, type)
+                    }
+                }
+            }
+        }
+
+        unresolvedProperty { pexp ->
+            if (pexp.objectExpression.text=='this.getModel()') {
+                if (modelTypesClassNodes!=null) {
+                    // type checked mode detected!
+                    def type = modelTypesClassNodes[pexp.propertyAsString]
+                    if (type) {
+                        makeDynamic(pexp, type)
+                    }
+                } else {
+                    makeDynamic(pexp)
+                }
+            } else if (modelTypesClassNodes==null) {
+                // dynamic mode
+                makeDynamic(pexp)
+            }
+        }
+
+        afterVisitMethod { mn ->
+            scopeExit {
+                new BuilderMethodReplacer(context.source, builderCalls).visitMethod(mn)
+            }
+        }
+    }
+
+    @CompileStatic
+    private static ClassNode buildNodeFromString(String option, TypeCheckingContext ctx) {
+        GroovyLexer lexer = new GroovyLexer(new StringReader(option))
+        final GroovyRecognizer rn = GroovyRecognizer.make(lexer)
+        rn.classOrInterfaceType(true);
+        final AtomicReference<ClassNode> ref = new AtomicReference<ClassNode>();
+        AntlrParserPlugin plugin = new AntlrParserPlugin() {
+            @Override
+            public ModuleNode buildAST(
+                    final SourceUnit sourceUnit,
+                    final ClassLoader classLoader, final Reduction cst) throws ParserException {
+                ref.set(makeTypeWithArguments(rn.getAST()));
+                return null;
+            }
+        };
+        plugin.buildAST(null, null, null);
+        ClassNode parsedNode = ref.get();
+        ClassNode dummyClass = new ClassNode("dummy", 0, ClassHelper.OBJECT_TYPE);
+        dummyClass.setModule(new ModuleNode(ctx.source));
+        MethodNode dummyMN = new MethodNode(
+                "dummy",
+                0,
+                parsedNode,
+                Parameter.EMPTY_ARRAY,
+                ClassNode.EMPTY_ARRAY,
+                EmptyStatement.INSTANCE
+        )
+        dummyClass.addMethod(dummyMN);
+        ResolveVisitor visitor = new ResolveVisitor(ctx.compilationUnit) {
+            @Override
+            protected void addError(final String msg, final ASTNode expr) {
+                ctx.errorCollector.addErrorAndContinue(new SyntaxErrorMessage(
+                        new SyntaxException(msg + '\n', expr.getLineNumber(), expr.getColumnNumber(), expr.getLastLineNumber(), expr.getLastColumnNumber()),
+                        ctx.source)
+                );
+            }
+        };
+        visitor.startResolving(dummyClass, ctx.source)
+        return dummyMN.getReturnType()
+    }
+
+    private static class BuilderMethodReplacer extends ClassCodeExpressionTransformer {
+
+        private static final MethodNode METHOD_MISSING = ClassHelper.make(BaseTemplate).getMethods('methodMissing')[0]
+
+        private final SourceUnit unit;
+        private final Set<MethodCallExpression> callsToBeReplaced;
+
+        BuilderMethodReplacer(SourceUnit unit, Collection<MethodCallExpression> calls) {
+            this.unit = unit
+            this.callsToBeReplaced = calls as Set;
+        }
+
+        @Override
+        protected SourceUnit getSourceUnit() {
+            unit
+        }
+
+        @Override
+        void visitClosureExpression(final ClosureExpression expression) {
+            super.visitClosureExpression(expression)
+        }
+
+        @Override
+        public Expression transform(final Expression exp) {
+            if (callsToBeReplaced.contains(exp)) {
+                def args = exp.arguments instanceof TupleExpression ? exp.arguments.expressions : [exp.arguments]
+                args*.visit(this)
+                // replace with direct call to methodMissing
+                def call = new MethodCallExpression(
+                        new VariableExpression("this"),
+                        "methodMissing",
+                        new ArgumentListExpression(
+                                new ConstantExpression(exp.getMethodAsString()),
+                                new ArrayExpression(
+                                        OBJECT_TYPE,
+                                        [* args]
+                                )
+                        )
+                )
+                call.implicitThis = true
+                call.safe = exp.safe
+                call.spreadSafe = exp.spreadSafe
+                call.methodTarget = METHOD_MISSING
+                call
+            } else if (exp instanceof ClosureExpression) {
+                exp.code.visit(this)
+                super.transform(exp)
+            } else {
+                super.transform(exp)
+            }
+        }
+    }
+}
diff --git a/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/TagLibAdapter.groovy b/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/TagLibAdapter.groovy
new file mode 100644
index 0000000000..bcd8b78c8c
--- /dev/null
+++ b/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/TagLibAdapter.groovy
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2003-2014 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package groovy.text.markup
+
+/**
+ * Adapts Grails taglibs for use in the template engine. An adapter may be created like this:
+ *
+ * <pre>
+ *     def model = [:]
+ *     def tpl = template.make(model)
+ *     model.g = new TagLibAdapter(tpl)
+ *     model.g.registerTagLib(SimpleTagLib)
+ * </pre>
+ *
+ * where <i>SimpleTagLib</i> is:
+ *
+ * <pre>
+ *     class SimpleTagLib {
+ *        def emoticon = { attrs, body ->
+ *            out << body() << (attrs.happy == 'true' ? " :-)" : " :-(")
+ *        }
+ *     }
+ * </pre>
+ *
+ * Then it can be used inside a template like this:
+ *
+ * <pre>
+ *     g.emoticon(happy:'true') { 'Hi John' }
+ * </pre>
+ *
+ * Performance-wise, it would be better to reimplement the taglib, but this makes it easier to reuse
+ * exisiting code.
+ *
+ * @author Cdric Champeau
+ */
+class TagLibAdapter {
+    private final BaseTemplate template
+    private final List<Object> tagLibs = []
+
+    public TagLibAdapter(BaseTemplate tpl) {
+        this.template = tpl
+    }
+
+    public void registerTagLib(Class tagLibClass) {
+        tagLibs.add(tagLibClass.newInstance())
+    }
+
+    public void registerTagLib(Object tagLib) {
+        tagLibs.add(tagLib)
+    }
+
+    public Object methodMissing(String name, args) {
+        for (Object tagLib : tagLibs) {
+            def p = tagLib."$name"
+            if (p instanceof Closure) {
+                def clone = p.rehydrate(template, template, template)
+                return clone.call(*args)
+            }
+        }
+        throw new MissingMethodException(name, TagLibAdapter, args)
+    }
+}
diff --git a/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/TemplateASTTransformer.java b/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/TemplateASTTransformer.java
new file mode 100644
index 0000000000..1a75c6aba2
--- /dev/null
+++ b/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/TemplateASTTransformer.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright 2003-2014 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package groovy.text.markup;
+
+import org.codehaus.groovy.ast.ClassHelper;
+import org.codehaus.groovy.ast.ClassNode;
+import org.codehaus.groovy.ast.ConstructorNode;
+import org.codehaus.groovy.ast.DynamicVariable;
+import org.codehaus.groovy.ast.MethodNode;
+import org.codehaus.groovy.ast.Parameter;
+import org.codehaus.groovy.ast.VariableScope;
+import org.codehaus.groovy.ast.expr.ArgumentListExpression;
+import org.codehaus.groovy.ast.expr.ClosureExpression;
+import org.codehaus.groovy.ast.expr.ConstructorCallExpression;
+import org.codehaus.groovy.ast.expr.Expression;
+import org.codehaus.groovy.ast.expr.MethodCallExpression;
+import org.codehaus.groovy.ast.expr.VariableExpression;
+import org.codehaus.groovy.ast.stmt.BlockStatement;
+import org.codehaus.groovy.ast.stmt.ExpressionStatement;
+import org.codehaus.groovy.ast.stmt.Statement;
+import org.codehaus.groovy.classgen.GeneratorContext;
+import org.codehaus.groovy.classgen.VariableScopeVisitor;
+import org.codehaus.groovy.control.CompilationFailedException;
+import org.codehaus.groovy.control.CompilePhase;
+import org.codehaus.groovy.control.SourceUnit;
+import org.codehaus.groovy.control.customizers.CompilationCustomizer;
+import org.objectweb.asm.Opcodes;
+
+import java.util.LinkedList;
+import java.util.List;
+
+/**
+ * <p>An AST transformation which adapts the AST generated from a script as a class extending {@link groovy.text.markup.BaseTemplate}.</p>
+ *
+ * <p>This transformation:</p>
+ *
+ * <ul>
+ *     <li>Sets the super class of the script to the selected {@link TemplateConfiguration#getBaseTemplateClass() template class}</li>
+ *     <li>Calls the {@link groovy.text.markup.MarkupBuilderCodeTransformer} on the "run" method</li>
+ *     <li>Creates the appropriate constructor</li>
+ * </ul>
+ *
+ * @author Cedric Champeau
+ */
+class TemplateASTTransformer extends CompilationCustomizer {
+
+    private static final ClassNode TEMPLATECONFIG_CLASSNODE = ClassHelper.make(TemplateConfiguration.class);
+    private final TemplateConfiguration config;
+
+    public TemplateASTTransformer(TemplateConfiguration config) {
+        super(CompilePhase.SEMANTIC_ANALYSIS);
+        this.config = config;
+    }
+
+    @Override
+    public void call(final SourceUnit source, final GeneratorContext context, final ClassNode classNode) throws CompilationFailedException {
+        if (classNode.isScriptBody()) {
+            classNode.setSuperClass(ClassHelper.make(config.getBaseTemplateClass()));
+            createConstructor(classNode);
+            transformRunMethod(classNode, source);
+        }
+    }
+
+    private void transformRunMethod(final ClassNode classNode, final SourceUnit source) {
+        MethodNode runMethod = classNode.getDeclaredMethod("run", Parameter.EMPTY_ARRAY);
+        Statement code = runMethod.getCode();
+        MarkupBuilderCodeTransformer transformer = new MarkupBuilderCodeTransformer(source, config.isAutoEscape());
+        code.visit(transformer);
+    }
+
+    private void createConstructor(final ClassNode classNode) {
+        Parameter[] params = new Parameter[]{
+                new Parameter(MarkupTemplateEngine.MARKUPTEMPLATEENGINE_CLASSNODE, "engine"),
+                new Parameter(ClassHelper.MAP_TYPE.getPlainNodeReference(), "model"),
+                new Parameter(ClassHelper.MAP_TYPE.getPlainNodeReference(), "modelTypes"),
+                new Parameter(TEMPLATECONFIG_CLASSNODE, "tplConfig")
+        };
+        List<Expression> vars = new LinkedList<Expression>();
+        for (Parameter param : params) {
+            vars.add(new VariableExpression(param));
+        }
+        ExpressionStatement body = new ExpressionStatement(
+                new ConstructorCallExpression(ClassNode.SUPER, new ArgumentListExpression(vars)));
+        ConstructorNode ctor = new ConstructorNode(Opcodes.ACC_PUBLIC, params, ClassNode.EMPTY_ARRAY, body);
+        classNode.addConstructor(ctor);
+    }
+}
diff --git a/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/TemplateConfiguration.java b/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/TemplateConfiguration.java
new file mode 100644
index 0000000000..92604bef32
--- /dev/null
+++ b/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/TemplateConfiguration.java
@@ -0,0 +1,146 @@
+/*
+ * Copyright 2003-2014 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package groovy.text.markup;
+
+/**
+ * Configuration options for the {@link groovy.text.markup.MarkupTemplateEngine markup template engine}.
+ *
+ * @author Cedric Champeau
+ */
+public class TemplateConfiguration {
+
+    private String declarationEncoding;
+    private boolean expandEmptyElements;
+    private boolean useDoubleQuotes;
+    private String newLineString = System.getProperty("line.separator");
+    private boolean autoEscape = false;
+    private boolean autoIndent = false;
+    private String autoIndentString = DelegatingIndentWriter.SPACES;
+    private boolean autoNewLine = false;
+    private Class<? extends BaseTemplate> baseTemplateClass = BaseTemplate.class;
+
+    /**
+     * @return the encoding used in the declaration header
+     */
+    public String getDeclarationEncoding() {
+        return declarationEncoding;
+    }
+
+    /**
+     * Set the encoding used to write the declaration header. Note that it is the responsability of
+     * the user to ensure that it matches the writer encoding.
+     * @param declarationEncoding encoding to be used in the declaration string
+     */
+    public void setDeclarationEncoding(final String declarationEncoding) {
+        this.declarationEncoding = declarationEncoding;
+    }
+
+    /**
+     * @return whether elements without body should be written in the short form (ex: &lt;br/&gt;) or
+     * in an expanded form (ex: &lt;br&gt;&lt;/br&gt;)
+     */
+    public boolean isExpandEmptyElements() {
+        return expandEmptyElements;
+    }
+
+    public void setExpandEmptyElements(final boolean expandEmptyElements) {
+        this.expandEmptyElements = expandEmptyElements;
+    }
+
+    /**
+     * @return true if attributes should use double quotes instead of single quotes
+     */
+    public boolean isUseDoubleQuotes() {
+        return useDoubleQuotes;
+    }
+
+    public void setUseDoubleQuotes(final boolean useDoubleQuotes) {
+        this.useDoubleQuotes = useDoubleQuotes;
+    }
+
+    public String getNewLineString() {
+        return newLineString;
+    }
+
+    public void setNewLineString(final String newLineString) {
+        this.newLineString = newLineString;
+    }
+
+    /**
+     * @return true if variables in the model which are assignable to {@link java.lang.CharSequence} should be
+     * automatically escaped.
+     */
+    public boolean isAutoEscape() {
+        return autoEscape;
+    }
+
+    /**
+     * Set to true if you want variables in the model which are assignable to {@link java.lang.CharSequence} to
+     * be escaped automatically in templates. If this flag is set to true and that you want a value not to be
+     * automatically escaped, then you need to use <i>${unescaped.variable}</i> instead of <i>$variable</i>
+     * @param autoEscape value if the autoEscape flag
+     */
+    public void setAutoEscape(final boolean autoEscape) {
+        this.autoEscape = autoEscape;
+    }
+
+    /**
+     * @return true if the template engine should handle indents automatically
+     */
+    public boolean isAutoIndent() {
+        return autoIndent;
+    }
+
+    /**
+     * Set this to true if you want the template engine to render indents automatically. In that case,
+     * the supplied writer is wrapped into a {@link groovy.text.markup.DelegatingIndentWriter} and indents
+     * are inserted after each call to newLine.
+     * @param autoIndent the auto-indent flag
+     */
+    public void setAutoIndent(final boolean autoIndent) {
+        this.autoIndent = autoIndent;
+    }
+
+    public String getAutoIndentString() {
+        return autoIndentString;
+    }
+
+    public void setAutoIndentString(final String autoIndentString) {
+        this.autoIndentString = autoIndentString;
+    }
+
+    public boolean isAutoNewLine() {
+        return autoNewLine;
+    }
+
+    public void setAutoNewLine(final boolean autoNewLine) {
+        this.autoNewLine = autoNewLine;
+    }
+
+    public Class<? extends BaseTemplate> getBaseTemplateClass() {
+        return baseTemplateClass;
+    }
+
+    /**
+     * Set the template base class. You can use a distrinct template class to provide more
+     * statically available data to your templates.
+     *
+     * @param baseTemplateClass a class extending {@link groovy.text.markup.BaseTemplate}
+     */
+    public void setBaseTemplateClass(final Class<? extends BaseTemplate> baseTemplateClass) {
+        this.baseTemplateClass = baseTemplateClass;
+    }
+}
diff --git a/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/package.html b/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/package.html
new file mode 100644
index 0000000000..8e1f206942
--- /dev/null
+++ b/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/package.html
@@ -0,0 +1,8 @@
+<html>
+  <head>
+    <title>package groovy.text.markup.*</title>
+  </head>
+  <body>
+    <p>Contains a template engine facilitating generation of XML-like markup with optional type checking.</p>
+  </body>
+</html>
diff --git a/subprojects/groovy-templates/src/main/java/groovy/text/package.html b/subprojects/groovy-templates/src/main/groovy/groovy/text/package.html
similarity index 100%
rename from subprojects/groovy-templates/src/main/java/groovy/text/package.html
rename to subprojects/groovy-templates/src/main/groovy/groovy/text/package.html
diff --git a/subprojects/groovy-templates/src/test/groovy/groovy/text/CustomBaseTemplate.java b/subprojects/groovy-templates/src/test/groovy/groovy/text/CustomBaseTemplate.java
new file mode 100644
index 0000000000..a106da3331
--- /dev/null
+++ b/subprojects/groovy-templates/src/test/groovy/groovy/text/CustomBaseTemplate.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2003-2014 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package groovy.text;
+
+import groovy.lang.GroovySystem;
+import groovy.text.markup.BaseTemplate;
+import groovy.text.markup.MarkupTemplateEngine;
+import groovy.text.markup.TemplateConfiguration;
+
+import java.util.Map;
+
+public abstract class CustomBaseTemplate extends BaseTemplate {
+    private String version;
+
+    public CustomBaseTemplate(
+            final MarkupTemplateEngine templateEngine,
+            final Map model,
+            final Map modelTypes, final TemplateConfiguration configuration) {
+        super(templateEngine, model, modelTypes, configuration);
+    }
+
+    public String getVersion() {
+        return version;
+    }
+
+    public void setVersion(final String version) {
+        this.version = version;
+    }
+}
diff --git a/subprojects/groovy-templates/src/test/groovy/groovy/text/MarkupTemplateEngineTest.groovy b/subprojects/groovy-templates/src/test/groovy/groovy/text/MarkupTemplateEngineTest.groovy
new file mode 100644
index 0000000000..99e65292a5
--- /dev/null
+++ b/subprojects/groovy-templates/src/test/groovy/groovy/text/MarkupTemplateEngineTest.groovy
@@ -0,0 +1,581 @@
+/*
+ * Copyright 2003-2014 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package groovy.text
+
+import groovy.text.markup.BaseTemplate
+import groovy.text.markup.MarkupTemplateEngine
+import groovy.text.markup.TagLibAdapter
+import groovy.text.markup.TemplateConfiguration
+import groovy.transform.CompileStatic
+
+class MarkupTemplateEngineTest extends GroovyTestCase {
+    void testSimpleTemplate() {
+        MarkupTemplateEngine engine = new MarkupTemplateEngine()
+        def template = engine.createTemplate '''
+html {
+    body {
+        yield 'It works!'
+    }
+}
+'''
+        StringWriter rendered = new StringWriter()
+        template.make().writeTo(rendered)
+        assert rendered.toString() == '<html><body>It works!</body></html>'
+    }
+
+    void testSimpleTemplateWithModel() {
+        MarkupTemplateEngine engine = new MarkupTemplateEngine()
+        def template = engine.createTemplate '''
+html {
+    body {
+        yield message
+    }
+}
+'''
+        def model = [message: 'It works!']
+        StringWriter rendered = new StringWriter()
+        template.make(model).writeTo(rendered)
+        assert rendered.toString() == '<html><body>It works!</body></html>'
+    }
+
+    void testSimpleTemplateWithIncludeTemplate() {
+        MarkupTemplateEngine engine = new MarkupTemplateEngine()
+        def template = engine.createTemplate '''
+html {
+    body {
+        include template:'includes/hello.tpl'
+    }
+}
+'''
+        StringWriter rendered = new StringWriter()
+        template.make().writeTo(rendered)
+        assert rendered.toString() == '<html><body>Hello from include!</body></html>'
+    }
+
+    void testSimpleTemplateWithIncludeRaw() {
+        MarkupTemplateEngine engine = new MarkupTemplateEngine()
+        def template = engine.createTemplate '''
+html {
+    body {
+        include unescaped:'includes/hello.html'
+    }
+}
+'''
+        StringWriter rendered = new StringWriter()
+        template.make().writeTo(rendered)
+        assert rendered.toString() == '<html><body>Hello unescaped!</body></html>'
+    }
+
+    void testSimpleTemplateWithIncludeEscaped() {
+        MarkupTemplateEngine engine = new MarkupTemplateEngine()
+        def template = engine.createTemplate '''
+html {
+    body {
+        include escaped:'includes/hello-escaped.txt'
+    }
+}
+'''
+        StringWriter rendered = new StringWriter()
+        template.make().writeTo(rendered)
+        assert rendered.toString() == '<html><body>Hello &lt;escaped&gt;!</body></html>'
+    }
+
+    void testCollectionInModel() {
+        MarkupTemplateEngine engine = new MarkupTemplateEngine()
+        def template = engine.createTemplate '''
+html {
+    body {
+        ul {
+            persons.each { p ->
+                li(p.name)
+            }
+        }
+    }
+}
+'''
+        StringWriter rendered = new StringWriter()
+        def model = [persons: [[name: 'Cedric'], [name: 'Jochen']]]
+        template.make(model).writeTo(rendered)
+        assert rendered.toString() == '<html><body><ul><li>Cedric</li><li>Jochen</li></ul></body></html>'
+
+    }
+
+    void testHTMLHeader() {
+        MarkupTemplateEngine engine = new MarkupTemplateEngine()
+        def template = engine.createTemplate '''
+yieldUnescaped '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'
+html {
+    body('Hello, XHTML!')
+}
+'''
+        StringWriter rendered = new StringWriter()
+        template.make().writeTo(rendered)
+        assert rendered.toString() == '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html><body>Hello, XHTML!</body></html>'
+    }
+
+    void testTemplateWithHelperMethod() {
+        MarkupTemplateEngine engine = new MarkupTemplateEngine()
+        def template = engine.createTemplate '''
+def foo = {
+    body('Hello from foo!')
+}
+
+html {
+    foo()
+}
+'''
+        StringWriter rendered = new StringWriter()
+        template.make().writeTo(rendered)
+        assert rendered.toString() == '<html><body>Hello from foo!</body></html>'
+    }
+
+    void testCallPi() {
+        MarkupTemplateEngine engine = new MarkupTemplateEngine()
+        def template = engine.createTemplate '''
+pi("xml-stylesheet":[href:"mystyle.css", type:"text/css"])
+html {
+    body('Hello, PI!')
+}
+'''
+        StringWriter rendered = new StringWriter()
+        template.make().writeTo(rendered)
+        assert rendered.toString() == '<?xml-stylesheet href=\'mystyle.css\' type=\'text/css\'?>\n<html><body>Hello, PI!</body></html>'
+    }
+
+    void testXmlDeclaration() {
+        MarkupTemplateEngine engine = new MarkupTemplateEngine()
+        def template = engine.createTemplate '''
+xmlDeclaration()
+html {
+    body('Hello, PI!')
+}
+'''
+        StringWriter rendered = new StringWriter()
+        template.make().writeTo(rendered)
+        assert rendered.toString() == '<?xml version=\'1.0\'?>\n<html><body>Hello, PI!</body></html>'
+    }
+
+    void testNewLine() {
+        MarkupTemplateEngine engine = new MarkupTemplateEngine()
+        engine.templateConfiguration.newLineString = '||'
+        def template = engine.createTemplate '''
+html {
+    newLine()
+    body('Hello, PI!')
+}
+'''
+        StringWriter rendered = new StringWriter()
+        template.make().writeTo(rendered)
+        assert rendered.toString() == '<html>||<body>Hello, PI!</body></html>'
+    }
+
+    void testXMLWithYieldTag() {
+        MarkupTemplateEngine engine = new MarkupTemplateEngine()
+        def template = engine.createTemplate '''
+':yield'()
+'''
+        StringWriter rendered = new StringWriter()
+        template.make().writeTo(rendered)
+        assert rendered.toString() == '<yield/>'
+    }
+
+    void testTagsWithAttributes() {
+        MarkupTemplateEngine engine = new MarkupTemplateEngine()
+        def template = engine.createTemplate '''
+html {
+    a(href:'foo.html', 'Link text')
+    tagWithQuote(attr:"fo'o")
+}
+'''
+        StringWriter rendered = new StringWriter()
+        template.make().writeTo(rendered)
+        assert rendered.toString() == '<html><a href=\'foo.html\'>Link text</a><tagWithQuote attr=\'fo&apos;o\'/></html>'
+    }
+
+    void testTagsWithAttributesAndDoubleQuotes() {
+        MarkupTemplateEngine engine = new MarkupTemplateEngine()
+        engine.templateConfiguration.useDoubleQuotes = true
+        def template = engine.createTemplate '''
+html {
+    a(href:'foo.html', 'Link text')
+    tagWithQuote(attr:"fo'o")
+}
+'''
+        StringWriter rendered = new StringWriter()
+        template.make().writeTo(rendered)
+        assert rendered.toString() == '<html><a href="foo.html">Link text</a><tagWithQuote attr="fo\'o"/></html>'
+    }
+
+    void testLoopInTemplate() {
+        MarkupTemplateEngine engine = new MarkupTemplateEngine()
+        def model = [text: 'Hello', persons: ['Bob', 'Alice']]
+        def template = engine.createTemplate '''
+html {
+    body {
+        ul {
+            persons.each {
+                li("$text $it")
+            }
+        }
+    }
+}
+'''
+        StringWriter rendered = new StringWriter()
+        template.make(model).writeTo(rendered)
+        assert rendered.toString() == '<html><body><ul><li>Hello Bob</li><li>Hello Alice</li></ul></body></html>'
+    }
+
+    void testHelperFunctionInBinding() {
+        MarkupTemplateEngine engine = new MarkupTemplateEngine()
+        def model = [text: { it.toUpperCase() }]
+        def template = engine.createTemplate '''
+html {
+    body {
+        text('hello')
+    }
+}
+'''
+        StringWriter rendered = new StringWriter()
+        template.make(model).writeTo(rendered)
+        assert rendered.toString() == '<html><body>HELLO</body></html>'
+    }
+
+    void testShouldNotEscapeUserInputAutomatically() {
+        MarkupTemplateEngine engine = new MarkupTemplateEngine()
+        def model = [text: '<xml>']
+        def template = engine.createTemplate '''
+html {
+    body(text)
+}
+'''
+        StringWriter rendered = new StringWriter()
+        template.make(model).writeTo(rendered)
+        assert rendered.toString() == '<html><body><xml></body></html>'
+    }
+
+    void testShouldEscapeUserInputAutomatically() {
+        TemplateConfiguration config = new TemplateConfiguration()
+        config.autoEscape = true
+        MarkupTemplateEngine engine = new MarkupTemplateEngine(this.class.classLoader, config)
+        def model = [text: '<xml>']
+        def template = engine.createTemplate '''
+html {
+    body(text)
+}
+'''
+        StringWriter rendered = new StringWriter()
+        template.make(model).writeTo(rendered)
+        assert rendered.toString() == '<html><body>&lt;xml&gt;</body></html>'
+    }
+
+    void testShouldNotEscapeUserInputAutomaticallyEvenIfFlagSet() {
+        TemplateConfiguration config = new TemplateConfiguration()
+        config.autoEscape = true
+        MarkupTemplateEngine engine = new MarkupTemplateEngine(this.class.classLoader, config)
+        def model = [text: '<xml>']
+        def template = engine.createTemplate '''
+html {
+    body(unescaped.text)
+}
+'''
+        StringWriter rendered = new StringWriter()
+        template.make(model).writeTo(rendered)
+        assert rendered.toString() == '<html><body><xml></body></html>'
+    }
+
+
+    void testTypeCheckedModel() {
+        MarkupTemplateEngine engine = new MarkupTemplateEngine()
+        def template = engine.createTypeCheckedModelTemplate '''
+html {
+    body(text.toUpperCase())
+}
+''', [text: 'String']
+        def model = [text: 'Type checked!']
+        StringWriter rendered = new StringWriter()
+        template.make(model).writeTo(rendered)
+        assert rendered.toString() == '<html><body>TYPE CHECKED!</body></html>'
+
+    }
+
+    void testTypeCheckedModelShouldFail() {
+        assert shouldFail {
+            MarkupTemplateEngine engine = new MarkupTemplateEngine()
+            def template = engine.createTypeCheckedModelTemplate '''
+    html {
+        body(text.toUpperCase())
+    }
+    ''', [text: 'Integer']
+            def model = [text: 'Type checked!']
+            StringWriter rendered = new StringWriter()
+            template.make(model).writeTo(rendered)
+            assert rendered.toString() == '<html><body>TYPE CHECKED!</body></html>'
+        } =~ 'Cannot find matching method java.lang.Integer#toUpperCase()'
+
+    }
+
+    void testTypeCheckedModelShouldFailWithoutModelDescription() {
+        assert shouldFail {
+            MarkupTemplateEngine engine = new MarkupTemplateEngine()
+            def template = engine.createTypeCheckedModelTemplate '''
+    html {
+        body(p.name.toUpperCase())
+    }
+    ''', [:]
+            def model = [p: new Person(name: 'Cdric')]
+            StringWriter rendered = new StringWriter()
+            template.make(model).writeTo(rendered)
+        } =~ 'No such property: name'
+
+    }
+
+    void testTypeCheckedModelShouldSucceedWithModelDescription() {
+        MarkupTemplateEngine engine = new MarkupTemplateEngine()
+        def template = engine.createTypeCheckedModelTemplate '''
+    html {
+        body(p.name.toUpperCase())
+    }
+    ''', [p: 'groovy.text.MarkupTemplateEngineTest.Person']
+        def model = [p: new Person(name: 'Cedric')]
+        StringWriter rendered = new StringWriter()
+        template.make(model).writeTo(rendered)
+        assert rendered.toString() == '<html><body>CEDRIC</body></html>'
+    }
+
+    void testTypeCheckedModelShouldSucceedWithModelDescriptionUsingGenerics() {
+        MarkupTemplateEngine engine = new MarkupTemplateEngine()
+        def template = engine.createTypeCheckedModelTemplate '''
+    html {
+        ul {
+            persons.each { p ->
+                li(p.name.toUpperCase())
+            }
+        }
+    }
+    ''', [persons: 'List<groovy.text.MarkupTemplateEngineTest.Person>']
+        def model = [persons: [new Person(name: 'Cedric')]]
+        StringWriter rendered = new StringWriter()
+        template.make(model).writeTo(rendered)
+        assert rendered.toString() == '<html><ul><li>CEDRIC</li></ul></html>'
+    }
+
+    void testTypeCheckedTemplateShouldFailInInclude() {
+        assert shouldFail {
+            MarkupTemplateEngine engine = new MarkupTemplateEngine()
+            def template = engine.createTypeCheckedModelTemplate '''
+    html {
+        body {
+            include template:'includes/typecheckedinclude.tpl'
+        }
+    }
+    ''', [text: 'Integer']
+            def model = [text: 'Type checked!']
+            StringWriter rendered = new StringWriter()
+            template.make(model).writeTo(rendered)
+        } =~ 'Cannot find matching method java.lang.Integer#toUpperCase()'
+    }
+
+    void testSimpleAutoIndent() {
+        TemplateConfiguration config = new TemplateConfiguration()
+        config.autoIndent = true
+        config.newLineString = '\n'
+        MarkupTemplateEngine engine = new MarkupTemplateEngine(this.class.classLoader, config)
+        def template = engine.createTemplate '''
+html {
+    newLine()
+    body {
+        newLine()
+        p('Test')
+        newLine()
+    }
+    newLine()
+}
+'''
+        StringWriter rendered = new StringWriter()
+        template.make().writeTo(rendered)
+        assert rendered.toString() == '''<html>
+    <body>
+        <p>Test</p>
+    </body>
+</html>'''
+    }
+
+   void testSimpleAutoIndentShouldAddNewLineInLoop() {
+        TemplateConfiguration config = new TemplateConfiguration()
+        config.autoIndent = true
+        config.newLineString = '\n'
+        MarkupTemplateEngine engine = new MarkupTemplateEngine(this.class.classLoader, config)
+        def template = engine.createTemplate '''
+html {
+    newLine()
+    body {
+        newLine()
+        ul {
+            newLine()
+            persons.eachWithIndex { p,i ->
+                if (i) newLine()
+                li(p)
+            }
+            newLine()
+        }
+        newLine()
+    }
+    newLine()
+}
+'''
+        StringWriter rendered = new StringWriter()
+        def model = [persons:['Cedric','Jochen']]
+        template.make(model).writeTo(rendered)
+        assert rendered.toString() == '''<html>
+    <body>
+        <ul>
+            <li>Cedric</li>
+            <li>Jochen</li>
+        </ul>
+    </body>
+</html>'''
+    }
+
+    void testSimpleAutoIndentShouldAutoAddNewLineInLoop() {
+        TemplateConfiguration config = new TemplateConfiguration()
+        config.autoIndent = true
+        config.autoNewLine = true
+        config.newLineString = '\n'
+        MarkupTemplateEngine engine = new MarkupTemplateEngine(this.class.classLoader, config)
+        def template = engine.createTemplate '''
+html {
+    body {
+        ul {
+            persons.each {
+                li(it)
+                newLine()
+            }
+        }
+    }
+}
+'''
+        StringWriter rendered = new StringWriter()
+        def model = [persons:['Cedric','Jochen']]
+        template.make(model).writeTo(rendered)
+        assert rendered.toString() == '''<html>
+    <body>
+        <ul>
+            <li>Cedric</li>
+            <li>Jochen</li>
+            
+        </ul>
+    </body>
+</html>'''
+    }
+
+    void testSimpleAutoIndentWithAutoNewLine() {
+        TemplateConfiguration config = new TemplateConfiguration()
+        config.autoIndent = true
+        config.autoNewLine = true
+        config.newLineString = '\n'
+        MarkupTemplateEngine engine = new MarkupTemplateEngine(this.class.classLoader, config)
+        def template = engine.createTemplate '''
+html {
+    body {
+        p('Test')
+    }
+}
+'''
+        StringWriter rendered = new StringWriter()
+        template.make().writeTo(rendered)
+        assert rendered.toString() == '''<html>
+    <body>
+        <p>Test</p>
+    </body>
+</html>'''
+    }
+
+    void testCustomTemplateClass() {
+        TemplateConfiguration config = new TemplateConfiguration()
+        config.baseTemplateClass = CustomBaseTemplate
+        MarkupTemplateEngine engine = new MarkupTemplateEngine(this.class.classLoader, config)
+        def template = engine.createTemplate '''p(getVersion())'''
+        StringWriter rendered = new StringWriter()
+        def tpl = template.make()
+        tpl.version = 'Template v1'
+        tpl.writeTo(rendered)
+        assert rendered.toString() == "<p>Template v1</p>"
+
+    }
+
+    void testShouldNotThrowTypeCheckingError() {
+        TemplateConfiguration config = new TemplateConfiguration()
+        MarkupTemplateEngine engine = new MarkupTemplateEngine(this.class.classLoader, config)
+        def template = engine.createTemplate '''int x = name.length()
+yield "$name: $x"
+'''
+        StringWriter rendered = new StringWriter()
+        def model = [name: 'Michel']
+        def tpl = template.make(model)
+        tpl.writeTo(rendered)
+        assert rendered.toString() == "Michel: 6"
+    }
+
+    void testComment() {
+        TemplateConfiguration config = new TemplateConfiguration()
+        MarkupTemplateEngine engine = new MarkupTemplateEngine(this.class.classLoader, config)
+        def template = engine.createTemplate '''comment " This is a $comment "
+'''
+        StringWriter rendered = new StringWriter()
+        def model = [comment: 'comment']
+        def tpl = template.make(model)
+        tpl.writeTo(rendered)
+        assert rendered.toString() == "<!-- This is a comment -->"
+    }
+
+    void testYieldUnescaped() {
+        TemplateConfiguration config = new TemplateConfiguration()
+        MarkupTemplateEngine engine = new MarkupTemplateEngine(this.class.classLoader, config)
+        def template = engine.createTemplate '''yieldUnescaped html
+'''
+        StringWriter rendered = new StringWriter()
+        def model = [html: '<html></html>']
+        def tpl = template.make(model)
+        tpl.writeTo(rendered)
+        assert rendered.toString() == "<html></html>"
+    }
+
+    void testGrailsTagLibCompatibility() {
+        TemplateConfiguration config = new TemplateConfiguration()
+        MarkupTemplateEngine engine = new MarkupTemplateEngine(this.class.classLoader, config)
+        def template = engine.createTemplate '''g.emoticon(happy:'true') { 'Hi John' }
+'''
+        StringWriter rendered = new StringWriter()
+        def model = [:]
+        def tpl = template.make(model)
+        model.g = new TagLibAdapter(tpl)
+        model.g.registerTagLib(SimpleTagLib)
+        tpl.writeTo(rendered)
+        assert rendered.toString() == "Hi John :-)"
+    }
+
+    class SimpleTagLib {
+        def emoticon = { attrs, body ->
+            out << body() << (attrs.happy == 'true' ? " :-)" : " :-(")
+        }
+    }
+
+    public static class Person {
+        String name
+    }
+
+}
diff --git a/subprojects/groovy-templates/src/test/resources/includes/hello-escaped.txt b/subprojects/groovy-templates/src/test/resources/includes/hello-escaped.txt
new file mode 100644
index 0000000000..96921c09a3
--- /dev/null
+++ b/subprojects/groovy-templates/src/test/resources/includes/hello-escaped.txt
@@ -0,0 +1 @@
+Hello <escaped>!
\ No newline at end of file
diff --git a/subprojects/groovy-templates/src/test/resources/includes/hello.html b/subprojects/groovy-templates/src/test/resources/includes/hello.html
new file mode 100644
index 0000000000..3e910a1bf7
--- /dev/null
+++ b/subprojects/groovy-templates/src/test/resources/includes/hello.html
@@ -0,0 +1 @@
+Hello unescaped!
\ No newline at end of file
diff --git a/subprojects/groovy-templates/src/test/resources/includes/hello.tpl b/subprojects/groovy-templates/src/test/resources/includes/hello.tpl
new file mode 100644
index 0000000000..d572fca040
--- /dev/null
+++ b/subprojects/groovy-templates/src/test/resources/includes/hello.tpl
@@ -0,0 +1 @@
+yield 'Hello from include!'
\ No newline at end of file
diff --git a/subprojects/groovy-templates/src/test/resources/includes/typecheckedinclude.tpl b/subprojects/groovy-templates/src/test/resources/includes/typecheckedinclude.tpl
new file mode 100644
index 0000000000..20db0f57dd
--- /dev/null
+++ b/subprojects/groovy-templates/src/test/resources/includes/typecheckedinclude.tpl
@@ -0,0 +1 @@
+yield text.toUpperCase()
\ No newline at end of file
diff --git a/subprojects/groovy-xml/src/main/groovy/groovy/xml/StreamingMarkupBuilder.groovy b/subprojects/groovy-xml/src/main/groovy/groovy/xml/StreamingMarkupBuilder.groovy
index 1bdecd3f15..9bd4c8fde5 100644
--- a/subprojects/groovy-xml/src/main/groovy/groovy/xml/StreamingMarkupBuilder.groovy
+++ b/subprojects/groovy-xml/src/main/groovy/groovy/xml/StreamingMarkupBuilder.groovy
@@ -236,7 +236,7 @@ class StreamingMarkupBuilder extends AbstractStreamingBuilder {
      *
      * @return a {@link Writable} to render the markup
      */
-    public bind(closure) {
+    public Writable bind(closure) {
         def boundClosure = this.builder.bind(closure);
         def enc = encoding; // take a snapshot of the encoding when the closure is bound to the builder
 
