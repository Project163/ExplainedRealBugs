diff --git a/src/main/java/org/codehaus/groovy/runtime/StringGroovyMethods.java b/src/main/java/org/codehaus/groovy/runtime/StringGroovyMethods.java
index 5e7e04f3fc..b4b884f4ba 100644
--- a/src/main/java/org/codehaus/groovy/runtime/StringGroovyMethods.java
+++ b/src/main/java/org/codehaus/groovy/runtime/StringGroovyMethods.java
@@ -1029,16 +1029,7 @@ public class StringGroovyMethods extends DefaultGroovyMethodsSupport {
     public static String find(final CharSequence self, final Pattern pattern, @ClosureParams(value=FromString.class, options={"java.util.List<java.lang.String>","java.lang.String[]"}) final Closure closure) {
         Matcher matcher = pattern.matcher(self.toString());
         if (matcher.find()) {
-            if (hasGroup(matcher)) {
-                int count = matcher.groupCount();
-                List<String> groups = new ArrayList<>(count);
-                for (int i = 0; i <= count; i += 1) {
-                    groups.add(matcher.group(i));
-                }
-                return FormatHelper.toString(closure.call(groups));
-            } else {
-                return FormatHelper.toString(closure.call(matcher.group(0)));
-            }
+            return getReplacement(matcher, closure);
         }
         return null;
     }
@@ -1133,7 +1124,7 @@ public class StringGroovyMethods extends DefaultGroovyMethodsSupport {
                 list.add((String) iter.next());
             }
         }
-        return new ArrayList<String>(list);
+        return new ArrayList<>(list);
     }
 
     /**
@@ -1518,22 +1509,29 @@ public class StringGroovyMethods extends DefaultGroovyMethodsSupport {
      * @param closure specified with replaceAll() to get replacement
      * @return replacement correspond replacement for a match
      */
-    private static String getReplacement(final Matcher matcher, final Closure closure) {
-        if (!hasGroup(matcher)) {
-            return FormatHelper.toString(closure.call(matcher.group()));
-        }
-
-        int count = matcher.groupCount();
-        List<String> groups = new ArrayList<>();
-        for (int i = 0; i <= count; i++) {
-            groups.add(matcher.group(i));
+    private static String getReplacement(final Matcher matcher, final Closure<?> closure) {
+        if (hasGroup(matcher)) {
+            List<String> groups = getGroups(matcher);
+            Class<?>[] paramTypes = closure.getParameterTypes();
+            if (paramTypes.length == 1 && paramTypes[0].isArray()) {
+                Class<?> elementType = paramTypes[0].getComponentType();
+                if (elementType.isAssignableFrom(String.class)) { // GROOVY-11076
+                    return FormatHelper.toString(closure.call(groups.toArray()));
+                }
+            }
+            return FormatHelper.toString(closure.call(groups));
+        } else {
+            return FormatHelper.toString(closure.call(matcher.group(0)));
         }
+    }
 
-        if (closure.getParameterTypes().length == 1
-                && closure.getParameterTypes()[0] == Object[].class) {
-            return FormatHelper.toString(closure.call(groups.toArray()));
+    private static List<String> getGroups(final Matcher matcher) {
+        final int n = matcher.groupCount() + 1;
+        List<String> list = new ArrayList<>(n);
+        for (int i = 0; i < n; i += 1) {
+            list.add(matcher.group(i));
         }
-        return FormatHelper.toString(closure.call(groups));
+        return list;
     }
 
     /**
@@ -1792,13 +1790,8 @@ public class StringGroovyMethods extends DefaultGroovyMethodsSupport {
                 found = false;
 
                 if (hasGroup(self)) {
-                    // are we using groups?
-                    // yes, so return the specified group as list
-                    List<String> list = new ArrayList<String>(self.groupCount());
-                    for (int i = 0; i <= self.groupCount(); i += 1) {
-                        list.add(self.group(i));
-                    }
-                    return list;
+                    // yes, so return the specified group list
+                    return getGroups(self);
                 } else {
                     // not using groups, so return the nth
                     // occurrence of the pattern
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 5c134ebcd2..5e988b2ca3 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -138,7 +138,6 @@ import java.util.Optional;
 import java.util.Set;
 import java.util.StringJoiner;
 import java.util.concurrent.atomic.AtomicLong;
-import java.util.function.BiConsumer;
 import java.util.function.BiPredicate;
 import java.util.function.Consumer;
 import java.util.function.Function;
@@ -3196,10 +3195,17 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
         List<ClassNode[]> closureSignatures = getSignaturesFromHint(selectedMethod, hintClass, options, expression);
         List<ClassNode[]> candidates = new LinkedList<>();
-        for (ClassNode[] signature : closureSignatures) {
+        for (ClassNode[]  signature : closureSignatures) {
             resolveGenericsFromTypeHint(receiver, arguments, selectedMethod, signature);
-            if (signature.length == closureParams.length // matching number of parameters
-                    || (closureParams.length > signature.length && last(signature).isArray())) { // vargs
+            if (closureParams.length == signature.length) {
+                candidates.add(signature);
+            }
+            if ((closureParams.length > 1 || closureParams.length == 1 && !isObjectType(closureParams[0].getOriginType()))
+                    && signature.length == 1 && isOrImplements(signature[0],LIST_TYPE)) { // ClosureMetaClass#invokeMethod
+                // list element(s) spread across the closure parameter(s)
+                ClassNode itemType = inferLoopElementType(signature[0]);
+                signature = new ClassNode[closureParams.length];
+                Arrays.fill(signature, itemType);
                 candidates.add(signature);
             }
         }
@@ -3212,13 +3218,12 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
         if (candidates.size() > 1) {
             for (Iterator<ClassNode[]> candIt = candidates.iterator(); candIt.hasNext(); ) {
-                ClassNode[] inferred = candIt.next();
-                checkClosureSignature(closureParams, inferred, (closureParam, inferredType) -> {
-                    ClassNode declaredType = closureParam.getOriginType();
-                    if (!typeCheckMethodArgumentWithGenerics(declaredType, inferredType, false)) candIt.remove();
-                }, () -> {
-                    candIt.remove();
-                });
+                ClassNode[] inferredTypes = candIt.next();
+                for (int i = 0; i < inferredTypes.length; i += 1) {
+                    ClassNode inferredType = inferredTypes[i], parameterType = closureParams[i].getOriginType();
+                    if (parameterType.getGenericsTypes() != null) parameterType = GenericsUtils.nonGeneric(parameterType);
+                    if (!typeCheckMethodArgumentWithGenerics(parameterType, inferredType, false)) { candIt.remove(); break; }
+                }
             }
             if (candidates.size() > 1 && resolverClass instanceof ClassExpression) {
                 candidates = resolveWithResolver(candidates, receiver, arguments, expression, selectedMethod, resolverClass, options);
@@ -3229,36 +3234,16 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         }
 
         if (candidates.size() == 1) {
-            ClassNode[] inferred = candidates.get(0);
-            if (hasImplicitParameter(expression) && inferred.length == 1) {
-                expression.putNodeMetaData(CLOSURE_ARGUMENTS, inferred);
+            ClassNode[] inferredTypes = candidates.get(0);
+            if (inferredTypes.length == 1 && hasImplicitParameter(expression)) {
+                expression.putNodeMetaData(CLOSURE_ARGUMENTS, inferredTypes);
             } else {
-                checkClosureSignature(closureParams, inferred, (closureParam, inferredType) -> {
-                    checkParamType(closureParam, inferredType, false, false);
-                    typeCheckingContext.controlStructureVariables.put(closureParam, inferredType);
-                }, () -> {
-                    addError("Incorrect number of parameters. Expected " + inferred.length + " but found " + closureParams.length, expression);
-                });
-            }
-        }
-    }
-
-    private static void checkClosureSignature(final Parameter[] declared, final ClassNode[] inferred, final BiConsumer<Parameter,ClassNode> consumer, final Runnable reject) {
-        for (int i = 0, j = inferred.length-1, n = declared.length; i < n; i += 1) {
-            ClassNode declaredType = declared[i].getOriginType();
-            ClassNode inferredType = inferred[Math.min(i, j)];
-            if (isDynamicTyped(inferredType)) continue;
-            if (i >= j) { // at or past end
-                if (inferredType.isArray()) {
-                    if (n > inferred.length || !declaredType.isArray() && !isObjectType(declaredType)) {
-                        inferredType = inferredType.getComponentType(); // spread array out
-                    }
-                } else if (i > j) {
-                    reject.run();
-                    continue;
+                for (int i = 0; i < inferredTypes.length; i += 1) {
+                    if (isDynamicTyped(inferredTypes[i])) continue; // GROOVY-6939
+                    checkParamType(closureParams[i], inferredTypes[i], false, false);
+                    typeCheckingContext.controlStructureVariables.put(closureParams[i], inferredTypes[i]);
                 }
             }
-            consumer.accept(declared[i], inferredType);
         }
     }
 
diff --git a/src/test/groovy/transform/stc/ClosureParamTypeInferenceSTCTest.groovy b/src/test/groovy/transform/stc/ClosureParamTypeInferenceSTCTest.groovy
index 506ae6449b..54443251dc 100644
--- a/src/test/groovy/transform/stc/ClosureParamTypeInferenceSTCTest.groovy
+++ b/src/test/groovy/transform/stc/ClosureParamTypeInferenceSTCTest.groovy
@@ -386,19 +386,6 @@ class ClosureParamTypeInferenceSTCTest extends StaticTypeCheckingTestCase {
         '''
     }
 
-    void testStringGroovyMethodsFindMethodWithVargs() {
-        assertScript '''
-            "75001 Paris".find(/(\\d{5}\\s(\\w+))/) { all, zip, city -> println all.toUpperCase() }
-        '''
-        assertScript '''
-            "75001 Paris".find(/(\\d{5}\\s(\\w+))/) { String all, String zip, String city -> println all.toUpperCase() }
-        '''
-        shouldFailWithMessages '''
-            "75001 Paris".find(/(\\d{5}\\s(\\w+))/) { String all, Date zip, String city -> println all.toUpperCase() }
-        ''',
-        'Expected type java.lang.String for closure parameter: zip'
-    }
-
     void testFromStringInSameSourceUnit() {
         assertScript '''import groovy.transform.stc.FromString
             public <T> void doSomething(T val, @ClosureParams(value=FromString, options="T") Closure cl) {
@@ -413,12 +400,6 @@ class ClosureParamTypeInferenceSTCTest extends StaticTypeCheckingTestCase {
         '''
     }
 
-    void testStringGroovyMethodsFindMethodWithList() {
-        assertScript '''
-            "75001 Paris".find(/(\\d{5}\\s(\\w+))/) { List<String> all -> println all*.toUpperCase() }
-        '''
-    }
-
     void testInferenceForDGM_countIterableOrIterator() {
         assertScript '''
             assert ['Groovy','Java'].count { it.length() > 4 } == 1
@@ -443,7 +424,7 @@ class ClosureParamTypeInferenceSTCTest extends StaticTypeCheckingTestCase {
         '''
     }
 
-    void testInferenceForDGM_countBy() {
+    void testInferenceForDGM_countByCollection() {
         assertScript '''
             assert ['Groovy','yvoorG'].countBy { it.length() } == [6:2]
         '''
@@ -747,24 +728,6 @@ class ClosureParamTypeInferenceSTCTest extends StaticTypeCheckingTestCase {
         '''
     }
 
-    void testInferenceForDGM_split() {
-        assertScript '''
-            String[] items1 = ['foo','bar','baz']
-            assert items1.split { it.startsWith('ba') } == [['bar', 'baz'], ['foo']]
-            Collection items2 = ['foo','bar','baz']
-            assert items2.split { it.startsWith('ba') } == [['bar', 'baz'], ['foo']]
-        '''
-    }
-
-    void testInferenceForDGM_sum() {
-        assertScript '''
-            String[] items1 = ['foo','bar','baz']
-            assert items1.sum { it.toUpperCase() } == 'FOOBARBAZ'
-            def items2 = ['fi','fo','fum']
-            assert items2.sum('FEE') { it.toUpperCase() } == 'FEEFIFOFUM'
-        '''
-    }
-
     void testInferenceForDGM_findOnCollection() {
         assertScript '''
             assert ['a','bbb','ccc'].find { String it -> it.length() == 3 } == 'bbb'
@@ -788,6 +751,27 @@ class ClosureParamTypeInferenceSTCTest extends StaticTypeCheckingTestCase {
             assert [a:2,b:4,c:6].find { it.key.toUpperCase()=='C' && 2*it.value==12 } instanceof Map.Entry
         '''
     }
+    void testInferenceForDGM_findOnStr() { // GROOVY-11076, GROOVY-11089
+        assertScript '''
+            "75001 Paris".find(/(\\d{5}\\s(\\w+))/) { List<String> all_zip_city -> all_zip_city*.toUpperCase() }
+        '''
+        assertScript '''
+            "75001 Paris".find(/(\\d{5}\\s(\\w+))/) { String[] all_zip_city -> all_zip_city*.toUpperCase() }
+        '''
+        assertScript '''
+            "75001 Paris".find(/(\\d{5}\\s(\\w+))/) { Object[] all_zip_city -> all_zip_city*.toString() }
+        '''
+        assertScript '''
+            "75001 Paris".find(/(\\d{5}\\s(\\w+))/) { all, zip, city -> all.size() + zip.size() + city.size() }
+        '''
+        assertScript '''
+            "75001 Paris".find(/(\\d{5}\\s(\\w+))/) { String all, String zip, String city -> city + " " + zip }
+        '''
+        shouldFailWithMessages '''
+            "75001 Paris".find(/(\\d{5}\\s(\\w+))/) { String all, Date zip, String city -> }
+        ''',
+        'Expected type java.lang.String for closure parameter: zip'
+    }
 
     void testInferenceForDGM_findAllOnCollection() {
         assertScript '''
@@ -1100,9 +1084,28 @@ class ClosureParamTypeInferenceSTCTest extends StaticTypeCheckingTestCase {
         '''
     }
 
-    void testDGM_slitOnCollection() {
+    void testDGM_splitOnCollection() {
+        assertScript '''
+            assert [1,2,3,4].split { it % 2 == 0 } == [[2,4],[1,3]]
+        '''
         assertScript '''
-            assert [[2,4],[1,3]] == [1,2,3,4].split { it % 2 == 0 }
+            Collection items = ['foo','bar','baz']
+            assert items.split { it.startsWith('ba') } == [['bar', 'baz'], ['foo']]
+        '''
+    }
+    void testDGM_splitOnArray() {
+        assertScript '''
+            String[] items = ['foo','bar','baz']
+            assert items.split { it.startsWith('ba') } == [['bar', 'baz'], ['foo']]
+        '''
+    }
+
+    void testDGM_sum() {
+        assertScript '''
+            String[] items1 = ['foo','bar','baz']
+            assert items1.sum { it.toUpperCase() } == 'FOOBARBAZ'
+            def items2 = ['fi','fo','fum']
+            assert items2.sum('FEE') { it.toUpperCase() } == 'FEEFIFOFUM'
         '''
     }
 
@@ -1278,8 +1281,16 @@ class ClosureParamTypeInferenceSTCTest extends StaticTypeCheckingTestCase {
         'Incorrect number of parameters. Expected 1 or 2 but found 0'
     }
 
-    // GROOVY-8816
+    // GROOVY-8499
     void testParamCountCheck6() {
+        shouldFailWithMessages '''
+            ['ab'.chars,'12'.chars].combinations().stream().map((x, y) -> "$x$y")
+        ''',
+        'Incorrect number of parameters. Expected 1 but found 2'
+    }
+
+    // GROOVY-8816
+    void testParamCountCheck7() {
         shouldFailWithMessages '''
             def m() {
                 [].each { -> }
@@ -1289,7 +1300,7 @@ class ClosureParamTypeInferenceSTCTest extends StaticTypeCheckingTestCase {
     }
 
     // GROOVY-9854
-    void testParamCountCheck7() {
+    void testParamCountCheck8() {
         shouldFailWithMessages '''
             switch (42) { case { -> }: break; }
         ''',
@@ -1297,17 +1308,18 @@ class ClosureParamTypeInferenceSTCTest extends StaticTypeCheckingTestCase {
     }
 
     // GROOVY-9854
-    void testParamCountCheck8() {
+    void testParamCountCheck9() {
         shouldFailWithMessages '''
             switch (42) { case { i, j -> }: break; }
         ''',
         'Incorrect number of parameters. Expected 1 but found 2'
     }
 
-    // GROOVY-8499: SAM type
-    void testParamCountCheck9() {
+    // GROOVY-11089
+    void testParamCountCheck10() {
         shouldFailWithMessages '''
-            ['ab'.chars, '12'.chars].combinations().stream().map((x, y) -> "$x$y")
+            def array = new String[]{'a','b'}
+            array.with { a,b -> }
         ''',
         'Incorrect number of parameters. Expected 1 but found 2'
     }
diff --git a/src/test/org/codehaus/groovy/runtime/StringGroovyMethodsTest.java b/src/test/org/codehaus/groovy/runtime/StringGroovyMethodsTest.java
index dd31cf339a..e1c623d69a 100644
--- a/src/test/org/codehaus/groovy/runtime/StringGroovyMethodsTest.java
+++ b/src/test/org/codehaus/groovy/runtime/StringGroovyMethodsTest.java
@@ -34,74 +34,31 @@ import static org.junit.Assert.assertTrue;
 
 public final class StringGroovyMethodsTest {
 
-    @Test
-    public void testIncrementString() throws Exception {
-        String original = "z";
-        String answer = StringGroovyMethods.next(original);
-
-        assertEquals("{", answer);
-        assertTrue(answer.compareTo(original) > 0);
-    }
-
-    @Test
-    public void testDecrementString() throws Exception {
-        String original = "a";
-        String answer = StringGroovyMethods.previous(original);
+    @SuppressWarnings("serial")
+    private Closure<String> createClosureForFindOrFindAll() {
+        return new Closure<String>(this) {
+            @SuppressWarnings("unused") // see parameterTypes
+            public Object doCall(List<String> args) {
+                return null;
+            }
 
-        assertEquals("`", answer);
-        assertTrue(ScriptBytecodeAdapter.compareLessThan(answer, original));
-    }
+            @Override
+            public String call(Object arguments) {
+                assertTrue(arguments instanceof List);
+                return ((List<?>) arguments).get(2).toString();
+            }
 
-    @Test
-    public void testToMethods() throws Exception {
-        assertEquals(Integer.valueOf(1), StringGroovyMethods.toInteger("1"));
-        assertEquals(Long.valueOf(1), StringGroovyMethods.toLong("1"));
-        assertEquals(Float.valueOf(1), StringGroovyMethods.toFloat("1"));
-        assertEquals(Double.valueOf(1), StringGroovyMethods.toDouble("1"));
-        assertEquals(new BigInteger("1"), StringGroovyMethods.toBigInteger("1"));
-        assertEquals(new BigDecimal("1"), StringGroovyMethods.toBigDecimal("1"));
-        assertEquals(Boolean.TRUE, StringGroovyMethods.toBoolean("True"));
-        assertEquals(Boolean.TRUE, StringGroovyMethods.toBoolean("Y"));
-        assertEquals(Boolean.TRUE, StringGroovyMethods.toBoolean(" y "));
-        assertEquals(Boolean.TRUE, StringGroovyMethods.toBoolean("1"));
-        assertEquals(Boolean.FALSE, StringGroovyMethods.toBoolean("false"));
-        assertEquals(Boolean.FALSE, StringGroovyMethods.toBoolean("n"));
-        assertEquals(Boolean.FALSE, StringGroovyMethods.toBoolean("0"));
+            @Override
+            public String call(Object... args) {
+                return call((Object) args);
+            }
+        };
     }
 
-    @Test
-    public void testIsMethods() throws Exception {
-        String intStr = "123";
-        String floatStr = "1.23E-1";
-        String nonNumberStr = "ONE";
-
-        assertTrue(StringGroovyMethods.isInteger(intStr));
-        assertFalse(StringGroovyMethods.isInteger(floatStr));
-        assertFalse(StringGroovyMethods.isInteger(nonNumberStr));
-        assertTrue(StringGroovyMethods.isLong(intStr));
-        assertFalse(StringGroovyMethods.isLong(floatStr));
-        assertFalse(StringGroovyMethods.isLong(nonNumberStr));
-
-        assertTrue(StringGroovyMethods.isFloat(intStr));
-        assertTrue(StringGroovyMethods.isFloat(floatStr));
-        assertFalse(StringGroovyMethods.isFloat(nonNumberStr));
-        assertTrue(StringGroovyMethods.isDouble(intStr));
-        assertTrue(StringGroovyMethods.isDouble(floatStr));
-        assertFalse(StringGroovyMethods.isDouble(nonNumberStr));
-
-        assertTrue(StringGroovyMethods.isBigInteger(intStr));
-        assertFalse(StringGroovyMethods.isBigInteger(floatStr));
-        assertFalse(StringGroovyMethods.isBigInteger(nonNumberStr));
-        assertTrue(StringGroovyMethods.isBigDecimal(intStr));
-        assertTrue(StringGroovyMethods.isBigDecimal(floatStr));
-        assertFalse(StringGroovyMethods.isBigDecimal(nonNumberStr));
-        assertTrue(StringGroovyMethods.isNumber(intStr));
-        assertTrue(StringGroovyMethods.isNumber(floatStr));
-        assertFalse(StringGroovyMethods.isNumber(nonNumberStr));
-    }
+    //
 
     @Test
-    public void testAsMethods() {
+    public void testAsBoolean() {
         Pattern pattern = Pattern.compile("[a-z]+");
         String correctInput = "abcde";
         String incorrectInput = "123";
@@ -115,9 +72,12 @@ public final class StringGroovyMethodsTest {
     }
 
     @Test
-    public void testStartsWithAny() {
-        assertTrue(StringGroovyMethods.startsWithAny("abcd", "ab", "ef"));
-        assertFalse(StringGroovyMethods.startsWithAny("abcd", "ef", "gh"));
+    public void testDecrementString() {
+        String original = "a";
+        String answer = StringGroovyMethods.previous(original);
+
+        assertEquals("`", answer);
+        assertTrue(ScriptBytecodeAdapter.compareLessThan(answer, original));
     }
 
     @Test
@@ -126,31 +86,6 @@ public final class StringGroovyMethodsTest {
         assertFalse(StringGroovyMethods.endsWithAny("abcd", "ef", "gh"));
     }
 
-    @Test
-    public void testIsBlank() {
-        assertTrue(StringGroovyMethods.isBlank(""));
-        assertTrue(StringGroovyMethods.isBlank(" "));
-        assertTrue(StringGroovyMethods.isBlank("  "));
-        assertTrue(StringGroovyMethods.isBlank("\t"));
-        assertTrue(StringGroovyMethods.isBlank("\t\t"));
-        assertTrue(StringGroovyMethods.isBlank(" \t"));
-        assertTrue(StringGroovyMethods.isBlank("\t "));
-        assertTrue(StringGroovyMethods.isBlank(" \n "));
-        assertTrue(StringGroovyMethods.isBlank("\n"));
-        assertTrue(StringGroovyMethods.isBlank("\n\n"));
-        assertTrue(StringGroovyMethods.isBlank(" \n"));
-        assertTrue(StringGroovyMethods.isBlank("\n "));
-        assertTrue(StringGroovyMethods.isBlank(" \n "));
-        assertTrue(StringGroovyMethods.isBlank(" \n \t "));
-        assertFalse(StringGroovyMethods.isBlank("abc"));
-        assertFalse(StringGroovyMethods.isBlank("abc "));
-        assertFalse(StringGroovyMethods.isBlank(" abc"));
-        assertFalse(StringGroovyMethods.isBlank(" abc "));
-        assertFalse(StringGroovyMethods.isBlank("\tabc"));
-        assertFalse(StringGroovyMethods.isBlank("abc\t"));
-        assertFalse(StringGroovyMethods.isBlank("\tabc\t"));
-    }
-
     @Test
     public void testFindAllFromCharSequenceWithClosure() {
         CharSequence charSequence = new StringBuilder().append("ABCD");
@@ -232,25 +167,98 @@ public final class StringGroovyMethodsTest {
     }
 
     @Test
-    public void testisAtLeast() {
+    public void testIncrementString() {
+        String original = "z";
+        String answer = StringGroovyMethods.next(original);
+
+        assertEquals("{", answer);
+        assertTrue(answer.compareTo(original) > 0);
+    }
+
+    @Test
+    public void testIsAtLeast() {
         assertTrue(StringGroovyMethods.isAtLeast("2.1", "2.1"));
         assertTrue(StringGroovyMethods.isAtLeast("2.1", "2.0"));
         assertTrue(StringGroovyMethods.isAtLeast("3.0", "2.1"));
         assertFalse(StringGroovyMethods.isAtLeast("2.5", "3.0"));
     }
 
-    private Closure<String> createClosureForFindOrFindAll() {
-        return new Closure<String>(this) {
-            @Override
-            public String call(Object arguments) {
-                assertTrue(arguments instanceof List);
-                return ((List) arguments).get(2).toString();
-            }
+    @Test
+    public void testIsBlank() {
+        assertTrue(StringGroovyMethods.isBlank(""));
+        assertTrue(StringGroovyMethods.isBlank(" "));
+        assertTrue(StringGroovyMethods.isBlank("  "));
+        assertTrue(StringGroovyMethods.isBlank("\t"));
+        assertTrue(StringGroovyMethods.isBlank("\t\t"));
+        assertTrue(StringGroovyMethods.isBlank(" \t"));
+        assertTrue(StringGroovyMethods.isBlank("\t "));
+        assertTrue(StringGroovyMethods.isBlank(" \n "));
+        assertTrue(StringGroovyMethods.isBlank("\n"));
+        assertTrue(StringGroovyMethods.isBlank("\n\n"));
+        assertTrue(StringGroovyMethods.isBlank(" \n"));
+        assertTrue(StringGroovyMethods.isBlank("\n "));
+        assertTrue(StringGroovyMethods.isBlank(" \n "));
+        assertTrue(StringGroovyMethods.isBlank(" \n \t "));
+        assertFalse(StringGroovyMethods.isBlank("abc"));
+        assertFalse(StringGroovyMethods.isBlank("abc "));
+        assertFalse(StringGroovyMethods.isBlank(" abc"));
+        assertFalse(StringGroovyMethods.isBlank(" abc "));
+        assertFalse(StringGroovyMethods.isBlank("\tabc"));
+        assertFalse(StringGroovyMethods.isBlank("abc\t"));
+        assertFalse(StringGroovyMethods.isBlank("\tabc\t"));
+    }
 
-            @Override
-            public String call(Object... args) {
-                return call((Object) args);
-            }
-        };
+    @Test
+    public void testIsMethods() {
+        String intStr = "123";
+        String floatStr = "1.23E-1";
+        String nonNumberStr = "ONE";
+
+        assertTrue(StringGroovyMethods.isInteger(intStr));
+        assertFalse(StringGroovyMethods.isInteger(floatStr));
+        assertFalse(StringGroovyMethods.isInteger(nonNumberStr));
+        assertTrue(StringGroovyMethods.isLong(intStr));
+        assertFalse(StringGroovyMethods.isLong(floatStr));
+        assertFalse(StringGroovyMethods.isLong(nonNumberStr));
+
+        assertTrue(StringGroovyMethods.isFloat(intStr));
+        assertTrue(StringGroovyMethods.isFloat(floatStr));
+        assertFalse(StringGroovyMethods.isFloat(nonNumberStr));
+        assertTrue(StringGroovyMethods.isDouble(intStr));
+        assertTrue(StringGroovyMethods.isDouble(floatStr));
+        assertFalse(StringGroovyMethods.isDouble(nonNumberStr));
+
+        assertTrue(StringGroovyMethods.isBigInteger(intStr));
+        assertFalse(StringGroovyMethods.isBigInteger(floatStr));
+        assertFalse(StringGroovyMethods.isBigInteger(nonNumberStr));
+        assertTrue(StringGroovyMethods.isBigDecimal(intStr));
+        assertTrue(StringGroovyMethods.isBigDecimal(floatStr));
+        assertFalse(StringGroovyMethods.isBigDecimal(nonNumberStr));
+        assertTrue(StringGroovyMethods.isNumber(intStr));
+        assertTrue(StringGroovyMethods.isNumber(floatStr));
+        assertFalse(StringGroovyMethods.isNumber(nonNumberStr));
+    }
+
+    @Test
+    public void testStartsWithAny() {
+        assertTrue(StringGroovyMethods.startsWithAny("abcd", "ab", "ef"));
+        assertFalse(StringGroovyMethods.startsWithAny("abcd", "ef", "gh"));
+    }
+
+    @Test
+    public void testToMethods() {
+        assertEquals(Integer.valueOf(1), StringGroovyMethods.toInteger("1"));
+        assertEquals(Long.valueOf(1), StringGroovyMethods.toLong("1"));
+        assertEquals(Float.valueOf(1), StringGroovyMethods.toFloat("1"));
+        assertEquals(Double.valueOf(1), StringGroovyMethods.toDouble("1"));
+        assertEquals(new BigInteger("1"), StringGroovyMethods.toBigInteger("1"));
+        assertEquals(new BigDecimal("1"), StringGroovyMethods.toBigDecimal("1"));
+        assertEquals(Boolean.TRUE, StringGroovyMethods.toBoolean("True"));
+        assertEquals(Boolean.TRUE, StringGroovyMethods.toBoolean("Y"));
+        assertEquals(Boolean.TRUE, StringGroovyMethods.toBoolean(" y "));
+        assertEquals(Boolean.TRUE, StringGroovyMethods.toBoolean("1"));
+        assertEquals(Boolean.FALSE, StringGroovyMethods.toBoolean("false"));
+        assertEquals(Boolean.FALSE, StringGroovyMethods.toBoolean("n"));
+        assertEquals(Boolean.FALSE, StringGroovyMethods.toBoolean("0"));
     }
 }
