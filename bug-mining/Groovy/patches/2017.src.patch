diff --git a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
index c65b9e39f8..41109aef3a 100644
--- a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
+++ b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
@@ -120,6 +120,7 @@ public class StaticTypesCallSiteWriter extends CallSiteWriter implements Opcodes
         if (receiver instanceof ClassExpression) {
             if (makeGetField(receiver, receiver.getType(), methodName, implicitThis, samePackages(receiver.getType().getPackageName(), classNode.getPackageName()))) return;
             if (makeGetPropertyWithGetter(receiver, receiver.getType(), methodName, safe, implicitThis)) return;
+            if (makeGetPrivateFieldWithBridgeMethod(receiver, receiver.getType(), methodName, safe, implicitThis)) return;
         }
         if (isClassReceiver) {
             // we are probably looking for a property of the class
diff --git a/src/main/org/codehaus/groovy/transform/sc/StaticCompilationVisitor.java b/src/main/org/codehaus/groovy/transform/sc/StaticCompilationVisitor.java
index ccb1c13456..cd7c100153 100644
--- a/src/main/org/codehaus/groovy/transform/sc/StaticCompilationVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/sc/StaticCompilationVisitor.java
@@ -31,7 +31,6 @@ import org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor;
 import org.codehaus.groovy.transform.stc.StaticTypesMarker;
 import org.objectweb.asm.Opcodes;
 
-import java.lang.reflect.Modifier;
 import java.util.*;
 
 import static org.codehaus.groovy.transform.sc.StaticCompilationMetadataKeys.*;
@@ -87,24 +86,28 @@ public class StaticCompilationVisitor extends StaticTypeCheckingVisitor {
         return false;
     }
 
+    private void addPrivateFieldAndMethodAccessors(ClassNode node) {
+        addPrivateBridgeMethods(node);
+        addPrivateFieldsAccessors(node);
+        Iterator<InnerClassNode> it = node.getInnerClasses();
+        while (it.hasNext()) {
+            addPrivateFieldAndMethodAccessors(it.next());
+        }
+    }
+
     @Override
     public void visitClass(final ClassNode node) {
         boolean skip = shouldSkipClassNode(node);
         ClassNode oldCN = classNode;
         classNode = node;
         Iterator<InnerClassNode> innerClasses = classNode.getInnerClasses();
-        if (innerClasses.hasNext()) {
-            addPrivateBridgeMethods(classNode);
-            addPrivateFieldsAccessors(classNode);
-        }
         while (innerClasses.hasNext()) {
             InnerClassNode innerClassNode = innerClasses.next();
             innerClassNode.putNodeMetaData(STATIC_COMPILE_NODE, !skip);
             innerClassNode.putNodeMetaData(WriterControllerFactory.class, node.getNodeMetaData(WriterControllerFactory.class));
-            addPrivateBridgeMethods(innerClassNode);
-            addPrivateFieldsAccessors(innerClassNode);
         }
         super.visitClass(node);
+        addPrivateFieldAndMethodAccessors(node);
         classNode = oldCN;
     }
 
@@ -121,6 +124,8 @@ public class StaticCompilationVisitor extends StaticTypeCheckingVisitor {
      */
     @SuppressWarnings("unchecked")
     private void addPrivateFieldsAccessors(ClassNode node) {
+        Set<ASTNode> accessedFields = (Set<ASTNode>) node.getNodeMetaData(StaticTypesMarker.PV_FIELDS_ACCESS);
+        if (accessedFields==null) return;
         Map<String, MethodNode> privateConstantAccessors = (Map<String, MethodNode>) node.getNodeMetaData(PRIVATE_FIELDS_ACCESSORS);
         if (privateConstantAccessors!=null) {
             // already added
@@ -130,7 +135,7 @@ public class StaticCompilationVisitor extends StaticTypeCheckingVisitor {
         privateConstantAccessors = new HashMap<String, MethodNode>();
         for (FieldNode fieldNode : node.getFields()) {
             int access = fieldNode.getModifiers();
-            if (Modifier.isPrivate(fieldNode.getModifiers()) && (access& Opcodes.ACC_SYNTHETIC)==0) {
+            if (accessedFields.contains(fieldNode)) {
                 acc++;
                 access = (access - Opcodes.ACC_PRIVATE + Opcodes.ACC_SYNTHETIC) + Opcodes.ACC_FINAL;
                 Expression receiver = fieldNode.isStatic()?new ClassExpression(node):new VariableExpression("this", node);
@@ -152,7 +157,10 @@ public class StaticCompilationVisitor extends StaticTypeCheckingVisitor {
      *
      * @param node an inner/outer class node for which to generate bridge methods
      */
+    @SuppressWarnings("unchecked")
     private void addPrivateBridgeMethods(final ClassNode node) {
+        Set<ASTNode> accessedMethods = (Set<ASTNode>) node.getNodeMetaData(StaticTypesMarker.PV_METHODS_ACCESS);
+        if (accessedMethods==null) return;
         List<MethodNode> methods = new ArrayList<MethodNode>(node.getMethods());
         Map<MethodNode, MethodNode> privateBridgeMethods = (Map<MethodNode, MethodNode>) node.getNodeMetaData(PRIVATE_BRIDGE_METHODS);
         if (privateBridgeMethods!=null) {
@@ -163,7 +171,7 @@ public class StaticCompilationVisitor extends StaticTypeCheckingVisitor {
         int i=-1;
         for (MethodNode method : methods) {
             int access = method.getModifiers();
-            if (method.isPrivate() && (access& Opcodes.ACC_SYNTHETIC)==0) {
+            if (accessedMethods.contains(method)) {
                 i++;
                 access = (access - Opcodes.ACC_PRIVATE + Opcodes.ACC_SYNTHETIC) + Opcodes.ACC_FINAL;
                 Expression arguments;
@@ -177,9 +185,13 @@ public class StaticCompilationVisitor extends StaticTypeCheckingVisitor {
                     arguments = new ArgumentListExpression(args);
                 }
                 Expression receiver = method.isStatic()?new ClassExpression(node):new VariableExpression("this", node);
-                ExpressionStatement returnStatement = new ExpressionStatement(new MethodCallExpression(receiver, method.getName(), arguments));
+                MethodCallExpression mce = new MethodCallExpression(receiver, method.getName(), arguments);
+
+                ExpressionStatement returnStatement = new ExpressionStatement(mce);
                 MethodNode bridge = node.addMethod("access$"+i, access, method.getReturnType(), method.getParameters(), method.getExceptions(), returnStatement);
                 privateBridgeMethods.put(method, bridge);
+                mce.setMethodTarget(method);
+                bridge.addAnnotation(new AnnotationNode(COMPILESTATIC_CLASSNODE));
             }
         }
         node.setNodeMetaData(PRIVATE_BRIDGE_METHODS, privateBridgeMethods);
diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 062953594c..17dedad865 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -37,6 +37,7 @@ import org.codehaus.groovy.transform.StaticTypesTransformation;
 import org.codehaus.groovy.util.ListHashMap;
 import org.objectweb.asm.Opcodes;
 
+import java.lang.reflect.Modifier;
 import java.util.*;
 import java.util.concurrent.atomic.AtomicReference;
 
@@ -249,6 +250,38 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         }
     }
 
+    @SuppressWarnings("unchecked")
+    private void addPrivateFieldOrMethodAccess(ClassNode cn, StaticTypesMarker type, ASTNode accessedMember) {
+        Set<ASTNode> set = (Set<ASTNode>) cn.getNodeMetaData(type);
+        if (set==null) {
+            set = new LinkedHashSet<ASTNode>();
+            cn.putNodeMetaData(type, set);
+        }
+        set.add(accessedMember);
+    }
+
+    /**
+     * Given a field node, checks if we are calling a private field from an inner class.
+     */
+    private void checkOrMarkPrivateAccess(FieldNode fn) {
+        if (fn!=null && Modifier.isPrivate(fn.getModifiers()) &&
+            (fn.getDeclaringClass() != typeCheckingContext.getEnclosingClassNode() || typeCheckingContext.getEnclosingClosure()!=null) &&
+            fn.getDeclaringClass().getModule() == typeCheckingContext.getEnclosingClassNode().getModule()) {
+            addPrivateFieldOrMethodAccess(fn.getDeclaringClass(), StaticTypesMarker.PV_FIELDS_ACCESS, fn);
+        }
+    }
+
+    /**
+     * Given a method node, checks if we are calling a private method from an inner class.
+     */
+    private void checkOrMarkPrivateAccess(MethodNode mn) {
+        if (mn!=null && Modifier.isPrivate(mn.getModifiers()) &&
+            (mn.getDeclaringClass() != typeCheckingContext.getEnclosingClassNode() || typeCheckingContext.getEnclosingClosure()!=null) &&
+            mn.getDeclaringClass().getModule() == typeCheckingContext.getEnclosingClassNode().getModule()) {
+            addPrivateFieldOrMethodAccess(mn.getDeclaringClass(), StaticTypesMarker.PV_METHODS_ACCESS, mn);
+        }
+    }
+
     @Override
     public void visitVariableExpression(VariableExpression vexp) {
         super.visitVariableExpression(vexp);
@@ -284,6 +317,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 }
                 if (node.getField(dynName) != null) {
                     storeType(vexp, node.getField(dynName).getType());
+                    checkOrMarkPrivateAccess(node.getField(dynName));
                     return;
                 }
                 Set<ClassNode> allInterfaces = node.getAllInterfaces();
@@ -838,6 +872,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                             if (visitor != null) visitor.visitField(field);
                             storeInferredTypeForPropertyExpression(pexp, field.getOriginType());
                             storeType(pexp, field.getOriginType());
+                            checkOrMarkPrivateAccess(field);
                             return true;
                         }
                     }
@@ -859,6 +894,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                             if (visitor != null) visitor.visitField(field);
                             storeInferredTypeForPropertyExpression(pexp, field.getOriginType());
                             storeType(pexp, field.getOriginType());
+                            checkOrMarkPrivateAccess(field);
                             return true;
                         }
                     }
@@ -894,6 +930,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                                 if (visitor != null) visitor.visitField(field);
                                 storeInferredTypeForPropertyExpression(pexp, field.getOriginType());
                                 storeType(pexp, field.getOriginType());
+                                checkOrMarkPrivateAccess(field);
                                 return true;
                             }
                         }
@@ -2078,6 +2115,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
     protected void storeTargetMethod(final Expression call, final MethodNode directMethodCallCandidate) {
         call.putNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET, directMethodCallCandidate);
+        checkOrMarkPrivateAccess(directMethodCallCandidate);
         extension.onMethodSelection(call, directMethodCallCandidate);
     }
 
@@ -2634,6 +2672,9 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             if (vexp == VariableExpression.THIS_EXPRESSION) return typeCheckingContext.getEnclosingClassNode();
             if (vexp == VariableExpression.SUPER_EXPRESSION) return typeCheckingContext.getEnclosingClassNode().getSuperClass();
             final Variable variable = vexp.getAccessedVariable();
+            if (variable instanceof FieldNode) {
+                checkOrMarkPrivateAccess((FieldNode) variable);
+            }
             if (variable != null && variable != vexp && variable instanceof VariableExpression) {
                 return getType((Expression) variable);
             }
diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypesMarker.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypesMarker.java
index 7d7fa60976..a3863bb9e6 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypesMarker.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypesMarker.java
@@ -29,5 +29,7 @@ public enum StaticTypesMarker {
     INITIAL_EXPRESSION, // used to store the default expression for a parameter
     DIRECT_METHOD_CALL_TARGET, // used to store the MethodNode a MethodCallExpression should target
     DELEGATION_METADATA, // used to store the delegation strategy and delegate type of a closure when declared with @DelegatesTo
-    IMPLICIT_RECEIVER // if the receiver is implicit but not "this", store the name of the receiver (delegate or owner)
+    IMPLICIT_RECEIVER, // if the receiver is implicit but not "this", store the name of the receiver (delegate or owner)
+    PV_FIELDS_ACCESS, // set of private fields that are accessed from closures or inner classes
+    PV_METHODS_ACCESS // set of private methods that are accessed from closures or inner classes
 }
diff --git a/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy b/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy
index f0945b8831..78ac30c904 100644
--- a/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy
+++ b/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy
@@ -386,6 +386,60 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
         '''
     }
 
+    void testPrivateFieldAccessInClosure() {
+        assertScript '''
+            class A {
+                private int x
+                void foo() {
+                    def cl = { x = 666 }
+                    cl()
+                }
+                void ensure() {
+                    assert x == 666
+                }
+            }
+            def a = new A()
+            a.foo()
+            a.ensure()
+        '''
+    }
+
+    void testPrivateFieldAccessInAIC() {
+        assertScript '''
+            class A {
+                private int x
+                void foo() {
+                    def aic = new Runnable() { void run() { x = 666 } }
+                    aic.run()
+                }
+                void ensure() {
+                    assert x == 666
+                }
+            }
+            def a = new A()
+            a.foo()
+            a.ensure()
+        '''
+    }
+
+    // GROOVY-5737
+    void testAccessGeneratedFieldFromClosure() {
+        assertScript '''
+            import groovy.transform.*
+            import groovy.util.logging.*
+
+            @Log
+            class GreetingActor {
+
+              def receive = {
+                log.info "test"
+              }
+
+            }
+            new GreetingActor()
+            '''
+    }
+
     public static interface InterfaceWithField {
         String boo = "I don't fancy fields in interfaces"
     }
