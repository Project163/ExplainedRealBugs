diff --git a/src/main/org/codehaus/groovy/transform/AbstractASTTransformUtil.java b/src/main/org/codehaus/groovy/transform/AbstractASTTransformUtil.java
index a317863731..343022ef53 100644
--- a/src/main/org/codehaus/groovy/transform/AbstractASTTransformUtil.java
+++ b/src/main/org/codehaus/groovy/transform/AbstractASTTransformUtil.java
@@ -24,6 +24,7 @@ import org.codehaus.groovy.ast.expr.ConstantExpression;
 import org.codehaus.groovy.ast.expr.DeclarationExpression;
 import org.codehaus.groovy.ast.expr.Expression;
 import org.codehaus.groovy.ast.expr.MethodCallExpression;
+import org.codehaus.groovy.ast.expr.NotExpression;
 import org.codehaus.groovy.ast.expr.PropertyExpression;
 import org.codehaus.groovy.ast.expr.VariableExpression;
 import org.codehaus.groovy.ast.stmt.EmptyStatement;
@@ -203,6 +204,12 @@ public abstract class AbstractASTTransformUtil implements Opcodes {
         return new BooleanExpression(new BinaryExpression(fieldExpr, COMPARE_NOT_EQUAL, otherExpr));
     }
 
+    public static BooleanExpression differentFieldExpr(FieldNode fNode, Expression other) {
+        final Expression fieldExpr = new VariableExpression(fNode);
+        final Expression otherExpr = new PropertyExpression(other, fNode.getName());
+        return differentExpr(fieldExpr, otherExpr);
+    }
+
     private static BooleanExpression notEqualsPropertyExpr(PropertyNode pNode, Expression other) {
         String getterName = "get" + Verifier.capitalize(pNode.getName());
         Expression selfGetter = new MethodCallExpression(new VariableExpression("this"), getterName, MethodCallExpression.NO_ARGUMENTS);
@@ -210,10 +217,21 @@ public abstract class AbstractASTTransformUtil implements Opcodes {
         return new BooleanExpression(new BinaryExpression(selfGetter, COMPARE_NOT_EQUAL, otherGetter));
     }
 
+    public static BooleanExpression differentPropertyExpr(PropertyNode pNode, Expression other) {
+        String getterName = "get" + Verifier.capitalize(pNode.getName());
+        Expression selfGetter = new MethodCallExpression(new VariableExpression("this"), getterName, MethodCallExpression.NO_ARGUMENTS);
+        Expression otherGetter = new MethodCallExpression(other, getterName, MethodCallExpression.NO_ARGUMENTS);
+        return differentExpr(selfGetter, otherGetter);
+    }
+
     public static BooleanExpression identicalExpr(Expression self, Expression other) {
         return new BooleanExpression(new MethodCallExpression(self, "is", new ArgumentListExpression(other)));
     }
 
+    public static BooleanExpression differentExpr(Expression self, Expression other) {
+        return new NotExpression(new BooleanExpression(new MethodCallExpression(self, "is", new ArgumentListExpression(other))));
+    }
+
     private static BooleanExpression notEqualClasses(ClassNode cNode, Expression other) {
         return new BooleanExpression(new BinaryExpression(new ClassExpression(cNode), COMPARE_NOT_EQUAL,
                 new MethodCallExpression(other, "getClass", MethodCallExpression.NO_ARGUMENTS)));
diff --git a/src/main/org/codehaus/groovy/transform/EqualsAndHashCodeASTTransformation.java b/src/main/org/codehaus/groovy/transform/EqualsAndHashCodeASTTransformation.java
index 2986e93d2f..35204698a4 100644
--- a/src/main/org/codehaus/groovy/transform/EqualsAndHashCodeASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/EqualsAndHashCodeASTTransformation.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2012 the original author or authors.
+ * Copyright 2008-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -17,7 +17,17 @@ package org.codehaus.groovy.transform;
 
 import groovy.transform.EqualsAndHashCode;
 import org.codehaus.groovy.ast.*;
-import org.codehaus.groovy.ast.expr.*;
+import org.codehaus.groovy.ast.expr.BinaryExpression;
+import org.codehaus.groovy.ast.expr.BooleanExpression;
+import org.codehaus.groovy.ast.expr.CastExpression;
+import org.codehaus.groovy.ast.expr.ConstantExpression;
+import org.codehaus.groovy.ast.expr.DeclarationExpression;
+import org.codehaus.groovy.ast.expr.Expression;
+import org.codehaus.groovy.ast.expr.MethodCallExpression;
+import org.codehaus.groovy.ast.expr.PropertyExpression;
+import org.codehaus.groovy.ast.expr.StaticMethodCallExpression;
+import org.codehaus.groovy.ast.expr.TupleExpression;
+import org.codehaus.groovy.ast.expr.VariableExpression;
 import org.codehaus.groovy.ast.stmt.BlockStatement;
 import org.codehaus.groovy.ast.stmt.EmptyStatement;
 import org.codehaus.groovy.ast.stmt.ExpressionStatement;
@@ -43,6 +53,8 @@ public class EqualsAndHashCodeASTTransformation extends AbstractASTTransformatio
     static final String MY_TYPE_NAME = "@" + MY_TYPE.getNameWithoutPackage();
     private static final ClassNode HASHUTIL_TYPE = ClassHelper.make(HashCodeHelper.class);
     private static final Token ASSIGN = Token.newSymbol(Types.ASSIGN, -1, -1);
+    private static final Token LOGICAL_OR = Token.newSymbol(Types.LOGICAL_OR, -1, -1);
+    private static final Token LOGICAL_AND = Token.newSymbol(Types.LOGICAL_AND, -1, -1);
     private static final ClassNode OBJECT_TYPE = ClassHelper.make(Object.class);
 
     public void visit(ASTNode[] nodes, SourceUnit source) {
@@ -192,7 +204,14 @@ public class EqualsAndHashCodeASTTransformation extends AbstractASTTransformatio
         List<PropertyNode> pList = getInstanceProperties(cNode);
         for (PropertyNode pNode : pList) {
             if (shouldSkip(pNode.getName(), excludes, includes)) continue;
-            body.addStatement(returnFalseIfPropertyNotEqual(pNode, otherTyped));
+            body.addStatement(
+                    new IfStatement(differentPropertyExpr(pNode, otherTyped),
+                            new IfStatement(differentSelfRecursivePropertyExpr(pNode, otherTyped),
+                                    new ReturnStatement(ConstantExpression.FALSE),
+                                    new IfStatement(bothSelfRecursivePropertyExpr(pNode, otherTyped),
+                                            EmptyStatement.INSTANCE,
+                                            returnFalseIfPropertyNotEqual(pNode, otherTyped))),
+                            EmptyStatement.INSTANCE));
         }
         List<FieldNode> fList = new ArrayList<FieldNode>();
         if (includeFields) {
@@ -200,7 +219,14 @@ public class EqualsAndHashCodeASTTransformation extends AbstractASTTransformatio
         }
         for (FieldNode fNode : fList) {
             if (shouldSkip(fNode.getName(), excludes, includes)) continue;
-            body.addStatement(returnFalseIfFieldNotEqual(fNode, otherTyped));
+            body.addStatement(
+                    new IfStatement(differentFieldExpr(fNode, otherTyped),
+                            new IfStatement(differentSelfRecursiveFieldExpr(fNode, otherTyped),
+                                    new ReturnStatement(ConstantExpression.FALSE),
+                                    new IfStatement(bothSelfRecursiveFieldExpr(fNode, otherTyped),
+                                            EmptyStatement.INSTANCE,
+                                            returnFalseIfFieldNotEqual(fNode, otherTyped))),
+                            EmptyStatement.INSTANCE));
         }
         if (callSuper) {
             body.addStatement(new IfStatement(
@@ -217,4 +243,36 @@ public class EqualsAndHashCodeASTTransformation extends AbstractASTTransformatio
         cNode.addMethod(new MethodNode(hasExistingEquals ? "_equals" : "equals", hasExistingEquals ? ACC_PRIVATE : ACC_PUBLIC,
                 ClassHelper.boolean_TYPE, params, ClassNode.EMPTY_ARRAY, body));
     }
+
+    private static BooleanExpression differentSelfRecursivePropertyExpr(PropertyNode pNode, Expression other) {
+        String getterName = "get" + Verifier.capitalize(pNode.getName());
+        Expression selfGetter = new MethodCallExpression(new VariableExpression("this"), getterName, MethodCallExpression.NO_ARGUMENTS);
+        Expression otherGetter = new MethodCallExpression(other, getterName, MethodCallExpression.NO_ARGUMENTS);
+        return new BooleanExpression(new BinaryExpression(new BinaryExpression(
+                identicalExpr(selfGetter, new VariableExpression("this")), LOGICAL_AND, differentExpr(otherGetter, other)), LOGICAL_OR, new BinaryExpression(
+                differentExpr(selfGetter, new VariableExpression("this")), LOGICAL_AND, identicalExpr(otherGetter, other))));
+    }
+
+    private static BooleanExpression bothSelfRecursivePropertyExpr(PropertyNode pNode, Expression other) {
+        String getterName = "get" + Verifier.capitalize(pNode.getName());
+        Expression selfGetter = new MethodCallExpression(new VariableExpression("this"), getterName, MethodCallExpression.NO_ARGUMENTS);
+        Expression otherGetter = new MethodCallExpression(other, getterName, MethodCallExpression.NO_ARGUMENTS);
+        return new BooleanExpression(new BinaryExpression(
+                identicalExpr(selfGetter, new VariableExpression("this")), LOGICAL_AND, identicalExpr(otherGetter, other)));
+    }
+
+    private static BooleanExpression differentSelfRecursiveFieldExpr(FieldNode fNode, Expression other) {
+        final Expression fieldExpr = new VariableExpression(fNode);
+        final Expression otherExpr = new PropertyExpression(other, fNode.getName());
+        return new BooleanExpression(new BinaryExpression(new BinaryExpression(
+                identicalExpr(fieldExpr, new VariableExpression("this")), LOGICAL_AND, differentExpr(otherExpr, other)), LOGICAL_OR, new BinaryExpression(
+                differentExpr(fieldExpr, new VariableExpression("this")), LOGICAL_AND, identicalExpr(otherExpr, other))));
+    }
+
+    private static BooleanExpression bothSelfRecursiveFieldExpr(FieldNode fNode, Expression other) {
+        final Expression fieldExpr = new VariableExpression(fNode);
+        final Expression otherExpr = new PropertyExpression(other, fNode.getName());
+        return new BooleanExpression(new BinaryExpression(
+                identicalExpr(fieldExpr, new VariableExpression("this")), LOGICAL_AND, identicalExpr(otherExpr, other)));
+    }
 }
