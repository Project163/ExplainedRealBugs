diff --git a/src/main/groovy/transform/AutoClone.java b/src/main/groovy/transform/AutoClone.java
index 88126758f4..7e1103cb1d 100644
--- a/src/main/groovy/transform/AutoClone.java
+++ b/src/main/groovy/transform/AutoClone.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2013 the original author or authors.
+ * Copyright 2008-2014 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -226,8 +226,8 @@ import java.lang.annotation.Target;
  * </ul>
  *
  * @author Paul King
- * @see groovy.transform.AutoCloneStyle
- * @see groovy.transform.AutoExternalize
+ * @see AutoCloneStyle
+ * @see ExternalizeMethods
  * @since 1.8.0
  */
 @java.lang.annotation.Documented
@@ -272,5 +272,5 @@ public @interface AutoClone {
     /**
      * Style to use when cloning.
      */
-    groovy.transform.AutoCloneStyle style() default AutoCloneStyle.CLONE;
+    AutoCloneStyle style() default AutoCloneStyle.CLONE;
 }
diff --git a/src/main/groovy/transform/AutoExternalize.groovy b/src/main/groovy/transform/AutoExternalize.groovy
new file mode 100644
index 0000000000..2bc90fb0e6
--- /dev/null
+++ b/src/main/groovy/transform/AutoExternalize.groovy
@@ -0,0 +1,64 @@
+/*
+ * Copyright 2003-2014 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package groovy.transform;
+
+/**
+ * Class annotation used to assist in the creation of {@code Externalizable} classes.
+ * The {@code @AutoExternalize} annotation instructs the compiler to execute an
+ * AST transformation which adds {@code writeExternal()} and {@code readExternal()} methods
+ * to a class and adds {@code Externalizable} to the interfaces which the class implements.
+ * The {@code writeExternal()} method writes each property (or field) for the class while the
+ * {@code readExternal()} method will read each one back in the same order. Properties or fields
+ * marked as {@code transient} are ignored.
+ * <p>
+ * Example usage:
+ * <pre>
+ * import groovy.transform.*
+ * {@code @AutoExternalize}
+ * class Person {
+ *   String first, last
+ *   List favItems
+ *   Date since
+ * }
+ * </pre>
+ * Which will create a class of the following form:
+ * <pre>
+ * class Person implements Externalizable {
+ *   ...
+ *   public void writeExternal(ObjectOutput out) throws IOException {
+ *     out.writeObject(first)
+ *     out.writeObject(last)
+ *     out.writeObject(favItems)
+ *     out.writeObject(since)
+ *   }
+ *
+ *   public void readExternal(ObjectInput oin) {
+ *     first = oin.readObject()
+ *     last = oin.readObject()
+ *     favItems = oin.readObject()
+ *     since = oin.readObject()
+ *   }
+ *   ...
+ * }
+ * </pre>
+ * <p>
+ * The {@code @AutoExternalize} transform is implemented as a combination of the {@code @ExternalizeMethods} and {@code @ExternalizeVerifier} transforms.
+ *
+ * @author Paul King
+ * @since 1.8.0
+ */
+@AnnotationCollector([ExternalizeMethods, ExternalizeVerifier])
+@interface AutoExternalize { }
diff --git a/src/main/groovy/transform/AutoExternalize.java b/src/main/groovy/transform/ExternalizeMethods.java
similarity index 75%
rename from src/main/groovy/transform/AutoExternalize.java
rename to src/main/groovy/transform/ExternalizeMethods.java
index a89495d1ab..2aeb7aad9b 100644
--- a/src/main/groovy/transform/AutoExternalize.java
+++ b/src/main/groovy/transform/ExternalizeMethods.java
@@ -1,84 +1,86 @@
-/*
- * Copyright 2008-2013 the original author or authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package groovy.transform;
-
-import org.codehaus.groovy.transform.GroovyASTTransformationClass;
-
-import java.lang.annotation.ElementType;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.lang.annotation.Target;
-
-/**
- * Class annotation used to assist in the creation of {@code Externalizable} classes.
- * The {@code @AutoExternalize} annotation instructs the compiler to execute an
- * AST transformation which adds {@code writeExternal()} and {@code readExternal()} methods
- * to a class and adds {@code Externalizable} to the interfaces which the class implements.
- * The {@code writeExternal()} method writes each property (or field) for the class while the
- * {@code readExternal()} method will read each one back in the same order. Properties or fields
- * marked as {@code transient} are ignored.
- * <p>
- * Example usage:
- * <pre>
- * import groovy.transform.*
- * {@code @AutoExternalize}
- * class Person {
- *   String first, last
- *   List favItems
- *   Date since
- * }
- * </pre>
- * Which will create a class of the following form:
- * <pre>
- * class Person implements Externalizable {
- *   ...
- *   public void writeExternal(ObjectOutput out) throws IOException {
- *     out.writeObject(first)
- *     out.writeObject(last)
- *     out.writeObject(favItems)
- *     out.writeObject(since)
- *   }
- *
- *   public void readExternal(ObjectInput oin) {
- *     first = oin.readObject()
- *     last = oin.readObject()
- *     favItems = oin.readObject()
- *     since = oin.readObject()
- *   }
- *   ...
- * }
- * </pre>
- *
- * @author Paul King
- * @since 1.8.0
- */
-@java.lang.annotation.Documented
-@Retention(RetentionPolicy.RUNTIME)
-@Target({ElementType.TYPE})
-@GroovyASTTransformationClass("org.codehaus.groovy.transform.AutoExternalizeASTTransformation")
-public @interface AutoExternalize {
-    /**
-     * Comma separated list of property names to exclude from externalizing.
-     * For convenience, a String with comma separated names
-     * can be used in addition to an array (using Groovy's literal list notation) of String values.
-     */
-    String[] excludes() default {};
-
-    /**
-     * Include fields as well as properties when externalizing.
-     */
-    boolean includeFields() default false;
-}
+/*
+ * Copyright 2008-2014 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package groovy.transform;
+
+import org.codehaus.groovy.transform.GroovyASTTransformationClass;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Class annotation used to assist in the creation of {@code Externalizable} classes.
+ * The {@code @ExternalizeMethods} annotation instructs the compiler to execute an
+ * AST transformation which adds {@code writeExternal()} and {@code readExternal()} methods
+ * to a class and adds {@code Externalizable} to the interfaces which the class implements.
+ * The {@code writeExternal()} method writes each property (and optionally field) of the class
+ * while the {@code readExternal()} method will read each one back in the same order.
+ * Properties or fields marked as {@code transient} are ignored.
+ * This annotation is typically used in conjunction with the {@code @ExternalizeMethods} annotation but
+ * most usually not directly but rather via {@code @AutoExternalizable} which is a shortcut for both annotations.
+ * <p>
+ * Example usage:
+ * <pre>
+ * import groovy.transform.*
+ * {@code @ExternalizeMethods}
+ * class Person {
+ *   String first, last
+ *   List favItems
+ *   Date since
+ * }
+ * </pre>
+ * Which will create a class of the following form:
+ * <pre>
+ * class Person implements Externalizable {
+ *   ...
+ *   public void writeExternal(ObjectOutput out) throws IOException {
+ *     out.writeObject(first)
+ *     out.writeObject(last)
+ *     out.writeObject(favItems)
+ *     out.writeObject(since)
+ *   }
+ *
+ *   public void readExternal(ObjectInput oin) {
+ *     first = oin.readObject()
+ *     last = oin.readObject()
+ *     favItems = oin.readObject()
+ *     since = oin.readObject()
+ *   }
+ *   ...
+ * }
+ * </pre>
+ *
+ * @author Paul King
+ * @since 1.8.0
+ */
+@java.lang.annotation.Documented
+@Retention(RetentionPolicy.RUNTIME)
+@Target({ElementType.TYPE})
+@GroovyASTTransformationClass("org.codehaus.groovy.transform.ExternalizeMethodsASTTransformation")
+public @interface ExternalizeMethods {
+    /**
+     * Comma separated list of property names to exclude from externalizing.
+     * For convenience, a String with comma separated names
+     * can be used in addition to an array (using Groovy's literal list notation) of String values.
+     */
+    String[] excludes() default {};
+
+    /**
+     * Include fields as well as properties when externalizing.
+     */
+    boolean includeFields() default false;
+}
diff --git a/src/main/groovy/transform/ExternalizeVerifier.java b/src/main/groovy/transform/ExternalizeVerifier.java
new file mode 100644
index 0000000000..d2984c3e7c
--- /dev/null
+++ b/src/main/groovy/transform/ExternalizeVerifier.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright 2003-2014 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package groovy.transform;
+
+import org.codehaus.groovy.transform.GroovyASTTransformationClass;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * Class annotation used to assist in the creation of {@code Externalizable} classes.
+ * The {@code @ExternalizeVerifier} annotation instructs the compiler to check
+ * that a class has {@code writeExternal()} and {@code readExternal()} methods,
+ * implements the {@code Externalizable} interface and that each property (and optionally field) is not final
+ * and, optionally for non-primitives, has a type which is either {@code Externalizable} or {@code Serializable}.
+ * Properties or fields marked as {@code transient} are ignored.
+ * This annotation is typically used in conjunction with the {@code @ExternalizeMethods} annotation but
+ * most usually not directly but rather via {@code @AutoExternalizable} which is a shortcut for both annotations.
+ */
+@java.lang.annotation.Documented
+@Retention(RetentionPolicy.SOURCE)
+@Target({ElementType.TYPE})
+@GroovyASTTransformationClass("org.codehaus.groovy.transform.ExternalizeVerifierASTTransformation")
+public @interface ExternalizeVerifier {
+    /**
+     * Comma separated list of property names to exclude from externalization verification.
+     * For convenience, a String with comma separated names
+     * can be used in addition to an array (using Groovy's literal list notation) of String values.
+     */
+    String[] excludes() default {};
+
+    /**
+     * Include fields as well as properties when verifying externalization properties.
+     */
+    boolean includeFields() default false;
+
+    /**
+     * Turns on strict type checking for property (or field) types. In strict mode, such types must also implement Serializable or Externalizable.
+     * If your properties have interface types that don't implement Serializable but all the concrete implementations do, or the
+     * type is of a non-Serializable class but the property will be null at runtime, then your instances will still be serializable
+     * but you can't turn on strict checking.
+     */
+    boolean checkPropertyTypes() default false;
+}
diff --git a/src/main/org/codehaus/groovy/transform/AutoExternalizeASTTransformation.java b/src/main/org/codehaus/groovy/transform/ExternalizeMethodsASTTransformation.java
similarity index 92%
rename from src/main/org/codehaus/groovy/transform/AutoExternalizeASTTransformation.java
rename to src/main/org/codehaus/groovy/transform/ExternalizeMethodsASTTransformation.java
index 4bf0497af7..ac4bdfb08e 100644
--- a/src/main/org/codehaus/groovy/transform/AutoExternalizeASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/ExternalizeMethodsASTTransformation.java
@@ -1,119 +1,119 @@
-/*
- * Copyright 2008-2012 the original author or authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.codehaus.groovy.transform;
-
-import groovy.transform.AutoExternalize;
-import org.codehaus.groovy.ast.ASTNode;
-import org.codehaus.groovy.ast.AnnotatedNode;
-import org.codehaus.groovy.ast.AnnotationNode;
-import org.codehaus.groovy.ast.ClassHelper;
-import org.codehaus.groovy.ast.ClassNode;
-import org.codehaus.groovy.ast.FieldNode;
-import org.codehaus.groovy.ast.Parameter;
-import org.codehaus.groovy.ast.expr.BinaryExpression;
-import org.codehaus.groovy.ast.expr.Expression;
-import org.codehaus.groovy.ast.expr.MethodCallExpression;
-import org.codehaus.groovy.ast.expr.VariableExpression;
-import org.codehaus.groovy.ast.stmt.BlockStatement;
-import org.codehaus.groovy.ast.stmt.ExpressionStatement;
-import org.codehaus.groovy.control.CompilePhase;
-import org.codehaus.groovy.control.SourceUnit;
-import org.codehaus.groovy.syntax.Token;
-import org.codehaus.groovy.syntax.Types;
-
-import java.io.Externalizable;
-import java.io.IOException;
-import java.io.ObjectInput;
-import java.io.ObjectOutput;
-import java.util.List;
-
-import static org.codehaus.groovy.transform.AbstractASTTransformUtil.getInstanceNonPropertyFields;
-import static org.codehaus.groovy.transform.AbstractASTTransformUtil.getInstancePropertyFields;
-
-/**
- * Handles generation of code for the @AutoExternalize annotation.
- *
- * @author Paul King
- */
-@GroovyASTTransformation(phase = CompilePhase.CANONICALIZATION)
-public class AutoExternalizeASTTransformation extends AbstractASTTransformation {
-    static final Class MY_CLASS = AutoExternalize.class;
-    static final ClassNode MY_TYPE = ClassHelper.make(MY_CLASS);
-    static final String MY_TYPE_NAME = "@" + MY_TYPE.getNameWithoutPackage();
-    private static final ClassNode EXTERNALIZABLE_TYPE = ClassHelper.make(Externalizable.class);
-    private static final ClassNode OBJECTOUTPUT_TYPE = ClassHelper.make(ObjectOutput.class);
-    private static final ClassNode OBJECTINPUT_TYPE = ClassHelper.make(ObjectInput.class);
-    private static final Token ASSIGN = Token.newSymbol(Types.ASSIGN, -1, -1);
-
-    public void visit(ASTNode[] nodes, SourceUnit source) {
-        init(nodes, source);
-        AnnotatedNode parent = (AnnotatedNode) nodes[1];
-        AnnotationNode anno = (AnnotationNode) nodes[0];
-        if (!MY_TYPE.equals(anno.getClassNode())) return;
-
-        if (parent instanceof ClassNode) {
-            ClassNode cNode = (ClassNode) parent;
-            checkNotInterface(cNode, MY_TYPE_NAME);
-            cNode.addInterface(EXTERNALIZABLE_TYPE);
-            boolean includeFields = memberHasValue(anno, "includeFields", true);
-            List<String> excludes = getMemberList(anno, "excludes");
-            List<FieldNode> list = getInstancePropertyFields(cNode);
-            if (includeFields) {
-                list.addAll(getInstanceNonPropertyFields(cNode));
-            }
-            createWriteExternal(cNode, excludes, list);
-            createReadExternal(cNode, excludes, list);
-        }
-    }
-
-    private void createWriteExternal(ClassNode cNode, List<String> excludes, List<FieldNode> list) {
-        final BlockStatement body = new BlockStatement();
-        VariableExpression out = new VariableExpression("out", OBJECTOUTPUT_TYPE);
-        for (FieldNode fNode : list) {
-            if (excludes.contains(fNode.getName())) continue;
-            if ((fNode.getModifiers() & ACC_TRANSIENT) != 0) continue;
-            body.addStatement(new ExpressionStatement(new MethodCallExpression(out, "write" + suffixForField(fNode), new VariableExpression(fNode))));
-        }
-        ClassNode[] exceptions = {ClassHelper.make(IOException.class)};
-        cNode.addMethod("writeExternal", ACC_PUBLIC, ClassHelper.VOID_TYPE, new Parameter[]{new Parameter(OBJECTOUTPUT_TYPE, "out")}, exceptions, body);
-    }
-
-    private void createReadExternal(ClassNode cNode, List<String> excludes, List<FieldNode> list) {
-        final BlockStatement body = new BlockStatement();
-        final Expression oin = new VariableExpression("oin", OBJECTINPUT_TYPE);
-        for (FieldNode fNode : list) {
-            if (excludes.contains(fNode.getName())) continue;
-            if ((fNode.getModifiers() & ACC_TRANSIENT) != 0) continue;
-            Expression readObject = new MethodCallExpression(oin, "read" + suffixForField(fNode), MethodCallExpression.NO_ARGUMENTS);
-            body.addStatement(new ExpressionStatement(new BinaryExpression(new VariableExpression(fNode), ASSIGN, readObject)));
-        }
-        cNode.addMethod("readExternal", ACC_PUBLIC, ClassHelper.VOID_TYPE, new Parameter[]{new Parameter(OBJECTINPUT_TYPE, "oin")}, ClassNode.EMPTY_ARRAY, body);
-    }
-
-    private String suffixForField(FieldNode fNode) {
-        // use primitives for efficiently
-        if (fNode.getType() == ClassHelper.int_TYPE) return "Int";
-        if (fNode.getType() == ClassHelper.boolean_TYPE) return "Boolean";
-//        currently char isn't found due to a bug, so go with Object
-//        if (fNode.getType() == ClassHelper.char_TYPE) return "Char";
-        if (fNode.getType() == ClassHelper.long_TYPE) return "Long";
-        if (fNode.getType() == ClassHelper.short_TYPE) return "Short";
-        if (fNode.getType() == ClassHelper.byte_TYPE) return "Byte";
-        if (fNode.getType() == ClassHelper.float_TYPE) return "Float";
-        if (fNode.getType() == ClassHelper.double_TYPE) return "Double";
-        return "Object";
-    }
-}
+/*
+ * Copyright 2008-2014 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.codehaus.groovy.transform;
+
+import groovy.transform.ExternalizeMethods;
+import org.codehaus.groovy.ast.ASTNode;
+import org.codehaus.groovy.ast.AnnotatedNode;
+import org.codehaus.groovy.ast.AnnotationNode;
+import org.codehaus.groovy.ast.ClassHelper;
+import org.codehaus.groovy.ast.ClassNode;
+import org.codehaus.groovy.ast.FieldNode;
+import org.codehaus.groovy.ast.Parameter;
+import org.codehaus.groovy.ast.expr.BinaryExpression;
+import org.codehaus.groovy.ast.expr.Expression;
+import org.codehaus.groovy.ast.expr.MethodCallExpression;
+import org.codehaus.groovy.ast.expr.VariableExpression;
+import org.codehaus.groovy.ast.stmt.BlockStatement;
+import org.codehaus.groovy.ast.stmt.ExpressionStatement;
+import org.codehaus.groovy.control.CompilePhase;
+import org.codehaus.groovy.control.SourceUnit;
+import org.codehaus.groovy.syntax.Token;
+import org.codehaus.groovy.syntax.Types;
+
+import java.io.Externalizable;
+import java.io.IOException;
+import java.io.ObjectInput;
+import java.io.ObjectOutput;
+import java.util.List;
+
+import static org.codehaus.groovy.transform.AbstractASTTransformUtil.getInstanceNonPropertyFields;
+import static org.codehaus.groovy.transform.AbstractASTTransformUtil.getInstancePropertyFields;
+
+/**
+ * Handles generation of code for the @ExternalizeMethods annotation.
+ *
+ * @author Paul King
+ */
+@GroovyASTTransformation(phase = CompilePhase.CANONICALIZATION)
+public class ExternalizeMethodsASTTransformation extends AbstractASTTransformation {
+    static final Class MY_CLASS = ExternalizeMethods.class;
+    static final ClassNode MY_TYPE = ClassHelper.make(MY_CLASS);
+    static final String MY_TYPE_NAME = "@" + MY_TYPE.getNameWithoutPackage();
+    private static final ClassNode EXTERNALIZABLE_TYPE = ClassHelper.make(Externalizable.class);
+    private static final ClassNode OBJECTOUTPUT_TYPE = ClassHelper.make(ObjectOutput.class);
+    private static final ClassNode OBJECTINPUT_TYPE = ClassHelper.make(ObjectInput.class);
+    private static final Token ASSIGN = Token.newSymbol(Types.ASSIGN, -1, -1);
+
+    public void visit(ASTNode[] nodes, SourceUnit source) {
+        init(nodes, source);
+        AnnotatedNode parent = (AnnotatedNode) nodes[1];
+        AnnotationNode anno = (AnnotationNode) nodes[0];
+        if (!MY_TYPE.equals(anno.getClassNode())) return;
+
+        if (parent instanceof ClassNode) {
+            ClassNode cNode = (ClassNode) parent;
+            checkNotInterface(cNode, MY_TYPE_NAME);
+            cNode.addInterface(EXTERNALIZABLE_TYPE);
+            boolean includeFields = memberHasValue(anno, "includeFields", true);
+            List<String> excludes = getMemberList(anno, "excludes");
+            List<FieldNode> list = getInstancePropertyFields(cNode);
+            if (includeFields) {
+                list.addAll(getInstanceNonPropertyFields(cNode));
+            }
+            createWriteExternal(cNode, excludes, list);
+            createReadExternal(cNode, excludes, list);
+        }
+    }
+
+    private void createWriteExternal(ClassNode cNode, List<String> excludes, List<FieldNode> list) {
+        final BlockStatement body = new BlockStatement();
+        VariableExpression out = new VariableExpression("out", OBJECTOUTPUT_TYPE);
+        for (FieldNode fNode : list) {
+            if (excludes.contains(fNode.getName())) continue;
+            if ((fNode.getModifiers() & ACC_TRANSIENT) != 0) continue;
+            body.addStatement(new ExpressionStatement(new MethodCallExpression(out, "write" + suffixForField(fNode), new VariableExpression(fNode))));
+        }
+        ClassNode[] exceptions = {ClassHelper.make(IOException.class)};
+        cNode.addMethod("writeExternal", ACC_PUBLIC, ClassHelper.VOID_TYPE, new Parameter[]{new Parameter(OBJECTOUTPUT_TYPE, "out")}, exceptions, body);
+    }
+
+    private void createReadExternal(ClassNode cNode, List<String> excludes, List<FieldNode> list) {
+        final BlockStatement body = new BlockStatement();
+        final Expression oin = new VariableExpression("oin", OBJECTINPUT_TYPE);
+        for (FieldNode fNode : list) {
+            if (excludes.contains(fNode.getName())) continue;
+            if ((fNode.getModifiers() & ACC_TRANSIENT) != 0) continue;
+            Expression readObject = new MethodCallExpression(oin, "read" + suffixForField(fNode), MethodCallExpression.NO_ARGUMENTS);
+            body.addStatement(new ExpressionStatement(new BinaryExpression(new VariableExpression(fNode), ASSIGN, readObject)));
+        }
+        cNode.addMethod("readExternal", ACC_PUBLIC, ClassHelper.VOID_TYPE, new Parameter[]{new Parameter(OBJECTINPUT_TYPE, "oin")}, ClassNode.EMPTY_ARRAY, body);
+    }
+
+    private String suffixForField(FieldNode fNode) {
+        // use primitives for efficiency
+        if (fNode.getType() == ClassHelper.int_TYPE) return "Int";
+        if (fNode.getType() == ClassHelper.boolean_TYPE) return "Boolean";
+//        currently char isn't found due to a bug, so go with Object
+//        if (fNode.getType() == ClassHelper.char_TYPE) return "Char";
+        if (fNode.getType() == ClassHelper.long_TYPE) return "Long";
+        if (fNode.getType() == ClassHelper.short_TYPE) return "Short";
+        if (fNode.getType() == ClassHelper.byte_TYPE) return "Byte";
+        if (fNode.getType() == ClassHelper.float_TYPE) return "Float";
+        if (fNode.getType() == ClassHelper.double_TYPE) return "Double";
+        return "Object";
+    }
+}
diff --git a/src/main/org/codehaus/groovy/transform/ExternalizeVerifierASTTransformation.java b/src/main/org/codehaus/groovy/transform/ExternalizeVerifierASTTransformation.java
new file mode 100644
index 0000000000..c6cf41f653
--- /dev/null
+++ b/src/main/org/codehaus/groovy/transform/ExternalizeVerifierASTTransformation.java
@@ -0,0 +1,104 @@
+/*
+ * Copyright 2003-2014 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.codehaus.groovy.transform;
+
+import groovy.transform.ExternalizeVerifier;
+import org.codehaus.groovy.ast.ASTNode;
+import org.codehaus.groovy.ast.AnnotatedNode;
+import org.codehaus.groovy.ast.AnnotationNode;
+import org.codehaus.groovy.ast.ClassHelper;
+import org.codehaus.groovy.ast.ClassNode;
+import org.codehaus.groovy.ast.ConstructorNode;
+import org.codehaus.groovy.ast.FieldNode;
+import org.codehaus.groovy.control.CompilePhase;
+import org.codehaus.groovy.control.SourceUnit;
+
+import java.io.Externalizable;
+import java.io.Serializable;
+import java.util.List;
+
+import static org.codehaus.groovy.ast.ClassHelper.isPrimitiveType;
+import static org.codehaus.groovy.transform.AbstractASTTransformUtil.getInstanceNonPropertyFields;
+import static org.codehaus.groovy.transform.AbstractASTTransformUtil.getInstancePropertyFields;
+
+@GroovyASTTransformation(phase = CompilePhase.CLASS_GENERATION)
+public class ExternalizeVerifierASTTransformation extends AbstractASTTransformation {
+    static final Class MY_CLASS = ExternalizeVerifier.class;
+    static final ClassNode MY_TYPE = ClassHelper.make(MY_CLASS);
+    static final String MY_TYPE_NAME = "@" + MY_TYPE.getNameWithoutPackage();
+    private static final ClassNode EXTERNALIZABLE_TYPE = ClassHelper.make(Externalizable.class);
+    private static final ClassNode SERIALIZABLE_TYPE = ClassHelper.make(Serializable.class);
+
+    public void visit(ASTNode[] nodes, SourceUnit source) {
+        init(nodes, source);
+        AnnotatedNode parent = (AnnotatedNode) nodes[1];
+        AnnotationNode anno = (AnnotationNode) nodes[0];
+        if (!MY_TYPE.equals(anno.getClassNode())) return;
+
+        if (parent instanceof ClassNode) {
+            ClassNode cNode = (ClassNode) parent;
+            if (!hasNoargConstructor(cNode)) {
+                addError(MY_TYPE_NAME + ": An Externalizable class requires a no-arg constructor but none found", cNode);
+            }
+            if (!implementsExternalizable(cNode)) {
+                addError(MY_TYPE_NAME + ": An Externalizable class must implement the Externalizable interface", cNode);
+            }
+            boolean includeFields = memberHasValue(anno, "includeFields", true);
+            boolean checkPropertyTypes = memberHasValue(anno, "checkPropertyTypes", true);
+            List<String> excludes = getMemberList(anno, "excludes");
+            List<FieldNode> list = getInstancePropertyFields(cNode);
+            if (includeFields) {
+                list.addAll(getInstanceNonPropertyFields(cNode));
+            }
+            checkProps(list, excludes, checkPropertyTypes);
+        }
+    }
+
+    private void checkProps(List<FieldNode> list, List<String> excludes, boolean checkPropertyTypes) {
+        for (FieldNode fNode : list) {
+            if (excludes.contains(fNode.getName())) continue;
+            if ((fNode.getModifiers() & ACC_TRANSIENT) != 0) continue;
+            if ((fNode.getModifiers() & ACC_FINAL) != 0) {
+                addError(MY_TYPE_NAME + ": The Externalizable property (or field) '" + fNode.getName() + "' cannot be final", fNode);
+            }
+            ClassNode propType = fNode.getType();
+            if (checkPropertyTypes && !isPrimitiveType(propType) && !implementsExternalizable(propType) && !implementsSerializable(propType)) {
+                addError(MY_TYPE_NAME + ": strict type checking is enabled and the non-primitive property (or field) '" + fNode.getName() +
+                        "' in an Externalizable class has the type '" + propType.getName() + "' which isn't Externalizable or Serializable", fNode);
+            }
+        }
+    }
+
+    private boolean implementsExternalizable(ClassNode cNode) {
+        return cNode.implementsInterface(EXTERNALIZABLE_TYPE);
+    }
+
+    private boolean implementsSerializable(ClassNode cNode) {
+        return cNode.implementsInterface(SERIALIZABLE_TYPE);
+    }
+
+    private boolean hasNoargConstructor(ClassNode cNode) {
+        List<ConstructorNode> constructors = cNode.getDeclaredConstructors();
+        for (ConstructorNode next : constructors) {
+            if (next.getParameters().length == 0) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+}
diff --git a/src/test/org/codehaus/groovy/transform/CanonicalComponentsTransformTest.groovy b/src/test/org/codehaus/groovy/transform/CanonicalComponentsTransformTest.groovy
index aa7a7e48f7..2b62b5c28f 100644
--- a/src/test/org/codehaus/groovy/transform/CanonicalComponentsTransformTest.groovy
+++ b/src/test/org/codehaus/groovy/transform/CanonicalComponentsTransformTest.groovy
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2013 the original author or authors.
+ * Copyright 2008-2014 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -19,6 +19,8 @@ import groovy.transform.AutoClone
 import groovy.transform.AutoExternalize
 import groovy.transform.EqualsAndHashCode
 import groovy.transform.TupleConstructor
+import org.codehaus.groovy.control.MultipleCompilationErrorsException
+
 import static groovy.transform.AutoCloneStyle.*
 import groovy.transform.ToString
 import groovy.transform.Canonical
@@ -309,6 +311,88 @@ class CanonicalComponentsTransformTest extends GroovyShellTestCase {
         assert !('canEqual' in p2.class.methods*.name)
     }
 
+    // GROOVY-5864
+    void testExternalizeMethodsWithImmutable() {
+        try {
+            new GroovyShell().parse """
+                @groovy.transform.ExternalizeMethods
+                @groovy.transform.Immutable
+                class Person {
+                    String first
+                }
+            """
+            fail('The compilation should have failed as the final field first (created via @Immutable) is being assigned to (via @ExternalizeMethods).')
+        } catch (MultipleCompilationErrorsException e) {
+            def syntaxError = e.errorCollector.getSyntaxError(0)
+            assert syntaxError.message.contains("cannot modify final field 'first' outside of constructor")
+        }
+    }
+
+    // GROOVY-5864
+    void testExternalizeVerifierWithNonExternalizableClass() {
+        try {
+            new GroovyShell().parse """
+                @groovy.transform.ExternalizeVerifier
+                class Person { }
+            """
+            fail("The compilation should have failed as the class doesn't implement Externalizable")
+        } catch (MultipleCompilationErrorsException e) {
+            def syntaxError = e.errorCollector.getSyntaxError(0)
+            assert syntaxError.message.contains("An Externalizable class must implement the Externalizable interface")
+        }
+    }
+
+    // GROOVY-5864
+    void testExternalizeVerifierWithFinalField() {
+        try {
+            new GroovyShell().parse """
+                @groovy.transform.ExternalizeVerifier
+                class Person implements Externalizable {
+                    final String first
+                    void writeExternal(ObjectOutput out)throws IOException{ }
+                    void readExternal(ObjectInput objectInput)throws IOException,ClassNotFoundException{ }
+                }
+            """
+            fail("The compilation should have failed as the final field first (can't be set inside readExternal).")
+        } catch (MultipleCompilationErrorsException e) {
+            def syntaxError = e.errorCollector.getSyntaxError(0)
+            assert syntaxError.message.contains("The Externalizable property (or field) 'first' cannot be final")
+        }
+    }
+
+    // GROOVY-5864
+    void testExternalizeVerifierWithNonExternalizableField() {
+        try {
+            new GroovyShell().parse """
+                class Name {}
+
+                @groovy.transform.ExternalizeVerifier(checkPropertyTypes=true)
+                class Person implements Externalizable {
+                    Name name
+                    int age
+                    void writeExternal(ObjectOutput out)throws IOException{ }
+                    void readExternal(ObjectInput objectInput)throws IOException,ClassNotFoundException{ }
+                }
+            """
+            fail("The compilation should have failed as the type of Name isn't Externalizable or Serializable.")
+        } catch (MultipleCompilationErrorsException e) {
+            def syntaxError = e.errorCollector.getSyntaxError(0)
+            assert syntaxError.message.contains("strict type checking is enabled and the non-primitive property (or field) 'name' in an Externalizable class has the type 'Name' which isn't Externalizable or Serializable")
+        }
+    }
+
+    // GROOVY-5864
+    void testAutoExternalizeHappyPath() {
+        new GroovyShell().evaluate """
+            import org.codehaus.groovy.transform.*
+            def orig = new Person7(name: new Name7('John', 'Smith'), address: new Address7(street: 'somewhere lane', town: 'my town'), age: 21, verified: true)
+            def baos = new ByteArrayOutputStream()
+            baos.withObjectOutputStream{ os -> os.writeObject(orig) }
+            def bais = new ByteArrayInputStream(baos.toByteArray())
+            bais.withObjectInputStream { is -> assert is.readObject().toString() == 'Person7(Name7(John, Smith), Address7(somewhere lane, my town), 21, true)' }
+        """
+    }
+
     // GROOVY-4570
     void testToStringForEnums() {
         assert Color.PURPLE.toString() == 'org.codehaus.groovy.transform.Color(r:255, g:0, b:255)'
@@ -368,6 +452,26 @@ class Person6 { String first, last; Date since }
 @EqualsAndHashCode
 class Customer6 extends Person6 { List<String> favItems }
 
+// GROOVY-5864
+@Canonical
+@ToString(includePackage=false)
+class Name7 implements Serializable { String first, last }
+
+// GROOVY-5864
+@AutoExternalize
+@ToString(includePackage=false)
+class Address7 { String street, town }
+
+// GROOVY-5864
+@ToString(includePackage=false)
+@AutoExternalize(checkPropertyTypes=true)
+class Person7 {
+    Name7 name
+    Address7 address
+    int age
+    Boolean verified
+}
+
 // GROOVY-4786
 @EqualsAndHashCode(excludes="y")
 @ToString(includes="x")
@@ -394,7 +498,7 @@ class IntPairNoCanEqual {
 // GROOVY-4570
 @ToString(includeNames=true)
 enum Color {
-  BLACK(0,0,0), WHITE(255,255,255), PURPLE(255,0,255)
-  int r, g, b
-  Color(int r, g, b) { this.r = r; this.g = g; this.b = b }
+    BLACK(0,0,0), WHITE(255,255,255), PURPLE(255,0,255)
+    int r, g, b
+    Color(int r, g, b) { this.r = r; this.g = g; this.b = b }
 }
