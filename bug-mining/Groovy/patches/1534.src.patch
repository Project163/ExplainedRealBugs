diff --git a/src/main/org/codehaus/groovy/tools/groovydoc/ArrayClassDocWrapper.java b/src/main/org/codehaus/groovy/tools/groovydoc/ArrayClassDocWrapper.java
new file mode 100644
index 0000000000..1baaa8662d
--- /dev/null
+++ b/src/main/org/codehaus/groovy/tools/groovydoc/ArrayClassDocWrapper.java
@@ -0,0 +1,289 @@
+/*
+ * Copyright 2003-2011 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.codehaus.groovy.tools.groovydoc;
+
+import org.codehaus.groovy.groovydoc.GroovyAnnotationRef;
+import org.codehaus.groovy.groovydoc.GroovyClassDoc;
+import org.codehaus.groovy.groovydoc.GroovyConstructorDoc;
+import org.codehaus.groovy.groovydoc.GroovyFieldDoc;
+import org.codehaus.groovy.groovydoc.GroovyMethodDoc;
+import org.codehaus.groovy.groovydoc.GroovyPackageDoc;
+import org.codehaus.groovy.groovydoc.GroovyType;
+
+public class ArrayClassDocWrapper implements GroovyClassDoc {
+
+    private final GroovyClassDoc delegate;
+
+    public ArrayClassDocWrapper(GroovyClassDoc delegate) {
+        this.delegate = delegate;
+    }
+
+    public GroovyClassDoc getDelegate() {
+        return delegate;
+    }
+
+    public GroovyConstructorDoc[] constructors() {
+        return delegate.constructors();
+    }
+
+    public GroovyConstructorDoc[] constructors(boolean filter) {
+        return delegate.constructors(filter);
+    }
+
+    public boolean definesSerializableFields() {
+        return delegate.definesSerializableFields();
+    }
+
+    public GroovyFieldDoc[] enumConstants() {
+        return delegate.enumConstants();
+    }
+
+    public GroovyFieldDoc[] fields() {
+        return delegate.fields();
+    }
+
+    public GroovyFieldDoc[] properties() {
+        return delegate.properties();
+    }
+
+    public GroovyFieldDoc[] fields(boolean filter) {
+        return delegate.fields(filter);
+    }
+
+    public GroovyClassDoc findClass(String className) {
+        return delegate.findClass(className);
+    }
+
+    public GroovyClassDoc[] importedClasses() {
+        return delegate.importedClasses();
+    }
+
+    public GroovyPackageDoc[] importedPackages() {
+        return delegate.importedPackages();
+    }
+
+    public GroovyClassDoc[] innerClasses() {
+        return delegate.innerClasses();
+    }
+
+    public GroovyClassDoc[] innerClasses(boolean filter) {
+        return delegate.innerClasses(filter);
+    }
+
+    public GroovyClassDoc[] interfaces() {
+        return delegate.interfaces();
+    }
+
+    public GroovyType[] interfaceTypes() {
+        return delegate.interfaceTypes();
+    }
+
+    public boolean isAbstract() {
+        return delegate.isAbstract();
+    }
+
+    public boolean isExternalizable() {
+        return delegate.isExternalizable();
+    }
+
+    public boolean isSerializable() {
+        return delegate.isSerializable();
+    }
+
+    public GroovyMethodDoc[] methods() {
+        return delegate.methods();
+    }
+
+    public GroovyMethodDoc[] methods(boolean filter) {
+        return delegate.methods(filter);
+    }
+
+    public GroovyFieldDoc[] serializableFields() {
+        return delegate.serializableFields();
+    }
+
+    public GroovyMethodDoc[] serializationMethods() {
+        return delegate.serializationMethods();
+    }
+
+    public boolean subclassOf(GroovyClassDoc gcd) {
+        return delegate.subclassOf(gcd);
+    }
+
+    public GroovyClassDoc superclass() {
+        return delegate.superclass();
+    }
+
+    public GroovyType superclassType() {
+        return delegate.superclassType();
+    }
+
+    public String getFullPathName() {
+        return delegate.getFullPathName();
+    }
+
+    public String getRelativeRootPath() {
+        return delegate.getRelativeRootPath();
+    }
+
+    public boolean isPrimitive() {
+        return delegate.isPrimitive();
+    }
+
+    public String qualifiedTypeName() {
+        return delegate.qualifiedTypeName();
+    }
+
+    public String simpleTypeName() {
+        return delegate.simpleTypeName();
+    }
+
+    public String typeName() {
+        return delegate.typeName();
+    }
+
+    public String toString() {
+        return delegate.toString();
+    }
+
+    public GroovyAnnotationRef[] annotations() {
+        return delegate.annotations();
+    }
+
+    public GroovyClassDoc containingClass() {
+        return delegate.containingClass();
+    }
+
+    public GroovyPackageDoc containingPackage() {
+        return delegate.containingPackage();
+    }
+
+    public boolean isFinal() {
+        return delegate.isFinal();
+    }
+
+    public boolean isPackagePrivate() {
+        return delegate.isPackagePrivate();
+    }
+
+    public boolean isPrivate() {
+        return delegate.isPrivate();
+    }
+
+    public boolean isProtected() {
+        return delegate.isProtected();
+    }
+
+    public boolean isPublic() {
+        return delegate.isPublic();
+    }
+
+    public boolean isStatic() {
+        return delegate.isStatic();
+    }
+
+    public String modifiers() {
+        return delegate.modifiers();
+    }
+
+    public int modifierSpecifier() {
+        return delegate.modifierSpecifier();
+    }
+
+    public String qualifiedName() {
+        return delegate.qualifiedName();
+    }
+
+    public String commentText() {
+        return delegate.commentText();
+    }
+
+    public String getRawCommentText() {
+        return delegate.getRawCommentText();
+    }
+
+    public boolean isAnnotationType() {
+        return delegate.isAnnotationType();
+    }
+
+    public boolean isAnnotationTypeElement() {
+        return delegate.isAnnotationTypeElement();
+    }
+
+    public boolean isClass() {
+        return delegate.isClass();
+    }
+
+    public boolean isConstructor() {
+        return delegate.isConstructor();
+    }
+
+    public boolean isDeprecated() {
+        return delegate.isDeprecated();
+    }
+
+    public boolean isEnum() {
+        return delegate.isEnum();
+    }
+
+    public boolean isEnumConstant() {
+        return delegate.isEnumConstant();
+    }
+
+    public boolean isError() {
+        return delegate.isError();
+    }
+
+    public boolean isException() {
+        return delegate.isException();
+    }
+
+    public boolean isField() {
+        return delegate.isField();
+    }
+
+    public boolean isIncluded() {
+        return delegate.isIncluded();
+    }
+
+    public boolean isInterface() {
+        return delegate.isInterface();
+    }
+
+    public boolean isMethod() {
+        return delegate.isMethod();
+    }
+
+    public boolean isOrdinaryClass() {
+        return delegate.isOrdinaryClass();
+    }
+
+    public String name() {
+        return delegate.name();
+    }
+
+    public void setRawCommentText(String arg0) {
+        delegate.setRawCommentText(arg0);
+    }
+
+    public String firstSentenceCommentText() {
+        return delegate.firstSentenceCommentText();
+    }
+
+    public int compareTo(Object o) {
+        return delegate.compareTo(o);
+    }
+}
diff --git a/src/main/org/codehaus/groovy/tools/groovydoc/SimpleGroovyClassDoc.java b/src/main/org/codehaus/groovy/tools/groovydoc/SimpleGroovyClassDoc.java
index 05bb769afc..a69da8098c 100644
--- a/src/main/org/codehaus/groovy/tools/groovydoc/SimpleGroovyClassDoc.java
+++ b/src/main/org/codehaus/groovy/tools/groovydoc/SimpleGroovyClassDoc.java
@@ -26,7 +26,7 @@ public class SimpleGroovyClassDoc extends SimpleGroovyAbstractableElementDoc imp
     public static final Pattern TAG_REGEX = Pattern.compile("(?sm)\\s*@([a-zA-Z.]+)\\s+(.*?)(?=\\s+@)");
     public static final Pattern LINK_REGEX = Pattern.compile("(?m)[{]@(link)\\s+([^}]*)}");
     public static final Pattern CODE_REGEX = Pattern.compile("(?m)[{]@(code)\\s+([^}]*)}");
-    public static final Pattern REF_LABEL_REGEX = Pattern.compile("([\\w.#]*(\\(.*\\))?)(\\s(.*))?");
+    public static final Pattern REF_LABEL_REGEX = Pattern.compile("([\\w.#\\$]*(\\(.*\\))?)(\\s(.*))?");
     public static final Pattern NAME_ARGS_REGEX = Pattern.compile("([^(]+)\\(([^)]*)\\)");
     public static final Pattern SPLIT_ARGS_REGEX = Pattern.compile(",\\s*");
     private static final List<String> PRIMITIVES = Arrays.asList("void", "boolean", "byte", "short", "char", "int", "long", "float", "double");
@@ -413,7 +413,7 @@ public class SimpleGroovyClassDoc extends SimpleGroovyAbstractableElementDoc imp
         final String[] target = type.split("#");
         String shortClassName = target[0].replaceAll(".*\\.", "");
         shortClassName += (target.length > 1 ? "#" + target[1].split("\\(")[0] : "");
-        String name = (full ? target[0] : shortClassName).replaceAll("#", ".");
+        String name = (full ? target[0] : shortClassName).replaceAll("#", ".").replace('$', '.');
 
         // last chance lookup for classes within the current codebase
         if (rootDoc != null) {
@@ -440,12 +440,20 @@ public class SimpleGroovyClassDoc extends SimpleGroovyAbstractableElementDoc imp
         if (!relativeRoot.endsWith("/")) {
             relativeRoot += "/";
         }
-        String url = relativeRoot + target[0].replace('.', '/') + ".html" + (target.length > 1 ? "#" + target[1] : "");
+        String url = relativeRoot + target[0].replace('.', '/').replace('$', '.') + ".html" + (target.length > 1 ? "#" + target[1] : "");
         return "<a href='" + url + "' title='" + shortClassName + "'>" + shortClassName + "</a>";
     }
 
     private GroovyClassDoc resolveClass(GroovyRootDoc rootDoc, String name) {
         if (isPrimitiveType(name)) return null;
+        if (name.endsWith("[]")) {
+            GroovyClassDoc componentClass = resolveClass(rootDoc, name.substring(0, name.length() - 2));
+            if (componentClass != null) return new ArrayClassDocWrapper(componentClass);
+            return null;
+        }
+        if (name.equals("T") || name.equals("U") || name.equals("K") || name.equals("V") || name.equals("G")) {
+            name = "java/lang/Object";
+        }
         GroovyClassDoc doc = ((SimpleGroovyRootDoc)rootDoc).classNamedExact(name);
         if (doc != null) return doc;
         int slashIndex = name.lastIndexOf("/");
@@ -469,16 +477,48 @@ public class SimpleGroovyClassDoc extends SimpleGroovyAbstractableElementDoc imp
         } else {
             c = resolveExternalClassFromImport(name);
         }
+        if (c == null) {
+            c = resolveFromJavaLang(name);
+        }
         if (c != null) {
             return new ExternalGroovyClassDoc(c);
         }
 
+        if (name.contains("/")) {
+            // search for nested class
+            if (slashIndex > 0) {
+                String outerName = name.substring(0, slashIndex);
+                GroovyClassDoc gcd = resolveClass(rootDoc, outerName);
+                if (gcd instanceof ExternalGroovyClassDoc) {
+                    ExternalGroovyClassDoc egcd = (ExternalGroovyClassDoc) gcd;
+                    String innerName = name.substring(slashIndex+1);
+                    Class outerClass = egcd.externalClass();
+                    for (Class inner : outerClass.getDeclaredClasses()) {
+                        if (inner.getName().equals(outerClass.getName() + "$" + innerName)) {
+                            return new ExternalGroovyClassDoc(inner);
+                        }
+                    }
+                }
+            }
+        }
+
         // and we can't find it
         SimpleGroovyClassDoc placeholder = new SimpleGroovyClassDoc(null, shortname);
         placeholder.setFullPathName(name);
         return placeholder;
     }
 
+    private Class resolveFromJavaLang(String name) {
+        try {
+            return Class.forName("java.lang." + name);
+        } catch (NoClassDefFoundError e) {
+            // ignore
+        } catch (ClassNotFoundException e) {
+            // ignore
+        }
+        return null;
+    }
+
     private static boolean isPrimitiveType(String name) {
         String type = name;
         if (name.endsWith("[]")) type = name.substring(0, name.length() - 2);
diff --git a/src/main/org/codehaus/groovy/tools/groovydoc/SimpleGroovyClassDocAssembler.java b/src/main/org/codehaus/groovy/tools/groovydoc/SimpleGroovyClassDocAssembler.java
index 644aec0df9..df00c3f040 100644
--- a/src/main/org/codehaus/groovy/tools/groovydoc/SimpleGroovyClassDocAssembler.java
+++ b/src/main/org/codehaus/groovy/tools/groovydoc/SimpleGroovyClassDocAssembler.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2010 the original author or authors.
+ * Copyright 2003-2011 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -23,6 +23,7 @@ import org.codehaus.groovy.antlr.parser.GroovyTokenTypes;
 import org.codehaus.groovy.antlr.treewalker.VisitorAdapter;
 import org.codehaus.groovy.control.ResolveVisitor;
 import org.codehaus.groovy.groovydoc.*;
+import org.codehaus.groovy.runtime.DefaultGroovyMethods;
 
 import java.util.*;
 import java.util.regex.Matcher;
@@ -609,49 +610,50 @@ public class SimpleGroovyClassDocAssembler extends VisitorAdapter implements Gro
     }
 
     private String getAsText(GroovySourceAST typeNode, String defaultText) {
-        String returnValue = defaultText;
-        GroovySourceAST child = (GroovySourceAST) typeNode.getFirstChild(); // assume type has only one child // todo type of "foo.bar.Wibble"
-        switch (child.getType()) {
+        GroovySourceAST child = (GroovySourceAST) typeNode.getFirstChild();
+        return getAsTextCurrent(child, defaultText);
+    }
+
+    private String getAsTextCurrent(GroovySourceAST node, String defaultText) {
+        switch (node.getType()) {
             // literals
             case LITERAL_boolean:
-                returnValue = "boolean";
-                break;
+                return "boolean";
             case LITERAL_byte:
-                returnValue = "byte";
-                break;
+                return "byte";
             case LITERAL_char:
-                returnValue = "char";
-                break;
+                return "char";
             // note: LITERAL_def never created
             case LITERAL_double:
-                returnValue = "double";
-                break;
+                return "double";
             case LITERAL_float:
-                returnValue = "float";
-                break;
+                return "float";
             case LITERAL_int:
-                returnValue = "int";
-                break;
+                return "int";
             case LITERAL_long:
-                returnValue = "long";
-                break;
+                return "long";
             case LITERAL_short:
-                returnValue = "short";
-                break;
+                return "short";
             case LITERAL_void:
-                returnValue = "void";
-                break;
+                return "void";
             case ARRAY_DECLARATOR:
-                String componentType = getAsText(child, defaultText);
-                if (!componentType.equals("def")) returnValue = componentType + "[]";
-                break;
-
+                String componentType = getAsText(node, defaultText);
+                if (!componentType.equals("def")) return componentType + "[]";
+                return "java/lang/Object[]";
             // identifiers
             case IDENT:
-                returnValue = child.getText();
-                break;
+                return node.getText();
+            case DOT:
+                List<String> result = new ArrayList<String>();
+                GroovySourceAST child = (GroovySourceAST) node.getFirstChild();
+                while (child != null) {
+                    if (child.getType() == IDENT) { result.add(child.getText()); }
+                    else if (child.getType() == DOT) { result.add(getAsTextCurrent(child, defaultText)); }
+                    child = (GroovySourceAST) child.getNextSibling();
+                }
+                return DefaultGroovyMethods.join(result, "/");
         }
-        return returnValue;
+        return defaultText;
     }
 
     private void addParametersTo(GroovySourceAST t, SimpleGroovyExecutableMemberDoc executableMemberDoc) {
@@ -663,6 +665,7 @@ public class SimpleGroovyClassDocAssembler extends VisitorAdapter implements Gro
                 String parameterTypeName = getTypeOrDefault(currentNode);
                 String parameterName = getText(currentNode.childOfType(IDENT));
                 SimpleGroovyParameter parameter = new SimpleGroovyParameter(parameterName);
+                parameter.setVararg(currentNode.getType() == VARIABLE_PARAMETER_DEF);
                 parameter.setTypeName(parameterTypeName);
                 GroovySourceAST modifiers = currentNode.childOfType(MODIFIERS);
                 if (modifiers != null) {
diff --git a/src/main/org/codehaus/groovy/tools/groovydoc/SimpleGroovyParameter.java b/src/main/org/codehaus/groovy/tools/groovydoc/SimpleGroovyParameter.java
index e51fc54e0d..3c0eefe303 100644
--- a/src/main/org/codehaus/groovy/tools/groovydoc/SimpleGroovyParameter.java
+++ b/src/main/org/codehaus/groovy/tools/groovydoc/SimpleGroovyParameter.java
@@ -25,6 +25,7 @@ public class SimpleGroovyParameter implements GroovyParameter {
     private String typeName;
     private String defaultValue;
     private GroovyType type;
+    private boolean vararg;
     private final List<GroovyAnnotationRef> annotationRefs;
 
     public SimpleGroovyParameter(String name) {
@@ -75,4 +76,12 @@ public class SimpleGroovyParameter implements GroovyParameter {
     public boolean isTypeAvailable() {
         return !(type == null);
     }
+
+    public boolean vararg() {
+        return vararg;
+    }
+
+    public void setVararg(boolean vararg) {
+        this.vararg = vararg;
+    }
 }
diff --git a/src/main/org/codehaus/groovy/tools/groovydoc/gstringTemplates/classLevel/classDocName.html b/src/main/org/codehaus/groovy/tools/groovydoc/gstringTemplates/classLevel/classDocName.html
index 7eb9bba0b2..818c7acc89 100644
--- a/src/main/org/codehaus/groovy/tools/groovydoc/gstringTemplates/classLevel/classDocName.html
+++ b/src/main/org/codehaus/groovy/tools/groovydoc/gstringTemplates/classLevel/classDocName.html
@@ -19,14 +19,19 @@
     boolean fieldSummaryShown = hasFields
     boolean hasEnumConstants = classDoc.enumConstants().findAll(isVisible)
     def dolink = { t, boolean b ->
+        boolean isArray = false
         if (!t || t instanceof String) {
             return classDoc.getDocUrl(t, b)
         }
+        if (t instanceof org.codehaus.groovy.tools.groovydoc.ArrayClassDocWrapper) {
+            t = t.delegate
+            isArray = true
+        }
         if (t instanceof org.codehaus.groovy.tools.groovydoc.SimpleGroovyClassDoc) {
             if (t.fullPathName == 'def') return classDoc.getDocUrl("java.lang.Object def", b)
-            return "<a href='" + classDoc.relativeRootPath + t.fullPathName + ".html'>" + (b ? t.qualifiedTypeName() : t.name()) + "</a>"
+            return "<a href='" + classDoc.relativeRootPath + t.fullPathName + ".html'>" + (b ? t.qualifiedTypeName() : t.name()) + "</a>" + (isArray ? "[]" : "")
         }
-        return classDoc.getDocUrl(t.qualifiedTypeName(), b)
+        return classDoc.getDocUrl(t.qualifiedTypeName(), b) + (isArray ? "[]" : "")
     }
     def linkfull = { t -> dolink(t, true) }
     def linkable = { t -> dolink(t, false) }
@@ -51,7 +56,7 @@
     ]
     def isRequired = { f, v -> def req = f.constantValueExpression() == null; req.toString() == v }
     def upcase = { n -> n[0].toUpperCase() + n[1..-1] }
-    def paramsOf = { n, boolean brief -> n.parameters().collect{ param -> (brief?'':annotations(param, ' ')) + linkable(param.isTypeAvailable()?param.type():param.typeName()) + ' ' + param.name() + (param.defaultValue() ? " = " + param.defaultValue():"") }.join(", ") }
+    def paramsOf = { n, boolean brief -> n.parameters().collect{ param -> (brief?'':annotations(param, ' ')) + linkable(param.isTypeAvailable()?param.type():param.typeName()) + (param.vararg()?'... ':' ') + param.name() + (param.defaultValue() ? " = " + param.defaultValue():"") }.join(", ") }
     def nameFromParams = { n -> n.name() + '(' + n.parameters().collect{ param -> param.isTypeAvailable()?param.type().qualifiedTypeName():param.typeName() }.join(', ') + ')' }
     def nameFromJavaParams = { n -> n.name + '(' + n.parameterTypes.collect{ param -> param.name }.join(', ') + ')' }
 %>
