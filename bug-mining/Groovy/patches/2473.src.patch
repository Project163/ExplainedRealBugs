diff --git a/src/main/org/codehaus/groovy/transform/sc/transformers/ListExpressionTransformer.java b/src/main/org/codehaus/groovy/transform/sc/transformers/ListExpressionTransformer.java
new file mode 100644
index 0000000000..47ba469eed
--- /dev/null
+++ b/src/main/org/codehaus/groovy/transform/sc/transformers/ListExpressionTransformer.java
@@ -0,0 +1,78 @@
+/*
+ * Copyright 2003-2014 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.codehaus.groovy.transform.sc.transformers;
+
+import org.codehaus.groovy.ast.ConstructorNode;
+import org.codehaus.groovy.ast.MethodNode;
+import org.codehaus.groovy.ast.expr.ArgumentListExpression;
+import org.codehaus.groovy.ast.expr.ArrayExpression;
+import org.codehaus.groovy.ast.expr.ConstructorCallExpression;
+import org.codehaus.groovy.ast.expr.Expression;
+import org.codehaus.groovy.ast.expr.ListExpression;
+import org.codehaus.groovy.transform.stc.StaticTypesMarker;
+
+import java.util.LinkedList;
+import java.util.List;
+
+import static org.codehaus.groovy.transform.stc.StaticTypesMarker.DIRECT_METHOD_CALL_TARGET;
+
+public class ListExpressionTransformer {
+    private final StaticCompilationTransformer transformer;
+
+    public ListExpressionTransformer(StaticCompilationTransformer staticCompilationTransformer) {
+        transformer = staticCompilationTransformer;
+    }
+
+    Expression transformListExpression(final ListExpression expr) {
+        MethodNode target = expr.getNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET);
+        if (target!=null && target instanceof ConstructorNode) {
+            if (target.getDeclaringClass().isArray()) {
+                return transformArrayConstructor(expr, target);
+            }
+            return transformRegularConstructor(expr, target);
+
+        } else {
+            return transformer.superTransform(expr);
+        }
+    }
+
+    private Expression transformArrayConstructor(final ListExpression expr, final MethodNode target) {
+        ArrayExpression aex = new ArrayExpression(target.getDeclaringClass().getComponentType(), transformArguments(expr));
+        aex.setSourcePosition(expr);
+        return aex;
+    }
+
+    private Expression transformRegularConstructor(final ListExpression expr, final MethodNode target) {
+        // can be replaced with a direct constructor call
+        List<Expression> transformedArgs = transformArguments(expr);
+        ConstructorCallExpression cce = new ConstructorCallExpression(
+                target.getDeclaringClass(),
+                new ArgumentListExpression(transformedArgs)
+        );
+        cce.setSourcePosition(expr);
+        cce.putNodeMetaData(DIRECT_METHOD_CALL_TARGET, target);
+        return cce;
+    }
+
+    private List<Expression> transformArguments(final ListExpression expr) {
+        List<Expression> expressions = expr.getExpressions();
+        List<Expression> transformedArgs = new LinkedList<Expression>();
+        for (Expression expression : expressions) {
+            transformedArgs.add(transformer.transform(expression));
+        }
+        return transformedArgs;
+    }
+}
diff --git a/src/main/org/codehaus/groovy/transform/sc/transformers/StaticCompilationTransformer.java b/src/main/org/codehaus/groovy/transform/sc/transformers/StaticCompilationTransformer.java
index 58a0c1fffa..210cea24b1 100644
--- a/src/main/org/codehaus/groovy/transform/sc/transformers/StaticCompilationTransformer.java
+++ b/src/main/org/codehaus/groovy/transform/sc/transformers/StaticCompilationTransformer.java
@@ -61,6 +61,7 @@ public class StaticCompilationTransformer extends ClassCodeExpressionTransformer
     private final BooleanExpressionTransformer booleanExpressionTransformer = new BooleanExpressionTransformer(this);
     private final VariableExpressionTransformer variableExpressionTransformer = new VariableExpressionTransformer();
     private final RangeExpressionTransformer rangeExpressionTransformer = new RangeExpressionTransformer(this);
+    private final ListExpressionTransformer listExpressionTransformer = new ListExpressionTransformer(this);
 
     public StaticCompilationTransformer(final SourceUnit unit) {
         this.unit = unit;
@@ -110,6 +111,9 @@ public class StaticCompilationTransformer extends ClassCodeExpressionTransformer
         if (expr instanceof RangeExpression) {
             return rangeExpressionTransformer.transformRangeExpression(((RangeExpression)expr));
         }
+        if (expr instanceof ListExpression) {
+            return listExpressionTransformer.transformListExpression((ListExpression) expr);
+        }
         return super.transform(expr);
     }
 
diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 82ef6ff1e4..d2f10ab5a0 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -731,7 +731,10 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         if (rightExpression instanceof ListExpression && !implementsInterfaceOrIsSubclassOf(LIST_TYPE, leftRedirect)) {
             ArgumentListExpression argList = new ArgumentListExpression(((ListExpression) rightExpression).getExpressions());
             ClassNode[] args = getArgumentTypes(argList);
-            checkGroovyStyleConstructor(leftRedirect, args);
+            MethodNode methodNode = checkGroovyStyleConstructor(leftRedirect, args, assignmentExpression);
+            if (methodNode!=null) {
+                rightExpression.putNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET, methodNode);
+            }
         } else if (!implementsInterfaceOrIsSubclassOf(inferredRightExpressionType, leftRedirect)
                 && implementsInterfaceOrIsSubclassOf(inferredRightExpressionType, LIST_TYPE)
                 && !isWildcardLeftHandSide(leftExpressionType)) {
@@ -749,7 +752,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             if (!(leftExpression instanceof VariableExpression) || !((VariableExpression) leftExpression).isDynamicTyped()) {
                 ArgumentListExpression argList = new ArgumentListExpression(rightExpression);
                 ClassNode[] args = getArgumentTypes(argList);
-                checkGroovyStyleConstructor(leftRedirect, args);
+                checkGroovyStyleConstructor(leftRedirect, args, rightExpression);
                 // perform additional type checking on arguments
                 MapExpression mapExpression = (MapExpression) rightExpression;
                 checkGroovyConstructorMap(leftExpression, leftRedirect, mapExpression);
@@ -858,18 +861,37 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
      *
      * @param node      the class node for which we will try to find a matching constructor
      * @param arguments the constructor arguments
+     * @deprecated use {@link #checkGroovyStyleConstructor(org.codehaus.groovy.ast.ClassNode, org.codehaus.groovy.ast.ClassNode[], org.codehaus.groovy.ast.ASTNode)} )}
      */
+    @Deprecated
     protected void checkGroovyStyleConstructor(final ClassNode node, final ClassNode[] arguments) {
+        checkGroovyStyleConstructor(node, arguments, typeCheckingContext.getEnclosingClassNode());
+    }
+
+    /**
+     * Checks that a constructor style expression is valid regarding the number of arguments and the argument types.
+     *
+     * @param node      the class node for which we will try to find a matching constructor
+     * @param arguments the constructor arguments
+     */
+    protected MethodNode checkGroovyStyleConstructor(final ClassNode node, final ClassNode[] arguments, final ASTNode source) {
         if (node.equals(ClassHelper.OBJECT_TYPE) || node.equals(ClassHelper.DYNAMIC_TYPE)) {
             // in that case, we are facing a list constructor assigned to a def or object
-            return;
+            return null;
         }
         List<ConstructorNode> constructors = node.getDeclaredConstructors();
-        if (constructors.isEmpty() && arguments.length == 0) return;
+        if (constructors.isEmpty() && arguments.length == 0) {
+            return null;
+        }
         List<MethodNode> constructorList = findMethod(node, "<init>", arguments);
         if (constructorList.isEmpty()) {
-            addStaticTypeError("No matching constructor found: " + node + toMethodParametersString("<init>", arguments), typeCheckingContext.getEnclosingClassNode());
+            addStaticTypeError("No matching constructor found: " + node + toMethodParametersString("<init>", arguments), source);
+            return null;
+        } else if (constructorList.size()>1) {
+            addStaticTypeError("Ambiguous constructor call " + node + toMethodParametersString("<init>", arguments), source);
+            return null;
         }
+        return constructorList.get(0);
     }
 
     /**
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/StaticCompilationTest.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/StaticCompilationTest.groovy
index 7b562e8a84..b3934657a7 100644
--- a/src/test/org/codehaus/groovy/classgen/asm/sc/StaticCompilationTest.groovy
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/StaticCompilationTest.groovy
@@ -284,4 +284,55 @@ class StaticCompilationTest extends AbstractBytecodeTestCase {
                 "INVOKEVIRTUAL java/lang/String.toUpperCase ()Ljava/lang/String;"
         ])
     }
+
+    void testShouldGenerateDirectConstructorCall() {
+        assert compile([method:'m'],'''
+        @groovy.transform.CompileStatic
+        class Foo {
+            String msg
+            Foo(int x, String y) { msg = y*x }
+            static Foo foo() {
+                Foo result = [2,'Bar']
+            }
+        }
+        ''').hasStrictSequence([
+                'ICONST_2',
+                'LDC "Bar"',
+                'INVOKESPECIAL Foo.<init> (ILjava/lang/String;)V'
+        ])
+    }
+
+    void testShouldGenerateDirectArrayConstruct() {
+        assert compile([method:'m'],'''
+        @groovy.transform.CompileStatic
+        void m() {
+            int[] arr = [123,456]
+        }
+        ''').hasStrictSequence([
+                'ICONST_2',
+                'NEWARRAY T_INT',
+                'DUP',
+                'ICONST_0',
+                'BIPUSH 123',
+                'IASTORE'
+        ])
+    }
+
+    void testShouldGenerateDirectBooleanArrayConstruct() {
+        assert compile([method:'m'],'''
+        @groovy.transform.CompileStatic
+        void m() {
+            boolean[] arr = [123,false]
+        }
+        ''').hasStrictSequence([
+                'ICONST_2',
+                'NEWARRAY T_BOOLEAN',
+                'DUP',
+                'ICONST_0',
+                'BIPUSH 123',
+                'INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;',
+                'INVOKESTATIC org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformation.booleanUnbox (Ljava/lang/Object;)Z',
+                'BASTORE'
+        ])
+    }
 }
