diff --git a/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java b/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
index d9bc27d6de..89caf082a0 100644
--- a/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
+++ b/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
@@ -2254,7 +2254,10 @@ public class AsmClassGenerator extends ClassGenerator {
         boolean isThisExpression = isThisExpression(call.getObjectExpression());
 
         // are we a local variable?
-        if (methodName != null && isThisExpression && isFieldOrVariable(methodName) && !classNode.hasPossibleMethod(methodName, arguments)) {
+        // it should not be an explicitly "this" qualified method call inside a closure
+        if (methodName != null && isThisExpression && isFieldOrVariable(methodName) 
+        		&& !classNode.hasPossibleMethod(methodName, arguments)
+        		&& isNotExplicitThisInClosure(call.isImplicitThis())) {
             // let's invoke the closure method
             visitVariableExpression(new VariableExpression(methodName));
             if (arguments instanceof TupleExpression) {
@@ -4238,6 +4241,10 @@ public class AsmClassGenerator extends ClassGenerator {
         return classNode.getOuterClass() != null
                 && classNode.getSuperClass() == ClassHelper.CLOSURE_TYPE;
     }
+    
+    protected boolean isNotExplicitThisInClosure(boolean implicitThis) {
+    	return implicitThis || !isInClosure();
+    }
 
     protected boolean isStaticMethod() {
       return methodNode != null && methodNode.isStatic();
diff --git a/src/test/groovy/bugs/Groovy3156And2621Bug.groovy b/src/test/groovy/bugs/Groovy3156And2621Bug.groovy
new file mode 100644
index 0000000000..3abe3d178f
--- /dev/null
+++ b/src/test/groovy/bugs/Groovy3156And2621Bug.groovy
@@ -0,0 +1,38 @@
+package groovy.bugs
+
+class Groovy3156And2621Bug extends GroovyTestCase {
+    void testMethodNameResolutionInANestedClosure() {
+        assert m() == 'method'
+        assert c1() == 'method'
+    }
+
+    void testSimilarNamesForMethodAndLocalWithLocalAsMethodArgument() {
+        failingExecute()
+    }
+
+    def m = { return 'method' }
+    def c1 = {
+        def m = { return 'c1' }
+        def c2 = {
+            /*
+            *  If both 'm()' and 'this.m()' are used as follows,
+            *  'this.m()' should not resolve to c1 closure's 'm' local variable.
+            *  It should resolve to outermost class' m().
+            */
+            assert m() == 'c1'
+            return this.m()
+        }
+        return c2()
+    }
+
+    void convention(String arg) {
+        println 'called'
+    }
+    
+    void failingExecute() {
+        def convention= 'value'
+        1.times {
+            this.convention(convention)
+        }
+    }
+}
