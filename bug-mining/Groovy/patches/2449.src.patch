diff --git a/src/main/org/codehaus/groovy/classgen/asm/InvocationWriter.java b/src/main/org/codehaus/groovy/classgen/asm/InvocationWriter.java
index 5076f9a4b3..5daabbcae2 100644
--- a/src/main/org/codehaus/groovy/classgen/asm/InvocationWriter.java
+++ b/src/main/org/codehaus/groovy/classgen/asm/InvocationWriter.java
@@ -418,8 +418,7 @@ public class InvocationWriter {
         // it should not be an explicitly "this" qualified method call
         // and the current class should have a possible method
 
-        // GROOVY-6522
-        ClassNode classNode = controller.isInClosure() ? controller.getOutermostClass() : controller.getClassNode();
+        ClassNode classNode = controller.getClassNode();
         String methodName = call.getMethodAsString();
         if (methodName==null) return false;
         if (!call.isImplicitThis()) return false;
diff --git a/src/main/org/codehaus/groovy/transform/sc/transformers/MethodCallExpressionTransformer.java b/src/main/org/codehaus/groovy/transform/sc/transformers/MethodCallExpressionTransformer.java
index 6d49f0fca9..57c29e62ff 100644
--- a/src/main/org/codehaus/groovy/transform/sc/transformers/MethodCallExpressionTransformer.java
+++ b/src/main/org/codehaus/groovy/transform/sc/transformers/MethodCallExpressionTransformer.java
@@ -17,8 +17,14 @@ package org.codehaus.groovy.transform.sc.transformers;
 
 import org.codehaus.groovy.ast.ClassHelper;
 import org.codehaus.groovy.ast.ClassNode;
-import org.codehaus.groovy.ast.expr.*;
+import org.codehaus.groovy.ast.FieldNode;
+import org.codehaus.groovy.ast.expr.BinaryExpression;
+import org.codehaus.groovy.ast.expr.Expression;
+import org.codehaus.groovy.ast.expr.FieldExpression;
+import org.codehaus.groovy.ast.expr.MethodCallExpression;
+import org.codehaus.groovy.ast.expr.TupleExpression;
 import org.codehaus.groovy.syntax.Token;
+import org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor;
 import org.codehaus.groovy.transform.stc.StaticTypesMarker;
 
 import java.util.List;
@@ -33,6 +39,21 @@ public class MethodCallExpressionTransformer {
     Expression transformMethodCallExpression(final MethodCallExpression expr) {
         Expression objectExpression = expr.getObjectExpression();
         ClassNode type = staticCompilationTransformer.getTypeChooser().resolveType(objectExpression, staticCompilationTransformer.getClassNode());
+        if (isCallOnClosure(expr)) {
+            FieldNode field = staticCompilationTransformer.getClassNode().getField(expr.getMethodAsString());
+            if (field != null) {
+                MethodCallExpression result = new MethodCallExpression(
+                        new FieldExpression(field),
+                        "call",
+                        staticCompilationTransformer.transform(expr.getArguments())
+                );
+                result.setImplicitThis(false);
+                result.setSourcePosition(expr);
+                result.setSafe(expr.isSafe());
+                result.setSpreadSafe(expr.isSpreadSafe());
+                return result;
+            }
+        }
         if (type != null && type.isArray()) {
             String method = expr.getMethodAsString();
             ClassNode componentType = type.getComponentType();
@@ -59,8 +80,7 @@ public class MethodCallExpressionTransformer {
                         }
                     }
                 }
-            }
-            if ("putAt".equals(method)) {
+            } else if ("putAt".equals(method)) {
                 Expression arguments = expr.getArguments();
                 if (arguments instanceof TupleExpression) {
                     List<Expression> argList = ((TupleExpression) arguments).getExpressions();
@@ -89,4 +109,10 @@ public class MethodCallExpressionTransformer {
         return staticCompilationTransformer.superTransform(expr);
     }
 
+    private boolean isCallOnClosure(final MethodCallExpression expr) {
+        return expr.isImplicitThis()
+                && expr.getNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET) == StaticTypeCheckingVisitor.CLOSURE_CALL_VARGS
+                && !"call".equals(expr.getMethodAsString());
+    }
+
 }
\ No newline at end of file
diff --git a/src/test/groovy/bugs/Groovy6522Bug.groovy b/src/test/groovy/bugs/Groovy6522Bug.groovy
new file mode 100644
index 0000000000..840924a82e
--- /dev/null
+++ b/src/test/groovy/bugs/Groovy6522Bug.groovy
@@ -0,0 +1,41 @@
+/*
+ * Copyright 2003-2014 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package groovy.bugs
+
+class Groovy6522Bug extends GroovyTestCase {
+    // this is a non-regression test that makes sure
+    // that the fix for 6522 doesn't introduce breaking changes
+    void testDelegateShouldOverrideField() {
+        assertScript '''
+class Delegate {
+  def getProperty(String name) {1}
+}
+class Tester {
+  def someProp = 2
+  def foo() {
+    def cl = {return someProp}
+    cl.delegate = new Delegate()
+    cl.resolveStrategy = Closure.DELEGATE_ONLY
+    return cl()
+  }
+}
+
+def t = new Tester()
+assert t.someProp == 2
+assert t.foo() == 1'''
+    }
+}
