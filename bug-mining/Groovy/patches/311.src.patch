diff --git a/src/main/groovy/lang/MetaClassImpl.java b/src/main/groovy/lang/MetaClassImpl.java
index f3980d608c..845fafde5d 100644
--- a/src/main/groovy/lang/MetaClassImpl.java
+++ b/src/main/groovy/lang/MetaClassImpl.java
@@ -705,6 +705,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
        
        if (arguments==null) arguments = EMPTY_ARGUMENTS;
        Class[] argClasses = MetaClassHelper.convertToTypeArray(arguments);
+       Object[] originalArguments = (Object[]) arguments.clone();
        unwrap(arguments);
        
        // lets try use the cache to find the method
@@ -719,10 +720,20 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
            return MetaClassHelper.doMethodInvoke(object, method, arguments);
        }
 
-       if (sender.getSuperclass() != Object.class) {
+       try {
+           Object prop = getProperty(theClass, theClass, methodName, false, false);
+           if (prop instanceof Closure) {
+               Closure closure = (Closure) prop;
+               MetaClass delegateMetaClass = closure.getMetaClass();
+               return delegateMetaClass.invokeMethod(closure.getClass(),closure,"doCall",originalArguments,false,false);
+           }
+       }  catch (MissingPropertyException mpe) {}
+
+       Class superClass = sender.getSuperclass();
+       if (superClass != Object.class && superClass != null) {
            return invokeStaticMethod(sender.getSuperclass(), methodName, arguments);
        }
-
+       
        throw new MissingMethodException(methodName, sender, arguments, true);
    }
    
@@ -1421,8 +1432,11 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
            if (mp instanceof MetaBeanProperty) {
                MetaBeanProperty mbp = (MetaBeanProperty) mp;
                method = mbp.getSetter();
-               if (method!=null) arguments = new Object[] { newValue };
-               field = mbp.getField();
+               MetaProperty f = mbp.getField();
+               if (method!=null || (f!=null && !Modifier.isFinal(f.getModifiers()))) {
+                   arguments = new Object[] { newValue };
+                   field = f;
+               } 
            } else {
                field = mp;
            }
@@ -1510,6 +1524,9 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
        if (ambigousListener){
            throw new GroovyRuntimeException("There are multiple listeners for the property "+name+". Please do not use the bean short form to access this listener.");
        } 
+       if (mp!=null) {
+           throw new ReadOnlyPropertyException(name,theClass);
+       }
        throw new MissingPropertyException(name, theClass);   
    }
    
diff --git a/src/test/groovy/PropertyTest.groovy b/src/test/groovy/PropertyTest.groovy
index 3459efafce..625af71642 100644
--- a/src/test/groovy/PropertyTest.groovy
+++ b/src/test/groovy/PropertyTest.groovy
@@ -62,7 +62,7 @@ class PropertyTest extends GroovyTestCase {
         def foo = new Foo()
         
         // methods should fail on non-existent method calls
-        //shouldFail { foo.blah = 4 }
+        shouldFail { foo.blah = 4 }
         shouldFail { foo.setBlah(4) }
     }
     
diff --git a/src/test/groovy/bugs/AttributeSetExpressionBug.groovy b/src/test/groovy/bugs/AttributeSetExpressionBug.groovy
index 4270ea9661..0d84f51f6f 100644
--- a/src/test/groovy/bugs/AttributeSetExpressionBug.groovy
+++ b/src/test/groovy/bugs/AttributeSetExpressionBug.groovy
@@ -21,7 +21,7 @@ class AttributeSetExpressionBug extends GroovyTestCase {
 }
 
 class HasStaticFieldSomeClass {
-    public static String name = "bar" 
+    static String name = "bar" 
     static String getName() {
         return "gettter"
     }
diff --git a/src/test/org/codehaus/groovy/classgen/CallClosureFieldAsMethodTest.groovy b/src/test/org/codehaus/groovy/classgen/CallClosureFieldAsMethodTest.groovy
index b8d6c77c73..d8d0b1287e 100644
--- a/src/test/org/codehaus/groovy/classgen/CallClosureFieldAsMethodTest.groovy
+++ b/src/test/org/codehaus/groovy/classgen/CallClosureFieldAsMethodTest.groovy
@@ -9,14 +9,18 @@ class CallClosureFieldAsMethodTest extends GroovyTestCase {
 
     String firstname = "Guillaume"
     def closureMethod = { greeting-> "${greeting} ${firstname}" }
+    public static staticClosureMethod = {it}
 
     /**
      * Check that we can call a closure defined as a field as if it were a normal method
      */
     void testCallToClosureAsMethod() {
-
         def obj = new CallClosureFieldAsMethodTest()
-
         assert obj.closureMethod("Hello") == "Hello Guillaume"
     }
+    
+    void testCallToClosureAsMethodFromStaticField() {
+        assert CallClosureFieldAsMethodTest.staticClosureMethod("Hello") == "Hello"
+    }
+
 }
