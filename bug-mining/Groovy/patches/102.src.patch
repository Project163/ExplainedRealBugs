diff --git a/src/main/org/codehaus/groovy/ast/ClassNode.java b/src/main/org/codehaus/groovy/ast/ClassNode.java
index fb491c45e2..cd7428e127 100644
--- a/src/main/org/codehaus/groovy/ast/ClassNode.java
+++ b/src/main/org/codehaus/groovy/ast/ClassNode.java
@@ -81,9 +81,19 @@ public class ClassNode extends MetadataNode implements Constants {
     private boolean staticClass = false;
     private boolean scriptBody = false;
     private boolean script;
-
     private ClassNode superClassNode;
 
+
+    //br added to track the enclosing method for local inner classes
+    private MethodNode enclosingMethod = null;
+    public MethodNode getEnclosingMethod() {
+        return enclosingMethod;
+    }
+    public void setEnclosingMethod(MethodNode enclosingMethod) {
+        this.enclosingMethod = enclosingMethod;
+    }
+
+
     /**
      * @param name
      *            is the full name of the class
@@ -114,6 +124,11 @@ public class ClassNode extends MetadataNode implements Constants {
         this.superClass = superClass;
         this.interfaces = interfaces;
         this.mixins = mixins;
+
+        //br for better JVM comformance
+        if ((modifiers & ACC_SUPER ) == 0) {
+            this.modifiers += ACC_SUPER;
+        }
     }
 
     public String getSuperClass() {
@@ -269,9 +284,9 @@ public class ClassNode extends MetadataNode implements Constants {
     public void addMixin(MixinNode mixin) {
         // lets check if it already uses a mixin
         boolean skip = false;
-        String name = mixin.getName();
+        String mixinName = mixin.getName();
         for (int i = 0; i < mixins.length; i++) {
-            if (name.equals(mixins[i].getName())) {
+            if (mixinName.equals(mixins[i].getName())) {
                 skip = true;
             }
         }
@@ -306,13 +321,13 @@ public class ClassNode extends MetadataNode implements Constants {
 
     public void addStaticInitializerStatements(List staticStatements) {
         MethodNode method = null;
-        List methods = getDeclaredMethods("<clinit>");
-        if (methods.isEmpty()) {
+        List declaredMethods = getDeclaredMethods("<clinit>");
+        if (declaredMethods.isEmpty()) {
             method =
                 addMethod("<clinit>", ACC_PUBLIC | ACC_STATIC, "void", Parameter.EMPTY_ARRAY, new BlockStatement());
         }
         else {
-            method = (MethodNode) methods.get(0);
+            method = (MethodNode) declaredMethods.get(0);
         }
         BlockStatement block = null;
         Statement statement = method.getCode();
@@ -453,13 +468,13 @@ public class ClassNode extends MetadataNode implements Constants {
      */
     public ClassNode findClassNode(String type) {
         ClassNode answer = null;
-        CompileUnit compileUnit = getCompileUnit();
-        if (compileUnit != null) {
-            answer = compileUnit.getClass(type);
+        CompileUnit theCompileUnit = getCompileUnit();
+        if (theCompileUnit != null) {
+            answer = theCompileUnit.getClass(type);
             if (answer == null) {
                 Class theClass;
                 try {
-                    theClass = compileUnit.loadClass(type);
+                    theClass = theCompileUnit.loadClass(type);
                     answer = createClassNode(theClass);
                 }
                 catch (ClassNotFoundException e) {
@@ -473,32 +488,32 @@ public class ClassNode extends MetadataNode implements Constants {
     }
 
     protected ClassNode createClassNode(Class theClass) {
-        Class[] interfaces = theClass.getInterfaces();
-        int size = interfaces.length;
+        Class[] classInterfaces = theClass.getInterfaces();
+        int size = classInterfaces.length;
         String[] interfaceNames = new String[size];
         for (int i = 0; i < size; i++) {
-            interfaceNames[i] = interfaces[i].getName();
+            interfaceNames[i] = classInterfaces[i].getName();
         }
         
-        String name = null;
+        String className = null;
         if (theClass.getSuperclass() != null) {
-            name = theClass.getSuperclass().getName();
+            className = theClass.getSuperclass().getName();
         }
         ClassNode answer =
             new ClassNode(
                 theClass.getName(),
                 theClass.getModifiers(),
-                name,
+                className,
                 interfaceNames,
                 MixinNode.EMPTY_ARRAY);
         answer.compileUnit = getCompileUnit();
-        Method[] methods = theClass.getDeclaredMethods();
-        for (int i = 0; i < methods.length; i++ ) {
-            answer.addMethod(createMethodNode(methods[i]));
+        Method[] declaredMethods = theClass.getDeclaredMethods();
+        for (int i = 0; i < declaredMethods.length; i++ ) {
+            answer.addMethod(createMethodNode(declaredMethods[i]));
         }
-        Constructor[] constructors = theClass.getDeclaredConstructors();
-        for (int i = 0; i < constructors.length; i++ ) {
-            answer.addConstructor(createConstructorNode(constructors[i]));
+        Constructor[] declaredConstructors = theClass.getDeclaredConstructors();
+        for (int i = 0; i < declaredConstructors.length; i++ ) {
+            answer.addConstructor(createConstructorNode(declaredConstructors[i]));
         }
         return answer;
     }
@@ -587,14 +602,14 @@ public class ClassNode extends MetadataNode implements Constants {
      * @return
      */
     protected String tryResolveClassFromCompileUnit(String type) {
-        CompileUnit compileUnit = getCompileUnit();
-        if (compileUnit != null) {
-            if (compileUnit.getClass(type) != null) {
+        CompileUnit theCompileUnit = getCompileUnit();
+        if (theCompileUnit != null) {
+            if (theCompileUnit.getClass(type) != null) {
                 return type;
             }
 
             try {
-                compileUnit.loadClass(type);
+                theCompileUnit.loadClass(type);
                 return type;
             }
             catch (AccessControlException ace) {
diff --git a/src/main/org/codehaus/groovy/ast/ModuleNode.java b/src/main/org/codehaus/groovy/ast/ModuleNode.java
index cc33ad2909..a5e4175e6d 100644
--- a/src/main/org/codehaus/groovy/ast/ModuleNode.java
+++ b/src/main/org/codehaus/groovy/ast/ModuleNode.java
@@ -71,7 +71,7 @@ import org.objectweb.asm.Constants;
  * Represents a module, which consists typically of a class declaration
  * but could include some imports, some statements and multiple classes
  * intermixed with statements like scripts in Python or Ruby
- * 
+ *
  * @author <a href="mailto:james@coredevelopers.net">James Strachan</a>
  * @version $Revision$
  */
@@ -88,7 +88,7 @@ public class ModuleNode extends ASTNode implements Constants {
     private String description;
     private boolean createClassForStatements = true;
     private SourceUnit context;
-    
+
 
     public ModuleNode( SourceUnit context ) {
         this.context = context;
@@ -176,7 +176,7 @@ public class ModuleNode extends ASTNode implements Constants {
     public void setPackageName(String packageName) {
         this.packageName = packageName;
     }
-    
+
     public SourceUnit getContext() {
         return context;
     }
@@ -252,14 +252,18 @@ public class ModuleNode extends ASTNode implements Constants {
             new MethodNode("run", ACC_PUBLIC, Object.class.getName(), Parameter.EMPTY_ARRAY, statementBlock));
 
         classNode.addConstructor(ACC_PUBLIC, Parameter.EMPTY_ARRAY, new BlockStatement());
+        Statement stmt = new ExpressionStatement(
+                        new MethodCallExpression(
+                            new VariableExpression("super"),
+            				"setBinding",
+            				new ArgumentListExpression(
+                                    new Expression[] {
+                                        new VariableExpression("context")})));
+
         classNode.addConstructor(
             ACC_PUBLIC,
             new Parameter[] { new Parameter(Binding.class.getName(), "context")},
-        new ExpressionStatement(
-            new MethodCallExpression(
-                new VariableExpression("super"),
-                "<init>",
-                new VariableExpression("context"))));
+			stmt);
 
         for (Iterator iter = methods.iterator(); iter.hasNext();) {
             MethodNode node = (MethodNode) iter.next();
diff --git a/src/main/org/codehaus/groovy/classgen/BytecodeHelper.java b/src/main/org/codehaus/groovy/classgen/BytecodeHelper.java
index 6e439ac9a9..a9630b0a59 100644
--- a/src/main/org/codehaus/groovy/classgen/BytecodeHelper.java
+++ b/src/main/org/codehaus/groovy/classgen/BytecodeHelper.java
@@ -32,7 +32,7 @@
  THIS SOFTWARE IS PROVIDED BY THE CODEHAUS AND CONTRIBUTORS
  ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
  NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
- FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+ FITNESS FOR AClass PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
  THE CODEHAUS OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
@@ -50,7 +50,7 @@ import org.objectweb.asm.CodeVisitor;
 import org.objectweb.asm.Constants;
 
 /**
- * A helper class for bytecode generation
+ * AClass helper class for bytecode generation
  * 
  * @author <a href="mailto:james@coredevelopers.net">James Strachan</a>
  * @version $Revision$
@@ -309,6 +309,29 @@ public class BytecodeHelper implements Constants {
         }
     }
 
+    public void store(String type, int idx) {
+        if (type.equals("double")) {
+            cv.visitVarInsn(DSTORE, idx);
+        }
+        else if (type.equals("float")) {
+            cv.visitVarInsn(FSTORE, idx);
+        }
+        else if (type.equals("long")) {
+            cv.visitVarInsn(LSTORE, idx);
+        }
+        else if (
+            type.equals("boolean")
+                || type.equals("char")
+                || type.equals("byte")
+                || type.equals("int")
+                || type.equals("short")) {
+            cv.visitVarInsn(ISTORE, idx);
+        }
+        else {
+            cv.visitVarInsn(ASTORE, idx);
+        }
+    }
+
     public String getObjectTypeForPrimitive(String type) {
         if (type.equals("boolean")) {  
             return Boolean.class.getName(); 
diff --git a/src/main/org/codehaus/groovy/classgen/ClassGenerator.java b/src/main/org/codehaus/groovy/classgen/ClassGenerator.java
index 28b956b746..0b647be428 100644
--- a/src/main/org/codehaus/groovy/classgen/ClassGenerator.java
+++ b/src/main/org/codehaus/groovy/classgen/ClassGenerator.java
@@ -20,7 +20,7 @@
  *
  * THIS SOFTWARE IS PROVIDED BY THE CODEHAUS AND CONTRIBUTORS ``AS IS'' AND ANY
  * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR AClass PARTICULAR PURPOSE ARE
  * DISCLAIMED. IN NO EVENT SHALL THE CODEHAUS OR ITS CONTRIBUTORS BE LIABLE FOR
  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
@@ -41,7 +41,6 @@ import groovy.lang.Reference;
 
 import java.math.BigDecimal;
 import java.math.BigInteger;
-import java.security.AccessControlException;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
@@ -271,6 +270,14 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
                 BytecodeHelper.getClassInternalNames(classNode.getInterfaces()),
                 sourceFile);
 
+            // set the optional enclosing method attribute of the current inner class
+//          br comment out once Groovy uses the latest CVS HEAD of ASM
+//            MethodNode enclosingMethod = classNode.getEnclosingMethod();
+//            String ownerName = BytecodeHelper.getClassInternalName(enclosingMethod.getDeclaringClass().getName());
+//            String descriptor = BytecodeHelper.getMethodDescriptor(enclosingMethod.getReturnType(), enclosingMethod.getParameters());
+//            EnclosingMethodAttribute attr = new EnclosingMethodAttribute(ownerName,enclosingMethod.getName(),descriptor);
+//            cw.visitAttribute(attr);
+
             classNode.visitContents(this);
 
             createSyntheticStaticFields();
@@ -279,13 +286,19 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
                 ClassNode innerClass = (ClassNode) iter.next();
                 String innerClassName = innerClass.getName();
                 String innerClassInternalName = BytecodeHelper.getClassInternalName(innerClassName);
+                String outerClassName = internalClassName; // default for inner classes
+                MethodNode enclosingMethod = innerClass.getEnclosingMethod();
+                if (enclosingMethod != null) {
+                    // local inner classes do not specify the outer class name
+                    outerClassName = null;
+                }
                 cw.visitInnerClass(
                     innerClassInternalName,
-                    internalClassName,
+                    outerClassName,
                     innerClassName,
                     innerClass.getModifiers());
             }
-
+// br TODO an inner class should have an entry of itself
             cw.visitEnd();
         }
         catch (GroovyRuntimeException e) {
@@ -312,7 +325,7 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
         resetVariableStack(node.getParameters());
 
         Statement code = node.getCode();
-        if (code == null || !firstStatementIsSuperMethodCall(code)) {
+        if (code == null || !firstStatementIsSuperInit(code)) {
             // invokes the super class constructor
             cv.visitVarInsn(ALOAD, 0);
             cv.visitMethodInsn(INVOKESPECIAL, internalBaseClassName, "<init>", "()V");
@@ -337,6 +350,8 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
 
         String methodType = BytecodeHelper.getMethodDescriptor(node.getReturnType(), node.getParameters());
         cv = cw.visitMethod(node.getModifiers(), node.getName(), methodType, null, null);
+        Label labelStart = new Label();
+        cv.visitLabel(labelStart);
         helper = new BytecodeHelper(cv);
 
         findMutableVariables();
@@ -357,6 +372,19 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
         }
         exceptionBlocks.clear();
 
+        Label labelEnd = new Label();
+        cv.visitLabel(labelEnd);
+
+        // br experiment with local var table so debugers can retrieve variable names
+        Set vars = this.variableStack.keySet();
+        for (Iterator iterator = vars.iterator(); iterator.hasNext();) {
+            String varName = (String) iterator.next();
+            Variable v = (Variable)variableStack.get(varName);
+            String type = v.getTypeName();
+            type = BytecodeHelper.getTypeDescription(type);
+            cv.visitLocalVariable(varName, type, labelStart, labelEnd, v.getIndex()); // the start and end should be fine-pined
+        }
+
         cv.visitMaxs(0, 0);
     }
 
@@ -928,6 +956,9 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
             // all IRETURN
             cv.visitInsn(IRETURN);
         }
+        else if (returnType.equals("void")) {
+            cv.visitInsn(RETURN);
+        }
         else {
             doConvertAndCast(returnType, expression);
             cv.visitInsn(ARETURN);
@@ -1176,20 +1207,6 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
             }
         }
 
-        /*
-        if (classNode instanceof InnerClassNode) {
-            // lets load the outer this
-            int paramIdx = defineVariable(createVariableName("iterator"), "java.lang.Object", false).getIndex();
-            cv.visitVarInsn(ALOAD, 0);
-            cv.visitFieldInsn(GETFIELD, internalClassName, "owner", helper.getTypeDescription(ownerTypeName));
-            cv.visitVarInsn(ASTORE, paramIdx);
-
-            cv.visitTypeInsn(NEW, innerClassinternalName);
-            cv.visitInsn(DUP);
-            cv.visitVarInsn(ALOAD, paramIdx);
-        }
-        else {
-        */
         cv.visitTypeInsn(NEW, innerClassinternalName);
         cv.visitInsn(DUP);
         if (isStaticMethod() || classNode.isStaticClass()) {
@@ -1198,14 +1215,11 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
         else {
             loadThisOrOwner();
         }
-        /*
-        }
-        */
 
         if (innerClass.getSuperClass().equals("groovy.lang.Closure")) {
             if (isStaticMethod()) {
                 /**
-                 * @todo could maybe stash this expression in a JVM variable
+                 * todo could maybe stash this expression in a JVM variable
                  * from previous statement above
                  */
                 visitClassExpression(new ClassExpression(ownerTypeName));
@@ -1271,7 +1285,7 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
             cv.visitLdcInsn(value);
         }
         else if (value instanceof Number) {
-            /** @todo it would be more efficient to generate class constants */
+            /** todo it would be more efficient to generate class constants */
             Number n = (Number) value;
             String className = BytecodeHelper.getClassInternalName(value.getClass().getName());
             cv.visitTypeInsn(NEW, className);
@@ -1316,6 +1330,13 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
             String text = (bool.booleanValue()) ? "TRUE" : "FALSE";
             cv.visitFieldInsn(GETSTATIC, "java/lang/Boolean", text, "Ljava/lang/Boolean;");
         }
+        else if (value instanceof Class) {
+            Class vc = (Class) value;
+            if (!vc.getName().equals("java.lang.Void")) {
+                throw new ClassGeneratorException(
+                "Cannot generate bytecode for constant: " + value + " of type: " + value.getClass().getName());
+            }
+        }
         else {
             throw new ClassGeneratorException(
                 "Cannot generate bytecode for constant: " + value + " of type: " + value.getClass().getName());
@@ -1374,10 +1395,16 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
         boolean superMethodCall = MethodCallExpression.isSuperMethodCall(call);
         String method = call.getMethod();
         if (superMethodCall && method.equals("<init>")) {
-            /** @todo handle method types! */
+            /** todo handle method types! */
             cv.visitVarInsn(ALOAD, 0);
-            cv.visitVarInsn(ALOAD, 1);
-            cv.visitMethodInsn(INVOKESPECIAL, internalBaseClassName, "<init>", "(Ljava/lang/Object;)V");
+            if (isInClosureConstructor()) { // br use the second param to init the super class (Closure)
+                cv.visitVarInsn(ALOAD, 2);
+                cv.visitMethodInsn(INVOKESPECIAL, internalBaseClassName, "<init>", "(Ljava/lang/Object;)V");
+            }
+            else {
+                cv.visitVarInsn(ALOAD, 1);
+                cv.visitMethodInsn(INVOKESPECIAL, internalBaseClassName, "<init>", "(Ljava/lang/Object;)V");
+            }
         }
         else {
             // are we a local variable
@@ -1398,24 +1425,24 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
             else {
                 if (superMethodCall) {
                     if (method.equals("super") || method.equals("<init>")) {
-                        ConstructorNode constructorNode = findSuperConstructor(call);
+                        ConstructorNode superConstructorNode = findSuperConstructor(call);
 
                         cv.visitVarInsn(ALOAD, 0);
 
-                        loadArguments(constructorNode.getParameters(), arguments);
+                        loadArguments(superConstructorNode.getParameters(), arguments);
 
-                        String descriptor = BytecodeHelper.getMethodDescriptor("void", constructorNode.getParameters());
+                        String descriptor = BytecodeHelper.getMethodDescriptor("void", superConstructorNode.getParameters());
                         cv.visitMethodInsn(INVOKESPECIAL, BytecodeHelper.getClassInternalName(classNode.getSuperClass()), "<init>", descriptor);
                     }
                     else {
-                        MethodNode methodNode = findSuperMethod(call);
+                        MethodNode superMethodNode = findSuperMethod(call);
 
                         cv.visitVarInsn(ALOAD, 0);
 
-                        loadArguments(methodNode.getParameters(), arguments);
+                        loadArguments(superMethodNode.getParameters(), arguments);
 
-                        String descriptor = BytecodeHelper.getMethodDescriptor(methodNode.getReturnType(), methodNode.getParameters());
-                        cv.visitMethodInsn(INVOKESPECIAL, BytecodeHelper.getClassInternalName(methodNode.getDeclaringClass().getName()), method, descriptor);
+                        String descriptor = BytecodeHelper.getMethodDescriptor(superMethodNode.getReturnType(), superMethodNode.getParameters());
+                        cv.visitMethodInsn(INVOKESPECIAL, BytecodeHelper.getClassInternalName(superMethodNode.getDeclaringClass().getName()), method, descriptor);
                     }
                 }
                 else {
@@ -1708,22 +1735,20 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
                 doConvertAndCast(type);
             }
         }
-        int opcode =
-            (leftHandExpression && !holder) ? ((isStatic) ? PUTSTATIC : PUTFIELD) : ((isStatic) ? GETSTATIC : GETFIELD);
+
         String ownerName =
             (field.getOwner().equals(classNode.getName()))
                 ? internalClassName
                 : org.objectweb.asm.Type.getInternalName(loadClass(field.getOwner()));
-
+        int opcode  = isStatic ?  GETSTATIC : GETFIELD;
         if (holder) {
             if (leftHandExpression) {
                 cv.visitVarInsn(ASTORE, tempIndex);
-
-                cv.visitVarInsn(ALOAD, 0);
+                if (!isStatic)
+                    cv.visitVarInsn(ALOAD, 0); // br
                 cv.visitFieldInsn(opcode, ownerName, expression.getFieldName(), BytecodeHelper.getTypeDescription(type));
-
+                //cv.visitInsn(SWAP); // swap the value and the this pointer . swap is used to save a temp
                 cv.visitVarInsn(ALOAD, tempIndex);
-
                 cv.visitMethodInsn(INVOKEVIRTUAL, "groovy/lang/Reference", "set", "(Ljava/lang/Object;)V");
             }
             else {
@@ -1732,9 +1757,24 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
             }
         }
         else {
-            cv.visitFieldInsn(opcode, ownerName, expression.getFieldName(), BytecodeHelper.getTypeDescription(type));
-            if (!leftHandExpression && helper.isPrimitiveType(type)) {
-                helper.box(type);
+            if (leftHandExpression) {
+                if (!isStatic)  {
+                    opcode = PUTFIELD;
+                    helper.store(field.getType(), tempIndex);
+                    cv.visitVarInsn(ALOAD, 0); // static does not need this pointer
+                    //cv.visitInsn(SWAP); // swap the value and the this pointer . swap is not type safe
+                    // cv.visitVarInsn(ALOAD, tempIndex);
+                    helper.load(field.getType(), tempIndex);
+
+                } else {
+                    opcode = PUTSTATIC;
+                }
+                cv.visitFieldInsn(opcode, ownerName, expression.getFieldName(), BytecodeHelper.getTypeDescription(type));
+            }else {
+                cv.visitFieldInsn(opcode, ownerName, expression.getFieldName(), BytecodeHelper.getTypeDescription(type));
+                if (helper.isPrimitiveType(type)) {
+                    helper.box(type);
+                }
             }
         }
     }
@@ -1905,34 +1945,15 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
         if( leftHandExpression ) {
             if (holder) {
                 int tempIndex = defineVariable(createVariableName("reference"), type, false).getIndex();
-
                 cv.visitVarInsn(ASTORE, tempIndex);
-
                 cv.visitVarInsn(ALOAD, index);
+                //cv.visitInsn(SWAP);  // assuming the value is already on the stack
                 cv.visitVarInsn(ALOAD, tempIndex);
                 cv.visitMethodInsn(INVOKEVIRTUAL, "groovy/lang/Reference", "set", "(Ljava/lang/Object;)V");
             }
             else {
-                //TODO: make work with arrays
-                if (type.equals("double")) {
-                    cv.visitVarInsn(DSTORE, index);
-                }
-                else if (type.equals("float")) {
-                    cv.visitVarInsn(FSTORE, index);
-                }
-                else if (type.equals("long")) {
-                    cv.visitVarInsn(LSTORE, index);
-                }
-                else if (
-                    type.equals("byte")
-                        || type.equals("short")
-                        || type.equals("boolean")
-                        || type.equals("int")) {
-                    cv.visitVarInsn(ISTORE, index);
-                }
-                else {
-                    cv.visitVarInsn(ASTORE, index);
-                }
+                helper.store("objref", index); // br seems right hand values on the stack are always object refs, primitives boxed
+                //cv.visitVarInsn(ASTORE, index);
             }
         }
         else {
@@ -2017,7 +2038,7 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
         return true;
     }
 
-    protected boolean firstStatementIsSuperMethodCall(Statement code) {
+    protected boolean firstStatementIsSuperInit(Statement code) {
         ExpressionStatement expStmt = null;
         if (code instanceof ExpressionStatement) {
             expStmt = (ExpressionStatement) code;
@@ -2034,7 +2055,11 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
         if (expStmt != null) {
             Expression expr = expStmt.getExpression();
             if (expr instanceof MethodCallExpression) {
-                return MethodCallExpression.isSuperMethodCall((MethodCallExpression) expr);
+            	MethodCallExpression call = (MethodCallExpression) expr;
+                if (MethodCallExpression.isSuperMethodCall(call)) {
+                    // not sure which one is constantly used as the super class ctor call. To cover both for now
+                	return call.getMethod().equals("<init>") || call.getMethod().equals("super");
+                }
             }
         }
         return false;
@@ -2073,7 +2098,7 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
             cv.visitMethodInsn(INVOKEVIRTUAL, "java/lang/ClassNotFoundException", "getMessage", "()Ljava/lang/String;");
             cv.visitMethodInsn(INVOKESPECIAL, "java/lang/NoClassDefFoundError", "<init>", "(Ljava/lang/String;)V");
             cv.visitInsn(ATHROW);
-            cv.visitTryCatchBlock(l0, l1, l2, "java/lang/ClassNotFoundException");
+            cv.visitTryCatchBlock(l0, l2, l2, "java/lang/ClassNotFoundException"); // br using l2 as the 2nd param seems create the right table entry
             cv.visitMaxs(3, 2);
 
             cw.visitEnd();
@@ -2249,7 +2274,8 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
         ClassNode owner = getOutermostClass();
         boolean parentIsInnerClass = owner instanceof InnerClassNode;
         String outerClassName = owner.getName();
-        String name = outerClassName + "$" + context.getNextInnerClassIdx();
+        String name = outerClassName + "$"
+                + context.getNextClosureInnerName(owner, classNode, methodNode); // br added a more infomative name
         boolean staticMethodOrInStaticClass = isStaticMethod() || classNode.isStaticClass();
         if (staticMethodOrInStaticClass) {
             outerClassName = "java.lang.Class";
@@ -2262,7 +2288,8 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
 
         Parameter[] localVariableParams = getClosureSharedVariables(expression);
 
-        InnerClassNode answer = new InnerClassNode(owner, name, ACC_PUBLIC, "groovy.lang.Closure");
+        InnerClassNode answer = new InnerClassNode(owner, name, ACC_SUPER, "groovy.lang.Closure"); // clsures are local inners and not public
+        answer.setEnclosingMethod(this.methodNode);
         if (staticMethodOrInStaticClass) {
             answer.setStaticClass(true);
         }
@@ -2275,13 +2302,13 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
         method.setLineNumber(expression.getLineNumber());
         method.setColumnNumber(expression.getColumnNumber());
 
-        VariableScope scope = expression.getVariableScope();
-        if (scope == null) {
+        VariableScope varScope = expression.getVariableScope();
+        if (varScope == null) {
             throw new RuntimeException(
                 "Must have a VariableScope by now! for expression: " + expression + " class: " + name);
         }
         else {
-            method.setVariableScope(scope);
+            method.setVariableScope(varScope);
         }
         if (parameters.length > 1
             || (parameters.length == 1
@@ -2301,7 +2328,7 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
                         new ArgumentListExpression(parameters))));
         }
 
-        FieldNode field = answer.addField("owner", ACC_PRIVATE, outerClassName, null);
+        FieldNode ownerField = answer.addField("owner", ACC_PRIVATE, outerClassName, null);
 
         // lets make the constructor
         BlockStatement block = new BlockStatement();
@@ -2314,7 +2341,7 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
         block.addStatement(
             new ExpressionStatement(
                 new BinaryExpression(
-                    new FieldExpression(field),
+                    new FieldExpression(ownerField),
                     Token.newSymbol(Types.EQUAL, -1, -1),
                     new VariableExpression("_outerInstance"))));
 
@@ -2325,14 +2352,11 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
             boolean holder = mutableVars.contains(paramName);
             Expression initialValue = null;
             String type = param.getType();
+            FieldNode paramField = null;
             if (holder) {
-                initialValue = new VariableExpression(paramName);
+            	initialValue = new VariableExpression(paramName);
                 type = Reference.class.getName();
                 param.makeReference();
-            }
-
-            FieldNode paramField = null;
-            if (holder) {
                 paramField = answer.addField(paramName, ACC_PRIVATE, type, initialValue);
                 paramField.setHolder(true);
                 String realType = param.getRealType();
@@ -2358,11 +2382,8 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
                         */
             }
             else {
-                PropertyNode propertyNode = answer.addProperty(paramName, ACC_PUBLIC, type, initialValue, null, null);
+            	PropertyNode propertyNode = answer.addProperty(paramName, ACC_PUBLIC, type, initialValue, null, null);
                 paramField = propertyNode.getField();
-            }
-
-            if (!holder) {
                 block.addStatement(
                     new ExpressionStatement(
                         new BinaryExpression(
@@ -2398,11 +2419,12 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
         }
         String outerClassName = owner.getName();
         String name = outerClassName + "$" + context.getNextInnerClassIdx();
-        InnerClassNode answer = new InnerClassNode(owner, name, ACC_PUBLIC, GString.class.getName());
+        InnerClassNode answer = new InnerClassNode(owner, name, ACC_SUPER, GString.class.getName());
+        answer.setEnclosingMethod(this.methodNode);
         FieldNode stringsField =
             answer.addField(
                 "strings",
-                ACC_PRIVATE | ACC_STATIC,
+                ACC_PRIVATE /*| ACC_STATIC*/,
                 "java.lang.String[]",
                 new ArrayExpression("java.lang.String", expression.getStrings()));
         answer.addMethod(
@@ -2423,7 +2445,7 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
 
     protected void doConvertAndCast(String type) {
         if (!type.equals("java.lang.Object")) {
-            /** @todo should probably support array coercions */
+            /** todo should probably support array coercions */
             if (!type.endsWith("[]") && isValidTypeForCast(type)) {
                 visitClassExpression(new ClassExpression(type));
                 asTypeMethod.call(cv);
@@ -2567,9 +2589,7 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
                 return;
             }
         }
-        if (isNonStaticField(leftExpression)) {
-            cv.visitVarInsn(ALOAD, 0);
-        }
+        // br we'll load this pointer later right where we really need it
 
         // lets evaluate the RHS then hopefully the LHS will be a field
         leftHandExpression = false;
@@ -2670,9 +2690,9 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
     }
 
     protected void evaluatePostfixMethod(String method, Expression expression) {
-        if (isNonStaticField(expression) && ! isHolderVariable(expression) && !isStaticMethod()) {
-            cv.visitVarInsn(ALOAD, 0);
-        }
+//        if (isNonStaticField(expression) && ! isHolderVariable(expression) && !isStaticMethod()) {
+//            cv.visitVarInsn(ALOAD, 0);  // br again, loading this pointer is moved to staying close to variable
+//        }
         leftHandExpression = false;
         expression.visit(this);
 
@@ -3089,18 +3109,18 @@ public class ClassGenerator extends CodeVisitorSupport implements GroovyClassVis
             if (define) {
                 if (definingParameters) {
                     if (answer.isHolder()) {
-                        cv.visitTypeInsn(NEW, "groovy/lang/Reference");
+                        cv.visitTypeInsn(NEW, "groovy/lang/Reference"); // br todo to associate a label with the variable
                         cv.visitInsn(DUP);
                         cv.visitVarInsn(ALOAD, lastVariableIndex);
-                        cv.visitMethodInsn(INVOKESPECIAL, "groovy/lang/Reference", "<init>", "(Ljava/lang/Object;)V");
+                        cv.visitMethodInsn(INVOKESPECIAL, "groovy/lang/Reference", "<init>", "(Ljava/lang/Object;)V"); // br wrap the param in a ref
                         cv.visitVarInsn(ASTORE, lastVariableIndex);
                     }
                 }
                 else {
                     // using new variable inside a comparison expression
                     // so lets initialize it too
-                    if (answer.isHolder() && !isInScriptBody()) {
-                        //cv.visitVarInsn(ASTORE, idx + 1);
+                    if (answer.isHolder() /*&& !isInScriptBody()*/) { // br doesn't seem to need different treatment, in script or not
+                        //cv.visitVarInsn(ASTORE, lastVariableIndex + 1); // I might need this to set the reference value
 
                         cv.visitTypeInsn(NEW, "groovy/lang/Reference");
                         cv.visitInsn(DUP);
diff --git a/src/main/org/codehaus/groovy/classgen/GeneratorContext.java b/src/main/org/codehaus/groovy/classgen/GeneratorContext.java
index 3392f5df95..1d75251eda 100644
--- a/src/main/org/codehaus/groovy/classgen/GeneratorContext.java
+++ b/src/main/org/codehaus/groovy/classgen/GeneratorContext.java
@@ -45,7 +45,9 @@
  */
 package org.codehaus.groovy.classgen;
 
+import org.codehaus.groovy.ast.ClassNode;
 import org.codehaus.groovy.ast.CompileUnit;
+import org.codehaus.groovy.ast.MethodNode;
 
 
 /**
@@ -63,11 +65,15 @@ public class GeneratorContext {
         this.compileUnit = compileUnit;
     }
 
+    public CompileUnit getCompileUnit() {
+        return compileUnit;
+    }
+
     public int getNextInnerClassIdx() {
         return innerClassIdx++;
     }
     
-    public CompileUnit getCompileUnit() {
-        return compileUnit;
+    public String getNextClosureInnerName(ClassNode owner, ClassNode classNode, MethodNode methodNode) {
+        return "" + getNextInnerClassIdx();
     }
 }
diff --git a/src/test/groovy/PrimitiveTypeFieldTest.groovy b/src/test/groovy/PrimitiveTypeFieldTest.groovy
index a234c78e23..ab1018bab3 100644
--- a/src/test/groovy/PrimitiveTypeFieldTest.groovy
+++ b/src/test/groovy/PrimitiveTypeFieldTest.groovy
@@ -19,21 +19,19 @@ class PrimitiveTypeFieldTest extends GroovyTestCase {
 	}
 	
 	void testIntLocalVariable() {
-		/* @todo 
 		int x = 123
 		y = x + 1
 		assert y == 124
-		*/
 	}
 	
 	void testIntParamBug() {
 		assert bugMethod(123) == 246
 		assert bugMethod2(123) == 246
 		
-		/* @todo GROOVY-133
+		/* @todo GROOVY-133 */
 		closure = { int x | x * 2 }
 		assert closure.call(123) == 246
-		*/
+
 	}
 	
 	int bugMethod(int x) {
diff --git a/src/test/groovy/bugs/ClassGeneratorFixesTest.groovy b/src/test/groovy/bugs/ClassGeneratorFixesTest.groovy
new file mode 100644
index 0000000000..f14bc03b77
--- /dev/null
+++ b/src/test/groovy/bugs/ClassGeneratorFixesTest.groovy
@@ -0,0 +1,77 @@
+package groovy.bugs
+
+
+class ClassGeneratorFixesTest extends GroovyTestCase {
+    pf(int p) {
+        int i = p
+        boolean b = true
+    }
+
+	void testPrimitvesInFunc() { // groovy-373, 453, 385, 451, 199
+		pf(10)
+	}
+
+    count = 0;
+
+    void testPlusEqual() { // 372
+        count += 1
+        assert count == 1
+
+        foo =
+            {i|
+                {j|
+                    i += j
+                    i
+                }
+            }
+        x = foo(1)
+        x(5)
+        foo(3)
+        println x(2.3)
+    }
+
+    void testIfAndSwitchInClosure (){ // 321, 324, 412
+
+        a = 1
+        1.times {
+            if (a ==1) {
+                a = 2
+            }
+        }
+
+        noneYet=true;
+        ["a","b","c","d"].each { c |
+          if (noneYet) {
+            noneYet=false;
+          } else {
+            print(" > ");
+          }
+          print( c );
+        }
+
+        a = 1
+        switch (a) {
+        case 1:
+            a = 2;
+        case 2:
+            break;
+        default:
+            break;
+        }
+    }
+
+    void returnVoid() {
+        return
+    }
+    void testReturnVoid() { // groovy-405, 387
+        returnVoid()
+    }
+    
+    void testBooleanValue() { // groovy-385
+    		/** @todo
+    		boolean value
+    		*/
+    	}
+
+}
+
