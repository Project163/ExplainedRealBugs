diff --git a/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java b/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java
index b83145d1d8..c04918a216 100644
--- a/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java
+++ b/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java
@@ -431,19 +431,26 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
             modifiers = modifiers(node, annotations, modifiers);
             node = node.getNextSibling();
         }
-        assertNodeType(TYPE, node);
-        String type = typeName(node);
 
-        node = node.getNextSibling();
+        String type = null;
+        if (isType(TYPE, node)) {
+            type = typeName(node);
+            node = node.getNextSibling();
+        }
 
         String name = identifier(node);
-
-        Expression defaultValue = null;
         node = node.getNextSibling();
+        VariableExpression leftExpression = new VariableExpression(name, type);
+        configureAST(leftExpression, paramNode);
+
+        Expression rightExpression = ConstantExpression.NULL;
         if (node != null) {
-            defaultValue = expression(node);
+            assertNodeType(ASSIGN, node);
+
+            rightExpression = expression(node.getFirstChild());
         }
-        Parameter parameter = new Parameter(type, name, defaultValue);
+
+        Parameter parameter = new Parameter(type, name, rightExpression);
         // TODO
         //configureAST(parameter,paramNode);
         //parameter.addAnnotations(annotations);
@@ -1414,11 +1421,41 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
 
         AST leftNode = node.getFirstChild();
         Expression leftExpression = expression(leftNode);
+
         AST rightNode = leftNode.getNextSibling();
         if (rightNode == null) {
-            //rightNode = leftNode.getFirstChild();
             return leftExpression;
         }
+
+        if (Types.ofType(type, Types.ASSIGNMENT_OPERATOR)) {
+            if (leftExpression instanceof VariableExpression || leftExpression instanceof PropertyExpression
+                                                             || leftExpression instanceof FieldExpression
+                                                             || leftExpression instanceof DeclarationExpression) {
+                // Do nothing.
+            }
+            else if (leftExpression instanceof ConstantExpression) {
+                throw new ASTRuntimeException(node, "\n[" + ((ConstantExpression) leftExpression).getValue() + "] is a constant expression, but it should be a variable expression");
+            }
+            else if (leftExpression instanceof BinaryExpression) {
+                Expression leftexp = ((BinaryExpression) leftExpression).getLeftExpression();
+                int lefttype = ((BinaryExpression) leftExpression).getOperation().getType();
+                if (!Types.ofType(lefttype, Types.ASSIGNMENT_OPERATOR) && lefttype != Types.LEFT_SQUARE_BRACKET) {
+                    throw new ASTRuntimeException(node, "\n" + ((BinaryExpression) leftExpression).getText() + " is a binary expression, but it should be a variable expression");
+                }
+            }
+            else if (leftExpression instanceof GStringExpression) {
+                throw new ASTRuntimeException(node, "\n\"" + ((GStringExpression) leftExpression).getText() + "\" is a GString expression, but it should be a variable expression");
+            }
+            else if (leftExpression instanceof MethodCallExpression) {
+                throw new ASTRuntimeException(node, "\n\"" + ((MethodCallExpression) leftExpression).getText() + "\" is a method call expression, but it should be a variable expression");
+            }
+            else if (leftExpression instanceof MapExpression) {
+                throw new ASTRuntimeException(node, "\n'" + ((MapExpression) leftExpression).getText() + "' is a map expression, but it should be a variable expression");
+            }
+            else {
+                throw new ASTRuntimeException(node, "\n" + leftExpression.getClass() + ", with its value '" + leftExpression.getText() + "', is a bad expression as the LSH of an assignment operator");
+            }
+        }
         /*if (rightNode == null) {
             throw new NullPointerException("No rightNode associated with binary expression");
         }*/
@@ -1556,7 +1593,7 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
         if (isType(ARRAY_DECLARATOR, elist)) {
             AST expressionNode = elist.getFirstChild();
             if (expressionNode == null) {
-                throw new ASTRuntimeException(elist, "No expression for the arrary constructor call");
+                throw new ASTRuntimeException(elist, "No expression for the array constructor call");
             }
             Expression size = expression(expressionNode);
             ArrayExpression arrayExpression = new ArrayExpression(name, size);
diff --git a/src/test/groovy/IdentityClosureTest.groovy b/src/test/groovy/IdentityClosureTest.groovy
index ea0ad07941..c20b4c4c39 100644
--- a/src/test/groovy/IdentityClosureTest.groovy
+++ b/src/test/groovy/IdentityClosureTest.groovy
@@ -16,7 +16,7 @@ class IdentityClosureTest extends GroovyTestCase {
 
         bar.toUpperCase().trim().identity{
             assert "BAR" == it
-            assert 3 = it.size()
+            assert 3 == it.size()
             assert it.indexOf("A") > 0
         }
     }  
@@ -54,7 +54,7 @@ class IdentityClosureTest extends GroovyTestCase {
     void testClosureDelegate1() {
         bar.toUpperCase().trim().identity{
             assert "BAR" == it
-            assert 3 = size()
+            assert 3 == size()
             assert indexOf("A") > 0
         }
     }
