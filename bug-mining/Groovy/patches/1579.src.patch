diff --git a/src/main/groovy/lang/MetaClassImpl.java b/src/main/groovy/lang/MetaClassImpl.java
index 9d16887ee2..ba2f5857c3 100644
--- a/src/main/groovy/lang/MetaClassImpl.java
+++ b/src/main/groovy/lang/MetaClassImpl.java
@@ -31,6 +31,7 @@ import org.codehaus.groovy.reflection.ReflectionCache;
 import org.codehaus.groovy.runtime.ConvertedClosure;
 import org.codehaus.groovy.runtime.CurriedClosure;
 import org.codehaus.groovy.runtime.DefaultGroovyMethods;
+import org.codehaus.groovy.runtime.GeneratedClosure;
 import org.codehaus.groovy.runtime.GroovyCategorySupport;
 import org.codehaus.groovy.runtime.InvokerHelper;
 import org.codehaus.groovy.runtime.InvokerInvocationException;
@@ -76,7 +77,6 @@ import java.lang.reflect.Modifier;
 import java.lang.reflect.Proxy;
 import java.net.URL;
 import java.security.AccessController;
-import java.security.PrivilegedAction;
 import java.security.PrivilegedActionException;
 import java.security.PrivilegedExceptionAction;
 import java.util.ArrayList;
@@ -893,24 +893,24 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
             throw new NullPointerException("Cannot invoke method: " + methodName + " on null object");
         }
 
-        final Object[] arguments = originalArguments == null ? EMPTY_ARGUMENTS : originalArguments;
-//        final Class[] argClasses = MetaClassHelper.convertToTypeArray(arguments);
-//
-//        unwrap(arguments);
+        String correctedMethodName = methodName;
+        if (object instanceof GeneratedClosure && CLOSURE_CALL_METHOD.equals(methodName)) {
+            correctedMethodName = CLOSURE_DO_CALL_METHOD;
+        }
 
-        MetaMethod method = getMethodWithCaching(sender, methodName, arguments, isCallToSuper);
+        final Object[] arguments = originalArguments == null ? EMPTY_ARGUMENTS : originalArguments;
+        MetaMethod method = getMethodWithCaching(sender, correctedMethodName, arguments, isCallToSuper);
         MetaClassHelper.unwrap(arguments);
 
         if (method == null)
-            method = tryListParamMetaMethod(sender, methodName, isCallToSuper, arguments);
+            method = tryListParamMetaMethod(sender, correctedMethodName, isCallToSuper, arguments);
 
         final boolean isClosure = object instanceof Closure;
         if (isClosure) {
             final Closure closure = (Closure) object;
 
             final Object owner = closure.getOwner();
-
-            if (CLOSURE_CALL_METHOD.equals(methodName) || CLOSURE_DO_CALL_METHOD.equals(methodName)) {
+            if (CLOSURE_DO_CALL_METHOD.equals(methodName)) {
                 final Class objectClass = object.getClass();
                 if (objectClass == MethodClosure.class) {
                     final MethodClosure mc = (MethodClosure) object;
diff --git a/src/test/groovy/lang/ClosureMetaClassTest.groovy b/src/test/groovy/lang/ClosureMetaClassTest.groovy
new file mode 100644
index 0000000000..ae3f2d9967
--- /dev/null
+++ b/src/test/groovy/lang/ClosureMetaClassTest.groovy
@@ -0,0 +1,28 @@
+package groovy.lang
+
+import groovy.util.GroovyTestCase
+import org.codehaus.groovy.runtime.metaclass.ClosureMetaClass
+
+class ClosureMetaClassTest extends GroovyTestCase {
+    
+    void testClosureMetaClass() {
+        Object[] myObjectArray = ['a', 'b'] as Object[]
+        def closure = {1}
+        assert closure.metaClass.getClass() == ClosureMetaClass.class
+        assert closure(myObjectArray) == 1
+    }    
+
+    void testMetaClassImpl() {
+        Object[] myObjectArray = ['a', 'b'] as Object[]
+        def closure = {1}
+        closure.metaClass == new MetaClassImpl(closure.getClass())
+        assert closure(myObjectArray) == 1
+    }
+    
+    void testEMC() {
+        Object[] myObjectArray = ['a', 'b'] as Object[]
+        def closure = {1}
+        closure.metaClass == new ExpandoMetaClass(closure.getClass())
+        assert closure(myObjectArray) == 1
+    }
+}
\ No newline at end of file
