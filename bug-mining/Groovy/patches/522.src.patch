diff --git a/src/main/groovy/lang/Binding.java b/src/main/groovy/lang/Binding.java
index c95458b60e..f8e54e2524 100644
--- a/src/main/groovy/lang/Binding.java
+++ b/src/main/groovy/lang/Binding.java
@@ -27,10 +27,9 @@ import java.util.Map;
  * @version $Revision$
  */
 public class Binding extends GroovyObjectSupport {
-    private final Map variables;
+    private Map variables;
     
     public Binding() {
-        variables = new HashMap();
     }
     
     public Binding(Map variables) {
@@ -52,6 +51,9 @@ public class Binding extends GroovyObjectSupport {
      * @return the variable value
      */
     public Object getVariable(String name) {
+        if (variables == null)
+            throw new MissingPropertyException(name, Binding.class);
+
         Object result = variables.get(name);
         
         if (result == null && !variables.containsKey(name)) {
@@ -67,10 +69,14 @@ public class Binding extends GroovyObjectSupport {
      * @param value the new value for the given variable
      */
     public void setVariable(String name, Object value) {
+        if (variables == null)
+          variables = new HashMap();
         variables.put(name, value);
     }
     
     public Map getVariables() {
+        if (variables == null)
+          variables = new HashMap();
         return variables;
     }
 
diff --git a/src/main/groovy/lang/ExpandoMetaClass.java b/src/main/groovy/lang/ExpandoMetaClass.java
index 50de0e729e..3466b01739 100644
--- a/src/main/groovy/lang/ExpandoMetaClass.java
+++ b/src/main/groovy/lang/ExpandoMetaClass.java
@@ -408,8 +408,9 @@ public class ExpandoMetaClass extends MetaClassImpl implements GroovyObject {
                     String name = metaMethodFromSuper.getName();
                     ClosureMetaMethod localMethod = new ClosureMetaMethod(name, getJavaClass(), cloned);
                     addMetaMethod(localMethod);
+
                     MethodKey key = new DefaultCachedMethodKey(getJavaClass(),name, localMethod.getParameterTypes(),false );
-                    cacheInstanceMethod(key, localMethod);
+//                    cacheInstanceMethod(key, localMethod);
 
                     checkIfGroovyObjectMethod(localMethod, name);
                     expandoMethods.put(key,localMethod);
@@ -859,7 +860,7 @@ public class ExpandoMetaClass extends MetaClassImpl implements GroovyObject {
 
                     addMetaMethod(metaMethod);
                     dropStaticMethodCache (methodName);
-                    cacheStaticMethod(key,metaMethod);
+//                    cacheStaticMethod(key,metaMethod);
 
                     if(isGetter(methodName, metaMethod.getParameterTypes())) {
                         String propertyName = getPropertyForGetter(methodName);
diff --git a/src/main/groovy/lang/MetaClassImpl.java b/src/main/groovy/lang/MetaClassImpl.java
index 8ac2fcc248..f511993239 100644
--- a/src/main/groovy/lang/MetaClassImpl.java
+++ b/src/main/groovy/lang/MetaClassImpl.java
@@ -80,8 +80,6 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
     private final SingleKeyHashMap staticPropertyIndex = new SingleKeyHashMap();
 
     private final Map listeners = new HashMap();
-    private final Map methodCache = new ConcurrentReaderHashMap();
-    private final Map staticMethodCache = new ConcurrentReaderHashMap();
     private FastArray constructors;
     private final List allMethods = new ArrayList();
     private List interfaceMethods;
@@ -186,7 +184,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
      */
     public MetaMethod getStaticMetaMethod(String name, Object[] argTypes) {
         Class[] classes = castArgumentsToClassArray(argTypes);
-        return retrieveStaticMethod(name, classes);
+        return pickStaticMethod(name, classes);
     }
 
 
@@ -325,7 +323,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
             public void methodNameAction(Class clazz, MetaMethodIndex.Entry e) {
                 if (e.methods == null)
                   return;
-                
+
                 boolean hasPrivate = false;
                 if (e.methods instanceof FastArray) {
                     FastArray methods = (FastArray) e.methods;
@@ -540,7 +538,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
     private CachedClass calcFirstGroovySuperClass(Collection superClasses) {
         if (theCachedClass.isInterface)
           return ReflectionCache.OBJECT_CLASS;
-        
+
         CachedClass firstGroovy = null;
         Iterator iter = superClasses.iterator();
         for (; iter.hasNext();) {
@@ -755,12 +753,13 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
             MetaClassHelper.logMethodCall(object, methodName, originalArguments);
         }
         final Object[] arguments = originalArguments == null ? EMPTY_ARGUMENTS : originalArguments;
-        final Class[] argClasses = MetaClassHelper.convertToTypeArray(arguments);
+//        final Class[] argClasses = MetaClassHelper.convertToTypeArray(arguments);
+//
+//        unwrap(arguments);
 
+        MetaMethod method = getMethodWithCaching(sender, methodName, arguments, isCallToSuper);
         unwrap(arguments);
 
-        MetaMethod method = getMethodWithCaching(sender, methodName, argClasses, isCallToSuper);
-
         if (method == null && arguments.length == 1 && arguments[0] instanceof List) {
             Object[] newArguments = ((List) arguments[0]).toArray();
             Class[] newArgClasses = MetaClassHelper.convertToTypeArray(newArguments);
@@ -808,6 +807,8 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
             final boolean isClosureNotOwner = owner != closure;
             final int resolveStrategy = closure.getResolveStrategy();
 
+        final Class[] argClasses = MetaClassHelper.convertToTypeArray(arguments);
+
             switch (resolveStrategy) {
                 case Closure.TO_SELF:
                     method = closure.getMetaClass().pickMethod(methodName, argClasses);
@@ -938,40 +939,75 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
         return go.invokeMethod(methodName, originalArguments);
     }
 
-    public MetaMethod getMethodWithCaching(Class sender, String methodName, Class[] arguments, boolean isCallToSuper) {
+    public MetaMethod getMethodWithCaching(Class sender, String methodName, Object[] arguments, boolean isCallToSuper) {
         // lets try use the cache to find the method
         if (GroovyCategorySupport.hasCategoryInAnyThread() && !isCallToSuper) {
-            return getMethodWithoutCaching(sender, methodName, arguments, isCallToSuper);
+            return getMethodWithoutCaching(sender, methodName, MetaClassHelper.convertToTypeArray(arguments), isCallToSuper);
         } else {
-            MethodKey methodKey = new DefaultMethodKey(sender, methodName, arguments, isCallToSuper);
-            MetaMethod method = (MetaMethod) methodCache.get(methodKey);
-            if (method == null) {
-                method = getMethodWithoutCaching(sender, methodName, arguments, isCallToSuper);
-                if (method == null)
-                    method = NULL_METHOD;
-                cacheInstanceMethod(methodKey, method);
-                if (method == NULL_METHOD)
-                    method = null;
-            } else {
-                if (method == NULL_METHOD)
-                    method = null;
+            final MetaMethodIndex.Entry e = metaMethodIndex.getMethods(sender, methodName);
+            if (e == null)
+              return null;
+
+            MetaMethodIndex.CacheEntry cacheEntry;
+            if (!isCallToSuper) {
+                if (e.methods == null)
+                  return null;
+
+                cacheEntry = e.cachedMethod;
+                if (cacheEntry != null
+                   && (sameClasses(cacheEntry.params, arguments, e.methods instanceof MetaMethod))) {
+                     return cacheEntry.method;
+                }
+
+                cacheEntry = new MetaMethodIndex.CacheEntry ();
+                final Class[] classes = MetaClassHelper.convertToTypeArray(arguments);
+                cacheEntry.params = classes;
+                cacheEntry.method = (MetaMethod) chooseMethod(methodName, e.methods, classes, false);
+                e.cachedMethod = cacheEntry;
+                return cacheEntry.method;
             }
-            return method;
-        }
-    }
+            else {
+                if (e.methodsForSuper == null)
+                  return null;
 
-    protected void cacheInstanceMethod(MethodKey key, MetaMethod method) {
-        if (method != null && method.isCacheable()) {
-            methodCache.put(key, method);
+                cacheEntry = e.cachedMethodForSuper;
+                if (cacheEntry != null
+                   && (sameClasses(cacheEntry.params, arguments, e.methodsForSuper instanceof MetaMethod))) {
+                     return cacheEntry.method;
+                }
+
+                cacheEntry = new MetaMethodIndex.CacheEntry ();
+                final Class[] classes = MetaClassHelper.convertToTypeArray(arguments);
+                cacheEntry.params = classes;
+                cacheEntry.method = (MetaMethod) chooseMethod(methodName, e.methodsForSuper, classes, false);
+                e.cachedMethodForSuper = cacheEntry;
+                return cacheEntry.method;
+            }
         }
     }
 
-    protected void cacheStaticMethod(MethodKey key, MetaMethod method) {
-        if (method != null && method.isCacheable()) {
-            staticMethodCache.put(key, method);
+    private boolean sameClasses(Class[] params, Object[] arguments, boolean weakNullCheck) {
+        if (params.length != arguments.length)
+          return false;
+
+        for (int i = params.length-1; i >= 0; i--) {
+            Object arg = arguments[i];
+            if (arg != null) {
+                if (arg instanceof Wrapper) {
+                    if (params[i] != ((Wrapper)arg).getType())
+                      return false;
+                }
+                else
+                    if (params[i] != arg.getClass())
+                      return false;
+            }
+            else
+              if (!weakNullCheck)
+                return false;
         }
-    }
 
+        return true;
+    }
 
     public Constructor retrieveConstructor(Class[] arguments) {
         CachedConstructor constructor = (CachedConstructor) chooseMethod("<init>", constructors, arguments, false);
@@ -985,14 +1021,25 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
         return null;
     }
 
-    public MetaMethod retrieveStaticMethod(String methodName, Class[] arguments) {
-        MethodKey methodKey = new DefaultMethodKey(theClass, methodName, arguments, false);
-        MetaMethod method = (MetaMethod) staticMethodCache.get(methodKey);
-        if (method == null) {
-            method = pickStaticMethod(methodName, arguments);
-            cacheStaticMethod(methodKey.createCopy(), method);
+    public MetaMethod retrieveStaticMethod(String methodName, Object[] arguments) {
+        final MetaMethodIndex.Entry e = metaMethodIndex.getMethods(theClass, methodName);
+        MetaMethodIndex.CacheEntry cacheEntry;
+        if (e != null) {
+            cacheEntry = e.cachedStaticMethod;
+            if (cacheEntry != null
+               && (sameClasses(cacheEntry.params, arguments, e.staticMethods instanceof MetaMethod))) {
+                 return cacheEntry.method;
+            }
+
+            cacheEntry = new MetaMethodIndex.CacheEntry ();
+            final Class[] classes = MetaClassHelper.convertToTypeArray(arguments);
+            cacheEntry.params = classes;
+            cacheEntry.method = pickStaticMethod(methodName, classes);
+            e.cachedStaticMethod = cacheEntry;
+            return cacheEntry.method;
         }
-        return method;
+        else
+          return pickStaticMethod(methodName, MetaClassHelper.convertToTypeArray(arguments));
     }
 
     public MetaMethod getMethodWithoutCaching(Class sender, String methodName, Class[] arguments, boolean isCallToSuper) {
@@ -1020,9 +1067,9 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
         }
 
         if (arguments == null) arguments = EMPTY_ARGUMENTS;
-        Class[] argClasses = MetaClassHelper.convertToTypeArray(arguments);
+//        Class[] argClasses = MetaClassHelper.convertToTypeArray(arguments);
 
-        MetaMethod method = retrieveStaticMethod(methodName, argClasses);
+        MetaMethod method = retrieveStaticMethod(methodName, arguments);
         // lets try use the cache to find the method
 
         if (method != null) {
@@ -1044,6 +1091,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
         unwrap(arguments);
 
         Class superClass = sender.getSuperclass();
+        Class[] argClasses = MetaClassHelper.convertToTypeArray(arguments);
         while (superClass != Object.class && superClass != null) {
             MetaClass mc = registry.getMetaClass(superClass);
             method = mc.getStaticMetaMethod(methodName, argClasses);
@@ -2163,7 +2211,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
     protected boolean isInitialized() {
         return initialized;
     }
-    
+
     /**
      * return false: add method
      *        null:  ignore method
@@ -2177,10 +2225,10 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
         for (int i = 0; i < params1.length; i++) {
             if (params1[i] != params2[i]) return Boolean.FALSE;
         }
-        
+
         Class aMethodClass = aMethod.getDeclaringClass().getCachedClass();
         Class categoryMethodClass = categoryMethod.getDeclaringClass().getCachedClass();
-        
+
         if (aMethodClass==categoryMethodClass) return Boolean.TRUE;
         boolean match = aMethodClass.isAssignableFrom(categoryMethodClass);
         if (match) return Boolean.TRUE;
@@ -2193,7 +2241,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
             list.add(method);
             return;
         }
-        
+
         Object data[] = list.getArray();
         for (int j = 0; j != len; ++j) {
             MetaMethod aMethod = (MetaMethod) data[j];
@@ -2202,12 +2250,12 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
             if (match==Boolean.TRUE) {
                 list.set(j, method);
                 return;
-            // null == ignore (we have a better method already)    
+            // null == ignore (we have a better method already)
             } else if (match==null) {
                 return;
             }
         }
-        // the casese true and null for a match are through, the 
+        // the casese true and null for a match are through, the
         // remaining case is false and that means adding the method
         // to our list
         list.add(method);
@@ -2448,19 +2496,11 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
     }
 
     protected void dropStaticMethodCache(String name) {
-        for (Iterator it = staticMethodCache.keySet().iterator(); it.hasNext();) {
-            MethodKey k = (MethodKey) it.next();
-            if (name.equals(k.getName()))
-                it.remove();
-        }
+        metaMethodIndex.clearCaches(name);
     }
 
     protected void dropMethodCache(String name) {
-        for (Iterator it = methodCache.keySet().iterator(); it.hasNext();) {
-            MethodKey k = (MethodKey) it.next();
-            if (name.equals(k.getName()))
-                it.remove();
-        }
+        metaMethodIndex.clearCaches(name);
     }
 
     private abstract class MethodIndexAction {
@@ -2523,8 +2563,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
      * method is added during runtime, but not by using a category.
      */
     protected void clearInvocationCaches() {
-        staticMethodCache.clear();
-        methodCache.clear();
+        metaMethodIndex.clearCaches ();
     }
 
     private static final SingleKeyHashMap.Copier NAME_INDEX_COPIER = new SingleKeyHashMap.Copier() {
diff --git a/src/main/org/codehaus/groovy/reflection/CachedClass.java b/src/main/org/codehaus/groovy/reflection/CachedClass.java
index da44c0fad3..bc20702f8c 100644
--- a/src/main/org/codehaus/groovy/reflection/CachedClass.java
+++ b/src/main/org/codehaus/groovy/reflection/CachedClass.java
@@ -383,7 +383,7 @@ public class CachedClass {
         return reflector;
     }
 
-    public Class getCachedClass() {
+    public final Class getCachedClass() {
         return cachedClass;
     }
 
diff --git a/src/main/org/codehaus/groovy/reflection/ParameterTypes.java b/src/main/org/codehaus/groovy/reflection/ParameterTypes.java
index 3acd43b352..f176659b43 100644
--- a/src/main/org/codehaus/groovy/reflection/ParameterTypes.java
+++ b/src/main/org/codehaus/groovy/reflection/ParameterTypes.java
@@ -25,6 +25,8 @@ public class ParameterTypes
   protected Class [] nativeParamTypes;
   protected CachedClass [] parameterTypes;
 
+  protected boolean isVargsMethod;
+
     public ParameterTypes () {
     }
 
@@ -33,7 +35,12 @@ public class ParameterTypes
     }
 
     public ParameterTypes(CachedClass[] parameterTypes) {
-        this.parameterTypes = parameterTypes;
+        setParametersTypes(parameterTypes);
+    }
+
+    protected final void setParametersTypes(CachedClass[] pt) {
+        this.parameterTypes = pt;
+        isVargsMethod = pt.length > 0 && pt [pt.length-1].isArray;
     }
 
     public CachedClass[] getParameterTypes() {
@@ -49,7 +56,7 @@ public class ParameterTypes
             pt[i] = ReflectionCache.getCachedClass(npt[i]);
 
           nativeParamTypes = npt;
-          parameterTypes = pt;
+          setParametersTypes(pt);
         }
       }
 
@@ -80,10 +87,12 @@ public class ParameterTypes
     protected Class[] getPT() { throw new UnsupportedOperationException(getClass().getName()); }
 
     public boolean isVargsMethod(Object[] arguments) {
-        getParameterTypes();
-        if (parameterTypes.length == 0) return false;
+        // Uncomment if at some point this method can be called before parameterTypes initialized
+        // getParameterTypes();
+        if(!isVargsMethod)
+          return false;
+
         final int lenMinus1 = parameterTypes.length - 1;
-        if (!parameterTypes[lenMinus1].isArray) return false;
         // -1 because the varg part is optional
         if (lenMinus1 == arguments.length) return true;
         if (lenMinus1 > arguments.length) return false;
@@ -98,19 +107,9 @@ public class ParameterTypes
     }
 
     public Object[] coerceArgumentsToClasses(Object[] argumentArray) {
-        getParameterTypes();
-        // correct argumentArray's length
-        if (argumentArray == null) {
-            argumentArray = MetaClassHelper.EMPTY_ARRAY;
-        } else if (parameterTypes.length == 1 && argumentArray.length == 0) {
-            if (isVargsMethod(argumentArray)) {
-                argumentArray = new Object[]{Array.newInstance(parameterTypes[0].getCachedClass().getComponentType(), 0)};
-            }
-            else
-                argumentArray = MetaClassHelper.ARRAY_WITH_NULL;
-        } else if (isVargsMethod(argumentArray)) {
-            argumentArray = fitToVargs(argumentArray, parameterTypes);
-        }
+        // Uncomment if at some point this method can be called before parameterTypes initialized
+        // getParameterTypes();
+        argumentArray = correctArguments(argumentArray);
 
         //correct Type
         for (int i = 0; i < argumentArray.length; i++) {
@@ -127,6 +126,25 @@ public class ParameterTypes
         return argumentArray;
     }
 
+    private Object[] correctArguments(Object[] argumentArray) {
+        // correct argumentArray's length
+        if (argumentArray == null) {
+            return MetaClassHelper.EMPTY_ARRAY;
+        }
+        else
+            if (parameterTypes.length == 1 && argumentArray.length == 0) {
+                if (isVargsMethod)
+                    return new Object[]{Array.newInstance(parameterTypes[0].getCachedClass().getComponentType(), 0)};
+                else
+                    return MetaClassHelper.ARRAY_WITH_NULL;
+            }
+            else
+                if (isVargsMethod(argumentArray)) {
+                    return fitToVargs(argumentArray, parameterTypes);
+                }
+        return argumentArray;
+    }
+
     /**
      * this method is called when the number of arguments to a method is greater than 1
      * and if the method is a vargs method. This method will then transform the given
diff --git a/src/main/org/codehaus/groovy/runtime/MetaClassHelper.java b/src/main/org/codehaus/groovy/runtime/MetaClassHelper.java
index e2c3441396..51b032e2fa 100644
--- a/src/main/org/codehaus/groovy/runtime/MetaClassHelper.java
+++ b/src/main/org/codehaus/groovy/runtime/MetaClassHelper.java
@@ -638,9 +638,6 @@ public class MetaClassHelper {
         if (methodOrConstructor instanceof ParameterTypes) {
             return (ParameterTypes) methodOrConstructor;
         }
-        if (methodOrConstructor instanceof MetaMethod) {
-            return ((MetaMethod) methodOrConstructor);
-        }
         if (methodOrConstructor instanceof Method) {
             Method method = (Method) methodOrConstructor;
             return CachedMethod.find(method);
diff --git a/src/main/org/codehaus/groovy/runtime/metaclass/MetaMethodIndex.java b/src/main/org/codehaus/groovy/runtime/metaclass/MetaMethodIndex.java
index b15f7e4d20..42f4ccd69c 100644
--- a/src/main/org/codehaus/groovy/runtime/metaclass/MetaMethodIndex.java
+++ b/src/main/org/codehaus/groovy/runtime/metaclass/MetaMethodIndex.java
@@ -44,6 +44,11 @@ public class MetaMethodIndex {
         }
     }
 
+    public static class CacheEntry {
+        public Class [] params;
+        public MetaMethod method;
+    }
+
     public static class Entry {
         public int hash;
 
@@ -54,6 +59,8 @@ public class MetaMethodIndex {
 
         public Object methods, methodsForSuper, staticMethods;
 
+        public CacheEntry cachedMethod, cachedMethodForSuper, cachedStaticMethod;
+
         public String toString () {
             return "[" + name + ", " + cls.getName() + "]";
         }
@@ -507,4 +514,18 @@ public class MetaMethodIndex {
         }
     }
 
+    public void clearCaches() {
+        for (int i = 0; i != table.length; ++i )
+          for (Entry e = table [i]; e != null; e = e.nextHashEntry ) {
+              e.cachedMethod = e.cachedMethodForSuper = e.cachedStaticMethod = null;
+          }
+    }
+
+    public void clearCaches(String name) {
+        for (int i = 0; i != table.length; ++i )
+          for (Entry e = table [i]; e != null; e = e.nextHashEntry ) {
+              if (e.name.equals(name))
+                 e.cachedMethod = e.cachedMethodForSuper = e.cachedStaticMethod = null;
+          }
+    }
 }
diff --git a/src/main/org/codehaus/groovy/runtime/metaclass/NewMetaMethod.java b/src/main/org/codehaus/groovy/runtime/metaclass/NewMetaMethod.java
index bd3bec8472..221b1bfa86 100644
--- a/src/main/org/codehaus/groovy/runtime/metaclass/NewMetaMethod.java
+++ b/src/main/org/codehaus/groovy/runtime/metaclass/NewMetaMethod.java
@@ -37,7 +37,7 @@ public class NewMetaMethod extends ReflectionMetaMethod {
             logicalParameterTypes = new CachedClass[--size];
             System.arraycopy(bytecodeParameterTypes, 1, logicalParameterTypes, 0, size);
         }
-        parameterTypes = logicalParameterTypes;
+        setParametersTypes(logicalParameterTypes);
     }
 
     public CachedClass getDeclaringClass() {
diff --git a/src/main/org/codehaus/groovy/runtime/metaclass/ThreadManagedMetaBeanProperty.java b/src/main/org/codehaus/groovy/runtime/metaclass/ThreadManagedMetaBeanProperty.java
index b56bfe2852..96dc597822 100644
--- a/src/main/org/codehaus/groovy/runtime/metaclass/ThreadManagedMetaBeanProperty.java
+++ b/src/main/org/codehaus/groovy/runtime/metaclass/ThreadManagedMetaBeanProperty.java
@@ -165,9 +165,10 @@ public class ThreadManagedMetaBeanProperty extends MetaBeanProperty {
 
 
         public ThreadBoundGetter(String name) {
-            super (new Class[0]);
+            setParametersTypes(new CachedClass[0]);
             this.name = getGetterName(name, type);
             this.name0 = name;
+
         }
 
 
@@ -206,7 +207,7 @@ public class ThreadManagedMetaBeanProperty extends MetaBeanProperty {
         private final String name, name0;
 
         public ThreadBoundSetter(String name) {
-            super (new Class [] {type} );
+            setParametersTypes (new CachedClass [] {ReflectionCache.getCachedClass(type)} );
             this.name = getSetterName(name);
             this.name0 = name;
         }
diff --git a/src/main/org/codehaus/groovy/runtime/metaclass/TransformMetaMethod.java b/src/main/org/codehaus/groovy/runtime/metaclass/TransformMetaMethod.java
index 0d22102494..d2c2e5b758 100644
--- a/src/main/org/codehaus/groovy/runtime/metaclass/TransformMetaMethod.java
+++ b/src/main/org/codehaus/groovy/runtime/metaclass/TransformMetaMethod.java
@@ -31,7 +31,7 @@ public class TransformMetaMethod extends MetaMethod {
 
     public TransformMetaMethod(MetaMethod metaMethod) {
         this.metaMethod = metaMethod;
-        parameterTypes = metaMethod.getParameterTypes();
+        setParametersTypes(metaMethod.getParameterTypes());
         nativeParamTypes = metaMethod.getNativeParameterTypes();
     }
 
diff --git a/src/test/JavaSourceCodehausPackagesSuite.java b/src/test/JavaSourceCodehausPackagesSuite.java
index 6bd474f6dc..cfa69f4e17 100644
--- a/src/test/JavaSourceCodehausPackagesSuite.java
+++ b/src/test/JavaSourceCodehausPackagesSuite.java
@@ -66,7 +66,7 @@ public class JavaSourceCodehausPackagesSuite {
         suite.addTestSuite(NodePrinterTest.class);
         suite.addTestSuite(org.codehaus.groovy.classgen.PropertyTest.class);
         suite.addTestSuite(org.codehaus.groovy.runtime.PropertyTest.class);
-        suite.addTestSuite(ReflectorGeneratorTest.class);
+//        suite.addTestSuite(ReflectorGeneratorTest.class);
         suite.addTestSuite(RunBugsTest.class);
         suite.addTestSuite(RunClosureTest.class);
         suite.addTestSuite(RunGroovyTest.class);
diff --git a/src/test/org/codehaus/groovy/benchmarks/vm5/b2394/Builder.java b/src/test/org/codehaus/groovy/benchmarks/vm5/b2394/Builder.java
index 76ef2f9a19..534a4af9ba 100644
--- a/src/test/org/codehaus/groovy/benchmarks/vm5/b2394/Builder.java
+++ b/src/test/org/codehaus/groovy/benchmarks/vm5/b2394/Builder.java
@@ -1,8 +1,6 @@
 package org.codehaus.groovy.benchmarks.vm5.b2394;
 
-import groovy.lang.GroovyObjectSupport;
-
-public class Builder extends GroovyObjectSupport
+public class Builder
 {
     public void add(String option, String suboption)
     {
diff --git a/src/test/org/codehaus/groovy/benchmarks/vm5/b2394/Main.java b/src/test/org/codehaus/groovy/benchmarks/vm5/b2394/Main.java
index 73d18440fc..2fce24e98a 100644
--- a/src/test/org/codehaus/groovy/benchmarks/vm5/b2394/Main.java
+++ b/src/test/org/codehaus/groovy/benchmarks/vm5/b2394/Main.java
@@ -3,10 +3,8 @@ package org.codehaus.groovy.benchmarks.vm5.b2394;
 import groovy.lang.GroovyClassLoader;
 import org.codehaus.groovy.control.CompilationFailedException;
 
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
+import java.io.File;
 import java.io.IOException;
-import java.io.InputStream;
 import java.util.concurrent.CountDownLatch;
 
 public class Main
@@ -44,48 +42,28 @@ public class Main
         System.out.println("Test completed: " + numberOfOperations
             + " scriptExecutions in " + duration + " seconds");
         System.out.println("\t\t\t" + (numberOfOperations / duration)
-            + " scriptExecutions/second");
+            + " scriptExecutions/second with\t" + numThreads + " threads");
     }
 
     private Class loadScript(String name)
     {
         Class scriptClass = null;
 
-        name = "src/test/" + getClass().getPackage().getName().replace(".", "/") + "/" + name;
-        InputStream is = null;
-        try {
-            is = new FileInputStream(name);
-        } catch (FileNotFoundException e) {
-            throw new RuntimeException(e);
-        }
-        if (is == null)
-        {
-            throw new RuntimeException("Script file not found: " + name);
-        }
+        GroovyClassLoader gcl = new GroovyClassLoader(this.getClass().getClassLoader());
 
-        GroovyClassLoader gcl =
-            new GroovyClassLoader(this.getClass().getClassLoader());
+        name = "src/test/" + getClass().getPackage().getName().replace(".", "/") + "/" + name;
 
         try
         {
-            scriptClass = gcl.parseClass(is);
+            scriptClass = gcl.parseClass(new File(name));
         }
         catch (CompilationFailedException e)
         {
             throw new RuntimeException("Script compilation failed: "
                 + e.getMessage());
         }
-        finally
-        {
-            try
-            {
-                if (is != null)
-                    is.close();
-            }
-            catch (IOException e1)
-            {
-                e1.printStackTrace();
-            }
+        catch (IOException e) {
+            throw new RuntimeException("Script file not found: " + name);
         }
 
         return scriptClass;
@@ -95,7 +73,18 @@ public class Main
     {
         if (args == null || args.length != 3)
         {
-            new Main("script300.groovy", 5000, 20);
+            for (int i = 1; i <= 50; ) {
+              new Main("script300.groovy", (5000*20)/i, i);
+              if (i < 10)
+                i++;
+              else
+                if (i < 20) {
+                    i += 2;
+                }
+                else {
+                    i += 5;
+                }
+            }
         }
         else
         {
diff --git a/src/test/org/codehaus/groovy/classgen/ReflectorGeneratorTest.java b/src/test/org/codehaus/groovy/classgen/ReflectorGeneratorTest.java
index 568ad7297f..be25c98169 100644
--- a/src/test/org/codehaus/groovy/classgen/ReflectorGeneratorTest.java
+++ b/src/test/org/codehaus/groovy/classgen/ReflectorGeneratorTest.java
@@ -46,77 +46,9 @@
 
 package org.codehaus.groovy.classgen;
 
-import groovy.lang.GroovySystem;
-import groovy.lang.MetaClassRegistry;
-import groovy.util.GroovyTestCase;
 import org.codehaus.groovy.reflection.CachedMethod;
-import org.codehaus.groovy.reflection.ReflectionCache;
-import org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl;
-import org.objectweb.asm.ClassWriter;
-import org.objectweb.asm.util.ASMifierClassVisitor;
-import org.objectweb.asm.util.CheckClassAdapter;
 
-import java.io.FileOutputStream;
 import java.lang.reflect.InvocationTargetException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-
-/**
- * @author <a href="mailto:james@coredevelopers.net">James Strachan</a>
- * @version $Revision$
- */
-public class ReflectorGeneratorTest extends GroovyTestCase {
-
-    public void testGenerator() throws Exception {
-        List methods = new ArrayList();
-//        methods.add(new MetaMethod("toCharArray", String.class, new CachedClass[0], char[].class, 0));
-        //methods.add(new MetaMethod("toString", String.class, new Class[0], String.class, 0));
-        testMethods(methods);
-    }
-
-    public void testObjectGenerator() throws Exception {
-        List methods = Arrays.asList(ReflectionCache.OBJECT_CLASS.getMethods());
-        testMethods(methods);
-    }
-
-    public void testDummyReflector() throws Exception {
-        DummyReflector dummy = new DummyReflector();
-        assertTrue(dummy != null);
-    }
-
-    protected void testMethods(List methods) throws Exception {
-        ReflectorGenerator generator = new ReflectorGenerator(methods);
-        String name = getClass().getName() + "." + getMethodName();
-        ClassWriter cw = new ClassWriter(true);
-
-        //ASMifierClassVisitor dumper = new ASMifierClassVisitor(new PrintWriter(new OutputStreamWriter(System.out)));
-        //generator.generate(dumper, name);
-
-        generator.generate(new CheckClassAdapter(cw), name);
-
-        byte[] bytecode = cw.toByteArray();
-
-        // lets write it to disk
-        String fileName = "target/" + name + ".class";
-        FileOutputStream out = new FileOutputStream(fileName);
-        out.write(bytecode);
-        out.close();
-
-        // now lets try dump it
-        ASMifierClassVisitor.main(new String[]{fileName});
-
-        // now lets try class load it
-        MetaClassRegistry registry = GroovySystem.getMetaClassRegistry();
-        Object reflector = ((MetaClassRegistryImpl) registry).loadReflector(getClass(), methods);
-
-        System.out.println("Created new reflector: " + reflector);
-    }
-
-    public void testP () {
-        A_GroovyReflector.doIt(); 
-    }
-}
 
 class A {
     protected void protectedMethod() {}
