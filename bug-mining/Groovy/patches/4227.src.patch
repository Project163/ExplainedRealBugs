diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 837e9e266e..3d051da21b 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -3674,6 +3674,8 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             }
         }
 
+        if (methodReferenceParamIndexList.isEmpty()) return; // GROOVY-10269
+
         visitMethodCallArguments(receiver, args(newArgumentExpressionList), true, selectedMethod);
 
         for (int index : methodReferenceParamIndexList) {
diff --git a/src/test/groovy/transform/stc/MethodReferenceTest.groovy b/src/test/groovy/transform/stc/MethodReferenceTest.groovy
index 89661aa43b..a5ad7aa404 100644
--- a/src/test/groovy/transform/stc/MethodReferenceTest.groovy
+++ b/src/test/groovy/transform/stc/MethodReferenceTest.groovy
@@ -626,4 +626,22 @@ final class MethodReferenceTest {
 
         assert err.message.contains('Failed to find the expected method[toLowerCaseX(java.lang.String)] in the type[java.lang.String]')
     }
+
+    @Test // GROOVY-10269
+    void testNotFunctionalInterface() {
+        def err = shouldFail shell, '''
+            void foo(Integer y) {
+            }
+            void bar(Consumer<Integer> x) {
+            }
+            @CompileStatic
+            void test() {
+                bar(this::foo)
+                def baz = { Consumer<Integer> x -> }
+                baz(this::foo) // not yet supported!
+            }
+        '''
+
+        assert err =~ /The argument is a method reference, but the parameter type is not a functional interface/
+    }
 }
