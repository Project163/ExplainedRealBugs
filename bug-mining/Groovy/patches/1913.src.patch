diff --git a/src/main/org/codehaus/groovy/transform/stc/SecondPassExpression.java b/src/main/org/codehaus/groovy/transform/stc/SecondPassExpression.java
new file mode 100644
index 0000000000..92c96db8ba
--- /dev/null
+++ b/src/main/org/codehaus/groovy/transform/stc/SecondPassExpression.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright 2003-2012 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.codehaus.groovy.transform.stc;
+
+import org.codehaus.groovy.ast.expr.Expression;
+
+/**
+ * An utility class used to wrap an expression with additional metadata used by the type checker.
+ * In particular, this is used to detect closure shared variables misuses. We need in some circumstances
+ * to store the method call expression and its argument types.
+ *
+ * @author Cedric Champeau
+ */
+class SecondPassExpression<T> {
+    private final Expression expression;
+    private final T data;
+
+    SecondPassExpression(final Expression expression) {
+        this.expression = expression;
+        this.data = null;
+    }
+
+    SecondPassExpression(final Expression expression, final T data) {
+        this.data = data;
+        this.expression = expression;
+    }
+
+    public T getData() {
+        return data;
+    }
+
+    public Expression getExpression() {
+        return expression;
+    }
+
+    @Override
+    public boolean equals(final Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+
+        final SecondPassExpression that = (SecondPassExpression) o;
+
+        if (data != null ? !data.equals(that.data) : that.data != null) return false;
+        if (!expression.equals(that.expression)) return false;
+
+        return true;
+    }
+
+    @Override
+    public int hashCode() {
+        int result = expression.hashCode();
+        result = 31 * result + (data != null ? data.hashCode() : 0);
+        return result;
+    }
+}
diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
index 55c2a80275..bd03150bff 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
@@ -190,6 +190,7 @@ public abstract class StaticTypeCheckingSupport {
             params = Parameter.EMPTY_ARRAY;
         }
         int dist = 0;
+        if (args.length<params.length) return -1;
         // we already know the lengths are equal
         for (int i = 0; i < params.length; i++) {
             ClassNode paramType = params[i].getType();
diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index cfe3de8edf..c075ec2372 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -20,6 +20,7 @@ import groovy.lang.IntRange;
 import groovy.lang.ObjectRange;
 import groovy.transform.TypeChecked;
 import groovy.transform.TypeCheckingMode;
+import org.codehaus.groovy.GroovyBugError;
 import org.codehaus.groovy.ast.*;
 import org.codehaus.groovy.ast.expr.*;
 import org.codehaus.groovy.ast.stmt.*;
@@ -126,7 +127,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
      * is assigned to a closure shared variable, then a second pass to ensure that every method call on
      * such a variable is made on a LUB.
      */
-    private final LinkedHashSet<Expression> secondPassExpressions = new LinkedHashSet<Expression>();
+    private final LinkedHashSet<SecondPassExpression> secondPassExpressions = new LinkedHashSet<SecondPassExpression>();
 
     /**
      * A map used to store every type used in closure shared variable assignments. In a second pass, we will
@@ -1809,7 +1810,13 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                         // if the object expression is a closure shared variable, we will have to perform a second pass
                         if (objectExpression instanceof VariableExpression) {
                             VariableExpression var = (VariableExpression) objectExpression;
-                            if (var.isClosureSharedVariable()) secondPassExpressions.add(call);
+                            if (var.isClosureSharedVariable()) {
+                                SecondPassExpression<ClassNode[]> wrapper = new SecondPassExpression<ClassNode[]>(
+                                        call,
+                                        args
+                                );
+                                secondPassExpressions.add(wrapper);
+                            }
                         }
 
                     } else {
@@ -2903,7 +2910,8 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
     }
 
     public void performSecondPass() {
-        for (Expression expression : secondPassExpressions) {
+        for (SecondPassExpression wrapper : secondPassExpressions) {
+            Expression expression = wrapper.getExpression();
             if (expression instanceof MethodCallExpression) {
                 MethodCallExpression call = (MethodCallExpression) expression;
                 Expression objectExpression = call.getObjectExpression();
@@ -2919,8 +2927,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                             // we must check that such a method exists on the LUB
                             Parameter[] parameters = methodNode.getParameters();
                             ClassNode[] params = extractTypesFromParameters(parameters);
-                            ArgumentListExpression argumentList = InvocationWriter.makeArgumentList(call.getArguments());
-                            ClassNode[] argTypes = getArgumentTypes(argumentList);
+                            ClassNode[] argTypes = (ClassNode[]) wrapper.getData();
                             List<MethodNode> method = findMethod(lub, methodNode.getName(), argTypes);
                             if (method.size() != 1) {
                                 addStaticTypeError("A closure shared variable [" + target.getName() + "] has been assigned with various types and the method" +
diff --git a/src/test/groovy/transform/stc/ClosuresSTCTest.groovy b/src/test/groovy/transform/stc/ClosuresSTCTest.groovy
index fc948ed50d..71c727b4f7 100644
--- a/src/test/groovy/transform/stc/ClosuresSTCTest.groovy
+++ b/src/test/groovy/transform/stc/ClosuresSTCTest.groovy
@@ -215,5 +215,25 @@ class ClosuresSTCTest extends StaticTypeCheckingTestCase {
         }
         '''
     }
+    // a case in Grails
+    void testShouldNotThrowClosureSharedVariableError2() {
+        assertScript '''
+            class AntPathMatcher {
+                boolean match(String x, String y) { true }
+            }
+            private String relativePath() { '' }
+            def foo() {
+                AntPathMatcher pathMatcher = new AntPathMatcher()
+                def relPath = relativePath()
+                def cl = { String it ->
+                    pathMatcher.match(it, relPath)
+                }
+                cl('foo')
+            }
+
+            foo()
+        '''
+    }
+
 }
 
