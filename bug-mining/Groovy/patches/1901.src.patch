diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
index b67f6d7cfe..5ffd69cd42 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
@@ -186,7 +186,9 @@ public abstract class StaticTypeCheckingSupport {
      * not of the exact type but still match
      */
     public static int allParametersAndArgumentsMatch(Parameter[] params, ClassNode[] args) {
-        if (params==null) return args.length==0?0:-1;
+        if (params==null) {
+            params = Parameter.EMPTY_ARRAY;
+        }
         int dist = 0;
         // we already know the lengths are equal
         for (int i = 0; i < params.length; i++) {
@@ -940,7 +942,9 @@ public abstract class StaticTypeCheckingSupport {
                     firstParamMatches = allParametersAndArgumentsMatch(firstParams, args) >= 0;
                 }
                 int lastArgMatch = isVargs(params) && firstParamMatches?lastArgMatchesVarg(params, args):-1;
-                if (lastArgMatch>=0) lastArgMatch++; // ensure exact matches are preferred over vargs
+                if (lastArgMatch>=0) {
+                    lastArgMatch+=((args.length-params.length)+1); // ensure exact matches are preferred over vargs
+                }
                 int dist = allPMatch>=0?Math.max(allPMatch, lastArgMatch):lastArgMatch;
                 if (dist>=0 && !actualReceiver.equals(declaringClass)) dist+=getDistance(actualReceiver, declaringClass);
                 if (dist>=0 && dist<bestDist) {
@@ -972,11 +976,11 @@ public abstract class StaticTypeCheckingSupport {
                         //      that case is handled above already
                         // (3) there is more than one argument for the vargs array
                         int dist = excessArgumentsMatchesVargsParameter(params, args);
-                        if (dist >= 0 && !actualReceiver.equals(declaringClass)) dist++;
+                        if (dist >= 0 && !actualReceiver.equals(declaringClass)) dist+=getDistance(actualReceiver, declaringClass);
                         // varargs methods must not be preferred to methods without varargs
                         // for example :
                         // int sum(int x) should be preferred to int sum(int x, int... y)
-                        dist++;
+                        dist+=((args.length-params.length)+1);
                         if (params.length < args.length && dist >= 0) {
                             if (dist >= 0 && dist < bestDist) {
                                 bestChoices.clear();
diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index d2dfa5603c..2f1027ba81 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -2232,7 +2232,22 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
     }
 
     private void addAmbiguousErrorMessage(final List<MethodNode> foundMethods, final String name, final ClassNode[] args, final Expression expr) {
-        addStaticTypeError("Reference to method is ambiguous. Cannot choose between " + foundMethods, expr);
+        addStaticTypeError("Reference to method is ambiguous. Cannot choose between " + prettyPrintMethodList(foundMethods), expr);
+    }
+
+    private static String prettyPrintMethodList(List<MethodNode> nodes) {
+        StringBuilder sb = new StringBuilder("[");
+        for (int i = 0, nodesSize = nodes.size(); i < nodesSize; i++) {
+            final MethodNode node = nodes.get(i);
+            sb.append(node.getReturnType().toString(false));
+            sb.append(" ");
+            sb.append(node.getDeclaringClass().toString(false));
+            sb.append("#");
+            sb.append(toMethodParametersString(node.getName(), extractTypesFromParameters(node.getParameters())));
+            if (i<nodesSize-1) sb.append(", ");
+        }
+        sb.append("]");
+        return sb.toString();
     }
 
     private void addCategoryMethodCallError(final Expression call) {
diff --git a/src/test/groovy/transform/stc/MethodCallsSTCTest.groovy b/src/test/groovy/transform/stc/MethodCallsSTCTest.groovy
index dd3c417280..f7495611a0 100644
--- a/src/test/groovy/transform/stc/MethodCallsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/MethodCallsSTCTest.groovy
@@ -765,6 +765,44 @@ class MethodCallsSTCTest extends StaticTypeCheckingTestCase {
                 'The spread operator cannot be used as argument of method or closure calls with static type checking because the number of arguments cannot be determined at compile time'
     }
 
+    void testBoxingShouldCostMore() {
+        assertScript '''
+            int foo(int x) { 1 }
+            int foo(Integer x) { 2 }
+            int bar() {
+                foo(1)
+            }
+            assert bar() == 1
+        '''
+    }
+
+    // GROOVY-5645
+    void testSuperCallWithVargs() {
+        assertScript '''
+            class Base {
+                int foo(int x, Object... args) { 1 }
+                int foo(Object... args) { 2 }
+            }
+            class Child extends Base {
+                void bar() {
+                    assert foo(1, 'a') == 1
+                    super.foo(1, 'a') == 1
+                }
+            }
+            new Child().bar()
+        '''
+    }
+
+    void testVargsSelection() {
+        assertScript '''
+            int foo(int x, Object... args) { 1 }
+            int foo(Object... args) { 2 }
+            assert foo(1) == 1
+            assert foo() == 2
+            assert foo(1,2) == 1
+        '''
+    }
+
     static class MyMethodCallTestClass {
 
         static int mul(int... args) { args.toList().inject(1) { x,y -> x*y } }
