diff --git a/src/main/org/codehaus/groovy/transform/ASTTransformationCollectorCodeVisitor.java b/src/main/org/codehaus/groovy/transform/ASTTransformationCollectorCodeVisitor.java
index 2926bf2bc2..4ee434a7b2 100644
--- a/src/main/org/codehaus/groovy/transform/ASTTransformationCollectorCodeVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/ASTTransformationCollectorCodeVisitor.java
@@ -28,6 +28,9 @@ import groovy.lang.GroovyClassLoader;
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
 
 /**
  * This visitor walks the AST tree and collects references to Annotations that
@@ -78,21 +81,15 @@ public class ASTTransformationCollectorCodeVisitor extends ClassCodeVisitorSuppo
             addTransformsToClassNode(annotation, transformClassAnnotation);
         }
     }
-    
+
     private void addTransformsToClassNode(AnnotationNode annotation, Annotation transformClassAnnotation) {
-        String[] transformClassNames = getTransformClassNames(transformClassAnnotation);
-        Class[] transformClasses = getTransformClasses(transformClassAnnotation);
+        List<String> transformClassNames = getTransformClassNames(annotation, transformClassAnnotation);
 
-        if(transformClassNames.length == 0 && transformClasses.length == 0) {
-            source.getErrorCollector().addError(new SimpleMessage("@GroovyASTTransformationClass in " + 
+        if(transformClassNames.isEmpty()) {
+            source.getErrorCollector().addError(new SimpleMessage("@GroovyASTTransformationClass in " +
                     annotation.getClassNode().getName() + " does not specify any transform class names/classes", source));
         }
 
-        if(transformClassNames.length > 0 && transformClasses.length > 0) {
-            source.getErrorCollector().addError(new SimpleMessage("@GroovyASTTransformationClass in " + 
-                    annotation.getClassNode().getName() +  " should specify transforms only by class names or by classes and not by both", source));
-        }
-
         for (String transformClass : transformClassNames) {
             try {
                 Class klass = transformLoader.loadClass(transformClass, false, true, false);
@@ -106,9 +103,6 @@ public class ASTTransformationCollectorCodeVisitor extends ClassCodeVisitorSuppo
                                 source));
             }
         }
-        for (Class klass : transformClasses) {
-            verifyAndAddTransform(annotation, klass);
-        }
     }
 
     private void verifyAndAddTransform(AnnotationNode annotation, Class klass) {
@@ -151,28 +145,34 @@ public class ASTTransformationCollectorCodeVisitor extends ClassCodeVisitorSuppo
             if (ann.annotationType().getName().equals(GroovyASTTransformationClass.class.getName())){
                 return ann;
             }
-        }  
+        }
 
         return null;
     }
 
-    private String[] getTransformClassNames(Annotation transformClassAnnotation) {
+    private List<String> getTransformClassNames(AnnotationNode annotation, Annotation transformClassAnnotation) {
+        List<String> result = new ArrayList<String>();
+
         try {
             Method valueMethod = transformClassAnnotation.getClass().getMethod("value");
-            return (String[]) valueMethod.invoke(transformClassAnnotation);
-        } catch (Exception e) {
-            source.addException(e);
-            return new String[0];
-        }
-    }
+            String[] names = (String[]) valueMethod.invoke(transformClassAnnotation);
+            result.addAll(Arrays.asList(names));
 
-    private Class[] getTransformClasses(Annotation transformClassAnnotation) {
-        try {
             Method classesMethod = transformClassAnnotation.getClass().getMethod("classes");
-            return (Class[]) classesMethod.invoke(transformClassAnnotation);
+            Class[] classes = (Class[]) classesMethod.invoke(transformClassAnnotation);
+            for (Class klass : classes) {
+                result.add(klass.getName());
+            }
+
+            if(names.length > 0 && classes.length > 0) {
+                source.getErrorCollector().addError(new SimpleMessage("@GroovyASTTransformationClass in " +
+                        annotation.getClassNode().getName() +
+                        " should specify transforms only by class names or by classes and not by both", source));
+            }
         } catch (Exception e) {
             source.addException(e);
-            return new Class[0];
         }
+
+        return result;
     }
 }
diff --git a/src/test/org/codehaus/groovy/transform/GlobalTestTransformClassLoader.groovy b/src/test/org/codehaus/groovy/transform/GlobalTestTransformClassLoader.groovy
new file mode 100644
index 0000000000..0390cd10a7
--- /dev/null
+++ b/src/test/org/codehaus/groovy/transform/GlobalTestTransformClassLoader.groovy
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2012 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.codehaus.groovy.transform
+
+class GlobalTestTransformClassLoader extends GroovyClassLoader {
+    private final String transformDescriptor
+
+    GlobalTestTransformClassLoader(ClassLoader parent, Class<?>... transformClasses) {
+        super(parent)
+        transformDescriptor = transformClasses*.name.join("\n")
+    }
+
+    Enumeration getResources(String name) {
+        if (name == "META-INF/services/org.codehaus.groovy.transform.ASTTransformation") {
+            return Collections.enumeration(Collections.singleton(new FakeURLFactory().createURL(transformDescriptor)))
+        }
+
+        super.getResources(name)
+    }
+}
\ No newline at end of file
diff --git a/src/test/org/codehaus/groovy/transform/TransformsAndCustomClassLoadersTest.groovy b/src/test/org/codehaus/groovy/transform/TransformsAndCustomClassLoadersTest.groovy
deleted file mode 100644
index 464c7e74b0..0000000000
--- a/src/test/org/codehaus/groovy/transform/TransformsAndCustomClassLoadersTest.groovy
+++ /dev/null
@@ -1,156 +0,0 @@
-/*
- * Copyright 2009 the original author or authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.codehaus.groovy.transform
-
-import org.codehaus.groovy.control.CompilationUnit
-import org.codehaus.groovy.control.SourceUnit
-import org.codehaus.groovy.control.CompilerConfiguration
-import org.codehaus.groovy.transform.GroovyASTTransformation
-import org.codehaus.groovy.transform.ASTTransformation
-import org.codehaus.groovy.ast.ASTNode
-import org.codehaus.groovy.ast.ModuleNode
-import org.codehaus.groovy.control.CompilePhase
-import org.codehaus.groovy.control.Phases
-
-/**
- * Tests whether local and global transforms are successfully detected, loaded,
- * and run if a custom class loader is used for resolving compile dependencies
- * that does not delegate to the compiler's defining class loader (e.g. to
- * avoid pollution of the compile classpath).
- *
- * @author Peter Niederwieser
- */
-class TransformsAndCustomClassLoadersTest extends GroovyTestCase {
-    void testLocalTransform() {
-        def resolvingLoader = new GroovyProjectClassesLoader()
-        def transformLoader = new GroovyClassLoader(TransformsAndCustomClassLoadersTest.classLoader)
-        checkIsIsolated(resolvingLoader)
-
-        def clazz = compileAndLoadClass("@groovy.transform.Immutable class Foo { String bar }", resolvingLoader, transformLoader)
-        checkIsImmutable(clazz)
-    }
-
-    void testGlobalTransform() {
-        def resolvingLoader = new GroovyProjectClassesLoader()
-        def transformLoader = new ToUpperCaseTransformLoader()
-        checkIsIsolated(resolvingLoader)
-
-        def clazz = compileAndLoadClass("class Foo {}", resolvingLoader, transformLoader)
-        assert clazz
-        assert clazz.name == "FOO"
-    }
-
-    private compileAndLoadClass(String source, GroovyClassLoader dependencyLoader, GroovyClassLoader transformLoader) {
-        def unit = new CompilationUnit(null, null, dependencyLoader, transformLoader)
-        unit.addSource(new SourceUnit("", source, new CompilerConfiguration(), null, null))
-        unit.compile(Phases.CLASS_GENERATION)
-
-        def classInfo = unit.classes[0]
-        assert classInfo
-        return transformLoader.defineClass(classInfo.name, classInfo.bytes)
-    }
-
-    private checkIsIsolated(ClassLoader loader) {
-        def clazz = loader.loadClass(CompilationUnit.name)
-        assert clazz
-        assert clazz != CompilationUnit
-    }
-
-    private checkIsImmutable(Class clazz) {
-        try {
-            def foo = clazz.newInstance(["setting property"] as Object[])
-            foo.bar = "updating property"
-            fail()
-        } catch (ReadOnlyPropertyException expected) {}
-    }
-}
-
-/**
- * A class loader that can load classes in the Groovy project,
- * but does so without delegating to another class loader.
- */
-class GroovyProjectClassesLoader extends GroovyClassLoader {
-    private bootstrapClassLoader = new URLClassLoader([] as URL[], (ClassLoader) null)
-
-    GroovyProjectClassesLoader() {
-        super(null, null, false)
-        for (url in getGroovyLoaderURLs())
-            addURL(url)
-        checkCanLoadGroovyClasses()
-        checkCanLoadOrgCodehausGroovyClasses()
-    }
-
-    private URL[] getGroovyLoaderURLs() {
-        def groovyLoader = Closure.classLoader
-        if (groovyLoader instanceof URLClassLoader)
-            return groovyLoader.URLs
-        else
-            assert false, "sorry, GroovyProjectClassesLoader doesn't work in this class loader environment"
-    }
-
-    private checkCanLoadGroovyClasses() {
-        assert loadClass(GroovyShell.name)
-    }
-
-    private checkCanLoadOrgCodehausGroovyClasses() {
-        assert loadClass(CompilationUnit.name)
-    }
-
-    @Override
-    synchronized Class loadClass(String name, boolean resolve) {
-        def clazz = doLoadClass(name)
-        if (resolve) resolveClass(clazz)
-        return clazz
-    }
-
-    private Class doLoadClass(String name) {
-        def clazz = findLoadedClass(name)
-        if (clazz != null) return clazz
-
-        if (name.startsWith("java."))
-            return bootstrapClassLoader.loadClass(name)
-
-        return findClass(name)
-    }
-}
-
-class ToUpperCaseTransformLoader extends GroovyClassLoader {
-    ToUpperCaseTransformLoader() {
-        super(CompilationUnit.classLoader)
-    }
-
-    Enumeration getResources(String name) {
-        if (name.equals("META-INF/services/org.codehaus.groovy.transform.ASTTransformation"))
-            return Collections.enumeration([getURL()])
-        else
-          return super.getResources(name)
-    }
-
-    def getURL() {
-        return new FakeURLFactory().createURL("org.codehaus.groovy.transform.ToUpperCaseTransform")
-    }
-}
-
-@GroovyASTTransformation(phase = CompilePhase.CONVERSION)
-class ToUpperCaseTransform implements ASTTransformation {
-    void visit(ASTNode[] nodes, SourceUnit source) {
-        assert nodes[0] instanceof ModuleNode
-
-        for (clazz in nodes[0].classes)
-            clazz.name = clazz.name.toUpperCase()
-    }
-}
-
diff --git a/src/test/org/codehaus/groovy/transform/classloading/TransformsAndCustomClassLoadersTest.groovy b/src/test/org/codehaus/groovy/transform/classloading/TransformsAndCustomClassLoadersTest.groovy
new file mode 100644
index 0000000000..7c37656040
--- /dev/null
+++ b/src/test/org/codehaus/groovy/transform/classloading/TransformsAndCustomClassLoadersTest.groovy
@@ -0,0 +1,150 @@
+/*
+ * Copyright 2009 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.codehaus.groovy.transform.classloading
+
+import org.codehaus.groovy.ast.ASTNode
+import org.codehaus.groovy.ast.ModuleNode
+import org.codehaus.groovy.ast.ClassNode
+import org.codehaus.groovy.control.CompilationUnit
+import org.codehaus.groovy.control.SourceUnit
+import org.codehaus.groovy.control.CompilePhase
+import org.codehaus.groovy.transform.GroovyASTTransformationClass
+import org.codehaus.groovy.transform.ASTTransformation
+import org.codehaus.groovy.transform.GroovyASTTransformation
+import org.codehaus.groovy.transform.GlobalTestTransformClassLoader
+
+import java.lang.annotation.Retention
+import java.lang.annotation.RetentionPolicy
+import java.lang.annotation.Target
+import java.lang.annotation.ElementType
+
+/**
+ * Tests whether local and global transforms are successfully detected, loaded,
+ * and run if separate class loaders are used for loading compile dependencies
+ * and AST transforms.
+ *
+ * @author Peter Niederwieser
+ */
+class TransformsAndCustomClassLoadersTest extends GroovyTestCase {
+    URL[] urls = collectUrls(getClass().classLoader)
+    GroovyClassLoader dependencyLoader = new GroovyClassLoader(new URLClassLoader(urls, null))
+    GroovyClassLoader transformLoader = new GroovyClassLoader(new URLClassLoader(urls, new GroovyOnlyClassLoader()))
+
+    void setUp() {
+        assert dependencyLoader.loadClass(CompilationUnit.class.name) != CompilationUnit
+        assert dependencyLoader.loadClass(getClass().name) != getClass()
+
+        assert transformLoader.loadClass(CompilationUnit.class.name) == CompilationUnit
+        // TODO: reversing arguments of != results in VerifyError
+        assert getClass() != transformLoader.loadClass(getClass().name)
+    }
+
+    void testBuiltInLocalTransform() {
+        def clazz = compileAndLoadClass("@groovy.transform.Immutable class Foo { String bar }", dependencyLoader, transformLoader)
+        checkIsImmutable(clazz)
+    }
+
+    void testThirdPartyLocalTransform() {
+        def clazz = compileAndLoadClass("@org.codehaus.groovy.transform.classloading.ToUpperCase class Foo {}", dependencyLoader, transformLoader)
+        assert clazz.name == "FOO"
+    }
+
+    void testLocalTransformWhoseAnnotationUsesClassesAttribute() {
+        def clazz = compileAndLoadClass("@org.codehaus.groovy.transform.classloading.ToUpperCase2 class Foo {}", dependencyLoader, transformLoader)
+        assert clazz.name == "FOO"
+    }
+
+    void testGlobalTransform() {
+        transformLoader = new GlobalTestTransformClassLoader(transformLoader, ToUpperCaseGlobalTransform)
+
+        def clazz = compileAndLoadClass("class Foo {}", dependencyLoader, transformLoader)
+        assert clazz
+        assert clazz.name == "FOO"
+    }
+
+    private compileAndLoadClass(String source, GroovyClassLoader dependencyLoader, GroovyClassLoader transformLoader) {
+        def unit = new CompilationUnit(null, null, dependencyLoader, transformLoader)
+        unit.addSource("Foo.groovy", source)
+        unit.compile()
+
+        assert unit.classes.size() == 1
+        def classInfo = unit.classes[0]
+
+        def loader = new GroovyClassLoader(getClass().classLoader)
+        return loader.defineClass(classInfo.name, classInfo.bytes)
+    }
+
+    private checkIsImmutable(Class clazz) {
+        try {
+            def foo = clazz.newInstance(["setting property"] as Object[])
+            foo.bar = "updating property"
+            fail()
+        } catch (ReadOnlyPropertyException expected) {}
+    }
+
+    private Set<URL> collectUrls(ClassLoader classLoader) {
+        if (classLoader == null) return []
+        if (classLoader instanceof URLClassLoader) {
+            return collectUrls(classLoader.parent) + Arrays.asList(classLoader.URLs)
+        }
+        collectUrls(classLoader.parent)
+    }
+
+    static class GroovyOnlyClassLoader extends ClassLoader {
+        synchronized Class<?> loadClass(String name, boolean resolve) {
+            // treat this package as not belonging to Groovy
+            if (name.startsWith(getClass().getPackage().name)) {
+                throw new ClassNotFoundException(name)
+            }
+            if (name.startsWith("java.") || name.startsWith("groovy.") || name.startsWith("org.codehaus.groovy.")) {
+                return getClass().classLoader.loadClass(name, resolve)
+            }
+            throw new ClassNotFoundException(name)
+        }
+    }
+}
+
+@Target(ElementType.TYPE)
+@Retention(RetentionPolicy.RUNTIME)
+@GroovyASTTransformationClass("org.codehaus.groovy.transform.classloading.ToUpperCaseLocalTransform")
+@interface ToUpperCase {}
+
+@Target(ElementType.TYPE)
+@Retention(RetentionPolicy.RUNTIME)
+@GroovyASTTransformationClass(classes = [ToUpperCaseLocalTransform])
+@interface ToUpperCase2 {}
+
+@GroovyASTTransformation(phase = CompilePhase.SEMANTIC_ANALYSIS)
+class ToUpperCaseLocalTransform implements ASTTransformation {
+    void visit(ASTNode[] nodes, SourceUnit source) {
+        def clazz = nodes[1]
+        assert clazz instanceof ClassNode
+
+        clazz.name = clazz.name.toUpperCase()
+    }
+}
+
+@GroovyASTTransformation(phase = CompilePhase.CONVERSION)
+class ToUpperCaseGlobalTransform implements ASTTransformation {
+    void visit(ASTNode[] nodes, SourceUnit source) {
+        def module = nodes[0]
+        assert module instanceof ModuleNode
+
+        for (clazz in module.classes) {
+            clazz.name = clazz.name.toUpperCase()
+        }
+    }
+}
