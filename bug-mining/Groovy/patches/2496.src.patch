diff --git a/src/main/groovy/lang/Delegate.java b/src/main/groovy/lang/Delegate.java
index 696344923b..97834c1542 100644
--- a/src/main/groovy/lang/Delegate.java
+++ b/src/main/groovy/lang/Delegate.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2013 the original author or authors.
+ * Copyright 2008-2014 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -170,15 +170,14 @@ public @interface Delegate {
     String[] excludes() default {};
 
 
-    /* *
+    /**
      * List of interfaces containing method signatures to exclude when delegating.
      * Only one of 'includes', 'includeTypes', 'excludes', 'excludeTypes' should be used.
      * If interfaces is true (the default), you will need to manually supply any methods excluded
      * from delegation that are required for the interface.
-     * @since ???
+     * @since 2.3.0
      */
-    // GROOVY-6329: awaiting resolution of GROOVY-6330
-//    Class[] excludeTypes() default {};
+    Class[] excludeTypes() default {};
 
     /**
      * List of method and/or property names to include when delegating.
@@ -190,13 +189,12 @@ public @interface Delegate {
      */
     String[] includes() default {};
 
-    /* *
+    /**
      * List of interfaces containing method signatures to exclude when delegating.
      * Only one of 'includes', 'includeTypes', 'excludes', 'excludeTypes' should be used.
      * If interfaces is true (the default), you will need to manually supply any methods excluded
      * from delegation that are required for the interface.
-     * @since ???
+     * @since 2.3.0
      */
-    // GROOVY-6329: awaiting resolution of GROOVY-6330
-//    Class[] includeTypes() default {};
+    Class[] includeTypes() default {};
 }
diff --git a/src/main/org/codehaus/groovy/transform/AbstractASTTransformation.java b/src/main/org/codehaus/groovy/transform/AbstractASTTransformation.java
index f7f5ba8066..dcbd92fa00 100644
--- a/src/main/org/codehaus/groovy/transform/AbstractASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/AbstractASTTransformation.java
@@ -21,8 +21,9 @@ import org.codehaus.groovy.ast.AnnotatedNode;
 import org.codehaus.groovy.ast.AnnotationNode;
 import org.codehaus.groovy.ast.ClassHelper;
 import org.codehaus.groovy.ast.ClassNode;
-//import org.codehaus.groovy.ast.MethodNode;
-//import org.codehaus.groovy.ast.expr.ClassExpression;
+import org.codehaus.groovy.ast.MethodNode;
+import org.codehaus.groovy.ast.Parameter;
+import org.codehaus.groovy.ast.expr.ClassExpression;
 import org.codehaus.groovy.ast.GenericsType;
 import org.codehaus.groovy.ast.expr.ConstantExpression;
 import org.codehaus.groovy.ast.expr.Expression;
@@ -36,7 +37,6 @@ import org.objectweb.asm.Opcodes;
 
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
@@ -92,8 +92,6 @@ public abstract class AbstractASTTransformation implements Opcodes, ASTTransform
         return list;
     }
 
-    // GROOVY-6329: awaiting resolution of GROOVY-6330
-/*
     protected List<ClassNode> getClassList(AnnotationNode anno, String name) {
         List<ClassNode> list = new ArrayList<ClassNode>();
         Expression expr = anno.getMember(name);
@@ -111,7 +109,6 @@ public abstract class AbstractASTTransformation implements Opcodes, ASTTransform
         }
         return list;
     }
-*/
 
     protected void addError(String msg, ASTNode expr) {
         sourceUnit.getErrorCollector().addErrorAndContinue(new SyntaxErrorMessage(
@@ -141,11 +138,10 @@ public abstract class AbstractASTTransformation implements Opcodes, ASTTransform
         return (excludes != null && excludes.contains(name)) || name.contains("$") || (includes != null && !includes.isEmpty() && !includes.contains(name));
     }
 
-    // GROOVY-6329: awaiting resolution of GROOVY-6330
-/*
     public static boolean shouldSkipOnDescriptor(String descriptor, List<ClassNode> excludeTypes, List<ClassNode> includeTypes) {
         if (excludeTypes != null) {
             for (ClassNode cn : excludeTypes) {
+                // TODO correct to generics spec?
                 for (MethodNode mn : nonGeneric(cn).getMethods()) {
                     if (mn.getTypeDescriptor().equals(descriptor)) return true;
                 }
@@ -162,7 +158,6 @@ public abstract class AbstractASTTransformation implements Opcodes, ASTTransform
         }
         return false;
     }
-*/
 
     protected void checkIncludeExclude(AnnotationNode node, List<String> excludes, List<String> includes, String typeName) {
         if (includes != null && !includes.isEmpty() && excludes != null && !excludes.isEmpty()) {
@@ -170,8 +165,6 @@ public abstract class AbstractASTTransformation implements Opcodes, ASTTransform
         }
     }
 
-    // GROOVY-6329: awaiting resolution of GROOVY-6330
-/*
     protected void checkIncludeExclude(AnnotationNode node, List<String> excludes, List<String> includes, List<ClassNode> excludeTypes, List<ClassNode> includeTypes, String typeName) {
         int found = 0;
         if (includes != null && !includes.isEmpty()) found++;
@@ -182,7 +175,6 @@ public abstract class AbstractASTTransformation implements Opcodes, ASTTransform
             addError("Error during " + typeName + " processing: Only one of 'includes', 'excludes', 'includeTypes' and 'excludeTypes' should be supplied.", node);
         }
     }
-*/
 
     public static ClassNode nonGeneric(ClassNode type) {
         if (type.isUsingGenerics()) {
@@ -208,8 +200,10 @@ public abstract class AbstractASTTransformation implements Opcodes, ASTTransform
         return plainNodeReference;
     }
 
+
     public static ClassNode makeClassSafeWithGenerics(ClassNode type, GenericsType... genericTypes) {
-        if (type.isArray()) {
+        if (type.isArray() /*&& type.getComponentType().isUsingGenerics()*/) {
+
             return makeClassSafeWithGenerics(type.getComponentType(), genericTypes).makeArray();
         }
         GenericsType[] gtypes = new GenericsType[0];
@@ -220,6 +214,17 @@ public abstract class AbstractASTTransformation implements Opcodes, ASTTransform
         return makeClassSafe0(type, gtypes);
     }
 
+    static MethodNode correctToGenericsSpec(Map genericsSpec, MethodNode mn) {
+        ClassNode correctedType = correctToGenericsSpecRecurse(genericsSpec, mn.getReturnType());
+        Parameter[] origParameters = mn.getParameters();
+        Parameter[] newParameters = new Parameter[origParameters.length];
+        for (int i = 0; i < origParameters.length; i++) {
+            Parameter origParameter = origParameters[i];
+            newParameters[i] = new Parameter(correctToGenericsSpecRecurse(genericsSpec, origParameter.getType()), origParameter.getName(), origParameter.getInitialExpression());
+        }
+        return new MethodNode(mn.getName(), mn.getModifiers(), correctedType, newParameters, mn.getExceptions(), mn.getCode());
+    }
+
     static ClassNode correctToGenericsSpecRecurse(Map genericsSpec, ClassNode type) {
         if (type.isGenericsPlaceHolder()) {
             String name = type.getGenericsTypes()[0].getName();
diff --git a/src/main/org/codehaus/groovy/transform/DelegateASTTransformation.java b/src/main/org/codehaus/groovy/transform/DelegateASTTransformation.java
index 1b7ccadf3a..beabbd421d 100644
--- a/src/main/org/codehaus/groovy/transform/DelegateASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/DelegateASTTransformation.java
@@ -54,9 +54,8 @@ public class DelegateASTTransformation extends AbstractASTTransformation impleme
     private static final String MEMBER_INTERFACES = "interfaces";
     private static final String MEMBER_INCLUDES = "includes";
     private static final String MEMBER_EXCLUDES = "excludes";
-    // GROOVY-6329: awaiting resolution of GROOVY-6330
-//    private static final String MEMBER_INCLUDE_TYPES = "includeTypes";
-//    private static final String MEMBER_EXCLUDE_TYPES = "excludeTypes";
+    private static final String MEMBER_INCLUDE_TYPES = "includeTypes";
+    private static final String MEMBER_EXCLUDE_TYPES = "excludeTypes";
     private static final String MEMBER_PARAMETER_ANNOTATIONS = "parameterAnnotations";
     private static final String MEMBER_METHOD_ANNOTATIONS = "methodAnnotations";
 
@@ -89,20 +88,14 @@ public class DelegateASTTransformation extends AbstractASTTransformation impleme
             final boolean includeDeprecated = hasBooleanValue(node.getMember(MEMBER_DEPRECATED), true) || (type.isInterface() && !skipInterfaces);
             List<String> excludes = getMemberList(node, MEMBER_EXCLUDES);
             List<String> includes = getMemberList(node, MEMBER_INCLUDES);
-            // GROOVY-6329: awaiting resolution of GROOVY-6330
-/*
             List<ClassNode> excludeTypes = getClassList(node, MEMBER_EXCLUDE_TYPES);
             List<ClassNode> includeTypes = getClassList(node, MEMBER_INCLUDE_TYPES);
             checkIncludeExclude(node, excludes, includes, excludeTypes, includeTypes, MY_TYPE_NAME);
-*/
-            checkIncludeExclude(node, excludes, includes, MY_TYPE_NAME);
 
             final List<MethodNode> ownerMethods = getAllMethods(owner);
             for (MethodNode mn : fieldMethods) {
-                // GROOVY-6329: awaiting resolution of GROOVY-6330
-//                addDelegateMethod(node, fieldNode, owner, ownerMethods, mn, includeDeprecated, includes, excludes, includeTypes, excludeTypes);
-                addDelegateMethod(node, fieldNode, owner, ownerMethods, mn, includeDeprecated, includes, excludes);
-            }
+               addDelegateMethod(node, fieldNode, owner, ownerMethods, mn, includeDeprecated, includes, excludes, includeTypes, excludeTypes);
+           }
 
             for (PropertyNode prop : getAllProperties(type)) {
                 if (prop.isStatic() || !prop.isPublic())
@@ -199,7 +192,7 @@ public class DelegateASTTransformation extends AbstractASTTransformation impleme
         }
     }
 
-    private void addDelegateMethod(AnnotationNode node, FieldNode fieldNode, ClassNode owner, List<MethodNode> ownMethods, MethodNode candidate, boolean includeDeprecated, List<String> includes, List<String> excludes/*, List<ClassNode> includeTypes, List<ClassNode> excludeTypes*/) {
+    private void addDelegateMethod(AnnotationNode node, FieldNode fieldNode, ClassNode owner, List<MethodNode> ownMethods, MethodNode candidate, boolean includeDeprecated, List<String> includes, List<String> excludes, List<ClassNode> includeTypes, List<ClassNode> excludeTypes) {
         if (!candidate.isPublic() || candidate.isStatic() || 0 != (candidate.getModifiers () & Opcodes.ACC_SYNTHETIC))
             return;
 
@@ -207,12 +200,12 @@ public class DelegateASTTransformation extends AbstractASTTransformation impleme
             return;
 
         if (shouldSkip(candidate.getName(), excludes, includes)) return;
-        checkIncludeExclude(node, excludes, includes, MY_TYPE_NAME);
-        // GROOVY-6329: awaiting resolution of GROOVY-6330
-/*
-        checkIncludeExclude(node, excludes, includes, excludeTypes, includeTypes, MY_TYPE_NAME);
-        if (shouldSkipOnDescriptor(candidate.getTypeDescriptor(), excludeTypes, includeTypes)) return;
-*/
+
+        Map genericsSpec = Verifier.createGenericsSpec(fieldNode.getDeclaringClass(), new HashMap());
+        genericsSpec = Verifier.createGenericsSpec(fieldNode.getType(), genericsSpec);
+
+        String correctedTypeDescriptor = correctToGenericsSpec(genericsSpec, candidate).getTypeDescriptor();
+        if (shouldSkipOnDescriptor(correctedTypeDescriptor, excludeTypes, includeTypes)) return;
 
         // ignore methods from GroovyObject
         for (MethodNode mn : GROOVYOBJECT_TYPE.getMethods()) {
@@ -237,8 +230,6 @@ public class DelegateASTTransformation extends AbstractASTTransformation impleme
                 break;
             }
         }
-        Map genericsSpec = Verifier.createGenericsSpec(fieldNode.getDeclaringClass(), new HashMap());
-        genericsSpec = Verifier.createGenericsSpec(fieldNode.getType(), genericsSpec);
         if (existingNode == null || existingNode.getCode() == null) {
 
             final boolean includeParameterAnnotations = hasBooleanValue(node.getMember(MEMBER_PARAMETER_ANNOTATIONS), true);
diff --git a/src/test/org/codehaus/groovy/transform/DelegateTransformTest.groovy b/src/test/org/codehaus/groovy/transform/DelegateTransformTest.groovy
index b0987f327c..5531184691 100644
--- a/src/test/org/codehaus/groovy/transform/DelegateTransformTest.groovy
+++ b/src/test/org/codehaus/groovy/transform/DelegateTransformTest.groovy
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2013 the original author or authors.
+ * Copyright 2003-2014 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -467,6 +467,31 @@ class DelegateTransformTest extends CompilableTestSupport {
         """
     }
 
+    // GROOVY-6330
+    void testIncludeAndExcludeByType() {
+        assertScript """
+            interface AddAllCollectionSelector {
+                boolean addAll(Collection<? extends Integer> c)
+                Integer remove(int index)
+            }
+
+            class SplitNumberList {
+                // collection variant of addAll and remove will work on odd list, all other methods on even list
+                @Delegate(excludeTypes=AddAllCollectionSelector) List<Integer> evens = [2, 4, 6]
+                @Delegate(includeTypes=AddAllCollectionSelector) List<Integer> odds = [1, 3, 5]
+                def getEvensThenOdds() { evens + odds }
+            }
+
+            def list = new SplitNumberList()
+            assert list.evensThenOdds == [2, 4, 6, 1, 3, 5]
+            list.addAll([7, 9])
+            list.addAll(1, [8])
+            list.remove(0)
+            assert list.indexOf(8) == 1
+            assert list.evensThenOdds == [2, 8, 4, 6, 3, 5, 7, 9]
+        """
+    }
+
     // GROOVY-5211
     void testAvoidFieldNameClashWithParameterName() {
         assertScript """
