diff --git a/src/main/groovy/beans/BindableASTTransformation.java b/src/main/groovy/beans/BindableASTTransformation.java
index 75a2bb75f3..985ea1aa46 100644
--- a/src/main/groovy/beans/BindableASTTransformation.java
+++ b/src/main/groovy/beans/BindableASTTransformation.java
@@ -95,13 +95,11 @@ public class BindableASTTransformation implements ASTTransformation, Opcodes {
 
         ClassNode declaringClass = parent.getDeclaringClass();
         if (parent instanceof FieldNode) {
-            if ((((FieldNode)parent).getModifiers() & Opcodes.ACC_FINAL) != 0) {
-                source.getErrorCollector().addErrorAndContinue(
-                            new SyntaxErrorMessage(new SyntaxException(
-                                "@groovy.beans.Bindable cannot annotate a final property.",
-                                node.getLineNumber(),
-                                node.getColumnNumber()),
-                                source));
+            if ((((FieldNode) parent).getModifiers() & Opcodes.ACC_FINAL) != 0) {
+                source.getErrorCollector().addErrorAndContinue(new SyntaxErrorMessage(
+                        new SyntaxException("@groovy.beans.Bindable cannot annotate a final property.",
+                                node.getLineNumber(), node.getColumnNumber(), node.getLastLineNumber(), node.getLastColumnNumber()),
+                        source));
             }
 
             if (VetoableASTTransformation.hasVetoableAnnotation(parent.getDeclaringClass())) {
@@ -120,12 +118,10 @@ public class BindableASTTransformation implements ASTTransformation, Opcodes {
             if (propertyNode.getName().equals(fieldName)) {
                 if (field.isStatic()) {
                     //noinspection ThrowableInstanceNeverThrown
-                    source.getErrorCollector().addErrorAndContinue(
-                                new SyntaxErrorMessage(new SyntaxException(
-                                    "@groovy.beans.Bindable cannot annotate a static property.",
-                                    node.getLineNumber(),
-                                    node.getColumnNumber()),
-                                    source));
+                    source.getErrorCollector().addErrorAndContinue(new SyntaxErrorMessage(
+                            new SyntaxException("@groovy.beans.Bindable cannot annotate a static property.",
+                                    node.getLineNumber(), node.getColumnNumber(), node.getLastLineNumber(), node.getLastColumnNumber()),
+                            source));
                 } else {
                     if (needsPropertyChangeSupport(declaringClass, source)) {
                         addPropertyChangeSupport(declaringClass);
@@ -136,12 +132,10 @@ public class BindableASTTransformation implements ASTTransformation, Opcodes {
             }
         }
         //noinspection ThrowableInstanceNeverThrown
-        source.getErrorCollector().addErrorAndContinue(
-                new SyntaxErrorMessage(new SyntaxException(
-                        "@groovy.beans.Bindable must be on a property, not a field.  Try removing the private, protected, or public modifier.",
-                        node.getLineNumber(),
-                        node.getColumnNumber()),
-                        source));
+        source.getErrorCollector().addErrorAndContinue(new SyntaxErrorMessage(
+                new SyntaxException("@groovy.beans.Bindable must be on a property, not a field.  Try removing the private, protected, or public modifier.",
+                        node.getLineNumber(), node.getColumnNumber(), node.getLastLineNumber(), node.getLastColumnNumber()),
+                source));
     }
 
     private void addListenerToClass(SourceUnit source, AnnotationNode node, ClassNode classNode) {
diff --git a/src/main/groovy/beans/VetoableASTTransformation.java b/src/main/groovy/beans/VetoableASTTransformation.java
index 50b8838ffd..2b283669c6 100644
--- a/src/main/groovy/beans/VetoableASTTransformation.java
+++ b/src/main/groovy/beans/VetoableASTTransformation.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2009 the original author or authors.
+ * Copyright 2008-2012 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -91,12 +91,10 @@ public class VetoableASTTransformation extends BindableASTTransformation {
             addListenerToClass(source, node, (ClassNode) nodes[1]);
         } else {
             if ((((FieldNode)nodes[1]).getModifiers() & Opcodes.ACC_FINAL) != 0) {
-                source.getErrorCollector().addErrorAndContinue(
-                            new SyntaxErrorMessage(new SyntaxException(
-                                "@groovy.beans.Vetoable cannot annotate a final property.",
-                                node.getLineNumber(),
-                                node.getColumnNumber()),
-                                source));
+                source.getErrorCollector().addErrorAndContinue(new SyntaxErrorMessage(
+                        new SyntaxException("@groovy.beans.Vetoable cannot annotate a final property.",
+                                node.getLineNumber(), node.getColumnNumber(), node.getLastLineNumber(), node.getLastColumnNumber()),
+                        source));
             }
 
             addListenerToProperty(source, node, (AnnotatedNode) nodes[1]);
@@ -109,30 +107,26 @@ public class VetoableASTTransformation extends BindableASTTransformation {
         String fieldName = field.getName();
         for (PropertyNode propertyNode : declaringClass.getProperties()) {
             boolean bindable = BindableASTTransformation.hasBindableAnnotation(parent)
-                || BindableASTTransformation.hasBindableAnnotation(parent.getDeclaringClass());
+                    || BindableASTTransformation.hasBindableAnnotation(parent.getDeclaringClass());
 
             if (propertyNode.getName().equals(fieldName)) {
                 if (field.isStatic()) {
                     //noinspection ThrowableInstanceNeverThrown
-                    source.getErrorCollector().addErrorAndContinue(
-                                new SyntaxErrorMessage(new SyntaxException(
-                                    "@groovy.beans.Vetoable cannot annotate a static property.",
-                                    node.getLineNumber(),
-                                    node.getColumnNumber()),
-                                    source));
+                    source.getErrorCollector().addErrorAndContinue(new SyntaxErrorMessage(
+                            new SyntaxException("@groovy.beans.Vetoable cannot annotate a static property.",
+                                    node.getLineNumber(), node.getColumnNumber(), node.getLastLineNumber(), node.getLastColumnNumber()),
+                            source));
                 } else {
-                    createListenerSetter(source, node, bindable, declaringClass,  propertyNode);
+                    createListenerSetter(source, node, bindable, declaringClass, propertyNode);
                 }
                 return;
             }
         }
         //noinspection ThrowableInstanceNeverThrown
-        source.getErrorCollector().addErrorAndContinue(
-                    new SyntaxErrorMessage(new SyntaxException(
-                        "@groovy.beans.Vetoable must be on a property, not a field.  Try removing the private, protected, or public modifier.",
-                        node.getLineNumber(),
-                        node.getColumnNumber()),
-                        source));
+        source.getErrorCollector().addErrorAndContinue(new SyntaxErrorMessage(
+                new SyntaxException("@groovy.beans.Vetoable must be on a property, not a field.  Try removing the private, protected, or public modifier.",
+                        node.getLineNumber(), node.getColumnNumber(), node.getLastLineNumber(), node.getLastColumnNumber()),
+                source));
     }
 
 
diff --git a/src/main/org/codehaus/groovy/antlr/ASTParserException.java b/src/main/org/codehaus/groovy/antlr/ASTParserException.java
index 08809861ff..a8c6570938 100644
--- a/src/main/org/codehaus/groovy/antlr/ASTParserException.java
+++ b/src/main/org/codehaus/groovy/antlr/ASTParserException.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2007 the original author or authors.
+ * Copyright 2003-2012 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -27,16 +27,26 @@ public class ASTParserException extends ParserException {
     private final AST ast;
 
     public ASTParserException(ASTRuntimeException e) {
-        super(e.getMessage(), e, e.getLine(), e.getColumn());
+        super(e.getMessage(), e, e.getLine(), e.getColumn(), getLineLast(e), getColumnLast(e));
         this.ast = e.getAst();
     }
 
     public ASTParserException(String message, ASTRuntimeException e) {
-        super(message, e, e.getLine(), e.getColumn());
+        super(message, e, e.getLine(), e.getColumn(), getLineLast(e), getColumnLast(e));
         this.ast = e.getAst();
     }
 
     public AST getAst() {
         return ast;
     }
+    
+    private static int getLineLast(ASTRuntimeException e) {
+        final AST ast = e.getAst();
+        return (ast instanceof SourceInfo) ? ((SourceInfo)ast).getLineLast() : ast.getLine();
+    }
+
+    private static int getColumnLast(ASTRuntimeException e) {
+        final AST ast = e.getAst();
+        return (ast instanceof SourceInfo) ? ((SourceInfo)ast).getColumnLast() : ast.getColumn()+1;
+    }
 }
diff --git a/src/main/org/codehaus/groovy/ast/ClassCodeVisitorSupport.java b/src/main/org/codehaus/groovy/ast/ClassCodeVisitorSupport.java
index 08db6fa70b..22c68840d6 100644
--- a/src/main/org/codehaus/groovy/ast/ClassCodeVisitorSupport.java
+++ b/src/main/org/codehaus/groovy/ast/ClassCodeVisitorSupport.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2010 the original author or authors.
+ * Copyright 2003-2012 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -142,11 +142,9 @@ public abstract class ClassCodeVisitorSupport extends CodeVisitorSupport impleme
     }
 
     protected void addError(String msg, ASTNode expr) {
-        int line = expr.getLineNumber();
-        int col = expr.getColumnNumber();
         SourceUnit source = getSourceUnit();
         source.getErrorCollector().addErrorAndContinue(
-                new SyntaxErrorMessage(new SyntaxException(msg + '\n', line, col), source)
+                new SyntaxErrorMessage(new SyntaxException(msg + '\n', expr.getLineNumber(), expr.getColumnNumber(), expr.getLastLineNumber(), expr.getLastColumnNumber()), source)
         );
     }
 
diff --git a/src/main/org/codehaus/groovy/ast/CompileUnit.java b/src/main/org/codehaus/groovy/ast/CompileUnit.java
index 4b50e4dae7..d3f46c0aaa 100644
--- a/src/main/org/codehaus/groovy/ast/CompileUnit.java
+++ b/src/main/org/codehaus/groovy/ast/CompileUnit.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2007 the original author or authors.
+ * Copyright 2003-2012 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -143,7 +143,7 @@ public class CompileUnit {
                 txt += "The sources " + nodeSource.getName() + " and " + storedSource.getName() + " are containing both a class of the name " + node.getName() + ".\n";
             }
             nodeSource.getErrorCollector().addErrorAndContinue(
-                    new SyntaxErrorMessage(new SyntaxException(txt, node.getLineNumber(), node.getColumnNumber()), nodeSource)
+                    new SyntaxErrorMessage(new SyntaxException(txt, node.getLineNumber(), node.getColumnNumber(), node.getLastLineNumber(), node.getLastColumnNumber()), nodeSource)
             );
         }
         classes.put(name, node);
diff --git a/src/main/org/codehaus/groovy/ast/builder/AstBuilderTransformation.java b/src/main/org/codehaus/groovy/ast/builder/AstBuilderTransformation.java
index 675504066f..6e1d2baed1 100644
--- a/src/main/org/codehaus/groovy/ast/builder/AstBuilderTransformation.java
+++ b/src/main/org/codehaus/groovy/ast/builder/AstBuilderTransformation.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2011 the original author or authors.
+ * Copyright 2003-2012 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -186,10 +186,8 @@ public class AstBuilderTransformation implements ASTTransformation {
          * @param expr the expression that caused the error message.
          */
         private void addError(String msg, ASTNode expr) {
-            int line = expr.getLineNumber();
-            int col = expr.getColumnNumber();
             sourceUnit.getErrorCollector().addErrorAndContinue(
-                    new SyntaxErrorMessage(new SyntaxException(msg + '\n', line, col), sourceUnit)
+                    new SyntaxErrorMessage(new SyntaxException(msg + '\n', expr.getLineNumber(), expr.getColumnNumber(), expr.getLastLineNumber(), expr.getLastColumnNumber()), sourceUnit)
             );
         }
 
diff --git a/src/main/org/codehaus/groovy/classgen/AnnotationVisitor.java b/src/main/org/codehaus/groovy/classgen/AnnotationVisitor.java
index 2dd6259db7..59f11e4582 100644
--- a/src/main/org/codehaus/groovy/classgen/AnnotationVisitor.java
+++ b/src/main/org/codehaus/groovy/classgen/AnnotationVisitor.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2009 the original author or authors.
+ * Copyright 2003-2012 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -295,10 +295,7 @@ public class AnnotationVisitor {
 
     protected void addError(String msg, ASTNode expr) {
         this.errorCollector.addErrorAndContinue(
-                new SyntaxErrorMessage(new SyntaxException(
-                        msg + " in @" + this.reportClass.getName() + '\n',
-                        expr.getLineNumber(),
-                        expr.getColumnNumber()), this.source)
+                new SyntaxErrorMessage(new SyntaxException(msg + " in @" + this.reportClass.getName() + '\n', expr.getLineNumber(), expr.getColumnNumber(), expr.getLastLineNumber(), expr.getLastColumnNumber()), this.source)
         );
     }
 
diff --git a/src/main/org/codehaus/groovy/classgen/EnumVisitor.java b/src/main/org/codehaus/groovy/classgen/EnumVisitor.java
index 8977033b52..0f4af53de8 100644
--- a/src/main/org/codehaus/groovy/classgen/EnumVisitor.java
+++ b/src/main/org/codehaus/groovy/classgen/EnumVisitor.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2011 the original author or authors.
+ * Copyright 2003-2012 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -298,7 +298,7 @@ public class EnumVisitor extends ClassCodeVisitorSupport {
                         String msg = "The usage of a map entry expression to initialize an Enum is currently not supported, please use an explicit map instead.";
                         sourceUnit.getErrorCollector().addErrorAndContinue(
                                 new SyntaxErrorMessage(
-                                        new SyntaxException(msg + '\n', exp.getLineNumber(), exp.getColumnNumber()), sourceUnit)
+                                        new SyntaxException(msg + '\n', exp.getLineNumber(), exp.getColumnNumber(), exp.getLastLineNumber(), exp.getLastColumnNumber()), sourceUnit)
                         );
                         continue;
                     }
diff --git a/src/main/org/codehaus/groovy/classgen/ExtendedVerifier.java b/src/main/org/codehaus/groovy/classgen/ExtendedVerifier.java
index c97cfea05a..02a5d3bfd1 100644
--- a/src/main/org/codehaus/groovy/classgen/ExtendedVerifier.java
+++ b/src/main/org/codehaus/groovy/classgen/ExtendedVerifier.java
@@ -165,7 +165,7 @@ public class ExtendedVerifier implements GroovyClassVisitor {
     protected void addError(String msg, ASTNode expr) {
         this.source.getErrorCollector().addErrorAndContinue(
                 new SyntaxErrorMessage(
-                        new SyntaxException(msg + '\n', expr.getLineNumber(), expr.getColumnNumber()), this.source)
+                        new SyntaxException(msg + '\n', expr.getLineNumber(), expr.getColumnNumber(), expr.getLastLineNumber(), expr.getLastColumnNumber()), this.source)
         );
     }
 
diff --git a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java
index 5394c09908..88e9734193 100644
--- a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java
+++ b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java
@@ -172,12 +172,8 @@ public class StaticInvocationWriter extends InvocationWriter {
                     }
                 }
                 if (declaringClass != classNode) {
-                    controller.getSourceUnit().addError(new SyntaxException(
-                            "Cannot call private method " + (target.isStatic() ? "static " : "") +
-                                    declaringClass.toString(false) + "#" + target.getName() + " from class " + classNode.toString(false),
-                            receiver.getLineNumber(),
-                            receiver.getColumnNumber()
-                    ));
+                    controller.getSourceUnit().addError(new SyntaxException("Cannot call private method " + (target.isStatic() ? "static " : "") +
+                                                        declaringClass.toString(false) + "#" + target.getName() + " from class " + classNode.toString(false), receiver.getLineNumber(), receiver.getColumnNumber(), receiver.getLastLineNumber(), receiver.getLastColumnNumber()));
                 }
             }
             if (target != null && receiver != null) {
diff --git a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
index a515ceb89e..d7bd74f0a5 100644
--- a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
+++ b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2010 the original author or authors.
+ * Copyright 2003-2012 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -193,13 +193,9 @@ public class StaticTypesCallSiteWriter extends CallSiteWriter implements Opcodes
         }
 
         controller.getSourceUnit().addError(
-                new SyntaxException(
-                        "Access to "+
-                                (receiver instanceof ClassExpression?receiver.getType():receiverType).toString(false)
-                                +"#"+methodName+" is forbidden",
-                        receiver.getLineNumber(),
-                        receiver.getColumnNumber()
-                )
+                new SyntaxException("Access to "+
+                                                (receiver instanceof ClassExpression ?receiver.getType():receiverType).toString(false)
+                                                +"#"+methodName+" is forbidden", receiver.getLineNumber(), receiver.getColumnNumber(), receiver.getLastLineNumber(), receiver.getLastColumnNumber())
         );
         controller.getMethodVisitor().visitInsn(ACONST_NULL);
         controller.getOperandStack().push(ClassHelper.OBJECT_TYPE);
@@ -612,4 +608,4 @@ public class StaticTypesCallSiteWriter extends CallSiteWriter implements Opcodes
     }
 
 
-}
\ No newline at end of file
+}
diff --git a/src/main/org/codehaus/groovy/control/CompilationUnit.java b/src/main/org/codehaus/groovy/control/CompilationUnit.java
index dea692d4e5..fa15f2a0c8 100644
--- a/src/main/org/codehaus/groovy/control/CompilationUnit.java
+++ b/src/main/org/codehaus/groovy/control/CompilationUnit.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2010 the original author or authors.
+ * Copyright 2003-2012 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -747,7 +747,7 @@ public class CompilationUnit extends ProcessingUnit {
             } catch (GroovyRuntimeException rpe) {
                 ASTNode node = rpe.getNode();
                 getErrorCollector().addError(
-                        new SyntaxException(rpe.getMessage(), null, node.getLineNumber(), node.getColumnNumber()),
+                        new SyntaxException(rpe.getMessage(), node.getLineNumber(), node.getColumnNumber(), node.getLastLineNumber(), node.getLastColumnNumber()),
                         source
                 );
             }
diff --git a/src/main/org/codehaus/groovy/syntax/ParserException.java b/src/main/org/codehaus/groovy/syntax/ParserException.java
index 4591272173..e2c4065f48 100644
--- a/src/main/org/codehaus/groovy/syntax/ParserException.java
+++ b/src/main/org/codehaus/groovy/syntax/ParserException.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2007 the original author or authors.
+ * Copyright 2003-2012 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -25,4 +25,7 @@ public class ParserException extends TokenException {
         super(message, cause, lineNumber, columnNumber);
     }
 
+    public ParserException(String message, Throwable cause, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber) {
+        super(message, cause, lineNumber, columnNumber, endLineNumber, endColumnNumber);
+    }
 }
diff --git a/src/main/org/codehaus/groovy/syntax/RuntimeParserException.java b/src/main/org/codehaus/groovy/syntax/RuntimeParserException.java
index a4c05ca651..57d2a3eabc 100644
--- a/src/main/org/codehaus/groovy/syntax/RuntimeParserException.java
+++ b/src/main/org/codehaus/groovy/syntax/RuntimeParserException.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2007 the original author or authors.
+ * Copyright 2003-2012 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -33,7 +33,8 @@ public class RuntimeParserException extends GroovyRuntimeException {
     }
 
     public void throwParserException() throws SyntaxException {
-        throw new SyntaxException(getMessage(), getNode().getLineNumber(), getNode().getColumnNumber());
+        final ASTNode node = getNode();
+        throw new SyntaxException(getMessage(), node.getLineNumber(), node.getColumnNumber(), node.getLastLineNumber(), node.getLastColumnNumber());
     }
 
 }
diff --git a/src/main/org/codehaus/groovy/syntax/SyntaxException.java b/src/main/org/codehaus/groovy/syntax/SyntaxException.java
index e9908e876c..c124e60cfe 100644
--- a/src/main/org/codehaus/groovy/syntax/SyntaxException.java
+++ b/src/main/org/codehaus/groovy/syntax/SyntaxException.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2007 the original author or authors.
+ * Copyright 2003-2012 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -26,23 +26,37 @@ import org.codehaus.groovy.GroovyException;
 public class SyntaxException extends GroovyException {
 
     /** Line upon which the error occurred. */
-    private final int line;
+    private final int startLine;
+    private final int endLine;
 
     /** Column upon which the error occurred. */
-    private final int column;
+    private final int startColumn;
+    private final int endColumn;
 
     private String sourceLocator;
 
-    public SyntaxException(String message, int line, int column) {
+    public SyntaxException(String message, int startLine, int startColumn) {
+        this(message, startLine, startColumn, startLine, startColumn+1);
+    }
+
+    public SyntaxException(String message, int startLine, int startColumn, int endLine, int endColumn) {
         super(message, false);
-        this.line = line;
-        this.column = column;
+        this.startLine = startLine;
+        this.startColumn = startColumn;
+        this.endLine = endLine;
+        this.endColumn = endColumn;
+    }
+
+    public SyntaxException(String message, Throwable cause, int startLine, int startColumn) {
+        this(message, cause, startLine, startColumn, startLine, startColumn+1);
     }
 
-    public SyntaxException(String message, Throwable cause, int line, int column) {
+    public SyntaxException(String message, Throwable cause, int startLine, int startColumn, int endLine, int endColumn) {
         super(message, cause);
-        this.line = line;
-        this.column = column;
+        this.startLine = startLine;
+        this.startColumn = startColumn;
+        this.endLine = endLine;
+        this.endColumn = endColumn;
     }
 
     // Properties
@@ -60,29 +74,37 @@ public class SyntaxException extends GroovyException {
      *  @return The line.
      */
     public int getLine() {
-        return line;
+        return getStartLine();
     }
 
-    /** Retrieve the column upon which the error occurred.
+    /**
+     * @return the line on which the error occurs
+     */
+    public int getStartLine() {
+        return startLine;
+    }
+
+    /**
+     * Retrieve the column upon which the error occurred.
      *
      *  @return The column.
      */
     public int getStartColumn() {
-        return column;
+        return startColumn;
     }
-    
-    /** 
-     * @return the end of the line on which the error occurs
+
+    /**
+     * @return the end line on which the error occurs
      */
-    public int getStartLine() {
-        return getLine();
+    public int getEndLine() {
+        return endLine;
     }
 
     /**
      * @return the end column on which the error occurs
      */
     public int getEndColumn() {
-        return getStartColumn() + 1;
+        return endColumn;
     }
 
     public String getOriginalMessage() {
@@ -90,6 +112,6 @@ public class SyntaxException extends GroovyException {
     }
 
     public String getMessage() {
-        return super.getMessage() + " @ line " + line + ", column " + column + ".";
+        return super.getMessage() + " @ line " + startLine + ", column " + startColumn + ".";
     }
 }
diff --git a/src/main/org/codehaus/groovy/syntax/TokenException.java b/src/main/org/codehaus/groovy/syntax/TokenException.java
index 50da0a942c..76bb7d5a4a 100644
--- a/src/main/org/codehaus/groovy/syntax/TokenException.java
+++ b/src/main/org/codehaus/groovy/syntax/TokenException.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2007 the original author or authors.
+ * Copyright 2003-2012 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,7 +16,6 @@
 
 package org.codehaus.groovy.syntax;
 
-
 public class TokenException extends SyntaxException {
     public TokenException(String message, Token token) {
         super(
@@ -31,12 +30,15 @@ public class TokenException extends SyntaxException {
         super(message, cause, line, column);
     }
 
+    public TokenException(String message, Throwable cause, int line, int column, int endLine, int endColumn) {
+        super(message, cause, line, column, endLine, endColumn);
+    }
+
     public int getEndColumn() {
         int length = 1;
         return getStartColumn() + length;
     }
 
-
     // Implementation methods
     // ----------------------------------------------------------------------
     private static int getColumn(Token token) {
diff --git a/src/main/org/codehaus/groovy/transform/AbstractASTTransformation.java b/src/main/org/codehaus/groovy/transform/AbstractASTTransformation.java
index 49284cf2fc..c400aaec61 100644
--- a/src/main/org/codehaus/groovy/transform/AbstractASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/AbstractASTTransformation.java
@@ -82,10 +82,10 @@ public abstract class AbstractASTTransformation implements Opcodes, ASTTransform
     }
 
     protected void addError(String msg, ASTNode expr) {
-        int line = expr.getLineNumber();
-        int col = expr.getColumnNumber();
-        sourceUnit.getErrorCollector().addErrorAndContinue(
-                new SyntaxErrorMessage(new SyntaxException(msg + '\n', line, col), sourceUnit)
+        sourceUnit.getErrorCollector().addErrorAndContinue(new SyntaxErrorMessage(
+                new SyntaxException(msg + '\n', expr.getLineNumber(), expr.getColumnNumber(),
+                        expr.getLastLineNumber(), expr.getLastColumnNumber()),
+                sourceUnit)
         );
     }
 
diff --git a/src/main/org/codehaus/groovy/transform/CategoryASTTransformation.java b/src/main/org/codehaus/groovy/transform/CategoryASTTransformation.java
index a2fa220c01..4805f2c540 100644
--- a/src/main/org/codehaus/groovy/transform/CategoryASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/CategoryASTTransformation.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2011 the original author or authors.
+ * Copyright 2008-2012 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -218,16 +218,14 @@ public class CategoryASTTransformation implements ASTTransformation, Opcodes {
         Expression value = annotation.getMember("value");
         if (value == null || !(value instanceof ClassExpression)) {
             //noinspection ThrowableInstanceNeverThrown
-            source.getErrorCollector().addErrorAndContinue(
-                    new SyntaxErrorMessage(new SyntaxException(
-                            "@groovy.lang.Category must define 'value' which is the class to apply this category to",
-                            annotation.getLineNumber(),
-                            annotation.getColumnNumber()),
-                            source));
+            source.getErrorCollector().addErrorAndContinue(new SyntaxErrorMessage(
+                    new SyntaxException("@groovy.lang.Category must define 'value' which is the class to apply this category to",
+                            annotation.getLineNumber(), annotation.getColumnNumber(), annotation.getLastLineNumber(), annotation.getLastColumnNumber()),
+                    source));
             return null;
         } else {
             ClassExpression ce = (ClassExpression) value;
             return ce.getType();
         }
     }
-}
\ No newline at end of file
+}
diff --git a/src/main/org/codehaus/groovy/transform/DelegateASTTransformation.java b/src/main/org/codehaus/groovy/transform/DelegateASTTransformation.java
index 6466074d17..b9350d4016 100644
--- a/src/main/org/codehaus/groovy/transform/DelegateASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/DelegateASTTransformation.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2010 the original author or authors.
+ * Copyright 2008-2012 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -224,10 +224,9 @@ public class DelegateASTTransformation implements ASTTransformation, Opcodes {
     }
 
     public void addError(String msg, ASTNode expr, SourceUnit source) {
-        int line = expr.getLineNumber();
-        int col = expr.getColumnNumber();
         source.getErrorCollector().addErrorAndContinue(
-                new SyntaxErrorMessage(new SyntaxException(msg + '\n', line, col), source)
+                new SyntaxErrorMessage(new SyntaxException(msg + '\n', expr.getLineNumber(), expr.getColumnNumber(),
+                        expr.getLastLineNumber(), expr.getLastColumnNumber()), source)
         );
     }
 }
diff --git a/src/main/org/codehaus/groovy/transform/IndexedPropertyASTTransformation.java b/src/main/org/codehaus/groovy/transform/IndexedPropertyASTTransformation.java
index 19b7b946b4..21f00c016c 100644
--- a/src/main/org/codehaus/groovy/transform/IndexedPropertyASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/IndexedPropertyASTTransformation.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2010 the original author or authors.
+ * Copyright 2008-2012 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -153,10 +153,9 @@ public class IndexedPropertyASTTransformation implements ASTTransformation, Opco
     }
 
     private void addError(String msg, ASTNode expr, SourceUnit source) {
-        int line = expr.getLineNumber();
-        int col = expr.getColumnNumber();
         source.getErrorCollector().addErrorAndContinue(
-                new SyntaxErrorMessage(new SyntaxException(msg + '\n', line, col), source)
+                new SyntaxErrorMessage(new SyntaxException(msg + '\n', expr.getLineNumber(), expr.getColumnNumber(),
+                        expr.getLastLineNumber(), expr.getLastColumnNumber()), source)
         );
     }
 
diff --git a/src/main/org/codehaus/groovy/transform/InheritConstructorsASTTransformation.java b/src/main/org/codehaus/groovy/transform/InheritConstructorsASTTransformation.java
index eac357961f..990ed85116 100644
--- a/src/main/org/codehaus/groovy/transform/InheritConstructorsASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/InheritConstructorsASTTransformation.java
@@ -119,10 +119,9 @@ public class InheritConstructorsASTTransformation implements ASTTransformation,
     }
 
     private void addError(String msg, ASTNode expr, SourceUnit source) {
-        int line = expr.getLineNumber();
-        int col = expr.getColumnNumber();
         source.getErrorCollector().addErrorAndContinue(
-                new SyntaxErrorMessage(new SyntaxException(msg + '\n', line, col), source)
+                new SyntaxErrorMessage(new SyntaxException(msg + '\n', expr.getLineNumber(), expr.getColumnNumber(),
+                        expr.getLastLineNumber(), expr.getLastColumnNumber()), source)
         );
     }
 
diff --git a/src/main/org/codehaus/groovy/transform/LogASTTransformation.java b/src/main/org/codehaus/groovy/transform/LogASTTransformation.java
index 244b7a0a19..3c8827bc3e 100644
--- a/src/main/org/codehaus/groovy/transform/LogASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/LogASTTransformation.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2010 the original author or authors.
+ * Copyright 2003-2012 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -147,10 +147,9 @@ public class LogASTTransformation implements ASTTransformation {
     }
 
     public void addError(String msg, ASTNode expr, SourceUnit source) {
-        int line = expr.getLineNumber();
-        int col = expr.getColumnNumber();
         source.getErrorCollector().addErrorAndContinue(
-                new SyntaxErrorMessage(new SyntaxException(msg + '\n', line, col), source)
+                new SyntaxErrorMessage(new SyntaxException(msg + '\n', expr.getLineNumber(), expr.getColumnNumber(),
+                        expr.getLastLineNumber(), expr.getLastColumnNumber()), source)
         );
     }
 
diff --git a/src/main/org/codehaus/groovy/transform/StaticTypesTransformation.java b/src/main/org/codehaus/groovy/transform/StaticTypesTransformation.java
index 4f5ac787b8..c0d6aafb9a 100644
--- a/src/main/org/codehaus/groovy/transform/StaticTypesTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/StaticTypesTransformation.java
@@ -77,7 +77,8 @@ public class StaticTypesTransformation implements ASTTransformation {
             visitor.setMethodsToBeVisited(Collections.singleton(methodNode));
             visitor.visitMethod(methodNode);
         } else {
-            source.addError(new SyntaxException(STATIC_ERROR_PREFIX + "Unimplemented node type", node.getLineNumber(), node.getColumnNumber()));
+            source.addError(new SyntaxException(STATIC_ERROR_PREFIX + "Unimplemented node type",
+                    node.getLineNumber(), node.getColumnNumber(), node.getLastLineNumber(), node.getLastColumnNumber()));
         }
         if (visitor != null) {
             visitor.performSecondPass();
diff --git a/src/main/org/codehaus/groovy/transform/sc/StaticCompileTransformation.java b/src/main/org/codehaus/groovy/transform/sc/StaticCompileTransformation.java
index 719fa38bb6..74831f82be 100644
--- a/src/main/org/codehaus/groovy/transform/sc/StaticCompileTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/sc/StaticCompileTransformation.java
@@ -67,7 +67,8 @@ public class StaticCompileTransformation extends StaticTypesTransformation {
             visitor.setMethodsToBeVisited(Collections.singleton(methodNode));
             visitor.visitMethod(methodNode);
         } else {
-            source.addError(new SyntaxException(STATIC_ERROR_PREFIX + "Unimplemented node type", node.getLineNumber(), node.getColumnNumber()));
+            source.addError(new SyntaxException(STATIC_ERROR_PREFIX + "Unimplemented node type",
+                    node.getLineNumber(), node.getColumnNumber(), node.getLastLineNumber(), node.getLastColumnNumber()));
         }
         if (visitor != null) {
             visitor.performSecondPass();
diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index be97b79cfa..882e71fb1a 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -58,7 +58,7 @@ import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.*;
  * @author Jochen Theodorou
  */
 public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
-	private final static Object ERROR_COLLECTOR = ErrorCollector.class;
+    private final static Object ERROR_COLLECTOR = ErrorCollector.class;
     private static final ClassNode ITERABLE_TYPE = ClassHelper.make(Iterable.class);
     private final static List<MethodNode> EMPTY_METHODNODE_LIST = Collections.emptyList();
     private static final ClassNode TYPECHECKED_CLASSNODE = ClassHelper.make(TypeChecked.class);
@@ -297,7 +297,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 vexp != VariableExpression.SUPER_EXPRESSION) {
             if (vexp.getName().equals("this")) storeType(vexp, classNode);
             if (vexp.getName().equals("super")) storeType(vexp, classNode.getSuperClass());
-            if (closureExpression!=null) {
+            if (closureExpression != null) {
                 if (vexp.getName().equals("owner")
                         || vexp.getName().equals("delegate")
                         || vexp.getName().equals("thisObject")) {
@@ -350,7 +350,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         if (!existsProperty(pexp, true)) {
             // if the property doesn't exist, we can do a last check, which is verifying if a setter exists
             // and that the expression is the left hand side of an assignment
-            if (currentBinaryExpression!=null && currentBinaryExpression.getLeftExpression()==pexp && isAssignment(currentBinaryExpression.getOperation().getType())) {
+            if (currentBinaryExpression != null && currentBinaryExpression.getLeftExpression() == pexp && isAssignment(currentBinaryExpression.getOperation().getType())) {
                 if (hasSetter(pexp)) return;
             }
 
@@ -402,8 +402,8 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 resultType = lType;
             }
             if (isArrayOp(op) &&
-                    oldBinaryExpression!=null
-                    && oldBinaryExpression.getLeftExpression()==expression
+                    oldBinaryExpression != null
+                    && oldBinaryExpression.getLeftExpression() == expression
                     && isAssignment(oldBinaryExpression.getOperation().getType())
                     && !lType.isArray()) {
                 // left hand side of an assignment : map['foo'] = ...
@@ -414,7 +414,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 } else if (nodes.isEmpty() && lType.implementsInterface(LIST_TYPE)) {
                     nodes = findMethod(lType, "add", arguments);
                 }*/
-                if (nodes.size()==1) {
+                if (nodes.size() == 1) {
                     typeCheckMethodsWithGenerics(lType, arguments, nodes.get(0), expression);
                 }
             }
@@ -485,12 +485,12 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         // check if constructor call expression makes use of the diamond operator
         ClassNode node = cce.getType();
         if (node.isUsingGenerics() && node instanceof InnerClassNode && ((InnerClassNode) node).isAnonymous()
-                && (node.getGenericsTypes()==null || node.getGenericsTypes().length==0) && lType.isUsingGenerics()) {
+                && (node.getGenericsTypes() == null || node.getGenericsTypes().length == 0) && lType.isUsingGenerics()) {
             // InterfaceA<Foo> obj = new InterfaceA<>() { ... }
             // InterfaceA<Foo> obj = new ClassA<>() { ... }
             // ClassA<Foo> obj = new ClassA<>() { ... }
             addStaticTypeError("Cannot use diamond <> with anonymous inner classes", cce);
-        } else if (node.isUsingGenerics() && node.getGenericsTypes()!=null && node.getGenericsTypes().length == 0) {
+        } else if (node.isUsingGenerics() && node.getGenericsTypes() != null && node.getGenericsTypes().length == 0) {
             ArgumentListExpression argumentListExpression = InvocationWriter.makeArgumentList(cce.getArguments());
             if (argumentListExpression.getExpressions().isEmpty()) {
                 GenericsType[] genericsTypes = lType.getGenericsTypes();
@@ -678,8 +678,8 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                                     "Make sure to call toString() on all GString values.", assignmentExpression.getRightExpression());
                         } else {
                             addStaticTypeError("Incompatible generic argument types. Cannot assign "
-                                + wrappedRHS.toString(false)
-                                + " to: " + leftExpressionType.toString(false), assignmentExpression.getRightExpression());
+                                    + wrappedRHS.toString(false)
+                                    + " to: " + leftExpressionType.toString(false), assignmentExpression.getRightExpression());
                         }
                     }
                 }
@@ -846,7 +846,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                             return true;
                         }
                     }
-                    if (getter==null && checkForReadOnly) {
+                    if (getter == null && checkForReadOnly) {
                         FieldNode field = current.getDeclaredField(propertyName);
                         if (field != null) {
                             if (visitor != null) visitor.visitField(field);
@@ -856,7 +856,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                     }
                     // if the property expression is an attribute expression (o.@attr), then
                     // we stop now, otherwise we must check the parent class
-                    if (/*!isAttributeExpression && */current.getSuperClass()!=null) {
+                    if (/*!isAttributeExpression && */current.getSuperClass() != null) {
                         queue.add(current.getSuperClass());
                     }
                 }
@@ -891,18 +891,18 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                         }
                         // if the property expression is an attribute expression (o.@attr), then
                         // we stop now, otherwise we must check the parent class
-                        if (!isAttributeExpression && current.getSuperClass()!=null) {
+                        if (!isAttributeExpression && current.getSuperClass() != null) {
                             queue.add(current.getSuperClass());
                         }
                     }
                 }
                 // GROOVY-5568, the property may be defined by DGM
-                List<MethodNode> methods = findDGMMethodsByNameAndArguments(testClass, "get"+capName, ClassNode.EMPTY_ARRAY);
+                List<MethodNode> methods = findDGMMethodsByNameAndArguments(testClass, "get" + capName, ClassNode.EMPTY_ARRAY);
                 if (!methods.isEmpty()) {
                     List<MethodNode> methodNodes = chooseBestMethod(testClass, methods, ClassNode.EMPTY_ARRAY);
-                    if (methodNodes.size()==1) {
+                    if (methodNodes.size() == 1) {
                         MethodNode getter = methodNodes.get(0);
-                        if (visitor!=null) {
+                        if (visitor != null) {
                             visitor.visitMethod(getter);
                         }
                         storeType(pexp, inferReturnTypeGenerics(testClass, getter, ArgumentListExpression.EMPTY_ARGUMENTS));
@@ -954,7 +954,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 current = current.redirect();
                 // check that a setter also exists
                 MethodNode setterMethod = current.getSetterMethod("set" + capName, false);
-                if (setterMethod!=null) {
+                if (setterMethod != null) {
                     storeType(pexp, setterMethod.getParameters()[0].getType());
                     return true;
                 }
@@ -973,7 +973,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             isInStaticContext = node.isInStaticContext();
             super.visitField(node);
             Expression init = node.getInitialExpression();
-            if (init!=null) {
+            if (init != null) {
                 FieldExpression left = new FieldExpression(node);
                 BinaryExpression bexp = new BinaryExpression(
                         left,
@@ -983,7 +983,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 bexp.setSourcePosition(init);
                 typeCheckAssignment(bexp, left, node.getOriginType(), init, getType(init));
                 if (init instanceof ConstructorCallExpression) {
-                    inferDiamondType((ConstructorCallExpression)init, node.getOriginType());
+                    inferDiamondType((ConstructorCallExpression) init, node.getOriginType());
                 }
             }
         } finally {
@@ -1015,7 +1015,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             if (!checkCompatibleAssignmentTypes(forLoopVariableType, componentType)) {
                 addStaticTypeError("Cannot loop with element of type " + forLoopVariableType.toString(false) + " with collection of type " + collectionType.toString(false), forLoop);
             }
-            if (forLoopVariableType!=DYNAMIC_TYPE) {
+            if (forLoopVariableType != DYNAMIC_TYPE) {
                 // user has specified a type, prefer it over the inferred type
                 componentType = forLoopVariableType;
             }
@@ -1228,10 +1228,10 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         Expression arguments = call.getArguments();
         ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(arguments));
         MethodNode node = null;
-        if (args.length == 1 && implementsInterfaceOrIsSubclassOf(args[0], MAP_TYPE) && findMethod(receiver, "<init>", ClassNode.EMPTY_ARRAY).size()==1) {
+        if (args.length == 1 && implementsInterfaceOrIsSubclassOf(args[0], MAP_TYPE) && findMethod(receiver, "<init>", ClassNode.EMPTY_ARRAY).size() == 1) {
             // bean-style constructor
             node = typeCheckMapConstructor(call, receiver, arguments);
-            if (node!=null) {
+            if (node != null) {
                 storeTargetMethod(call, node);
                 return;
             }
@@ -1241,7 +1241,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             if (node.getParameters().length == 0 && args.length == 1 && implementsInterfaceOrIsSubclassOf(args[0], MAP_TYPE)) {
                 node = typeCheckMapConstructor(call, receiver, arguments);
             }
-            if (node!=null) storeTargetMethod(call, node);
+            if (node != null) storeTargetMethod(call, node);
         }
     }
 
@@ -1371,10 +1371,10 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             return;
         }
         ErrorCollector collector = (ErrorCollector) node.getNodeMetaData(ERROR_COLLECTOR);
-        if (collector!=null) {
+        if (collector != null) {
             errorCollector.addCollectorContents(collector);
         } else {
-        	startMethodInference(node, errorCollector);
+            startMethodInference(node, errorCollector);
         }
         node.removeNodeMetaData(ERROR_COLLECTOR);
     }
@@ -1402,14 +1402,14 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             isInStaticContext = node.isStatic();
             super.visitMethod(node);
             ClassNode rtype = (ClassNode) node.getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);
-            if (rtype==null) {
+            if (rtype == null) {
                 node.putNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE, node.getReturnType());
             }
             addTypeCheckingInfoAnnotation(node);
         } finally {
             isInStaticContext = osc;
         }
-        
+
         errorCollector = oldCollector;
         node.putNodeMetaData(ERROR_COLLECTOR, collector);
     }
@@ -1517,7 +1517,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                     ClassNode returnType = getType(directMethodCallCandidate);
                     if (returnType.isUsingGenerics() && !returnType.isEnum()) {
                         ClassNode irtg = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);
-                        returnType = irtg!=null && implementsInterfaceOrIsSubclassOf(irtg, returnType)?irtg:returnType;
+                        returnType = irtg != null && implementsInterfaceOrIsSubclassOf(irtg, returnType) ? irtg : returnType;
                     }
                     storeType(call, returnType);
                     storeTargetMethod(call, directMethodCallCandidate);
@@ -1548,12 +1548,12 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
     }
 
     /**
-     * visit a method call target, to infer the type. Don't report errors right 
+     * visit a method call target, to infer the type. Don't report errors right
      * away, that will be done by a later visitMethod call
      */
     private void silentlyVisitMethodNode(final MethodNode directMethodCallCandidate) {
         // visit is authorized because the classnode belongs to the same source unit
-    	//TODO: add method to ErrorCollector to get a CompilerConfiguration from it instead of simply using a new one with maybe wrong settings
+        //TODO: add method to ErrorCollector to get a CompilerConfiguration from it instead of simply using a new one with maybe wrong settings
         ErrorCollector collector = new ErrorCollector(new CompilerConfiguration());
         startMethodInference(directMethodCallCandidate, collector);
     }
@@ -1729,7 +1729,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                     // if the receiver is "this" or "implicit this", then we must make sure that the compatible
                     // methods are only static if we are in a static context
                     if (!mn.isEmpty() && isInStaticContext && (call.isImplicitThis()
-                            || (objectExpression instanceof VariableExpression && ((VariableExpression)objectExpression).isThisExpression()))) {
+                            || (objectExpression instanceof VariableExpression && ((VariableExpression) objectExpression).isThisExpression()))) {
                         // we create a separate method list just to be able to print out
                         // a nice error message to the user
                         List<MethodNode> staticMethods = new LinkedList<MethodNode>();
@@ -1746,7 +1746,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                             // choose an arbitrary method to display an error message
                             MethodNode node = nonStaticMethods.get(0);
                             ClassNode owner = node.getDeclaringClass();
-                            addStaticTypeError("Non static method "+owner.getName()+"#"+node.getName()+" cannot be called from static context", call);
+                            addStaticTypeError("Non static method " + owner.getName() + "#" + node.getName() + " cannot be called from static context", call);
                         }
                     }
 
@@ -1756,13 +1756,13 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                         break;
                     }
                 }
-                if (mn.isEmpty() && closureExpression!=null && args.length==0) {
+                if (mn.isEmpty() && closureExpression != null && args.length == 0) {
                     // add special handling of getDelegate() and getOwner()
                     if ("getDelegate".equals(name)) {
                         mn = Collections.singletonList(GET_DELEGATE);
                     } else if ("getOwner".equals(name)) {
                         mn = Collections.singletonList(GET_OWNER);
-                    }else if ("getThisObject".equals(name)) {
+                    } else if ("getThisObject".equals(name)) {
                         mn = Collections.singletonList(GET_THISOBJECT);
                     }
                 }
@@ -1789,7 +1789,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                         ClassNode returnType = getType(directMethodCallCandidate);
                         if (isUsingGenericsOrIsArrayUsingGenerics(returnType)) {
                             ClassNode irtg = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);
-                            returnType = irtg!=null && implementsInterfaceOrIsSubclassOf(irtg, returnType)?irtg:returnType;
+                            returnType = irtg != null && implementsInterfaceOrIsSubclassOf(irtg, returnType) ? irtg : returnType;
                         }
                         storeType(call, returnType);
                         storeTargetMethod(call, directMethodCallCandidate);
@@ -2128,7 +2128,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 return getGroupOperationResultType(leftRedirect, rightRedirect);
             }
         }
-        if (isNumberCategory(getWrapper(rightRedirect)) && isNumberCategory(getWrapper(leftRedirect)) && (MOD == op || MOD_EQUAL==op)) {
+        if (isNumberCategory(getWrapper(rightRedirect)) && isNumberCategory(getWrapper(leftRedirect)) && (MOD == op || MOD_EQUAL == op)) {
             return leftRedirect;
         }
 
@@ -2225,10 +2225,10 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
     private boolean areCategoryMethodCalls(final List<MethodNode> foundMethods, final String name, final ClassNode[] args) {
         boolean category = false;
-        if ("use".equals(name) && args!=null && args.length==2 && args[1].equals(ClassHelper.CLOSURE_TYPE)) {
+        if ("use".equals(name) && args != null && args.length == 2 && args[1].equals(ClassHelper.CLOSURE_TYPE)) {
             category = true;
             for (MethodNode method : foundMethods) {
-                if (!(method instanceof ExtensionMethodNode) || !((ExtensionMethodNode)method).getExtensionMethodNode().getDeclaringClass().equals(DGM_CLASSNODE)) {
+                if (!(method instanceof ExtensionMethodNode) || !((ExtensionMethodNode) method).getExtensionMethodNode().getDeclaringClass().equals(DGM_CLASSNODE)) {
                     category = false;
                 }
             }
@@ -2251,7 +2251,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             methods = receiver.getMethods(name);
             if (receiver.isInterface()) {
                 ClassNode[] interfaces = receiver.getInterfaces();
-                if (interfaces!=null && interfaces.length>0) {
+                if (interfaces != null && interfaces.length > 0) {
                     methods = new ArrayList<MethodNode>(methods);
                     for (ClassNode node : interfaces) {
                         List<MethodNode> intfMethods = node.getMethods(name);
@@ -2280,7 +2280,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                     // we don't use property exists there because findMethod is called on super clases recursively
                     PropertyNode property = null;
                     ClassNode curNode = receiver;
-                    while (property==null && curNode!=null) {
+                    while (property == null && curNode != null) {
                         property = curNode.getProperty(pname);
                         curNode = curNode.getSuperClass();
                     }
@@ -2301,7 +2301,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                     String pname = java.beans.Introspector.decapitalize(name.substring(3));
                     ClassNode curNode = receiver;
                     PropertyNode property = null;
-                    while (property==null && curNode!=null) {
+                    while (property == null && curNode != null) {
                         property = curNode.getProperty(pname);
                         curNode = curNode.getSuperClass();
                     }
@@ -2327,7 +2327,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         if (!chosen.isEmpty()) return chosen;
 
         // GROOVY-5566
-        if (receiver instanceof InnerClassNode && ((InnerClassNode) receiver).isAnonymous() && methods.size()==1 && args!=null && "<init>".equals(name)) {
+        if (receiver instanceof InnerClassNode && ((InnerClassNode) receiver).isAnonymous() && methods.size() == 1 && args != null && "<init>".equals(name)) {
             MethodNode constructor = methods.get(0);
             if (constructor.getParameters().length == args.length) {
                 return methods;
@@ -2423,7 +2423,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             return inferMapExpressionType((MapExpression) exp);
         }
         if (exp instanceof MethodNode) {
-            if ((exp==GET_DELEGATE || exp==GET_OWNER || exp==GET_THISOBJECT) && closureExpression!=null) {
+            if ((exp == GET_DELEGATE || exp == GET_OWNER || exp == GET_THISOBJECT) && closureExpression != null) {
                 return classNode;
             }
             ClassNode ret = (ClassNode) exp.getNodeMetaData(StaticTypesMarker.INFERRED_RETURN_TYPE);
@@ -2586,7 +2586,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                     if (OBJECT_TYPE.equals(type)) {
                         // special case for handing Object<E> -> Object
                         for (String key : typePlaceholders.keySet()) {
-                            resolvedPlaceholders.put(key, new GenericsType(actualType.isArray()?actualType.getComponentType():actualType));
+                            resolvedPlaceholders.put(key, new GenericsType(actualType.isArray() ? actualType.getComponentType() : actualType));
                         }
                     } else {
                         while (!actualType.equals(type)) {
@@ -2633,9 +2633,9 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             if (firstGenericsType.isWildcard()) {
                 // ? extends Foo
                 // ? super Foo
-                if (firstGenericsType.getLowerBound()!=null) return firstGenericsType.getLowerBound();
+                if (firstGenericsType.getLowerBound() != null) return firstGenericsType.getLowerBound();
                 ClassNode[] upperBounds = firstGenericsType.getUpperBounds();
-                if (upperBounds.length==1) return upperBounds[0];
+                if (upperBounds.length == 1) return upperBounds[0];
                 return new UnionTypeClassNode(upperBounds);
             }
             return firstGenericsType.getType();
@@ -2669,9 +2669,9 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
         ClassNode type = fullyResolveType(gt.getType(), placeholders);
         ClassNode lowerBound = gt.getLowerBound();
-        if (lowerBound!=null) lowerBound = fullyResolveType(lowerBound, placeholders);
+        if (lowerBound != null) lowerBound = fullyResolveType(lowerBound, placeholders);
         ClassNode[] upperBounds = gt.getUpperBounds();
-        if (upperBounds!=null) {
+        if (upperBounds != null) {
             ClassNode[] copy = new ClassNode[upperBounds.length];
             for (int i = 0, upperBoundsLength = upperBounds.length; i < upperBoundsLength; i++) {
                 final ClassNode upperBound = upperBounds[i];
@@ -2687,7 +2687,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
     private static ClassNode fullyResolveType(final ClassNode type, final Map<String, GenericsType> placeholders) {
         if (type.isUsingGenerics() && !type.isGenericsPlaceHolder()) {
             GenericsType[] gts = type.getGenericsTypes();
-            if (gts!=null) {
+            if (gts != null) {
                 GenericsType[] copy = new GenericsType[gts.length];
                 for (int i = 0; i < gts.length; i++) {
                     GenericsType genericsType = gts[i];
@@ -2698,10 +2698,10 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             ClassNode result = type.getPlainNodeReference();
             result.setGenericsTypes(gts);
             return result;
-        } else if (type.isUsingGenerics() && OBJECT_TYPE.equals(type) && type.getGenericsTypes()!=null) {
+        } else if (type.isUsingGenerics() && OBJECT_TYPE.equals(type) && type.getGenericsTypes() != null) {
             // Object<T>
             GenericsType genericsType = placeholders.get(type.getGenericsTypes()[0].getName());
-            if (genericsType!=null) {
+            if (genericsType != null) {
                 return genericsType.getType();
             }
         } else if (type.isArray()) {
@@ -2712,11 +2712,12 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
     /**
      * Checks that the parameterized generics of an argument are compatible with the generics of the parameter.
+     *
      * @param parameterType the parameter type of a method
-     * @param argumentType the type of the argument passed to the method
+     * @param argumentType  the type of the argument passed to the method
      */
     private boolean typeCheckMethodArgumentWithGenerics(ClassNode parameterType, ClassNode argumentType, boolean lastArg) {
-        if (UNKNOWN_PARAMETER_TYPE==argumentType) {
+        if (UNKNOWN_PARAMETER_TYPE == argumentType) {
             // called with null
             return true;
         }
@@ -2739,7 +2740,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         } else if (parameterType.isArray() && argumentType.isArray()) {
             // verify component type
             typeCheckMethodArgumentWithGenerics(parameterType.getComponentType(), argumentType.getComponentType(), lastArg);
-        }else if (lastArg && parameterType.isArray()) {
+        } else if (lastArg && parameterType.isArray()) {
             // verify component type, but if we reach that point, the only possibility is that the argument is
             // the last one of the call, so we're in the cast of a vargs call
             // (otherwise, we face a type checker bug)
@@ -2751,7 +2752,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
     private void typeCheckMethodsWithGenerics(ClassNode receiver, ClassNode[] arguments, MethodNode candidateMethod, Expression location) {
         if (CLASS_Type.equals(receiver)
                 && receiver.isUsingGenerics()
-                && candidateMethod.getDeclaringClass()!=receiver
+                && candidateMethod.getDeclaringClass() != receiver
                 && !(candidateMethod instanceof ExtensionMethodNode)) {
             typeCheckMethodsWithGenerics(receiver.getGenericsTypes()[0].getType(), arguments, candidateMethod, location);
             return;
@@ -2760,10 +2761,10 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         // both candidate method and receiver have generic information so a check is possible
         Parameter[] parameters = candidateMethod.getParameters();
         GenericsType[] genericsTypes = candidateMethod.getGenericsTypes();
-        boolean methodUsesGenerics = (genericsTypes!=null && genericsTypes.length>0);
+        boolean methodUsesGenerics = (genericsTypes != null && genericsTypes.length > 0);
         boolean isExtensionMethod = candidateMethod instanceof ExtensionMethodNode;
         if (isExtensionMethod && methodUsesGenerics) {
-            ClassNode[] dgmArgs = new ClassNode[arguments.length+1];
+            ClassNode[] dgmArgs = new ClassNode[arguments.length + 1];
             dgmArgs[0] = receiver;
             System.arraycopy(arguments, 0, dgmArgs, 1, arguments.length);
             MethodNode extensionMethodNode = ((ExtensionMethodNode) candidateMethod).getExtensionMethodNode();
@@ -2780,7 +2781,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
                 Map<String, GenericsType> placeholders = new HashMap<String, GenericsType>();
                 GenericsType[] gts = dgmMethodFirstArgType.getGenericsTypes();
-                for (int i = 0; gts!=null && i < gts.length; i++) {
+                for (int i = 0; gts != null && i < gts.length; i++) {
                     GenericsType gt = gts[i];
                     if (gt.isPlaceholder()) {
                         placeholders.put(gt.getName(), firstArgType.getGenericsTypes()[i]);
@@ -2792,10 +2793,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 for (int i = 1; i < dgmMethodArgsWithPlaceholdersReplaced.length; i++) {
                     ClassNode substitute = dgmMethodArgs[i].getType();
                     substitute = fullyResolveType(substitute, placeholders);
-                    dgmMethodArgsWithPlaceholdersReplaced[i] = new Parameter(
-                            substitute,
-                            "arg"+i
-                    );
+                    dgmMethodArgsWithPlaceholdersReplaced[i] = new Parameter(substitute, "arg" + i);
                 }
                 MethodNode vdgm = new MethodNode(
                         extensionMethodNode.getName(),
@@ -2810,7 +2808,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             }
         }
         Map<String, GenericsType> classGTs = GenericsUtils.extractPlaceholders(receiver);
-        if (parameters.length>arguments.length) {
+        if (parameters.length > arguments.length) {
             // this is a limitation that must be removed in a future version
             // we cannot check generic type arguments if there are default parameters!
             return;
@@ -2821,7 +2819,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             ClassNode type = parameters[pindex].getType();
             type = fullyResolveType(type, classGTs);
             ptypes[pindex] = type;
-            failure |= !typeCheckMethodArgumentWithGenerics(type, arguments[i], i>=parameters.length-1);
+            failure |= !typeCheckMethodArgumentWithGenerics(type, arguments[i], i >= parameters.length - 1);
         }
         if (failure) {
             addStaticTypeError("Cannot call " + receiver.getName() + "#" +
@@ -2846,12 +2844,11 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
     @Override
     protected void addError(final String msg, final ASTNode expr) {
-        int line = expr.getLineNumber();
-        int col = expr.getColumnNumber();
         Long err = ((long) expr.getLineNumber()) << 16 + expr.getColumnNumber();
         if (!reportedErrors.contains(err)) {
-            errorCollector.addErrorAndContinue(
-                    new SyntaxErrorMessage(new SyntaxException(msg + '\n', line, col), source)
+            errorCollector.addErrorAndContinue(new SyntaxErrorMessage(
+                    new SyntaxException(msg + '\n', expr.getLineNumber(), expr.getColumnNumber(), expr.getLastLineNumber(), expr.getLastColumnNumber()),
+                    source)
             );
             reportedErrors.add(err);
         }
@@ -3171,7 +3168,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
     protected static class SignatureCodecFactory {
         static SignatureCodec getCodec(int version) {
             switch (version) {
-                case 1: return new SignatureCodecVersion1();
+                case 1:  return new SignatureCodecVersion1();
                 default: return null;
             }
         }
