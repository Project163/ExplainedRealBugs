diff --git a/src/main/groovy/lang/DelegatingMetaClass.java b/src/main/groovy/lang/DelegatingMetaClass.java
index baa378f794..63b43d243f 100644
--- a/src/main/groovy/lang/DelegatingMetaClass.java
+++ b/src/main/groovy/lang/DelegatingMetaClass.java
@@ -17,6 +17,7 @@
 package groovy.lang;
 
 import org.codehaus.groovy.ast.ClassNode;
+import org.codehaus.groovy.runtime.InvokerHelper;
 
 import java.lang.reflect.Method;
 import java.util.List;
@@ -26,7 +27,7 @@ import java.util.List;
  *
  */
 
-public class DelegatingMetaClass implements MetaClass, MutableMetaClass {
+public class DelegatingMetaClass implements MetaClass, MutableMetaClass, GroovyObject {
     protected MetaClass delegate;
     
     public DelegatingMetaClass(final MetaClass delegate) {
@@ -171,12 +172,11 @@ public class DelegatingMetaClass implements MetaClass, MutableMetaClass {
     public int hashCode() {
         return delegate.hashCode();
     }
-    /* (non-Javadoc)
-     * @see java.lang.Object#toString()
-     */
-    public String toString() {
-        return delegate.toString();
+
+    public String toString() { 
+        return super.toString() + "[" + delegate.toString()+ "]";
     }
+
     /**
      * @deprecated
      */
@@ -247,4 +247,52 @@ public class DelegatingMetaClass implements MetaClass, MutableMetaClass {
 	public void setAdaptee(MetaClass adaptee) {
 		this.delegate = adaptee; 
 	}
+
+    public MetaClass getAdaptee() {
+        return this.delegate; 
+    }
+
+    public Object invokeMethod(String name, Object args) {
+      try {
+        return getMetaClass().invokeMethod(this, name, args);
+      }
+      catch (MissingMethodException e) {
+        if (delegate instanceof GroovyObject)
+          return ((GroovyObject)delegate).invokeMethod(name, args);
+        else
+          throw e;
+      }
+    }
+
+    public Object getProperty(String property) {
+      try {
+        return getMetaClass().getProperty(this, property);
+      }
+      catch (MissingPropertyException e) {
+        if (delegate instanceof GroovyObject)
+          return ((GroovyObject)delegate).getProperty(property);
+        else
+          throw e;
+      }
+    }
+
+    public void setProperty(String property, Object newValue) {
+        try {
+          getMetaClass().setProperty(this, property, newValue);
+        }
+        catch (MissingPropertyException e) {
+          if (delegate instanceof GroovyObject)
+            ((GroovyObject)delegate).setProperty(property, newValue);
+          else
+            throw e;
+        }
+    }
+
+    public MetaClass getMetaClass() {
+        return InvokerHelper.getMetaClass(this);
+    }
+
+    public void setMetaClass(MetaClass metaClass) {
+        throw new UnsupportedOperationException();
+    }
 }
diff --git a/src/main/groovy/lang/ExpandoMetaClass.java b/src/main/groovy/lang/ExpandoMetaClass.java
index c0e2a004ff..50de0e729e 100644
--- a/src/main/groovy/lang/ExpandoMetaClass.java
+++ b/src/main/groovy/lang/ExpandoMetaClass.java
@@ -95,7 +95,6 @@ public class ExpandoMetaClass extends MetaClassImpl implements GroovyObject {
 
     // These two properties are used when no ExpandoMetaClassCreationHandle is present
 
-    private boolean hasCreationHandle;
     private MetaClass myMetaClass;
     private boolean allowChangesAfterInit;
 
@@ -342,7 +341,7 @@ public class ExpandoMetaClass extends MetaClassImpl implements GroovyObject {
      * Call to disable the global use of ExpandoMetaClass
      */
     public static void disableGlobally() {
-        GroovySystem.getMetaClassRegistry().setMetaClassCreationHandle( new MetaClassRegistry.MetaClassCreationHandle() );
+        ExpandoMetaClassCreationHandle.disable();
     }
 
 
@@ -797,7 +796,6 @@ public class ExpandoMetaClass extends MetaClassImpl implements GroovyObject {
 		// tell child classes of this class to re-inherit their methods
 		if(registry.getMetaClassCreationHandler() instanceof ExpandoMetaClassCreationHandle) {
 			ExpandoMetaClassCreationHandle creationHandler = (ExpandoMetaClassCreationHandle)registry.getMetaClassCreationHandler();
-			hasCreationHandle  = true;
 			if(!creationHandler.hasModifiedMetaClass(this))
 				creationHandler.registerModifiedMetaClass(this);
 
diff --git a/src/main/groovy/lang/ExpandoMetaClassCreationHandle.java b/src/main/groovy/lang/ExpandoMetaClassCreationHandle.java
index 4bb01bd307..ed3ae36ab8 100644
--- a/src/main/groovy/lang/ExpandoMetaClassCreationHandle.java
+++ b/src/main/groovy/lang/ExpandoMetaClassCreationHandle.java
@@ -38,6 +38,8 @@ import java.util.*;
  */
 public class ExpandoMetaClassCreationHandle extends MetaClassCreationHandle {
 
+    public static final ExpandoMetaClassCreationHandle instance = new ExpandoMetaClassCreationHandle();
+
 	private final Map modifiedExpandos = new ConcurrentReaderHashMap();
 
 
@@ -111,6 +113,18 @@ public class ExpandoMetaClassCreationHandle extends MetaClassCreationHandle {
      *
      */
     public static void enable() {
-        GroovySystem.getMetaClassRegistry().setMetaClassCreationHandle(new ExpandoMetaClassCreationHandle());
+        final MetaClassRegistry metaClassRegistry = GroovySystem.getMetaClassRegistry();
+        if (metaClassRegistry.getMetaClassCreationHandler() != instance) {
+           instance.modifiedExpandos.clear();
+           metaClassRegistry.setMetaClassCreationHandle(instance);
+        }
+    }
+
+    public static void disable() {
+        final MetaClassRegistry metaClassRegistry = GroovySystem.getMetaClassRegistry();
+        if (metaClassRegistry.getMetaClassCreationHandler() == instance) {
+            instance.modifiedExpandos.clear();
+            metaClassRegistry.setMetaClassCreationHandle(new MetaClassCreationHandle());
+        }
     }
 }
diff --git a/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java b/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
index a1e0f3e5e6..c33c081744 100644
--- a/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
+++ b/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
@@ -7426,14 +7426,16 @@ public class DefaultGroovyMethods {
      * String.metaClass.myMethod = { println "foo" }
      *
      * @param c The java.lang.Class instance
-     * @return An ExpandoMetaClass instance
+     * @return An MetaClass instance
      */
-    public static ExpandoMetaClass getMetaClass(Class c) {
+    public static MetaClass getMetaClass(Class c) {
         MetaClassRegistry metaClassRegistry = GroovySystem.getMetaClassRegistry();
         MetaClass mc = metaClassRegistry.getMetaClass(c);
-        if (mc instanceof ExpandoMetaClass) return (ExpandoMetaClass) mc;
+        if (mc instanceof ExpandoMetaClass
+         || mc instanceof DelegatingMetaClass && ((DelegatingMetaClass)mc).getAdaptee() instanceof ExpandoMetaClass)
+            return mc;
         else {
-            ExpandoMetaClass emc = new ExpandoMetaClass(c, true, true);
+            MetaClass emc = ExpandoMetaClassCreationHandle.instance.create(c, metaClassRegistry);
             emc.initialize();
             metaClassRegistry.setMetaClass(c, emc);
             return emc;
diff --git a/src/test/groovy/bugs/CustomMetaClassTest.groovy b/src/test/groovy/bugs/CustomMetaClassTest.groovy
index b45f9fc8c6..a77412013c 100644
--- a/src/test/groovy/bugs/CustomMetaClassTest.groovy
+++ b/src/test/groovy/bugs/CustomMetaClassTest.groovy
@@ -36,7 +36,7 @@ class CustomMetaClassTest extends GroovyTestCase{
     }
 
   void testNormalCreated () {
-      assertTrue metaClass instanceof groovy.runtime.metaclass.groovy.bugs.CustomMetaClassTestMetaClass
+      assertEquals groovy.runtime.metaclass.groovy.bugs.CustomMetaClassTestMetaClass, metaClass.class
       assertEquals  MetaClassImpl, metaClass.delegate.class
   }
 
@@ -47,7 +47,44 @@ class CustomMetaClassTest extends GroovyTestCase{
         assertTrue metaClass instanceof groovy.runtime.metaclass.groovy.bugs.CustomMetaClassTestMetaClass
         assertEquals  ExpandoMetaClass, metaClass.delegate.class
     ExpandoMetaClass.disableGlobally()
+    GroovySystem.metaClassRegistry.removeMetaClass metaClass.theClass
+  }
+
+  void testStaticMetaClass () {
+      // Custom metaclass created
+      assertEquals  groovy.runtime.metaclass.groovy.bugs.CustomMetaClassTestMetaClass, metaClass.class
+      // delegated to MCImpl
+      assertEquals  MetaClassImpl, metaClass.delegate.class
+
+      MetaClass expandoMetaClass = CustomMetaClassTest.metaClass
+
+      // It still to be custom
+      assertEquals groovy.runtime.metaclass.groovy.bugs.CustomMetaClassTestMetaClass, expandoMetaClass.class
+      // But delegated to EMC
+      assertEquals  ExpandoMetaClass, expandoMetaClass.delegate.class
+
+      // But object still to hold reference to old one
+      assertEquals  MetaClassImpl, metaClass.delegate.class
+      // let give it chance to reinitialize
+      metaClass = null
+      // Now it should be OK
+      assertEquals  ExpandoMetaClass, expandoMetaClass.delegate.class
+
+      expandoMetaClass.toString = {
+          -> "I am modified"
+      }
+
+      assertEquals "I am modified", toString()
+
+      assertEquals "I am modified", metaClass.invokeMethod(this, "toString", null)
+
+      expandoMetaClass.static.toString = {
+          -> "I am modified static"
+      }
+
+      assertEquals "I am modified static", getClass().toString()
   }
+
 }
 
 class MyDelegatingMetaClass extends groovy.lang.DelegatingMetaClass
diff --git a/src/test/groovy/lang/ExpandoMetaClassCreationHandleTest.groovy b/src/test/groovy/lang/ExpandoMetaClassCreationHandleTest.groovy
index d96e8b9e68..af2b833b2a 100644
--- a/src/test/groovy/lang/ExpandoMetaClassCreationHandleTest.groovy
+++ b/src/test/groovy/lang/ExpandoMetaClassCreationHandleTest.groovy
@@ -41,8 +41,9 @@ class ExpandoMetaClassCreationHandleTest extends GroovyTestCase {
 
         Object.metaClass.doStuff = {-> delegate.toString().toUpperCase() }
 
-        assertEquals "HELLO", foo.doStuff()                
+        assertEquals "HELLO", foo.doStuff()
     }
+
     void testInheritFromInterfaceHeirarchy() {
         registry.removeMetaClass(IBar.class)
         registry.removeMetaClass(Foo.class)
@@ -141,8 +142,6 @@ class ExpandoMetaClassCreationHandleTest extends GroovyTestCase {
 
         assertEquals "bar!!", t.doStuff()
         assertEquals "foo", t.invokeMe()
-
-
     }
 
 	void testInterfaceMethodInheritance() {
@@ -265,4 +264,4 @@ class Test1 implements Foo {
 }
 class EMCInheritTest extends Test1 {
 
-}
\ No newline at end of file
+}
