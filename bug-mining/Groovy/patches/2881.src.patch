diff --git a/src/main/org/codehaus/groovy/ast/expr/CastExpression.java b/src/main/org/codehaus/groovy/ast/expr/CastExpression.java
index 15723cc600..02db7f3318 100644
--- a/src/main/org/codehaus/groovy/ast/expr/CastExpression.java
+++ b/src/main/org/codehaus/groovy/ast/expr/CastExpression.java
@@ -32,6 +32,7 @@ public class CastExpression extends Expression {
     private final Expression expression;
     private boolean ignoreAutoboxing=false;
     private boolean coerce = false;
+    private boolean strict = false;
 
     public static CastExpression asExpression(ClassNode type, Expression expression) {
         CastExpression answer = new CastExpression(type, expression);
@@ -61,6 +62,24 @@ public class CastExpression extends Expression {
         this.coerce = coerce;
     }
 
+    /**
+     * If strict mode is true, then when the compiler generates a cast, it will disable
+     * Groovy casts and rely on a strict cast (CHECKCAST)
+     * @return true if strict mode is enable
+     */
+    public boolean isStrict() {
+        return strict;
+    }
+
+    /**
+     * If strict mode is true, then when the compiler generates a cast, it will disable
+     * Groovy casts and rely on a strict cast (CHECKCAST)
+     * @param strict strict mode
+     */
+    public void setStrict(final boolean strict) {
+        this.strict = strict;
+    }
+
     public String toString() {
         return super.toString() +"[(" + getType().getName() + ") " + expression + "]";
     }
@@ -73,6 +92,7 @@ public class CastExpression extends Expression {
         CastExpression ret =  new CastExpression(getType(), transformer.transform(expression));
         ret.setSourcePosition(this);
         ret.setCoerce(this.isCoerce());
+        ret.setStrict(this.isStrict());
         ret.copyNodeMetaData(this);
         return ret;
     }
diff --git a/src/main/org/codehaus/groovy/ast/tools/GeneralUtils.java b/src/main/org/codehaus/groovy/ast/tools/GeneralUtils.java
index 9b61225ade..28d6114cc1 100644
--- a/src/main/org/codehaus/groovy/ast/tools/GeneralUtils.java
+++ b/src/main/org/codehaus/groovy/ast/tools/GeneralUtils.java
@@ -54,6 +54,7 @@ import org.codehaus.groovy.ast.stmt.ReturnStatement;
 import org.codehaus.groovy.ast.stmt.Statement;
 import org.codehaus.groovy.classgen.Verifier;
 import org.codehaus.groovy.runtime.GeneratedClosure;
+import org.codehaus.groovy.runtime.MetaClassHelper;
 import org.codehaus.groovy.syntax.Token;
 import org.codehaus.groovy.syntax.Types;
 import org.codehaus.groovy.transform.AbstractASTTransformation;
@@ -613,4 +614,24 @@ public class GeneralUtils {
     public static VariableExpression varX(String name, ClassNode type) {
         return new VariableExpression(name, type);
     }
+
+    /**
+     * This method is similar to {@link #propX(Expression, Expression)} but will make sure that if the property
+     * being accessed is defined inside the classnode provided as a parameter, then a getter call is generated
+     * instead of a field access.
+     * @param annotatedNode the class node where the property node is accessed from
+     * @param pNode the property being accessed
+     * @return a method call expression or a property expression
+     */
+    public static Expression getterX(ClassNode annotatedNode, PropertyNode pNode) {
+        ClassNode owner = pNode.getDeclaringClass();
+        if (annotatedNode.equals(owner)) {
+            String getterName = "get" + MetaClassHelper.capitalize(pNode.getName());
+            if (ClassHelper.boolean_TYPE.equals(pNode.getOriginType())) {
+                getterName = "is" + MetaClassHelper.capitalize(pNode.getName());
+            }
+            return callX(new VariableExpression("this"), getterName, ArgumentListExpression.EMPTY_ARGUMENTS);
+        }
+        return propX(new VariableExpression("this"), pNode.getName());
+    }
 }
diff --git a/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java b/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
index 099a144cc5..dcfe12093e 100644
--- a/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
+++ b/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
@@ -734,7 +734,8 @@ public class AsmClassGenerator extends ClassGenerator {
                 controller.getOperandStack().replace(type);
             } else {
                 ClassNode subExprType = controller.getTypeChooser().resolveType(subExpression, controller.getClassNode());
-                if (!ClassHelper.isPrimitiveType(type) && WideningCategories.implementsInterfaceOrSubclassOf(subExprType, type)) {
+                if (castExpression.isStrict() ||
+                        (!ClassHelper.isPrimitiveType(type) && WideningCategories.implementsInterfaceOrSubclassOf(subExprType, type))) {
                     BytecodeHelper.doCast(controller.getMethodVisitor(), type);
                     controller.getOperandStack().replace(type);
                 } else {
diff --git a/src/main/org/codehaus/groovy/transform/EqualsAndHashCodeASTTransformation.java b/src/main/org/codehaus/groovy/transform/EqualsAndHashCodeASTTransformation.java
index f55612ef03..c7fba0de61 100644
--- a/src/main/org/codehaus/groovy/transform/EqualsAndHashCodeASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/EqualsAndHashCodeASTTransformation.java
@@ -37,7 +37,7 @@ import org.codehaus.groovy.ast.stmt.Statement;
 import org.codehaus.groovy.ast.tools.GenericsUtils;
 import org.codehaus.groovy.control.CompilePhase;
 import org.codehaus.groovy.control.SourceUnit;
-import org.codehaus.groovy.runtime.InvokerHelper;
+import org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport;
 import org.codehaus.groovy.util.HashCodeHelper;
 
 import java.util.ArrayList;
@@ -53,7 +53,6 @@ public class EqualsAndHashCodeASTTransformation extends AbstractASTTransformatio
     static final ClassNode MY_TYPE = make(MY_CLASS);
     static final String MY_TYPE_NAME = "@" + MY_TYPE.getNameWithoutPackage();
     private static final ClassNode HASHUTIL_TYPE = make(HashCodeHelper.class);
-    private static final ClassNode INVOKERHELPER_TYPE = make(InvokerHelper.class);
     private static final ClassNode OBJECT_TYPE = makeClassSafe(Object.class);
 
     public void visit(ASTNode[] nodes, SourceUnit source) {
@@ -127,7 +126,7 @@ public class EqualsAndHashCodeASTTransformation extends AbstractASTTransformatio
         for (PropertyNode pNode : pList) {
             if (shouldSkip(pNode.getName(), excludes, includes)) continue;
             // _result = HashCodeHelper.updateHash(_result, getProperty()) // plus self-reference checking
-            Expression getter = callX(INVOKERHELPER_TYPE, "getProperty", args(varX("this"), constX(pNode.getName())));
+            Expression getter = getterX(cNode, pNode);
             final Expression current = callX(HASHUTIL_TYPE, "updateHash", args(result, getter));
             body.addStatement(ifS(
                     notX(sameX(getter, varX("this"))),
@@ -184,34 +183,43 @@ public class EqualsAndHashCodeASTTransformation extends AbstractASTTransformatio
         VariableExpression other = varX("other");
 
         // some short circuit cases for efficiency
-        body.addStatement(ifS(equalsNullX(other), returnS(constX(Boolean.FALSE))));
-        body.addStatement(ifS(sameX(varX("this"), other), returnS(constX(Boolean.TRUE))));
+        body.addStatement(ifS(equalsNullX(other), returnS(constX(Boolean.FALSE, true))));
+        body.addStatement(ifS(sameX(varX("this"), other), returnS(constX(Boolean.TRUE, true))));
 
         if (useCanEqual) {
-            body.addStatement(ifS(notX(isInstanceOfX(other, GenericsUtils.nonGeneric(cNode))), returnS(constX(Boolean.FALSE))));
+            body.addStatement(ifS(notX(isInstanceOfX(other, GenericsUtils.nonGeneric(cNode))), returnS(constX(Boolean.FALSE,true))));
         } else {
-            body.addStatement(ifS(notX(hasClassX(other, GenericsUtils.nonGeneric(cNode))), returnS(constX(Boolean.FALSE))));
+            body.addStatement(ifS(notX(hasClassX(other, GenericsUtils.nonGeneric(cNode))), returnS(constX(Boolean.FALSE,true))));
         }
 
         VariableExpression otherTyped = varX("otherTyped", GenericsUtils.nonGeneric(cNode));
-        body.addStatement(declS(otherTyped, new CastExpression(GenericsUtils.nonGeneric(cNode), other)));
+        CastExpression castExpression = new CastExpression(GenericsUtils.nonGeneric(cNode), other);
+        castExpression.setStrict(true);
+        body.addStatement(declS(otherTyped, castExpression));
 
         if (useCanEqual) {
-            body.addStatement(ifS(notX(callX(otherTyped, "canEqual", varX("this"))), returnS(constX(Boolean.FALSE))));
+            body.addStatement(ifS(notX(callX(otherTyped, "canEqual", varX("this"))), returnS(constX(Boolean.FALSE,true))));
         }
 
         List<PropertyNode> pList = getInstanceProperties(cNode);
         for (PropertyNode pNode : pList) {
             if (shouldSkip(pNode.getName(), excludes, includes)) continue;
-            body.addStatement(
-                    ifS(notX(hasSamePropertyX(pNode, otherTyped)),
-                            ifElseS(differentSelfRecursivePropertyX(pNode, otherTyped),
-                                    returnS(constX(Boolean.FALSE)),
-                                    ifS(notX(bothSelfRecursivePropertyX(pNode, otherTyped)),
-                                            ifS(notX(hasEqualPropertyX(pNode, otherTyped)), returnS(constX(Boolean.FALSE))))
-                            )
-                    )
+            boolean canBeSelf = StaticTypeCheckingSupport.implementsInterfaceOrIsSubclassOf(
+                    pNode.getOriginType(), cNode
             );
+            if (!canBeSelf) {
+                body.addStatement(ifS(notX(hasEqualPropertyX(pNode, otherTyped)), returnS(constX(Boolean.FALSE, true))));
+            } else {
+                body.addStatement(
+                        ifS(notX(hasSamePropertyX(pNode, otherTyped)),
+                                ifElseS(differentSelfRecursivePropertyX(pNode, otherTyped),
+                                        returnS(constX(Boolean.FALSE, true)),
+                                        ifS(notX(bothSelfRecursivePropertyX(pNode, otherTyped)),
+                                                ifS(notX(hasEqualPropertyX(pNode, otherTyped)), returnS(constX(Boolean.FALSE, true))))
+                                )
+                        )
+                );
+            }
         }
         List<FieldNode> fList = new ArrayList<FieldNode>();
         if (includeFields) {
@@ -222,20 +230,20 @@ public class EqualsAndHashCodeASTTransformation extends AbstractASTTransformatio
             body.addStatement(
                     ifS(notX(hasSameFieldX(fNode, otherTyped)),
                             ifElseS(differentSelfRecursiveFieldX(fNode, otherTyped),
-                                    returnS(constX(Boolean.FALSE)),
+                                    returnS(constX(Boolean.FALSE,true)),
                                     ifS(notX(bothSelfRecursiveFieldX(fNode, otherTyped)),
-                                            ifS(notX(hasEqualFieldX(fNode, otherTyped)), returnS(constX(Boolean.FALSE)))))
+                                            ifS(notX(hasEqualFieldX(fNode, otherTyped)), returnS(constX(Boolean.FALSE,true)))))
                     ));
         }
         if (callSuper) {
             body.addStatement(ifS(
                     notX(isTrueX(callSuperX("equals", other))),
-                    returnS(constX(Boolean.FALSE))
+                    returnS(constX(Boolean.FALSE,true))
             ));
         }
 
         // default
-        body.addStatement(returnS(constX(Boolean.TRUE)));
+        body.addStatement(returnS(constX(Boolean.TRUE,true)));
 
         cNode.addMethod(new MethodNode(
                 hasExistingEquals ? "_equals" : "equals",
diff --git a/src/main/org/codehaus/groovy/transform/ToStringASTTransformation.java b/src/main/org/codehaus/groovy/transform/ToStringASTTransformation.java
index 38f2cfa311..b93ccbb3d9 100644
--- a/src/main/org/codehaus/groovy/transform/ToStringASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/ToStringASTTransformation.java
@@ -43,25 +43,7 @@ import java.util.Iterator;
 import java.util.List;
 
 import static org.codehaus.groovy.ast.ClassHelper.make;
-import static org.codehaus.groovy.ast.tools.GeneralUtils.args;
-import static org.codehaus.groovy.ast.tools.GeneralUtils.assignS;
-import static org.codehaus.groovy.ast.tools.GeneralUtils.callX;
-import static org.codehaus.groovy.ast.tools.GeneralUtils.callSuperX;
-import static org.codehaus.groovy.ast.tools.GeneralUtils.constX;
-import static org.codehaus.groovy.ast.tools.GeneralUtils.ctorX;
-import static org.codehaus.groovy.ast.tools.GeneralUtils.declS;
-import static org.codehaus.groovy.ast.tools.GeneralUtils.equalsNullX;
-import static org.codehaus.groovy.ast.tools.GeneralUtils.getAllProperties;
-import static org.codehaus.groovy.ast.tools.GeneralUtils.getInstanceNonPropertyFields;
-import static org.codehaus.groovy.ast.tools.GeneralUtils.getInstanceProperties;
-import static org.codehaus.groovy.ast.tools.GeneralUtils.hasDeclaredMethod;
-import static org.codehaus.groovy.ast.tools.GeneralUtils.sameX;
-import static org.codehaus.groovy.ast.tools.GeneralUtils.ifElseS;
-import static org.codehaus.groovy.ast.tools.GeneralUtils.ifS;
-import static org.codehaus.groovy.ast.tools.GeneralUtils.notNullX;
-import static org.codehaus.groovy.ast.tools.GeneralUtils.returnS;
-import static org.codehaus.groovy.ast.tools.GeneralUtils.stmt;
-import static org.codehaus.groovy.ast.tools.GeneralUtils.varX;
+import static org.codehaus.groovy.ast.tools.GeneralUtils.*;
 
 /**
  * Handles generation of code for the @ToString annotation.
@@ -178,7 +160,8 @@ public class ToStringASTTransformation extends AbstractASTTransformation {
         }
         for (PropertyNode pNode : pList) {
             if (shouldSkip(pNode.getName(), excludes, includes)) continue;
-            Expression getter = callX(INVOKER_TYPE, "getProperty", args(varX("this"), constX(pNode.getName())));
+            Expression getter = getterX(cNode, pNode);
+
             appendValue(body, result, first, getter, pNode.getName(), includeNames, ignoreNulls);
         }
 
@@ -213,7 +196,7 @@ public class ToStringASTTransformation extends AbstractASTTransformation {
         appendCommaIfNotFirst(thenBlock, result, first);
         appendPrefix(thenBlock, result, name, includeNames);
         thenBlock.addStatement(ifElseS(
-                sameX(value, VariableExpression.THIS_EXPRESSION),
+                sameX(value, new VariableExpression("this")),
                 appendS(result, constX("(this)")),
                 appendS(result, callX(INVOKER_TYPE, "toString", value))));
         body.addStatement(appendValue);
diff --git a/src/main/org/codehaus/groovy/transform/sc/transformers/CompareIdentityExpression.java b/src/main/org/codehaus/groovy/transform/sc/transformers/CompareIdentityExpression.java
index db01ca516f..618379fdf9 100644
--- a/src/main/org/codehaus/groovy/transform/sc/transformers/CompareIdentityExpression.java
+++ b/src/main/org/codehaus/groovy/transform/sc/transformers/CompareIdentityExpression.java
@@ -64,12 +64,11 @@ public class CompareIdentityExpression extends BinaryExpression implements Opcod
             WriterController controller = acg.getController();
             ClassNode leftType = controller.getTypeChooser().resolveType(leftExpression, controller.getClassNode());
             ClassNode rightType = controller.getTypeChooser().resolveType(rightExpression, controller.getClassNode());
-            if (ClassHelper.isPrimitiveType(leftType) || ClassHelper.isPrimitiveType(rightType)) {
-                throw new IllegalArgumentException("Both operands of a CompareIdentityExpression must be objects");
-            }
             MethodVisitor mv = controller.getMethodVisitor();
             leftExpression.visit(acg);
+            controller.getOperandStack().box();
             rightExpression.visit(acg);
+            controller.getOperandStack().box();
             Label l1 = new Label();
             mv.visitJumpInsn(IF_ACMPNE, l1);
             mv.visitInsn(ICONST_1);
diff --git a/src/main/org/codehaus/groovy/transform/sc/transformers/MethodCallExpressionTransformer.java b/src/main/org/codehaus/groovy/transform/sc/transformers/MethodCallExpressionTransformer.java
index a325c5453d..273fb6d131 100644
--- a/src/main/org/codehaus/groovy/transform/sc/transformers/MethodCallExpressionTransformer.java
+++ b/src/main/org/codehaus/groovy/transform/sc/transformers/MethodCallExpressionTransformer.java
@@ -22,6 +22,7 @@ import org.codehaus.groovy.ast.ClassHelper;
 import org.codehaus.groovy.ast.ClassNode;
 import org.codehaus.groovy.ast.FieldNode;
 import org.codehaus.groovy.ast.MethodNode;
+import org.codehaus.groovy.ast.expr.ArgumentListExpression;
 import org.codehaus.groovy.ast.expr.BinaryExpression;
 import org.codehaus.groovy.ast.expr.Expression;
 import org.codehaus.groovy.ast.expr.MethodCallExpression;
@@ -29,7 +30,9 @@ import org.codehaus.groovy.ast.expr.TupleExpression;
 import org.codehaus.groovy.ast.expr.VariableExpression;
 import org.codehaus.groovy.ast.stmt.EmptyStatement;
 import org.codehaus.groovy.classgen.asm.MopWriter;
+import org.codehaus.groovy.runtime.DefaultGroovyMethods;
 import org.codehaus.groovy.syntax.Token;
+import org.codehaus.groovy.transform.stc.ExtensionMethodNode;
 import org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor;
 import org.codehaus.groovy.transform.stc.StaticTypesMarker;
 
@@ -39,6 +42,8 @@ import static org.objectweb.asm.Opcodes.ACC_PUBLIC;
 import static org.objectweb.asm.Opcodes.ACC_SYNTHETIC;
 
 public class MethodCallExpressionTransformer {
+    private final static ClassNode DGM_CLASSNODE = ClassHelper.make(DefaultGroovyMethods.class);
+
     private final StaticCompilationTransformer staticCompilationTransformer;
 
     public MethodCallExpressionTransformer(StaticCompilationTransformer staticCompilationTransformer) {
@@ -46,6 +51,10 @@ public class MethodCallExpressionTransformer {
     }
 
     Expression transformMethodCallExpression(final MethodCallExpression expr) {
+        Expression trn = tryTransformIsToCompareIdentity(expr);
+        if (trn!=null) {
+            return trn;
+        }
         ClassNode superCallReceiver = expr.getNodeMetaData(StaticTypesMarker.SUPER_MOP_METHOD_REQUIRED);
         if (superCallReceiver!=null) {
             return transformMethodCallExpression(transformToMopSuperCall(superCallReceiver, expr));
@@ -155,4 +164,29 @@ public class MethodCallExpressionTransformer {
                 && !"call".equals(expr.getMethodAsString());
     }
 
+    /**
+     * Identifies a method call expression on {@link DefaultGroovyMethods#is(Object, Object)} and if recognized, transforms it into a {@link CompareIdentityExpression}.
+     * @param call a method call to be transformed
+     * @return null if the method call is not DGM#is, or {@link CompareIdentityExpression}
+     */
+    private static Expression tryTransformIsToCompareIdentity(MethodCallExpression call) {
+        MethodNode methodTarget = call.getMethodTarget();
+        if (methodTarget instanceof ExtensionMethodNode && "is".equals(methodTarget.getName()) && methodTarget.getParameters().length==1) {
+           methodTarget = ((ExtensionMethodNode) methodTarget).getExtensionMethodNode();
+            ClassNode owner = methodTarget.getDeclaringClass();
+            if (DGM_CLASSNODE.equals(owner)) {
+                Expression args = call.getArguments();
+                if (args instanceof ArgumentListExpression) {
+                    ArgumentListExpression arguments = (ArgumentListExpression) args;
+                    List<Expression> exprs = arguments.getExpressions();
+                    if (exprs.size() == 1) {
+                        CompareIdentityExpression cid = new CompareIdentityExpression(call.getObjectExpression(), exprs.get(0));
+                        cid.setSourcePosition(call);
+                        return cid;
+                    }
+                }
+            }
+        }
+        return null;
+    }
 }
\ No newline at end of file
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/StaticCompileComparisonTest.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/StaticCompileComparisonTest.groovy
index ef5d096536..7802bd5785 100644
--- a/src/test/org/codehaus/groovy/classgen/asm/sc/StaticCompileComparisonTest.groovy
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/StaticCompileComparisonTest.groovy
@@ -94,7 +94,7 @@ class StaticCompileComparisonTest extends AbstractBytecodeTestCase {
             assert m(new Object())
         ''')
         assert bytecode.hasStrictSequence(
-                ['ALOAD','ALOAD', 'INVOKESTATIC org/codehaus/groovy/runtime/DefaultGroovyMethods.is (Ljava/lang/Object;Ljava/lang/Object;)Z']
+                ['ALOAD','ALOAD', 'IF_ACMPNE']
         )
         clazz.newInstance().main()
     }
diff --git a/subprojects/groovy-console/src/test/groovy/groovy/inspect/swingui/AstNodeToScriptAdapterTest.groovy b/subprojects/groovy-console/src/test/groovy/groovy/inspect/swingui/AstNodeToScriptAdapterTest.groovy
index 50784b825d..dbb4967526 100644
--- a/subprojects/groovy-console/src/test/groovy/groovy/inspect/swingui/AstNodeToScriptAdapterTest.groovy
+++ b/subprojects/groovy-console/src/test/groovy/groovy/inspect/swingui/AstNodeToScriptAdapterTest.groovy
@@ -553,7 +553,7 @@ class AstNodeToScriptAdapterTest extends GroovyTestCase {
 
         String result = compileToScript(script, CompilePhase.CANONICALIZATION)
         // we had problems with the ast transform passing a VariableExpression as StaticMethodCallExpression arguments
-        assert result.contains("_result.append(org.codehaus.groovy.runtime.InvokerHelper.toStringorg.codehaus.groovy.runtime.InvokerHelper.getProperty(this, 'when'))")
+        assert result.contains("_result.append(org.codehaus.groovy.runtime.InvokerHelper.toString(this.getWhen())")
     }
 
     void testAtImmutableClassWithProperties() {
@@ -573,9 +573,9 @@ class AstNodeToScriptAdapterTest extends GroovyTestCase {
         // assert hashCode
         assert result.contains('public int hashCode()')
         assert result.contains('java.lang.Object _result = org.codehaus.groovy.util.HashCodeHelper.initHash()')
-        assert result.contains("_result = org.codehaus.groovy.util.HashCodeHelper.updateHash(_result, org.codehaus.groovy.runtime.InvokerHelper.getProperty(this, 'title'))")
-        assert result.contains("_result = org.codehaus.groovy.util.HashCodeHelper.updateHash(_result, org.codehaus.groovy.runtime.InvokerHelper.getProperty(this, 'when'))")
-        assert result.contains("_result = org.codehaus.groovy.util.HashCodeHelper.updateHash(_result, org.codehaus.groovy.runtime.InvokerHelper.getProperty(this, 'color'))")
+        assert result.contains("_result = org.codehaus.groovy.util.HashCodeHelper.updateHash(_result, this.getTitle())")
+        assert result.contains("_result = org.codehaus.groovy.util.HashCodeHelper.updateHash(_result, this.getWhen())")
+        assert result.contains("_result = org.codehaus.groovy.util.HashCodeHelper.updateHash(_result, this.getColor())")
 
         // assert clones
         assert result.contains("((org.codehaus.groovy.runtime.ReflectionMethodInvoker.invoke(when, 'clone', new java.lang.Object[][])) as java.util.Date)")
