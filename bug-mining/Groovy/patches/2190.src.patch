diff --git a/src/main/groovy/transform/Canonical.java b/src/main/groovy/transform/Canonical.java
index 214bb023a9..047ee60aa4 100644
--- a/src/main/groovy/transform/Canonical.java
+++ b/src/main/groovy/transform/Canonical.java
@@ -80,13 +80,13 @@ import java.lang.annotation.Target;
  * </ul>
  * <p>
  * If you want similar functionality to what this annotation provides but also require immutability, see the
- * {@code @Immutable} annotation.
+ * {@code @}{@link Immutable} annotation.
  * <p>
  * Limitations:
  * <ul>
- * <li>
- * If you explicitly add your own constructors, then the transformation will not add any other constructor to the class.
- * </li>
+ * <li>If you explicitly add your own constructors, then the transformation will not add any other constructor to the class</li>
+ * <li>Groovy's normal map-style naming conventions will not be available if the first property
+ * has type {@code LinkedHashMap} or if there is a single Map, AbstractMap or HashMap property</li>
  * </ul>
  *
  * @author Paulo Poiati
diff --git a/src/main/groovy/transform/TupleConstructor.java b/src/main/groovy/transform/TupleConstructor.java
index 7d941c810e..d28a6c188f 100644
--- a/src/main/groovy/transform/TupleConstructor.java
+++ b/src/main/groovy/transform/TupleConstructor.java
@@ -51,7 +51,11 @@ import java.lang.annotation.Target;
  * by the fields of the class (if {@code includeFields} is set). Within each grouping the order
  * is as attributes appear within the respective class.
  * <p>
- * Limitations: currently not designed to support inner classes.
+ * Limitations:
+ * <ul>
+ * <li>Groovy's normal map-style naming conventions will not be available if the first property (or field)
+ * has type {@code LinkedHashMap} or if there is a single Map, AbstractMap or HashMap property (or field)</li>
+ * </ul>
  *
  * @author Paul King
  * @since 1.8.0
diff --git a/src/main/org/codehaus/groovy/classgen/EnumCompletionVisitor.java b/src/main/org/codehaus/groovy/classgen/EnumCompletionVisitor.java
index 19be420b00..8d170f4976 100644
--- a/src/main/org/codehaus/groovy/classgen/EnumCompletionVisitor.java
+++ b/src/main/org/codehaus/groovy/classgen/EnumCompletionVisitor.java
@@ -16,25 +16,21 @@
 package org.codehaus.groovy.classgen;
 
 import org.codehaus.groovy.ast.*;
-import org.codehaus.groovy.ast.expr.*;
+import org.codehaus.groovy.ast.expr.ArgumentListExpression;
+import org.codehaus.groovy.ast.expr.ConstructorCallExpression;
+import org.codehaus.groovy.ast.expr.Expression;
+import org.codehaus.groovy.ast.expr.TupleExpression;
+import org.codehaus.groovy.ast.expr.VariableExpression;
 import org.codehaus.groovy.ast.stmt.BlockStatement;
-import org.codehaus.groovy.ast.stmt.EmptyStatement;
 import org.codehaus.groovy.ast.stmt.ExpressionStatement;
-import org.codehaus.groovy.ast.stmt.IfStatement;
 import org.codehaus.groovy.ast.stmt.Statement;
-import org.codehaus.groovy.ast.stmt.ThrowStatement;
 import org.codehaus.groovy.control.CompilationUnit;
 import org.codehaus.groovy.control.SourceUnit;
-import org.codehaus.groovy.transform.ImmutableASTTransformation;
+import org.codehaus.groovy.transform.TupleConstructorASTTransformation;
 import org.objectweb.asm.Opcodes;
 
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
-import java.util.Map;
-
-import static org.codehaus.groovy.transform.AbstractASTTransformUtil.assignStatement;
-import static org.codehaus.groovy.transform.AbstractASTTransformUtil.equalsNullExpr;
 
 /**
  * Enums have a parent constructor with two arguments from java.lang.Enum.
@@ -42,9 +38,6 @@ import static org.codehaus.groovy.transform.AbstractASTTransformUtil.equalsNullE
  * and performs the necessary super call.
  */
 public class EnumCompletionVisitor extends ClassCodeVisitorSupport {
-    private static final ClassNode MAP_TYPE = ClassHelper.makeWithoutCaching(Map.class, false);
-    private static final ClassNode COLLECTIONS_TYPE = ClassHelper.makeWithoutCaching(Collections.class);
-    private static final ClassNode CHECK_METHOD_TYPE = ClassHelper.make(ImmutableASTTransformation.class);
     private final SourceUnit sourceUnit;
 
     public EnumCompletionVisitor(CompilationUnit cu, SourceUnit su) {
@@ -79,7 +72,7 @@ public class EnumCompletionVisitor extends ClassCodeVisitorSupport {
             ClassNode sn = enumClass.getSuperClass();
             List<ConstructorNode> sctors = new ArrayList<ConstructorNode>(sn.getDeclaredConstructors());
             if (sctors.size() == 0) {
-                addMapConstructors(enumClass);
+                addMapConstructors(enumClass, false);
             } else {
                 for (ConstructorNode constructorNode : sctors) {
                     ConstructorNode init = new ConstructorNode(Opcodes.ACC_PUBLIC, constructorNode.getParameters(), ClassNode.EMPTY_ARRAY, new BlockStatement());
@@ -87,7 +80,7 @@ public class EnumCompletionVisitor extends ClassCodeVisitorSupport {
                 }
             }
         } else {
-            addMapConstructors(enumClass);
+            addMapConstructors(enumClass, false);
         }
     }
 
@@ -138,47 +131,9 @@ public class EnumCompletionVisitor extends ClassCodeVisitorSupport {
         }
     }
 
-    private void addMapConstructors(ClassNode enumClass) {
-        Parameter[] parameters = new Parameter[1];
-        parameters[0] = new Parameter(MAP_TYPE, "__namedArgs");
-        BlockStatement code = new BlockStatement();
-        VariableExpression namedArgs = new VariableExpression("__namedArgs");
-        code.addStatement(new IfStatement(equalsNullExpr(namedArgs),
-                illegalArgumentBlock(enumClass),
-                processArgsBlock(enumClass, namedArgs)));
-        ConstructorNode init = new ConstructorNode(Opcodes.ACC_PUBLIC, parameters, ClassNode.EMPTY_ARRAY, code);
-        enumClass.addConstructor(init);
-        // add a no-arg constructor too
-        code = new BlockStatement();
-        code.addStatement(new ExpressionStatement(new ConstructorCallExpression(ClassNode.THIS, new StaticMethodCallExpression(COLLECTIONS_TYPE, "emptyMap", MethodCallExpression.NO_ARGUMENTS))));
-        init = new ConstructorNode(Opcodes.ACC_PUBLIC, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, code);
-        enumClass.addConstructor(init);
-    }
-
-    private BlockStatement illegalArgumentBlock(ClassNode enumClass) {
-        BlockStatement outerElseBlock = new BlockStatement();
-        outerElseBlock.addStatement(new ThrowStatement(new ConstructorCallExpression(ClassHelper.make(IllegalArgumentException.class),
-                new ArgumentListExpression(new ConstantExpression(
-                        "One of the enum constants for enum " + enumClass.getName() +
-                                " was initialized with null. Please use a non-null value or define your own constructor.")))));
-        return outerElseBlock;
-    }
-
-    private BlockStatement processArgsBlock(ClassNode enumClass, VariableExpression namedArgs) {
-        BlockStatement outerThenBlock = new BlockStatement();
-        for (PropertyNode pNode : enumClass.getProperties()) {
-            if (pNode.isStatic()) continue;
-
-            // if namedArgs.containsKey(propertyName) setProperty(propertyName, namedArgs.get(propertyName));
-            BooleanExpression ifTest = new BooleanExpression(new MethodCallExpression(namedArgs, "containsKey", new ConstantExpression(pNode.getName())));
-            Expression pExpr = new VariableExpression(pNode);
-            Statement thenBlock = assignStatement(pExpr, new PropertyExpression(namedArgs, pNode.getName()));
-            IfStatement ifStatement = new IfStatement(ifTest, thenBlock, EmptyStatement.INSTANCE);
-            outerThenBlock.addStatement(ifStatement);
-        }
-        Expression checkArgs = new ArgumentListExpression(new VariableExpression("this"), namedArgs);
-        outerThenBlock.addStatement(new ExpressionStatement(new StaticMethodCallExpression(CHECK_METHOD_TYPE, "checkPropNames", checkArgs)));
-        return outerThenBlock;
+    public static void addMapConstructors(ClassNode enumClass, boolean hasNoArg) {
+        TupleConstructorASTTransformation.addMapConstructors(enumClass, hasNoArg, "One of the enum constants for enum " + enumClass.getName() +
+                " was initialized with null. Please use a non-null value or define your own constructor.");
     }
 
     private String getUniqueVariableName(final String name, Statement code) {
diff --git a/src/main/org/codehaus/groovy/transform/TupleConstructorASTTransformation.java b/src/main/org/codehaus/groovy/transform/TupleConstructorASTTransformation.java
index 668593a77e..0c7cca288c 100644
--- a/src/main/org/codehaus/groovy/transform/TupleConstructorASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/TupleConstructorASTTransformation.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2012 the original author or authors.
+ * Copyright 2008-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -24,19 +24,29 @@ import org.codehaus.groovy.ast.ClassNode;
 import org.codehaus.groovy.ast.ConstructorNode;
 import org.codehaus.groovy.ast.FieldNode;
 import org.codehaus.groovy.ast.Parameter;
+import org.codehaus.groovy.ast.PropertyNode;
 import org.codehaus.groovy.ast.expr.ArgumentListExpression;
+import org.codehaus.groovy.ast.expr.BooleanExpression;
 import org.codehaus.groovy.ast.expr.ConstantExpression;
 import org.codehaus.groovy.ast.expr.ConstructorCallExpression;
 import org.codehaus.groovy.ast.expr.Expression;
+import org.codehaus.groovy.ast.expr.MethodCallExpression;
 import org.codehaus.groovy.ast.expr.PropertyExpression;
+import org.codehaus.groovy.ast.expr.StaticMethodCallExpression;
 import org.codehaus.groovy.ast.expr.VariableExpression;
 import org.codehaus.groovy.ast.stmt.BlockStatement;
+import org.codehaus.groovy.ast.stmt.EmptyStatement;
 import org.codehaus.groovy.ast.stmt.ExpressionStatement;
+import org.codehaus.groovy.ast.stmt.IfStatement;
+import org.codehaus.groovy.ast.stmt.Statement;
+import org.codehaus.groovy.ast.stmt.ThrowStatement;
 import org.codehaus.groovy.control.CompilePhase;
 import org.codehaus.groovy.control.SourceUnit;
 
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.HashMap;
+import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 
@@ -53,6 +63,10 @@ public class TupleConstructorASTTransformation extends AbstractASTTransformation
     static final Class MY_CLASS = TupleConstructor.class;
     static final ClassNode MY_TYPE = ClassHelper.make(MY_CLASS);
     static final String MY_TYPE_NAME = "@" + MY_TYPE.getNameWithoutPackage();
+    private static final ClassNode LHMAP_TYPE = ClassHelper.makeWithoutCaching(LinkedHashMap.class, false);
+    private static final ClassNode HMAP_TYPE = ClassHelper.makeWithoutCaching(HashMap.class, false);
+    private static final ClassNode COLLECTIONS_TYPE = ClassHelper.makeWithoutCaching(Collections.class);
+    private static final ClassNode CHECK_METHOD_TYPE = ClassHelper.make(ImmutableASTTransformation.class);
     private static Map<Class<?>, Expression> primitivesInitialValues;
 
     static {
@@ -146,6 +160,25 @@ public class TupleConstructorASTTransformation extends AbstractASTTransformation
             body.addStatement(assignStatement(new PropertyExpression(VariableExpression.THIS_EXPRESSION, name), new VariableExpression(name)));
         }
         cNode.addConstructor(new ConstructorNode(ACC_PUBLIC, params.toArray(new Parameter[params.size()]), ClassNode.EMPTY_ARRAY, body));
+        // add map constructor if needed, don't do it for LinkedHashMap for now (would lead to duplicate signature)
+        // or if there is only one Map property (for backwards compatibility)
+        if (params.size() > 0) {
+            ClassNode firstParam = params.get(0).getType();
+            if (params.size() > 1 || firstParam.equals(ClassHelper.OBJECT_TYPE)) {
+                if (firstParam.equals(ClassHelper.MAP_TYPE)) {
+                    addMapConstructors(cNode, true, "The class " + cNode.getName() + " was incorrectly initialized via the map constructor with null.");
+                } else {
+                    ClassNode candidate = HMAP_TYPE;
+                    while (candidate != null) {
+                        if (candidate.equals(firstParam)) {
+                            addMapConstructors(cNode, true, "The class " + cNode.getName() + " was incorrectly initialized via the map constructor with null.");
+                            break;
+                        }
+                        candidate = candidate.getSuperClass();
+                    }
+                }
+            }
+        }
     }
 
     private static Parameter createParam(FieldNode fNode, String name) {
@@ -167,4 +200,46 @@ public class TupleConstructorASTTransformation extends AbstractASTTransformation
         return initialExp;
     }
 
+    public static void addMapConstructors(ClassNode cNode, boolean hasNoArg, String message) {
+        Parameter[] parameters = new Parameter[1];
+        parameters[0] = new Parameter(LHMAP_TYPE, "__namedArgs");
+        BlockStatement code = new BlockStatement();
+        VariableExpression namedArgs = new VariableExpression("__namedArgs");
+        code.addStatement(new IfStatement(equalsNullExpr(namedArgs),
+                illegalArgumentBlock(message),
+                processArgsBlock(cNode, namedArgs)));
+        ConstructorNode init = new ConstructorNode(ACC_PUBLIC, parameters, ClassNode.EMPTY_ARRAY, code);
+        cNode.addConstructor(init);
+        // add a no-arg constructor too
+        if (!hasNoArg) {
+            code = new BlockStatement();
+            code.addStatement(new ExpressionStatement(new ConstructorCallExpression(ClassNode.THIS, new StaticMethodCallExpression(COLLECTIONS_TYPE, "emptyMap", MethodCallExpression.NO_ARGUMENTS))));
+            init = new ConstructorNode(ACC_PUBLIC, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, code);
+            cNode.addConstructor(init);
+        }
+    }
+
+    private static BlockStatement illegalArgumentBlock(String message) {
+        BlockStatement block = new BlockStatement();
+        block.addStatement(new ThrowStatement(new ConstructorCallExpression(ClassHelper.make(IllegalArgumentException.class),
+                new ArgumentListExpression(new ConstantExpression(message)))));
+        return block;
+    }
+
+    private static BlockStatement processArgsBlock(ClassNode cNode, VariableExpression namedArgs) {
+        BlockStatement block = new BlockStatement();
+        for (PropertyNode pNode : cNode.getProperties()) {
+            if (pNode.isStatic()) continue;
+
+            // if namedArgs.containsKey(propertyName) setProperty(propertyName, namedArgs.get(propertyName));
+            BooleanExpression ifTest = new BooleanExpression(new MethodCallExpression(namedArgs, "containsKey", new ConstantExpression(pNode.getName())));
+            Expression pExpr = new VariableExpression(pNode);
+            Statement thenBlock = assignStatement(pExpr, new PropertyExpression(namedArgs, pNode.getName()));
+            IfStatement ifStatement = new IfStatement(ifTest, thenBlock, EmptyStatement.INSTANCE);
+            block.addStatement(ifStatement);
+        }
+        Expression checkArgs = new ArgumentListExpression(new VariableExpression("this"), namedArgs);
+        block.addStatement(new ExpressionStatement(new StaticMethodCallExpression(CHECK_METHOD_TYPE, "checkPropNames", checkArgs)));
+        return block;
+    }
 }
diff --git a/src/test/org/codehaus/groovy/transform/CanonicalTransformTest.groovy b/src/test/org/codehaus/groovy/transform/CanonicalTransformTest.groovy
index 7e340c809e..876ca14335 100644
--- a/src/test/org/codehaus/groovy/transform/CanonicalTransformTest.groovy
+++ b/src/test/org/codehaus/groovy/transform/CanonicalTransformTest.groovy
@@ -556,4 +556,40 @@ class CanonicalTransformTest extends GroovyShellTestCase {
         """
     }
 
+    void testMapStyleConstructorSupportWithObjectOrMapFirstProperty() {
+        // GROOVY-5243: special support for Map, Object, AbstractMap, HashMap but currently not LinkedHashMap
+        assertScript """
+            import groovy.transform.*
+
+            def obj1 = new Canonical1(foo: [:], bar: 'BAR')
+            def obj2 = new Canonical2(foo: [:], bar: 'BAR')
+            def obj3 = new Canonical3(foo: [:], bar: 'BAR')
+
+            check(obj1)
+            check(obj2)
+            check(obj3)
+
+            def check(obj) {
+              assert obj.foo == [:]
+              assert obj.bar == 'BAR'
+            }
+
+            @Canonical
+            class Canonical1 {
+                def foo
+                String bar
+            }
+            @Canonical
+            class Canonical2 {
+                Map foo
+                String bar
+            }
+            @Canonical
+            class Canonical3 {
+                HashMap foo
+                String bar
+            }
+        """
+    }
+
 }
