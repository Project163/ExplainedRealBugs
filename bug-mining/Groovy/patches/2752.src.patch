diff --git a/src/main/org/codehaus/groovy/classgen/asm/InvocationWriter.java b/src/main/org/codehaus/groovy/classgen/asm/InvocationWriter.java
index c4ab5ac92e..96430ab39c 100644
--- a/src/main/org/codehaus/groovy/classgen/asm/InvocationWriter.java
+++ b/src/main/org/codehaus/groovy/classgen/asm/InvocationWriter.java
@@ -30,6 +30,7 @@ import org.codehaus.groovy.ast.tools.WideningCategories;
 import org.codehaus.groovy.classgen.AsmClassGenerator;
 import org.codehaus.groovy.classgen.asm.OptimizingStatementWriter.StatementMeta;
 import org.codehaus.groovy.runtime.ScriptBytecodeAdapter;
+import org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation;
 import org.codehaus.groovy.runtime.typehandling.ShortTypeHandling;
 import org.codehaus.groovy.syntax.SyntaxException;
 import org.objectweb.asm.Label;
@@ -45,6 +46,7 @@ public class InvocationWriter {
     public static final MethodCallerMultiAdapter invokeMethod = MethodCallerMultiAdapter.newStatic(ScriptBytecodeAdapter.class, "invokeMethod", true, false);
     public static final MethodCallerMultiAdapter invokeStaticMethod = MethodCallerMultiAdapter.newStatic(ScriptBytecodeAdapter.class, "invokeStaticMethod", true, true);
     public static final MethodCaller invokeClosureMethod = MethodCaller.newStatic(ScriptBytecodeAdapter.class, "invokeClosure");
+    public static final MethodCaller castToVargsArray = MethodCaller.newStatic(DefaultTypeTransformation.class, "castToVargsArray");
     private static final MethodNode CLASS_FOR_NAME_STRING = ClassHelper.CLASS_Type.getDeclaredMethod("forName", new Parameter[]{new Parameter(ClassHelper.STRING_TYPE,"name")});
 
     // type conversions
@@ -661,7 +663,6 @@ public class InvocationWriter {
     private void makeMOPBasedConstructorCall(List<ConstructorNode> constructors, ConstructorCallExpression call, ClassNode callNode) {
         MethodVisitor mv = controller.getMethodVisitor();
         OperandStack operandStack = controller.getOperandStack();
-
         call.getArguments().visit(controller.getAcg());
         // keep Object[] on stack
         mv.visitInsn(DUP);
@@ -732,23 +733,31 @@ public class InvocationWriter {
 
             ConstructorNode cn = constructorIt.next();
             String descriptor = BytecodeHelper.getMethodDescriptor(ClassHelper.VOID_TYPE, cn.getParameters());
+
             // unwrap the Object[] and make transformations if needed
             // that means, to duplicate the Object[], make a cast with possible
             // unboxing and then swap it with the Object[] for each parameter
+            // vargs need special attention and transformation though
             Parameter[] parameters = cn.getParameters();
-            for (int p = 0; p < parameters.length; p++) {
-                operandStack.push(ClassHelper.OBJECT_TYPE);
-                mv.visitInsn(DUP);
-                BytecodeHelper.pushConstant(mv, p);
-                mv.visitInsn(AALOAD);
-                operandStack.push(ClassHelper.OBJECT_TYPE);
-                ClassNode type = parameters[p].getType();
-                operandStack.doGroovyCast(type);
-                operandStack.swap();
-                operandStack.remove(2);
+            int lengthWithoutVargs = parameters.length;
+            if (parameters.length>0 && parameters[parameters.length-1].getType().isArray()) {
+                lengthWithoutVargs--;
+            }
+            for (int p = 0; p < lengthWithoutVargs; p++) {
+                loadAndCastElement(operandStack, mv, parameters, p);
+            }
+            if (parameters.length>lengthWithoutVargs) {
+                ClassNode type = parameters[lengthWithoutVargs].getType();
+                BytecodeHelper.pushConstant(mv, lengthWithoutVargs);
+                controller.getAcg().visitClassExpression(new ClassExpression(type));
+                operandStack.remove(1);
+                castToVargsArray.call(mv);
+                BytecodeHelper.doCast(mv, type);
+            } else {
+                // at the end we remove the Object[]
+                // the vargs case simply the last swap so no pop is needed
+                mv.visitInsn(POP);
             }
-            // at the end we remove the Object[]
-            mv.visitInsn(POP);
             // make the constructor call
             mv.visitMethodInsn(INVOKESPECIAL, BytecodeHelper.getClassInternalName(callNode), "<init>", descriptor, false);
             mv.visitJumpInsn(GOTO, afterSwitch);
@@ -778,6 +787,18 @@ public class InvocationWriter {
         mv.visitInsn(POP);
     }
 
+    private static void loadAndCastElement(OperandStack operandStack, MethodVisitor mv, Parameter[] parameters, int p) {
+        operandStack.push(ClassHelper.OBJECT_TYPE);
+        mv.visitInsn(DUP);
+        BytecodeHelper.pushConstant(mv, p);
+        mv.visitInsn(AALOAD);
+        operandStack.push(ClassHelper.OBJECT_TYPE);
+        ClassNode type = parameters[p].getType();
+        operandStack.doGroovyCast(type);
+        operandStack.swap();
+        operandStack.remove(2);
+    }
+
     // we match only on the number of arguments, not anything else
     private static ConstructorNode getMatchingConstructor(List<ConstructorNode> constructors, List<Expression> argumentList) {
         ConstructorNode lastMatch = null;
diff --git a/src/main/org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformation.java b/src/main/org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformation.java
index 11b15f41d9..f7e20c2564 100644
--- a/src/main/org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformation.java
+++ b/src/main/org/codehaus/groovy/runtime/typehandling/DefaultTypeTransformation.java
@@ -853,4 +853,17 @@ public class DefaultTypeTransformation {
         }
     }
 
+    public static Object castToVargsArray(Object[] origin, int firstVargsPos, Class<?> arrayType) {
+        Class<?> componentType = arrayType.getComponentType();
+        if (firstVargsPos>= origin.length) return Array.newInstance(componentType, 0);
+        int length = origin.length-firstVargsPos;
+        if (length==1 && arrayType.isInstance(origin[firstVargsPos])) return origin[firstVargsPos];
+        Object newArray = Array.newInstance(componentType, length);
+        for (int i=0; i<length; i++) {
+            Object convertedValue = castToType(origin[firstVargsPos+i],componentType);
+            Array.set(newArray, i, convertedValue);
+        }
+        return newArray;
+    }
+
 }
diff --git a/src/test/gls/enums/EnumTest.groovy b/src/test/gls/enums/EnumTest.groovy
index 94215e23cb..a3776acd7a 100644
--- a/src/test/gls/enums/EnumTest.groovy
+++ b/src/test/gls/enums/EnumTest.groovy
@@ -539,6 +539,20 @@ class EnumTest extends CompilableTestSupport {
             assert MyEnum.ENUM1.accept(new ConcreteVisitor(), null) == 'I have been visited!'
         """
     }
+
+    void testVargsConstructor() {
+        assertScript '''
+            enum Test {
+                TEST1(1, 2, 3)
+                public final info
+
+                Test(Integer... ints) {
+                    info = ints
+                }
+            }
+            println Test.TEST1.info == [1,2,3]
+        '''
+    }
 }
 
 enum UsCoin {
diff --git a/src/test/gls/invocation/ConstructorDelegationTest.groovy b/src/test/gls/invocation/ConstructorDelegationTest.groovy
index 01e9045113..fe4165a180 100644
--- a/src/test/gls/invocation/ConstructorDelegationTest.groovy
+++ b/src/test/gls/invocation/ConstructorDelegationTest.groovy
@@ -115,4 +115,40 @@ public class ConstructorDelegationTest extends CompilableTestSupport {
         """
         shouldNotCompile(scriptStr)
     }
+
+    // GROOVY-6618
+    public void testVarsConstructor() {
+        assertScript '''
+            class Foo {
+                public info
+                Foo(String s,Integer[] a){info=a}
+                Foo() {this("foo",1)}
+            }
+            assert new Foo().info == [1]
+        '''
+        assertScript '''
+            class Foo {
+                public info
+                Foo(String s,Integer[] a){info=a}
+                Foo() {this("foo",null)}
+            }
+            assert new Foo().info == null
+        '''
+        assertScript '''
+            class Foo {
+                public info
+                Foo(String s,Integer[] a){info=a}
+                Foo() {this("foo",1,2,3)}
+            }
+            assert new Foo().info == [1,2,3]
+        '''
+        assertScript '''
+            class Foo {
+                public info
+                Foo(String s,Integer[] a){info=a}
+                Foo() {this("foo")}
+            }
+            assert new Foo().info == []
+        '''
+    }
 }
\ No newline at end of file
