diff --git a/src/main/groovy/util/logging/Commons.java b/src/main/groovy/util/logging/Commons.java
index aa25d4afaa..fcd435c8f2 100644
--- a/src/main/groovy/util/logging/Commons.java
+++ b/src/main/groovy/util/logging/Commons.java
@@ -15,6 +15,7 @@
  */
 package groovy.util.logging;
 
+import groovy.lang.GroovyClassLoader;
 import org.codehaus.groovy.ast.ClassHelper;
 import org.codehaus.groovy.ast.ClassNode;
 import org.codehaus.groovy.ast.FieldNode;
@@ -58,33 +59,21 @@ public @interface Commons {
     String value() default "log";
     Class<? extends LogASTTransformation.LoggingStrategy> loggingStrategy() default CommonsLoggingStrategy.class;
 
-    public  static class CommonsLoggingStrategy implements LogASTTransformation.LoggingStrategy {
+    public  static class CommonsLoggingStrategy extends LogASTTransformation.AbstractLoggingStrategy {
 
-        private static final ClassNode LOGGER_CLASSNODE;
-        private static final ClassNode LOGGERFACTORY_CLASSNODE;
+        private static final String LOGGER_NAME = "org.apache.commons.logging.Log";
+        private static final String LOGGERFACTORY_NAME = "org.apache.commons.logging.LogFactory";
 
-        static {
-            ClassNode tmp1 = null;
-            ClassNode tmp2 = null;
-
-            try {
-                tmp1 = ClassHelper.make(Class.forName("org.apache.commons.logging.Log"));
-                tmp2 = ClassHelper.make(Class.forName("org.apache.commons.logging.LogFactory"));
-            } catch (ClassNotFoundException e) {
-                tmp1 = ClassHelper.make("org.apache.commons.logging.Log");
-                tmp2 = ClassHelper.make("org.apache.commons.logging.LogFactory");
-            } finally {
-                LOGGER_CLASSNODE = tmp1;
-                LOGGERFACTORY_CLASSNODE = tmp2;
-            }
+        protected CommonsLoggingStrategy(final GroovyClassLoader loader) {
+            super(loader);
         }
 
         public FieldNode addLoggerFieldToClass(ClassNode classNode, String logFieldName) {
             return classNode.addField(logFieldName,
                     Opcodes.ACC_FINAL | Opcodes.ACC_TRANSIENT | Opcodes.ACC_STATIC | Opcodes.ACC_PRIVATE,
-                    LOGGER_CLASSNODE,
+                    classNode(LOGGER_NAME),
                     new MethodCallExpression(
-                            new ClassExpression(LOGGERFACTORY_CLASSNODE),
+                            new ClassExpression(classNode(LOGGERFACTORY_NAME)),
                             "getLog",
                             new ClassExpression(classNode)));
         }
diff --git a/src/main/groovy/util/logging/Log.java b/src/main/groovy/util/logging/Log.java
index a094071a42..c8d870a63f 100644
--- a/src/main/groovy/util/logging/Log.java
+++ b/src/main/groovy/util/logging/Log.java
@@ -15,11 +15,13 @@
  */
 package groovy.util.logging;
 
+import groovy.lang.GroovyClassLoader;
 import org.codehaus.groovy.ast.ClassHelper;
 import org.codehaus.groovy.ast.ClassNode;
 import org.codehaus.groovy.ast.FieldNode;
 import org.codehaus.groovy.ast.expr.*;
 import org.codehaus.groovy.transform.GroovyASTTransformationClass;
+import org.codehaus.groovy.transform.LogASTTransformation;
 import org.codehaus.groovy.transform.LogASTTransformation.LoggingStrategy;
 import org.objectweb.asm.Opcodes;
 
@@ -67,11 +69,15 @@ public @interface Log {
     /**
      * This class contains the logic of how to weave a Java Util Logging logger into the host class.
      */
-    public static class JavaUtilLoggingStrategy implements LoggingStrategy {
+    public static class JavaUtilLoggingStrategy extends LogASTTransformation.AbstractLoggingStrategy {
 
         private static final ClassNode LOGGER_CLASSNODE = ClassHelper.make(java.util.logging.Logger.class);
         private static final ClassNode LEVEL_CLASSNODE = ClassHelper.make(java.util.logging.Level.class);
 
+        protected JavaUtilLoggingStrategy(final GroovyClassLoader loader) {
+            super(loader);
+        }
+
         public FieldNode addLoggerFieldToClass(ClassNode classNode, String logFieldName) {
             return classNode.addField(logFieldName,
                         Opcodes.ACC_FINAL | Opcodes.ACC_TRANSIENT | Opcodes.ACC_STATIC | Opcodes.ACC_PRIVATE,
diff --git a/src/main/groovy/util/logging/Log4j.java b/src/main/groovy/util/logging/Log4j.java
index 2a6fe971f0..f1b6a3ec86 100644
--- a/src/main/groovy/util/logging/Log4j.java
+++ b/src/main/groovy/util/logging/Log4j.java
@@ -15,6 +15,7 @@
  */
 package groovy.util.logging;
 
+import groovy.lang.GroovyClassLoader;
 import org.codehaus.groovy.ast.ClassHelper;
 import org.codehaus.groovy.ast.ClassNode;
 import org.codehaus.groovy.ast.FieldNode;
@@ -58,32 +59,20 @@ public @interface Log4j {
     String value() default "log";
     Class<? extends LogASTTransformation.LoggingStrategy> loggingStrategy() default Log4jLoggingStrategy.class;
 
-    public static class Log4jLoggingStrategy implements LogASTTransformation.LoggingStrategy {
-        private static final ClassNode LOGGER_CLASSNODE;
-        private static final ClassNode PRIORITY_CLASSNODE;
+    public static class Log4jLoggingStrategy extends LogASTTransformation.AbstractLoggingStrategy {
+        private static final String LOGGER_NAME = "org.apache.log4j.Logger";
+        private static final String PRIORITY_NAME = "org.apache.log4j.Priority";
 
-        static {
-            ClassNode tmp1 = null;
-            ClassNode tmp2 = null;
-
-            try {
-                tmp1 = ClassHelper.make(Class.forName("org.apache.log4j.Logger"));
-                tmp2 = ClassHelper.make(Class.forName("org.apache.log4j.Priority"));
-            } catch (ClassNotFoundException e) {
-                tmp1 = ClassHelper.make("org.apache.log4j.Logger");
-                tmp2 = ClassHelper.make("org.apache.log4j.Priority");
-            } finally {
-                LOGGER_CLASSNODE = tmp1;
-                PRIORITY_CLASSNODE = tmp2;
-            }
+        protected Log4jLoggingStrategy(final GroovyClassLoader loader) {
+            super(loader);
         }
 
         public FieldNode addLoggerFieldToClass(ClassNode classNode, String logFieldName) {
             return classNode.addField(logFieldName,
                     Opcodes.ACC_FINAL | Opcodes.ACC_TRANSIENT | Opcodes.ACC_STATIC | Opcodes.ACC_PRIVATE,
-                    LOGGER_CLASSNODE,
+                    classNode(LOGGER_NAME),
                     new MethodCallExpression(
-                            new ClassExpression(LOGGER_CLASSNODE),
+                            new ClassExpression(classNode(LOGGER_NAME)),
                             "getLogger",
                             new ClassExpression(classNode)));
         }
@@ -96,7 +85,7 @@ public @interface Log4j {
             final MethodCallExpression condition;
             if (!"trace".equals(methodName)) {
                 AttributeExpression logLevelExpression = new AttributeExpression(
-                        new ClassExpression(PRIORITY_CLASSNODE),
+                        new ClassExpression(classNode(PRIORITY_NAME)),
                         new ConstantExpression(methodName.toUpperCase()));
                 ArgumentListExpression args = new ArgumentListExpression();
                 args.addExpression(logLevelExpression);
diff --git a/src/main/groovy/util/logging/Slf4j.java b/src/main/groovy/util/logging/Slf4j.java
index be37287b6f..1b9cdf6754 100644
--- a/src/main/groovy/util/logging/Slf4j.java
+++ b/src/main/groovy/util/logging/Slf4j.java
@@ -20,6 +20,7 @@ import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 
+import groovy.lang.GroovyClassLoader;
 import org.codehaus.groovy.ast.ClassHelper;
 import org.codehaus.groovy.ast.ClassNode;
 import org.codehaus.groovy.ast.FieldNode;
@@ -58,32 +59,20 @@ public @interface Slf4j {
     String value() default "log";
     Class<? extends LogASTTransformation.LoggingStrategy> loggingStrategy() default Slf4jLoggingStrategy.class;
 
-    public static class Slf4jLoggingStrategy implements LogASTTransformation.LoggingStrategy {
-        private static final ClassNode LOGGER_CLASSNODE;
-        private static final ClassNode FACTORY_CLASSNODE;
+    public static class Slf4jLoggingStrategy extends LogASTTransformation.AbstractLoggingStrategy {
+        private static final String LOGGER_NAME = "org.slf4j.Logger";
+        private static final String FACTORY_NAME = "org.slf4j.LoggerFactory";
 
-        static {
-            ClassNode tmp1 = null;
-            ClassNode tmp2 = null;
-
-            try {
-                tmp1 = ClassHelper.make(Class.forName("org.slf4j.Logger"));
-                tmp2 = ClassHelper.make(Class.forName("org.slf4j.LoggerFactory"));
-            } catch (ClassNotFoundException e) {
-                tmp1 = ClassHelper.make("org.slf4j.Logger");
-                tmp2 = ClassHelper.make("org.slf4j.LoggerFactory");
-            } finally {
-                LOGGER_CLASSNODE = tmp1;
-                FACTORY_CLASSNODE = tmp2;
-            }
+        protected Slf4jLoggingStrategy(final GroovyClassLoader loader) {
+            super(loader);
         }
 
         public FieldNode addLoggerFieldToClass(ClassNode classNode, String logFieldName) {
             return classNode.addField(logFieldName,
                     Opcodes.ACC_FINAL | Opcodes.ACC_TRANSIENT | Opcodes.ACC_STATIC | Opcodes.ACC_PRIVATE,
-                    LOGGER_CLASSNODE,
+                    classNode(LOGGER_NAME),
                     new MethodCallExpression(
-                            new ClassExpression(FACTORY_CLASSNODE),
+                            new ClassExpression(classNode(FACTORY_NAME)),
                             "getLogger",
                             new ClassExpression(classNode)));
 
diff --git a/src/main/org/codehaus/groovy/transform/LogASTTransformation.java b/src/main/org/codehaus/groovy/transform/LogASTTransformation.java
index a470a4eef9..244b7a0a19 100644
--- a/src/main/org/codehaus/groovy/transform/LogASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/LogASTTransformation.java
@@ -1,212 +1,240 @@
-/*
- * Copyright 2003-2010 the original author or authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.codehaus.groovy.transform;
-
-import org.codehaus.groovy.GroovyBugError;
-import org.codehaus.groovy.ast.*;
-import org.codehaus.groovy.ast.expr.*;
-import org.codehaus.groovy.control.CompilePhase;
-import org.codehaus.groovy.control.SourceUnit;
-import org.codehaus.groovy.control.messages.SyntaxErrorMessage;
-import org.codehaus.groovy.syntax.SyntaxException;
-
-import java.lang.reflect.Method;
-import java.lang.reflect.Modifier;
-import java.util.Arrays;
-
-/**
- * This class provides an AST Transformation to add a log field to a class.
- *
- * @author Guillaume Laforge
- * @author Jochen Theodorou
- * @author Dinko Srkoc
- * @author Hamlet D'Arcy
- * @author Raffaele Cigni
- * @author Alberto Vilches Raton
- * @author Tomasz Bujok
- * @author Martin Ghados
- * @author Matthias Cullmann
- */
-@GroovyASTTransformation(phase = CompilePhase.SEMANTIC_ANALYSIS)
-public class LogASTTransformation implements ASTTransformation {
-
-    public void visit(ASTNode[] nodes, final SourceUnit source) {
-        if (nodes.length != 2 || !(nodes[0] instanceof AnnotationNode) || !(nodes[1] instanceof AnnotatedNode)) {
-            addError("Internal error: expecting [AnnotationNode, AnnotatedNode] but got: " + Arrays.asList(nodes), nodes[0], source);
-        }
-
-        AnnotatedNode targetClass = (AnnotatedNode) nodes[1];
-        AnnotationNode logAnnotation = (AnnotationNode) nodes[0];
-
-        final LoggingStrategy loggingStrategy = createLoggingStrategy(logAnnotation);
-        if (loggingStrategy == null) return;
-
-        final String logFieldName = lookupLogFieldName(logAnnotation);
-
-        if (!(targetClass instanceof ClassNode))
-            throw new GroovyBugError("Class annotation " + logAnnotation.getClassNode().getName() + " annotated no Class, this must not happen.");
-
-        final ClassNode classNode = (ClassNode) targetClass;
-
-        ClassCodeExpressionTransformer transformer = new ClassCodeExpressionTransformer() {
-            private FieldNode logNode;
-
-            @Override
-            protected SourceUnit getSourceUnit() {
-                return source;
-            }
-
-            public Expression transform(Expression exp) {
-                if (exp == null) return null;
-                if (exp instanceof MethodCallExpression) {
-                    return transformMethodCallExpression(exp);
-                }
-                return super.transform(exp);
-            }
-
-            @Override
-            public void visitClass(ClassNode node) {
-                FieldNode logField = node.getField(logFieldName);
-                if (logField != null && logField.getOwner().equals(node)) {
-                    addError("Class annotated with Log annotation cannot have log field declared", logField);
-                } else if (logField != null && !Modifier.isPrivate(logField.getModifiers())) {
-                    addError("Class annotated with Log annotation cannot have log field declared because the field exists in the parent class: " + logField.getOwner().getName(), logField);
-                } else {
-                    logNode = loggingStrategy.addLoggerFieldToClass(node, logFieldName);
-                }
-                super.visitClass(node);
-            }
-
-            private Expression transformMethodCallExpression(Expression exp) {
-                MethodCallExpression mce = (MethodCallExpression) exp;
-                if (!(mce.getObjectExpression() instanceof VariableExpression)) {
-                    return exp;
-                }
-                VariableExpression variableExpression = (VariableExpression) mce.getObjectExpression();
-                if (!variableExpression.getName().equals(logFieldName)
-                        || !(variableExpression.getAccessedVariable() instanceof DynamicVariable)) {
-                    return exp;
-                }
-                String methodName = mce.getMethodAsString();
-                if (methodName == null) return exp;
-                if (usesSimpleMethodArgumentsOnly(mce)) return exp;
-
-                variableExpression.setAccessedVariable(logNode);
-
-                if (!loggingStrategy.isLoggingMethod(methodName)) return exp;
-
-                return loggingStrategy.wrapLoggingMethodCall(variableExpression, methodName, exp);
-            }
-
-            private boolean usesSimpleMethodArgumentsOnly(MethodCallExpression mce) {
-                Expression arguments = mce.getArguments();
-                if (arguments instanceof TupleExpression) {
-                    TupleExpression tuple = (TupleExpression) arguments;
-                    for (Expression exp : tuple.getExpressions()) {
-                        if (!isSimpleExpression(exp)) return false;
-                    }
-                    return true;
-                }
-                return !isSimpleExpression(arguments);
-            }
-
-            private boolean isSimpleExpression(Expression exp) {
-                if (exp instanceof ConstantExpression) return true;
-                if (exp instanceof VariableExpression) return true;
-                return false;
-            }
-
-        };
-        transformer.visitClass(classNode);
-
-    }
-
-    private String lookupLogFieldName(AnnotationNode logAnnotation) {
-        Expression member = logAnnotation.getMember("value");
-        if (member != null && member.getText() != null) {
-            return member.getText();
-        } else {
-            return "log";
-        }
-    }
-
-    public void addError(String msg, ASTNode expr, SourceUnit source) {
-        int line = expr.getLineNumber();
-        int col = expr.getColumnNumber();
-        source.getErrorCollector().addErrorAndContinue(
-                new SyntaxErrorMessage(new SyntaxException(msg + '\n', line, col), source)
-        );
-    }
-
-    private LoggingStrategy createLoggingStrategy(AnnotationNode logAnnotation) {
-
-        String annotationName = logAnnotation.getClassNode().getName();
-
-        Class annotationClass;
-        try {
-            annotationClass = Class.forName(annotationName);
-        } catch (Throwable e) {
-            throw new RuntimeException("Could not resolve class named " + annotationName);
-        }
-
-        Method annotationMethod;
-        try {
-            annotationMethod = annotationClass.getDeclaredMethod("loggingStrategy", (Class[]) null);
-        } catch (Throwable e) {
-            throw new RuntimeException("Could not find method named loggingStrategy on class named " + annotationName);
-        }
-
-        Object defaultValue;
-        try {
-            defaultValue = annotationMethod.getDefaultValue();
-        } catch (Throwable e) {
-            throw new RuntimeException("Could not find default value of method named loggingStrategy on class named " + annotationName);
-        }
-
-        if (!LoggingStrategy.class.isAssignableFrom((Class) defaultValue)) {
-            throw new RuntimeException("Default loggingStrategy value on class named " + annotationName + " is not a LoggingStrategy");
-        }
-
-        try {
-            Class<? extends LoggingStrategy> strategyClass = (Class<? extends LoggingStrategy>) defaultValue;
-            return strategyClass.newInstance();
-        } catch (Exception e) {
-            return null;
-        }
-    }
-
-
-    /**
-     * A LoggingStrategy defines how to wire a new logger instance into an existing class.
-     * It is meant to be used with the @Log family of annotations to allow you to
-     * write your own Log annotation provider.
-     */
-    public interface LoggingStrategy {
-        /**
-         * In this method, you are given a ClassNode and a field name, and you must add a new Field
-         * onto the class. Return the result of the ClassNode.addField operations.
-         *
-         * @param classNode the class that was originally annotated with the Log transformation.
-         * @param fieldName the name of the logger field
-         * @return the FieldNode instance that was created and added to the class
-         */
-        FieldNode addLoggerFieldToClass(ClassNode classNode, String fieldName);
-
-        boolean isLoggingMethod(String methodName);
-
-        Expression wrapLoggingMethodCall(Expression logVariable, String methodName, Expression originalExpression);
-    }
-}
+/*
+ * Copyright 2003-2010 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.codehaus.groovy.transform;
+
+import groovy.lang.GroovyClassLoader;
+import groovy.lang.GroovyRuntimeException;
+import org.codehaus.groovy.GroovyBugError;
+import org.codehaus.groovy.ast.*;
+import org.codehaus.groovy.ast.expr.*;
+import org.codehaus.groovy.control.CompilePhase;
+import org.codehaus.groovy.control.SourceUnit;
+import org.codehaus.groovy.control.messages.SyntaxErrorMessage;
+import org.codehaus.groovy.runtime.DefaultGroovyMethods;
+import org.codehaus.groovy.syntax.SyntaxException;
+
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.util.Arrays;
+
+/**
+ * This class provides an AST Transformation to add a log field to a class.
+ *
+ * @author Guillaume Laforge
+ * @author Jochen Theodorou
+ * @author Dinko Srkoc
+ * @author Hamlet D'Arcy
+ * @author Raffaele Cigni
+ * @author Alberto Vilches Raton
+ * @author Tomasz Bujok
+ * @author Martin Ghados
+ * @author Matthias Cullmann
+ */
+@GroovyASTTransformation(phase = CompilePhase.SEMANTIC_ANALYSIS)
+public class LogASTTransformation implements ASTTransformation {
+
+    public void visit(ASTNode[] nodes, final SourceUnit source) {
+        if (nodes.length != 2 || !(nodes[0] instanceof AnnotationNode) || !(nodes[1] instanceof AnnotatedNode)) {
+            addError("Internal error: expecting [AnnotationNode, AnnotatedNode] but got: " + Arrays.asList(nodes), nodes[0], source);
+        }
+
+        AnnotatedNode targetClass = (AnnotatedNode) nodes[1];
+        AnnotationNode logAnnotation = (AnnotationNode) nodes[0];
+
+        final LoggingStrategy loggingStrategy = createLoggingStrategy(logAnnotation, source.getClassLoader());
+        if (loggingStrategy == null) return;
+
+        final String logFieldName = lookupLogFieldName(logAnnotation);
+
+        if (!(targetClass instanceof ClassNode))
+            throw new GroovyBugError("Class annotation " + logAnnotation.getClassNode().getName() + " annotated no Class, this must not happen.");
+
+        final ClassNode classNode = (ClassNode) targetClass;
+
+        ClassCodeExpressionTransformer transformer = new ClassCodeExpressionTransformer() {
+            private FieldNode logNode;
+
+            @Override
+            protected SourceUnit getSourceUnit() {
+                return source;
+            }
+
+            public Expression transform(Expression exp) {
+                if (exp == null) return null;
+                if (exp instanceof MethodCallExpression) {
+                    return transformMethodCallExpression(exp);
+                }
+                return super.transform(exp);
+            }
+
+            @Override
+            public void visitClass(ClassNode node) {
+                FieldNode logField = node.getField(logFieldName);
+                if (logField != null && logField.getOwner().equals(node)) {
+                    addError("Class annotated with Log annotation cannot have log field declared", logField);
+                } else if (logField != null && !Modifier.isPrivate(logField.getModifiers())) {
+                    addError("Class annotated with Log annotation cannot have log field declared because the field exists in the parent class: " + logField.getOwner().getName(), logField);
+                } else {
+                    logNode = loggingStrategy.addLoggerFieldToClass(node, logFieldName);
+                }
+                super.visitClass(node);
+            }
+
+            private Expression transformMethodCallExpression(Expression exp) {
+                MethodCallExpression mce = (MethodCallExpression) exp;
+                if (!(mce.getObjectExpression() instanceof VariableExpression)) {
+                    return exp;
+                }
+                VariableExpression variableExpression = (VariableExpression) mce.getObjectExpression();
+                if (!variableExpression.getName().equals(logFieldName)
+                        || !(variableExpression.getAccessedVariable() instanceof DynamicVariable)) {
+                    return exp;
+                }
+                String methodName = mce.getMethodAsString();
+                if (methodName == null) return exp;
+                if (usesSimpleMethodArgumentsOnly(mce)) return exp;
+
+                variableExpression.setAccessedVariable(logNode);
+
+                if (!loggingStrategy.isLoggingMethod(methodName)) return exp;
+
+                return loggingStrategy.wrapLoggingMethodCall(variableExpression, methodName, exp);
+            }
+
+            private boolean usesSimpleMethodArgumentsOnly(MethodCallExpression mce) {
+                Expression arguments = mce.getArguments();
+                if (arguments instanceof TupleExpression) {
+                    TupleExpression tuple = (TupleExpression) arguments;
+                    for (Expression exp : tuple.getExpressions()) {
+                        if (!isSimpleExpression(exp)) return false;
+                    }
+                    return true;
+                }
+                return !isSimpleExpression(arguments);
+            }
+
+            private boolean isSimpleExpression(Expression exp) {
+                if (exp instanceof ConstantExpression) return true;
+                if (exp instanceof VariableExpression) return true;
+                return false;
+            }
+
+        };
+        transformer.visitClass(classNode);
+
+    }
+
+    private String lookupLogFieldName(AnnotationNode logAnnotation) {
+        Expression member = logAnnotation.getMember("value");
+        if (member != null && member.getText() != null) {
+            return member.getText();
+        } else {
+            return "log";
+        }
+    }
+
+    public void addError(String msg, ASTNode expr, SourceUnit source) {
+        int line = expr.getLineNumber();
+        int col = expr.getColumnNumber();
+        source.getErrorCollector().addErrorAndContinue(
+                new SyntaxErrorMessage(new SyntaxException(msg + '\n', line, col), source)
+        );
+    }
+
+    private LoggingStrategy createLoggingStrategy(AnnotationNode logAnnotation, GroovyClassLoader loader) {
+
+        String annotationName = logAnnotation.getClassNode().getName();
+
+        Class annotationClass;
+        try {
+            annotationClass = Class.forName(annotationName);
+        } catch (Throwable e) {
+            throw new RuntimeException("Could not resolve class named " + annotationName);
+        }
+
+        Method annotationMethod;
+        try {
+            annotationMethod = annotationClass.getDeclaredMethod("loggingStrategy", (Class[]) null);
+        } catch (Throwable e) {
+            throw new RuntimeException("Could not find method named loggingStrategy on class named " + annotationName);
+        }
+
+        Object defaultValue;
+        try {
+            defaultValue = annotationMethod.getDefaultValue();
+        } catch (Throwable e) {
+            throw new RuntimeException("Could not find default value of method named loggingStrategy on class named " + annotationName);
+        }
+
+        if (!LoggingStrategy.class.isAssignableFrom((Class) defaultValue)) {
+            throw new RuntimeException("Default loggingStrategy value on class named " + annotationName + " is not a LoggingStrategy");
+        }
+
+        try {
+            Class<? extends LoggingStrategy> strategyClass = (Class<? extends LoggingStrategy>) defaultValue;
+            if (AbstractLoggingStrategy.class.isAssignableFrom(strategyClass)) {
+                return DefaultGroovyMethods.newInstance(strategyClass, new Object[]{loader});
+            } else {
+                return strategyClass.newInstance();
+            }
+        } catch (Exception e) {
+            return null;
+        }
+    }
+
+
+    /**
+     * A LoggingStrategy defines how to wire a new logger instance into an existing class.
+     * It is meant to be used with the @Log family of annotations to allow you to
+     * write your own Log annotation provider.
+     */
+    public interface LoggingStrategy {
+        /**
+         * In this method, you are given a ClassNode and a field name, and you must add a new Field
+         * onto the class. Return the result of the ClassNode.addField operations.
+         *
+         * @param classNode the class that was originally annotated with the Log transformation.
+         * @param fieldName the name of the logger field
+         * @return the FieldNode instance that was created and added to the class
+         */
+        FieldNode addLoggerFieldToClass(ClassNode classNode, String fieldName);
+
+        boolean isLoggingMethod(String methodName);
+
+        Expression wrapLoggingMethodCall(Expression logVariable, String methodName, Expression originalExpression);
+    }
+
+    public static abstract class AbstractLoggingStrategy implements LoggingStrategy {
+        protected final GroovyClassLoader loader;
+
+        protected AbstractLoggingStrategy(final GroovyClassLoader loader) {
+            this.loader = loader;
+        }
+
+        protected AbstractLoggingStrategy() {
+            this(null);
+        }
+
+        protected ClassNode classNode(String name) {
+            ClassLoader cl = loader==null?this.getClass().getClassLoader():loader;
+            try {
+                return ClassHelper.make(Class.forName(name, false, cl));
+            } catch (ClassNotFoundException e) {
+                throw new GroovyRuntimeException(e);
+            }
+        }
+    }
+}
