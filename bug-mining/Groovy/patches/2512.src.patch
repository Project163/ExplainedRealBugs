diff --git a/subprojects/groovy-console/src/main/groovy/groovy/ui/Console.groovy b/subprojects/groovy-console/src/main/groovy/groovy/ui/Console.groovy
index ffb305d947..8d26f0fb27 100644
--- a/subprojects/groovy-console/src/main/groovy/groovy/ui/Console.groovy
+++ b/subprojects/groovy-console/src/main/groovy/groovy/ui/Console.groovy
@@ -177,7 +177,6 @@ class Console implements CaretListener, HyperlinkListener, ComponentListener, Fo
     SystemOutputInterceptor systemOutInterceptor
     SystemOutputInterceptor systemErrorInterceptor
     Thread runThread = null
-    OutputStreamSynchronisation outputStreamSynchronisation = new OutputStreamSynchronisation(prefs.getLong('outputStreamSyncDelay', 200l), prefs.getLong('outputStreamSyncPeriod', 250l))
     Closure beforeExecution
     Closure afterExecution
 
@@ -369,8 +368,7 @@ options:
         // as there is no point in showing the repeating details at the back 
         int offset = stackOverFlowError ? maxOutputChars : 0
         if (doc.length > maxOutputChars) {
-            // if not a stackoverflow remove a quarter of the currently rendered screen
-            doc.remove(offset, stackOverFlowError ? doc.length - maxOutputChars : (int) (maxOutputChars * 1.0f / 4))
+            doc.remove(offset, doc.length - maxOutputChars)
         }
     }
 
@@ -446,12 +444,21 @@ options:
     // Append a string to the output area on a new line
     void appendOutputNl(text, style) {
         def doc = outputArea.styledDocument
+        def len = doc.length
+        def alreadyNewLine = (len == 0 || doc.getText(len - 1, 1) == '\n')
         doc.insertString(doc.length, ' \n', style)
+        if (alreadyNewLine) {
+            doc.remove(len, 2) // windows hack to fix (improve?) line spacing
+        }
         appendOutput(text, style)
     }
 
     void appendOutputLines(text, style) {
         appendOutput(text, style)
+        def doc = outputArea.styledDocument
+        def len = doc.length
+        doc.insertString(len, ' \n', style)
+        doc.remove(len, 2) // windows hack to fix (improve?) line spacing
     }
 
     // Return false if use elected to cancel
@@ -684,8 +691,6 @@ options:
     }
 
     def finishException(Throwable t, boolean executing) {
-        stopOutputAreaSync()
-
         if(executing) {
             statusLabel.text = 'Execution terminated with exception.'
             history[-1].exception = t
@@ -707,27 +712,23 @@ options:
 
                     String scriptFileName = scriptFile?.name ?: DEFAULT_SCRIPT_NAME_START 
 
-                    SwingUtilities.invokeLater {
-                        def doc = outputArea.styledDocument
+                    def doc = outputArea.styledDocument
 
-                        def style = hyperlinkStyle
-                        def hrefAttr = new SimpleAttributeSet()
-                        // don't pass a GString as it won't be coerced to String as addAttribute takes an Object
-                        hrefAttr.addAttribute(HTML.Attribute.HREF, 'file://' + scriptFileName + ':' + errorLine)
-                        style.addAttribute(HTML.Tag.A, hrefAttr);
+                    def style = hyperlinkStyle
+                    def hrefAttr = new SimpleAttributeSet()
+                    // don't pass a GString as it won't be coerced to String as addAttribute takes an Object
+                    hrefAttr.addAttribute(HTML.Attribute.HREF, 'file://' + scriptFileName + ':' + errorLine)
+                    style.addAttribute(HTML.Tag.A, hrefAttr);
 
-                        doc.insertString(doc.length, message + ' at ', stacktraceStyle)
-                        doc.insertString(doc.length, "line: ${se.line}, column: ${se.startColumn}\n\n", style)
-                    }
+                    doc.insertString(doc.length, message + ' at ', stacktraceStyle)
+                    doc.insertString(doc.length, "line: ${se.line}, column: ${se.startColumn}\n\n", style)
                 } else if (error instanceof Throwable) {
                     reportException(error)
                 } else if (error instanceof ExceptionMessage) {
                     reportException(error.cause) 
                 } else if (error instanceof SimpleMessage) {
-                    SwingUtilities.invokeLater {
-                        def doc = outputArea.styledDocument
-                        doc.insertString(doc.length, "${error.message}\n", new SimpleAttributeSet())
-                    }
+                    def doc = outputArea.styledDocument
+                    doc.insertString(doc.length, "${error.message}\n", new SimpleAttributeSet())
                 }
             }
         } else {
@@ -752,31 +753,25 @@ options:
     }
 
     private reportException(Throwable t) {
-        SwingUtilities.invokeLater {
-            appendOutputNl('Exception thrown\n', commandStyle)
+        appendOutputNl('Exception thrown\n', commandStyle)
 
-            StringWriter sw = new StringWriter()
-            new PrintWriter(sw).withWriter {pw -> StackTraceUtils.deepSanitize(t).printStackTrace(pw) }
-            appendStacktrace("\n${sw.buffer}\n")
-        }
+        StringWriter sw = new StringWriter()
+        new PrintWriter(sw).withWriter {pw -> StackTraceUtils.deepSanitize(t).printStackTrace(pw) }
+        appendStacktrace("\n${sw.buffer}\n")
     }
 
     def finishNormal(Object result) {
-        stopOutputAreaSync()
-
         // Take down the wait/cancel dialog
         history[-1].result = result
         if (result != null) {
             statusLabel.text = 'Execution complete.'
-            SwingUtilities.invokeLater {
-                appendOutputNl('Result: ', promptStyle)
-                def obj = (visualizeScriptResults
-                    ? OutputTransforms.transformResult(result, shell.getContext()._outputTransforms)
-                    : result.toString())
+            appendOutputNl('Result: ', promptStyle)
+            def obj = (visualizeScriptResults
+                ? OutputTransforms.transformResult(result, shell.getContext()._outputTransforms)
+                : result.toString())
 
-                // multi-methods are magical!
-                appendOutput(obj, resultStyle)
-            }
+            // multi-methods are magical!
+            appendOutput(obj, resultStyle)
         } else {
             statusLabel.text = 'Execution complete. Result was null.'
         }
@@ -786,27 +781,7 @@ options:
             showOutputWindow()
         }
     }
-
-    /**
-     * Start the {@code outputArea} synchronisation task.
-     */
-    void startOutputAreaSync() {
-        outputStreamSynchronisation.start()
-    }
-
-    /**
-     * Stops the {@code outputArea} synchronisation task and flushes all buffers. This method will block as long as
-     * all document updates have been completed.
-     */
-    void stopOutputAreaSync() {
-        // let's wait till all updates are completed
-        outputStreamSynchronisation.stop()
-
-        // flush the buffers once again to have clean buffers
-        System.out.flush()
-        System.err.flush()
-    }
-
+    
     def compileFinishNormal() {
         statusLabel.text = 'Compilation complete.'
     }
@@ -994,7 +969,6 @@ options:
                 if(beforeExecution) {
                     beforeExecution()
                 }
-                startOutputAreaSync()
                 def result
                 if(useScriptClassLoaderForScriptExecution) {
                     ClassLoader savedThreadContextClassLoader = Thread.currentThread().contextClassLoader
@@ -1024,7 +998,6 @@ options:
                 runThread = null
                 scriptRunning = false
                 interruptAction.enabled = false
-                stopOutputAreaSync()
             }
         }
     }
diff --git a/subprojects/groovy-console/src/main/groovy/groovy/ui/SystemOutputInterceptor.java b/subprojects/groovy-console/src/main/groovy/groovy/ui/SystemOutputInterceptor.java
index 5e3fbcd920..a8a87833d4 100644
--- a/subprojects/groovy-console/src/main/groovy/groovy/ui/SystemOutputInterceptor.java
+++ b/subprojects/groovy-console/src/main/groovy/groovy/ui/SystemOutputInterceptor.java
@@ -17,18 +17,17 @@ package groovy.ui;
 
 import groovy.lang.Closure;
 
-import java.io.BufferedOutputStream;
 import java.io.FilterOutputStream;
 import java.io.IOException;
 import java.io.PrintStream;
 
 /**
  * Intercepts System.out/System.err. Implementation helper for Console.groovy.
+ *
+ * @version $Id$
  */
 public class SystemOutputInterceptor extends FilterOutputStream {
 
-    private static final int BUFFER_SIZE = 2048;
-
     private Closure callback;
     private boolean output;
 
@@ -61,15 +60,13 @@ public class SystemOutputInterceptor extends FilterOutputStream {
     }
 
     /**
-     * Installs the stream intercepting System.out/System.err stream. This will turn {@code autoFlush} mode off as this
-     * interceptor uses a {@link BufferedOutputStream} stream for more control on when the actual flush is done.
-     * This way we can decrease the actual amount of document updates for the outputArea.
+     * Starts intercepting System.out/System.err
      */
     public void start() {
         if (output) {
-            System.setOut(new PrintStream(new BufferedOutputStream(this, BUFFER_SIZE), false));
+            System.setOut(new PrintStream(this));
         } else {
-            System.setErr(new PrintStream(new BufferedOutputStream(this, BUFFER_SIZE), false));
+            System.setErr(new PrintStream(this));
         }
     }
 
@@ -86,7 +83,7 @@ public class SystemOutputInterceptor extends FilterOutputStream {
     }
 
     /**
-     * Intercepts output - more common case of byte[]
+     * Intercepts output - moret common case of byte[]
      */
     public void write(byte[] b, int off, int len) throws IOException {
         Boolean result = (Boolean) callback.call(new String(b, off, len));
diff --git a/subprojects/groovy-console/src/main/java/groovy/ui/OutputStreamSynchronisation.java b/subprojects/groovy-console/src/main/java/groovy/ui/OutputStreamSynchronisation.java
deleted file mode 100644
index 7b29461d2a..0000000000
--- a/subprojects/groovy-console/src/main/java/groovy/ui/OutputStreamSynchronisation.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Copyright 2003-2014 the original author or authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package groovy.ui;
-
-import java.util.concurrent.Executors;
-import java.util.concurrent.ScheduledExecutorService;
-import java.util.concurrent.TimeUnit;
-
-/**
- * Implementation helper for groovyConsole. Flushes {@code System.out} and {@code System.err} at a fixed rate. This
- * bundles updates for the outputArea Swing document as the {@link SystemOutputInterceptor} uses a
- * a {@link java.io.BufferedOutputStream} with a certain size that will get flushed by this class constantly.
- *
- * @author Andre Steingress
- */
-public class OutputStreamSynchronisation {
-
-    protected ScheduledExecutorService executorService;
-
-    protected final long delay;
-    protected final long period;
-
-    /**
-     * Creates a new instance without actually starting the synchronisation. This must be done with a separate call to
-     * {@link #start()}.
-     *
-     * @param delay the initial delay in milli-seconds till synchronisation will start
-     * @param period the time period in milli-seconds to be used between subsequent flushes
-     */
-    public OutputStreamSynchronisation(long delay, long period)  {
-        this.delay = delay;
-        this.period = period;
-    }
-
-    /**
-     * Starts the scheduled flushes with the given {@code delay} and {@code period}.
-     */
-    public synchronized void start() {
-        executorService = Executors.newSingleThreadScheduledExecutor();
-        executorService.scheduleAtFixedRate(new Runnable() {
-            @Override
-            public void run() {
-                System.out.flush();
-                System.err.flush();
-            }
-
-        }, delay, period, TimeUnit.MILLISECONDS);
-    }
-
-    /**
-     * Stops the scheduled flushes and blocks as long as all scheduled updates have been completed.
-     *
-     * @throws InterruptedException if waiting has been interrupted
-     */
-    public synchronized void stop() throws InterruptedException {
-        if (executorService == null)  return;
-
-        executorService.shutdown();
-        executorService.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS);
-    }
-}
diff --git a/subprojects/groovy-console/src/test/groovy/groovy/swing/SwingBuilderConsoleTest.groovy b/subprojects/groovy-console/src/test/groovy/groovy/swing/SwingBuilderConsoleTest.groovy
index d5891b9833..f14c74c921 100644
--- a/subprojects/groovy-console/src/test/groovy/groovy/swing/SwingBuilderConsoleTest.groovy
+++ b/subprojects/groovy-console/src/test/groovy/groovy/swing/SwingBuilderConsoleTest.groovy
@@ -432,47 +432,4 @@ class SwingBuilderConsoleTest extends GroovySwingTestCase {
             }
         }
     }
-
-    void testIterateOverLargeList() {
-        testInEDT {
-            SwingUtilities.metaClass.static.invokeLater = { Runnable runnable ->
-                runnable.run()
-            }
-            Thread.metaClass.static.start = { Runnable runnable ->
-                runnable.run()
-            }
-
-            // in case the static final var has been already initialized
-            Console.prefs = testPreferences
-
-            try {
-                final console = new Console()
-
-                def binding = new Binding()
-                binding.setVariable('controller', console)
-
-                final consoleActions = new ConsoleActions()
-
-                def swing = new SwingBuilder()
-                swing.controller = console
-
-                swing.build(consoleActions)
-                console.run()
-
-                console.inputArea.text = '(1..10000).each { println it }'
-                def start = System.currentTimeMillis()
-                console.runScript(new EventObject([:]))
-                def end = System.currentTimeMillis()
-
-                def doc = console.outputArea.document
-
-                assert (end - start) <= 10000
-                assert doc.getText(0, doc.length).contains('Result: 1..10000')
-            } finally {
-                GroovySystem.metaClassRegistry.removeMetaClass(Thread)
-                GroovySystem.metaClassRegistry.removeMetaClass(SwingUtilities)
-                GroovySystem.metaClassRegistry.removeMetaClass(Preferences)
-            }
-        }
-    }
 }
