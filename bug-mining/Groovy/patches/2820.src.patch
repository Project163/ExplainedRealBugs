diff --git a/src/main/org/codehaus/groovy/transform/stc/TraitTypeCheckingExtension.java b/src/main/org/codehaus/groovy/transform/stc/TraitTypeCheckingExtension.java
index 92be29fffc..fe19e79b98 100644
--- a/src/main/org/codehaus/groovy/transform/stc/TraitTypeCheckingExtension.java
+++ b/src/main/org/codehaus/groovy/transform/stc/TraitTypeCheckingExtension.java
@@ -20,6 +20,8 @@ import org.codehaus.groovy.ast.ClassNode;
 import org.codehaus.groovy.ast.MethodNode;
 import org.codehaus.groovy.ast.expr.ArgumentListExpression;
 import org.codehaus.groovy.ast.expr.MethodCall;
+import org.codehaus.groovy.ast.expr.MethodCallExpression;
+import org.codehaus.groovy.transform.trait.TraitASTTransformation;
 import org.codehaus.groovy.transform.trait.Traits;
 
 import java.util.Arrays;
@@ -56,6 +58,12 @@ public class TraitTypeCheckingExtension extends AbstractTypeCheckingExtension {
         if (decomposed != null) {
             return convertToDynamicCall(call, receiver, decomposed, argumentTypes);
         }
+        if (call instanceof MethodCallExpression) {
+            ClassNode dynamic = ((MethodCallExpression) call).getNodeMetaData(TraitASTTransformation.DO_DYNAMIC);
+            if (dynamic!=null) {
+                return Collections.singletonList(makeDynamic(call, dynamic));
+            }
+        }
         return NOTFOUND;
     }
 
diff --git a/src/main/org/codehaus/groovy/transform/trait/TraitASTTransformation.java b/src/main/org/codehaus/groovy/transform/trait/TraitASTTransformation.java
index 8c91687325..c1897a2a24 100644
--- a/src/main/org/codehaus/groovy/transform/trait/TraitASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/trait/TraitASTTransformation.java
@@ -73,6 +73,7 @@ import java.util.Set;
 @GroovyASTTransformation(phase = CompilePhase.SEMANTIC_ANALYSIS)
 public class TraitASTTransformation extends AbstractASTTransformation implements CompilationUnitAware {
 
+    public static final String DO_DYNAMIC = TraitReceiverTransformer.class+".doDynamic";
     private static final ClassNode INVOKERHELPER_CLASSNODE = ClassHelper.make(InvokerHelper.class);
 
     private static final ClassNode OVERRIDE_CLASSNODE = ClassHelper.make(Override.class);
diff --git a/src/main/org/codehaus/groovy/transform/trait/TraitReceiverTransformer.java b/src/main/org/codehaus/groovy/transform/trait/TraitReceiverTransformer.java
index 5b7caba1c5..583878eea1 100644
--- a/src/main/org/codehaus/groovy/transform/trait/TraitReceiverTransformer.java
+++ b/src/main/org/codehaus/groovy/transform/trait/TraitReceiverTransformer.java
@@ -101,31 +101,20 @@ class TraitReceiverTransformer extends ClassCodeExpressionTransformer {
                 } else if (leftExpression instanceof PropertyExpression
                         && (((PropertyExpression) leftExpression).isImplicitThis() || "this".equals(((PropertyExpression) leftExpression).getObjectExpression().getText()))) {
                     leftFieldName = ((PropertyExpression) leftExpression).getPropertyAsString();
-                    FieldNode fn = weavedType.getDeclaredField(leftFieldName);
-                    if (fn==null && ClassHelper.CLASS_Type.equals(weavedType)) {
-                        GenericsType[] genericsTypes = weavedType.getGenericsTypes();
-                        if (genericsTypes !=null && genericsTypes.length==1) {
-                            // for static properties
-                            fn = genericsTypes[0].getType().getDeclaredField(leftFieldName);
-                        }
-                    }
+                    FieldNode fn = tryGetFieldNode(weavedType, leftFieldName);
                     if (fieldHelper == null || fn==null && !fieldHelper.hasPossibleMethod(Traits.helperSetterName(new FieldNode(leftFieldName, 0, ClassHelper.OBJECT_TYPE, weavedType, null)), rightExpression)) {
-                        return new BinaryExpression(
-                                new PropertyExpression(
-                                        new VariableExpression(weaved),
-                                        leftFieldName
-                                ),
-                                operation,
-                                transform(rightExpression));
+                        return createAssignmentToField(rightExpression, operation, leftFieldName);
                     }
                 }
                 if (leftFieldName!=null) {
                     FieldNode fn = weavedType.getDeclaredField(leftFieldName);
+                    FieldNode staticField = tryGetFieldNode(weavedType, leftFieldName);
                     if (fn==null) {
                         fn = new FieldNode(leftFieldName, 0, ClassHelper.OBJECT_TYPE, weavedType, null);
                     }
                     Expression receiver = createFieldHelperReceiver();
-                    if (fn.isStatic()) {
+                    boolean isStatic = staticField!=null && staticField.isStatic();
+                    if (fn.isStatic()) { // DO NOT USE isStatic variable here!
                         receiver = new PropertyExpression(receiver, "class");
                     }
                     String method = Traits.helperSetterName(fn);
@@ -136,6 +125,7 @@ class TraitReceiverTransformer extends ClassCodeExpressionTransformer {
                     );
                     mce.setSourcePosition(exp);
                     mce.setImplicitThis(false);
+                    markDynamicCall(mce, staticField, isStatic);
                     return mce;
                 }
             }
@@ -181,6 +171,7 @@ class TraitReceiverTransformer extends ClassCodeExpressionTransformer {
             );
             mce.setSourcePosition(exp);
             mce.setImplicitThis(false);
+            markDynamicCall(mce, field, field.isStatic());
             return mce;
         } else if (exp instanceof VariableExpression) {
             VariableExpression vexp = (VariableExpression) exp;
@@ -189,24 +180,18 @@ class TraitReceiverTransformer extends ClassCodeExpressionTransformer {
                 FieldNode fn = (FieldNode) accessedVariable;
                 Expression receiver = createFieldHelperReceiver();
                 MethodCallExpression mce;
-                if (fn.isStatic()) {
-                    receiver = new TernaryExpression(
-                            new BooleanExpression(new BinaryExpression(
-                                    receiver,
-                                    Token.newSymbol(Types.KEYWORD_INSTANCEOF, -1, -1),
-                                    new ClassExpression(ClassHelper.CLASS_Type)
-                            )),
-                            receiver,
-                            new MethodCallExpression(createFieldHelperReceiver(), "getClass", ArgumentListExpression.EMPTY_ARGUMENTS)
-                    );
+                boolean isStatic = fn.isStatic();
+                if (isStatic) {
+                    receiver = createStaticReceiver(receiver);
                 }
                 mce = new MethodCallExpression(
                             receiver,
-                            Traits.helperGetterName((FieldNode) accessedVariable),
+                            Traits.helperGetterName(fn),
                             ArgumentListExpression.EMPTY_ARGUMENTS
                 );
                 mce.setSourcePosition(exp);
                 mce.setImplicitThis(false);
+                markDynamicCall(mce, fn, isStatic);
                 return mce;
             } else if (accessedVariable instanceof PropertyNode) {
                 String propName = accessedVariable.getName();
@@ -276,6 +261,46 @@ class TraitReceiverTransformer extends ClassCodeExpressionTransformer {
         return super.transform(exp);
     }
 
+    private void markDynamicCall(final MethodCallExpression mce, final FieldNode fn, final boolean isStatic) {
+        if (isStatic) {
+            mce.putNodeMetaData(TraitASTTransformation.DO_DYNAMIC, fn.getOriginType());
+        }
+    }
+
+    private TernaryExpression createStaticReceiver(final Expression receiver) {
+        return new TernaryExpression(
+                new BooleanExpression(new BinaryExpression(
+                        receiver,
+                        Token.newSymbol(Types.KEYWORD_INSTANCEOF, -1, -1),
+                        new ClassExpression(ClassHelper.CLASS_Type)
+                )),
+                receiver,
+                new MethodCallExpression(createFieldHelperReceiver(), "getClass", ArgumentListExpression.EMPTY_ARGUMENTS)
+        );
+    }
+
+    private BinaryExpression createAssignmentToField(final Expression rightExpression, final Token operation, final String fieldName) {
+        return new BinaryExpression(
+                new PropertyExpression(
+                        new VariableExpression(weaved),
+                        fieldName
+                ),
+                operation,
+                transform(rightExpression));
+    }
+
+    private FieldNode tryGetFieldNode(final ClassNode weavedType, final String fieldName) {
+        FieldNode fn = weavedType.getDeclaredField(fieldName);
+        if (fn==null && ClassHelper.CLASS_Type.equals(weavedType)) {
+            GenericsType[] genericsTypes = weavedType.getGenericsTypes();
+            if (genericsTypes !=null && genericsTypes.length==1) {
+                // for static properties
+                fn = genericsTypes[0].getType().getDeclaredField(fieldName);
+            }
+        }
+        return fn;
+    }
+
     private void throwSuperError(final ASTNode node) {
         unit.addError(new SyntaxException("Call to super is not allowed in a trait", node.getLineNumber(), node.getColumnNumber()));
     }
diff --git a/src/test/org/codehaus/groovy/transform/traitx/Groovy7255Bug.groovy b/src/test/org/codehaus/groovy/transform/traitx/Groovy7255Bug.groovy
new file mode 100644
index 0000000000..9bf18fb65d
--- /dev/null
+++ b/src/test/org/codehaus/groovy/transform/traitx/Groovy7255Bug.groovy
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2003-2015 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.codehaus.groovy.transform.traitx
+
+class Groovy7255Bug extends GroovyTestCase {
+    void testShouldAllowSettingStaticFieldInTraitUsingCompileStatic() {
+        assertScript '''
+@groovy.transform.CompileStatic
+trait SomeTrait {
+    static List stuff = [1,2,3]
+
+    static void initStuff(List l) {
+        stuff = stuff + l
+    }
+}
+
+class A implements SomeTrait {}
+A.initStuff([4,5,6])
+assert A.stuff == [1,2,3,4,5,6]
+'''
+    }
+}
