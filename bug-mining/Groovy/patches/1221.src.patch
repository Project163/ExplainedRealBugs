diff --git a/src/main/groovy/lang/Immutable.java b/src/main/groovy/lang/Immutable.java
index a42b6f3620..9164e031fb 100644
--- a/src/main/groovy/lang/Immutable.java
+++ b/src/main/groovy/lang/Immutable.java
@@ -41,7 +41,7 @@ import java.lang.annotation.Target;
  * </pre>
  * A class created in this way has the following characteristics:
  * <ul>
- * <li>The class is automatically made final if not already final.
+ * <li>The class is automatically made final.
  * <li>Properties automatically have private, final backing fields with getters.
  * Attempts to update the property will result in a {@code ReadOnlyPropertyException}.
  * <li>A map-based constructor is provided which allows you to set properties by name.
@@ -69,10 +69,13 @@ import java.lang.annotation.Target;
  * then you can write explicit get and set methods. Such an approach, isn't currently prohibited (to give you some
  * wiggle room to get around these conventions) but any fields created in this way are deemed not to be part of the
  * significant state of the object and aren't factored into the {@code equals} or {@code hashCode} methods.
- * Use at your own risk!
+ * Similarly, you may use static properties (though usually this is discouraged) and these too will be ignored
+ * as far as significant state is concerned. If you do break standard conventions, you do so at your own risk and
+ * your objects may no longer be immutable. It is up to you to ensure that your objects remain immutable at least
+ * to the extent expected in other parts of your program!
  * </ul>
  * <p/>
- * Such classes are particularly useful for functional and concurrent styles of programming
+ * Immutable classes are particularly useful for functional and concurrent styles of programming
  * and for use as key values within maps.
  * <p/>
  * Limitations:
diff --git a/src/main/org/codehaus/groovy/transform/ImmutableASTTransformation.java b/src/main/org/codehaus/groovy/transform/ImmutableASTTransformation.java
index c1ebae8d7e..735bdba579 100644
--- a/src/main/org/codehaus/groovy/transform/ImmutableASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/ImmutableASTTransformation.java
@@ -97,7 +97,7 @@ public class ImmutableASTTransformation implements ASTTransformation, Opcodes {
                 cNode.setModifiers(cNode.getModifiers() | ACC_FINAL);
             }
 
-            final List<PropertyNode> pList = cNode.getProperties();
+            final List<PropertyNode> pList = getInstanceProperties(cNode);
             for (PropertyNode pNode : pList) {
                 adjustPropertyForImmutability(pNode, newNodes);
             }
@@ -143,7 +143,7 @@ public class ImmutableASTTransformation implements ASTTransformation, Opcodes {
         final FieldNode hashField = cNode.addField("$hash$code", ACC_PRIVATE | ACC_SYNTHETIC, ClassHelper.int_TYPE, null);
         final BlockStatement body = new BlockStatement();
         final Expression hash = new FieldExpression(hashField);
-        final List<PropertyNode> list = cNode.getProperties();
+        final List<PropertyNode> list = getInstanceProperties(cNode);
 
         body.addStatement(new IfStatement(
                 isZeroExpr(hash),
@@ -163,7 +163,7 @@ public class ImmutableASTTransformation implements ASTTransformation, Opcodes {
         if (hasExistingToString && hasDeclaredMethod(cNode, "_toString", 0)) return;
         
         final BlockStatement body = new BlockStatement();
-        final List<PropertyNode> list = cNode.getProperties();
+        final List<PropertyNode> list = getInstanceProperties(cNode);
         // def _result = new StringBuffer()
         final Expression result = new VariableExpression("_result");
         final Expression init = new ConstructorCallExpression(STRINGBUFFER_TYPE, MethodCallExpression.NO_ARGUMENTS);
@@ -238,7 +238,7 @@ public class ImmutableASTTransformation implements ASTTransformation, Opcodes {
 
         body.addStatement(new ExpressionStatement(new BinaryExpression(other, ASSIGN, new CastExpression(cNode, other))));
 
-        final List<PropertyNode> list = cNode.getProperties();
+        final List<PropertyNode> list = getInstanceProperties(cNode);
         // fields
         for (PropertyNode pNode : list) {
             body.addStatement(returnFalseIfPropertyNotEqual(pNode, other));
@@ -303,7 +303,7 @@ public class ImmutableASTTransformation implements ASTTransformation, Opcodes {
             throw new RuntimeException("Explicit constructors not allowed for " + MY_TYPE_NAME + " class: " + cNode.getNameWithoutPackage());
         }
 
-        List<PropertyNode> list = cNode.getProperties();
+        List<PropertyNode> list = getInstanceProperties(cNode);
         boolean specialHashMapCase = list.size() == 1 && list.get(0).getField().getType().equals(HASHMAP_TYPE);
         if (specialHashMapCase) {
             createConstructorMapSpecial(cNode, constructorStyle, list);
@@ -313,6 +313,16 @@ public class ImmutableASTTransformation implements ASTTransformation, Opcodes {
         }
     }
 
+    private List<PropertyNode> getInstanceProperties(ClassNode cNode) {
+        final List<PropertyNode> result = new ArrayList<PropertyNode>();
+        for (PropertyNode pNode : cNode.getProperties()) {
+            if (!pNode.isStatic()) {
+                result.add(pNode);
+            }
+        }
+        return result;
+    }
+
     private void createConstructorMapSpecial(ClassNode cNode, FieldExpression constructorStyle, List<PropertyNode> list) {
         final BlockStatement body = new BlockStatement();
         body.addStatement(createConstructorStatementMapSpecial(list.get(0).getField()));
diff --git a/src/test/org/codehaus/groovy/transform/ImmutableTransformTest.groovy b/src/test/org/codehaus/groovy/transform/ImmutableTransformTest.groovy
index 0d601cfe05..a9bd76d3d9 100644
--- a/src/test/org/codehaus/groovy/transform/ImmutableTransformTest.groovy
+++ b/src/test/org/codehaus/groovy/transform/ImmutableTransformTest.groovy
@@ -186,4 +186,33 @@ class ImmutableTransformTest extends GroovyShellTestCase {
             assert baz2.hashCode() == -100
         """
     }
+
+    void testStaticsAllowed_ThoughUsuallyBadDesign() {
+        // design here is questionable as getDescription() method is not idempotent
+        assertScript '''
+            @Immutable class Person {
+               String first, last
+               static species = 'Human'
+               String getFullname() {
+                 "$first $last"
+               }
+               String getDescription() {
+                 "$fullname is a $species"
+               }
+            }
+
+            def spock = new Person('Leonard', 'Nimoy')
+            assert spock.species == 'Human'
+            assert spock.fullname == 'Leonard Nimoy'
+            assert spock.description == 'Leonard Nimoy is a Human'
+
+            spock.species = 'Romulan'
+            assert spock.species == 'Romulan'
+
+            Person.species = 'Vulcan'
+            assert spock.species == 'Vulcan'
+            assert spock.fullname == 'Leonard Nimoy'
+            assert spock.description == 'Leonard Nimoy is a Vulcan'
+        '''
+    }
 }
\ No newline at end of file
