diff --git a/src/main/org/codehaus/groovy/reflection/ClassInfo.java b/src/main/org/codehaus/groovy/reflection/ClassInfo.java
index 2bad25be3a..5c4daa0346 100644
--- a/src/main/org/codehaus/groovy/reflection/ClassInfo.java
+++ b/src/main/org/codehaus/groovy/reflection/ClassInfo.java
@@ -153,7 +153,12 @@ public class ClassInfo extends ManagedConcurrentMap.Entry<Class,ClassInfo> {
     }
 
     public MetaClass getMetaClassForClass() {
-        return strongMetaClass != null ? strongMetaClass : weakMetaClass == null ? null : weakMetaClass.get();
+        if (strongMetaClass!=null) return strongMetaClass;
+        MetaClass weakMc = getWeakMetaClass();
+        if (isValidWeakMetaClass(weakMc)) {
+            return weakMc;
+        }
+        return null;
     }
 
     private MetaClass getMetaClassUnderLock() {
@@ -164,14 +169,8 @@ public class ClassInfo extends ManagedConcurrentMap.Entry<Class,ClassInfo> {
         final MetaClassRegistry metaClassRegistry = GroovySystem.getMetaClassRegistry();
         MetaClassRegistry.MetaClassCreationHandle mccHandle = metaClassRegistry.getMetaClassCreationHandler();
         
-        if (answer != null) {
-            boolean enableGloballyOn = (mccHandle instanceof ExpandoMetaClassCreationHandle);
-            boolean cachedAnswerIsEMC = (answer instanceof ExpandoMetaClass);
-            // if EMC.enableGlobally() is OFF, return whatever the cached answer is.
-            // but if EMC.enableGlobally() is ON and the cached answer is not an EMC, come up with a fresh answer
-            if(!enableGloballyOn || cachedAnswerIsEMC) {
-                return answer;
-            }
+        if (isValidWeakMetaClass(answer, mccHandle)) {
+            return answer;
         }
 
         answer = mccHandle.create(get(), metaClassRegistry);
@@ -184,6 +183,21 @@ public class ClassInfo extends ManagedConcurrentMap.Entry<Class,ClassInfo> {
         }
         return answer;
     }
+    
+    private boolean isValidWeakMetaClass(MetaClass metaClass) {
+        return isValidWeakMetaClass(metaClass, GroovySystem.getMetaClassRegistry().getMetaClassCreationHandler());
+    }
+
+    /**
+     * if EMC.enableGlobally() is OFF, return whatever the cached answer is.
+     * but if EMC.enableGlobally() is ON and the cached answer is not an EMC, come up with a fresh answer
+     */
+    private boolean isValidWeakMetaClass(MetaClass metaClass, MetaClassRegistry.MetaClassCreationHandle mccHandle) {
+        if(metaClass==null) return false;
+        boolean enableGloballyOn = (mccHandle instanceof ExpandoMetaClassCreationHandle);
+        boolean cachedAnswerIsEMC = (metaClass instanceof ExpandoMetaClass);
+        return (!enableGloballyOn || cachedAnswerIsEMC);
+    }
 
     public final MetaClass getMetaClass() {
         MetaClass answer = getMetaClassForClass();
