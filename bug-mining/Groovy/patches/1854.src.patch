diff --git a/src/main/org/codehaus/groovy/vmplugin/v7/IndyInterface.java b/src/main/org/codehaus/groovy/vmplugin/v7/IndyInterface.java
index 4ad790fd5c..b7bc5cb3ff 100644
--- a/src/main/org/codehaus/groovy/vmplugin/v7/IndyInterface.java
+++ b/src/main/org/codehaus/groovy/vmplugin/v7/IndyInterface.java
@@ -33,6 +33,7 @@ import java.lang.invoke.MethodHandles.Lookup;
 import java.lang.reflect.Array;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
+import java.math.BigDecimal;
 import java.math.BigInteger;
 
 import org.codehaus.groovy.GroovyBugError;
@@ -77,16 +78,12 @@ public class IndyInterface {
         private static final MethodType INVOKE_METHOD_SIGNATURE = MethodType.methodType(Object.class, Class.class, Object.class, String.class, Object[].class, boolean.class, boolean.class);
         private static final MethodType O2O = MethodType.methodType(Object.class, Object.class);
         private static final MethodHandle   
-            UNWRAP_METHOD,  TO_STRING,          TO_BYTE,        
-            TO_BIGINT,      SAME_MC,            IS_NULL,
+            UNWRAP_METHOD,  SAME_MC,            IS_NULL,
             IS_NOT_NULL,    UNWRAP_EXCEPTION,   SAME_CLASS,
             META_METHOD_INVOKER,    GROOVY_OBJECT_INVOKER;
         static {
             try {
                 UNWRAP_METHOD = LOOKUP.findStatic(IndyInterface.class, "unwrap", O2O);
-                TO_STRING = LOOKUP.findStatic(IndyInterface.class, "coerceToString", MethodType.methodType(String.class, Object.class));
-                TO_BYTE = LOOKUP.findStatic(IndyInterface.class, "coerceToByte", O2O);
-                TO_BIGINT = LOOKUP.findStatic(IndyInterface.class, "coerceToBigInt", O2O);
                 SAME_MC = LOOKUP.findStatic(IndyInterface.class, "isSameMetaClass", MethodType.methodType(boolean.class, MetaClass.class, Object.class));
                 IS_NULL = LOOKUP.findStatic(IndyInterface.class, "isNull", MethodType.methodType(boolean.class, Object.class));
                 IS_NOT_NULL = LOOKUP.findStatic(IndyInterface.class, "isNotNull", MethodType.methodType(boolean.class, Object.class));
@@ -377,33 +374,6 @@ public class IndyInterface {
             return w.unwrap();
         }
         
-        /**
-         * Converts an Object to String.
-         * This method is called by the handle to convert for example 
-         * a GString to String.
-         */
-        public static String coerceToString(Object o) {
-            return o.toString();
-        }
-        
-        /**
-         * Converts a Number to Byte.
-         * This method is called by the handle to convert
-         * Numbers to Byte.
-         */
-        public static Object coerceToByte(Object o) {
-            return new Byte(((Number) o).byteValue());
-        }
-        
-        /**
-         * Converts an Object to BigInteger.
-         * This method is called by the handle to convert
-         * Numbers to BigInteger using {@link String#valueOf(Object)} 
-         */
-        public static Object coerceToBigInt(Object o) {
-            return new BigInteger(String.valueOf((Number) o));
-        }
-        
         /**
          * Guard to check if the argument is null.
          * This method is called by the handle to check
@@ -459,22 +429,49 @@ public class IndyInterface {
             if (ci.useMetaClass) return;
             Class[] parameters = ci.handle.type().parameterArray();
             if (ci.args.length != parameters.length) {
-                throw new GroovyBugError("at this point argument array length and parameter array length should be the same");
+                throw new GroovyBugError("At this point argument array length and parameter array length should be the same");
             }
             for (int i=1; i<ci.args.length; i++) {
+            	if (parameters[i]==Object.class) continue; 
                 Object arg = ci.args[i];
+                // we have to handle here different cases in which we do no
+                // transformations. We depend on our method selection to have
+                // selected only a compatible method, that means for a null
+                // argument we don't have to do anything. Same of course is if
+                // the argument is an instance of the parameter type. We also
+                // exclude boxing, since the MethodHandles will do that part
+                // already for us. Another case is the conversion of a primitive
+                // to another primitive or of the wrappers, or a combination of 
+                // these. This is also handled already. What is left is the 
+                // GString conversion and the number conversions.
                 if (arg==null) continue;
-                Class got = arg.getClass(); 
-                if (arg instanceof GString && parameters[i] == String.class) {
-                    ci.handle = MethodHandles.filterArguments(ci.handle, i, TO_STRING);                    
-                } else if (parameters[i] == Byte.class && got != Byte.class) {
-                    ci.handle = MethodHandles.filterArguments(ci.handle, i, TO_BYTE);
-                } else if (parameters[i] == BigInteger.class && got != BigInteger.class) {
-                    ci.handle = MethodHandles.filterArguments(ci.handle, i, TO_BIGINT);
-                }
+                Class got = arg.getClass();
+                if (got==parameters[i]) continue;
+                Class wrappedPara = getWrapperClass(parameters[i]);
+                if (wrappedPara==got) continue;
+                if (parameters[i].isAssignableFrom(got)) continue;
+                if (isPrimitiveOrWrapper(parameters[i]) && isPrimitiveOrWrapper(got)) continue;
+                ci.handle = TypeTransformers.addTransformer(ci.handle, i, arg, wrappedPara);
             }
         }
-        
+
+        /**
+         * Return true if the given argument is either a primitive or
+         * one of its wrapper. 
+         */
+        private static boolean isPrimitiveOrWrapper(Class c) {
+            return  c == byte.class    || c == Byte.class      ||
+                    c == int.class     || c == Integer.class   ||
+                    c == long.class    || c == Long.class      ||
+                    c == float.class   || c == Float.class     ||
+                    c == double.class  || c == Double.class    ||
+                    c == short.class   || c == Short.class     ||
+                    c == boolean.class || c == Boolean.class   ||
+                    c == char.class    || c == Character.class;
+        }
+
+
+
         /**
          * Gives a replacement receiver for null.
          * In case of the receiver being null we want to do the method
@@ -535,7 +532,7 @@ public class IndyInterface {
          * will be returned. If it is no primtive number type, we return the 
          * class itself.
          */
-        private static Class getWrapperClass(Class c) {
+        protected static Class getWrapperClass(Class c) {
             if (c == Integer.TYPE) {
                 c = Integer.class;
             } else if (c == Byte.TYPE) {
diff --git a/src/main/org/codehaus/groovy/vmplugin/v7/TypeTransformers.java b/src/main/org/codehaus/groovy/vmplugin/v7/TypeTransformers.java
new file mode 100644
index 0000000000..d769569ed7
--- /dev/null
+++ b/src/main/org/codehaus/groovy/vmplugin/v7/TypeTransformers.java
@@ -0,0 +1,94 @@
+/*
+ * Copyright 2003-2012 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.codehaus.groovy.vmplugin.v7;
+
+import groovy.lang.GString;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodType;
+import java.math.BigDecimal;
+import java.math.BigInteger;
+
+import org.codehaus.groovy.GroovyBugError;
+
+/**
+ * This class contains several transformers for used during method invocation.
+ * @author <a href="mailto:blackdrag@gmx.org">Jochen "blackdrag" Theodorou</a>
+ */
+public class TypeTransformers {
+	private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();
+    private static final MethodHandle 
+        TO_STRING, TO_BYTE,   TO_INT,     TO_LONG,    TO_SHORT,
+        TO_FLOAT,  TO_DOUBLE, TO_BIG_INT, TO_BIG_DEC;
+    static {
+        try {
+            TO_STRING   = LOOKUP.findVirtual(Object.class, "toString",      MethodType.methodType(String.class));
+            TO_BYTE	    = LOOKUP.findVirtual(Number.class, "byteValue",     MethodType.methodType(Byte.TYPE));
+            TO_SHORT    = LOOKUP.findVirtual(Number.class, "shortValue",    MethodType.methodType(Short.TYPE));
+            TO_INT      = LOOKUP.findVirtual(Number.class, "intValue",      MethodType.methodType(Integer.TYPE));
+            TO_LONG     = LOOKUP.findVirtual(Number.class, "longValue",     MethodType.methodType(Long.TYPE));
+            TO_FLOAT    = LOOKUP.findVirtual(Number.class, "floatValue",    MethodType.methodType(Float.TYPE));
+            TO_DOUBLE   = LOOKUP.findVirtual(Number.class, "doubleValue",   MethodType.methodType(Double.TYPE));
+
+            // BigDecimal conversion is done by using the double value
+            // if the given number.
+            MethodHandle tmp = LOOKUP.findConstructor(BigDecimal.class, MethodType.methodType(Void.TYPE, Double.TYPE));
+            TO_BIG_DEC  = MethodHandles.filterReturnValue(TO_DOUBLE, tmp);
+
+            // BigInteger conversion is done by using the string representation
+            // if the given number
+            tmp = LOOKUP.findConstructor(BigInteger.class, MethodType.methodType(Void.TYPE, String.class));
+            TO_BIG_INT  = MethodHandles.filterReturnValue(TO_STRING, tmp);
+        } catch (Exception e) {
+            throw new GroovyBugError(e);
+        }
+    }
+
+    protected static MethodHandle addTransformer(MethodHandle handle, int pos, Object arg, Class parameter) {
+        MethodHandle transformer=null;
+    	if (arg instanceof GString) {
+    		transformer = TO_STRING;
+        } else if (Number.class.isAssignableFrom(parameter)) {
+            transformer = selectNumberTransformer(parameter, arg);
+        } 
+        if (transformer==null) throw new GroovyBugError("Unknown transformation for argument "+arg+" at position "+pos+" with "+arg.getClass()+" for parameter of type "+parameter);
+    	return MethodHandles.filterArguments(handle, pos, transformer);
+    }
+
+    private static MethodHandle selectNumberTransformer(Class param, Object arg) {
+        param = IndyInterface.getWrapperClass(param);
+        if (param == Byte.class) {
+            return TO_BYTE;
+        } else if (param == Character.class || param == Integer.class) {
+            return TO_INT;
+        } else  if (param == Long.class) {
+            return TO_LONG;
+        } else if (param == Float.class) {
+            return TO_FLOAT;
+        } else if (param == Double.class) {
+            return TO_DOUBLE;
+        } else if (param == BigInteger.class) {
+            return TO_BIG_INT;
+        } else if (param == BigDecimal.class) {
+            return TO_BIG_DEC;
+        } else if (param == Short.class) {
+            return TO_SHORT;
+        } else {
+             return null;
+        }
+    }
+}
diff --git a/subprojects/groovy-test/src/main/groovy/groovy/util/JavadocAssertionTestSuite.groovy b/subprojects/groovy-test/src/main/groovy/groovy/util/JavadocAssertionTestSuite.groovy
index 11fa6a750f..0462655339 100644
--- a/subprojects/groovy-test/src/main/groovy/groovy/util/JavadocAssertionTestSuite.groovy
+++ b/subprojects/groovy-test/src/main/groovy/groovy/util/JavadocAssertionTestSuite.groovy
@@ -68,7 +68,7 @@ class JavadocAssertionTestSuite extends TestSuite {
     public static final String SYSPROP_SRC_EXCLUDES_PATTERN = "javadocAssertion.src.excludesPattern";
     
     private static JavadocAssertionTestBuilder testBuilder = new JavadocAssertionTestBuilder()
-    private static IFileNameFinder finder = Class.forName('groovy.util.FileNameFinder').newInstance()
+    private static IFileNameFinder finder = Class.forName('groovy.util.FileNameFinder',true,this.classLoader).newInstance()
     
     static Test suite() {
         String basedir = System.getProperty(SYSPROP_SRC_DIR, "./src/")
