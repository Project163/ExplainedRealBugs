diff --git a/src/main/org/codehaus/groovy/tools/javac/JavaStubGenerator.java b/src/main/org/codehaus/groovy/tools/javac/JavaStubGenerator.java
index 0ada724bbd..7d150c93fd 100644
--- a/src/main/org/codehaus/groovy/tools/javac/JavaStubGenerator.java
+++ b/src/main/org/codehaus/groovy/tools/javac/JavaStubGenerator.java
@@ -421,18 +421,19 @@ public class JavaStubGenerator {
         ClassNode type = node.getDeclaringClass();
         ClassNode superType = type.getUnresolvedSuperClass();
 
+        Parameter[] bestMatch = null;
         for (ConstructorNode c : superType.getDeclaredConstructors()) {
             // Only look at things we can actually call
-            if (c.isPublic() || c.isProtected()) {
-                Parameter[] parameters = c.getParameters();
-                // workaround for GROOVY-5859: remove generic type info
-                Parameter[] copy = new Parameter[parameters.length];
-                for (int i = 0; i < copy.length; i++) {
-                    Parameter orig = parameters[i];
-                    copy[i] = new Parameter(orig.getOriginType().getPlainNodeReference(), orig.getName());
-                }
-                return copy;
+            if (!c.isPublic() && !c.isProtected()) continue;
+            Parameter[] parameters = c.getParameters();
+            // workaround for GROOVY-5859: remove generic type info
+            Parameter[] copy = new Parameter[parameters.length];
+            for (int i = 0; i < copy.length; i++) {
+                Parameter orig = parameters[i];
+                copy[i] = new Parameter(orig.getOriginType().getPlainNodeReference(), orig.getName());
             }
+            if (noExceptionToAvoid(node,c)) return copy;
+            if (bestMatch==null) bestMatch = copy;
         }
 
         // fall back for parameterless constructor
@@ -443,6 +444,42 @@ public class JavaStubGenerator {
         return null;
     }
 
+    final private static ClassNode RUNTIME_EXCEPTION = ClassHelper.make(RuntimeException.class);
+
+    private boolean noExceptionToAvoid(ConstructorNode fromStub, ConstructorNode fromSuper) {
+        ClassNode[] superExceptions = fromSuper.getExceptions();
+        if (superExceptions==null || superExceptions.length==0) return true;
+        superExceptions = superExceptions.clone();
+
+        // let's filter out all runtime exceptions
+        int offset = 0;
+        for (int i=0; i<superExceptions.length; i++) {
+            ClassNode exc = superExceptions[i];
+            if (exc.isDerivedFrom(RUNTIME_EXCEPTION)) {
+                superExceptions[i]=superExceptions[offset];
+                superExceptions[offset] = null;
+                offset++;
+            }
+        }
+
+        // if nothing left, we are good
+        if (offset>=superExceptions.length) return true;
+
+        // if all remaining exceptions are used in the stub weare good
+        ClassNode[] stubExceptions = fromStub.getExceptions();
+        if (stubExceptions==null || stubExceptions.length==0) return false;
+        outer: for (int i=offset; i<superExceptions.length; i++) {
+            ClassNode superExc = superExceptions[i];
+            for (ClassNode stub:stubExceptions) {
+                if (stub.isDerivedFrom(superExc)) continue outer;
+            }
+            // not found 
+            return false;
+        }
+
+        return true;
+    }
+
     private void printSpecialConstructorArgs(PrintWriter out, ConstructorNode node, ConstructorCallExpression constrCall) {
         // Select a constructor from our class, or super-class which is legal to call,
         // then write out an invoke w/nulls using casts to avoid ambiguous crapo
diff --git a/src/test/org/codehaus/groovy/tools/stubgenerator/ExceptionThrowingSuperConstructorTest.groovy b/src/test/org/codehaus/groovy/tools/stubgenerator/ExceptionThrowingSuperConstructorTest.groovy
new file mode 100644
index 0000000000..e748217bcd
--- /dev/null
+++ b/src/test/org/codehaus/groovy/tools/stubgenerator/ExceptionThrowingSuperConstructorTest.groovy
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2003-2010 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.codehaus.groovy.tools.stubgenerator
+
+/**
+ * Test stub generation for super constructors with exceptions
+ *
+ * @author Jochen Theodorou
+ */
+class ExceptionThrowingSuperConstructorTest extends StringSourcesStubTestCase {
+
+    Map<String, String> provideSources() {
+        [   'Dummy.java': '''
+                import java.io.*;
+                 class Dummy{
+                    public Dummy(String s) {}
+                    public Dummy(Integer s) {}
+                    public Dummy(InputStream i) throws IOException {}
+                 }
+                 ''',
+            'Derived6282.groovy': '''
+                class Derived6282 extends jline.SimpleCompletor {
+                  Derived6282(foo) {
+                    super(foo)
+                  }
+                }
+            '''
+        ]
+    }
+
+    void verifyStubs() {
+        String source = stubJavaSourceFor('Derived6282')
+        // it should never select the exception throwing constructor
+        assert source.contains("super ((java.lang.String")
+    }
+}
\ No newline at end of file
