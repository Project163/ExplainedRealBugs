diff --git a/src/main/groovy/transform/AutoClone.java b/src/main/groovy/transform/AutoClone.java
index e3354c8fa6..fc868a79b5 100644
--- a/src/main/groovy/transform/AutoClone.java
+++ b/src/main/groovy/transform/AutoClone.java
@@ -139,6 +139,57 @@ import java.lang.annotation.Target;
  * This approach can be slightly slower than the traditional cloning approach
  * but the {@code Cloneable} fields of your class can be final.
  * <p/>
+ * As a variation of the last two styles, if you set {@code style=SIMPLE}
+ * then the no-arg constructor will be called followed by setting the
+ * individual properties (and/or fields) calling {@code clone()} if the
+ * property/field implements {@code Cloneable}. Here is an example:
+ * <pre>
+ * import groovy.transform.AutoClone
+ * import static groovy.transform.AutoCloneStyle.*
+ * {@code @AutoClone(style=SIMPLE)}
+ * class Person {
+ *   final String first, last
+ *   final Date birthday
+ * }
+ * {@code @AutoClone(style=SIMPLE)}
+ * class Customer {
+ *   final List favItems
+ * }
+ * </pre>
+ * Which will create classes as follows:
+ * <pre>
+ * class Person implements Cloneable {
+ *   ...
+ *   public Object clone() throws CloneNotSupportedException {
+ *     def result = new Person()
+ *     copyOrCloneMembers(result)
+ *     return result
+ *   }
+ *   protected void copyOrCloneMembers(other) {
+ *     other.first = first
+ *     other.last = last
+ *     other.birthday = birthday.clone()
+ *   }
+ *   ...
+ * }
+ * class Customer extends Person {
+ *   ...
+ *   public Object clone() throws CloneNotSupportedException {
+ *     def result = new Customer()
+ *     copyOrCloneMembers(result)
+ *     return result
+ *   }
+ *   protected void copyOrCloneMembers(other) {
+ *     super.copyOrCloneMembers(other)
+ *     other.favItems = favItems.clone()
+ *   }
+ *   ...
+ * }
+ * </pre>
+ * You would typically use this style only for base classes where you didn't
+ * want the normal {@code Object} {@code clone()} method to be called and
+ * you would typically need to use the {@code SIMPLE} style for any child classes.
+ * <p/>
  * As a final example, if your class already implements the {@code Serializable}
  * or {@code Externalizable} interface, you can choose the following cloning style:
  * <pre>
@@ -190,14 +241,14 @@ public @interface AutoClone {
      * <p>Comma separated list of property (and/or field) names to exclude from cloning.
      * For convenience, a String with comma separated names can be used in addition
      * to an array (using Groovy's literal list notation) of String values.</p>
-     * <p>NOTE: When using the CLONE style, property (and/or field) copying might occur as part of
+     * <p>NOTE: When using the {@code CLONE} style, property (and/or field) copying might occur as part of
      * calling {@code super.clone()} which will ignore this list. You can then use this list to
-     * streamline the provided {@code clone()} implementation by selecting which properties
+     * streamline the provided {@code clone()} implementation by selecting which Cloneable properties
      * (and/or fields) will have a subsequent call to their {@code clone()} method. If you have
      * immutable properties (and/or fields) this can be useful as the extra {@code clone()} will
      * not be necessary and cloning will be more efficient.</p>
      * <p>NOTE: This doesn't affect property (and/or field) copying that might occur as part
-     * of serialization when using the SERIALIZATION style, i.e. this flag is ignored;
+     * of serialization when using the {@code SERIALIZATION} style, i.e. this flag is ignored;
      * instead adjust your serialization code to include or exclude the desired
      * properties (and/or fields) which should carry over during cloning.</p>
      */
@@ -205,13 +256,13 @@ public @interface AutoClone {
 
     /**
      * <p>Include fields as well as properties when cloning.</p>
-     * <p>NOTE: When using the CLONE style, field copying might occur as part of
+     * <p>NOTE: When using the {@code CLONE} style, field copying might occur as part of
      * calling {@code super.clone()} and might be all you require; if you turn on
      * this flag, the provided {@code clone()} implementation will also
-     * subsequently call {@code clone()} for each field which can be useful if
-     * you have mutable fields.</p>
+     * subsequently call {@code clone()} for each {@code Cloneable} field which can be
+     * useful if you have mutable fields.</p>
      * <p>NOTE: This doesn't affect field copying that might occur as part of
-     * serialization when using the SERIALIZATION style, i.e. this flag is ignored;
+     * serialization when using the {@code SERIALIZATION} style, i.e. this flag is ignored;
      * instead adjust your serialization code to include or exclude your fields.</p>
      */
     boolean includeFields() default false;
diff --git a/src/main/groovy/transform/AutoCloneStyle.java b/src/main/groovy/transform/AutoCloneStyle.java
index c35586dc10..88f036e265 100644
--- a/src/main/groovy/transform/AutoCloneStyle.java
+++ b/src/main/groovy/transform/AutoCloneStyle.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2010 the original author or authors.
+ * Copyright 2003-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -28,6 +28,11 @@ public enum AutoCloneStyle {
      */
     CLONE,
 
+    /**
+     * Uses the no-arg constructor followed by property/field copying/cloning.
+     */
+    SIMPLE,
+
     /**
      * Uses the copy constructor pattern.
      */
diff --git a/src/main/org/codehaus/groovy/transform/AutoCloneASTTransformation.java b/src/main/org/codehaus/groovy/transform/AutoCloneASTTransformation.java
index 9683be6c3a..d609805a6e 100644
--- a/src/main/org/codehaus/groovy/transform/AutoCloneASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/AutoCloneASTTransformation.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2012 the original author or authors.
+ * Copyright 2008-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -84,16 +84,19 @@ public class AutoCloneASTTransformation extends AbstractASTTransformation {
                     createCloneCopyConstructor(cNode, list, excludes);
                     break;
                 case SERIALIZATION:
-                    createCloneSerialization(cNode, list, excludes);
+                    createCloneSerialization(cNode);
                     break;
                 case CLONE:
                     createClone(cNode, list, excludes);
                     break;
+                case SIMPLE:
+                    createSimpleClone(cNode, list, excludes);
+                    break;
             }
         }
     }
 
-    private void createCloneSerialization(ClassNode cNode, List<FieldNode> list, List<String> excludes) {
+    private void createCloneSerialization(ClassNode cNode) {
         final BlockStatement body = new BlockStatement();
         // def baos = new ByteArrayOutputStream()
         final Expression baos = new VariableExpression("baos");
@@ -157,6 +160,46 @@ public class AutoCloneASTTransformation extends AbstractASTTransformation {
         cNode.addMethod("clone", ACC_PUBLIC, ClassHelper.OBJECT_TYPE, new Parameter[0], exceptions, cloneBody);
     }
 
+    private void createSimpleClone(ClassNode cNode, List<FieldNode> list, List<String> excludes) {
+        if (cNode.getDeclaredConstructors().size() == 0) {
+            // add no-arg constructor
+            BlockStatement initBody = new BlockStatement();
+            initBody.addStatement(new EmptyStatement());
+            cNode.addConstructor(ACC_PUBLIC, new Parameter[0], ClassNode.EMPTY_ARRAY, initBody);
+        }
+        final BlockStatement cloneBody = new BlockStatement();
+        final Expression result = new VariableExpression("_result");
+        final Expression noarg = new ConstructorCallExpression(cNode, ArgumentListExpression.EMPTY_ARGUMENTS);
+        cloneBody.addStatement(new ExpressionStatement(new DeclarationExpression(result, ASSIGN, noarg)));
+        addSimpleCloneHelperMethod(cNode, list, excludes);
+        cloneBody.addStatement(new ExpressionStatement(new MethodCallExpression(VariableExpression.THIS_EXPRESSION, "cloneOrCopyMembers", new ArgumentListExpression(result))));
+        cloneBody.addStatement(new ReturnStatement(result));
+        ClassNode[] exceptions = {ClassHelper.make(CloneNotSupportedException.class)};
+        cNode.addMethod("clone", ACC_PUBLIC, ClassHelper.OBJECT_TYPE, new Parameter[0], exceptions, cloneBody);
+    }
+
+    private void addSimpleCloneHelperMethod(ClassNode cNode, List<FieldNode> list, List<String> excludes) {
+        Parameter methodParam = new Parameter(cNode, "other");
+        final Expression other = new VariableExpression(methodParam);
+        boolean hasParent = cNode.getSuperClass() != ClassHelper.OBJECT_TYPE;
+        BlockStatement methodBody = new BlockStatement();
+        if (hasParent) {
+            methodBody.addStatement(new ExpressionStatement(new MethodCallExpression(VariableExpression.SUPER_EXPRESSION, "cloneOrCopyMembers", new ArgumentListExpression(other))));
+        }
+        for (FieldNode fieldNode : list) {
+            String name = fieldNode.getName();
+            if (excludes.contains(name)) continue;
+            PropertyExpression direct = new PropertyExpression(VariableExpression.THIS_EXPRESSION, name);
+            Expression cloned = new MethodCallExpression(direct, "clone", MethodCallExpression.NO_ARGUMENTS);
+            Expression to = new PropertyExpression(other, name);
+            Statement assignCloned = assignStatement(to, cloned);
+            Statement assignDirect = assignStatement(to, direct);
+            methodBody.addStatement(new IfStatement(isInstanceOf(direct, CLONEABLE_TYPE), assignCloned, assignDirect));
+        }
+        ClassNode[] exceptions = {ClassHelper.make(CloneNotSupportedException.class)};
+        cNode.addMethod("cloneOrCopyMembers", ACC_PROTECTED, ClassHelper.VOID_TYPE, new Parameter[]{methodParam}, exceptions, methodBody);
+    }
+
     private void createClone(ClassNode cNode, List<FieldNode> list, List<String> excludes) {
         final BlockStatement body = new BlockStatement();
         final Expression result = new VariableExpression("_result");
diff --git a/src/test/org/codehaus/groovy/transform/CanonicalComponentsTransformTest.groovy b/src/test/org/codehaus/groovy/transform/CanonicalComponentsTransformTest.groovy
index 5ab77b5a7a..ec4a423186 100644
--- a/src/test/org/codehaus/groovy/transform/CanonicalComponentsTransformTest.groovy
+++ b/src/test/org/codehaus/groovy/transform/CanonicalComponentsTransformTest.groovy
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2011 the original author or authors.
+ * Copyright 2008-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -19,8 +19,7 @@ import groovy.transform.AutoClone
 import groovy.transform.AutoExternalize
 import groovy.transform.EqualsAndHashCode
 import groovy.transform.TupleConstructor
-import static groovy.transform.AutoCloneStyle.COPY_CONSTRUCTOR
-import static groovy.transform.AutoCloneStyle.SERIALIZATION
+import static groovy.transform.AutoCloneStyle.*
 import groovy.transform.ToString
 //import groovy.transform.InheritConstructors
 import groovy.transform.Canonical
@@ -197,6 +196,24 @@ class CanonicalComponentsTransformTest extends GroovyShellTestCase {
         assert p3.hasEqualXY(t1) && t1.hasEqualXY(p3)
     }
 
+    // GROOVY-5901
+    void testSimpleCloning() {
+      def p1 = new Person6(first:'John', last:'Smith', since:new Date())
+      def p2 = p1.clone()
+      def c1 = new Customer6(first:'John', last:'Smith', favItems:['ipod', 'shiraz'], since:new Date())
+      def c2 = c1.clone()
+
+      assert [p1, p1.since, c1, c1.favItems, c1.since].every{ it instanceof Cloneable }
+      assert !(p1.first instanceof Cloneable)
+      assert !p1.is(p2)
+      assert !c1.is(c2)
+      assert !c1.favItems.is(c2.favItems)
+      assert !p1.since.is(p2.since)
+      assert !c1.since.is(c2.since)
+      assert p1.first.is(p2.first)
+      assert c1.first.is(c2.first)
+    }
+
     // GROOVY-4849
     void testCanEqualDefined() {
         def p1 = new IntPair(1, 2)
@@ -256,6 +273,16 @@ class Customer5 {
     int agePeek() { age }
 }
 
+@TupleConstructor
+@AutoClone(style=SIMPLE)
+@EqualsAndHashCode
+class Person6 { String first, last; Date since }
+
+@TupleConstructor(includeSuperProperties=true, callSuper=true)
+@AutoClone(style=SIMPLE)
+@EqualsAndHashCode
+class Customer6 extends Person6 { List favItems }
+
 // GROOVY-4786
 @EqualsAndHashCode(excludes="y")
 @ToString(includes="x")
