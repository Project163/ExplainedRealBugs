diff --git a/src/main/org/codehaus/groovy/ast/ClassNode.java b/src/main/org/codehaus/groovy/ast/ClassNode.java
index dccbe17813..a7064429e2 100644
--- a/src/main/org/codehaus/groovy/ast/ClassNode.java
+++ b/src/main/org/codehaus/groovy/ast/ClassNode.java
@@ -491,6 +491,16 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
         return node;
     }
 
+    public boolean hasProperty(String name) {
+    	for (Iterator iter = getProperties().iterator(); iter.hasNext();) {
+            PropertyNode pn = (PropertyNode) iter.next();
+            if (pn.getName().equals(name)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
     public void addConstructor(ConstructorNode node) {
         node.setDeclaringClass(this);
         redirect().constructors.add(node);
@@ -509,10 +519,10 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
     }
 
     /**
-     * IF a method with the given name and parameters is already defined then it is returned
+     * If a method with the given name and parameters is already defined then it is returned
      * otherwise the given method is added to this node. This method is useful for
      * default method adding like getProperty() or invokeMethod() where there may already
-     * be a method defined in a class and  so the default implementations should not be added
+     * be a method defined in a class and so the default implementations should not be added
      * if already present.
      */
     public MethodNode addMethod(String name,
@@ -522,7 +532,7 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
                                 ClassNode[] exceptions,
                                 Statement code) {
         MethodNode other = getDeclaredMethod(name, parameters);
-        // lets not add duplicate methods
+        // let's not add duplicate methods
         if (other != null) {
             return other;
         }
@@ -531,6 +541,11 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
         return node;
     }
 
+    public boolean hasMethod(String name, Parameter[] parameters) {
+        MethodNode other = getDeclaredMethod(name, parameters);
+        return other != null;
+    }
+
     /**
      * Adds a synthetic method as part of the compilation process
      */
@@ -715,17 +730,17 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
      *         i.e. it implements GroovyObject
      */
     public boolean isDerivedFromGroovyObject() {
-        return implementsInterface(GroovyObject.class.getName());
+        return implementsInterface(ClassHelper.make(GroovyObject.class));
     }
 
     /**
-     * @param name the fully qualified name of the interface
+     * @param classNode the class node for the interface
      * @return true if this class or any base class implements the given interface
      */
-    public boolean implementsInterface(String name) {
+    public boolean implementsInterface(ClassNode classNode) {
         ClassNode node = redirect();
         do {
-            if (node.declaresInterface(name)) {
+            if (node.declaresInterface(classNode)) {
                 return true;
             }
             node = node.getSuperClass();
@@ -735,14 +750,30 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
     }
 
     /**
-     * @param name the fully qualified name of the interface
+     * @param classNode the class node for the interface
      * @return true if this class declares that it implements the given interface
+     * or if one of its interfaces extends directly or indirectly the interface
      */
-    public boolean declaresInterface(String name) {
+    public boolean declaresInterface(ClassNode classNode) {
         ClassNode[] interfaces = redirect().getInterfaces();
+        if (declaresInterfaceDirect(interfaces, classNode)) return true;
+        List superInterfaces = Arrays.asList(interfaces);
+        while (superInterfaces.size() > 0) {
+            List keep = new ArrayList();
+            for (int i = 0; i < superInterfaces.size(); i++) {
+                ClassNode cn = (ClassNode) superInterfaces.get(i);
+                if (cn.declaresInterface(classNode)) return true;
+                keep.addAll(Arrays.asList(cn.getInterfaces()));
+            }
+            superInterfaces = keep;
+        }
+        return false;
+    }
+
+    private boolean declaresInterfaceDirect(ClassNode[] interfaces, ClassNode classNode) {
         int size = interfaces.length;
         for (int i = 0; i < size; i++) {
-            if (interfaces[i].getName().equals(name)) {
+            if (interfaces[i].equals(classNode)) {
                 return true;
             }
         }
diff --git a/src/main/org/codehaus/groovy/classgen/AnnotationVisitor.java b/src/main/org/codehaus/groovy/classgen/AnnotationVisitor.java
index 501c701178..7876abcee1 100644
--- a/src/main/org/codehaus/groovy/classgen/AnnotationVisitor.java
+++ b/src/main/org/codehaus/groovy/classgen/AnnotationVisitor.java
@@ -88,7 +88,7 @@ public class AnnotationVisitor {
     }
 
     private boolean isValidAnnotationClass(ClassNode node) {
-        return node.implementsInterface("java.lang.annotation.Annotation");
+        return node.implementsInterface(ClassHelper.Annotation_TYPE);
     }
 
     protected void visitExpression(String attrName, Expression attrExp, ClassNode attrType) {
diff --git a/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java b/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
index b65712bc51..f0efa1eb45 100644
--- a/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
+++ b/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
@@ -244,7 +244,7 @@ public class AsmClassGenerator extends ClassGenerator {
                 createInterfaceSyntheticStaticFields();
             } else {
                 super.visitClass(classNode);
-                if (!classNode.declaresInterface(ClassHelper.GENERATED_CLOSURE_Type.getName())) {
+                if (!classNode.declaresInterface(ClassHelper.GENERATED_CLOSURE_Type)) {
                     createMopMethods();
                 }
                 createSyntheticStaticFields();
@@ -700,7 +700,7 @@ public class AsmClassGenerator extends ClassGenerator {
            String desc = BytecodeHelper.getTypeDescription(cExp.getType());
            String name = pExp.getPropertyAsString();
            av.visitEnum(null, desc, name);
-       } else if (type.implementsInterface("java.lang.annotation.Annotation")) {
+       } else if (type.implementsInterface(ClassHelper.Annotation_TYPE)) {
            AnnotationConstantExpression avExp = (AnnotationConstantExpression) exp;
            AnnotationNode value = (AnnotationNode) avExp.getValue();
            AnnotationVisitor avc = av.visitAnnotation(null, BytecodeHelper.getTypeDescription(avExp.getType()));
@@ -1390,7 +1390,7 @@ public class AsmClassGenerator extends ClassGenerator {
             type = ClassHelper.getWrapper(type);
         }
 
-        if (forceCast || (type != null && !expType.isDerivedFrom(type) && !expType.implementsInterface(type.getName()))) {
+        if (forceCast || (type != null && !expType.isDerivedFrom(type) && !expType.implementsInterface(type))) {
             doConvertAndCast(type, coerce);
         }
     }
@@ -1689,7 +1689,7 @@ public class AsmClassGenerator extends ClassGenerator {
 
         mv.visitTypeInsn(NEW, innerClassinternalName);
         mv.visitInsn(DUP);
-        if (isStaticMethod() && !classNode.declaresInterface(ClassHelper.GENERATED_CLOSURE_Type.getName())) {
+        if (isStaticMethod() && !classNode.declaresInterface(ClassHelper.GENERATED_CLOSURE_Type)) {
             visitClassExpression(new ClassExpression(classNode));
             visitClassExpression(new ClassExpression(getOutermostClass()));
         } else {
@@ -2473,7 +2473,7 @@ public class AsmClassGenerator extends ClassGenerator {
     }
 
     private void visitSpecialConstructorCall(ConstructorCallExpression call) {
-        if (classNode.declaresInterface(ClassHelper.GENERATED_CLOSURE_Type.getName())) {
+        if (classNode.declaresInterface(ClassHelper.GENERATED_CLOSURE_Type)) {
             addGeneratedClosureConstructorCall(call);
             return;
         }
@@ -3863,7 +3863,7 @@ public class AsmClassGenerator extends ClassGenerator {
 
     protected void doConvertAndCast(ClassNode type, boolean coerce) {
         if (type == ClassHelper.OBJECT_TYPE) return;
-        if (rightHandType == null || !rightHandType.isDerivedFrom(type) || !rightHandType.implementsInterface(type.getName())) {
+        if (rightHandType == null || !rightHandType.isDerivedFrom(type) || !rightHandType.implementsInterface(type)) {
             if (isValidTypeForCast(type)) {
                 visitClassExpression(new ClassExpression(type));
                 if (coerce) {
diff --git a/src/main/org/codehaus/groovy/classgen/Verifier.java b/src/main/org/codehaus/groovy/classgen/Verifier.java
index bc3e7b26b6..ae4a8e3a18 100644
--- a/src/main/org/codehaus/groovy/classgen/Verifier.java
+++ b/src/main/org/codehaus/groovy/classgen/Verifier.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2007 the original author or authors.
+ * Copyright 2003-2008 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -18,6 +18,7 @@ package org.codehaus.groovy.classgen;
 import groovy.lang.GroovyClassLoader;
 import groovy.lang.GroovyObject;
 import groovy.lang.MetaClass;
+import groovy.lang.GroovyObjectSupport;
 import org.codehaus.groovy.ast.*;
 import org.codehaus.groovy.ast.expr.*;
 import org.codehaus.groovy.ast.stmt.BlockStatement;
@@ -47,7 +48,19 @@ public class Verifier implements GroovyClassVisitor, Opcodes {
 
     public static final String __TIMESTAMP = "__timeStamp";
     public static final String __TIMESTAMP__ = "__timeStamp__239_neverHappen";
-	private ClassNode classNode;
+    private static final Parameter[] INVOKE_METHOD_PARAMS = new Parameter[]{
+            new Parameter(ClassHelper.STRING_TYPE, "method"),
+            new Parameter(ClassHelper.OBJECT_TYPE, "arguments")
+    };
+    private static final Parameter[] SET_PROPERTY_PARAMS = new Parameter[]{
+            new Parameter(ClassHelper.STRING_TYPE, "property"),
+            new Parameter(ClassHelper.OBJECT_TYPE, "value")
+    };
+    private static final Parameter[] GET_PROPERTY_PARAMS = new Parameter[]{
+            new Parameter(ClassHelper.STRING_TYPE, "property")
+    };
+
+    private ClassNode classNode;
     private MethodNode methodNode;
 
     public ClassNode getClassNode() {
@@ -144,72 +157,78 @@ public class Verifier implements GroovyClassVisitor, Opcodes {
             new BytecodeSequence(getStaticMetaClassCode)
         );
 
-        if (!node.isDerivedFromGroovyObject()) {
-            node.addInterface(ClassHelper.make(GroovyObject.class));
+        boolean knownSpecialCase =
+                node.isDerivedFrom(ClassHelper.GSTRING_TYPE)
+                        || node.isDerivedFrom(ClassHelper.make(GroovyObjectSupport.class))
+                        || node.implementsInterface(ClassHelper.METACLASS_TYPE);
 
-            PropertyNode metaClassProperty =
-                node.addProperty("metaClass", ACC_PUBLIC, ClassHelper.METACLASS_TYPE, new BytecodeExpression() {
+        if (!knownSpecialCase) {
+
+            boolean isGroovyObject = node.isDerivedFromGroovyObject();
+            if (!isGroovyObject) {
+                node.addInterface(ClassHelper.make(GroovyObject.class));
+            }
+
+            if (!node.hasProperty("metaClass")) {
+                PropertyNode metaClassProperty =
+                        node.addProperty("metaClass", ACC_PUBLIC, ClassHelper.METACLASS_TYPE, new BytecodeExpression() {
+                            public void visit(MethodVisitor mv) {
+                                mv.visitVarInsn(ALOAD, 0);
+                                mv.visitInsn(DUP);
+                                mv.visitMethodInsn(INVOKEVIRTUAL, classInternalName, "$getStaticMetaClass", "()Lgroovy/lang/MetaClass;");
+                                mv.visitFieldInsn(PUTFIELD, classInternalName, "metaClass", "Lgroovy/lang/MetaClass;");
+                                mv.visitVarInsn(ALOAD, 0);
+                                mv.visitFieldInsn(GETFIELD, classInternalName, "metaClass", "Lgroovy/lang/MetaClass;");
+                            }
+
+                            public ClassNode getType() {
+                                return ClassHelper.METACLASS_TYPE;
+                            }
+                        }, null, null);
+                metaClassProperty.setSynthetic(true);
+                FieldNode metaClassField = metaClassProperty.getField();
+                metaClassField.setModifiers(metaClassField.getModifiers() | ACC_TRANSIENT);
+            }
+
+            if (!node.hasMethod("getMetaClass", Parameter.EMPTY_ARRAY)) {
+                List getMetaClassCode = new LinkedList();
+                getMetaClassCode.add(new BytecodeInstruction() {
                     public void visit(MethodVisitor mv) {
+                        Label nullLabel = new Label();
+
+                        mv.visitVarInsn(ALOAD, 0);
+                        mv.visitFieldInsn(GETFIELD, classInternalName, "metaClass", "Lgroovy/lang/MetaClass;");
+                        mv.visitInsn(DUP);
+                        mv.visitJumpInsn(IFNULL, nullLabel);
+                        mv.visitInsn(ARETURN);
+
+                        mv.visitLabel(nullLabel);
+                        mv.visitInsn(POP);
                         mv.visitVarInsn(ALOAD, 0);
                         mv.visitInsn(DUP);
-                        mv.visitMethodInsn(INVOKEVIRTUAL,classInternalName,"$getStaticMetaClass","()Lgroovy/lang/MetaClass;");
-                        mv.visitFieldInsn(PUTFIELD, classInternalName,"metaClass","Lgroovy/lang/MetaClass;");
+                        mv.visitMethodInsn(INVOKEVIRTUAL, classInternalName, "$getStaticMetaClass", "()Lgroovy/lang/MetaClass;");
+                        mv.visitFieldInsn(PUTFIELD, classInternalName, "metaClass", "Lgroovy/lang/MetaClass;");
                         mv.visitVarInsn(ALOAD, 0);
-                        mv.visitFieldInsn(GETFIELD, classInternalName,"metaClass","Lgroovy/lang/MetaClass;");
+                        mv.visitFieldInsn(GETFIELD, classInternalName, "metaClass", "Lgroovy/lang/MetaClass;");
+                        mv.visitInsn(ARETURN);
                     }
+                });
+                node.addSyntheticMethod(
+                        "getMetaClass",
+                        ACC_PUBLIC,
+                        ClassHelper.make(MetaClass.class),
+                        Parameter.EMPTY_ARRAY,
+                        ClassNode.EMPTY_ARRAY,
+                        new BytecodeSequence(getMetaClassCode)
+                );
+            }
 
-                    public ClassNode getType() {
-                        return ClassHelper.METACLASS_TYPE;
-                    }
-                }, null, null);
-            metaClassProperty.setSynthetic(true);
-            FieldNode metaClassField = metaClassProperty.getField();
-            metaClassField.setModifiers(metaClassField.getModifiers() | ACC_TRANSIENT);
-
-            List getMetaClassCode = new LinkedList();
-            getMetaClassCode.add( new BytecodeInstruction(){
-                public void visit(MethodVisitor mv) {
-                    Label nullLabel = new Label();
-
-                    mv.visitVarInsn(ALOAD, 0);
-                    mv.visitFieldInsn(GETFIELD, classInternalName,"metaClass","Lgroovy/lang/MetaClass;");
-                    mv.visitInsn(DUP);
-                    mv.visitJumpInsn(IFNULL, nullLabel);
-                    mv.visitInsn(ARETURN);
-
-                    mv.visitLabel(nullLabel);
-                    mv.visitInsn(POP);
-                    mv.visitVarInsn(ALOAD, 0);
-                    mv.visitInsn(DUP);
-                    mv.visitMethodInsn(INVOKEVIRTUAL,classInternalName,"$getStaticMetaClass","()Lgroovy/lang/MetaClass;");
-                    mv.visitFieldInsn(PUTFIELD, classInternalName,"metaClass","Lgroovy/lang/MetaClass;");
-                    mv.visitVarInsn(ALOAD, 0);
-                    mv.visitFieldInsn(GETFIELD, classInternalName,"metaClass","Lgroovy/lang/MetaClass;");
-                    mv.visitInsn(ARETURN);
-                }
-            });
-            node.addSyntheticMethod(
-                "getMetaClass",
-                ACC_PUBLIC,
-                ClassHelper.make(MetaClass.class),
-                Parameter.EMPTY_ARRAY,
-                ClassNode.EMPTY_ARRAY,
-                new BytecodeSequence(getMetaClassCode)
-            );
-
-            // @todo we should check if the base class implements the invokeMethod method
-
-            // let's add the invokeMethod implementation
-            ClassNode superClass = node.getSuperClass();
-            boolean addDelegateObject =
-                (node instanceof InnerClassNode && superClass.equals(ClassHelper.CLOSURE_TYPE))
-                    || superClass.equals(ClassHelper.GSTRING_TYPE);
-
-            // don't do anything as the base class implements the invokeMethod
-            if (!addDelegateObject) {
+//            if (!node.hasMethod("invokeMethod", INVOKE_METHOD_PARAMS)) {
+            if (!isGroovyObject) {
 
+                // let's add the invokeMethod implementation
                 List invokeMethodCode = new LinkedList();
-                invokeMethodCode.add( new BytecodeInstruction(){
+                invokeMethodCode.add(new BytecodeInstruction() {
                     public void visit(MethodVisitor mv) {
                         mv.visitVarInsn(ALOAD, 0);
                         mv.visitMethodInsn(INVOKEVIRTUAL, classInternalName, "getMetaClass", "()Lgroovy/lang/MetaClass;");
@@ -221,21 +240,19 @@ public class Verifier implements GroovyClassVisitor, Opcodes {
                     }
                 });
                 node.addSyntheticMethod(
-                    "invokeMethod",
-                    ACC_PUBLIC,
-                    ClassHelper.OBJECT_TYPE,
-                    new Parameter[] {
-                        new Parameter(ClassHelper.STRING_TYPE, "method"),
-                        new Parameter(ClassHelper.OBJECT_TYPE, "arguments")
-                    },
-                    ClassNode.EMPTY_ARRAY,
-                    new BytecodeSequence(invokeMethodCode)
+                        "invokeMethod",
+                        ACC_PUBLIC,
+                        ClassHelper.OBJECT_TYPE,
+                        INVOKE_METHOD_PARAMS,
+                        ClassNode.EMPTY_ARRAY,
+                        new BytecodeSequence(invokeMethodCode)
                 );
+            }
 
-
-                if (!node.isScript()) {
+            if (!node.isScript()) {
+                if (!node.hasMethod("getProperty", GET_PROPERTY_PARAMS)) {
                     List getPropertyCode = new LinkedList();
-                    getPropertyCode.add( new BytecodeInstruction(){
+                    getPropertyCode.add(new BytecodeInstruction() {
                         public void visit(MethodVisitor mv) {
                             mv.visitVarInsn(ALOAD, 0);
                             mv.visitMethodInsn(INVOKEVIRTUAL, classInternalName, "getMetaClass", "()Lgroovy/lang/MetaClass;");
@@ -246,16 +263,18 @@ public class Verifier implements GroovyClassVisitor, Opcodes {
                         }
                     });
                     node.addSyntheticMethod(
-                        "getProperty",
-                        ACC_PUBLIC|ACC_SYNTHETIC,
-                        ClassHelper.OBJECT_TYPE,
-                        new Parameter[] { new Parameter(ClassHelper.STRING_TYPE, "property")},
-                        ClassNode.EMPTY_ARRAY,
-                        new BytecodeSequence(getPropertyCode)
+                            "getProperty",
+                            ACC_PUBLIC | ACC_SYNTHETIC,
+                            ClassHelper.OBJECT_TYPE,
+                            GET_PROPERTY_PARAMS,
+                            ClassNode.EMPTY_ARRAY,
+                            new BytecodeSequence(getPropertyCode)
                     );
+                }
 
+                if (!node.hasMethod("setProperty", SET_PROPERTY_PARAMS)) {
                     List setPropertyCode = new LinkedList();
-                    setPropertyCode.add( new BytecodeInstruction(){
+                    setPropertyCode.add(new BytecodeInstruction() {
                         public void visit(MethodVisitor mv) {
                             mv.visitVarInsn(ALOAD, 0);
                             mv.visitMethodInsn(INVOKEVIRTUAL, classInternalName, "getMetaClass", "()Lgroovy/lang/MetaClass;");
@@ -267,15 +286,12 @@ public class Verifier implements GroovyClassVisitor, Opcodes {
                         }
                     });
                     node.addSyntheticMethod(
-                        "setProperty",
-                        ACC_PUBLIC,
-                        ClassHelper.VOID_TYPE,
-                        new Parameter[] {
-                            new Parameter(ClassHelper.STRING_TYPE, "property"),
-                            new Parameter(ClassHelper.OBJECT_TYPE, "value")
-                        },
-                        ClassNode.EMPTY_ARRAY,
-                        new BytecodeSequence(setPropertyCode)
+                            "setProperty",
+                            ACC_PUBLIC,
+                            ClassHelper.VOID_TYPE,
+                            SET_PROPERTY_PARAMS,
+                            ClassNode.EMPTY_ARRAY,
+                            new BytecodeSequence(setPropertyCode)
                     );
                 }
             }
@@ -852,7 +868,7 @@ public class Verifier implements GroovyClassVisitor, Opcodes {
 
     private boolean isAssignable(ClassNode node, ClassNode testNode) {
         if (testNode.isInterface()) {
-            if (node.implementsInterface(testNode.getName())) return true;
+            if (node.implementsInterface(testNode)) return true;
         } else {
             if (node.isDerivedFrom(testNode)) return true;
         }
diff --git a/src/main/org/codehaus/groovy/control/GenericsVisitor.java b/src/main/org/codehaus/groovy/control/GenericsVisitor.java
index 3777e12048..fba4796910 100644
--- a/src/main/org/codehaus/groovy/control/GenericsVisitor.java
+++ b/src/main/org/codehaus/groovy/control/GenericsVisitor.java
@@ -85,7 +85,7 @@ public class GenericsVisitor extends ClassCodeVisitorSupport {
             ClassNode nType = nTypes[i].getType();
             ClassNode cnType = cnTypes[i].getType();
             if (!nType.isDerivedFrom(cnType)) {
-                if (cnType.isInterface() && nType.declaresInterface(cnType.getName())) continue;
+                if (cnType.isInterface() && nType.declaresInterface(cnType)) continue;
                 addError("The type "+nTypes[i].getName()+
                          " is not a valid substitute for the bounded parameter <"+
                          getPrintName(cnTypes[i])+">",n);
diff --git a/src/test/gls/invocation/CovariantReturnTest.groovy b/src/test/gls/invocation/CovariantReturnTest.groovy
index 29fabdc358..0a6e15aef4 100644
--- a/src/test/gls/invocation/CovariantReturnTest.groovy
+++ b/src/test/gls/invocation/CovariantReturnTest.groovy
@@ -60,16 +60,20 @@ public class CovariantReturnTest extends CompilableTestSupport {
     assertScript """
       interface Base {
         List foo()
+        Base baz()
       }
       interface Child extends Base {
         ArrayList foo()
+        Child baz()
       }
       class GroovyChildImpl implements Child {
         ArrayList foo() {}
+        GroovyChildImpl baz() {}
       }
 
       def x = new GroovyChildImpl()
       x.foo()
+      x.baz()
     """
   }
 
@@ -77,6 +81,8 @@ public class CovariantReturnTest extends CompilableTestSupport {
     assertScript """
       interface Base {
         List foo()
+        List bar()
+        Base baz()
       }
       interface Child extends Base {
         ArrayList foo()
@@ -84,9 +90,13 @@ public class CovariantReturnTest extends CompilableTestSupport {
       class MyArrayList extends ArrayList { }
       class GroovyChildImpl implements Child {
         MyArrayList foo() {}
+        MyArrayList bar() {}
+        GroovyChildImpl baz() {}
       }
       def x = new GroovyChildImpl()
       x.foo()
+      x.bar()
+      x.baz()
     """
   }
 
