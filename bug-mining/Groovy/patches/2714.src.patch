diff --git a/src/main/groovy/transform/AutoClone.java b/src/main/groovy/transform/AutoClone.java
index e6fcde0664..99c2882a2d 100644
--- a/src/main/groovy/transform/AutoClone.java
+++ b/src/main/groovy/transform/AutoClone.java
@@ -135,7 +135,9 @@ import java.lang.annotation.Target;
  * If you use this style on a child class, the parent class must
  * also have a copy constructor (created using this annotation or by hand).
  * This approach can be slightly slower than the traditional cloning approach
- * but the {@code Cloneable} fields of your class can be final.
+ * but the {@code Cloneable} fields of your class can be final. When using the copy constructor style,
+ * you can provide your own custom constructor by hand if you wish. If you do so, it is up to you to
+ * correctly copy, clone or deep clone the properties of your class.
  * <p>
  * As a variation of the last two styles, if you set {@code style=SIMPLE}
  * then the no-arg constructor will be called followed by setting the
diff --git a/src/main/org/codehaus/groovy/transform/AutoCloneASTTransformation.java b/src/main/org/codehaus/groovy/transform/AutoCloneASTTransformation.java
index b30fc1f606..cc2e56b454 100644
--- a/src/main/org/codehaus/groovy/transform/AutoCloneASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/AutoCloneASTTransformation.java
@@ -22,6 +22,7 @@ import org.codehaus.groovy.ast.AnnotatedNode;
 import org.codehaus.groovy.ast.AnnotationNode;
 import org.codehaus.groovy.ast.ClassHelper;
 import org.codehaus.groovy.ast.ClassNode;
+import org.codehaus.groovy.ast.ConstructorNode;
 import org.codehaus.groovy.ast.FieldNode;
 import org.codehaus.groovy.ast.Parameter;
 import org.codehaus.groovy.ast.VariableScope;
@@ -133,40 +134,48 @@ public class AutoCloneASTTransformation extends AbstractASTTransformation {
     }
 
     private void createCloneCopyConstructor(ClassNode cNode, List<FieldNode> list, List<String> excludes) {
-        BlockStatement initBody = new BlockStatement();
         if (cNode.getDeclaredConstructors().size() == 0) {
             // add no-arg constructor
-            initBody.addStatement(EmptyStatement.INSTANCE);
-            cNode.addConstructor(ACC_PUBLIC, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, initBody);
-            initBody = new BlockStatement();
+            BlockStatement noArgBody = new BlockStatement();
+            noArgBody.addStatement(EmptyStatement.INSTANCE);
+            cNode.addConstructor(ACC_PUBLIC, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, noArgBody);
         }
-        Parameter initParam = param(GenericsUtils.nonGeneric(cNode), "other");
-        final Expression other = varX(initParam);
-        boolean hasParent = cNode.getSuperClass() != ClassHelper.OBJECT_TYPE;
-        if (hasParent) {
-            initBody.addStatement(stmt(ctorX(ClassNode.SUPER, other)));
+        boolean hasThisCons = false;
+        for (ConstructorNode consNode : cNode.getDeclaredConstructors()) {
+            Parameter[] parameters = consNode.getParameters();
+            if (parameters.length == 1 && parameters[0].getType().equals(cNode)) {
+                hasThisCons = true;
+            }
         }
-        for (FieldNode fieldNode : list) {
-            String name = fieldNode.getName();
-            if (excludes.contains(name)) continue;
-            ClassNode fieldType = fieldNode.getType();
-            Expression direct = propX(other, name);
-            Expression to = propX(varX("this"), name);
-            Statement assignDirect = assignS(to, direct);
-            Statement assignCloned = assignS(to, castX(fieldType, callX(direct, "clone")));
-            Statement assignClonedDynamic = assignS(to, castX(fieldType, callCloneDynamicX(direct)));
-            if (isOrImplements(fieldType, CLONEABLE_TYPE)) {
-                initBody.addStatement(assignCloned);
-            } else if (!possiblyCloneable(fieldType)) {
-                initBody.addStatement(assignDirect);
-            } else {
-                initBody.addStatement(ifElseS(isInstanceOfX(direct, CLONEABLE_TYPE), assignClonedDynamic, assignDirect));
+        if (!hasThisCons) {
+            BlockStatement initBody = new BlockStatement();
+            Parameter initParam = param(GenericsUtils.nonGeneric(cNode), "other");
+            final Expression other = varX(initParam);
+            boolean hasParent = cNode.getSuperClass() != ClassHelper.OBJECT_TYPE;
+            if (hasParent) {
+                initBody.addStatement(stmt(ctorX(ClassNode.SUPER, other)));
             }
+            for (FieldNode fieldNode : list) {
+                String name = fieldNode.getName();
+                if (excludes.contains(name)) continue;
+                ClassNode fieldType = fieldNode.getType();
+                Expression direct = propX(other, name);
+                Expression to = propX(varX("this"), name);
+                Statement assignDirect = assignS(to, direct);
+                Statement assignCloned = assignS(to, castX(fieldType, callX(direct, "clone")));
+                Statement assignClonedDynamic = assignS(to, castX(fieldType, callCloneDynamicX(direct)));
+                if (isOrImplements(fieldType, CLONEABLE_TYPE)) {
+                    initBody.addStatement(assignCloned);
+                } else if (!possiblyCloneable(fieldType)) {
+                    initBody.addStatement(assignDirect);
+                } else {
+                    initBody.addStatement(ifElseS(isInstanceOfX(direct, CLONEABLE_TYPE), assignClonedDynamic, assignDirect));
+                }
+            }
+            cNode.addConstructor(ACC_PROTECTED, params(initParam), ClassNode.EMPTY_ARRAY, initBody);
         }
         ClassNode[] exceptions = {make(CloneNotSupportedException.class)};
-        cNode.addConstructor(ACC_PROTECTED, params(initParam), ClassNode.EMPTY_ARRAY, initBody);
-        cNode.addMethod("clone", ACC_PUBLIC, GenericsUtils.nonGeneric(cNode), Parameter.EMPTY_ARRAY, exceptions, block(
-                stmt(ctorX(cNode, args(varX("this"))))));
+        cNode.addMethod("clone", ACC_PUBLIC, GenericsUtils.nonGeneric(cNode), Parameter.EMPTY_ARRAY, exceptions, block(stmt(ctorX(cNode, args(varX("this"))))));
     }
 
     private boolean possiblyCloneable(ClassNode type) {
diff --git a/src/test/org/codehaus/groovy/transform/CanonicalComponentsTransformTest.groovy b/src/test/org/codehaus/groovy/transform/CanonicalComponentsTransformTest.groovy
index 3a7e737eb6..bf09f65467 100644
--- a/src/test/org/codehaus/groovy/transform/CanonicalComponentsTransformTest.groovy
+++ b/src/test/org/codehaus/groovy/transform/CanonicalComponentsTransformTest.groovy
@@ -535,6 +535,17 @@ class CanonicalComponentsTransformTest extends GroovyShellTestCase {
     void testToStringForEnums() {
         assert Color.PURPLE.toString() == 'org.codehaus.groovy.transform.Color(r:255, g:0, b:255)'
     }
+
+    void testCustomCopyConstructor_GROOVY7016() {
+        new GroovyShell().evaluate """
+            import org.codehaus.groovy.transform.Shopper
+            def p1 = new Shopper('John', [['bread', 'milk'], ['bacon', 'eggs']])
+            def p2 = p1.clone()
+            p2.shoppingHistory[0][1] = 'jam'
+            assert p1.shoppingHistory[0] == ['bread', 'milk']
+            assert p2.shoppingHistory[0] == ['bread', 'jam']
+        """
+    }
 }
 
 @TupleConstructor
@@ -722,3 +733,14 @@ enum Color {
     int r, g, b
     Color(int r, g, b) { this.r = r; this.g = g; this.b = b }
 }
+
+@TupleConstructor(force=true) @AutoClone(style=COPY_CONSTRUCTOR)
+class Shopper {
+    final String name
+    final List<List<String>> shoppingHistory
+    Shopper(Shopper other) {
+        name = other.name
+        // requires deep clone
+        shoppingHistory = other.shoppingHistory*.clone()
+    }
+}
