diff --git a/src/main/groovy/lang/Lazy.java b/src/main/groovy/lang/Lazy.java
index d03fe699c0..c2505bd86c 100644
--- a/src/main/groovy/lang/Lazy.java
+++ b/src/main/groovy/lang/Lazy.java
@@ -26,7 +26,7 @@ import java.lang.annotation.Target;
 /**
  * Field annotation to simplify lazy initialization.
  * <p>
- * Example usage:
+ * Example usage without any special modifiers just defers initialization until the first call but is not thread-safe:
  * <pre>
  * {@code @Lazy} T x
  * </pre>
@@ -38,13 +38,14 @@ import java.lang.annotation.Target;
  *    if ($x != null)
  *       return $x
  *    else {
- *        $x = new T()
- *        return $x
+ *       $x = new T()
+ *       return $x
  *    }
  * }
  * </pre>
  *
- * If the field is declared volatile then initialization will be synchronized.
+ * If the field is declared volatile then initialization will be synchronized using
+ * the <a href="http://en.wikipedia.org/wiki/Double-checked_locking">double-checked locking</a> pattern as shown here:
  *
  * <pre>
  * {@code @Lazy} volatile T x
@@ -54,8 +55,9 @@ import java.lang.annotation.Target;
  * private volatile T $x
  *
  * T getX() {
- *    if ($x != null)
- *       return $x
+ *    T $x_local = $x
+ *    if ($x_local != null)
+ *       return $x_local
  *    else {
  *       synchronized(this) {
  *          if ($x == null) {
@@ -73,27 +75,72 @@ import java.lang.annotation.Target;
  * In particular, it is possible to use closure <code>{ ... } ()</code> syntax as follows:
  *
  * <pre>
- * {@code @Lazy} T x = { [1,2,3] } ()
+ * {@code @Lazy} T x = { [1, 2, 3] } ()
  * </pre>
  * becomes
  * <pre>
  * private T $x
  *
  * T getX() {
- *    if ($x != null)
- *       return $x
+ *    T $x_local = $x
+ *    if ($x_local != null)
+ *       return $x_local
  *    else {
  *       synchronized(this) {
  *          if ($x == null) {
- *             $x = { [1,2,3] } ()
+ *             $x = { [1, 2, 3] } ()
  *          }
  *          return $x
  *       }
  *    }
  * }
  * </pre>
- *
+ * <p>
  * <code>@Lazy(soft=true)</code> will use a soft reference instead of the field and use the above rules each time re-initialization is required.
+ * <p>
+ * If the <code>soft</code> flag for the annotation is not set but the field is static, then
+ * the <a href="http://en.wikipedia.org/wiki/Initialization_on_demand_holder_idiom">initialization on demand holder idiom</a> is
+ * used as follows:
+ * <pre>
+ * {@code @Lazy} static FieldType field
+ * {@code @Lazy} static Date date1
+ * {@code @Lazy} static Date date2 = { new Date().updated(year: 2000) }()
+ * {@code @Lazy} static Date date3 = new GregorianCalendar(2009, Calendar.JANUARY, 1).time
+ * </pre>
+ * becomes these methods and inners classes within the class containing the above definitions:
+ * <pre>
+ * private static class FieldTypeHolder_field {
+ *     private static final FieldType INSTANCE = new FieldType()
+ * }
+ *
+ * private static class DateHolder_date1 {
+ *     private static final Date INSTANCE = new Date()
+ * }
+ *
+ * private static class DateHolder_date2 {
+ *     private static final Date INSTANCE = { new Date().updated(year: 2000) }()
+ * }
+ *
+ * private static class DateHolder_date3 {
+ *     private static final Date INSTANCE = new GregorianCalendar(2009, Calendar.JANUARY, 1).time
+ * }
+ *
+ * static FieldType getField() {
+ *     return FieldTypeHolder_field.INSTANCE
+ * }
+ *
+ * static Date getDate1() {
+ *     return DateHolder_date1.INSTANCE
+ * }
+ *
+ * static Date getDate2() {
+ *     return DateHolder_date2.INSTANCE
+ * }
+ *
+ * static Date getDate3() {
+ *     return DateHolder_date3.INSTANCE
+ * }
+ * </pre>
  *
  * @author Alex Tkachman
  * @author Paul King
diff --git a/src/main/org/codehaus/groovy/transform/LazyASTTransformation.java b/src/main/org/codehaus/groovy/transform/LazyASTTransformation.java
index 4a79f21862..0951745737 100644
--- a/src/main/org/codehaus/groovy/transform/LazyASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/LazyASTTransformation.java
@@ -37,8 +37,11 @@ import java.util.Arrays;
 @GroovyASTTransformation(phase = CompilePhase.CANONICALIZATION)
 public class LazyASTTransformation implements ASTTransformation, Opcodes {
 
-    static final ClassNode SOFT_REF = ClassHelper.make(SoftReference.class);
-    static final Expression NULL_EXPR = ConstantExpression.NULL;
+    private static final ClassNode SOFT_REF = ClassHelper.make(SoftReference.class);
+    private static final Expression NULL_EXPR = ConstantExpression.NULL;
+    private static final ClassNode OBJECT_TYPE = new ClassNode(Object.class);
+    private static final Token ASSIGN = Token.newSymbol("=", -1, -1);
+    private static final Token COMPARE_NOT_EQUAL = Token.newSymbol("!=", -1, -1);
 
     public void visit(ASTNode[] nodes, SourceUnit source) {
         if (nodes.length != 2 || !(nodes[0] instanceof AnnotationNode) || !(nodes[1] instanceof AnnotatedNode)) {
@@ -49,7 +52,7 @@ public class LazyASTTransformation implements ASTTransformation, Opcodes {
         AnnotationNode node = (AnnotationNode) nodes[0];
 
         if (parent instanceof FieldNode) {
-            FieldNode fieldNode = (FieldNode) parent;
+            final FieldNode fieldNode = (FieldNode) parent;
             final Expression member = node.getMember("soft");
             final Expression init = getInitExpr(fieldNode);
 
@@ -60,36 +63,66 @@ public class LazyASTTransformation implements ASTTransformation, Opcodes {
                 createSoft(fieldNode, init);
             else {
                 create(fieldNode, init);
+                // @Lazy not meaningful with primitive so convert to wrapper if needed
+                if (ClassHelper.isPrimitiveType(fieldNode.getType())) {
+                    fieldNode.setType(ClassHelper.getWrapper(fieldNode.getType()));
+                }
             }
         }
     }
 
     private void create(FieldNode fieldNode, final Expression initExpr) {
-        BlockStatement body = new BlockStatement();
-        final Expression fieldExpr = new FieldExpression(fieldNode);
-        if ((fieldNode.getModifiers() & ACC_VOLATILE) == 0) {
-            body.addStatement(new IfStatement(
-                    new BooleanExpression(new BinaryExpression(fieldExpr, notEqualsOp(), NULL_EXPR)),
-                    new ExpressionStatement(fieldExpr),
-                    new ExpressionStatement(new BinaryExpression(fieldExpr, equalsOp(), initExpr))
-            ));
+        final BlockStatement body = new BlockStatement();
+        if (fieldNode.isStatic()) {
+            addHolderClassIdiomBody(body, fieldNode, initExpr);
+        } else if (isVolatile(fieldNode)) {
+            addNonThreadSafeBody(body, fieldNode, initExpr);
         } else {
-            body.addStatement(new IfStatement(
-                    new BooleanExpression(new BinaryExpression(fieldExpr, notEqualsOp(), NULL_EXPR)),
-                    new ReturnStatement(fieldExpr),
-                    new SynchronizedStatement(
-                            synchTarget(fieldNode),
-                            new IfStatement(
-                                    new BooleanExpression(new BinaryExpression(fieldExpr, notEqualsOp(), NULL_EXPR)),
-                                    new ReturnStatement(fieldExpr),
-                                    new ReturnStatement(new BinaryExpression(fieldExpr, equalsOp(), initExpr))
-                            )
-                    )
-            ));
+            addDoubleCheckedLockingBody(body, fieldNode, initExpr);
         }
         addMethod(fieldNode, body, fieldNode.getType());
     }
 
+    private void addHolderClassIdiomBody(BlockStatement body, FieldNode fieldNode, Expression initExpr) {
+        final ClassNode declaringClass = fieldNode.getDeclaringClass();
+        final ClassNode fieldType = fieldNode.getType();
+        final int visibility = ACC_PRIVATE | ACC_STATIC;
+        final String fullName = declaringClass.getName() + "$" + fieldType.getNameWithoutPackage() + "Holder_" + fieldNode.getName().substring(1);
+        final InnerClassNode holderClass = new InnerClassNode(declaringClass, fullName, visibility, OBJECT_TYPE);
+        final String innerFieldName = "INSTANCE";
+        holderClass.addField(innerFieldName, ACC_PRIVATE | ACC_STATIC | ACC_FINAL, fieldType, initExpr);
+        final Expression innerField = new PropertyExpression(new ClassExpression(holderClass), innerFieldName);
+        declaringClass.getModule().addClass(holderClass);
+        body.addStatement(new ReturnStatement(innerField));
+    }
+
+    private void addDoubleCheckedLockingBody(BlockStatement body, FieldNode fieldNode, Expression initExpr) {
+        final Expression fieldExpr = new FieldExpression(fieldNode);
+        final VariableExpression localVar = new VariableExpression(fieldNode.getName() + "_local", fieldNode.getType());
+        body.addStatement(new ExpressionStatement(new DeclarationExpression(localVar, ASSIGN, fieldExpr)));
+        body.addStatement(new IfStatement(
+                new BooleanExpression(new BinaryExpression(localVar, COMPARE_NOT_EQUAL, NULL_EXPR)),
+                new ReturnStatement(localVar),
+                new SynchronizedStatement(
+                        synchTarget(fieldNode),
+                        new IfStatement(
+                                new BooleanExpression(new BinaryExpression(fieldExpr, COMPARE_NOT_EQUAL, NULL_EXPR)),
+                                new ReturnStatement(fieldExpr),
+                                new ReturnStatement(new BinaryExpression(fieldExpr, ASSIGN, initExpr))
+                        )
+                )
+        ));
+    }
+
+    private void addNonThreadSafeBody(BlockStatement body, FieldNode fieldNode, Expression initExpr) {
+        final Expression fieldExpr = new FieldExpression(fieldNode);
+        body.addStatement(new IfStatement(
+                new BooleanExpression(new BinaryExpression(fieldExpr, COMPARE_NOT_EQUAL, NULL_EXPR)),
+                new ExpressionStatement(fieldExpr),
+                new ExpressionStatement(new BinaryExpression(fieldExpr, ASSIGN, initExpr))
+        ));
+    }
+
     private void addMethod(FieldNode fieldNode, BlockStatement body, ClassNode type) {
         int visibility = ACC_PUBLIC;
         if (fieldNode.isStatic()) visibility |= ACC_STATIC;
@@ -98,39 +131,36 @@ public class LazyASTTransformation implements ASTTransformation, Opcodes {
     }
 
     private void createSoft(FieldNode fieldNode, Expression initExpr) {
-        ClassNode type = fieldNode.getType();
-
+        final ClassNode type = fieldNode.getType();
         fieldNode.setType(SOFT_REF);
-
         createSoftGetter(fieldNode, initExpr, type);
         createSoftSetter(fieldNode, type);
     }
 
     private void createSoftGetter(FieldNode fieldNode, Expression initExpr, ClassNode type) {
-        BlockStatement body = new BlockStatement();
+        final BlockStatement body = new BlockStatement();
         final Expression fieldExpr = new FieldExpression(fieldNode);
-
         final Expression resExpr = new VariableExpression("res", type);
         final MethodCallExpression callExpression = new MethodCallExpression(new FieldExpression(fieldNode), "get", new ArgumentListExpression());
         callExpression.setSafe(true);
-        body.addStatement(new ExpressionStatement(new DeclarationExpression(resExpr, equalsOp(), callExpression)));
+        body.addStatement(new ExpressionStatement(new DeclarationExpression(resExpr, ASSIGN, callExpression)));
 
-        BlockStatement elseBlock = new BlockStatement();
-        elseBlock.addStatement(new ExpressionStatement(new BinaryExpression(resExpr, equalsOp(), initExpr)));
-        elseBlock.addStatement(new ExpressionStatement(new BinaryExpression(fieldExpr, equalsOp(), new ConstructorCallExpression(SOFT_REF, resExpr))));
+        final BlockStatement elseBlock = new BlockStatement();
+        elseBlock.addStatement(new ExpressionStatement(new BinaryExpression(resExpr, ASSIGN, initExpr)));
+        elseBlock.addStatement(new ExpressionStatement(new BinaryExpression(fieldExpr, ASSIGN, new ConstructorCallExpression(SOFT_REF, resExpr))));
         elseBlock.addStatement(new ExpressionStatement(resExpr));
 
         final Statement mainIf = new IfStatement(
-                new BooleanExpression(new BinaryExpression(resExpr, notEqualsOp(), NULL_EXPR)),
+                new BooleanExpression(new BinaryExpression(resExpr, COMPARE_NOT_EQUAL, NULL_EXPR)),
                 new ExpressionStatement(resExpr),
                 elseBlock
         );
 
-        if ((fieldNode.getModifiers() & ACC_VOLATILE) == 0) {
+        if (isVolatile(fieldNode)) {
             body.addStatement(mainIf);
         } else {
             body.addStatement(new IfStatement(
-                    new BooleanExpression(new BinaryExpression(resExpr, notEqualsOp(), NULL_EXPR)),
+                    new BooleanExpression(new BinaryExpression(resExpr, COMPARE_NOT_EQUAL, NULL_EXPR)),
                     new ExpressionStatement(resExpr),
                     new SynchronizedStatement(synchTarget(fieldNode), mainIf)
             ));
@@ -139,15 +169,15 @@ public class LazyASTTransformation implements ASTTransformation, Opcodes {
     }
 
     private void createSoftSetter(FieldNode fieldNode, ClassNode type) {
-        BlockStatement body = new BlockStatement();
+        final BlockStatement body = new BlockStatement();
         final Expression fieldExpr = new FieldExpression(fieldNode);
         final String name = "set" + MetaClassHelper.capitalize(fieldNode.getName().substring(1));
         final Parameter parameter = new Parameter(type, "value");
         final Expression paramExpr = new VariableExpression(parameter);
         body.addStatement(new IfStatement(
-                new BooleanExpression(new BinaryExpression(paramExpr, notEqualsOp(), NULL_EXPR)),
-                new ExpressionStatement(new BinaryExpression(fieldExpr, equalsOp(), new ConstructorCallExpression(SOFT_REF, paramExpr))),
-                new ExpressionStatement(new BinaryExpression(fieldExpr, equalsOp(), NULL_EXPR))
+                new BooleanExpression(new BinaryExpression(paramExpr, COMPARE_NOT_EQUAL, NULL_EXPR)),
+                new ExpressionStatement(new BinaryExpression(fieldExpr, ASSIGN, new ConstructorCallExpression(SOFT_REF, paramExpr))),
+                new ExpressionStatement(new BinaryExpression(fieldExpr, ASSIGN, NULL_EXPR))
         ));
         int visibility = ACC_PUBLIC;
         if (fieldNode.isStatic()) visibility |= ACC_STATIC;
@@ -158,12 +188,8 @@ public class LazyASTTransformation implements ASTTransformation, Opcodes {
         return fieldNode.isStatic() ? new ClassExpression(fieldNode.getDeclaringClass()) : VariableExpression.THIS_EXPRESSION;
     }
 
-    private static Token equalsOp() {
-        return Token.newSymbol("=", -1, -1);
-    }
-
-    private static Token notEqualsOp() {
-        return Token.newSymbol("!=", -1, -1);
+    private boolean isVolatile(FieldNode fieldNode) {
+        return (fieldNode.getModifiers() & ACC_VOLATILE) == 0;
     }
 
     private Expression getInitExpr(FieldNode fieldNode) {
diff --git a/src/test/org/codehaus/groovy/transform/LazyTransformTest.groovy b/src/test/org/codehaus/groovy/transform/LazyTransformTest.groovy
index da42b32acd..fc8178b0f6 100644
--- a/src/test/org/codehaus/groovy/transform/LazyTransformTest.groovy
+++ b/src/test/org/codehaus/groovy/transform/LazyTransformTest.groovy
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2008 the original author or authors.
+ * Copyright 2003-2010 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -19,6 +19,7 @@ import java.lang.ref.SoftReference
 
 /**
  * @author Alex Tkachman
+ * @author Paul King
  */
 class LazyTransformTest extends GroovyShellTestCase {
 
@@ -97,6 +98,33 @@ class LazyTransformTest extends GroovyShellTestCase {
         assertEquals([1,2,3], res.list)
     }
 
+    void testStatic() {
+        def res = evaluate("""
+              class X {
+                @Lazy static List list = { [1,2,3] } ()
+              }
+              new X ()
+        """)
+
+        assertNull res.@'$list'
+        assert res.list == [1, 2, 3]
+    }
+
+    void testLazyPrimitivePromotedToWrapper() {
+        def res = evaluate("""
+              class X {
+                @Lazy int val1 = 1
+                @Lazy volatile int val2 = 2
+              }
+              new X ()
+        """)
+
+        assertNull res.@'$val1'
+        assertNull res.@'$val2'
+        assert res.val1 == 1
+        assert res.val2 == 2
+    }
+
     void testSoft() {
         def res = evaluate("""
               class X {
