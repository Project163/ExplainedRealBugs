diff --git a/src/main/org/codehaus/groovy/ast/expr/ClosureExpression.java b/src/main/org/codehaus/groovy/ast/expr/ClosureExpression.java
index 5a282b8a75..65b3dd8a57 100644
--- a/src/main/org/codehaus/groovy/ast/expr/ClosureExpression.java
+++ b/src/main/org/codehaus/groovy/ast/expr/ClosureExpression.java
@@ -48,6 +48,7 @@ package org.codehaus.groovy.ast.expr;
 import org.codehaus.groovy.ast.GroovyCodeVisitor;
 import org.codehaus.groovy.ast.Parameter;
 import org.codehaus.groovy.ast.stmt.*;
+import org.codehaus.groovy.runtime.InvokerHelper;
 
 
 /**
@@ -75,6 +76,10 @@ public class ClosureExpression extends Expression {
         return this;
     }
     
+    public String toString() {
+        return super.toString() + InvokerHelper.toString(parameters) + "{ " + code + " }";
+    }
+
     public Statement getCode() {
         return code;
     }
diff --git a/src/main/org/codehaus/groovy/ast/expr/MapEntryExpression.java b/src/main/org/codehaus/groovy/ast/expr/MapEntryExpression.java
index c0f425bf56..0a80b95aa3 100644
--- a/src/main/org/codehaus/groovy/ast/expr/MapEntryExpression.java
+++ b/src/main/org/codehaus/groovy/ast/expr/MapEntryExpression.java
@@ -71,6 +71,10 @@ public class MapEntryExpression extends Expression {
         return new MapEntryExpression(transformer.transform(keyExpression), transformer.transform(valueExpression)); 
     }
     
+    public String toString() {
+        return super.toString() + "(key: " + keyExpression + ", value: " + valueExpression + ")";
+    }
+
     public Expression getKeyExpression() {
         return keyExpression;
     }
diff --git a/src/main/org/codehaus/groovy/ast/expr/MapExpression.java b/src/main/org/codehaus/groovy/ast/expr/MapExpression.java
index 7208382da0..e9a103a9d3 100644
--- a/src/main/org/codehaus/groovy/ast/expr/MapExpression.java
+++ b/src/main/org/codehaus/groovy/ast/expr/MapExpression.java
@@ -83,6 +83,10 @@ public class MapExpression extends Expression {
         return new MapExpression(transformExpressions(getMapEntryExpressions(), transformer));
     }
     
+    public String toString() {
+        return super.toString() + mapEntryExpressions;
+    }
+
     public void addMapEntryExpression(Expression keyExpression, Expression valueExpression) {
         addMapEntryExpression(new MapEntryExpression(keyExpression, valueExpression));
     }
diff --git a/src/main/org/codehaus/groovy/syntax/parser/Parser.java b/src/main/org/codehaus/groovy/syntax/parser/Parser.java
index fb91ac3577..80217fa7f9 100644
--- a/src/main/org/codehaus/groovy/syntax/parser/Parser.java
+++ b/src/main/org/codehaus/groovy/syntax/parser/Parser.java
@@ -419,16 +419,8 @@ public class Parser {
     protected CSTNode parameterDeclarationList() throws IOException, SyntaxException {
         CSTNode parameterDeclarationList = new CSTNode();
 
-        while (lt() == Token.IDENTIFIER ||
-	           lt() == Token.KEYWORD_BOOLEAN ||
-	    	   lt() == Token.KEYWORD_BYTE ||
-	    	   lt() == Token.KEYWORD_CHAR ||
-	    	   lt() == Token.KEYWORD_DOUBLE ||
-	    	   lt() == Token.KEYWORD_FLOAT ||
-	    	   lt() == Token.KEYWORD_INT ||
-	    	   lt() == Token.KEYWORD_LONG ||
-	    	   lt() == Token.KEYWORD_SHORT)
-        {
+        while (lt() == Token.IDENTIFIER
+            || isIdentifierOrPrimtiveTypeKeyword(lt())) {
             parameterDeclarationList.addChild(parameterDeclaration());
 
             if (lt() == Token.COMMA) {
@@ -444,15 +436,15 @@ public class Parser {
 
     protected CSTNode parameterDeclaration() throws IOException, SyntaxException {
         CSTNode parameterDeclaration = null;
-        
+
         //
         // TODO: deal with array declarations
         // { int a[]
         //
 
         switch (lt(2)) {
-        	case (Token.IDENTIFIER) :
-        	case (Token.LEFT_SQUARE_BRACKET) :
+            case (Token.IDENTIFIER) :
+            case (Token.LEFT_SQUARE_BRACKET) :
             case (Token.DOT) :
                 {
                     parameterDeclaration = parameterDeclarationWithDatatype();
@@ -1617,20 +1609,21 @@ public class Parser {
         // { A a |
         // { A a, B b |
         // { int[] a, char b |
+        // but not { a }, 
+
+        int value = lt(1);
         
-        if (lt(1) == Token.KEYWORD_BOOLEAN ||
-    		lt(1) == Token.KEYWORD_BYTE ||
-    		lt(1) == Token.KEYWORD_CHAR ||
-    		lt(1) == Token.KEYWORD_DOUBLE ||
-    		lt(1) == Token.KEYWORD_FLOAT ||
-    		lt(1) == Token.KEYWORD_INT ||
-    		lt(1) == Token.KEYWORD_LONG ||
-    		lt(1) == Token.KEYWORD_SHORT ||
-        	lt(2) == Token.PIPE ||
-        	lt(2) == Token.COMMA ||
-        	lt(3) == Token.PIPE ||
-        	lt(3) == Token.COMMA)
-        {
+        boolean canBeParamList = false;
+        
+        if (isIdentifierOrPrimtiveTypeKeyword(lt())) {
+            if (isIdentifierOrPrimtiveTypeKeyword(lt(2))) {
+                canBeParamList = lt(3) == Token.PIPE || lt(3) == Token.COMMA;
+            }
+            else {
+                canBeParamList = lt(2) == Token.PIPE || lt(2) == Token.COMMA;
+            }
+        }
+        if (canBeParamList) {
             expr.addChild(parameterDeclarationList());
             pipeRequired = true;
         }
@@ -1638,13 +1631,15 @@ public class Parser {
             expr.addChild(new CSTNode());
         }
 
-        if (pipeRequired || lt() == Token.PIPE) {
-            consume(Token.PIPE);
-        }
-
         CSTNode block = new CSTNode();
 
-        statementsUntilRightCurly(block);
+        if (lt_bare() != Token.RIGHT_CURLY_BRACE) {
+            if (pipeRequired || lt() == Token.PIPE) {
+                consume(Token.PIPE);
+            }
+
+            statementsUntilRightCurly(block);
+        }
 
         consume(Token.RIGHT_CURLY_BRACE);
 
@@ -1653,6 +1648,18 @@ public class Parser {
         return expr;
     }
 
+    protected boolean isIdentifierOrPrimtiveTypeKeyword(int value) {
+        return value == Token.IDENTIFIER
+            || value == Token.KEYWORD_BOOLEAN
+        || value == Token.KEYWORD_BYTE
+            || value == Token.KEYWORD_CHAR
+            || value == Token.KEYWORD_DOUBLE
+            || value == Token.KEYWORD_FLOAT
+            || value == Token.KEYWORD_INT
+            || value == Token.KEYWORD_LONG
+            || value == Token.KEYWORD_SHORT;
+    }
+
     protected CSTNode listOrMapExpression() throws IOException, SyntaxException {
         CSTNode expr = null;
 
diff --git a/src/test/groovy/bugs/ClosureVariableBug.groovy b/src/test/groovy/bugs/ClosureVariableBug.groovy
index 6c85734f5c..2d627066a9 100644
--- a/src/test/groovy/bugs/ClosureVariableBug.groovy
+++ b/src/test/groovy/bugs/ClosureVariableBug.groovy
@@ -11,4 +11,17 @@ class ClosureVariableBug extends GroovyTestCase {
         count = 1
         closure(1)
     }
+    
+    void testPassingClosureAsNamedParameter() {
+        x = 123
+        
+        foo = new Expando(a:{x}, b:456)
+    
+    	assert foo.a != null
+        
+        println "Foo has a = ${foo.a}"
+        
+    	value = foo.a()
+    	assert value == 123
+    }
 }
\ No newline at end of file
diff --git a/src/test/org/codehaus/groovy/syntax/parser/ASTBuilderTest.java b/src/test/org/codehaus/groovy/syntax/parser/ASTBuilderTest.java
index e22c850ea8..d1e02382fb 100644
--- a/src/test/org/codehaus/groovy/syntax/parser/ASTBuilderTest.java
+++ b/src/test/org/codehaus/groovy/syntax/parser/ASTBuilderTest.java
@@ -40,8 +40,11 @@ import org.codehaus.groovy.ast.MethodNode;
 import org.codehaus.groovy.ast.ModuleNode;
 import org.codehaus.groovy.ast.expr.BinaryExpression;
 import org.codehaus.groovy.ast.expr.ClassExpression;
+import org.codehaus.groovy.ast.expr.ClosureExpression;
 import org.codehaus.groovy.ast.expr.ConstantExpression;
 import org.codehaus.groovy.ast.expr.Expression;
+import org.codehaus.groovy.ast.expr.MapEntryExpression;
+import org.codehaus.groovy.ast.expr.MapExpression;
 import org.codehaus.groovy.ast.expr.VariableExpression;
 import org.codehaus.groovy.ast.stmt.BlockStatement;
 import org.codehaus.groovy.ast.stmt.ExpressionStatement;
@@ -195,6 +198,23 @@ public class ASTBuilderTest extends TestParserSupport {
         System.out.println("expr: " + exp);
     }
 
+    public void testClosureWithJustIdentifierInMapBug() throws Exception {
+        ModuleNode module = parse("class Foo { void testMethod() { ['x':{a}, 'd':123] } }", "Dummy.groovy");
+        BlockStatement statement = getCode(module, "testMethod");
+
+        assertEquals("Statements size: " + statement.getStatements(), 1, statement.getStatements().size());
+
+        System.out.println(statement.getStatements());
+
+        ExpressionStatement exprStmt = (ExpressionStatement) statement.getStatements().get(0);
+
+        MapExpression mapExp = (MapExpression) exprStmt.getExpression();
+        MapEntryExpression entryExp = (MapEntryExpression) mapExp.getMapEntryExpressions().get(0);
+        ClosureExpression closureExp = (ClosureExpression) entryExp.getValueExpression();
+        assertEquals("Parameters on closure", 0, closureExp.getParameters().length);
+        System.out.println("expr: " + closureExp);
+    }
+
     public void testArrayExpression() throws Exception {
         ModuleNode module = parse("class Foo { void testMethod() { foo = new String[] { 'a', 'b', 'c' }\n assert foo != null } }", "Dummy.groovy");
         BlockStatement statement = getCode(module, "testMethod");
