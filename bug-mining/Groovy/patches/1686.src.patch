diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index eac020fb74..e81f30ff6e 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -532,7 +532,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         if (constructors.isEmpty() && arguments.length==0) return;
         List<MethodNode> constructorList = findMethod(node, "<init>", arguments);
         if (constructorList.isEmpty()) {
-            addStaticTypeError("No matching constructor found: "+node+toMethodParametersString("<init>", arguments), classNode);
+            addStaticTypeError("No matching constructor found: " + node + toMethodParametersString("<init>", arguments), classNode);
         }
     }
 
@@ -559,9 +559,8 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
      *         otherwise falls back to the provided type class.
      */
     private ClassNode findCurrentInstanceOfClass(final Expression expr, final ClassNode type) {
-        if (!temporaryIfBranchTypeInformation.empty()) {
-            Object key = extractTemporaryTypeInfoKey(expr);
-            List<ClassNode> nodes = temporaryIfBranchTypeInformation.peek().get(key);
+        if (!temporaryIfBranchTypeInformation.empty()) {            
+            List<ClassNode> nodes = getTemporaryTypesForExpression(expr);
             if (nodes != null && nodes.size() == 1) return nodes.get(0);
         }
         return type;
@@ -594,10 +593,8 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         List<ClassNode> tests = new LinkedList<ClassNode>();
         tests.add(clazz);
         if (objectExpression instanceof ClassExpression) tests.add(CLASS_Type);
-        if (!temporaryIfBranchTypeInformation.empty()) {
-            Map<Object, List<ClassNode>> info = temporaryIfBranchTypeInformation.peek();
-            Object key = extractTemporaryTypeInfoKey(objectExpression);
-            List<ClassNode> classNodes = info.get(key);
+        if (!temporaryIfBranchTypeInformation.empty()) {            
+            List<ClassNode> classNodes = getTemporaryTypesForExpression(objectExpression);
             if (classNodes != null) tests.addAll(classNodes);
         }
         if (lastImplicitItType != null
@@ -814,11 +811,21 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         List<Expression> arglist = args.getExpressions();
         ClassNode[] ret = new ClassNode[arglist.size()];
         int i = 0;
+        Map<Object, List<ClassNode>> info = temporaryIfBranchTypeInformation.empty()?null:temporaryIfBranchTypeInformation.peek();
         for (Expression exp : arglist) {
             if (exp instanceof ConstantExpression && ((ConstantExpression)exp).getValue()==null) {
                 ret[i] = UNKNOWN_PARAMETER_TYPE;
             } else {
                 ret[i] = getType(exp);
+                if (exp instanceof VariableExpression && info!=null) {
+                    List<ClassNode> classNodes = getTemporaryTypesForExpression(exp);
+                    if (classNodes!=null && !classNodes.isEmpty()) {
+                        ArrayList<ClassNode> arr = new ArrayList<ClassNode>(classNodes.size()+1);
+                        arr.add(ret[i]);
+                        arr.addAll(classNodes);
+                        ret[i] = new UnionTypeClassNode(arr.toArray(new ClassNode[arr.size()]));
+                    }
+                }
             }
             i++;
         }
@@ -903,6 +910,101 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         super.visitMethod(node);
     }
 
+    @Override
+    public void visitStaticMethodCallExpression(final StaticMethodCallExpression call) {
+        final String name = call.getMethod();
+        if (name == null) {
+            addStaticTypeError("cannot resolve dynamic method name at compile time.", call);
+            return;
+        }
+
+        final ClassNode rememberLastItType = lastImplicitItType;
+        Expression callArguments = call.getArguments();
+
+        boolean isWithCall = isWithCall(name, callArguments);
+
+        if (!isWithCall) {
+            // if it is not a "with" call, arguments should be visited first
+            callArguments.visit(this);
+        }
+
+        ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(callArguments));
+        final ClassNode receiver = call.getOwnerType();
+
+        if (isWithCall) {
+            withReceiverList.add(0, receiver); // must be added first in the list
+            lastImplicitItType = receiver;
+            // if the provided closure uses an explicit parameter definition, we can
+            // also check that the provided type is correct
+            if (callArguments instanceof ArgumentListExpression) {
+                ArgumentListExpression argList = (ArgumentListExpression) callArguments;
+                ClosureExpression closure = (ClosureExpression) argList.getExpression(0);
+                Parameter[] parameters = closure.getParameters();
+                if (parameters.length > 1) {
+                    addStaticTypeError("Unexpected number of parameters for a with call", argList);
+                } else if (parameters.length == 1) {
+                    Parameter param = parameters[0];
+                    if (!param.isDynamicTyped() && !isAssignableTo(receiver, param.getType().redirect())) {
+                        addStaticTypeError("Expected parameter type: " + receiver.toString(false) + " but was: " + param.getType().redirect().toString(false), param);
+                    }
+                }
+            }
+        }
+
+        try {
+            if (isWithCall) {
+                // in case of a with call, arguments (the closure) should be visited now that we checked
+                // the arguments
+                callArguments.visit(this);
+            }
+
+                // method call receivers are :
+                //   - possible "with" receivers
+                //   - the actual receiver as found in the method call expression
+                //   - any of the potential receivers found in the instanceof temporary table
+                // in that order
+                List<ClassNode> receivers = new LinkedList<ClassNode>();
+                if (!withReceiverList.isEmpty()) receivers.addAll(withReceiverList);
+                receivers.add(receiver);
+                List<MethodNode> mn = null;
+                ClassNode chosenReceiver = null;
+                for (ClassNode currentReceiver : receivers) {
+                    mn = findMethod(currentReceiver, name, args);
+                    if (!mn.isEmpty()) {
+                        typeCheckMethodsWithGenerics(currentReceiver, args, mn, call);
+                        chosenReceiver = currentReceiver;
+                        break;
+                    }
+                }
+                if (mn.isEmpty()) {
+                    addStaticTypeError("Cannot find matching method " + receiver.getName() + "#" + toMethodParametersString(name, args), call);
+                } else {
+                    if (mn.size() == 1) {
+                        MethodNode directMethodCallCandidate = mn.get(0);
+                        // visit the method to obtain inferred return type
+                        ClassNode currentClassNode = classNode;
+                        classNode = directMethodCallCandidate.getDeclaringClass();
+                        visitMethod(directMethodCallCandidate);
+                        classNode = currentClassNode;
+                        ClassNode returnType = getType(directMethodCallCandidate);
+                        if (returnType.isUsingGenerics() && !returnType.isEnum()) {
+                            returnType = inferReturnTypeGenerics(chosenReceiver, directMethodCallCandidate, callArguments);
+                        }
+                        storeType(call, returnType);
+                        storeTargetMethod(call, directMethodCallCandidate);
+
+                    } else {
+                        addStaticTypeError("Reference to method is ambiguous. Cannot choose between " + mn, call);
+                    }
+                }
+        } finally {
+            if (isWithCall) {
+                lastImplicitItType = rememberLastItType;
+                withReceiverList.removeFirst();
+            }
+        }
+    }
+
     @Override
     public void visitMethodCallExpression(MethodCallExpression call) {
         final String name = call.getMethodAsString();
@@ -1051,9 +1153,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                     receivers.add(CLASS_Type);
                 }
                 if (!temporaryIfBranchTypeInformation.empty()) {
-                    final Map<Object, List<ClassNode>> tempo = temporaryIfBranchTypeInformation.peek();
-                    Object key = extractTemporaryTypeInfoKey(objectExpression);
-                    List<ClassNode> potentialReceiverType = tempo.get(key);
+                    List<ClassNode> potentialReceiverType = getTemporaryTypesForExpression(objectExpression);
                     if (potentialReceiverType != null) receivers.addAll(potentialReceiverType);
                 }
                 List<MethodNode> mn = null;
@@ -1102,6 +1202,17 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         }
     }
 
+    private List<ClassNode> getTemporaryTypesForExpression(final Expression objectExpression) {
+        List<ClassNode> classNodes = null;
+        int depth = temporaryIfBranchTypeInformation.size();
+        while (classNodes==null && depth>0) {
+            final Map<Object, List<ClassNode>> tempo = temporaryIfBranchTypeInformation.get(--depth);
+            Object key = extractTemporaryTypeInfoKey(objectExpression);
+            classNodes = tempo.get(key);
+        }
+        return classNodes;
+    }
+
     private void storeTargetMethod(final Expression call, final MethodNode directMethodCallCandidate) {
         call.putNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET, directMethodCallCandidate);
     }
@@ -1259,7 +1370,14 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 				}
 				assignedTypes.add(cn);
 			}
-
+            if (!temporaryIfBranchTypeInformation.empty()) {
+                List<ClassNode> temporaryTypesForExpression = getTemporaryTypesForExpression(exp);
+                if (temporaryTypesForExpression!=null && !temporaryTypesForExpression.isEmpty()) {
+                    // a type inference has been made on a variable which type was defined in an instanceof block
+                    // we erase available information with the new type
+                    temporaryTypesForExpression.clear();
+                }
+            }
         }
     }
 
diff --git a/src/main/org/codehaus/groovy/transform/stc/UnionTypeClassNode.java b/src/main/org/codehaus/groovy/transform/stc/UnionTypeClassNode.java
new file mode 100644
index 0000000000..f6563e13cb
--- /dev/null
+++ b/src/main/org/codehaus/groovy/transform/stc/UnionTypeClassNode.java
@@ -0,0 +1,449 @@
+/*
+ * Copyright 2003-2009 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.codehaus.groovy.transform.stc;
+
+import org.codehaus.groovy.ast.*;
+import org.codehaus.groovy.ast.expr.Expression;
+import org.codehaus.groovy.ast.stmt.Statement;
+import org.codehaus.groovy.transform.ASTTransformation;
+
+import java.util.*;
+
+/**
+ * This class node type is very special and should only be used by the static type checker
+ * to represent types which are the union of other types. This is useful when, for example,
+ * we enter a section like :
+ * <pre>if (x instanceof A || x instanceof B)</pre>
+ * where the type of <i>x</i> can be represented as one of <i>A</i> or <i>B</i>.
+ *
+ * This class node type should never leak outside of the type checker. More precisely, it should
+ * only be used to check method call arguments, and nothing more.
+ *
+ * @author Cedric Champeau
+ */
+class UnionTypeClassNode extends ClassNode {
+    private final ClassNode[] delegates;
+    
+    public UnionTypeClassNode(ClassNode... classNodes) {
+        super("<UnionType"+classNodes+">", 0, ClassHelper.OBJECT_TYPE);
+        delegates = classNodes==null?new ClassNode[0] : classNodes;
+    }
+
+    @Override
+    public ConstructorNode addConstructor(final int modifiers, final Parameter[] parameters, final ClassNode[] exceptions, final Statement code) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void addConstructor(final ConstructorNode node) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public FieldNode addField(final String name, final int modifiers, final ClassNode type, final Expression initialValue) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void addField(final FieldNode node) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public FieldNode addFieldFirst(final String name, final int modifiers, final ClassNode type, final Expression initialValue) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void addFieldFirst(final FieldNode node) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void addInterface(final ClassNode type) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public MethodNode addMethod(final String name, final int modifiers, final ClassNode returnType, final Parameter[] parameters, final ClassNode[] exceptions, final Statement code) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void addMethod(final MethodNode node) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void addMixin(final MixinNode mixin) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void addObjectInitializerStatements(final Statement statements) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public PropertyNode addProperty(final String name, final int modifiers, final ClassNode type, final Expression initialValueExpression, final Statement getterBlock, final Statement setterBlock) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void addProperty(final PropertyNode node) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void addStaticInitializerStatements(final List<Statement> staticStatements, final boolean fieldInit) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public MethodNode addSyntheticMethod(final String name, final int modifiers, final ClassNode returnType, final Parameter[] parameters, final ClassNode[] exceptions, final Statement code) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void addTransform(final Class<? extends ASTTransformation> transform, final ASTNode node) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean declaresInterface(final ClassNode classNode) {
+        for (ClassNode delegate : delegates) {
+            if (delegate.declaresInterface(classNode)) return true;
+        }
+        return false;
+    }
+
+    @Override
+    public boolean equals(final Object o) {
+        if (!(o instanceof UnionTypeClassNode)) return false;
+        return Arrays.equals(delegates, ((UnionTypeClassNode)o).delegates);
+    }
+
+    @Override
+    public List<MethodNode> getAbstractMethods() {
+        List<MethodNode> allMethods = new LinkedList<MethodNode>();
+        for (ClassNode delegate : delegates) {
+            allMethods.addAll(delegate.getAbstractMethods());
+        }
+        return allMethods;
+    }
+
+    @Override
+    public List<MethodNode> getAllDeclaredMethods() {
+        List<MethodNode> allMethods = new LinkedList<MethodNode>();
+        for (ClassNode delegate : delegates) {
+            allMethods.addAll(delegate.getAllDeclaredMethods());
+        }
+        return allMethods;
+    }
+
+    @Override
+    public Set<ClassNode> getAllInterfaces() {
+        Set<ClassNode> allMethods = new HashSet<ClassNode>();
+        for (ClassNode delegate : delegates) {
+            allMethods.addAll(delegate.getAllInterfaces());
+        }
+        return allMethods;
+    }
+
+    @Override
+    public List<AnnotationNode> getAnnotations() {
+        List<AnnotationNode> nodes = new LinkedList<AnnotationNode>();
+        for (ClassNode delegate : delegates) {
+            List<AnnotationNode> annotations = delegate.getAnnotations();
+            if (annotations!=null) nodes.addAll(annotations);
+        }
+        return nodes;
+    }
+
+    @Override
+    public List<AnnotationNode> getAnnotations(final ClassNode type) {
+        List<AnnotationNode> nodes = new LinkedList<AnnotationNode>();
+        for (ClassNode delegate : delegates) {
+            List<AnnotationNode> annotations = delegate.getAnnotations(type);
+            if (annotations!=null) nodes.addAll(annotations);
+        }
+        return nodes;
+    }
+
+    @Override
+    public ClassNode getComponentType() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public List<ConstructorNode> getDeclaredConstructors() {
+        List<ConstructorNode> nodes = new LinkedList<ConstructorNode>();
+        for (ClassNode delegate : delegates) {
+            nodes.addAll(delegate.getDeclaredConstructors());
+        }
+        return nodes;
+    }
+
+    @Override
+    public FieldNode getDeclaredField(final String name) {
+        for (ClassNode delegate : delegates) {
+            FieldNode node = delegate.getDeclaredField(name);
+            if (node!=null) return node;
+        }
+        return null;
+    }
+
+    @Override
+    public MethodNode getDeclaredMethod(final String name, final Parameter[] parameters) {
+        for (ClassNode delegate : delegates) {
+            MethodNode node = delegate.getDeclaredMethod(name, parameters);
+            if (node!=null) return node;
+        }
+        return null;
+    }
+
+    @Override
+    public List<MethodNode> getDeclaredMethods(final String name) {
+        List<MethodNode> nodes = new LinkedList<MethodNode>();
+        for (ClassNode delegate : delegates) {
+            List<MethodNode> methods = delegate.getDeclaredMethods(name);
+            if (methods!=null) nodes.addAll(methods);
+        }
+        return nodes;
+    }
+
+    @Override
+    public Map<String, MethodNode> getDeclaredMethodsMap() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public MethodNode getEnclosingMethod() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public FieldNode getField(final String name) {
+        for (ClassNode delegate : delegates) {
+            FieldNode field = delegate.getField(name);
+            if (field!=null) return field;
+        }
+        return null;
+    }
+
+    @Override
+    public List<FieldNode> getFields() {
+        List<FieldNode> nodes = new LinkedList<FieldNode>();
+        for (ClassNode delegate : delegates) {
+            List<FieldNode> fields = delegate.getFields();
+            if (fields!=null) nodes.addAll(fields);
+        }
+        return nodes;
+    }
+
+    @Override
+    public Iterator<InnerClassNode> getInnerClasses() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public ClassNode[] getInterfaces() {
+        Set<ClassNode> nodes = new LinkedHashSet<ClassNode>();
+        for (ClassNode delegate : delegates) {
+            ClassNode[] interfaces = delegate.getInterfaces();
+            if (interfaces!=null) Collections.addAll(nodes, interfaces);
+        }
+        return nodes.toArray(new ClassNode[nodes.size()]);
+    }
+
+    @Override
+    public List<MethodNode> getMethods() {
+        List<MethodNode> nodes = new LinkedList<MethodNode>();
+        for (ClassNode delegate : delegates) {
+            List<MethodNode> methods = delegate.getMethods();
+            if (methods!=null) nodes.addAll(methods);
+        }
+        return nodes;
+    }
+
+    @Override
+    public List<PropertyNode> getProperties() {
+        List<PropertyNode> nodes = new LinkedList<PropertyNode>();
+        for (ClassNode delegate : delegates) {
+            List<PropertyNode> properties = delegate.getProperties();
+            if (properties!=null) nodes.addAll(properties);
+        }
+        return nodes;
+    }
+
+    @Override
+    public Class getTypeClass() {
+        return super.getTypeClass();
+    }
+
+    @Override
+    public ClassNode[] getUnresolvedInterfaces() {
+        Set<ClassNode> nodes = new LinkedHashSet<ClassNode>();
+        for (ClassNode delegate : delegates) {
+            ClassNode[] interfaces = delegate.getUnresolvedInterfaces();
+            if (interfaces!=null) Collections.addAll(nodes, interfaces);
+        }
+        return nodes.toArray(new ClassNode[nodes.size()]);
+    }
+
+    @Override
+    public ClassNode[] getUnresolvedInterfaces(final boolean useRedirect) {
+        Set<ClassNode> nodes = new LinkedHashSet<ClassNode>();
+        for (ClassNode delegate : delegates) {
+            ClassNode[] interfaces = delegate.getUnresolvedInterfaces(useRedirect);
+            if (interfaces!=null) Collections.addAll(nodes, interfaces);
+        }
+        return nodes.toArray(new ClassNode[nodes.size()]);
+    }
+
+    @Override
+    public int hashCode() {
+        int hash = 13;
+        for (ClassNode delegate : delegates) {
+            hash = 31*hash + delegate.hashCode();
+        }
+        return hash;
+    }
+
+    @Override
+    public boolean implementsInterface(final ClassNode classNode) {
+        for (ClassNode delegate : delegates) {
+            if (delegate.implementsInterface(classNode)) return true;
+        }
+        return false;
+    }
+
+    @Override
+    public boolean isAnnotated() {
+        for (ClassNode delegate : delegates) {
+            if (delegate.isAnnotated()) return true;
+        }
+        return false;
+    }
+
+    @Override
+    public boolean isDerivedFrom(final ClassNode type) {
+        for (ClassNode delegate : delegates) {
+            if (delegate.isDerivedFrom(type)) return true;
+        }
+        return false;
+    }
+
+    @Override
+    public boolean isDerivedFromGroovyObject() {
+        for (ClassNode delegate : delegates) {
+            if (delegate.isDerivedFromGroovyObject()) return true;
+        }
+        return false;
+    }
+
+    @Override
+    public void removeField(final String oldName) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void renameField(final String oldName, final String newName) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void setAnnotated(final boolean flag) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void setEnclosingMethod(final MethodNode enclosingMethod) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void setGenericsPlaceHolder(final boolean b) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void setGenericsTypes(final GenericsType[] genericsTypes) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void setInterfaces(final ClassNode[] interfaces) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void setModifiers(final int modifiers) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public String setName(final String name) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void setRedirect(final ClassNode cn) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void setScript(final boolean script) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void setScriptBody(final boolean scriptBody) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void setStaticClass(final boolean staticClass) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void setSuperClass(final ClassNode superClass) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void setSyntheticPublic(final boolean syntheticPublic) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void setUnresolvedSuperClass(final ClassNode sn) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void setUsingGenerics(final boolean b) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void visitContents(final GroovyClassVisitor visitor) {
+        for (ClassNode delegate : delegates) {
+            delegate.visitContents(visitor);
+        }
+    }
+}
diff --git a/src/test/groovy/transform/stc/MethodCallsSTCTest.groovy b/src/test/groovy/transform/stc/MethodCallsSTCTest.groovy
index 676db6af24..b3adeb85e0 100644
--- a/src/test/groovy/transform/stc/MethodCallsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/MethodCallsSTCTest.groovy
@@ -279,6 +279,151 @@ class MethodCallsSTCTest extends StaticTypeCheckingTestCase {
         '''
     }
 
+    void testMethodCallArgumentUsingInstanceOf() {
+        assertScript '''
+            void foo(String str) { 'String' }
+            def o
+            if (o instanceof String) {
+                foo(o)
+            }
+        '''
+    }
+
+
+    void testShouldFindStaticMethod() {
+        assertScript '''
+                static String foo(String s) {
+                    'String'
+                }
+                foo('String')
+            '''
+    }
+
+    void testShouldFailWithNoMatchingMethod() {
+        shouldFailWithMessages '''
+                static String foo(String s) {
+                    'String'
+                }
+                static String foo(Integer s) {
+                    'Integer'
+                }
+                static String foo(Boolean s) {
+                    'Boolean'
+                }
+                ['foo',123,true].each { foo(it) }
+            ''', 'Cannot find matching method'
+    }
+
+    void testShouldNotFailThanksToInstanceOfChecks() {
+        assertScript '''
+                static String foo(String s) {
+                    'String'
+                }
+                static String foo(Integer s) {
+                    'Integer'
+                }
+                static String foo(Boolean s) {
+                    'Boolean'
+                }
+                ['foo',123,true].each {
+                    if (it instanceof String) {
+                        foo((String)it)
+                    } else if (it instanceof Boolean) {
+                        foo((Boolean)it)
+                    } else if (it instanceof Integer) {
+                        foo((Integer)it)
+                    }
+                }
+            '''
+    }
+
+    void testShouldNotFailThanksToInstanceOfChecksAndWithoutExplicitCasts() {
+        assertScript '''
+                static String foo(String s) {
+                    'String'
+                }
+                static String foo(Integer s) {
+                    'Integer'
+                }
+                static String foo(Boolean s) {
+                    'Boolean'
+                }
+                ['foo',123,true].each {
+                    if (it instanceof String) {
+                        foo(it)
+                    } else if (it instanceof Boolean) {
+                        foo(it)
+                    } else if (it instanceof Integer) {
+                        foo(it)
+                    }
+                }
+            '''
+    }
+
+    void testShouldFailWithMultiplePossibleMethods() {
+        shouldFailWithMessages '''
+                static String foo(String s) {
+                    'String'
+                }
+                static String foo(Integer s) {
+                    'Integer'
+                }
+                static String foo(Boolean s) {
+                    'Boolean'
+                }
+                ['foo',123,true].each {
+                    if (it instanceof String || it instanceof Boolean || it instanceof Integer) {
+                        foo(it)
+                    }
+                }
+            ''', 'Reference to method is ambiguous'
+    }
+
+    void testShouldFailBecauseVariableIsReassigned() {
+        shouldFailWithMessages '''
+                static String foo(String s) {
+                    'String'
+                }
+                def it
+                if (it instanceof String) {
+                    it = new Date()
+                    foo(it)
+                }
+            ''', 'foo(java.util.Date)'
+    }
+
+    void testShouldNotFailEvenIfVariableIsReassigned() {
+        assertScript '''
+                static String foo(int val) {
+                    'int'
+                }
+                def it
+                if (it instanceof String) {
+                    it = 123
+                    foo(it)
+                }
+            '''
+    }
+
+    void testShouldNotFailEvenIfVariableIsReassignedAndInstanceOfIsEmbed() {
+        assertScript '''
+                static String foo(int val) {
+                    'int'
+                }
+                static String foo(Date val) {
+                    'Date'
+                }
+                def it
+                if (it instanceof String) {
+                    it = 123
+                    foo(it)
+                    if (it instanceof Date) {
+                        foo(it)
+                    }
+                }
+            '''
+    }
+
     static class MyMethodCallTestClass {
 
         static int mul(int... args) { args.toList().inject(1) { x,y -> x*y } }
diff --git a/src/test/groovy/transform/stc/TypeInferenceSTCTest.groovy b/src/test/groovy/transform/stc/TypeInferenceSTCTest.groovy
index 6f5c04b652..d167192e7e 100644
--- a/src/test/groovy/transform/stc/TypeInferenceSTCTest.groovy
+++ b/src/test/groovy/transform/stc/TypeInferenceSTCTest.groovy
@@ -86,6 +86,39 @@ class TypeInferenceSTCTest extends StaticTypeCheckingTestCase {
         """
     }
 
+    void testEmbeddedInstanceOf() {
+        assertScript """
+        Object o
+        if (o instanceof Object) {
+            if (o instanceof String) {
+                o.toUpperCase()
+            }
+        }
+        """
+    }
+
+    void testEmbeddedInstanceOf2() {
+        assertScript """
+        Object o
+        if (o instanceof String) {
+            if (true) {
+                o.toUpperCase()
+            }
+        }
+        """
+    }
+
+    void testEmbeddedInstanceOf3() {
+        shouldFailWithMessages '''
+        Object o
+        if (o instanceof String) {
+            if (o instanceof Object) { // causes the inferred type of 'o' to be overwritten
+                o.toUpperCase()
+            }
+        }
+        ''', 'Cannot find matching method java.lang.Object#toUpperCase()'
+    }
+
     void testInstanceOfAfterEach() {
         shouldFailWithMessages '''
             Object o
