diff --git a/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java b/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java
index 89ce6c40c3..2c95b886b0 100644
--- a/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java
+++ b/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java
@@ -197,6 +197,7 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
                     packageDef(node);
                     break;
 
+                case STATIC_IMPORT:
                 case IMPORT:
                     importDef(node);
                     break;
@@ -236,7 +237,7 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
     }
     
     protected void importDef(AST importNode) {
-        // TODO handle static imports
+        boolean isStatic = importNode.getType() == STATIC_IMPORT;
 
         AST node = importNode.getFirstChild();
 
@@ -249,11 +250,11 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
         }
 
         if (node.getNumberOfChildren()==0) {
-            // import is like  "import Foo"
             String name = identifier(node);
+            // import is like  "import Foo"
             ClassNode type = ClassHelper.make(name);
             configureAST(type,importNode);
-            importClass(type,name,alias);
+            importClass(type, name, alias);
             return;
         }
 
@@ -261,17 +262,34 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
         String packageName = qualifiedName(packageNode);
         AST nameNode = packageNode.getNextSibling();
         if (isType(STAR, nameNode)) {
-            // import is like "import foo.*"
-            importPackageWithStar(packageName);
+            if (isStatic) {
+                // import is like "import static foo.Bar.*"
+                // packageName is actually a className in this case
+                ClassNode type = ClassHelper.make(packageName);
+                configureAST(type, importNode);
+                staticImportClassWithStar(type, packageName);
+            } else {
+                // import is like "import foo.*"
+                importPackageWithStar(packageName);
+            }
+
             if (alias!=null) throw new GroovyBugError(
                     "imports like 'import foo.* as Bar' are not "+
                     "supported and should be caught by the grammar");
         } else {
-            // import is like "import foo.Bar"
             String name = identifier(nameNode);
-            ClassNode type = ClassHelper.make(packageName+"."+name);
-            configureAST(type,importNode);
-            importClass(type,name,alias);
+            if (isStatic) {
+                // import is like "import static foo.Bar.method"
+                // packageName is really class name in this case
+                ClassNode type = ClassHelper.make(packageName);
+                configureAST(type, importNode);
+                staticImportMethodOrField(type, name, alias);
+            } else {
+                // import is like "import foo.Bar"
+                ClassNode type = ClassHelper.make(packageName+"."+name);
+                configureAST(type, importNode);
+                importClass(type, name, alias);
+            }
         }
     }
 
@@ -658,7 +676,11 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
         for (AST node = modifierNode.getFirstChild(); node != null; node = node.getNextSibling()) {
             int type = node.getType();
             switch (type) {
-                // annotations
+                case STATIC_IMPORT:
+                    // ignore
+                    break;
+
+                    // annotations
                 case ANNOTATION:
                     annotations.add(annotation(node));
                     break;
diff --git a/src/main/org/codehaus/groovy/ast/ClassNode.java b/src/main/org/codehaus/groovy/ast/ClassNode.java
index daca6683a3..5b2687f3aa 100644
--- a/src/main/org/codehaus/groovy/ast/ClassNode.java
+++ b/src/main/org/codehaus/groovy/ast/ClassNode.java
@@ -907,7 +907,7 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
 
         if (arguments instanceof TupleExpression) {
             TupleExpression tuple = (TupleExpression) arguments;
-            // TODO this won't strictly be true when using list expension in argument calls
+            // TODO this won't strictly be true when using list expansion in argument calls
             count = tuple.getExpressions().size();
         }
         ClassNode node = this;
@@ -924,6 +924,26 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
         return false;
     }
     
+    /**
+     * Returns true if the given method has a possibly matching static method with the given name and arguments
+     */
+    public boolean hasPossibleStaticMethod(String name, Expression arguments) {
+        int count = 0;
+
+        if (arguments instanceof TupleExpression) {
+            TupleExpression tuple = (TupleExpression) arguments;
+            // TODO this won't strictly be true when using list expansion in argument calls
+            count = tuple.getExpressions().size();
+        }
+        for (Iterator iter = getMethods().iterator(); iter.hasNext();) {
+            MethodNode method = (MethodNode) iter.next();
+            if (name.equals(method.getName()) && method.getParameters().length == count && method.isStatic()) {
+                return true;
+            }
+        }
+        return false;
+    }
+
     public boolean isInterface(){
         return (getModifiers() & Opcodes.ACC_INTERFACE) > 0; 
     }
diff --git a/src/main/org/codehaus/groovy/ast/ModuleNode.java b/src/main/org/codehaus/groovy/ast/ModuleNode.java
index 0927953f4f..da3612a9b1 100644
--- a/src/main/org/codehaus/groovy/ast/ModuleNode.java
+++ b/src/main/org/codehaus/groovy/ast/ModuleNode.java
@@ -48,12 +48,7 @@ package org.codehaus.groovy.ast;
 import groovy.lang.Binding;
 
 import java.io.File;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
+import java.util.*;
 
 import org.codehaus.groovy.ast.expr.ArgumentListExpression;
 import org.codehaus.groovy.ast.expr.ClassExpression;
@@ -84,6 +79,9 @@ public class ModuleNode extends ASTNode implements Opcodes {
     private List imports = new ArrayList();
     private List importPackages = new ArrayList();
     private Map importIndex = new HashMap();
+    private Map staticImportAliases = new HashMap();
+    private Map staticImportFields = new LinkedHashMap();
+    private Map staticImportClasses = new LinkedHashMap();
     private CompileUnit unit;
     private String packageName;
     private String description;
@@ -340,4 +338,24 @@ public class ModuleNode extends ASTNode implements Opcodes {
         this.importsResolved = importsResolved;
     }
 
+    public Map getStaticImportAliases() {
+        return staticImportAliases;
+    }
+
+    public Map getStaticImportClasses() {
+        return staticImportClasses;
+    }
+
+    public Map getStaticImportFields() {
+        return staticImportFields;
+    }
+
+    public void addStaticMethodOrField(ClassNode type, String fieldName, String alias) {
+        staticImportAliases.put(alias, type);
+        staticImportFields.put(alias, fieldName);
+    }
+
+    public void addStaticImportClass(String name, ClassNode type) {
+        staticImportClasses.put(name, type);
+    }
 }
diff --git a/src/main/org/codehaus/groovy/control/ResolveVisitor.java b/src/main/org/codehaus/groovy/control/ResolveVisitor.java
index 19fb6b32de..28a27a5006 100644
--- a/src/main/org/codehaus/groovy/control/ResolveVisitor.java
+++ b/src/main/org/codehaus/groovy/control/ResolveVisitor.java
@@ -62,19 +62,7 @@ import org.codehaus.groovy.ast.Parameter;
 import org.codehaus.groovy.ast.PropertyNode;
 import org.codehaus.groovy.ast.Variable;
 import org.codehaus.groovy.ast.VariableScope;
-import org.codehaus.groovy.ast.expr.AnnotationConstantExpression;
-import org.codehaus.groovy.ast.expr.BinaryExpression;
-import org.codehaus.groovy.ast.expr.BooleanExpression;
-import org.codehaus.groovy.ast.expr.ClassExpression;
-import org.codehaus.groovy.ast.expr.ClosureExpression;
-import org.codehaus.groovy.ast.expr.ConstructorCallExpression;
-import org.codehaus.groovy.ast.expr.DeclarationExpression;
-import org.codehaus.groovy.ast.expr.Expression;
-import org.codehaus.groovy.ast.expr.ExpressionTransformer;
-import org.codehaus.groovy.ast.expr.ListExpression;
-import org.codehaus.groovy.ast.expr.MethodCallExpression;
-import org.codehaus.groovy.ast.expr.PropertyExpression;
-import org.codehaus.groovy.ast.expr.VariableExpression;
+import org.codehaus.groovy.ast.expr.*;
 import org.codehaus.groovy.ast.stmt.AssertStatement;
 import org.codehaus.groovy.ast.stmt.BlockStatement;
 import org.codehaus.groovy.ast.stmt.CaseStatement;
@@ -97,8 +85,8 @@ import org.codehaus.groovy.syntax.Types;
  * Visitor to resolve Types and convert VariableExpression to
  * ClassExpressions if needed. The ResolveVisitor will try to
  * find the Class for a ClassExpression and prints an error if
- * it fails to do so. Constructions like C[], foo as C, (C) foo 
- * will force creation of a ClasssExpression for C   
+ * it fails to do so. Constructions like C[], foo as C, (C) foo
+ * will force creation of a ClassExpression for C
  *
  * Note: the method to start the resolving is  startResolving(ClassNode, SourceUnit).
  *
@@ -137,7 +125,7 @@ public class ResolveVisitor extends ClassCodeVisitorSupport implements Expressio
             ClassNode t = paras[i].getType();
             resolveOrFail(t,node);
             if (paras[i].hasInitialExpression()) {
-                Expression init = paras[i].getInitialExpression(); 
+                Expression init = paras[i].getInitialExpression();
                 paras[i].setInitialExpression(transform(init));
             }
         }
@@ -196,13 +184,12 @@ public class ResolveVisitor extends ClassCodeVisitorSupport implements Expressio
         if (prefereImports && resolveAliasFromModule(type)) return;
         resolveOrFail(type,node);
     }
-    
+
     private void resolveOrFail(ClassNode type, ASTNode node) {
         resolveOrFail(type,"",node);
     }
 
     private boolean resolve(ClassNode type) {
-        String name = type.getName();
         return resolve(type,true,true,true);
     }
 
@@ -275,7 +262,7 @@ public class ResolveVisitor extends ClassCodeVisitorSupport implements Expressio
             else {
                 lastMod = source.openConnection().getLastModified();
             }
-            return lastMod > getTimeStamp(cls);            
+            return lastMod > getTimeStamp(cls);
         } catch (IOException e) {
             // if the stream can't be opened, let's keep the old reference
             return false;
@@ -288,7 +275,7 @@ public class ResolveVisitor extends ClassCodeVisitorSupport implements Expressio
         if (cachedClasses.get(name)==NO_CLASS) return false;
         if (cachedClasses.get(name)==SCRIPT) cachedClasses.put(name,NO_CLASS);
         if (name.startsWith("java.")) return type.isResolved();
-        //TODO: don't ignore inner static classes completly
+        //TODO: don't ignore inner static classes completely
         if (name.indexOf('$')!=-1) return type.isResolved();
         ModuleNode module = currentClass.getModule();
         if (module.hasPackageName() && name.indexOf('.')==-1) return type.isResolved();
@@ -354,7 +341,7 @@ public class ResolveVisitor extends ClassCodeVisitorSupport implements Expressio
                 return true;
             } else if (name.equals("BigDecimal")) {
                 type.setRedirect(ClassHelper.BigDecimal_TYPE);
-                return true;    
+                return true;
             }
         }
         return false;
@@ -378,19 +365,19 @@ public class ResolveVisitor extends ClassCodeVisitorSupport implements Expressio
         n.setRedirect(cn);
     }
 
-    private void ambigousClass(ClassNode type, ClassNode iType, String name, boolean resolved){
+    private void ambiguousClass(ClassNode type, ClassNode iType, String name, boolean resolved){
         if (resolved && !type.getName().equals(iType.getName())) {
-            addError("reference to "+name+" is ambigous, both class "+type.getName()+" and "+iType.getName()+" match",type);
+            addError("reference to "+name+" is ambiguous, both class "+type.getName()+" and "+iType.getName()+" match",type);
         } else {
             type.setRedirect(iType);
         }
     }
-    
+
     private boolean resolveAliasFromModule(ClassNode type) {
         ModuleNode module = currentClass.getModule();
         if (module==null) return false;
         String name = type.getName();
-        
+
         // check module node imports aliases
         // the while loop enables a check for inner classes which are not fully imported,
         // but visible as the surrounding class is imported and the inner class is public/protected static
@@ -422,14 +409,78 @@ public class ResolveVisitor extends ClassCodeVisitorSupport implements Expressio
             if (index==-1) break;
         }
          return false;
-        
     }
 
-    private boolean resolveFromModule(ClassNode type, boolean testModuleImports) {
+    private Expression findStaticFieldImportFromModule(String name) {
         ModuleNode module = currentClass.getModule();
-        if (module==null) return false;
+        if (module == null) return null;
+        Map aliases = module.getStaticImportAliases();
+        if (aliases.containsKey(name)) {
+            ClassNode node = (ClassNode) aliases.get(name);
+            Map fields = module.getStaticImportFields();
+            String fieldName = (String) fields.get(name);
+            Expression expression = findStaticField(node, fieldName);
+            if (expression != null) return expression;
+    }
+        Map importedClasses = module.getStaticImportClasses();
+        Iterator it = importedClasses.keySet().iterator();
+        while (it.hasNext()) {
+            String className = (String) it.next();
+            ClassNode node = (ClassNode) importedClasses.get(className);
+            Expression expression = findStaticField(node, name);
+            if (expression != null) return expression;
+        }
+        return null;
+    }
+
+    private Expression findStaticField(ClassNode staticImportType, String fieldName) {
+        if (resolve(staticImportType, true, true, true)) {
+            staticImportType.getFields(); // force init
+            FieldNode field = staticImportType.getField(fieldName);
+            if (field != null && field.isStatic()) {
+                return new PropertyExpression(new ClassExpression(staticImportType), fieldName);
+            }
+        }
+        return null;
+    }
+
+    private Expression findStaticMethodImportFromModule(Expression method, Expression args) {
+        ModuleNode module = currentClass.getModule();
+        if (module == null || !(method instanceof ConstantExpression)) return null;
+        Map aliases = module.getStaticImportAliases();
+        ConstantExpression ce = (ConstantExpression) method;
+        final String name = (String) ce.getValue();
+        if (aliases.containsKey(name)) {
+            ClassNode node = (ClassNode) aliases.get(name);
+            Map fields = module.getStaticImportFields();
+            String fieldName = (String) fields.get(name);
+            Expression expression = findStaticMethod(node, fieldName, args);
+            if (expression != null) return expression;
+        }
+        Map importPackages = module.getStaticImportClasses();
+        Iterator it = importPackages.keySet().iterator();
+        while (it.hasNext()) {
+            String className = (String) it.next();
+            ClassNode starImportType = (ClassNode) importPackages.get(className);
+            Expression expression = findStaticMethod(starImportType, name, args);
+            if (expression != null) return expression;
+        }
+        return null;
+    }
+
+    private Expression findStaticMethod(ClassNode staticImportType, String methodName, Expression args) {
+        if (resolve(staticImportType, true, true, true)) {
+            if (staticImportType.hasPossibleStaticMethod(methodName, args)) {
+                return new StaticMethodCallExpression(staticImportType, methodName, args);
+            }
+        }
+        return null;
+    }
 
+    private boolean resolveFromModule(ClassNode type, boolean testModuleImports) {
         String name = type.getName();
+        ModuleNode module = currentClass.getModule();
+        if (module==null) return false;
 
         if (!type.hasPackageName() && module.hasPackageName()){
             type.setName(module.getPackageName()+name);
@@ -447,9 +498,9 @@ public class ResolveVisitor extends ClassCodeVisitorSupport implements Expressio
 
         if (testModuleImports) {
             if (resolveAliasFromModule(type)) return true;
-            
+
             boolean resolved = false;
-            if (module.hasPackageName()) { 
+            if (module.hasPackageName()) {
                 // check package this class is defined in
                 type.setName(module.getPackageName()+name);
                 resolved = resolve(type,false,false,false);
@@ -462,7 +513,7 @@ public class ResolveVisitor extends ClassCodeVisitorSupport implements Expressio
                 String fqn = packagePrefix+name;
                 iType.setName(fqn);
                 if (resolve(iType,false,false,true)) {
-                	ambigousClass(type,iType,name,resolved);
+                	ambiguousClass(type,iType,name,resolved);
                     return true;
                 }
                 iType.setName(name);
@@ -478,11 +529,10 @@ public class ResolveVisitor extends ClassCodeVisitorSupport implements Expressio
         if (cachedClasses.get(name)==NO_CLASS) return false;
         if (currentClass.getModule().hasPackageName() && name.indexOf('.')==-1) return false;
         GroovyClassLoader loader  = compilationUnit.getClassLoader();
-        Class cls = null;
+        Class cls;
         try {
             // NOTE: it's important to do no lookup against script files
-            // here since the GroovyClassLoader would create a new
-            // CompilationUnit
+            // here since the GroovyClassLoader would create a new CompilationUnit
             cls = loader.loadClass(name,false,true);
         } catch (ClassNotFoundException cnfe) {
             cachedClasses.put(name,SCRIPT);
@@ -490,10 +540,10 @@ public class ResolveVisitor extends ClassCodeVisitorSupport implements Expressio
         } catch (CompilationFailedException cfe) {
             compilationUnit.getErrorCollector().addErrorAndContinue(new ExceptionMessage(cfe,true,source));
             return false;
-        } 
+        }
         //TODO: the case of a NoClassDefFoundError needs a bit more research
         // a simple recompilation is not possible it seems. The current class
-        // we are searching for is there, so we should mark that somehow. 
+        // we are searching for is there, so we should mark that somehow.
         // Basically the missing class needs to be completly compiled before
         // we can again search for the current name.
         /*catch (NoClassDefFoundError ncdfe) {
@@ -548,7 +598,7 @@ public class ResolveVisitor extends ClassCodeVisitorSupport implements Expressio
                 }
                 name= ve.getName()+"."+name;
                 break;
-            } 
+            }
             // anything other than PropertyExpressions, ClassExpression or
             // VariableExpressions will stop resolving
             else if (!(it.getClass()==PropertyExpression.class)) {
@@ -566,8 +616,8 @@ public class ResolveVisitor extends ClassCodeVisitorSupport implements Expressio
         if (name.length()>0) return name.substring(0,name.length()-1);
         return null;
     }
-    
-    // iterate from the outside to the inside and throw an error 
+
+    // iterate from the outside to the inside and throw an error
     // for each VariableExpression that is found but not referenced
     // do this only in a static scope
     private void checkStaticScope(PropertyExpression pe){
@@ -583,7 +633,7 @@ public class ResolveVisitor extends ClassCodeVisitorSupport implements Expressio
     }
 
     // iterate from the inner most to the outer and check for classes
-    // this check will ignore a .class property, for Exmaple Integer.class will be
+    // this check will ignore a .class property, for Example Integer.class will be
     // a PropertyExpression with the ClassExpression of Integer as objectExpression
     // and class as property
     private Expression correctClassClassChain(PropertyExpression pe){
@@ -615,11 +665,11 @@ public class ResolveVisitor extends ClassCodeVisitorSupport implements Expressio
         classPropertyExpressionContainer.setObjectExpression(found);
         return pe;
     }
-    
+
     protected Expression transformPropertyExpression(PropertyExpression pe) {
         boolean itlp = isTopLevelProperty;
         boolean ipe = inPropertyExpression;
-        
+
         Expression objectExpression = pe.getObjectExpression();
         inPropertyExpression = true;
         isTopLevelProperty = !(objectExpression.getClass()==PropertyExpression.class);
@@ -629,18 +679,18 @@ public class ResolveVisitor extends ClassCodeVisitorSupport implements Expressio
         Expression property = transform(pe.getProperty());
         isTopLevelProperty = itlp;
         inPropertyExpression = ipe;
-        
+
         boolean spreadSafe = pe.isSpreadSafe();
         pe = new PropertyExpression(objectExpression,property,pe.isSafe());
         pe.setSpreadSafe(spreadSafe);
-        
+
         String className = lookupClassName(pe);
         if (className!=null) {
             ClassNode type = ClassHelper.make(className);
             if (resolve(type)) return new ClassExpression(type);
-        }  
+        }
         if (objectExpression instanceof ClassExpression && pe.getPropertyAsString()!=null){
-            // possibly a inner class
+            // possibly an inner class
             ClassExpression ce = (ClassExpression) objectExpression;
             ClassNode type = ClassHelper.make(ce.getType().getName()+"$"+pe.getPropertyAsString());
             if (resolve(type,false,false,false)) return new ClassExpression(type);
@@ -649,19 +699,23 @@ public class ResolveVisitor extends ClassCodeVisitorSupport implements Expressio
         if (isTopLevelProperty) {
             checkStaticScope(pe);
             ret = correctClassClassChain(pe);
-        }        
+    }
         return ret;
     }
-       
+
     protected Expression transformVariableExpression(VariableExpression ve) {
         if (ve.getName().equals("this"))  return VariableExpression.THIS_EXPRESSION;
         if (ve.getName().equals("super")) return VariableExpression.SUPER_EXPRESSION;
         Variable v = ve.getAccessedVariable();
         if (v instanceof DynamicVariable) {
+            Expression result = findStaticFieldImportFromModule(ve.getName());
+            if (result != null) {
+                return result;
+            }
             ClassNode t = ClassHelper.make(ve.getName());
             if (resolve(t)) {
                 // the name is a type so remove it from the scoping
-                // as it is only a classvariable, it is only in 
+                // as it is only a classvariable, it is only in
                 // referencedClassVariables, but must be removed
                 // for each parentscope too
                 for (VariableScope scope = currentScope; scope!=null && !scope.isRoot(); scope = scope.getParent()) {
@@ -673,12 +727,12 @@ public class ResolveVisitor extends ClassCodeVisitorSupport implements Expressio
                 return ce;
             } else if (!inPropertyExpression) {
                 addStaticVariableError(ve);
-            } 
-        }
+            }
+            }
         resolveOrFail(ve.getType(),ve);
         return ve;
     }
-    
+
     private void addStaticVariableError(VariableExpression ve){
         // closures are always dynamic
         // propertiesExpressions will handle the error a bit different
@@ -690,11 +744,11 @@ public class ResolveVisitor extends ClassCodeVisitorSupport implements Expressio
                 " scope requires to declare variables before using them. If the variable should have"+
                 " been a class check the spelling.",ve);
     }
-    
+
     protected Expression transformBinaryExpression(BinaryExpression be) {
         Expression left = transform(be.getLeftExpression());
         int type = be.getOperation().getType();
-        if ((type==Types.ASSIGNMENT_OPERATOR || type==Types.EQUAL) && 
+        if ((type==Types.ASSIGNMENT_OPERATOR || type==Types.EQUAL) &&
             left instanceof ClassExpression)
         {
             ClassExpression  ce = (ClassExpression) left;
@@ -704,7 +758,6 @@ public class ResolveVisitor extends ClassCodeVisitorSupport implements Expressio
         if (left instanceof ClassExpression && be.getRightExpression() instanceof ListExpression) {
             // we have C[] if the list is empty -> should be an array then!
             ListExpression list = (ListExpression) be.getRightExpression();
-            ClassExpression ce = (ClassExpression) left;
             if (list.getExpressions().isEmpty()) {
                 return new ClassExpression(left.getType().makeArray());
             }
@@ -714,7 +767,7 @@ public class ResolveVisitor extends ClassCodeVisitorSupport implements Expressio
         ret.setSourcePosition(be);
         return ret;
     }
-    
+
     protected Expression transformClosureExpression(ClosureExpression ce) {
         boolean oldInClosure = inClosure;
         inClosure = true;
@@ -733,27 +786,33 @@ public class ResolveVisitor extends ClassCodeVisitorSupport implements Expressio
         inClosure = oldInClosure;
         return newCe;
     }
-    
+
     protected Expression transformConstructorCallExpression(ConstructorCallExpression cce){
     	ClassNode type = cce.getType();
     	resolveOrFail(type,cce);
-    	Expression expr = cce.transformExpression(this);
-        return expr;
+        return cce.transformExpression(this);
     }
-    
+
     protected Expression transformMethodCallExpression(MethodCallExpression mce) {
-        Expression obj = mce.getObjectExpression();
-        Expression newObject = transform(obj);
         Expression args = transform(mce.getArguments());
         Expression method = transform(mce.getMethod());
-        MethodCallExpression ret = new MethodCallExpression(newObject,method,args);
-        ret.setSafe(mce.isSafe());
-        ret.setImplicitThis(mce.isImplicitThis());
-        ret.setSpreadSafe(mce.isSpreadSafe());
-        ret.setSourcePosition(mce);
+
+        if (mce.isImplicitThis()) {
+            Expression ret = findStaticMethodImportFromModule(method, args);
+            if (ret != null) {
         return ret;
     }
-    
+        }
+        Expression obj = mce.getObjectExpression();
+        Expression newObject = transform(obj);
+        MethodCallExpression result = new MethodCallExpression(newObject,method,args);
+        result.setSafe(mce.isSafe());
+        result.setImplicitThis(mce.isImplicitThis());
+        result.setSpreadSafe(mce.isSpreadSafe());
+        result.setSourcePosition(mce);
+        return result;
+    }
+
     protected Expression transformDeclarationExpression(DeclarationExpression de) {
         Expression oldLeft = de.getLeftExpression();
         Expression left = transform(oldLeft);
@@ -766,25 +825,24 @@ public class ResolveVisitor extends ClassCodeVisitorSupport implements Expressio
         if (right==de.getRightExpression()) return de;
         return new DeclarationExpression((VariableExpression) left,de.getOperation(),right);
     }
-    
+
     protected Expression transformAnnotationConstantExpression(AnnotationConstantExpression ace) {
         AnnotationNode an = (AnnotationNode) ace.getValue();
         ClassNode type = an.getClassNode();
         resolveOrFail(type, "unable to find class for annotation", an);
         for (Iterator iter = an.getMembers().entrySet().iterator(); iter.hasNext();) {
             Map.Entry member = (Map.Entry) iter.next();
-            String memberName = (String) member.getKey();
             Expression memberValue = (Expression) member.getValue();
             member.setValue(transform(memberValue));
-        }  
+        }
 
         return ace;
     }
-    
+
     public void visitAnnotations(AnnotatedNode node) {
         Map annotionMap = node.getAnnotations();
         if (annotionMap.isEmpty()) return;
-        Iterator it = annotionMap.values().iterator(); 
+        Iterator it = annotionMap.values().iterator();
         while (it.hasNext()) {
             AnnotationNode an = (AnnotationNode) it.next();
             //skip builtin properties
@@ -793,17 +851,16 @@ public class ResolveVisitor extends ClassCodeVisitorSupport implements Expressio
             resolveOrFail(type,"unable to find class for annotation",an);
             for (Iterator iter = an.getMembers().entrySet().iterator(); iter.hasNext();) {
                 Map.Entry member = (Map.Entry) iter.next();
-                String memberName = (String) member.getKey();
                 Expression memberValue = (Expression) member.getValue();
                 member.setValue(transform(memberValue));
-            }  
+            }
         }
     }
 
     public void visitClass(ClassNode node) {
         ClassNode oldNode = currentClass;
         currentClass = node;
-        
+
         ModuleNode module = node.getModule();
         if (!module.hasImportsResolved()) {
            List l = module.getImports();
@@ -815,17 +872,17 @@ public class ResolveVisitor extends ClassCodeVisitorSupport implements Expressio
            }
            module.setImportsResolved(true);
         }
-        
+
         ClassNode sn = node.getUnresolvedSuperClass();
         if (sn!=null) resolveOrFail(sn,node,true);
         ClassNode[] interfaces = node.getInterfaces();
         for (int i=0; i<interfaces.length; i++) {
             resolveOrFail(interfaces[i],node,true);
-        }        
+        }
         super.visitClass(node);
-        currentClass = oldNode;        
+        currentClass = oldNode;
     }
-    
+
     public void visitReturnStatement(ReturnStatement statement) {
        statement.setExpression(transform(statement.getExpression()));
     }
@@ -834,7 +891,7 @@ public class ResolveVisitor extends ClassCodeVisitorSupport implements Expressio
         as.setBooleanExpression((BooleanExpression) (transform(as.getBooleanExpression())));
         as.setMessageExpression(transform(as.getMessageExpression()));
     }
-    
+
     public void visitCaseStatement(CaseStatement statement) {
     	statement.setExpression(transform(statement.getExpression()));
     	statement.getCode().visit(this);
@@ -844,7 +901,7 @@ public class ResolveVisitor extends ClassCodeVisitorSupport implements Expressio
         resolveOrFail(cs.getExceptionType(),cs);
         if (cs.getExceptionType()==ClassHelper.DYNAMIC_TYPE) {
             cs.getVariable().setType(ClassHelper.make(Exception.class));
-        } 
+        }
         super.visitCatchStatement(cs);
     }
 
@@ -852,31 +909,31 @@ public class ResolveVisitor extends ClassCodeVisitorSupport implements Expressio
         loop.setBooleanExpression((BooleanExpression) (transform(loop.getBooleanExpression())));
         super.visitDoWhileLoop(loop);
     }
-    
+
     public void visitForLoop(ForStatement forLoop) {
         forLoop.setCollectionExpression(transform(forLoop.getCollectionExpression()));
         resolveOrFail(forLoop.getVariableType(),forLoop);
         super.visitForLoop(forLoop);
     }
-    
+
     public void visitSynchronizedStatement(SynchronizedStatement sync) {
         sync.setExpression(transform(sync.getExpression()));
         super.visitSynchronizedStatement(sync);
     }
-    
+
     public void visitThrowStatement(ThrowStatement ts) {
         ts.setExpression(transform(ts.getExpression()));
     }
-    
+
     public void visitWhileLoop(WhileStatement loop) {
     	loop.setBooleanExpression((BooleanExpression) transform(loop.getBooleanExpression()));
     	super.visitWhileLoop(loop);
     }
-    
+
     public void visitExpressionStatement(ExpressionStatement es) {
         es.setExpression(transform(es.getExpression()));
     }
-    
+
     public void visitBlockStatement(BlockStatement block) {
         VariableScope oldScope = currentScope;
         currentScope = block.getVariableScope();
diff --git a/src/main/org/codehaus/groovy/syntax/ASTHelper.java b/src/main/org/codehaus/groovy/syntax/ASTHelper.java
index 86681174fa..26037d87ed 100644
--- a/src/main/org/codehaus/groovy/syntax/ASTHelper.java
+++ b/src/main/org/codehaus/groovy/syntax/ASTHelper.java
@@ -38,8 +38,6 @@ import java.util.Map;
  */
 public class ASTHelper {
 
-    private static final String[] EMPTY_STRING_ARRAY = new String[0];
-
     /** The SourceUnit controlling us */
     private SourceUnit controller;
 
@@ -47,7 +45,11 @@ public class ASTHelper {
     private ClassLoader classLoader;
 
     /** Our imports, simple name => fully qualified name */
-    private Map imports;
+    protected Map imports;
+    /** Our explicit static imports, simple name => fully qualified name */
+    protected Map staticImports;
+    /** Our implicit static imports */
+    protected List staticDotImports;
     protected ModuleNode output;
 
     /** The package name in which the module sits */
@@ -69,6 +71,8 @@ public class ASTHelper {
 
     public ASTHelper() {
         imports = new HashMap();
+        staticImports = new HashMap();
+        staticDotImports = new ArrayList();
     }
 
     public String getPackageName() {
@@ -293,16 +297,25 @@ public class ASTHelper {
     }
 
     protected void importClass(ClassNode type, String name, String as) {
-        if (as==null) as=name;
+        if (as == null) as=name;
 
         output.addImport(as, type); 
         imports.put(as, type);
     }
 
+    protected void staticImportMethodOrField(ClassNode type, String name, String alias) {
+        if (alias == null) alias = name;
+        output.addStaticMethodOrField(type, name, alias);
+    }
+
+    protected void staticImportClassWithStar(ClassNode type, String importClass) {
+        // keep track of the fact that it was a static import
+        output.addStaticImportClass(importClass, type);
+    }
+
     protected void importPackageWithStar(String importPackage) {
         String[] classes = output.addImportPackage( dot(importPackage) );
-        for( int i = 0; i < classes.length; i++ )
-        {
+        for( int i = 0; i < classes.length; i++ ) {
             imports.put( classes[i], dot(importPackage, classes[i]) );
         }
     }
diff --git a/src/test/groovy/StaticImportTarget.groovy b/src/test/groovy/StaticImportTarget.groovy
new file mode 100644
index 0000000000..158cf6d26b
--- /dev/null
+++ b/src/test/groovy/StaticImportTarget.groovy
@@ -0,0 +1,10 @@
+package groovy
+
+class StaticImportTarget {
+    def static x(String message, int times) {
+        return message * times
+    }
+    def y(String message, int times) {
+        return message * times
+    }
+}
diff --git a/src/test/groovy/StaticImportTest.groovy b/src/test/groovy/StaticImportTest.groovy
new file mode 100644
index 0000000000..1b639fc371
--- /dev/null
+++ b/src/test/groovy/StaticImportTest.groovy
@@ -0,0 +1,43 @@
+package groovy
+
+import static Boolean.FALSE as F
+import static java.text.DateFormat.MEDIUM as M
+import static java.text.DateFormat.MEDIUM
+import static java.awt.Color.*
+import static junit.framework.Assert.format
+import static junit.framework.Assert.assertEquals
+import static StaticImportTarget.x
+
+class StaticImportTest extends GroovyTestCase {
+    void testNormalUsage() {
+        assert !F
+    }
+
+    void testAliasing() {
+        assert MEDIUM == M
+    }
+
+    void testWildCarding() {
+        assert LIGHT_GRAY == java.awt.Color.LIGHT_GRAY
+    }
+
+    private format(a, b, c, ignored) { format(a, b, c) }
+
+    void testMethodSelection() {
+        assert format("different", "abc", "aBc", 3) == 'different expected:<abc> but was:<aBc>'
+    }
+
+    void testAssertEqualsFromJUnit() {
+        double[] values = [3.9999, 4.0001, 0.00021, 0.00019]
+        assertEquals(values[0], values[1], values[2])
+        shouldFail(junit.framework.AssertionFailedError) {
+            assertEquals(values[0], values[1], values[3])
+        }
+    }
+
+    void testStaticImportFromGroovy() {
+        def nonstaticval = new StaticImportTarget().y("he", 3)
+        def staticval = x("he", 3)
+        assert nonstaticval == staticval
+    }
+}
diff --git a/src/test/groovy/StaticMessage.groovy b/src/test/groovy/StaticMessageTest.groovy
similarity index 100%
rename from src/test/groovy/StaticMessage.groovy
rename to src/test/groovy/StaticMessageTest.groovy
diff --git a/src/test/org/codehaus/groovy/antlr/treewalker/UnimplementedSyntaxTest.java b/src/test/org/codehaus/groovy/antlr/treewalker/UnimplementedSyntaxTest.java
index 765cff1690..eb0062ba6b 100644
--- a/src/test/org/codehaus/groovy/antlr/treewalker/UnimplementedSyntaxTest.java
+++ b/src/test/org/codehaus/groovy/antlr/treewalker/UnimplementedSyntaxTest.java
@@ -229,16 +229,13 @@ public class UnimplementedSyntaxTest extends GroovyTestCase {
     // -----------------------
     // feature: static imports
     // -----------------------
-    public void test_StaticImport1_FAILS() throws Exception {
-        if (notYetImplemented()) return;
-        // Unknown type: STATIC_IMPORT
-        assertNotNull(compile("import static foo.Bar.mooky")); // fails after parser
+    // TODO: move somewhere else
+    public void test_StaticImport1() throws Exception {
+        assertNotNull(compile("import static foo.Bar.mooky"));
     }
 
-    public void test_StaticImport2_FAILS() throws Exception {
-        if (notYetImplemented()) return;
-        // Unknown type: STATIC_IMPORT
-        assertNotNull(compile("import static foo.Bar.*")); // fails after parser
+    public void test_StaticImport2() throws Exception {
+        assertNotNull(compile("import static foo.Bar.*"));
     }
 
     // ------------------------
