diff --git a/src/main/java/groovy/lang/Closure.java b/src/main/java/groovy/lang/Closure.java
index da59968b6c..7debb91130 100644
--- a/src/main/java/groovy/lang/Closure.java
+++ b/src/main/java/groovy/lang/Closure.java
@@ -300,9 +300,9 @@ public abstract class Closure<V> extends GroovyObjectSupport implements Cloneabl
             case DELEGATE_FIRST:
                 return getPropertyDelegateFirst(property);
             case DELEGATE_ONLY:
-                return InvokerHelper.getProperty(this.delegate, property);
+                return InvokerHelper.getProperty(getDelegate(), property);
             case OWNER_ONLY:
-                return InvokerHelper.getProperty(this.owner, property);
+                return InvokerHelper.getProperty(getOwner(), property);
             case TO_SELF:
                 return super.getProperty(property);
             default:
@@ -312,11 +312,11 @@ public abstract class Closure<V> extends GroovyObjectSupport implements Cloneabl
 
     private Object getPropertyDelegateFirst(String property) {
         if (delegate == null) return getPropertyOwnerFirst(property);
-        return getPropertyTryThese(property, this.delegate, this.owner);
+        return getPropertyTryThese(property, getDelegate(), getOwner());
     }
 
     private Object getPropertyOwnerFirst(String property) {
-        return getPropertyTryThese(property, this.owner, this.delegate);
+        return getPropertyTryThese(property, getOwner(), getDelegate());
     }
 
     private Object getPropertyTryThese(String property, Object firstTry, Object secondTry) {
@@ -354,10 +354,10 @@ public abstract class Closure<V> extends GroovyObjectSupport implements Cloneabl
                     setPropertyDelegateFirst(property, newValue);
                 break;
                 case DELEGATE_ONLY:
-                    InvokerHelper.setProperty(this.delegate, property, newValue);
+                    InvokerHelper.setProperty(getDelegate(), property, newValue);
                 break;
                 case OWNER_ONLY:
-                    InvokerHelper.setProperty(this.owner, property, newValue);
+                    InvokerHelper.setProperty(getOwner(), property, newValue);
                 break;
                 case TO_SELF:
                     super.setProperty(property, newValue);
@@ -370,11 +370,11 @@ public abstract class Closure<V> extends GroovyObjectSupport implements Cloneabl
 
     private void setPropertyDelegateFirst(String property, Object newValue) {
         if (delegate == null) setPropertyOwnerFirst(property, newValue);
-        else setPropertyTryThese(property, newValue, this.delegate, this.owner);
+        else setPropertyTryThese(property, newValue, getDelegate(), getOwner());
     }
 
     private void setPropertyOwnerFirst(String property, Object newValue) {
-        setPropertyTryThese(property, newValue, this.owner, this.delegate);
+        setPropertyTryThese(property, newValue, getOwner(), getDelegate());
     }
 
     private void setPropertyTryThese(String property, Object newValue, Object firstTry, Object secondTry) {
@@ -1112,8 +1112,8 @@ public abstract class Closure<V> extends GroovyObjectSupport implements Cloneabl
      *
      * @since 1.8.5
      */
-    @SuppressWarnings("unchecked")
     public Closure<V> dehydrate() {
+        @SuppressWarnings("unchecked")
         Closure<V> result = (Closure<V>) this.clone();
         result.delegate = null;
         result.owner = null;
@@ -1133,8 +1133,8 @@ public abstract class Closure<V> extends GroovyObjectSupport implements Cloneabl
      *
      * @since 1.8.5
      */
-    @SuppressWarnings("unchecked")
     public Closure<V> rehydrate(Object delegate, Object owner, Object thisObject) {
+        @SuppressWarnings("unchecked")
         Closure<V> result = (Closure<V>) this.clone();
         result.delegate = delegate;
         result.owner = owner;
diff --git a/src/main/java/groovy/lang/MetaClassImpl.java b/src/main/java/groovy/lang/MetaClassImpl.java
index b6a5257bff..86b8e113c2 100644
--- a/src/main/java/groovy/lang/MetaClassImpl.java
+++ b/src/main/java/groovy/lang/MetaClassImpl.java
@@ -1001,11 +1001,11 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
     }
 
     private Object invokeMethodClosure(final MethodClosure object, final Object[] arguments) {
-        Object owner = object.getOwner();
-        String method = object.getMethod();
-        boolean ownerIsClass = (owner instanceof Class);
-        Class ownerClass = ownerIsClass ? (Class) owner : owner.getClass();
-        final MetaClass ownerMetaClass = registry.getMetaClass(ownerClass);
+        var owner = object.getOwner();
+        var method = object.getMethod();
+        var ownerClass = object.getOwnerClass();
+        var ownerIsClass = (owner instanceof Class);
+        var ownerMetaClass = registry.getMetaClass(ownerClass);
         try {
             return ownerMetaClass.invokeMethod(ownerClass, owner, method, arguments, false, false);
         } catch (GroovyRuntimeException e) { // GroovyRuntimeException(cause:IllegalArgumentException) thrown for final fields
@@ -1027,7 +1027,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
                 if (arrayDimension < nArguments) {
                     throw new GroovyRuntimeException("The length[" + nArguments + "] of arguments should not be greater than the dimensions[" + arrayDimension + "] of array[" + ownerClass.getCanonicalName() + "]");
                 }
-                Class elementType = arrayDimension == nArguments
+                var elementType = arrayDimension == nArguments
                         ? ArrayTypeUtils.elementType(ownerClass)
                         : ArrayTypeUtils.elementType(ownerClass, arrayDimension - nArguments);
                 return Array.newInstance(elementType, Arrays.stream(arguments).mapToInt(argument ->
diff --git a/src/main/java/org/codehaus/groovy/classgen/asm/MethodPointerExpressionWriter.java b/src/main/java/org/codehaus/groovy/classgen/asm/MethodPointerExpressionWriter.java
index d0bfd4f6bf..f66c2ab7eb 100644
--- a/src/main/java/org/codehaus/groovy/classgen/asm/MethodPointerExpressionWriter.java
+++ b/src/main/java/org/codehaus/groovy/classgen/asm/MethodPointerExpressionWriter.java
@@ -22,6 +22,9 @@ import org.codehaus.groovy.ast.expr.MethodPointerExpression;
 import org.codehaus.groovy.runtime.ScriptBytecodeAdapter;
 
 import static org.codehaus.groovy.ast.ClassHelper.CLOSURE_TYPE;
+import static org.codehaus.groovy.ast.ClassHelper.isClassType;
+import static org.codehaus.groovy.ast.ClassHelper.isObjectType;
+import static org.codehaus.groovy.ast.tools.GeneralUtils.varX;
 
 /**
  * Generates bytecode for method pointer expressions.
@@ -43,6 +46,12 @@ public class MethodPointerExpressionWriter {
         OperandStack operandStack = controller.getOperandStack();
         operandStack.box();
 
+        var type = operandStack.getTopOperand();
+        if (!isClassType(type) && !isObjectType(type)) {
+            // GROOVY-5051, GROOVY-10568: retain static type
+            controller.getAcg().loadWrapper(varX("", type));
+        }
+
         operandStack.pushDynamicName(pointerOrReference.getMethodName());
         // delegate to ScriptBytecodeAdapter#getMethodPointer
         getMethodPointer.call(controller.getMethodVisitor());
diff --git a/src/main/java/org/codehaus/groovy/runtime/MethodClosure.java b/src/main/java/org/codehaus/groovy/runtime/MethodClosure.java
index 897c22f852..5f0efb60ff 100644
--- a/src/main/java/org/codehaus/groovy/runtime/MethodClosure.java
+++ b/src/main/java/org/codehaus/groovy/runtime/MethodClosure.java
@@ -21,6 +21,7 @@ package org.codehaus.groovy.runtime;
 import groovy.lang.Closure;
 import groovy.lang.MetaMethod;
 import org.codehaus.groovy.reflection.ReflectionCache;
+import org.codehaus.groovy.runtime.wrappers.Wrapper;
 
 import java.util.Arrays;
 
@@ -53,22 +54,21 @@ public class MethodClosure extends Closure {
         this.maximumNumberOfParameters = 0;
         this.parameterTypes = MetaClassHelper.EMPTY_TYPE_ARRAY;
 
-        Class<?> theClass = owner.getClass();
-        if (theClass == Class.class) theClass = (Class<?>) owner;
+        var ownerClass = getOwnerClass();
 
         if (method.equals(NEW)) {
-            if (theClass.isArray()) {
-                Class<?>[] sizeTypes = new Class[ArrayTypeUtils.dimension(theClass)];
+            if (ownerClass.isArray()) {
+                Class<?>[] sizeTypes = new Class[ArrayTypeUtils.dimension(ownerClass)];
                 Arrays.fill(sizeTypes, int.class);
                 setParameterTypesAndNumber(sizeTypes);
             } else {
-                for (var c : ReflectionCache.getCachedClass(theClass).getConstructors()) {
+                for (var c : ReflectionCache.getCachedClass(ownerClass).getConstructors()) {
                     setParameterTypesAndNumber(c.getNativeParameterTypes());
                 }
             }
         } else {
-            for (var m : InvokerHelper.getMetaClass(theClass).respondsTo(owner, method)) {
-                setParameterTypesAndNumber(makeParameterTypes(owner, m));
+            for (var m : InvokerHelper.getMetaClass(ownerClass).respondsTo(getOwner(), method)) {
+                setParameterTypesAndNumber(makeParameterTypes(getOwner(), m));
                 if (!m.isStatic()) {
                     this.anyInstanceMethodExists = true;
                 }
@@ -88,7 +88,7 @@ public class MethodClosure extends Closure {
      * String) and the method is instance method, we expand the original array of
      * parameter type by inserting the owner at the first position of the array.
      */
-    private Class[] makeParameterTypes(final Object owner, final MetaMethod m) {
+    private static Class[] makeParameterTypes(final Object owner, final MetaMethod m) {
         Class[] newParameterTypes;
 
         if (owner instanceof Class && !m.isStatic()) {
@@ -110,6 +110,27 @@ public class MethodClosure extends Closure {
         return method;
     }
 
+    @Override
+    public Object getOwner() {
+        var owner = super.getOwner();
+        if (owner instanceof Wrapper) {
+            owner = ((Wrapper) owner).unwrap(); // GROOVY-5051
+        }
+        return owner;
+    }
+
+    /**
+     * @since 5.0.0
+     */
+    public Class<?> getOwnerClass() {
+        var owner = super.getOwner();
+        if (owner instanceof Wrapper) {
+            return ((Wrapper) owner).getType(); // GROOVY-5051
+        }
+        var theClass = owner.getClass();
+        return (theClass == Class.class ? (Class<?>) owner : theClass);
+    }
+
     @Override
     public Object getProperty(final String property) {
         switch (property) {
diff --git a/src/main/java/org/codehaus/groovy/runtime/metaclass/ClosureMetaMethod.java b/src/main/java/org/codehaus/groovy/runtime/metaclass/ClosureMetaMethod.java
index 0e1bcca9c4..616652fe31 100644
--- a/src/main/java/org/codehaus/groovy/runtime/metaclass/ClosureMetaMethod.java
+++ b/src/main/java/org/codehaus/groovy/runtime/metaclass/ClosureMetaMethod.java
@@ -99,33 +99,26 @@ public class ClosureMetaMethod extends MetaMethod implements ClosureInvokingMeth
     }
 
     public static List<MetaMethod> createMethodList(final String name, final Class declaringClass, final Closure closure) {
-        List<MetaMethod> res = new ArrayList<MetaMethod>();
+        List<MetaMethod> mms = new ArrayList<>();
         if (closure instanceof MethodClosure) {
-            MethodClosure methodClosure = (MethodClosure) closure;
-            Object owner = closure.getOwner();
-            Class ownerClass = (Class) (owner instanceof Class ? owner : owner.getClass());
-            for (CachedMethod method : ReflectionCache.getCachedClass(ownerClass).getMethods() ) {
-                if (method.getName().equals(methodClosure.getMethod())) {
+            for (CachedMethod method : ReflectionCache.getCachedClass(((MethodClosure) closure).getOwnerClass()).getMethods()) {
+                if (method.getName().equals(((MethodClosure) closure).getMethod())) {
                     MetaMethod metaMethod = new MethodClosureMetaMethod(name, declaringClass, closure, method);
-                    res.add(adjustParamTypesForStdMethods(metaMethod, name));
+                    mms.add(adjustParamTypesForStdMethods(metaMethod, name));
                 }
             }
-        }
-        else {
-            if (closure instanceof GeneratedClosure) {
-                for (CachedMethod method : ReflectionCache.getCachedClass(closure.getClass()).getMethods() ) {
-                    if (method.getName().equals("doCall")) {
-                        MetaMethod metaMethod = new ClosureMetaMethod(name, declaringClass, closure, method);
-                        res.add(adjustParamTypesForStdMethods(metaMethod, name));
-                    }
+        } else if (closure instanceof GeneratedClosure) {
+            for (CachedMethod method : ReflectionCache.getCachedClass(closure.getClass()).getMethods()) {
+                if (method.getName().equals("doCall")) {
+                    MetaMethod metaMethod = new ClosureMetaMethod(name, declaringClass, closure, method);
+                    mms.add(adjustParamTypesForStdMethods(metaMethod, name));
                 }
             }
-            else {
-                MetaMethod metaMethod = new AnonymousMetaMethod(closure, name, declaringClass);
-                res.add(adjustParamTypesForStdMethods(metaMethod, name));
-            }
+        } else {
+            MetaMethod metaMethod = new AnonymousMetaMethod(closure, name, declaringClass);
+            mms.add(adjustParamTypesForStdMethods(metaMethod, name));
         }
-        return res;
+        return mms;
     }
 
     private static MetaMethod adjustParamTypesForStdMethods(MetaMethod metaMethod, String methodName) {
diff --git a/src/test/groovy/ClosureCurryTest.groovy b/src/test/groovy/ClosureCurryTest.groovy
index 20b5abbd76..96221fed46 100644
--- a/src/test/groovy/ClosureCurryTest.groovy
+++ b/src/test/groovy/ClosureCurryTest.groovy
@@ -288,7 +288,7 @@ final class ClosureCurryTest {
                     println p
                 }
                 void test() {
-                    def proc = C.&m.curry(this, 'x') // was "this.&m.curry('x')"
+                    def proc = this.&m.curry('x')
                     proc()
                 }
             }
