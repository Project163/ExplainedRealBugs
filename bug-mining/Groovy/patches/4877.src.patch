diff --git a/src/main/java/org/codehaus/groovy/classgen/AsmClassGenerator.java b/src/main/java/org/codehaus/groovy/classgen/AsmClassGenerator.java
index d4410759c9..25dc4d0003 100644
--- a/src/main/java/org/codehaus/groovy/classgen/AsmClassGenerator.java
+++ b/src/main/java/org/codehaus/groovy/classgen/AsmClassGenerator.java
@@ -1221,7 +1221,7 @@ public class AsmClassGenerator extends ClassGenerator {
                 if (isThisExpression(objectExpression)) {
                     if (controller.isInGeneratedFunction()) { // params/variables are stored as fields
                         if (expression.isImplicitThis()) fieldNode = classNode.getDeclaredField(name);
-                    } else {
+                    } else if (!expression.isSpreadSafe()) {
                         fieldNode = classNode.getDeclaredField(name);
                         // GROOVY-8448: "this.name" from anon. inner class
                         if (fieldNode != null && !expression.isImplicitThis()
diff --git a/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java b/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java
index ab190ee44b..6b69b78a22 100644
--- a/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java
+++ b/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java
@@ -99,6 +99,7 @@ import static org.objectweb.asm.Opcodes.ACONST_NULL;
 import static org.objectweb.asm.Opcodes.ALOAD;
 import static org.objectweb.asm.Opcodes.CHECKCAST;
 import static org.objectweb.asm.Opcodes.GOTO;
+import static org.objectweb.asm.Opcodes.IFNONNULL;
 import static org.objectweb.asm.Opcodes.IFNULL;
 import static org.objectweb.asm.Opcodes.INVOKESTATIC;
 
@@ -485,70 +486,89 @@ public class StaticInvocationWriter extends InvocationWriter {
             return;
         }
         // if call is spread safe, replace it with a for in loop
-        if (spreadSafe && origin instanceof MethodCallExpression) {
-            // receiver expressions with side effects should not be visited twice, avoid by using a temporary variable
+        if (spreadSafe && (origin instanceof MethodCallExpression || (origin instanceof PropertyExpression && !controller.getCompileStack().isLHS()))) {
+            // receiver expressions with side-effects should not be re-visited; avoid by using a temporary variable
             Expression tmpReceiver = receiver;
-            if (!(receiver instanceof VariableExpression) && !(receiver instanceof ConstantExpression)) {
+            if (!(receiver instanceof VariableExpression || receiver instanceof ConstantExpression)) {
                 tmpReceiver = new TemporaryVariableExpression(receiver);
             }
+
+            Label nonNull = new Label();
+            Label allDone = new Label();
             MethodVisitor mv = controller.getMethodVisitor();
-            CompileStack compileStack = controller.getCompileStack();
-            TypeChooser typeChooser = controller.getTypeChooser();
             OperandStack operandStack = controller.getOperandStack();
-            ClassNode classNode = controller.getClassNode();
-            int counter = labelCounter.incrementAndGet();
 
-            // use a temporary variable for the arraylist in which the results of the spread call will be stored
+            // if (receiver == null)
+            tmpReceiver.visit(controller.getAcg());
+            mv.visitJumpInsn(IFNONNULL, nonNull);
+            operandStack.remove(1);
+
+            // result is null
+            mv.visitInsn(ACONST_NULL);
+            mv.visitJumpInsn(GOTO, allDone);
+
+            // else
+            mv.visitLabel(nonNull);
+
+            ClassNode resultType = origin.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);
+            ClassNode valuesType = origin.getNodeMetaData(StaticCompilationMetadataKeys.COMPONENT_TYPE);
+            if (valuesType == null) valuesType = StaticTypeCheckingVisitor.inferLoopElementType(resultType);
+
+            // def result = new ArrayList()
             ConstructorCallExpression cce = ctorX(StaticCompilationVisitor.ARRAYLIST_CLASSNODE);
-            cce.setNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET, StaticCompilationVisitor.ARRAYLIST_CONSTRUCTOR);
-            TemporaryVariableExpression result = new TemporaryVariableExpression(cce);
+            cce.putNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET,
+                    StaticCompilationVisitor.ARRAYLIST_CONSTRUCTOR);
+            var result = new TemporaryVariableExpression(cce);
             result.visit(controller.getAcg());
-            operandStack.pop();
-            // if (receiver != null)
-            tmpReceiver.visit(controller.getAcg());
-            Label ifnull = compileStack.createLocalLabel("ifnull_" + counter);
-            mv.visitJumpInsn(IFNULL, ifnull);
-            operandStack.remove(1); // receiver consumed by if()
-            Label nonull = compileStack.createLocalLabel("nonull_" + counter);
-            mv.visitLabel(nonull);
-            ClassNode componentType = StaticTypeCheckingVisitor.inferLoopElementType(typeChooser.resolveType(tmpReceiver, classNode));
-            Parameter iterator = new Parameter(componentType, "for$it$" + counter);
-            VariableExpression iteratorAsVar = varX(iterator);
-            MethodCallExpression origMCE = (MethodCallExpression) origin;
-            MethodCallExpression newMCE = callX(
-                    iteratorAsVar,
-                    origMCE.getMethodAsString(),
-                    origMCE.getArguments()
-            );
-            newMCE.setImplicitThis(false);
-            newMCE.setMethodTarget(origMCE.getMethodTarget());
-            newMCE.setSafe(true);
-            MethodCallExpression add = callX(
-                    result,
-                    "add",
-                    newMCE
-            );
-            add.setImplicitThis(false);
-            add.setMethodTarget(StaticCompilationVisitor.ARRAYLIST_ADD_METHOD);
-            // for (e in receiver) { result.add(e?.method(arguments) }
-            ForStatement stmt = new ForStatement(
-                    iterator,
+
+            ClassNode elementType = StaticTypeCheckingVisitor.inferLoopElementType(controller.getTypeChooser().resolveType(receiver, controller.getClassNode()));
+            Parameter element = new Parameter(elementType, "for$it$" + labelCounter.incrementAndGet());
+
+            Expression nextValue;
+            if (origin instanceof MethodCallExpression) {
+                MethodCallExpression oldMCE = (MethodCallExpression) origin;
+                MethodCallExpression newMCE = callX(
+                        varX(element),
+                        oldMCE.getMethod(),
+                        oldMCE.getArguments()
+                );
+                newMCE.setImplicitThis(false);
+                MethodNode target = oldMCE.getMethodTarget();
+                newMCE.setMethodTarget(target);
+                if (target == null || !target.isVoidMethod())
+                    newMCE.setNodeMetaData(StaticTypesMarker.INFERRED_TYPE, valuesType);
+                newMCE.setSafe(true);
+                nextValue = newMCE;
+            } else {
+                PropertyExpression oldPE = (PropertyExpression) origin;
+                PropertyExpression newPE = origin instanceof AttributeExpression
+                    ? new AttributeExpression(varX(element), oldPE.getProperty(), true)
+                    : new  PropertyExpression(varX(element), oldPE.getProperty(), true);
+                newPE.setImplicitThis(false);
+                newPE.setNodeMetaData(StaticTypesMarker.INFERRED_TYPE, valuesType);
+                nextValue = newPE;
+            }
+
+            MethodCallExpression addNextValue = callX(result, "add", /*castX(valuesType, */nextValue/*)*/);
+            addNextValue.setImplicitThis(false);
+            addNextValue.setMethodTarget(StaticCompilationVisitor.ARRAYLIST_ADD_METHOD);
+
+            // for (element in receiver) result.add(element?.method(arguments));
+            var stmt = new ForStatement(
+                    element,
                     tmpReceiver,
-                    stmt(add)
+                    stmt(addNextValue)
             );
             stmt.visit(controller.getAcg());
-            // else { empty list }
-            mv.visitLabel(ifnull);
+
+            result.remove(controller);
 
             // end of if/else
-            // return result list
-            result.visit(controller.getAcg());
+            mv.visitLabel(allDone);
 
-            // cleanup temporary variables
             if (tmpReceiver instanceof TemporaryVariableExpression) {
                 ((TemporaryVariableExpression) tmpReceiver).remove(controller);
             }
-            result.remove(controller);
         } else if (safe && origin instanceof MethodCallExpression) {
             // wrap call in an IFNULL check
             MethodVisitor mv = controller.getMethodVisitor();
diff --git a/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java b/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
index 17f3f79072..8afbfa7de5 100644
--- a/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
+++ b/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
@@ -48,7 +48,6 @@ import org.codehaus.groovy.transform.stc.StaticTypesMarker;
 import org.objectweb.asm.Label;
 import org.objectweb.asm.MethodVisitor;
 
-import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 import java.util.function.BiPredicate;
@@ -88,8 +87,10 @@ import static org.codehaus.groovy.ast.tools.GeneralUtils.isOrImplements;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.nullX;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.propX;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.varX;
+import static org.codehaus.groovy.transform.sc.StaticCompilationVisitor.ARRAYLIST_CLASSNODE;
 import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.findDGMMethodsByNameAndArguments;
 import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.isClassClassNodeWrappingConcreteType;
+import static org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor.inferLoopElementType;
 import static org.objectweb.asm.Opcodes.AALOAD;
 import static org.objectweb.asm.Opcodes.ACC_PUBLIC;
 import static org.objectweb.asm.Opcodes.ACC_STATIC;
@@ -249,76 +250,79 @@ public class StaticTypesCallSiteWriter extends CallSiteWriter {
         //   result
         ClassNode componentType = receiver.getNodeMetaData(StaticCompilationMetadataKeys.COMPONENT_TYPE);
         if (componentType == null) {
-            componentType = OBJECT_TYPE;
+            componentType = inferLoopElementType(controller.getTypeChooser().resolveType(receiver, controller.getClassNode()));
         }
         CompileStack compileStack = controller.getCompileStack();
+        OperandStack operandStack = controller.getOperandStack();
         MethodVisitor mv = controller.getMethodVisitor();
 
-        Label exit = new Label();
+        Label allDone = new Label();
         if (safe) {
+            Label nonNull = new Label();
             receiver.visit(controller.getAcg());
-            Label doGet = new Label();
-            mv.visitJumpInsn(IFNONNULL, doGet);
-            controller.getOperandStack().remove(1);
+            mv.visitJumpInsn(IFNONNULL, nonNull);
+            operandStack.remove(1);
+
             mv.visitInsn(ACONST_NULL);
-            mv.visitJumpInsn(GOTO, exit);
-            mv.visitLabel(doGet);
+            mv.visitJumpInsn(GOTO, allDone);
+            mv.visitLabel(nonNull);
         }
 
-        Variable tmpList = varX("tmpList", ClassHelper.make(ArrayList.class));
-        int var = compileStack.defineTemporaryVariable(tmpList, false);
+        Variable tmpList = varX("tmpList", ARRAYLIST_CLASSNODE);
+        int list = compileStack.defineTemporaryVariable(tmpList, false);
         Variable iterator = varX("iterator", Iterator_TYPE);
-        int it = compileStack.defineTemporaryVariable(iterator, false);
+        int iter = compileStack.defineTemporaryVariable(iterator, false);
         Variable nextVar = varX("next", componentType);
-        final int next = compileStack.defineTemporaryVariable(nextVar, false);
+        int next = compileStack.defineTemporaryVariable(nextVar, false);
 
         mv.visitTypeInsn(NEW, "java/util/ArrayList");
         mv.visitInsn(DUP);
         receiver.visit(controller.getAcg());
         mv.visitMethodInsn(INVOKEINTERFACE, "java/util/List", "size", "()I", true);
-        controller.getOperandStack().remove(1);
+        operandStack.remove(1);
         mv.visitMethodInsn(INVOKESPECIAL, "java/util/ArrayList", "<init>", "(I)V", false);
-        mv.visitVarInsn(ASTORE, var);
+        mv.visitVarInsn(ASTORE, list);
         Label l1 = new Label();
         mv.visitLabel(l1);
         receiver.visit(controller.getAcg());
         mv.visitMethodInsn(INVOKEINTERFACE, "java/util/List", "iterator", "()Ljava/util/Iterator;", true);
-        controller.getOperandStack().remove(1);
-        mv.visitVarInsn(ASTORE, it);
+        operandStack.remove(1);
+        mv.visitVarInsn(ASTORE, iter);
         Label l2 = new Label();
         mv.visitLabel(l2);
-        mv.visitVarInsn(ALOAD, it);
+        mv.visitVarInsn(ALOAD, iter);
         mv.visitMethodInsn(INVOKEINTERFACE, "java/util/Iterator", "hasNext", "()Z", true);
         Label l3 = new Label();
         mv.visitJumpInsn(IFEQ, l3);
-        mv.visitVarInsn(ALOAD, it);
+        mv.visitVarInsn(ALOAD, iter);
         mv.visitMethodInsn(INVOKEINTERFACE, "java/util/Iterator", "next", "()Ljava/lang/Object;", true);
         mv.visitTypeInsn(CHECKCAST, BytecodeHelper.getClassInternalName(componentType));
         mv.visitVarInsn(ASTORE, next);
         Label l4 = new Label();
         mv.visitLabel(l4);
-        mv.visitVarInsn(ALOAD, var);
-        PropertyExpression pexp = propX(
+        mv.visitVarInsn(ALOAD, list);
+        Expression pexp = propX(
                 bytecodeX(componentType, v -> v.visitVarInsn(ALOAD, next)),
                 propertyName
         );
         pexp.visit(controller.getAcg());
-        controller.getOperandStack().box();
-        controller.getOperandStack().remove(1);
+        operandStack.box();
+        operandStack.remove(1);
         mv.visitMethodInsn(INVOKEINTERFACE, "java/util/List", "add", "(Ljava/lang/Object;)Z", true);
         mv.visitInsn(POP);
         Label l5 = new Label();
         mv.visitLabel(l5);
         mv.visitJumpInsn(GOTO, l2);
         mv.visitLabel(l3);
-        mv.visitVarInsn(ALOAD, var);
+        mv.visitVarInsn(ALOAD, list);
         if (safe) {
-            mv.visitLabel(exit);
+            mv.visitLabel(allDone);
         }
-        controller.getOperandStack().push(ClassHelper.make(ArrayList.class));
-        controller.getCompileStack().removeVar(next);
-        controller.getCompileStack().removeVar(it);
-        controller.getCompileStack().removeVar(var);
+        operandStack.push(ARRAYLIST_CLASSNODE);
+
+        compileStack.removeVar(next);
+        compileStack.removeVar(iter);
+        compileStack.removeVar(list);
     }
 
     private boolean makeGetPrivateFieldWithBridgeMethod(final Expression receiver, final ClassNode receiverType, final String fieldName, final boolean safe, final boolean implicitThis) {
diff --git a/src/test/groovy/transform/stc/ArraysAndCollectionsSTCTest.groovy b/src/test/groovy/transform/stc/ArraysAndCollectionsSTCTest.groovy
index 6f6bd77083..c9963d1282 100644
--- a/src/test/groovy/transform/stc/ArraysAndCollectionsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/ArraysAndCollectionsSTCTest.groovy
@@ -286,6 +286,43 @@ class ArraysAndCollectionsSTCTest extends StaticTypeCheckingTestCase {
         '''
     }
 
+    // GROOVY-11453
+    void testListStarWithNull() {
+        assertScript '''
+            List<String> strings = null
+            List<byte[]> bArrays = strings*.bytes
+            assert bArrays == null
+        '''
+    }
+
+    void testListStarWithMethodReturningVoid() {
+        assertScript '''
+            class C { void m() {} }
+            List<C> objects = [new C(),new C(),new C()]
+            List<?> returns = objects*.m()
+            assert  returns == [null,null,null]
+        '''
+    }
+
+    void testListStarWithMethodWithNullInList() {
+        assertScript '''
+            List<String> strings = ['a',(String)null,'C']
+            List<String> returns = strings*.toUpperCase()
+            assert returns == ['A',null,'C']
+        '''
+    }
+
+    // GROOVY-7442
+    void testSpreadSafeMethodCallWithinAssert() {
+        assertScript '''
+            def myMethod(String a, String b) {
+                assert [a, b]*.size() == [5, 5]
+            }
+
+            myMethod('hello', 'world')
+        '''
+    }
+
     void testInlineMap() {
         assertScript '''
             Map map = [a:1, b:2]
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/ArraysAndCollectionsStaticCompileTest.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/ArraysAndCollectionsStaticCompileTest.groovy
index 2dba5ad2fa..aa0681cb39 100644
--- a/src/test/org/codehaus/groovy/classgen/asm/sc/ArraysAndCollectionsStaticCompileTest.groovy
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/ArraysAndCollectionsStaticCompileTest.groovy
@@ -25,23 +25,6 @@ import groovy.transform.stc.ArraysAndCollectionsSTCTest
  */
 final class ArraysAndCollectionsStaticCompileTest extends ArraysAndCollectionsSTCTest implements StaticCompilationTestSupport {
 
-    void testListStarWithMethodReturningVoid() {
-        assertScript '''
-            class A { void m() {} }
-            List<A> elems = [new A(), new A(), new A()]
-            List result = elems*.m()
-            assert result == [null,null,null]
-        '''
-    }
-
-    void testListStarWithMethodWithNullInList() {
-        assertScript '''
-            List<String> elems = ['a',(String)null,'C']
-            List<String> result = elems*.toUpperCase()
-            assert result == ['A',null,'C']
-        '''
-    }
-
     void testShouldNotThrowVerifyError() {
         assertScript '''
             def al = new ArrayList<Double>()
@@ -94,17 +77,6 @@ final class ArraysAndCollectionsStaticCompileTest extends ArraysAndCollectionsST
         assert astTrees['Foo'][1].count('ScriptBytecodeAdapter.createList') == 4
     }
 
-    // GROOVY-7442
-    void testSpreadDotOperatorWithinAssert() {
-        assertScript '''
-            def myMethod(String a, String b) {
-                assert [a, b]*.size() == [5, 5]
-            }
-
-            myMethod('hello', 'world')
-        '''
-    }
-
     // GROOVY-7688
     void testSpreadSafeMethodCallReceiversWithSideEffectsShouldNotBeVisitedTwice() {
         assertScript '''
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7324Bug.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7324Bug.groovy
index 74be12a546..4f225ccdf7 100644
--- a/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7324Bug.groovy
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7324Bug.groovy
@@ -16,61 +16,51 @@
  *  specific language governing permissions and limitations
  *  under the License.
  */
-
-
 package org.codehaus.groovy.classgen.asm.sc.bugs
 
 import groovy.transform.stc.StaticTypeCheckingTestCase
 import org.codehaus.groovy.classgen.asm.sc.StaticCompilationTestSupport
 
 class Groovy7324Bug extends StaticTypeCheckingTestCase implements StaticCompilationTestSupport {
-    void testInferenceOfListDotOperator() {
-        assertScript '''class Account {
-    String id
-}
 
-class GCAccount {
-    List<Account> sfAccounts
-}
-
-class User {
-    List<GCAccount> gcAccounts
-}
-
-void foo() {
-    def accounts = (1..10).collect { new Account(id: "Id $it") }
-    def user1 = new User(gcAccounts: [new GCAccount(sfAccounts: accounts[0..2]), new GCAccount(sfAccounts: accounts[3..4])])
-    def user2 = new User(gcAccounts: [new GCAccount(sfAccounts: accounts[5..7]), new GCAccount(sfAccounts: accounts[8..9])])
-    def users = [user1,user2]
-    def ids = users.gcAccounts.sfAccounts.id.flatten()
-    println ids
-}
+    void testInferenceOfListDotOperator() {
+        assertScript '''
+            class Account {
+                String id
+            }
+            class Accounts {
+                List<Account> accountList
+            }
+            class User {
+                List<Accounts> accountsList
+            }
 
-foo()
+            def accounts = (1..10).collect { new Account(id: "Id $it") }
+            def user1 = new User(accountsList: [new Accounts(accountList: accounts[0..2]), new Accounts(accountList: accounts[3..4])])
+            def user2 = new User(accountsList: [new Accounts(accountList: accounts[5..7]), new Accounts(accountList: accounts[8..9])])
+            def users = [user1, user2]
+            def ids = (List<String>) users.accountsList.accountList.id.flatten()
+            assert ids.size() == 10
         '''
     }
 
     void testInferenceOfSpreadDotOperator() {
-        assertScript '''class Account {
-    String id
-}
-
-class GCAccount {
-    List<Account> sfAccounts
-}
-
-class User {
-    List<GCAccount> gcAccounts
-}
-
-void foo() {
-    def accounts = (1..10).collect { new Account(id: "Id $it") }
-    def user = new User(gcAccounts: [new GCAccount(sfAccounts: accounts[0..2]), new GCAccount(sfAccounts: accounts[3..4])])
-    def ids = user.gcAccounts*.sfAccounts*.id.flatten()
-    println ids
-}
+        assertScript '''
+            class Account {
+                String id
+            }
+            class Accounts {
+                List<Account> accountList
+            }
+            class User {
+                List<Accounts> accountsList
+            }
 
-foo()
+            def accounts = (1..5).collect { new Account(id: "Id $it") }
+            def user = new User(accountsList: [new Accounts(accountList: accounts[0..2]), new Accounts(accountList: accounts[3..4])])
+            // "user.accountsList*.accountList" produces List<List<Account>> so "that*.id" includes spread-dot and list-dot operation
+            def ids = (List<String>) user.accountsList*.accountList*.id.flatten()
+            assert ids.size() == 5
         '''
     }
 }
