diff --git a/src/main/java/org/codehaus/groovy/classgen/InnerClassCompletionVisitor.java b/src/main/java/org/codehaus/groovy/classgen/InnerClassCompletionVisitor.java
index da8bb4d0b9..2b88d8f748 100644
--- a/src/main/java/org/codehaus/groovy/classgen/InnerClassCompletionVisitor.java
+++ b/src/main/java/org/codehaus/groovy/classgen/InnerClassCompletionVisitor.java
@@ -282,24 +282,21 @@ public class InnerClassCompletionVisitor extends InnerClassVisitorHelper {
         );
     }
 
-    private void addSyntheticMethod(final InnerClassNode node, final String methodName, final int modifiers,
+    private void addSyntheticMethod(final InnerClassNode innerClass, final String methodName, final int modifiers,
             final ClassNode returnType, final Parameter[] parameters, final BiConsumer<BlockStatement, Parameter[]> consumer) {
-        MethodNode method = node.getMethod(methodName, parameters);
-        if (method != null) {
-            // GROOVY-8914: pre-compiled classes lose synthetic boolean - TODO fix earlier as per GROOVY-4346 then remove extra check here
-            if (isStatic(node) && !method.isSynthetic() && (method.getModifiers() & ACC_SYNTHETIC) == 0) {
-                // if there is a user-defined methodNode, add compiler error and continue
-                addError("\"" + methodName + "\" implementations are not supported on static inner classes as " +
-                    "a synthetic version of \"" + methodName + "\" is added during compilation for the purpose " +
-                    "of outer class delegation.",
-                    method);
-            }
-            return;
+        MethodNode method = innerClass.getDeclaredMethod(methodName, parameters);
+        if (method == null) {
+            BlockStatement methodBody = block();
+            consumer.accept(methodBody, parameters);
+            innerClass.addSyntheticMethod(methodName, modifiers, returnType, parameters, ClassNode.EMPTY_ARRAY, methodBody);
+
+            // if there is a user-defined method, add compiler error and continue
+        } else if (isStatic(innerClass) && (method.getModifiers() & ACC_SYNTHETIC) == 0) {
+            addError("\"" + methodName + "\" implementations are not supported on static inner classes as " +
+                "a synthetic version of \"" + methodName + "\" is added during compilation for the purpose " +
+                "of outer class delegation.",
+                method);
         }
-
-        BlockStatement methodBody = block();
-        consumer.accept(methodBody, parameters);
-        node.addSyntheticMethod(methodName, modifiers, returnType, parameters, ClassNode.EMPTY_ARRAY, methodBody);
     }
 
     private void addThisReference(ConstructorNode node) {
diff --git a/src/test/gls/innerClass/InnerClassTest.groovy b/src/test/gls/innerClass/InnerClassTest.groovy
index 7024462f21..ea06cbf4d8 100644
--- a/src/test/gls/innerClass/InnerClassTest.groovy
+++ b/src/test/gls/innerClass/InnerClassTest.groovy
@@ -700,6 +700,29 @@ final class InnerClassTest {
         '''
     }
 
+    @Test // GROOVY-9905
+    void testUsageOfOuterSuperField3() {
+        assertScript '''
+            abstract class A {
+                protected final f = 'foo'
+                abstract static class B {}
+            }
+
+            class C extends A {
+                private class D extends A.B { // B is static inner
+                    String toString() {
+                        f + 'bar' // No such property: f for class: A
+                    }
+                }
+                def m() {
+                    new D().toString()
+                }
+            }
+
+            assert new C().m() == 'foobar'
+        '''
+    }
+
     @Test
     void testUsageOfOuterField_WrongCallToSuper() {
         shouldFail '''
