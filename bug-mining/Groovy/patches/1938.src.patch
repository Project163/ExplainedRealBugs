diff --git a/src/main/org/codehaus/groovy/classgen/asm/OperandStack.java b/src/main/org/codehaus/groovy/classgen/asm/OperandStack.java
index 64e9da29a4..a1b98eabd1 100644
--- a/src/main/org/codehaus/groovy/classgen/asm/OperandStack.java
+++ b/src/main/org/codehaus/groovy/classgen/asm/OperandStack.java
@@ -308,7 +308,9 @@ public class OperandStack {
     private void doConvertAndCast(ClassNode targetType, boolean coerce) {
         int size = stack.size();
         try {
-            if (size==0) throw new ArrayIndexOutOfBoundsException("size==0");
+            if (size==0) {
+                throw new ArrayIndexOutOfBoundsException("size==0");
+            }
         } catch (ArrayIndexOutOfBoundsException ai) {
             throw ai;
         }
diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index f011703d98..57e3eeb4dd 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -231,7 +231,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         node.putNodeMetaData(StaticTypesMarker.INFERRED_TYPE, node);
         // mark all methods as visited. We can't do this in visitMethod because the type checker
         // works in a two pass sequence and we don't want to skip the second pass
-        for (MethodNode methodNode : node.getAllDeclaredMethods()) {
+        for (MethodNode methodNode : node.getMethods()) {
             methodNode.putNodeMetaData(StaticTypeCheckingVisitor.class, Boolean.TRUE);
         }
         for (ConstructorNode constructorNode : node.getDeclaredConstructors()) {
@@ -1619,8 +1619,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
      */
     private void silentlyVisitMethodNode(final MethodNode directMethodCallCandidate) {
         // visit is authorized because the classnode belongs to the same source unit
-        //TODO: add method to ErrorCollector to get a CompilerConfiguration from it instead of simply using a new one with maybe wrong settings
-        ErrorCollector collector = new ErrorCollector(new CompilerConfiguration());
+        ErrorCollector collector = new ErrorCollector(errorCollector.getConfiguration());
         startMethodInference(directMethodCallCandidate, collector);
     }
 
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/BugsStaticCompileTest.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/BugsStaticCompileTest.groovy
index 1547612fa6..8b56b16cc9 100644
--- a/src/test/org/codehaus/groovy/classgen/asm/sc/BugsStaticCompileTest.groovy
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/BugsStaticCompileTest.groovy
@@ -441,5 +441,24 @@ class BugsStaticCompileTest extends BugsSTCTest {
         new SampleClass()
         '''
     }
+
+    void testSubclassShouldNotThrowArrayIndexOutOfBoundsException() {
+        assertScript '''
+            // The error only shows up if the subclass is compiled *before* the superclass
+            class Subclass extends Z {
+                public Subclass(double x, double y, double z) {
+                    super(x,y,z)
+                }
+            }
+            class Z {
+               double x, y, z
+
+                public Z(double x, double y, double z) { this.x = x; this.y = y; this.z = z }
+
+                public Z negative() { return new Z(-x, -y, -z) }
+            }
+            new Subclass(0,0,0)
+        '''
+    }
 }
 
