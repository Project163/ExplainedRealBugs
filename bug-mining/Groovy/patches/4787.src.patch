diff --git a/src/main/java/org/codehaus/groovy/ast/ClassNode.java b/src/main/java/org/codehaus/groovy/ast/ClassNode.java
index 2fe66e16fe..2e843e7bb6 100644
--- a/src/main/java/org/codehaus/groovy/ast/ClassNode.java
+++ b/src/main/java/org/codehaus/groovy/ast/ClassNode.java
@@ -30,6 +30,7 @@ import org.codehaus.groovy.ast.stmt.ExpressionStatement;
 import org.codehaus.groovy.ast.stmt.Statement;
 import org.codehaus.groovy.ast.tools.ParameterUtils;
 import org.codehaus.groovy.control.CompilePhase;
+import org.codehaus.groovy.runtime.ArrayGroovyMethods;
 import org.codehaus.groovy.transform.ASTTransformation;
 import org.codehaus.groovy.transform.GroovyASTTransformation;
 import org.codehaus.groovy.vmplugin.VMPluginFactory;
@@ -46,6 +47,7 @@ import java.util.ListIterator;
 import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
+import java.util.stream.IntStream;
 
 import static java.util.Objects.requireNonNull;
 import static java.util.stream.Collectors.toList;
@@ -1121,13 +1123,8 @@ public class ClassNode extends AnnotatedNode {
     }
 
     public MethodNode tryFindPossibleMethod(final String name, final Expression arguments) {
-        if (!(arguments instanceof TupleExpression)) {
-            return null;
-        }
-
-        // TODO: this won't strictly be true when using list expansion in argument calls
-        TupleExpression args = (TupleExpression) arguments;
-        int nArgs = args.getExpressions().size();
+        List<Expression> args = arguments instanceof TupleExpression ? ((TupleExpression) arguments).getExpressions() : Collections.singletonList(arguments);
+        int nArgs = args.size(); // TODO: this isn't strictly accurate when using spread argument expansion
         MethodNode method = null;
 
         for (ClassNode cn = this; cn != null; cn = cn.getSuperClass()) {
@@ -1135,7 +1132,7 @@ public class ClassNode extends AnnotatedNode {
                 if (hasCompatibleNumberOfArgs(mn, nArgs)) {
                     boolean match = true;
                     for (int i = 0; i < nArgs; i += 1) {
-                        if (!hasCompatibleType(args, mn, i)) {
+                        if (!hasCompatibleType(args.get(i), mn, i)) {
                             match = false;
                             break;
                         }
@@ -1159,6 +1156,18 @@ public class ClassNode extends AnnotatedNode {
             }
         }
 
+faces:  if (method == null && ArrayGroovyMethods.asBoolean(getInterfaces())) { // GROOVY-11323
+            for (ClassNode cn : getAllInterfaces()) {
+                for (MethodNode mn : cn.getDeclaredMethods(name)) {
+                    if (mn.isPublic() && !mn.isStatic() && hasCompatibleNumberOfArgs(mn, nArgs) && (nArgs == 0
+                            || IntStream.range(0,nArgs).allMatch(i -> hasCompatibleType(args.get(i),mn,i)))) {
+                        method = mn;
+                        break faces;
+                    }
+                }
+            }
+        }
+
         return method;
     }
 
@@ -1168,10 +1177,10 @@ public class ClassNode extends AnnotatedNode {
                 || (i >= lastParamIndex && isPotentialVarArg(maybe, lastParamIndex) && match.getParameters()[i].getType().equals(maybe.getParameters()[lastParamIndex].getType().getComponentType()));
     }
 
-    private static boolean hasCompatibleType(final TupleExpression args, final MethodNode method, final int i) {
+    private static boolean hasCompatibleType(final Expression arg, final MethodNode method, final int i) {
         int lastParamIndex = method.getParameters().length - 1;
-        return (i <= lastParamIndex && args.getExpression(i).getType().isDerivedFrom(method.getParameters()[i].getType()))
-                || (i >= lastParamIndex && isPotentialVarArg(method, lastParamIndex) && args.getExpression(i).getType().isDerivedFrom(method.getParameters()[lastParamIndex].getType().getComponentType()));
+        return (i <= lastParamIndex && arg.getType().isDerivedFrom(method.getParameters()[i].getType()))
+                || (i >= lastParamIndex && isPotentialVarArg(method, lastParamIndex) && arg.getType().isDerivedFrom(method.getParameters()[lastParamIndex].getType().getComponentType()));
     }
 
     private static boolean hasCompatibleNumberOfArgs(final MethodNode method, final int nArgs) {
diff --git a/src/test/groovy/StaticImportTest.groovy b/src/test/groovy/StaticImportTest.groovy
index 1d97ef20cd..9edf549148 100644
--- a/src/test/groovy/StaticImportTest.groovy
+++ b/src/test/groovy/StaticImportTest.groovy
@@ -162,6 +162,26 @@ final class StaticImportTest extends groovy.test.GroovyTestCase {
         '''
     }
 
+    // GROOVY-11323
+    void testStaticImportAndInterfaceDefaultMethod() {
+        assertScript '''import static Bar.*
+            interface Foo {
+                default m() { 'Foo' }
+            }
+            class Bar {
+                static  m() { 'Bar' }
+            }
+
+            class Baz implements Foo {
+                void test() {
+                    assert m() == 'Foo'
+                }
+            }
+
+            new Baz().test()
+        '''
+    }
+
     void testStaticImportProperty() {
         for (imports in ['import static Foo.getX; import static Foo.setX', 'import static Foo.*']) {
             assertScript """$imports
