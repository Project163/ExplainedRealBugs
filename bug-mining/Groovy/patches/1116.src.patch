diff --git a/src/main/groovy/grape/GrabAnnotationTransformation.java b/src/main/groovy/grape/GrabAnnotationTransformation.java
index ffbb1b8e71..98e3f2c41a 100644
--- a/src/main/groovy/grape/GrabAnnotationTransformation.java
+++ b/src/main/groovy/grape/GrabAnnotationTransformation.java
@@ -27,6 +27,7 @@ import org.codehaus.groovy.ast.stmt.Statement;
 import org.codehaus.groovy.control.CompilePhase;
 import org.codehaus.groovy.control.SourceUnit;
 import org.codehaus.groovy.transform.ASTTransformation;
+import org.codehaus.groovy.transform.ASTTransformationVisitor;
 import org.codehaus.groovy.transform.GroovyASTTransformation;
 import org.codehaus.groovy.runtime.DefaultGroovyMethods;
 
@@ -219,6 +220,8 @@ public class GrabAnnotationTransformation extends ClassCodeVisitorSupport implem
 
             try {
                 Grape.grab(basicArgs, grabMaps.toArray(new Map[grabMaps.size()]));
+                // grab may have added more transformations through new URLs added to classpath, so do one more scan
+                ASTTransformationVisitor.addGlobalTransformsAfterGrab();
             } catch (RuntimeException re) {
                 // Decided against syntax exception since this is not a syntax error.
                 // The down side is we lose line number information for the offending
diff --git a/src/main/org/codehaus/groovy/control/CompilationUnit.java b/src/main/org/codehaus/groovy/control/CompilationUnit.java
index 50e3352728..c4e42237fd 100644
--- a/src/main/org/codehaus/groovy/control/CompilationUnit.java
+++ b/src/main/org/codehaus/groovy/control/CompilationUnit.java
@@ -78,7 +78,7 @@ public class CompilationUnit extends ProcessingUnit {
     protected OptimizerVisitor optimizer;
 
     LinkedList[] phaseOperations;
-
+    LinkedList[] newPhaseOperations;
 
     /**
      * Initializes the CompilationUnit with defaults.
@@ -147,8 +147,10 @@ public class CompilationUnit extends ProcessingUnit {
         this.optimizer = new OptimizerVisitor(this);
 
         phaseOperations = new LinkedList[Phases.ALL + 1];
+        newPhaseOperations = new LinkedList[Phases.ALL + 1];
         for (int i = 0; i < phaseOperations.length; i++) {
             phaseOperations[i] = new LinkedList();
+            newPhaseOperations[i] = new LinkedList();
         }
         addPhaseOperation(new SourceUnitOperation() {
             public void call(SourceUnit source) throws CompilationFailedException {
@@ -205,6 +207,10 @@ public class CompilationUnit extends ProcessingUnit {
         phaseOperations[Phases.OUTPUT].addFirst(op);
     }
 
+    public void addNewPhaseOperation(SourceUnitOperation op, int phase) {
+        if (phase < 0 || phase > Phases.ALL) throw new IllegalArgumentException("phase " + phase + " is unknown");
+        newPhaseOperations[phase].add(op);
+    }
 
     /**
      * Configures its debugging mode and classloader classpath from a given compiler configuration.
@@ -462,16 +468,9 @@ public class CompilationUnit extends ProcessingUnit {
 
         while (throughPhase >= phase && phase <= Phases.ALL) {
 
-            for (Iterator it = phaseOperations[phase].iterator(); it.hasNext();) {
-                Object operation = it.next();
-                if (operation instanceof PrimaryClassNodeOperation) {
-                    applyToPrimaryClassNodes((PrimaryClassNodeOperation) operation);
-                } else if (operation instanceof SourceUnitOperation) {
-                    applyToSourceUnits((SourceUnitOperation) operation);
-                } else {
-                    applyToGeneratedGroovyClasses((GroovyClassOperation) operation);
-                }
-            }
+            processPhaseOperations(phase);
+            // Grab processing may have brought in new AST transforms into various phases, process them as well
+            processNewPhaseOperations(phase);
 
             if (progressCallback != null) progressCallback.call(this, phase);
             completePhase();
@@ -489,6 +488,49 @@ public class CompilationUnit extends ProcessingUnit {
         errorCollector.failIfErrors();
     }
 
+    private void processPhaseOperations(int ph) {
+        LinkedList ops = phaseOperations[ph];
+        for (Iterator it = ops.iterator(); it.hasNext();) {
+            doPhaseOperation(it.next());
+        }
+    }
+    
+    private void processNewPhaseOperations(int currPhase) {
+        recordPhaseOpsInAllOtherPhases(currPhase);
+        LinkedList currentPhaseNewOps = newPhaseOperations[currPhase];
+        while (!currentPhaseNewOps.isEmpty()) {
+            Object operation = currentPhaseNewOps.removeFirst();
+            // push this operation to master list and then process it.
+            phaseOperations[currPhase].add(operation);
+            doPhaseOperation(operation);
+            // if this operation has brought in more phase ops for ast transforms, keep recording them
+            // in master list of other phases and keep processing them for this phase.
+            recordPhaseOpsInAllOtherPhases(currPhase);
+            currentPhaseNewOps = newPhaseOperations[currPhase];
+        }
+        
+    }
+    
+    private void doPhaseOperation(Object operation) {
+        if (operation instanceof PrimaryClassNodeOperation) {
+            applyToPrimaryClassNodes((PrimaryClassNodeOperation) operation);
+        } else if (operation instanceof SourceUnitOperation) {
+            applyToSourceUnits((SourceUnitOperation) operation);
+        } else {
+            applyToGeneratedGroovyClasses((GroovyClassOperation) operation);
+        }
+    }
+
+    private void recordPhaseOpsInAllOtherPhases(int currPhase) {
+        // apart from current phase, push new operations for every other phase in the master phase ops list
+        for (int ph = Phases.INITIALIZATION; ph <= Phases.ALL; ph++) {
+            if(ph != currPhase && !newPhaseOperations[ph].isEmpty()) {
+                phaseOperations[ph].addAll(newPhaseOperations[ph]);
+                newPhaseOperations[ph].clear();
+            }
+        }
+    }
+
     private void sortClasses() throws CompilationFailedException {
         Iterator modules = this.ast.getModules().iterator();
         while (modules.hasNext()) {
diff --git a/src/main/org/codehaus/groovy/transform/ASTTransformationVisitor.java b/src/main/org/codehaus/groovy/transform/ASTTransformationVisitor.java
index 245e7fa526..21aa240287 100644
--- a/src/main/org/codehaus/groovy/transform/ASTTransformationVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/ASTTransformationVisitor.java
@@ -58,6 +58,8 @@ public class ASTTransformationVisitor extends ClassCodeVisitorSupport {
     private List<ASTNode[]> targetNodes;
     private Map<ASTNode, List<ASTTransformation>> transforms;
     private Map<Class<? extends ASTTransformation>, ASTTransformation> transformInstances;
+    private static CompilationUnit compUnit;
+    private static Set<String> globalTransformNames = new HashSet<String>();
 
     private ASTTransformationVisitor(CompilePhase phase) {
         this.phase = phase;
@@ -176,10 +178,19 @@ public class ASTTransformationVisitor extends ClassCodeVisitorSupport {
             }
         }
     }
-
+    
+    public static void addGlobalTransformsAfterGrab() {
+        doAddGlobalTransforms(compUnit, false);
+    }
+    
     public static void addGlobalTransforms(CompilationUnit compilationUnit) {
+        compUnit = compilationUnit;
+        doAddGlobalTransforms(compilationUnit, true);
+    }
+
+    private static void doAddGlobalTransforms(CompilationUnit compilationUnit, boolean isFirstScan) {
         GroovyClassLoader transformLoader = compilationUnit.getTransformLoader();
-        LinkedHashMap<String, URL> globalTransformNames = new LinkedHashMap<String, URL>();
+        Map<String, URL> transformNames = new LinkedHashMap<String, URL>();
         try {
             Enumeration<URL> globalServices = transformLoader.getResources("META-INF/services/org.codehaus.groovy.transform.ASTTransformation");
             while (globalServices.hasMoreElements()) {
@@ -196,12 +207,12 @@ public class ASTTransformationVisitor extends ClassCodeVisitorSupport {
                 }
                 while (className != null) {
                     if (!className.startsWith("#") && className.length() > 0) {
-                        if (globalTransformNames.containsKey(className)) {
-                            if (!service.equals(globalTransformNames.get(className))) {
+                        if (transformNames.containsKey(className)) {
+                            if (!service.equals(transformNames.get(className))) {
                                 compilationUnit.getErrorCollector().addWarning(
                                         WarningMessage.POSSIBLE_ERRORS,
                                         "The global transform for class " + className + " is defined in both "
-                                            + globalTransformNames.get(className).toExternalForm()
+                                            + transformNames.get(className).toExternalForm()
                                             + " and "
                                             + service.toExternalForm()
                                             + " - the former definition will be used and the latter ignored.",
@@ -210,7 +221,7 @@ public class ASTTransformationVisitor extends ClassCodeVisitorSupport {
                             }
 
                         } else {
-                            globalTransformNames.put(className, service);
+                            transformNames.put(className, service);
                         }
                     }
                     try {
@@ -237,7 +248,7 @@ public class ASTTransformationVisitor extends ClassCodeVisitorSupport {
             StringBuffer sb = new StringBuffer();
             sb.append("Global ASTTransformations are not enabled in retro builds of groovy.\n");
             sb.append("The following transformations will be ignored:");
-            for (Map.Entry<String, URL> entry : globalTransformNames.entrySet()) {
+            for (Map.Entry<String, URL> entry : transformNames.entrySet()) {
                 sb.append('\t');
                 sb.append(entry.getKey());
                 sb.append('\n');
@@ -246,7 +257,31 @@ public class ASTTransformationVisitor extends ClassCodeVisitorSupport {
                 WarningMessage.POSSIBLE_ERRORS, sb.toString(), null, null));
             return;
         }
-        for (Map.Entry<String, URL> entry : globalTransformNames.entrySet()) {
+        
+        // record the transforms found in the first scan, so that in the 2nd scan, phase operations 
+        // can be added for only for new transforms that have come in 
+        if(isFirstScan) {
+            for (Map.Entry<String, URL> entry : transformNames.entrySet()) {
+                globalTransformNames.add(entry.getKey());
+            }
+            addPhaseOperationsForGlobalTransforms(compilationUnit, transformNames, isFirstScan);
+        } else {
+            Iterator<Map.Entry<String, URL>> it = transformNames.entrySet().iterator();
+            while(it.hasNext()) {
+                Map.Entry<String, URL> entry = it.next();
+                if(!globalTransformNames.add(entry.getKey())) {
+                    // phase operations for this transform class have already been added before, so remove from current scan cycle
+                    it.remove(); 
+                }
+            }
+            addPhaseOperationsForGlobalTransforms(compilationUnit, transformNames, isFirstScan);
+        }
+    }
+    
+    private static void addPhaseOperationsForGlobalTransforms(CompilationUnit compilationUnit, 
+            Map<String, URL> transformNames, boolean isFirstScan) {
+        GroovyClassLoader transformLoader = compilationUnit.getTransformLoader();
+        for (Map.Entry<String, URL> entry : transformNames.entrySet()) {
             try {
                 Class gTransClass = transformLoader.loadClass(entry.getKey(), false, true, false);
                 //no inspection unchecked
@@ -263,11 +298,16 @@ public class ASTTransformationVisitor extends ClassCodeVisitorSupport {
                 }
                 if (ASTTransformation.class.isAssignableFrom(gTransClass)) {
                     final ASTTransformation instance = (ASTTransformation)gTransClass.newInstance();
-                    compilationUnit.addPhaseOperation(new CompilationUnit.SourceUnitOperation() {
+                    CompilationUnit.SourceUnitOperation suOp = new CompilationUnit.SourceUnitOperation() {
                         public void call(SourceUnit source) throws CompilationFailedException {
                             instance.visit(new ASTNode[] {source.getAST()}, source);
                         }
-                    }, transformAnnotation.phase().getPhaseNumber());
+                    }; 
+                    if(isFirstScan) {
+                        compilationUnit.addPhaseOperation(suOp, transformAnnotation.phase().getPhaseNumber());
+                    } else {
+                        compilationUnit.addNewPhaseOperation(suOp, transformAnnotation.phase().getPhaseNumber());
+                    }
                 } else {
                     compilationUnit.getErrorCollector().addError(new SimpleMessage(
                         "Transform Class " + entry.getKey() + " specified at "
