diff --git a/src/main/groovy/transform/Undefined.java b/src/main/groovy/transform/Undefined.java
new file mode 100644
index 0000000000..c2f3e7056f
--- /dev/null
+++ b/src/main/groovy/transform/Undefined.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright 2003-2014 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package groovy.transform;
+
+import org.codehaus.groovy.ast.ClassNode;
+
+/**
+ * Java doesn't allow you to have null as an attribute value. It wants you to indicate what you really
+ * mean by null, so that is what we do here - as ugly as it is.
+ */
+public final class Undefined {
+    private Undefined() {}
+    public static final String STRING = "<DummyUndefinedMarkerString-DoNotUse>";
+    public static final class CLASS {}
+    public static boolean isUndefined(String other) { return STRING.equals(other); }
+    public static boolean isUndefined(ClassNode other) { return CLASS.class.getName().equals(other.getName()); }
+}
diff --git a/src/main/groovy/transform/builder/Builder.java b/src/main/groovy/transform/builder/Builder.java
index 6108938722..17fac339c2 100644
--- a/src/main/groovy/transform/builder/Builder.java
+++ b/src/main/groovy/transform/builder/Builder.java
@@ -21,6 +21,7 @@ import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 import java.lang.annotation.Documented;
 
+import groovy.transform.Undefined;
 import org.codehaus.groovy.transform.GroovyASTTransformationClass;
 
 import static org.codehaus.groovy.transform.BuilderASTTransformation.BuilderStrategy;
@@ -73,7 +74,7 @@ public @interface Builder {
      * A class for which builder methods should be created. It will be an error to leave
      * this attribute with its default value for some strategies.
      */
-    Class forClass() default ForClassNotSet.class;
+    Class forClass() default Undefined.CLASS.class;
 
     /**
      * A class capturing the builder strategy
@@ -85,20 +86,20 @@ public @interface Builder {
      * Default is determined by the strategy which might use "" or "set" but you can choose your own, e.g. "with".
      * If non-empty the first letter of the property will be capitalized before being appended to the prefix.
      */
-    String prefix() default "<strategyDefault>";
+    String prefix() default Undefined.STRING;
 
     /**
      * For strategies which create a builder helper class, the class name to use for the helper class.
      * Not used if using {@code forClass} since in such cases the builder class is explicitly supplied.
      * Default is determined by the strategy, e.g. <em>TargetClass</em> + "Builder" or <em>TargetClass</em> + "Initializer".
      */
-    String builderClassName() default "<strategyDefault>";
+    String builderClassName() default Undefined.STRING;
 
     /**
      * For strategies which create a builder helper class that creates the instance, the method name to call to create the instance.
      * Default is determined by the strategy, e.g. <em>build</em> or <em>create</em>.
      */
-    String buildMethodName() default "<strategyDefault>";
+    String buildMethodName() default Undefined.STRING;
 
     /**
      * The method name to use for a builder factory method in the source class for easy access of the
@@ -106,7 +107,7 @@ public @interface Builder {
      * Must not be used if using {@code forClass}.
      * Default is determined by the strategy, e.g. <em>builder</em> or <em>createInitializer</em>.
      */
-    String builderMethodName() default "<strategyDefault>";
+    String builderMethodName() default Undefined.STRING;
 
     /**
      * List of field and/or property names to exclude from generated builder methods.
@@ -121,7 +122,4 @@ public @interface Builder {
      * can be used in addition to an array (using Groovy's literal list notation) of String values.
      */
     String[] includes() default {};
-
-    /** Marker class */
-    static class ForClassNotSet {}
 }
diff --git a/src/main/org/codehaus/groovy/transform/BuilderASTTransformation.java b/src/main/org/codehaus/groovy/transform/BuilderASTTransformation.java
index 74b2ccc814..e92fc0874c 100644
--- a/src/main/org/codehaus/groovy/transform/BuilderASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/BuilderASTTransformation.java
@@ -35,6 +35,7 @@ import org.codehaus.groovy.control.SourceUnit;
 import java.util.ArrayList;
 import java.util.List;
 
+import static groovy.transform.Undefined.isUndefined;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.getInstancePropertyFields;
 
 /**
@@ -94,10 +95,10 @@ public class BuilderASTTransformation extends AbstractASTTransformation implemen
 
         protected boolean unsupportedAttribute(BuilderASTTransformation transform, AnnotationNode anno, String memberName, String extraMessage) {
             Object memberValue = transform.getMemberValue(anno, memberName);
-            if (memberValue != null && memberValue.equals("<strategyDefault>")) return false;
+            if (memberValue != null && memberValue instanceof String && isUndefined((String) memberValue)) return false;
             if (memberValue == null) {
                 memberValue = transform.getMemberClassValue(anno, memberName);
-                if (memberValue != null && ((ClassNode)memberValue).getName().equals(Builder.ForClassNotSet.class.getName())) {
+                if (memberValue != null && isUndefined((ClassNode) memberValue)) {
                     memberValue = null;
                 }
             }
@@ -150,12 +151,12 @@ public class BuilderASTTransformation extends AbstractASTTransformation implemen
 
         protected String getBuilderMemberStringValue(BuilderASTTransformation transform, AnnotationNode anno, String name, String defaultValue) {
             String result = transform.getMemberStringValue(anno, name, defaultValue);
-            return result != null && result.equals("<strategyDefault>") ? defaultValue : result;
+            return result == null || isUndefined(result) ? defaultValue : result;
         }
 
         protected ClassNode getBuilderMemberClassValue(BuilderASTTransformation transform, AnnotationNode anno, String name) {
             ClassNode forClass = transform.getMemberClassValue(anno, name);
-            return forClass == null || forClass.getName().equals(Builder.ForClassNotSet.class.getName()) ? null : forClass;
+            return forClass == null || isUndefined(forClass) ? null : forClass;
         }
 
         protected static class PropertyInfo {
