diff --git a/src/main/org/codehaus/groovy/transform/sc/StaticCompilationVisitor.java b/src/main/org/codehaus/groovy/transform/sc/StaticCompilationVisitor.java
index 6b8064357f..6f604385af 100644
--- a/src/main/org/codehaus/groovy/transform/sc/StaticCompilationVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/sc/StaticCompilationVisitor.java
@@ -282,9 +282,4 @@ public class StaticCompilationVisitor extends StaticTypeCheckingVisitor {
         return exists;
     }
 
-    @Override
-    public void visitPostfixExpression(final PostfixExpression expression) {
-        super.visitPostfixExpression(expression);
-//        if (!getType(expression.getExpression()))
-    }
 }
diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 882d571c47..f3414d680f 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -279,6 +279,28 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         if (node instanceof MethodNode) {
             return isSkipMode(node.getDeclaringClass());
         }
+        if (isSkippedInnerClass(node)) return true;
+        return false;
+    }
+
+    /**
+     * Test if a node is an inner class node, and if it is, then checks if the enclosing method is skipped.
+     * @param node
+     * @return true if the inner class node should be skipped
+     */
+    private boolean isSkippedInnerClass(AnnotatedNode node) {
+        if (!(node instanceof InnerClassNode)) return false;
+        ClassNode outerClass = ((InnerClassNode) node).getOuterClass();
+        // inner.getEnclosingMethod() returns null, so we must perform a "dirty" check based on line numbers to figure
+        // out if the class was created in a skipped method node
+        List<MethodNode> methods = new LinkedList<MethodNode>();
+        methods.addAll(outerClass.getDeclaredMethodsMap().values());
+        methods.addAll(outerClass.getDeclaredConstructors());
+        for (MethodNode mn : methods) {
+            if (mn.getLineNumber()>0 && mn.getLineNumber()<=node.getLineNumber() && mn.getLastLineNumber()>=node.getLastLineNumber()) {
+                return isSkipMode(mn);
+            }
+        }
         return false;
     }
 
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/BugsStaticCompileTest.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/BugsStaticCompileTest.groovy
index 991d278817..6fce562426 100644
--- a/src/test/org/codehaus/groovy/classgen/asm/sc/BugsStaticCompileTest.groovy
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/BugsStaticCompileTest.groovy
@@ -407,5 +407,24 @@ class BugsStaticCompileTest extends BugsSTCTest {
                 assert x == -3
             '''
     }
+
+    void testShouldSkipSpreadOperator() {
+        new GroovyShell().evaluate '''import groovy.transform.TypeCheckingMode
+            import groovy.transform.CompileStatic
+
+            @CompileStatic // top level must be @CS
+            class Foo {
+                @CompileStatic(TypeCheckingMode.SKIP)
+                static void foo(fun, args) {
+                    new Runnable() { // create an anonymous class which should *not* be visited
+                        void run() {
+                            fun(*args) // spread operator is disallowed with STC/SC, but SKIP should prevent from an error
+                        }
+                    }
+                }
+            }
+            new Foo()
+        '''
+    }
 }
 
