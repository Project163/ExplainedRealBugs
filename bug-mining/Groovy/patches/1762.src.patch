diff --git a/src/main/groovy/transform/Canonical.java b/src/main/groovy/transform/Canonical.java
index 30b693b156..e38f51b8cd 100644
--- a/src/main/groovy/transform/Canonical.java
+++ b/src/main/groovy/transform/Canonical.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2011 the original author or authors.
+ * Copyright 2008-2012 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -77,6 +77,9 @@ import java.lang.annotation.Target;
  * If an "underscore" version of the respective method already exists, then no default implementation is provided.
  * </ul>
  * <p/>
+ * If you want similar functionality to what this annotation provides but also require immutability, see the
+ * {@code @Immutable} annotation.
+ * <p/>
  * Limitations:
  * <ul>
  * <li>
@@ -88,6 +91,7 @@ import java.lang.annotation.Target;
  * @see groovy.transform.EqualsAndHashCode
  * @see groovy.transform.ToString
  * @see groovy.transform.TupleConstructor
+ * @see groovy.transform.Immutable
  * @since 1.8.0
  */
 @java.lang.annotation.Documented
diff --git a/src/main/groovy/transform/Immutable.java b/src/main/groovy/transform/Immutable.java
index 5bdfd3e24f..153a317f55 100644
--- a/src/main/groovy/transform/Immutable.java
+++ b/src/main/groovy/transform/Immutable.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2011 the original author or authors.
+ * Copyright 2008-2012 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -85,9 +85,14 @@ import java.lang.annotation.Target;
  * your objects may no longer be immutable. It is up to you to ensure that your objects remain immutable at least
  * to the extent expected in other parts of your program!
  * </ul>
- * <p/>
  * Immutable classes are particularly useful for functional and concurrent styles of programming
- * and for use as key values within maps.
+ * and for use as key values within maps. If you want similar functionality to what this annotation
+ * provides but don't need immutability then consider using {@code @Canonical}.
+ * <p/>
+ * Customising behaviour:
+ * <p/>
+ * You can customise the toString() method provided for you by {@code @Immutable}
+ * by also adding the {@code @ToString} annotation to your class definition.
  * <p/>
  * Limitations:
  * <ul>
@@ -113,6 +118,8 @@ import java.lang.annotation.Target;
  * </ul>
  *
  * @author Paul King
+ * @see groovy.transform.ToString
+ * @see groovy.transform.Canonical
  * @since 1.7
  */
 @java.lang.annotation.Documented
diff --git a/src/main/groovy/transform/ToString.java b/src/main/groovy/transform/ToString.java
index d3105a93cf..da45ac2aff 100644
--- a/src/main/groovy/transform/ToString.java
+++ b/src/main/groovy/transform/ToString.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2011 the original author or authors.
+ * Copyright 2008-2012 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -76,22 +76,25 @@ import java.lang.annotation.Target;
  * <pre>
  * AgedThing(age:5, super:NamedThing(Lassie))
  * </pre>
- * If you want to omit fields or properties referring to <tt>null</tt> you can use:
- * <pre>
- * import groovy.transform.ToString
- * {@code @ToString(ignoreNullValues = true)} class NamedThing {
- *     String name
- * }
- * println new NamedThing(name: null)
- * </pre>
- * Which results in:
- * <pre>
- * NamedThing()
- * </pre>
+ * {@code @ToString} can also be used in conjunction with {@code @Canonical} and {@code @Immutable}.
+ * <p/>
+ * If you want to omit fields or properties referring to <tt>null</tt>, you can use the <tt>ignoreNulls</tt> flag:
+ * <pre>
+ * import groovy.transform.ToString
+ * {@code @ToString(ignoreNulls = true)} class NamedThing {
+ *     String name
+ * }
+ * println new NamedThing(name: null)
+ * </pre>
+ * Which results in:
+ * <pre>
+ * NamedThing()
+ * </pre>
  *
  * @author Paul King
- * @author Andre Steingress
- *
+ * @author Andre Steingress
+ * @see groovy.transform.Immutable
+ * @see groovy.transform.Canonical
  * @since 1.8.0
  */
 @java.lang.annotation.Documented
@@ -125,9 +128,9 @@ public @interface ToString {
      * Include fields as well as properties in generated toString
      */
     boolean includeFields() default false;
-
-    /**
-     * Ignore fields as well as properties referring to <tt>null</tt>
-     */
-    boolean ignoreNullValues() default false;
+
+    /**
+     * Don't display any fields or properties with value <tt>null</tt>
+     */
+    boolean ignoreNulls() default false;
 }
diff --git a/src/main/org/codehaus/groovy/transform/CanonicalASTTransformation.java b/src/main/org/codehaus/groovy/transform/CanonicalASTTransformation.java
index fc39857231..3c9c9d62fe 100644
--- a/src/main/org/codehaus/groovy/transform/CanonicalASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/CanonicalASTTransformation.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2011 the original author or authors.
+ * Copyright 2008-2012 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -17,7 +17,6 @@ package org.codehaus.groovy.transform;
 
 import groovy.transform.Canonical;
 import org.codehaus.groovy.ast.*;
-import org.codehaus.groovy.ast.expr.ConstantExpression;
 import org.codehaus.groovy.control.CompilePhase;
 import org.codehaus.groovy.control.SourceUnit;
 
@@ -26,7 +25,6 @@ import java.util.List;
 import static org.codehaus.groovy.transform.EqualsAndHashCodeASTTransformation.createEquals;
 import static org.codehaus.groovy.transform.EqualsAndHashCodeASTTransformation.createHashCode;
 import static org.codehaus.groovy.transform.ToStringASTTransformation.createToString;
-import static org.codehaus.groovy.transform.ToStringASTTransformation.toStringInit;
 import static org.codehaus.groovy.transform.TupleConstructorASTTransformation.createConstructor;
 
 /**
@@ -68,8 +66,7 @@ public class CanonicalASTTransformation extends AbstractASTTransformation {
                 createEquals(cNode, false, false, true, excludes, includes);
             }
             if (!hasAnnotation(cNode, ToStringASTTransformation.MY_TYPE)) {
-                toStringInit(cNode, ConstantExpression.FALSE);
-                createToString(cNode, false, false, excludes, includes);
+                createToString(cNode, false, false, excludes, includes, false);
             }
         }
     }
diff --git a/src/main/org/codehaus/groovy/transform/ImmutableASTTransformation.java b/src/main/org/codehaus/groovy/transform/ImmutableASTTransformation.java
index 15225d6974..83cbd16953 100644
--- a/src/main/org/codehaus/groovy/transform/ImmutableASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/ImmutableASTTransformation.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2011 the original author or authors.
+ * Copyright 2008-2012 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -121,7 +121,9 @@ public class ImmutableASTTransformation extends AbstractASTTransformation {
             createConstructors(cNode);
             createHashCode(cNode, true, false, false, null, null);
             createEquals(cNode, false, false, false, null, null);
-            createToString(cNode, false, false, null, null);
+            if (!hasAnnotation(cNode, ToStringASTTransformation.MY_TYPE)) {
+                createToString(cNode, false, false, null, null, false);
+            }
         }
     }
 
@@ -132,22 +134,19 @@ public class ImmutableASTTransformation extends AbstractASTTransformation {
     }
 
     private void createConstructors(ClassNode cNode) {
-        // pretty toString will remember how the user declared the params and print accordingly
-        final FieldNode constructorField = cNode.addField("$print$names", ACC_PRIVATE | ACC_SYNTHETIC, ClassHelper.boolean_TYPE, null);
-        final Expression constructorStyle = new VariableExpression(constructorField);
         if (!validateConstructors(cNode)) return;
 
         List<PropertyNode> list = getInstanceProperties(cNode);
         boolean specialHashMapCase = list.size() == 1 && list.get(0).getField().getType().equals(HASHMAP_TYPE);
         if (specialHashMapCase) {
-            createConstructorMapSpecial(cNode, constructorStyle, list);
+            createConstructorMapSpecial(cNode, list);
         } else {
-            createConstructorMap(cNode, constructorStyle, list);
-            createConstructorOrdered(cNode, constructorStyle, list);
+            createConstructorMap(cNode, list);
+            createConstructorOrdered(cNode, list);
         }
     }
 
-    private void createConstructorOrdered(ClassNode cNode, Expression constructorStyle, List<PropertyNode> list) {
+    private void createConstructorOrdered(ClassNode cNode, List<PropertyNode> list) {
         final MapExpression argMap = new MapExpression();
         final Parameter[] orderedParams = new Parameter[list.size()];
         int index = 0;
@@ -160,7 +159,6 @@ public class ImmutableASTTransformation extends AbstractASTTransformation {
         orderedBody.addStatement(new ExpressionStatement(
                 new ConstructorCallExpression(ClassNode.THIS, new ArgumentListExpression(new CastExpression(HASHMAP_TYPE, argMap)))
         ));
-        orderedBody.addStatement(assignStatement(constructorStyle, ConstantExpression.FALSE));
         cNode.addConstructor(new ConstructorNode(ACC_PUBLIC, orderedParams, ClassNode.EMPTY_ARRAY, orderedBody));
     }
 
@@ -177,13 +175,13 @@ public class ImmutableASTTransformation extends AbstractASTTransformation {
         return new MethodCallExpression(fieldExpr, "clone", MethodCallExpression.NO_ARGUMENTS);
     }
 
-    private void createConstructorMapSpecial(ClassNode cNode, Expression constructorStyle, List<PropertyNode> list) {
+    private void createConstructorMapSpecial(ClassNode cNode, List<PropertyNode> list) {
         final BlockStatement body = new BlockStatement();
         body.addStatement(createConstructorStatementMapSpecial(list.get(0).getField()));
-        createConstructorMapCommon(cNode, constructorStyle, body);
+        createConstructorMapCommon(cNode, body);
     }
 
-    private void createConstructorMap(ClassNode cNode, Expression constructorStyle, List<PropertyNode> list) {
+    private void createConstructorMap(ClassNode cNode, List<PropertyNode> list) {
         final BlockStatement body = new BlockStatement();
         for (PropertyNode pNode : list) {
             body.addStatement(createConstructorStatement(cNode, pNode));
@@ -191,10 +189,10 @@ public class ImmutableASTTransformation extends AbstractASTTransformation {
         // check for missing properties
         Expression checkArgs = new ArgumentListExpression(new VariableExpression("this"), new VariableExpression("args"));
         body.addStatement(new ExpressionStatement(new StaticMethodCallExpression(SELF_TYPE, "checkPropNames", checkArgs)));
-        createConstructorMapCommon(cNode, constructorStyle, body);
+        createConstructorMapCommon(cNode, body);
     }
 
-    private void createConstructorMapCommon(ClassNode cNode, Expression constructorStyle, BlockStatement body) {
+    private void createConstructorMapCommon(ClassNode cNode, BlockStatement body) {
         final List<FieldNode> fList = cNode.getFields();
         for (FieldNode fNode : fList) {
             if (fNode.isPublic()) continue; // public fields will be rejected elsewhere
@@ -204,7 +202,6 @@ public class ImmutableASTTransformation extends AbstractASTTransformation {
             if (fNode.isFinal() && fNode.getInitialExpression() != null) body.addStatement(checkFinalArgNotOverridden(cNode, fNode));
             body.addStatement(createConstructorStatementDefault(fNode));
         }
-        body.addStatement(assignStatement(constructorStyle, ConstantExpression.TRUE));
         final Parameter[] params = new Parameter[]{new Parameter(HASHMAP_TYPE, "args")};
         cNode.addConstructor(new ConstructorNode(ACC_PUBLIC, params, ClassNode.EMPTY_ARRAY, new IfStatement(
                 equalsNullExpr(new VariableExpression("args")),
diff --git a/src/main/org/codehaus/groovy/transform/ToStringASTTransformation.java b/src/main/org/codehaus/groovy/transform/ToStringASTTransformation.java
index 2992fdb141..1a2e6e2c5f 100644
--- a/src/main/org/codehaus/groovy/transform/ToStringASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/ToStringASTTransformation.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2011 the original author or authors.
+ * Copyright 2008-2012 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,9 +16,26 @@
 package org.codehaus.groovy.transform;
 
 import groovy.transform.ToString;
-import org.codehaus.groovy.ast.*;
-import org.codehaus.groovy.ast.expr.*;
-import org.codehaus.groovy.ast.stmt.*;
+import org.codehaus.groovy.ast.ASTNode;
+import org.codehaus.groovy.ast.AnnotatedNode;
+import org.codehaus.groovy.ast.AnnotationNode;
+import org.codehaus.groovy.ast.ClassHelper;
+import org.codehaus.groovy.ast.ClassNode;
+import org.codehaus.groovy.ast.FieldNode;
+import org.codehaus.groovy.ast.MethodNode;
+import org.codehaus.groovy.ast.Parameter;
+import org.codehaus.groovy.ast.PropertyNode;
+import org.codehaus.groovy.ast.expr.ConstantExpression;
+import org.codehaus.groovy.ast.expr.ConstructorCallExpression;
+import org.codehaus.groovy.ast.expr.DeclarationExpression;
+import org.codehaus.groovy.ast.expr.Expression;
+import org.codehaus.groovy.ast.expr.MethodCallExpression;
+import org.codehaus.groovy.ast.expr.StaticMethodCallExpression;
+import org.codehaus.groovy.ast.expr.VariableExpression;
+import org.codehaus.groovy.ast.stmt.BlockStatement;
+import org.codehaus.groovy.ast.stmt.ExpressionStatement;
+import org.codehaus.groovy.ast.stmt.ReturnStatement;
+import org.codehaus.groovy.ast.stmt.Statement;
 import org.codehaus.groovy.classgen.Verifier;
 import org.codehaus.groovy.control.CompilePhase;
 import org.codehaus.groovy.control.SourceUnit;
@@ -29,28 +46,24 @@ import org.codehaus.groovy.syntax.Types;
 import java.util.ArrayList;
 import java.util.List;
 
-import static org.codehaus.groovy.transform.AbstractASTTransformUtil.*;
+import static org.codehaus.groovy.transform.AbstractASTTransformUtil.getInstanceNonPropertyFields;
+import static org.codehaus.groovy.transform.AbstractASTTransformUtil.getInstanceProperties;
+import static org.codehaus.groovy.transform.AbstractASTTransformUtil.hasDeclaredMethod;
 
 /**
  * Handles generation of code for the @ToString annotation.
  *
  * @author Paul King
- * @author Andre Steingress
  */
 @GroovyASTTransformation(phase = CompilePhase.CANONICALIZATION)
 public class ToStringASTTransformation extends AbstractASTTransformation {
 
     static final Class MY_CLASS = ToString.class;
-
     static final ClassNode MY_TYPE = ClassHelper.make(MY_CLASS);
     static final String MY_TYPE_NAME = "@" + MY_TYPE.getNameWithoutPackage();
-
     private static final ClassNode STRINGBUFFER_TYPE = ClassHelper.make(StringBuffer.class);
     private static final ClassNode INVOKER_TYPE = ClassHelper.make(InvokerHelper.class);
-
     private static final Token ASSIGN = Token.newSymbol(Types.ASSIGN, -1, -1);
-    private static final Token LOGICAL_OR = Token.newSymbol(Types.LOGICAL_OR, -1, -1);
-    private static final Token COMPARE_NOT_EQUAL = Token.newSymbol(Types.COMPARE_NOT_EQUAL, -1, -1);
 
     public void visit(ASTNode[] nodes, SourceUnit source) {
         init(nodes, source);
@@ -69,8 +82,8 @@ public class ToStringASTTransformation extends AbstractASTTransformation {
             boolean includeFields = memberHasValue(anno, "includeFields", true);
             List<String> excludes = tokenize((String) getMemberValue(anno, "excludes"));
             List<String> includes = tokenize((String) getMemberValue(anno, "includes"));
-            boolean ignoreNullValues = memberHasValue(anno, "ignoreNullValues", true);
-
+            boolean ignoreNulls = memberHasValue(anno, "ignoreNulls", true);
+
             if (hasAnnotation(cNode, CanonicalASTTransformation.MY_TYPE)) {
                 AnnotationNode canonical = cNode.getAnnotations(CanonicalASTTransformation.MY_TYPE).get(0);
                 if (excludes == null || excludes.isEmpty()) excludes = tokenize((String) getMemberValue(canonical, "excludes"));
@@ -79,116 +92,69 @@ public class ToStringASTTransformation extends AbstractASTTransformation {
             if (includes != null && !includes.isEmpty() && excludes != null && !excludes.isEmpty()) {
                 addError("Error during " + MY_TYPE_NAME + " processing: Only one of 'includes' and 'excludes' should be supplied not both.", anno);
             }
-            toStringInit(cNode, new ConstantExpression(includeNames));
-            createToString(cNode, includeSuper, includeFields, excludes, includes, ignoreNullValues);
+            createToString(cNode, includeSuper, includeFields, excludes, includes, includeNames, ignoreNulls);
         }
     }
 
-    public static void createToString(ClassNode cNode, boolean includeSuper, boolean includeFields, List<String> excludes, List<String> includes) {
-        createToString(cNode, includeSuper, includeFields, excludes, includes, false);
-    }
-
-    public static void createToString(ClassNode cNode, boolean includeSuper, boolean includeFields, List<String> excludes, List<String> includes, boolean ignoreNullValues) {
+    public static void createToString(ClassNode cNode, boolean includeSuper, boolean includeFields, List<String> excludes, List<String> includes, boolean includeNames) {
+        createToString(cNode, includeSuper, includeFields, excludes, includes, includeNames, false);
+    }
+
+    public static void createToString(ClassNode cNode, boolean includeSuper, boolean includeFields, List<String> excludes, List<String> includes, boolean includeNames, boolean ignoreNulls) {
         // make a public method if none exists otherwise try a private method with leading underscore
         boolean hasExistingToString = hasDeclaredMethod(cNode, "toString", 0);
         if (hasExistingToString && hasDeclaredMethod(cNode, "_toString", 0)) return;
 
         final BlockStatement body = new BlockStatement();
-
-        // def $toStringLocalVar = null
-        final VariableExpression localVar = new VariableExpression("$toStringLocalVar");
-        body.addStatement(new ExpressionStatement(new DeclarationExpression(localVar, ASSIGN, ConstantExpression.NULL)));
-
-        // def $toStringLocalVarFirst = true
-        final VariableExpression localVarFirst = new VariableExpression("$toStringLocalVarFirst");
-        body.addStatement(new ExpressionStatement(new DeclarationExpression(localVarFirst, ASSIGN, ConstantExpression.TRUE)));
-
         // def _result = new StringBuffer()
         final Expression result = new VariableExpression("_result");
         final Expression init = new ConstructorCallExpression(STRINGBUFFER_TYPE, MethodCallExpression.NO_ARGUMENTS);
         body.addStatement(new ExpressionStatement(new DeclarationExpression(result, ASSIGN, init)));
 
-        // <class_name>(
         body.addStatement(append(result, new ConstantExpression(cNode.getName())));
         body.addStatement(append(result, new ConstantExpression("(")));
-
-        // append properties, append fields, append super
+        boolean first = true;
         List<PropertyNode> pList = getInstanceProperties(cNode);
         for (PropertyNode pNode : pList) {
             if (shouldSkip(pNode.getName(), excludes, includes)) continue;
+            first = appendPrefix(body, result, first, pNode.getName(), includeNames);
             String getterName = "get" + Verifier.capitalize(pNode.getName());
             Expression getter = new MethodCallExpression(VariableExpression.THIS_EXPRESSION, getterName, MethodCallExpression.NO_ARGUMENTS);
-
-            assignExpressionToVar(body, localVar, getter);
-            appendValue(cNode, body, localVar, result, pNode.getName(), localVarFirst, ignoreNullValues);
+            body.addStatement(append(result, new StaticMethodCallExpression(INVOKER_TYPE, "toString", getter)));
         }
-
         List<FieldNode> fList = new ArrayList<FieldNode>();
         if (includeFields) {
             fList.addAll(getInstanceNonPropertyFields(cNode));
         }
         for (FieldNode fNode : fList) {
             if (shouldSkip(fNode.getName(), excludes, includes)) continue;
-
-            assignExpressionToVar(body, localVar, new VariableExpression(fNode));
-            appendValue(cNode, body, localVar, result, fNode.getName(), localVarFirst, ignoreNullValues);
+            first = appendPrefix(body, result, first, fNode.getName(), includeNames);
+            body.addStatement(append(result, new StaticMethodCallExpression(INVOKER_TYPE, "toString", new VariableExpression(fNode))));
         }
-
         if (includeSuper) {
-            appendCommaIfNotFirst(result, localVarFirst, body);
-            appendPrefix(cNode, body, result, "super");
+            appendPrefix(body, result, first, "super", includeNames);
             // not through MOP to avoid infinite recursion
             body.addStatement(append(result, new MethodCallExpression(VariableExpression.SUPER_EXPRESSION, "toString", MethodCallExpression.NO_ARGUMENTS)));
         }
-
-        // )
         body.addStatement(append(result, new ConstantExpression(")")));
-
-        // return result.toString()
-        body.addStatement(new ReturnStatement(new MethodCallExpression(result, "toString", ArgumentListExpression.EMPTY_ARGUMENTS)));
+        body.addStatement(new ReturnStatement(new MethodCallExpression(result, "toString", MethodCallExpression.NO_ARGUMENTS)));
         cNode.addMethod(new MethodNode(hasExistingToString ? "_toString" : "toString", hasExistingToString ? ACC_PRIVATE : ACC_PUBLIC,
                 ClassHelper.STRING_TYPE, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, body));
     }
 
-    private static void appendValue(ClassNode cNode, BlockStatement body, VariableExpression localVar, Expression memberList, String nodeName, VariableExpression localVarFirst, boolean ignoreNullValues) {
-        final BlockStatement ifBlock = new BlockStatement();
-        
-        final IfStatement ifNotNull = new IfStatement(
-                // if (!ignoreValues || (value != null))
-                new BooleanExpression(new BinaryExpression(new NotExpression(new ConstantExpression(ignoreNullValues)), LOGICAL_OR, new BinaryExpression(localVar, COMPARE_NOT_EQUAL, ConstantExpression.NULL))),
-                ifBlock, 
-                EmptyStatement.INSTANCE
-        );
-
-        appendCommaIfNotFirst(memberList, localVarFirst, ifBlock);
-        appendPrefix(cNode, ifBlock, memberList, nodeName);
-
-        ifBlock.addStatement(append(memberList, new StaticMethodCallExpression(INVOKER_TYPE, "toString", localVar)));
-        ifBlock.addStatement(new IfStatement(new BooleanExpression(localVarFirst), assignStatement(localVarFirst, ConstantExpression.FALSE), EmptyStatement.INSTANCE));
-
-        body.addStatement(ifNotNull);
-    }
-
-    private static void appendCommaIfNotFirst(Expression memberList, VariableExpression localVarFirst, BlockStatement statements) {
-        // if (!$toStringLocalVarFirst) result.append(", ");
-        statements.addStatement(new IfStatement(new NotExpression(localVarFirst), append(memberList, new ConstantExpression(", ")), EmptyStatement.INSTANCE));
-    }
-
-    private static void assignExpressionToVar(BlockStatement body, VariableExpression localVar, Expression expression) {
-        body.addStatement(assignStatement(localVar, expression));
-    }
-
-    private static void appendPrefix(ClassNode cNode, BlockStatement body, Expression result, String name) {
-        body.addStatement(new IfStatement(
-                new BooleanExpression(new VariableExpression(cNode.getField("$print$names"))),
-                toStringPropertyName(result, name),
-                new EmptyStatement()
-        ));
+    private static boolean appendPrefix(BlockStatement body, Expression result, boolean first, String name, boolean includeNames) {
+        if (first) {
+            first = false;
+        } else {
+            body.addStatement(append(result, new ConstantExpression(", ")));
+        }
+        if (includeNames) body.addStatement(toStringPropertyName(result, name));
+        return first;
     }
 
     private static Statement toStringPropertyName(Expression result, String fName) {
         final BlockStatement body = new BlockStatement();
-        body.addStatement(append(result, new ConstantExpression(fName + ":")));
+        body.addStatement(append(result, new ConstantExpression(fName + ":")));
         return body;
     }
 
@@ -200,8 +166,4 @@ public class ToStringASTTransformation extends AbstractASTTransformation {
         return (excludes != null && excludes.contains(name)) || name.contains("$") || (includes != null && !includes.isEmpty() && !includes.contains(name));
     }
 
-    public static void toStringInit(ClassNode cNode, ConstantExpression fieldValue) {
-        cNode.addField("$print$names", ACC_PRIVATE | ACC_SYNTHETIC, ClassHelper.boolean_TYPE, fieldValue);
-    }
-
 }
diff --git a/src/test/org/codehaus/groovy/transform/ImmutableTransformTest.groovy b/src/test/org/codehaus/groovy/transform/ImmutableTransformTest.groovy
index d3aca51dd9..01887f4337 100644
--- a/src/test/org/codehaus/groovy/transform/ImmutableTransformTest.groovy
+++ b/src/test/org/codehaus/groovy/transform/ImmutableTransformTest.groovy
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2011 the original author or authors.
+ * Copyright 2008-2012 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -392,17 +392,24 @@ class ImmutableTransformTest extends GroovyShellTestCase {
         '''
     }
 
-    void testImmutableToString_TracksNamedParameters() {
+    void testImmutableToStringVariants() {
         assertScript '''
-            @groovy.transform.Immutable
-            class Person {
-                String first, last
-            }
+            import groovy.transform.*
+
+            @Immutable
+            class Person1 { String first, last }
+
+            @Immutable
+            @ToString(includeNames=true)
+            class Person2 { String first, last }
+
+            @Immutable
+            @ToString(excludes="last")
+            class Person3 { String first, last }
 
-            // normal toString
-            assert new Person("Hamlet", "D'Arcy").toString() == "Person(Hamlet, D'Arcy)"
-            // instance created with named parameters has special toString
-            assert new Person(first: "Hamlet", last: "D'Arcy").toString() == "Person(first:Hamlet, last:D'Arcy)"
+            assert new Person1("Hamlet", "D'Arcy").toString() == "Person1(Hamlet, D'Arcy)"
+            assert new Person2(first: "Hamlet", last: "D'Arcy").toString() == "Person2(first:Hamlet, last:D'Arcy)"
+            assert new Person3("Hamlet", "D'Arcy").toString() == "Person3(Hamlet)"
             '''
     }
 
diff --git a/src/test/org/codehaus/groovy/transform/ToStringTransformTest.groovy b/src/test/org/codehaus/groovy/transform/ToStringTransformTest.groovy
index 3b33f04fbd..e14cfa6df8 100644
--- a/src/test/org/codehaus/groovy/transform/ToStringTransformTest.groovy
+++ b/src/test/org/codehaus/groovy/transform/ToStringTransformTest.groovy
@@ -100,18 +100,18 @@ class ToStringTransformTest extends GroovyShellTestCase {
 
     void testIncludeFieldsAndIgnoreNullValues() {
         def toString = evaluate("""
-                            import groovy.transform.ToString
+            import groovy.transform.ToString
 
-                            @ToString(includeFields = true, includeNames = true, ignoreNullValues = true)
-                            class Person {
-                                String firstName
-                                String surName
+            @ToString(includeFields = true, includeNames = true, ignoreNullValues = true)
+            class Person {
+                String firstName
+                String surName
 
-                                private age = 50
-                            }
+                private age = 50
+            }
 
-                            new Person(firstName:null, surName: 'Doe').toString()
-                        """)
+            new Person(firstName:null, surName: 'Doe').toString()
+        """)
 
         assertEquals("Person(surName:Doe, age:50)", toString)
     }
@@ -143,15 +143,15 @@ class ToStringTransformTest extends GroovyShellTestCase {
     void testIgnoreStaticProperties()  {
 
         def toString = evaluate("""
-                import groovy.transform.ToString
+            import groovy.transform.ToString
 
-                @ToString
-                class Person {
-                    static int humanBeings = 0
-                }
+            @ToString
+            class Person {
+                static int humanBeings = 0
+            }
 
-                new Person().toString()
-            """)
+            new Person().toString()
+        """)
 
         assertEquals("Person()", toString)
     }
@@ -159,16 +159,16 @@ class ToStringTransformTest extends GroovyShellTestCase {
     void testWithCollection()  {
 
         def toString = evaluate("""
-                    import groovy.transform.ToString
+            import groovy.transform.ToString
 
-                    @ToString(includeNames = true)
-                    class Person {
-                        def relatives = []
-                        def mates = [:]
-                    }
+            @ToString(includeNames = true)
+            class Person {
+                def relatives = []
+                def mates = [:]
+            }
 
-                    new Person(relatives: ['a', 'b', 'c'], mates: [friends: ['c', 'd', 'e']]).toString()
-                """)
+            new Person(relatives: ['a', 'b', 'c'], mates: [friends: ['c', 'd', 'e']]).toString()
+        """)
 
         assertEquals("Person(relatives:[a, b, c], mates:[friends:[c, d, e]])", toString)
     }
@@ -176,15 +176,15 @@ class ToStringTransformTest extends GroovyShellTestCase {
     void testExcludesAndIgnoreNullValues()  {
 
         def toString = evaluate("""
-                        import groovy.transform.ToString
+            import groovy.transform.ToString
 
-                        @ToString(excludes = 'surName', ignoreNullValues = true)
-                        class Person {
-                            String surName
-                        }
+            @ToString(excludes = 'surName', ignoreNullValues = true)
+            class Person {
+                String surName
+            }
 
-                        new Person(surName: 'Doe').toString()
-                    """)
+            new Person(surName: 'Doe').toString()
+        """)
 
         assertEquals("Person()", toString)
     }
@@ -192,15 +192,15 @@ class ToStringTransformTest extends GroovyShellTestCase {
     void testIncludesAndIgnoreNullValues()  {
 
         def toString = evaluate("""
-                            import groovy.transform.ToString
+            import groovy.transform.ToString
 
-                            @ToString(includes = 'surName', ignoreNullValues = true)
-                            class Person {
-                                String surName
-                            }
+            @ToString(includes = 'surName', ignoreNullValues = true)
+            class Person {
+                String surName
+            }
 
-                            new Person(surName: null).toString()
-                        """)
+            new Person(surName: null).toString()
+        """)
 
         assertEquals("Person()", toString)
     }
@@ -208,15 +208,15 @@ class ToStringTransformTest extends GroovyShellTestCase {
     void testSkipInternalProperties()  {
 
         def toString = evaluate("""
-                            import groovy.transform.ToString
+            import groovy.transform.ToString
 
-                            @ToString(includeFields = true)
-                            class Person {
-                                private String \$surName = 'Doe'
-                            }
+            @ToString(includeFields = true)
+            class Person {
+                private String \$surName = 'Doe'
+            }
 
-                            new Person().toString()
-                            """)
+            new Person().toString()
+        """)
 
         assertEquals("Person()", toString)
     }
