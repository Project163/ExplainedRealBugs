diff --git a/src/main/groovy/lang/ExpandoMetaClass.java b/src/main/groovy/lang/ExpandoMetaClass.java
index 8bfc4d981e..61c6ed8a7f 100644
--- a/src/main/groovy/lang/ExpandoMetaClass.java
+++ b/src/main/groovy/lang/ExpandoMetaClass.java
@@ -537,7 +537,6 @@ public class  ExpandoMetaClass extends MetaClassImpl implements GroovyObject {
 					addMetaMethod(metaMethod);
                     expandoMethods.put(key,metaMethod);
 
-					cacheInstanceMethod(key, metaMethod);
 					if(inited && isGetter(methodName, metaMethod.getParameterTypes())) {
 						String propertyName = getPropertyForGetter(methodName);
 						registerBeanPropertyForMethod(metaMethod, propertyName, true, false);
@@ -675,7 +674,6 @@ public class  ExpandoMetaClass extends MetaClassImpl implements GroovyObject {
 	protected void registerStaticMethod(final String methodName, final Closure callable) {
 		performOperationOnMetaClass(new Callable() {
 			public void call() {
-
                 ClosureStaticMetaMethod metaMethod = new ClosureStaticMetaMethod(methodName, theClass,callable);
                 if(methodName.equals(INVOKE_METHOD_METHOD) && callable.getParameterTypes().length == 2) {
                     invokeStaticMethodMethod = metaMethod;
@@ -696,7 +694,6 @@ public class  ExpandoMetaClass extends MetaClassImpl implements GroovyObject {
                     }
                     performRegistryCallbacks();
                     expandoMethods.put(key,metaMethod);
-                    cacheStaticMethod(key, metaMethod);
                 }
 			}
 
@@ -786,7 +783,7 @@ public class  ExpandoMetaClass extends MetaClassImpl implements GroovyObject {
      * @see MetaClassImpl#getProperty(Class, Object, String, boolean, boolean)
      */
     public Object getProperty(Class sender, Object object, String name, boolean useSuper, boolean fromInsideClass) {
-        if(hasOverrideGetProperty(name)) {
+        if(hasOverrideGetProperty(name) && getJavaClass().isInstance(object)) {
             return getPropertyMethod.invoke(object, new Object[]{name});
         }
         return super.getProperty(sender, object, name, useSuper, fromInsideClass);
@@ -799,7 +796,7 @@ public class  ExpandoMetaClass extends MetaClassImpl implements GroovyObject {
      * @see MetaClassImpl#getProperty(Object, String)
      */    
     public Object getProperty(Object object, String name) {
-        if(hasOverrideGetProperty(name)) {
+        if(hasOverrideGetProperty(name) && getJavaClass().isInstance(object)) {
             return getPropertyMethod.invoke(object, new Object[]{name});
         }
         return super.getProperty(object,name);
@@ -816,7 +813,7 @@ public class  ExpandoMetaClass extends MetaClassImpl implements GroovyObject {
      */
 
     public void setProperty(Class sender, Object object, String name, Object newValue, boolean useSuper, boolean fromInsideClass) {
-        if(setPropertyMethod!=null  && !name.equals(META_CLASS_PROPERTY)) {
+        if(setPropertyMethod!=null  && !name.equals(META_CLASS_PROPERTY) && getJavaClass().isInstance(object)) {
             setPropertyMethod.invoke(object, new Object[]{name, newValue});
             return;
         }
diff --git a/src/main/groovy/lang/MetaClassImpl.java b/src/main/groovy/lang/MetaClassImpl.java
index ba0c33a9d2..72ce5ff4d6 100644
--- a/src/main/groovy/lang/MetaClassImpl.java
+++ b/src/main/groovy/lang/MetaClassImpl.java
@@ -1898,6 +1898,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
    
    private void addMethodToList(List list, MetaMethod method) {
        MetaMethod match = removeMatchingMethod(list,method);
+
        if (match==null) {
            list.add(method);
        } else if (match.isPrivate()){
@@ -1911,10 +1912,17 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
            Class methodC = method.getDeclaringClass();
            Class matchC = match.getDeclaringClass();
            if (methodC == matchC){
+               if(method.getName().equals("f"))
+                    System.out.println("adding original method back " + method);
+               
                if (method instanceof NewInstanceMetaMethod) {
                    // let DGM replace existing methods
                    list.add(method);
-               } else {
+               }
+               else if(method instanceof NewStaticMetaMethod) {
+                   list.add(method);
+               }
+               else {
                    list.add(match);
                }               
            } else if (MetaClassHelper.isAssignableFrom(methodC,matchC)){
diff --git a/src/test/groovy/lang/ExpandoMetaClassCreationHandleTest.groovy b/src/test/groovy/lang/ExpandoMetaClassCreationHandleTest.groovy
index fb300d76e6..9c4372d762 100644
--- a/src/test/groovy/lang/ExpandoMetaClassCreationHandleTest.groovy
+++ b/src/test/groovy/lang/ExpandoMetaClassCreationHandleTest.groovy
@@ -33,6 +33,17 @@ class ExpandoMetaClassCreationHandleTest extends GroovyTestCase {
 	}
 
 
+    void testInheritWithExistingMetaClass() {
+        registry.removeMetaClass(String.class)
+        registry.removeMetaClass(Object.class)
+
+        String foo = "hello"
+        assertEquals "HELLO", foo.toUpperCase()
+
+        Object.metaClass.doStuff = {-> delegate.toString().toUpperCase() }
+
+        assertEquals "HELLO", foo.doStuff()                
+    }
     void testInheritFromInterfaceHeirarchy() {
         registry.removeMetaClass(IBar.class)
         registry.removeMetaClass(Foo.class)
diff --git a/src/test/groovy/lang/ExpandoMetaClassTest.groovy b/src/test/groovy/lang/ExpandoMetaClassTest.groovy
index b34d8dc85f..30d680646e 100644
--- a/src/test/groovy/lang/ExpandoMetaClassTest.groovy
+++ b/src/test/groovy/lang/ExpandoMetaClassTest.groovy
@@ -21,6 +21,14 @@ package groovy.lang
 
 class ExpandoMetaClassTest extends GroovyTestCase {
 
+    void testOverrideStaticMethod() {        
+        TestStatic.metaClass.'static'.f = { "first" }
+        TestStatic.metaClass.'static'.f = { "second" }
+
+        assertEquals "second",TestStatic.f("")
+    }
+
+
     void testStaticBeanStyleProperties() {
         def mc = new ExpandoMetaClass(TestInvokeMethod.class, true)
         mc.initialize()
@@ -575,4 +583,5 @@ class Child extends Test {
     def aChildMethod() {
         "hello children"
     }
-}
\ No newline at end of file
+}
+class TestStatic {}
\ No newline at end of file
