diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 1d76859a94..1262f0d945 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -2663,11 +2663,8 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                     // if it is a wildcard, we're only able, for now, to perform limited type checking
                     // todo: improve type checking, which probably means having a more interesting data structure too
                     ClassNode nodeType = methodGenericTypes[0].isWildcard()?OBJECT_TYPE:getWrapper(methodGenericTypes[0].getType());
-                    GenericsType[] argumentGenericTypes = arguments[argNum].getGenericsTypes();
-                    ClassNode actualType = argumentGenericTypes != null ? getWrapper(argumentGenericTypes[0].getType()) : nodeType;
-                    if (!implementsInterfaceOrIsSubclassOf(actualType, nodeType)) {
-                        failure = true;
-                    }
+                    GenericsType gt = GenericsUtils.buildWildcardType(nodeType);
+                    failure = !UNKNOWN_PARAMETER_TYPE.equals(arguments[argNum]) && !gt.isCompatibleWith(getWrapper(arguments[argNum]));
                 } else {
                     // not sure this is possible !
                 }
diff --git a/src/test/groovy/transform/stc/GenericsSTCTest.groovy b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
index cf2c7e368d..57e53f9157 100644
--- a/src/test/groovy/transform/stc/GenericsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
@@ -607,6 +607,14 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
 
     }
 
+    void testMethodCallWithArgumentUsingNestedGenerics() {
+        assertScript '''
+           ThreadLocal<Map<Integer, String>> cachedConfigs = new ThreadLocal<Map<Integer, String>>()
+           def configs = new HashMap<Integer, String>()
+           cachedConfigs.set configs
+        '''
+    }
+
     static class MyList extends LinkedList<String> {}
 
     public static class ClassA<T> {
