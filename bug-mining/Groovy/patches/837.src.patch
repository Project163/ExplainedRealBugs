diff --git a/src/main/groovy/util/ProxyGenerator.java b/src/main/groovy/util/ProxyGenerator.java
index 6295e18c37..d65ff3be73 100644
--- a/src/main/groovy/util/ProxyGenerator.java
+++ b/src/main/groovy/util/ProxyGenerator.java
@@ -17,6 +17,7 @@ package groovy.util;
 
 import groovy.lang.*;
 import org.codehaus.groovy.control.MultipleCompilationErrorsException;
+import org.codehaus.groovy.runtime.ConversionHandler;
 import org.codehaus.groovy.runtime.DefaultGroovyMethods;
 import org.codehaus.groovy.runtime.InvokerHelper;
 
@@ -159,13 +160,11 @@ public class ProxyGenerator {
         // add overwriting methods
         Map<String, Method> selectedMethods = new HashMap<String, Method>();
         List<Method> publicAndProtectedMethods = getInheritedMethods(baseClass, new ArrayList<Method>());
-        List<Method> directMethods = getDeclaredMethodsList(baseClass);
         boolean closureIndicator = map.containsKey("*");
         for (Method method : publicAndProtectedMethods) {
             if (method.getName().indexOf('$') != -1
                     || Modifier.isFinal(method.getModifiers())
-                    || (containsEquivalentMethod(objectMethods, method)
-                    && !containsEquivalentMethod(directMethods, method))
+                    || ConversionHandler.isCoreObjectMethod(method)
                     || containsEquivalentMethod(selectedMethods.values(), method))
                 continue;
             if (map.containsKey(method.getName()) || closureIndicator) {
@@ -381,10 +380,6 @@ public class ProxyGenerator {
         return methods;
     }
 
-    private List<Method> getDeclaredMethodsList(Class baseClass) {
-        return new ArrayList<Method>(Arrays.asList(baseClass.getDeclaredMethods()));
-    }
-
     private void addNewMapCall(StringBuffer buffer, String methodName) {
         buffer.append("    def ").append(methodName).append("(Object[] args) {\n")
                 .append("        this.@closureMap['").append(methodName).append("'] (*args)\n    }\n");
diff --git a/src/main/org/codehaus/groovy/runtime/ConversionHandler.java b/src/main/org/codehaus/groovy/runtime/ConversionHandler.java
index dc5357ac57..2537c5b422 100644
--- a/src/main/org/codehaus/groovy/runtime/ConversionHandler.java
+++ b/src/main/org/codehaus/groovy/runtime/ConversionHandler.java
@@ -23,9 +23,10 @@ import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
 
 /**
- * This class is a general adapter to map a call to an Java interface 
+ * This class is a general adapter to map a call to a Java interface
  * to a given delegate.
- * <p>
+ * <p/>
+ *
  * @author Ben Yu
  * @author <a href="mailto:blackdrag@gmx.org">Jochen Theodorou</a>
  */
@@ -34,106 +35,119 @@ public abstract class ConversionHandler implements InvocationHandler, Serializab
     private static final long serialVersionUID = 1162833717190835227L;
 
     /**
-     * Creates a ConversionHandler with an deleagte.
+     * Creates a ConversionHandler with an delegate.
+     *
      * @param delegate the delegate
      * @throws IllegalArgumentException if the given delegate is null
      */
     public ConversionHandler(Object delegate) {
-        if (delegate==null) throw new IllegalArgumentException("delegate must not be null");
+        if (delegate == null) throw new IllegalArgumentException("delegate must not be null");
         this.delegate = delegate;
     }
-    
+
     /**
-     * gets the delegate.
+     * Returns the delegate.
+     *
      * @return the delegate
      */
-    public Object getDelegate(){
+    public Object getDelegate() {
         return delegate;
     }
-    
+
     /**
-     * This method is a default implementation for the invoke method
-     * given in Invocationhandler. Any call to an method with an
-     * declaring class that is not Object is redirected to invokeCustom. 
-     * Methods like tostring, equals and hashcode are called on the class
-     * itself instead of the delegate. It is better to overwrite the 
-     * invokeCustom method where the Object related methods are filtered out.
-     * 
-     * @see #invokeCustom(Object, Method, Object[])
-     * @see InvocationHandler#invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])
-     * 
-     * @param proxy the proxy
+     * This method is a default implementation for the invoke method given in
+     * Invocationhandler. Any call to a method with a declaring class that is
+     * not Object, excluding toString(), is redirected to invokeCustom.
+     * Methods like equals and hashcode are called on the class itself instead
+     * of the delegate because they are considered fundamental methods that should
+     * not be overwritten. The toString() method gets special treatment as it is
+     * deemed to be a method that you might wish to override when called from Groovy.
+     *
+     * In many scenarios, it is better to overwrite the invokeCustom method where
+     * the core Object related methods are filtered out.
+     *
+     * @param proxy  the proxy
      * @param method the method
-     * @param args the arguments
+     * @param args   the arguments
      * @return the result of the invocation by method or delegate
-     * @throws Throwable any exception caused by the delegate or the method
+     * @throws Throwable if caused by the delegate or the method
+     * @see #invokeCustom(Object, Method, Object[])
+     * @see InvocationHandler#invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])
      */
-    public Object invoke(Object proxy, Method method, Object[] args)
-    throws Throwable {
-        if(!isObjectMethod(method) || method.getName().equals("toString")){
-            return invokeCustom(proxy,method,args);
+    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
+        if (!isCoreObjectMethod(method)) {
+            return invokeCustom(proxy, method, args);
         }
         try {
             return method.invoke(this, args);
         } catch (InvocationTargetException ite) {
             throw ite.getTargetException();
-        }  
+        }
     }
-    
+
     /**
-     * This method is called for all Methods not defined on Object. 
+     * This method is called for all Methods not defined on Object.
      * The delegate should be called here.
-     * 
-     * @param proxy the proxy
+     *
+     * @param proxy  the proxy
      * @param method the method
-     * @param args the arguments
+     * @param args   the arguments
      * @return the result of the invocation of the delegate
      * @throws Throwable any exception causes by the delegate
      * @see #invoke(Object, Method, Object[])
      * @see InvocationHandler#invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])
-     * 
      */
     public abstract Object invokeCustom(Object proxy, Method method, Object[] args) throws Throwable;
-    
+
     /**
      * Indicates whether some other object is "equal to" this one.
      * The delegate is used if the class of the parameter and the
-     * current class are equal. In other cases the method will return 
+     * current class are equal. In other cases the method will return
      * false. The exact class is here used, if inheritance is needed,
-     * this method must be overwritten. 
-     *        
+     * this method must be overwritten.
+     *
      * @see java.lang.Object#equals(java.lang.Object)
      */
     public boolean equals(Object obj) {
-        if (obj instanceof Proxy){
+        if (obj instanceof Proxy) {
             obj = Proxy.getInvocationHandler(obj);
         }
-        
-        if (obj instanceof ConversionHandler){
-            return (((ConversionHandler)obj).getDelegate()).equals(delegate);
+
+        if (obj instanceof ConversionHandler) {
+            return (((ConversionHandler) obj).getDelegate()).equals(delegate);
         } else {
             return false;
         }
     }
 
     /**
-     * Returns a hash code value for the delegate. 
+     * Returns a hash code value for the delegate.
+     *
      * @see java.lang.Object#hashCode()
      */
     public int hashCode() {
         return delegate.hashCode();
     }
-    
+
     /**
      * Returns a String version of the delegate.
+     *
      * @see java.lang.Object#toString()
      */
     public String toString() {
         return delegate.toString();
     }
-    
-    private static boolean isObjectMethod(Method mtd){
-        return mtd.getDeclaringClass().equals(Object.class);
+
+    /**
+     * Checks whether a method is a core method from java.lang.Object.
+     * Such methods often receive special treatment because they are
+     * deemed fundamental enough to not be tampered with.
+     *
+     * @param method the method to check
+     * @return true if the method is deemed to be a core method
+     */
+    public static boolean isCoreObjectMethod(Method method) {
+        return Object.class.equals(method.getDeclaringClass()) && !"toString".equals(method.getName());
     }
 
 }
diff --git a/src/test/groovy/bugs/Groovy3205Bug.groovy b/src/test/groovy/bugs/Groovy3205Bug.groovy
new file mode 100644
index 0000000000..f55f47a96d
--- /dev/null
+++ b/src/test/groovy/bugs/Groovy3205Bug.groovy
@@ -0,0 +1,17 @@
+package groovy.bugs
+
+class Groovy3205Bug extends GroovyTestCase {
+    def void testOverrideToStringInMapOfClosures() {
+        def proxyImpl = [
+                control: { "new control" },
+                toString: { "new toString" }
+        ] as IGroovy3205Bug
+        assert proxyImpl.control() == "new control"
+        assert proxyImpl.toString() == "new toString"
+    }
+}
+
+class IGroovy3205Bug {
+    String control() { "original control" }
+    String toString() { "original toString" }
+}
