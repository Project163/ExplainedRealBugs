diff --git a/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java b/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
index 8f8b8801f1..98b99749d3 100644
--- a/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
+++ b/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
@@ -32,6 +32,7 @@ import org.codehaus.groovy.syntax.RuntimeParserException;
 import org.objectweb.asm.AnnotationVisitor;
 import org.objectweb.asm.*;
 
+import java.lang.reflect.Modifier;
 import java.util.*;
 
 /**
@@ -764,7 +765,7 @@ public class AsmClassGenerator extends ClassGenerator {
     private void makeMOPBasedConstructorCall(List<ConstructorNode> constructors, ConstructorCallExpression call, ClassNode callNode) {
         MethodVisitor mv = controller.getMethodVisitor();
         OperandStack operandStack = controller.getOperandStack();
-        
+
         call.getArguments().visit(this);
         // keep Object[] on stack
         mv.visitInsn(DUP);
@@ -946,8 +947,9 @@ public class AsmClassGenerator extends ClassGenerator {
 
     private void visitAttributeOrProperty(PropertyExpression expression, MethodCallerMultiAdapter adapter) {
         MethodVisitor mv = controller.getMethodVisitor();
-        
+
         Expression objectExpression = expression.getObjectExpression();
+        ClassNode classNode = controller.getClassNode();
         if (isThisOrSuper(objectExpression)) {
             // let's use the field expression if it's available
             String name = expression.getPropertyAsString();
@@ -955,13 +957,32 @@ public class AsmClassGenerator extends ClassGenerator {
                 FieldNode field = null;
                 boolean privateSuperField = false;
                 if (isSuperExpression(objectExpression)) {
-                    field = controller.getClassNode().getSuperClass().getDeclaredField(name);
+                    field = classNode.getSuperClass().getDeclaredField(name);
                     if (field != null && ((field.getModifiers() & ACC_PRIVATE) != 0)) {
                     	privateSuperField = true;
                     }
                 } else {
                 	if (controller.isNotExplicitThisInClosure(expression.isImplicitThis())) {
-                        field = controller.getClassNode().getDeclaredField(name);
+                        field = classNode.getDeclaredField(name);
+                        if (field==null && classNode instanceof InnerClassNode) {
+                            ClassNode outer = classNode.getOuterClass();
+                            FieldNode outerClassField;
+                            while (outer!=null) {
+                                outerClassField = outer.getDeclaredField(name);
+                                if (outerClassField!=null && outerClassField.isStatic() && outerClassField.isFinal()) {
+                                    if (outer!=classNode.getOuterClass() && Modifier.isPrivate(outerClassField.getModifiers())) {
+                                        throw new GroovyBugError("Trying to access private constant field ["+outerClassField.getDeclaringClass()+"#"+outerClassField.getName()+"] from inner class");
+                                    }
+                                    PropertyExpression pexp = new PropertyExpression(
+                                            new ClassExpression(outer),
+                                            expression.getProperty()
+                                    );
+                                    pexp.visit(controller.getAcg());
+                                    return;
+                                }
+                                outer = outer.getSuperClass();
+                            }
+                        }
                 	}
                 }
                 if (field != null && !privateSuperField) {//GROOVY-4497: don't visit super field if it is private 
@@ -991,7 +1012,7 @@ public class AsmClassGenerator extends ClassGenerator {
             // into this.this$0.this$0, where this.this$0 returns 
             // A.B and this.this$0.this$0 return A.
             ClassNode type = objectExpression.getType();
-            ClassNode iterType = controller.getClassNode();
+            ClassNode iterType = classNode;
             mv.visitVarInsn(ALOAD, 0);
             while (!iterType.equals(type)) {
                 String ownerName = BytecodeHelper.getClassInternalName(iterType);
diff --git a/src/test/groovy/bugs/Groovy5259Bug.groovy b/src/test/groovy/bugs/Groovy5259Bug.groovy
new file mode 100644
index 0000000000..4891260fff
--- /dev/null
+++ b/src/test/groovy/bugs/Groovy5259Bug.groovy
@@ -0,0 +1,112 @@
+package groovy.bugs
+
+class Groovy5259Bug extends GroovyTestCase {
+    void testInnerClassAccessingOuterClassConstant() {
+        // using a script because the bug is a compiler error
+        assertScript '''
+            class InnerAccessOuter {
+                static final String OUTER_CONSTANT = 'Constant Value'
+
+                class InnerClass {
+                    InnerClass() {
+                    }
+
+                    String innerCompiled() {
+                        OUTER_CONSTANT
+                    }
+                }
+
+                void testInnerClassAccessOuter() {
+                    def inner = new InnerClass()
+                    assert OUTER_CONSTANT == inner.innerCompiled()
+                }
+            }
+            new InnerAccessOuter().testInnerClassAccessOuter()
+        '''
+
+    }
+
+    void testInnerClassWithWrongCallToSuperAccessingOuterClassConstant() {
+        // using a script because the bug is a compiler error
+        shouldFail {
+            assertScript '''
+            class InnerAccessOuter {
+                protected static final String OUTER_CONSTANT = 'Constant Value'
+
+                class InnerClass {
+                    InnerClass() {
+                        // there's no Object#<init>(String) method, but it throws a VerifyError when a new instance
+                        // is created, meaning a wrong super call is generated
+                        super(OUTER_CONSTANT)
+                    }
+                    String m() {
+                         OUTER_CONSTANT
+                    }
+                }
+
+                void testInnerClassAccessOuter() {
+                    def inner = new InnerClass()
+                    inner.m()
+                }
+            }
+            new InnerAccessOuter().testInnerClassAccessOuter()
+        '''
+        }
+    }
+
+    void testInnerClassWithSuperClassAccessingOuterClassConstant() {
+        // using a script because the bug is a compiler error
+        assertScript '''
+            class Base {
+                Base(String str) {}
+            }
+            class InnerAccessOuter {
+                static final String OUTER_CONSTANT = 'Constant Value'
+
+                class InnerClass extends Base {
+                    InnerClass() {
+                        super(OUTER_CONSTANT)
+                    }
+
+                    String innerCompiled() { OUTER_CONSTANT }
+                }
+
+                void testInnerClassAccessOuter() {
+                    def inner = new InnerClass() // throws a VerifyError
+                    assert OUTER_CONSTANT == inner.innerCompiled()
+                }
+            }
+            new InnerAccessOuter().testInnerClassAccessOuter()
+        '''
+
+    }
+
+    void testInnerClassWithSuperClassAccessingSuperOuterClassConstant() {
+        // using a script because the bug is a compiler error
+        assertScript '''
+            class Base {
+                Base(String str) {}
+            }
+            class OuterBase {
+                protected static final String OUTER_CONSTANT = 'Constant Value'
+            }
+            class InnerAccessOuter extends OuterBase {
+
+                class InnerClass extends Base {
+                    InnerClass() {
+                        super(OUTER_CONSTANT)
+                    }
+
+                    String innerCompiled() { OUTER_CONSTANT }
+                }
+
+                void testInnerClassAccessOuter() {
+                    def inner = new InnerClass() // throws a VerifyError
+                    assert OUTER_CONSTANT == inner.innerCompiled()
+                }
+            }
+            new InnerAccessOuter().testInnerClassAccessOuter()
+        '''
+
+    }
+}
