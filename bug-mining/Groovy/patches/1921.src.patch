diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
index c962e8e8b0..38da14be0a 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
@@ -253,7 +253,7 @@ public abstract class StaticTypeCheckingSupport {
         ClassNode vargsBase = params[params.length - 1].getType().getComponentType();
         for (int i = params.length; i < args.length; i++) {
             if (!isAssignableTo(args[i],vargsBase)) return -1;
-            else if (!args[i].equals(vargsBase)) dist++;
+            else if (!args[i].equals(vargsBase)) dist+=getDistance(args[i], vargsBase);
         }
         return dist;
     }
@@ -274,7 +274,7 @@ public abstract class StaticTypeCheckingSupport {
         ClassNode ptype = params[params.length - 1].getType().getComponentType();
         ClassNode arg = args[args.length - 1];
         if (isNumberType(ptype) && isNumberType(arg) && !ptype.equals(arg)) return -1;
-        return isAssignableTo(arg, ptype)?(ptype.equals(arg)?0:1):-1;
+        return isAssignableTo(arg, ptype)?getDistance(arg,ptype):-1;
     }
 
     /**
@@ -945,7 +945,7 @@ public abstract class StaticTypeCheckingSupport {
                 }
                 int lastArgMatch = isVargs(params) && firstParamMatches?lastArgMatchesVarg(params, args):-1;
                 if (lastArgMatch>=0) {
-                    lastArgMatch+=((args.length-params.length)+1); // ensure exact matches are preferred over vargs
+                    lastArgMatch += 256-params.length; // ensure exact matches are preferred over vargs
                 }
                 int dist = allPMatch>=0?Math.max(allPMatch, lastArgMatch):lastArgMatch;
                 if (dist>=0 && !actualReceiver.equals(declaringClass)) dist+=getDistance(actualReceiver, declaringClass);
@@ -982,7 +982,7 @@ public abstract class StaticTypeCheckingSupport {
                         // varargs methods must not be preferred to methods without varargs
                         // for example :
                         // int sum(int x) should be preferred to int sum(int x, int... y)
-                        dist+=((args.length-params.length)+1);
+                        dist+=256-params.length;
                         if (params.length < args.length && dist >= 0) {
                             if (dist >= 0 && dist < bestDist) {
                                 bestChoices.clear();
diff --git a/src/test/groovy/transform/stc/BugsSTCTest.groovy b/src/test/groovy/transform/stc/BugsSTCTest.groovy
index e2d4345de3..eb7eb4edec 100644
--- a/src/test/groovy/transform/stc/BugsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/BugsSTCTest.groovy
@@ -244,4 +244,26 @@ class BugsSTCTest extends StaticTypeCheckingTestCase {
         list.add(new A())
         '''
     }
+
+    // GROOVY-5656
+    void testShouldNotThrowAmbiguousMethodError() {
+        assertScript '''import groovy.transform.*
+
+        class Expr {}
+        class VarExpr extends Expr {}
+
+        class ArgList {
+            ArgList(Expr e1) {  }
+            ArgList(Expr[] es) {  }
+        }
+
+        class Bug4 {
+            void test() {
+                new ArgList(new VarExpr())
+            }
+        }
+
+        new Bug4().test()
+        '''
+    }
 }
