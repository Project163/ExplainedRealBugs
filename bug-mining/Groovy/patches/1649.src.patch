diff --git a/src/main/org/codehaus/groovy/ast/tools/WideningCategories.java b/src/main/org/codehaus/groovy/ast/tools/WideningCategories.java
index 63a97550ad..d5f45332a4 100644
--- a/src/main/org/codehaus/groovy/ast/tools/WideningCategories.java
+++ b/src/main/org/codehaus/groovy/ast/tools/WideningCategories.java
@@ -19,6 +19,8 @@ import static org.codehaus.groovy.ast.ClassHelper.*;
 
 import org.codehaus.groovy.ast.ClassNode;
 import org.codehaus.groovy.ast.GenericsType;
+import org.codehaus.groovy.ast.MethodNode;
+import org.codehaus.groovy.vmplugin.VMPluginFactory;
 
 import java.util.*;
 
@@ -461,7 +463,7 @@ public class WideningCategories {
     protected static class LowestUpperBoundClassNode extends ClassNode {
         private final ClassNode compileTimeClassNode;
         protected final String name;
-
+		
         public LowestUpperBoundClassNode(String name, ClassNode upper, ClassNode... interfaces) {
             super(name, ACC_PUBLIC|ACC_FINAL, upper, interfaces, null);
             compileTimeClassNode = upper.equals(OBJECT_TYPE) && interfaces.length>0?interfaces[0]:upper;
@@ -469,6 +471,11 @@ public class WideningCategories {
             if (upper.isUsingGenerics()) {
                 setGenericsTypes(upper.getGenericsTypes());
             }
+			for (ClassNode anInterface : interfaces) {
+				for (MethodNode methodNode : anInterface.getMethods()) {
+					addMethod(methodNode.getName(), methodNode.getModifiers(), methodNode.getReturnType(), methodNode.getParameters(), methodNode.getExceptions(), methodNode.getCode());
+				}
+			}
         }
 
         @Override
@@ -485,7 +492,11 @@ public class WideningCategories {
         public Class getTypeClass() {
             return compileTimeClassNode.getTypeClass();
         }
-    }
+
+		/*public ClassNode[] getInterfaces() {
+			return interfaces;
+		}*/
+	}
 
     /**
      * Compares two class nodes, but including their generics types.
diff --git a/src/main/org/codehaus/groovy/transform/StaticTypesTransformation.java b/src/main/org/codehaus/groovy/transform/StaticTypesTransformation.java
index 7e7faad05c..88c918feb8 100644
--- a/src/main/org/codehaus/groovy/transform/StaticTypesTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/StaticTypesTransformation.java
@@ -16,6 +16,8 @@
 package org.codehaus.groovy.transform;
 
 import org.codehaus.groovy.ast.*;
+import org.codehaus.groovy.ast.expr.Expression;
+import org.codehaus.groovy.ast.stmt.ExpressionStatement;
 import org.codehaus.groovy.control.*;
 import org.codehaus.groovy.syntax.SyntaxException;
 import org.codehaus.groovy.transform.stc.StaticTypeCheckingVisitor;
@@ -38,18 +40,22 @@ public class StaticTypesTransformation implements ASTTransformation {
     public void visit(ASTNode[] nodes, SourceUnit source) {
 //        AnnotationNode annotationInformation = (AnnotationNode) nodes[0];
         AnnotatedNode node = (AnnotatedNode) nodes[1];
+		StaticTypeCheckingVisitor visitor = null;
         if (node instanceof ClassNode) {
             ClassNode classNode = (ClassNode) node;
-            StaticTypeCheckingVisitor visitor = newVisitor(source, classNode);
+            visitor = newVisitor(source, classNode);
             visitor.visitClass(classNode);
         } else if (node instanceof MethodNode) {
             MethodNode methodNode = (MethodNode)node;
-            StaticTypeCheckingVisitor visitor = newVisitor(source, methodNode.getDeclaringClass());
+            visitor = newVisitor(source, methodNode.getDeclaringClass());
             visitor.setMethodsToBeVisited(Collections.singleton(methodNode));
             visitor.visitMethod(methodNode);
         } else {
             source.addError(new SyntaxException(STATIC_ERROR_PREFIX + "Unimplemented node type", node.getLineNumber(), node.getColumnNumber()));
         }
+		if (visitor!=null) {
+			visitor.performSecondPass();
+		}
     }
 
     /**
diff --git a/src/main/org/codehaus/groovy/transform/stc/SharedVariableCollector.java b/src/main/org/codehaus/groovy/transform/stc/SharedVariableCollector.java
new file mode 100644
index 0000000000..7b64fbba23
--- /dev/null
+++ b/src/main/org/codehaus/groovy/transform/stc/SharedVariableCollector.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2003-2009 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.codehaus.groovy.transform.stc;
+
+import org.codehaus.groovy.ast.ClassCodeVisitorSupport;
+import org.codehaus.groovy.ast.expr.ClosureExpression;
+import org.codehaus.groovy.ast.expr.VariableExpression;
+import org.codehaus.groovy.control.SourceUnit;
+
+import java.util.Collections;
+import java.util.LinkedHashSet;
+import java.util.Set;
+
+/**
+ * A visitor which collects the list of variable expressions which are closure shared.
+ */
+public class SharedVariableCollector extends ClassCodeVisitorSupport {
+	private final SourceUnit unit;
+	private final Set<VariableExpression> closureSharedExpressions = new LinkedHashSet<VariableExpression>();
+	private boolean visited = false;
+	public SharedVariableCollector(final SourceUnit unit) {
+		this.unit = unit;
+	}
+
+	@Override
+	protected SourceUnit getSourceUnit() {
+		return unit;
+	}
+
+	public Set<VariableExpression> getClosureSharedExpressions() {
+		return Collections.unmodifiableSet(closureSharedExpressions);
+	}
+
+	@Override
+	public void visitVariableExpression(final VariableExpression expression) {
+		if (visited) {
+			// we should not visit embedded closures recursively
+			return;
+		}
+		visited = true;
+		if (expression.isClosureSharedVariable()) closureSharedExpressions.add(expression);
+		super.visitVariableExpression(expression);
+	}
+
+}
diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 88336fd762..c25b02e751 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -24,6 +24,7 @@ import org.codehaus.groovy.classgen.asm.InvocationWriter;
 import org.codehaus.groovy.control.SourceUnit;
 import org.codehaus.groovy.runtime.MetaClassHelper;
 import org.codehaus.groovy.transform.StaticTypesTransformation;
+import org.codehaus.groovy.util.ListHashMap;
 import org.objectweb.asm.Opcodes;
 
 import java.util.*;
@@ -78,6 +79,19 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
     private Set<MethodNode> alreadyVisitedMethods = new HashSet<MethodNode>();
 
+	/**
+	 * Some expressions need to be visited twice, because type information may be insufficient at some
+	 * point. For example, for closure shared variables, we need a first pass to collect every type which
+	 * is assigned to a closure shared variable, then a second pass to ensure that every method call on
+	 * such a variable is made on a LUB.
+	 */
+	private final LinkedHashSet<Expression> secondPassExpressions = new LinkedHashSet<Expression>();
+
+	/**
+	 * A map used to store every type used in closure shared variable assignments. In a second pass, we will
+	 * compute the LUB of each type and check that method calls on those variables are valid.
+	 */
+	private final Map<VariableExpression, List<ClassNode>> closureSharedVariablesAssignmentTypes = new HashMap<VariableExpression, List<ClassNode>>();
 
     private final ReturnAdder returnAdder = new ReturnAdder(new ReturnAdder.ReturnStatementListener() {
         public void returnStatementAdded(final ReturnStatement returnStatement) {
@@ -714,6 +728,17 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
     @Override
     public void visitClosureExpression(final ClosureExpression expression) {
+		// first, collect closure shared variables and reinitialize types
+		SharedVariableCollector collector = new SharedVariableCollector(getSourceUnit());
+		collector.visitClosureExpression(expression);
+		Set<VariableExpression> closureSharedExpressions = collector.getClosureSharedExpressions();
+		Map<VariableExpression, ListHashMap> typesBeforeVisit = null;
+		if (!closureSharedExpressions.isEmpty()) {
+			typesBeforeVisit = new HashMap<VariableExpression, ListHashMap>();
+			saveVariableExpressionMetadata(closureSharedExpressions, typesBeforeVisit);
+		}
+
+		// perform visit
         ClosureExpression oldClosureExpr = closureExpression;
         List<ClassNode> oldClosureReturnTypes = closureReturnTypes;
         closureExpression = expression;
@@ -727,9 +752,43 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
         closureExpression = oldClosureExpr;
         closureReturnTypes = oldClosureReturnTypes;
-    }
+		
+		// restore original metadata
+		restoreVariableExpressionMetadata(typesBeforeVisit);
+	}
+
+	private void restoreVariableExpressionMetadata(final Map<VariableExpression, ListHashMap> typesBeforeVisit) {
+		if (typesBeforeVisit!=null) {
+			for (Map.Entry<VariableExpression, ListHashMap> entry : typesBeforeVisit.entrySet()) {
+				VariableExpression ve = entry.getKey();
+				ListHashMap metadata = entry.getValue();
+				for (StaticTypesMarker marker : StaticTypesMarker.values()) {
+					ve.removeNodeMetaData(marker);
+					Object value = metadata.get(marker);
+					if (value!=null) ve.setNodeMetaData(marker, value);
+				}
+			}
+		}
+	}
+
+	private void saveVariableExpressionMetadata(final Set<VariableExpression> closureSharedExpressions, final Map<VariableExpression, ListHashMap> typesBeforeVisit) {
+		for (VariableExpression ve : closureSharedExpressions) {
+			ListHashMap<StaticTypesMarker,Object> metadata = new ListHashMap<StaticTypesMarker, Object>();
+			for (StaticTypesMarker marker : StaticTypesMarker.values()) {
+				Object value = ve.getNodeMetaData(marker);
+				if (value!=null) {
+					metadata.put(marker, value);
+				}
+			}
+			typesBeforeVisit.put(ve, metadata);
+			Variable accessedVariable = ve.getAccessedVariable();
+			if (accessedVariable!=ve && accessedVariable instanceof VariableExpression) {
+				saveVariableExpressionMetadata(Collections.singleton((VariableExpression)accessedVariable), typesBeforeVisit);
+			}
+		}
+	}
 
-    @Override
+	@Override
     public void visitMethod(final MethodNode node) {
         // alreadyVisitedMethods prevents from visiting the same method multiple times
         // and prevents from infinite loops
@@ -894,6 +953,13 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                         }
                         storeType(call, returnType);
                         storeTargetMethod(call, directMethodCallCandidate);
+
+						// if the object expression is a closure shared variable, we will have to perform a second pass
+						if (objectExpression instanceof VariableExpression) {
+							VariableExpression var = (VariableExpression) objectExpression;
+							if (var.isClosureSharedVariable()) secondPassExpressions.add(call);
+						}
+
                     } else {
                         addStaticTypeError("Reference to method is ambiguous. Cannot choose between "+mn, call);
                     }
@@ -1038,10 +1104,20 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             }
         }
         if (exp instanceof VariableExpression) {
-            final Variable accessedVariable = ((VariableExpression) exp).getAccessedVariable();
+			VariableExpression var = (VariableExpression) exp;
+			final Variable accessedVariable = var.getAccessedVariable();
             if (accessedVariable != null && accessedVariable != exp && accessedVariable instanceof VariableExpression) {
                 storeType((Expression) accessedVariable, cn);
             }
+			if (var.isClosureSharedVariable()) {
+				List<ClassNode> assignedTypes = closureSharedVariablesAssignmentTypes.get(var);
+				if (assignedTypes==null) {
+					assignedTypes = new LinkedList<ClassNode>();
+					closureSharedVariablesAssignmentTypes.put(var, assignedTypes);
+				}
+				assignedTypes.add(cn);
+			}
+
         }
     }
 
@@ -1621,7 +1697,42 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         this.methodsToBeVisited = methodsToBeVisited;
     }
 
-    /**
+	public void performSecondPass() {
+		for (Expression expression : secondPassExpressions) {
+			if (expression instanceof MethodCallExpression) {
+				MethodCallExpression call = (MethodCallExpression) expression;
+				Expression objectExpression = call.getObjectExpression();
+			 	if (objectExpression instanceof VariableExpression) {
+					 // this should always be the case, but adding a test is safer
+					 Variable target = findTargetVariable((VariableExpression) objectExpression);
+					 if (target instanceof VariableExpression) {
+						 VariableExpression var = (VariableExpression) target;
+						 List<ClassNode> classNodes = closureSharedVariablesAssignmentTypes.get(var);
+						 if (classNodes!=null && classNodes.size()>1) {
+							 ClassNode lub = lowestUpperBound(classNodes);
+							 MethodNode methodNode = (MethodNode) call.getNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET);
+							 // we must check that such a method exists on the LUB
+							 Parameter[] parameters = methodNode.getParameters();
+							 ClassNode[] params = new ClassNode[parameters.length];
+							 for (int i = 0; i < params.length; i++) {
+								 params[i] = parameters[i].getType();								 
+							 }
+							 List<MethodNode> method = findMethod(lub, methodNode.getName(), params);
+							 if (method.size()!=1) {
+								 addStaticTypeError("A closure shared variable ["+target.getName()+"] has been assigned with various types and the method" +
+								" ["+toMethodParametersString(methodNode.getName(), params)+"]"+
+								 " does not exist in the lowest upper bound of those types: ["+
+								 lub.toString(false)+"]. In general, this is a bad practice (variable reuse) because the compiler cannot"+
+								 " determine safely what is the type of the variable at the moment of the call in a multithreaded context.", call);
+							 }
+						 }
+					 }
+				 }
+			}
+		}
+	}
+
+	/**
      * A visitor used as a callback to {@link StaticTypeCheckingVisitor#existsProperty(org.codehaus.groovy.ast.expr.PropertyExpression, boolean, org.codehaus.groovy.ast.ClassCodeVisitorSupport)}
      * which will return set the type of the found property in the provided reference.
      */
diff --git a/src/test/groovy/transform/stc/ClosuresSTCTest.groovy b/src/test/groovy/transform/stc/ClosuresSTCTest.groovy
index 00ef4c4746..23613c007a 100644
--- a/src/test/groovy/transform/stc/ClosuresSTCTest.groovy
+++ b/src/test/groovy/transform/stc/ClosuresSTCTest.groovy
@@ -109,5 +109,22 @@ class ClosuresSTCTest extends StaticTypeCheckingTestCase {
             List<String> strings = [1,2,3].collect(new StringClosure())
         '''
     }
+
+    void testClosureShouldNotChangeInferredType() {
+        assertScript '''
+            def x = '123';
+            { -> x = new StringBuffer() }
+            x.charAt(0)
+        '''
+    }
+
+    void testClosureSharedVariableWithIncompatibleType() {
+        shouldFailWithMessages '''
+            def x = '123';
+            { -> x = 1 }
+            x.charAt(0)
+        ''', 'A closure shared variable [x] has been assigned with various types and the method [charAt(int)] does not exist in the lowest upper bound'
+    }
+
 }
 
