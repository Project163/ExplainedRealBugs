diff --git a/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java b/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
index 3c4a3dcf24..dc83fc1bcd 100644
--- a/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
+++ b/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
@@ -2908,36 +2908,48 @@ public class DefaultGroovyMethods {
         // add class header with constrcutor
         buffer.append("class ").append(name).append(" extends ")
                 .append(clazz.getName()).append(" {\n")
-                .append("private closureMap\n")
+                .append("    private closureMap\n    ")
                 .append(name).append("(map) {\n")
-                .append("super()\n")
-                .append("this.closureMap = map\n")
-                .append("}\n");
+                .append("        super()\n")
+                .append("        this.closureMap = map\n")
+                .append("    }\n");
 
         // add overwriting methods
         List selectedMethods = new ArrayList();
-        Method[] methods = clazz.getMethods();
-        for (int i = 0; i < methods.length; i++) {
-            if (map.containsKey(methods[i].getName())) {
-                selectedMethods.add(methods[i].getName());
-                buffer.append(methods[i].getReturnType().getName())
-                        .append(" ").append(methods[i].getName()).append(" (");
-                Class[] parameterTypes = methods[i].getParameterTypes();
+
+        List publicAndProtectedMethods = toList(clazz.getMethods());
+        // add the protected methods of the class and its parents
+        Class currentClass = clazz;
+        do {
+            Method[] protectedMethods = currentClass.getDeclaredMethods();
+            for (int i = 0; i < protectedMethods.length; i++) {
+                Method method = protectedMethods[i];
+                if (Modifier.isProtected(method.getModifiers()))
+                    publicAndProtectedMethods.add(method);
+            }
+            currentClass = currentClass.getSuperclass();
+        } while (currentClass != null);
+
+        Iterator iterator1 = publicAndProtectedMethods.iterator();
+        while (iterator1.hasNext()) {
+            Method method = (Method) iterator1.next();
+            if (map.containsKey(method.getName())) {
+                selectedMethods.add(method.getName());
+                buffer.append("    ").append(method.getReturnType().getSimpleName())
+                        .append(" ").append(method.getName()).append("(");
+                Class[] parameterTypes = method.getParameterTypes();
                 boolean first = true;
-                for (int parameterTypeIndex = 0;
-                     parameterTypeIndex < parameterTypes.length;
-                     parameterTypeIndex++) {
+                for (int parameterTypeIndex = 0; parameterTypeIndex < parameterTypes.length; parameterTypeIndex++) {
                     Class parameter = parameterTypes[parameterTypeIndex];
                     if (!first) {
                         buffer.append(", ");
                     } else {
                         first = false;
                     }
-                    buffer.append(parameter.getName()).append(" ")
+                    buffer.append(parameter.getSimpleName()).append(" ")
                             .append("p").append(parameterTypeIndex);
                 }
-                buffer.append(") {this.@closureMap['")
-                        .append(methods[i].getName()).append("'](");
+                buffer.append(") { this.@closureMap['").append(method.getName()).append("'] (");
                 first = true;
                 for (int j = 0; j < parameterTypes.length; j++) {
                     if (!first) {
@@ -2947,7 +2959,7 @@ public class DefaultGroovyMethods {
                     }
                     buffer.append("p").append(j);
                 }
-                buffer.append(")}\n");
+                buffer.append(") }\n");
 
             }
         }
@@ -2955,13 +2967,12 @@ public class DefaultGroovyMethods {
         for (Iterator iterator = map.keySet().iterator(); iterator.hasNext();) {
             String methodName = (String) iterator.next();
             if (selectedMethods.contains(methodName)) continue;
-            buffer.append("def ").append(methodName).append("(Object[] args {\n")
-                    .append("this.@closureMap['").append(methodName)
-                    .append("'](*args)\n}\n");
+            buffer.append("    def ").append(methodName).append("(Object[] args) { \n")
+                    .append("        this.@closureMap['").append(methodName).append("'] (*args)\n    }\n");
         }
         // end class
-        buffer.append("}\n")
-                .append("new ").append(name).append("(map)");
+        buffer.append("}\n").append("new ").append(name).append("(map)");
+        
         Binding binding = new Binding();
         binding.setVariable("map", map);
         GroovyShell shell = new GroovyShell(clazz.getClassLoader(), binding);
diff --git a/src/test/groovy/lang/MapOfClosureTest.groovy b/src/test/groovy/lang/MapOfClosureTest.groovy
index 87c0841bab..2a19420738 100644
--- a/src/test/groovy/lang/MapOfClosureTest.groovy
+++ b/src/test/groovy/lang/MapOfClosureTest.groovy
@@ -16,30 +16,80 @@
 package groovy.lang
 
 /**
- * Tests maps containing closures coerced to classes by asType
- *   @author Jochen Theodorou
+ * Tests maps of closures coerced to classes by asType()
+ *
+ * @author Jochen Theodorou
+ * @author Guillaume Laforge
  */
 class MapOfClosureTest extends GroovyTestCase {
 
-  void testInterfaceProxy() {
-     def outer=1
-     def x = [run:{outer++}] as Runnable
-     x.run()
-     assert x instanceof Runnable
-     assert outer==2
-  }
-  
-  void testObject() {
-     def m = [run:{}]
-     def x = m as Object
-     assert x.is(m)
-  }
-  
-  void testAbstractClassSubclassing() {
-     def outer=1
-     def x = [run:{outer++}] as TimerTask
-     x.run()
-     assert x instanceof TimerTask
-     assert outer==2
-  }
+    void testInterfaceProxy() {
+        def outer = 1
+        def x = [run: { outer++ }] as Runnable
+        x.run()
+
+        assert x instanceof Runnable
+        assert outer == 2
+    }
+
+    void testObject() {
+        def m = [bar: { "foo" }]
+        def x = m as Object
+
+        assert x.is(m)
+        assert "foo" == x.bar()
+    }
+
+    void testAbstractClassSubclassing() {
+        def outer = 1
+        def x = [run: { outer++ }] as TimerTask
+        x.run()
+        assert x instanceof TimerTask
+        assert outer == 2
+    }
+
+    /**
+     * Checks public and protected methods from parents can also be overriden by the Map coercion to classes.
+     */
+    void testOverrideProtectedMethods() {
+        def b = [pub: { "map pub" }, prot: { "map prot" }, child: { "map child" }] as B
+
+        assert "map pub" == b.pub()
+        assert "map prot" == b.prot()
+        assert "map child" == b.child()
+        assert "abstract" == b.abstractMethod()
+    }
+
+    /**
+     * Checks that abstract methods can also be overriden.
+     */
+    void testAbstractMethodIsOverrided() {
+        def a = [abstractMethod: { "map abstract" }] as A
+
+        assert "map abstract" == a.abstractMethod()
+    }
+
+    /**
+     * Verify that complex method signatures, even with primitive types and arrays, can be overriden.
+     */
+    void testComplexMethodSignature() {
+        def c = [foo: { int a, List b, Double[] c -> ["map foo"] as String[] }] as C
+
+        assert ["map foo"] as String[] == c.foo(1, ['a', 'b'], [0.2, 0.3] as Double[])
+    }
+}
+
+abstract class A {
+    protected prot() { "prot" }
+    def pub() { "pub" }
+    abstract abstractMethod()
+}
+
+class B extends A {
+    protected child() { "child" }
+    def abstractMethod() { "abstract" }
+}
+
+class C {
+    String[] foo(int a, List b, Double[] c) { ["foo"] as String[] }
 }
\ No newline at end of file
