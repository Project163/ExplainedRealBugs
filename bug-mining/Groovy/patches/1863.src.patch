diff --git a/src/main/org/codehaus/groovy/ast/tools/GenericsUtils.java b/src/main/org/codehaus/groovy/ast/tools/GenericsUtils.java
index 2130868e28..b37fb7dc42 100644
--- a/src/main/org/codehaus/groovy/ast/tools/GenericsUtils.java
+++ b/src/main/org/codehaus/groovy/ast/tools/GenericsUtils.java
@@ -166,6 +166,7 @@ public class GenericsUtils {
         extractPlaceholders(classNode, parameters);
         ClassNode node = interfaceFromClassNode.getPlainNodeReference();
         GenericsType[] interfaceGTs = interfaceFromClassNode.getGenericsTypes();
+        if (interfaceGTs==null) return anInterface;
         GenericsType[] types = new GenericsType[interfaceGTs.length];
         for (int i = 0; i < interfaceGTs.length; i++) {
             GenericsType interfaceGT = interfaceGTs[i];
diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 19105eb4de..1a3ecb2900 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -774,7 +774,10 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 LinkedList<ClassNode> queue = new LinkedList<ClassNode>();
                 queue.add(testClass);
                 if (testClass.isInterface()) {
-                    queue.addAll(testClass.getAllInterfaces());
+                    Set<ClassNode> allInterfaces = testClass.getAllInterfaces();
+                    for (ClassNode intf : allInterfaces) {
+                        queue.add(GenericsUtils.parameterizeInterfaceGenerics(testClass, intf));
+                    }
                 }
                 while (!queue.isEmpty()) {
                     ClassNode current = queue.removeFirst();
@@ -792,7 +795,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                         MethodNode setterMethod = current.getSetterMethod("set" + capName);
                         if (setterMethod != null) {
                             if (visitor != null) visitor.visitMethod(getter);
-                            storeType(pexp, getter.getReturnType());
+                            storeType(pexp, inferReturnTypeGenerics(current, getter, ArgumentListExpression.EMPTY_ARGUMENTS));
                             return true;
                         }
                     }
@@ -813,19 +816,19 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 if (checkForReadOnly) {
                     queue = new LinkedList<ClassNode>();
                     queue.add(testClass);
-                    if (testClass.isInterface()) {
-                        queue.addAll(testClass.getAllInterfaces());
+                    Set<ClassNode> allInterfaces = testClass.getAllInterfaces();
+                    for (ClassNode intf : allInterfaces) {
+                        queue.add(GenericsUtils.parameterizeInterfaceGenerics(testClass, intf));
                     }
                     while (!queue.isEmpty()) {
                         ClassNode current = queue.removeFirst();
-                        current = current.redirect();
 
                         MethodNode getter = current.getGetterMethod("get" + capName);
                         if (getter == null) getter = current.getGetterMethod("is" + capName);
                         if (getter != null) {
                             if (visitor != null) visitor.visitMethod(getter);
                             pexp.putNodeMetaData(StaticTypesMarker.READONLY_PROPERTY, Boolean.TRUE);
-                            storeType(pexp, getter.getReturnType());
+                            storeType(pexp, inferReturnTypeGenerics(current, getter, ArgumentListExpression.EMPTY_ARGUMENTS));
                             return true;
                         }
                         if (pluginFactory != null) {
@@ -855,7 +858,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                         if (visitor!=null) {
                             visitor.visitMethod(getter);
                         }
-                        storeType(pexp, getter.getReturnType());
+                        storeType(pexp, inferReturnTypeGenerics(testClass, getter, ArgumentListExpression.EMPTY_ARGUMENTS));
                         return true;
                     }
                 }
@@ -954,14 +957,19 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             collectionExpression.visit(this);
             final ClassNode collectionType = getType(collectionExpression);
             ClassNode componentType = inferLoopElementType(collectionType);
-            if (ClassHelper.getUnwrapper(componentType) == forLoop.getVariableType()) {
+            ClassNode forLoopVariableType = forLoop.getVariableType();
+            if (ClassHelper.getUnwrapper(componentType) == forLoopVariableType) {
                 // prefer primitive type over boxed type
-                componentType = forLoop.getVariableType();
+                componentType = forLoopVariableType;
             }
-            controlStructureVariables.put(forLoop.getVariable(), componentType);
-            if (!checkCompatibleAssignmentTypes(forLoop.getVariableType(), componentType)) {
-                addStaticTypeError("Cannot loop with element of type " + forLoop.getVariableType() + " with collection of type " + collectionType, forLoop);
+            if (!checkCompatibleAssignmentTypes(forLoopVariableType, componentType)) {
+                addStaticTypeError("Cannot loop with element of type " + forLoopVariableType + " with collection of type " + collectionType, forLoop);
+            }
+            if (forLoopVariableType!=DYNAMIC_TYPE) {
+                // user has specified a type, prefer it over the inferred type
+                componentType = forLoopVariableType;
             }
+            controlStructureVariables.put(forLoop.getVariable(), componentType);
             try {
                 super.visitForLoop(forLoop);
             } finally {
@@ -2502,16 +2510,10 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         }
         if (!isUsingGenericsOrIsArrayUsingGenerics(returnType)) return returnType;
         GenericsType[] returnTypeGenerics = returnType.isArray() ? returnType.getComponentType().getGenericsTypes() : returnType.getGenericsTypes();
-        List<GenericsType> placeholders = new LinkedList<GenericsType>();
-        for (GenericsType returnTypeGeneric : returnTypeGenerics) {
-            if (returnTypeGeneric.isPlaceholder() || returnTypeGeneric.isWildcard()) {
-                placeholders.add(returnTypeGeneric);
-            }
-        }
-        if (placeholders.isEmpty()) return returnType; // nothing to infer
         Map<String, GenericsType> resolvedPlaceholders = new HashMap<String, GenericsType>();
         GenericsUtils.extractPlaceholders(receiver, resolvedPlaceholders);
         GenericsUtils.extractPlaceholders(method.getReturnType(), resolvedPlaceholders);
+        if (resolvedPlaceholders.isEmpty()) return returnType;
         // then resolve receivers from method arguments
         Parameter[] parameters = method.getParameters();
         boolean isVargs = isVargs(parameters);
@@ -2561,15 +2563,17 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 }
             }
         }
+
         GenericsType[] copy = new GenericsType[returnTypeGenerics.length];
+        Set<GenericsType> visitedResolvedGenericsTypes = new LinkedHashSet<GenericsType>();
         for (int i = 0; i < copy.length; i++) {
             GenericsType returnTypeGeneric = returnTypeGenerics[i];
             if (returnTypeGeneric.isPlaceholder() || returnTypeGeneric.isWildcard()) {
                 GenericsType resolved = resolvedPlaceholders.get(returnTypeGeneric.getName());
                 if (resolved == null) resolved = returnTypeGeneric;
-                copy[i] = resolved;
+                copy[i] = fullyResolve(resolved, resolvedPlaceholders, visitedResolvedGenericsTypes);
             } else {
-                copy[i] = returnTypeGeneric;
+                copy[i] = fullyResolve(returnTypeGeneric, resolvedPlaceholders, visitedResolvedGenericsTypes);
             }
         }
         if (returnType.equals(OBJECT_TYPE)) {
@@ -2594,6 +2598,44 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         return returnType;
     }
 
+    /**
+     * Given a generics type representing SomeClass&lt;T,V&gt; and a resolved placeholder map, returns a new generics type
+     * for which placeholders are resolved recursively.
+     */
+    private static GenericsType fullyResolve(GenericsType gt, Map<String, GenericsType> placeholders, Set<GenericsType> visited) {
+        if (visited.contains(gt)) return gt;
+        visited.add(gt);
+        if (gt.isPlaceholder() && placeholders.containsKey(gt.getName())) {
+            gt = placeholders.get(gt.getName());
+        }
+        ClassNode type = gt.getType();
+        fullyResolveType(type, placeholders, visited);
+        ClassNode lowerBound = gt.getLowerBound();
+        if (lowerBound!=null) fullyResolveType(lowerBound, placeholders, visited);
+        ClassNode[] upperBounds = gt.getUpperBounds();
+        if (upperBounds!=null) {
+            for (ClassNode upperBound : upperBounds) {
+                fullyResolveType(upperBound, placeholders, visited);
+            }
+        }
+        return gt;
+    }
+
+    private static void fullyResolveType(final ClassNode type, final Map<String, GenericsType> placeholders, Set<GenericsType> visited) {
+        if (type.isUsingGenerics()) {
+            GenericsType[] gts = type.getGenericsTypes();
+            if (gts!=null) {
+                for (int i = 0; i < gts.length; i++) {
+                    GenericsType genericsType = gts[i];
+                    gts[i] = fullyResolve(genericsType, placeholders, visited);
+                }
+            }
+            type.setGenericsTypes(gts);
+        } else if (type.isArray()) {
+            fullyResolveType(type.getComponentType(), placeholders, visited);
+        }
+    }
+
     private void typeCheckMethodsWithGenerics(ClassNode receiver, ClassNode[] arguments, MethodNode candidateMethod, Expression location) {
         if (!isUsingGenericsOrIsArrayUsingGenerics(receiver)) return;
         boolean failure = false;
diff --git a/src/test/groovy/transform/stc/GenericsSTCTest.groovy b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
index 366bcdda09..3007ad64c2 100644
--- a/src/test/groovy/transform/stc/GenericsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
@@ -535,6 +535,55 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
         '''
     }
 
+    // GROOVY-5594
+    void testMapEntryUsingPropertyNotation() {
+        assertScript '''
+        Map.Entry<Date, Integer> entry
+
+        @ASTTest(phase=INSTRUCTION_SELECTION, value={
+            assert node.getNodeMetaData(INFERRED_TYPE) == make(Date)
+        })
+        def k = entry?.key
+
+        @ASTTest(phase=INSTRUCTION_SELECTION, value={
+            assert node.getNodeMetaData(INFERRED_TYPE) == Integer_TYPE
+        })
+        def v = entry?.value
+        '''
+    }
+
+    void testInferenceFromMap() {
+        assertScript '''
+        Map<Date, Integer> map
+
+        @ASTTest(phase=INSTRUCTION_SELECTION, value={
+            def infType = node.getNodeMetaData(INFERRED_TYPE)
+            assert infType == make(Set)
+            def entryInfType = infType.genericsTypes[0].type
+            assert entryInfType == make(Map.Entry)
+            assert entryInfType.genericsTypes[0].type == make(Date)
+            assert entryInfType.genericsTypes[1].type == Integer_TYPE
+        })
+        def entries = map?.entrySet()
+        '''
+    }
+
+    void testInferenceFromListOfMaps() {
+        assertScript '''
+        List<Map<Date, Integer>> maps
+
+        @ASTTest(phase=INSTRUCTION_SELECTION, value={
+            def listType = node.getNodeMetaData(INFERRED_TYPE)
+            assert listType == Iterator_TYPE
+            def infType = listType.genericsTypes[0].type
+            assert infType == make(Map)
+            assert infType.genericsTypes[0].type == make(Date)
+            assert infType.genericsTypes[1].type == Integer_TYPE
+        })
+        def iter = maps?.iterator()
+        '''
+    }
+
     static class MyList extends LinkedList<String> {}
 
     public static class ClassA<T> {
diff --git a/src/test/groovy/transform/stc/LoopsSTCTest.groovy b/src/test/groovy/transform/stc/LoopsSTCTest.groovy
index 13d1d9aeee..e37dd06683 100644
--- a/src/test/groovy/transform/stc/LoopsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/LoopsSTCTest.groovy
@@ -15,6 +15,12 @@
  */
 package groovy.transform.stc
 
+import org.codehaus.groovy.ast.ClassCodeVisitorSupport
+import org.codehaus.groovy.control.SourceUnit
+import org.codehaus.groovy.ast.stmt.Statement
+import org.codehaus.groovy.ast.MethodNode
+import org.codehaus.groovy.ast.ClassNode
+
 /**
  * Unit tests for static type checking : loops.
  *
@@ -107,5 +113,67 @@ class LoopsSTCTest extends StaticTypeCheckingTestCase {
             }
         ''', 'Cannot find matching method'
     }
+
+    // GROOVY-5587
+    void testMapEntryInForInLoop() {
+        assertScript '''
+            void test() {
+                def result = ""
+                def sum = 0
+                forLoop:
+                for ( Map.Entry<String, Integer> it in [a:1, b:3].entrySet() ) {
+                   result += it.getKey()
+                   sum += it.getValue()
+                }
+                assert result == "ab"
+                assert sum == 4
+            }
+            test()
+        '''
+    }
+
+    public static class LabelFinder extends ClassCodeVisitorSupport {
+
+
+        public static List<Statement> lookup(MethodNode node, String label) {
+            LabelFinder finder = new LabelFinder(label, null)
+            node.code.visit(finder)
+
+            finder.targets
+        }
+
+        public static List<Statement> lookup(ClassNode node, String label) {
+            LabelFinder finder = new LabelFinder(label, null)
+            node.methods*.code*.visit(finder)
+            node.declaredConstructors*.code*.visit(finder)
+
+            finder.targets
+        }
+
+        private final String label
+        private final SourceUnit unit
+
+        private List<Statement> targets = new LinkedList<Statement>();
+
+        LabelFinder(final String label, final SourceUnit unit) {
+            this.label = label
+            this.unit = unit;
+        }
+
+        @Override
+        protected SourceUnit getSourceUnit() {
+            unit
+        }
+
+        @Override
+        protected void visitStatement(final Statement statement) {
+            super.visitStatement(statement)
+            if (statement.statementLabel==label) targets << statement
+        }
+
+        List<Statement> getTargets() {
+            return Collections.unmodifiableList(targets)
+        }
+    }
 }
 
