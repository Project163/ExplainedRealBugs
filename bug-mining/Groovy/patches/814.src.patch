diff --git a/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java b/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
index 4a30f75fdb..217679c653 100644
--- a/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
+++ b/src/main/org/codehaus/groovy/classgen/AsmClassGenerator.java
@@ -2259,13 +2259,11 @@ public class AsmClassGenerator extends ClassGenerator {
         		&& !classNode.hasPossibleMethod(methodName, arguments)
         		&& isNotExplicitThisInClosure(call.isImplicitThis())) {
             // let's invoke the closure method
-            visitVariableExpression(new VariableExpression(methodName));
-            if (arguments instanceof TupleExpression) {
-                arguments.visit(this);
-            } else {
-                new TupleExpression(arguments).visit(this);
-            }
-            invokeClosureMethod.call(mv);
+        	invokeClosure(arguments, methodName);
+        } else if(call.isImplicitThis() && isThisExpression && compileStack.containsVariable(methodName)) {
+        	// if it is a non-qualified method call (implicitThis=true) on a local variable 
+        	// of the same name, then it should take precedence (GROOVY-3069)
+        	invokeClosure(arguments, methodName);
         } else {
             MethodCallerMultiAdapter adapter = invokeMethod;
             if (isThisExpression) adapter = invokeMethodOnCurrent;
@@ -2274,6 +2272,16 @@ public class AsmClassGenerator extends ClassGenerator {
             makeInvokeMethodCall(call, isSuperMethodCall, adapter);
         }
     }
+    
+    private void invokeClosure(Expression arguments, String methodName) {
+        visitVariableExpression(new VariableExpression(methodName));
+        if (arguments instanceof TupleExpression) {
+            arguments.visit(this);
+        } else {
+            new TupleExpression(arguments).visit(this);
+        }
+        invokeClosureMethod.call(mv);
+    }
 
     private boolean isStaticInvocation(MethodCallExpression call) {
         if (!isThisExpression(call.getObjectExpression())) return false;
diff --git a/src/main/org/codehaus/groovy/tools/shell/BufferManager.groovy b/src/main/org/codehaus/groovy/tools/shell/BufferManager.groovy
index 9acbb2d069..6370247748 100644
--- a/src/main/org/codehaus/groovy/tools/shell/BufferManager.groovy
+++ b/src/main/org/codehaus/groovy/tools/shell/BufferManager.groovy
@@ -62,7 +62,7 @@ class BufferManager
         def i = buffers.size() - 1
 
         if (select) {
-            select(i)
+            this.select(i)
         }
         
         if (log.debugEnabled) {
diff --git a/src/test/groovy/bugs/Groovy3069Bug.groovy b/src/test/groovy/bugs/Groovy3069Bug.groovy
new file mode 100644
index 0000000000..6dc8993102
--- /dev/null
+++ b/src/test/groovy/bugs/Groovy3069Bug.groovy
@@ -0,0 +1,44 @@
+package groovy.bugs
+
+class Groovy3069Bug extends GroovyTestCase {
+    final String CLOSURE_STR = '[Closure]'
+    final String CLASS_METHOD_STR = '[ClassMethod]'
+
+    def void testClosureParamPrecedenceWithTypeSpecified() {
+        def cl = { CLOSURE_STR }
+        checkPrecendenceWithTypeSpecified(cl)
+    }
+
+    def void testClosureParamPrecedenceWithTypeNotSpecified() {
+        def cl = { CLOSURE_STR }
+        checkPrecendenceWithTypeNotSpecified(cl)
+    }
+
+    def void testClosureLocalVarPrecedenceExplicitClosureType() {
+        Closure method = { CLOSURE_STR }
+
+        assert method() == CLOSURE_STR
+        assert this.method() == CLASS_METHOD_STR
+    }
+
+    def void testClosureLocalVarPrecedenceImplicitClosureType() {
+        def method = { CLOSURE_STR }
+
+        assert method() == CLOSURE_STR
+        assert this.method() == CLASS_METHOD_STR
+    }
+
+    String method() {
+        return CLASS_METHOD_STR
+    }
+
+    String checkPrecendenceWithTypeSpecified(Closure method) {
+        assert method() == CLOSURE_STR
+        assert this.method() == CLASS_METHOD_STR
+    }
+
+    String checkPrecendenceWithTypeNotSpecified(method) {
+        assert method() == CLOSURE_STR
+        assert this.method() == CLASS_METHOD_STR
+    }
+}
