diff --git a/src/main/org/codehaus/groovy/transform/trait/TraitASTTransformation.java b/src/main/org/codehaus/groovy/transform/trait/TraitASTTransformation.java
index 1543f788d1..44d944d465 100644
--- a/src/main/org/codehaus/groovy/transform/trait/TraitASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/trait/TraitASTTransformation.java
@@ -19,6 +19,7 @@ import groovy.transform.CompilationUnitAware;
 import org.codehaus.groovy.ast.ASTNode;
 import org.codehaus.groovy.ast.AnnotatedNode;
 import org.codehaus.groovy.ast.AnnotationNode;
+import org.codehaus.groovy.ast.ClassCodeExpressionTransformer;
 import org.codehaus.groovy.ast.ClassHelper;
 import org.codehaus.groovy.ast.ClassNode;
 import org.codehaus.groovy.ast.FieldNode;
@@ -40,8 +41,10 @@ import org.codehaus.groovy.ast.stmt.BlockStatement;
 import org.codehaus.groovy.ast.stmt.ExpressionStatement;
 import org.codehaus.groovy.ast.stmt.Statement;
 import org.codehaus.groovy.ast.tools.GeneralUtils;
+import org.codehaus.groovy.classgen.GeneratorContext;
 import org.codehaus.groovy.classgen.VariableScopeVisitor;
 import org.codehaus.groovy.classgen.Verifier;
+import org.codehaus.groovy.control.CompilationFailedException;
 import org.codehaus.groovy.control.CompilationUnit;
 import org.codehaus.groovy.control.CompilePhase;
 import org.codehaus.groovy.control.SourceUnit;
@@ -74,6 +77,8 @@ import java.util.Set;
 public class TraitASTTransformation extends AbstractASTTransformation implements CompilationUnitAware {
 
     public static final String DO_DYNAMIC = TraitReceiverTransformer.class+".doDynamic";
+    public static final String POST_TYPECHECKING_REPLACEMENT = TraitReceiverTransformer.class+".replacement";
+
     private static final ClassNode INVOKERHELPER_CLASSNODE = ClassHelper.make(InvokerHelper.class);
 
     private static final ClassNode OVERRIDE_CLASSNODE = ClassHelper.make(Override.class);
@@ -218,6 +223,12 @@ public class TraitASTTransformation extends AbstractASTTransformation implements
         if (fieldHelper != null) {
             unit.getAST().addClass(fieldHelper);
         }
+
+        // resolve scope (for closures)
+        resolveScope(helper);
+        if (fieldHelper!=null) {
+            resolveScope(fieldHelper);
+        }
     }
 
     private MethodNode createInitMethod(final boolean isStatic, final ClassNode cNode, final ClassNode helper) {
@@ -244,6 +255,16 @@ public class TraitASTTransformation extends AbstractASTTransformation implements
                 unit, compilationUnit.getTransformLoader()
         );
         collector.visitClass(helper);
+        // Perform an additional phase which has to be done *after* type checking
+        compilationUnit.addPhaseOperation(new CompilationUnit.PrimaryClassNodeOperation() {
+            @Override
+            public void call(final SourceUnit source, final GeneratorContext context, final ClassNode classNode) throws CompilationFailedException {
+                if (classNode==helper) {
+                    PostTypeCheckingExpressionReplacer replacer = new PostTypeCheckingExpressionReplacer(source);
+                    replacer.visitClass(helper);
+                }
+            }
+        }, CompilePhase.INSTRUCTION_SELECTION.getPhaseNumber());
     }
 
     /**
@@ -515,4 +536,27 @@ public class TraitASTTransformation extends AbstractASTTransformation implements
             super.addDefaultParameterMethods(node);
         }
     }
+
+    private static class PostTypeCheckingExpressionReplacer extends ClassCodeExpressionTransformer {
+        private final SourceUnit sourceUnit;
+
+        private PostTypeCheckingExpressionReplacer(final SourceUnit sourceUnit) {
+            this.sourceUnit = sourceUnit;
+        }
+
+        @Override
+        protected SourceUnit getSourceUnit() {
+            return sourceUnit;
+        }
+
+        @Override
+        public Expression transform(final Expression exp) {
+            Expression replacement = exp.getNodeMetaData(TraitASTTransformation.POST_TYPECHECKING_REPLACEMENT);
+            if (replacement!=null) {
+                return replacement;
+            }
+            return super.transform(exp);
+        }
+    }
+
 }
diff --git a/src/main/org/codehaus/groovy/transform/trait/TraitReceiverTransformer.java b/src/main/org/codehaus/groovy/transform/trait/TraitReceiverTransformer.java
index 583878eea1..cf442934d0 100644
--- a/src/main/org/codehaus/groovy/transform/trait/TraitReceiverTransformer.java
+++ b/src/main/org/codehaus/groovy/transform/trait/TraitReceiverTransformer.java
@@ -88,57 +88,7 @@ class TraitReceiverTransformer extends ClassCodeExpressionTransformer {
     public Expression transform(final Expression exp) {
         ClassNode weavedType = weaved.getOriginType();
         if (exp instanceof BinaryExpression) {
-            Expression leftExpression = ((BinaryExpression) exp).getLeftExpression();
-            Expression rightExpression = ((BinaryExpression) exp).getRightExpression();
-            Token operation = ((BinaryExpression) exp).getOperation();
-            if (operation.getText().equals("=")) {
-                String leftFieldName = null;
-                // it's an assignment
-                if (leftExpression instanceof VariableExpression && ((VariableExpression) leftExpression).getAccessedVariable() instanceof FieldNode) {
-                    leftFieldName = ((VariableExpression) leftExpression).getAccessedVariable().getName();
-                } else if (leftExpression instanceof FieldExpression) {
-                    leftFieldName = ((FieldExpression) leftExpression).getFieldName();
-                } else if (leftExpression instanceof PropertyExpression
-                        && (((PropertyExpression) leftExpression).isImplicitThis() || "this".equals(((PropertyExpression) leftExpression).getObjectExpression().getText()))) {
-                    leftFieldName = ((PropertyExpression) leftExpression).getPropertyAsString();
-                    FieldNode fn = tryGetFieldNode(weavedType, leftFieldName);
-                    if (fieldHelper == null || fn==null && !fieldHelper.hasPossibleMethod(Traits.helperSetterName(new FieldNode(leftFieldName, 0, ClassHelper.OBJECT_TYPE, weavedType, null)), rightExpression)) {
-                        return createAssignmentToField(rightExpression, operation, leftFieldName);
-                    }
-                }
-                if (leftFieldName!=null) {
-                    FieldNode fn = weavedType.getDeclaredField(leftFieldName);
-                    FieldNode staticField = tryGetFieldNode(weavedType, leftFieldName);
-                    if (fn==null) {
-                        fn = new FieldNode(leftFieldName, 0, ClassHelper.OBJECT_TYPE, weavedType, null);
-                    }
-                    Expression receiver = createFieldHelperReceiver();
-                    boolean isStatic = staticField!=null && staticField.isStatic();
-                    if (fn.isStatic()) { // DO NOT USE isStatic variable here!
-                        receiver = new PropertyExpression(receiver, "class");
-                    }
-                    String method = Traits.helperSetterName(fn);
-                    MethodCallExpression mce = new MethodCallExpression(
-                            receiver,
-                            method,
-                            new ArgumentListExpression(super.transform(rightExpression))
-                    );
-                    mce.setSourcePosition(exp);
-                    mce.setImplicitThis(false);
-                    markDynamicCall(mce, staticField, isStatic);
-                    return mce;
-                }
-            }
-            Expression leftTransform = transform(leftExpression);
-            Expression rightTransform = transform(rightExpression);
-            Expression ret =
-                    exp instanceof DeclarationExpression ?new DeclarationExpression(
-                            leftTransform, operation, rightTransform
-                    ):
-                    new BinaryExpression(leftTransform, operation, rightTransform);
-            ret.setSourcePosition(exp);
-            ret.copyNodeMetaData(exp);
-            return ret;
+            return transformBinaryExpression((BinaryExpression)exp, weavedType);
         } else if (exp instanceof StaticMethodCallExpression) {
             StaticMethodCallExpression call = (StaticMethodCallExpression) exp;
             ClassNode ownerType = call.getOwnerType();
@@ -163,16 +113,7 @@ class TraitReceiverTransformer extends ClassCodeExpressionTransformer {
                 return transformSuperMethodCall(call);
             }
         } else if (exp instanceof FieldExpression) {
-            FieldNode field = ((FieldExpression) exp).getField();
-            MethodCallExpression mce = new MethodCallExpression(
-                    createFieldHelperReceiver(),
-                    Traits.helperGetterName(field),
-                    ArgumentListExpression.EMPTY_ARGUMENTS
-            );
-            mce.setSourcePosition(exp);
-            mce.setImplicitThis(false);
-            markDynamicCall(mce, field, field.isStatic());
-            return mce;
+            return transformFieldExpression((FieldExpression)exp);
         } else if (exp instanceof VariableExpression) {
             VariableExpression vexp = (VariableExpression) exp;
             Variable accessedVariable = vexp.getAccessedVariable();
@@ -254,13 +195,85 @@ class TraitReceiverTransformer extends ClassCodeExpressionTransformer {
             );
             mce.setImplicitThis(false);
             mce.setSourcePosition(exp);
-            return mce;
+            ((ClosureExpression) exp).getCode().visit(this);
+            // The rewrite we do is causing some troubles with type checking, which will
+            // not be able to perform closure parameter type inference
+            // so we store the replacement, which will be done *after* type checking.
+            exp.putNodeMetaData(TraitASTTransformation.POST_TYPECHECKING_REPLACEMENT, mce);
+            return exp;
         }
 
         // todo: unary expressions (field++, field+=, ...)
         return super.transform(exp);
     }
 
+    private Expression transformFieldExpression(final FieldExpression exp) {
+        FieldNode field = exp.getField();
+        MethodCallExpression mce = new MethodCallExpression(
+                createFieldHelperReceiver(),
+                Traits.helperGetterName(field),
+                ArgumentListExpression.EMPTY_ARGUMENTS
+        );
+        mce.setSourcePosition(exp);
+        mce.setImplicitThis(false);
+        markDynamicCall(mce, field, field.isStatic());
+        return mce;
+    }
+
+    private Expression transformBinaryExpression(final BinaryExpression exp, final ClassNode weavedType) {
+        Expression leftExpression = exp.getLeftExpression();
+        Expression rightExpression = exp.getRightExpression();
+        Token operation = exp.getOperation();
+        if (operation.getText().equals("=")) {
+            String leftFieldName = null;
+            // it's an assignment
+            if (leftExpression instanceof VariableExpression && ((VariableExpression) leftExpression).getAccessedVariable() instanceof FieldNode) {
+                leftFieldName = ((VariableExpression) leftExpression).getAccessedVariable().getName();
+            } else if (leftExpression instanceof FieldExpression) {
+                leftFieldName = ((FieldExpression) leftExpression).getFieldName();
+            } else if (leftExpression instanceof PropertyExpression
+                    && (((PropertyExpression) leftExpression).isImplicitThis() || "this".equals(((PropertyExpression) leftExpression).getObjectExpression().getText()))) {
+                leftFieldName = ((PropertyExpression) leftExpression).getPropertyAsString();
+                FieldNode fn = tryGetFieldNode(weavedType, leftFieldName);
+                if (fieldHelper == null || fn==null && !fieldHelper.hasPossibleMethod(Traits.helperSetterName(new FieldNode(leftFieldName, 0, ClassHelper.OBJECT_TYPE, weavedType, null)), rightExpression)) {
+                    return createAssignmentToField(rightExpression, operation, leftFieldName);
+                }
+            }
+            if (leftFieldName!=null) {
+                FieldNode fn = weavedType.getDeclaredField(leftFieldName);
+                FieldNode staticField = tryGetFieldNode(weavedType, leftFieldName);
+                if (fn==null) {
+                    fn = new FieldNode(leftFieldName, 0, ClassHelper.OBJECT_TYPE, weavedType, null);
+                }
+                Expression receiver = createFieldHelperReceiver();
+                boolean isStatic = staticField!=null && staticField.isStatic();
+                if (fn.isStatic()) { // DO NOT USE isStatic variable here!
+                    receiver = new PropertyExpression(receiver, "class");
+                }
+                String method = Traits.helperSetterName(fn);
+                MethodCallExpression mce = new MethodCallExpression(
+                        receiver,
+                        method,
+                        new ArgumentListExpression(super.transform(rightExpression))
+                );
+                mce.setSourcePosition(exp);
+                mce.setImplicitThis(false);
+                markDynamicCall(mce, staticField, isStatic);
+                return mce;
+            }
+        }
+        Expression leftTransform = transform(leftExpression);
+        Expression rightTransform = transform(rightExpression);
+        Expression ret =
+                exp instanceof DeclarationExpression ?new DeclarationExpression(
+                        leftTransform, operation, rightTransform
+                ):
+                new BinaryExpression(leftTransform, operation, rightTransform);
+        ret.setSourcePosition(exp);
+        ret.copyNodeMetaData(exp);
+        return ret;
+    }
+
     private void markDynamicCall(final MethodCallExpression mce, final FieldNode fn, final boolean isStatic) {
         if (isStatic) {
             mce.putNodeMetaData(TraitASTTransformation.DO_DYNAMIC, fn.getOriginType());
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7242Bug.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7242Bug.groovy
new file mode 100644
index 0000000000..4112166c64
--- /dev/null
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7242Bug.groovy
@@ -0,0 +1,81 @@
+/*
+ * Copyright 2003-2015 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+
+
+
+
+
+
+
+package org.codehaus.groovy.classgen.asm.sc.bugs
+
+import groovy.transform.stc.StaticTypeCheckingTestCase
+import org.codehaus.groovy.classgen.asm.sc.StaticCompilationTestSupport
+
+class Groovy7242Bug extends StaticTypeCheckingTestCase implements StaticCompilationTestSupport {
+    void testCallMethodOfTraitInsideClosure() {
+        assertScript '''
+            trait MyTrait {
+                def f() {
+                    ['a'].collect {String it -> f2(it)}
+                }
+
+                def f2(String s) {
+                    s.toUpperCase()
+                }
+            }
+
+            class A implements MyTrait {}
+            def a = new A()
+            assert a.f() == ['A']
+        '''
+    }
+
+    void testCallMethodOfTraitInsideClosureAndClosureParamTypeInference() {
+        assertScript '''
+            trait MyTrait {
+                def f() {
+                    ['a'].collect {f2(it)}
+                }
+
+                def f2(String s) {
+                    s.toUpperCase()
+                }
+            }
+
+            class A implements MyTrait {}
+            def a = new A()
+            assert a.f() == ['A']
+        '''
+    }
+
+    void testAccessTraitPropertyFromClosureInTrait() {
+        assertScript '''
+            trait MyTrait {
+                int x
+                def f() {
+                    [1].each { x = it }
+                }
+            }
+            class A implements MyTrait {}
+            def a = new A()
+            a.f()
+            assert a.x == 1
+        '''
+    }
+}
