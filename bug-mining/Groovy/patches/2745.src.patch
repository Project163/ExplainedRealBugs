diff --git a/src/main/org/codehaus/groovy/ast/ClassNode.java b/src/main/org/codehaus/groovy/ast/ClassNode.java
index 65c57575a2..12b2d7e8d7 100644
--- a/src/main/org/codehaus/groovy/ast/ClassNode.java
+++ b/src/main/org/codehaus/groovy/ast/ClassNode.java
@@ -400,6 +400,7 @@ public class ClassNode extends AnnotatedNode implements Opcodes {
         } else {
             return result;
         }
+
     }
 
     public List<MethodNode> getAllDeclaredMethods() {
diff --git a/src/main/org/codehaus/groovy/classgen/ClassCompletionVerifier.java b/src/main/org/codehaus/groovy/classgen/ClassCompletionVerifier.java
index 756e58ec8b..2c7c4ae036 100644
--- a/src/main/org/codehaus/groovy/classgen/ClassCompletionVerifier.java
+++ b/src/main/org/codehaus/groovy/classgen/ClassCompletionVerifier.java
@@ -11,7 +11,9 @@
  ******************************************************************************/
 package org.codehaus.groovy.classgen;
 
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
 
 import org.codehaus.groovy.ast.*;
 import org.codehaus.groovy.ast.expr.BinaryExpression;
@@ -28,6 +30,7 @@ import org.codehaus.groovy.ast.stmt.CatchStatement;
 import org.codehaus.groovy.control.SourceUnit;
 import org.codehaus.groovy.runtime.MetaClassHelper;
 import org.codehaus.groovy.syntax.Types;
+import org.codehaus.groovy.transform.trait.Traits;
 
 import static java.lang.reflect.Modifier.*;
 import static org.objectweb.asm.Opcodes.*;
@@ -61,13 +64,39 @@ public class ClassCompletionVerifier extends ClassCodeVisitorSupport {
             checkMethodsForWeakerAccess(node);
             checkMethodsForOverridingFinal(node);
             checkNoAbstractMethodsNonabstractClass(node);
+            checkNoStaticMethodWithSameSignatureAsNonStatic(node);
             checkGenericsUsage(node, node.getUnresolvedInterfaces());
             checkGenericsUsage(node, node.getUnresolvedSuperClass());
         }
         super.visitClass(node);
         currentClass = oldClass;
     }
-    
+
+    private void checkNoStaticMethodWithSameSignatureAsNonStatic(final ClassNode node) {
+        Map<String, MethodNode> result = new HashMap<String, MethodNode>();
+        // add in unimplemented abstract methods from the interfaces
+        for (ClassNode iface : node.getInterfaces()) {
+            Map<String, MethodNode> ifaceMethodsMap = iface.getDeclaredMethodsMap();
+            for (String methSig : ifaceMethodsMap.keySet()) {
+                if (!result.containsKey(methSig)) {
+                    MethodNode methNode = ifaceMethodsMap.get(methSig);
+                    result.put(methSig, methNode);
+                }
+            }
+        }
+        for (MethodNode methodNode : node.getMethods()) {
+            MethodNode mn = result.get(methodNode.getTypeDescriptor());
+            if (mn!=null && methodNode.isStatic() && !methodNode.isStaticConstructor()) {
+                ClassNode cn = mn.getDeclaringClass().getOuterClass();
+                if (cn==null || !Traits.isTrait(cn)) {
+                    addError("Method '" + mn.getName() + "' is already defined in " + getDescription(node) + ". You cannot have " +
+                            "both a static and a non static method with the same signature", methodNode);
+                }
+            }
+            result.put(methodNode.getTypeDescriptor(), methodNode);
+        }
+    }
+
     private void checkInterfaceMethodVisibility(ClassNode node) {
         if (!node.isInterface()) return;
         for (MethodNode method : node.getMethods()) {
@@ -84,9 +113,18 @@ public class ClassCompletionVerifier extends ClassCodeVisitorSupport {
         List<MethodNode> abstractMethods = node.getAbstractMethods();
         if (abstractMethods == null) return;
         for (MethodNode method : abstractMethods) {
-            addError("Can't have an abstract method in a non-abstract class." +
-                    " The " + getDescription(node) + " must be declared abstract or" +
-                    " the " + getDescription(method) + " must be implemented.", node);
+            MethodNode sameArgsMethod = node.getMethod(method.getName(), method.getParameters());
+            if (sameArgsMethod==null) {
+                addError("Can't have an abstract method in a non-abstract class." +
+                        " The " + getDescription(node) + " must be declared abstract or" +
+                        " the " + getDescription(method) + " must be implemented.", node);
+            } else {
+                addError("Abstract "+getDescription(method)+" is not implemented but a " +
+                                "method of the same name but different return type is defined: "+
+                                (sameArgsMethod.isStatic()?"static ":"")+
+                                getDescription(sameArgsMethod), method
+                );
+            }
         }
     }
 
diff --git a/src/test/groovy/bugs/Groovy7081Bug.groovy b/src/test/groovy/bugs/Groovy7081Bug.groovy
new file mode 100644
index 0000000000..d69fe0a985
--- /dev/null
+++ b/src/test/groovy/bugs/Groovy7081Bug.groovy
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2003-2014 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+
+package groovy.bugs
+
+import org.codehaus.groovy.control.MultipleCompilationErrorsException
+
+class Groovy7081Bug extends GroovyTestCase {
+    void testShouldSeeThatMethodIsNotImplemented() {
+        def msg = shouldFail '''
+            interface DefinesProperty {
+                String getName()
+            }
+            class Foo implements DefinesProperty {
+                static String name = 'Foo'
+            }
+            new Foo().name
+            '''
+
+        assert msg.contains("Method 'getName' is already defined in class 'Foo'")
+    }
+
+    void testShouldSeeConflictInTypeSignature() {
+        def msg = shouldFail '''
+            interface DefinesProperty {
+                String getName()
+            }
+            class Foo implements DefinesProperty {
+                static int name = 666
+            }
+            new Foo().name
+            '''
+
+        assert msg.contains("Abstract method 'java.lang.String getName()' is not implemented but a method of the same name but different return type is defined: static method 'int getName()'")
+    }
+
+    void testShouldSeeConflictUsingTrait() {
+        def msg = shouldFail '''
+            trait SomeTrait {
+                int getMagicNumber() {
+                    42
+                }
+            }
+            class SomeClass implements SomeTrait {
+                static magicNumber = 'Forty Two'
+            }
+        '''
+        assert msg.contains("Abstract method 'int getMagicNumber()' is not implemented but a method of the same name but different return type is defined: static method 'java.lang.Object getMagicNumber()'")
+    }
+}
