diff --git a/src/main/org/codehaus/groovy/ast/tools/GeneralUtils.java b/src/main/org/codehaus/groovy/ast/tools/GeneralUtils.java
index 76e7f33c83..4efae84647 100644
--- a/src/main/org/codehaus/groovy/ast/tools/GeneralUtils.java
+++ b/src/main/org/codehaus/groovy/ast/tools/GeneralUtils.java
@@ -412,6 +412,15 @@ public class GeneralUtils {
         return new BinaryExpression(lhv, LT, rhv);
     }
 
+    public static String makeDescriptorWithoutReturnType(MethodNode mn) {
+        StringBuilder sb = new StringBuilder();
+        sb.append(mn.getName()).append(':');
+        for (Parameter p : mn.getParameters()) {
+            sb.append(p.getType()).append(',');
+        }
+        return sb.toString();
+    }
+
     public static BinaryExpression neX(Expression lhv, Expression rhv) {
         return new BinaryExpression(lhv, NE, rhv);
     }
diff --git a/src/main/org/codehaus/groovy/classgen/Verifier.java b/src/main/org/codehaus/groovy/classgen/Verifier.java
index 0ea9abbcd8..3397c098b9 100644
--- a/src/main/org/codehaus/groovy/classgen/Verifier.java
+++ b/src/main/org/codehaus/groovy/classgen/Verifier.java
@@ -60,6 +60,7 @@ import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
+import static org.codehaus.groovy.ast.tools.GeneralUtils.makeDescriptorWithoutReturnType;
 import static org.codehaus.groovy.ast.tools.GenericsUtils.correctToGenericsSpec;
 import static org.codehaus.groovy.ast.tools.GenericsUtils.createGenericsSpec;
 
@@ -197,16 +198,7 @@ public class Verifier implements GroovyClassVisitor, Opcodes {
         checkForDuplicateMethods(node);
         addCovariantMethods(node);
     }
-    
-    private String makeDescriptorWithoutReturnType(MethodNode mn) {
-        StringBuilder sb = new StringBuilder();
-        sb.append(mn.getName()).append(':');
-        for (Parameter p : mn.getParameters()) {
-            sb.append(p.getType()).append(',');
-        }
-        return sb.toString();
-    }
-    
+
     private void checkForDuplicateMethods(ClassNode cn) {
         HashSet<String> descriptors = new HashSet<String>();
         for (MethodNode mn : cn.getMethods()) {
diff --git a/src/main/org/codehaus/groovy/transform/AbstractASTTransformation.java b/src/main/org/codehaus/groovy/transform/AbstractASTTransformation.java
index e87b012e6e..43888e66cb 100644
--- a/src/main/org/codehaus/groovy/transform/AbstractASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/AbstractASTTransformation.java
@@ -30,6 +30,7 @@ import org.codehaus.groovy.ast.expr.ConstantExpression;
 import org.codehaus.groovy.ast.expr.Expression;
 import org.codehaus.groovy.ast.expr.ListExpression;
 import org.codehaus.groovy.ast.expr.PropertyExpression;
+import org.codehaus.groovy.ast.tools.GeneralUtils;
 import org.codehaus.groovy.ast.tools.GenericsUtils;
 import org.codehaus.groovy.control.SourceUnit;
 import org.codehaus.groovy.control.messages.SyntaxErrorMessage;
@@ -158,7 +159,9 @@ public abstract class AbstractASTTransformation implements Opcodes, ASTTransform
         return (excludes != null && excludes.contains(name)) || deemedInternalName(name) || (includes != null && !includes.isEmpty() && !includes.contains(name));
     }
 
-    public static boolean shouldSkipOnDescriptor(Map genericsSpec, String descriptor, List<ClassNode> excludeTypes, List<ClassNode> includeTypes) {
+    public static boolean shouldSkipOnDescriptor(boolean checkReturn, Map genericsSpec, MethodNode mNode, List<ClassNode> excludeTypes, List<ClassNode> includeTypes) {
+        String descriptor = mNode.getTypeDescriptor();
+        String descriptorNoReturn = GeneralUtils.makeDescriptorWithoutReturnType(mNode);
             for (ClassNode cn : excludeTypes) {
                 List<ClassNode> remaining = new LinkedList<ClassNode>();
                 remaining.add(cn);
@@ -168,8 +171,14 @@ public abstract class AbstractASTTransformation implements Opcodes, ASTTransform
                     if (!next.equals(ClassHelper.OBJECT_TYPE)) {
                         updatedGenericsSpec = GenericsUtils.createGenericsSpec(next, updatedGenericsSpec);
                         for (MethodNode mn : next.getMethods()) {
-                            String md = GenericsUtils.correctToGenericsSpec(updatedGenericsSpec, mn).getTypeDescriptor();
-                            if (md.equals(descriptor)) return true;
+                            MethodNode correctedMethodNode = GenericsUtils.correctToGenericsSpec(updatedGenericsSpec, mn);
+                            if (checkReturn) {
+                                String md = correctedMethodNode.getTypeDescriptor();
+                                if (md.equals(descriptor)) return true;
+                            } else {
+                                String md = GeneralUtils.makeDescriptorWithoutReturnType(correctedMethodNode);
+                                if (md.equals(descriptorNoReturn)) return true;
+                            }
                         }
                         remaining.addAll(Arrays.asList(next.getInterfaces()));
                     }
@@ -185,8 +194,14 @@ public abstract class AbstractASTTransformation implements Opcodes, ASTTransform
                     if (!next.equals(ClassHelper.OBJECT_TYPE)) {
                         updatedGenericsSpec = GenericsUtils.createGenericsSpec(next, updatedGenericsSpec);
                         for (MethodNode mn : next.getMethods()) {
-                            String md = GenericsUtils.correctToGenericsSpec(updatedGenericsSpec, mn).getTypeDescriptor();
-                            if (md.equals(descriptor)) return false;
+                            MethodNode correctedMethodNode = GenericsUtils.correctToGenericsSpec(updatedGenericsSpec, mn);
+                            if (checkReturn) {
+                                String md = correctedMethodNode.getTypeDescriptor();
+                                if (md.equals(descriptor)) return false;
+                            } else {
+                                String md = GeneralUtils.makeDescriptorWithoutReturnType(correctedMethodNode);
+                                if (md.equals(descriptorNoReturn)) return false;
+                            }
                         }
                         remaining.addAll(Arrays.asList(next.getInterfaces()));
                     }
diff --git a/src/main/org/codehaus/groovy/transform/DelegateASTTransformation.java b/src/main/org/codehaus/groovy/transform/DelegateASTTransformation.java
index a318c7c7d1..ee2dba03d9 100644
--- a/src/main/org/codehaus/groovy/transform/DelegateASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/DelegateASTTransformation.java
@@ -191,8 +191,9 @@ public class DelegateASTTransformation extends AbstractASTTransformation {
         genericsSpec = createGenericsSpec(fieldNode.getType(), genericsSpec);
 
         if (!excludeTypes.isEmpty() || !includeTypes.isEmpty()) {
-            String correctedTypeDescriptor = correctToGenericsSpec(genericsSpec, candidate).getTypeDescriptor();
-            if (shouldSkipOnDescriptor(genericsSpec, correctedTypeDescriptor, excludeTypes, includeTypes)) return;
+            MethodNode correctedMethodNode = correctToGenericsSpec(genericsSpec, candidate);
+            boolean checkReturn = fieldNode.getType().getMethods().contains(candidate);
+            if (shouldSkipOnDescriptor(checkReturn, genericsSpec, correctedMethodNode, excludeTypes, includeTypes)) return;
         }
 
         // ignore methods from GroovyObject
diff --git a/src/spec/test/ClassDesignASTTransformsTest.groovy b/src/spec/test/ClassDesignASTTransformsTest.groovy
index 53c783f06c..b057c9efbb 100644
--- a/src/spec/test/ClassDesignASTTransformsTest.groovy
+++ b/src/spec/test/ClassDesignASTTransformsTest.groovy
@@ -204,17 +204,14 @@ b.append(3.5d) // would fail because we didn't include append(double)
 '''
         assertScript '''
 // tag::delegate_example_excludeTypes[]
-interface AppendStringSelector1 {
+interface AppendStringSelector {
     StringBuilder append(String str)
 }
-interface AppendStringSelector2 {
-    AbstractStringBuilder append(String str)
-}
 class UpperStringBuilder {
-    @Delegate(excludeTypes=[AppendStringSelector1,AppendStringSelector2])
+    @Delegate(excludeTypes=AppendStringSelector)
     StringBuilder sb1 = new StringBuilder()
 
-    @Delegate(includeTypes=AppendStringSelector1)
+    @Delegate(includeTypes=AppendStringSelector)
     StringBuilder sb2 = new StringBuilder()
 
     String toString() { sb1.toString() + sb2.toString().toUpperCase() }
