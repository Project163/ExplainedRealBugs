diff --git a/src/main/java/org/codehaus/groovy/classgen/ClassCompletionVerifier.java b/src/main/java/org/codehaus/groovy/classgen/ClassCompletionVerifier.java
index 76936fe420..417b34ee47 100644
--- a/src/main/java/org/codehaus/groovy/classgen/ClassCompletionVerifier.java
+++ b/src/main/java/org/codehaus/groovy/classgen/ClassCompletionVerifier.java
@@ -123,7 +123,7 @@ public class ClassCompletionVerifier extends ClassCodeVisitorSupport {
                 checkMethodsForWeakerAccess(node);
                 checkMethodsForOverridingFinal(node);
                 checkNoAbstractMethodsNonAbstractClass(node);
-                checkClassExtendsAllSelfTypes(node);
+                checkClassExtendsOrImplementsSelfTypes(node);
                 checkNoStaticMethodWithSameSignatureAsNonStatic(node);
                 checkGenericsUsage(node, node.getUnresolvedInterfaces());
                 checkGenericsUsage(node, node.getUnresolvedSuperClass());
@@ -234,22 +234,16 @@ public class ClassCompletionVerifier extends ClassCodeVisitorSupport {
         }
     }
 
-    private void checkClassExtendsAllSelfTypes(final ClassNode node) {
+    private void checkClassExtendsOrImplementsSelfTypes(final ClassNode node) {
         if (node.isInterface()) return;
         for (ClassNode anInterface : GeneralUtils.getInterfacesAndSuperInterfaces(node)) {
             if (Traits.isTrait(anInterface)) {
-                LinkedHashSet<ClassNode> selfTypes = new LinkedHashSet<ClassNode>();
-                for (ClassNode type : Traits.collectSelfTypes(anInterface, selfTypes, true, false)) {
-                    if (type.isInterface() && !node.implementsInterface(type)) {
-                        addError(getDescription(node)
-                            + " implements " + getDescription(anInterface)
-                            + " but does not implement self type " + getDescription(type),
-                            anInterface);
-                    } else if (!type.isInterface() && !node.isDerivedFrom(type)) {
-                        addError(getDescription(node)
-                            + " implements " + getDescription(anInterface)
-                            + " but does not extend self type " + getDescription(type),
-                            anInterface);
+                for (ClassNode selfType : Traits.collectSelfTypes(anInterface, new LinkedHashSet<>(), true, false)) {
+                    ClassNode superClass;
+                    if (selfType.isInterface() ? !node.implementsInterface(selfType) : !(node.isDerivedFrom(selfType)
+                            || ((superClass = node.getNodeMetaData("super.class")) != null && superClass.isDerivedFrom(selfType)))) {
+                        addError(getDescription(node) + " implements " + getDescription(anInterface) + " but does not " +
+                            (selfType.isInterface() ? "implement" : "extend") + " self type " + getDescription(selfType), anInterface);
                     }
                 }
             }
diff --git a/src/main/java/org/codehaus/groovy/runtime/ProxyGeneratorAdapter.java b/src/main/java/org/codehaus/groovy/runtime/ProxyGeneratorAdapter.java
index 03c18ccc1c..f6aa433001 100644
--- a/src/main/java/org/codehaus/groovy/runtime/ProxyGeneratorAdapter.java
+++ b/src/main/java/org/codehaus/groovy/runtime/ProxyGeneratorAdapter.java
@@ -186,12 +186,12 @@ public class ProxyGeneratorAdapter extends ClassVisitor {
         }
         this.hasWildcard = wildcard;
 
+        this.delegateClass = delegateClass;
         Class<?> fixedSuperClass = adjustSuperClass(superClass, interfaces);
         // if we have to delegate to another object, generate the appropriate delegate field
         // and collect the name of the methods for which delegation is active
         this.generateDelegateField = delegateClass != null;
         this.objectDelegateMethods = generateDelegateField ? createDelegateMethodList(fixedSuperClass, delegateClass, interfaces) : Collections.emptySet();
-        this.delegateClass = delegateClass;
 
         // a proxy is supposed to be a concrete class, so it cannot extend an interface.
         // If the provided superclass is an interface, then we replace the superclass with Object
@@ -240,6 +240,7 @@ public class ProxyGeneratorAdapter extends ClassVisitor {
         if (!traits.isEmpty()) {
             String name = superClass.getName() + "$TraitAdapter";
             ClassNode cn = new ClassNode(name, ACC_PUBLIC | ACC_ABSTRACT, ClassHelper.OBJECT_TYPE, traits.toArray(ClassNode.EMPTY_ARRAY), null);
+            if (delegateClass != null) cn.putNodeMetaData("super.class", ClassHelper.make(delegateClass)); // GROOVY-7984
             CompilationUnit cu = new CompilationUnit(innerLoader);
             CompilerConfiguration config = new CompilerConfiguration();
             SourceUnit su = new SourceUnit(name + "wrapper", "", config, innerLoader, new ErrorCollector(config));
diff --git a/src/test/org/codehaus/groovy/transform/traitx/TraitASTTransformationTest.groovy b/src/test/org/codehaus/groovy/transform/traitx/TraitASTTransformationTest.groovy
index c88b82bfa6..eca305f36d 100644
--- a/src/test/org/codehaus/groovy/transform/traitx/TraitASTTransformationTest.groovy
+++ b/src/test/org/codehaus/groovy/transform/traitx/TraitASTTransformationTest.groovy
@@ -18,7 +18,6 @@
  */
 package org.codehaus.groovy.transform.traitx
 
-import groovy.test.NotYetImplemented
 import groovy.transform.SelfType
 import org.codehaus.groovy.ast.ClassHelper
 import org.codehaus.groovy.ast.expr.ClassExpression
@@ -626,7 +625,7 @@ final class TraitASTTransformationTest {
     }
 
     // GROOVY-7984
-    @Test @NotYetImplemented
+    @Test
     void testRuntimeWithTraitsDGM2() {
         assertScript shell, '''
             class C {
