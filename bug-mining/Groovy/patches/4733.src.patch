diff --git a/src/main/java/org/codehaus/groovy/classgen/EnumCompletionVisitor.java b/src/main/java/org/codehaus/groovy/classgen/EnumCompletionVisitor.java
index cf46b49e6e..da0ec9d807 100644
--- a/src/main/java/org/codehaus/groovy/classgen/EnumCompletionVisitor.java
+++ b/src/main/java/org/codehaus/groovy/classgen/EnumCompletionVisitor.java
@@ -53,6 +53,7 @@ import static org.codehaus.groovy.ast.tools.GeneralUtils.params;
 import static org.codehaus.groovy.transform.sc.StaticCompilationVisitor.isStaticallyCompiled;
 import static org.objectweb.asm.Opcodes.ACC_PRIVATE;
 import static org.objectweb.asm.Opcodes.ACC_PUBLIC;
+import static org.objectweb.asm.Opcodes.ACC_STATIC;
 import static org.objectweb.asm.Opcodes.ACC_SYNTHETIC;
 
 /**
@@ -214,6 +215,19 @@ public class EnumCompletionVisitor extends ClassCodeVisitorSupport {
                 }
         );
 
+        visitor.addMissingHandler(
+                innerClass,
+                "$static_methodMissing",
+                ACC_PUBLIC | ACC_STATIC,
+                OBJECT_TYPE,
+                params(param(STRING_TYPE, "name"), param(OBJECT_TYPE, "args")),
+                (methodBody, parameters) -> {
+                    InnerClassVisitorHelper.setMethodDispatcherCode(methodBody, classX(outerClass), parameters);
+                }
+        );
+
+        //
+
         visitor.addMissingHandler(
                 innerClass,
                 "propertyMissing",
@@ -225,6 +239,19 @@ public class EnumCompletionVisitor extends ClassCodeVisitorSupport {
                 }
         );
 
+        visitor.addMissingHandler(
+                innerClass,
+                "$static_propertyMissing",
+                ACC_PUBLIC | ACC_STATIC,
+                OBJECT_TYPE,
+                params(param(STRING_TYPE, "name")),
+                (methodBody, parameters) -> {
+                    InnerClassVisitorHelper.setPropertyGetterDispatcher(methodBody, classX(outerClass), parameters);
+                }
+        );
+
+        //
+
         visitor.addMissingHandler(
                 innerClass,
                 "propertyMissing",
@@ -235,5 +262,16 @@ public class EnumCompletionVisitor extends ClassCodeVisitorSupport {
                     InnerClassVisitorHelper.setPropertySetterDispatcher(methodBody, classX(outerClass), parameters);
                 }
         );
+
+        visitor.addMissingHandler(
+                innerClass,
+                "$static_propertyMissing",
+                ACC_PUBLIC | ACC_STATIC,
+                VOID_TYPE,
+                params(param(STRING_TYPE, "name"), param(OBJECT_TYPE, "value")),
+                (methodBody, parameters) -> {
+                    InnerClassVisitorHelper.setPropertySetterDispatcher(methodBody, classX(outerClass), parameters);
+                }
+        );
     }
 }
diff --git a/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java b/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
index e6c2a67cf9..e61d641782 100644
--- a/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
+++ b/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
@@ -51,9 +51,9 @@ import org.objectweb.asm.Label;
 import org.objectweb.asm.MethodVisitor;
 
 import java.util.ArrayList;
-import java.util.Collection;
 import java.util.List;
 import java.util.Map;
+import java.util.Optional;
 import java.util.function.BiPredicate;
 import java.util.function.Predicate;
 
@@ -63,6 +63,7 @@ import static org.apache.groovy.ast.tools.ExpressionUtils.isThisExpression;
 import static org.apache.groovy.util.BeanUtils.capitalize;
 import static org.codehaus.groovy.ast.ClassHelper.CLASS_Type;
 import static org.codehaus.groovy.ast.ClassHelper.CLOSURE_TYPE;
+import static org.codehaus.groovy.ast.ClassHelper.COLLECTION_TYPE;
 import static org.codehaus.groovy.ast.ClassHelper.GROOVY_OBJECT_TYPE;
 import static org.codehaus.groovy.ast.ClassHelper.Iterator_TYPE;
 import static org.codehaus.groovy.ast.ClassHelper.LIST_TYPE;
@@ -124,8 +125,7 @@ import static org.objectweb.asm.Opcodes.PUTSTATIC;
  */
 public class StaticTypesCallSiteWriter extends CallSiteWriter {
 
-    private static final ClassNode COLLECTION_TYPE = ClassHelper.make(Collection.class);
-    private static final ClassNode INVOKERHELPER_TYPE = ClassHelper.make(InvokerHelper.class);
+    private static final ClassNode  INVOKERHELPER_TYPE = ClassHelper.make(InvokerHelper.class);
     private static final MethodNode COLLECTION_SIZE_METHOD = COLLECTION_TYPE.getMethod("size", Parameter.EMPTY_ARRAY);
     private static final MethodNode CLOSURE_GETTHISOBJECT_METHOD = CLOSURE_TYPE.getMethod("getThisObject", Parameter.EMPTY_ARRAY);
     private static final MethodNode MAP_GET_METHOD = MAP_TYPE.getMethod("get", new Parameter[]{new Parameter(OBJECT_TYPE, "key")});
@@ -184,49 +184,19 @@ public class StaticTypesCallSiteWriter extends CallSiteWriter {
         // GROOVY-5001, GROOVY-5491, GROOVY-5517, GROOVY-6144, GROOVY-8788: for map types,
         // replace "map.foo" with "map.get('foo')" -- if no public field "foo" is declared
         if (!isStaticProperty && isOrImplements(receiverType, MAP_TYPE)
-                && !java.util.Optional.ofNullable(getField(receiverType, propertyName)).filter(FieldNode::isPublic).isPresent()) {
+                && Optional.ofNullable(getField(receiverType, propertyName)).filter(FieldNode::isPublic).isEmpty()) {
             writeMapDotProperty(receiver, propertyName, safe);
             return;
         }
         if (makeGetField(receiver, receiverType, propertyName, safe, implicitThis)) return;
-        if (receiver instanceof ClassExpression) {
-            if (makeGetField(receiver, receiver.getType(), propertyName, safe, implicitThis)) return;
-            if (makeGetPropertyWithGetter(receiver, receiver.getType(), propertyName, safe, implicitThis)) return;
-            if (makeGetPrivateFieldWithBridgeMethod(receiver, receiver.getType(), propertyName, safe, implicitThis)) return;
+        if (isThisExpression(receiver) && receiverType.getOuterClass() != null) { // GROOVY-11198: outer field
+            if (makeGetField(receiver, receiverType.getOuterClass(), propertyName, safe, implicitThis)) return;
         }
         if (isClassReceiver[0]) {
-            // we are probably looking for a property of the class
             if (makeGetPropertyWithGetter(receiver, CLASS_Type, propertyName, safe, implicitThis)) return;
-            if (makeGetField(receiver, CLASS_Type, propertyName, safe, false)) return;
         }
         if (makeGetPrivateFieldWithBridgeMethod(receiver, receiverType, propertyName, safe, implicitThis)) return;
 
-        // GROOVY-5580: it is still possible that we're calling a superinterface property
-        String isserName = "is" + capitalize(propertyName);
-        String getterName = "get" + capitalize(propertyName);
-        if (receiverType.isInterface()) {
-            MethodNode getterMethod = null;
-            for (ClassNode anInterface : receiverType.getAllInterfaces()) {
-                getterMethod = anInterface.getGetterMethod(isserName);
-                if (getterMethod == null)
-                    getterMethod = anInterface.getGetterMethod(getterName);
-                if (getterMethod != null) break;
-            }
-            // GROOVY-5585
-            if (getterMethod == null) {
-                getterMethod = OBJECT_TYPE.getGetterMethod(getterName);
-            }
-            if (getterMethod != null) {
-                MethodCallExpression call = callX(receiver, getterName);
-                call.setImplicitThis(false);
-                call.setMethodTarget(getterMethod);
-                call.setSafe(safe);
-                call.setSourcePosition(receiver);
-                call.visit(controller.getAcg());
-                return;
-            }
-        }
-
         if (!isStaticProperty && isOrImplements(receiverType, LIST_TYPE)) {
             writeListDotProperty(receiver, propertyName, safe);
             return;
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 01ff32bc29..58ee1260ec 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -590,14 +590,14 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
      * Checks for private field access from inner or outer class.
      */
     private void checkOrMarkPrivateAccess(final Expression source, final FieldNode fn, final boolean lhsOfAssignment) {
-        if (fn == null || !fn.isPrivate()) return;
-        ClassNode declaringClass = fn.getDeclaringClass();
-        ClassNode enclosingClass = typeCheckingContext.getEnclosingClassNode();
-        if (declaringClass == enclosingClass && typeCheckingContext.getEnclosingClosure() == null) return;
-
-        if (declaringClass == enclosingClass || getOutermost(declaringClass) == getOutermost(enclosingClass)) {
-            StaticTypesMarker accessKind = lhsOfAssignment ? PV_FIELDS_MUTATION : PV_FIELDS_ACCESS;
-            addPrivateFieldOrMethodAccess(source, declaringClass, accessKind, fn);
+        if (fn != null && fn.isPrivate() && !fn.isSynthetic()) {
+            ClassNode declaringClass = fn.getDeclaringClass();
+            ClassNode enclosingClass = typeCheckingContext.getEnclosingClassNode();
+            if (declaringClass == enclosingClass && typeCheckingContext.getEnclosingClosure() == null) return;
+            if (declaringClass == enclosingClass || getOutermost(declaringClass) == getOutermost(enclosingClass)) {
+                StaticTypesMarker accessKind = lhsOfAssignment ? PV_FIELDS_MUTATION : PV_FIELDS_ACCESS;
+                addPrivateFieldOrMethodAccess(source, declaringClass, accessKind, fn);
+            }
         }
     }
 
@@ -1603,11 +1603,11 @@ out:    if ((samParameterTypes.length == 1 && isOrImplements(samParameterTypes[0
                     }
                 }
 
-                MethodNode getter = findGetter(current, "is" + capName, pexp.isImplicitThis());
+                MethodNode getter = current.getGetterMethod("is" + capName);
                 getter = allowStaticAccessToMember(getter, staticOnly);
-                if (getter == null) getter = findGetter(current, getGetterName(propertyName), pexp.isImplicitThis());
+                if (getter == null) getter = current.getGetterMethod(getGetterName(propertyName));
                 getter = allowStaticAccessToMember(getter, staticOnly);
-                List<MethodNode> setters = findSetters(current, getSetterName(propertyName), /*enforce void:*/false);
+                List<MethodNode> setters = findSetters(current, getSetterName(propertyName), /*voidOnly:*/false);
                 setters = allowStaticAccessToMember(setters, staticOnly);
 
                 if (readMode && getter != null && visitor != null) visitor.visitMethod(getter);
@@ -1752,14 +1752,6 @@ out:    if ((samParameterTypes.length == 1 && isOrImplements(samParameterTypes[0
         return Modifier.isProtected(modifiers) && accessor.isDerivedFrom(receiver);
     }
 
-    private MethodNode findGetter(final ClassNode current, String name, final boolean searchOuterClasses) {
-        MethodNode getterMethod = current.getGetterMethod(name);
-        if (getterMethod == null && searchOuterClasses && current.getOuterClass() != null) {
-            return findGetter(current.getOuterClass(), name, true);
-        }
-        return getterMethod;
-    }
-
     private ClassNode getTypeForMultiValueExpression(final ClassNode compositeType, final Expression prop) {
         GenericsType[] gts = compositeType.getGenericsTypes();
         ClassNode itemType = (gts != null && gts.length == 1 ? getCombinedBoundType(gts[0]) : OBJECT_TYPE);
diff --git a/src/test/gls/enums/EnumTest.groovy b/src/test/gls/enums/EnumTest.groovy
index 512a4009b4..5c1ba15cb3 100644
--- a/src/test/gls/enums/EnumTest.groovy
+++ b/src/test/gls/enums/EnumTest.groovy
@@ -205,6 +205,7 @@ class EnumTest extends CompilableTestSupport {
                 }
             }
         '''
+
         shouldCompile '''
             enum E {
                 FOO;
@@ -215,6 +216,7 @@ class EnumTest extends CompilableTestSupport {
                 }
             }
         '''
+
         shouldNotCompile '''
             enum E {
                 FOO;
@@ -281,7 +283,7 @@ class EnumTest extends CompilableTestSupport {
             class Mother3483 {
                 Mother3483.Child child
 
-                enum Child{
+                enum Child {
                     Franz,
                     Ferdi,
                     Nand
@@ -297,20 +299,42 @@ class EnumTest extends CompilableTestSupport {
     // GROOVY-3110
     void testInnerEnumUsedInDefiningClassWithUnqualifiedEnumNameUsed() {
         assertScript '''
-            class Class3110 {
-                enum Enum3110{FOO, BAR}
-                Enum3110 var
-                def setEnumVar() {
-                    var = Enum3110.FOO
+            class C {
+                enum E {
+                    FOO, BAR
                 }
-                def getEnumVar() {
-                    var
+                E enumVar
+                void setEnumVar() {
+                    enumVar = E.FOO
+                }
+            }
+
+            def c = new C()
+            assert c.enumVar == null
+
+            c.setEnumVar()
+            assert c.enumVar == C.E.FOO
+
+            c.setEnumVar(C.E.BAR)
+            assert c.enumVar == C.E.BAR
+        '''
+    }
+
+    // GROOVY-11198
+    void testInnerEnumInitWithUnqualifiedOuterClassField() {
+        assertScript '''
+            class C {
+                private static final int ONE = 1
+                enum E {
+                    FOO(1 + ONE)
+                    final value
+                    E(value) {
+                        this.value = value
+                    }
                 }
             }
 
-            def obj = new Class3110()
-            obj.setEnumVar()
-            assert obj.getEnumVar() == Class3110.Enum3110.FOO
+            assert C.E.FOO.value == 2
         '''
     }
 
diff --git a/src/test/groovy/bugs/Groovy7994Bug.groovy b/src/test/groovy/bugs/Groovy7994Bug.groovy
deleted file mode 100644
index ba6b881535..0000000000
--- a/src/test/groovy/bugs/Groovy7994Bug.groovy
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one
- *  or more contributor license agreements.  See the NOTICE file
- *  distributed with this work for additional information
- *  regarding copyright ownership.  The ASF licenses this file
- *  to you under the Apache License, Version 2.0 (the
- *  "License"); you may not use this file except in compliance
- *  with the License.  You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing,
- *  software distributed under the License is distributed on an
- *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- *  KIND, either express or implied.  See the License for the
- *  specific language governing permissions and limitations
- *  under the License.
- */
-package groovy.bugs
-
-import groovy.test.GroovyTestCase
-
-class Groovy7994Bug extends GroovyTestCase {
-    void testJavaBeanPropertiesAvailableInInnerClasses() {
-        assertScript '''
-            import groovy.transform.CompileStatic
-
-            @CompileStatic
-            class Outer {
-                String prop = 'wally'
-                String getName() { "sally" }
-                class Inner {
-                    String innerGo() { new Other(name).text + new Other(Outer.this.name).text + new Other(getName()).text }
-                }
-                String go() {
-                    new Other(name).text + new Other(getName()).text
-                }
-                def makeAIC() {
-                    new Object() {
-                        String aicGo() { new Other(name).text + new Other(Outer.this.name).text + new Other(getName()).text }
-                        String staticMethodGo() { Other.foo(name) + Other.foo(Outer.this.name) + Other.foo(getName()) }
-                        String instanceMethodGo() { new Other().bar(name) + new Other().bar(getName()) }
-                        String methodWithClosureGo() { new Other().with { bar(name) + bar(getName()) } }
-                        String propGo() { new Other(prop).text + new Other(getProp()).text }
-                    }
-                }
-            }
-
-            @CompileStatic
-            class Other {
-                public final String text
-                static String foo(Object object) { "Object|$object:" }
-                static String foo(String string) { "String|$string:" }
-                String bar(Object object) { "Object|$object:" }
-                String bar(String string) { "String|$string:" }
-                Other(Object object) { text = "Object:$object|" }
-                Other(String string) { text = "String:$string|" }
-                Other() {}
-            }
-
-            def o = new Outer()
-            assert o.go() == 'String:sally|String:sally|'
-            assert o.makeAIC().aicGo() == 'String:sally|String:sally|String:sally|'
-            assert o.makeAIC().propGo() == 'String:wally|String:wally|'
-            assert o.makeAIC().staticMethodGo() == 'String|sally:String|sally:String|sally:'
-            assert o.makeAIC().instanceMethodGo() == 'String|sally:String|sally:'
-            assert o.makeAIC().methodWithClosureGo() == 'String|sally:String|sally:'
-            assert new Outer.Inner(o).innerGo() == 'String:sally|String:sally|String:sally|'
-        '''
-    }
-}
diff --git a/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy b/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy
index 73256144c9..4d8765b508 100644
--- a/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy
+++ b/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy
@@ -419,7 +419,6 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
         assertScript '''
             class Person {
                 String name
-
                 static Person create() {
                     def p = new Person()
                     p.setName("Guillaume")
@@ -515,6 +514,7 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
         '''
     }
 
+    // GROOVY-5585
     void testClassPropertyOnInterface() {
         assertScript '''
             Class test(Serializable arg) {
@@ -715,11 +715,10 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
     void testAccessFieldDefinedInInterface() {
         assertScript '''
             class Foo implements groovy.transform.stc.FieldsAndPropertiesSTCTest.InterfaceWithField {
-                void test() {
+                static main(args) {
                     assert boo == "I don't fancy fields in interfaces"
                 }
             }
-            new Foo().test()
         '''
     }
 
@@ -733,6 +732,7 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
                 }
                 def p = 1
             }
+
             def i = new Outer.Inner(new Outer())
             def x = i.m()
             assert x == 1
@@ -749,6 +749,7 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
                 }
                 def p = 1
             }
+
             def i = new Outer.Inner(new Outer())
             def x = i.m()
             assert x == 1
@@ -767,6 +768,7 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
                 }
                 def p = 1
             }
+
             def i = new Outer.Inner(new Outer())
             def x = i.m()
             assert x == 2
@@ -812,8 +814,6 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
                 }
                 def p = 1
             }
-            def i = new Outer.Inner()
-            def x = i.m()
         ''',
         'The variable [p] is undeclared.'
     }
@@ -828,8 +828,6 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
                 }
                 def p = 1
             }
-            def i = new Outer.Inner()
-            def x = i.m()
         ''',
         'No such property: p for class: Outer$Inner'
     }
@@ -846,6 +844,7 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
                     }
                 }
             }
+
             def in = Outer.Inner.FOO
             assert Outer.props == [bar: 10, baz: 20, foo: 30]
         '''
@@ -870,12 +869,44 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
                         }
                     }
                 }
+
                 Object value = new Outer.Inner().test(0)
                 assert value == 2
             """
         }
     }
 
+    void testOuterPropertyAccess10() {
+        assertScript '''
+            class Outer {
+                class Inner {
+                    def m() { p }
+                }
+                String p = 'field'
+                String getP() { 'property' }
+            }
+
+            String which = new Outer.Inner(new Outer()).m()
+            assert which == 'property'
+        '''
+    }
+
+    // GROOVY-11199
+    void testOuterPropertyAccess11() {
+        assertScript '''
+            class C {
+                class D {
+                    def m() { p = 'method' }
+                }
+                String p = 'field'
+                String getP() { 'property' }
+            }
+
+            String which = new C.D(new C()).m()
+            assert which == 'method'
+        '''
+    }
+
     // GROOVY-11029
     void testSuperPropertyAccess1() {
         assertScript '''
@@ -929,40 +960,40 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
 
     void testPrivateFieldAccessInAIC() {
         assertScript '''
-            class A {
+            class C {
                 private int x
-                void foo() {
-                    def aic = new Runnable() { void run() { x = 666 } }
+                void test() {
+                    def aic = new Runnable() {
+                        void run() { x = 666 }
+                    }
                     aic.run()
-                }
-                void ensure() {
                     assert x == 666
                 }
             }
-            def a = new A()
-            a.foo()
-            a.ensure()
+
+            new C().test()
         '''
     }
 
     void testPrivateFieldAccessInClosure1() {
         assertScript '''
-            class A {
+            class C {
                 private int x
                 void test() {
-                    def c = { -> x = 666 }
-                    c()
+                    def fun = { -> x = 666 }
+                    fun.call()
                     assert x == 666
                 }
             }
-            new A().test()
+
+            new C().test()
         '''
     }
 
     // GROOVY-9683
     void testPrivateFieldAccessInClosure2() {
         assertScript '''
-            class A {
+            class C {
                 private static X = 'xxx'
                 void test() {
                     [:].withDefault { throw new MissingPropertyException(it.toString()) }.with {
@@ -970,24 +1001,41 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
                     }
                 }
             }
-            new A().test()
+
+            new C().test()
         '''
     }
 
+    // GROOVY-11198
+    void testPrivateFieldAccessInEnumInit() {
+        for (mode in ['', 'public', 'private', 'protected', '@groovy.transform.PackageScope']) {
+            assertScript """
+                class C {
+                    $mode static int ONE = 1
+                    enum E {
+                        FOO(1 + ONE)
+                        final number
+                        E(int number) {
+                            this.number = number
+                        }
+                    }
+                }
+
+                assert C.E.FOO.number == 2
+            """
+        }
+    }
+
     // GROOVY-5737
     void testGeneratedFieldAccessInClosure() {
         assertScript '''
-            import groovy.transform.*
-            import groovy.util.logging.*
-
-            @Log
+            @groovy.util.logging.Log
             class GreetingActor {
-
-              def receive = {
-                log.info "test"
-              }
-
+                def receive = {
+                    log.info "test"
+                }
             }
+
             new GreetingActor()
         '''
     }
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/FieldsAndPropertiesStaticCompileTest.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/FieldsAndPropertiesStaticCompileTest.groovy
index 387febad8b..23d5a8b20e 100644
--- a/src/test/org/codehaus/groovy/classgen/asm/sc/FieldsAndPropertiesStaticCompileTest.groovy
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/FieldsAndPropertiesStaticCompileTest.groovy
@@ -812,12 +812,8 @@ final class FieldsAndPropertiesStaticCompileTest extends FieldsAndPropertiesSTCT
     // GROOVY-8369
     void testPropertyAccessOnEnumClass() {
         assertScript '''
-            enum Foo {}
-
-            def test() {
-                assert Foo.getModifiers() == Foo.modifiers
-            }
-            test()
+            enum Foo { }
+            assert Foo.modifiers === Foo.getModifiers()
         '''
     }
 
diff --git a/subprojects/groovy-ginq/src/main/groovy/org/apache/groovy/ginq/provider/collection/GinqAstWalker.groovy b/subprojects/groovy-ginq/src/main/groovy/org/apache/groovy/ginq/provider/collection/GinqAstWalker.groovy
index ca3b30f3a1..756e0182fd 100644
--- a/subprojects/groovy-ginq/src/main/groovy/org/apache/groovy/ginq/provider/collection/GinqAstWalker.groovy
+++ b/subprojects/groovy-ginq/src/main/groovy/org/apache/groovy/ginq/provider/collection/GinqAstWalker.groovy
@@ -78,7 +78,7 @@ import java.util.stream.Collectors
 
 import static groovy.lang.Tuple.tuple
 import static org.apache.groovy.ginq.dsl.GinqAstBuilder.GINQ_SELECT_DISTINCT
-import static org.codehaus.groovy.ast.ClassHelper.DYNAMIC_TYPE
+import static org.codehaus.groovy.ast.ClassHelper.dynamicType
 import static org.codehaus.groovy.ast.ClassHelper.makeCached
 import static org.codehaus.groovy.ast.ClassHelper.makeWithoutCaching
 import static org.codehaus.groovy.ast.tools.GeneralUtils.args
@@ -101,8 +101,9 @@ import static org.codehaus.groovy.ast.tools.GeneralUtils.returnS
 import static org.codehaus.groovy.ast.tools.GeneralUtils.stmt
 import static org.codehaus.groovy.ast.tools.GeneralUtils.tryCatchS
 import static org.codehaus.groovy.ast.tools.GeneralUtils.varX
+
 /**
- * Visit AST of GINQ to generate target method calls for GINQ
+ * Visit AST of GINQ to generate target method calls for GINQ.
  *
  * @since 4.0.0
  */
@@ -130,7 +131,7 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
 
         FromExpression fromExpression = currentGinqExpression.fromExpression
         resultDataSourceExpression = fromExpression
-        MethodCallExpression fromMethodCallExpression = this.visitFromExpression(fromExpression)
+        MethodCallExpression fromMethodCallExpression = visitFromExpression(fromExpression)
         resultMethodCallReceiver = fromMethodCallExpression
 
         for (JoinExpression joinExpression : currentGinqExpression.joinExpressionList) {
@@ -138,7 +139,7 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
             joinExpression.dataSourceExpression = resultDataSourceExpression
 
             resultDataSourceExpression = joinExpression
-            resultMethodCallReceiver = this.visitJoinExpression(resultDataSourceExpression)
+            resultMethodCallReceiver = visitJoinExpression(joinExpression)
         }
 
         WhereExpression whereExpression = currentGinqExpression.whereExpression
@@ -177,7 +178,7 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
         SelectExpression selectExpression = currentGinqExpression.selectExpression
         selectExpression.putNodeMetaData(__METHOD_CALL_RECEIVER, resultMethodCallReceiver)
         selectExpression.dataSourceExpression = resultDataSourceExpression
-        MethodCallExpression selectMethodCallExpression = this.visitSelectExpression(selectExpression)
+        MethodCallExpression selectMethodCallExpression = visitSelectExpression(selectExpression)
 
         List<Statement> statementList = []
         boolean isRootGinqExpression = ginqExpression === ginqExpression.getNodeMetaData(GinqAstBuilder.ROOT_GINQ_EXPRESSION)
@@ -192,7 +193,7 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
         }
 
         statementList << declS(
-                localVarX(metaDataMapName).tap {it.modifiers |= Opcodes.ACC_FINAL},
+                localVarX(metaDataMapName).tap{ modifiers |= Opcodes.ACC_FINAL },
                 callX(MAPS_TYPE, "of", args(
                         constX(MD_ALIAS_NAME_LIST), aliasNameListExpression,
                         constX(MD_GROUP_NAME_LIST), groupNameListExpression,
@@ -209,7 +210,7 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
         final resultName = "__r${System.nanoTime()}"
         statementList << tryCatchS(
                 block(
-                        declS(localVarX(resultName).tap {it.modifiers |= Opcodes.ACC_FINAL}, selectMethodCallExpression),
+                        declS(localVarX(resultName).tap{ modifiers |= Opcodes.ACC_FINAL }, selectMethodCallExpression),
                         returnS(varX(resultName))
                 ),
                 block(
@@ -237,18 +238,18 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
 
     private boolean isUseWindowFunction(GinqExpression ginqExpression) {
         boolean useWindowFunction = false
+
         ginqExpression.visit(new GinqAstBaseVisitor() {
             @Override
             void visitMethodCallExpression(MethodCallExpression call) {
                 if (isOverMethodCall(call)) {
                     useWindowFunction = true
-                    return
+                } else {
+                    super.visitMethodCallExpression(call)
                 }
-
-                super.visitMethodCallExpression(call)
             }
-
         })
+
         return useWindowFunction
     }
 
@@ -272,13 +273,10 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
     }
 
     private static boolean isOverMethodCall(Expression expression) {
-        if (expression instanceof MethodCallExpression) {
-            return expression.methodAsString == 'over'
-                    && expression.objectExpression instanceof MethodCallExpression
-                    && ((ArgumentListExpression) expression.arguments).getExpressions().size() < 2
-        }
-
-        return false
+        return expression instanceof MethodCallExpression
+            && expression.methodAsString == 'over'
+            && expression.objectExpression instanceof MethodCallExpression
+            && ((ArgumentListExpression) expression.arguments).getExpressions().size() < 2
     }
 
     private void addDummyGroupExpressionIfNecessary() {
@@ -293,22 +291,17 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
             void visitMethodCallExpression(MethodCallExpression call) {
                 if (isAggregateFunction(call)) {
                     hasAggFunctionInSelect = true
-                    return
-                }
-                if (isOverMethodCall(call)) {
-                    return
+                } else if (!isOverMethodCall(call)) {
+                    super.visitMethodCallExpression(call)
                 }
-
-                super.visitMethodCallExpression(call)
             }
 
             @Override
             void visitListOfExpressions(List<? extends Expression> list) {
-                if (list != null)
-                    list.forEach(expr -> {
-                        if (expr instanceof AbstractGinqExpression) return // do not visit subquery
+                list?.forEach(expr -> {
+                    if (expr !instanceof AbstractGinqExpression) // do not visit subquery
                         expr.visit(this)
-                    })
+                })
             }
         })
 
@@ -335,7 +328,7 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
         OnExpression onExpression = joinExpression.onExpression
 
         if (!onExpression && !joinExpression.crossJoin) {
-            this.collectSyntaxError(
+            collectSyntaxError(
                     new GinqSyntaxError(
                             "`on` clause is expected for `" + joinExpression.joinName + "`",
                             joinExpression.getLineNumber(), joinExpression.getColumnNumber()
@@ -360,16 +353,13 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
                 'from',
                 args(
                         dataSourceExpr instanceof AbstractGinqExpression
-                                ? this.visit((AbstractGinqExpression) dataSourceExpr)
+                                ? visit((AbstractGinqExpression) dataSourceExpr)
                                 : dataSourceExpr
                 )
         )
     }
 
-    private MethodCallExpression constructJoinMethodCallExpression(
-            Expression receiver, JoinExpression joinExpression,
-            OnExpression onExpression) {
-
+    private MethodCallExpression constructJoinMethodCallExpression(Expression receiver, JoinExpression joinExpression, OnExpression onExpression) {
         DataSourceExpression otherDataSourceExpression = joinExpression.dataSourceExpression
         Expression otherAliasExpr = otherDataSourceExpression.aliasExpr
 
@@ -402,7 +392,7 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
             List<Expression> rightExpressionList = []
 
             if (onExpression.filterExpr !instanceof BinaryExpression) {
-                this.collectSyntaxError(
+                collectSyntaxError(
                         new GinqSyntaxError(
                                 "Only binary expressions(`==`, `&&`) are allowed in `on` clause of hash join",
                                 onExpression.filterExpr.getLineNumber(), onExpression.filterExpr.getColumnNumber()
@@ -427,14 +417,14 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
             statementList.add(stmt(listX(leftExpressionList)))
             argumentExpressionList << lambdaX(
                     params(
-                            param(DYNAMIC_TYPE, otherParamName)
+                            param(dynamicType(), otherParamName)
                     ),
                     block(statementList as Statement[])
             )
 
             argumentExpressionList << lambdaX(
                     params(
-                            param(DYNAMIC_TYPE, joinExpression.aliasExpr.text)
+                            param(dynamicType(), joinExpression.aliasExpr.text)
                     ),
                     block(stmt(listX(rightExpressionList)))
             )
@@ -442,8 +432,8 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
             statementList.add(stmt(filterExpr))
             argumentExpressionList << (null == onExpression ? EmptyExpression.INSTANCE : lambdaX(
                     params(
-                            param(DYNAMIC_TYPE, otherParamName),
-                            param(DYNAMIC_TYPE, joinExpression.aliasExpr.text)
+                            param(dynamicType(), otherParamName),
+                            param(dynamicType(), joinExpression.aliasExpr.text)
                     ),
                     block(statementList as Statement[])))
         }
@@ -479,15 +469,13 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
             void visitBinaryExpression(BinaryExpression expression) {
                 if (Types.LOGICAL_AND == expression.operation.type) {
                     super.visitBinaryExpression(expression)
-                    return
                 } else if (Types.COMPARE_EQUAL == expression.operation.type) {
                     equalExpressionList << expression
-                    return
-                }
-
-                valid = false
-                if (errorCollector) {
-                    errorCollector.accept(expression)
+                } else {
+                    valid = false
+                    if (errorCollector) {
+                        errorCollector.accept(expression)
+                    }
                 }
             }
         })
@@ -513,7 +501,7 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
             })
             def variableNameList = foundVariableExpressionList.collect { it.text }
             if (1 != variableNameList.size()) {
-                this.collectSyntaxError(
+                collectSyntaxError(
                         new GinqSyntaxError(
                                 "Only one alias expected at each side of `==`, but found: ${variableNameList}",
                                 expression.getLineNumber(), expression.getColumnNumber()
@@ -527,7 +515,7 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
             } else if (dataSourceAliasList.contains(aliasName)) {
                 leftExpressionList << expression
             } else {
-                this.collectSyntaxError(
+                collectSyntaxError(
                         new GinqSyntaxError(
                                 "Unknown alias: ${aliasName}",
                                 expression.getLineNumber(), expression.getColumnNumber()
@@ -539,35 +527,30 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
 
     @Override
     MethodCallExpression visitWhereExpression(WhereExpression whereExpression) {
-        DataSourceExpression dataSourceExpression = whereExpression.dataSourceExpression
+        DataSourceExpression dataSourceExpression = whereExpression.getDataSourceExpression()
         Expression fromMethodCallExpression = whereExpression.getNodeMetaData(__METHOD_CALL_RECEIVER)
         Expression filterExpr = whereExpression.getFilterExpr()
 
         // construct the `ListExpression` instance to transform `filterExpr` in the same time
-        filterExpr = ((ListExpression) new ListExpression(Collections.singletonList(filterExpr)).transformExpression(
-                new ExpressionTransformer() {
-                    @Override
-                    Expression transform(Expression expression) {
-                        if (expression instanceof AbstractGinqExpression) {
-                            def ginqExpression = GinqAstWalker.this.visit((AbstractGinqExpression) expression)
-                            return ginqExpression
-                        }
+        filterExpr = ((ListExpression) new ListExpression(Collections.singletonList(filterExpr)).transformExpression(new ExpressionTransformer() {
+            @Override
+            Expression transform(Expression expression) {
+                if (expression instanceof AbstractGinqExpression) {
+                    return visit((AbstractGinqExpression) expression)
+                }
 
-                        if (expression instanceof BinaryExpression) {
-                            if (expression.operation.type in [Types.KEYWORD_IN, Types.COMPARE_NOT_IN]) {
-                                if (expression.rightExpression instanceof AbstractGinqExpression) {
-                                    expression.rightExpression =
-                                            callX(GinqAstWalker.this.visit((AbstractGinqExpression) expression.rightExpression),
-                                                    "toList")
-                                    return expression
-                                }
-                            }
+                if (expression instanceof BinaryExpression) {
+                    if (expression.operation.type in [Types.KEYWORD_IN, Types.COMPARE_NOT_IN]) {
+                        if (expression.rightExpression instanceof AbstractGinqExpression) {
+                            expression.rightExpression = callX(visit((AbstractGinqExpression) expression.rightExpression), "toList")
+                            return expression
                         }
-
-                        return expression.transformExpression(this)
                     }
                 }
-        )).getExpression(0)
+
+                return expression.transformExpression(this)
+            }
+        })).getExpression(0)
 
         def whereMethodCallExpression = callXWithLambda(fromMethodCallExpression, "where", dataSourceExpression, filterExpr)
         whereMethodCallExpression.setSourcePosition(whereExpression)
@@ -586,10 +569,9 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
 
         LambdaExpression classifierLambdaExpression = constructLambdaExpression(dataSourceExpression, namedListCtorCallExpression)
 
-        List<Expression> argList = new ArrayList<>()
-        argList << classifierLambdaExpression
+        List<Expression> argList = [classifierLambdaExpression]
 
-        this.currentGinqExpression.putNodeMetaData(__GROUPBY_VISITED, true)
+        getCurrentGinqExpression().putNodeMetaData(__GROUPBY_VISITED, true)
 
         HavingExpression havingExpression = groupExpression.havingExpression
         if (havingExpression) {
@@ -606,7 +588,7 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
 
     @Override
     Expression visitHavingExpression(HavingExpression havingExpression) {
-        return null // do nothing
+        // do nothing
     }
 
     @Override
@@ -634,7 +616,7 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
                                 ? ((MethodCallExpression) e.rightExpression).methodAsString
                                 : e.rightExpression.text
                 if (!ORDER_OPTION_LIST.contains(orderOption)) {
-                    this.collectSyntaxError(
+                    collectSyntaxError(
                             new GinqSyntaxError(
                                     "Invalid order: " + orderOption + ", `asc`/`desc` is expected",
                                     e.rightExpression.getLineNumber(), e.rightExpression.getColumnNumber()
@@ -652,7 +634,7 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
                         if (nullsOptionExpression instanceof VariableExpression) {
                             nullsOption = nullsOptionExpression.text
                             if (!NULLS_OPTION_LIST.contains(nullsOption)) {
-                                this.collectSyntaxError(
+                                collectSyntaxError(
                                         new GinqSyntaxError(
                                                 "Invalid nulls order: " + nullsOption + ", `nullslast`/`nullsfirst` is expected",
                                                 nullsOptionExpression.getLineNumber(), nullsOptionExpression.getColumnNumber()
@@ -661,7 +643,7 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
                             }
                         }
                     } else {
-                        this.collectSyntaxError(
+                        collectSyntaxError(
                                 new GinqSyntaxError(
                                         "Only `nullslast`/`nullsfirst` is expected",
                                         mce.arguments.getLineNumber(), mce.arguments.getColumnNumber()
@@ -683,11 +665,10 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
     @Override
     MethodCallExpression visitLimitExpression(LimitExpression limitExpression) {
         Expression limitMethodCallReceiver = limitExpression.getNodeMetaData(__METHOD_CALL_RECEIVER)
-        Expression offsetAndSizeExpr = limitExpression.offsetAndSizeExpr
+        Expression offsetAndSizeExpr = limitExpression.getOffsetAndSizeExpr()
 
         def limitMethodCallExpression = callX(limitMethodCallReceiver, "limit", offsetAndSizeExpr)
         limitMethodCallExpression.setSourcePosition(limitExpression)
-
         return limitMethodCallExpression
     }
 
@@ -716,13 +697,13 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
             void visitMethodCallExpression(MethodCallExpression call) {
                 if (isOverMethodCall(call)) {
                     hasOverMethodCallExpression = true
-                    return
+                } else {
+                    super.visitMethodCallExpression(call)
                 }
-                super.visitMethodCallExpression(call)
             }
         })
 
-        final enableCount = !hasRnVariable && hasOverMethodCallExpression
+        final boolean enableCount = !hasRnVariable && hasOverMethodCallExpression
 
         Expression lambdaCode = expressionList.get(0)
         def expressionListSize = expressionList.size()
@@ -738,15 +719,15 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
             Expression transform(Expression expression) {
                 if (expression instanceof VariableExpression) {
                     if (_RN == expression.text) {
-                        currentGinqExpression.putNodeMetaData(__RN_USED, true)
-                        return parallel ? supplyAsyncLambdaParam : callX(varX(rowNumberName), 'get')
+                        getCurrentGinqExpression().putNodeMetaData(__RN_USED, true)
+                        return parallel ? supplyAsyncLambdaParam : callX(varX(getRowNumberName()), 'get')
                     }
                 }
 
                 if (expression instanceof AbstractGinqExpression) {
                     return callX(
                             classX(QUERYABLE_HELPER_TYPE), "singleValue",
-                            GinqAstWalker.this.visit((AbstractGinqExpression) expression)
+                            visit((AbstractGinqExpression) expression)
                     )
                 }
 
@@ -758,7 +739,7 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
                             String lambdaParamName = getLambdaParamName(dataSourceExpression, lambdaCode)
                             VariableExpression currentRecordVar = varX(lambdaParamName)
 
-                            currentGinqExpression.putNodeMetaData(__VISITING_WINDOW_FUNCTION, true)
+                            getCurrentGinqExpression().putNodeMetaData(__VISITING_WINDOW_FUNCTION, true)
                             def windowFunctionMethodCallExpression = (MethodCallExpression) expression.objectExpression
 
                             Expression result = null
@@ -781,7 +762,7 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
                                                         return correctVars(dataSourceExpression, windowFunctionLambdaName, expr)
                                                     }
 
-                                                    return new VariableExpression(windowFunctionLambdaName)
+                                                    return varX(windowFunctionLambdaName)
                                                 } else if (FUNCTION_AGG == windowFunctionMethodCallExpression.methodAsString && _G == expr.text) {
                                                     if (isJoin) {
                                                         windowFunctionLambdaName = getLambdaParamName(dataSourceExpression, expr)
@@ -790,7 +771,7 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
                                                     return callX(
                                                             classX(QUERYABLE_HELPER_TYPE),
                                                             "navigate",
-                                                            args(new VariableExpression(windowFunctionLambdaName), getMetaDataMethodCall(MD_ALIAS_NAME_LIST))
+                                                            args(varX(windowFunctionLambdaName), getMetaDataMethodCall(MD_ALIAS_NAME_LIST))
                                                     )
                                                 }
                                             }
@@ -802,7 +783,7 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
                                         argumentExpressionList << argumentListExpression.getExpression(0)
                                     } else {
                                         argumentExpressionList << lambdaX(
-                                                params(param(DYNAMIC_TYPE, windowFunctionLambdaName)),
+                                                params(param(dynamicType(), windowFunctionLambdaName)),
                                                 block(stmt(windowFunctionLambdaCode))
                                         )
                                     }
@@ -826,13 +807,13 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
                                         args(argumentExpressionList)
                                 )
                             } else {
-                                GinqAstWalker.this.collectSyntaxError(new GinqSyntaxError(
+                                collectSyntaxError(new GinqSyntaxError(
                                         "Unsupported window function: `${windowFunctionMethodCallExpression.methodAsString}`",
                                         windowFunctionMethodCallExpression.getLineNumber(), windowFunctionMethodCallExpression.getColumnNumber()
                                 ))
                             }
 
-                            currentGinqExpression.putNodeMetaData(__VISITING_WINDOW_FUNCTION, false)
+                            getCurrentGinqExpression().putNodeMetaData(__VISITING_WINDOW_FUNCTION, false)
 
                             return result
                         }
@@ -849,7 +830,7 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
             extra << callX(varX(rowNumberName), 'getAndIncrement')
         }
 
-        def selectMethodCallExpression = callXWithLambda(selectMethodReceiver, "select", dataSourceExpression, parallel, lambdaCode, extra, param(DYNAMIC_TYPE, getWindowQueryableName()))
+        def selectMethodCallExpression = callXWithLambda(selectMethodReceiver, "select", dataSourceExpression, parallel, lambdaCode, extra, param(dynamicType(), getWindowQueryableName()))
 
         currentGinqExpression.putNodeMetaData(__VISITING_SELECT, false)
 
@@ -862,8 +843,7 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
     }
 
     private MethodCallExpression getRowNumberMethodCall() {
-        final rowNumberGetMethodCall = callX(varX(rowNumberName), 'get')
-        return rowNumberGetMethodCall
+        callX(varX(rowNumberName), 'get')
     }
 
     private MethodCallExpression constructWindowDefinitionFactoryMethodCallExpression(MethodCallExpression methodCallExpression, DataSourceExpression dataSourceExpression) {
@@ -910,7 +890,7 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
         }
 
         if (rowsExpr && rangeExpr) {
-            this.collectSyntaxError(new GinqSyntaxError(
+            collectSyntaxError(new GinqSyntaxError(
                     "`rows` and `range` cannot be used in the same time",
                     rangeExpr.getLineNumber(), rangeExpr.getColumnNumber()
             ))
@@ -918,7 +898,7 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
 
         if (rowsExpr) {
             if (2 != ((ArgumentListExpression) rowsExpr).getExpressions().size()) {
-                this.collectSyntaxError(new GinqSyntaxError(
+                collectSyntaxError(new GinqSyntaxError(
                         "Both lower bound and upper bound are expected for `rows`",
                         rowsExpr.getLineNumber(), rowsExpr.getColumnNumber()
                 ))
@@ -930,20 +910,20 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
 
         if (rangeExpr) {
             if (2 != ((ArgumentListExpression) rangeExpr).getExpressions().size()) {
-                this.collectSyntaxError(new GinqSyntaxError(
+                collectSyntaxError(new GinqSyntaxError(
                         "Both lower bound and upper bound are expected for `range`",
                         rangeExpr.getLineNumber(), rangeExpr.getColumnNumber()
                 ))
             }
 
             if (!orderExpr) {
-                this.collectSyntaxError(new GinqSyntaxError(
+                collectSyntaxError(new GinqSyntaxError(
                         "`orderby` is expected when using `range`",
                         rangeExpr.getLineNumber(), rangeExpr.getColumnNumber()
                 ))
             }
             if (((ArgumentListExpression) orderExpr).getExpressions().size() != 1) {
-                this.collectSyntaxError(new GinqSyntaxError(
+                collectSyntaxError(new GinqSyntaxError(
                         "Only one field is expected in the `orderby` clause when using `range`",
                         orderExpr.getLineNumber(), orderExpr.getColumnNumber()
                 ))
@@ -990,7 +970,7 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
 
         if (ignoredMethodCallExpressionList) {
             MethodCallExpression ignoredMce = ignoredMethodCallExpressionList.get(0)
-            this.collectSyntaxError(new GinqSyntaxError(
+            collectSyntaxError(new GinqSyntaxError(
                     "Unknown window clause: `${ignoredMce.methodAsString}`",
                     ignoredMce.getLineNumber(), ignoredMce.getColumnNumber()
             ))
@@ -1025,18 +1005,17 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
                 new ListExpression(Collections.singletonList(expression)).transformExpression(new ExpressionTransformer() {
                     @Override
                     Expression transform(Expression expr) {
-                        if (transformCol(expr).v2.text in groupNameList) {
+                        if (transformCol(expr).v2.text in getGroupNameList()) {
                             return expr
                         }
                         if (isExpression(expr, VariableExpression, PropertyExpression)) {
-                            def text = expr instanceof PropertyExpression ? ((PropertyExpression) expr).propertyAsString : expr.text
+                            def text = expr instanceof PropertyExpression ? expr.propertyAsString : expr.text
                             if (Character.isUpperCase(text.charAt(0))) {
                                 return expr
                             }
-
-                            Expression rootObjectExpression = findRootObjectExpression(expr)
-                            if (rootObjectExpression.text !in groupNameList && rootObjectExpression.text in aliasNameList) {
-                                GinqAstWalker.this.collectSyntaxError(new GinqSyntaxError(
+                            def rootObjectExpression = findRootObjectExpression(expr).text
+                            if (rootObjectExpression !in getGroupNameList() && rootObjectExpression in getAliasNameList()) {
+                                collectSyntaxError(new GinqSyntaxError(
                                         "`${expr.text}` is not in the `groupby` clause",
                                         expr.getLineNumber(), expr.getColumnNumber()
                                 ))
@@ -1045,20 +1024,18 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
                             if (isAggregateFunction(expr)) {
                                 return expr
                             }
-
                             if (((MethodCallExpression) expr).implicitThis) {
-                                GinqAstWalker.this.collectSyntaxError(new GinqSyntaxError(
+                                collectSyntaxError(new GinqSyntaxError(
                                         "`${expr instanceof CastExpression ? expr.expression.text : expr.text}` is not an aggregate function",
                                         expr.getLineNumber(), expr.getColumnNumber()
                                 ))
                             }
                         } else if (isExpression(expr, AbstractGinqExpression)) {
-                            GinqAstWalker.this.collectSyntaxError(new GinqSyntaxError(
+                            collectSyntaxError(new GinqSyntaxError(
                                     "sub-query could not be used in the `select` clause with `groupby`",
                                     expr.getLineNumber(), expr.getColumnNumber()
                             ))
                         }
-
                         return expr.transformExpression(this)
                     }
                 })
@@ -1069,7 +1046,6 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
     private static Tuple2<Expression, Expression> transformCol(Expression e) {
         Expression elementExpression = e
         Expression nameExpression = null
-
         if (e instanceof CastExpression) {
             elementExpression = e.expression
             nameExpression = constX(e.type.text)
@@ -1082,11 +1058,9 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
                 nameExpression = e.property
             }
         }
-
-        if (null == nameExpression) {
+        if (nameExpression == null) {
             nameExpression = constX(e.text)
         }
-
         return tuple(elementExpression, nameExpression)
     }
 
@@ -1159,35 +1133,34 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
     }
 
     private ListExpression getSelectNameListExpression() {
-        return (ListExpression) (currentGinqExpression.getNodeMetaData(MD_SELECT_NAME_LIST) ?: [])
+        (ListExpression) (currentGinqExpression.getNodeMetaData(MD_SELECT_NAME_LIST) ?: [])
     }
 
     private ListExpression getGroupNameListExpression() {
-        return (ListExpression) (currentGinqExpression.getNodeMetaData(MD_GROUP_NAME_LIST) ?: [])
+        (ListExpression) (currentGinqExpression.getNodeMetaData(MD_GROUP_NAME_LIST) ?: [])
     }
 
     private List<String> getGroupNameList() {
-        return groupNameListExpression.expressions*.text
+        groupNameListExpression.expressions*.text
     }
 
     private ListExpression getAliasNameListExpression() {
-        return new ListExpression(aliasExpressionList)
+        new ListExpression(aliasExpressionList)
     }
 
     private List<String> getAliasNameList() {
-        return aliasExpressionList*.text
+        aliasExpressionList*.text
     }
 
     private List<Expression> getAliasExpressionList() {
-        return dataSourceAliasList.collect { (Expression) constX(it) }
+        dataSourceAliasList.collect { (Expression) constX(it) }
     }
 
     private List<String> getDataSourceAliasList() {
         List<DataSourceExpression> dataSourceExpressionList = []
         dataSourceExpressionList << currentGinqExpression.fromExpression
         dataSourceExpressionList.addAll(currentGinqExpression.joinExpressionList)
-
-        return dataSourceExpressionList.stream().map(e -> e.aliasExpr.text).collect(Collectors.toList())
+        dataSourceExpressionList.stream().map(e -> e.aliasExpr.text).collect(Collectors.toList())
     }
 
     private Tuple2<List<DeclarationExpression>, Expression> correctVariablesOfGinqExpression(DataSourceExpression dataSourceExpression, Expression expr) {
@@ -1209,13 +1182,13 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
                 }
             })
 
-            def lambdaParam = new VariableExpression(lambdaParamName)
+            def lambdaParam = varX(lambdaParamName)
             Map<String, Expression> aliasToAccessPathMap = findAliasAccessPath(dataSourceExpression, lambdaParam)
             declarationExpressionList =
                     aliasToAccessPathMap.entrySet().stream()
                             .filter(e -> variableNameSet.contains(e.key))
                             .map(e -> {
-                                def v = localVarX(e.key).tap {it.modifiers |= Opcodes.ACC_FINAL  }
+                                def v = localVarX(e.key).tap { modifiers |= Opcodes.ACC_FINAL }
 
                                 if (isGroup) {
                                     return declX(v, propX(varX(__SOURCE_RECORD), e.key))
@@ -1245,7 +1218,7 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
             }
         }))).getExpression(0)
 
-        return tuple(declarationExpressionList, expr)
+        tuple(declarationExpressionList, expr)
     }
 
     private boolean isExternalVariable(Expression rootObjectExpression) {
@@ -1284,10 +1257,10 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
                                     callX(
                                         classX(QUERYABLE_HELPER_TYPE),
                                             "navigate",
-                                        args(new VariableExpression(lambdaParamName), getMetaDataMethodCall(MD_ALIAS_NAME_LIST))
+                                        args(varX(lambdaParamName), getMetaDataMethodCall(MD_ALIAS_NAME_LIST))
                                     )
                         } else {
-                            transformedExpression = new VariableExpression(lambdaParamName)
+                            transformedExpression = varX(lambdaParamName)
                         }
                     } else {
                         if (groupNameListExpression.getExpressions().stream().map(e -> e.text).anyMatch(e -> e == expression.text)
@@ -1302,7 +1275,7 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
                 if (visitingWindowFunction) {
                     boolean isJoin = dataSourceExpression instanceof JoinExpression
                     if (isJoin) {
-                        Map<String, Expression>  aliasAccessPathMap = findAliasAccessPath(dataSourceExpression, new VariableExpression(lambdaParamName))
+                        Map<String, Expression>  aliasAccessPathMap = findAliasAccessPath(dataSourceExpression, varX(lambdaParamName))
                         transformedExpression = aliasAccessPathMap.get(expression.text)
                     }
                 }
@@ -1333,7 +1306,7 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
             return transformedExpression
         }
 
-        return expression
+        expression
     }
 
     private static Map<String, Expression> findAliasAccessPath(DataSourceExpression dataSourceExpression, Expression prop) {
@@ -1373,7 +1346,7 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
             }
         }
 
-        return aliasToAccessPathMap
+        aliasToAccessPathMap
     }
 
     private static Expression findRootObjectExpression(Expression expression) {
@@ -1382,19 +1355,18 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
             for (; expr instanceof PropertyExpression; expr = ((PropertyExpression) expr).objectExpression) {}
             return expr
         }
-
-        return expression
+        expression
     }
 
     private final Deque<String> visitingAggregateFunctionStack = new ArrayDeque<>()
 
     @Override
     Expression visit(AbstractGinqExpression expression) {
-        return expression.accept(this)
+        expression.accept(this)
     }
 
     private MethodCallExpression callXWithLambda(Expression receiver, String methodName, DataSourceExpression dataSourceExpression, Expression lambdaCode, Parameter... extraParams) {
-        this.callXWithLambda(receiver, methodName, dataSourceExpression, lambdaCode, Collections.emptyList(), extraParams)
+        callXWithLambda(receiver, methodName, dataSourceExpression, lambdaCode, Collections.emptyList(), extraParams)
     }
 
     private MethodCallExpression callXWithLambda(Expression receiver, String methodName, DataSourceExpression dataSourceExpression, boolean async = false, Expression lambdaCode, List<Expression> extraLambdaCode, Parameter... extraParams) {
@@ -1420,7 +1392,7 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
         if (async) {
             ArgumentListExpression  argumentListExpression
             argumentListExpression = rowNumberUsed
-                                        ? args(lambdaX(params(param(DYNAMIC_TYPE, supplyAsyncLambdaParamName)),
+                                        ? args(lambdaX(params(param(dynamicType(), supplyAsyncLambdaParamName)),
                                                         stmt(transformedLambdCode)),
                                                 rowNumberUsed ? getRowNumberMethodCall() : nullX())
                                         : args(lambdaX(stmt(transformedLambdCode)))
@@ -1433,7 +1405,7 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
         }
         statementList.add(stmt(transformedLambdCode))
 
-        def paramList = [param(DYNAMIC_TYPE, paramNameAndLambdaCode.v1)]
+        def paramList = [param(dynamicType(), paramNameAndLambdaCode.v1)]
         if (extraParams) {
             paramList.addAll(Arrays.asList(extraParams))
         }
@@ -1461,7 +1433,7 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
             lambdaParamName = dataSourceExpression.aliasExpr.text
         }
         lambdaCode.putNodeMetaData(__LAMBDA_PARAM_NAME, lambdaParamName)
-        return lambdaParamName
+        lambdaParamName
     }
 
     private Tuple3<String, List<DeclarationExpression>, Expression> correctVariablesOfLambdaExpression(DataSourceExpression dataSourceExpression, Expression lambdaCode) {
@@ -1475,13 +1447,13 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
 
                 if (groupByVisited) {
                     final sourceRecordDecl =
-                            declX(localVarX(__SOURCE_RECORD).tap { it.modifiers |= Opcodes.ACC_FINAL },
-                                    propX(new VariableExpression(lambdaParamName), 'v1'))
+                            declX(localVarX(__SOURCE_RECORD).tap{ modifiers |= Opcodes.ACC_FINAL },
+                                    propX(varX(lambdaParamName), 'v1'))
                     declarationExpressionList.add(0, sourceRecordDecl)
 
                     final groupDecl =
-                            declX(localVarX(__GROUP).tap { it.modifiers |= Opcodes.ACC_FINAL },
-                                    propX(new VariableExpression(lambdaParamName), 'v2'))
+                            declX(localVarX(__GROUP).tap{ modifiers |= Opcodes.ACC_FINAL },
+                                    propX(varX(lambdaParamName), 'v2'))
                     declarationExpressionList.add(1, groupDecl)
                 }
             }
@@ -1493,7 +1465,7 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
                     Expression transform(Expression expr) {
                         if (expr instanceof VariableExpression) {
                             if (dataSourceExpression.aliasExpr.text == expr.text) {
-                                return new VariableExpression(lambdaParamName)
+                                return varX(lambdaParamName)
                             }
                         }
                         return expr.transformExpression(this)
@@ -1502,15 +1474,14 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
             }
         }
 
-
         if (lambdaCode instanceof ConstructorCallExpression) {
             if (NAMEDRECORD_CLASS_NAME == lambdaCode.type.redirect().name) {
                 // store the source record
-                lambdaCode = callX(lambdaCode, 'sourceRecord', new VariableExpression(lambdaParamName))
+                lambdaCode = callX(lambdaCode, 'sourceRecord', varX(lambdaParamName))
             }
         }
 
-        return tuple(lambdaParamName, declarationExpressionList, lambdaCode)
+        tuple(lambdaParamName, declarationExpressionList, lambdaCode)
     }
 
     private boolean isGroupByVisited() {
@@ -1518,15 +1489,15 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
     }
 
     private boolean isVisitingSelect() {
-        return currentGinqExpression.getNodeMetaData(__VISITING_SELECT) ?: false
+        currentGinqExpression.getNodeMetaData(__VISITING_SELECT) ?: false
     }
 
     private boolean isVisitingWindowFunction() {
-        return currentGinqExpression.getNodeMetaData(__VISITING_WINDOW_FUNCTION) ?: false
+        currentGinqExpression.getNodeMetaData(__VISITING_WINDOW_FUNCTION) ?: false
     }
 
     private boolean isRowNumberUsed() {
-        return currentGinqExpression.getNodeMetaData(__RN_USED)  ?: false
+        currentGinqExpression.getNodeMetaData(__RN_USED)  ?: false
     }
 
     private static MethodCallExpression callXWithLambda(Expression receiver, String methodName, LambdaExpression lambdaExpression) {
@@ -1537,10 +1508,7 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
         )
     }
 
-    @Override
-    SourceUnit getSourceUnit() {
-        sourceUnit
-    }
+    final SourceUnit sourceUnit
 
     private Map<String, String> configuration
     @Override
@@ -1552,7 +1520,6 @@ class GinqAstWalker implements GinqAstVisitor<Expression>, SyntaxErrorReportable
         return configuration
     }
 
-    private final SourceUnit sourceUnit
     private final Deque<GinqExpression> ginqExpressionStack = new ArrayDeque<>()
 
     private static final ClassNode MAPS_TYPE = makeWithoutCaching(Maps.class)
