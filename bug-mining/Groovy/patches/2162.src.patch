diff --git a/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java b/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java
index 4620091051..df5b021237 100644
--- a/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java
+++ b/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java
@@ -688,6 +688,8 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
             element = element.getNextSibling();
         }
         String identifier = identifier(element);
+        int savedLine = element.getLine();
+        int savedColumn = element.getColumn();
         Expression init = null;
         element = element.getNextSibling();
 
@@ -736,7 +738,7 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
                 }
             }
         }
-        EnumHelper.addEnumConstant(classNode, identifier, init);
+        EnumHelper.addEnumConstant(classNode, identifier, init, savedLine, savedColumn);
         enumConstantBeingDef = false;
     }
 
diff --git a/src/main/org/codehaus/groovy/antlr/EnumHelper.java b/src/main/org/codehaus/groovy/antlr/EnumHelper.java
index d09773614b..76f2194488 100644
--- a/src/main/org/codehaus/groovy/antlr/EnumHelper.java
+++ b/src/main/org/codehaus/groovy/antlr/EnumHelper.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2010 the original author or authors.
+ * Copyright 2003-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -25,7 +25,6 @@ import org.codehaus.groovy.ast.expr.Expression;
 import org.codehaus.groovy.ast.expr.ListExpression;
 import org.objectweb.asm.Opcodes;
 
-
 public class EnumHelper {
     private static final int FS = Opcodes.ACC_FINAL | Opcodes.ACC_STATIC;
     private static final int PUBLIC_FS = Opcodes.ACC_PUBLIC | FS; 
@@ -52,13 +51,19 @@ public class EnumHelper {
     }
 
     public static void addEnumConstant(ClassNode enumClass, String name, Expression init) {
+        addEnumConstant(enumClass, name, init, -1, -1);
+    }
+
+    public static void addEnumConstant(ClassNode enumClass, String name, Expression init, int lineNumber, int colNumber) {
         int modifiers = PUBLIC_FS | Opcodes.ACC_ENUM;
-        if  (init!=null && !(init instanceof ListExpression)) {
+        if (init != null && !(init instanceof ListExpression)) {
             ListExpression list = new ListExpression();
             list.addExpression(init);
             init = list;
         }
-        FieldNode fn = new FieldNode(name,modifiers,enumClass.getPlainNodeReference(),enumClass,init);
+        FieldNode fn = new FieldNode(name, modifiers, enumClass.getPlainNodeReference(), enumClass, init);
+        fn.setLineNumber(lineNumber);
+        fn.setColumnNumber(colNumber);
         enumClass.addField(fn);
     }
 }
diff --git a/src/main/org/codehaus/groovy/classgen/EnumVisitor.java b/src/main/org/codehaus/groovy/classgen/EnumVisitor.java
index 0f4af53de8..755f97b965 100644
--- a/src/main/org/codehaus/groovy/classgen/EnumVisitor.java
+++ b/src/main/org/codehaus/groovy/classgen/EnumVisitor.java
@@ -66,15 +66,26 @@ public class EnumVisitor extends ClassCodeVisitorSupport {
             values.setSynthetic(true);
 
             addMethods(enumClass, values);
+            checkForAbstractMethods(enumClass);
 
             // create MIN_VALUE and MAX_VALUE fields
             minValue = new FieldNode("MIN_VALUE", PUBLIC_FS, enumRef, enumClass, null);
             maxValue = new FieldNode("MAX_VALUE", PUBLIC_FS, enumRef, enumClass, null);
-
         }
         addInit(enumClass, minValue, maxValue, values, isAic);
     }
 
+    private void checkForAbstractMethods(ClassNode enumClass) {
+        List<MethodNode> methods = enumClass.getMethods();
+        for (MethodNode m : methods) {
+            if (m.isAbstract()) {
+                // make the class abstract also see Effective Java p.152
+                enumClass.setModifiers(enumClass.getModifiers() | Opcodes.ACC_ABSTRACT);
+                break;
+            }
+        }
+    }
+
     private void addMethods(ClassNode enumClass, FieldNode values) {
         List<MethodNode> methods = enumClass.getMethods();
 
@@ -291,15 +302,16 @@ public class EnumVisitor extends ClassCodeVisitorSupport {
             ArgumentListExpression args = new ArgumentListExpression();
             args.addExpression(new ConstantExpression(field.getName()));
             args.addExpression(new ConstantExpression(value));
-            if (field.getInitialExpression() != null) {
+            if (field.getInitialExpression() == null) {
+                if ((enumClass.getModifiers() & Opcodes.ACC_ABSTRACT) != 0) {
+                    addError(field, "The enum constant " + field.getName() + " must override abstract methods from " + enumBase.getName() + ".");
+                    continue;
+                }
+            } else {
                 ListExpression oldArgs = (ListExpression) field.getInitialExpression();
                 for (Expression exp : oldArgs.getExpressions()) {
                     if (exp instanceof MapEntryExpression) {
-                        String msg = "The usage of a map entry expression to initialize an Enum is currently not supported, please use an explicit map instead.";
-                        sourceUnit.getErrorCollector().addErrorAndContinue(
-                                new SyntaxErrorMessage(
-                                        new SyntaxException(msg + '\n', exp.getLineNumber(), exp.getColumnNumber(), exp.getLastLineNumber(), exp.getLastColumnNumber()), sourceUnit)
-                        );
+                        addError(exp, "The usage of a map entry expression to initialize an Enum is currently not supported, please use an explicit map instead.");
                         continue;
                     }
 
@@ -312,6 +324,14 @@ public class EnumVisitor extends ClassCodeVisitorSupport {
                         }
                     }
                     if (inner != null) {
+                        List<MethodNode> baseMethods = enumBase.getMethods();
+                        for (MethodNode methodNode : baseMethods) {
+                            if (!methodNode.isAbstract()) continue;
+                            MethodNode enumConstMethod = inner.getMethod(methodNode.getName(), methodNode.getParameters());
+                            if (enumConstMethod == null || (enumConstMethod.getModifiers() & Opcodes.ACC_ABSTRACT) != 0) {
+                                addError(field, "Can't have an abstract method in enum constant " + field.getName() + ". Implement method '" + methodNode.getTypeDescriptor() + "'.");
+                            }
+                        }
                         if (inner.getVariableScope() == null) {
                             enumBase = inner;
                             /*
@@ -373,6 +393,13 @@ public class EnumVisitor extends ClassCodeVisitorSupport {
         enumClass.addStaticInitializerStatements(block, true);
     }
 
+    private void addError(AnnotatedNode exp, String msg) {
+        sourceUnit.getErrorCollector().addErrorAndContinue(
+                new SyntaxErrorMessage(
+                        new SyntaxException(msg + '\n', exp.getLineNumber(), exp.getColumnNumber(), exp.getLastLineNumber(), exp.getLastColumnNumber()), sourceUnit)
+        );
+    }
+
     private boolean isAnonymousInnerClass(ClassNode enumClass) {
         if (!(enumClass instanceof EnumConstantClassNode)) return false;
         InnerClassNode ic = (InnerClassNode) enumClass;
diff --git a/src/test/gls/enums/EnumTest.groovy b/src/test/gls/enums/EnumTest.groovy
index db58cc0498..6db9c470dd 100644
--- a/src/test/gls/enums/EnumTest.groovy
+++ b/src/test/gls/enums/EnumTest.groovy
@@ -442,6 +442,42 @@ class EnumTest extends CompilableTestSupport {
             assert Country.Poland.countryCode == 'pl'
         """
     }
+
+    void testAbstractMethodOverriding() {
+        // GROOVY-4641
+        assertScript """
+            enum Day {
+               SUNDAY {
+                  String getAction() { 'Relax' }
+               },
+               MONDAY {
+                   String getAction() { 'Work' }
+               }
+               abstract String getAction()
+            }
+            assert 'Relax' ==  Day.SUNDAY.action
+        """
+        shouldNotCompile """
+            enum Day {
+               SUNDAY {
+                  String getAction() { 'Relax' }
+               },
+               MONDAY
+               abstract String getAction()
+            }
+            assert 'Relax' ==  Day.SUNDAY.action
+        """
+        shouldNotCompile """
+            enum Day {
+               SUNDAY {
+                  String getAction() { 'Relax' }
+               },
+               MONDAY {}
+               abstract String getAction()
+            }
+            assert 'Relax' ==  Day.SUNDAY.action
+        """
+    }
 }
 
 enum UsCoin {
