diff --git a/src/main/java/org/codehaus/groovy/reflection/CachedClass.java b/src/main/java/org/codehaus/groovy/reflection/CachedClass.java
index 61cdc32092..abcd31e17a 100644
--- a/src/main/java/org/codehaus/groovy/reflection/CachedClass.java
+++ b/src/main/java/org/codehaus/groovy/reflection/CachedClass.java
@@ -31,7 +31,6 @@ import org.codehaus.groovy.util.FastArray;
 import org.codehaus.groovy.util.LazyReference;
 import org.codehaus.groovy.util.ReferenceBundle;
 
-import java.security.PrivilegedAction;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
@@ -42,6 +41,9 @@ import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Set;
 
+import static java.lang.reflect.Modifier.isProtected;
+import static java.lang.reflect.Modifier.isPublic;
+
 public class CachedClass {
 
     public static final CachedClass[] EMPTY_ARRAY = new CachedClass[0];
@@ -53,10 +55,9 @@ public class CachedClass {
 
         @Override
         public CachedField[] initValue() {
-            PrivilegedAction<CachedField[]> action = () -> Arrays.stream(getTheClass().getDeclaredFields())
+            return doPrivileged(() -> Arrays.stream(getTheClass().getDeclaredFields())
                 .filter(f -> ReflectionUtils.checkCanSetAccessible(f, CachedClass.class))
-                .map(CachedField::new).toArray(CachedField[]::new);
-            return doPrivileged(action);
+                .map(CachedField::new).toArray(CachedField[]::new));
         }
     };
 
@@ -65,12 +66,11 @@ public class CachedClass {
 
         @Override
         public CachedConstructor[] initValue() {
-            PrivilegedAction<CachedConstructor[]> action = () -> Arrays.stream(getTheClass().getDeclaredConstructors())
+            return doPrivileged(() -> Arrays.stream(getTheClass().getDeclaredConstructors())
                 .filter(c -> !c.isSynthetic()) // GROOVY-9245: exclude inner class ctors
-                .filter(c -> ReflectionUtils.checkCanSetAccessible(c, CachedClass.class))
+                .filter(c -> ReflectionUtils.checkCanSetAccessible(c, CachedClass.class) || (isProtected(c.getModifiers()) && isPublic(c.getDeclaringClass().getModifiers())))
                 .map(c -> new CachedConstructor(CachedClass.this, c))
-                .toArray(CachedConstructor[]::new);
-            return doPrivileged(action);
+                .toArray(CachedConstructor[]::new));
         }
     };
 
@@ -79,18 +79,17 @@ public class CachedClass {
 
         @Override
         public CachedMethod[] initValue() {
-            PrivilegedAction<CachedMethod[]> action = () -> {
+            CachedMethod[] declaredMethods = doPrivileged(() -> {
                 try {
                     return Arrays.stream(getTheClass().getDeclaredMethods())
                         .filter(m -> m.getName().indexOf('+') < 0) // no synthetic JDK 5+ methods
-                        .filter(m -> ReflectionUtils.checkCanSetAccessible(m, CachedClass.class))
+                        .filter(m -> ReflectionUtils.checkCanSetAccessible(m, CachedClass.class) || (isProtected(m.getModifiers()) && isPublic(m.getDeclaringClass().getModifiers())))
                         .map(m -> new CachedMethod(CachedClass.this, m))
                         .toArray(CachedMethod[]::new);
                 } catch (LinkageError e) {
                     return CachedMethod.EMPTY_ARRAY;
                 }
-            };
-            CachedMethod[] declaredMethods = doPrivileged(action);
+            });
 
             List<CachedMethod> methods = new ArrayList<>(declaredMethods.length);
             List<CachedMethod> mopMethods = new ArrayList<>(declaredMethods.length);
@@ -133,8 +132,8 @@ public class CachedClass {
         }
     };
 
-    @SuppressWarnings("removal") // TODO a future Groovy version should perform the action not as a privileged action
-    private static <T> T doPrivileged(PrivilegedAction<T> action) {
+    @SuppressWarnings("removal") // TODO: a future Groovy version should perform the action not as a privileged action
+    private static <T> T doPrivileged(java.security.PrivilegedAction<T> action) {
         return java.security.AccessController.doPrivileged(action);
     }
 
@@ -143,7 +142,7 @@ public class CachedClass {
 
         @Override
         public CallSiteClassLoader initValue() {
-            return doPrivileged((PrivilegedAction<CallSiteClassLoader>) () -> new CallSiteClassLoader(CachedClass.this.cachedClass));
+            return doPrivileged(() -> new CallSiteClassLoader(CachedClass.this.cachedClass));
         }
     };
 
diff --git a/src/main/java/org/codehaus/groovy/vmplugin/v8/Selector.java b/src/main/java/org/codehaus/groovy/vmplugin/v8/Selector.java
index c6e89ba33f..f1a35520f9 100644
--- a/src/main/java/org/codehaus/groovy/vmplugin/v8/Selector.java
+++ b/src/main/java/org/codehaus/groovy/vmplugin/v8/Selector.java
@@ -594,12 +594,12 @@ public abstract class Selector {
                 if (LOG_ENABLED) LOG.info("receiver is a class");
                 if (!mci.hasCustomStaticInvokeMethod()) method = mci.retrieveStaticMethod(name, newArgs);
             } else {
-                String changedName = name;
-                if (receiver instanceof GeneratedClosure && changedName.equals("call")) {
-                    changedName = "doCall";
+                String name = this.name;
+                if (name.equals("call") && receiver instanceof GeneratedClosure) {
+                    name = "doCall";
                 }
                 if (!mci.hasCustomInvokeMethod())
-                    method = mci.getMethodWithCaching(selectionBase, changedName, newArgs, false);
+                    method = mci.getMethodWithCaching(selectionBase, name, newArgs, false);
             }
             if (LOG_ENABLED) LOG.info("retrieved method from meta class: " + method);
         }
@@ -639,23 +639,19 @@ public abstract class Selector {
             if (metaMethod instanceof CachedMethod) {
                 if (LOG_ENABLED) LOG.info("meta method is CachedMethod instance");
                 CachedMethod cm = (CachedMethod) metaMethod;
-                cm = (CachedMethod) VMPluginFactory.getPlugin().transformMetaMethod(mc, cm, LOOKUP.lookupClass());
+                cm = (CachedMethod) VMPluginFactory.getPlugin().transformMetaMethod(mc, cm, sender);
                 isVargs = cm.isVargsMethod();
-                try {
-                    Method m = cm.getCachedMethod();
-                    handle = correctClassForNameAndUnReflectOtherwise(m);
-                    if (LOG_ENABLED) LOG.info("successfully unreflected method");
-                    if (isStaticCategoryTypeMethod) {
-                        handle = MethodHandles.insertArguments(handle, 0, SINGLE_NULL_ARRAY);
-                        handle = MethodHandles.dropArguments(handle, 0, targetType.parameterType(0));
-                    } else if (!isCategoryTypeMethod && isStatic(m)) {
-                        // we drop the receiver, which might be a Class (invocation on Class)
-                        // or it might be an object (static method invocation on instance)
-                        // Object.class handles both cases at once
-                        handle = MethodHandles.dropArguments(handle, 0, Object.class);
-                    }
-                } catch (IllegalAccessException e) {
-                    throw new GroovyBugError(e);
+                Method m = cm.getCachedMethod();
+                handle = dealWithClassForNameOrObjectCloneOtherwiseUnreflect(m);
+                if (LOG_ENABLED) LOG.info("successfully unreflected method");
+                if (isStaticCategoryTypeMethod) {
+                    handle = MethodHandles.insertArguments(handle, 0, SINGLE_NULL_ARRAY);
+                    handle = MethodHandles.dropArguments(handle, 0, targetType.parameterType(0));
+                } else if (!isCategoryTypeMethod && Modifier.isStatic(m.getModifiers())) {
+                    // we drop the receiver, which might be a Class (invocation on Class)
+                    // or it might be an object (static method invocation on instance)
+                    // Object.class handles both cases at once
+                    handle = MethodHandles.dropArguments(handle, 0, Object.class);
                 }
             } else if (method != null) {
                 if (LOG_ENABLED) LOG.info("meta method is dgm helper");
@@ -674,17 +670,23 @@ public abstract class Selector {
             }
         }
 
-        private MethodHandle correctClassForNameAndUnReflectOtherwise(Method m) throws IllegalAccessException {
-            final String methodName = m.getName();
-            final int parameterCount = m.getParameterTypes().length;
-            final Class<?> declaringClass = m.getDeclaringClass();
-            if (declaringClass == Class.class && parameterCount == 1 && methodName.equals("forName")) {
-                return MethodHandles.insertArguments(CLASS_FOR_NAME, 1, true, sender.getClassLoader());
-            } else if (declaringClass == Object.class && parameterCount == 0 && methodName.equals("clone") && null != args && 1 == args.length) {
+        private MethodHandle dealWithClassForNameOrObjectCloneOtherwiseUnreflect(final Method m) {
+            int parameterCount = m.getParameterCount();
+            if (parameterCount == 1 && m.getName().equals("forName") && m.getDeclaringClass() == Class.class) {
+                return MethodHandles.insertArguments(CLASS_FOR_NAME, 1, Boolean.TRUE, sender.getClassLoader());
+            } else if (parameterCount == 0 && m.getName().equals("clone") && args != null && args.length == 1 && m.getDeclaringClass() == Object.class) {
                 return ObjectUtil.getCloneObjectMethodHandle();
             }
 
-            return LOOKUP.unreflect(m); // throws IllegalAccessException if IndyInterface cannot invoke method
+            try {
+                MethodHandles.Lookup lookup = LOOKUP;
+                if (!Modifier.isPublic(m.getModifiers())) { // GROOVY-10070, et al.
+                    lookup = ((Java8)VMPluginFactory.getPlugin()).newLookup(sender);
+                }
+                return lookup.unreflect(m); // throws if sender cannot invoke method
+            } catch (IllegalAccessException e) {
+                throw new GroovyBugError(e);
+            }
         }
 
         /**
@@ -1063,14 +1065,6 @@ public abstract class Selector {
         return receiver;
     }
 
-    /**
-     * Returns if a method is static
-     */
-    private static boolean isStatic(Method m) {
-        int mods = m.getModifiers();
-        return (mods & Modifier.STATIC) != 0;
-    }
-
     /**
      * Returns the MetaClassImpl if the given MetaClass is one of
      * MetaClassImpl, AdaptingMetaClass or ClosureMetaClass. If
diff --git a/subprojects/groovy-swing/src/test/groovy/groovy/swing/beans/BindableSwingTest.groovy b/subprojects/groovy-swing/src/test/groovy/groovy/swing/beans/BindableSwingTest.groovy
index 876f0d7cbb..202da85494 100644
--- a/subprojects/groovy-swing/src/test/groovy/groovy/swing/beans/BindableSwingTest.groovy
+++ b/subprojects/groovy-swing/src/test/groovy/groovy/swing/beans/BindableSwingTest.groovy
@@ -18,38 +18,28 @@
  */
 package groovy.swing.beans
 
-import groovy.swing.GroovySwingTestCase
+import org.junit.Test
 
-class BindableSwingTest extends GroovySwingTestCase {
-    void testExtendsComponent() {
-        testInEDT {
-            GroovyShell shell = new GroovyShell()
-            shell.evaluate("""
-                import groovy.beans.Bindable
-                import javax.swing.JPanel
-
-                class BindableTestBean6 extends JPanel {
-                    @Bindable String testField
+import static groovy.swing.GroovySwingTestCase.testInEDT
 
-                    /*
-                    // if the following stub added, the illegal access warnings can be fixed
-                    // java.awt.Component.firePropertyChange(java.lang.String,java.lang.Object,java.lang.Object)
-                    // should we add this kind of stubs automatically?
-                    void firePropertyChange(String propertyName,
-                                      Object oldValue, Object newValue) {
+final class BindableSwingTest {
 
-                        super.firePropertyChange(propertyName, oldValue, newValue)                  
-                    }
-                    */
+    // GROOVY-8339, GROOVY-10070
+    @Test
+    void testExtendsComponent() {
+        testInEDT {
+            new GroovyShell().evaluate '''
+                class BindableTestBean extends javax.swing.JPanel {
+                    @groovy.beans.Bindable String testValue
                 }
 
-                sb = new BindableTestBean6()
-                sb.testField = "bar"
                 changed = false
-                sb.propertyChange = {changed = true}
-                sb.testField = "foo"
+
+                def bean = new BindableTestBean(testValue: 'foo')
+                bean.propertyChange = {changed = true}
+                bean.testValue = 'bar'
                 assert changed
-            """)
+            '''
         }
     }
-}
\ No newline at end of file
+}
diff --git a/subprojects/groovy-swing/src/test/groovy/groovy/swing/beans/VetoableSwingTest.groovy b/subprojects/groovy-swing/src/test/groovy/groovy/swing/beans/VetoableSwingTest.groovy
index 73378be1c8..d12c82311b 100644
--- a/subprojects/groovy-swing/src/test/groovy/groovy/swing/beans/VetoableSwingTest.groovy
+++ b/subprojects/groovy-swing/src/test/groovy/groovy/swing/beans/VetoableSwingTest.groovy
@@ -18,27 +18,28 @@
  */
 package groovy.swing.beans
 
-import groovy.swing.GroovySwingTestCase
+import org.junit.Test
 
-class VetoableSwingTest extends GroovySwingTestCase {
+import static groovy.swing.GroovySwingTestCase.testInEDT
+
+final class VetoableSwingTest {
+
+    // GROOVY-8339, GROOVY-10070
+    @Test
     void testExtendsComponent() {
         testInEDT {
-            GroovyShell shell = new GroovyShell()
-            shell.evaluate("""
-                import groovy.beans.Vetoable
-                import javax.swing.JPanel
-
-                class VetoableTestBean7 extends JPanel {
-                    @Vetoable String testField
+            new GroovyShell().evaluate '''
+                class VetoableTestBean extends javax.swing.JPanel {
+                    @groovy.beans.Vetoable String testValue
                 }
 
-                sb = new VetoableTestBean7()
-                sb.testField = "bar"
                 changed = false
-                sb.vetoableChange = {changed = true}
-                sb.testField = "foo"
+
+                def bean = new VetoableTestBean(testValue: 'foo')
+                bean.vetoableChange = {changed = true}
+                bean.testValue = 'bar'
                 assert changed
-            """)
+            '''
         }
     }
-}
\ No newline at end of file
+}
