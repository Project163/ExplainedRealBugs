diff --git a/subprojects/groovy-json/src/main/java/groovy/json/internal/ReaderCharacterSource.java b/subprojects/groovy-json/src/main/java/groovy/json/internal/ReaderCharacterSource.java
index ac66af05cd..bee97b8481 100644
--- a/subprojects/groovy-json/src/main/java/groovy/json/internal/ReaderCharacterSource.java
+++ b/subprojects/groovy-json/src/main/java/groovy/json/internal/ReaderCharacterSource.java
@@ -160,81 +160,57 @@ public class ReaderCharacterSource implements CharacterSource {
         try {
             ensureBuffer();
 
-            int idx = index;
-            char[] _chars = readBuf;
-
-            int ch = this.ch;
-            if (ch == '"') {
-
-            } else if (idx < length - 1) {
-                ch = _chars[idx];
-
-                if (ch == '"') {
-                    idx++;
-                }
-            }
-
-            if (idx < length) {
-                ch = _chars[idx];
-            }
-
-            if (ch == '"') {
-                index = idx;
+            if (readBuf[index] == '"') {
                 index++;
                 return EMPTY_CHARS;
             }
-            int start = idx;
 
+            int start = index;
             foundEscape = false;
 
+            char[] results = null;
             boolean foundEnd = false;
-            char[] results;
-
-            for (; idx < length; idx++) {
-                ch = _chars[idx];
-                if (ch == match || ch == esc) {
-                    if (ch == match) {
+            boolean wasEscaped = false;
+            while (!foundEnd) {
+                for (; index < length; index++) {
+                    ch = readBuf[index];
+                    if (wasEscaped) {
+                        wasEscaped = false;
+                    } else if (ch == match) {
                         foundEnd = true;
-
                         break;
                     } else if (ch == esc) {
                         foundEscape = true;
-                        /** if we are dealing with an escape then see if the escaped char is a match
-                         *  if so, skip it.
-                         */
-                        if (idx + 1 < length) {
-                            idx++;
-                        }
+                        wasEscaped = true;
                     }
                 }
-            }
 
-            if (idx == 0) {
-                results = EMPTY_CHARS;
-            } else {
-                results = ArrayUtils.copyRange(_chars, start, idx);
+                if (results != null) {
+                    results = Chr.add(results, ArrayUtils.copyRange(readBuf, start, index));
+                }
+                else {
+                    results = ArrayUtils.copyRange(readBuf, start, index);
+                }
+
+                ensureBuffer();
+
+                // Reset start if new buffer
+                if (index == 0) {
+                    start = 0;
+                }
+
+                // Exit early if we run out of data
+                if (done) {
+                    break;
+                }
             }
-            index = idx;
 
-            if (foundEnd) {
+            // done will only be true if we ran out of data without seeing the match character
+            if (done) {
+                return Exceptions.die(char[].class, "Unable to find close char " + (char)match + ": " + new String(results));
+            } else {
                 index++;
-                if (index < length) {
-                    ch = _chars[index];
-                    this.ch = ch;
-                }
                 return results;
-            } else {
-                if (index >= length && !done) {
-                    ensureBuffer();
-                    boolean hasAlreadyFoundEscape = foundEscape;
-                    char results2[] = findNextChar(match, esc);
-                    if (hasAlreadyFoundEscape) {
-                        foundEscape = true; //restore foundEscapeState
-                    }
-                    return Chr.add(results, results2);
-                } else {
-                    return Exceptions.die(char[].class, "Unable to find close char " + (char) match + " " + new String(results));
-                }
             }
         } catch (Exception ex) {
             String str = CharScanner.errorDetails("findNextChar issue", readBuf, index, ch);
diff --git a/subprojects/groovy-json/src/test/groovy/groovy/json/internal/ReaderCharacterSourceTest.groovy b/subprojects/groovy-json/src/test/groovy/groovy/json/internal/ReaderCharacterSourceTest.groovy
index e8df954bcb..6f79081aaa 100644
--- a/subprojects/groovy-json/src/test/groovy/groovy/json/internal/ReaderCharacterSourceTest.groovy
+++ b/subprojects/groovy-json/src/test/groovy/groovy/json/internal/ReaderCharacterSourceTest.groovy
@@ -16,25 +16,62 @@
  *  specific language governing permissions and limitations
  *  under the License.
  */
-package groovy.json.internal;
+package groovy.json.internal
+
+import groovy.json.internal.Exceptions.JsonInternalException;
 
 class ReaderCharacterSourceTest extends GroovyTestCase {
 
-    void testFindNextCharWithRecursionHadEscape() {
-        int[] control = '"\\'.toCharArray() as int[]
+    public static final int QUOTE_CHAR = (int)'"'.charAt(0)
+    public static final int BACKSLASH_CHAR = (int)'\\'.charAt(0)
+
+    void testFindNextChar() {
+        def testCases = [
+                [ input: '""', expected: '' ],
+                [ input: '"word"', expected: 'word' ],
+                [ input: '"\\u0026value"', expected: '\\u0026value' ],
+                [ input: '"value\\u0026"', expected: 'value\\u0026' ],
+                [ input: '"double\\"quote"', expected: 'double\\"quote' ],
+                [ input: '"\\"\\"\\"\\""', expected: '\\"\\"\\"\\"' ],
+                [ input: '"\\\\\\\\\\\\"', expected: '\\\\\\\\\\\\' ]
+        ]
+
+        testCases.each {
+            boolean containsEscape = it.input.contains('\\')
+            // Test all possible buffer sizes
+            for (int i = 1; i < it.input.length() + 1; i++) {
+                ReaderCharacterSource rcs = new ReaderCharacterSource(new StringReader(it.input), i)
+                rcs.nextChar() // Read the first double quote as if JSON parsing
 
-        // create a ReaderCharacterSource with a very small buffer, findNextChar must be invoked recursive
+                String result = new String(rcs.findNextChar(QUOTE_CHAR, BACKSLASH_CHAR))
 
-        // use a string where escape-character is in last invocation
-        ReaderCharacterSource cs = new ReaderCharacterSource(new StringReader('"value\\u0026"'), 6)
-        cs.findNextChar(control[0], control[1])
+                assertEquals("Buffer size ${i}", it.expected, result)
+                assertEquals("Expected escape character in ${it.input}, buffer size ${i}", containsEscape, rcs.hadEscape())
+            }
+        }
+    }
 
-        assert cs.hadEscape()
+    void testFindNextCharException() {
+        shouldFail(JsonInternalException) {
+            ReaderCharacterSource rcs = new ReaderCharacterSource(new StringReader('"missing end quote'))
+            rcs.nextChar() // Read the first double quote as if JSON parsing
+            rcs.findNextChar(QUOTE_CHAR, BACKSLASH_CHAR)
+        }
+    }
 
-        // use a string where escape-character is in first invocation
-        cs = new ReaderCharacterSource(new StringReader('"\\u0026value"'), 6)
-        cs.findNextChar(control[0], control[1])
+    void testFindNextCharExceptionWithEscapedEnding() {
+        shouldFail(JsonInternalException) {
+            ReaderCharacterSource rcs = new ReaderCharacterSource(new StringReader('"missing end quote ending with escape \\'))
+            rcs.nextChar() // Read the first double quote as if JSON parsing
+            rcs.findNextChar(QUOTE_CHAR, BACKSLASH_CHAR)
+        }
+    }
 
-        assert cs.hadEscape()
+    void testFindNextCharExceptionWithEscapedQuote() {
+        shouldFail(JsonInternalException) {
+            ReaderCharacterSource rcs = new ReaderCharacterSource(new StringReader('"missing end quote with escaped quote \\"'))
+            rcs.nextChar() // Read the first double quote as if JSON parsing
+            rcs.findNextChar(QUOTE_CHAR, BACKSLASH_CHAR)
+        }
     }
 }
