diff --git a/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java b/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java
index eeaedf8f63..c04918a216 100644
--- a/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java
+++ b/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java
@@ -431,19 +431,26 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
             modifiers = modifiers(node, annotations, modifiers);
             node = node.getNextSibling();
         }
-        assertNodeType(TYPE, node);
-        String type = typeName(node);
 
-        node = node.getNextSibling();
+        String type = null;
+        if (isType(TYPE, node)) {
+            type = typeName(node);
+            node = node.getNextSibling();
+        }
 
         String name = identifier(node);
-
-        Expression defaultValue = null;
         node = node.getNextSibling();
+        VariableExpression leftExpression = new VariableExpression(name, type);
+        configureAST(leftExpression, paramNode);
+
+        Expression rightExpression = ConstantExpression.NULL;
         if (node != null) {
-            defaultValue = expression(node);
+            assertNodeType(ASSIGN, node);
+
+            rightExpression = expression(node.getFirstChild());
         }
-        Parameter parameter = new Parameter(type, name, defaultValue);
+
+        Parameter parameter = new Parameter(type, name, rightExpression);
         // TODO
         //configureAST(parameter,paramNode);
         //parameter.addAnnotations(annotations);
@@ -1414,11 +1421,41 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
 
         AST leftNode = node.getFirstChild();
         Expression leftExpression = expression(leftNode);
+
         AST rightNode = leftNode.getNextSibling();
         if (rightNode == null) {
-            //rightNode = leftNode.getFirstChild();
             return leftExpression;
         }
+
+        if (Types.ofType(type, Types.ASSIGNMENT_OPERATOR)) {
+            if (leftExpression instanceof VariableExpression || leftExpression instanceof PropertyExpression
+                                                             || leftExpression instanceof FieldExpression
+                                                             || leftExpression instanceof DeclarationExpression) {
+                // Do nothing.
+            }
+            else if (leftExpression instanceof ConstantExpression) {
+                throw new ASTRuntimeException(node, "\n[" + ((ConstantExpression) leftExpression).getValue() + "] is a constant expression, but it should be a variable expression");
+            }
+            else if (leftExpression instanceof BinaryExpression) {
+                Expression leftexp = ((BinaryExpression) leftExpression).getLeftExpression();
+                int lefttype = ((BinaryExpression) leftExpression).getOperation().getType();
+                if (!Types.ofType(lefttype, Types.ASSIGNMENT_OPERATOR) && lefttype != Types.LEFT_SQUARE_BRACKET) {
+                    throw new ASTRuntimeException(node, "\n" + ((BinaryExpression) leftExpression).getText() + " is a binary expression, but it should be a variable expression");
+                }
+            }
+            else if (leftExpression instanceof GStringExpression) {
+                throw new ASTRuntimeException(node, "\n\"" + ((GStringExpression) leftExpression).getText() + "\" is a GString expression, but it should be a variable expression");
+            }
+            else if (leftExpression instanceof MethodCallExpression) {
+                throw new ASTRuntimeException(node, "\n\"" + ((MethodCallExpression) leftExpression).getText() + "\" is a method call expression, but it should be a variable expression");
+            }
+            else if (leftExpression instanceof MapExpression) {
+                throw new ASTRuntimeException(node, "\n'" + ((MapExpression) leftExpression).getText() + "' is a map expression, but it should be a variable expression");
+            }
+            else {
+                throw new ASTRuntimeException(node, "\n" + leftExpression.getClass() + ", with its value '" + leftExpression.getText() + "', is a bad expression as the LSH of an assignment operator");
+            }
+        }
         /*if (rightNode == null) {
             throw new NullPointerException("No rightNode associated with binary expression");
         }*/
diff --git a/src/main/org/codehaus/groovy/ast/expr/GStringExpression.java b/src/main/org/codehaus/groovy/ast/expr/GStringExpression.java
index d0ed787f1c..3ad6a41834 100644
--- a/src/main/org/codehaus/groovy/ast/expr/GStringExpression.java
+++ b/src/main/org/codehaus/groovy/ast/expr/GStringExpression.java
@@ -98,6 +98,10 @@ public class GStringExpression extends Expression {
         return super.toString() + "[strings: " + strings + " values: " + values + "]";
     }
 
+    public String getText() {
+        return verbatimText;
+    }
+
     public List getStrings() {
         return strings;
     }
diff --git a/src/main/org/codehaus/groovy/ast/expr/MapExpression.java b/src/main/org/codehaus/groovy/ast/expr/MapExpression.java
index 26929c6232..0cbb59b6ee 100644
--- a/src/main/org/codehaus/groovy/ast/expr/MapExpression.java
+++ b/src/main/org/codehaus/groovy/ast/expr/MapExpression.java
@@ -93,6 +93,27 @@ public class MapExpression extends Expression {
         return super.toString() + mapEntryExpressions;
     }
 
+    public String getText() {
+        StringBuffer sb = new StringBuffer(32);
+        sb.append("[");
+        int size = mapEntryExpressions.size();
+        MapEntryExpression mapEntryExpression = null;
+        if (size > 0) {
+            mapEntryExpression = (MapEntryExpression) mapEntryExpressions.get(0);
+            sb.append(mapEntryExpression.getKeyExpression().getText() + ":" + mapEntryExpression.getValueExpression().getText());
+            for (int i = 1; i < size; i++) {
+                mapEntryExpression = (MapEntryExpression) mapEntryExpressions.get(i);
+                sb.append(", " + mapEntryExpression.getKeyExpression().getText() + ":" + mapEntryExpression.getValueExpression().getText());
+                if (sb.length() > 120 && i < size - 1) {
+                    sb.append(", ... ");
+                    break;
+                }
+            }
+        }
+        sb.append("]");
+        return sb.toString();
+    }
+
     public void addMapEntryExpression(Expression keyExpression, Expression valueExpression) {
         addMapEntryExpression(new MapEntryExpression(keyExpression, valueExpression));
     }
