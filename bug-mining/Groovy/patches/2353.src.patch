diff --git a/src/main/org/codehaus/groovy/ast/tools/GenericsUtils.java b/src/main/org/codehaus/groovy/ast/tools/GenericsUtils.java
index 6ec55a9499..a56886527c 100644
--- a/src/main/org/codehaus/groovy/ast/tools/GenericsUtils.java
+++ b/src/main/org/codehaus/groovy/ast/tools/GenericsUtils.java
@@ -116,6 +116,12 @@ public class GenericsUtils {
      */
     public static void extractPlaceholders(ClassNode node, Map<String, GenericsType> map) {
         if (node == null) return;
+
+        if (node.isArray()) {
+            extractPlaceholders(node.getComponentType(), map);
+            return;
+        }
+
         if (!node.isUsingGenerics() || !node.isRedirectNode()) return;
         GenericsType[] parameterized = node.getGenericsTypes();
         if (parameterized == null || parameterized.length == 0) return;
@@ -128,9 +134,6 @@ public class GenericsUtils {
                 if (!map.containsKey(name)) map.put(name, parameterized[i]);
             }
         }
-        if (node.isArray()) {
-            extractPlaceholders(node.getComponentType(), map);
-        }
     }
 
     /**
diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
index 9e49da3884..06d6fe090b 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
@@ -16,7 +16,6 @@
 
 package org.codehaus.groovy.transform.stc;
 
-import groovy.lang.GroovyClassLoader;
 import org.codehaus.groovy.GroovyBugError;
 import org.codehaus.groovy.ast.*;
 import org.codehaus.groovy.ast.expr.*;
@@ -187,8 +186,8 @@ public abstract class StaticTypeCheckingSupport {
         }
         if (clazz.isArray()) {
             ClassNode componentClass = clazz.getComponentType();
-            if (!componentClass.equals(OBJECT_TYPE)) {
-                if (componentClass.isInterface() || componentClass.getSuperClass()==null) {
+            if (!componentClass.equals(OBJECT_TYPE) && !ClassHelper.isPrimitiveType(componentClass)) {
+                if (componentClass.isInterface()) {
                     findDGMMethodsForClassNode(loader, OBJECT_TYPE.makeArray(), name, accumulator);
                 } else {
                     findDGMMethodsForClassNode(loader, componentClass.getSuperClass().makeArray(), name, accumulator);
diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 31d9fcb791..7c7520b033 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -2335,6 +2335,30 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         }
     }
 
+    /**
+     * add various getAt and setAt methods for primtive arrays
+     * @param receiver the receiver class
+     * @param name  the name of the method
+     * @param args the argument classes
+     * @return a list containing the single match or null
+     */
+    private void addArrayMethods(List<MethodNode> methods, ClassNode receiver, String name, ClassNode[] args) {
+        if (args.length!=1) return;
+        if (!receiver.isArray()) return;
+        if (!isIntCategory(args[0])) return;
+        if ("getAt".equals(name)) {
+            MethodNode node = new MethodNode(name, Opcodes.ACC_PUBLIC, receiver.getComponentType(), new Parameter[]{new Parameter(args[0],"arg")}, null, null);
+            node.setDeclaringClass(receiver.redirect());
+            methods.add(node);
+        } else if ("setAt".equals(name)) {
+            MethodNode node = new MethodNode(name, Opcodes.ACC_PUBLIC, VOID_TYPE, new Parameter[]{new Parameter(args[0],"arg")}, null, null);
+            node.setDeclaringClass(receiver.redirect());
+            methods.add(node);
+        } else {
+            return;
+        }
+    }
+
     /**
      * In the case of a <em>Object.with { ... }</em> call, this method is supposed to retrieve
      * the inferred closure return type.
@@ -3005,6 +3029,9 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                     methods.addAll(findMethodsWithGenerated(parent,name));
                 }
             }
+            if (methods.isEmpty()) {
+                addArrayMethods(methods, receiver, name, args);
+            }
             if (methods.isEmpty() && (args == null || args.length == 0)) {
                 // check if it's a property
                 String pname = extractPropertyNameFromMethodName("get", name);
@@ -3033,7 +3060,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             } else if (methods.isEmpty() && args != null && args.length == 1) {
                 // maybe we are looking for a setter ?
                 String pname = extractPropertyNameFromMethodName("set", name);
-                if (name!=null) {
+                if (pname!=null) {
                     ClassNode curNode = receiver;
                     PropertyNode property = null;
                     while (property == null && curNode != null) {
@@ -3331,7 +3358,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             } else {
                 argList.addExpression(arguments);
             }
-            return inferReturnTypeGenerics(dc, dgmMethod, argList);
+            return inferReturnTypeGenerics(receiver, dgmMethod, argList);
         }
         if (!isUsingGenericsOrIsArrayUsingGenerics(returnType)) return returnType;
         if (getGenericsWithoutArray(returnType)==null) return returnType;
@@ -3538,7 +3565,18 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 }
             }
 
-            if (nextNode==null) nextNode = current.getUnresolvedSuperClass();
+            if (nextNode==null) {
+                nextNode = current.getUnresolvedSuperClass();
+                if (current.isArray()) {
+                    nextNode = current.getComponentType();
+                    nextNode = nextNode.getUnresolvedSuperClass();
+                    if (nextNode!=null) {
+                        nextNode = nextNode.makeArray();
+                    } else {
+                        nextNode = OBJECT_TYPE;
+                    }
+                }
+            }
             current = nextNode;
             if (current==null) {
                 String descriptor = "<>";
diff --git a/src/test/groovy/transform/stc/ArraysAndCollectionsSTCTest.groovy b/src/test/groovy/transform/stc/ArraysAndCollectionsSTCTest.groovy
index 553bea47e3..f3cb338862 100644
--- a/src/test/groovy/transform/stc/ArraysAndCollectionsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/ArraysAndCollectionsSTCTest.groovy
@@ -524,5 +524,15 @@ class ArraysAndCollectionsSTCTest extends StaticTypeCheckingTestCase {
             assert res[0].contains('def')
         """
     }
+    
+    // GROOVY-6241
+    void testAsImmutable() {
+        assertScript """
+            List<Integer> list = [1, 2, 3]
+            List<Integer> immutableList = [1, 2, 3].asImmutable()
+            Map<String, Integer> map = [foo: 123, bar: 456]
+            Map<String, Integer> immutableMap = [foo: 123, bar: 456].asImmutable()
+        """
+    }
 }
 
