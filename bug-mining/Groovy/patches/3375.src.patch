diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
index bc413a0054..6da4abc1dd 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
@@ -20,6 +20,7 @@
 package org.codehaus.groovy.transform.stc;
 
 import org.codehaus.groovy.GroovyBugError;
+import org.codehaus.groovy.ast.ClassHelper;
 import org.codehaus.groovy.ast.ClassNode;
 import org.codehaus.groovy.ast.GenericsType;
 import org.codehaus.groovy.ast.MethodNode;
@@ -72,6 +73,7 @@ import java.util.UUID;
 import java.util.WeakHashMap;
 import java.util.regex.Matcher;
 
+import static java.lang.Math.min;
 import static org.codehaus.groovy.ast.ClassHelper.BigDecimal_TYPE;
 import static org.codehaus.groovy.ast.ClassHelper.BigInteger_TYPE;
 import static org.codehaus.groovy.ast.ClassHelper.Boolean_TYPE;
@@ -441,7 +443,7 @@ public abstract class StaticTypeCheckingSupport {
         ClassNode ptype = lastParamType.getComponentType();
         ClassNode arg = args[args.length - 1];
         if (isNumberType(ptype) && isNumberType(arg) && !ptype.equals(arg)) return -1;
-        return isAssignableTo(arg, ptype) ? Math.min(getDistance(arg, lastParamType), getDistance(arg, ptype)) : -1;
+        return isAssignableTo(arg, ptype) ? min(getDistance(arg, lastParamType), getDistance(arg, ptype)) : -1;
     }
 
     /**
@@ -1097,7 +1099,8 @@ public abstract class StaticTypeCheckingSupport {
                 Person p = foo(b)
              */
 
-            Parameter[] params = makeRawTypes(safeNode.getParameters());
+            Map<GenericsType, GenericsType> declaringAndActualGenericsTypeMap = makeDeclaringAndActualGenericsTypeMap(declaringClassForDistance, actualReceiverForDistance);
+            Parameter[] params = makeRawTypes(safeNode.getParameters(), declaringAndActualGenericsTypeMap);
             int dist = measureParametersAndArgumentsDistance(params, safeArgs);
             if (dist >= 0) {
                 dist += getClassDistance(declaringClassForDistance, actualReceiverForDistance);
@@ -1187,11 +1190,95 @@ public abstract class StaticTypeCheckingSupport {
         return isExtensionMethodNode ? 0 : 1;
     }
 
-    private static Parameter[] makeRawTypes(Parameter[] params) {
+    private static ClassNode findActualTypeByGenericsPlaceholderName(String placeholderName, Map<GenericsType, GenericsType> genericsPlaceholderAndTypeMap) {
+        for (Map.Entry<GenericsType, GenericsType> entry : genericsPlaceholderAndTypeMap.entrySet()) {
+            GenericsType declaringGenericsType = entry.getKey();
+
+            if (placeholderName.equals(declaringGenericsType.getName())) {
+                return entry.getValue().getType();
+            }
+        }
+
+        return null;
+    }
+
+    /**
+     * map declaring generics type to actual generics type, e.g. GROOVY-7204:
+     * declaring generics types:      T,      S extends Serializable
+     * actual generics types   : String,      Long
+     *
+     * the result map is [
+     *  T: String,
+     *  S: Long
+     * ]
+     *
+     * The resolved types can not help us to choose methods correctly if the argument is a string:  T: Object, S: Serializable
+     * so we need actual types:  T: String, S: Long
+     */
+    private static Map<GenericsType, GenericsType> makeDeclaringAndActualGenericsTypeMap(ClassNode declaringClassForDistance, ClassNode actualReceiverForDistance) {
+        GenericsType[] declaringGenericsTypes = declaringClassForDistance.getGenericsTypes();
+        GenericsType[] actualGenericsTypes = actualReceiverForDistance.getGenericsTypes();
+
+        if (null == declaringGenericsTypes) {
+            return Collections.emptyMap();
+        }
+
+        if (null == actualGenericsTypes) {
+            List<ClassNode> superClassAndInterfaceList = getAllSuperClassesAndInterfaces(actualReceiverForDistance);
+
+            for (ClassNode cn : superClassAndInterfaceList) {
+                if (cn.isDerivedFrom(declaringClassForDistance)) {
+                    actualGenericsTypes = cn.getGenericsTypes();
+
+                    if (null != actualGenericsTypes && declaringGenericsTypes.length == actualGenericsTypes.length) {
+                        break;
+                    }
+                }
+            }
+        }
+
+        if (null == actualGenericsTypes || declaringGenericsTypes.length != actualGenericsTypes.length) {
+            return Collections.emptyMap();
+        }
+
+        Map<GenericsType, GenericsType> result = new HashMap<>();
+        for (int i = 0, n = declaringGenericsTypes.length; i < n; i++) {
+            result.put(declaringGenericsTypes[i], actualGenericsTypes[i]);
+        }
+
+        return result;
+    }
+
+    private static List<ClassNode> getAllSuperClassesAndInterfaces(ClassNode actualReceiverForDistance) {
+        List<ClassNode> superClassAndInterfaceList = new LinkedList<>();
+        List<ClassNode> allSuperClassNodeList = getAllUnresolvedSuperClasses(actualReceiverForDistance);
+        superClassAndInterfaceList.addAll(allSuperClassNodeList);
+        superClassAndInterfaceList.addAll(actualReceiverForDistance.getAllInterfaces());
+
+        for (ClassNode superClassNode : allSuperClassNodeList) {
+            superClassAndInterfaceList.addAll(superClassNode.getAllInterfaces());
+        }
+
+        return superClassAndInterfaceList;
+    }
+
+    private static List<ClassNode> getAllUnresolvedSuperClasses(ClassNode actualReceiverForDistance) {
+        List<ClassNode> superClassNodeList = new LinkedList<>();
+
+        for (ClassNode cn = actualReceiverForDistance.getUnresolvedSuperClass(); null != cn && ClassHelper.OBJECT_TYPE != cn; cn = cn.getUnresolvedSuperClass()) {
+            superClassNodeList.add(cn);
+        }
+
+        return superClassNodeList;
+    }
+
+    private static Parameter[] makeRawTypes(Parameter[] params, Map<GenericsType, GenericsType> genericsPlaceholderAndTypeMap) {
         Parameter[] newParam = new Parameter[params.length];
         for (int i = 0; i < params.length; i++) {
             Parameter oldP = params[i];
-            Parameter newP = new Parameter(makeRawType(oldP.getType()), oldP.getName());
+
+            ClassNode actualType = findActualTypeByGenericsPlaceholderName(oldP.getType().getUnresolvedName(), genericsPlaceholderAndTypeMap);
+            Parameter newP = new Parameter(makeRawType(null == actualType ? oldP.getType() : actualType), oldP.getName());
             newParam[i] = newP;
         }
         return newParam;
@@ -1522,7 +1609,7 @@ public abstract class StaticTypeCheckingSupport {
         Set<String> fixedGenericsPlaceHolders = extractResolvedPlaceHolders(resolvedMethodGenerics);
 
         for (int i = 0; i < arguments.length; i++) {
-            int pindex = Math.min(i, parameters.length - 1);
+            int pindex = min(i, parameters.length - 1);
             ClassNode wrappedArgument = arguments[i];
             ClassNode type = parameters[pindex].getOriginType();
 
diff --git a/src/spec/test/typing/TypeCheckingTest.groovy b/src/spec/test/typing/TypeCheckingTest.groovy
index f32ca3f6a3..fc87413438 100644
--- a/src/spec/test/typing/TypeCheckingTest.groovy
+++ b/src/spec/test/typing/TypeCheckingTest.groovy
@@ -685,7 +685,7 @@ import static org.codehaus.groovy.ast.tools.WideningCategories.lowestUpperBound
             }
             // end::flowtyping_typeconstraints_failure[]
             flowTypingWithExplicitType()
-        ''', 'Cannot call java.util.List <java.lang.String>#add(java.lang.String) with arguments [int]'
+        ''', '[Static type checking] - Cannot find matching method java.util.List#add(int)'
 
         assertScript '''
             // tag::flowtyping_typeconstraints_fixed[]
diff --git a/src/test/groovy/bugs/Groovy7204Bug.groovy b/src/test/groovy/bugs/Groovy7204Bug.groovy
new file mode 100644
index 0000000000..09375ac772
--- /dev/null
+++ b/src/test/groovy/bugs/Groovy7204Bug.groovy
@@ -0,0 +1,546 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package groovy.bugs
+
+class Groovy7204Bug extends GroovyTestCase {
+    void testTypeChecked1() {
+        assertScript '''
+        import java.io.Serializable;
+        
+        import groovy.transform.CompileStatic;
+        import groovy.transform.TypeChecked;
+        
+        @TypeChecked
+        public class MyClass {
+            static MyRepository factory() {
+                return new MyRepositoryImpl()
+            }
+            
+            static void main(String[] args) {
+                MyRepository r = factory()
+                r.delete('foo')
+            }
+        }
+        
+        @TypeChecked
+        interface CrudRepository<T, S extends Serializable> {
+            void delete(T arg);
+            void delete(S arg);
+        }
+        
+        @TypeChecked
+        interface MyRepository extends CrudRepository<String, Long> {
+        }
+        
+        @TypeChecked
+        class MyRepositoryImpl implements MyRepository {
+            @Override
+            public void delete(String arg) {
+                System.out.println("String");
+                assert true
+            }
+            
+            @Override
+            public void delete(Long arg) {
+                System.out.println("Long");
+                assert false: 'wrong method invoked'
+            }
+        }
+        '''
+    }
+
+    void testTypeChecked2() {
+        assertScript '''
+        import java.io.Serializable;
+        
+        import groovy.transform.CompileStatic;
+        import groovy.transform.TypeChecked;
+        
+        @TypeChecked
+        public class MyClass {
+            static MyRepository factory() {
+                return new MyRepositoryImpl()
+            }
+            
+            static void main(String[] args) {
+                MyRepository r = factory()
+                r.delete('foo')
+            }
+        }
+        
+        @TypeChecked
+        abstract class CrudRepository<T, S extends Serializable> {
+            abstract void delete(T arg);
+            abstract void delete(S arg);
+        }
+        
+        @TypeChecked
+        abstract class MyRepository extends CrudRepository<String, Long> {
+        }
+        
+        @TypeChecked
+        class MyRepositoryImpl extends MyRepository {
+            @Override
+            public void delete(String arg) {
+                System.out.println("String");
+                assert true
+            }
+            
+            @Override
+            public void delete(Long arg) {
+                System.out.println("Long");
+                assert false: 'wrong method invoked'
+            }
+        }
+        '''
+    }
+
+    void testTypeChecked3() {
+        assertScript '''
+        import java.io.Serializable;
+        
+        import groovy.transform.CompileStatic;
+        import groovy.transform.TypeChecked;
+        
+        @TypeChecked
+        public class MyClass {
+            static MyRepository factory() {
+                return new MyRepositoryImpl()
+            }
+            
+            static void main(String[] args) {
+                MyRepository r = factory()
+                r.delete('foo')
+            }
+        }
+        
+        @TypeChecked
+        interface CrudRepository<T, S extends Serializable> {
+            void delete(T arg);
+            void delete(S arg);
+        }
+        
+        @TypeChecked
+        interface MyRepository2 extends CrudRepository<String, Long> {
+        }
+        
+        @TypeChecked
+        interface MyRepository extends MyRepository2 {
+        }
+        
+        @TypeChecked
+        class MyRepositoryImpl implements MyRepository {
+            @Override
+            public void delete(String arg) {
+                System.out.println("String");
+                assert true
+            }
+            
+            @Override
+            public void delete(Long arg) {
+                System.out.println("Long");
+                assert false: 'wrong method invoked'
+            }
+        }
+        '''
+    }
+
+    void testTypeChecked4() {
+        assertScript '''
+        import java.io.Serializable;
+        
+        import groovy.transform.CompileStatic;
+        import groovy.transform.TypeChecked;
+        
+        @TypeChecked
+        public class MyClass {
+            static MyRepository factory() {
+                return new MyRepositoryImpl()
+            }
+            
+            static void main(String[] args) {
+                MyRepository r = factory()
+                r.delete('foo')
+            }
+        }
+        
+        @TypeChecked
+        abstract class CrudRepository<T, S extends Serializable> {
+            abstract void delete(T arg);
+            abstract void delete(S arg);
+        }
+        
+        @TypeChecked
+        abstract class MyRepository2 extends CrudRepository<String, Long> {
+        }
+        
+        @TypeChecked
+        abstract class MyRepository extends MyRepository2 {
+        }
+        
+        @TypeChecked
+        class MyRepositoryImpl extends MyRepository {
+            @Override
+            public void delete(String arg) {
+                System.out.println("String");
+                assert true
+            }
+            
+            @Override
+            public void delete(Long arg) {
+                System.out.println("Long");
+                assert false: 'wrong method invoked'
+            }
+        }
+        '''
+    }
+
+    void testTypeChecked5() {
+        assertScript '''
+        import java.io.Serializable;
+        
+        import groovy.transform.CompileStatic;
+        import groovy.transform.TypeChecked;
+        
+        @TypeChecked
+        public class MyClass {
+            static MyRepository factory() {
+                return new MyRepositoryImpl()
+            }
+            
+            static void main(String[] args) {
+                MyRepository r = factory()
+                r.delete('foo')
+            }
+        }
+        
+        @TypeChecked
+        interface CrudRepository<T, S extends Serializable> {
+            void delete(T arg);
+            void delete(S arg);
+        }
+        
+        @TypeChecked
+        abstract class MyRepository2 implements CrudRepository<String, Long> {
+        }
+        
+        @TypeChecked
+        abstract class MyRepository extends MyRepository2 {
+        }
+        
+        @TypeChecked
+        class MyRepositoryImpl extends MyRepository {
+            @Override
+            public void delete(String arg) {
+                System.out.println("String");
+                assert true
+            }
+            
+            @Override
+            public void delete(Long arg) {
+                System.out.println("Long");
+                assert false: 'wrong method invoked'
+            }
+        }
+        '''
+    }
+
+
+    void testCompileStatic1() {
+        assertScript '''
+        import java.io.Serializable;
+        
+        import groovy.transform.CompileStatic;
+        import groovy.transform.TypeChecked;
+        
+        @CompileStatic
+        public class MyClass {
+            static MyRepository factory() {
+                return new MyRepositoryImpl()
+            }
+            
+            static void main(String[] args) {
+                MyRepository r = factory()
+                r.delete('foo')
+            }
+        }
+        
+        @CompileStatic
+        interface CrudRepository<T, S extends Serializable> {
+            void delete(T arg);
+            void delete(S arg);
+        }
+        
+        @CompileStatic
+        interface MyRepository extends CrudRepository<String, Long> {
+        }
+        
+        @CompileStatic
+        class MyRepositoryImpl implements MyRepository {
+            @Override
+            public void delete(String arg) {
+                System.out.println("String");
+                assert true
+            }
+            
+            @Override
+            public void delete(Long arg) {
+                System.out.println("Long");
+                assert false: 'wrong method invoked'
+            }
+        }
+        '''
+    }
+
+    void testCompileStatic2() {
+        assertScript '''
+        import java.io.Serializable;
+        
+        import groovy.transform.CompileStatic;
+        import groovy.transform.TypeChecked;
+        
+        @CompileStatic
+        public class MyClass {
+            static MyRepository factory() {
+                return new MyRepositoryImpl()
+            }
+            
+            static void main(String[] args) {
+                MyRepository r = factory()
+                r.delete('foo')
+            }
+        }
+        
+        @CompileStatic
+        abstract class CrudRepository<T, S extends Serializable> {
+            abstract void delete(T arg);
+            abstract void delete(S arg);
+        }
+        
+        @CompileStatic
+        abstract class MyRepository extends CrudRepository<String, Long> {
+        }
+        
+        @CompileStatic
+        class MyRepositoryImpl extends MyRepository {
+            @Override
+            public void delete(String arg) {
+                System.out.println("String");
+                assert true
+            }
+            
+            @Override
+            public void delete(Long arg) {
+                System.out.println("Long");
+                assert false: 'wrong method invoked'
+            }
+        }
+        '''
+    }
+
+    void testCompileStatic3() {
+        assertScript '''
+        import java.io.Serializable;
+        
+        import groovy.transform.CompileStatic;
+        import groovy.transform.TypeChecked;
+        
+        @CompileStatic
+        public class MyClass {
+            static MyRepository factory() {
+                return new MyRepositoryImpl()
+            }
+            
+            static void main(String[] args) {
+                MyRepository r = factory()
+                r.delete('foo')
+            }
+        }
+        
+        @CompileStatic
+        interface CrudRepository<T, S extends Serializable> {
+            void delete(T arg);
+            void delete(S arg);
+        }
+        
+        @CompileStatic
+        interface MyRepository2 extends CrudRepository<String, Long> {
+        }
+        
+        @CompileStatic
+        interface MyRepository extends MyRepository2 {
+        }
+        
+        @CompileStatic
+        class MyRepositoryImpl implements MyRepository {
+            @Override
+            public void delete(String arg) {
+                System.out.println("String");
+                assert true
+            }
+            
+            @Override
+            public void delete(Long arg) {
+                System.out.println("Long");
+                assert false: 'wrong method invoked'
+            }
+        }
+        '''
+    }
+
+    void testCompileStatic4() {
+        assertScript '''
+        import java.io.Serializable;
+        
+        import groovy.transform.CompileStatic;
+        import groovy.transform.TypeChecked;
+        
+        @CompileStatic
+        public class MyClass {
+            static MyRepository factory() {
+                return new MyRepositoryImpl()
+            }
+            
+            static void main(String[] args) {
+                MyRepository r = factory()
+                r.delete('foo')
+            }
+        }
+        
+        @CompileStatic
+        abstract class CrudRepository<T, S extends Serializable> {
+            abstract void delete(T arg);
+            abstract void delete(S arg);
+        }
+        
+        @CompileStatic
+        abstract class MyRepository2 extends CrudRepository<String, Long> {
+        }
+        
+        @CompileStatic
+        abstract class MyRepository extends MyRepository2 {
+        }
+        
+        @CompileStatic
+        class MyRepositoryImpl extends MyRepository {
+            @Override
+            public void delete(String arg) {
+                System.out.println("String");
+                assert true
+            }
+            
+            @Override
+            public void delete(Long arg) {
+                System.out.println("Long");
+                assert false: 'wrong method invoked'
+            }
+        }
+        '''
+    }
+
+    void testCompileStatic5() {
+        assertScript '''
+        import java.io.Serializable;
+        
+        import groovy.transform.CompileStatic;
+        import groovy.transform.TypeChecked;
+        
+        @CompileStatic
+        public class MyClass {
+            static MyRepository factory() {
+                return new MyRepositoryImpl()
+            }
+            
+            static void main(String[] args) {
+                MyRepository r = factory()
+                r.delete('foo')
+            }
+        }
+        
+        @CompileStatic
+        interface CrudRepository<T, S extends Serializable> {
+            void delete(T arg);
+            void delete(S arg);
+        }
+        
+        @CompileStatic
+        abstract class MyRepository2 implements CrudRepository<String, Long> {
+        }
+        
+        @CompileStatic
+        abstract class MyRepository extends MyRepository2 {
+        }
+        
+        @CompileStatic
+        class MyRepositoryImpl extends MyRepository {
+            @Override
+            public void delete(String arg) {
+                System.out.println("String");
+                assert true
+            }
+            
+            @Override
+            public void delete(Long arg) {
+                System.out.println("Long");
+                assert false: 'wrong method invoked'
+            }
+        }
+        '''
+    }
+
+    void testCompileStatic6() {
+        assertScript '''
+        import java.io.Serializable;
+        import groovy.transform.CompileStatic;
+
+        @CompileStatic
+        class Repository<T, S extends Serializable> {
+            void delete(T arg) { assert true }
+            void delete(S arg) { assert false: 'wrong method invoked' }
+        }
+        
+        @CompileStatic
+        def test() {
+            Repository<String, Long> r = new Repository<String, Long>()
+            r.delete('foo')
+        }
+        
+        test()
+        '''
+    }
+}
diff --git a/src/test/groovy/transform/stc/GenericsSTCTest.groovy b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
index a35506caf3..9c42e3e9da 100644
--- a/src/test/groovy/transform/stc/GenericsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
@@ -50,7 +50,7 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
         shouldFailWithMessages '''
             List<String> list = []
             list.add(1)
-        ''', "Cannot call java.util.List <String>#add(java.lang.String) with arguments [int]"
+        ''', "[Static type checking] - Cannot find matching method java.util.List#add(int)"
     }
 
     void testAddOnList2() {
@@ -76,7 +76,7 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
         shouldFailWithMessages '''
             List<String> list = []
             list << 1
-        ''', 'Cannot call <T> java.util.List <String>#leftShift(T) with arguments [int]'
+        ''', '[Static type checking] - Cannot find matching method java.util.List#leftShift(int)'
     }
 
     void testAddOnList2UsingLeftShift() {
@@ -116,14 +116,14 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
         shouldFailWithMessages '''
             List<Integer> list = new LinkedList<>()
             list.add 'Hello'
-        ''', 'Cannot call java.util.LinkedList <java.lang.Integer>#add(java.lang.Integer) with arguments [java.lang.String]'
+        ''', '[Static type checking] - Cannot find matching method java.util.LinkedList#add(java.lang.String)'
     }
 
     void testAddOnListWithDiamondAndWrongTypeUsingLeftShift() {
         shouldFailWithMessages '''
             List<Integer> list = new LinkedList<>()
             list << 'Hello'
-        ''', 'Cannot call <T> java.util.LinkedList <java.lang.Integer>#leftShift(T) with arguments [java.lang.String]'
+        ''', '[Static type checking] - Cannot find matching method java.util.LinkedList#leftShift(java.lang.String)'
     }
 
     void testAddOnListWithDiamondAndNullUsingLeftShift() {
@@ -424,7 +424,7 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
         shouldFailWithMessages '''
             Map<String, Integer> map = new HashMap<String,Integer>()
             map.put('hello', new Object())
-        ''', 'Cannot call java.util.HashMap <String, Integer>#put(java.lang.String, java.lang.Integer) with arguments [java.lang.String, java.lang.Object]'
+        ''', '[Static type checking] - Cannot find matching method java.util.HashMap#put(java.lang.String, java.lang.Object)'
     }
 
     void testPutMethodWithPrimitiveValueAndArrayPut() {
@@ -749,7 +749,7 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
             })
             Map<Date, Date> map = new HashMap<>()
             map.put('foo', new Date())
-        ''', 'Cannot call java.util.HashMap <java.util.Date, java.util.Date>#put(java.util.Date, java.util.Date) with arguments [java.lang.String, java.util.Date]'
+        ''', '[Static type checking] - Cannot find matching method java.util.HashMap#put(java.lang.String, java.util.Date)'
     }
     void testInferDiamondForAssignmentWithDatesAndIllegalKeyUsingSquareBracket() {
         shouldFailWithMessages '''
@@ -787,7 +787,7 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
             })
             Map<Date, Date> map = new HashMap<>()
             map.put(new Date(), 'foo')
-        ''', 'Cannot call java.util.HashMap <java.util.Date, java.util.Date>#put(java.util.Date, java.util.Date) with arguments [java.util.Date, java.lang.String]'
+        ''', '[Static type checking] - Cannot find matching method java.util.HashMap#put(java.util.Date, java.lang.String)'
     }
     void testInferDiamondForAssignmentWithDatesAndIllegalValueUsingSquareBracket() {
         shouldFailWithMessages '''
@@ -1306,7 +1306,7 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
                 Foo<Map> f = new Foo<Map>("a",1)
             }
             bar()
-        ''', '[Static type checking] - Cannot call Foo <Map>#<init>(java.util.Map, java.util.Map) with arguments [java.lang.String, int]'
+        ''', '[Static type checking] - Cannot find matching method Foo#<init>(java.lang.String, int)'
     }
     
     // Groovy-5742
diff --git a/src/test/org/codehaus/groovy/transform/InheritConstructorsTransformTest.groovy b/src/test/org/codehaus/groovy/transform/InheritConstructorsTransformTest.groovy
index 123c91d615..8b69d07844 100644
--- a/src/test/org/codehaus/groovy/transform/InheritConstructorsTransformTest.groovy
+++ b/src/test/org/codehaus/groovy/transform/InheritConstructorsTransformTest.groovy
@@ -221,7 +221,7 @@ class InheritConstructorsTransformTest extends GroovyShellTestCase {
             assert op.toString() == '3|DOWN'
         """
         assert message.contains('Cannot call OrderPublisher <RoundingMode>#<init>(java.util.Deque <java.lang.Integer>) with arguments [java.util.LinkedList <String>]')
-        assert message.contains('Cannot call OrderPublisher <RoundingMode>#<init>(java.math.RoundingMode) with arguments [java.util.Date]')
+        assert message.contains('Cannot find matching method OrderPublisher#<init>(java.util.Date)')
         assert message.contains('Cannot call OrderPublisher <RoundingMode>#<init>(java.util.Set <RoundingMode>) with arguments [java.util.HashSet <Date>]')
     }
 
