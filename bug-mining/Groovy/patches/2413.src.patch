diff --git a/src/main/groovy/grape/GrabAnnotationTransformation.java b/src/main/groovy/grape/GrabAnnotationTransformation.java
index f035047b1c..d32c53d3d6 100644
--- a/src/main/groovy/grape/GrabAnnotationTransformation.java
+++ b/src/main/groovy/grape/GrabAnnotationTransformation.java
@@ -184,6 +184,7 @@ public class GrabAnnotationTransformation extends ClassCodeVisitorSupport implem
         }
 
         List<Map<String,Object>> grabMaps = new ArrayList<Map<String,Object>>();
+        List<Map<String,Object>> grabMapsInit = new ArrayList<Map<String,Object>>();
         List<Map<String,Object>> grabExcludeMaps = new ArrayList<Map<String,Object>>();
 
         for (ClassNode classNode : sourceUnit.getAST().getClasses()) {
@@ -317,12 +318,17 @@ public class GrabAnnotationTransformation extends ClassCodeVisitorSupport implem
                             addError("Attribute \"" + s + "\" has value " + member.getText() + " but should be an inline constant in @" + node.getClassNode().getNameWithoutPackage() + " annotations", node);
                             continue grabAnnotationLoop;
                         }
-                        if (node.getMember(s) != null)
+                        if (node.getMember(s) != null) {
                             grabMap.put(s, ((ConstantExpression)member).getValue());
+                        }
                     }
                     grabMaps.add(grabMap);
-                    callGrabAsStaticInitIfNeeded(classNode, grapeClassNode, node, grabExcludeMaps);
+                    if ((node.getMember("initClass") == null)
+                            || (node.getMember("initClass") == ConstantExpression.TRUE)) {
+                        grabMapsInit.add(grabMap);
+                    }
                 }
+                callGrabAsStaticInitIfNeeded(classNode, grapeClassNode, grabMapsInit, grabExcludeMaps);
             }
 
             if (!grabResolverInitializers.isEmpty()) {
@@ -369,55 +375,49 @@ public class GrabAnnotationTransformation extends ClassCodeVisitorSupport implem
         return new URL(sourceName);
     }
 
-    private void callGrabAsStaticInitIfNeeded(ClassNode classNode, ClassNode grapeClassNode, AnnotationNode node, List<Map<String, Object>> grabExcludeMaps) {
-        if ((node.getMember("initClass") == null)
-            || (node.getMember("initClass") == ConstantExpression.TRUE))
-        {
-            List<Statement> grabInitializers = new ArrayList<Statement>();
+    private void callGrabAsStaticInitIfNeeded(ClassNode classNode, ClassNode grapeClassNode, List<Map<String,Object>> grabMapsInit, List<Map<String, Object>> grabExcludeMaps) {
+        List<Statement> grabInitializers = new ArrayList<Statement>();
+        MapExpression basicArgs = new MapExpression();
+        if (autoDownload != null)  {
+            basicArgs.addMapEntryExpression(new ConstantExpression(AUTO_DOWNLOAD_SETTING), new ConstantExpression(autoDownload));
+        }
 
+        if (disableChecksums != null)  {
+            basicArgs.addMapEntryExpression(new ConstantExpression(DISABLE_CHECKSUMS_SETTING), new ConstantExpression(disableChecksums));
+        }
+        if (!grabExcludeMaps.isEmpty()) {
+            ListExpression list = new ListExpression();
+            for (Map<String, Object> map : grabExcludeMaps) {
+                Set<Map.Entry<String, Object>> entries = map.entrySet();
+                MapExpression inner = new MapExpression();
+                for (Map.Entry<String, Object> entry : entries) {
+                    inner.addMapEntryExpression(new ConstantExpression(entry.getKey()), new ConstantExpression(entry.getValue()));
+                }
+                list.addExpression(inner);
+            }
+            basicArgs.addMapEntryExpression(new ConstantExpression("excludes"), list);
+        }
+
+        List<Expression> argList = new ArrayList<Expression>();
+        argList.add(basicArgs);
+        for (Map<String, Object> grabMap : grabMapsInit) {
             // add Grape.grab(excludeArgs, [group:group, module:module, version:version, classifier:classifier])
             // or Grape.grab([group:group, module:module, version:version, classifier:classifier])
-            MapExpression me = new MapExpression();
+            MapExpression dependencyArg = new MapExpression();
             for (String s : GRAB_REQUIRED) {
-                me.addMapEntryExpression(new ConstantExpression(s),node.getMember(s));
+                dependencyArg.addMapEntryExpression(new ConstantExpression(s), new ConstantExpression(grabMap.get(s)));
             }
-
             for (String s : GRAB_OPTIONAL) {
-                if (node.getMember(s) != null)
-                    me.addMapEntryExpression(new ConstantExpression(s),node.getMember(s));
+                if (grabMap.containsKey(s))
+                    dependencyArg.addMapEntryExpression(new ConstantExpression(s), new ConstantExpression(grabMap.get(s)));
             }
-
-            if (autoDownload != null)  {
-                me.addMapEntryExpression(new ConstantExpression(AUTO_DOWNLOAD_SETTING), new ConstantExpression(autoDownload));
-            }
-
-            if (disableChecksums != null)  {
-                me.addMapEntryExpression(new ConstantExpression(DISABLE_CHECKSUMS_SETTING), new ConstantExpression(disableChecksums));
-            }
-
-            ArgumentListExpression grabArgs;
-            if (grabExcludeMaps.isEmpty()) {
-                grabArgs = new ArgumentListExpression(me);
-            } else {
-                MapExpression args = new MapExpression();
-                ListExpression list = new ListExpression();
-                for (Map<String, Object> map : grabExcludeMaps) {
-                    Set<Map.Entry<String, Object>> entries = map.entrySet();
-                    MapExpression inner = new MapExpression();
-                    for (Map.Entry<String, Object> entry : entries) {
-                        inner.addMapEntryExpression(new ConstantExpression(entry.getKey()), new ConstantExpression(entry.getValue()));
-                    }
-                    list.addExpression(inner);
-                }
-                args.addMapEntryExpression(new ConstantExpression("excludes"), list);
-                grabArgs = new ArgumentListExpression(args, me);
-            }
-            grabInitializers.add(new ExpressionStatement(
-                    new StaticMethodCallExpression(grapeClassNode, "grab", grabArgs)));
-
-            // insert at beginning so we have the classloader set up before the class is called
-            classNode.addStaticInitializerStatements(grabInitializers, true);
+            argList.add(dependencyArg);
         }
+        ArgumentListExpression grabArgs = new ArgumentListExpression(argList);
+        grabInitializers.add(new ExpressionStatement(new StaticMethodCallExpression(grapeClassNode, "grab", grabArgs)));
+
+        // insert at beginning so we have the classloader set up before the class is called
+        classNode.addStaticInitializerStatements(grabInitializers, true);
     }
 
     private void addGrabResolverAsStaticInitIfNeeded(ClassNode grapeClassNode, AnnotationNode node,
