diff --git a/src/main/java/org/codehaus/groovy/classgen/asm/InvocationWriter.java b/src/main/java/org/codehaus/groovy/classgen/asm/InvocationWriter.java
index c6e65718fb..c7786c5a09 100644
--- a/src/main/java/org/codehaus/groovy/classgen/asm/InvocationWriter.java
+++ b/src/main/java/org/codehaus/groovy/classgen/asm/InvocationWriter.java
@@ -55,10 +55,10 @@ import java.util.TreeMap;
 import static org.apache.groovy.ast.tools.ExpressionUtils.isNullConstant;
 import static org.apache.groovy.ast.tools.ExpressionUtils.isSuperExpression;
 import static org.apache.groovy.ast.tools.ExpressionUtils.isThisExpression;
-import static org.codehaus.groovy.ast.ClassHelper.isFunctionalInterface;
-import static org.codehaus.groovy.ast.ClassHelper.isPrimitiveType;
 import static org.codehaus.groovy.ast.ClassHelper.isClassType;
+import static org.codehaus.groovy.ast.ClassHelper.isFunctionalInterface;
 import static org.codehaus.groovy.ast.ClassHelper.isObjectType;
+import static org.codehaus.groovy.ast.ClassHelper.isPrimitiveType;
 import static org.codehaus.groovy.ast.ClassHelper.isPrimitiveVoid;
 import static org.codehaus.groovy.ast.ClassHelper.isStringType;
 import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.isClassClassNodeWrappingConcreteType;
@@ -126,35 +126,28 @@ public class InvocationWriter {
 
     protected boolean writeDirectMethodCall(final MethodNode target, final boolean implicitThis, final Expression receiver, final TupleExpression args) {
         if (target == null) return false;
-
         ClassNode declaringClass = target.getDeclaringClass();
-        String methodName = target.getName();
-        int opcode;
-        if (target.isStatic()) {
-            opcode = INVOKESTATIC;
-        } else if (declaringClass.isInterface()) {
-            opcode = INVOKEINTERFACE;
-        } else if (target.isPrivate() || isSuperExpression(receiver)) {
-            opcode = INVOKESPECIAL;
-        } else {
-            opcode = INVOKEVIRTUAL;
+        ClassNode enclosingClass = controller.getClassNode(), receiverType = enclosingClass;
+        if (receiver != null) {
+            receiverType = controller.getTypeChooser().resolveType(receiver, enclosingClass);
+            if (target.isStatic() && isClassClassNodeWrappingConcreteType(receiverType)) {
+                receiverType = receiverType.getGenericsTypes()[0].getType();
+            }
         }
 
         CompileStack compileStack = controller.getCompileStack();
         OperandStack operandStack = controller.getOperandStack();
         MethodVisitor mv = controller.getMethodVisitor();
-        ClassNode classNode = controller.getClassNode();
+        int startDepth = operandStack.getStackLength();
 
         // handle receiver
-        int argumentsToRemove = 0;
-        if (opcode != INVOKESTATIC) {
-            argumentsToRemove = 1;
+        if (!target.isStatic()) {
             if (receiver != null) {
                 Expression objectExpression = receiver;
                 if (implicitThis
-                        && classNode.getOuterClass() != null
-                        && !classNode.isDerivedFrom(declaringClass)
-                        && !classNode.implementsInterface(declaringClass)) {
+                        && enclosingClass.getOuterClass() != null
+                        && !enclosingClass.isDerivedFrom(declaringClass)
+                        && !enclosingClass.implementsInterface(declaringClass)) {
                     // outer class method invocation
                     compileStack.pushImplicitThis(false);
                     if (!controller.isInGeneratedFunction() && isThis(receiver)) {
@@ -168,54 +161,54 @@ public class InvocationWriter {
                 compileStack.popImplicitThis();
             } else {
                 mv.visitIntInsn(ALOAD, 0);
-                operandStack.push(classNode);
+                operandStack.push(enclosingClass);
             }
         }
 
-        ClassNode receiverType;
-        if (receiver != null) {
-            receiverType = controller.getTypeChooser().resolveType(receiver, classNode);
-            if (isClassClassNodeWrappingConcreteType(receiverType) && target.isStatic())
-                receiverType = receiverType.getGenericsTypes()[0].getType();
+        int opcode;
+        if (target.isStatic()) {
+            opcode = INVOKESTATIC;
+        } else if (declaringClass.isInterface()) {
+            opcode = INVOKEINTERFACE;
+        } else if (target.isPrivate() || isSuperExpression(receiver)) {
+            opcode = INVOKESPECIAL;
         } else {
-            receiverType = declaringClass;
+            opcode = INVOKEVIRTUAL;
         }
 
-        int stackLen = operandStack.getStackLength();
-        String owner = BytecodeHelper.getClassInternalName(declaringClass);
+        ClassNode ownerClass = declaringClass;
         if (opcode == INVOKEVIRTUAL && isObjectType(declaringClass)) {
-            // avoid using a narrowed type if the method is defined on object because it can interfere
+            // avoid using a narrowed type if the method is defined on Object, because it can interfere
             // with delegate type inference in static compilation mode and trigger a ClassCastException
-            receiverType = declaringClass;
         } else if (opcode == INVOKEVIRTUAL
                 && !receiverType.isArray()
                 && !receiverType.isInterface()
                 && !isPrimitiveType(receiverType)
                 && !receiverType.equals(declaringClass)
                 && receiverType.isDerivedFrom(declaringClass)) {
-
-            owner = BytecodeHelper.getClassInternalName(receiverType);
+            ownerClass = receiverType; // use actual for typical call
             if (!receiverType.equals(operandStack.getTopOperand())) {
-                mv.visitTypeInsn(CHECKCAST, owner);
+                mv.visitTypeInsn(CHECKCAST, BytecodeHelper.getClassInternalName(ownerClass));
             }
         } else if (opcode != INVOKESPECIAL && (declaringClass.getModifiers() & (ACC_FINAL | ACC_PUBLIC)) == 0 && !receiverType.equals(declaringClass)
                 && (declaringClass.isInterface() ? receiverType.implementsInterface(declaringClass) : receiverType.isDerivedFrom(declaringClass))) {
-            // GROOVY-6962, GROOVY-9955: method declared by inaccessible class
-            owner = BytecodeHelper.getClassInternalName(receiverType);
+            // GROOVY-6962, GROOVY-9955, GROOVY-10380: method declared by inaccessible class or interface
+            if (declaringClass.isInterface() && !receiverType.isInterface()) opcode = INVOKEVIRTUAL;
+            ownerClass = receiverType;
         }
 
         loadArguments(args.getExpressions(), target.getParameters());
 
-        String descriptor = BytecodeHelper.getMethodDescriptor(target.getReturnType(), target.getParameters());
-        mv.visitMethodInsn(opcode, owner, methodName, descriptor, declaringClass.isInterface());
-        ClassNode returnType = target.getReturnType().redirect();
+        String ownerName = BytecodeHelper.getClassInternalName(ownerClass), methodName = target.getName();
+        String signature = BytecodeHelper.getMethodDescriptor(target.getReturnType(), target.getParameters());
+        mv.visitMethodInsn(opcode, ownerName, methodName, signature, ownerClass.isInterface());
+        ClassNode returnType = target.getReturnType();
         if (isPrimitiveVoid(returnType)) {
             returnType = ClassHelper.OBJECT_TYPE;
             mv.visitInsn(ACONST_NULL);
         }
-        argumentsToRemove += (operandStack.getStackLength() - stackLen);
-        operandStack.remove(argumentsToRemove);
-        operandStack.push(returnType);
+        // replace the method call's receiver and argument types with the return type
+        operandStack.replace(returnType, operandStack.getStackLength() - startDepth);
         return true;
     }
 
diff --git a/src/test/groovy/transform/stc/BugsSTCTest.groovy b/src/test/groovy/transform/stc/BugsSTCTest.groovy
index 5837086550..813b5f4299 100644
--- a/src/test/groovy/transform/stc/BugsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/BugsSTCTest.groovy
@@ -371,6 +371,7 @@ class BugsSTCTest extends StaticTypeCheckingTestCase {
         GroovyObject obj = new A.B()
         '''
     }
+
     void testCastInnerClassToGroovyObject() {
         assertScript '''
         class A { static class B {} }
@@ -969,6 +970,7 @@ Printer
             }
         '''
     }
+
     void testInnerClassImplementsInterfaceMethodWithTrait() {
         assertScript '''
             class Main {
@@ -994,6 +996,7 @@ Printer
             }
         '''
     }
+
     void testInnerClassImplementsInterfaceMethodWithDelegate() {
         assertScript '''
             class Main {
@@ -1038,4 +1041,17 @@ Printer
             assert obj.proper == 'value'
         '''
     }
+
+    // GROOVY-10380
+    void testInvokeDefaultMethodFromPackagePrivateInterface() {
+        assertScript '''
+            class C extends groovy.transform.stc.Groovy10380 {
+                void test() {
+                    String result = m() // default method
+                    assert result == 'works'
+                }
+            }
+            new C().test()
+        '''
+    }
 }
diff --git a/src/test/groovy/transform/stc/Groovy10380.java b/src/test/groovy/transform/stc/Groovy10380.java
new file mode 100644
index 0000000000..254316f504
--- /dev/null
+++ b/src/test/groovy/transform/stc/Groovy10380.java
@@ -0,0 +1,29 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package groovy.transform.stc;
+
+public abstract class Groovy10380 implements I10380 {
+    // m() should be callable
+}
+
+interface I10380 {
+    default String m() {
+        return "works";
+    }
+}
