diff --git a/src/main/org/codehaus/groovy/transform/LazyASTTransformation.java b/src/main/org/codehaus/groovy/transform/LazyASTTransformation.java
index 0216c47e26..871fe7081e 100644
--- a/src/main/org/codehaus/groovy/transform/LazyASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/LazyASTTransformation.java
@@ -23,7 +23,6 @@ import org.codehaus.groovy.ast.AnnotatedNode;
 import org.codehaus.groovy.ast.AnnotationNode;
 import org.codehaus.groovy.ast.ClassHelper;
 import org.codehaus.groovy.ast.ClassNode;
-import org.codehaus.groovy.ast.CodeVisitorSupport;
 import org.codehaus.groovy.ast.FieldNode;
 import org.codehaus.groovy.ast.InnerClassNode;
 import org.codehaus.groovy.ast.Parameter;
@@ -115,7 +114,17 @@ public class LazyASTTransformation extends AbstractASTTransformation {
         final String fullName = declaringClass.getName() + "$" + fieldType.getNameWithoutPackage() + "Holder_" + fieldNode.getName().substring(1);
         final InnerClassNode holderClass = new InnerClassNode(declaringClass, fullName, visibility, ClassHelper.OBJECT_TYPE);
         final String innerFieldName = "INSTANCE";
-        holderClass.addField(innerFieldName, ACC_PRIVATE | ACC_STATIC | ACC_FINAL, fieldType, initExpr);
+
+        // we have two options:
+        // (1) embed initExpr within holder class but redirect field access/method calls to declaring class members
+        // (2) keep initExpr within a declaring class method that is only called by the holder class
+        // currently we have gone with (2) for simplicity with only a slight memory footprint increase in the declaring class
+        final String initializeMethodName = (fullName + "_initExpr").replace('.', '_');
+        declaringClass.addMethod(initializeMethodName, ACC_PRIVATE | ACC_STATIC | ACC_FINAL, fieldType,
+                Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, returnS(initExpr));
+        holderClass.addField(innerFieldName, ACC_PRIVATE | ACC_STATIC | ACC_FINAL, fieldType,
+                callX(declaringClass, initializeMethodName));
+
         final Expression innerField = propX(classX(holderClass), innerFieldName);
         declaringClass.getModule().addClass(holderClass);
         body.addStatement(returnS(innerField));
diff --git a/src/test/org/codehaus/groovy/transform/LazyTransformTest.groovy b/src/test/org/codehaus/groovy/transform/LazyTransformTest.groovy
index 08a0b191ef..de8b110cc0 100644
--- a/src/test/org/codehaus/groovy/transform/LazyTransformTest.groovy
+++ b/src/test/org/codehaus/groovy/transform/LazyTransformTest.groovy
@@ -22,8 +22,7 @@ import java.lang.ref.SoftReference
 import java.lang.reflect.Modifier
 
 /**
- * @author Alex Tkachman
- * @author Paul King
+ * Tests for the {@code @Lazy} transform.
  */
 class LazyTransformTest extends GroovyShellTestCase {
 
@@ -181,4 +180,26 @@ class LazyTransformTest extends GroovyShellTestCase {
         assertTrue res.@'$list' instanceof SoftReference
         assertEquals([1,2,3], res.list)
     }
-}
\ No newline at end of file
+
+    void testNestedLazyCalls() {
+        def res = evaluate("""
+            class X {
+              @Lazy def smallSet = [1, 2, 3]
+              @Lazy def biggerSet = (smallSet + [4, 5, 6])
+            }
+            new X().biggerSet
+        """)
+        assertEquals([1,2,3,4,5,6], res)
+    }
+
+    void testNestedStaticLazyCalls() {
+        def res = evaluate("""
+            class X {
+              @Lazy static final SMALL_SET = [10, 20, 30]
+              @Lazy static final BIGGER_SET = (SMALL_SET + [40, 50, 60])
+            }
+            X.BIGGER_SET
+        """)
+        assertEquals([10,20,30,40,50,60], res)
+    }
+}
