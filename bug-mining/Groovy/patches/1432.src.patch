diff --git a/src/main/groovy/lang/Delegate.java b/src/main/groovy/lang/Delegate.java
index 3a2ae6008b..1f0722b2ad 100644
--- a/src/main/groovy/lang/Delegate.java
+++ b/src/main/groovy/lang/Delegate.java
@@ -111,6 +111,8 @@ import java.lang.annotation.Target;
  * <li>All methods defined in the owner class (including static, abstract or private etc.)
  * take precedence over methods with identical signatures from a {@code @Delegate} field
  * <li>Recursive delegation to your own class is not allowed
+ * <li>Mixing of {@code @Delegate} with default method arguments is known not to work in some cases. We recommend
+ * not using these features together.
  * </ul>
  *
  * @author Alex Tkachman
diff --git a/src/main/org/codehaus/groovy/transform/DelegateASTTransformation.java b/src/main/org/codehaus/groovy/transform/DelegateASTTransformation.java
index ff1c50731f..fd59cf1d5b 100644
--- a/src/main/org/codehaus/groovy/transform/DelegateASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/DelegateASTTransformation.java
@@ -71,11 +71,15 @@ public class DelegateASTTransformation implements ASTTransformation, Opcodes {
                 return;
             }
             final List<MethodNode> fieldMethods = getAllMethods(type);
+            for (ClassNode next : type.getAllInterfaces()) {
+                fieldMethods.addAll(getAllMethods(next));
+            }
             final Expression deprecatedElement = node.getMember("deprecated");
             final boolean deprecated = hasBooleanValue(deprecatedElement, true);
 
+            final List<MethodNode> ownerMethods = getAllMethods(owner);
             for (MethodNode mn : fieldMethods) {
-                addDelegateMethod(fieldNode, owner, getAllMethods(owner), mn, deprecated);
+                addDelegateMethod(fieldNode, owner, ownerMethods, mn, deprecated);
             }
 
             for (PropertyNode prop : type.getProperties()) {
@@ -164,6 +168,13 @@ public class DelegateASTTransformation implements ASTTransformation, Opcodes {
             }
         }
 
+        // ignore methods already in owner
+        for (MethodNode mn : owner.getMethods()) {
+            if (mn.getTypeDescriptor().equals(candidate.getTypeDescriptor())) {
+                return;
+            }
+        }
+
         // give precedence to methods of self (but not abstract or static superclass methods)
         // also allows abstract or static self methods to be selected for overriding but they are ignored later
         MethodNode existingNode = null;
diff --git a/src/test/org/codehaus/groovy/transform/DelegateTransformTest.groovy b/src/test/org/codehaus/groovy/transform/DelegateTransformTest.groovy
index 238e50d14b..0300608354 100644
--- a/src/test/org/codehaus/groovy/transform/DelegateTransformTest.groovy
+++ b/src/test/org/codehaus/groovy/transform/DelegateTransformTest.groovy
@@ -213,6 +213,10 @@ class DelegateTransformTest extends CompilableTestSupport {
             foo.finalBaz = 'New value - finalBaz'
         }
     }
+
+    void testDelegateSuperInterfaces_Groovy4619() {
+        assert 'doSomething' in SomeClass4619.class.methods*.name
+    }
 }
 
 interface DelegateFoo {
@@ -256,3 +260,14 @@ class Bar4244 {
     String nonFinalBaz = "Initial value - nonFinalBaz"
     final String finalBaz = "Initial value - finalBaz"
 }
+
+interface SomeInterface4619 {
+    void doSomething()
+}
+
+interface SomeOtherInterface4619 extends SomeInterface4619 {}
+
+class SomeClass4619 {
+    @Delegate
+    SomeOtherInterface4619 delegate
+}
