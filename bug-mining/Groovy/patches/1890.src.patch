diff --git a/src/main/org/codehaus/groovy/ast/tools/GenericsUtils.java b/src/main/org/codehaus/groovy/ast/tools/GenericsUtils.java
index ef19f076a6..91a1129653 100644
--- a/src/main/org/codehaus/groovy/ast/tools/GenericsUtils.java
+++ b/src/main/org/codehaus/groovy/ast/tools/GenericsUtils.java
@@ -118,7 +118,7 @@ public class GenericsUtils {
         if (node == null) return;
         if (!node.isUsingGenerics() || !node.isRedirectNode()) return;
         GenericsType[] parameterized = node.getGenericsTypes();
-        if (parameterized == null) return;
+        if (parameterized == null || parameterized.length == 0) return;
         GenericsType[] redirectGenericsTypes = node.redirect().getGenericsTypes();
         if (redirectGenericsTypes==null) redirectGenericsTypes = parameterized;
         for (int i = 0; i < redirectGenericsTypes.length; i++) {
diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 7b941eebd9..0146d7eb78 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -401,6 +401,23 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             if (resultType == null) {
                 resultType = lType;
             }
+            if (isArrayOp(op) &&
+                    oldBinaryExpression!=null
+                    && oldBinaryExpression.getLeftExpression()==expression
+                    && isAssignment(oldBinaryExpression.getOperation().getType())
+                    && !lType.isArray()) {
+                // left hand side of an assignment : map['foo'] = ...
+                ClassNode[] arguments = {rType, getType(oldBinaryExpression.getRightExpression())};
+                List<MethodNode> nodes = findMethod(lType.redirect(), "putAt", arguments);
+                /*if (nodes.isEmpty() && lType.implementsInterface(MAP_TYPE)) {
+                    nodes = findMethod(lType, "put", arguments);
+                } else if (nodes.isEmpty() && lType.implementsInterface(LIST_TYPE)) {
+                    nodes = findMethod(lType, "add", arguments);
+                }*/
+                if (nodes.size()==1) {
+                    typeCheckMethodsWithGenerics(lType, arguments, nodes.get(0), expression);
+                }
+            }
             boolean isEmptyDeclaration = expression instanceof DeclarationExpression && rightExpression instanceof EmptyExpression;
             if (!isEmptyDeclaration) storeType(expression, resultType);
             if (!isEmptyDeclaration && isAssignment(op)) {
@@ -503,6 +520,8 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                     node.setGenericsTypes(copy);
                 }
             }
+            // store inferred type on CCE
+            storeType(cce, node);
         }
     }
 
@@ -954,6 +973,9 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 );
                 bexp.setSourcePosition(init);
                 typeCheckAssignment(bexp, left, node.getOriginType(), init, getType(init));
+                if (init instanceof ConstructorCallExpression) {
+                    inferDiamondType((ConstructorCallExpression)init, node.getOriginType());
+                }
             }
         } finally {
             isInStaticContext = osc;
diff --git a/src/test/groovy/transform/stc/GenericsSTCTest.groovy b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
index 865ae11a27..3523cf2490 100644
--- a/src/test/groovy/transform/stc/GenericsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
@@ -620,6 +620,150 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
         ''', 'Cannot use diamond <> with anonymous inner classes'
     }
 
+    // GROOVY-5614
+    void testInferDiamondForFields() {
+        assertScript '''
+            class Rules {
+                @ASTTest(phase=INSTRUCTION_SELECTION, value={
+                    def type = node.initialExpression.getNodeMetaData(INFERRED_TYPE)
+                    assert type == make(HashMap)
+                    assert type.genericsTypes.length == 2
+                    assert type.genericsTypes[0].type == Integer_TYPE
+                    assert type.genericsTypes[1].type == make(Date)
+                })
+
+                final Map<Integer, Date> bindings1  = new HashMap<>();
+                @ASTTest(phase=INSTRUCTION_SELECTION, value={
+                    def type = node.initialExpression.getNodeMetaData(INFERRED_TYPE)
+                    assert type == make(HashMap)
+                    assert type.genericsTypes.length == 2
+                    assert type.genericsTypes[0].type == STRING_TYPE
+                    assert type.genericsTypes[1].type == STRING_TYPE
+                })
+                final Map<String, String> bindings2 = new HashMap<>();
+            }
+            def r = new Rules()
+
+            r.bindings1[3] = new Date()
+            assert r.bindings1.containsKey(3)
+
+            r.bindings2['a'] = 'A'
+            r.bindings2.put('b', 'B')
+
+        '''
+    }
+    void testInferDiamondForAssignment() {
+        assertScript '''
+            @ASTTest(phase=INSTRUCTION_SELECTION, value={
+                def type = node.getNodeMetaData(INFERRED_TYPE)
+                assert type == make(HashMap)
+                assert type.genericsTypes.length == 2
+                assert type.genericsTypes[0].type == STRING_TYPE
+                assert type.genericsTypes[1].type == STRING_TYPE
+                type = node.rightExpression.getNodeMetaData(INFERRED_TYPE)
+                assert type == make(HashMap)
+                assert type.genericsTypes.length == 2
+                assert type.genericsTypes[0].type == STRING_TYPE
+                assert type.genericsTypes[1].type == STRING_TYPE
+            })
+            Map<String, String> map = new HashMap<>()
+        '''
+    }
+    void testInferDiamondForAssignmentWithDates() {
+        assertScript '''
+            @ASTTest(phase=INSTRUCTION_SELECTION, value={
+                def DATE = make(Date)
+                def type = node.getNodeMetaData(INFERRED_TYPE)
+                assert type == make(HashMap)
+                assert type.genericsTypes.length == 2
+                assert type.genericsTypes[0].type == DATE
+                assert type.genericsTypes[1].type == DATE
+                type = node.rightExpression.getNodeMetaData(INFERRED_TYPE)
+                assert type == make(HashMap)
+                assert type.genericsTypes.length == 2
+                assert type.genericsTypes[0].type == DATE
+                assert type.genericsTypes[1].type == DATE
+            })
+            Map<Date, Date> map = new HashMap<>()
+        '''
+    }
+    void testInferDiamondForAssignmentWithDatesAndIllegalKeyUsingPut() {
+        shouldFailWithMessages '''
+            @ASTTest(phase=INSTRUCTION_SELECTION, value={
+                def DATE = make(Date)
+                def type = node.getNodeMetaData(INFERRED_TYPE)
+                assert type == make(HashMap)
+                assert type.genericsTypes.length == 2
+                assert type.genericsTypes[0].type == DATE
+                assert type.genericsTypes[1].type == DATE
+                type = node.rightExpression.getNodeMetaData(INFERRED_TYPE)
+                assert type == make(HashMap)
+                assert type.genericsTypes.length == 2
+                assert type.genericsTypes[0].type == DATE
+                assert type.genericsTypes[1].type == DATE
+            })
+            Map<Date, Date> map = new HashMap<>()
+            map.put('foo', new Date())
+        ''', 'Cannot find matching method java.util.HashMap#put(java.lang.String, java.util.Date)'
+    }
+    void testInferDiamondForAssignmentWithDatesAndIllegalKeyUsingSquareBracket() {
+        shouldFailWithMessages '''
+            @ASTTest(phase=INSTRUCTION_SELECTION, value={
+                def DATE = make(Date)
+                def type = node.getNodeMetaData(INFERRED_TYPE)
+                assert type == make(HashMap)
+                assert type.genericsTypes.length == 2
+                assert type.genericsTypes[0].type == DATE
+                assert type.genericsTypes[1].type == DATE
+                type = node.rightExpression.getNodeMetaData(INFERRED_TYPE)
+                assert type == make(HashMap)
+                assert type.genericsTypes.length == 2
+                assert type.genericsTypes[0].type == DATE
+                assert type.genericsTypes[1].type == DATE
+            })
+            Map<Date, Date> map = new HashMap<>()
+            map['foo'] = new Date()
+        ''', 'Cannot call org.codehaus.groovy.runtime.DefaultGroovyMethods#putAt(java.util.Map <java.util.Date, java.util.Date>, java.util.Date, java.util.Date) with arguments [java.util.HashMap <java.util.Date, java.util.Date>, java.lang.String, java.util.Date]'
+    }
+    void testInferDiamondForAssignmentWithDatesAndIllegalValueUsingPut() {
+        shouldFailWithMessages '''
+            @ASTTest(phase=INSTRUCTION_SELECTION, value={
+                def DATE = make(Date)
+                def type = node.getNodeMetaData(INFERRED_TYPE)
+                assert type == make(HashMap)
+                assert type.genericsTypes.length == 2
+                assert type.genericsTypes[0].type == DATE
+                assert type.genericsTypes[1].type == DATE
+                type = node.rightExpression.getNodeMetaData(INFERRED_TYPE)
+                assert type == make(HashMap)
+                assert type.genericsTypes.length == 2
+                assert type.genericsTypes[0].type == DATE
+                assert type.genericsTypes[1].type == DATE
+            })
+            Map<Date, Date> map = new HashMap<>()
+            map.put(new Date(), 'foo')
+        ''', 'Cannot find matching method java.util.HashMap#put(java.util.Date, java.lang.String)'
+    }
+    void testInferDiamondForAssignmentWithDatesAndIllegalValueUsingSquareBracket() {
+        shouldFailWithMessages '''
+            @ASTTest(phase=INSTRUCTION_SELECTION, value={
+                def DATE = make(Date)
+                def type = node.getNodeMetaData(INFERRED_TYPE)
+                assert type == make(HashMap)
+                assert type.genericsTypes.length == 2
+                assert type.genericsTypes[0].type == DATE
+                assert type.genericsTypes[1].type == DATE
+                type = node.rightExpression.getNodeMetaData(INFERRED_TYPE)
+                assert type == make(HashMap)
+                assert type.genericsTypes.length == 2
+                assert type.genericsTypes[0].type == DATE
+                assert type.genericsTypes[1].type == DATE
+            })
+            Map<Date, Date> map = new HashMap<>()
+            map[new Date()] = 'foo'
+        ''', 'Cannot assign value of type java.lang.String to variable of type java.util.Date'
+    }
+
     void testCallMethodWithParameterizedArrayList() {
         assertScript '''
         class MyUtility {
