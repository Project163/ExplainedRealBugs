diff --git a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
index 09782fd0bd..bd9fbd9cd4 100644
--- a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
+++ b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
@@ -171,7 +171,7 @@ public class StaticTypesCallSiteWriter extends CallSiteWriter implements Opcodes
         }
 
         // GROOVY-5568, we would be facing a DGM call, but instead of foo.getText(), have foo.text
-        List<MethodNode> methods = findDGMMethodsByNameAndArguments(receiverType, getterName, ClassNode.EMPTY_ARRAY);
+        List<MethodNode> methods = findDGMMethodsByNameAndArguments(controller.getSourceUnit().getClassLoader(), receiverType, getterName, ClassNode.EMPTY_ARRAY);
         if (!methods.isEmpty()) {
             List<MethodNode> methodNodes = chooseBestMethod(receiverType, methods, ClassNode.EMPTY_ARRAY);
             if (methodNodes.size()==1) {
@@ -538,7 +538,7 @@ public class StaticTypesCallSiteWriter extends CallSiteWriter implements Opcodes
         boolean acceptAnyMethod =
                 MAP_TYPE.equals(rType) || rType.implementsInterface(MAP_TYPE)
                 || LIST_TYPE.equals(rType) || rType.implementsInterface(LIST_TYPE);
-        List<MethodNode> nodes = StaticTypeCheckingSupport.findDGMMethodsByNameAndArguments(rType, message, args);
+        List<MethodNode> nodes = StaticTypeCheckingSupport.findDGMMethodsByNameAndArguments(controller.getSourceUnit().getClassLoader(), rType, message, args);
         nodes = StaticTypeCheckingSupport.chooseBestMethod(rType, nodes, args);
         if (nodes.size()==1 || nodes.size()>1 && acceptAnyMethod) {
             MethodNode methodNode = nodes.get(0);
diff --git a/src/main/org/codehaus/groovy/runtime/m12n/ExtensionModuleScanner.java b/src/main/org/codehaus/groovy/runtime/m12n/ExtensionModuleScanner.java
new file mode 100644
index 0000000000..fa7688cfec
--- /dev/null
+++ b/src/main/org/codehaus/groovy/runtime/m12n/ExtensionModuleScanner.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright 2003-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.codehaus.groovy.runtime.m12n;
+
+import groovy.lang.GroovyRuntimeException;
+import org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URL;
+import java.util.*;
+
+import static org.codehaus.groovy.runtime.DefaultGroovyMethodsSupport.closeQuietly;
+
+/**
+ * A module extension scanner is responsible for searching classpath modules,
+ * loading metadata from module descriptors, then perform custom tasks for each
+ * module.
+ *
+ * This class was introduced as a fix for GROOVY-6008
+ *
+ * @author Cedric Champeau
+ * @since 2.1.2
+ */
+public class ExtensionModuleScanner {
+    public final static String MODULE_META_INF_FILE = "META-INF/services/org.codehaus.groovy.runtime.ExtensionModule";
+
+    private final ExtensionModuleListener listener;
+    private final ClassLoader classLoader;
+
+    public ExtensionModuleScanner(final ExtensionModuleListener listener, final ClassLoader loader) {
+        this.listener = listener;
+        this.classLoader = loader;
+    }
+
+    public void scanClasspathModules() {
+        try {
+            Enumeration<URL> resources = classLoader.getResources(MODULE_META_INF_FILE);
+            while (resources.hasMoreElements()) {
+                URL url = resources.nextElement();
+                scanExtensionModuleFromMetaInf(url);
+            }
+        } catch (IOException e) {
+            // DO NOTHING
+        }
+    }
+
+    private void scanExtensionModuleFromMetaInf(final URL metadata) {
+        Properties properties = new Properties();
+        InputStream inStream = null;
+        try {
+            inStream = metadata.openStream();
+            properties.load(inStream);
+        } catch (IOException e) {
+            throw new GroovyRuntimeException("Unable to load module META-INF descriptor", e);
+        } finally {
+            closeQuietly(inStream);
+        }
+        scanExtensionModuleFromProperties(properties);
+    }
+
+    public void scanExtensionModuleFromProperties(final Properties properties) {
+        StandardPropertiesModuleFactory factory = new StandardPropertiesModuleFactory();
+        ExtensionModule module = factory.newModule(properties, classLoader);
+        listener.onModule(module);
+    }
+
+
+    public static interface ExtensionModuleListener {
+        void onModule(ExtensionModule module);
+    }
+}
diff --git a/src/main/org/codehaus/groovy/runtime/metaclass/MetaClassRegistryImpl.java b/src/main/org/codehaus/groovy/runtime/metaclass/MetaClassRegistryImpl.java
index 2915f93cf1..d5bcf720a3 100644
--- a/src/main/org/codehaus/groovy/runtime/metaclass/MetaClassRegistryImpl.java
+++ b/src/main/org/codehaus/groovy/runtime/metaclass/MetaClassRegistryImpl.java
@@ -22,22 +22,17 @@ import org.codehaus.groovy.reflection.*;
 import org.codehaus.groovy.runtime.*;
 import org.codehaus.groovy.runtime.m12n.ExtensionModule;
 import org.codehaus.groovy.runtime.m12n.ExtensionModuleRegistry;
-import org.codehaus.groovy.runtime.m12n.StandardPropertiesModuleFactory;
+import org.codehaus.groovy.runtime.m12n.ExtensionModuleScanner;
 import org.codehaus.groovy.vmplugin.VMPluginFactory;
 import org.codehaus.groovy.util.FastArray;
 import org.codehaus.groovy.util.ManagedLinkedList;
 import org.codehaus.groovy.util.ReferenceBundle;
 
-import java.io.IOException;
-import java.io.InputStream;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Field;
 import java.lang.reflect.Modifier;
-import java.net.URL;
 import java.util.*;
 
-import static org.codehaus.groovy.runtime.DefaultGroovyMethodsSupport.closeQuietly;
-
 /**
  * A registry of MetaClass instances which caches introspection &
  * reflection information and allows methods to be dynamically added to
@@ -52,6 +47,9 @@ import static org.codehaus.groovy.runtime.DefaultGroovyMethodsSupport.closeQuiet
  * @version $Revision$
  */
 public class MetaClassRegistryImpl implements MetaClassRegistry{
+    /**
+     * @deprecated Use {@link ExtensionModuleScanner#MODULE_META_INF_FILE instead}
+     */
     public final static String MODULE_META_INF_FILE = "META-INF/services/org.codehaus.groovy.runtime.ExtensionModule";
 
     private boolean useAccessible;
@@ -89,7 +87,7 @@ public class MetaClassRegistryImpl implements MetaClassRegistry{
         this.useAccessible = useAccessible;
 
         if (loadDefault == LOAD_DEFAULT) {
-            Map<CachedClass, List<MetaMethod>> map = new HashMap<CachedClass, List<MetaMethod>>();
+            final Map<CachedClass, List<MetaMethod>> map = new HashMap<CachedClass, List<MetaMethod>>();
 
             // let's register the default methods
             registerMethods(null, true, true, map);
@@ -108,7 +106,8 @@ public class MetaClassRegistryImpl implements MetaClassRegistry{
                 registerMethods(plugin, false, false, map);
             }
 
-            registerClasspathModules(map, this.getClass().getClassLoader());
+            ExtensionModuleScanner scanner = new ExtensionModuleScanner(new DefaultModuleListener(map), this.getClass().getClassLoader());
+            scanner.scanClasspathModules();
 
             refreshMopMethods(map);
 
@@ -148,62 +147,9 @@ public class MetaClassRegistryImpl implements MetaClassRegistry{
         }
     }
 
-    private void registerClasspathModules(final Map<CachedClass, List<MetaMethod>> map, final ClassLoader classLoader) {
-        try {
-            Enumeration<URL> resources = classLoader.getResources(MODULE_META_INF_FILE);
-            while (resources.hasMoreElements()) {
-                URL url = resources.nextElement();
-                registerExtensionModuleFromMetaInf(url, map, classLoader);
-            }
-        } catch (IOException e) {
-            // DO NOTHING
-        }
-    }
-
-    private void registerExtensionModuleFromMetaInf(final URL metadata, final Map<CachedClass, List<MetaMethod>> map, final ClassLoader classLoader) {
-        Properties properties = new Properties();
-        InputStream inStream = null;
-        try {
-            inStream = metadata.openStream();
-            properties.load(inStream);
-        } catch (IOException e) {
-            throw new GroovyRuntimeException("Unable to load module META-INF descriptor", e);
-        } finally {
-            closeQuietly(inStream);
-        }
-        registerExtensionModuleFromProperties(properties, classLoader, map);
-    }
-
     public void registerExtensionModuleFromProperties(final Properties properties, final ClassLoader classLoader, final Map<CachedClass, List<MetaMethod>> map) {
-        StandardPropertiesModuleFactory factory = new StandardPropertiesModuleFactory();
-        ExtensionModule module = factory.newModule(properties, classLoader);
-        if (moduleRegistry.hasModule(module.getName())) {
-            ExtensionModule loadedModule = moduleRegistry.getModule(module.getName());
-            if (loadedModule.getVersion().equals(module.getVersion())) {
-                // already registered
-                return;
-            } else {
-                throw new GroovyRuntimeException("Conflicting module versions. Module ["+module.getName()+" is loaded in version "+
-                loadedModule.getVersion()+" and you are trying to load version "+module.getVersion());
-            }
-        }
-        moduleRegistry.addModule(module);
-        // register MetaMethods
-        List<MetaMethod> metaMethods = module.getMetaMethods();
-        for (MetaMethod metaMethod : metaMethods) {
-            CachedClass cachedClass = metaMethod.getDeclaringClass();
-            List<MetaMethod> methods = map.get(cachedClass);
-            if (methods==null) {
-                methods = new ArrayList<MetaMethod>(4);
-                map.put(cachedClass, methods);
-            }
-            methods.add(metaMethod);
-            if (metaMethod.isStatic()) {
-                staticMethods.add(metaMethod);
-            } else {
-                instanceMethods.add(metaMethod);
-            }
-        }
+        ExtensionModuleScanner scanner = new ExtensionModuleScanner(new DefaultModuleListener(map), classLoader);
+        scanner.scanExtensionModuleFromProperties(properties);
     }
 
     public ExtensionModuleRegistry getModuleRegistry() {
@@ -545,4 +491,42 @@ public class MetaClassRegistryImpl implements MetaClassRegistry{
             }
         };
     }
+
+    private class DefaultModuleListener implements ExtensionModuleScanner.ExtensionModuleListener {
+        private final Map<CachedClass, List<MetaMethod>> map;
+
+        public DefaultModuleListener(final Map<CachedClass, List<MetaMethod>> map) {
+            this.map = map;
+        }
+
+        public void onModule(final ExtensionModule module) {
+            if (moduleRegistry.hasModule(module.getName())) {
+            ExtensionModule loadedModule = moduleRegistry.getModule(module.getName());
+            if (loadedModule.getVersion().equals(module.getVersion())) {
+                // already registered
+                return;
+            } else {
+                throw new GroovyRuntimeException("Conflicting module versions. Module ["+module.getName()+" is loaded in version "+
+                        loadedModule.getVersion()+" and you are trying to load version "+module.getVersion());
+            }
+        }
+            moduleRegistry.addModule(module);
+            // register MetaMethods
+            List<MetaMethod> metaMethods = module.getMetaMethods();
+            for (MetaMethod metaMethod : metaMethods) {
+                CachedClass cachedClass = metaMethod.getDeclaringClass();
+                List<MetaMethod> methods = map.get(cachedClass);
+                if (methods==null) {
+                    methods = new ArrayList<MetaMethod>(4);
+                    map.put(cachedClass, methods);
+                }
+                methods.add(metaMethod);
+                if (metaMethod.isStatic()) {
+                    staticMethods.add(metaMethod);
+                } else {
+                    instanceMethods.add(metaMethod);
+                }
+            }
+        }
+    }
 }
diff --git a/src/main/org/codehaus/groovy/transform/sc/transformers/BooleanExpressionTransformer.java b/src/main/org/codehaus/groovy/transform/sc/transformers/BooleanExpressionTransformer.java
index 314a51cda7..186372e58d 100644
--- a/src/main/org/codehaus/groovy/transform/sc/transformers/BooleanExpressionTransformer.java
+++ b/src/main/org/codehaus/groovy/transform/sc/transformers/BooleanExpressionTransformer.java
@@ -127,7 +127,7 @@ public class BooleanExpressionTransformer {
                     controller.getOperandStack().replace(ClassHelper.boolean_TYPE);
                     return;
                 }
-                List<MethodNode> asBoolean = findDGMMethodsByNameAndArguments(type, "asBoolean", ClassNode.EMPTY_ARRAY);
+                List<MethodNode> asBoolean = findDGMMethodsByNameAndArguments(controller.getSourceUnit().getClassLoader(), type, "asBoolean", ClassNode.EMPTY_ARRAY);
                 if (asBoolean.size() == 1) {
                     MethodNode node = asBoolean.get(0);
                     if (node instanceof ExtensionMethodNode) {
diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
index bef0902ea5..f56627d91c 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
@@ -15,8 +15,6 @@
  */
 package org.codehaus.groovy.transform.stc;
 
-import groovy.lang.GroovySystem;
-import groovy.lang.MetaClassRegistry;
 import org.codehaus.groovy.GroovyBugError;
 import org.codehaus.groovy.ast.*;
 import org.codehaus.groovy.ast.expr.*;
@@ -27,12 +25,13 @@ import org.codehaus.groovy.control.CompilationUnit;
 import org.codehaus.groovy.runtime.DefaultGroovyMethods;
 import org.codehaus.groovy.runtime.DefaultGroovyStaticMethods;
 import org.codehaus.groovy.runtime.m12n.ExtensionModule;
-import org.codehaus.groovy.runtime.m12n.ExtensionModuleRegistry;
+import org.codehaus.groovy.runtime.m12n.ExtensionModuleScanner;
 import org.codehaus.groovy.runtime.m12n.MetaInfExtensionModule;
 import org.codehaus.groovy.runtime.metaclass.MetaClassRegistryImpl;
 import org.codehaus.groovy.tools.GroovyClass;
 import org.objectweb.asm.Opcodes;
 
+import java.lang.ref.WeakReference;
 import java.lang.reflect.InvocationTargetException;
 import java.util.*;
 import java.util.concurrent.locks.ReentrantReadWriteLock;
@@ -150,36 +149,53 @@ public abstract class StaticTypeCheckingSupport {
     }
 
 
+    /**
+     * @deprecated Use {@link #findDGMMethodsForClassNode(ClassLoader,ClassNode,String)} instead
+     */
+    @Deprecated
     protected static Set<MethodNode> findDGMMethodsForClassNode(ClassNode clazz, String name) {
+        return findDGMMethodsForClassNode(MetaClassRegistryImpl.class.getClassLoader(), clazz,  name);
+    }
+
+    protected static Set<MethodNode> findDGMMethodsForClassNode(final ClassLoader loader, ClassNode clazz, String name) {
         TreeSet<MethodNode> accumulator = new TreeSet<MethodNode>(DGM_METHOD_NODE_COMPARATOR);
-        findDGMMethodsForClassNode(clazz, name, accumulator);
+        findDGMMethodsForClassNode(loader, clazz, name, accumulator);
         return accumulator;
     }
 
+
+    /**
+     * @deprecated Use {@link #findDGMMethodsForClassNode(ClassLoader, ClassNode, String, TreeSet)} instead
+     */
+    @Deprecated
     protected static void findDGMMethodsForClassNode(ClassNode clazz, String name, TreeSet<MethodNode> accumulator) {
-        List<MethodNode> fromDGM = EXTENSION_METHOD_CACHE.getExtensionMethods().get(clazz.getName());
+        findDGMMethodsForClassNode(MetaClassRegistryImpl.class.getClassLoader(), clazz, name, accumulator);
+    }
+
+    protected static void findDGMMethodsForClassNode(final ClassLoader loader, ClassNode clazz, String name, TreeSet<MethodNode> accumulator) {
+        List<MethodNode> fromDGM = EXTENSION_METHOD_CACHE.getExtensionMethods(loader).get(clazz.getName());
         if (fromDGM != null) {
             for (MethodNode node : fromDGM) {
                 if (node.getName().equals(name)) accumulator.add(node);
             }
         }
         for (ClassNode node : clazz.getInterfaces()) {
-            findDGMMethodsForClassNode(node, name, accumulator);
+            findDGMMethodsForClassNode(loader, node, name, accumulator);
         }
         if (clazz.isArray()) {
             ClassNode componentClass = clazz.getComponentType();
             if (!componentClass.equals(OBJECT_TYPE)) {
                 if (componentClass.isInterface() || componentClass.getSuperClass()==null) {
-                    findDGMMethodsForClassNode(OBJECT_TYPE.makeArray(), name, accumulator);
+                    findDGMMethodsForClassNode(loader, OBJECT_TYPE.makeArray(), name, accumulator);
                 } else {
-                    findDGMMethodsForClassNode(componentClass.getSuperClass().makeArray(), name, accumulator);
+                    findDGMMethodsForClassNode(loader, componentClass.getSuperClass().makeArray(), name, accumulator);
                 }
             }
         }
         if (clazz.getSuperClass() != null) {
-            findDGMMethodsForClassNode(clazz.getSuperClass(), name, accumulator);
+            findDGMMethodsForClassNode(loader, clazz.getSuperClass(), name, accumulator);
         } else if (!clazz.equals(ClassHelper.OBJECT_TYPE)) {
-            findDGMMethodsForClassNode(ClassHelper.OBJECT_TYPE, name, accumulator);
+            findDGMMethodsForClassNode(loader, ClassHelper.OBJECT_TYPE, name, accumulator);
         }
     }
 
@@ -810,13 +826,29 @@ public abstract class StaticTypeCheckingSupport {
         return Math.max(max, superClassMax);
     }
 
+    /**
+     * @deprecated Use {@link #findDGMMethodsByNameAndArguments(ClassLoader, org.codehaus.groovy.ast.ClassNode, String, org.codehaus.groovy.ast.ClassNode[], java.util.List)} instead
+     */
+    @Deprecated
     public static List<MethodNode> findDGMMethodsByNameAndArguments(final ClassNode receiver, final String name, final ClassNode[] args) {
-        return findDGMMethodsByNameAndArguments(receiver, name, args, new LinkedList<MethodNode>());
+        return findDGMMethodsByNameAndArguments(MetaClassRegistryImpl.class.getClassLoader(), receiver, name, args);
     }
 
+    public static List<MethodNode> findDGMMethodsByNameAndArguments(final ClassLoader loader, final ClassNode receiver, final String name, final ClassNode[] args) {
+        return findDGMMethodsByNameAndArguments(loader, receiver, name, args, new LinkedList<MethodNode>());
+    }
+
+    /**
+     * @deprecated Use {@link #findDGMMethodsByNameAndArguments(ClassLoader, org.codehaus.groovy.ast.ClassNode, String, org.codehaus.groovy.ast.ClassNode[], List)} instead
+     */
+    @Deprecated
     public static List<MethodNode> findDGMMethodsByNameAndArguments(final ClassNode receiver, final String name, final ClassNode[] args, final List<MethodNode> methods) {
+        return findDGMMethodsByNameAndArguments(MetaClassRegistryImpl.class.getClassLoader(), receiver, name, args, methods);
+    }
+
+    public static List<MethodNode> findDGMMethodsByNameAndArguments(final ClassLoader loader, final ClassNode receiver, final String name, final ClassNode[] args, final List<MethodNode> methods) {
         final List<MethodNode> chosen;
-        methods.addAll(findDGMMethodsForClassNode(receiver, name));
+        methods.addAll(findDGMMethodsForClassNode(loader, receiver, name));
 
         chosen = chooseBestMethod(receiver, methods, args);
         // specifically for DGM-like methods, we may have a generic type as the first argument of the DGM method
@@ -1150,34 +1182,33 @@ public abstract class StaticTypeCheckingSupport {
         private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
         private List<ExtensionModule> modules = Collections.emptyList();
         private Map<String, List<MethodNode>> cachedMethods = null;
+        private WeakReference<ClassLoader> origin = new WeakReference<ClassLoader>(null);
 
-        public Map<String, List<MethodNode>> getExtensionMethods() {
+        public Map<String, List<MethodNode>> getExtensionMethods(ClassLoader loader) {
             lock.readLock().lock();
-            MetaClassRegistry registry = GroovySystem.getMetaClassRegistry();
-            if (registry instanceof MetaClassRegistryImpl) {
-                MetaClassRegistryImpl impl = (MetaClassRegistryImpl) registry;
-                ExtensionModuleRegistry moduleRegistry = impl.getModuleRegistry();
-                if (!modules.equals(moduleRegistry.getModules())) {
-                    lock.readLock().unlock();
-                    lock.writeLock().lock();
-                    try {
-                        if (!modules.equals(moduleRegistry.getModules())) {
-                            modules = moduleRegistry.getModules();
-                            cachedMethods = getDGMMethods(registry);
+            if (loader!=origin.get()) {
+                lock.readLock().unlock();
+                lock.writeLock().lock();
+                try {
+                    final List<ExtensionModule> modules = new LinkedList<ExtensionModule>();
+                    ExtensionModuleScanner scanner = new ExtensionModuleScanner(new ExtensionModuleScanner.ExtensionModuleListener() {
+                        public void onModule(final ExtensionModule module) {
+                            boolean skip = false;
+                            for (ExtensionModule extensionModule : modules) {
+                                if (extensionModule.getName().equals(module.getName())) {
+                                    skip = true;
+                                    break;
+                                }
+                            }
+                            if (!skip) modules.add(module);
                         }
-                    } finally {
-                        lock.writeLock().unlock();
-                        lock.readLock().lock();
-                    }
-                } else if (cachedMethods==null) {
-                    lock.readLock().unlock();
-                    lock.writeLock().lock();
-                    try {
-                        cachedMethods = getDGMMethods(registry);
-                    } finally {
-                        lock.writeLock().unlock();
-                        lock.readLock().lock();
-                    }
+                    }, loader);
+                    scanner.scanClasspathModules();
+                    cachedMethods = getDGMMethods(modules);
+                    origin = new WeakReference<ClassLoader>(loader);
+                } finally {
+                    lock.writeLock().unlock();
+                    lock.readLock().lock();
                 }
             }
             try {
@@ -1192,20 +1223,16 @@ public abstract class StaticTypeCheckingSupport {
          * consists of a list of MethodNode, one for each default groovy method found
          * which is applicable for this class.
          * @return
-         * @param registry
+         * @param modules
          */
-        private static Map<String, List<MethodNode>> getDGMMethods(final MetaClassRegistry registry) {
+        private static Map<String, List<MethodNode>> getDGMMethods(List<ExtensionModule> modules) {
            Set<Class> instanceExtClasses = new LinkedHashSet<Class>();
            Set<Class> staticExtClasses = new LinkedHashSet<Class>();
-            if (registry instanceof MetaClassRegistryImpl) {
-                MetaClassRegistryImpl impl = (MetaClassRegistryImpl) registry;
-                List<ExtensionModule> modules = impl.getModuleRegistry().getModules();
-                for (ExtensionModule module : modules) {
-                    if (module instanceof MetaInfExtensionModule) {
-                        MetaInfExtensionModule extensionModule = (MetaInfExtensionModule) module;
-                        instanceExtClasses.addAll(extensionModule.getInstanceMethodsExtensionClasses());
-                        staticExtClasses.addAll(extensionModule.getStaticMethodsExtensionClasses());
-                    }
+            for (ExtensionModule module : modules) {
+                if (module instanceof MetaInfExtensionModule) {
+                    MetaInfExtensionModule extensionModule = (MetaInfExtensionModule) module;
+                    instanceExtClasses.addAll(extensionModule.getInstanceMethodsExtensionClasses());
+                    staticExtClasses.addAll(extensionModule.getStaticMethodsExtensionClasses());
                 }
             }
             Map<String, List<MethodNode>> methods = new HashMap<String, List<MethodNode>>();
diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index b5f41df45c..256a3ae4f3 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -981,7 +981,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                     }
                 }
                 // GROOVY-5568, the property may be defined by DGM
-                List<MethodNode> methods = findDGMMethodsByNameAndArguments(testClass, "get" + capName, ClassNode.EMPTY_ARRAY);
+                List<MethodNode> methods = findDGMMethodsByNameAndArguments(getSourceUnit().getClassLoader(), testClass, "get" + capName, ClassNode.EMPTY_ARRAY);
                 if (!methods.isEmpty()) {
                     List<MethodNode> methodNodes = chooseBestMethod(testClass, methods, ClassNode.EMPTY_ARRAY);
                     if (methodNodes.size() == 1) {
@@ -2820,7 +2820,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
         // perform a lookup in DGM methods
         methods.clear();
-        chosen = findDGMMethodsByNameAndArguments(receiver, name, args, methods);
+        chosen = findDGMMethodsByNameAndArguments(getSourceUnit().getClassLoader(), receiver, name, args, methods);
         if (!chosen.isEmpty()) {
             return chosen;
         }
