diff --git a/src/main/java/groovy/lang/MetaClassImpl.java b/src/main/java/groovy/lang/MetaClassImpl.java
index 6a51a9d62d..8e094440cc 100644
--- a/src/main/java/groovy/lang/MetaClassImpl.java
+++ b/src/main/java/groovy/lang/MetaClassImpl.java
@@ -1035,59 +1035,64 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
     }
 
     private Object invokeMethodClosure(Object object, Object[] arguments) {
-        final MethodClosure mc = (MethodClosure) object;
-        final Object owner = mc.getOwner();
+        MethodClosure mc = (MethodClosure) object;
 
+        Object owner = mc.getOwner();
         String methodName = mc.getMethod();
-        final Class ownerClass = owner instanceof Class ? (Class) owner : owner.getClass();
+        boolean ownerIsClass = (owner instanceof Class);
+        Class ownerClass = ownerIsClass ? (Class) owner : owner.getClass();
         final MetaClass ownerMetaClass = registry.getMetaClass(ownerClass);
 
-        // To conform to "Least Surprise" principle, try to invoke method with original arguments first, which can match most of use cases
         try {
             return ownerMetaClass.invokeMethod(ownerClass, owner, methodName, arguments, false, false);
+
         } catch (MissingMethodExceptionNoStack | InvokerInvocationException e) {
-            // CONSTRUCTOR REFERENCE
-            if (owner instanceof Class && MethodClosure.NEW.equals(methodName)) {
-                if (ownerClass.isArray()) {
-                    if (0 == arguments.length) {
-                        throw new GroovyRuntimeException("The arguments(specifying size) are required to create array[" + ownerClass.getCanonicalName() + "]");
-                    }
+            if (ownerIsClass) {
+                if (MethodClosure.NEW.equals(methodName)) { // CONSTRUCTOR REFERENCE
+                    if (!ownerClass.isArray()) {
+                        return ownerMetaClass.invokeConstructor(arguments);
 
-                    int arrayDimension = ArrayTypeUtils.dimension(ownerClass);
+                    } else {
+                        if (arguments.length == 0) {
+                            throw new GroovyRuntimeException("The arguments(specifying size) are required to create array[" + ownerClass.getCanonicalName() + "]");
+                        }
 
-                    if (arguments.length > arrayDimension) {
-                        throw new GroovyRuntimeException("The length[" + arguments.length + "] of arguments should not be greater than the dimensions[" + arrayDimension + "] of array[" + ownerClass.getCanonicalName() + "]");
-                    }
+                        int arrayDimension = ArrayTypeUtils.dimension(ownerClass);
 
-                    int[] sizeArray = new int[arguments.length];
+                        if (arguments.length > arrayDimension) {
+                            throw new GroovyRuntimeException("The length[" + arguments.length + "] of arguments should not be greater than the dimensions[" + arrayDimension + "] of array[" + ownerClass.getCanonicalName() + "]");
+                        }
 
-                    for (int i = 0, n = sizeArray.length; i < n; i++) {
-                        Object argument = arguments[i];
+                        int[] sizeArray = new int[arguments.length];
 
-                        if (argument instanceof Integer) {
-                            sizeArray[i] = (Integer) argument;
-                        } else {
-                            sizeArray[i] = Integer.parseInt(String.valueOf(argument));
+                        for (int i = 0, n = sizeArray.length; i < n; i += 1) {
+                            Object argument = arguments[i];
+                            if (argument instanceof Integer) {
+                                sizeArray[i] = (Integer) argument;
+                            } else {
+                                sizeArray[i] = Integer.parseInt(String.valueOf(argument));
+                            }
                         }
+
+                        Class arrayType = arguments.length == arrayDimension
+                                ? ArrayTypeUtils.elementType(ownerClass) // Just for better performance, though we can use reduceDimension only
+                                : ArrayTypeUtils.elementType(ownerClass, (arrayDimension - arguments.length));
+                        return Array.newInstance(arrayType, sizeArray);
                     }
+                } else if (ownerClass != Class.class) { // not "new"; maybe it's a reference to a Class method
+                    try {
+                        return InvokerHelper.getMetaClass(owner).invokeMethod(Class.class, owner, methodName, arguments, false, false);
 
-                    Class arrayType =
-                            arguments.length == arrayDimension
-                                    ? ArrayTypeUtils.elementType(ownerClass) // Just for better performance, though we can use reduceDimension only
-                                    : ArrayTypeUtils.elementType(ownerClass, (arrayDimension - arguments.length));
-                    return Array.newInstance(arrayType, sizeArray);
+                    } catch (MissingMethodExceptionNoStack nope) {
+                    }
                 }
-
-                return ownerMetaClass.invokeConstructor(arguments);
             }
 
             // METHOD REFERENCE
-            // if and only if the owner is a class and the method closure can be related to some instance methods,
-            // try to invoke method with adjusted arguments(first argument is the actual owner) again.
-            // otherwise throw the MissingMethodExceptionNoStack.
-            if (!(owner instanceof Class
-                    && (Boolean) mc.getProperty(MethodClosure.ANY_INSTANCE_METHOD_EXISTS))) {
-
+            // if the owner is a class and the method closure can be related to some instance method(s),
+            // try to invoke method with adjusted arguments -- first argument is instance of owner type;
+            // otherwise re-throw the exception
+            if (!(ownerIsClass && (Boolean) mc.getProperty(MethodClosure.ANY_INSTANCE_METHOD_EXISTS))) {
                 throw e;
             }
 
diff --git a/src/main/java/org/codehaus/groovy/classgen/asm/MethodPointerExpressionWriter.java b/src/main/java/org/codehaus/groovy/classgen/asm/MethodPointerExpressionWriter.java
index ba14cb4a12..d0bfd4f6bf 100644
--- a/src/main/java/org/codehaus/groovy/classgen/asm/MethodPointerExpressionWriter.java
+++ b/src/main/java/org/codehaus/groovy/classgen/asm/MethodPointerExpressionWriter.java
@@ -18,18 +18,19 @@
  */
 package org.codehaus.groovy.classgen.asm;
 
-import org.codehaus.groovy.ast.ClassHelper;
-import org.codehaus.groovy.ast.expr.Expression;
 import org.codehaus.groovy.ast.expr.MethodPointerExpression;
 import org.codehaus.groovy.runtime.ScriptBytecodeAdapter;
 
+import static org.codehaus.groovy.ast.ClassHelper.CLOSURE_TYPE;
+
 /**
- * A helper class used to generate bytecode for method pointer expressions.
+ * Generates bytecode for method pointer expressions.
+ *
  * @since 3.0.0
  */
 public class MethodPointerExpressionWriter {
-    // Closure
-    static final MethodCaller getMethodPointer = MethodCaller.newStatic(ScriptBytecodeAdapter.class, "getMethodPointer");
+
+    private static final MethodCaller getMethodPointer = MethodCaller.newStatic(ScriptBytecodeAdapter.class, "getMethodPointer");
 
     protected final WriterController controller;
 
@@ -37,12 +38,14 @@ public class MethodPointerExpressionWriter {
         this.controller = controller;
     }
 
-    public void writeMethodPointerExpression(MethodPointerExpression expression) {
-        Expression subExpression = expression.getExpression();
-        subExpression.visit(controller.getAcg());
-        controller.getOperandStack().box();
-        controller.getOperandStack().pushDynamicName(expression.getMethodName());
+    public void writeMethodPointerExpression(final MethodPointerExpression pointerOrReference) {
+        pointerOrReference.getExpression().visit(controller.getAcg());
+        OperandStack operandStack = controller.getOperandStack();
+        operandStack.box();
+
+        operandStack.pushDynamicName(pointerOrReference.getMethodName());
+        // delegate to ScriptBytecodeAdapter#getMethodPointer
         getMethodPointer.call(controller.getMethodVisitor());
-        controller.getOperandStack().replace(ClassHelper.CLOSURE_TYPE,2);
+        operandStack.replace(CLOSURE_TYPE, 2);
     }
 }
diff --git a/src/main/java/org/codehaus/groovy/classgen/asm/MethodReferenceExpressionWriter.java b/src/main/java/org/codehaus/groovy/classgen/asm/MethodReferenceExpressionWriter.java
index 8296e5f39f..3ef55a3c80 100644
--- a/src/main/java/org/codehaus/groovy/classgen/asm/MethodReferenceExpressionWriter.java
+++ b/src/main/java/org/codehaus/groovy/classgen/asm/MethodReferenceExpressionWriter.java
@@ -21,15 +21,17 @@ package org.codehaus.groovy.classgen.asm;
 import org.codehaus.groovy.ast.expr.MethodReferenceExpression;
 
 /**
- * A helper class used to generate bytecode for method reference expressions.
+ * Generates bytecode for method reference expressions.
+ *
  * @since 3.0.0
  */
 public class MethodReferenceExpressionWriter extends MethodPointerExpressionWriter {
+
     public MethodReferenceExpressionWriter(final WriterController controller) {
         super(controller);
     }
 
-    public void writeMethodReferenceExpression(MethodReferenceExpression expression) {
+    public void writeMethodReferenceExpression(final MethodReferenceExpression expression) {
         super.writeMethodPointerExpression(expression);
     }
 }
diff --git a/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesMethodReferenceExpressionWriter.java b/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesMethodReferenceExpressionWriter.java
index 24b6088a8d..6294174b93 100644
--- a/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesMethodReferenceExpressionWriter.java
+++ b/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesMethodReferenceExpressionWriter.java
@@ -60,7 +60,7 @@ import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.findDG
 import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.isAssignableTo;
 
 /**
- * Writer responsible for generating method reference in statically compiled mode.
+ * Generates bytecode for method reference expressions in statically-compiled code.
  *
  * @since 3.0.0
  */
diff --git a/src/main/java/org/codehaus/groovy/runtime/MethodClosure.java b/src/main/java/org/codehaus/groovy/runtime/MethodClosure.java
index 9c251c0d2b..eaad0bdeb0 100644
--- a/src/main/java/org/codehaus/groovy/runtime/MethodClosure.java
+++ b/src/main/java/org/codehaus/groovy/runtime/MethodClosure.java
@@ -23,70 +23,63 @@ import groovy.lang.MetaMethod;
 import org.codehaus.groovy.reflection.CachedConstructor;
 import org.codehaus.groovy.reflection.ReflectionCache;
 
-import java.io.IOException;
 import java.util.Arrays;
-import java.util.List;
 
 /**
- * Represents a method on an object using a closure which can be invoked
- * at any time
+ * Represents a method on an object using a closure, which can be invoked at any
+ * time.
  */
 public class MethodClosure extends Closure {
-    public static final String NEW = "new";
+
+    public static boolean ALLOW_RESOLVE; // choose readObject/readResolve return/throw
     public static final String ANY_INSTANCE_METHOD_EXISTS = "anyInstanceMethodExists";
+    public static final String NEW = "new";
+
+    //
 
     private static final long serialVersionUID = -2491254866810955844L;
-    public static boolean ALLOW_RESOLVE = false;
 
-    private static final Class[] EMPTY_CLASS_ARRAY = new Class[0];
+    /**
+     * Indicates if this may be related to an instance method.
+     */
+    private boolean anyInstanceMethodExists;
+
     private final String method;
-    private final boolean anyInstanceMethodExists; // whether the method closure is related to instance method
 
-    public MethodClosure(Object owner, String method) {
+    //--------------------------------------------------------------------------
+
+    public MethodClosure(final Object owner, final String method) {
         super(owner);
         this.method = method;
-
-        final Class clazz = owner.getClass() == Class.class ? (Class) owner : owner.getClass();
-
         this.maximumNumberOfParameters = 0;
-        this.parameterTypes = EMPTY_CLASS_ARRAY;
-
-        List<MetaMethod> methods = InvokerHelper.getMetaClass(clazz).respondsTo(owner, method);
+        this.parameterTypes = MetaClassHelper.EMPTY_TYPE_ARRAY;
 
-        int instanceMethodCnt = 0;
-        for (MetaMethod m : methods) {
-            Class[] newParameterTypes = this.makeParameterTypes(owner, m);
-
-            this.setParameterTypesAndNumber(newParameterTypes);
-
-            if (!m.isStatic()) {
-                instanceMethodCnt++;
-            }
-        }
-
-        this.anyInstanceMethodExists = instanceMethodCnt > 0;
+        Class<?> clazz = owner.getClass() == Class.class ? (Class<?>) owner : owner.getClass();
 
         if (NEW.equals(method)) {
             if (clazz.isArray()) {
-                Class[] sizeTypes = new Class[ArrayTypeUtils.dimension(clazz)];
+                Class<?>[] sizeTypes = new Class[ArrayTypeUtils.dimension(clazz)];
                 Arrays.fill(sizeTypes, int.class);
-
-                this.setParameterTypesAndNumber(sizeTypes);
+                setParameterTypesAndNumber(sizeTypes);
             } else {
                 for (CachedConstructor c : ReflectionCache.getCachedClass(clazz).getConstructors()) {
-                    Class[] newParameterTypes = c.getNativeParameterTypes();
-
-                    this.setParameterTypesAndNumber(newParameterTypes);
+                    setParameterTypesAndNumber(c.getNativeParameterTypes());
+                }
+            }
+        } else {
+            for (MetaMethod m : InvokerHelper.getMetaClass(clazz).respondsTo(owner, method)) {
+                setParameterTypesAndNumber(makeParameterTypes(owner, m));
+                if (!m.isStatic()) {
+                    this.anyInstanceMethodExists = true;
                 }
             }
         }
     }
 
-    private void setParameterTypesAndNumber(Class[] newParameterTypes) {
+    private void setParameterTypesAndNumber(final Class[] newParameterTypes) {
         if (!(newParameterTypes.length > this.maximumNumberOfParameters)) {
             return;
         }
-
         this.maximumNumberOfParameters = newParameterTypes.length;
         this.parameterTypes = newParameterTypes;
     }
@@ -97,7 +90,7 @@ public class MethodClosure extends Closure {
      * If the owner is a class instance(e.g. String) and the method is instance method,
      * we expand the original array of parameter type by inserting the owner at the first place of the expanded array
      */
-    private Class[] makeParameterTypes(Object owner, MetaMethod m) {
+    private Class[] makeParameterTypes(final Object owner, final MetaMethod m) {
         Class[] newParameterTypes;
 
         if (owner instanceof Class && !m.isStatic()) {
@@ -112,36 +105,41 @@ public class MethodClosure extends Closure {
 
         return newParameterTypes;
     }
-    
+
+    //--------------------------------------------------------------------------
+
     public String getMethod() {
         return method;
     }
 
-    // TODO confirm: The "doCall" method seems to be never called..., because MetaClassImpl.invokeMethod will intercept calls and return the result
-    protected Object doCall(Object arguments) {
-        return InvokerHelper.invokeMethod(getOwner(), method, arguments);
+    @Override
+    public Object getProperty(final String property) {
+        switch (property) {
+          case "method":
+            return getMethod();
+          case ANY_INSTANCE_METHOD_EXISTS:
+            return anyInstanceMethodExists;
+          default:
+            return super.getProperty(property);
+        }
     }
 
-    private Object readResolve() {
+    // TODO: This method seems to be never called..., because MetaClassImpl.invokeMethod will intercept calls and return the result.
+    protected Object doCall(final Object arguments) {
+        return InvokerHelper.invokeMethod(getOwner(), getMethod(), arguments);
+    }
+
+    private void readObject(final java.io.ObjectInputStream stream) throws java.io.IOException, ClassNotFoundException {
         if (ALLOW_RESOLVE) {
-            return this;
+            stream.defaultReadObject();
         }
         throw new UnsupportedOperationException();
     }
 
-    private void readObject(java.io.ObjectInputStream stream) throws IOException, ClassNotFoundException {
+    private Object readResolve() {
         if (ALLOW_RESOLVE) {
-            stream.defaultReadObject();
+            return this;
         }
         throw new UnsupportedOperationException();
     }
-    
-    @Override
-    public Object getProperty(String property) {
-        if ("method".equals(property)) {
-            return getMethod();
-        } else if (ANY_INSTANCE_METHOD_EXISTS.equals(property)) {
-            return this.anyInstanceMethodExists;
-        } else return super.getProperty(property);
-    }
 }
diff --git a/src/test/groovy/transform/stc/GenericsSTCTest.groovy b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
index 944b1f8788..788b2b1223 100644
--- a/src/test/groovy/transform/stc/GenericsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
@@ -250,14 +250,14 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
             assert result == [ 42 ]
         '''
 
-        ['n -> (N) n', '{ n -> (N) n }'].each { cast ->
+        ['t::cast', 'n -> (N) n', '{ n -> (N) n }'].each { cast ->
             assertScript """
                 Set<Number> f() {
                     Collections.<Number>singleton(42)
                 }
                 def <N extends Number> Set<N> g(Class<N> t) {
                     Set<N> result = new HashSet<>()
-                    f().stream().filter(n -> t.isInstance(n))
+                    f().stream().filter(t::isInstance)
                         .<N>map($cast).forEach(n -> result.add(n))
                     return result
                 }
diff --git a/src/test/groovy/transform/stc/MethodReferenceTest.groovy b/src/test/groovy/transform/stc/MethodReferenceTest.groovy
index a09ccb7030..89661aa43b 100644
--- a/src/test/groovy/transform/stc/MethodReferenceTest.groovy
+++ b/src/test/groovy/transform/stc/MethodReferenceTest.groovy
@@ -154,6 +154,34 @@ final class MethodReferenceTest {
         '''
     }
 
+    @Test // instance::instanceMethod -- GROOVY-10057
+    void testPredicateII() {
+        assertScript shell, '''
+            Class c = Integer
+            Predicate p
+
+            p = c::isInstance
+            assert p.test(null) == false
+            assert p.test('xx') == false
+            assert p.test(1234) == true
+
+            p = c.&isInstance
+            assert p.test(null) == false
+            assert p.test('xx') == false
+            assert p.test(1234) == true
+
+            p = o -> c.isInstance(o)
+            assert p.test(null) == false
+            assert p.test('xx') == false
+            assert p.test(1234) == true
+
+            p = { c.isInstance(it) }
+            assert p.test(null) == false
+            assert p.test('xx') == false
+            assert p.test(1234) == true
+        '''
+    }
+
     @Test // instance::instanceMethod
     void testBinaryOperatorII() {
         assertScript shell, '''
@@ -236,6 +264,47 @@ final class MethodReferenceTest {
         '''
     }
 
+    @Test // instance::instanceMethod
+    void testBinaryOperatorII_RHS() {
+        assertScript shell, '''
+            @CompileStatic
+            void p() {
+                Adder adder = new Adder()
+                BinaryOperator<BigDecimal> b = adder::add
+                def result = [1.0G, 2.0G, 3.0G].stream().reduce(0.0G, b)
+                assert 6.0G == result
+            }
+
+            p()
+
+            class Adder {
+                BigDecimal add(BigDecimal a, BigDecimal b) {
+                    a.add(b)
+                }
+            }
+        '''
+    }
+
+    @Test // expression::instanceMethod
+    void testBinaryOperatorII_RHS2() {
+        assertScript shell, '''
+            @CompileStatic
+            void p() {
+                BinaryOperator<BigDecimal> b = new Adder()::add
+                def result = [1.0G, 2.0G, 3.0G].stream().reduce(0.0G, b)
+                assert 6.0G == result
+            }
+
+            p()
+
+            class Adder {
+                BigDecimal add(BigDecimal a, BigDecimal b) {
+                    a.add(b)
+                }
+            }
+        '''
+    }
+
     @Test // instance::staticMethod
     void testBinaryOperatorIS() {
         assertScript shell, '''
@@ -452,47 +521,6 @@ final class MethodReferenceTest {
         '''
     }
 
-    @Test // instance::instanceMethod
-    void testBinaryOperatorII_RHS() {
-        assertScript shell, '''
-            @CompileStatic
-            void p() {
-                Adder adder = new Adder()
-                BinaryOperator<BigDecimal> b = adder::add
-                def result = [1.0G, 2.0G, 3.0G].stream().reduce(0.0G, b)
-                assert 6.0G == result
-            }
-
-            p()
-
-            class Adder {
-                BigDecimal add(BigDecimal a, BigDecimal b) {
-                    a.add(b)
-                }
-            }
-        '''
-    }
-
-    @Test // expression::instanceMethod
-    void testBinaryOperatorII_RHS2() {
-        assertScript shell, '''
-            @CompileStatic
-            void p() {
-                BinaryOperator<BigDecimal> b = new Adder()::add
-                def result = [1.0G, 2.0G, 3.0G].stream().reduce(0.0G, b)
-                assert 6.0G == result
-            }
-
-            p()
-
-            class Adder {
-                BigDecimal add(BigDecimal a, BigDecimal b) {
-                    a.add(b)
-                }
-            }
-        '''
-    }
-
     @Test // class::new
     void testFunctionCN_RHS() {
         assertScript shell, '''
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/GenericsStaticCompileTest.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/GenericsStaticCompileTest.groovy
index d8c10e6b12..4a599b2827 100644
--- a/src/test/org/codehaus/groovy/classgen/asm/sc/GenericsStaticCompileTest.groovy
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/GenericsStaticCompileTest.groovy
@@ -24,22 +24,4 @@ import groovy.transform.stc.GenericsSTCTest
  * Unit tests for static compilation : generics.
  */
 class GenericsStaticCompileTest extends GenericsSTCTest implements StaticCompilationTestSupport {
-
-    // GROOVY-10053
-    void testReturnTypeInferenceWithMethodGenericsSC() {
-        assertScript """
-            Set<Number> f() {
-                Collections.<Number>singleton(42)
-            }
-            def <N extends Number> Set<N> g(Class<N> t) {
-                Set<N> result = new HashSet<>()
-                f().stream().filter(n -> t.isInstance(n))
-                    .<N>map(t::cast).forEach(n -> result.add(n))
-                return result
-            }
-
-            def result = g(Integer)
-            assert result == [42] as Set
-        """
-    }
 }
