diff --git a/subprojects/groovy-groovysh/src/main/groovy/org/codehaus/groovy/tools/shell/completion/GroovySyntaxCompletor.groovy b/subprojects/groovy-groovysh/src/main/groovy/org/codehaus/groovy/tools/shell/completion/GroovySyntaxCompletor.groovy
index e080f759fd..95d087b6d4 100644
--- a/subprojects/groovy-groovysh/src/main/groovy/org/codehaus/groovy/tools/shell/completion/GroovySyntaxCompletor.groovy
+++ b/subprojects/groovy-groovysh/src/main/groovy/org/codehaus/groovy/tools/shell/completion/GroovySyntaxCompletor.groovy
@@ -45,7 +45,9 @@ class GroovySyntaxCompletor implements Completer {
         SECOND_IDENT,
         NO_COMPLETION,
         DOT_LAST,
+        SPREAD_DOT_LAST,
         PREFIX_AFTER_DOT,
+        PREFIX_AFTER_SPREAD_DOT,
         NO_DOT_PREFIX
     }
 
@@ -104,6 +106,8 @@ class GroovySyntaxCompletor implements Completer {
                 break
             case CompletionCase.DOT_LAST:
             case CompletionCase.PREFIX_AFTER_DOT:
+            case CompletionCase.SPREAD_DOT_LAST:
+            case CompletionCase.PREFIX_AFTER_SPREAD_DOT:
                 result = reflectionCompletor.complete(tokens, candidates)
                 break
             default:
@@ -131,6 +135,12 @@ class GroovySyntaxCompletor implements Completer {
                     return CompletionCase.NO_COMPLETION
                 }
                 return CompletionCase.PREFIX_AFTER_DOT
+            } else if (previousToken.type == SPREAD_DOT) {
+                    // we have a dot, so need to evaluate the statement up to the dot for completion
+                    if (tokens.size() < 3) {
+                        return CompletionCase.NO_COMPLETION
+                    }
+                    return CompletionCase.PREFIX_AFTER_SPREAD_DOT
             } else {
                 // no dot, so we complete a varname, classname, or similar
                 switch (previousToken.type) {
@@ -173,6 +183,14 @@ class GroovySyntaxCompletor implements Completer {
                 return CompletionCase.NO_COMPLETION
             }
             return CompletionCase.DOT_LAST
+        } else if (currentToken.type == SPREAD_DOT) {
+            // cursor is on spread-dot, so need to evaluate the statement up to the dot for completion
+            if (tokens.size() == 1) {
+                return CompletionCase.NO_COMPLETION
+            }
+            return CompletionCase.SPREAD_DOT_LAST
+        } else {
+            println(currentToken.type)
         }
         return CompletionCase.NO_COMPLETION
     }
diff --git a/subprojects/groovy-groovysh/src/main/groovy/org/codehaus/groovy/tools/shell/completion/ReflectionCompletor.groovy b/subprojects/groovy-groovysh/src/main/groovy/org/codehaus/groovy/tools/shell/completion/ReflectionCompletor.groovy
index d30e353fc1..b7d59e1564 100644
--- a/subprojects/groovy-groovysh/src/main/groovy/org/codehaus/groovy/tools/shell/completion/ReflectionCompletor.groovy
+++ b/subprojects/groovy-groovysh/src/main/groovy/org/codehaus/groovy/tools/shell/completion/ReflectionCompletor.groovy
@@ -56,21 +56,35 @@ class ReflectionCompletor {
         if (tokens.size() < 2) {
             throw new IllegalArgumentException('must be invoked with at least 2 tokens, one of which is dot' + tokens*.text)
         }
-        if (tokens.last().type == DOT || tokens.last().type == OPTIONAL_DOT) {
+        if (tokens.last().type == DOT || tokens.last().type == OPTIONAL_DOT || tokens.last().type == SPREAD_DOT) {
             dotToken = tokens.last()
             previousTokens = tokens[0..-2]
         } else {
-            if (tokens[-2].type != DOT && tokens[-2].type != OPTIONAL_DOT) {
+            if (tokens[-2].type != DOT && tokens[-2].type != OPTIONAL_DOT && tokens[-2].type != SPREAD_DOT) {
                 throw new IllegalArgumentException('must be invoked with token list with dot at last position or one position before' + tokens*.text)
             }
             currentElementToken = tokens.last()
             dotToken = tokens[-2]
             previousTokens = tokens[0..-3]
         }
-        Object instance = getInvokerClassOrInstance(previousTokens)
-        if (instance == null) {
+
+        Object instanceOrClass = getInvokerClassOrInstance(previousTokens)
+        if (instanceOrClass == null) {
             return -1
         }
+        if (dotToken.type == SPREAD_DOT) {
+            /**
+             * for aggregate types, find an arbitrary collection-member
+             * element within the instance. This may cause invalid completion candidates when the collection is not
+             * homogenous, but still better than no completion at all. Alternatively the union or intersection of
+             * candidate completions could be built. For non-aggregate types, we assume that whatever find()
+             * returns is useful for *. completion as well.
+             */
+            instanceOrClass = instanceOrClass.find()
+            if (instanceOrClass == null) {
+                return -1
+            }
+        }
 
         String identifierPrefix
         if (currentElementToken) {
@@ -79,15 +93,23 @@ class ReflectionCompletor {
             identifierPrefix = ''
         }
 
+        return completeInstanceMembers(instanceOrClass, identifierPrefix, candidates, currentElementToken, dotToken)
+    }
+
+    private int completeInstanceMembers(final Object instanceOrClass,
+                                final String identifierPrefix,
+                                final List<CharSequence> candidates,
+                                final GroovySourceToken currentElementToken,
+                                final GroovySourceToken dotToken) {
         // look for public methods/fields that match the prefix
-        Collection<ReflectionCompletionCandidate> myCandidates = getPublicFieldsAndMethods(instance, identifierPrefix)
+        Collection<ReflectionCompletionCandidate> myCandidates = getPublicFieldsAndMethods(instanceOrClass, identifierPrefix)
 
         boolean showAllMethods = (identifierPrefix.length() >= Integer.valueOf(Preferences.get(Groovysh.METACLASS_COMPLETION_PREFIX_LENGTH_PREFERENCE_KEY, '3')))
         // Also add metaclass methods if prefix is long enough (user would usually not care about those)
         myCandidates.addAll(getMetaclassMethods(
-                instance,
+                instanceOrClass,
                 identifierPrefix,
-                showAllMethods).collect({String it -> new ReflectionCompletionCandidate(it)}))
+                showAllMethods).collect({ String it -> new ReflectionCompletionCandidate(it) }))
 
         if (!showAllMethods) {
             // user probably does not care to see default Object / GroovyObject Methods,
@@ -96,8 +118,8 @@ class ReflectionCompletor {
         }
 
         // specific DefaultGroovyMethods only suggested for suitable instances
-        myCandidates.addAll(getDefaultMethods(instance,
-                identifierPrefix).collect({String it -> new ReflectionCompletionCandidate(it, AnsiRenderer.Code.BLUE.name())}))
+        myCandidates.addAll(getDefaultMethods(instanceOrClass,
+                identifierPrefix).collect({ String it -> new ReflectionCompletionCandidate(it, AnsiRenderer.Code.BLUE.name()) }))
 
         if (myCandidates.size() > 0) {
             myCandidates = myCandidates.sort()
@@ -116,7 +138,8 @@ class ReflectionCompletor {
             if (currentElementToken && dotToken.line != currentElementToken.line) {
                 lastDot = currentElementToken.column - 1
             } else {
-                lastDot = dotToken.column
+                // Spread-dot has length 2!
+                lastDot = dotToken.column +(dotToken.getText().length() - 1)
             }
             return lastDot
         }
diff --git a/subprojects/groovy-groovysh/src/test/groovy/org/codehaus/groovy/tools/shell/completion/GroovySyntaxCompletorTest.groovy b/subprojects/groovy-groovysh/src/test/groovy/org/codehaus/groovy/tools/shell/completion/GroovySyntaxCompletorTest.groovy
index 096c88bd89..aefa6a8536 100644
--- a/subprojects/groovy-groovysh/src/test/groovy/org/codehaus/groovy/tools/shell/completion/GroovySyntaxCompletorTest.groovy
+++ b/subprojects/groovy-groovysh/src/test/groovy/org/codehaus/groovy/tools/shell/completion/GroovySyntaxCompletorTest.groovy
@@ -96,6 +96,21 @@ class GroovySyntaxCompletorTest extends CompletorTestSupport {
         }
     }
 
+    void testMemberSpreadDot() {
+        reflectionCompletorMocker.demand.complete(1) { tokens, candidates ->
+            assert(tokens.collect{it.getText()} == ['[', 'foo', ']', '*.', 'len']); candidates << "length()"; 9}
+        IdentifierCompletor mockIdCompletor = idCompletorMocker.proxyDelegateInstance()
+        groovyshMocker.use {
+            Groovysh groovyshMock = new Groovysh()
+            ReflectionCompletor mockReflComp = reflectionCompletorMocker.proxyInstance(groovyshMock)
+            GroovySyntaxCompletor completor = new GroovySyntaxCompletor(groovyshMock, mockReflComp, [mockIdCompletor], null)
+            def candidates = []
+            String buffer = "['foo']*.len"
+            assert 9 == completor.complete(buffer, buffer.length(), candidates)
+            assert ["length()"] == candidates
+        }
+    }
+
     void testMemberAfterMethod() {
         reflectionCompletorMocker.demand.complete(1) { tokens, candidates ->
             assert(tokens.collect{it.getText()} == ["Fo", ".", "ba", "(", ")", ".", "xyz"]); candidates << "xyzabc"; 0}
