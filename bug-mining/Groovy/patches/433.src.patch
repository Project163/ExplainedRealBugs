diff --git a/src/main/groovy/lang/ExpandoMetaClass.java b/src/main/groovy/lang/ExpandoMetaClass.java
index 279321e0d1..1493061d88 100644
--- a/src/main/groovy/lang/ExpandoMetaClass.java
+++ b/src/main/groovy/lang/ExpandoMetaClass.java
@@ -47,7 +47,7 @@ import java.util.*;
  * // defines a new static method with the 'static' qualifier
  * metaClass.'static'.myMethod << { args ->  }
  *
- * // defines a new contructor
+ * // defines a new constructor
  * metaClass.constructor << { String arg -> }
  *
  * // defines or replaces a constructor
diff --git a/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java b/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java
index 44f9623a14..7a1ae91e78 100644
--- a/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java
+++ b/src/main/org/codehaus/groovy/antlr/AntlrParserPlugin.java
@@ -1968,7 +1968,7 @@ public class AntlrParserPlugin extends ASTHelper implements ParserPlugin, Groovy
         Expression ret = expression;
         //FIXME: do we really want this() to create a new object regardless
         // the position.. for example not as first statement in a constructor
-        // this=first statement in contructor is handled by specialConstructorCallExpression
+        // this=first statement in constructor is handled by specialConstructorCallExpression
         // we may have to add a check and remove this part of the code
         if (implicitThis && "this".equals(expression.getMethodAsString())) {
             ret = new ConstructorCallExpression(this.classNode, arguments);
diff --git a/src/main/org/codehaus/groovy/classgen/VariableScopeVisitor.java b/src/main/org/codehaus/groovy/classgen/VariableScopeVisitor.java
index d80c9ec65d..e8b57a2c81 100644
--- a/src/main/org/codehaus/groovy/classgen/VariableScopeVisitor.java
+++ b/src/main/org/codehaus/groovy/classgen/VariableScopeVisitor.java
@@ -58,7 +58,7 @@ public class VariableScopeVisitor extends ClassCodeVisitorSupport {
     private SourceUnit source;
     private boolean inClosure = false;
     private boolean inPropertyExpression = false;
-    private boolean isSpecialContructorCall = false;
+    private boolean isSpecialConstructorCall = false;
 
     private LinkedList stateStack = new LinkedList();
 
@@ -261,7 +261,7 @@ public class VariableScopeVisitor extends ClassCodeVisitorSupport {
             if (classScope != null) {
                 Variable member = findClassMember(classScope, var.getName());
                 if (member != null) {
-                    boolean cc = currentScope.isInStaticContext() || isSpecialContructorCall;
+                    boolean cc = currentScope.isInStaticContext() || isSpecialConstructorCall;
                     boolean cm = member.isInStaticContext();
                     //
                     // we don't allow access from dynamic context to static context
@@ -494,9 +494,9 @@ public class VariableScopeVisitor extends ClassCodeVisitorSupport {
     }
 
     public void visitConstructorCallExpression(ConstructorCallExpression call) {
-        isSpecialContructorCall = call.isSpecialCall();
+        isSpecialConstructorCall = call.isSpecialCall();
         super.visitConstructorCallExpression(call);
-        isSpecialContructorCall = false;
+        isSpecialConstructorCall = false;
     }
 
     public void visitProperty(PropertyNode node) {
diff --git a/src/main/org/codehaus/groovy/control/ResolveVisitor.java b/src/main/org/codehaus/groovy/control/ResolveVisitor.java
index d03016f39f..f5fe888905 100644
--- a/src/main/org/codehaus/groovy/control/ResolveVisitor.java
+++ b/src/main/org/codehaus/groovy/control/ResolveVisitor.java
@@ -58,7 +58,7 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
     private boolean isTopLevelProperty = true;
     private boolean inPropertyExpression = false;
     private boolean inClosure = false;
-    private boolean isSpecialContructorCall = false;
+    private boolean isSpecialConstructorCall = false;
 
     private Map genericParameterNames = new HashMap();
 
@@ -621,9 +621,9 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
     protected Expression transformConstructorCallExpression(ConstructorCallExpression cce) {
         ClassNode type = cce.getType();
         resolveOrFail(type, cce);
-        isSpecialContructorCall = cce.isSpecialCall();
+        isSpecialConstructorCall = cce.isSpecialCall();
         Expression ret = cce.transformExpression(this);
-        isSpecialContructorCall = false;
+        isSpecialConstructorCall = false;
         return ret;
     }
 
diff --git a/src/main/org/codehaus/groovy/control/StaticImportVisitor.java b/src/main/org/codehaus/groovy/control/StaticImportVisitor.java
index 1f68c1c2a6..1b9d9ef76a 100644
--- a/src/main/org/codehaus/groovy/control/StaticImportVisitor.java
+++ b/src/main/org/codehaus/groovy/control/StaticImportVisitor.java
@@ -32,7 +32,8 @@ public class StaticImportVisitor extends ClassCodeExpressionTransformer {
     private SourceUnit source;
     private CompilationUnit compilationUnit;
     private boolean stillResolving;
-    private boolean inSpecialContructorCall;
+    private boolean inSpecialConstructorCall;
+    private ClassNode lastFoundConstructorType;
     private boolean inClosure;
     private boolean inPropertyExpression;
     private Expression foundConstant;
@@ -87,7 +88,7 @@ public class StaticImportVisitor extends ClassCodeExpressionTransformer {
         if (v != null && v instanceof DynamicVariable) {
             Expression result = findStaticFieldImportFromModule(v.getName());
             if (result != null) return result;
-            if (!inPropertyExpression || inSpecialContructorCall) addStaticVariableError(ve);
+            if (!inPropertyExpression || inSpecialConstructorCall) addStaticVariableError(ve);
         }
         return ve;
     }
@@ -100,6 +101,15 @@ public class StaticImportVisitor extends ClassCodeExpressionTransformer {
             if (ret != null) {
                 return ret;
             }
+            if (inSpecialConstructorCall
+                    && method instanceof ConstantExpression
+                    && lastFoundConstructorType != null) {
+                ConstantExpression ce = (ConstantExpression) method;
+                Object value = ce.getValue();
+                if (value instanceof String) {
+                    return new StaticMethodCallExpression(lastFoundConstructorType, (String) value, args);
+                }
+            }
         }
         Expression object = transform(mce.getObjectExpression());
         mce.setObjectExpression(object);
@@ -109,9 +119,12 @@ public class StaticImportVisitor extends ClassCodeExpressionTransformer {
     }
 
     protected Expression transformConstructorCallExpression(ConstructorCallExpression cce) {
-        inSpecialContructorCall = cce.isSpecialCall();
+        inSpecialConstructorCall = cce.isSpecialCall();
         Expression ret = cce.transformExpression(this);
-        inSpecialContructorCall = false;
+        if (!inSpecialConstructorCall) {
+            lastFoundConstructorType = ret.getType();
+        }
+        inSpecialConstructorCall = false;
         return ret;
     }
 
@@ -130,9 +143,9 @@ public class StaticImportVisitor extends ClassCodeExpressionTransformer {
         Expression oldFoundArgs = foundArgs;
         Expression oldFoundMethod = foundConstant;
         inPropertyExpression = true;
-        Expression objectExpression = transform(pe.getObjectExpression());
         foundArgs = null;
         foundConstant = null;
+        Expression objectExpression = transform(pe.getObjectExpression());
         if (foundArgs != null && foundConstant != null) {
             Expression result = findStaticMethodImportFromModule(foundConstant, foundArgs);
             if (result != null) {
@@ -143,7 +156,7 @@ public class StaticImportVisitor extends ClassCodeExpressionTransformer {
         foundArgs = oldFoundArgs;
         foundConstant = oldFoundMethod;
         pe.setObjectExpression(objectExpression);
-        if (!inSpecialContructorCall) checkStaticScope(pe);
+        if (!inSpecialConstructorCall) checkStaticScope(pe);
         return pe;
     }
 
@@ -161,7 +174,7 @@ public class StaticImportVisitor extends ClassCodeExpressionTransformer {
     private void addStaticVariableError(VariableExpression ve) {
         // closures are always dynamic
         // propertiesExpressions will handle the error a bit different
-        if (!inSpecialContructorCall && (inClosure || !ve.isInStaticContext())) return;
+        if (!inSpecialConstructorCall && (inClosure || !ve.isInStaticContext())) return;
         if (stillResolving) return;
         if (ve == VariableExpression.THIS_EXPRESSION || ve == VariableExpression.SUPER_EXPRESSION) return;
         Variable v = ve.getAccessedVariable();
diff --git a/src/main/org/codehaus/groovy/reflection/CachedClass.java b/src/main/org/codehaus/groovy/reflection/CachedClass.java
index fdf32034d3..7b5d0c18a2 100644
--- a/src/main/org/codehaus/groovy/reflection/CachedClass.java
+++ b/src/main/org/codehaus/groovy/reflection/CachedClass.java
@@ -145,10 +145,10 @@ public class CachedClass {
 
     public CachedConstructor[] getConstructors() {
         if (constructors == null) {
-            final Constructor[] declaredContructors = getCachedClass().getDeclaredConstructors();
-            constructors = new CachedConstructor[declaredContructors.length];
+            final Constructor[] declaredConstructors = getCachedClass().getDeclaredConstructors();
+            constructors = new CachedConstructor[declaredConstructors.length];
             for (int i = 0; i != constructors.length; ++i)
-                constructors[i] = new CachedConstructor(this, declaredContructors[i]);
+                constructors[i] = new CachedConstructor(this, declaredConstructors[i]);
         }
         return constructors;
     }
diff --git a/src/main/org/codehaus/groovy/tools/javac/JavaStubGenerator.java b/src/main/org/codehaus/groovy/tools/javac/JavaStubGenerator.java
index 34ee34f27b..919a111eb0 100644
--- a/src/main/org/codehaus/groovy/tools/javac/JavaStubGenerator.java
+++ b/src/main/org/codehaus/groovy/tools/javac/JavaStubGenerator.java
@@ -137,7 +137,7 @@ public class JavaStubGenerator
     }
 
     private void genMethods(ClassNode classNode, PrintWriter out) {
-        getContructors(classNode, out);
+        getConstructors(classNode, out);
 
         List methods = classNode.getMethods();
         if (methods != null)
@@ -147,7 +147,7 @@ public class JavaStubGenerator
             }
     }
 
-    private void getContructors(ClassNode classNode, PrintWriter out) {
+    private void getConstructors(ClassNode classNode, PrintWriter out) {
         List constrs = classNode.getDeclaredConstructors();
         if (constrs != null)
             for (Iterator it = constrs.iterator(); it.hasNext();) {
@@ -295,7 +295,7 @@ public class JavaStubGenerator
         else {
             out.println(" {");
 
-            genSpecialContructorArgs(out, constructorNode, constrCall);
+            genSpecialConstructorArgs(out, constructorNode, constrCall);
 
             out.println("}");
         }
@@ -339,7 +339,7 @@ public class JavaStubGenerator
         return null;
     }
 
-    private void genSpecialContructorArgs(PrintWriter out, ConstructorNode node, ConstructorCallExpression constrCall) {
+    private void genSpecialConstructorArgs(PrintWriter out, ConstructorNode node, ConstructorCallExpression constrCall) {
         // Select a constructor from our class, or super-class which is legal to call,
         // then write out an invoke w/nulls using casts to avoid abigous crapo
 
diff --git a/src/test/groovy/OuterUser.java b/src/test/groovy/OuterUser.java
index e5bf788f0a..ba00a269db 100644
--- a/src/test/groovy/OuterUser.java
+++ b/src/test/groovy/OuterUser.java
@@ -1,7 +1,7 @@
 package groovy;
 
 /**
- * <p>Sample class used for testing that groovy can call inner classes contructors.</p>
+ * <p>Sample class used for testing that groovy can call inner classes constructors.</p>
  *
  * @author Guillaume Laforge
  * @cvs.revision $Revision$
