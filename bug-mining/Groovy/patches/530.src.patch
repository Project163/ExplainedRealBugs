diff --git a/src/main/org/codehaus/groovy/runtime/ScriptBytecodeAdapter.java b/src/main/org/codehaus/groovy/runtime/ScriptBytecodeAdapter.java
index 88ae1f3657..f7ded066f5 100644
--- a/src/main/org/codehaus/groovy/runtime/ScriptBytecodeAdapter.java
+++ b/src/main/org/codehaus/groovy/runtime/ScriptBytecodeAdapter.java
@@ -16,6 +16,7 @@
 package org.codehaus.groovy.runtime;
 
 import groovy.lang.*;
+
 import org.codehaus.groovy.runtime.metaclass.MissingMethodExceptionNoStack;
 import org.codehaus.groovy.runtime.metaclass.MissingPropertyExceptionNoStack;
 import org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation;
@@ -64,10 +65,11 @@ public class ScriptBytecodeAdapter {
     //  --------------------------------------------------------
     public static Object invokeMethodOnCurrentN(Class senderClass, GroovyObject receiver, String messageName, Object[] messageArguments) throws Throwable {
         Object result = null;
+        boolean intercepting = receiver instanceof GroovyInterceptable;
         try {
             try {
                 // if it's a pure interceptable object (even intercepting toString(), clone(), ...)
-                if (receiver instanceof GroovyInterceptable) {
+                if (intercepting) {
                     result = receiver.invokeMethod(messageName, messageArguments);
                 }
                 //else if there's a statically typed method or a GDK method
@@ -75,7 +77,7 @@ public class ScriptBytecodeAdapter {
                     result = receiver.getMetaClass().invokeMethod(senderClass, receiver, messageName, messageArguments, false, true);
                 }
             } catch (MissingMethodException e) {
-                if (receiver.getClass() == e.getType() && e.getMethod().equals(messageName)) {
+                if (!intercepting && receiver.getClass() == e.getType() && e.getMethod().equals(messageName)) {
                     // in case there's nothing else, invoke the object's own invokeMethod()
                     result = receiver.invokeMethod(messageName, messageArguments);
                 } else {
diff --git a/src/test/groovy/GroovyInterceptableTest.groovy b/src/test/groovy/GroovyInterceptableTest.groovy
index 9e6ca6c119..a8ae0efb19 100644
--- a/src/test/groovy/GroovyInterceptableTest.groovy
+++ b/src/test/groovy/GroovyInterceptableTest.groovy
@@ -19,6 +19,18 @@ class GroovyInterceptableTest extends GroovyTestCase {
         // should this be 1 or 90?
         assert g.getFoo() == 1
     }
+    
+    void testCallMissingMethod() {
+        def obj = new GI2()
+        shouldFail { obj.notAMethod() }
+        assert 'missing' == obj.result 
+    }
+ 
+    void testCallMissingMethodFromInstance() {
+        def obj = new GI2()
+        shouldFail { obj.method() }
+        assert 'missing' == obj.result
+   }
 }
 
 class GI implements GroovyInterceptable {
@@ -38,3 +50,17 @@ class GI implements GroovyInterceptable {
     }
 }
 
+
+class GI2 implements GroovyInterceptable {
+  def result = ""
+  def invokeMethod(String name, args) {
+    def metaMethod = Foo.metaClass.getMetaMethod(name, args)
+    if (metaMethod != null) return metaMethod.invoke(this, args)
+    result += "missing"
+    throw new MissingMethodException(name, Foo.class, args)
+  }
+  
+  def method() {
+      notAMethod()
+  }
+}
