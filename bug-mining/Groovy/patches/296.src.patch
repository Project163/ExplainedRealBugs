diff --git a/src/main/groovy/xml/DOMBuilder.java b/src/main/groovy/xml/DOMBuilder.java
index 71ef540099..cba7275f21 100644
--- a/src/main/groovy/xml/DOMBuilder.java
+++ b/src/main/groovy/xml/DOMBuilder.java
@@ -157,8 +157,8 @@ public class DOMBuilder extends BuilderSupport {
                     throw new IllegalArgumentException("The value of the xmlns attribute must be a Map of QNames to String URIs");
                 }
             } else {
-                // TODO handle null values and treat as ''
-                element.setAttribute(attrName, value.toString());
+                String valueText = (value != null) ? value.toString() : "";
+                element.setAttribute(attrName, valueText);
             }
         }
         return element;
diff --git a/src/main/groovy/xml/StreamingDOMBuilder.groovy b/src/main/groovy/xml/StreamingDOMBuilder.groovy
index 01320e0283..78fc48df55 100644
--- a/src/main/groovy/xml/StreamingDOMBuilder.groovy
+++ b/src/main/groovy/xml/StreamingDOMBuilder.groovy
@@ -73,7 +73,7 @@ class StreamingDOMBuilder extends AbstractStreamingBuilder {
                 }
                 pi = dom.document.createProcessingInstruction(target, buf.toString())
             } else {
-                pi =dom.document.createProcessingInstruction(target, instruction)
+                pi = dom.document.createProcessingInstruction(target, instruction)
             }
             if (pi != null) {
                 dom.element.appendChild(pi)
@@ -102,105 +102,102 @@ class StreamingDOMBuilder extends AbstractStreamingBuilder {
         }
     }
     def tagClosure = {tag, doc, pendingNamespaces, namespaces, namespaceSpecificTags, prefix, attrs, body, dom ->
-                    def attributes = []
-                    def nsAttributes = []
+        def attributes = []
+        def nsAttributes = []
 
-                    attrs.each {key, value ->
-                        if (key.contains('$')) {
-                            def parts = key.tokenize('$')
-                            def namespaceUri = null
+        attrs.each {key, value ->
+            if (key.contains('$')) {
+                def parts = key.tokenize('$')
+                def namespaceUri = null
 
-                            if (namespaces.containsKey(parts[0])) {
-                                namespaceUri = namespaces[parts[0]]
+                if (namespaces.containsKey(parts[0])) {
+                    namespaceUri = namespaces[parts[0]]
 
-                                nsAttributes.add([namespaceUri, "${parts[0]}:${parts[1]}", value])
+                    nsAttributes.add([namespaceUri, "${parts[0]}:${parts[1]}", value])
 
-                            } else {
-                                throw new GroovyRuntimeException("bad attribute namespace tag in ${key}")
-                            }
-                        } else {
-                            attributes.add([key, value])
-                        }
-                    }
+                } else {
+                    throw new GroovyRuntimeException("bad attribute namespace tag in ${key}")
+                }
+            } else {
+                attributes.add([key, value])
+            }
+        }
 
-                    def hiddenNamespaces = [:]
+        def hiddenNamespaces = [:]
 
-                    pendingNamespaces.each {key, value ->
-                        hiddenNamespaces[key] = namespaces[key]
-                        namespaces[key] = value
-                        nsAttributes.add(["http://www.w3.org/2000/xmlns/", "xmlns:${key}", value])
+        pendingNamespaces.each {key, value ->
+            hiddenNamespaces[key] = namespaces[key]
+            namespaces[key] = value
+            nsAttributes.add(["http://www.w3.org/2000/xmlns/", "xmlns:${key}", value])
 
-                    }
+        }
 
-                    // setup the tag info
-
-                    def uri = ""
-                    def qualifiedName = tag
-
-                    if (prefix != "") {
-                        if (namespaces.containsKey(prefix)) {
-                            uri = namespaces[prefix]
-                        } else if (pendingNamespaces.containsKey(prefix)) {
-                            uri = pendingNamespaces[prefix]
-                        } else {
-                            throw new GroovyRuntimeException("Namespace prefix: ${prefix} is not bound to a URI")
-                        }
-                        if (prefix != ":") {
-                            qualifiedName = prefix + ":" + tag
-                        }
-                    }
+        // setup the tag info
 
-                    def element = dom.document.createElementNS(uri, qualifiedName)
+        def uri = ""
+        def qualifiedName = tag
 
-                    nsAttributes.each {
-                        element.setAttributeNS(it[0], it[1], it[2])
-                    }
-                    attributes.each {
-                        element.setAttribute(it[0], it[1])
-                    }
+        if (prefix != "") {
+            if (namespaces.containsKey(prefix)) {
+                uri = namespaces[prefix]
+            } else if (pendingNamespaces.containsKey(prefix)) {
+                uri = pendingNamespaces[prefix]
+            } else {
+                throw new GroovyRuntimeException("Namespace prefix: ${prefix} is not bound to a URI")
+            }
+            if (prefix != ":") {
+                qualifiedName = prefix + ":" + tag
+            }
+        }
 
-                    dom.element.appendChild(element)
-                    dom.element = element
-
-                    if (body != null) {
-                        pendingStack.add pendingNamespaces.clone()
-                        pendingNamespaces.clear()
-
-                        if (body instanceof Closure) {
-                          def body1 = body.clone()
-
-                          body1.delegate = doc
-                          body1(doc)
-                        } else if (body instanceof Buildable) {
-                              body.build(doc)
-                        } else {
-                          body.each {
-                            if (it instanceof Closure) {
-                              def body1 = it.clone()
-
-                              body1.delegate = doc
-                              body1(doc)
-                            } else if (it instanceof Buildable) {
-                              it.build(doc)
-                            } else {
-                              dom.element.appendChild(dom.document.createTextNode(it))
-                            }
-                          }
-                        }
-
-                        pendingNamespaces.clear()
-                        pendingNamespaces.putAll pendingStack.pop()
-                    }
+        def element = dom.document.createElementNS(uri, qualifiedName)
+
+        nsAttributes.each {
+            element.setAttributeNS(it[0], it[1], it[2])
+        }
+        attributes.each {
+            element.setAttribute(it[0], it[1])
+        }
 
-                    dom.element = dom.element.getParentNode()
+        dom.element.appendChild(element)
+        dom.element = element
 
-                    hiddenNamespaces.each {key, value ->
-                                                if (value == null) {
-                                                    namespaces.remove key
-                                                } else {
-                                                    namespaces[key] = value
-                                                }
+        if (body != null) {
+            pendingStack.add pendingNamespaces.clone()
+            pendingNamespaces.clear()
+
+            if (body instanceof Closure) {
+                def body1 = body.clone()
+
+                body1.delegate = doc
+                body1(doc)
+            } else if (body instanceof Buildable) {
+                body.build(doc)
+            } else {
+                body.each {
+                    if (it instanceof Closure) {
+                        def body1 = it.clone()
+
+                        body1.delegate = doc
+                        body1(doc)
+                    } else if (it instanceof Buildable) {
+                        it.build(doc)
+                    } else {
+                        dom.element.appendChild(dom.document.createTextNode(it))
                     }
+                }
+            }
+
+            pendingNamespaces.clear()
+            pendingNamespaces.putAll pendingStack.pop()
+        }
+
+        dom.element = dom.element.getParentNode()
+
+        hiddenNamespaces.each { key, value ->
+            if (value == null) namespaces.remove key
+            else namespaces[key] = value
+        }
     }
 
     def builder = null
@@ -210,10 +207,10 @@ class StreamingDOMBuilder extends AbstractStreamingBuilder {
                             'yieldUnescaped':noopClosure,
                             'comment':commentClosure,
                             'pi':piClosure])
-//        def nsSpecificTags = [':'                                          : [tagClosure, tagClosure, [:]],    // the default namespace
-//                          'http://www.w3.org/XML/1998/namespace'           : [tagClosure, tagClosure, [:]],
-//                          'http://www.codehaus.org/Groovy/markup/keywords' : [badTagClosure, tagClosure, specialTags]]
-//        this.builder = new BaseMarkupBuilder(nsSpecificTags)
+        def nsSpecificTags = [':'                                          : [tagClosure, tagClosure, [:]],    // the default namespace
+                          'http://www.w3.org/XML/1998/namespace'           : [tagClosure, tagClosure, [:]],
+                          'http://www.codehaus.org/Groovy/markup/keywords' : [badTagClosure, tagClosure, specialTags]]
+        this.builder = new BaseMarkupBuilder(nsSpecificTags)
     }
 
     def bind(closure) {
diff --git a/src/main/groovy/xml/streamingmarkupsupport/BaseMarkupBuilder.java b/src/main/groovy/xml/streamingmarkupsupport/BaseMarkupBuilder.java
index f6a2938086..35620bd0ab 100644
--- a/src/main/groovy/xml/streamingmarkupsupport/BaseMarkupBuilder.java
+++ b/src/main/groovy/xml/streamingmarkupsupport/BaseMarkupBuilder.java
@@ -53,26 +53,26 @@ import java.util.HashMap;
 import java.util.Map;
 
 public class BaseMarkupBuilder extends Builder {
-	public BaseMarkupBuilder(final Map namespaceMethodMap) {
-		super(namespaceMethodMap);
-	}
-	
-	public Object bind(final Closure root) {
-		return new Document(root, this.namespaceMethodMap);
-	}
-	
-	private static class Document extends Built implements GroovyInterceptable {
-		private Object out;
-		private final Map pendingNamespaces = new HashMap();
-		private final Map namespaces = new HashMap();
-         private final Map specialProperties = new HashMap();
-		private String prefix = "";
-        
+    public BaseMarkupBuilder(final Map namespaceMethodMap) {
+        super(namespaceMethodMap);
+    }
+
+    public Object bind(final Closure root) {
+        return new Document(root, this.namespaceMethodMap);
+    }
+
+    private static class Document extends Built implements GroovyInterceptable {
+        private Object out;
+        private final Map pendingNamespaces = new HashMap();
+        private final Map namespaces = new HashMap();
+        private final Map specialProperties = new HashMap();
+        private String prefix = "";
+
         {
-            
+
             namespaces.put("xml", "http://www.w3.org/XML/1998/namespace");             // built in namespace
             namespaces.put("mkp", "http://www.codehaus.org/Groovy/markup/keywords");   // pseudo namespace for markup keywords
-            
+
             specialProperties.put("out", new OutputSink("out") {
                 public Object leftShift(final Object value) {
                     return leftShift("yield", value);
@@ -99,110 +99,109 @@ public class BaseMarkupBuilder extends Builder {
                 }
             });
         }
-        
+
         private abstract class OutputSink extends GroovyObjectSupport {
             private final String name;
-            
+
             public OutputSink(final String name) {
                 this.name = name;
             }
-            
+
             public Object invokeMethod(final String name, final Object args) {
                 Document.this.prefix = this.name;
                 return Document.this.invokeMethod(name, args);
             }
-            
+
             public abstract Object leftShift(Object item);
-            
+
             protected Object leftShift(final String command, final Object value) {
                 Document.this.getProperty("mkp");
                 Document.this.invokeMethod(command, new Object[]{value});
                 return this;
             }
         }
-		
-		public Document(final Closure root, final Map namespaceMethodMap) {
-			super(root, namespaceMethodMap);
-		}
-		
-		/* (non-Javadoc)
-		 * @see groovy.lang.GroovyObject#invokeMethod(java.lang.String, java.lang.Object)
-		 */
-		public Object invokeMethod(final String name, final Object args) {
-			final Object[] arguments = (Object[]) args;
-			Map attrs = Collections.EMPTY_MAP;
-			Object body = null;
-			
-			
-			//
-			// Sort the parameters out
-			//
-			for (int i = 0; i != arguments.length; i++) {
-				final Object arg = arguments[i];
-				
-				if (arg instanceof Map) {
-					attrs = (Map)arg;
-				} else if (arg instanceof Closure) {
-					final Closure c = ((Closure) arg);
-					
-					c.setDelegate(this);
-					body = c.asWritable();
-				} else {
-					body = arg;
-				}
-			}
-			
-			//
-			// call the closure corresponding to the tag
-			//
-			final Object uri;
-			
-			if (this.pendingNamespaces.containsKey(this.prefix)) {
-				uri = this.pendingNamespaces.get(this.prefix);
-			} else if (this.namespaces.containsKey(this.prefix)) {
-				uri = this.namespaces.get(this.prefix);
-			} else {
-				uri = ":";
-			}
-			
-			final Object[] info  = (Object[])this.namespaceSpecificTags.get(uri);
-			final Map tagMap = (Map)info[2];
-			final Closure defaultTagClosure = (Closure)info[0];
-			
-			final String prefix = this.prefix;
-			this.prefix = "";
-			
-			if (tagMap.containsKey(name)) {
-				return ((Closure)tagMap.get(name)).call(new Object[]{this, this.pendingNamespaces, this.namespaces, this.namespaceSpecificTags, prefix, attrs, body, this.out});
-			} else {
-				return defaultTagClosure.call(new Object[]{name, this, this.pendingNamespaces, this.namespaces, this.namespaceSpecificTags, prefix, attrs, body, this.out});		
-			}
-		}
-		
-		/* (non-Javadoc)
-		 * @see groovy.lang.GroovyObject#getProperty(java.lang.String)
-		 */
-		public Object getProperty(final String property) {
-        final Object special = this.specialProperties.get(property);
-        
+
+        public Document(final Closure root, final Map namespaceMethodMap) {
+            super(root, namespaceMethodMap);
+        }
+
+        /* (non-Javadoc)
+           * @see groovy.lang.GroovyObject#invokeMethod(java.lang.String, java.lang.Object)
+           */
+        public Object invokeMethod(final String name, final Object args) {
+            final Object[] arguments = (Object[]) args;
+            Map attrs = Collections.EMPTY_MAP;
+            Object body = null;
+
+            //
+            // Sort the parameters out
+            //
+            for (int i = 0; i != arguments.length; i++) {
+                final Object arg = arguments[i];
+
+                if (arg instanceof Map) {
+                    attrs = (Map) arg;
+                } else if (arg instanceof Closure) {
+                    final Closure c = ((Closure) arg);
+
+                    c.setDelegate(this);
+                    body = c.asWritable();
+                } else {
+                    body = arg;
+                }
+            }
+
+            //
+            // call the closure corresponding to the tag
+            //
+            final Object uri;
+
+            if (this.pendingNamespaces.containsKey(this.prefix)) {
+                uri = this.pendingNamespaces.get(this.prefix);
+            } else if (this.namespaces.containsKey(this.prefix)) {
+                uri = this.namespaces.get(this.prefix);
+            } else {
+                uri = ":";
+            }
+
+            final Object[] info = (Object[]) this.namespaceSpecificTags.get(uri);
+            final Map tagMap = (Map) info[2];
+            final Closure defaultTagClosure = (Closure) info[0];
+
+            final String prefix = this.prefix;
+            this.prefix = "";
+
+            if (tagMap.containsKey(name)) {
+                return ((Closure) tagMap.get(name)).call(new Object[]{this, this.pendingNamespaces, this.namespaces, this.namespaceSpecificTags, prefix, attrs, body, this.out});
+            } else {
+                return defaultTagClosure.call(new Object[]{name, this, this.pendingNamespaces, this.namespaces, this.namespaceSpecificTags, prefix, attrs, body, this.out});
+            }
+        }
+
+        /* (non-Javadoc)
+         * @see groovy.lang.GroovyObject#getProperty(java.lang.String)
+         */
+        public Object getProperty(final String property) {
+            final Object special = this.specialProperties.get(property);
+
             if (special == null) {
-        			this.prefix = property;
-        			return this;
+                this.prefix = property;
+                return this;
             } else {
                 return special;
             }
-		}
-		
-		/* (non-Javadoc)
-		 * @see groovy.lang.GroovyObject#setProperty(java.lang.String, java.lang.Object)
-		 */
-		public void setProperty(String property, Object newValue) {
-			if ("trigger".equals(property)) {
-				this.out = newValue;
-				this.root.call(this);
-			} else {
-				super.setProperty(property, newValue);
-			}
-		}
-	}
+        }
+
+        /* (non-Javadoc)
+         * @see groovy.lang.GroovyObject#setProperty(java.lang.String, java.lang.Object)
+         */
+        public void setProperty(String property, Object newValue) {
+            if ("trigger".equals(property)) {
+                this.out = newValue;
+                this.root.call(this);
+            } else {
+                super.setProperty(property, newValue);
+            }
+        }
+    }
 }
diff --git a/src/test/groovy/xml/dom/DOMTest.groovy b/src/test/groovy/xml/dom/DOMTest.groovy
index 467b63df15..b02320eb43 100644
--- a/src/test/groovy/xml/dom/DOMTest.groovy
+++ b/src/test/groovy/xml/dom/DOMTest.groovy
@@ -27,9 +27,21 @@ class DOMTest extends GroovyTestCase {
         if (!benchmark) assertCorrect html
     }
 
-  void testStreamingDOMBuilder_FAILS() { if (notYetImplemented()) return
+    void testDOMBuilderWithNullValue() {
+        def html = DOMBuilder.newInstance().
+        html {
+          head {
+            title (testAttr:null, "Test")
+          }
+        }
+        use (DOMCategory) {
+            assert html.head.title[0].'@testAttr' == ''
+        }
+    }
 
-        def doc = new StreamingDOMBuilder().bind{
+    void testStreamingDOMBuilder() {
+        def builder = new StreamingDOMBuilder()
+        def doc = builder.bind{
           html {
             head {
               title (class:"mytitle", "Test")
@@ -38,35 +50,48 @@ class DOMTest extends GroovyTestCase {
               p (class:"mystyle", "This is a test.")
             }
           }
-        }()
-        if (!benchmark) { assertCorrect doc.documentElement }
+        }
+        if (!benchmark) assertCorrectStreaming doc().docElement
     }
 
-    private def assertCorrect(html) {
+    // TODO: reduce dup with assertCorrect
+    private def assertCorrectStreaming(html) {
         use (DOMCategory) {
-          assert html.head.title.collect{ it.text() } == ['Test']
-          assert html.head.title[0].text() == 'Test'
-          assert html.body.p[0].text() == 'This is a test.'
-          assert html.find { it.tagName == 'body' }.tagName == 'body'
-          assert html.getElementsByTagName('*').findAll{ it.'@class' != '' }.size() == 2
+            assert html.head.title[0].textContent == 'Test'
+            assert html.body.p[0].textContent == 'This is a test.'
+            assert html.find { it.tagName == 'body' }.tagName == 'body'
+            assert html.getElementsByTagName('*').findAll{ it.'@class' != '' }.size() == 2
         }
         // should fail outside category
         shouldFail (MissingPropertyException) { html.head }
     }
   
+    private def assertCorrect(html) {
+        use (DOMCategory) {
+            assert html.head.title.collect{ it.text() } == ['Test']
+            assert html.head.title[0].text() == 'Test'
+            assert html.body.p[0].text() == 'This is a test.'
+            assert html.find { it.tagName == 'body' }.tagName == 'body'
+            assert html.getElementsByTagName('*').findAll{ it.'@class' != '' }.size() == 2
+        }
+        // should fail outside category
+        shouldFail (MissingPropertyException) { html.head }
+    }
+
     static void main(args) {
         // Relative results:
-        // Test       05 May 2004  14 Oct 2006
-        // Parser:    1.0          1.0
-        // Builder:   1.05         2.90
-        // Streaming: 0.77         0.20
+        // When:      05 May 2004  14 Oct 2006  4 Mar 2007
+        // Notes:                  Xerces 2.4   Xerces 2.8
+        // Parser:    1.0          1.0          1.0
+        // Builder:   1.05         2.90         1.20
+        // Streaming: 0.77         0.20         0.20
         def x = args.size() == 0 ? 1000 : Integer.parseInt(args[0])
         def mydomtest = new DOMTest()
         def standard = 0
         mydomtest.benchmark = true
         [{ mydomtest.testDOMParser() },
          { mydomtest.testDOMBuilder() },
-         { mydomtest.testStreamingDOMBuilder_FAILS() }].eachWithIndex { testMethod, index ->
+         { mydomtest.testStreamingDOMBuilder() }].eachWithIndex { testMethod, index ->
             // Run the method once to fill any caches and to load classes
             testMethod()
             def start = System.currentTimeMillis()
