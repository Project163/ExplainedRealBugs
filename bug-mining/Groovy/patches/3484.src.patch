diff --git a/src/main/groovy/groovy/util/GroovyScriptEngine.java b/src/main/groovy/groovy/util/GroovyScriptEngine.java
index c9e0c5bd4c..8634e3a6be 100644
--- a/src/main/groovy/groovy/util/GroovyScriptEngine.java
+++ b/src/main/groovy/groovy/util/GroovyScriptEngine.java
@@ -264,12 +264,8 @@ public class GroovyScriptEngine implements ResourceConnector {
                 Set<String> newDep = new HashSet<String>(origDep.size());
                 for (String depName : origDep) {
                     ScriptCacheEntry dep = scriptCache.get(depName);
-                    try {
-                        if (origEntry == dep || GroovyScriptEngine.this.isSourceNewer(dep)) {
-                            newDep.add(depName);
-                        }
-                    } catch (ResourceException re) {
-
+                    if (origEntry == dep || GroovyScriptEngine.this.isSourceNewer(dep)) {
+                        newDep.add(depName);
                     }
                 }
                 StringSetMap cache = localData.dependencyCache;
@@ -613,7 +609,7 @@ public class GroovyScriptEngine implements ResourceConnector {
         return lastMod;
     }
 
-    protected boolean isSourceNewer(ScriptCacheEntry entry) throws ResourceException {
+    protected boolean isSourceNewer(ScriptCacheEntry entry) {
         if (entry == null) return true;
 
         long mainEntryLastCheck = entry.lastCheck;
@@ -634,7 +630,18 @@ public class GroovyScriptEngine implements ResourceConnector {
             long nextSourceCheck = depEntry.lastCheck + config.getMinimumRecompilationInterval();
             if (nextSourceCheck > now) continue;
 
-            long lastMod = getLastModified(scriptName);
+            long lastMod;
+            try {
+                lastMod = getLastModified(scriptName);
+            } catch (ResourceException e) {
+                /*
+                Class A depends on class B and they both are compiled once.  If class A is then
+                loaded again from loadScriptByName(scriptName) after class B and all references to
+                it have been deleted from the root, this exception will occur.  It is still valid
+                and necessary to attempt a recompile of class A.
+                */
+                return true;
+            }
             if (depEntry.lastModified < lastMod) {
                 depEntry = new ScriptCacheEntry(depEntry, lastMod, true);
                 scriptCache.put(scriptName, depEntry);
diff --git a/src/test/groovy/util/GroovyScriptEngineReloadingTest.groovy b/src/test/groovy/util/GroovyScriptEngineReloadingTest.groovy
index 1ca7f01e5c..443a692e41 100644
--- a/src/test/groovy/util/GroovyScriptEngineReloadingTest.groovy
+++ b/src/test/groovy/util/GroovyScriptEngineReloadingTest.groovy
@@ -92,6 +92,19 @@ class GroovyScriptEngineReloadingTest extends GroovyTestCase {
         execute (100000, 200000, 2)
     }
 
+    void testDeleteDependent() {
+        sleep 10000
+        MapFileSystem.instance.modFile('ClassA.groovy','DependentClass ic = new DependentClass()',gse.@time as long)
+        MapFileSystem.instance.modFile('DependentClass.groovy','class DependentClass {}',gse.@time as long)
+        def clazz = gse.loadScriptByName('ClassA.groovy')
+        assert clazz != null //classA is valid with dep
+        sleep 11000
+        MapFileSystem.instance.modFile('ClassA.groovy',"println 'this is a valid script'",gse.@time as long)
+        MapFileSystem.instance.deleteFile('DependentClass.groovy')
+        clazz = gse.loadScriptByName('ClassA.groovy')
+        assert clazz != null //classA is valid with dep removed
+    }
+
     public void testReloadWith2ScriptsDependentOnSameBeanAndReloadForSecond() {
         gse.config.minimumRecompilationInterval = 1000
         writeBean(1)
@@ -456,7 +469,11 @@ class GroovyScriptEngineReloadingTest extends GroovyTestCase {
                 fileCache.put(name, new MapFileEntry(content, lutime))
             }
         }
-    
+
+        def deleteFile(String name) {
+            return fileCache.remove(name)
+        }
+
         String getFilesrc(String name) {
             return fileCache.get(name).content
         }
