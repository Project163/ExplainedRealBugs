diff --git a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
index 2e4e0b6ee1..46b5a38cfb 100644
--- a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
+++ b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
@@ -522,25 +522,42 @@ public class StaticTypesCallSiteWriter extends CallSiteWriter implements Opcodes
         ClassNode classNode = controller.getClassNode();
         ClassNode rType = typeChooser.resolveType(receiver, classNode);
         ClassNode aType = typeChooser.resolveType(arguments, classNode);
+        if (trySubscript(receiver, message, arguments, rType, aType)) {
+            return;
+        }
+        // new try with flow type instead of declaration type
+        rType = receiver.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);
+        if (rType!=null && trySubscript(receiver, message, arguments, rType, aType)) {
+            return;
+        }
+        // todo: more cases
+        throw new GroovyBugError(
+                "At line "+receiver.getLineNumber() + " column " + receiver.getColumnNumber() + "\n" +
+                "On receiver: "+receiver.getText() + " with message: "+message+" and arguments: "+arguments.getText()+"\n"+
+                "This method should not have been called. Please try to create a simple example reproducing this error and file" +
+                "a bug report at http://jira.codehaus.org/browse/GROOVY");
+    }
+
+    private boolean trySubscript(final Expression receiver, final String message, final Expression arguments, ClassNode rType, final ClassNode aType) {
         if (getWrapper(rType).isDerivedFrom(Number_TYPE)
                 && getWrapper(aType).isDerivedFrom(Number_TYPE)) {
             if ("plus".equals(message) || "minus".equals(message) || "multiply".equals(message) || "div".equals(message)) {
                 writeNumberNumberCall(receiver, message, arguments);
-                return;
+                return true;
             } else if ("power".equals(message)) {
                 writePowerCall(receiver, arguments, rType, aType);
-                return;
+                return true;
             } else if ("mod".equals(message)) {
                 writeModCall(receiver, arguments, rType, aType);
-                return;
+                return true;
             }
         } else if (STRING_TYPE.equals(rType) && "plus".equals(message)) {
             writeStringPlusCall(receiver, message, arguments);
-            return;
+            return true;
         } else if ("getAt".equals(message)) {
             if (rType.isArray() && getWrapper(aType).isDerivedFrom(Number_TYPE)) {
                 writeArrayGet(receiver, arguments, rType, aType);
-                return;
+                return true;
             } else {
                 // check if a getAt method can be found on the receiver
                 ClassNode current = rType;
@@ -564,9 +581,9 @@ public class StaticTypesCallSiteWriter extends CallSiteWriter implements Opcodes
                     call.setImplicitThis(false);
                     call.setMethodTarget(getAtNode);
                     call.visit(controller.getAcg());
-                    return;
+                    return true;
                 }
-        
+
                 // make sure Map#getAt() and List#getAt handled with the bracket syntax are properly compiled
                 ClassNode[] args = {aType};
                 boolean acceptAnyMethod =
@@ -590,7 +607,7 @@ public class StaticTypesCallSiteWriter extends CallSiteWriter implements Opcodes
                     call.setImplicitThis(false);
                     call.setMethodTarget(methodNode);
                     call.visit(controller.getAcg());
-                    return;
+                    return true;
                 }
                 if (implementsInterfaceOrIsSubclassOf(rType, MAP_TYPE)) {
                     // fallback to Map#get
@@ -603,16 +620,11 @@ public class StaticTypesCallSiteWriter extends CallSiteWriter implements Opcodes
                     call.setSourcePosition(arguments);
                     call.setImplicitThis(false);
                     call.visit(controller.getAcg());
-                    return;
+                    return true;
                 }
             }
         }
-        // todo: more cases
-        throw new GroovyBugError(
-                "At line "+receiver.getLineNumber() + " column " + receiver.getColumnNumber() + "\n" +
-                "On receiver: "+receiver.getText() + " with message: "+message+" and arguments: "+arguments.getText()+"\n"+
-                "This method should not have been called. Please try to create a simple example reproducing this error and file" +
-                "a bug report at http://jira.codehaus.org/browse/GROOVY");
+        return false;
     }
 
     private void writeArrayGet(final Expression receiver, final Expression arguments, final ClassNode rType, final ClassNode aType) {
diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index ea4a540ff6..03ecf23a98 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -452,6 +452,10 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 // in case of the "in" operator, the receiver and the arguments are reversed
                 // so we use the reversedExpression and get the target method from it
                 storeTargetMethod(expression, (MethodNode) reversedBinaryExpression.getNodeMetaData(StaticTypesMarker.DIRECT_METHOD_CALL_TARGET));
+            } else if (op == LEFT_SQUARE_BRACKET
+                    && leftExpression instanceof VariableExpression
+                    && leftExpression.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE)==null) {
+                storeType(leftExpression, lType);
             }
             if (resultType == null) {
                 resultType = lType;
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy6782Bug.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy6782Bug.groovy
new file mode 100644
index 0000000000..aa21ffd3fd
--- /dev/null
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy6782Bug.groovy
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2003-2014 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+
+
+
+package org.codehaus.groovy.classgen.asm.sc.bugs
+
+import groovy.transform.stc.StaticTypeCheckingTestCase
+import org.codehaus.groovy.classgen.asm.sc.StaticCompilationTestSupport
+
+class Groovy6782Bug extends StaticTypeCheckingTestCase implements StaticCompilationTestSupport {
+
+    void testFlowTypingBreaksSubscriptOperator() {
+            assertScript '''String[] array = [123]
+def tokens = array
+def t = tokens[0]
+tokens = [:]    // if this line is removed, compiles fine
+        '''
+    }
+
+}
