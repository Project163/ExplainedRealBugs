diff --git a/src/main/java/org/codehaus/groovy/runtime/typehandling/BigIntegerMath.java b/src/main/java/org/codehaus/groovy/runtime/typehandling/BigIntegerMath.java
index e307576f40..fc5d7d2c18 100644
--- a/src/main/java/org/codehaus/groovy/runtime/typehandling/BigIntegerMath.java
+++ b/src/main/java/org/codehaus/groovy/runtime/typehandling/BigIntegerMath.java
@@ -81,4 +81,12 @@ public final class BigIntegerMath extends NumberMath {
     protected Number xorImpl(Number left, Number right) {
         return toBigInteger(left).xor(toBigInteger(right));
     }
+
+    protected Number leftShiftImpl(Number left, Number right) {
+        return toBigInteger(left).shiftLeft(right.intValue());
+    }
+
+    protected Number rightShiftImpl(Number left, Number right) {
+        return toBigInteger(left).shiftRight(right.intValue());
+    }
 }
diff --git a/src/spec/doc/core-operators.adoc b/src/spec/doc/core-operators.adoc
index 3f90c060d4..011c057600 100644
--- a/src/spec/doc/core-operators.adoc
+++ b/src/spec/doc/core-operators.adoc
@@ -93,6 +93,8 @@ include::{projectdir}/src/spec/test/OperatorsTest.groovy[tags=plusplus_minusminu
 <3> The prefix increment will increment `e` before the expression is evaluated and assigned into `f`
 <4> The prefix decrement will decrement `g` before the expression is evaluated and assigned into `h`
 
+For the unary not operator on Booleans, see <<#_conditional_operators>>.
+
 === Assignment arithmetic operators
 
 The binary arithmetic operators we have seen above are also available in an assignment form:
@@ -231,16 +233,21 @@ include::{projectdir}/src/spec/test/OperatorsTest.groovy[tags=logical_shortcircu
 <4> Likewise for `&&`, we confirm that the function is not called with a false left operand
 <5> But the function is called with a true left operand
 
-== Bitwise operators
+== Bitwise and bit shift operators
+
+=== Bitwise operators
 
-Groovy offers 4 bitwise operators:
+Groovy offers four bitwise operators:
 
 * `&`: bitwise "and"
 * `|`: bitwise "or"
 * `^`: bitwise "xor" (exclusive "or")
 * `~`: bitwise negation
 
-Bitwise operators can be applied on a `byte` or an `int` and return an `int`:
+Bitwise operators can be applied on arguments which are of type `byte`, `short`, `int`, `long`, or `BigInteger`.
+If one of the arguments is a `BigInteger`, the result will be of type `BigInteger`;
+otherwise, if one of the arguments is a `long`, the result will be of type `long`;
+otherwise, the result will be of type `int`:
 
 [source,groovy]
 ----
@@ -258,7 +265,29 @@ include::{projectdir}/src/spec/test/OperatorsTest.groovy[tags=bitwise_op,indent=
 It's worth noting that the internal representation of primitive types follow the http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html[Java Language Specification]. In particular,
 primitive types are signed, meaning that for a bitwise negation, it is always good to use a mask to retrieve only the necessary bits.
 
-In Groovy, bitwise operators have the particularity of being <<Operator-Overloading,overloadable>>, meaning that you can define the behavior of those operators for any kind of object.
+In Groovy, bitwise operators are <<Operator-Overloading,overloadable>>, meaning that you can define the behavior of those operators for any kind of object.
+
+=== Bit shift operators
+
+Groovy offers three bit shift operators:
+
+* `<<`: left shift
+* `>>`: right shift
+* `>>>`: right shift unsigned
+
+All three operators are applicable where the left argument is of type `byte`, `short`, `int`, or `long`.
+The first two operators can also be applied where the left argument is of type `BigInteger`.
+If the left argument is a `BigInteger`, the result will be of type `BigInteger`;
+otherwise, if the left argument is a `long`, the result will be of type `long`;
+otherwise, the result will be of type `int`:
+
+[source,groovy]
+----
+include::{projectdir}/src/spec/test/OperatorsTest.groovy[tags=bit_shift_op,indent=0]
+----
+<1> `equals` method used instead of `==` to confirm result type
+
+In Groovy, bit shift operators are <<Operator-Overloading,overloadable>>, meaning that you can define the behavior of those operators for any kind of object.
 
 == Conditional operators
 
diff --git a/src/spec/test/OperatorsTest.groovy b/src/spec/test/OperatorsTest.groovy
index e26c73c2a6..a833afa2de 100644
--- a/src/spec/test/OperatorsTest.groovy
+++ b/src/spec/test/OperatorsTest.groovy
@@ -137,6 +137,19 @@ class OperatorsTest extends CompilableTestSupport {
         // end::bitwise_op[]
     }
 
+    void testBitShiftOperators() {
+        // tag::bit_shift_op[]
+        assert 12.equals(3 << 2)           // <1>
+        assert 24L.equals(3L << 3)         // <1>
+        assert 48G.equals(3G << 4)         // <1>
+
+        assert 4095 == -200 >>> 20
+        assert -1 == -200 >> 20
+        assert 2G == 5G >> 1
+        assert -3G == -5G >> 1
+        // end::bit_shift_op[]
+    }
+
     void testLogicalOperatorPrecedence() {
         // tag::logical_precendence_1[]
         assert (!false && false) == false   // <1>
