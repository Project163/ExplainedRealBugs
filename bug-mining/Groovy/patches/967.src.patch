diff --git a/src/main/groovy/mock/interceptor/MockInterceptor.groovy b/src/main/groovy/mock/interceptor/MockInterceptor.groovy
index 8f6b26304f..b1b8861b7a 100644
--- a/src/main/groovy/mock/interceptor/MockInterceptor.groovy
+++ b/src/main/groovy/mock/interceptor/MockInterceptor.groovy
@@ -27,19 +27,19 @@ class MockInterceptor implements PropertyAccessInterceptor {
 
     Object beforeInvoke(Object object, String methodName, Object[] arguments) {
         if (!expectation) throw new IllegalStateException("Property 'expectation' must be set before use.")
-        return expectation.match(methodName).call(arguments)
+        return expectation.match(methodName)(*arguments)
     }
 
     Object beforeGet(Object object, String property) {
         if (!expectation) throw new IllegalStateException("Property 'expectation' must be set before use.")
         String name = "get${property[0].toUpperCase()}${property[1..-1]}"
-        return expectation.match(name).call()                    
+        return expectation.match(name)()                    
     }
 
     void beforeSet(Object object, String property, Object newValue) {
         if (!expectation) throw new IllegalStateException("Property 'expectation' must be set before use.")
         String name = "set${property[0].toUpperCase()}${property[1..-1]}"
-        expectation.match(name).call(newValue)
+        expectation.match(name)(newValue)
     }
 
     Object afterInvoke(Object object, String methodName, Object[] arguments, Object result) {
diff --git a/src/main/org/codehaus/groovy/runtime/metaclass/ClosureMetaClass.java b/src/main/org/codehaus/groovy/runtime/metaclass/ClosureMetaClass.java
index 9c15088beb..a10a2122e8 100644
--- a/src/main/org/codehaus/groovy/runtime/metaclass/ClosureMetaClass.java
+++ b/src/main/org/codehaus/groovy/runtime/metaclass/ClosureMetaClass.java
@@ -221,7 +221,7 @@ public final class ClosureMetaClass extends MetaClassImpl {
             }
 
             if (delegateMetaClass instanceof MetaClassImpl) {
-                method = ((MetaClassImpl)delegateMetaClass).findMethodInClassHierarchy(getTheClass(), methodName, argClasses, this);
+                method = MetaClassImpl.findMethodInClassHierarchy(getTheClass(), methodName, argClasses, this);
                 if(method != null) {
                     onSuperMethodFoundInHierarchy(method);
                     return method;
@@ -381,11 +381,6 @@ public final class ClosureMetaClass extends MetaClassImpl {
 
     private Object[] makeArguments(Object[] arguments, String methodName) {
         if (arguments == null) return EMPTY_ARGUMENTS;
-        if (CLOSURE_CALL_METHOD.equals(methodName)) {
-            if (arguments.length==1 && arguments[0] instanceof Object[]) {
-                return (Object[]) arguments[0];
-            }
-        }
         return arguments;
     }
     
@@ -554,21 +549,6 @@ public final class ClosureMetaClass extends MetaClassImpl {
         }
     }
 
-    private void generateReflector() {
-//        if (GroovySystem.isUseReflection())
-//          return;
-//
-//        reflector = ((MetaClassRegistryImpl) registry).loadReflector(theClass, closureMethods);
-//        if (reflector == null) {
-//            throw new RuntimeException("Should have a reflector for " + theClass.getName());
-//        }
-//        // lets set the reflector on all the methods
-//        for (Iterator iter = closureMethods.iterator(); iter.hasNext();) {
-//            StdMetaMethod metaMethod = (StdMetaMethod) iter.next();
-//            metaMethod.setReflector(reflector);
-//        }
-    }
-
     private MetaClass lookupObjectMetaClass(Object object) {
         if (object instanceof GroovyObject) {
             GroovyObject go = (GroovyObject) object;
@@ -677,11 +657,7 @@ public final class ClosureMetaClass extends MetaClassImpl {
     public void setProperties(Object bean, Map map) {
         throw new UnsupportedOperationException();
     }
-
-    private Object invokeConstructor(Class at, Object[] arguments) {
-        throw new UnsupportedOperationException();
-    }
-
+    
     public void addMetaBeanProperty(MetaBeanProperty mp) {
         throw new UnsupportedOperationException();
     }
diff --git a/src/test/groovy/ClosureMethodCallTest.groovy b/src/test/groovy/ClosureMethodCallTest.groovy
index a9e60cd43d..e6ab0accb6 100644
--- a/src/test/groovy/ClosureMethodCallTest.groovy
+++ b/src/test/groovy/ClosureMethodCallTest.groovy
@@ -20,10 +20,20 @@ class ClosureMethodCallTest extends GroovyTestCase {
     }
     
     void testClosureCallMethodWithObjectArray() {
-      // GROOVY-2266
-      def args = [1] as Object[]
-      def closure = {x -> x}
-      assert closure.call(args) == 1
+        // GROOVY-2266
+        def args = [1] as Object[]
+        def closure = {x -> x[0]}
+        assert closure.call(args) == 1
+    }
+    
+    void testClosureWithStringArrayCastet() {
+        def doSomething={ list ->  list }
+
+        String[] x=["hello", "world"]
+        String[] y=["hello", "world"]
+
+        assert doSomething(x as String[]) == x
+        assert doSomething( y ) == y
     }
     
     void testClosureAsLocalVar() {
