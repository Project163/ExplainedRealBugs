diff --git a/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java b/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
index ee6949c80a..67c6cdaa0d 100644
--- a/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
+++ b/src/main/java/org/codehaus/groovy/classgen/asm/sc/StaticTypesCallSiteWriter.java
@@ -74,16 +74,13 @@ import static org.codehaus.groovy.ast.ClassHelper.int_TYPE;
 import static org.codehaus.groovy.ast.ClassHelper.isBigDecimalType;
 import static org.codehaus.groovy.ast.ClassHelper.isBigIntegerType;
 import static org.codehaus.groovy.ast.ClassHelper.isClassType;
-import static org.codehaus.groovy.ast.ClassHelper.isGeneratedFunction;
 import static org.codehaus.groovy.ast.ClassHelper.isPrimitiveType;
 import static org.codehaus.groovy.ast.ClassHelper.isStringType;
 import static org.codehaus.groovy.ast.ClassHelper.isWrapperInteger;
 import static org.codehaus.groovy.ast.ClassHelper.isWrapperLong;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.args;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.bytecodeX;
-import static org.codehaus.groovy.ast.tools.GeneralUtils.callThisX;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.callX;
-import static org.codehaus.groovy.ast.tools.GeneralUtils.castX;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.classX;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.constX;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.isOrImplements;
@@ -124,7 +121,6 @@ public class StaticTypesCallSiteWriter extends CallSiteWriter {
 
     private static final ClassNode  INVOKERHELPER_TYPE = ClassHelper.make(InvokerHelper.class);
     private static final MethodNode COLLECTION_SIZE_METHOD = COLLECTION_TYPE.getMethod("size", Parameter.EMPTY_ARRAY);
-    private static final MethodNode CLOSURE_GETTHISOBJECT_METHOD = CLOSURE_TYPE.getMethod("getThisObject", Parameter.EMPTY_ARRAY);
     private static final MethodNode MAP_GET_METHOD = MAP_TYPE.getMethod("get", new Parameter[]{new Parameter(OBJECT_TYPE, "key")});
     private static final MethodNode GROOVYOBJECT_GETPROPERTY_METHOD = GROOVY_OBJECT_TYPE.getMethod("getProperty", new Parameter[]{new Parameter(STRING_TYPE, "propertyName")});
     private static final MethodNode INVOKERHELPER_GETPROPERTY_METHOD = INVOKERHELPER_TYPE.getMethod("getProperty", new Parameter[]{new Parameter(OBJECT_TYPE, "object"), new Parameter(STRING_TYPE, "propertyName")});
@@ -350,31 +346,6 @@ public class StaticTypesCallSiteWriter extends CallSiteWriter {
                     }
                 }
             }
-        } else if (implicitThis) {
-            ClassNode outerClass = receiverType.getOuterClass();
-            if (outerClass != null && (receiverType.getModifiers() & ACC_STATIC) == 0) {
-                Expression expr;
-                ClassNode thisType = outerClass;
-                if (controller.isInGeneratedFunction()) {
-                    while (isGeneratedFunction(thisType)) {
-                        thisType = thisType.getOuterClass();
-                        // TODO: stop if thisType is static?
-                    }
-
-                    MethodCallExpression call = callThisX("getThisObject");
-                    call.setImplicitThis(true);
-                    call.setMethodTarget(CLOSURE_GETTHISOBJECT_METHOD);
-                    call.putNodeMetaData(StaticTypesMarker.INFERRED_TYPE, thisType);
-
-                    expr = castX(thisType, call);
-                } else {
-                    expr = propX(classX(outerClass), "this");
-                }
-                expr.setSourcePosition(receiver);
-                expr.putNodeMetaData(StaticTypesMarker.INFERRED_TYPE, thisType);
-                // try again with "(Outer) getThisObject()" or "Outer.this" as receiver
-                return makeGetPrivateFieldWithBridgeMethod(expr, outerClass, fieldName, safe, true);
-            }
         }
         return false;
     }
@@ -435,6 +406,9 @@ public class StaticTypesCallSiteWriter extends CallSiteWriter {
             addPropertyAccessError(receiver, propertyName, receiverType);
         }
 
+        if (isThisExpression(receiver) && implicitThis) // GROOVY-11412
+            receiver.removeNodeMetaData(StaticTypesMarker.INFERRED_TYPE);
+
         MethodCallExpression call = callX(receiver, "getProperty", args(constX(propertyName)));
         call.setImplicitThis(implicitThis);
         call.setMethodTarget(GROOVYOBJECT_GETPROPERTY_METHOD);
@@ -768,11 +742,10 @@ public class StaticTypesCallSiteWriter extends CallSiteWriter {
                             int i = compileStack.defineTemporaryVariable("$rhs", rhsType, true);
                             VariableSlotLoader rhsValue = new VariableSlotLoader(rhsType, i, operandStack);
 
-                            MethodCallExpression call = callX(objectExpression, methodNode.getName(), args(fieldNode.isStatic() ? nullX() : objectExpression, rhsValue));
-                            call.setImplicitThis(expression.isImplicitThis());
-                            call.setSpreadSafe(expression.isSpreadSafe());
-                            call.setSafe(expression.isSafe());
+                            MethodCallExpression call = callX(classX(receiverType), methodNode.getName(), args(fieldNode.isStatic() ? nullX() : objectExpression, rhsValue));
+                            call.setImplicitThis(false);
                             call.setMethodTarget(methodNode);
+                            // NOTE: safe and spreadSafe cannot be mapped to "FieldOwner.pfaccess$00(receiver, value)"
                             call.visit(controller.getAcg());
 
                             // GROOVY-9892: assuming that the mutator method has a return value, make sure the operand
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 656274b331..867acbe4ad 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -226,6 +226,7 @@ import static org.codehaus.groovy.ast.tools.GeneralUtils.defaultValueX;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.elvisX;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.getGetterName;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.getSetterName;
+import static org.codehaus.groovy.ast.tools.GeneralUtils.inSamePackage;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.indexX;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.isOrImplements;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.nullX;
@@ -920,7 +921,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                     ClassNode enclosingType = typeCheckingContext.getEnclosingClassNode();
                     if (!Modifier.isPublic(modifiers) && !enclosingType.equals(resultType)
                             && !getOutermost(enclosingType).equals(getOutermost(resultType))
-                            && (Modifier.isPrivate(modifiers) || !Objects.equals(enclosingType.getPackageName(), resultType.getPackageName()))) {
+                            && (Modifier.isPrivate(modifiers) || !inSamePackage(enclosingType, resultType))) {
                         resultType = originType; // TODO: Find accessible type in hierarchy of resultType?
                     } else if (GenericsUtils.hasUnresolvedGenerics(resultType)) { // GROOVY-9033, GROOVY-10089, et al.
                         Map<GenericsTypeName, GenericsType> enclosing = extractGenericsParameterMapOfThis(typeCheckingContext);
@@ -1830,10 +1831,13 @@ out:    if ((samParameterTypes.length == 1 && isOrImplements(samParameterTypes[0
                 || accessor.getOuterClasses().contains(receiver)) {
             return true;
         }
-        if (!Modifier.isPrivate(modifiers) && Objects.equals(accessor.getPackageName(), receiver.getPackageName())) {
+        if (!Modifier.isPrivate(modifiers) && inSamePackage(accessor, receiver)) {
             return true;
         }
-        return Modifier.isProtected(modifiers) && accessor.isDerivedFrom(receiver);
+        if (Modifier.isProtected(modifiers) && accessor.isDerivedFrom(receiver)) {
+            return true;
+        }
+        return false;
     }
 
     private ClassNode getTypeForMultiValueExpression(final ClassNode compositeType, final Expression prop) {
diff --git a/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy b/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy
index e626e3bb1b..fc6aad849c 100644
--- a/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy
+++ b/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy
@@ -1472,7 +1472,7 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
         '''
     }
 
-    // GROOVY-10981, GROOVY-10985
+    // GROOVY-10981, GROOVY-10985, GROOVY-11412
     void testOuterPropertyAccess12() {
         for (propertySource in [
                 'def get(String name){if(name=="VALUE")return 2}',
@@ -1484,11 +1484,32 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
                     static class Inner {
                         $propertySource
                         def test(int i) {
+                            print( Outer.VALUE )
                             return VALUE
                         }
                     }
+                    def test() {
+                        new Inner().test(0)
+                    }
+                }
+                Object value = new Outer().test()
+                assert value == 2
+            """
+            assertScript """
+                class Outer {
+                    private static int VALUE = 1
+                    /*non-static*/ class Inner {
+                        $propertySource
+                        def test(int i) {
+                            print( Outer.VALUE )
+                            return VALUE
+                        }
+                    }
+                    def test() {
+                        new Inner().test(0)
+                    }
                 }
-                Object value = new Outer.Inner().test(0)
+                Object value = new Outer().test()
                 assert value == 2
             """
         }
diff --git a/src/test/groovy/transform/stc/LambdaTest.groovy b/src/test/groovy/transform/stc/LambdaTest.groovy
index 3ef762194e..902c0f8d9a 100644
--- a/src/test/groovy/transform/stc/LambdaTest.groovy
+++ b/src/test/groovy/transform/stc/LambdaTest.groovy
@@ -1007,16 +1007,16 @@ final class LambdaTest {
                 private List<String> strList = ['a', 'e', 'f']
                 private Map<String, List<String>> strListHolder = ['strList': strList]
                 private String b = 'b'
-                def p() {
+                def f() {
                     ['abc', 'def', 'ghi'].stream().filter(e -> strList.stream().anyMatch(c -> e.contains(c + b))).toList()
                 }
-                def p2() {
+                def g() {
                     ['abc', 'def', 'ghi'].stream().filter(e -> strListHolder.strList.stream().anyMatch(c -> e.contains(c + b))).toList()
                 }
             }
 
-            assert ['abc'] == new Test1().p()
-            assert ['abc'] == new Test1().p2()
+            assert new Test1().f() == ['abc']
+            assert new Test1().g() == ['abc']
         '''
     }
 
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy6276Bug.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy6276.groovy
similarity index 68%
rename from src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy6276Bug.groovy
rename to src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy6276.groovy
index 171d00643a..0123d43146 100644
--- a/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy6276Bug.groovy
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy6276.groovy
@@ -21,29 +21,26 @@ package org.codehaus.groovy.classgen.asm.sc.bugs
 import groovy.transform.stc.StaticTypeCheckingTestCase
 import org.codehaus.groovy.classgen.asm.sc.StaticCompilationTestSupport
 
-final class Groovy6276Bug extends StaticTypeCheckingTestCase implements StaticCompilationTestSupport {
+final class Groovy6276 extends StaticTypeCheckingTestCase implements StaticCompilationTestSupport {
 
     void testOuterClassMethodCall() {
         assertScript '''
             class Outer {
                 private int outerField = 1
-
-                private int outerMethod() { 2 }
-                int outerProperty = 3
+                private int outerMethod() {2}
+                        int outerProperty = 3
                 class Inner {
-                    void assertions() {
-                        assert outerField == 1            // #1
-                        assert outerMethod() == 2         // #2
-                        assert outerProperty == 3         // #3
-                        assert getOuterProperty() == 3    // #4
+                    void m() {
+                        assert outerField         == 1 // #1
+                        assert outerMethod()      == 2 // #2
+                        assert outerProperty      == 3 // #3
+                        assert getOuterProperty() == 3 // #4
                     }
                 }
-
                 void test() {
-                    new Inner().assertions()
+                    new Inner().m()
                 }
             }
-
             new Outer().test()
         '''
     }
@@ -51,17 +48,16 @@ final class Groovy6276Bug extends StaticTypeCheckingTestCase implements StaticCo
     void testAccessPrivateMethodFromClosure() {
         assertScript '''
             class Outer {
-                private int foo(int x) {
+                private int f(int x) {
                     2*x
                 }
-
-                int bar() {
-                    (Integer) [1,2,3].collect {
-                        foo(it)
+                int test() {
+                    (Integer) [1,2,3].collect { // closure is inner class
+                        f(it)
                     }.sum()
                 }
             }
-            new Outer().bar()
+            new Outer().test()
         '''
     }
 }
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7276.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7276.groovy
index 0cff79c173..e2d46247c1 100644
--- a/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7276.groovy
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7276.groovy
@@ -18,14 +18,13 @@
  */
 package org.codehaus.groovy.classgen.asm.sc.bugs
 
-import groovy.test.NotYetImplemented
 import groovy.transform.stc.StaticTypeCheckingTestCase
 import org.codehaus.groovy.classgen.asm.sc.StaticCompilationTestSupport
 
 final class Groovy7276 extends StaticTypeCheckingTestCase implements StaticCompilationTestSupport {
 
     void testShouldGoThroughPrivateBridgeMethod1() {
-        ['i', 'i++'].each {
+        for (it in ['i', 'i++']) {
             assertScript """
                 class Foo {
                     private int i = 1
@@ -36,8 +35,9 @@ final class Groovy7276 extends StaticTypeCheckingTestCase implements StaticCompi
         }
     }
 
+    // GROOVY-7304
     void testShouldGoThroughPrivateBridgeMethod2() {
-        ['i', 'i++'].each { // GROOVY-7304
+        for (it in ['i', 'i++']) {
             assertScript """
                 class Foo {
                     private int i = 1
@@ -51,7 +51,7 @@ final class Groovy7276 extends StaticTypeCheckingTestCase implements StaticCompi
     }
 
     void testShouldGoThroughPrivateBridgeMethod3() {
-        ['++i', 'i+=1', 'i=i+1'].each {
+        for (it in ['++i', 'i+=1', 'i=i+1']) {
             assertScript """
                 class Foo {
                     private int i = 1
@@ -64,7 +64,7 @@ final class Groovy7276 extends StaticTypeCheckingTestCase implements StaticCompi
 
     // GROOVY-7304
     void testShouldGoThroughPrivateBridgeMethod4() {
-        ['++i', 'i+=1', 'i=i+1'].each {
+        for (it in ['++i', 'i+=1', 'i=i+1']) {
             assertScript """
                 class Foo {
                     private int i = 1
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7304.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7304.groovy
deleted file mode 100644
index 13b5222c8b..0000000000
--- a/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7304.groovy
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one
- *  or more contributor license agreements.  See the NOTICE file
- *  distributed with this work for additional information
- *  regarding copyright ownership.  The ASF licenses this file
- *  to you under the Apache License, Version 2.0 (the
- *  "License"); you may not use this file except in compliance
- *  with the License.  You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing,
- *  software distributed under the License is distributed on an
- *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- *  KIND, either express or implied.  See the License for the
- *  specific language governing permissions and limitations
- *  under the License.
- */
-package org.codehaus.groovy.classgen.asm.sc.bugs
-
-import groovy.transform.CompileStatic
-import org.junit.Test
-
-import static groovy.test.GroovyAssert.assertScript
-
-@CompileStatic
-final class Groovy7304 {
-
-    @Test // bridge methods should also be statically compiled
-    void testShouldGoThroughPrivateBridgeMethod() {
-        assertScript '''
-            class A {
-                private int i = 1
-                @groovy.transform.CompileStatic
-                int m() { new String().with { i++ } }
-            }
-            class B extends A {
-            }
-            assert new B().m() == 1
-        '''
-    }
-}
