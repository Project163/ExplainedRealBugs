diff --git a/src/main/org/codehaus/groovy/classgen/asm/MopWriter.java b/src/main/org/codehaus/groovy/classgen/asm/MopWriter.java
index 82d7586e03..e5835da611 100644
--- a/src/main/org/codehaus/groovy/classgen/asm/MopWriter.java
+++ b/src/main/org/codehaus/groovy/classgen/asm/MopWriter.java
@@ -82,7 +82,9 @@ public class MopWriter {
         LinkedList<MethodNode> mopCalls = new LinkedList<MethodNode>();
         for (Object method : methods) {
             MethodNode mn = (MethodNode) method;
-            if ((mn.getModifiers() & ACC_ABSTRACT) != 0) continue;
+            // mop methods are helper for this and super calls and do direct calls
+            // to the target methods. Such a method cannot be abstract or a bridge
+            if ((mn.getModifiers() & (ACC_ABSTRACT | ACC_BRIDGE)) != 0) continue;
             if (mn.isStatic()) continue;
             // no this$ methods for non-private isThis=true
             // super$ method for non-private isThis=false
diff --git a/src/test/org/codehaus/groovy/classgen/asm/AbstractBytecodeTestCase.groovy b/src/test/org/codehaus/groovy/classgen/asm/AbstractBytecodeTestCase.groovy
index d12a3de56a..c14bf37d21 100644
--- a/src/test/org/codehaus/groovy/classgen/asm/AbstractBytecodeTestCase.groovy
+++ b/src/test/org/codehaus/groovy/classgen/asm/AbstractBytecodeTestCase.groovy
@@ -57,7 +57,8 @@ abstract class AbstractBytecodeTestCase extends GroovyTestCase {
      * @param scriptText the script to compile
      * @return the decompiled <code>InstructionSequence</code>
      */
-    InstructionSequence compile(Map options=[method:"run"], String scriptText) {
+    InstructionSequence compile(Map options=[:], String scriptText) {
+        options = [method:"run", classNamePattern:'.*script', *:options]
         sequence = null
         clazz = null
         def cu = new CompilationUnit()
@@ -69,7 +70,7 @@ abstract class AbstractBytecodeTestCase extends GroovyTestCase {
         cu.compile(Phases.CLASS_GENERATION)
 
         cu.classes.each {
-            if (it.name==~'.*script') {
+            if (it.name ==~ (options.classNamePattern)) {
                 sequence = extractSequence(it.bytes, options)
             }
         }
diff --git a/src/test/org/codehaus/groovy/classgen/asm/CovariantReturnBytecodeTest.groovy b/src/test/org/codehaus/groovy/classgen/asm/CovariantReturnBytecodeTest.groovy
new file mode 100644
index 0000000000..b5c3524dde
--- /dev/null
+++ b/src/test/org/codehaus/groovy/classgen/asm/CovariantReturnBytecodeTest.groovy
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2003-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.codehaus.groovy.classgen.asm
+
+class CovariantReturnBytecodeTest extends AbstractBytecodeTestCase {
+    void testCovariance(){
+        def code = compile (method:'super$3$attach', classNamePattern:'C', '''
+            abstract class A {
+                A attach(){return this}
+            }
+            class B extends A {
+                @Override
+                B attach(){return (B) super.attach()}
+            }
+            class C extends B {
+                @Override
+                C attach(){return (C) super.attach()}
+            }
+        ''')
+        assert code.hasSequence([
+            "INVOKESPECIAL B.attach ()LB;"
+        ])
+    }
+}
