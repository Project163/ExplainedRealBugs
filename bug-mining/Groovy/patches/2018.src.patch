diff --git a/subprojects/groovy-swing/src/main/groovy/groovy/swing/factory/ListFactory.groovy b/subprojects/groovy-swing/src/main/groovy/groovy/swing/factory/ListFactory.groovy
index 9232992d72..b0cf8eadfc 100644
--- a/subprojects/groovy-swing/src/main/groovy/groovy/swing/factory/ListFactory.groovy
+++ b/subprojects/groovy-swing/src/main/groovy/groovy/swing/factory/ListFactory.groovy
@@ -18,6 +18,7 @@ package groovy.swing.factory
 
 import javax.swing.JList
 import groovy.swing.binding.JListMetaMethods
+import groovy.swing.impl.ListWrapperListModel
 
 /**
  * Create a JList, and handle the optional items attribute.
@@ -30,28 +31,26 @@ public class ListFactory extends AbstractFactory {
         // FactoryBuilderSupport.checkValueIsType(value, name, JList)
 
         JList list
-        Object items = attributes.get("items")
+        Object items = attributes.remove("items")
 
-        if (items instanceof Vector) {
-            list = new JList(attributes.remove("items"))
-        } else if (items instanceof List) {
-            List l = (List) attributes.remove("items")
-            list = new JList(l.toArray())
-        } else if (items instanceof Object[]) {
-            list = new JList(attributes.remove("items"))
-        } else if (value instanceof JList) {
+        if (value instanceof JList) {
             list = value
-        } else if (value instanceof Vector) {
+        } else if (value instanceof Vector || value instanceof Object[]){
             list = new JList(value)
         } else if (value instanceof List) {
-            List l = (List) value
-            list = new JList(l.toArray())
-        } else if (value instanceof Object[]) {
-            list = new JList(value)
+            list = new JList(new ListWrapperListModel(items))
         } else {
             list = new JList()
         }
 
+        if (items instanceof Vector) {
+            list.setListData((Vector) items)
+        } else if (items instanceof Object[]) {
+            list.setListData((Object[]) items)
+        } else if (items instanceof List) {
+            list.model = new ListWrapperListModel(items)
+        }
+
         JListMetaMethods.enhanceMetaClass(list)
         return list
     }
@@ -61,6 +60,8 @@ public class ListFactory extends AbstractFactory {
             def listData = attributes.remove("listData")
             if (listData instanceof Vector || listData instanceof Object[]) {
                 node.listData = listData
+            } else if (listData instanceof List) {
+                node.model = new ListWrapperListModel(listData)
             } else if (listData instanceof Collection) {
                 node.listData = listData.toArray()
             } else {
diff --git a/subprojects/groovy-swing/src/main/groovy/groovy/swing/impl/ListWrapperListModel.java b/subprojects/groovy-swing/src/main/groovy/groovy/swing/impl/ListWrapperListModel.java
new file mode 100644
index 0000000000..54b6445cb6
--- /dev/null
+++ b/subprojects/groovy-swing/src/main/groovy/groovy/swing/impl/ListWrapperListModel.java
@@ -0,0 +1,157 @@
+/*
+ * Copyright 2012 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package groovy.swing.impl;
+
+import javax.swing.*;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import java.util.ListIterator;
+
+/**
+ * A {@code ListModel} implementation that's backed by a live {@List}.
+ *
+ * @author Andres Almiray
+ */
+public class ListWrapperListModel<E> extends AbstractListModel {
+    private final List<E> delegate;
+
+    public ListWrapperListModel(List<E> delegateList) {
+        this.delegate = delegateList;
+    }
+
+    public List<E> getDelegateList() {
+        return delegate;
+    }
+
+    public int getSize() {
+        return delegate.size();
+    }
+
+    public Object getElementAt(int i) {
+        return delegate.get(i);
+    }
+
+    public E set(int i, E e) {
+        E element = delegate.set(i, e);
+        fireContentsChanged(this, i, i);
+        return element;
+    }
+
+    public void clear() {
+        int i = delegate.size() - 1;
+        delegate.clear();
+        if (i >= 0) {
+            fireIntervalRemoved(this, 0, i);
+        }
+    }
+
+    public int lastIndexOf(Object o) {
+        return delegate.lastIndexOf(o);
+    }
+
+    public boolean contains(Object o) {
+        return delegate.contains(o);
+    }
+
+    public ListIterator<E> listIterator() {
+        return delegate.listIterator();
+    }
+
+    public boolean isEmpty() {
+        return delegate.isEmpty();
+    }
+
+    public int indexOf(Object o) {
+        return delegate.indexOf(o);
+    }
+
+    public void add(int i, E e) {
+        int index = delegate.size();
+        delegate.add(i, e);
+        fireIntervalAdded(this, index, index);
+    }
+
+    public Iterator<E> iterator() {
+        return delegate.iterator();
+    }
+
+    public boolean addAll(Collection<? extends E> es) {
+        int i = delegate.size();
+        boolean added = delegate.addAll(es);
+        if (added) fireIntervalAdded(this, i, i + es.size());
+        return added;
+    }
+
+    public E remove(int i) {
+        E element = delegate.remove(i);
+        fireIntervalRemoved(this, i, i);
+        return element;
+    }
+
+    public boolean addAll(int i, Collection<? extends E> es) {
+        boolean added = delegate.addAll(i, es);
+        if (added) fireIntervalAdded(this, i, i + es.size());
+        return added;
+    }
+
+    public ListIterator<E> listIterator(int i) {
+        return delegate.listIterator(i);
+    }
+
+    public boolean containsAll(Collection<?> objects) {
+        return delegate.containsAll(objects);
+    }
+
+    public boolean remove(Object o) {
+        int i = indexOf(o);
+        boolean rv = delegate.remove(o);
+        if (i >= 0) {
+            fireIntervalRemoved(this, i, i);
+        }
+        return rv;
+    }
+
+    public boolean add(E e) {
+        int i = delegate.size();
+        boolean added = delegate.add(e);
+        if (added) fireIntervalAdded(this, i, i);
+        return added;
+    }
+
+    public E get(int i) {
+        return delegate.get(i);
+    }
+
+    public <T> T[] toArray(T[] ts) {
+        return delegate.toArray(ts);
+    }
+
+    public Object[] toArray() {
+        return delegate.toArray();
+    }
+
+    public void removeRange(int fromIndex, int toIndex) {
+        if (fromIndex > toIndex) {
+            throw new IllegalArgumentException("fromIndex must be <= toIndex");
+        }
+        for (int i = toIndex; i >= fromIndex; i--) {
+            delegate.remove(i);
+        }
+        fireIntervalRemoved(this, fromIndex, toIndex);
+    }
+}
\ No newline at end of file
diff --git a/subprojects/groovy-swing/src/test/groovy/groovy/swing/SwingBuilderTest.groovy b/subprojects/groovy-swing/src/test/groovy/groovy/swing/SwingBuilderTest.groovy
index 515c2feddc..bbb6c2d02d 100644
--- a/subprojects/groovy-swing/src/test/groovy/groovy/swing/SwingBuilderTest.groovy
+++ b/subprojects/groovy-swing/src/test/groovy/groovy/swing/SwingBuilderTest.groovy
@@ -466,6 +466,12 @@ class SwingBuilderTest extends GroovySwingTestCase {
             assert swing.list(listData: vector).model.size == 4
             assert swing.list(listData: "list").model.size == 4
             assert swing.list(listData: [a: 1, b: 2].collect { k, v -> v}).model.size == 2
+            def theList = swing.list(items: list)
+            list[1] = 'a'
+            assert theList.model.getElementAt(1) == 'a'
+            theList.model.add('z')
+            assert list.size() == 4
+            assert list[3] == 'z'
         }
     }
 
