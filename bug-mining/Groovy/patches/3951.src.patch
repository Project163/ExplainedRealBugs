diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 136f7fefdd..ca5943147a 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -1618,11 +1618,11 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
         for (Receiver<String> receiver : receivers) {
             ClassNode receiverType = receiver.getType();
-            ClassNode propertyType = getTypeForMapPropertyExpression(receiverType, objectExpressionType, pexp);
+            ClassNode propertyType = getTypeForMapPropertyExpression(receiverType, pexp);
             if (propertyType == null)
-                propertyType = getTypeForListPropertyExpression(receiverType, objectExpressionType, pexp);
+                propertyType = getTypeForListPropertyExpression(receiverType, pexp);
             if (propertyType == null)
-                propertyType = getTypeForSpreadExpression(receiverType, objectExpressionType, pexp);
+                propertyType = getTypeForSpreadExpression(receiverType, pexp);
             if (propertyType == null)
                 continue;
             if (visitor != null) {
@@ -1659,67 +1659,63 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         return getterMethod;
     }
 
-    private ClassNode getTypeForSpreadExpression(final ClassNode testClass, final ClassNode objectExpressionType, final PropertyExpression pexp) {
+    private ClassNode getTypeForMultiValueExpression(final ClassNode compositeType, final Expression prop) {
+        GenericsType[] gts = compositeType.getGenericsTypes();
+        ClassNode itemType = (gts != null && gts.length == 1 ? getCombinedBoundType(gts[0]) : OBJECT_TYPE);
+
+        AtomicReference<ClassNode> propertyType = new AtomicReference<>();
+        if (existsProperty(propX(varX("{}", itemType), prop), true, new PropertyLookupVisitor(propertyType))) {
+            return extension.buildListType(propertyType.get());
+        }
+        return null;
+    }
+
+    private ClassNode getTypeForSpreadExpression(final ClassNode testClass, final PropertyExpression pexp) {
         if (pexp.isSpreadSafe()) {
             MethodCallExpression mce = callX(varX("_", testClass), "iterator");
             mce.setImplicitThis(false);
             mce.visit(this);
             ClassNode iteratorType = getType(mce);
             if (isOrImplements(iteratorType, Iterator_TYPE)) {
-                GenericsType[] gts = iteratorType.getGenericsTypes();
-                ClassNode itemType = (gts != null && gts.length == 1 ? getCombinedBoundType(gts[0]) : OBJECT_TYPE);
-
-                AtomicReference<ClassNode> propertyType = new AtomicReference<>();
-                if (existsProperty(propX(varX("{}", itemType), pexp.getProperty()), true, new PropertyLookupVisitor(propertyType))) {
-                    return extension.buildListType(propertyType.get());
-                }
+                return getTypeForMultiValueExpression(iteratorType, pexp.getProperty());
             }
         }
         return null;
     }
 
-    private ClassNode getTypeForListPropertyExpression(final ClassNode testClass, final ClassNode objectExpressionType, final PropertyExpression pexp) {
-        if (!implementsInterfaceOrIsSubclassOf(testClass, LIST_TYPE)) return null;
-        ClassNode intf = GenericsUtils.parameterizeType(objectExpressionType, LIST_TYPE.getPlainNodeReference());
-        GenericsType[] types = intf.getGenericsTypes();
-        if (types == null || types.length != 1) return OBJECT_TYPE;
-
-        PropertyExpression subExp = new PropertyExpression(varX("{}", types[0].getType()), pexp.getPropertyAsString());
-        AtomicReference<ClassNode> result = new AtomicReference<>();
-        if (existsProperty(subExp, true, new PropertyLookupVisitor(result))) {
-            return extension.buildListType(result.get());
+    private ClassNode getTypeForListPropertyExpression(final ClassNode testClass, final PropertyExpression pexp) {
+        if (isOrImplements(testClass, LIST_TYPE)) {
+            ClassNode listType = testClass.equals(LIST_TYPE) ? testClass
+                    : GenericsUtils.parameterizeType(testClass, LIST_TYPE);
+            return getTypeForMultiValueExpression(listType, pexp.getProperty());
         }
         return null;
     }
 
-    private ClassNode getTypeForMapPropertyExpression(final ClassNode testClass, final ClassNode objectExpressionType, final PropertyExpression pexp) {
-        if (!implementsInterfaceOrIsSubclassOf(testClass, MAP_TYPE)) return null;
-        ClassNode intf;
-        if (objectExpressionType.getGenericsTypes() != null) {
-            intf = GenericsUtils.parameterizeType(objectExpressionType, MAP_TYPE.getPlainNodeReference());
-        } else {
-            intf = MAP_TYPE.getPlainNodeReference();
-        }
-        // 0 is the key, 1 is the value
-        GenericsType[] types = intf.getGenericsTypes();
-        if (types == null || types.length != 2) return OBJECT_TYPE;
+    private ClassNode getTypeForMapPropertyExpression(final ClassNode testClass, final PropertyExpression pexp) {
+        if (isOrImplements(testClass, MAP_TYPE)) {
+            ClassNode mapType = testClass.equals(MAP_TYPE) ? testClass
+                    : GenericsUtils.parameterizeType(testClass, MAP_TYPE);
+            GenericsType[] gts = mapType.getGenericsTypes();//<K,V>
+            if (gts == null || gts.length != 2) return OBJECT_TYPE;
 
-        if (pexp.isSpreadSafe()) {
-            // map*.property syntax
-            // only "key" and "value" are allowed
-            if ("key".equals(pexp.getPropertyAsString())) {
-                ClassNode listKey = LIST_TYPE.getPlainNodeReference();
-                listKey.setGenericsTypes(new GenericsType[]{types[0]});
-                return listKey;
-            } else if ("value".equals(pexp.getPropertyAsString())) {
-                ClassNode listValue = LIST_TYPE.getPlainNodeReference();
-                listValue.setGenericsTypes(new GenericsType[]{types[1]});
-                return listValue;
+            if (!pexp.isSpreadSafe()) {
+                return getCombinedBoundType(gts[1]);
             } else {
-                addStaticTypeError("Spread operator on map only allows one of [key,value]", pexp);
+                // map*.property syntax acts on Entry
+                switch (pexp.getPropertyAsString()) {
+                case "key":
+                    ClassNode keyList = LIST_TYPE.getPlainNodeReference();
+                    keyList.setGenericsTypes(new GenericsType[]{gts[0]});
+                    return keyList;
+                case "value":
+                    ClassNode valueList = LIST_TYPE.getPlainNodeReference();
+                    valueList.setGenericsTypes(new GenericsType[]{gts[1]});
+                    return valueList;
+                default:
+                    addStaticTypeError("Spread operator on map only allows one of [key,value]", pexp);
+                }
             }
-        } else {
-            return types[1].getType();
         }
         return null;
     }
diff --git a/src/test/groovy/transform/stc/GenericsSTCTest.groovy b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
index 469a0dc185..90d27c59cb 100644
--- a/src/test/groovy/transform/stc/GenericsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
@@ -2298,35 +2298,37 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
         '''
 
         // GROOVY-9821
-        config.with {
-            targetDirectory = File.createTempDir()
-            jointCompilationOptions = [memStub: true]
-        }
-        File parentDir = File.createTempDir()
-        try {
-            def a = new File(parentDir, 'Types.java')
-            a.write '''
-                interface A {
-                    java.util.Collection<? extends B> getBees();
-                }
-                interface B {
-                    Object getC();
-                }
-            '''
-            def b = new File(parentDir, 'Script.groovy')
-            b.write '''
-                def test(A a) {
-                    a.bees*.c
-                }
-            '''
+        ['.', '?.', '*.'].each { op ->
+            config.with {
+                targetDirectory = File.createTempDir()
+                jointCompilationOptions = [memStub: true]
+            }
+            File parentDir = File.createTempDir()
+            try {
+                def a = new File(parentDir, 'Types.java')
+                a.write '''
+                    interface A {
+                        java.util.List<? extends B> getBees();
+                    }
+                    interface B {
+                        Object getC();
+                    }
+                '''
+                def b = new File(parentDir, 'Script.groovy')
+                b.write """
+                    def test(A a) {
+                        a.bees${op}c
+                    }
+                """
 
-            def loader = new GroovyClassLoader(this.class.classLoader)
-            def cu = new JavaAwareCompilationUnit(config, loader)
-            cu.addSources(a, b)
-            cu.compile()
-        } finally {
-            parentDir.deleteDir()
-            config.targetDirectory.deleteDir()
+                def loader = new GroovyClassLoader(this.class.classLoader)
+                def cu = new JavaAwareCompilationUnit(config, loader)
+                cu.addSources(a, b)
+                cu.compile()
+            } finally {
+                parentDir.deleteDir()
+                config.targetDirectory.deleteDir()
+            }
         }
     }
 
