diff --git a/src/main/org/codehaus/groovy/ast/ModuleNode.java b/src/main/org/codehaus/groovy/ast/ModuleNode.java
index 1e7c20ff1e..065ed9c12f 100644
--- a/src/main/org/codehaus/groovy/ast/ModuleNode.java
+++ b/src/main/org/codehaus/groovy/ast/ModuleNode.java
@@ -276,6 +276,8 @@ public class ModuleNode extends ASTNode implements Opcodes {
             return classNode;
         }
         
+        handleMainMethodIfPresent(methods);
+
         // return new Foo(new ShellContext(args)).run()
         classNode.addMethod(
             new MethodNode(
@@ -325,6 +327,34 @@ public class ModuleNode extends ASTNode implements Opcodes {
         return classNode;
     }
 
+    /*
+     * If a main method is provided by user, account for it under run() as scripts generate their own 'main' so they can run.  
+     */
+    private void handleMainMethodIfPresent(List methods) {
+        for (Iterator iter = methods.iterator(); iter.hasNext();) {
+            MethodNode node = (MethodNode) iter.next();
+            if(node.getName().equals("main")) {
+                int modifiers = node.getModifiers();
+                if (node.isStatic() && node.getParameters().length == 1) {
+                    boolean retTypeMatches, argTypeMatches;
+                    ClassNode argType = node.getParameters()[0].getType();
+                    ClassNode retType = node.getReturnType();
+
+                    argTypeMatches = (argType.equals(ClassHelper.OBJECT_TYPE) || argType.getName().contains("String[]"));
+                    retTypeMatches = (retType == ClassHelper.VOID_TYPE || retType == ClassHelper.OBJECT_TYPE);
+                    
+                    if(retTypeMatches && argTypeMatches) {
+                        // if script has both loose statements as well as main(), then main() is ignored
+                        if(statementBlock.isEmpty()) {
+                            addStatement(node.getCode());
+                        }
+                        iter.remove();
+                    }
+                }
+            }
+        }
+    }
+
     protected String extractClassFromFileDescription() {
         // let's strip off everything after the last '.'
         String answer = getDescription();
diff --git a/src/test/groovy/bugs/Groovy3749Bug.groovy b/src/test/groovy/bugs/Groovy3749Bug.groovy
new file mode 100644
index 0000000000..36c6bf4a7a
--- /dev/null
+++ b/src/test/groovy/bugs/Groovy3749Bug.groovy
@@ -0,0 +1,73 @@
+package groovy.bugs
+
+class Groovy3749Bug extends GroovyTestCase {
+    void testScriptsProvidingStaticMainMethod() {
+        def scriptStr
+        
+        // test various signatures of main()
+        scriptStr = """
+            static main(args) {
+                throw new RuntimeException('main called')
+            }
+        """
+        verifyScriptRun(scriptStr, "RuntimeException")
+        
+        scriptStr = """
+            static def main(args) {
+                throw new RuntimeException('main called')
+            }
+        """
+        verifyScriptRun(scriptStr, "RuntimeException")
+        
+        scriptStr = """
+            static void main(args) {
+                throw new RuntimeException('main called')
+            }
+        """
+        verifyScriptRun(scriptStr, "RuntimeException")
+
+        scriptStr = """
+            static main(String[] args) {
+                throw new RuntimeException('main called')
+            }
+        """
+        verifyScriptRun(scriptStr, "RuntimeException")
+
+        scriptStr = """
+            static def main(String[] args) {
+                throw new RuntimeException('main called')
+            }
+        """
+        verifyScriptRun(scriptStr, "RuntimeException")
+
+        scriptStr = """
+            static void main(String[] args) {
+                throw new RuntimeException('main called')
+            }
+        """
+        verifyScriptRun(scriptStr, "RuntimeException")
+        
+        // if both main() and the loose statements are provided, then the loose statements should run and not main
+        scriptStr = """
+            static main(args) {
+                throw new RuntimeException('main called')
+            }
+            throw new Error()
+        """
+        verifyScriptRun(scriptStr, "Error")
+        
+        assertScript """
+            def main(args) {
+                throw new RuntimeException('main called')
+            }
+        """
+    }
+    
+    void verifyScriptRun(scriptText, expectedFailure) {
+        try{
+            assertScript(scriptText)
+        }catch(Throwable ex) {
+            assertTrue ex.class.name.contains(expectedFailure) 
+        }
+    }
+}
