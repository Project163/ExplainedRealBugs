diff --git a/src/main/org/codehaus/groovy/ast/tools/GenericsUtils.java b/src/main/org/codehaus/groovy/ast/tools/GenericsUtils.java
index 8257574c2c..7aed9efb34 100644
--- a/src/main/org/codehaus/groovy/ast/tools/GenericsUtils.java
+++ b/src/main/org/codehaus/groovy/ast/tools/GenericsUtils.java
@@ -259,7 +259,10 @@ public class GenericsUtils {
 
     public static ClassNode makeClassSafe0(ClassNode type, GenericsType... genericTypes) {
         ClassNode plainNodeReference = newClass(type);
-        if (genericTypes != null && genericTypes.length > 0) plainNodeReference.setGenericsTypes(genericTypes);
+        if (genericTypes != null && genericTypes.length > 0) {
+            plainNodeReference.setGenericsTypes(genericTypes);
+            if (type.isGenericsPlaceHolder()) plainNodeReference.setGenericsPlaceHolder(true);
+        }
         return plainNodeReference;
     }
 
@@ -293,6 +296,11 @@ public class GenericsUtils {
         if (type.isGenericsPlaceHolder()) {
             String name = type.getGenericsTypes()[0].getName();
             type = genericsSpec.get(name);
+            if (type != null && type.isGenericsPlaceHolder() && type.getGenericsTypes() == null) {
+                ClassNode placeholder = ClassHelper.makeWithoutCaching(type.getUnresolvedName());
+                placeholder.setGenericsPlaceHolder(true);
+                type = makeClassSafeWithGenerics(type, new GenericsType(placeholder));
+            }
         }
         if (type == null) type = ClassHelper.OBJECT_TYPE;
         GenericsType[] oldgTypes = type.getGenericsTypes();
diff --git a/src/main/org/codehaus/groovy/transform/InheritConstructorsASTTransformation.java b/src/main/org/codehaus/groovy/transform/InheritConstructorsASTTransformation.java
index e31a51aa26..f9b0c7a3b7 100644
--- a/src/main/org/codehaus/groovy/transform/InheritConstructorsASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/InheritConstructorsASTTransformation.java
@@ -28,12 +28,17 @@ import org.codehaus.groovy.control.SourceUnit;
 
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Map;
 
 import static org.codehaus.groovy.ast.ClassHelper.make;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.args;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.block;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.ctorSuperS;
+import static org.codehaus.groovy.ast.tools.GeneralUtils.param;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.varX;
+import static org.codehaus.groovy.ast.tools.GenericsUtils.correctToGenericsSpecRecurse;
+import static org.codehaus.groovy.ast.tools.GenericsUtils.createGenericsSpec;
+import static org.codehaus.groovy.ast.tools.GenericsUtils.extractSuperClassGenerics;
 
 /**
  * Handles generation of code for the {@code @}InheritConstructors annotation.
@@ -83,12 +88,13 @@ public class InheritConstructorsASTTransformation extends AbstractASTTransformat
         if (consNode.isPrivate()) return;
         Parameter[] params = new Parameter[origParams.length];
         List<Expression> theArgs = new ArrayList<Expression>();
+        Map<String, ClassNode> genericsSpec = createGenericsSpec(classNode);
+        extractSuperClassGenerics(classNode, classNode.getSuperClass(), genericsSpec);
         for (int i = 0; i < origParams.length; i++) {
             Parameter p = origParams[i];
-            params[i] = p.hasInitialExpression() ?
-                    new Parameter(p.getType(), p.getName(), p.getInitialExpression()) :
-                    new Parameter(p.getType(), p.getName());
-            theArgs.add(varX(p.getName(), p.getType()));
+            ClassNode newType = correctToGenericsSpecRecurse(genericsSpec, p.getType());
+            params[i] = p.hasInitialExpression() ? param(newType, p.getName(), p.getInitialExpression()) : param(newType, p.getName());
+            theArgs.add(varX(p.getName(), newType));
         }
         if (isExisting(classNode, params)) return;
         classNode.addConstructor(consNode.getModifiers(), params, consNode.getExceptions(), block(ctorSuperS(args(theArgs))));
diff --git a/src/test/org/codehaus/groovy/transform/InheritConstructorsTransformTest.groovy b/src/test/org/codehaus/groovy/transform/InheritConstructorsTransformTest.groovy
index a322b95728..a421dcc7ab 100644
--- a/src/test/org/codehaus/groovy/transform/InheritConstructorsTransformTest.groovy
+++ b/src/test/org/codehaus/groovy/transform/InheritConstructorsTransformTest.groovy
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2012 the original author or authors.
+ * Copyright 2008-2014 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -86,4 +86,44 @@ class InheritConstructorsTransformTest extends GroovyShellTestCase {
         """
     }
 
+    void testParametersWithGenericsAndCompileStatic_GROOVY6874() {
+        assertScript """
+            import groovy.transform.*
+            import java.math.RoundingMode
+
+            @CompileStatic
+            abstract class BasePublisher<T, U> {
+               final Deque<T> items
+               private U mode
+               BasePublisher(Deque<T> items) { this.items = items }
+               BasePublisher(U mode) {
+                  this.mode = mode
+                  this.items = []
+               }
+               BasePublisher(Set<U> modes) { this(modes[0]) }
+               void publish(T item) { items.addFirst(item) }
+               void init(U mode) { this.mode = mode }
+               String toString() { items.join('|') + "|" + mode.toString() }
+            }
+
+            @CompileStatic @InheritConstructors
+            class OrderPublisher<V> extends BasePublisher<Integer, V> {
+              static OrderPublisher make() {
+                new OrderPublisher<RoundingMode>(new LinkedList<Integer>())
+              }
+              void foo() { publish(3) }
+              void bar(V mode) { init(mode) }
+              void baz() {
+                new OrderPublisher<RoundingMode>(RoundingMode.UP)
+                new OrderPublisher<RoundingMode>(new HashSet<RoundingMode>())
+              }
+            }
+
+            def op = OrderPublisher.make()
+            op.foo()
+            op.bar(RoundingMode.DOWN)
+            assert op.toString() == '3|DOWN'
+        """
+    }
+
 }
\ No newline at end of file
