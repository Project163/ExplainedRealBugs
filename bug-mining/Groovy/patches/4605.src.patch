diff --git a/src/main/java/org/codehaus/groovy/ast/expr/FieldExpression.java b/src/main/java/org/codehaus/groovy/ast/expr/FieldExpression.java
index c221dfc80e..78a4c028a3 100644
--- a/src/main/java/org/codehaus/groovy/ast/expr/FieldExpression.java
+++ b/src/main/java/org/codehaus/groovy/ast/expr/FieldExpression.java
@@ -84,6 +84,6 @@ public class FieldExpression extends Expression {
 
     @Override
     public String toString() {
-        return "field(" + getType() + " " + getFieldName() + ")";
+        return "field(" + getType().toString(false) + " " + getFieldName() + ")";
     }
 }
diff --git a/src/main/java/org/codehaus/groovy/transform/MapConstructorASTTransformation.java b/src/main/java/org/codehaus/groovy/transform/MapConstructorASTTransformation.java
index 2361c181ff..4c51b5af2d 100644
--- a/src/main/java/org/codehaus/groovy/transform/MapConstructorASTTransformation.java
+++ b/src/main/java/org/codehaus/groovy/transform/MapConstructorASTTransformation.java
@@ -157,7 +157,7 @@ public class MapConstructorASTTransformation extends AbstractASTTransformation i
         properties.addAll(getAllProperties(names, cNode, cNode, includeProperties, includeFields, includePseudoGetters, includePseudoSetters, /*super*/false, skipReadOnly, /*reverse*/false, allNames, includeStatic));
 
         BlockStatement body = new BlockStatement();
-        ClassCodeExpressionTransformer transformer = makeMapTypedArgsTransformer();
+        ClassCodeExpressionTransformer transformer = makeMapTypedArgsTransformer(source);
         if (pre != null) {
             ClosureExpression transformed = (ClosureExpression) transformer.transform(pre);
             copyStatementsWithSuperAdjustment(transformed, body);
@@ -170,7 +170,7 @@ public class MapConstructorASTTransformation extends AbstractASTTransformation i
         Parameter map = new Parameter(MAP_TYPE, "args");
         boolean specialNamedArgsCase = specialNamedArgHandling
                 && ImmutableASTTransformation.isSpecialNamedArgCase(properties, true);
-        processProps(xform, anno, cNode, handler, allNames, excludes, includes, properties, map, inner);
+        createInitializers(xform, anno, cNode, handler, allNames, excludes, includes, properties, map, inner);
         if (specialNamedArgsCase) map = new Parameter(LHMAP_TYPE, "args");
         body.addStatement(inner);
         if (post != null) {
@@ -188,11 +188,6 @@ public class MapConstructorASTTransformation extends AbstractASTTransformation i
             ConstructorNode ctor = addGeneratedConstructor(cNode, mods, parameters, ClassNode.EMPTY_ARRAY, body);
             // GROOVY-5814: fix compatibility with @CompileStatic
             ClassCodeVisitorSupport variableExpressionFix = new ClassCodeVisitorSupport() {
-                @Override
-                protected SourceUnit getSourceUnit() {
-                    return cNode.getModule().getContext();
-                }
-
                 @Override
                 public void visitVariableExpression(final VariableExpression expression) {
                     super.visitVariableExpression(expression);
@@ -200,6 +195,11 @@ public class MapConstructorASTTransformation extends AbstractASTTransformation i
                         expression.setAccessedVariable(args);
                     }
                 }
+
+                @Override
+                protected SourceUnit getSourceUnit() {
+                    return cNode.getModule().getContext();
+                }
             };
             variableExpressionFix.visitConstructor(ctor);
         }
@@ -208,18 +208,18 @@ public class MapConstructorASTTransformation extends AbstractASTTransformation i
         }
     }
 
-    private static void processProps(AbstractASTTransformation xform, AnnotationNode anno, ClassNode cNode, PropertyHandler handler, boolean allNames, List<String> excludes, List<String> includes, List<PropertyNode> superList, Parameter map, BlockStatement inner) {
-        for (PropertyNode pNode : superList) {
+    private static void createInitializers(final AbstractASTTransformation xform, final AnnotationNode aNode, final ClassNode cNode, final PropertyHandler handler, final boolean allNames, final List<String> excludes, final List<String> includes, final List<PropertyNode> list, final Parameter map, final BlockStatement block) {
+        for (PropertyNode pNode : list) {
             String name = pNode.getName();
             if (shouldSkipUndefinedAware(name, excludes, includes, allNames)) continue;
-            Statement propInit = handler.createPropInit(xform, anno, cNode, pNode, map);
+            Statement propInit = handler.createPropInit(xform, aNode, cNode, pNode, map);
             if (propInit != null) {
-                inner.addStatement(propInit);
+                block.addStatement(propInit);
             }
         }
     }
 
-    private static ClassCodeExpressionTransformer makeMapTypedArgsTransformer() {
+    private static ClassCodeExpressionTransformer makeMapTypedArgsTransformer(final SourceUnit unit) {
         return new ClassCodeExpressionTransformer() {
             @Override
             public Expression transform(final Expression exp) {
@@ -239,7 +239,7 @@ public class MapConstructorASTTransformation extends AbstractASTTransformation i
 
             @Override
             protected SourceUnit getSourceUnit() {
-                return null;
+                return unit;
             }
         };
     }
diff --git a/src/main/java/org/codehaus/groovy/transform/TupleConstructorASTTransformation.java b/src/main/java/org/codehaus/groovy/transform/TupleConstructorASTTransformation.java
index 007b8ad682..6aefc8afd6 100644
--- a/src/main/java/org/codehaus/groovy/transform/TupleConstructorASTTransformation.java
+++ b/src/main/java/org/codehaus/groovy/transform/TupleConstructorASTTransformation.java
@@ -336,7 +336,6 @@ public class TupleConstructorASTTransformation extends AbstractASTTransformation
           case AUTO:
               if (init != null) {
                   param.setInitialExpression(init);
-                  fNode.setInitialValueExpression(null); // GROOVY-10238
               }
             break;
           default:
diff --git a/src/main/java/org/codehaus/groovy/transform/sc/StaticCompilationVisitor.java b/src/main/java/org/codehaus/groovy/transform/sc/StaticCompilationVisitor.java
index 871c9ae88f..ee7f9275e9 100644
--- a/src/main/java/org/codehaus/groovy/transform/sc/StaticCompilationVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/sc/StaticCompilationVisitor.java
@@ -63,11 +63,10 @@ import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
 
+import static org.apache.groovy.ast.tools.AnnotatedNodeUtils.hasAnnotation;
 import static org.codehaus.groovy.ast.ClassHelper.LIST_TYPE;
 import static org.codehaus.groovy.ast.ClassHelper.OBJECT_TYPE;
 import static org.codehaus.groovy.ast.ClassHelper.int_TYPE;
-import static org.codehaus.groovy.ast.ClassHelper.isStringType;
-import static org.codehaus.groovy.ast.ClassHelper.isWrapperCharacter;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.args;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.assignS;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.attrX;
@@ -139,13 +138,14 @@ public class StaticCompilationVisitor extends StaticTypeCheckingVisitor {
             node.putNodeMetaData(MopWriter.Factory.class, StaticCompilationMopWriter.FACTORY);
         }
 
-        node.getInnerClasses().forEachRemaining(innerClassNode -> {
-            boolean innerClassSkip = !(skip || isSkippedInnerClass(innerClassNode));
-            innerClassNode.putNodeMetaData(STATIC_COMPILE_NODE, Boolean.valueOf(innerClassSkip));
-            innerClassNode.putNodeMetaData(WriterControllerFactory.class, node.getNodeMetaData(WriterControllerFactory.class));
-            if (innerClassSkip && !anyMethodSkip(innerClassNode)) {
-                innerClassNode.putNodeMetaData(MopWriter.Factory.class, StaticCompilationMopWriter.FACTORY);
+        node.getInnerClasses().forEachRemaining(innerClass -> {
+            boolean isSC = !isSkipMode(innerClass) && (isStaticallyCompiled(node) || hasAnnotation(innerClass, COMPILESTATIC_CLASSNODE));
+            // GROOVY-10238: @CompileDynamic outer class, @CompileStatic inner class ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+            innerClass.putNodeMetaData(STATIC_COMPILE_NODE, Boolean.valueOf(isSC));
+            if (isSC && !anyMethodSkip(innerClass)) {
+                innerClass.putNodeMetaData(MopWriter.Factory.class, StaticCompilationMopWriter.FACTORY);
             }
+            innerClass.putNodeMetaData(WriterControllerFactory.class, node.getNodeMetaData(WriterControllerFactory.class));
         });
 
         super.visitClass(node);
@@ -265,7 +265,7 @@ public class StaticCompilationVisitor extends StaticTypeCheckingVisitor {
             ClassNode forLoopVariableType = statement.getVariableType();
             ClassNode collectionType = getType(collectionExpression);
             ClassNode componentType;
-            if (isWrapperCharacter(ClassHelper.getWrapper(forLoopVariableType)) && isStringType(collectionType)) {
+            if (ClassHelper.isWrapperCharacter(ClassHelper.getWrapper(forLoopVariableType)) && ClassHelper.isStringType(collectionType)) {
                 // we allow auto-coercion here
                 componentType = forLoopVariableType;
             } else {
diff --git a/src/test/org/codehaus/groovy/transform/TupleConstructorTransformTest.groovy b/src/test/org/codehaus/groovy/transform/TupleConstructorTransformTest.groovy
index 42b585ed97..a50a986125 100644
--- a/src/test/org/codehaus/groovy/transform/TupleConstructorTransformTest.groovy
+++ b/src/test/org/codehaus/groovy/transform/TupleConstructorTransformTest.groovy
@@ -18,7 +18,6 @@
  */
 package org.codehaus.groovy.transform
 
-import groovy.test.NotYetImplemented
 import org.junit.Test
 
 import static groovy.test.GroovyAssert.assertScript
@@ -526,6 +525,41 @@ final class TupleConstructorTransformTest {
         '''
     }
 
+    // GROOVY-10919
+    @Test
+    void testNamedVariant() {
+        assertScript shell, '''
+            @TupleConstructor(includeFields=true, namedVariant=true)
+            @ToString(includeFields=true, includeNames=true)
+            class Foo {
+                private final int x
+                private       int y = 1
+                private final int z
+            }
+
+            String string = new Foo(x:2, z:3)
+            assert string == 'Foo(x:2, y:1, z:3)'
+        '''
+    }
+
+    // GROOVY-10925
+    @Test
+    void testNamedVariant2() {
+        def err = shouldFail shell, '''
+            @TupleConstructor(includeFields=true, namedVariant=true)
+            @ToString(includeNames=true, includeFields=true)
+            class Foo {
+                private final int x = 1
+                private       int y = 2
+                private final int z
+            }
+
+            String string = new Foo(x:3, y:3, z:3)
+            assert string == 'Foo(x:3, y:3, z:3)'
+        '''
+        assert err =~ /Unrecognized namedArgKey: x/
+    }
+
     // GROOVY-10790
     @Test
     void testWithMapConstructor() {
@@ -554,7 +588,7 @@ final class TupleConstructorTransformTest {
     }
 
     // GROOVY-10919
-    @NotYetImplemented @Test
+    @Test
     void testWithMapConstructor2() {
         assertScript shell, '''
             @MapConstructor(includeFields=true)
