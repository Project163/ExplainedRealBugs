diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
index 18817e9372..ececcfbf00 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
@@ -881,7 +881,7 @@ public abstract class StaticTypeCheckingSupport {
         if (type.isArray()) {
             return prettyPrintTypeName(type.getComponentType()) + "[]";
         }
-        return type.getText();
+        return type.isGenericsPlaceHolder() ? type.getUnresolvedName() : type.getText();
     }
 
     public static boolean implementsInterfaceOrIsSubclassOf(final ClassNode type, final ClassNode superOrInterface) {
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index d000776e53..c605696c67 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -866,7 +866,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                     } else { // GROOVY-10235, et al.
                         Map<GenericsTypeName, GenericsType> gt = new HashMap<>();
                         extractGenericsConnections(gt, resultType, resultType.redirect());
-                        extractGenericsConnections(gt, lType, ClassHelper.getNextSuperClass(resultType, lType));
+                        extractGenericsConnections(gt, lType, getNextSuperClass(resultType, lType));
 
                         resultType = applyGenericsContext(gt, resultType.redirect());
                     }
@@ -3816,10 +3816,10 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 addTraitType(staticType, owners); // T in Class<T$Trait$Helper>
                 owners.add(Receiver.make(receiver)); // Class<Type>
             } else {
-                owners.add(Receiver.make(receiver));
+                addBoundType(receiver, owners);
                 addSelfTypes(receiver, owners);
                 addTraitType(receiver, owners);
-                if (receiver.isInterface()) {
+                if (receiver.redirect().isInterface()) {
                     owners.add(Receiver.make(OBJECT_TYPE));
                 }
             }
@@ -3827,6 +3827,23 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         return owners;
     }
 
+    private static void addBoundType(final ClassNode receiver, final List<Receiver<String>> owners) {
+        if (!receiver.isGenericsPlaceHolder() || receiver.getGenericsTypes() == null) {
+            owners.add(Receiver.make(receiver));
+            return;
+        }
+
+        GenericsType gt = receiver.getGenericsTypes()[0];
+        if (gt.getLowerBound() == null && gt.getUpperBounds() != null) {
+            for (ClassNode cn : gt.getUpperBounds()) { // T extends C & I
+                addBoundType(cn, owners);
+                addSelfTypes(cn, owners);
+            }
+        } else {
+            owners.add(Receiver.make(OBJECT_TYPE)); // T or T super Type
+        }
+    }
+
     private static void addSelfTypes(final ClassNode receiver, final List<Receiver<String>> owners) {
         for (ClassNode selfType : Traits.collectSelfTypes(receiver, new LinkedHashSet<>())) {
             owners.add(Receiver.make(selfType));
@@ -5944,71 +5961,17 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         ParameterVariableExpression(final Parameter parameter) {
             super(parameter);
             this.parameter = parameter;
-            ClassNode inferred = parameter.getNodeMetaData(INFERRED_TYPE);
-            if (inferred == null) {
-                inferred = infer(parameter);
-
-                parameter.setNodeMetaData(INFERRED_TYPE, inferred);
-            }
-        }
-
-        private static ClassNode infer(final Variable variable) {
-            ClassNode originType = variable.getOriginType();
-
-            if (originType.isGenericsPlaceHolder()) {
-                GenericsType[] genericsTypes = originType.getGenericsTypes();
-
-                if (genericsTypes != null && genericsTypes.length > 0) {
-                    GenericsType gt = genericsTypes[0];
-                    ClassNode[] upperBounds = gt.getUpperBounds();
-
-                    if (upperBounds != null && upperBounds.length > 0) {
-                        return upperBounds[0];
-                    }
-                }
-            }
-
-            return originType;
-        }
-
-        @Override
-        public void copyNodeMetaData(final ASTNode other) {
-            parameter.copyNodeMetaData(other);
-        }
-
-        @Override
-        public Object putNodeMetaData(final Object key, final Object value) {
-            return parameter.putNodeMetaData(key, value);
-        }
-
-        @Override
-        public void removeNodeMetaData(final Object key) {
-            parameter.removeNodeMetaData(key);
-        }
-
-        @Override
-        public Map<?, ?> getNodeMetaData() {
-            return parameter.getNodeMetaData();
-        }
-
-        @Override
-        public <T> T getNodeMetaData(final Object key) {
-            return parameter.getNodeMetaData(key);
-        }
-
-        @Override
-        public void setNodeMetaData(final Object key, final Object value) {
-            parameter.setNodeMetaData(key, value);
+            this.parameter.getNodeMetaData(INFERRED_TYPE, x -> parameter.getOriginType());
         }
 
         @Override
-        public int hashCode() {
-            return parameter.hashCode();
+        public Map<?, ?> getMetaDataMap() {
+            return parameter.getMetaDataMap();
         }
 
         @Override
-        public boolean equals(final Object other) {
-            return parameter.equals(other);
+        public void setMetaDataMap(final Map<?, ?> metaDataMap) {
+            parameter.setMetaDataMap(metaDataMap);
         }
     }
 
diff --git a/src/test/groovy/transform/stc/GenericsSTCTest.groovy b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
index 76edb2316e..93d8b68556 100644
--- a/src/test/groovy/transform/stc/GenericsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
@@ -18,6 +18,7 @@
  */
 package groovy.transform.stc
 
+import groovy.test.NotYetImplemented
 import org.codehaus.groovy.tools.javac.JavaAwareCompilationUnit
 
 /**
@@ -2483,29 +2484,23 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
     void testOutOfBoundsByExtendsPlaceholderParameterType() {
         shouldFailWithMessages '''
             class Foo {
-                static <T extends List<? extends CharSequence>> void bar(T a) {}
+                static <T extends List<? extends CharSequence>> void bar(T list) {}
             }
-            class Baz {
-                static <T extends List<Object>> void qux(T a) {
-                    Foo.bar(a)
-                }
+            def <U extends List<Object>> void baz(U list) {
+                Foo.bar(list)
             }
-            Baz.qux([new Object()])
-        ''', 'Cannot call <T extends java.util.List<? extends java.lang.CharSequence>> Foo#bar(T) with arguments [java.util.List<java.lang.Object>]'
+        ''', 'Cannot call <T extends java.util.List<? extends java.lang.CharSequence>> Foo#bar(T) with arguments [U]'
     }
 
     void testOutOfBoundsBySuperPlaceholderParameterType() {
         shouldFailWithMessages '''
             class Foo {
-                static <T extends List<? super CharSequence>> void bar(T a) {}
+                static <T extends List<? super CharSequence>> void bar(T list) {}
             }
-            class Baz {
-                static <T extends List<String>> void qux(T a) {
-                    Foo.bar(a)
-                }
+            def <U extends List<String>> void baz(U list) {
+                Foo.bar(list)
             }
-            Baz.qux(['abc'])
-        ''', 'Cannot call <T extends java.util.List<? super java.lang.CharSequence>> Foo#bar(T) with arguments [java.util.List<java.lang.String>]'
+        ''', 'Cannot call <T extends java.util.List<? super java.lang.CharSequence>> Foo#bar(T) with arguments [U]'
     }
 
     // GROOVY-5721
@@ -2922,8 +2917,8 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
         '#foo(java.util.List<? extends A>) with arguments [java.util.ArrayList<java.lang.Object>]'
     }
 
+    // GROOVY-5891
     void testMethodLevelGenericsForMethodCall() {
-        // Groovy-5891
         assertScript '''
             public <T extends List<Integer>> T foo(Class<T> type, def x) {
                 return type.cast(x)
@@ -2937,24 +2932,116 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
             }
             def cl = {1}
             assert foo(cl.class, cl) == cl
-         '''
-         assertScript '''
+        '''
+        assertScript '''
             public <T extends Runnable> T foo(Class<T> type, def x) {
                 return type.cast(x) as T
             }
             def cl = {1}
             assert foo(cl.class, cl) == cl
-         '''
-         // GROOVY-5885
-         assertScript '''
+        '''
+    }
+
+    // GROOVY-5885
+    void testMethodLevelGenericsForMethodCall2() {
+        assertScript '''
             class Test {
-                public <X extends Test> X castToMe(Class<X> type, Object o) {
+                public <T extends Test> T castToMe(Class<T> type, Object o) {
                     return type.cast(o);
                 }
             }
             def t = new Test()
-            assert t.castToMe(Test, t)  == t
-         '''
+            assert t == t.castToMe(Test, t)
+        '''
+    }
+
+    // GROOVY-6919
+    void testMethodLevelGenericsForMethodCall3() {
+        assertScript '''
+            interface I1 {
+                String getFoo()
+            }
+            interface I2 {
+                String getBar()
+            }
+            def <T extends I1 & I2> void test(T obj) {
+                obj?.getFoo()
+                obj?.getBar()
+            }
+            test(null)
+        '''
+    }
+
+    // GROOVY-6919
+    void testMethodLevelGenericsForPropertyRead() {
+        assertScript '''
+            interface I1 {
+                String getFoo()
+            }
+            interface I2 {
+                String getBar()
+            }
+            def <T extends I1 & I2> void test(T obj) {
+                obj?.foo
+                obj?.bar
+            }
+            test(null)
+        '''
+    }
+
+    @NotYetImplemented
+    void testMethodLevelGenericsForPropertyRead2() {
+        assertScript '''
+            interface I1 {
+                static String getFoo() { 'foo' }
+            }
+            interface I2 {
+                String bar = 'bar'
+            }
+            def <T extends I1 & I2> void test(Class<T> cls) {
+                cls?.foo
+                cls?.bar
+            }
+            test(null)
+        '''
+    }
+
+    void testMethodLevelGenericsForPropertyRead3() {
+        assertScript '''
+            interface I1 {
+                String getFoo()
+            }
+            interface I2 {
+                String getBar()
+            }
+            class C<T extends I1 & I2> {
+                def <U extends T> void test(U obj) {
+                    obj?.foo
+                    obj?.bar
+                }
+            }
+            new C().test(null)
+        '''
+    }
+
+    void testMethodLevelGenericsForPropertyRead4() {
+        assertScript '''
+            interface I1 {
+                String getFoo()
+            }
+            interface I2 {
+                String getBar()
+            }
+            @groovy.transform.SelfType(I2) trait T2 {
+                abstract String getBaz()
+            }
+            def <T extends I1 & T2> void test(T obj) {
+                obj?.foo
+                obj?.bar
+                obj?.baz
+            }
+            test(null)
+        '''
     }
 
     // GROOVY-5839
