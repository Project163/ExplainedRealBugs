diff --git a/subprojects/groovy-sql/src/main/java/groovy/sql/ExtractIndexAndSql.java b/subprojects/groovy-sql/src/main/java/groovy/sql/ExtractIndexAndSql.java
new file mode 100644
index 0000000000..3a9f7f58e6
--- /dev/null
+++ b/subprojects/groovy-sql/src/main/java/groovy/sql/ExtractIndexAndSql.java
@@ -0,0 +1,195 @@
+/*
+ * Copyright 2003-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package groovy.sql;
+
+import groovy.lang.Tuple;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ * Extracts and indexes named parameters from a sql string.
+ *
+ * This class is package-private scoped and is only intended for internal use.
+ *
+ * @see groovy.sql.Sql
+ */
+class ExtractIndexAndSql {
+
+    private static final Pattern NAMED_QUERY_PATTERN = Pattern.compile("(?<!:)(:)(\\w+)|\\?(\\d*)(?:\\.(\\w+))?");
+    private static final char QUOTE = '\'';
+
+    private final String sql;
+    private List<Tuple> indexPropList;
+    private String newSql;
+
+    /**
+     * Used to track the current position within the sql while parsing
+     */
+    private int index = 0;
+
+    /**
+     * Static factory method used to create a new instance.  Since parsing of the input
+     * is required, this ensures the object is fully initialized.
+     *
+     * @param sql statement to be parsed
+     * @return an instance of {@link ExtractIndexAndSql}
+     */
+    static ExtractIndexAndSql from(String sql) {
+        return new ExtractIndexAndSql(sql).invoke();
+    }
+
+    /**
+     * Checks a sql statement to determine whether it contains parameters.
+     *
+     * @param sql statement
+     * @return {@code true} if the statement contains named parameters, otherwise {@code false}
+     */
+    static boolean hasNamedParameters(String sql) {
+        return NAMED_QUERY_PATTERN.matcher(sql).find();
+    }
+
+    private ExtractIndexAndSql(String sql) {
+        this.sql = sql;
+    }
+
+    List<Tuple> getIndexPropList() {
+        return indexPropList;
+    }
+
+    String getNewSql() {
+        return newSql;
+    }
+
+    private ExtractIndexAndSql invoke() {
+        indexPropList = new ArrayList<Tuple>();
+        StringBuilder sb = new StringBuilder();
+        StringBuilder currentChunk = new StringBuilder();
+        while (index < sql.length()) {
+            switch (sql.charAt(index)) {
+                case QUOTE:
+                    sb.append(adaptForNamedParams(currentChunk.toString(), indexPropList));
+                    currentChunk = new StringBuilder();
+                    appendToEndOfString(sb);
+                    if (sb.charAt(sb.length() - 1) != QUOTE) {
+                        throw new IllegalStateException("Failed to process query. Unterminated ' character?");
+                    }
+                    break;
+                case '-':
+                    if (next() == '-') {
+                        sb.append(adaptForNamedParams(currentChunk.toString(), indexPropList));
+                        currentChunk = new StringBuilder();
+                        appendToEndOfLine(sb);
+                    } else {
+                        currentChunk.append(sql.charAt(index));
+                    }
+                    break;
+                case '/':
+                    if (next() == '*') {
+                        sb.append(adaptForNamedParams(currentChunk.toString(), indexPropList));
+                        currentChunk = new StringBuilder();
+                        appendToEndOfComment(sb);
+                    } else {
+                        currentChunk.append(sql.charAt(index));
+                    }
+                    break;
+                default:
+                    currentChunk.append(sql.charAt(index));
+            }
+            index++;
+        }
+        sb.append(adaptForNamedParams(currentChunk.toString(), indexPropList));
+        newSql = sb.toString();
+        return this;
+    }
+
+    private void appendToEndOfString(StringBuilder buffer) {
+        buffer.append(QUOTE);
+        ++index;
+        while (index < sql.length()) {
+            char c = sql.charAt(index);
+            buffer.append(c);
+            if (c == QUOTE && next() != QUOTE) {
+                int previousQuotes = countPreviousRepeatingChars(QUOTE);
+                if (previousQuotes == 0 || previousQuotes % 2 == 0) {
+                    break;
+                }
+            }
+            ++index;
+        }
+    }
+
+    private int countPreviousRepeatingChars(char c) {
+        int pos = index - 1;
+        while (pos >= 0) {
+            if (sql.charAt(pos) != c) {
+                break;
+            }
+            --pos;
+        }
+        return (index - 1) - pos;
+    }
+
+    private void appendToEndOfComment(StringBuilder buffer) {
+        while (index < sql.length()) {
+            char c = sql.charAt(index);
+            buffer.append(c);
+            if (c == '*' && next() == '/') {
+                buffer.append('/');
+                ++index;
+                break;
+            }
+            ++index;
+        }
+    }
+
+    private void appendToEndOfLine(StringBuilder buffer) {
+        while (index < sql.length()) {
+            char c = sql.charAt(index);
+            buffer.append(c);
+            if (c == '\n' || c == '\r') {
+                break;
+            }
+            ++index;
+        }
+    }
+
+    private char next() {
+        return ((index + 1) < sql.length()) ? sql.charAt(index + 1) : '\0';
+    }
+
+    private String adaptForNamedParams(String sql, List<Tuple> indexPropList) {
+        StringBuilder newSql = new StringBuilder();
+        int txtIndex = 0;
+
+        Matcher matcher = NAMED_QUERY_PATTERN.matcher(sql);
+        while (matcher.find()) {
+            newSql.append(sql.substring(txtIndex, matcher.start())).append('?');
+            String indexStr = matcher.group(1);
+            if (indexStr == null) indexStr = matcher.group(3);
+            int index = (indexStr == null || indexStr.length() == 0 || ":".equals(indexStr)) ? 0 : new Integer(indexStr) - 1;
+            String prop = matcher.group(2);
+            if (prop == null) prop = matcher.group(4);
+            indexPropList.add(new Tuple(new Object[]{index, prop == null || prop.length() == 0 ? "<this>" : prop}));
+            txtIndex = matcher.end();
+        }
+        newSql.append(sql.substring(txtIndex)); // append ending SQL after last param.
+        return newSql.toString();
+    }
+
+}
diff --git a/subprojects/groovy-sql/src/main/java/groovy/sql/Sql.java b/subprojects/groovy-sql/src/main/java/groovy/sql/Sql.java
index 8a6f8397c1..6f94dc16e8 100644
--- a/subprojects/groovy-sql/src/main/java/groovy/sql/Sql.java
+++ b/subprojects/groovy-sql/src/main/java/groovy/sql/Sql.java
@@ -233,8 +233,6 @@ public class Sql {
 
     private static final List<Object> EMPTY_LIST = Collections.emptyList();
 
-    private static final Pattern NAMED_QUERY_PATTERN = Pattern.compile("(?<!:)(:)(\\w+)|\\?(\\d*)(?:\\.(\\w+))?");
-
     private DataSource dataSource;
 
     private Connection useConnection;
@@ -3904,17 +3902,28 @@ public class Sql {
 
     public SqlWithParams preCheckForNamedParams(String sql) {
         // look for quick exit
-        if (!enableNamedQueries || !NAMED_QUERY_PATTERN.matcher(sql).find()) {
+        if (!enableNamedQueries || !ExtractIndexAndSql.hasNamedParameters(sql)) {
             return null;
         }
 
-        ExtractIndexAndSql extractIndexAndSql = new ExtractIndexAndSql(sql).invoke();
-        String newSql = extractIndexAndSql.getNewSql();
+        String newSql;
+        List<Tuple> propList;
+        if (cacheNamedQueries && namedParamSqlCache.containsKey(sql)) {
+            newSql = namedParamSqlCache.get(sql);
+            propList = namedParamIndexPropCache.get(sql);
+        } else {
+            ExtractIndexAndSql extractIndexAndSql = ExtractIndexAndSql.from(sql);
+            newSql = extractIndexAndSql.getNewSql();
+            propList = extractIndexAndSql.getIndexPropList();
+            namedParamSqlCache.put(sql, newSql);
+            namedParamIndexPropCache.put(sql, propList);
+        }
+
         if (sql.equals(newSql)) {
             return null;
         }
 
-        List<Object> indexPropList = new ArrayList<Object>(extractIndexAndSql.getIndexPropList());
+        List<Object> indexPropList = new ArrayList<Object>(propList);
         return new SqlWithParams(newSql, indexPropList);
     }
 
@@ -4159,80 +4168,4 @@ public class Sql {
     protected void setInternalConnection(Connection conn) {
     }
 
-    private class ExtractIndexAndSql {
-        private String sql;
-        private List<Tuple> indexPropList;
-        private String newSql;
-
-        private ExtractIndexAndSql(String sql) {
-            this.sql = sql;
-        }
-
-        private List<Tuple> getIndexPropList() {
-            return indexPropList;
-        }
-
-        private String getNewSql() {
-            return newSql;
-        }
-
-        private ExtractIndexAndSql invoke() {
-            if (cacheNamedQueries && namedParamSqlCache.containsKey(sql)) {
-                newSql = namedParamSqlCache.get(sql);
-                indexPropList = namedParamIndexPropCache.get(sql);
-            } else {
-                indexPropList = new ArrayList<Tuple>();
-                StringBuilder sb = new StringBuilder();
-                StringBuilder currentChunk = new StringBuilder();
-                char[] chars = sql.toCharArray();
-                int i = 0;
-                boolean inString = false; //TODO: Cater for comments?
-                while (i < chars.length) {
-                    switch (chars[i]) {
-                        case '\'':
-                            inString = !inString;
-                            if (inString) {
-                                sb.append(adaptForNamedParams(currentChunk.toString(), indexPropList));
-                                currentChunk = new StringBuilder();
-                                currentChunk.append(chars[i]);
-                            } else {
-                                currentChunk.append(chars[i]);
-                                sb.append(currentChunk);
-                                currentChunk = new StringBuilder();
-                            }
-                            break;
-                        default:
-                            currentChunk.append(chars[i]);
-                    }
-                    i++;
-                }
-                if (inString)
-                    throw new IllegalStateException("Failed to process query. Unterminated ' character?");
-                sb.append(adaptForNamedParams(currentChunk.toString(), indexPropList));
-                newSql = sb.toString();
-                namedParamSqlCache.put(sql, newSql);
-                namedParamIndexPropCache.put(sql, indexPropList);
-            }
-            return this;
-        }
-
-        private String adaptForNamedParams(String sql, List<Tuple> indexPropList) {
-            StringBuilder newSql = new StringBuilder();
-            int txtIndex = 0;
-
-            Matcher matcher = NAMED_QUERY_PATTERN.matcher(sql);
-            while (matcher.find()) {
-                newSql.append(sql.substring(txtIndex, matcher.start())).append('?');
-                String indexStr = matcher.group(1);
-                if (indexStr == null) indexStr = matcher.group(3);
-                int index = (indexStr == null || indexStr.length() == 0 || ":".equals(indexStr)) ? 0 : new Integer(indexStr) - 1;
-                String prop = matcher.group(2);
-                if (prop == null) prop = matcher.group(4);
-                indexPropList.add(new Tuple(new Object[]{index, prop == null || prop.length() == 0 ? "<this>" : prop}));
-                txtIndex = matcher.end();
-            }
-            newSql.append(sql.substring(txtIndex)); // append ending SQL after last param.
-            return newSql.toString();
-        }
-    }
 }
diff --git a/subprojects/groovy-sql/src/test/groovy/groovy/sql/ExtractIndexAndSqlTest.groovy b/subprojects/groovy-sql/src/test/groovy/groovy/sql/ExtractIndexAndSqlTest.groovy
new file mode 100644
index 0000000000..484cb0a7b8
--- /dev/null
+++ b/subprojects/groovy-sql/src/test/groovy/groovy/sql/ExtractIndexAndSqlTest.groovy
@@ -0,0 +1,193 @@
+/*
+ * Copyright 2003-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package groovy.sql
+
+class ExtractIndexAndSqlTest extends GroovyTestCase {
+
+    void testDetectsNamedParameters() {
+        assert !ExtractIndexAndSql.hasNamedParameters('select * from PERSON')
+        assert ExtractIndexAndSql.hasNamedParameters('select * from PERSON where id=:id')
+        assert ExtractIndexAndSql.hasNamedParameters('select * from PERSON where id=?.id')
+        assert ExtractIndexAndSql.hasNamedParameters('select * from PERSON where id=?1.id')
+        assert ExtractIndexAndSql.hasNamedParameters('select * from PERSON where id=?')
+    }
+
+    void testWithQuoteEmbeddedInInlineComments() {
+        String query = """select *
+from FOOD
+-- An ' apostrophe
+where type=:foo
+"""
+        def expected = """select *
+from FOOD
+-- An ' apostrophe
+where type=?
+"""
+        assert expected == ExtractIndexAndSql.from(query).newSql
+    }
+
+    void testWithNamedParamEmbeddedInInlineComments() {
+        String query = """select *
+from FOOD
+-- where type=:bar
+where type=:foo
+"""
+        String expected = """select *
+from FOOD
+-- where type=:bar
+where type=?
+"""
+
+        assert expected == ExtractIndexAndSql.from(query).newSql
+    }
+
+    void testWithQuoteEmbeddedInMultilineComments() {
+        String query = """select *
+from FOOD
+/* An ' apostrophe
+in a 'multiline' comment */where type=:foo
+"""
+        String expected = """select *
+from FOOD
+/* An ' apostrophe
+in a 'multiline' comment */where type=?
+"""
+
+        assert expected == ExtractIndexAndSql.from(query).newSql
+    }
+
+    void testWithNamedParamEmbeddedInMultilineComments() {
+        String query = """select *
+from FOOD
+/* An ' apostrophe
+where type=:bar
+in a 'multiline' comment */where type=:foo
+"""
+        String expected = """select *
+from FOOD
+/* An ' apostrophe
+where type=:bar
+in a 'multiline' comment */where type=?
+"""
+        assert expected == ExtractIndexAndSql.from(query).newSql
+    }
+
+    void testWithMultipleEmbeddedQuotesInString() {
+        String query = """select location_id, 'James O''Brian' as other_name
+from PERSON
+where lastname=:foo
+"""
+        String expected = """select location_id, 'James O''Brian' as other_name
+from PERSON
+where lastname=?
+"""
+        assert expected == ExtractIndexAndSql.from(query).newSql
+    }
+
+    void testWithUnterminatedString() {
+        String query = """select location_id, 'James O'''Brian' as other_name
+from PERSON
+where lastname=:foo
+"""
+
+        shouldFail(IllegalStateException) {
+            ExtractIndexAndSql.from(query)
+        }
+    }
+
+    void testWithStringSpanningMoreThanOneLine() {
+        String query = """select 'this is a ''multiline'' with a '':named :param'' string
+ and spans two lines'
+from PERSON
+where lastname=:foo
+"""
+        String expected = """select 'this is a ''multiline'' with a '':named :param'' string
+ and spans two lines'
+from PERSON
+where lastname=?
+"""
+
+        assert expected == ExtractIndexAndSql.from(query).newSql
+    }
+
+    void testSingleDash() {
+        String query = """select location_id
+from PERSON
+where lastname=?
+and 3 = (4 - 1)
+"""
+
+        assert query == ExtractIndexAndSql.from(query).newSql
+    }
+
+    void testForwardSlash() {
+        String query = """select location_id
+from PERSON
+where lastname=?
+and 3 = (12 / 4)
+"""
+
+        assert query == ExtractIndexAndSql.from(query).newSql
+    }
+
+    void testWithPostgreSqlCast() {
+        String query = """select 'name' from PERSON where id=:id and birth_date=:birthDate::timestamp"""
+        String expected = """select 'name' from PERSON where id=? and birth_date=?::timestamp"""
+
+        assert expected == ExtractIndexAndSql.from(query).newSql
+    }
+
+    void testNamedParameters() {
+        String query = "select * from PERSON where name=:name and location=:location and building=:building"
+        String expected = "select * from PERSON where name=? and location=? and building=?"
+
+        ExtractIndexAndSql extracter = new ExtractIndexAndSql(query).invoke()
+
+        assert expected == extracter.newSql
+
+        assert 3 == extracter.indexPropList.size()
+
+        assert 0 == extracter.indexPropList.get(0)[0]
+        assert 'name' == extracter.indexPropList.get(0)[1]
+
+        assert 0 == extracter.indexPropList.get(1)[0]
+        assert 'location' == extracter.indexPropList.get(1)[1]
+
+        assert 0 == extracter.indexPropList.get(2)[0]
+        assert 'building' == extracter.indexPropList.get(2)[1]
+    }
+
+    void testNamedOrdinalParameters() {
+        String query = "select * from PERSON where name=?1.name and location=?2.location and building=?3.building"
+        String expected = "select * from PERSON where name=? and location=? and building=?"
+
+        ExtractIndexAndSql extracter = ExtractIndexAndSql.from(query)
+
+        assert expected == extracter.newSql
+
+        assert 3 == extracter.indexPropList.size()
+
+        assert 0 == extracter.indexPropList.get(0)[0]
+        assert 'name' == extracter.indexPropList.get(0)[1]
+
+        assert 1 == extracter.indexPropList.get(1)[0]
+        assert 'location' == extracter.indexPropList.get(1)[1]
+
+        assert 2 == extracter.indexPropList.get(2)[0]
+        assert 'building' == extracter.indexPropList.get(2)[1]
+    }
+
+}
diff --git a/subprojects/groovy-sql/src/test/groovy/groovy/sql/SqlCompleteTest.groovy b/subprojects/groovy-sql/src/test/groovy/groovy/sql/SqlCompleteTest.groovy
index d96a84dbda..04582ad928 100644
--- a/subprojects/groovy-sql/src/test/groovy/groovy/sql/SqlCompleteTest.groovy
+++ b/subprojects/groovy-sql/src/test/groovy/groovy/sql/SqlCompleteTest.groovy
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2012 the original author or authors.
+ * Copyright 2003-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -514,6 +514,16 @@ class SqlCompleteTest extends SqlHelperTestCase {
         assert args2 == [url: url2, driver:  driver, properties: [user: user, password:  password]]
     }
 
+    void testWithQuoteEmbeddedInInlineComment_Groovy5898() {
+        def query = """select *
+from FOOD
+-- An ' apostrophe
+where type=:foo
+"""
+        def rows = sql.rows(query, foo: 'drink')
+        assert rows.size() == 2
+    }
+
 }
 
 class PersonDTO {
