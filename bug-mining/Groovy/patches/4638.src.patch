diff --git a/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java b/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
index e7b670f4aa..99f6eb15c9 100644
--- a/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
+++ b/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
@@ -43,6 +43,7 @@ import org.codehaus.groovy.ast.expr.BinaryExpression;
 import org.codehaus.groovy.ast.expr.CastExpression;
 import org.codehaus.groovy.ast.expr.ClassExpression;
 import org.codehaus.groovy.ast.expr.ClosureExpression;
+import org.codehaus.groovy.ast.expr.ConstantExpression;
 import org.codehaus.groovy.ast.expr.ConstructorCallExpression;
 import org.codehaus.groovy.ast.expr.DeclarationExpression;
 import org.codehaus.groovy.ast.expr.Expression;
@@ -870,86 +871,76 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
         return tuple(name, Boolean.FALSE);
     }
 
-    // iterate from the innermost to the outer and check for classes
-    // this check will ignore a .class property, for Example Integer.class will be
-    // a PropertyExpression with the ClassExpression of Integer as objectExpression
-    // and class as property
+    /**
+     * Returns "Type" class expression for "Type.class" or "pack.Type.class".
+     */
     private static Expression correctClassClassChain(final PropertyExpression pe) {
-        LinkedList<Expression> stack = new LinkedList<Expression>();
-        ClassExpression found = null;
-        for (Expression it = pe; it != null; it = ((PropertyExpression) it).getObjectExpression()) {
-            if (it instanceof ClassExpression) {
-                found = (ClassExpression) it;
-                break;
-            } else if (!(it.getClass() == PropertyExpression.class)) {
+        ClassExpression ce = null; LinkedList<PropertyExpression> stack = new LinkedList<>();
+        for (Expression e = pe; e != null; e = ((PropertyExpression) e).getObjectExpression()) {
+            if (e.getClass() == PropertyExpression.class) {
+                stack.push((PropertyExpression) e);
+            } else if (e instanceof ClassExpression) {
+                ce = (ClassExpression) e; break;
+            } else {
                 return pe;
             }
-            stack.addFirst(it);
         }
-        if (found == null) return pe;
-
-        if (stack.isEmpty()) return pe;
-        Object stackElement = stack.removeFirst();
-        if (!(stackElement.getClass() == PropertyExpression.class)) return pe;
-        PropertyExpression classPropertyExpression = (PropertyExpression) stackElement;
-        String propertyNamePart = classPropertyExpression.getPropertyAsString();
-        if (propertyNamePart == null || !propertyNamePart.equals("class")) return pe;
+        if (ce == null) return pe;
+        PropertyExpression classProperty = stack.pop();
+        String propertyName = classProperty.getPropertyAsString();
 
-        found.setSourcePosition(classPropertyExpression);
-        if (stack.isEmpty()) return found;
-        stackElement = stack.removeFirst();
-        if (!(stackElement.getClass() == PropertyExpression.class)) return pe;
-        PropertyExpression classPropertyExpressionContainer = (PropertyExpression) stackElement;
+        // if it's "Type.foo.bar" or something else return PropertyExpression
+        if (propertyName == null || !propertyName.equals("class")) return pe;
+        // if it's "Type.class" or "pack.Type.class" return ClassExpression
+        ce.setSourcePosition(classProperty);
+        if (stack.isEmpty()) return ce;
 
-        classPropertyExpressionContainer.setObjectExpression(found);
+        PropertyExpression classPropertyExpressionContainer = stack.pop();
+        classPropertyExpressionContainer.setObjectExpression(ce);
         return pe;
     }
 
-    protected Expression transformPropertyExpression(PropertyExpression pe) {
-        boolean itlp = isTopLevelProperty;
-        boolean ipe = inPropertyExpression;
-
-        Expression objectExpression = pe.getObjectExpression();
-        inPropertyExpression = true;
-        isTopLevelProperty = (objectExpression.getClass() != PropertyExpression.class);
-        objectExpression = transform(objectExpression);
-        // we handle the property part as if it were not part of the property
-        inPropertyExpression = false;
-        Expression property = transform(pe.getProperty());
-        isTopLevelProperty = itlp;
-        inPropertyExpression = ipe;
-
-        boolean spreadSafe = pe.isSpreadSafe();
-        PropertyExpression old = pe;
-        pe = new PropertyExpression(objectExpression, property, pe.isSafe());
-        pe.setSpreadSafe(spreadSafe);
-        pe.setSourcePosition(old);
-
-        String className = lookupClassName(pe);
+    protected Expression transformPropertyExpression(final PropertyExpression pe) {
+        Expression objectExpression = pe.getObjectExpression(), property;
+        boolean ipe = inPropertyExpression, itlp = isTopLevelProperty;
+        try {
+            inPropertyExpression = true;
+            isTopLevelProperty = (objectExpression.getClass() != PropertyExpression.class);
+            objectExpression = transform(objectExpression);
+            // handle the property part as if it were not part of the property
+            inPropertyExpression = false;
+            property = transform(pe.getProperty());
+        } finally {
+            inPropertyExpression = ipe;
+            isTopLevelProperty = itlp;
+        }
+        PropertyExpression xe = new PropertyExpression(objectExpression, property, pe.isSafe());
+        xe.setSpreadSafe(pe.isSpreadSafe());
+        xe.setSourcePosition(pe);
+      //xe.copyNodeMetaData(pe);
+
+        String className = lookupClassName(xe);
         if (className != null) {
             ClassNode type = ClassHelper.make(className);
             if (resolve(type)) {
                 return new ClassExpression(type);
             }
         }
-        if (objectExpression instanceof ClassExpression && pe.getPropertyAsString() != null) {
+
+        if (objectExpression instanceof ClassExpression && property instanceof ConstantExpression) {
             // possibly an inner class (or inherited inner class)
-            ClassExpression ce = (ClassExpression) objectExpression;
-            ClassNode classNode = ce.getType();
-            while (classNode != null) {
-                ClassNode type = new ConstructedNestedClass(classNode, pe.getPropertyAsString());
+            for (ClassNode propertyOwner = objectExpression.getType(); propertyOwner != null; propertyOwner = propertyOwner.getSuperClass()) {
+                ClassNode type = new ConstructedNestedClass(propertyOwner, xe.getPropertyAsString());
                 if (resolve(type, false, false, false)) {
-                    if (classNode == ce.getType() || isVisibleNestedClass(type, ce.getType())) {
+                    if (propertyOwner == objectExpression.getType() || isVisibleNestedClass(type, objectExpression.getType())) {
                         return new ClassExpression(type);
                     }
                 }
-                classNode = classNode.getSuperClass();
             }
         }
-        Expression ret = pe;
-        checkThisAndSuperAsPropertyAccess(pe);
-        if (isTopLevelProperty) ret = correctClassClassChain(pe);
-        return ret;
+
+        checkThisAndSuperAsPropertyAccess(xe);
+        return isTopLevelProperty ? correctClassClassChain(xe) : xe;
     }
 
     private static boolean isVisibleNestedClass(final ClassNode innerType, final ClassNode outerType) {
diff --git a/src/test-resources/groovy/bugs/groovyA196/Main.groovy b/src/test-resources/groovy/bugs/groovyA196/Main.groovy
new file mode 100644
index 0000000000..80e0f2e270
--- /dev/null
+++ b/src/test-resources/groovy/bugs/groovyA196/Main.groovy
@@ -0,0 +1,25 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package groovy.bugs.groovyA196
+
+@interface Anno {
+    Class<?> value()
+}
+
+new Service().method(null)
diff --git a/src/test-resources/groovy/bugs/groovyA196/Service.groovy b/src/test-resources/groovy/bugs/groovyA196/Service.groovy
new file mode 100644
index 0000000000..4e1027f6bd
--- /dev/null
+++ b/src/test-resources/groovy/bugs/groovyA196/Service.groovy
@@ -0,0 +1,25 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package groovy.bugs.groovyA196
+
+class Service {
+    @Anno(groovy.bugs.groovyA196.ServiceType.class)
+    def method(object) {
+    }
+}
diff --git a/src/test-resources/groovy/bugs/groovyA196/ServiceType.groovy b/src/test-resources/groovy/bugs/groovyA196/ServiceType.groovy
new file mode 100644
index 0000000000..21d5f3d794
--- /dev/null
+++ b/src/test-resources/groovy/bugs/groovyA196/ServiceType.groovy
@@ -0,0 +1,22 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package groovy.bugs.groovyA196
+
+class ServiceType {
+}
diff --git a/src/test/groovy/script/RuntimeResolveTests.groovy b/src/test/groovy/script/RuntimeResolveTests.groovy
index c039649c3f..d1e9b8cd20 100644
--- a/src/test/groovy/script/RuntimeResolveTests.groovy
+++ b/src/test/groovy/script/RuntimeResolveTests.groovy
@@ -82,4 +82,9 @@ final class RuntimeResolveTests {
     void testResolvePackagePeersAndTypeArgument() {
         runScript('/groovy/bugs/groovy7799/Main.groovy')
     }
+
+    @Test
+    void testResolvePackagePeersAndAnnotationValue() {
+        runScript('/groovy/bugs/groovyA196/Main.groovy')
+    }
 }
