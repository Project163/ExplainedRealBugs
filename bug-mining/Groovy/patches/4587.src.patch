diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 5be61fd0cd..c8d3599379 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -2469,6 +2469,15 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                             storeType(expression, closureType);
                         });
                 expression.putNodeMetaData(MethodNode.class, candidates);
+
+                // GROOVY-10734: Type::instanceMethod has implied first parameter type
+                ClassNode[] arguments = expression.getNodeMetaData(CLOSURE_ARGUMENTS);
+                if (asBoolean(arguments) && !isStaticInContext(candidates.get(0))
+                        &&  expression.getExpression() instanceof ClassExpression
+                        && (receiverType.isDerivedFrom(arguments[0])
+                            || receiverType.implementsInterface(arguments[0]))) {
+                    arguments[0] = receiverType;
+                }
             } else if (!(expression instanceof MethodReferenceExpression)
                     || this.getClass() == StaticTypeCheckingVisitor.class) {
                 ClassNode type = wrapTypeIfNecessary(getType(expression.getExpression()));
@@ -5336,6 +5345,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                             // parameters and return type correspond to the SAM's
                             for (int j = 0; j < p.length && j < q.length; j += 1) {
                                 if (!isDynamicTyped(p[j]))
+                                    // GROOVY-10054, GROOVY-10699, GROOVY-10749, et al.
                                     extractGenericsConnections(connections, wrapTypeIfNecessary(p[j]), q[j]);
                             }
                             extractGenericsConnections(connections, returnType, samParamsAndReturnType.getV2());
diff --git a/src/test/groovy/transform/stc/GenericsSTCTest.groovy b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
index 5cd2d70534..c2408cfb0a 100644
--- a/src/test/groovy/transform/stc/GenericsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
@@ -796,7 +796,7 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
     void testReturnTypeInferenceWithMethodGenerics30() {
         String named = 'class Named { String name }'
 
-        for (expr in ['Named.&getName', '{Named named -> named.getName()}', '(Named named) -> named.getName()']) {
+        for (expr in ['Named.&getName', 'Named::getName', '{Named named -> named.getName()}', '(Named named) -> named.getName()']) {
             assertScript named + """
                 @ASTTest(phase=INSTRUCTION_SELECTION, value={
                     def type = node.getNodeMetaData(INFERRED_TYPE)
diff --git a/src/test/groovy/transform/stc/MethodReferenceTest.groovy b/src/test/groovy/transform/stc/MethodReferenceTest.groovy
index d9879ce7ed..789874962b 100644
--- a/src/test/groovy/transform/stc/MethodReferenceTest.groovy
+++ b/src/test/groovy/transform/stc/MethodReferenceTest.groovy
@@ -224,9 +224,7 @@ final class MethodReferenceTest {
 
             @CompileStatic
             Map test(Collection<C> items) {
-                items.stream().collect(
-                    Collectors.<C,String>groupingBy(C::getP)
-                )
+                items.stream().collect(Collectors.groupingBy(C::getP))
             }
 
             def map = test([new C(p:'foo'), new C(p:'bar'), new C(p:'foo')])
