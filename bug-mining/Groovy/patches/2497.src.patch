diff --git a/src/main/org/codehaus/groovy/transform/AbstractASTTransformation.java b/src/main/org/codehaus/groovy/transform/AbstractASTTransformation.java
index fce97f146a..01d3c2bc68 100644
--- a/src/main/org/codehaus/groovy/transform/AbstractASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/AbstractASTTransformation.java
@@ -37,6 +37,7 @@ import org.objectweb.asm.Opcodes;
 
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
 
@@ -134,29 +135,45 @@ public abstract class AbstractASTTransformation implements Opcodes, ASTTransform
         return rawExcludes == null ? new ArrayList<String>() : StringGroovyMethods.tokenize(rawExcludes, ", ");
     }
 
+    public static boolean deemedInternalName(String name) {
+        return name.contains("$");
+    }
+
     public static boolean shouldSkip(String name, List<String> excludes, List<String> includes) {
-        return (excludes != null && excludes.contains(name)) || name.contains("$") || (includes != null && !includes.isEmpty() && !includes.contains(name));
+        return excludes.contains(name) || deemedInternalName(name) || (!includes.isEmpty() && !includes.contains(name));
     }
 
-    public static boolean shouldSkipOnDescriptor(String descriptor, List<ClassNode> excludeTypes, List<ClassNode> includeTypes) {
-        if (excludeTypes != null) {
+    public static boolean shouldSkipOnDescriptor(Map genericsSpec, String descriptor, List<ClassNode> excludeTypes, List<ClassNode> includeTypes) {
             for (ClassNode cn : excludeTypes) {
-                // TODO correct to generics spec?
-                for (MethodNode mn : nonGeneric(cn).getMethods()) {
-                    if (mn.getTypeDescriptor().equals(descriptor)) return true;
+                List<ClassNode> remaining = new LinkedList<ClassNode>();
+                remaining.add(cn);
+                while (!remaining.isEmpty()) {
+                    ClassNode next = remaining.remove(0);
+                    if (!next.equals(ClassHelper.OBJECT_TYPE)) {
+                        for (MethodNode mn : next.getMethods()) {
+                            String md = correctToGenericsSpec(genericsSpec, mn).getTypeDescriptor();
+                            if (md.equals(descriptor)) return true;
+                        }
+                        remaining.addAll(Arrays.asList(next.getInterfaces()));
+                    }
                 }
             }
-            return false;
-        }
-        if (includeTypes != null) {
+            if (includeTypes.isEmpty()) return false;
             for (ClassNode cn : includeTypes) {
-                for (MethodNode mn : nonGeneric(cn).getMethods()) {
-                    if (mn.getTypeDescriptor().equals(descriptor)) return false;
+                List<ClassNode> remaining = new LinkedList<ClassNode>();
+                remaining.add(cn);
+                while (!remaining.isEmpty()) {
+                    ClassNode next = remaining.remove(0);
+                    if (!next.equals(ClassHelper.OBJECT_TYPE)) {
+                        for (MethodNode mn : next.getMethods()) {
+                            String md = correctToGenericsSpec(genericsSpec, mn).getTypeDescriptor();
+                            if (md.equals(descriptor)) return false;
+                        }
+                        remaining.addAll(Arrays.asList(next.getInterfaces()));
+                    }
                 }
             }
             return true;
-        }
-        return false;
     }
 
     protected void checkIncludeExclude(AnnotationNode node, List<String> excludes, List<String> includes, String typeName) {
@@ -202,8 +219,7 @@ public abstract class AbstractASTTransformation implements Opcodes, ASTTransform
 
 
     public static ClassNode makeClassSafeWithGenerics(ClassNode type, GenericsType... genericTypes) {
-        if (type.isArray() /*&& type.getComponentType().isUsingGenerics()*/) {
-
+        if (type.isArray()) {
             return makeClassSafeWithGenerics(type.getComponentType(), genericTypes).makeArray();
         }
         GenericsType[] gtypes = new GenericsType[0];
diff --git a/src/main/org/codehaus/groovy/transform/DelegateASTTransformation.java b/src/main/org/codehaus/groovy/transform/DelegateASTTransformation.java
index beabbd421d..fca234e5dd 100644
--- a/src/main/org/codehaus/groovy/transform/DelegateASTTransformation.java
+++ b/src/main/org/codehaus/groovy/transform/DelegateASTTransformation.java
@@ -185,10 +185,7 @@ public class DelegateASTTransformation extends AbstractASTTransformation impleme
                     nonGeneric(prop.getType()),
                     Parameter.EMPTY_ARRAY,
                     null,
-                    new ReturnStatement(
-                            new PropertyExpression(
-                                    new VariableExpression(fieldNode),
-                                    name)));
+                    new ReturnStatement(new PropertyExpression(new VariableExpression(fieldNode), name)));
         }
     }
 
@@ -204,8 +201,10 @@ public class DelegateASTTransformation extends AbstractASTTransformation impleme
         Map genericsSpec = Verifier.createGenericsSpec(fieldNode.getDeclaringClass(), new HashMap());
         genericsSpec = Verifier.createGenericsSpec(fieldNode.getType(), genericsSpec);
 
-        String correctedTypeDescriptor = correctToGenericsSpec(genericsSpec, candidate).getTypeDescriptor();
-        if (shouldSkipOnDescriptor(correctedTypeDescriptor, excludeTypes, includeTypes)) return;
+        if (!excludeTypes.isEmpty() || !includeTypes.isEmpty()) {
+            String correctedTypeDescriptor = correctToGenericsSpec(genericsSpec, candidate).getTypeDescriptor();
+            if (shouldSkipOnDescriptor(genericsSpec, correctedTypeDescriptor, excludeTypes, includeTypes)) return;
+        }
 
         // ignore methods from GroovyObject
         for (MethodNode mn : GROOVYOBJECT_TYPE.getMethods()) {
diff --git a/src/test/org/codehaus/groovy/transform/DelegateTransformTest.groovy b/src/test/org/codehaus/groovy/transform/DelegateTransformTest.groovy
index 5531184691..6bdee978f4 100644
--- a/src/test/org/codehaus/groovy/transform/DelegateTransformTest.groovy
+++ b/src/test/org/codehaus/groovy/transform/DelegateTransformTest.groovy
@@ -467,28 +467,36 @@ class DelegateTransformTest extends CompilableTestSupport {
         """
     }
 
-    // GROOVY-6330
+    // GROOVY-6329
     void testIncludeAndExcludeByType() {
         assertScript """
-            interface AddAllCollectionSelector {
+            interface OddInclusions {
                 boolean addAll(Collection<? extends Integer> c)
                 Integer remove(int index)
             }
-
-            class SplitNumberList {
-                // collection variant of addAll and remove will work on odd list, all other methods on even list
-                @Delegate(excludeTypes=AddAllCollectionSelector) List<Integer> evens = [2, 4, 6]
-                @Delegate(includeTypes=AddAllCollectionSelector) List<Integer> odds = [1, 3, 5]
-                def getEvensThenOdds() { evens + odds }
+            interface OtherInclusions {
+                void clear()
+            }
+            interface EvenExclusions extends OddInclusions, OtherInclusions { }
+
+            class MixedNumbers {
+                // collection variant of addAll and remove will work on odd list
+                @Delegate(includeTypes=OddInclusions) List<Integer> odds = [1, 3, 5]
+                // clear will work on other list
+                @Delegate(includeTypes=OtherInclusions) List<Integer> others = [0]
+                // all other methods will work on even list
+                @Delegate(excludeTypes=EvenExclusions) List<Integer> evens = [2, 4, 6]
+                def getAll() { evens + odds + others }
             }
 
-            def list = new SplitNumberList()
-            assert list.evensThenOdds == [2, 4, 6, 1, 3, 5]
+            def list = new MixedNumbers()
+            assert list.all == [2, 4, 6, 1, 3, 5, 0]
             list.addAll([7, 9])
             list.addAll(1, [8])
             list.remove(0)
             assert list.indexOf(8) == 1
-            assert list.evensThenOdds == [2, 8, 4, 6, 3, 5, 7, 9]
+            list.clear()
+            assert list.all == [2, 8, 4, 6, 3, 5, 7, 9]
         """
     }
 
