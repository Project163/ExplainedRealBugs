diff --git a/src/main/org/codehaus/groovy/ast/ClassHelper.java b/src/main/org/codehaus/groovy/ast/ClassHelper.java
index 89b81f509f..b63d805a24 100644
--- a/src/main/org/codehaus/groovy/ast/ClassHelper.java
+++ b/src/main/org/codehaus/groovy/ast/ClassHelper.java
@@ -382,10 +382,19 @@ public class ClassHelper {
     }
     
     public static boolean isSAMType(ClassNode type) {
-        if (!Modifier.isAbstract(type.getModifiers())) return false;
+        return findSAM(type) != null;
+    }
+
+    /**
+     * Returns the single abstract method of a class node, if it is a SAM type, or null otherwise.
+     * @param type a type for which to search for a single abstract method
+     * @return the method node if type is a SAM type, null otherwise
+     */
+    public static MethodNode findSAM(ClassNode type) {
+        if (!Modifier.isAbstract(type.getModifiers())) return null;
         if (type.isInterface()) {
             List<MethodNode> methods = type.getMethods();
-            boolean found=false;
+            MethodNode found=null;
             for (MethodNode mi : methods) {
                 // ignore methods, that are not abstract and from Object
                 if (!Modifier.isAbstract(mi.getModifiers())) continue;
@@ -393,27 +402,27 @@ public class ClassHelper {
                 if (OBJECT_TYPE.getDeclaredMethod(mi.getName(), mi.getParameters())!=null) continue;
 
                 // we have two methods, so no SAM
-                if (found) return false;
-                found = true;
+                if (found!=null) return null;
+                found = mi;
             }
             return found;
 
         } else {
 
             List<MethodNode> methods = type.getAbstractMethods();
-            boolean found = false;
+            MethodNode found = null;
             if (methods!=null) {
                 for (MethodNode mi : methods) {
                     if (!hasUsableImplementation(type, mi)) {
-                        if (found) return false;
-                        found = true;
+                        if (found!=null) return null;
+                        found = mi;
                     }
                 }
             }
             return found;
         }
     }
-    
+
     private static boolean hasUsableImplementation(ClassNode c, MethodNode m) {
         if (c==m.getDeclaringClass()) return false;
         MethodNode found = c.getDeclaredMethod(m.getName(), m.getParameters());
diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 58b190e696..0baddc8345 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -2553,8 +2553,6 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             MethodNode node = new MethodNode(name, Opcodes.ACC_PUBLIC, VOID_TYPE, new Parameter[]{new Parameter(args[0],"arg")}, null, null);
             node.setDeclaringClass(receiver.redirect());
             methods.add(node);
-        } else {
-            return;
         }
     }
 
@@ -3598,6 +3596,11 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                 if (!type.isUsingGenerics() && type.isArray()) type = type.getComponentType();
                 if (type.isUsingGenerics()) {
                     ClassNode actualType = getType(expressions.get(i));
+                    if (implementsInterfaceOrIsSubclassOf(actualType, CLOSURE_TYPE) && !implementsInterfaceOrIsSubclassOf(type, CLOSURE_TYPE)) {
+                        // implicit closure coercion in action!
+                        Map<String,GenericsType> pholders = new HashMap<String, GenericsType>(resolvedPlaceholders);
+                        actualType = convertClosureTypeToSAMType(expressions.get(i), actualType, type, pholders);
+                    }
                     if (isVargs && lastArg && actualType.isArray()) {
                         actualType = actualType.getComponentType();
                     }
@@ -3641,6 +3644,95 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         return resolveGenericsWithContext(resolvedPlaceholders, returnType);
     }
 
+    /**
+     * This method will convert a closure type to the appropriate SAM type, which will be used
+     * to infer return type generics.
+     *
+     * @param closureType the inferred type of a closure (Closure&lt;ClosureReturnType&gt;)
+     * @param samType the type into which the closure is coerced into
+     * @param receiver
+     * @return same SAM type, but completed with information from the closure node
+     */
+    private static ClassNode convertClosureTypeToSAMType(final Expression expression, final ClassNode closureType, final ClassNode samType, final Map<String,GenericsType> placeholders) {
+        if (!samType.isUsingGenerics()) return samType;
+        MethodNode sam = findSAM(samType);
+        if (sam==null) {
+            // should never happen
+            return samType;
+        }
+
+        // the return type of the SAM method exactly corresponds to the inferred return type
+        ClassNode samReturnType = sam.getReturnType();
+
+        // now we can play!
+        // imagine that a closure returns an Integer, like in { -> 1 }
+        // and a SAM type defined like this: interface<T> SAM { T apply() }
+        // then if the closure is coerced to SAM, we can infer that we have a SAM<Integer>
+        // we can also have interface<T> SAM { void apply(T t) }
+        // so we build a list of couples(actualType, expectedType) to test
+        List<ClassNode[]> itemsToCheck = new LinkedList<ClassNode[]>();
+
+        if (closureType.isUsingGenerics()) {
+            ClassNode closureReturnType = closureType.getGenericsTypes()[0].getType();
+            itemsToCheck.add(new ClassNode[]{closureReturnType, samReturnType});
+        }
+        if (expression instanceof ClosureExpression) {
+            Parameter[] closureParams = ((ClosureExpression) expression).getParameters();
+            ClassNode[] closureParamTypes = extractTypesFromParameters(closureParams);
+            if (expression.getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS)!=null) {
+                closureParamTypes = expression.getNodeMetaData(StaticTypesMarker.CLOSURE_ARGUMENTS);
+            }
+            final Parameter[] parameters = sam.getParameters();
+            for (int i = 0; i < parameters.length; i++) {
+                final Parameter parameter = parameters[i];
+                if (closureParamTypes.length>i) {
+                    itemsToCheck.add(new ClassNode[]{closureParamTypes[i], parameter.getOriginType()});
+                }
+            }
+        }
+        for (ClassNode[] classNodes : itemsToCheck) {
+            ClassNode found = classNodes[0];
+            ClassNode expected = classNodes[1];
+            if (!isAssignableTo(found, expected)) {
+                // probably facing a type mismatch
+                continue;
+            }
+            ClassNode generifiedReturnType = GenericsUtils.parameterizeType(found, expected);
+            while (expected.isArray()) {
+                expected = expected.getComponentType();
+                generifiedReturnType = generifiedReturnType.getComponentType();
+            }
+            if (expected.isGenericsPlaceHolder()) {
+                placeholders.put(expected.getGenericsTypes()[0].getName(), new GenericsType(generifiedReturnType));
+            } else {
+                GenericsType[] samReturnTypeGenericsTypes = expected.getGenericsTypes();
+                GenericsType[] generifiedReturnTypeGenericsTypes = generifiedReturnType.getGenericsTypes();
+
+                for (int i = 0; i < samReturnTypeGenericsTypes.length; i++) {
+                    final GenericsType type = samReturnTypeGenericsTypes[i];
+                    if (type.isPlaceholder()) {
+                        String name = type.getName();
+                        placeholders.put(name, generifiedReturnTypeGenericsTypes[i]);
+                    }
+                }
+            }
+        }
+
+        ClassNode result = samType.getPlainNodeReference();
+        GenericsType[] genericsTypes = samType.redirect().getGenericsTypes();
+        GenericsType[] copy = new GenericsType[genericsTypes.length];
+        for (int i = 0; i < genericsTypes.length; i++) {
+            GenericsType genericsType = genericsTypes[i];
+            if (genericsType.isPlaceholder() && placeholders.containsKey(genericsType.getName())) {
+                copy[i] = placeholders.get(genericsType.getName());
+            } else {
+                copy[i] = genericsType;
+            }
+        }
+        result.setGenericsTypes(copy);
+        return result;
+    }
+
     private ClassNode resolveGenericsWithContext(Map<String, GenericsType> resolvedPlaceholders, ClassNode currentType) {
         Map<String, GenericsType> placeholdersFromContext = getGenericsParameterMapOfThis(typeCheckingContext.getEnclosingMethod());
         applyContextGenerics(resolvedPlaceholders,placeholdersFromContext);
@@ -3655,7 +3747,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         }
 
         GenericsType[] returnTypeGenerics = getGenericsWithoutArray(currentType);
-        if (returnTypeGenerics==null) return currentType;
+        if (returnTypeGenerics==null || returnTypeGenerics.length==0) return currentType;
         GenericsType[] copy = new GenericsType[returnTypeGenerics.length];
         for (int i = 0; i < copy.length; i++) {
             GenericsType returnTypeGeneric = returnTypeGenerics[i];
diff --git a/src/test/groovy/transform/stc/TypeInferenceSTCTest.groovy b/src/test/groovy/transform/stc/TypeInferenceSTCTest.groovy
index a62484c35a..703eab0d00 100644
--- a/src/test/groovy/transform/stc/TypeInferenceSTCTest.groovy
+++ b/src/test/groovy/transform/stc/TypeInferenceSTCTest.groovy
@@ -3,9 +3,7 @@
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ * You may obtain a copy of thearresSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -671,5 +669,78 @@ class TypeInferenceSTCTest extends StaticTypeCheckingTestCase {
             """
         }
     }
+
+    // GROOVY-6522
+    void testInferenceWithImplicitClosureCoercion() {
+        assertScript '''
+interface CustomCallable<T> {
+    T call()
+}
+
+class Thing {
+    static <T> T customType(CustomCallable<T> callable) {
+        callable.call()
+    }
+
+    @ASTTest(phase=INSTRUCTION_SELECTION,value={
+        lookup('test').each {
+            def call = it.expression
+            def irt = call.getNodeMetaData(INFERRED_TYPE)
+            assert irt == LIST_TYPE
+        }
+    })
+    static void run() {
+        test: customType { [] } // return type is not inferred - fails compile
+    }
+}
+
+Thing.run()
+'''
+    }
+
+    void testInferenceWithImplicitClosureCoercionAndArrayReturn() {
+        assertScript '''
+            interface ArrayFactory<T> { T[] array() }
+
+            public <T> T[] intArray(ArrayFactory<T> f) {
+                f.array()
+            }
+            @ASTTest(phase=INSTRUCTION_SELECTION,value={
+                assert node.getNodeMetaData(INFERRED_TYPE) == Integer_TYPE.makeArray()
+            })
+            def array = intArray { new Integer[8] }
+            assert array.length == 8
+        '''
+    }
+
+    void testInferenceWithImplicitClosureCoercionAndListReturn() {
+        assertScript '''
+            interface ListFactory<T> { List<T> list() }
+
+            public <T> List<T> list(ListFactory<T> f) {
+                f.list()
+            }
+
+            @ASTTest(phase=INSTRUCTION_SELECTION,value={
+                def irt = node.getNodeMetaData(INFERRED_TYPE)
+                assert irt == LIST_TYPE
+                assert irt.genericsTypes[0].type == Integer_TYPE
+            })
+            def res = list { new LinkedList<Integer>() }
+            assert res.size() == 0
+        '''
+    }
+
+    void testInferenceWithImplicitClosureCoercionAndGenericTypeAsParameter() {
+        assertScript '''
+            interface Action<T> { void execute(T t) }
+
+            public <T> void exec(T t, Action<T> f) {
+                f.execute(t)
+            }
+
+            exec('foo') { println it.toUpperCase() }
+        '''
+    }
 }
 
