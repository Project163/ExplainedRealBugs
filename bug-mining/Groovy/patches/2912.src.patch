diff --git a/src/main/groovy/lang/GroovyClassLoader.java b/src/main/groovy/lang/GroovyClassLoader.java
index 92d629e4d0..049d336679 100644
--- a/src/main/groovy/lang/GroovyClassLoader.java
+++ b/src/main/groovy/lang/GroovyClassLoader.java
@@ -905,48 +905,49 @@ public class GroovyClassLoader extends URLClassLoader {
     public void addClasspath(final String path) {
         AccessController.doPrivileged(new PrivilegedAction<Void>() {
             public Void run() {
+
+                URI newURI;
                 try {
-                    // As the java.net.URL Javadoc says, the recommended way to get a URL is via URI.
-                    // http://docs.oracle.com/javase/7/docs/api/java/net/URL.html
-                    // "Note, the URI class does perform escaping of its component fields in certain circumstances.
-                    // The recommended way to manage the encoding and decoding of URLs is to use URI, and to convert
-                    // between these two classes using toURI() and URI.toURL()."
-                    // A possibly better approach here is to construct a URI and then resolve it against
-                    // a URI for the current working directory.
-                    // But we use this string match for now so everyone can see it doesn't hurt file-only classpaths.
-                    URI newURI;
-                    if (!URI_PATTERN.matcher(path).matches()) {
-                        newURI = new File(path).toURI();
-                    } else {
-                        newURI = new URI(path);
-                    }
-                    URL[] urls = getURLs();
-                    for (URL url : urls) {
-                        // Do not use URL.equals.  It uses the network to resolve names and compares ip addresses!
-                        // That is a violation of RFC and just plain evil.
-                        // http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html
-                        // http://docs.oracle.com/javase/7/docs/api/java/net/URL.html#equals(java.lang.Object)
-                        // "Since hosts comparison requires name resolution, this operation is a blocking operation.
-                        // Note: The defined behavior for equals is known to be inconsistent with virtual hosting in HTTP."
+                    newURI = new URI(path);
+                    // check if we can create a URL from that URI
+                    newURI.toURL();
+                } catch (URISyntaxException e) {
+                    // the URI has a false format, so lets try it with files ...
+                    newURI=new File(path).toURI();
+                } catch (MalformedURLException e) {
+                    // the URL has a false format, so lets try it with files ...
+                    newURI=new File(path).toURI();
+                } catch (IllegalArgumentException e) {
+                    // the URL is not absolute, so lets try it with files ...
+                    newURI=new File(path).toURI();
+                }
+
+                URL[] urls = getURLs();
+                for (URL url : urls) {
+                    // Do not use URL.equals.  It uses the network to resolve names and compares ip addresses!
+                    // That is a violation of RFC and just plain evil.
+                    // http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html
+                    // http://docs.oracle.com/javase/7/docs/api/java/net/URL.html#equals(java.lang.Object)
+                    // "Since hosts comparison requires name resolution, this operation is a blocking operation.
+                    // Note: The defined behavior for equals is known to be inconsistent with virtual hosting in HTTP."
+                    try {
                         if (newURI.equals(url.toURI())) return null;
+                    } catch (URISyntaxException e) {
+                        // fail fast! if we got a malformed URI the Classloader has to tell it
+                        throw new RuntimeException( e );
                     }
+                }
+                try {
                     addURL(newURI.toURL());
                 } catch (MalformedURLException e) {
-                    //TODO: fail through ?
-                } catch (URISyntaxException e) {
-                    // Just doing the same thing...
+                    // fail fast! if we got a malformed URL the Classloader has to tell it
+                    throw new RuntimeException( e );
                 }
                 return null;
             }
         });
     }
 
-    // TODO remove duplication with GroovyMain#uriPattern
-    // RFC2396
-    // scheme        = alpha *( alpha | digit | "+" | "-" | "." )
-    // match URIs but not Windows filenames, e.g.: http://cnn.com but not C:\xxx\file.ext
-    private static final Pattern URI_PATTERN = Pattern.compile("\\p{Alpha}[-+.\\p{Alnum}]*:[^\\\\]*");
-
     /**
      * <p>Returns all Groovy classes loaded by this class loader.
      *
diff --git a/src/main/groovy/ui/GroovyMain.java b/src/main/groovy/ui/GroovyMain.java
index 4fc921b791..9f22ee1526 100644
--- a/src/main/groovy/ui/GroovyMain.java
+++ b/src/main/groovy/ui/GroovyMain.java
@@ -391,17 +391,16 @@ public class GroovyMain {
     protected GroovyCodeSource getScriptSource(boolean isScriptFile, String script) throws IOException, URISyntaxException {
         //check the script is currently valid before starting a server against the script
         if (isScriptFile) {
-            if (uriPattern.matcher(script).matches()) {
+            // search for the file and if it exists don't try to use URIs ...
+            File scriptFile = huntForTheScriptFile(script);
+            if (!scriptFile.exists() && uriPattern.matcher(script).matches()) {
                 return new GroovyCodeSource(new URI(script));
-            } else {
-                return new GroovyCodeSource(huntForTheScriptFile(script));
             }
-        } else {
-            return new GroovyCodeSource(script, "script_from_command_line", GroovyShell.DEFAULT_CODE_BASE);
+            return new GroovyCodeSource( scriptFile );
         }
+        return new GroovyCodeSource(script, "script_from_command_line", GroovyShell.DEFAULT_CODE_BASE);
     }
 
-    // TODO remove duplication with GroovyClassLoader#uriPattern
     // RFC2396
     // scheme        = alpha *( alpha | digit | "+" | "-" | "." )
     // match URIs but not Windows filenames, e.g.: http://cnn.com but not C:\xxx\file.ext
