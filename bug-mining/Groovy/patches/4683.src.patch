diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index df2a69862c..11845546a6 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -3219,6 +3219,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         }
 
         if (candidates.size() > 1) {
+            closureSignatures = new ArrayList<>(candidates);
             for (Iterator<ClassNode[]> candIt = candidates.iterator(); candIt.hasNext(); ) {
                 ClassNode[] inferredTypes = candIt.next();
                 for (int i = 0; i < inferredTypes.length; i += 1) {
@@ -3230,7 +3231,11 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             if (candidates.size() > 1 && resolverClass instanceof ClassExpression) {
                 candidates = resolveWithResolver(candidates, receiver, arguments, expression, selectedMethod, resolverClass, options);
             }
-            if (candidates.size() > 1) {
+            if (candidates.isEmpty()) {
+                String actual = toMethodParametersString("", extractTypesFromParameters(closureParams));
+                String expect = closureSignatures.stream().map(sig -> toMethodParametersString("",sig)).collect(Collectors.joining(" or "));
+                addStaticTypeError("Incorrect parameter type(s). Expected " + expect + " but found " + actual, expression); // at least one fails
+            } else if (candidates.size() > 1) {
                 addError("Ambiguous prototypes for closure. More than one target method matches. Please use explicit argument types.", expression);
             }
         }
diff --git a/src/test/groovy/transform/stc/ClosureParamTypeInferenceSTCTest.groovy b/src/test/groovy/transform/stc/ClosureParamTypeInferenceSTCTest.groovy
index 54443251dc..dc82c599dc 100644
--- a/src/test/groovy/transform/stc/ClosureParamTypeInferenceSTCTest.groovy
+++ b/src/test/groovy/transform/stc/ClosureParamTypeInferenceSTCTest.groovy
@@ -753,24 +753,33 @@ class ClosureParamTypeInferenceSTCTest extends StaticTypeCheckingTestCase {
     }
     void testInferenceForDGM_findOnStr() { // GROOVY-11076, GROOVY-11089
         assertScript '''
-            "75001 Paris".find(/(\\d{5}\\s(\\w+))/) { List<String> all_zip_city -> all_zip_city*.toUpperCase() }
+            "75001 Paris".find(/(\\d{5})\\s(\\w+)/) { List<String> all_zip_city -> all_zip_city*.toUpperCase() }
         '''
         assertScript '''
-            "75001 Paris".find(/(\\d{5}\\s(\\w+))/) { String[] all_zip_city -> all_zip_city*.toUpperCase() }
+            "75001 Paris".find(/(\\d{5})\\s(\\w+)/) { String[] all_zip_city -> all_zip_city*.toUpperCase() }
         '''
         assertScript '''
-            "75001 Paris".find(/(\\d{5}\\s(\\w+))/) { Object[] all_zip_city -> all_zip_city*.toString() }
+            "75001 Paris".find(/(\\d{5})\\s(\\w+)/) { Object[] all_zip_city -> all_zip_city*.toString() }
         '''
         assertScript '''
-            "75001 Paris".find(/(\\d{5}\\s(\\w+))/) { all, zip, city -> all.size() + zip.size() + city.size() }
+            "75001 Paris".find(/(\\d{5})\\s(\\w+)/) { all, zip, city -> all.size() + zip.size() + city.size() }
         '''
         assertScript '''
-            "75001 Paris".find(/(\\d{5}\\s(\\w+))/) { String all, String zip, String city -> city + " " + zip }
+            "75001 Paris".find(/(\\d{5})\\s(\\w+)/) { String all, String zip, String city -> city + " " + zip }
         '''
+        assertScript '''
+            "75001 Paris".find(~/\\d{5}/) { String zip -> zip }
+        '''
+
         shouldFailWithMessages '''
-            "75001 Paris".find(/(\\d{5}\\s(\\w+))/) { String all, Date zip, String city -> }
+            "75001 Paris".find(/(\\d{5})\\s(\\w+)/) { String all, Date zip, String city -> }
         ''',
         'Expected type java.lang.String for closure parameter: zip'
+
+        shouldFailWithMessages '''
+            "75001 Paris".find(~/\\d{5}/) { Number zip -> zip }
+        ''',
+        'Expected (java.util.List<java.lang.String>) or (java.lang.String) or (java.lang.String[]) but found (java.lang.Number)'
     }
 
     void testInferenceForDGM_findAllOnCollection() {
@@ -1200,6 +1209,13 @@ class ClosureParamTypeInferenceSTCTest extends StaticTypeCheckingTestCase {
         '''
     }
 
+    void testDGM_withDefaultOnMap() {
+        assertScript '''
+            def map = [a:'A'].withDefault { it.toUpperCase() }
+            assert map.b=='B'
+        '''
+    }
+
     void testDGM_anyOnMap() {
         assertScript '''
             assert [a:10, b:1].any { k,v -> k.length() == v }
@@ -1224,13 +1240,6 @@ class ClosureParamTypeInferenceSTCTest extends StaticTypeCheckingTestCase {
         '''
     }
 
-    void testDGM_mapWithDefault() {
-        assertScript '''
-            def map = [a:'A'].withDefault { it.toUpperCase() }
-            assert map.b=='B'
-        '''
-    }
-
     // GROOVY-6939
     void testParamCountCheck1() {
         shouldFailWithMessages '''
