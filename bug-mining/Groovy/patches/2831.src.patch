diff --git a/src/main/org/codehaus/groovy/transform/sc/StaticCompilationVisitor.java b/src/main/org/codehaus/groovy/transform/sc/StaticCompilationVisitor.java
index 39c8b842da..d492a6c0a7 100644
--- a/src/main/org/codehaus/groovy/transform/sc/StaticCompilationVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/sc/StaticCompilationVisitor.java
@@ -215,6 +215,7 @@ public class StaticCompilationVisitor extends StaticTypeCheckingVisitor {
         final int access = Opcodes.ACC_STATIC | Opcodes.ACC_PUBLIC | Opcodes.ACC_SYNTHETIC;
         for (MethodNode method : methods) {
             if (accessedMethods.contains(method)) {
+                List<String> methodSpecificGenerics = methodSpecificGenerics(method);
                 i++;
                 ClassNode declaringClass = method.getDeclaringClass();
                 Map<String,ClassNode> genericsSpec = createGenericsSpec(node);
@@ -225,7 +226,7 @@ public class StaticCompilationVisitor extends StaticTypeCheckingVisitor {
                 for (int j = 1; j < newParams.length; j++) {
                     Parameter orig = methodParameters[j-1];
                     newParams[j] = new Parameter(
-                            correctToGenericsSpecRecurse(genericsSpec, orig.getOriginType(),methodSpecificGenerics(method)),
+                            correctToGenericsSpecRecurse(genericsSpec, orig.getOriginType(), methodSpecificGenerics),
                             orig.getName()
                     );
                 }
@@ -247,10 +248,14 @@ public class StaticCompilationVisitor extends StaticTypeCheckingVisitor {
                 ExpressionStatement returnStatement = new ExpressionStatement(mce);
                 MethodNode bridge = node.addMethod(
                         "access$"+i, access,
-                        correctToGenericsSpecRecurse(genericsSpec, method.getReturnType(), methodSpecificGenerics(method)),
+                        correctToGenericsSpecRecurse(genericsSpec, method.getReturnType(), methodSpecificGenerics),
                         newParams,
                         method.getExceptions(),
                         returnStatement);
+                GenericsType[] origGenericsTypes = method.getGenericsTypes();
+                if (origGenericsTypes !=null) {
+                    bridge.setGenericsTypes(applyGenericsContextToPlaceHolders(genericsSpec,origGenericsTypes));
+                }
                 privateBridgeMethods.put(method, bridge);
                 bridge.addAnnotation(new AnnotationNode(COMPILESTATIC_CLASSNODE));
             }
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7298Bug.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7298Bug.groovy
new file mode 100644
index 0000000000..f6d15e1b89
--- /dev/null
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7298Bug.groovy
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2003-2015 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+
+package org.codehaus.groovy.classgen.asm.sc.bugs
+
+import groovy.transform.stc.StaticTypeCheckingTestCase
+import org.codehaus.groovy.classgen.asm.sc.StaticCompilationTestSupport
+
+class Groovy7298Bug extends StaticTypeCheckingTestCase implements StaticCompilationTestSupport {
+    void testShouldNotThrowNPEInTypeResolver() {
+            assertScript '''
+
+public <T> T tryToExecuteWithFreePort(Closure<T> closure) {
+    [1].each {
+        return executeLogicForAvailablePort(closure)
+    }
+}
+
+private <T> T executeLogicForAvailablePort(Closure<T> closure) {
+    return closure.call()
+}
+
+executeLogicForAvailablePort {}
+
+
+        '''
+    }
+}
