diff --git a/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java b/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
index 226640d3d7..e4158af395 100644
--- a/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
+++ b/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
@@ -3333,14 +3333,17 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
 
     /**
      * <p/>
-     * Returns a new Map containg all entries from <code>left</code> and <code>right</code>,
+     * Returns a new Map containing all entries from <code>left</code> and <code>right</code>,
      * giving precedence to <code>right</code>.  Any keys appearing in both Maps
      * will appear in the resultant map with values from the <code>right</code>
-     * operand.
+     * operand. If the <code>left</code> map is one of TreeMap, LinkedHashMap, Hashtable
+     * or Properties, the returned Map will preserve that type, otherwise a HashMap will
+     * be returned.
      * </p>
      * <p/>
-     * <p/>
-     * Equivalent to <code>Map m = new HashMap(); m.putAll(left); m.putAll(right); return m;</code>
+     * Roughly equivalent to <code>Map m = new HashMap(); m.putAll(left); m.putAll(right); return m;</code>
+     * but with some additional logic to preserve the <code>left</code> Map type for common cases as
+     * described above.
      * </p>
      *
      * @param left  a Map
@@ -3348,7 +3351,19 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      * @return a new Map containing all entries from left and right
      */
     public static Map plus(Map left, Map right) {
-        Map map = new TreeMap(left);
+        Map map;
+        if (left instanceof TreeMap)
+            map = new TreeMap(left);
+        else if (left instanceof LinkedHashMap)
+            map = new LinkedHashMap(left);
+        else if (left instanceof Properties) {
+            map = new Properties();
+            map.putAll(left);
+        }
+        else if (left instanceof Hashtable)
+            map = new Hashtable(left);
+        else
+            map = new HashMap(left);
         map.putAll(right);
         return map;
     }
diff --git a/src/test/groovy/MapTest.groovy b/src/test/groovy/MapTest.groovy
index 1efa58eb02..09d59f1407 100644
--- a/src/test/groovy/MapTest.groovy
+++ b/src/test/groovy/MapTest.groovy
@@ -53,7 +53,7 @@ class MapTest extends GroovyTestCase {
             assert false , "should contain 3!"
         }
     }
-    
+
     void testEmptyMap() {
         def m = [:]
 
@@ -99,14 +99,24 @@ class MapTest extends GroovyTestCase {
         assert [:]   == ['a':1].findAll {false}
     }
 
-    void testMapAddition() {
+    void testMapAdditionProducesCorrectValueAndPreservesOriginalMaps() {
         def left = [a:1, b:2]
         def right = [c:3]
         assert left + right == [a:1, b:2, c:3], "should contain all entries from both maps"
         assert left == [a:1, b:2] && right == [c:3], "LHS/RHS should not be modified"
+    }
 
-        left = [a:1, b:1]
-        right = [a:2]
+    void testMapAdditionGivesPrecedenceOfOverlappingValuesToRightMap() {
+        def left = [a:1, b:1]
+        def right = [a:2]
         assert left + right == [a:2, b:1], "RHS should take precedence when entries have same key"
     }
+
+    void testMapAdditionPreservesOriginalTypeForCommonCases() {
+        def other = [c: 3]
+        assert ([a: 1, b: 2] as Properties)    + other == [a:1, b:2, c:3] as Properties
+        assert ([a: 1, b: 2] as Hashtable)     + other == [a:1, b:2, c:3] as Hashtable
+        assert ([a: 1, b: 2] as LinkedHashMap) + other == [a:1, b:2, c:3] as LinkedHashMap
+        assert ([a: 1, b: 2] as TreeMap)       + other == [a:1, b:2, c:3] as TreeMap
+    }
 }
