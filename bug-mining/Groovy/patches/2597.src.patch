diff --git a/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/MarkupTemplateEngine.java b/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/MarkupTemplateEngine.java
index 9e3ee8d402..aa51740577 100644
--- a/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/MarkupTemplateEngine.java
+++ b/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/MarkupTemplateEngine.java
@@ -42,6 +42,7 @@ import java.net.URLClassLoader;
 import java.security.AccessController;
 import java.security.PrivilegedAction;
 import java.util.Collections;
+import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.regex.Matcher;
@@ -64,6 +65,7 @@ public class MarkupTemplateEngine extends TemplateEngine {
     private final TemplateGroovyClassLoader groovyClassLoader;
     private final CompilerConfiguration compilerConfiguration;
     private final TemplateConfiguration templateConfiguration;
+    private final Map<String, GroovyCodeSource> codeSourceCache = new LinkedHashMap<String, GroovyCodeSource>();
 
     public MarkupTemplateEngine(final TemplateConfiguration tplConfig) {
         this(MarkupTemplateEngine.class.getClassLoader(), tplConfig);
@@ -199,7 +201,22 @@ public class MarkupTemplateEngine extends TemplateEngine {
 
         @SuppressWarnings("unchecked")
         public MarkupTemplateMaker(final URL resource, Map<String, String> modelTypes) throws IOException {
-            templateClass = groovyClassLoader.parseClass(new GroovyCodeSource(resource), modelTypes);
+            boolean cache = templateConfiguration.isCacheTemplates();
+            GroovyCodeSource codeSource;
+            if (cache) {
+                // we use a map in addition to the internal caching mechanism of Groovy because the latter
+                // will always read from the URL even if it's cached
+                String key = resource.toExternalForm();
+                codeSource = codeSourceCache.get(key);
+                if (codeSource==null) {
+                    codeSource = new GroovyCodeSource(resource);
+                    codeSourceCache.put(key, codeSource);
+                }
+            } else {
+                codeSource = new GroovyCodeSource(resource);
+            }
+            codeSource.setCachable(cache);
+            templateClass = groovyClassLoader.parseClass(codeSource, modelTypes);
             this.modeltypes = modelTypes;
         }
 
diff --git a/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/TemplateConfiguration.java b/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/TemplateConfiguration.java
index 8fdcf03313..71bb202f4e 100644
--- a/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/TemplateConfiguration.java
+++ b/subprojects/groovy-templates/src/main/groovy/groovy/text/markup/TemplateConfiguration.java
@@ -34,6 +34,7 @@ public class TemplateConfiguration {
     private boolean autoNewLine = false;
     private Class<? extends BaseTemplate> baseTemplateClass = BaseTemplate.class;
     private Locale locale = Locale.getDefault();
+    private boolean cacheTemplates = true;
 
     public TemplateConfiguration() {
     }
@@ -170,4 +171,17 @@ public class TemplateConfiguration {
     public void setLocale(final Locale locale) {
         this.locale = locale;
     }
+
+    public boolean isCacheTemplates() {
+        return cacheTemplates;
+    }
+
+    /**
+     * If cache is enabled, then templates are compiled once for each source (URL or File). It is recommanded to keep
+     * this flag to true unless you are in development mode and want automatic reloading of templates.
+     * @param cacheTemplates should templates be cached
+     */
+    public void setCacheTemplates(final boolean cacheTemplates) {
+        this.cacheTemplates = cacheTemplates;
+    }
 }
