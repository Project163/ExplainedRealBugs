diff --git a/src/main/groovy/text/GStringTemplateEngine.java b/src/main/groovy/text/GStringTemplateEngine.java
index 2679fa912c..0c1db6816c 100644
--- a/src/main/groovy/text/GStringTemplateEngine.java
+++ b/src/main/groovy/text/GStringTemplateEngine.java
@@ -1,47 +1,47 @@
 /* $Id$
 
- Copyright 2004 (C) John Wilson. All Rights Reserved.
+Copyright 2004 (C) John Wilson. All Rights Reserved.
 
- Redistribution and use of this software and associated documentation
- ("Software"), with or without modification, are permitted provided
- that the following conditions are met:
+Redistribution and use of this software and associated documentation
+("Software"), with or without modification, are permitted provided
+that the following conditions are met:
 
- 1. Redistributions of source code must retain copyright
-    statements and notices.  Redistributions must also contain a
-    copy of this document.
+1. Redistributions of source code must retain copyright
+   statements and notices.  Redistributions must also contain a
+   copy of this document.
 
- 2. Redistributions in binary form must reproduce the
-    above copyright notice, this list of conditions and the
-    following disclaimer in the documentation and/or other
-    materials provided with the distribution.
+2. Redistributions in binary form must reproduce the
+   above copyright notice, this list of conditions and the
+   following disclaimer in the documentation and/or other
+   materials provided with the distribution.
 
- 3. The name "groovy" must not be used to endorse or promote
-    products derived from this Software without prior written
-    permission of The Codehaus.  For written permission,
-    please contact info@codehaus.org.
+3. The name "groovy" must not be used to endorse or promote
+   products derived from this Software without prior written
+   permission of The Codehaus.  For written permission,
+   please contact info@codehaus.org.
 
- 4. Products derived from this Software may not be called "groovy"
-    nor may "groovy" appear in their names without prior written
-    permission of The Codehaus. "groovy" is a registered
-    trademark of The Codehaus.
+4. Products derived from this Software may not be called "groovy"
+   nor may "groovy" appear in their names without prior written
+   permission of The Codehaus. "groovy" is a registered
+   trademark of The Codehaus.
 
- 5. Due credit should be given to The Codehaus -
-    http://groovy.codehaus.org/
+5. Due credit should be given to The Codehaus -
+   http://groovy.codehaus.org/
 
- THIS SOFTWARE IS PROVIDED BY THE CODEHAUS AND CONTRIBUTORS
- ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
- NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
- FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
- THE CODEHAUS OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
- INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
- OF THE POSSIBILITY OF SUCH DAMAGE.
+THIS SOFTWARE IS PROVIDED BY THE CODEHAUS AND CONTRIBUTORS
+``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
+NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
+THE CODEHAUS OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+OF THE POSSIBILITY OF SUCH DAMAGE.
 
- */
+*/
 package groovy.text;
 
 import groovy.lang.*;
@@ -59,9 +59,9 @@ import org.codehaus.groovy.control.CompilationFailedException;
 
 
 /**
- * @author tug@wilson.co.uk
- *
- */
+* @author tug@wilson.co.uk
+*
+*/
 public class GStringTemplateEngine extends TemplateEngine {
 	/* (non-Javadoc)
 	 * @see groovy.text.TemplateEngine#createTemplate(java.io.Reader)
@@ -85,7 +85,7 @@ public class GStringTemplateEngine extends TemplateEngine {
 		 * 
 		 * would compile into:
 		 * 
-		 * { |out| $var1 = ( "test" ); test = 1 ; $var2 = (test); out << "${$var1} of expr and ${$var2} script."}.asWritable()
+		 * { |out| out << "${"test"} of expr and "; test = 1 ; out << "${test} script."}.asWritable()
 		 * 
 		 * @param reader
 		 * @throws CompilationFailedException
@@ -93,13 +93,14 @@ public class GStringTemplateEngine extends TemplateEngine {
 		 * @throws IOException
 		 */
 		public GStringTemplate(final Reader reader) throws CompilationFailedException, ClassNotFoundException, IOException {
-			final StringBuffer templateExpressions = new StringBuffer("class C { getTemplate() { { |out| ");	
-			final StringBuffer templateGString = new StringBuffer("out << \"");
-			int varNumber = 1;
-        
+			final StringBuffer templateExpressions = new StringBuffer("class C { getTemplate() { { |out| out << \"");
+			boolean writingString = true;
+       
 	        while(true) {
 	        	int c = reader.read();
 	        	
+	        		if (c == -1) break;
+	        	
 	            if (c == '<') {
 	                c = reader.read();
 	                
@@ -107,36 +108,32 @@ public class GStringTemplateEngine extends TemplateEngine {
 		                c = reader.read();
 		                
 		                if (c == '=') {
-		                		parseExpression(reader, varNumber++, templateExpressions, templateGString);
+		                		parseExpression(reader, writingString, templateExpressions);
+		                		writingString = true;
 		                		continue;
 		                } else {
-		                		parseSection(reader, templateExpressions);
+		                		parseSection(reader, writingString, templateExpressions);
+		                		writingString = false;
 		                		continue;
 		                }
 	                } else {
-	                		templateGString.append('<');
-	                }
-	            } else if (c == '$') {
-	                c = reader.read();
-	                
-	                if (c == '{') {
-	                		parseGStringEpression(reader, varNumber++, templateExpressions, templateGString);
-	                		continue;
-	                } else {
-	                		templateGString.append('$');
+	                	appendCharacter('<', templateExpressions, writingString);
+	                	writingString = true;
 	                }
-	            }
-	            
-            		if (c == '"') {
-            			templateGString.append('\\');
-            		} if (c == -1) {
-            			break;
-            		}
-            		
-            		templateGString.append((char)c);
+	            } else if (c == '"') {
+	                	appendCharacter('\\', templateExpressions, writingString);
+	                	writingString = true;
+           		}
+           		
+	            	appendCharacter((char)c, templateExpressions, writingString);
+	            	writingString = true;
 	        }
 	        
-	        templateExpressions.append(templateGString).append("\"}.asWritable()}}");
+	        if (writingString) {
+	        		templateExpressions.append("\"");
+	        }
+	        
+	        templateExpressions.append("}.asWritable()}}");
 	        
 //	        System.out.println(templateExpressions.toString());
 	        
@@ -160,18 +157,36 @@ public class GStringTemplateEngine extends TemplateEngine {
 			}
 		}
 		
+		private static void appendCharacter(final char c,
+										  final StringBuffer templateExpressions,
+										  final boolean writingString)
+		{
+			if (!writingString) {
+				templateExpressions.append("out << \"");
+			}
+			
+			templateExpressions.append(c);
+		}
+		
 		/**
 		 * Parse a <% .... %> section
-		 * make the code in the section a statement at the begining of the closure
+		 * if we are writing a GString close and append ';'
+		 * then write the section as a statement
 		 * 
 		 * @param reader
+		 * @param writingString
 		 * @param templateExpressions
 		 * @throws IOException
 		 */
 		private static void parseSection(final Reader reader,
+									    final boolean writingString,
 				                         final StringBuffer templateExpressions)
 			throws IOException
 		{
+			if (writingString) {
+				templateExpressions.append("\"; ");
+			}
+			
 	    		while (true) {
 	    			int c = reader.read();
 	    			
@@ -191,25 +206,23 @@ public class GStringTemplateEngine extends TemplateEngine {
 		
 		/**
 		 * Parse a <%= .... %> expression
-		 * make the expression the RHS of an assignment at the begining of the closure
-		 * embed the variable on the LHS of the expression in the GString
 		 * 
 		 * @param reader
-		 * @param varNumber
+		 * @param writingString
 		 * @param templateExpressions
-		 * @param templateGString
 		 * @throws IOException
 		 */
 		private static void parseExpression(final Reader reader,
-											final int varNumber,
-											final StringBuffer templateExpressions,
-											final StringBuffer templateGString)
+										  final boolean writingString,
+										  final StringBuffer templateExpressions)
 			throws IOException
 		{
-	    		templateGString.append("${$var" + varNumber).append("}");
-	    		
-	    		templateExpressions.append("$var" + varNumber).append(" = (");
-	    		
+			if (!writingString) {
+				templateExpressions.append("out << \"");
+			}
+			
+			templateExpressions.append("${");
+			
 	    		while (true) {
 	    			int c = reader.read();
 	    			
@@ -223,84 +236,45 @@ public class GStringTemplateEngine extends TemplateEngine {
 	    			
 	    			templateExpressions.append((char)c);
 	    		}
-	    		
-	    		templateExpressions.append("); ");
-		}
-		
-		/**
-		 * Parse a ${ .... } expression
-		 * make the expression the RHS of an assignment at the begining of the closure
-		 * embed the variable on the LHS of the expression in the GString
-		 * 
-		 * @param reader
-		 * @param varNumber
-		 * @param templateExpressions
-		 * @param templateGString
-		 * @throws IOException
-		 */
-		private static void parseGStringEpression(final Reader reader,
-												  final int varNumber,
-												  final StringBuffer templateExpressions,
-												  final StringBuffer templateGString)
-		throws IOException
-		{
-	    		templateGString.append("${$var" + varNumber).append("}");
-	    		
-	    		templateExpressions.append("$var" + varNumber).append(" = (");
-	    		
-	    		int nestDepth = 0;
-	    		
-	    		while (true) {
-	    			int c = reader.read();
-	    			
-	    			if (c == -1) break;
-	    			
-	    			if (c == '}' && nestDepth-- == 0) break;
-	    			
-					if (c == '{') nestDepth++;
-					
-					templateExpressions.append((char)c);
-	    		}
-	    		
-	    		templateExpressions.append("); ");		                		
+				
+			templateExpressions.append('}');
 		}
 
+		public Writable make() {
+           return make(null);
+       }
 
-        public Writable make() {
-            return make(null);
-        }
-
-        public Writable make(final Map map) {
-        final Closure delegatedClosure = (Closure)this.template.clone();
-            
-            delegatedClosure.setDelegate(new Binding(map));
-            
-            return new Writable() {
-                /* (non-Javadoc)
-                * @see groovy.lang.Writable#writeTo(java.io.Writer)
-                */
-                public Writer writeTo(final Writer writer) throws IOException {
-                    delegatedClosure.call(new Object[] {new PrintWriter(writer)});
+       public Writable make(final Map map) {
+       final Closure delegatedClosure = (Closure)this.template.clone();
+           
+           delegatedClosure.setDelegate(new Binding(map));
+           
+           return new Writable() {
+               /* (non-Javadoc)
+               * @see groovy.lang.Writable#writeTo(java.io.Writer)
+               */
+               public Writer writeTo(final Writer writer) throws IOException {
+                   delegatedClosure.call(new Object[] {new PrintWriter(writer)});
 
-                    return writer;
-                }
+                   return writer;
+               }
 
-                /* (non-Javadoc)
-                * @see java.lang.Object#toString()
-                */
-                public String toString() {
-                    final StringWriter stringWriter = new StringWriter();
+               /* (non-Javadoc)
+               * @see java.lang.Object#toString()
+               */
+               public String toString() {
+                   final StringWriter stringWriter = new StringWriter();
 
-                    try {
-                        writeTo(stringWriter);
+                   try {
+                       writeTo(stringWriter);
 
-                        return stringWriter.toString();
-                    } catch (final IOException e) {
-                        return e.toString();
-                    }
-                }
+                       return stringWriter.toString();
+                   } catch (final IOException e) {
+                       return e.toString();
+                   }
+               }
 
-            };
-        }
+           };
+       }
 	}
 }
