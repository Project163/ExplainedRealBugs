diff --git a/src/main/groovy/lang/MetaClassImpl.java b/src/main/groovy/lang/MetaClassImpl.java
index 8a612ae7a6..0a173a6eb0 100644
--- a/src/main/groovy/lang/MetaClassImpl.java
+++ b/src/main/groovy/lang/MetaClassImpl.java
@@ -1936,18 +1936,16 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
             LinkedList<CachedClass> superInterfaces = new LinkedList<CachedClass>(interfaces);
             // sort interfaces so that we may ensure a deterministic behaviour in case of
             // ambiguous fields (class implementing two interfaces using the same field)
-            Collections.sort(superInterfaces, CACHED_CLASS_NAME_COMPARATOR);
-            superInterfaces.remove(theCachedClass);
+            if (superInterfaces.size()>1) {
+                Collections.sort(superInterfaces, CACHED_CLASS_NAME_COMPARATOR);
+            }
 
-            classPropertyIndexForSuper = classPropertyIndex;
-            final SingleKeyHashMap cPI = classPropertyIndex.getNotNull(theCachedClass);
-            for (Iterator interfaceIter = interfaces.iterator(); interfaceIter.hasNext();) {
-                CachedClass iclass = (CachedClass) interfaceIter.next();
-                SingleKeyHashMap iPropertyIndex = cPI;
-                inheritStaticInterfaceFields(superInterfaces, interfaces);
-                classPropertyIndex.put(iclass, iPropertyIndex);
+            SingleKeyHashMap iPropertyIndex = classPropertyIndex.getNotNull(theCachedClass);
+            for (CachedClass iclass : superInterfaces) {
+                SingleKeyHashMap sPropertyIndex = classPropertyIndex.getNotNull(iclass);
+                copyNonPrivateFields(sPropertyIndex, iPropertyIndex);
+                addFields(iclass, iPropertyIndex);
             }
-            classPropertyIndex.put(ReflectionCache.OBJECT_CLASS, cPI);
 
             applyPropertyDescriptors(propertyDescriptors);
             applyStrayPropertyMethods(superClasses, classPropertyIndex, true);
@@ -1958,7 +1956,9 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
             LinkedList<CachedClass> interfaces = new LinkedList<CachedClass>(theCachedClass.getInterfaces());
             // sort interfaces so that we may ensure a deterministic behaviour in case of
             // ambiguous fields (class implementing two interfaces using the same field)
-            Collections.sort(interfaces, CACHED_CLASS_NAME_COMPARATOR);
+            if (interfaces.size()>1) {
+                Collections.sort(interfaces, CACHED_CLASS_NAME_COMPARATOR);
+            }
 
             // if this an Array, then add the special read-only "length" property
             if (theCachedClass.isArray) {
diff --git a/src/test/groovy/bugs/Groovy5272Bug.groovy b/src/test/groovy/bugs/Groovy5272Bug.groovy
index da3c339e9d..e41dafb22b 100644
--- a/src/test/groovy/bugs/Groovy5272Bug.groovy
+++ b/src/test/groovy/bugs/Groovy5272Bug.groovy
@@ -39,6 +39,52 @@ class Groovy5272Bug extends GroovyTestCase {
             assert A.FOO == "Foo C"
             '''
         }
+    }
+    
+    void testResolveConstantInSuperInterfaceWithExpando() {
+        assertScript '''
+            ExpandoMetaClass.enableGlobally()
+            interface Foo {
+                String FOO = 'FOO'
+            }
+            interface Bar extends Foo { }
+            assert Bar.FOO == 'FOO'
+            ExpandoMetaClass.disableGlobally()
+        '''
+    }
 
+    void testResolveConstantInSuperInterfaceWithoutExpando() {
+        assertScript '''
+            interface Foo {
+                String FOO = 'FOO'
+            }
+            interface Bar extends Foo { }
+            assert Bar.FOO == 'FOO'
+        '''
     }
+
+    void testResolveConstantInClassWithSuperInterfaceWithoutExpando() {
+        assertScript '''
+            interface Foo {
+                String FOO = 'FOO'
+            }
+            interface Bar extends Foo { }
+            class Baz implements Bar {}
+            assert Baz.FOO == 'FOO'
+        '''
+    }
+
+    void testResolveConstantInClassWithSuperInterfaceWithExpando() {
+        assertScript '''
+            ExpandoMetaClass.enableGlobally()
+            interface Foo {
+                String FOO = 'FOO'
+            }
+            interface Bar extends Foo { }
+            class Baz implements Bar {}
+            assert Baz.FOO == 'FOO'
+            ExpandoMetaClass.disableGlobally()
+        '''
+    }
+
 }
