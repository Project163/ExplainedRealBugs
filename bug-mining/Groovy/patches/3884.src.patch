diff --git a/src/main/java/org/codehaus/groovy/control/StaticImportVisitor.java b/src/main/java/org/codehaus/groovy/control/StaticImportVisitor.java
index f83a84ed13..de4e174320 100644
--- a/src/main/java/org/codehaus/groovy/control/StaticImportVisitor.java
+++ b/src/main/java/org/codehaus/groovy/control/StaticImportVisitor.java
@@ -281,22 +281,26 @@ public class StaticImportVisitor extends ClassCodeExpressionTransformer {
                 return false;
             };
 
-            if (isInnerClass(currentClass)) {
-                if (mce.isImplicitThis() && !inClosure && inSpecialConstructorCall && !foundInstanceMethod) {
-                    if (currentClass.getOuterClass().hasPossibleMethod(methodName, args)) {
-                        object = new PropertyExpression(new ClassExpression(currentClass.getOuterClass()), new ConstantExpression("this"));
-                    } else if (hasPossibleStaticMember.test(currentClass.getOuterClass())) {
-                        Expression result = new StaticMethodCallExpression(currentClass.getOuterClass(), methodName, args);
+            if (mce.isImplicitThis()) {
+                if (isInnerClass(currentClass)) {
+                    if (inSpecialConstructorCall && !foundInstanceMethod) {
+                        // check for reference to outer class method in this(...) or super(...)
+                        if (currentClass.getOuterClass().hasPossibleMethod(methodName, args)) {
+                            object = new PropertyExpression(new ClassExpression(currentClass.getOuterClass()), new ConstantExpression("this"));
+                        } else if (hasPossibleStaticMember.test(currentClass.getOuterClass())) {
+                            Expression result = new StaticMethodCallExpression(currentClass.getOuterClass(), methodName, args);
+                            result.setSourcePosition(mce);
+                            return result;
+                        }
+                    }
+                } else if (inSpecialConstructorCall || (!inClosure && !foundInstanceMethod && !methodName.equals("call"))) {
+                    // check for reference to static method in this(...) or super(...) or when call not resolved
+                    if (hasPossibleStaticMember.test(currentClass)) {
+                        Expression result = new StaticMethodCallExpression(currentClass, methodName, args);
                         result.setSourcePosition(mce);
                         return result;
                     }
                 }
-            } else if (inSpecialConstructorCall || (!foundInstanceMethod && !methodName.equals("call"))) {
-                if (hasPossibleStaticMember.test(currentClass)) {
-                    Expression result = new StaticMethodCallExpression(currentClass, methodName, args);
-                    result.setSourcePosition(mce);
-                    return result;
-                }
             }
         }
 
diff --git a/src/test/groovy/bugs/Groovy8816Bug.groovy b/src/test/groovy/bugs/Groovy8816.groovy
similarity index 67%
rename from src/test/groovy/bugs/Groovy8816Bug.groovy
rename to src/test/groovy/bugs/Groovy8816.groovy
index 2d6854d00c..0bd56e4e04 100644
--- a/src/test/groovy/bugs/Groovy8816Bug.groovy
+++ b/src/test/groovy/bugs/Groovy8816.groovy
@@ -18,21 +18,22 @@
  */
 package groovy.bugs
 
-import groovy.test.GroovyTestCase
+import org.junit.Test
 
-class Groovy8816Bug extends GroovyTestCase {
-    void testCallNoArgClosureWithArg() {
-        def msg = shouldFail MissingMethodException, '''
-        import groovy.transform.CompileStatic
+import static groovy.test.GroovyAssert.shouldFail
 
-        @CompileStatic
-        void main() {
-            [0].each { -> }
-        }
+final class Groovy8816 {
 
-        main()
+    @Test
+    void testCallNoArgClosureWithArg() {
+        def err = shouldFail MissingMethodException, '''
+            @groovy.transform.CompileStatic
+            void test() {
+                [0].each { -> }
+            }
+            test()
         '''
-        assert msg.contains('No signature of method:')
-        assert msg.contains('doCall() is applicable for argument types: (Integer) values: [0]')
+
+        assert err =~ /No signature of method: .*\.doCall\(\) is applicable for argument types: \(Integer\) values: \[0\]/
     }
 }
diff --git a/src/test/groovy/bugs/Groovy9691.groovy b/src/test/groovy/bugs/Groovy9691.groovy
new file mode 100644
index 0000000000..6e179f244e
--- /dev/null
+++ b/src/test/groovy/bugs/Groovy9691.groovy
@@ -0,0 +1,53 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package groovy.bugs
+
+import org.junit.Test
+
+import static groovy.test.GroovyAssert.assertScript
+
+final class Groovy9691 {
+
+    @Test
+    void testMainCallInClosure() {
+        assertScript '''
+            import org.codehaus.groovy.ast.expr.*
+
+            void sourceSets(Closure block) {
+                // no-op
+            }
+
+            sourceSets {
+                @groovy.transform.ASTTest({
+                    def call = node.rightExpression
+                    assert call instanceof MethodCall
+                    assert !(call instanceof StaticMethodCallExpression)
+                })
+                x = main {
+                    java { srcDirs = [] }
+                    groovy { srcDirs = ['src/main'] }
+                }
+                test {
+                    java { srcDirs = [] }
+                    groovy { srcDirs = ['src/test'] }
+                }
+            }
+        '''
+    }
+}
