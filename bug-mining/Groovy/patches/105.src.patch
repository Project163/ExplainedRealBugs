diff --git a/project.xml b/project.xml
index 4830cdb9ec..59e78f71bd 100644
--- a/project.xml
+++ b/project.xml
@@ -316,7 +316,11 @@
       <name>Arjun Nayyar</name>
       <email></email>
     </contributor>
-  	  </contributors>
+    <contributor>
+      <name>Mark Chu-Carroll</name>
+      <email></email>
+    </contributor>
+  	  	  </contributors>
   <dependencies>
 
     <!-- core dependencies -->
diff --git a/src/main/org/codehaus/groovy/ast/ClassNode.java b/src/main/org/codehaus/groovy/ast/ClassNode.java
index cd7428e127..9692a79b1a 100644
--- a/src/main/org/codehaus/groovy/ast/ClassNode.java
+++ b/src/main/org/codehaus/groovy/ast/ClassNode.java
@@ -155,6 +155,72 @@ public class ClassNode extends MetadataNode implements Constants {
         return methods;
     }
 
+    public List getAbstractMethods() {
+
+        List result = new ArrayList();
+        for (Iterator methIt = getAllDeclaredMethods().iterator(); methIt.hasNext();) {
+            MethodNode method = (MethodNode) methIt.next();
+            if (method.isAbstract()) result.add(method);
+        }
+        if (result.size() == 0)
+            return null;
+        else
+            return result;
+    }
+
+    public List getAllDeclaredMethods() {
+        return new ArrayList(getDeclaredMethodsMap().values());
+    }
+
+
+    protected Map getDeclaredMethodsMap() {
+        // Start off with the methods from the superclass.
+        ClassNode parent = getSuperClassNode();
+        Map result = null;
+        if (parent != null)
+            result = parent.getDeclaredMethodsMap();
+        else
+            result = new HashMap();
+
+        // add in unimplemented abstract methods from the interfaces
+        for (int i = 0; i < interfaces.length; i++) {
+            String interfaceName = interfaces[i];
+            ClassNode iface = findClassNode(interfaceName);
+            Map ifaceMethodsMap = iface.getDeclaredMethodsMap();
+            for (Iterator iter = ifaceMethodsMap.keySet().iterator(); iter.hasNext();) {
+                String methSig = (String) iter.next();
+                if (!result.containsKey(methSig)) {
+                    MethodNode methNode = (MethodNode) ifaceMethodsMap.get(methSig);
+                    result.put(methSig, methNode);
+                }
+            }
+        }
+
+        // And add in the methods implemented in this class.
+        for (Iterator iter = getMethods().iterator(); iter.hasNext();) {
+            MethodNode method = (MethodNode) iter.next();
+            String sig = method.getTypeDescriptor();
+            if (result.containsKey(sig)) {
+                MethodNode inheritedMethod = (MethodNode) result.get(sig);
+                if (inheritedMethod.isAbstract()) {
+                    result.put(sig, method);
+                }                
+            } else {
+                result.put(sig, method);
+            }
+        }
+        return result;
+    }
+
+    protected int findMatchingMethodInList(MethodNode method, List methods) {
+        for (int i = 0; i < methods.size(); i++) {
+            MethodNode someMeth = (MethodNode) methods.get(i);
+            if (someMeth.getName().equals(method.getName())
+                    && parametersEqual(someMeth.getParameters(), method.getParameters())) return i;
+        }
+        return -1;
+    }
+
     public String getName() {
         return name;
     }
diff --git a/src/main/org/codehaus/groovy/ast/MethodNode.java b/src/main/org/codehaus/groovy/ast/MethodNode.java
index abf405c7d5..59d636a6a3 100644
--- a/src/main/org/codehaus/groovy/ast/MethodNode.java
+++ b/src/main/org/codehaus/groovy/ast/MethodNode.java
@@ -76,7 +76,53 @@ public class MethodNode extends MetadataNode implements Constants {
             this.dynamicReturnType = true;
         }
     }
+    
+    /**
+     * The type descriptor for a method node is a string containing the name of the method, its return type, 
+     * and its parameter types in a canonical form. For simplicity, I'm using the format of a Java declaration
+     * without parameter names, and with $dynamic as the type for any dynamically typed values.
+     * @return
+     */
+    // TODO: add test case for type descriptor
+    public String getTypeDescriptor() {
+        StringBuffer buf = new StringBuffer();
+        buf.append(dynamicReturnType ? "$dynamic" : cleanupTypeName(returnType));
+        buf.append(' ');
+        buf.append(name);
+        buf.append('(');
+        for (int i=0; i < parameters.length; i++) {
+            if (i>0) buf.append(',');
+            Parameter param = parameters[i];
+            buf.append(cleanupTypeName(param.getType()));
+        }
+        buf.append(')');
+        return buf.toString();
+    }
 
+    protected String cleanupTypeName(String typename) {
+        // if the typename begins with "[", ends with ";", or is
+        // one character long, it's in .class syntax.
+        if (typename.charAt(0) == '[') {
+            return cleanupTypeName(typename.substring(1)) + "[]";
+        }
+        if (typename.length() == 1) {
+            switch (typename.charAt(0)) {
+            case 'J': return "long"; 
+            case 'I': return "int"; 
+            case 'C' : return "char"; 
+            case 'F' : return "float";
+            case 'V' : return "void"; 
+            case 'D' : return "double";            
+            }
+        }
+        if (typename.endsWith(";")) {
+            // Type should be "Lclassname;"
+            return typename.substring(1, typename.length() - 1);
+        }
+        return typename;
+        
+    }
+    
     public boolean isVoidMethod() {
         return "void".equals(returnType);
     }
@@ -125,6 +171,10 @@ public class MethodNode extends MetadataNode implements Constants {
         return declaringClass;
     }
     
+    public boolean isAbstract() {
+        return (modifiers & ACC_ABSTRACT) != 0;
+    }
+    
     public boolean isStatic() {
         return (modifiers & ACC_STATIC) != 0;
     }
diff --git a/src/main/org/codehaus/groovy/classgen/ClassCompletionVerifier.java b/src/main/org/codehaus/groovy/classgen/ClassCompletionVerifier.java
new file mode 100644
index 0000000000..357d5cb844
--- /dev/null
+++ b/src/main/org/codehaus/groovy/classgen/ClassCompletionVerifier.java
@@ -0,0 +1,84 @@
+/*******************************************************************************
+ * Copyright (c) 2004 IBM Corporation and others.
+ * All rights reserved.   This program and the accompanying materials
+ * are made available under the terms of the Common Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/cpl-v10.html
+ * 
+ * Contributors:
+ * IBM - Initial API and implementation
+ ******************************************************************************/
+
+
+package org.codehaus.groovy.classgen;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+import org.codehaus.groovy.ast.ClassNode;
+import org.codehaus.groovy.ast.ConstructorNode;
+import org.codehaus.groovy.ast.FieldNode;
+import org.codehaus.groovy.ast.GroovyClassVisitor;
+import org.codehaus.groovy.ast.MethodNode;
+import org.codehaus.groovy.ast.PropertyNode;
+import org.objectweb.asm.Constants;
+
+
+/**
+ * ClassCompletionVerifier
+ * 
+ */
+public class ClassCompletionVerifier implements Constants, GroovyClassVisitor {
+    
+    ClassNode classNode;
+    
+    public ClassNode getClassNode() {
+        return classNode;
+    }
+    
+
+    /* (non-Javadoc)
+     * @see org.codehaus.groovy.ast.GroovyClassVisitor#visitClass(org.codehaus.groovy.ast.ClassNode)
+     */
+    public void visitClass(ClassNode a_node) {
+        classNode = a_node;
+        if ((classNode.getModifiers() & Constants.ACC_ABSTRACT) == 0 ) {
+            List abstractMethods = classNode.getAbstractMethods();
+            if (abstractMethods != null) {
+                List methodNames = new ArrayList();
+                for (Iterator iter = abstractMethods.iterator(); iter.hasNext();) {
+                    MethodNode method = (MethodNode) iter.next();
+                    String methodName = method.getTypeDescriptor();
+                    methodNames.add(methodName);                
+                }
+                throw new RuntimeIncompleteClassException(methodNames, classNode);
+            }
+        }
+    }
+
+    /* (non-Javadoc)
+     * @see org.codehaus.groovy.ast.GroovyClassVisitor#visitConstructor(org.codehaus.groovy.ast.ConstructorNode)
+     */
+    public void visitConstructor(ConstructorNode a_node) {
+    }
+
+    /* (non-Javadoc)
+     * @see org.codehaus.groovy.ast.GroovyClassVisitor#visitMethod(org.codehaus.groovy.ast.MethodNode)
+     */
+    public void visitMethod(MethodNode a_node) {
+    }
+
+    /* (non-Javadoc)
+     * @see org.codehaus.groovy.ast.GroovyClassVisitor#visitField(org.codehaus.groovy.ast.FieldNode)
+     */
+    public void visitField(FieldNode a_node) {
+    }
+
+    /* (non-Javadoc)
+     * @see org.codehaus.groovy.ast.GroovyClassVisitor#visitProperty(org.codehaus.groovy.ast.PropertyNode)
+     */
+    public void visitProperty(PropertyNode a_node) {
+    }
+
+}
diff --git a/src/main/org/codehaus/groovy/classgen/RuntimeIncompleteClassException.java b/src/main/org/codehaus/groovy/classgen/RuntimeIncompleteClassException.java
new file mode 100644
index 0000000000..1f221c2bdb
--- /dev/null
+++ b/src/main/org/codehaus/groovy/classgen/RuntimeIncompleteClassException.java
@@ -0,0 +1,35 @@
+/*******************************************************************************
+ * Copyright (c) 2004 IBM Corporation and others.
+ * All rights reserved.   This program and the accompanying materials
+ * are made available under the terms of the Common Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/cpl-v10.html
+ * 
+ * Contributors:
+ * IBM - Initial API and implementation
+ ******************************************************************************/
+
+
+package org.codehaus.groovy.classgen;
+
+import java.util.List;
+
+import org.codehaus.groovy.ast.ASTNode;
+import org.codehaus.groovy.syntax.parser.RuntimeParserException;
+
+
+/**
+ * RuntimeIncompleteClassException
+ * 
+ */
+public class RuntimeIncompleteClassException extends RuntimeParserException {
+
+    /**
+     * @param a_message
+     * @param a_node
+     */
+    public RuntimeIncompleteClassException(List a_classnames, ASTNode a_node) {
+        super("Incomplete class: does not implement abstract methods: " + a_classnames, a_node);
+    }
+
+}
diff --git a/src/main/org/codehaus/groovy/control/CompilationUnit.java b/src/main/org/codehaus/groovy/control/CompilationUnit.java
index bdb83fda73..69f1102c9e 100644
--- a/src/main/org/codehaus/groovy/control/CompilationUnit.java
+++ b/src/main/org/codehaus/groovy/control/CompilationUnit.java
@@ -64,6 +64,7 @@ import org.codehaus.groovy.GroovyBugError;
 import org.codehaus.groovy.ast.ClassNode;
 import org.codehaus.groovy.ast.CompileUnit;
 import org.codehaus.groovy.ast.ModuleNode;
+import org.codehaus.groovy.classgen.ClassCompletionVerifier;
 import org.codehaus.groovy.classgen.ClassGenerator;
 import org.codehaus.groovy.classgen.GeneratorContext;
 import org.codehaus.groovy.classgen.Verifier;
@@ -103,6 +104,8 @@ public class CompilationUnit extends ProcessingUnit
     
     protected Verifier    verifier;   // For use by verify().
     
+    protected ClassCompletionVerifier completionVerifier; // for use by checkClassCompletion
+    
     protected boolean     debug;      // Controls behaviour of classgen() and other routines.
     protected boolean     configured; // Set true after the first configure() operation
     
@@ -157,6 +160,7 @@ public class CompilationUnit extends ProcessingUnit
         this.classes  = new ArrayList();
         
         this.verifier = new Verifier();
+        this.completionVerifier = new ClassCompletionVerifier();
         
         this.classgenCallback = null;
     }
@@ -614,7 +618,7 @@ public class CompilationUnit extends ProcessingUnit
             // Run the Verifier on the outer class
       
             verifier.visitClass( classNode );
-
+            
              
             //
             // Prep the generator machinery
@@ -637,6 +641,7 @@ public class CompilationUnit extends ProcessingUnit
             // Run the generation and create the class (if required)
 
             generator.visitClass( classNode );
+            completionVerifier.visitClass(classNode);
              
             if( !debug )
             {
@@ -645,6 +650,8 @@ public class CompilationUnit extends ProcessingUnit
             }
             
             
+            
+            
             //
             // Handle any callback that's been set
             
@@ -667,17 +674,19 @@ public class CompilationUnit extends ProcessingUnit
                     classgenCallback.call( visitor, classNode );
                 }
             }
-             
-
+            
+            
             //
             // Recurse for inner classes
-
+            
             LinkedList innerClasses = generator.getInnerClasses();
             while( !innerClasses.isEmpty() ) 
             {
                 classgen.call( source, context, (ClassNode)innerClasses.removeFirst() );
             }
-        } 
+                        
+        }
+
     };
     
     
diff --git a/src/test/groovy/Bar.groovy b/src/test/groovy/Bar.groovy
index 8dd23ad4ca..40659f2c3f 100644
--- a/src/test/groovy/Bar.groovy
+++ b/src/test/groovy/Bar.groovy
@@ -13,6 +13,8 @@ class Cheddar extends Goober implements Runnable
     String getStringCheese() { }
     String getOtherCheese(foo,bar) { }
 
+    void run() { cheeseIt() }
+
     static Goober mutateGoober(Goober theGoober) { }
    
 }
diff --git a/src/test/org/codehaus/groovy/syntax/parser/AbstractMethodCheckTest.java b/src/test/org/codehaus/groovy/syntax/parser/AbstractMethodCheckTest.java
new file mode 100644
index 0000000000..9ea8a7c996
--- /dev/null
+++ b/src/test/org/codehaus/groovy/syntax/parser/AbstractMethodCheckTest.java
@@ -0,0 +1,134 @@
+
+
+/*
+interface Comparable { int compareTo(Object o); }
+abstract class GString { abstract String[] getStrings(); }
+interface CharSequence {
+    char charAt(int);  int length();  CharSequence subsequence(int, int);  String toString()
+}
+
+abstract  class AbstractList: { abstract Object get(int index); abstract int size(); }
+
+*/
+
+package org.codehaus.groovy.syntax.parser;
+
+import groovy.lang.GroovyObject;
+import groovy.lang.MissingClassException;
+import groovy.lang.MissingPropertyException;
+
+import java.io.ByteArrayInputStream;
+
+import org.codehaus.groovy.classgen.RuntimeIncompleteClassException;
+import org.codehaus.groovy.classgen.TestSupport;
+import org.codehaus.groovy.control.CompilationFailedException;
+
+public class AbstractMethodCheckTest extends TestSupport {
+
+
+    /**
+     * GString literals generate an anonymous inner class which 
+     * adds an implementation of the abstract String[] getStrings()
+     * method. 
+     */
+    public void testAnonymousGStringAbstract() throws Exception {
+	GroovyObject object =
+	    assertCompileWorks(
+               "class GStringTest {\n" +
+               "    public groovy.lang.GString testGStringAbstract(Integer x, Integer y) {\n" + 
+               "       return \"GStringTest of ${x} and ${y}\"\n" +
+               "    }\n" +
+               "}\n");
+
+    }
+
+    public void testCompleteComparable() throws Exception {
+	GroovyObject object =
+	    assertCompileWorks(
+	     "class ComparableTest implements java.lang.Comparable {\n" +
+	     "    int compareTo(java.lang.Object o) {\n" +
+	     "	return 0;\n" +
+	     "    }\n" +
+	     "}\n");
+    }
+
+
+    public void testIncompleteCharSequence() throws Exception {
+	// Should generate an error for not implementing subsequence
+	MissingClassException e =
+	    assertCompileFailed(
+           "class IncompleteCharSequenceTest implements java.lang.CharSequence {\n" +
+	       "    char charAt(int pos) {\n" +
+	       "	return 'a';\n" +
+	       "    }\n" +
+	       "\n" +
+	       "    int length() {\n" +
+	       "	return 5;\n" +
+	       "    }\n" +
+	       "}\n");
+    }
+
+    public void testCompleteCharSequence() throws Exception {
+	GroovyObject object =
+	    assertCompileWorks(
+              "class CompleteCharSequenceTest implements java.lang.CharSequence {\n" +
+	      "    char charAt(int pos) {\n" +
+	      "	return 'a';\n" +
+	      "    }\n" +
+	      "\n" +
+	      "    int length() {\n" +
+	      "	return 5;\n" +
+	      "    }\n" +
+	      "\n" +
+	      "   java.lang.CharSequence subSequence(int start, int end) {\n" +
+	      "	return null;\n" +
+	      "    }\n" +
+	      "}\n");
+    }
+
+
+    public void testIncompleteList() throws Exception {
+	// Should generate an error for not implementing Object get(int)
+	MissingClassException e =
+	    assertCompileFailed(
+               "class IncompleteList extends java.util.AbstractList {\n" +
+	       "    int size() { return 0; }\n" +
+	       "}\n");
+    }
+
+
+    public void testCompleteList() throws Exception {
+	GroovyObject object =
+	    assertCompileWorks(
+               "class CompleteList extends java.util.AbstractList {\n" +
+	       "    int size() { return 0; }\n" +
+	       "    Object get(int pos) { return null; }\n" +
+	       "}\n");
+    }
+
+    
+    protected GroovyObject assertCompileWorks(String code) throws Exception {
+        Class type =
+            loader.parseClass(new ByteArrayInputStream(code.getBytes()), "ValidClass_" + getMethodName() + ".groovy");
+        return (GroovyObject) type.newInstance();
+    }
+
+    protected MissingClassException assertCompileFailed(String code) throws Exception {
+        try {
+            assertCompileWorks(code);
+
+            fail("Should have thrown an exception");
+        }
+        catch( CompilationFailedException e ) {
+            Exception cause = e.getUnit().getException(0);
+            if( cause instanceof  RuntimeIncompleteClassException ) {
+                System.out.println("Worked, threw: " + cause);
+                //e.printStackTrace();
+                return null;
+            }
+            throw e;
+        }
+        return null;
+    }
+
+}
