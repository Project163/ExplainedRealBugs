diff --git a/src/main/groovy/lang/IntRange.java b/src/main/groovy/lang/IntRange.java
index dda5334140..cde9c13b4e 100644
--- a/src/main/groovy/lang/IntRange.java
+++ b/src/main/groovy/lang/IntRange.java
@@ -17,6 +17,7 @@
 package groovy.lang;
 
 import org.codehaus.groovy.runtime.IteratorClosureAdapter;
+import org.codehaus.groovy.runtime.RangeInfo;
 
 import java.math.BigInteger;
 import java.util.AbstractList;
@@ -30,6 +31,11 @@ import java.util.List;
  * <p>
  * This class is a copy of {@link ObjectRange} optimized for <code>int</code>. If you make any
  * changes to this class, you might consider making parallel changes to {@link ObjectRange}.
+ * Instances of this class may be either inclusive aware or non-inclusive aware. See the
+ * relevant constructors for creating each type. Inclusive aware IntRange instances are
+ * suitable for use with Groovy's range indexing - in particular if the from or to values
+ * might be negative. This normally happens underneath the covers but is worth keeping
+ * in mind if creating these ranges yourself explicitly.
  *
  * @author <a href="mailto:james@coredevelopers.net">James Strachan</a>
  */
@@ -52,7 +58,7 @@ public class IntRange extends AbstractList<Integer> implements Range<Integer> {
         /**
          * The next value to return.
          */
-        private int value = reverse ? to : from;
+        private int value = isReverse() ? getTo() : getFrom();
 
         /**
          * {@inheritDoc}
@@ -69,14 +75,14 @@ public class IntRange extends AbstractList<Integer> implements Range<Integer> {
                 if (index > size) {
                     return null;
                 } else {
-                    if (reverse) {
+                    if (isReverse()) {
                         --value;
                     } else {
                         ++value;
                     }
                 }
             }
-            return Integer.valueOf(value);
+            return value;
         }
 
         /**
@@ -91,32 +97,39 @@ public class IntRange extends AbstractList<Integer> implements Range<Integer> {
     }
 
     /**
-     * The first number in the range.  <code>from </code> is always less than or equal to <code>to</code>.
+     * For non-inclusive aware ranges, the first number in the range; <code>from</code> is always less than or equal to <code>to</code>.
+     * For inclusive aware ranges, the <code>from</code> argument supplied to the constructor.
      */
     private int from;
 
     /**
-     * The last number in the range. <code>to</code> is always greater than or equal to <code>from</code>.
+     * For non-inclusive aware ranges, the last number in the range; <code>to</code> is always greater than or equal to <code>from</code>.
+     * For inclusive aware ranges, the <code>from</code> argument supplied to the constructor.
      */
     private int to;
 
     /**
      * If <code>false</code>, counts up from <code>from</code> to <code>to</code>.  Otherwise, counts down
-     * from <code>to</code> to <code>from</code>.
+     * from <code>to</code> to <code>from</code>. Not used for inclusive aware ranges.
      */
     private boolean reverse;
 
     /**
-     * Creates a new <code>IntRange</code>. If <code>from</code> is greater
-     * than <code>to</code>, a reverse range is created with
-     * <code>from</code> and <code>to</code> swapped.
+     * If <code>true</code>, <code>to</code> is included in the range.  Otherwise, the range stops
+     * before the <code>to</code> value. Null for non-inclusive aware ranges.
+     */
+    private Boolean inclusive;
+
+    /**
+     * Creates a new non-inclusive <code>IntRange</code>. If <code>from</code> is greater than
+     * <code>to</code>, a reverse range is created with <code>from</code> and <code>to</code> swapped.
      *
      * @param from the first number in the range.
      * @param to   the last number in the range.
-     * @throws IllegalArgumentException if the range would contain more than
-     *                                  {@link Integer#MAX_VALUE} values.
+     * @throws IllegalArgumentException if the range would contain more than {@link Integer#MAX_VALUE} values.
      */
     public IntRange(int from, int to) {
+        this.inclusive = null;
         if (from > to) {
             this.from = to;
             this.to = from;
@@ -126,14 +139,15 @@ public class IntRange extends AbstractList<Integer> implements Range<Integer> {
             this.to = to;
         }
 
-        // size() an integer so ranges can have no more than Integer.MAX_VALUE elements
-        if (this.to - this.from >= Integer.MAX_VALUE) {
-            throw new IllegalArgumentException("range must have no more than " + Integer.MAX_VALUE + " elements");
+        // size() in the Collection interface returns an integer, so ranges can have no more than Integer.MAX_VALUE elements
+        Long size = 0L + this.to - this.from;
+        if (size >= Integer.MAX_VALUE) {
+            throw new IllegalArgumentException("A range must have no more than " + Integer.MAX_VALUE + " elements but attempted " + size + " elements");
         }
     }
 
     /**
-     * Creates a new <code>IntRange</code>.
+     * Creates a new non-inclusive aware <code>IntRange</code>.
      *
      * @param from    the first value in the range.
      * @param to      the last value in the range.
@@ -142,6 +156,7 @@ public class IntRange extends AbstractList<Integer> implements Range<Integer> {
      * @throws IllegalArgumentException if <code>from</code> is greater than <code>to</code>.
      */
     protected IntRange(int from, int to, boolean reverse) {
+        this.inclusive = null;
         if (from > to) {
             throw new IllegalArgumentException("'from' must be less than or equal to 'to'");
         }
@@ -149,6 +164,48 @@ public class IntRange extends AbstractList<Integer> implements Range<Integer> {
         this.from = from;
         this.to = to;
         this.reverse = reverse;
+
+        // size() in the Collection interface returns an integer, so ranges can have no more than Integer.MAX_VALUE elements
+        Long size = 0L + this.to - this.from;
+        if (size >= Integer.MAX_VALUE) {
+            throw new IllegalArgumentException("A range must have no more than " + Integer.MAX_VALUE + " elements but attempted " + size + " elements");
+        }
+    }
+
+    /**
+     * Creates a new inclusive aware <code>IntRange</code>.
+     *
+     * @param from    the first value in the range.
+     * @param to      the last value in the range.
+     * @param inclusive <code>true</code> if the to value is included in the range.
+     */
+    public IntRange(boolean inclusive, int from, int to) {
+        this.from = from;
+        this.to = to;
+        this.inclusive = inclusive;
+    }
+
+    /**
+     * A method for determining from and to information when using this IntRange to index an aggregate object of the specified size.
+     * Normally only used internally within Groovy but useful if adding range indexing support for your own aggregates.
+     *
+     * @param size the size of the aggregate being indexed
+     * @return the calculated range information (with 1 added to the to value, ready for providing to subList
+     */
+    public RangeInfo subListBorders(int size) {
+        if (inclusive == null) throw new IllegalStateException("Should not call subListBorders on a non-inclusive aware IntRange");
+        int tempFrom = from;
+        if (tempFrom < 0) {
+            tempFrom += size;
+        }
+        int tempTo = to;
+        if (tempTo < 0) {
+            tempTo += size;
+        }
+        if (tempFrom > tempTo) {
+            return new RangeInfo(inclusive ? tempTo : tempTo + 1, tempFrom + 1, true);
+        }
+        return new RangeInfo(tempFrom, inclusive ? tempTo + 1 : tempTo, false);
     }
 
     /**
@@ -176,46 +233,57 @@ public class IntRange extends AbstractList<Integer> implements Range<Integer> {
      * @return <code>true</code> if the ranges are equal
      */
     public boolean equals(IntRange that) {
-        return that != null && this.reverse == that.reverse && this.from == that.from && this.to == that.to;
+        return that != null && ((this.inclusive == null && this.reverse == that.reverse && this.from == that.from && this.to == that.to)
+                || (this.inclusive != null && this.inclusive == that.inclusive && this.from == that.from && this.to == that.to));
     }
 
     /**
      * {@inheritDoc}
      */
     public Integer getFrom() {
-        return Integer.valueOf(from);
+        if (inclusive == null || from <= to) return from;
+        return inclusive ? to : to + 1;
     }
 
     /**
      * {@inheritDoc}
      */
     public Integer getTo() {
-        return Integer.valueOf(to);
+        if (inclusive == null) return to;
+        if (from < to) return inclusive ? to : to - 1;
+        return from;
     }
 
     /**
-     * Gets the 'from' value as an integer.
+     * Returns the inclusive flag. Null for non-inclusive aware ranges or non-null for inclusive aware ranges.
+     */
+    public Boolean getInclusive() {
+        return inclusive;
+    }
+
+    /**
+     * Gets the 'from' value as a primitive integer.
      *
-     * @return the 'from' value as an integer.
+     * @return the 'from' value as a primitive integer.
      */
     public int getFromInt() {
-        return from;
+        return getFrom();
     }
 
     /**
-     * Gets the 'to' value as an integer.
+     * Gets the 'to' value as a primitive integer.
      *
-     * @return the 'to' value as an integer.
+     * @return the 'to' value as a primitive integer.
      */
     public int getToInt() {
-        return to;
+        return getTo();
     }
 
     /**
      * {@inheritDoc}
      */
     public boolean isReverse() {
-        return reverse;
+        return inclusive == null ? reverse : (from > to);
     }
 
     public boolean containsWithinBounds(Object o) {
@@ -232,15 +300,14 @@ public class IntRange extends AbstractList<Integer> implements Range<Integer> {
         if (index >= size()) {
             throw new IndexOutOfBoundsException("Index: " + index + " too big for range: " + this);
         }
-        int value = reverse ? to - index : index + from;
-        return Integer.valueOf(value);
+        return isReverse() ? getTo() - index : index + getFrom();
     }
 
     /**
      * {@inheritDoc}
      */
     public int size() {
-        return to - from + 1;
+        return getTo() - getFrom() + 1;
     }
 
     /**
@@ -265,17 +332,18 @@ public class IntRange extends AbstractList<Integer> implements Range<Integer> {
         }
 
         if (fromIndex == toIndex) {
-            return new EmptyRange(Integer.valueOf(from));
+            return new EmptyRange(getFrom());
         }
 
-        return new IntRange(fromIndex + this.from, toIndex + this.from - 1, reverse);
+        return new IntRange(fromIndex + getFrom(), toIndex + getFrom() - 1, isReverse());
     }
 
     /**
      * {@inheritDoc}
      */
     public String toString() {
-        return reverse ? "" + to + ".." + from : "" + from + ".." + to;
+        return inclusive != null ? ("" + from + ".." + (inclusive ? "" : "<") + to)
+                : (reverse ? "" + to + ".." + from : "" + from + ".." + to);
     }
 
     /**
@@ -290,14 +358,12 @@ public class IntRange extends AbstractList<Integer> implements Range<Integer> {
      */
     public boolean contains(Object value) {
         if (value instanceof Integer) {
-            Integer integer = (Integer) value;
-            int i = integer.intValue();
-            return i >= from && i <= to;
+            return (Integer) value >= getFrom() && (Integer) value <= getTo();
         }
         if (value instanceof BigInteger) {
             BigInteger bigint = (BigInteger) value;
-            return bigint.compareTo(BigInteger.valueOf(from)) >= 0 &&
-                    bigint.compareTo(BigInteger.valueOf(to)) <= 0;
+            return bigint.compareTo(BigInteger.valueOf(getFrom())) >= 0 &&
+                    bigint.compareTo(BigInteger.valueOf(getTo())) <= 0;
         }
         return false;
     }
@@ -308,7 +374,7 @@ public class IntRange extends AbstractList<Integer> implements Range<Integer> {
     public boolean containsAll(Collection other) {
         if (other instanceof IntRange) {
             final IntRange range = (IntRange) other;
-            return this.from <= range.from && range.to <= this.to;
+            return this.getFrom() <= range.getFrom() && range.getTo() <= this.getTo();
         }
         return super.containsAll(other);
     }
@@ -318,19 +384,19 @@ public class IntRange extends AbstractList<Integer> implements Range<Integer> {
      */
     public void step(int step, Closure closure) {
         if (step == 0) {
-            if (from != to) {
+            if (!getFrom().equals(getTo())) {
                 throw new GroovyRuntimeException("Infinite loop detected due to step size of 0");
             } else {
                 return; // from == to and step == 0, nothing to do, so return
             }
         }
 
-        if (reverse) {
+        if (isReverse()) {
             step = -step;
         }
         if (step > 0) {
-            int value = from;
-            while (value <= to) {
+            int value = getFrom();
+            while (value <= getTo()) {
                 closure.call(Integer.valueOf(value));
                 if((0L + value + step) >= Integer.MAX_VALUE) {
                     break;
@@ -338,8 +404,8 @@ public class IntRange extends AbstractList<Integer> implements Range<Integer> {
                 value = value + step;
             }
         } else {
-            int value = to;
-            while (value >= from) {
+            int value = getTo();
+            while (value >= getFrom()) {
                 closure.call(Integer.valueOf(value));
                 if((0L + value + step) <= Integer.MIN_VALUE) {
                     break;
diff --git a/src/main/groovy/lang/ListWithDefault.java b/src/main/groovy/lang/ListWithDefault.java
index 0e2406657c..76467785cc 100644
--- a/src/main/groovy/lang/ListWithDefault.java
+++ b/src/main/groovy/lang/ListWithDefault.java
@@ -154,7 +154,7 @@ public final class ListWithDefault<T> implements List<T> {
         final int size = size();
         int normalisedIndex = normaliseIndex(index, size);
         if (normalisedIndex < 0) {
-            throw new ArrayIndexOutOfBoundsException("Negative array index [" + normalisedIndex + "] too large for array size " + size);
+            throw new IndexOutOfBoundsException("Negative index [" + normalisedIndex + "] too large for list size " + size);
         }
 
         // either index >= size or the normalised index is negative
diff --git a/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java b/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
index d02161ba07..562e721065 100644
--- a/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
+++ b/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
@@ -5220,7 +5220,7 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
     public static <T> List<T> getAt(List<T> self, Range range) {
         RangeInfo info = subListBorders(self.size(), range);
 
-        List<T> subList = self.subList(info.from, info.to);  // sublist is always exclusive, but Ranges are not
+        List<T> subList = self.subList(info.from, info.to);
         if (info.reverse) {
             subList = reverse(subList);
         }
@@ -5276,7 +5276,7 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
             self.get(info.to - 1);
         }
 
-        List<T> answer = self.subList(info.from, info.to);  // sublist is always exclusive, but Ranges are not
+        List<T> answer = self.subList(info.from, info.to);
         if (info.reverse) {
             answer =  ListWithDefault.newInstance(reverse(answer), self.isLazyDefaultValues(), self.getInitClosure());
         } else {
@@ -5773,8 +5773,8 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
             right = DefaultTypeTransformation.intUnbox(splice.get(1));
         } else if (splice instanceof IntRange) {
             IntRange range = (IntRange) splice;
-            left = range.getFromInt();
-            right = range.getToInt();
+            left = range.getFrom();
+            right = range.getTo();
         } else if (splice instanceof EmptyRange) {
             RangeInfo info = subListBorders(self.size(), (EmptyRange) splice);
             left = info.from;
@@ -9386,7 +9386,9 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      */
     @SuppressWarnings("unchecked")
     public static List<Byte> getAt(byte[] array, IntRange range) {
-        return primitiveArrayGet(array, range);
+        RangeInfo info = subListBorders(array.length, range);
+        List<Byte> answer = primitiveArrayGet(array, new IntRange(true, info.from, info.to - 1));
+        return info.reverse ? reverse(answer) : answer;
     }
 
     /**
@@ -9399,7 +9401,9 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      */
     @SuppressWarnings("unchecked")
     public static List<Character> getAt(char[] array, IntRange range) {
-        return primitiveArrayGet(array, range);
+        RangeInfo info = subListBorders(array.length, range);
+        List<Character> answer = primitiveArrayGet(array, new IntRange(true, info.from, info.to - 1));
+        return info.reverse ? reverse(answer) : answer;
     }
 
     /**
@@ -9412,7 +9416,9 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      */
     @SuppressWarnings("unchecked")
     public static List<Short> getAt(short[] array, IntRange range) {
-        return primitiveArrayGet(array, range);
+        RangeInfo info = subListBorders(array.length, range);
+        List<Short> answer = primitiveArrayGet(array, new IntRange(true, info.from, info.to - 1));
+        return info.reverse ? reverse(answer) : answer;
     }
 
     /**
@@ -9425,7 +9431,9 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      */
     @SuppressWarnings("unchecked")
     public static List<Integer> getAt(int[] array, IntRange range) {
-        return primitiveArrayGet(array, range);
+        RangeInfo info = subListBorders(array.length, range);
+        List<Integer> answer = primitiveArrayGet(array, new IntRange(true, info.from, info.to - 1));
+        return info.reverse ? reverse(answer) : answer;
     }
 
     /**
@@ -9438,7 +9446,9 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      */
     @SuppressWarnings("unchecked")
     public static List<Long> getAt(long[] array, IntRange range) {
-        return primitiveArrayGet(array, range);
+        RangeInfo info = subListBorders(array.length, range);
+        List<Long> answer = primitiveArrayGet(array, new IntRange(true, info.from, info.to - 1));
+        return info.reverse ? reverse(answer) : answer;
     }
 
     /**
@@ -9451,7 +9461,9 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      */
     @SuppressWarnings("unchecked")
     public static List<Float> getAt(float[] array, IntRange range) {
-        return primitiveArrayGet(array, range);
+        RangeInfo info = subListBorders(array.length, range);
+        List<Float> answer = primitiveArrayGet(array, new IntRange(true, info.from, info.to - 1));
+        return info.reverse ? reverse(answer) : answer;
     }
 
     /**
@@ -9464,7 +9476,9 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      */
     @SuppressWarnings("unchecked")
     public static List<Double> getAt(double[] array, IntRange range) {
-        return primitiveArrayGet(array, range);
+        RangeInfo info = subListBorders(array.length, range);
+        List<Double> answer = primitiveArrayGet(array, new IntRange(true, info.from, info.to - 1));
+        return info.reverse ? reverse(answer) : answer;
     }
 
     /**
@@ -9477,7 +9491,9 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      */
     @SuppressWarnings("unchecked")
     public static List<Boolean> getAt(boolean[] array, IntRange range) {
-        return primitiveArrayGet(array, range);
+        RangeInfo info = subListBorders(array.length, range);
+        List<Boolean> answer = primitiveArrayGet(array, new IntRange(true, info.from, info.to - 1));
+        return info.reverse ? reverse(answer) : answer;
     }
 
     /**
@@ -9698,7 +9714,8 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      * @since 1.5.0
      */
     public static boolean getAt(BitSet self, int index) {
-        return self.get(index);
+        int i = normaliseIndex(index, self.length());
+        return self.get(i);
     }
 
     /**
@@ -9712,18 +9729,16 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      * @since 1.5.0
      */
     public static BitSet getAt(BitSet self, IntRange range) {
-        int from = DefaultTypeTransformation.intUnbox(range.getFrom());
-        int to = DefaultTypeTransformation.intUnbox(range.getTo());
-
+        RangeInfo info = subListBorders(self.length(), range);
         BitSet result = new BitSet();
 
-        int numberOfBits = to - from + 1;
+        int numberOfBits = info.to - info.from;
         int adjuster = 1;
-        int offset = from;
+        int offset = info.from;
 
-        if (range.isReverse()) {
+        if (info.reverse) {
             adjuster = -1;
-            offset = to;
+            offset = info.to - 1;
         }
 
         for (int i = 0; i < numberOfBits; i++) {
@@ -9807,16 +9822,8 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      * @since 1.5.0
      */
     public static void putAt(BitSet self, IntRange range, boolean value) {
-        int from = DefaultTypeTransformation.intUnbox(range.getFrom());
-        int to = DefaultTypeTransformation.intUnbox(range.getTo());
-
-        // If this is a backwards range, reverse the arguments to set.
-        if (from > to) {
-            int tmp = to;
-            to = from;
-            from = tmp;
-        }
-        self.set(from, to + 1, value);
+        RangeInfo info = subListBorders(self.length(), range);
+        self.set(info.from, info.to, value);
     }
 
     /**
diff --git a/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethodsSupport.java b/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethodsSupport.java
index b149b303d8..a7f00f5e19 100644
--- a/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethodsSupport.java
+++ b/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethodsSupport.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2008 the original author or authors.
+ * Copyright 2003-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -16,6 +16,7 @@
 package org.codehaus.groovy.runtime;
 
 import groovy.lang.EmptyRange;
+import groovy.lang.IntRange;
 import groovy.lang.Range;
 import org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation;
 
@@ -34,6 +35,9 @@ public class DefaultGroovyMethodsSupport {
 
     // helper method for getAt and putAt
     protected static RangeInfo subListBorders(int size, Range range) {
+        if (range instanceof IntRange) {
+            return ((IntRange)range).subListBorders(size);
+        }
         int from = normaliseIndex(DefaultTypeTransformation.intUnbox(range.getFrom()), size);
         int to = normaliseIndex(DefaultTypeTransformation.intUnbox(range.getTo()), size);
         boolean reverse = range.isReverse();
@@ -101,18 +105,6 @@ public class DefaultGroovyMethodsSupport {
         }
     }
 
-    protected static class RangeInfo {
-        public final int from;
-        public final int to;
-        public final boolean reverse;
-
-        public RangeInfo(int from, int to, boolean reverse) {
-            this.from = from;
-            this.to = to;
-            this.reverse = reverse;
-        }
-    }
-
     @SuppressWarnings("unchecked")
     protected static <T> Collection<T> cloneSimilarCollection(Collection<T> orig, int newCapacity) {
         Collection<T> answer = (Collection<T>) cloneObject(orig);
diff --git a/src/main/org/codehaus/groovy/runtime/RangeInfo.java b/src/main/org/codehaus/groovy/runtime/RangeInfo.java
new file mode 100644
index 0000000000..e6286388d1
--- /dev/null
+++ b/src/main/org/codehaus/groovy/runtime/RangeInfo.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright 2003-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.codehaus.groovy.runtime;
+
+public class RangeInfo {
+    public final int from;
+    public final int to;
+    public final boolean reverse;
+
+    public RangeInfo(int from, int to, boolean reverse) {
+        this.from = from;
+        this.to = to;
+        this.reverse = reverse;
+    }
+}
diff --git a/src/main/org/codehaus/groovy/runtime/ScriptBytecodeAdapter.java b/src/main/org/codehaus/groovy/runtime/ScriptBytecodeAdapter.java
index ca73f77f1b..9cde72321a 100644
--- a/src/main/org/codehaus/groovy/runtime/ScriptBytecodeAdapter.java
+++ b/src/main/org/codehaus/groovy/runtime/ScriptBytecodeAdapter.java
@@ -619,22 +619,13 @@ public class ScriptBytecodeAdapter {
         return InvokerHelper.createMap(values);
     }
 
-    //TODO: refactor
     public static List createRange(Object from, Object to, boolean inclusive) throws Throwable {
         if (from instanceof Integer && to instanceof Integer) {
-            int ito = (Integer) to;
             int ifrom = (Integer) from;
-            if (!inclusive) {
-                if (ifrom == ito) {
-                    return new EmptyRange((Comparable) from);
-                }
-                if (ifrom > ito) {
-                    ito++;
-                } else {
-                    ito--;
-                }
-            }
-            return new IntRange(ifrom, ito);
+            int ito = (Integer) to;
+            if (inclusive || ifrom != ito) {
+                return new IntRange(inclusive, ifrom, ito);
+            } // else fall through for EmptyRange
         }
         if (!inclusive) {
             if (compareEqual(from, to)) {
diff --git a/src/main/org/codehaus/groovy/runtime/StringGroovyMethods.java b/src/main/org/codehaus/groovy/runtime/StringGroovyMethods.java
index b2d9007cbe..22b44327fe 100644
--- a/src/main/org/codehaus/groovy/runtime/StringGroovyMethods.java
+++ b/src/main/org/codehaus/groovy/runtime/StringGroovyMethods.java
@@ -1339,20 +1339,9 @@ public class StringGroovyMethods extends DefaultGroovyMethodsSupport {
      * @since 1.0
      */
     public static CharSequence getAt(CharSequence text, Range range) {
-        int from = normaliseIndex(DefaultTypeTransformation.intUnbox(range.getFrom()), text.length());
-        int to = normaliseIndex(DefaultTypeTransformation.intUnbox(range.getTo()), text.length());
-
-        boolean reverse = range.isReverse();
-        // If this is a backwards range, reverse the arguments to substring.
-        if (from > to) {
-            int tmp = from;
-            from = to;
-            to = tmp;
-            reverse = !reverse;
-        }
-
-        CharSequence sequence = text.subSequence(from, to + 1);
-        return reverse ? reverse((String) sequence) : sequence;
+        RangeInfo info = subListBorders(text.length(), range);
+        CharSequence sequence = text.subSequence(info.from, info.to);
+        return info.reverse ? reverse((String) sequence) : sequence;
     }
 
     /**
@@ -1530,20 +1519,9 @@ public class StringGroovyMethods extends DefaultGroovyMethodsSupport {
      * @since 1.0
      */
     public static String getAt(String text, Range range) {
-        int from = normaliseIndex(DefaultTypeTransformation.intUnbox(range.getFrom()), text.length());
-        int to = normaliseIndex(DefaultTypeTransformation.intUnbox(range.getTo()), text.length());
-
-        // If this is a backwards range, reverse the arguments to substring.
-        boolean reverse = range.isReverse();
-        if (from > to) {
-            int tmp = to;
-            to = from;
-            from = tmp;
-            reverse = !reverse;
-        }
-
-        String answer = text.substring(from, to + 1);
-        if (reverse) {
+        RangeInfo info = subListBorders(text.length(), range);
+        String answer = text.substring(info.from, info.to);
+        if (info.reverse) {
             answer = reverse(answer);
         }
         return answer;
diff --git a/src/main/org/codehaus/groovy/vmplugin/v5/PluginDefaultGroovyMethods.java b/src/main/org/codehaus/groovy/vmplugin/v5/PluginDefaultGroovyMethods.java
index e28e949d60..94f338e103 100644
--- a/src/main/org/codehaus/groovy/vmplugin/v5/PluginDefaultGroovyMethods.java
+++ b/src/main/org/codehaus/groovy/vmplugin/v5/PluginDefaultGroovyMethods.java
@@ -20,6 +20,7 @@ import groovy.lang.IntRange;
 import groovy.lang.EmptyRange;
 import org.codehaus.groovy.runtime.InvokerHelper;
 import org.codehaus.groovy.runtime.DefaultGroovyMethodsSupport;
+import org.codehaus.groovy.runtime.RangeInfo;
 
 import java.util.Arrays;
 import java.lang.reflect.Method;
diff --git a/src/test/groovy/ListTest.groovy b/src/test/groovy/ListTest.groovy
index 72b3cb81e8..1caf18e369 100644
--- a/src/test/groovy/ListTest.groovy
+++ b/src/test/groovy/ListTest.groovy
@@ -302,8 +302,8 @@ class ListTest extends GroovyTestCase {
         assert list[-1..-2] == [3, 2]     , 'negative index range reversed'
         assert list[-1..<-2] == [3]       , 'negative index range reversed exclusive'  // aaaahhhhh !
         assert list[0..-1] == list        , 'pos - neg value'
-        assert list[0..<-1] == [0]        , 'pos - neg value exclusive -> empty'
-        assert list[0..<-2] == list       , 'pos - neg value exclusive -> full'
+        assert list[0..<-1] == [0, 1, 2]  , 'pos - neg value exclusive'
+        assert list[0..<-2] == [0, 1]     , 'pos - neg value exclusive'
         shouldFail(GroovyRuntimeException) { list[null] }
         shouldFail(IndexOutOfBoundsException) { list[5..6] }
     }
@@ -538,7 +538,7 @@ class ListTest extends GroovyTestCase {
     void testLazyListAndFailingNegativeRangeAccess() {
         def l1 = [].withDefault { 42 }
 
-        shouldFail(ArrayIndexOutOfBoundsException) {
+        shouldFail(IndexOutOfBoundsException) {
             l1[-42..0]
         }
     }
@@ -546,7 +546,7 @@ class ListTest extends GroovyTestCase {
     void testEagerListAndFailingNegativeRangeAccess() {
         def l1 = [].withEagerDefault { 42 }
 
-        shouldFail(ArrayIndexOutOfBoundsException) {
+        shouldFail(IndexOutOfBoundsException) {
             l1[-42..0]
         }
     }
@@ -648,7 +648,7 @@ class ListTest extends GroovyTestCase {
 
     void testEagerListWithNegativeIndex() {
         def a = [].withEagerDefault { 42 }
-        shouldFail(ArrayIndexOutOfBoundsException) {
+        shouldFail(IndexOutOfBoundsException) {
             a[-2]
         }
     }
diff --git a/src/test/groovy/RangeTest.groovy b/src/test/groovy/RangeTest.groovy
index 620fc78c22..3338d00510 100644
--- a/src/test/groovy/RangeTest.groovy
+++ b/src/test/groovy/RangeTest.groovy
@@ -54,7 +54,6 @@ class RangeTest extends GroovyTestCase {
     void testIntStep() {
         assertStep(0..9, 3, [0, 3, 6, 9])
         assertStep(0..<10, 3, [0, 3, 6, 9])
-        
         assertStep(9..0, 3, [9, 6, 3, 0])
         assertStep(9..<0, 3, [9, 6, 3])
     }
@@ -62,7 +61,6 @@ class RangeTest extends GroovyTestCase {
     void testObjectStep() {
         assertStep('a'..'f', 2, ['a', 'c', 'e'])
         assertStep('a'..<'e', 2, ['a', 'c'])
-        
         assertStep('z'..'v', 2, ['z', 'x', 'v'])
         assertStep('z'..<'v', 2, ['z', 'x'])
     }
@@ -131,14 +129,14 @@ class RangeTest extends GroovyTestCase {
         assertToString(0..10, "0..10")
         assertToString([1, 4..10, 9], "[1, 4..10, 9]")
 
-        assertToString(0..<11, "0..10")
-        assertToString([1, 4..<11, 9], "[1, 4..10, 9]")
+        assertToString(0..<11, "0..<11")
+        assertToString([1, 4..<11, 9], "[1, 4..<11, 9]")
 
         assertToString(10..0, "10..0")
         assertToString([1, 10..4, 9], "[1, 10..4, 9]")
 
-        assertToString(11..<0, "11..1")
-        assertToString([1, 11..<4, 9], "[1, 11..5, 9]")
+        assertToString(11..<0, "11..<0")
+        assertToString([1, 11..<4, 9], "[1, 11..<4, 9]")
     }
     
     void testObjectRangeToString() {
diff --git a/src/test/groovy/lang/IntRangeTest.groovy b/src/test/groovy/lang/IntRangeTest.groovy
index 51d139ba94..d69372dd00 100644
--- a/src/test/groovy/lang/IntRangeTest.groovy
+++ b/src/test/groovy/lang/IntRangeTest.groovy
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2011 the original author or authors.
+ * Copyright 2003-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -20,14 +20,14 @@ package groovy.lang;
  *
  * @author James Strachan
  */
-public class IntRangeTest extends GroovyTestCase {
+class IntRangeTest extends GroovyTestCase {
 
-    public void testCreateTooBigRange() {
+    void testCreateTooBigRange() {
         try {
             new IntRange(0, Integer.MAX_VALUE);
             fail("too large range accepted");
         }
-        catch (IllegalArgumentException e) {
+        catch (IllegalArgumentException ignore) {
             assertTrue("expected exception thrown", true);
         }
     }
@@ -35,12 +35,12 @@ public class IntRangeTest extends GroovyTestCase {
     /**
      * Tests providing invalid arguments to the protected constructor.
      */
-    public void testInvalidArgumentsToConstructor() {
+    void testInvalidArgumentsToConstructor() {
         try {
             new IntRange(2, 1, true);
             fail("invalid range created");
         }
-        catch (IllegalArgumentException e) {
+        catch (IllegalArgumentException ignore) {
             assertTrue("expected exception thrown", true);
         }
     }
@@ -48,7 +48,7 @@ public class IntRangeTest extends GroovyTestCase {
     /**
      * Tests getting the to and from values as <code>int</code>s.
      */
-    public void testGetToFromInt() {
+    void testGetToFromInt() {
         final int from = 3, to = 7;
         final IntRange range = new IntRange(from, to);
         assertEquals("wrong 'from'", from, range.getFromInt());
@@ -76,4 +76,51 @@ public class IntRangeTest extends GroovyTestCase {
             assert it <= 0
         }
     }
+
+    void testInclusiveRangesWithNegativesAndPositives() {
+        final a = [1, 2, 3, 4]
+        assert a[-3..-2] == [2, 3]
+        assert a[-3..<-2] == [2]
+        assert a[2..-3] == [3, 2]
+        assert a[1..-1] == [2, 3, 4]
+        assert a[1..<-1] == [2, 3]
+        assert a[-2..<1] == [3]
+        assert a[-2..<-3] == [3]
+    }
+
+    void testInclusiveRangesWithNegativesAndPositivesStrings() {
+        def items = 'abcde'
+        assert items[1..-2]   == 'bcd'
+        assert items[1..<-2]  == 'bc'
+        assert items[-3..<-2] == 'c'
+        assert items[-2..-4]  == 'dcb'
+        assert items[-2..<-4] == 'dc'
+    }
+
+    void testInclusiveRangesWithNegativesAndPositivesPrimBoolArray() {
+        boolean[] bs = [true, false, true, true]
+        assert bs[-3..-2]  == [false, true]
+        assert bs[-3..<-2] == [false]
+        assert bs[2..-3]   == [true, false]
+        assert bs[1..-1]   == [false, true, true]
+        assert bs[1..<-1]  == [false, true]
+        assert bs[-2..<1]  == [true]
+        assert bs[-2..<-3] == [true]
+    }
+
+    void testInclusiveRangesWithNegativesAndPositivesBitset() {
+        byte[] ba = [0x7E,0x44,0x87]
+        def bs = BitSet.valueOf(ba)
+        bs[3..5] = false
+        assert bs.toString() == '{1, 2, 6, 10, 14, 16, 17, 18, 23}'
+        assert bs[bs.length()-1] == true
+        assert bs[-1] == true
+        assert bs[6..17].toString() == '{0, 4, 8, 10, 11}'
+        assert bs[6..<17].toString() == '{0, 4, 8, 10}'
+        assert bs[17..6].toString() == '{0, 1, 3, 7, 11}'
+        assert bs[17..<6].toString() == '{0, 1, 3, 7}'
+        assert bs[-1..-7].toString() == '{0, 5, 6}'
+        assert bs[-1..<-7].toString() == '{0, 5}'
+        assert bs[20..<-8].toString() == '{2, 3}'
+    }
 }
diff --git a/src/test/org/codehaus/groovy/runtime/InvokeMethodTest.java b/src/test/org/codehaus/groovy/runtime/InvokeMethodTest.java
index 0ca61978af..8149627b17 100644
--- a/src/test/org/codehaus/groovy/runtime/InvokeMethodTest.java
+++ b/src/test/org/codehaus/groovy/runtime/InvokeMethodTest.java
@@ -278,7 +278,7 @@ public class InvokeMethodTest extends GroovyTestCase {
 
     public void testListGetWithRange() throws Throwable {
         List list = Arrays.asList(new Object[]{"a", "b", "c"});
-        Object range = new IntRange(0, 2);
+        Object range = new IntRange(true, 0, 2);
         Object value = invoke(list, "getAt", range);
         assertTrue("Returned List: " + value, value instanceof List);
         List retList = (List) value;
