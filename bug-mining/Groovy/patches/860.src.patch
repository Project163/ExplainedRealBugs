diff --git a/src/main/groovy/io/GroovyPrintWriter.java b/src/main/groovy/io/GroovyPrintWriter.java
new file mode 100644
index 0000000000..6648fedadb
--- /dev/null
+++ b/src/main/groovy/io/GroovyPrintWriter.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright 2009 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package groovy.io;
+
+import java.io.File;
+import java.io.OutputStream;
+import java.io.PrintWriter;
+import java.io.Writer;
+import java.io.FileNotFoundException;
+import java.io.UnsupportedEncodingException;
+
+import org.codehaus.groovy.runtime.InvokerHelper;
+
+/**
+ * A PrintWriter that outputs objects in Groovy style.
+ * That means print(Object) uses InvokerHelper.toString(Object)
+ * to produce the same results as Writer.print(Object).
+ *
+ * @author Jim White
+ */
+public class GroovyPrintWriter extends PrintWriter 
+{
+    public GroovyPrintWriter(File file) throws FileNotFoundException
+    {
+        super(file);
+    }
+
+    public GroovyPrintWriter(File file, String csn)
+        throws FileNotFoundException, UnsupportedEncodingException
+    {
+        super(file, csn);
+    }
+
+    public GroovyPrintWriter(Writer out) 
+    {
+        super(out);
+    }
+
+    public GroovyPrintWriter(Writer out, boolean autoflush) 
+    {
+        super(out, autoflush);
+    }
+
+    public GroovyPrintWriter(OutputStream out) 
+    {
+        super(out);
+    }
+
+    public GroovyPrintWriter(OutputStream out, boolean autoflush) 
+    {
+        super(out, autoflush);
+    }
+
+    public GroovyPrintWriter(String filename) throws FileNotFoundException 
+    {
+        super(filename);
+    }
+
+    public GroovyPrintWriter(String filename, String csn)
+        throws FileNotFoundException, UnsupportedEncodingException 
+    {
+        super(filename, csn);
+    }
+        
+// Don't need to do this if Groovy is going to print char[] like a string.
+//    public void print(char[] x) 
+//    {
+//        super.write(InvokerHelper.toString(x));
+//    }
+
+    public void print(Object x) 
+    {
+        super.write(InvokerHelper.toString(x));
+    }
+}
diff --git a/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java b/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
index 7da69c3d8f..840c467f4a 100644
--- a/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
+++ b/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
@@ -17,6 +17,7 @@ package org.codehaus.groovy.runtime;
 
 import groovy.io.EncodingAwareBufferedWriter;
 import groovy.io.PlatformLineWriter;
+import groovy.io.GroovyPrintWriter;
 import groovy.lang.*;
 import groovy.sql.GroovyRowResult;
 import groovy.util.*;
@@ -451,8 +452,8 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
     public static void print(Object self, Object value) {
         // we won't get here if we are a PrintWriter
         if (self instanceof Writer) {
-            final PrintWriter pw = new PrintWriter((Writer) self);
-            pw.print(InvokerHelper.toString(value));
+            final PrintWriter pw = new GroovyPrintWriter((Writer) self);
+            pw.print(value);
         } else {
             System.out.print(InvokerHelper.toString(value));
         }
@@ -480,7 +481,7 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
     public static void println(Object self) {
         // we won't get here if we are a PrintWriter
         if (self instanceof Writer) {
-            PrintWriter pw = new PrintWriter((Writer) self);
+            PrintWriter pw = new GroovyPrintWriter((Writer) self);
             pw.println();
         } else {
             System.out.println();
@@ -517,8 +518,8 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
     public static void println(Object self, Object value) {
         // we won't get here if we are a PrintWriter
         if (self instanceof Writer) {
-            final PrintWriter pw = new PrintWriter((Writer) self);
-            pw.println(InvokerHelper.toString(value));
+            final PrintWriter pw = new GroovyPrintWriter((Writer) self);
+            pw.println(value);
         } else {
             System.out.println(InvokerHelper.toString(value));
         }
@@ -712,7 +713,7 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      */
     public static void print(Object self, PrintWriter out) {
         if (out == null) {
-            out = new PrintWriter(System.out);
+            out = new GroovyPrintWriter(System.out);
         }
         out.print(InvokerHelper.toString(self));
     }
@@ -726,7 +727,7 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      */
     public static void println(Object self, PrintWriter out) {
         if (out == null) {
-            out = new PrintWriter(System.out);
+            out = new GroovyPrintWriter(System.out);
         }
         InvokerHelper.invokeMethod(self, "print", out);
         out.println();
@@ -3999,6 +4000,7 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
             stack.addAll(col);
             return stack;
         }
+        
         Object[] args = {col};
         try {
             return InvokerHelper.invokeConstructorOf(clazz, args);
@@ -4022,11 +4024,14 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
     public static Object asType(Object[] ary, Class clazz) {
         if (clazz == List.class) {
             return new ArrayList(Arrays.asList(ary));
-        } else if (clazz == Set.class) {
+        }
+        if (clazz == Set.class) {
             return new HashSet(Arrays.asList(ary));
-        } else if (clazz == SortedSet.class) {
+        }
+        if (clazz == SortedSet.class) {
             return new TreeSet(Arrays.asList(ary));
         }
+
         return asType((Object) ary, clazz);
     }
 
@@ -4048,7 +4053,7 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
                     new ConvertedClosure(cl));
         }
         try {
-        return asType((Object) cl, clazz);
+            return asType((Object) cl, clazz);
         } catch (GroovyCastException ce) {
             try {
                 return ProxyGenerator.INSTANCE.instantiateAggregateFromBaseClass(cl, clazz);
@@ -9940,7 +9945,7 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      * @since 1.0
      */
     public static PrintWriter newPrintWriter(File file) throws IOException {
-        return new PrintWriter(newWriter(file));
+        return new GroovyPrintWriter(newWriter(file));
     }
 
     /**
@@ -9954,7 +9959,19 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      * @since 1.0
      */
     public static PrintWriter newPrintWriter(File file, String charset) throws IOException {
-        return new PrintWriter(newWriter(file, charset));
+        return new GroovyPrintWriter(newWriter(file, charset));
+    }
+
+    /**
+     * Create a new PrintWriter for this file, using specified
+     * charset.
+     *
+     * @param writer   a writer
+     * @return a PrintWriter
+     * @since 1.6
+     */
+    public static PrintWriter newPrintWriter(Writer writer) {
+        return new GroovyPrintWriter(writer);
     }
 
     /**
@@ -9988,6 +10005,21 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
         return withWriter(newPrintWriter(file, charset), closure);
     }
 
+    /**
+     * Create a new PrintWriter with a specified charset for
+     * this file.  The writer is passed to the closure, and will be closed
+     * before this method returns.
+     *
+     * @param writer   a writer
+     * @param closure the closure to invoke with the PrintWriter
+     * @return the value returned by the closure
+     * @throws IOException if an IOException occurs.
+     * @since 1.6
+     */
+    public static Object withPrintWriter(Writer writer, Closure closure) throws IOException {
+        return withWriter(newPrintWriter(writer), closure);
+    }
+
     /**
      * Allows this writer to be used within the closure, ensuring that it
      * is flushed and closed before this method returns.
@@ -11365,6 +11397,10 @@ public class DefaultGroovyMethods extends DefaultGroovyMethodsSupport {
      * @since 1.0
      */
     public static Object asType(Object obj, Class type) {
+        if (String.class == type) {
+            return InvokerHelper.toString(obj);
+        }
+        
         try {
           return DefaultTypeTransformation.castToType(obj, type);
         }
diff --git a/src/main/org/codehaus/groovy/runtime/InvokerHelper.java b/src/main/org/codehaus/groovy/runtime/InvokerHelper.java
index b8ddd5a66b..150e76f979 100644
--- a/src/main/org/codehaus/groovy/runtime/InvokerHelper.java
+++ b/src/main/org/codehaus/groovy/runtime/InvokerHelper.java
@@ -492,6 +492,9 @@ public class InvokerHelper {
             return (String) nullObject.getMetaClass().invokeMethod(nullObject, "toString", EMPTY_ARGS);
         }
         if (arguments.getClass().isArray()) {
+            if (arguments instanceof char[]) {
+                return new String((char[]) arguments);
+            }
             return format(DefaultTypeTransformation.asCollection(arguments), verbose);
         }
         if (arguments instanceof Range) {
diff --git a/src/test/groovy/PrintTest.groovy b/src/test/groovy/PrintTest.groovy
index 080ec053c5..715e384fa1 100644
--- a/src/test/groovy/PrintTest.groovy
+++ b/src/test/groovy/PrintTest.groovy
@@ -64,4 +64,88 @@ class PrintTest extends GroovyTestCase {
             sprintf('%2.4f', [3])
         }
     }
+
+def NEWLINE = System.getProperty("line.separator")
+
+void doTest(def param) {
+    StringWriter sw1 = new StringWriter()
+    StringWriter sw2 = new StringWriter()
+    StringWriter sw3 = new StringWriter()
+    StringWriter sw4 = new StringWriter()
+
+    sw1.write(param as String)
+    sw2.print(param)
+    sw3.withPrintWriter { it.print param }
+    new PrintWriter(sw4).print(param as String)
+
+    def t1 = sw1.toString()
+    def t2 = sw2.toString()
+    def t3 = sw3.toString()
+    def t4 = sw4.toString()
+    
+    println param.getClass()
+    println t1
+    println t2
+    println t3
+    println t4
+    println (param.toString())
+    println String.valueOf(param)
+    println org.codehaus.groovy.runtime.InvokerHelper.toString(param)
+    println (param as String)
+    println param
+    
+    assert t1 == t2
+    assert t1 == t3
+    assert t1 == t4
+
+    sw1 = new StringWriter()
+    sw2 = new StringWriter()
+    sw3 = new StringWriter()
+    sw4 = new StringWriter()
+
+//    sw1.write(String.valueOf(param))
+//    sw1.write((param.is(null)) ? 'null' : param.toString())
+    sw1.write(param as String)
+    sw1.write(NEWLINE)
+    sw2.println(param)
+    sw3.withPrintWriter { it.println param }
+    new PrintWriter(sw4).println(param as String)
+
+    t1 = sw1.toString()
+    t2 = sw2.toString()
+    t3 = sw3.toString()
+    t4 = sw4.toString()
+    
+    assert t1 == t2
+    assert t1 == t3
+    assert t1 == t4
+}
+
+void testGroovy3227() { 
+//    doTest(null)
+    doTest("foo")
+    doTest(true)
+    doTest(false)
+    doTest((byte)123)
+    doTest((short)1234)
+    doTest(new Integer(1234))
+    doTest(new Long(9999999999))
+    doTest(new Float(1234.5678))
+    doTest(new Double(1234.5678))
+    doTest(new BigInteger("123456789012345678901234567890"))
+    doTest(new BigDecimal("12345678901234567890.1234567890123456789"))
+    doTest(new Date())
+    doTest(new StringBuffer("bar"))
+    doTest([null, "foo", true, false, new Integer(1234)])
+    doTest(["foo" : "bar", "true": true, "int": new Integer(1234)])
+    doTest([null, "foo", true, false, new Integer(1234)] as Object[])
+    doTest(["foo",new Integer(1234)] as String[])
+    doTest([true, false] as Boolean[])
+    doTest([true, false] as boolean[])
+    doTest([1, 2, 3] as int[])
+    doTest([1, 2, 3] as Integer[])
+    doTest(['a', 'b', 'c'] as char[])
+    doTest(['a', 'b', 'c'] as Character[])
+}
+
 }
