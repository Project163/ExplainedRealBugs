diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index c5bc7df760..d8e46eea86 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -197,7 +197,6 @@ import static org.codehaus.groovy.ast.ClassHelper.isPrimitiveType;
 import static org.codehaus.groovy.ast.ClassHelper.isPrimitiveVoid;
 import static org.codehaus.groovy.ast.ClassHelper.isSAMType;
 import static org.codehaus.groovy.ast.ClassHelper.isStringType;
-import static org.codehaus.groovy.ast.ClassHelper.isWrapperBoolean;
 import static org.codehaus.groovy.ast.ClassHelper.isWrapperByte;
 import static org.codehaus.groovy.ast.ClassHelper.isWrapperCharacter;
 import static org.codehaus.groovy.ast.ClassHelper.isWrapperDouble;
@@ -205,7 +204,6 @@ import static org.codehaus.groovy.ast.ClassHelper.isWrapperFloat;
 import static org.codehaus.groovy.ast.ClassHelper.isWrapperInteger;
 import static org.codehaus.groovy.ast.ClassHelper.isWrapperLong;
 import static org.codehaus.groovy.ast.ClassHelper.isWrapperShort;
-import static org.codehaus.groovy.ast.ClassHelper.isWrapperVoid;
 import static org.codehaus.groovy.ast.ClassHelper.long_TYPE;
 import static org.codehaus.groovy.ast.ClassHelper.short_TYPE;
 import static org.codehaus.groovy.ast.tools.ClosureUtils.getParametersSafe;
@@ -1273,19 +1271,12 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
     }
 
     private void checkTypeGenerics(final ClassNode leftExpressionType, final ClassNode wrappedRHS, final Expression rightExpression) {
-        // last, check generic type information to ensure that inferred types are compatible
-        if (!leftExpressionType.isUsingGenerics()) return;
-        // example of incomplete type info: "List<Type> list = new LinkedList()"
-        // we assume arity related errors are already handled here
-        if (missesGenericsTypes(wrappedRHS)) return;
-
-        GenericsType gt = GenericsUtils.buildWildcardType(leftExpressionType);
-        if (UNKNOWN_PARAMETER_TYPE.equals(wrappedRHS) ||
-                gt.isCompatibleWith(wrappedRHS) ||
-                isNullConstant(rightExpression)) return;
-
-        addStaticTypeError("Incompatible generic argument types. Cannot assign "
-                + prettyPrintType(wrappedRHS) + " to: " + prettyPrintType(leftExpressionType), rightExpression);
+        if (leftExpressionType.isUsingGenerics()
+                && !isNullConstant(rightExpression)
+                && !(rightExpression instanceof ClosureExpression) // GROOVY-10277
+                && !UNKNOWN_PARAMETER_TYPE.equals(wrappedRHS) && !missesGenericsTypes(wrappedRHS)
+                && !GenericsUtils.buildWildcardType(leftExpressionType).isCompatibleWith(wrappedRHS))
+            addStaticTypeError("Incompatible generic argument types. Cannot assign " + prettyPrintType(wrappedRHS) + " to: " + prettyPrintType(leftExpressionType), rightExpression);
     }
 
     private boolean hasGStringStringError(final ClassNode leftExpressionType, final ClassNode wrappedRHS, final Expression rightExpression) {
@@ -2203,20 +2194,29 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
     protected ClassNode checkReturnType(final ReturnStatement statement) {
         Expression expression = statement.getExpression();
         ClassNode type = getType(expression);
-        if (typeCheckingContext.getEnclosingClosure() != null) {
-            ClassNode inferredReturnType = getInferredReturnType(typeCheckingContext.getEnclosingClosure().getClosureExpression());
+
+        TypeCheckingContext.EnclosingClosure enclosingClosure = typeCheckingContext.getEnclosingClosure();
+        if (enclosingClosure != null) {
+            if (enclosingClosure.getClosureExpression().getNodeMetaData(INFERRED_TYPE) != null) return null; // re-visit
+
+            ClassNode inferredReturnType = getInferredReturnType(enclosingClosure.getClosureExpression());
             // GROOVY-9995: return ctor call with diamond operator
             if (expression instanceof ConstructorCallExpression) {
                 inferDiamondType((ConstructorCallExpression) expression, inferredReturnType != null ? inferredReturnType : /*GROOVY-10080:*/dynamicType());
             }
-            if (isStringType(inferredReturnType) && isGStringOrGStringStringLUB(type)) {
-                type = STRING_TYPE; // GROOVY-9971: convert GString to String at point of return
-            } else if (inferredReturnType != null
-                    && !type.equals(inferredReturnType)
+            if (inferredReturnType != null
+                    && !inferredReturnType.equals(type)
+                    && !isObjectType(inferredReturnType)
                     && !isPrimitiveVoid(inferredReturnType)
-                    && !GenericsUtils.hasUnresolvedGenerics(inferredReturnType)
-                    &&  GenericsUtils.buildWildcardType(inferredReturnType).isCompatibleWith(wrapTypeIfNecessary(type))) {
-                type = inferredReturnType; // GROOVY-8310, GROOVY-10082, GROOVY-10091, GROOVY-10128, GROOVY-10306: allow simple covariance
+                    && !isPrimitiveBoolean(inferredReturnType)
+                    && !GenericsUtils.hasUnresolvedGenerics(inferredReturnType)) {
+                if (isStringType(inferredReturnType) && isGStringOrGStringStringLUB(type)) {
+                    type = STRING_TYPE; // GROOVY-9971: convert GString to String at point of return
+                } else if (GenericsUtils.buildWildcardType(wrapTypeIfNecessary(inferredReturnType)).isCompatibleWith(wrapTypeIfNecessary(type))) {
+                    type = inferredReturnType; // GROOVY-8310, GROOVY-10082, GROOVY-10091, GROOVY-10128, GROOVY-10306: allow simple covariance
+                } else if (!isPrimitiveVoid(type) && !extension.handleIncompatibleReturnType(statement, type)) { // GROOVY-10277: incompatible return value
+                    addStaticTypeError("Cannot return value of type " + prettyPrintType(type) + " for " + (enclosingClosure.getClosureExpression() instanceof LambdaExpression ? "lambda" : "closure") + " expecting " + prettyPrintType(inferredReturnType), expression);
+                }
             }
             return type;
         }
@@ -2226,7 +2226,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             ClassNode returnType = enclosingMethod.getReturnType();
             if (!isPrimitiveVoid(getUnwrapper(type)) && !checkCompatibleAssignmentTypes(returnType, type, null, false)) {
                 if (!extension.handleIncompatibleReturnType(statement, type)) {
-                    addStaticTypeError("Cannot return value of type " + prettyPrintType(type) + " on method returning type " + prettyPrintType(returnType), expression);
+                    addStaticTypeError("Cannot return value of type " + prettyPrintType(type) + " for method returning " + prettyPrintType(returnType), expression);
                 }
             } else if (implementsInterfaceOrIsSubclassOf(type, returnType)) {
                 BinaryExpression dummy = assignX(varX("{target}", returnType), expression, statement);
@@ -3480,37 +3480,29 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                     mn = disambiguateMethods(mn, chosenReceiver != null ? chosenReceiver.getType() : null, args, call);
 
                     if (mn.size() == 1) {
-                        MethodNode directMethodCallCandidate = mn.get(0);
-                        ClassNode declaringClass = directMethodCallCandidate.getDeclaringClass();
-                        if (!directMethodCallCandidate.isStatic() && !isClassType(declaringClass)
+                        MethodNode targetMethodCandidate = mn.get(0);
+                        ClassNode declaringClass = targetMethodCandidate.getDeclaringClass();
+                        if (!targetMethodCandidate.isStatic() && !isClassType(declaringClass)
                                 && objectExpression instanceof ClassExpression && call.getNodeMetaData(DYNAMIC_RESOLUTION) == null) {
-                            addStaticTypeError("Non-static method " + prettyPrintTypeName(declaringClass) + "#" + directMethodCallCandidate.getName() + " cannot be called from static context", call);
+                            addStaticTypeError("Non-static method " + prettyPrintTypeName(declaringClass) + "#" + targetMethodCandidate.getName() + " cannot be called from static context", call);
                         }
                         if (chosenReceiver == null) {
                             chosenReceiver = Receiver.make(declaringClass);
                         }
                         // note second pass here to differentiate from extension that sets type
                         boolean mergeType = (call.getNodeMetaData(INFERRED_TYPE) != null);
-                        storeTargetMethod(call, directMethodCallCandidate);
+                        storeTargetMethod(call, targetMethodCandidate);
 
-                        visitMethodCallArguments(chosenReceiver.getType(), argumentList, true, directMethodCallCandidate);
-                        for (Expression argument : argumentList.getExpressions()) {
-                            if (argument instanceof ClosureExpression) {
-                                // GROOVY-10052: return type known now
-                                args = getArgumentTypes(argumentList);
-                                break;
-                            }
-                        }
-                        callArgsVisited = true;
+                        visitMethodCallArguments(chosenReceiver.getType(), argumentList, true, targetMethodCandidate); callArgsVisited = true;
 
-                        ClassNode returnType = getType(directMethodCallCandidate);
+                        ClassNode returnType = getType(targetMethodCandidate);
                         if (isUsingGenericsOrIsArrayUsingGenerics(returnType)) {
-                            ClassNode irtg = inferReturnTypeGenerics(chosenReceiver.getType(), directMethodCallCandidate, callArguments, call.getGenericsTypes());
+                            ClassNode irtg = inferReturnTypeGenerics(chosenReceiver.getType(), targetMethodCandidate, callArguments, call.getGenericsTypes());
                             if (irtg != null && implementsInterfaceOrIsSubclassOf(irtg, returnType))
                                 returnType = irtg;
                         }
                         // GROOVY-6091: use of "delegate" or "getDelegate()" does not make use of @DelegatesTo metadata
-                        if (directMethodCallCandidate == GET_DELEGATE && typeCheckingContext.getEnclosingClosure() != null) {
+                        if (targetMethodCandidate == GET_DELEGATE && typeCheckingContext.getEnclosingClosure() != null) {
                             DelegationMetadata md = getDelegationMetadata(typeCheckingContext.getEnclosingClosure().getClosureExpression());
                             if (md != null) {
                                 returnType = md.getType();
@@ -3519,14 +3511,14 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                             }
                         }
                         // GROOVY-7106, GROOVY-7274, GROOVY-8909, GROOVY-8961, GROOVY-9734, GROOVY-9844, GROOVY-9915, et al.
-                        Parameter[] parameters = directMethodCallCandidate.getParameters();
-                        if (chosenReceiver.getType().getGenericsTypes() != null && !directMethodCallCandidate.isStatic() && !(directMethodCallCandidate instanceof ExtensionMethodNode)) {
-                            Map<GenericsTypeName, GenericsType> context = extractPlaceHoldersVisibleToDeclaration(chosenReceiver.getType(), directMethodCallCandidate, argumentList);
+                        Parameter[] parameters = targetMethodCandidate.getParameters();
+                        if (chosenReceiver.getType().getGenericsTypes() != null && !targetMethodCandidate.isStatic() && !(targetMethodCandidate instanceof ExtensionMethodNode)) {
+                            Map<GenericsTypeName, GenericsType> context = extractPlaceHoldersVisibleToDeclaration(chosenReceiver.getType(), targetMethodCandidate, argumentList);
                             parameters = Arrays.stream(parameters).map(p -> new Parameter(applyGenericsContext(context, p.getType()), p.getName())).toArray(Parameter[]::new);
                         }
                         resolvePlaceholdersFromImplicitTypeHints(args, argumentList, parameters);
 
-                        if (typeCheckMethodsWithGenericsOrFail(chosenReceiver.getType(), args, directMethodCallCandidate, call)) {
+                        if (typeCheckMethodsWithGenericsOrFail(chosenReceiver.getType(), args, targetMethodCandidate, call)) {
                             String data = chosenReceiver.getData();
                             if (data != null) {
                                 // the method which has been chosen is supposed to be a call on delegate or owner
@@ -3535,7 +3527,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                             }
                             receiver = chosenReceiver.getType();
                             if (mergeType || call.getNodeMetaData(INFERRED_TYPE) == null)
-                                storeType(call, adjustWithTraits(directMethodCallCandidate, receiver, args, returnType));
+                                storeType(call, adjustWithTraits(targetMethodCandidate, receiver, args, returnType));
 
                             if (objectExpression instanceof VariableExpression && ((VariableExpression) objectExpression).isClosureSharedVariable()) {
                                 // if the object expression is a closure shared variable, we will have to perform a second pass
@@ -4090,17 +4082,11 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         } else if (isClosureWithType(type) && source instanceof ClosureExpression) {
             storeInferredReturnType(source, getCombinedBoundType(type.getGenericsTypes()[0]));
         }
-        ClassNode expect = wrapTypeIfNecessary(getInferredReturnType(source)); // GROOVY-10277
 
         source.visit(this);
 
-        if (!expression.isCoerce()) {
-            if (!checkCast(type, source))
-                addStaticTypeError("Inconvertible types: cannot cast " + prettyPrintType(getType(source)) + " to " + prettyPrintType(type), expression);
-        } else if (expect != null && !isObjectType(expect) && !isWrapperVoid(expect) && !isWrapperBoolean(expect)) {
-            ClassNode actual = getInferredReturnType(source); // check return type(s) against the target return type
-            if (actual != null && !GenericsUtils.buildWildcardType(expect).isCompatibleWith(wrapTypeIfNecessary(actual)))
-                addStaticTypeError("Cannot coerce lambda or closure returning " + prettyPrintType(actual) + " to " + prettyPrintType(type), expression);
+        if (!expression.isCoerce() && !checkCast(type, source)) {
+            addStaticTypeError("Inconvertible types: cannot cast " + prettyPrintType(getType(source)) + " to " + prettyPrintType(type), expression);
         }
     }
 
diff --git a/src/spec/test/typing/TypeCheckingTest.groovy b/src/spec/test/typing/TypeCheckingTest.groovy
index adab4e05d0..b6bfbd5cdd 100644
--- a/src/spec/test/typing/TypeCheckingTest.groovy
+++ b/src/spec/test/typing/TypeCheckingTest.groovy
@@ -848,9 +848,7 @@ import static org.codehaus.groovy.ast.tools.WideningCategories.lowestUpperBound
             }
         }
         // end::cl_pt_failure[]
-        ''',
-        'No such property: age for class: java.lang.Object',
-        '#inviteIf(Person, groovy.lang.Closure<java.lang.Boolean>) with arguments [Person, groovy.lang.Closure<java.lang.Object>]'
+        ''', 'No such property: age for class: java.lang.Object'
 
         assertScript '''
         class Person {
diff --git a/src/test/groovy/transform/stc/ClosuresSTCTest.groovy b/src/test/groovy/transform/stc/ClosuresSTCTest.groovy
index b78c3bb834..e3c5366315 100644
--- a/src/test/groovy/transform/stc/ClosuresSTCTest.groovy
+++ b/src/test/groovy/transform/stc/ClosuresSTCTest.groovy
@@ -62,7 +62,6 @@ class ClosuresSTCTest extends StaticTypeCheckingTestCase {
             assert c('bar') == 'bar'
             assert c() == 'foo'
         '''
-
         assertScript '''
             def c = { p, q = 'baz' -> '' + p + q }
             assert c('foo', 'bar') == 'foobar'
@@ -121,9 +120,9 @@ class ClosuresSTCTest extends StaticTypeCheckingTestCase {
         shouldFailWithMessages '''
             def c = { int x ->
                 if (x == 0) {
-                    1L // long
+                    1L
                 } else {
-                    x // int
+                    x
                 }
             }
             byte res = c(0)
@@ -160,7 +159,7 @@ class ClosuresSTCTest extends StaticTypeCheckingTestCase {
         '''
     }
 
-    // GROOVY-10082
+    // GROOVY-10082, GROOVY-10277
     void testClosureReturnTypeInference6() {
         assertScript '''
             class A {}
@@ -174,10 +173,10 @@ class ClosuresSTCTest extends StaticTypeCheckingTestCase {
         shouldFailWithMessages '''
             Closure<String> c = { -> 42 }
         ''',
-        'Cannot assign groovy.lang.Closure<java.lang.Integer> to: groovy.lang.Closure<java.lang.String>'
+        'Cannot return value of type int for closure expecting java.lang.String'
     }
 
-    // GROOVY-10091
+    // GROOVY-10091, GROOVY-10277
     void testClosureReturnTypeInference7() {
         shouldFailWithMessages '''
             class A<T> {}
@@ -190,7 +189,7 @@ class ClosuresSTCTest extends StaticTypeCheckingTestCase {
             c = { -> return new X() }
             c = { -> return new Y<String>() }
         ''',
-        'Cannot assign groovy.lang.Closure<X> to: groovy.lang.Closure<A<java.lang.Number>>'
+        'Cannot return value of type X for closure expecting A<java.lang.Number>'
     }
 
     // GROOVY-10128, GROOVY-10306
@@ -370,7 +369,8 @@ class ClosuresSTCTest extends StaticTypeCheckingTestCase {
               def c = x
               c.m()
             }
-        ''', 'Cannot find matching method A#m()'
+        ''',
+        'Cannot find matching method A#m()'
     }
 
     // GROOVY-10052
@@ -458,7 +458,8 @@ class ClosuresSTCTest extends StaticTypeCheckingTestCase {
         shouldFailWithMessages '''
             Closure fib
             fib = { int n -> n<2?n:fib(n-1)+fib(n-2) }
-        ''', 'Cannot find matching method java.lang.Object#plus(java.lang.Object)'
+        ''',
+        'Cannot find matching method java.lang.Object#plus(java.lang.Object)'
     }
 
     void testClosureRecursionWithDef() {
@@ -466,9 +467,9 @@ class ClosuresSTCTest extends StaticTypeCheckingTestCase {
             def fib
             fib = { int n -> n<2?n:fib(n-1)+fib(n-2) }
         ''',
-                'Cannot find matching method java.lang.Object#plus(java.lang.Object)',
-                'Cannot find matching method java.lang.Object#call(int)',
-                'Cannot find matching method java.lang.Object#call(int)'
+        'Cannot find matching method java.lang.Object#plus(java.lang.Object)',
+        'Cannot find matching method java.lang.Object#call(int)',
+        'Cannot find matching method java.lang.Object#call(int)'
     }
 
     void testClosureRecursionWithClosureTypeArgument() {
@@ -490,13 +491,13 @@ class ClosuresSTCTest extends StaticTypeCheckingTestCase {
     // GROOVY-5639
     void testShouldNotThrowClosureSharedVariableError() {
         assertScript '''
-        Closure<Void> c = {
-            List<String> list = new ArrayList<String>()
-            String s = "foo"
-            10.times {
-                list.add(s)
+            Closure<Void> c = {
+                List<String> list = new ArrayList<String>()
+                String s = "foo"
+                10.times {
+                    list.add(s)
+                }
             }
-        }
         '''
     }
 
@@ -562,7 +563,7 @@ class ClosuresSTCTest extends StaticTypeCheckingTestCase {
         '''
     }
 
-    // GROOVY-6219
+    // GROOVY-6219, GROOVY-10277
     void testShouldFailBecauseClosureReturnTypeDoesnMatchMethodSignature() {
         shouldFailWithMessages '''
             void printMessage(Closure<String> messageProvider) {
@@ -573,7 +574,7 @@ class ClosuresSTCTest extends StaticTypeCheckingTestCase {
                 printMessage { int x, int y -> x+y }
             }
         ''',
-        '#printMessage(groovy.lang.Closure<java.lang.String>) with arguments [groovy.lang.Closure<java.lang.Integer>]'
+        'Cannot return value of type int for closure expecting java.lang.String'
     }
 
     // GROOVY-6189, GROOVY-9852
@@ -621,7 +622,8 @@ class ClosuresSTCTest extends StaticTypeCheckingTestCase {
             foo {
                 print 'bar'
             }
-        ''', 'Reference to method is ambiguous. Cannot choose between'
+        ''',
+        'Reference to method is ambiguous. Cannot choose between'
 
         ['', 'x, y ->'].each { params ->
             shouldFailWithMessages """
@@ -630,7 +632,8 @@ class ClosuresSTCTest extends StaticTypeCheckingTestCase {
                 def foo(Function f) { f.apply(0) }
                 def foo(Supplier s) { s.get() }
                 foo { $params 'bar' }
-            """, 'Reference to method is ambiguous. Cannot choose between'
+            """,
+            'Reference to method is ambiguous. Cannot choose between'
         }
     }
 
@@ -662,7 +665,7 @@ class ClosuresSTCTest extends StaticTypeCheckingTestCase {
     }
 
     void testSAMVariable() {
-        assertScript """
+        assertScript '''
             interface SAM { def foo(); }
 
             @ASTTest(phase=INSTRUCTION_SELECTION, value={
@@ -672,27 +675,27 @@ class ClosuresSTCTest extends StaticTypeCheckingTestCase {
             assert s.foo() == 1
             def t = (SAM) {2}
             assert t.foo() == 2
-        """
+        '''
     }
 
     // GROOVY-7927
     void testSAMGenericsInAssignment() {
-        assertScript """
+        assertScript '''
             interface SAM<T,R> { R accept(T t); }
             SAM<Integer,Integer> s = { Integer n -> -n }
             assert s.accept(1) == -1
-        """
+        '''
     }
 
     void testSAMProperty() {
-        assertScript """
+        assertScript '''
             interface SAM { def foo(); }
             class X {
                 SAM s
             }
             def x = new X(s:{1})
             assert x.s.foo() == 1
-        """
+        '''
     }
 
     // GROOVY-7003
@@ -714,7 +717,7 @@ class ClosuresSTCTest extends StaticTypeCheckingTestCase {
     }
 
     void testSAMAttribute() {
-        assertScript """
+        assertScript '''
             interface SAM { def foo(); }
             class X {
                 public SAM s
@@ -725,7 +728,7 @@ class ClosuresSTCTest extends StaticTypeCheckingTestCase {
             x = new X()
             x.@s = {2}
             assert x.s.foo() == 2
-        """
+        '''
     }
 
     // GROOVY-10254
@@ -796,36 +799,38 @@ class ClosuresSTCTest extends StaticTypeCheckingTestCase {
     }
 
     void testSAMType() {
-        assertScript """
+        assertScript '''
             interface Foo {int foo()}
             Foo f = {1}
             assert f.foo() == 1
             abstract class Bar implements Foo {}
             Bar b = {2}
             assert b.foo() == 2
-        """
-        shouldFailWithMessages """
+        '''
+        shouldFailWithMessages '''
             interface Foo2 {
                 String toString()
             }
             Foo2 f2 = {int i->"hi"}
-        """, "Cannot assign"
-        shouldFailWithMessages """
+        ''',
+        'Cannot assign'
+        shouldFailWithMessages '''
             interface Foo2 {
                 String toString()
             }
             abstract class Bar2 implements Foo2 {}
             Bar2 b2 = {"there"}
-        """, "Cannot assign"
-        assertScript """
+        ''',
+        'Cannot assign'
+        assertScript '''
             interface Foo3 {
                 boolean equals(Object)
                 int f()
             }
             Foo3 f3 = {1}
             assert f3.f() == 1
-        """
-        shouldFailWithMessages """
+        '''
+        shouldFailWithMessages '''
             interface Foo3 {
                 boolean equals(Object)
                 int f()
@@ -834,7 +839,8 @@ class ClosuresSTCTest extends StaticTypeCheckingTestCase {
                 int f(){2}
             }
             Bar3 b3 = {2}
-        """, "Cannot assign"
+        ''',
+        'Cannot assign'
     }
 
     // GROOVY-6238
diff --git a/src/test/groovy/transform/stc/CoercionSTCTest.groovy b/src/test/groovy/transform/stc/CoercionSTCTest.groovy
index 81d9be1892..2c100508b7 100644
--- a/src/test/groovy/transform/stc/CoercionSTCTest.groovy
+++ b/src/test/groovy/transform/stc/CoercionSTCTest.groovy
@@ -129,21 +129,33 @@ class CoercionSTCTest extends StaticTypeCheckingTestCase {
     void testCoerceToFunctionalInterface() {
         assertScript '''
             import java.util.function.*
+            Consumer<Number> c = { n -> }
             Supplier<Number> s = { -> 42 }
             Predicate<Number> p = { n -> 42 }
         '''
         assertScript '''
             import java.util.function.*
+            def c = (Consumer<Number>) { n -> }
+            def s = (Supplier<Number>) { -> 42 }
+            def p = (Predicate<Number>) { n -> 42 }
+        '''
+        assertScript '''
+            import java.util.function.*
+            def c = { n -> } as Consumer<Number>
             def s = { -> 42 } as Supplier<Number>
             def p = { n -> 42 } as Predicate<Number>
         '''
+        shouldFailWithMessages '''
+            import java.util.function.*
+            def s = (Supplier<Number>) { -> false }
+        ''', 'Cannot return value of type boolean for closure expecting java.lang.Number'
         shouldFailWithMessages '''
             import java.util.function.*
             def s = { -> false } as Supplier<Number>
-        ''', 'Cannot coerce lambda or closure returning boolean to java.util.function.Supplier<java.lang.Number>'
+        ''', 'Cannot return value of type boolean for closure expecting java.lang.Number'
         shouldFailWithMessages '''
             import java.util.function.*
-            def s = (() -> false) as Supplier<Number>
-        ''', 'Cannot coerce lambda or closure returning boolean to java.util.function.Supplier<java.lang.Number>'
+            def s = (() -> ['']) as Supplier<Number>
+        ''', 'Cannot return value of type java.util.List<java.lang.String> for lambda expecting java.lang.Number'
     }
 }
diff --git a/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy b/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy
index c56e805c82..a7ccf1eb60 100644
--- a/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy
+++ b/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy
@@ -36,7 +36,8 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
             class C { int x }
             C c = new C()
             c.x = '1'
-        ''', 'Cannot assign value of type java.lang.String to variable of type int'
+        ''',
+        'Cannot assign value of type java.lang.String to variable of type int'
     }
 
     void testAssignFinalFieldValue() {
@@ -97,33 +98,39 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
         shouldFailWithMessages '''
             int[] array = []
             array.length = 1
-        ''', 'Cannot set read-only property: length'
+        ''',
+        'Cannot set read-only property: length'
 
         shouldFailWithMessages '''
             class C { final x }
             new C().x = null
-        ''', 'Cannot set read-only property: x'
+        ''',
+        'Cannot set read-only property: x'
 
         // GROOVY-5450
         shouldFailWithMessages '''
             class C { final x }
             new C().@x = null
-        ''', 'Cannot set read-only property: x'
+        ''',
+        'Cannot set read-only property: x'
 
         shouldFailWithMessages '''
             class C { final x }
             new C().with { x = null }
-        ''', 'Cannot set read-only property: x'
+        ''',
+        'Cannot set read-only property: x'
 
         shouldFailWithMessages '''
             class C { final x }
             new C().with { delegate.x = null }
-        ''', 'Cannot set read-only property: x'
+        ''',
+        'Cannot set read-only property: x'
 
         shouldFailWithMessages '''
             class C { final x }
             new C().setX(null)
-        ''', 'Cannot find matching method C#setX(<unknown parameter type>).'
+        ''',
+        'Cannot find matching method C#setX(<unknown parameter type>).'
     }
 
     void testMapDotPropertySyntax() {
@@ -148,14 +155,14 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
     }
 
     void testAssignFieldValueWithAttributeNotation() {
-        assertScript """
+        assertScript '''
             class A {
                 int x
             }
 
             A a = new A()
             a.@x = 1
-        """
+        '''
     }
 
     void testAssignFieldValueWithWrongTypeAndAttributeNotation() {
@@ -166,7 +173,8 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
 
              A a = new A()
              a.@x = '1'
-         ''', 'Cannot assign value of type java.lang.String to variable of type int'
+         ''',
+         'Cannot assign value of type java.lang.String to variable of type int'
      }
 
     void testInferenceFromAttributeType() {
@@ -184,7 +192,8 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
         shouldFailWithMessages '''
             Object o = new Object()
             o.x = 0
-        ''', 'No such property: x for class: java.lang.Object'
+        ''',
+        'No such property: x for class: java.lang.Object'
     }
 
     void testShouldComplainAboutMissingProperty2() {
@@ -193,7 +202,8 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
             }
             A a = new A()
             a.x = 0
-        ''', 'No such property: x for class: A'
+        ''',
+        'No such property: x for class: A'
     }
 
     @NotYetImplemented
@@ -207,14 +217,16 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
                     this.x
                 }
             }
-        ''', 'The field A.x is not accessible'
+        ''',
+        'The field A.x is not accessible'
     }
 
     void testShouldComplainAboutMissingAttribute() {
         shouldFailWithMessages '''
             Object o = new Object()
             o.@x = 0
-        ''', 'No such attribute: x for class: java.lang.Object'
+        ''',
+        'No such attribute: x for class: java.lang.Object'
     }
 
     void testShouldComplainAboutMissingAttribute2() {
@@ -223,7 +235,8 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
             }
             A a = new A()
             a.@x = 0
-        ''', 'No such attribute: x for class: A'
+        ''',
+        'No such attribute: x for class: A'
     }
 
     void testShouldComplainAboutMissingAttribute3() {
@@ -233,7 +246,8 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
             }
             A a = new A()
             println a.@x
-        ''', 'No such attribute: x for class: A'
+        ''',
+        'No such attribute: x for class: A'
     }
 
     void testShouldComplainAboutMissingAttribute4() {
@@ -243,7 +257,8 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
             }
             A a = new A()
             a.@x = 0
-        ''', 'No such attribute: x for class: A'
+        ''',
+        'No such attribute: x for class: A'
     }
 
     void testShouldComplainAboutMissingAttribute5() {
@@ -256,7 +271,8 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
                     this.@x
                 }
             }
-        ''', 'The field A.x is not accessible'
+        ''',
+        'The field A.x is not accessible'
     }
 
     void testPropertyWithInheritance() {
@@ -284,7 +300,8 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
             }
             B b = new B()
             b.x = '2'
-        ''', 'Cannot assign value of type java.lang.String to variable of type int'
+        ''',
+        'Cannot assign value of type java.lang.String to variable of type int'
     }
 
     void testPropertyWithInheritanceFromAnotherSourceUnit() {
@@ -302,7 +319,8 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
             }
             B b = new B()
             b.x = '2'
-        ''', 'Cannot assign value of type java.lang.String to variable of type int'
+        ''',
+        'Cannot assign value of type java.lang.String to variable of type int'
     }
 
     void testPropertyWithSuperInheritanceFromAnotherSourceUnit() {
@@ -398,26 +416,25 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
                 int bar = new Date()
             }
             new Foo()
-        ''', 'Cannot assign value of type java.util.Date to variable of type int'
+        ''',
+        'Cannot assign value of type java.util.Date to variable of type int'
     }
 
-    // GROOVY-5443
-    void testFieldInitShouldNotPassBecauseOfIncompatibleTypesWithClosure() {
+    // GROOVY-5443, GROOVY-10277
+    void testFieldInitShouldNotPassBecauseOfIncompatibleTypesWithClosure1() {
         shouldFailWithMessages '''
             class Foo {
                 Closure<List> bar = { Date date -> date.getTime() }
             }
-            new Foo()
-        ''', 'Incompatible generic argument types. Cannot assign groovy.lang.Closure<java.lang.Long> to: groovy.lang.Closure<java.util.List>'
-    }
+        ''',
+        'Cannot return value of type long for closure expecting java.util.List'
 
-    void testFieldInitShouldNotPassBecauseOfIncompatibleTypesWithClosure2() {
         shouldFailWithMessages '''
             class Foo {
-                java.util.function.Supplier<String> bar = { 123 }
+                java.util.function.Supplier<String> bar = { -> 123 }
             }
-            new Foo()
-        ''', 'Incompatible generic argument types. Cannot assign java.util.function.Supplier<java.lang.Integer> to: java.util.function.Supplier<java.lang.String>'
+        ''',
+        'Cannot return value of type int for closure expecting java.lang.String'
     }
 
     // GROOVY-9882
@@ -435,12 +452,15 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
             class Foo {
                 java.util.function.Supplier<String> bar = { baz -> '' }
             }
-        ''', 'Wrong number of parameters for method target get()'
+        ''',
+        'Wrong number of parameters for method target get()'
+
         shouldFailWithMessages '''
             class Foo {
                 java.util.function.Consumer<String> bar = { -> null }
             }
-        ''', 'Wrong number of parameters for method target accept(java.lang.String)'
+        ''',
+        'Wrong number of parameters for method target accept(java.lang.String)'
     }
 
     // GROOVY-9991
@@ -482,7 +502,6 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
             list.add(new Elem(value:789))
             assert list.value == [ 123, 456, 789 ]
         '''
-
         assertScript '''class Elem { String value }
             List<Elem> list = new LinkedList<Elem>()
             list.add(new Elem(value:'123'))
@@ -524,16 +543,16 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
 
     void testSetterUsingPropertyNotationOnInterface() {
         assertScript '''
-                interface FooAware { void setFoo(String arg) }
-                class A implements FooAware {
-                    void setFoo(String foo) { }
-                }
-                void test(FooAware a) {
-                    a.foo = 'foo'
-                }
-                def a = new A()
-                test(a)
-            '''
+            interface FooAware { void setFoo(String arg) }
+            class A implements FooAware {
+                void setFoo(String foo) { }
+            }
+            void test(FooAware a) {
+                a.foo = 'foo'
+            }
+            def a = new A()
+            test(a)
+        '''
     }
 
     // GROOVY-5700
@@ -595,7 +614,7 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
     // GROOVY-5779
     void testShouldNotUseNonStaticProperty() {
         assertScript '''import java.awt.Color
-        Color c = Color.red // should not be interpreted as Color.getRed()
+            Color c = Color.red // should not be interpreted as Color.getRed()
         '''
     }
 
@@ -640,7 +659,8 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
             }
             def i = new Outer.Inner()
             def x = i.m()
-        ''', 'The variable [p] is undeclared.'
+        ''',
+        'The variable [p] is undeclared.'
     }
 
     void testOuterPropertyAccess3() {
@@ -655,7 +675,8 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
             }
             def i = new Outer.Inner()
             def x = i.m()
-        ''', 'No such property: p for class: Outer$Inner'
+        ''',
+        'No such property: p for class: Outer$Inner'
     }
 
     // GROOVY-7024
@@ -764,7 +785,7 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
 
             }
             new GreetingActor()
-            '''
+        '''
     }
 
     // GROOVY-6610
@@ -887,29 +908,25 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
 
     // GROOVY-6489
     void testShouldNotThrowUnmatchedGenericsError() {
-        assertScript '''public class Foo {
-
-    private List<String> names;
-
-    public List<String> getNames() {
-        return names;
-    }
-
-    public void setNames(List<String> names) {
-        this.names = names;
-    }
-}
-
-class FooWorker {
-
-    public void doSomething() {
-        new Foo().with {
-            names = new ArrayList()
-        }
-    }
-}
-
-new FooWorker().doSomething()'''
+        assertScript '''
+            public class Foo {
+                private List<String> names;
+                public List<String> getNames() {
+                    return names;
+                }
+                public void setNames(List<String> names) {
+                    this.names = names;
+                }
+            }
+            class FooWorker {
+                public void doSomething() {
+                    new Foo().with {
+                        names = new ArrayList()
+                    }
+                }
+            }
+            new FooWorker().doSomething()
+        '''
     }
 
     void testShouldFailWithIncompatibleGenericTypes() {
@@ -949,9 +966,11 @@ new FooWorker().doSomething()'''
     }
 
     void testPropertyWithMultipleSetters() {
-        assertScript '''import org.codehaus.groovy.ast.expr.BinaryExpression
-import org.codehaus.groovy.ast.expr.BooleanExpression
-import org.codehaus.groovy.ast.stmt.AssertStatement
+        assertScript '''
+            import org.codehaus.groovy.ast.expr.BinaryExpression
+            import org.codehaus.groovy.ast.expr.BooleanExpression
+            import org.codehaus.groovy.ast.stmt.AssertStatement
+
             class A {
                 private field
                 void setX(Integer a) {field=a}
@@ -1223,7 +1242,8 @@ import org.codehaus.groovy.ast.stmt.AssertStatement
 
             Foo foo = new Foo(bar: new Bar(x: 1))
             Bar bar = foo.bar
-        ''', 'Cannot assign value of type int to variable of type Bar'
+        ''',
+        'Cannot assign value of type int to variable of type Bar'
 
         assertScript '''
             class Foo {
diff --git a/src/test/groovy/transform/stc/GenericsSTCTest.groovy b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
index 41ecf039ad..0e2559fb7b 100644
--- a/src/test/groovy/transform/stc/GenericsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
@@ -472,7 +472,7 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
                 chars()
             }
         ''',
-        'Cannot return value of type #T on method returning type java.util.List'
+        'Cannot return value of type #T for method returning java.util.List'
     }
 
     // GROOVY-10098
@@ -483,7 +483,7 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
               T p
               T m() {
                 Closure<T> x = { -> p }
-                x() // Cannot return value of type Object on method returning type T
+                x() // Cannot return value of type Object for method returning T
               }
             }
             assert new C<>(42).m() == 42
@@ -518,7 +518,7 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
             class Test {
                 Task task
                 def <T> T exec(args) {
-                    task.exec(args) // Cannot return value of type #T on method returning type T
+                    task.exec(args) // Cannot return value of type #T for method returning T
                 }
             }
             String result = new Test(task: new Task()).exec('works')
@@ -540,7 +540,7 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
 
                 abstract F start()
                 T end() {
-                  end // Cannot return value of type Path$Segment<F,T> on method returning type T
+                  end // Cannot return value of type Path$Segment<F,T> for method returning T
                 }
                 T end
 
@@ -2534,7 +2534,7 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
                 }
             }
         ''',
-        'Cannot return value of type T on method returning type U'
+        'Cannot return value of type T for method returning U'
 
         shouldFailWithMessages '''
             class C<X, Y> {
@@ -4067,7 +4067,7 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
             class Foo<T extends Bar> {
                 T method(T t) {
                     def c = { -> t }
-                    return c() // Cannot return value of type Object on method returning type T
+                    return c() // Cannot return value of type Object for method returning T
                 }
             }
             def bar = new Bar()
diff --git a/src/test/groovy/transform/stc/LambdaTest.groovy b/src/test/groovy/transform/stc/LambdaTest.groovy
index a32df04006..fe8168c2c8 100644
--- a/src/test/groovy/transform/stc/LambdaTest.groovy
+++ b/src/test/groovy/transform/stc/LambdaTest.groovy
@@ -18,7 +18,6 @@
  */
 package groovy.transform.stc
 
-import groovy.test.NotYetImplemented
 import groovy.transform.CompileStatic
 import org.junit.Test
 
@@ -231,7 +230,7 @@ final class LambdaTest {
     }
 
     @Test
-    void testComparator1() {
+    void testComparator() {
         assertScript '''
             @groovy.transform.CompileStatic class T {
                 Comparator<Integer> c = (Integer a, Integer b) -> Integer.compare(a, b)
@@ -239,7 +238,10 @@ final class LambdaTest {
             def t = new T()
             assert t.c.compare(0,0) == 0
         '''
+    }
 
+    //TODO: GROOVY-10277
+    void testComparator2() {
         def err = shouldFail '''
             @groovy.transform.CompileStatic class T {
                 Comparator<Integer> c = (int a, int b) -> Integer.compare(a, b)
@@ -249,16 +251,16 @@ final class LambdaTest {
     }
 
     @Test // GROOVY-9977
-    void testComparator2() {
+    void testComparator3() {
         assertScript '''
             @groovy.transform.CompileStatic
             class T {
                 Comparator<Integer> c = (a, b) -> Integer.compare(a, b)
 
-                static void m1() {
+                void m1() {
                     Comparator<Integer> x = (a, b) -> Integer.compare(a, b)
                 }
-                void m2() {
+                static void m2() {
                     Comparator<Integer> y = (a, b) -> Integer.compare(a, b)
                 }
             }
@@ -268,7 +270,7 @@ final class LambdaTest {
     }
 
     @Test // GROOVY-9997
-    void testComparator3() {
+    void testComparator4() {
         assertScript '''
             @groovy.transform.TypeChecked
             void test() {
@@ -326,7 +328,7 @@ final class LambdaTest {
     }
 
     @Test
-    void testFunctionWithLocalVariables4() {
+    void testFunctionWithLocalVariables3() {
         assertScript '''
             import groovy.transform.CompileStatic
             import java.util.stream.Collectors
@@ -348,7 +350,7 @@ final class LambdaTest {
     }
 
     @Test
-    void testFunctionWithLocalVariables5() {
+    void testFunctionWithLocalVariables4() {
         assertScript '''
             import groovy.transform.CompileStatic
             import java.util.stream.Collectors
@@ -372,7 +374,7 @@ final class LambdaTest {
     }
 
     @Test
-    void testFunctionWithLocalVariables6() {
+    void testFunctionWithLocalVariables5() {
         assertScript '''
             import groovy.transform.CompileStatic
             import java.util.stream.Collectors
@@ -1282,7 +1284,7 @@ final class LambdaTest {
                 def p() {
                     def out = new ByteArrayOutputStream()
                     out.withObjectOutputStream {
-                        Function<Integer, String> f = ((Integer e) -> 'a' + e)
+                        Function<Integer, String> f = (Integer e) -> 'a' + e
                         it.writeObject(f)
                     }
                     return out.toByteArray()
@@ -1373,7 +1375,7 @@ final class LambdaTest {
                 SerializableFunction<Integer, String> f
 
                 {
-                    f = ((Integer e) -> a + e)
+                    f = (Integer e) -> a + e
                 }
 
                 byte[] p() {
diff --git a/src/test/groovy/transform/stc/LoopsSTCTest.groovy b/src/test/groovy/transform/stc/LoopsSTCTest.groovy
index 2798cfb17e..1d306f0985 100644
--- a/src/test/groovy/transform/stc/LoopsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/LoopsSTCTest.groovy
@@ -26,40 +26,34 @@ import groovy.transform.CompileStatic
 class LoopsSTCTest extends StaticTypeCheckingTestCase {
 
     void testMethodCallInLoop() {
-        assertScript '''
-            int foo(int x) { x+1 }
-            int x = 0
-            for (int i=0;i<10;i++) {
-                x = foo(x)
-            }
-        '''
-    }
-
-    void testMethodCallInLoopAndDef() {
-        assertScript '''
-            int foo(int x) { x+1 }
-            def x = 0
-            for (int i=0;i<10;i++) {
-                x = foo(x)
-            }
-        '''
+        for (type in ['int', 'def', 'var']) {
+            assertScript """
+                int foo(int x) { x+1 }
+                $type x = 0
+                for (int i=0;i<10;i++) {
+                    x = foo(x)
+                }
+            """
+        }
     }
 
     // GROOVY-8882
     void testStringCollectionLoop() {
+        for (s in 'abc') assert s instanceof String
+        for (String s in 'abc') assert s instanceof String
+
         for (char c in 'abc') assert c instanceof Character
         for (Character c in 'abc') assert c instanceof Character
-        for (String s in 'abc') assert s instanceof String
-        for (s in 'abc') assert s instanceof String
     }
 
     // GROOVY-8882
     @CompileStatic
     void testStringCollectionLoopCS() {
+        for (s in 'abc') assert s instanceof String
+        for (String s in 'abc') assert s instanceof String
+
         for (char c in 'abc') assert c instanceof Character
         for (Character c in 'abc') assert c instanceof Character
-        for (String s in 'abc') assert s instanceof String
-        for (s in 'abc') assert s instanceof String
     }
 
     void testMethodCallWithEachAndDefAndTwoFooMethods() {
@@ -71,7 +65,8 @@ class LoopsSTCTest extends StaticTypeCheckingTestCase {
                  // there are two possible target methods. This is not a problem for STC, but it is for static compilation
                 x = foo(x)
             }
-        ''', 'Cannot find matching method'
+        ''',
+        'Cannot find matching method'
     }
 
     void testMethodCallInLoopAndDefAndTwoFooMethods() {
@@ -83,7 +78,8 @@ class LoopsSTCTest extends StaticTypeCheckingTestCase {
                  // there are two possible target methods. This is not a problem for STC, but it is for static compilation
                 x = foo(x)
             }
-        ''', 'Cannot find matching method'
+        ''',
+        'Cannot find matching method'
     }
 
     void testMethodCallInLoopAndDefAndTwoFooMethodsAndOneWithBadType() {
@@ -96,7 +92,8 @@ class LoopsSTCTest extends StaticTypeCheckingTestCase {
                 // then called in turn as a parameter of foo(). There's no #foo(Date)
                 x = foo(x)
             }
-        ''', 'Cannot find matching method'
+        ''',
+        'Cannot find matching method'
     }
 
     void testMethodCallInLoopAndDefAndTwoFooMethodsAndOneWithBadTypeAndIndirection() {
@@ -110,7 +107,8 @@ class LoopsSTCTest extends StaticTypeCheckingTestCase {
                 // then called in turn as a parameter of foo(). There's no #foo(Date)
                 x = y
             }
-        ''', 'Cannot find matching method'
+        ''',
+        'Cannot find matching method'
     }
 
     void testMethodCallWithEachAndDefAndTwoFooMethodsAndOneWithBadTypeAndIndirection() {
@@ -124,7 +122,8 @@ class LoopsSTCTest extends StaticTypeCheckingTestCase {
                 // then called in turn as a parameter of foo(). There's no #foo(Date)
                 x = y
             }
-        ''', 'Cannot find matching method'
+        ''',
+        'Cannot find matching method'
     }
 
     // GROOVY-5587
@@ -222,7 +221,7 @@ class LoopsSTCTest extends StaticTypeCheckingTestCase {
         assertScript '''import java.lang.reflect.Field
             import org.codehaus.groovy.ast.stmt.ForStatement
 
-            @ASTTest(phase=INSTRUCTION_SELECTION, value= {
+            @ASTTest(phase=INSTRUCTION_SELECTION, value={
                 def FIELD_ARRAY = make(Field).makeArray()
                 def forStmt = lookup('myLoop')[0]
                 assert forStmt instanceof ForStatement
@@ -278,7 +277,7 @@ class LoopsSTCTest extends StaticTypeCheckingTestCase {
     // GROOVY-5641
     void testShouldInferLoopElementTypeWithUndeclaredType() {
         assertScript '''import org.codehaus.groovy.ast.stmt.ForStatement
-        @ASTTest(phase=INSTRUCTION_SELECTION, value= {
+        @ASTTest(phase=INSTRUCTION_SELECTION, value={
             def forStmt = lookup('loop')[0]
             assert forStmt instanceof ForStatement
             def collectionType = forStmt.collectionExpression.getNodeMetaData(INFERRED_TYPE)
diff --git a/src/test/groovy/transform/stc/ReturnsSTCTest.groovy b/src/test/groovy/transform/stc/ReturnsSTCTest.groovy
index 8b0b2d686e..1172243665 100644
--- a/src/test/groovy/transform/stc/ReturnsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/ReturnsSTCTest.groovy
@@ -47,7 +47,7 @@ class ReturnsSTCTest extends StaticTypeCheckingTestCase {
             int method() {
                 return 'String'
             }
-        ''', 'Cannot return value of type java.lang.String on method returning type int'
+        ''', 'Cannot return value of type java.lang.String for method returning int'
     }
 
     void testIncompatibleImplicitReturn2() {
@@ -55,7 +55,7 @@ class ReturnsSTCTest extends StaticTypeCheckingTestCase {
             int method() {
                 'String'
             }
-        ''', 'Cannot return value of type java.lang.String on method returning type int'
+        ''', 'Cannot return value of type java.lang.String for method returning int'
     }
 
     void testIncompatibleImplicitReturn() {
@@ -77,7 +77,7 @@ class ReturnsSTCTest extends StaticTypeCheckingTestCase {
                     2
                 }
             }
-        ''', 'Cannot return value of type java.lang.String on method returning type int'
+        ''', 'Cannot return value of type java.lang.String for method returning int'
     }
 
     void testImplicitReturnFailureWithIfElse2() {
@@ -89,7 +89,7 @@ class ReturnsSTCTest extends StaticTypeCheckingTestCase {
                     'String'
                 }
             }
-        ''', 'Cannot return value of type java.lang.String on method returning type int'
+        ''', 'Cannot return value of type java.lang.String for method returning int'
     }
 
     void testImplicitReturnFailureWithIfElse3() {
@@ -102,8 +102,8 @@ class ReturnsSTCTest extends StaticTypeCheckingTestCase {
                 }
             }
         ''',
-        'Cannot return value of type java.lang.String on method returning type int', // first branch
-        'Cannot return value of type java.lang.String on method returning type int' // second branch
+        'Cannot return value of type java.lang.String for method returning int', // first branch
+        'Cannot return value of type java.lang.String for method returning int' // second branch
     }
 
     void testImplicitReturnFailureWithSwitch() {
@@ -121,7 +121,7 @@ class ReturnsSTCTest extends StaticTypeCheckingTestCase {
                  }
              }
          ''',
-         'Cannot return value of type java.lang.String on method returning type int'
+         'Cannot return value of type java.lang.String for method returning int'
     }
 
     void testImplicitReturnFailureWithSwitch2() {
@@ -145,7 +145,7 @@ class ReturnsSTCTest extends StaticTypeCheckingTestCase {
             double greeting(String name) {
                 new Object()
             }
-        ''', 'Cannot return value of type java.lang.Object on method returning type double'
+        ''', 'Cannot return value of type java.lang.Object for method returning double'
     }
 
     void testRecursiveTypeInferrence() {
diff --git a/src/test/groovy/transform/stc/TypeCheckingModeTest.groovy b/src/test/groovy/transform/stc/TypeCheckingModeTest.groovy
index c083dac754..07719de81b 100644
--- a/src/test/groovy/transform/stc/TypeCheckingModeTest.groovy
+++ b/src/test/groovy/transform/stc/TypeCheckingModeTest.groovy
@@ -22,11 +22,12 @@ package groovy.transform.stc
  * Unit tests for static type checking : type checking mode.
  */
 class TypeCheckingModeTest extends StaticTypeCheckingTestCase {
+
     void testShouldThrowErrorBecauseTypeCheckingIsOn() {
         shouldFailWithMessages '''
             int foo() { 'foo' }
             1
-        ''', 'Cannot return value of type java.lang.String on method returning type int'
+        ''', 'Cannot return value of type java.lang.String for method returning int'
     }
 
     void testShouldNotThrowErrorBecauseTypeCheckingIsOff() {
@@ -53,7 +54,7 @@ class TypeCheckingModeTest extends StaticTypeCheckingTestCase {
                 int foo() { 'foo' }
             }
             1
-        ''', 'Cannot return value of type java.lang.String on method returning type int'
+        ''', 'Cannot return value of type java.lang.String for method returning int'
     }
 
     void testShouldNotThrowErrorBecauseTypeCheckingIsOffIntoClass() {
diff --git a/src/test/org/codehaus/groovy/transform/traitx/TraitASTTransformationTest.groovy b/src/test/org/codehaus/groovy/transform/traitx/TraitASTTransformationTest.groovy
index c5ad96fcab..332221c99e 100644
--- a/src/test/org/codehaus/groovy/transform/traitx/TraitASTTransformationTest.groovy
+++ b/src/test/org/codehaus/groovy/transform/traitx/TraitASTTransformationTest.groovy
@@ -1841,7 +1841,7 @@ final class TraitASTTransformationTest {
                 int foo() { 1+'foo'}
             }
         '''
-        assert err =~ 'Cannot return value of type java.lang.String on method returning type int'
+        assert err =~ 'Cannot return value of type java.lang.String for method returning int'
     }
 
     @Test
