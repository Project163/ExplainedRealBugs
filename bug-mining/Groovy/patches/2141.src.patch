diff --git a/src/main/org/codehaus/groovy/classgen/AnnotationVisitor.java b/src/main/org/codehaus/groovy/classgen/AnnotationVisitor.java
index ec2b643813..a283f74f3f 100644
--- a/src/main/org/codehaus/groovy/classgen/AnnotationVisitor.java
+++ b/src/main/org/codehaus/groovy/classgen/AnnotationVisitor.java
@@ -241,17 +241,16 @@ public class AnnotationVisitor {
     private ConstantExpression getConstantExpression(Expression exp, ClassNode attrType) {
         if (exp instanceof ConstantExpression) {
             return (ConstantExpression) exp;
+        }
+        String base = "Expected '" + exp.getText() + "' to be an inline constant of type " + attrType.getName();
+        if (exp instanceof PropertyExpression) {
+            addError(base + " not a property expression", exp);
+        } else if (exp instanceof VariableExpression && ((VariableExpression)exp).getAccessedVariable() instanceof FieldNode) {
+            addError(base + " not a field expression", exp);
         } else {
-            String base = "expected '" + exp.getText() + "' to be an inline constant of type " + attrType.getName();
-            if (exp instanceof PropertyExpression) {
-                addError(base + " not a property expression", exp);
-            } else if (exp instanceof VariableExpression && ((VariableExpression)exp).getAccessedVariable() instanceof FieldNode) {
-                addError(base + " not a field expression", exp);
-            } else {
-                addError(base, exp);
-            }
-            return ConstantExpression.EMPTY_EXPRESSION;
+            addError(base, exp);
         }
+        return ConstantExpression.EMPTY_EXPRESSION;
     }
 
     /**
@@ -273,14 +272,18 @@ public class AnnotationVisitor {
     }
 
     protected void visitConstantExpression(String attrName, ConstantExpression constExpr, ClassNode attrType) {
-        ClassNode type = ClassHelper.getWrapper(constExpr.getType());
-        if (!type.isDerivedFrom(attrType)) {
-            addError("Attribute '" + attrName + "' should have type '" + attrType.getName() + "'; "
-                    + "but found type '" + constExpr.getType().getName() + "'",
-                    constExpr);
+        ClassNode constType = constExpr.getType();
+        ClassNode wrapperType = ClassHelper.getWrapper(constType);
+        if (!hasCompatibleType(attrType, wrapperType)) {
+            addError("Attribute '" + attrName + "' should have type '" + attrType.getName()
+                    + "'; but found type '" + constType.getName() + "'", constExpr);
         }
     }
 
+    private boolean hasCompatibleType(ClassNode attrType, ClassNode wrapperType) {
+        return wrapperType.isDerivedFrom(ClassHelper.getWrapper(attrType));
+    }
+
     protected void visitEnumExpression(String attrName, PropertyExpression propExpr, ClassNode attrType) {
         if (!propExpr.getObjectExpression().getType().isDerivedFrom(attrType)) {
             addError("Attribute '" + attrName + "' should have type '" + attrType.getName() + "' (Enum), but found "
diff --git a/src/main/org/codehaus/groovy/classgen/ExtendedVerifier.java b/src/main/org/codehaus/groovy/classgen/ExtendedVerifier.java
index 02a5d3bfd1..c0bd8e53d4 100644
--- a/src/main/org/codehaus/groovy/classgen/ExtendedVerifier.java
+++ b/src/main/org/codehaus/groovy/classgen/ExtendedVerifier.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2003-2012 the original author or authors.
+ * Copyright 2003-2013 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -17,6 +17,7 @@ package org.codehaus.groovy.classgen;
 
 import org.codehaus.groovy.ast.*;
 import org.codehaus.groovy.ast.stmt.ReturnStatement;
+import org.codehaus.groovy.control.AnnotationConstantsVisitor;
 import org.codehaus.groovy.control.CompilerConfiguration;
 import org.codehaus.groovy.control.ErrorCollector;
 import org.codehaus.groovy.control.SourceUnit;
@@ -44,6 +45,8 @@ public class ExtendedVerifier implements GroovyClassVisitor {
     }
 
     public void visitClass(ClassNode node) {
+        AnnotationConstantsVisitor acv = new AnnotationConstantsVisitor();
+        acv.visitClass(node, this.source);
         this.currentClass = node;
         if (node.isAnnotationDefinition()) {
             visitAnnotations(node, AnnotationNode.ANNOTATION_TARGET);
diff --git a/src/main/org/codehaus/groovy/control/AnnotationConstantsVisitor.java b/src/main/org/codehaus/groovy/control/AnnotationConstantsVisitor.java
new file mode 100644
index 0000000000..56cdc5f125
--- /dev/null
+++ b/src/main/org/codehaus/groovy/control/AnnotationConstantsVisitor.java
@@ -0,0 +1,108 @@
+/*
+ * Copyright 2003-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.codehaus.groovy.control;
+
+import org.codehaus.groovy.ast.*;
+import org.codehaus.groovy.ast.expr.*;
+import org.codehaus.groovy.ast.stmt.ReturnStatement;
+import org.codehaus.groovy.ast.stmt.Statement;
+import org.codehaus.groovy.classgen.Verifier;
+
+/**
+ * Visitor to resolve constants in annotation definitions.
+ *
+ * @author Paul King
+ */
+public class AnnotationConstantsVisitor extends ClassCodeVisitorSupport {
+    private SourceUnit source;
+    private boolean inAnnotationDef;
+
+    public void visitClass(ClassNode node, SourceUnit source) {
+        this.source = source;
+        this.inAnnotationDef = node.isAnnotationDefinition();
+        super.visitClass(node);
+        this.inAnnotationDef = false;
+    }
+
+    @Override
+    protected void visitConstructorOrMethod(MethodNode node, boolean isConstructor) {
+        if (!inAnnotationDef) return;
+        visitStatement(node.getFirstStatement(), node.getReturnType());
+    }
+
+    private void visitStatement(Statement statement, ClassNode returnType) {
+        if (statement instanceof ReturnStatement) {
+            ReturnStatement rs = (ReturnStatement) statement;
+            rs.setExpression(transformConstantExpression(rs.getExpression(), returnType));
+        }
+    }
+
+    private Expression transformConstantExpression(Expression val, ClassNode returnType) {
+        ClassNode returnWrapperType = ClassHelper.getWrapper(returnType);
+        if (val instanceof ConstantExpression) {
+            Expression result = revertType(val, returnWrapperType);
+            if (result != null) {
+                return result;
+            }
+            return val;
+        }
+        if (val instanceof CastExpression) {
+            CastExpression castExp = (CastExpression) val;
+            Expression castee = castExp.getExpression();
+            if (castee instanceof ConstantExpression) {
+                if (ClassHelper.getWrapper(castee.getType()).isDerivedFrom(returnWrapperType)) {
+                    return castee;
+                }
+                Expression result = revertType(castee, returnWrapperType);
+                if (result != null) {
+                    return result;
+                }
+                return castee;
+            }
+        }
+        return val;
+    }
+
+    private Expression revertType(Expression val, ClassNode returnWrapperType) {
+        ClassNode valWrapperType = ClassHelper.getWrapper(val.getType());
+        ConstantExpression ce = (ConstantExpression) val;
+        if (ClassHelper.Character_TYPE.equals(returnWrapperType) && ClassHelper.STRING_TYPE.equals(val.getType())) {
+            return configure(val, Verifier.transformToPrimitiveConstantIfPossible((ConstantExpression) val));
+        }
+        if (ClassHelper.Integer_TYPE.equals(valWrapperType)) {
+            Integer i = (Integer) ce.getValue();
+            if (ClassHelper.Character_TYPE.equals(returnWrapperType)) {
+                return configure(val, new ConstantExpression((char) i.intValue()));
+            }
+            if (ClassHelper.Short_TYPE.equals(returnWrapperType)) {
+                return configure(val, new ConstantExpression(i.shortValue()));
+            }
+            if (ClassHelper.Byte_TYPE.equals(returnWrapperType)) {
+                return configure(val, new ConstantExpression(i.byteValue()));
+            }
+        }
+        return null;
+    }
+
+    private Expression configure(Expression orig, Expression result) {
+        result.setSourcePosition(orig);
+        return result;
+    }
+
+    protected SourceUnit getSourceUnit() {
+        return source;
+    }
+}
