diff --git a/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java b/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
index 5ce8a8fb3c..f36ba85e5c 100644
--- a/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
+++ b/src/main/org/codehaus/groovy/runtime/DefaultGroovyMethods.java
@@ -1395,29 +1395,122 @@ public class DefaultGroovyMethods {
     }
 
     /**
-     * Support the subscript operator for a regex Matcher
+     * Support the subscript operator, e.g. matcher[index], for a regex Matcher.
+     *
+     * For an example using no group match, <code><pre>
+     *    def p = /ab[d|f]/ 
+     *    def m = "abcabdabeabf" =~ p 
+     *    for (i in 0..<m.count) { 
+     *        println( "m.groupCount() = " + m.groupCount())
+     *        println( "  " + i + ": " + m[i] )   // m[i] is a String
+     *    }
+     * </pre></code>
+     *
+     * For an example using group matches, <code><pre>
+     *    def p = /(?:ab([c|d|e|f]))/ `
+     *    def m = "abcabdabeabf" =~ p 
+     *    for (i in 0..<m.count) { 
+     *        println( "m.groupCount() = " + m.groupCount())
+     *        println( "  " + i + ": " + m[i] )   // m[i] is a List
+     *    }
+     * </pre></code>
+     *
+     * For another example using group matches, <code><pre>
+     *    def m = "abcabdabeabfabxyzabx" =~ /(?:ab([d|x-z]+))/
+     *    m.count.times { 
+     *        println( "m.groupCount() = " + m.groupCount())
+     *        println( "  " + it + ": " + m[it] )   // m[it] is a List
+     *    }
+     * </pre></code>
      *
      * @param matcher a Matcher
      * @param idx     an index
-     * @return the group at the given index
+     * @return object a matched String if no groups matched, list of matched groups otherwise.
      */
-    public static String getAt(Matcher matcher, int idx) {
-        idx = normaliseIndex(idx, matcher.groupCount());
-
-        // are we using groups?
-        if (matcher.groupCount() > 0) {
-            // yes, so return the specified group
-            matcher.find();
-            return matcher.group(idx);
-        } else {
-            // not using groups, so return the nth
-            // occurrence of the pattern
+    public static Object getAt(Matcher matcher, int idx) {
+        try {
+            int count = getCount(matcher);
+            if (idx < -count || idx >= count) {
+                throw new IndexOutOfBoundsException("index is out of range " + (-count) + ".." + (count - 1) + " (index = " + idx + ")");
+            }
+            idx = normaliseIndex(idx, count);
             matcher.reset();
             for (int i = 0; i <= idx; i++) {
                 matcher.find();
             }
-            return matcher.group();
+
+            if (hasGroup(matcher)) {
+                // are we using groups?
+                // yes, so return the specified group as list
+                ArrayList list = new ArrayList(matcher.groupCount());
+                for (int i = 0; i <= matcher.groupCount(); i++) {
+                    list.add(matcher.group(i));
+                }
+                return list;
+            } else {
+                // not using groups, so return the nth
+                // occurrence of the pattern
+                return matcher.group();
+            }
         }
+        catch (IllegalStateException ex) {
+            return null;
+        }
+    }
+
+    /**
+     * Set the position of the given Matcher to the given index.
+     *
+     * @param matcher a Matcher
+     * @param idx the index number
+     */
+    public static void setIndex(Matcher matcher, int idx) {
+        int count = getCount(matcher);
+        if (idx < -count || idx >= count) {
+            throw new IndexOutOfBoundsException("index is out of range " + (-count) + ".." + (count - 1) + " (index = " + idx + ")");
+        }
+        if (idx == 0) {
+            matcher.reset();
+        }
+        else if (idx > 0) {
+            matcher.reset();
+            for (int i = 0; i < idx; i++) {
+                matcher.find();
+            }
+        }
+        else if (idx < 0) {
+            matcher.reset();
+            idx += getCount(matcher);
+            for (int i = 0; i < idx; i++) {
+                matcher.find();
+            }
+        }
+    }
+
+    /**
+     * Find the number of Strings matched to the given Matcher.
+     *
+     * @param matcher a Matcher
+     * @return int  the number of Strings matched to the given matcher.
+     */
+    public static int getCount(Matcher matcher) {
+        int counter = 0;
+        matcher.reset();
+        while (matcher.find()) {
+            counter++;
+        }
+        matcher.reset();
+        return counter;
+    }
+
+    /**
+     * Check whether a Matcher contains a group or not.
+     *
+     * @param matcher a Matcher
+     * @return boolean  <code>true</code> if matcher contains at least one group.
+     */
+    public static boolean hasGroup(Matcher matcher) {
+        return matcher.groupCount() > 0;
     }
 
     /**
diff --git a/src/test/UberTestCase.java b/src/test/UberTestCase.java
index 0af6a3dcf1..a13b422f4f 100644
--- a/src/test/UberTestCase.java
+++ b/src/test/UberTestCase.java
@@ -203,6 +203,7 @@ public class UberTestCase extends TestCase {
         suite.addTestSuite(PropertyWithoutDotTest.class);
         suite.addTestSuite(RangeTest.class);
         suite.addTestSuite(ReadLineTest.class);
+        suite.addTestSuite(RegExpGroupMatchTest.class);
         suite.addTestSuite(RegularExpressionsTest.class);
         suite.addTestSuite(ReturnTest.class);
         suite.addTestSuite(RodsBooleanBug.class);
diff --git a/src/test/groovy/RegExpGroupMatchTest.groovy b/src/test/groovy/RegExpGroupMatchTest.groovy
new file mode 100644
index 0000000000..38c46c3ca5
--- /dev/null
+++ b/src/test/groovy/RegExpGroupMatchTest.groovy
@@ -0,0 +1,100 @@
+/**
+ * Test for fixing the Jira issue GROOVY-1000
+ *
+ *    Fix an infinite loop when getting after group matching in regular expression.
+ *    Graham Miller has given this idea.
+ *
+ * @author Pilho Kim
+ * @version $Revision$
+ */
+
+import java.util.regex.Matcher
+import java.util.regex.Pattern
+
+class RegExpGroupMatchTest extends GroovyTestCase {
+
+    void testFirst() {
+        assert "cheesecheese" =~ "cheese"
+        assert "cheesecheese" =~ /cheese/
+        assert "cheese" == /cheese/   /*they are both string syntaxes*/
+    }
+
+    void testSecond() {
+        // Lets create a regex Pattern
+        def pattern = ~/foo/
+        assert pattern instanceof Pattern
+        assert pattern.matcher("foo").matches()
+    }
+
+    void testThird() {
+        // Lets create a Matcher
+        def matcher = "cheesecheese" =~ /cheese/
+        assert matcher instanceof Matcher
+
+        def answer = matcher.replaceAll("edam")
+        println answer
+    }
+
+    void testFourth() {
+        // Lets do some replacement
+        def cheese = ("cheesecheese" =~ /cheese/).replaceFirst("nice")
+        assert cheese == "nicecheese"
+    }
+
+    void testFifth() {
+        // Group demo
+        def matcher = "\$abc." =~ "\\\$(.*)\\."
+        matcher.matches();                   // must be invoked
+        assert matcher.group(1) == "abc"     // is one, not zero
+        // assert matcher[1] == "abc"     // This has worked only before jsr-03-release
+        println (matcher[0])
+        assert matcher[0] == ["\$abc.", "abc"]
+        assert matcher[0][1] == "abc"
+    }
+
+    void testSixth() {
+        // Group demo
+        // Avoid having to double all the backslash escaping characters.
+        def matcher = "\$abc." =~ /\$(.*)\./    // no need to double-escape!
+        assert "\\\$(.*)\\." == /\$(.*)\./
+        matcher.matches();                      // must be invoked
+        assert matcher.group(1) == "abc"        // is one, not zero
+        // assert matcher[1] == "abc"     // This has worked only before jsr-03-release
+        println (matcher[0])
+        assert matcher[0] == ["\$abc.", "abc"]
+        assert matcher[0][1] == "abc"
+    }
+
+    // Test no group match.
+    void testNoGroupMatcherAndGet() {
+        def p = /ab[d|f]/
+        def m = "abcabdabeabf" =~ p 
+
+        for (i in 0..<m.count) { 
+            println( "m.groupCount() = " + m.groupCount())
+            println( "  " + i + ": " + m[i] )   // m[i] is a String
+        }
+    }
+
+    // Test group matches.
+    void testGroupMatcherAndGet() {
+        def p = /(?:ab([c|d|e|f]))/
+        def m = "abcabdabeabf" =~ p 
+
+        for (i in 0..<m.count) { 
+            println( "m.groupCount() = " + m.groupCount())
+            println( "  " + i + ": " + m[i] )   // m[i] is a String
+        }
+    }
+
+    // Test group matches.
+    void testAnotherGroupMatcherAndGet() {
+        def m = "abcabdabeabfabxyzabx" =~ /(?:ab([d|x-z]+))/
+
+        m.count.times { 
+            println( "m.groupCount() = " + m.groupCount())
+            println( "  " + it + ": " + m[it] )   // m[it] is a String
+        }
+    }
+}
+
