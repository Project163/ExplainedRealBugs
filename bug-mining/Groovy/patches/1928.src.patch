diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index f3414d680f..2460292ca5 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -290,18 +290,8 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
      */
     private boolean isSkippedInnerClass(AnnotatedNode node) {
         if (!(node instanceof InnerClassNode)) return false;
-        ClassNode outerClass = ((InnerClassNode) node).getOuterClass();
-        // inner.getEnclosingMethod() returns null, so we must perform a "dirty" check based on line numbers to figure
-        // out if the class was created in a skipped method node
-        List<MethodNode> methods = new LinkedList<MethodNode>();
-        methods.addAll(outerClass.getDeclaredMethodsMap().values());
-        methods.addAll(outerClass.getDeclaredConstructors());
-        for (MethodNode mn : methods) {
-            if (mn.getLineNumber()>0 && mn.getLineNumber()<=node.getLineNumber() && mn.getLastLineNumber()>=node.getLastLineNumber()) {
-                return isSkipMode(mn);
-            }
-        }
-        return false;
+        MethodNode enclosingMethod = ((InnerClassNode) node).getEnclosingMethod();
+        return enclosingMethod != null && isSkipMode(enclosingMethod);
     }
 
     @Override
