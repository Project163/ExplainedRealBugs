diff --git a/src/main/java/org/codehaus/groovy/transform/sc/StaticCompilationVisitor.java b/src/main/java/org/codehaus/groovy/transform/sc/StaticCompilationVisitor.java
index ee7f9275e9..758731783b 100644
--- a/src/main/java/org/codehaus/groovy/transform/sc/StaticCompilationVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/sc/StaticCompilationVisitor.java
@@ -38,6 +38,7 @@ import org.codehaus.groovy.ast.expr.BinaryExpression;
 import org.codehaus.groovy.ast.expr.ClosureListExpression;
 import org.codehaus.groovy.ast.expr.ConstructorCallExpression;
 import org.codehaus.groovy.ast.expr.Expression;
+import org.codehaus.groovy.ast.expr.LambdaExpression;
 import org.codehaus.groovy.ast.expr.MethodCallExpression;
 import org.codehaus.groovy.ast.expr.PropertyExpression;
 import org.codehaus.groovy.ast.stmt.EmptyStatement;
@@ -67,6 +68,7 @@ import static org.apache.groovy.ast.tools.AnnotatedNodeUtils.hasAnnotation;
 import static org.codehaus.groovy.ast.ClassHelper.LIST_TYPE;
 import static org.codehaus.groovy.ast.ClassHelper.OBJECT_TYPE;
 import static org.codehaus.groovy.ast.ClassHelper.int_TYPE;
+import static org.codehaus.groovy.ast.ClassHelper.isFunctionalInterface;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.args;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.assignS;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.attrX;
@@ -94,9 +96,11 @@ import static org.codehaus.groovy.transform.sc.StaticCompilationMetadataKeys.STA
 import static org.codehaus.groovy.transform.stc.StaticTypesMarker.DIRECT_METHOD_CALL_TARGET;
 import static org.codehaus.groovy.transform.stc.StaticTypesMarker.DYNAMIC_RESOLUTION;
 import static org.codehaus.groovy.transform.stc.StaticTypesMarker.INITIAL_EXPRESSION;
+import static org.codehaus.groovy.transform.stc.StaticTypesMarker.PARAMETER_TYPE;
 import static org.codehaus.groovy.transform.stc.StaticTypesMarker.PV_FIELDS_ACCESS;
 import static org.codehaus.groovy.transform.stc.StaticTypesMarker.PV_FIELDS_MUTATION;
 import static org.codehaus.groovy.transform.stc.StaticTypesMarker.PV_METHODS_ACCESS;
+import static org.codehaus.groovy.transform.trait.TraitASTTransformation.POST_TYPECHECKING_REPLACEMENT;
 import static org.objectweb.asm.Opcodes.ACC_PUBLIC;
 import static org.objectweb.asm.Opcodes.ACC_STATIC;
 import static org.objectweb.asm.Opcodes.ACC_SYNTHETIC;
@@ -275,6 +279,15 @@ public class StaticCompilationVisitor extends StaticTypeCheckingVisitor {
         }
     }
 
+    @Override
+    public void visitLambdaExpression(final LambdaExpression expression) {
+        super.visitLambdaExpression(expression);
+        // GROOVY-11256: static compiler uses lambda factory not proxy generator
+        if (isFunctionalInterface(expression.getNodeMetaData(PARAMETER_TYPE))) {
+            expression.removeNodeMetaData(POST_TYPECHECKING_REPLACEMENT); // for trait: lambda.rehydrate($self,$self,$self)
+        }
+    }
+
     @Override
     public void visitPropertyExpression(final PropertyExpression expression) {
         super.visitPropertyExpression(expression);
diff --git a/src/test/groovy/bugs/Groovy7797Bug.groovy b/src/test/groovy/bugs/Groovy7797Bug.groovy
deleted file mode 100644
index afdef3a858..0000000000
--- a/src/test/groovy/bugs/Groovy7797Bug.groovy
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one
- *  or more contributor license agreements.  See the NOTICE file
- *  distributed with this work for additional information
- *  regarding copyright ownership.  The ASF licenses this file
- *  to you under the Apache License, Version 2.0 (the
- *  "License"); you may not use this file except in compliance
- *  with the License.  You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing,
- *  software distributed under the License is distributed on an
- *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- *  KIND, either express or implied.  See the License for the
- *  specific language governing permissions and limitations
- *  under the License.
- */
-package groovy.bugs
-
-import groovy.test.GroovyTestCase
-
-class Groovy7797Bug extends GroovyTestCase {
-    void test() {
-        new GroovyShell().evaluate('''
-trait MyTrait {
-    void greeter() {
-        { ->doGreeting("hi") }.call()
-        //doGreeting("hi")
-    }
-
-    private void doGreeting(String message) { println message }
-}
-
-class MyClass implements MyTrait {}
-new MyClass().greeter()
-''')
-    }
-}
-
diff --git a/src/test/groovy/bugs/Groovy8127Bug.groovy b/src/test/groovy/bugs/Groovy8127Bug.groovy
deleted file mode 100644
index 842390eba3..0000000000
--- a/src/test/groovy/bugs/Groovy8127Bug.groovy
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one
- *  or more contributor license agreements.  See the NOTICE file
- *  distributed with this work for additional information
- *  regarding copyright ownership.  The ASF licenses this file
- *  to you under the Apache License, Version 2.0 (the
- *  "License"); you may not use this file except in compliance
- *  with the License.  You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing,
- *  software distributed under the License is distributed on an
- *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- *  KIND, either express or implied.  See the License for the
- *  specific language governing permissions and limitations
- *  under the License.
- */
-package groovy.bugs
-
-import gls.CompilableTestSupport
-
-class Groovy8127Bug extends CompilableTestSupport {
-    void testTraitWithClosureReferencingField() {
-        assertScript """
-        trait BarTrait {
-            String result = ''
-            public final Runnable bar = { result = 'changeme' } as Runnable
-            void doRun() { bar.run() }
-        }
-
-        class Bar implements BarTrait {}
-
-        def b = new Bar()
-        b.doRun()
-        assert b.result == 'changeme'
-        """
-    }
-
-    void testTraitWithCompileStaticAndCoercedClosure() {
-        shouldCompile """
-        @groovy.transform.CompileStatic
-        trait FooTrait {
-            public final Runnable foo = { println new Date() } as Runnable
-            void doRun() { foo.run() }
-        }
-
-        class Foo implements FooTrait { }
-
-        new Foo().doRun()
-        """
-    }
-}
diff --git a/src/test/groovy/transform/stc/BugsSTCTest.groovy b/src/test/groovy/transform/stc/BugsSTCTest.groovy
index 38797c69c4..ffffe02cf5 100644
--- a/src/test/groovy/transform/stc/BugsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/BugsSTCTest.groovy
@@ -161,40 +161,6 @@ class BugsSTCTest extends StaticTypeCheckingTestCase {
         '''
     }
 
-    // GROOVY-10106
-    void testCallStaticOrPrivateMethodInTraitFieldInitializer() {
-        ['private', 'static', 'private static'].each { mods ->
-            assertScript """
-                class C {
-                    String s
-                }
-                trait T {
-                    final C c = new C().tap {
-                        config(it)
-                    }
-                    $mods void config(C c) {
-                        c.s = 'x'
-                    }
-                }
-                class U implements T {
-                }
-                def c = new U().c
-                assert c.s == 'x'
-            """
-        }
-
-        shouldFailWithMessages '''
-            trait T {
-                def obj = new Object().tap {
-                    config(it)
-                }
-                static void config(String s) {
-                }
-            }
-        ''',
-        'Cannot find matching method T$Trait$Helper#config(java.lang.Class, java.lang.Object)'
-    }
-
     void testGroovy5444() {
         assertScript '''
             def millis = { System.currentTimeMillis() }
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7242.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7242.groovy
deleted file mode 100644
index 78f4b78b59..0000000000
--- a/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7242.groovy
+++ /dev/null
@@ -1,182 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one
- *  or more contributor license agreements.  See the NOTICE file
- *  distributed with this work for additional information
- *  regarding copyright ownership.  The ASF licenses this file
- *  to you under the Apache License, Version 2.0 (the
- *  "License"); you may not use this file except in compliance
- *  with the License.  You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing,
- *  software distributed under the License is distributed on an
- *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- *  KIND, either express or implied.  See the License for the
- *  specific language governing permissions and limitations
- *  under the License.
- */
-package org.codehaus.groovy.classgen.asm.sc.bugs
-
-import groovy.transform.stc.StaticTypeCheckingTestCase
-import org.codehaus.groovy.classgen.asm.sc.StaticCompilationTestSupport
-
-final class Groovy7242 extends StaticTypeCheckingTestCase implements StaticCompilationTestSupport {
-
-    void testWriteTraitPropertyFromTraitClosure() {
-        assertScript '''
-            trait T {
-                void p() {
-                    [1].each { x = it }
-                }
-                int x
-            }
-
-            class C implements T {
-            }
-
-            def c = new C()
-            c.p()
-            assert c.x == 1
-        '''
-    }
-
-    void testCallTraitMethodFromTraitClosure() {
-        assertScript '''
-            trait T {
-                def f() {
-                    ['a'].collect { String s -> g(s) }
-                }
-
-                String g(String s) {
-                    s.toUpperCase()
-                }
-            }
-
-            class C implements T {
-            }
-
-            def c = new C()
-            assert c.f() == ['A']
-        '''
-    }
-
-    void testCallTraitMethodFromTraitClosure_ImplicitParameter() {
-        assertScript '''
-            trait T {
-                def f() {
-                    ['a'].collect { g(it) }
-                }
-
-                String g(String s) {
-                    s.toUpperCase()
-                }
-            }
-
-            class C implements T {
-            }
-
-            def c = new C()
-            assert c.f() == ['A']
-        '''
-    }
-
-    // GROOVY-7456
-    void testCallPrivateTraitMethodFromTraitClosure() {
-        assertScript '''
-            trait T {
-                def f() {
-                    ['a'].collect { String s -> g(s) }
-                }
-
-                private String g(String s) {
-                    s.toUpperCase()
-                }
-            }
-
-            class C implements T {
-            }
-
-            def c = new C()
-            assert c.f() == ['A']
-        '''
-    }
-
-    // GROOVY-7512
-    void testCallTraitMethodFromTraitClosureInMapConstructor() {
-        assertScript '''
-            class Foo {
-                Closure bar
-            }
-
-            trait T {
-                Foo getFoo() {
-                    new Foo(bar: { ->
-                        baz 'xyz' // ClassCastException: java.lang.Class cannot be cast to T
-                    })
-                }
-                def baz(text) {
-                    text
-                }
-            }
-
-            class C implements T {
-            }
-
-            Foo foo = new C().foo
-            assert foo.bar.call() == 'xyz'
-        '''
-    }
-
-    // GROOVY-9586
-    void testDelegateVsOwnerMethodFromTraitClosure1() {
-        assertScript '''
-            class C {
-                def m(@DelegatesTo(strategy=Closure.DELEGATE_ONLY, value=C) Closure<?> block) {
-                    block.setResolveStrategy(Closure.OWNER_ONLY)
-                    block.setDelegate(this)
-                    return block.call()
-                }
-                def x() { 'C' }
-            }
-
-            trait T {
-                def test() {
-                    new C().m { -> x() } // "x" must come from delegate
-                }
-                def x() { 'T' }
-            }
-
-            class U implements T {
-            }
-
-            assert new U().test() == 'C'
-        '''
-    }
-
-    // GROOVY-9586
-    void testDelegateVsOwnerMethodFromTraitClosure2() {
-        assertScript '''
-            class C {
-                def m(@DelegatesTo(strategy=Closure.OWNER_ONLY, type='Void') Closure<?> block) {
-                    block.setResolveStrategy(Closure.OWNER_ONLY)
-                    block.setDelegate(null)
-                    return block.call()
-                }
-                def x() { 'C' }
-            }
-
-            trait T {
-                def test() {
-                    new C().m { -> x() } // "x" must come from owner
-                }
-                def x() { 'T' }
-            }
-
-            class U implements T {
-            }
-
-            assert new U().test() == 'T'
-        '''
-    }
-}
diff --git a/src/test/org/codehaus/groovy/transform/traitx/TraitASTTransformationTest.groovy b/src/test/org/codehaus/groovy/transform/traitx/TraitASTTransformationTest.groovy
index ad19c8a223..c7199402c0 100644
--- a/src/test/org/codehaus/groovy/transform/traitx/TraitASTTransformationTest.groovy
+++ b/src/test/org/codehaus/groovy/transform/traitx/TraitASTTransformationTest.groovy
@@ -251,23 +251,6 @@ final class TraitASTTransformationTest {
         '''
     }
 
-    @Test
-    void testClosureExpressionInTrait() {
-        assertScript shell, '''
-            trait GreetingObject {
-                String greeting = 'Welcome!'
-                Closure greeter() {
-                    return { -> greeting }
-                }
-            }
-            class Hello implements GreetingObject {}
-            def hello = new Hello()
-            def greeter = hello.greeter()
-            assert greeter.thisObject.is(hello)
-            assert greeter() == 'Welcome!'
-        '''
-    }
-
     @Test
     void testUpdatePropertyFromSelf() {
         assertScript shell, '''
@@ -859,36 +842,6 @@ final class TraitASTTransformationTest {
         '''
     }
 
-    @Test
-    void testClosureInsideTrait() {
-        assertScript shell, '''
-            trait Doubler {
-                int foo(int x) {
-                    { -> 2*x }.call()
-                }
-            }
-            class Foo implements Doubler {}
-            def f = new Foo()
-            assert f.foo(4) == 8
-        '''
-    }
-
-    @Test
-    void testClosureInsideTraitAccessingProperty() {
-        assertScript shell, '''
-            trait Doubler {
-                int x
-                int foo() {
-                    { -> 2*x }.call()
-                }
-            }
-            class Foo implements Doubler {}
-            def f = new Foo()
-            f.x = 4
-            assert f.foo() == 8
-        '''
-    }
-
     @Test
     void testThisDotClassInTrait() {
         assertScript shell, '''
diff --git a/src/test/org/codehaus/groovy/transform/traitx/TraitWithClosureOrLambda.groovy b/src/test/org/codehaus/groovy/transform/traitx/TraitWithClosureOrLambda.groovy
new file mode 100644
index 0000000000..7bc42106cf
--- /dev/null
+++ b/src/test/org/codehaus/groovy/transform/traitx/TraitWithClosureOrLambda.groovy
@@ -0,0 +1,387 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package org.codehaus.groovy.transform.traitx
+
+import org.junit.Test
+
+import static groovy.test.GroovyAssert.assertScript
+import static groovy.test.GroovyAssert.shouldFail
+
+final class TraitWithClosureOrLambda {
+
+    private final GroovyShell shell = GroovyShell.withConfig {
+        ast groovy.transform.CompileStatic
+    }
+
+    @Test
+    void testTraitClosure1() {
+        assertScript shell, '''
+            trait T {
+                int f(int x) {
+                    def impl = { -> 2*x }
+                    impl.call()
+                }
+            }
+            class C implements T {
+            }
+
+            assert new C().f(4) == 8
+        '''
+
+        assertScript shell, '''
+            trait T {
+                int f(int x) {
+                    def impl = () -> { 2*x }
+                    impl.call()
+                }
+            }
+            class C implements T {
+            }
+
+            assert new C().f(4) == 8
+        '''
+    }
+
+    @Test
+    void testTraitClosure2() {
+        assertScript shell, '''
+            trait T {
+                int x
+                int f() {
+                    def impl = { -> 2*x }
+                    impl.call()
+                }
+            }
+            class C implements T {
+            }
+
+            assert new C(x: 4).f() == 8
+        '''
+
+        assertScript shell, '''
+            trait T {
+                int x
+                int f() {
+                    def impl = () -> { 2*x }
+                    impl.call()
+                }
+            }
+            class C implements T {
+            }
+
+            assert new C(x: 4).f() == 8
+        '''
+    }
+
+    @Test
+    void testTraitClosure3() {
+        assertScript shell, '''
+            trait T {
+                final String greeting = 'Welcome!'
+                Closure greeter() {
+                    return { -> greeting }
+                }
+            }
+            class C implements T {
+            }
+
+            def c = new C()
+            def greeter = c.greeter()
+            assert greeter.thisObject.is(c)
+            assert greeter.call() == 'Welcome!'
+        '''
+
+        assertScript shell, '''
+            trait T {
+                final String greeting = 'Welcome!'
+                Closure greeter() {
+                    return () -> greeting
+                }
+            }
+            class C implements T {
+            }
+
+            def c = new C()
+            def greeter = c.greeter()
+            assert greeter.thisObject.is(c)
+            assert greeter.call() == 'Welcome!'
+        '''
+    }
+
+    // GROOVY-7242
+    @Test
+    void testWriteTraitPropertyFromTraitClosure() {
+        assertScript shell, '''
+            trait T {
+                int x
+                void p() {
+                    [1].each { x = it }
+                }
+            }
+            class C implements T {
+            }
+
+            def c = new C()
+            c.p()
+            assert c.x == 1
+        '''
+    }
+
+    // GROOVY-7242
+    @Test
+    void testInvokeTraitMethodsFromTraitClosure() {
+        assertScript shell, '''
+            trait T {
+                def f() {
+                    ['a'].collect { String s -> g(s) }
+                }
+                String g(String s) {
+                    s.toUpperCase()
+                }
+            }
+            class C implements T {
+            }
+
+            def c = new C()
+            assert c.f() == ['A']
+        '''
+
+        assertScript shell, '''
+            trait T {
+                def f() {
+                    ['a'].collect { g(it) }
+                }
+                String g(String s) {
+                    s.toUpperCase()
+                }
+            }
+            class C implements T {
+            }
+
+            def c = new C()
+            assert c.f() == ['A']
+        '''
+    }
+
+    // GROOVY-7456,  GROOVY-7797
+    @Test
+    void testInvokePrivateTraitMethodFromTraitClosure() {
+        assertScript shell, '''
+            trait T {
+                def f() {
+                    ['a'].collect { String s -> g(s) }
+                }
+                private String g(String s) {
+                    s.toUpperCase()
+                }
+            }
+            class C implements T {
+            }
+
+            def c = new C()
+            assert c.f() == ['A']
+        '''
+    }
+
+    // GROOVY-7512
+    @Test
+    void testInvokeTraitMethodFromTraitClosureInMapConstructor() {
+        assertScript shell, '''
+            class Foo {
+                Closure bar
+            }
+            trait T {
+                Foo getFoo() {
+                    new Foo(bar: { ->
+                        baz 'xyz' // ClassCastException: java.lang.Class cannot be cast to T
+                    })
+                }
+                def baz(text) {
+                    text
+                }
+            }
+            class C implements T {
+            }
+
+            Foo foo = new C().foo
+            assert foo.bar.call() == 'xyz'
+        '''
+    }
+
+    // GROOVY-8127
+    @Test
+    void testCoercedClosureField() {
+        assertScript shell, '''
+            trait T {
+                public final Runnable foo = { println new Date() } as Runnable
+                void doRun() { foo.run() }
+            }
+            class C implements T {
+            }
+
+            new C().doRun()
+        '''
+    }
+
+    // GROOVY-8127
+    @Test
+    void testCoercedClosureFieldWritesOtherField() {
+        assertScript shell, '''
+            trait T {
+                String result = ''
+                public final Runnable bar = { result = 'changeme' } as Runnable
+                void doRun() { bar.run() }
+            }
+            class C implements T {
+            }
+
+            def c = new C(); c.doRun()
+            assert c.result == 'changeme'
+        '''
+    }
+
+    // GROOVY-9586
+    @Test
+    void testDelegateVsOwnerMethodFromTraitClosure1() {
+        assertScript shell, '''
+            class C {
+                def m(@DelegatesTo(strategy=Closure.DELEGATE_ONLY, value=C) Closure<?> block) {
+                    block.setResolveStrategy(Closure.OWNER_ONLY)
+                    block.setDelegate(this)
+                    return block.call()
+                }
+                def x() { 'C' }
+            }
+            trait T {
+                def test() {
+                    new C().m { -> x() } // "x" must come from delegate
+                }
+                def x() { 'T' }
+            }
+            class U implements T {
+            }
+
+            assert new U().test() == 'C'
+        '''
+    }
+
+    // GROOVY-9586
+    @Test
+    void testDelegateVsOwnerMethodFromTraitClosure2() {
+        assertScript shell, '''
+            class C {
+                def m(@DelegatesTo(strategy=Closure.OWNER_ONLY, type='Void') Closure<?> block) {
+                    block.setResolveStrategy(Closure.OWNER_ONLY)
+                    block.setDelegate(null)
+                    return block.call()
+                }
+                def x() { 'C' }
+            }
+            trait T {
+                def test() {
+                    new C().m { -> x() } // "x" must come from owner
+                }
+                def x() { 'T' }
+            }
+            class U implements T {
+            }
+
+            assert new U().test() == 'T'
+        '''
+    }
+
+    // GROOVY-10106
+    @Test
+    void testCallStaticOrPrivateMethodInTraitFieldInitializer() {
+        ['private', 'static', 'private static'].each { mods ->
+            assertScript shell, """
+                class C {
+                    String s
+                }
+                trait T {
+                    final C c = new C().tap {
+                        config(it)
+                    }
+                    $mods void config(C c) {
+                        c.s = 'x'
+                    }
+                }
+                class U implements T {
+                }
+
+                def c = new U().c
+                assert c.s == 'x'
+            """
+        }
+
+        def err = shouldFail shell, '''
+            trait T {
+                def obj = new Object().tap {
+                    config(it)
+                }
+                static void config(String s) {
+                }
+            }
+        '''
+        assert err.message.contains('Cannot find matching method T$Trait$Helper#config')
+    }
+
+    // GROOVY-11265
+    @Test
+    void testTraitFunctionalInterfaceLambda1() {
+        assertScript shell, '''import java.util.function.Function
+            trait T {
+                abstract int f(int x)
+                Function<Integer,Integer> times(int multiplicand) {
+                    return (multiplier) -> { multiplier * multiplicand }
+                }
+            }
+            class C implements T {
+                @Override
+                int f(int x) {
+                    times(2).apply(x)
+                }
+            }
+
+            assert new C().f(8) == 16
+        '''
+    }
+
+    // GROOVY-11265
+    @Test
+    void testTraitFunctionalInterfaceLambda2() {
+        assertScript shell, '''import java.util.function.Function
+            trait T {
+                final int xx = 1
+                abstract int f(int x)
+                Function<Integer,Integer> times(int multiplicand) {
+                    return (multiplier) -> (multiplier + xx) * multiplicand;
+                }
+            }
+            class C implements T {
+                @Override
+                int f(int x) {
+                    times(2).apply(x)
+                }
+            }
+
+            assert new C().f(8) == 18
+        '''
+    }
+}
