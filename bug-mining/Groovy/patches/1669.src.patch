diff --git a/src/main/groovy/lang/MetaClassImpl.java b/src/main/groovy/lang/MetaClassImpl.java
index 9d16887ee2..f29293bc53 100644
--- a/src/main/groovy/lang/MetaClassImpl.java
+++ b/src/main/groovy/lang/MetaClassImpl.java
@@ -1168,9 +1168,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
              return cacheEntry.method;
         }
 
-        cacheEntry = new MetaMethodIndex.CacheEntry ();
-        cacheEntry.params = params;
-        cacheEntry.method = (MetaMethod) chooseMethod(e.name, methods, params);
+        cacheEntry = new MetaMethodIndex.CacheEntry (params, (MetaMethod) chooseMethod(e.name, methods, params));
         e.cachedMethod = cacheEntry;
         return cacheEntry.method;
     }
@@ -1189,11 +1187,9 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
             if (method!=null) return method;
         }
 
-        cacheEntry = new MetaMethodIndex.CacheEntry ();
         final Class[] classes = MetaClassHelper.convertToTypeArray(arguments);
-        cacheEntry.params = classes;
-        cacheEntry.method = (MetaMethod) chooseMethod(e.name, e.methodsForSuper, classes);
-        if (cacheEntry.method.isAbstract()) cacheEntry.method = null;
+        MetaMethod method = (MetaMethod) chooseMethod(e.name, e.methodsForSuper, classes);
+        cacheEntry = new MetaMethodIndex.CacheEntry (classes, method.isAbstract()?null:method);
 
         e.cachedMethodForSuper = cacheEntry;
 
@@ -1215,11 +1211,9 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
             if (method!=null) return method;
         }
 
-        cacheEntry = new MetaMethodIndex.CacheEntry ();
         final Class[] classes = MetaClassHelper.convertToTypeArray(arguments);
-        cacheEntry.params = classes;
-        cacheEntry.method = (MetaMethod) chooseMethod(e.name, methods, classes);
-        
+        cacheEntry = new MetaMethodIndex.CacheEntry (classes, (MetaMethod) chooseMethod(e.name, methods, classes));
+
         e.cachedMethod = cacheEntry;
         
         return cacheEntry.method;
@@ -1249,11 +1243,9 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
                  return cacheEntry.method;
             }
 
-            cacheEntry = new MetaMethodIndex.CacheEntry ();
             final Class[] classes = MetaClassHelper.convertToTypeArray(arguments);
-            cacheEntry.params = classes;
-            cacheEntry.method = pickStaticMethod(methodName, classes);
-            
+            cacheEntry = new MetaMethodIndex.CacheEntry (classes, pickStaticMethod(methodName, classes));
+
             e.cachedStaticMethod = cacheEntry;
             
             return cacheEntry.method;
diff --git a/src/main/org/codehaus/groovy/runtime/metaclass/MetaMethodIndex.java b/src/main/org/codehaus/groovy/runtime/metaclass/MetaMethodIndex.java
index 04881d6cd7..266d07e491 100644
--- a/src/main/org/codehaus/groovy/runtime/metaclass/MetaMethodIndex.java
+++ b/src/main/org/codehaus/groovy/runtime/metaclass/MetaMethodIndex.java
@@ -44,8 +44,13 @@ public class MetaMethodIndex {
     }
 
     public static class CacheEntry {
-        public Class [] params;
-        public MetaMethod method;
+        final public Class [] params;
+        final public MetaMethod method;
+
+        public CacheEntry(final Class[] params, final MetaMethod method) {
+            this.params = params;
+            this.method = method;
+        }
     }
 
     public static class Entry {
diff --git a/src/test/groovy/bugs/Groovy5185Bug.groovy b/src/test/groovy/bugs/Groovy5185Bug.groovy
new file mode 100644
index 0000000000..8e974d29df
--- /dev/null
+++ b/src/test/groovy/bugs/Groovy5185Bug.groovy
@@ -0,0 +1,30 @@
+package groovy.bugs
+
+class Groovy5185Bug extends GroovyTestCase {
+    void testShouldNotThrowMethodMissingException() {
+        assertScript '''
+            enum Foo {
+                foo,
+                bar,
+                baz
+            }
+
+            List<Closure> closures = []
+            5000.times { int index ->
+                closures << {
+                    100.times {
+                        String key = "bar"
+                        Foo f = key as Foo
+                        //Foo f = Foo.valueOf(key)
+                        //Foo f = Enum.valueOf(Foo, key)
+                    }
+                }
+            }
+
+            List<Thread> threads = closures.collect { Thread.start(it) }
+            threads.each { it.join() }
+
+            println('done')
+        '''
+    }
+}
