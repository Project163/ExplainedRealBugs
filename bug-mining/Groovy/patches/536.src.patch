diff --git a/src/main/org/codehaus/groovy/classgen/Verifier.java b/src/main/org/codehaus/groovy/classgen/Verifier.java
index 50973dab2c..0689c54329 100644
--- a/src/main/org/codehaus/groovy/classgen/Verifier.java
+++ b/src/main/org/codehaus/groovy/classgen/Verifier.java
@@ -62,21 +62,32 @@ public class Verifier implements GroovyClassVisitor, Opcodes {
         this.classNode = node;
         
         if ((classNode.getModifiers() & Opcodes.ACC_INTERFACE) >0) {
-            //interfaces have no construcotrs, but this code expects one, 
+            //interfaces have no constructors, but this code expects one,
             //so create a dummy and don't add it to the class node
             ConstructorNode dummy = new ConstructorNode(0,null);
             addInitialization(node, dummy);
             node.visitContents(this);
             return;
         }
-        
+
+        ClassNode[] classNodes = classNode.getInterfaces();
+        List interfaces = new ArrayList();
+        for (int i = 0; i < classNodes.length; i++) {
+            ClassNode classNode = classNodes[i];
+            interfaces.add(classNode.getName());
+        }
+        Set interfaceSet = new HashSet(interfaces);
+        if (interfaceSet.size() != interfaces.size()) {
+            throw new RuntimeParserException("Duplicate interfaces in implements list: " + interfaces, classNode);
+        }
+
         addDefaultParameterMethods(node);
         addDefaultParameterConstructors(node);
 
         if (!node.isDerivedFromGroovyObject()) {
             node.addInterface(ClassHelper.make(GroovyObject.class));
 
-            // lets add a new field for the metaclass
+            // let's add a new field for the metaclass
             StaticMethodCallExpression initMetaClassCall =
                 new StaticMethodCallExpression(
                     ClassHelper.make(ScriptBytecodeAdapter.class),
@@ -108,7 +119,7 @@ public class Verifier implements GroovyClassVisitor, Opcodes {
 
             // @todo we should check if the base class implements the invokeMethod method
 
-            // lets add the invokeMethod implementation
+            // let's add the invokeMethod implementation
             ClassNode superClass = node.getSuperClass();
             boolean addDelegateObject =
                 (node instanceof InnerClassNode && superClass.equals(ClassHelper.CLOSURE_TYPE))
@@ -297,7 +308,7 @@ public class Verifier implements GroovyClassVisitor, Opcodes {
             else if (statement instanceof BlockStatement) {
                 BlockStatement block = (BlockStatement) statement;
 
-                // lets copy the list so we create a new block
+                // let's copy the list so we create a new block
                 List list = new ArrayList(block.getStatements());
                 if (!list.isEmpty()) {
                     int idx = list.size() - 1;
diff --git a/src/test/groovy/AbstractClassAndInterfaceTest.groovy b/src/test/groovy/AbstractClassAndInterfaceTest.groovy
index 5689ecadeb..fab774c162 100644
--- a/src/test/groovy/AbstractClassAndInterfaceTest.groovy
+++ b/src/test/groovy/AbstractClassAndInterfaceTest.groovy
@@ -1,19 +1,9 @@
 package groovy
 
 import org.codehaus.groovy.control.CompilationFailedException
+import gls.CompilableTestSupport
 
-class AbstractClassAndInterfaceTest extends GroovyTestCase {
-
-	def shouldNotCompile(String script) {
-	  try {
-        GroovyShell shell = new GroovyShell()
-        shell.parse(script, getTestClassName())
-      } catch (CompilationFailedException cfe) {
-        assert true
-        return
-      }
-      fail("the compilation succeeded but should have failed")
-	}
+class AbstractClassAndInterfaceTest extends CompilableTestSupport {
 
 	void testInterface() {
     	def shell = new GroovyShell()
@@ -205,4 +195,15 @@ class AbstractClassAndInterfaceTest extends GroovyTestCase {
 	   """
 	   shell.evaluate(text)
 	}
+
+	void testImplementsDuplicateInterface() {
+        shouldCompile """
+        interface I {}
+        class C implements I {}
+        """
+        shouldNotCompile """
+        interface I {}
+        class C implements I, I {}
+        """
+    }
 }
\ No newline at end of file
