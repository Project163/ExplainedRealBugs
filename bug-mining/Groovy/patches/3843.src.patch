diff --git a/src/main/java/groovy/lang/MetaClassImpl.java b/src/main/java/groovy/lang/MetaClassImpl.java
index 63f95d3b20..f26af35cf6 100644
--- a/src/main/java/groovy/lang/MetaClassImpl.java
+++ b/src/main/java/groovy/lang/MetaClassImpl.java
@@ -290,15 +290,10 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
                 propertyMap = classPropertyIndexForSuper.getNotNull(theCachedClass);
                 metaProperty = (MetaProperty) propertyMap.get(name);
                 if (metaProperty == null) {
-                    CachedClass superClass = theCachedClass;
-                    while (superClass != null && superClass != ReflectionCache.OBJECT_CLASS) {
-                        MetaBeanProperty property = findPropertyInClassHierarchy(name, superClass);
-                        if (property != null) {
-                            onSuperPropertyFoundInHierarchy(property);
-                            metaProperty = property;
-                            break;
-                        }
-                        superClass = superClass.getCachedSuperClass();
+                    MetaBeanProperty property = findPropertyInClassHierarchy(name, theCachedClass);
+                    if (property != null) {
+                        onSuperPropertyFoundInHierarchy(property);
+                        metaProperty = property;
                     }
                 }
             }
@@ -333,7 +328,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
     }
 
     /**
-     * Return wether the class represented by this metaclass instance is an instance of the GroovyObject class
+     * Return whether the class represented by this metaclass instance is an instance of the GroovyObject class
      *
      * @return true if this is a groovy class, false otherwise.
      */
@@ -836,25 +831,21 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
      * @param instance      The object the method should be invoked on.
      * @param propertyName  The name of the property to invoke.
      * @param optionalValue The (optional) new value for the property
-     * @param isGetter      Wether the method is a getter
+     * @param isGetter      Whether the method is a getter
      * @return The result of the method invocation.
      */
     public Object invokeMissingProperty(Object instance, String propertyName, Object optionalValue, boolean isGetter) {
-        Class theClass = instance instanceof Class ? (Class) instance : instance.getClass();
-        CachedClass superClass = theCachedClass;
-        while (superClass != null && superClass != ReflectionCache.OBJECT_CLASS) {
-            final MetaBeanProperty property = findPropertyInClassHierarchy(propertyName, superClass);
-            if (property != null) {
-                onSuperPropertyFoundInHierarchy(property);
-                if (!isGetter) {
-                    property.setProperty(instance, optionalValue);
-                    return null;
-                }
-                return property.getProperty(instance);
+        MetaBeanProperty property = findPropertyInClassHierarchy(propertyName, theCachedClass);
+        if (property != null) {
+            onSuperPropertyFoundInHierarchy(property);
+            if (!isGetter) {
+                property.setProperty(instance, optionalValue);
+                return null;
             }
-            superClass = superClass.getCachedSuperClass();
+            return property.getProperty(instance);
         }
-        // got here to property not found, look for getProperty or setProperty overrides
+
+        // look for getProperty or setProperty overrides
         if (isGetter) {
             final Class[] getPropertyArgs = {String.class};
             final MetaMethod method = findMethodInClassHierarchy(instance.getClass(), GET_PROPERTY_METHOD, getPropertyArgs, this);
@@ -892,6 +883,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
             throw iie;
         }
 
+        Class theClass = instance instanceof Class ? (Class) instance : instance.getClass();
         if (instance instanceof Class && theClass != Class.class) {
             final MetaProperty metaProperty = InvokerHelper.getMetaClass(Class.class).hasProperty(instance, propertyName);
             if (metaProperty != null) {
@@ -902,6 +894,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
                 return null;
             }
         }
+
         throw new MissingPropertyExceptionNoStack(propertyName, theClass);
     }
 
@@ -3605,14 +3598,15 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
     }
 
     protected MetaBeanProperty findPropertyInClassHierarchy(String propertyName, CachedClass theClass) {
-        MetaBeanProperty property = null;
-        if (theClass == null)
+        if (theClass == null || theClass == ReflectionCache.OBJECT_CLASS)
             return null;
 
         final CachedClass superClass = theClass.getCachedSuperClass();
         if (superClass == null)
             return null;
 
+        MetaBeanProperty property = null;
+
         MetaClass metaClass = this.registry.getMetaClass(superClass.getTheClass());
         if (metaClass instanceof MutableMetaClass) {
             property = getMetaPropertyFromMutableMetaClass(propertyName, metaClass);
@@ -3627,7 +3621,6 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
             }
         }
         return property;
-
     }
 
     private MetaBeanProperty searchInterfacesForMetaProperty(String propertyName, Class[] interfaces) {
