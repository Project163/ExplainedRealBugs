diff --git a/src/main/groovy/lang/MetaClassImpl.java b/src/main/groovy/lang/MetaClassImpl.java
index 844e546d59..15aa44e0c7 100644
--- a/src/main/groovy/lang/MetaClassImpl.java
+++ b/src/main/groovy/lang/MetaClassImpl.java
@@ -693,7 +693,9 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
                 return methodMissing.invoke(instance, new Object[]{methodName, arguments});
             } catch (InvokerInvocationException iie) {
                 if (methodMissing instanceof ClosureMetaMethod && iie.getCause() instanceof MissingMethodException) {
-                    throw (MissingMethodException) iie.getCause();
+                    MissingMethodException mme =  (MissingMethodException) iie.getCause();
+                    throw new MissingMethodExecutionFailed (mme.getMethod(), mme.getClass(),
+                                                            mme.getArguments(),mme.isStatic(),mme);
                 }
                 throw iie;
             }
diff --git a/src/main/org/codehaus/groovy/runtime/InvokerHelper.java b/src/main/org/codehaus/groovy/runtime/InvokerHelper.java
index d8450da6f3..722b40d1dd 100644
--- a/src/main/org/codehaus/groovy/runtime/InvokerHelper.java
+++ b/src/main/org/codehaus/groovy/runtime/InvokerHelper.java
@@ -20,6 +20,7 @@ import groovy.xml.dom.DOMUtil;
 import org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation;
 import org.codehaus.groovy.runtime.typehandling.IntegerCache;
 import org.codehaus.groovy.runtime.wrappers.PojoWrapper;
+import org.codehaus.groovy.runtime.metaclass.MissingMethodExecutionFailed;
 import org.w3c.dom.Element;
 
 import java.beans.Introspector;
@@ -768,11 +769,14 @@ public class InvokerHelper {
             //else try a statically typed method or a GDK method
             return groovy.getMetaClass().invokeMethod(object, methodName, asArray(arguments));
         } catch (MissingMethodException e) {
-            if (!intercepting && e.getMethod().equals(methodName) && object.getClass() == e.getType()) {
+            if (e instanceof MissingMethodExecutionFailed) {
+                throw (MissingMethodException) e.getCause();
+            } else if (!intercepting && e.getMethod().equals(methodName) && object.getClass() == e.getType()) {
                 // in case there's nothing else, invoke the object's own invokeMethod()
                 return groovy.invokeMethod(methodName, asUnwrappedArray(arguments));
+            } else {
+                throw e;
             }
-            throw e;
         }
     }
 
diff --git a/src/main/org/codehaus/groovy/runtime/ScriptBytecodeAdapter.java b/src/main/org/codehaus/groovy/runtime/ScriptBytecodeAdapter.java
index d5a3b34785..a1da58bd95 100644
--- a/src/main/org/codehaus/groovy/runtime/ScriptBytecodeAdapter.java
+++ b/src/main/org/codehaus/groovy/runtime/ScriptBytecodeAdapter.java
@@ -18,6 +18,7 @@ package org.codehaus.groovy.runtime;
 import groovy.lang.*;
 import org.codehaus.groovy.runtime.metaclass.MissingMethodExceptionNoStack;
 import org.codehaus.groovy.runtime.metaclass.MissingPropertyExceptionNoStack;
+import org.codehaus.groovy.runtime.metaclass.MissingMethodExecutionFailed;
 import org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation;
 import org.codehaus.groovy.runtime.wrappers.GroovyObjectWrapper;
 import org.codehaus.groovy.runtime.wrappers.PojoWrapper;
@@ -75,7 +76,9 @@ public class ScriptBytecodeAdapter {
                 result = receiver.getMetaClass().invokeMethod(senderClass, receiver, messageName, messageArguments, false, true);
             }
         } catch (MissingMethodException e) {
-            if (!intercepting && receiver.getClass() == e.getType() && e.getMethod().equals(messageName)) {
+            if (e instanceof MissingMethodExecutionFailed) {
+                throw e.getCause();
+            } else if (!intercepting && receiver.getClass() == e.getType() && e.getMethod().equals(messageName)) {
                 // in case there's nothing else, invoke the object's own invokeMethod()
                 result = receiver.invokeMethod(messageName, messageArguments);
             } else {
diff --git a/src/main/org/codehaus/groovy/runtime/metaclass/MissingMethodExecutionFailed.java b/src/main/org/codehaus/groovy/runtime/metaclass/MissingMethodExecutionFailed.java
new file mode 100644
index 0000000000..f4f1d27424
--- /dev/null
+++ b/src/main/org/codehaus/groovy/runtime/metaclass/MissingMethodExecutionFailed.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2003-2007 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.codehaus.groovy.runtime.metaclass;
+
+import groovy.lang.MissingMethodException;
+
+/**
+ * A stack less exception used to indicate, that the execution of a missingMethod
+ * method failed with a MissingMethodException. This is used to preven a call to
+ * invokeMethod for GroovyObject implementing classes.
+ */
+public class MissingMethodExecutionFailed extends MissingMethodExceptionNoStack {
+    private Throwable cause;
+    public MissingMethodExecutionFailed(String method, Class type, Object[] arguments, boolean isStatic, Throwable cause) {
+        super(method, type, arguments, isStatic);
+        this.cause = cause;
+    }
+
+    public Throwable getCause() {
+        return cause;
+    }
+}
diff --git a/src/test/groovy/lang/ExpandoMetaClassTest.groovy b/src/test/groovy/lang/ExpandoMetaClassTest.groovy
index 5dfcf0081d..3fe7f75cdc 100644
--- a/src/test/groovy/lang/ExpandoMetaClassTest.groovy
+++ b/src/test/groovy/lang/ExpandoMetaClassTest.groovy
@@ -586,7 +586,52 @@ class ExpandoMetaClassTest extends GroovyTestCase {
             // causing the closure code to select the delegate to call the method
             Closure cl = {m1()}
             cl.delegate = circle
-            assert cl.call()== 1
+            assert cl.call() == 1
+        """
+    }
+
+    void testMissingMethodExceptionThrownFromMissingMethod() {
+        assertScript """
+           class Circle {
+                def invokeMethodInvocations = 0
+                def invokeMethod(String name, Object[] args) {
+                    invokeMethodInvocations++;
+                }
+                def callNonExistingMethod() {
+                  m1()
+                }
+            }
+
+            ExpandoMetaClass emc = new ExpandoMetaClass(Circle.class, false)
+            def exception = new MissingMethodException("m1", Circle, null)
+            emc.methodMissing = {String name, args ->
+                throw exception
+            }
+            emc.initialize()
+
+            Circle circle = new Circle()
+            circle.metaClass = emc
+
+            assert circle.invokeMethodInvocations == 0
+            def gotException=true
+            try {
+               circle.callNonExistingMethod()
+               gotException=false
+            } catch (MissingMethodException mme) {
+               gotException=true
+               assert mme == exception
+            }
+            assert gotException,"MissingMethodException expected, but got something else"
+
+            assert circle.invokeMethodInvocations == 0
+            gotException=true
+            try {
+               circle.m1()
+               gotException=false
+            } catch (MissingMethodException mme) {
+               assert mme == exception
+            }
+            assert gotException,"MissingMethodException expected, but got something else"
         """
     }
 
