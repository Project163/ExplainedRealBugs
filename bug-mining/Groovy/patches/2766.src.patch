diff --git a/subprojects/groovy-templates/src/main/groovy/groovy/text/StreamingTemplateEngine.java b/subprojects/groovy-templates/src/main/groovy/groovy/text/StreamingTemplateEngine.java
index a902b05d81..ceac04b9dc 100644
--- a/subprojects/groovy-templates/src/main/groovy/groovy/text/StreamingTemplateEngine.java
+++ b/subprojects/groovy-templates/src/main/groovy/groovy/text/StreamingTemplateEngine.java
@@ -57,7 +57,7 @@ import java.util.Map;
  * def binding = [
  *   firstname : "Grace",
  *   lastname  : "Hopper",
- *   accepted  : false,
+ *   accepted  : true,
  *   title     : 'Groovy for COBOL programmers'
  * ]
  * def text = '''\
@@ -127,7 +127,7 @@ import java.util.Map;
  * <p>With that being said, viewing the source might still have some value. For this reason the script
  * source is accessible via the template.scriptSource property, i.e.:
  * <pre>
- *     prinltn template.scriptSource
+ *     println template.scriptSource
  * </pre>
  * In the above example.
  * </p>
@@ -141,15 +141,67 @@ public class StreamingTemplateEngine extends TemplateEngine {
     private final ClassLoader parentLoader;
     private static int counter = 1;
 
+    /**
+     * Create a streaming template engine instance using the default class loader
+     */
     public StreamingTemplateEngine() {
         this(StreamingTemplate.class.getClassLoader());
     }
 
+    /**
+     * Create a streaming template engine instance using a custom class loader
+     *
+     * <p>The custom loader is used when parsing the template code</p>
+     *
+     * @param parentLoader The class loader to use when parsing the template code.
+     */
     public StreamingTemplateEngine(ClassLoader parentLoader) {
         this.parentLoader = parentLoader;
     }
 
-    /* (non-Javadoc)
+    /**
+     * <p>Creates a template instance using the template source from the provided Reader.</p>
+     *
+     * <p>The template can be applied repeatedly on different bindings to produce custom
+     * output.</p>
+     *
+     *
+     * <strong>Technical detail</strong><br />
+     * Under the hood the returned template is represented as a four argument
+     * closure where the three first arguments are {@link groovy.lang.Closure#curry curried} in
+     * while generating the template. <br />
+     * <br />
+     * In essence we start with a closure on the form:
+     *
+     * <pre>
+     *   { parentClass, stringSectionList, binding, out ->
+     *      //code generated by parsing the template data
+     *   }                                                                             *
+     * </pre>
+     *
+     * , we then curry in the parentClass and stringSectionList arguments so that the StreamingTemplate
+     * instance returned from 'createTemplate' internally contains a template closure on the form:
+     *
+     * <pre>
+     *   { binding, out ->
+     *      //code generated by parsing the template data
+     *   }                                                                             *
+     * </pre>
+     *
+     * Calling template.make(binding), curries in the 'binding' argument:
+     *
+     * <pre>
+     *   public Writable make(final Map map) {
+     *     final Closure template = this.template.curry(new Object[]{map});
+     *     return (Writable) template;
+     *   }
+     * </pre>
+     *
+     * which only leaves the 'out' argument unbound. The only method on the {@link groovy.lang.Writable writable} interface is
+     * {@link groovy.lang.Writable#writeTo writeTo(Writer out)} so groovy rules about casting a closure to a one-method-interface
+     * apply and the above works. I.e. we return the now one argument closure as the Writable
+     * which can be serialized to System.out, a file, etc according to the Writable interface contract.
+     * </p>
      * @see groovy.text.TemplateEngine#createTemplate(java.io.Reader)
      */
     @Override
@@ -301,7 +353,7 @@ public class StreamingTemplateEngine extends TemplateEngine {
 
             if (traceLine != -1) {
                 int actualLine = precedingSection.lastSourcePosition.row + traceLine - 1;
-                String message = "Template parse error at line " + actualLine + ":\n" + getErrorContext(actualLine);
+                String message = "Template execution error at line " + actualLine + ":\n" + getErrorContext(actualLine);
                 TemplateExecutionException unsanitized = new TemplateExecutionException(actualLine, message, StackTraceUtils.sanitize(e));
                 throw StackTraceUtils.sanitize(unsanitized);
             } else {
@@ -309,9 +361,26 @@ public class StreamingTemplateEngine extends TemplateEngine {
             }
         }
 
+        private int getLinesInSource() throws IOException {
+            int result = 0;
+
+            LineNumberReader reader = null;
+            try {
+                reader = new LineNumberReader(new StringReader(templateSource.toString()));
+                reader.skip(Long.MAX_VALUE);
+                result = reader.getLineNumber();
+            } finally {
+                if (reader != null) {
+                    reader.close();
+                }
+            }
+
+            return result;
+        }
+
         private String getErrorContext(int actualLine) throws IOException {
             int minLine = Math.max(0, actualLine -1);
-            int maxLine = actualLine + 1;
+            int maxLine = Math.min(getLinesInSource(), actualLine + 1);
 
             LineNumberReader r = new LineNumberReader(new StringReader(templateSource.toString()));
             int lineNr;
@@ -575,9 +644,6 @@ public class StreamingTemplateEngine extends TemplateEngine {
          * @param target The target groovy script source we write to
          * @param sourcePosition The reader position in the source stream
          * @param targetPosition The writer position in the target stream
-         * @param lookAhead The lookAhead buffer is here used to store the first non-identifier
-         *                  character located after the identifier (the space after 'bird' in the
-         *                  example above).
          * @return true if a valid dollar preceded identifier was found, false otherwise. More
          *         specifically, returns true if the first character after the dollar sign is
          *         a valid java identifier. Note that the dollar curly syntax is handled by
@@ -730,6 +796,8 @@ public class StreamingTemplateEngine extends TemplateEngine {
             if (errors.size() > 0) {
                 Message firstMessage = errors.get(0);
                 if (firstMessage instanceof SyntaxErrorMessage) {
+                    //System.out.println("Syntax message: " + firstMessage);
+
                     @SuppressWarnings({"ThrowableResultOfMethodCallIgnored"})
                     SyntaxException syntaxException = ((SyntaxErrorMessage) firstMessage).getCause();
                     Position errorPosition = new Position(syntaxException.getLine(), syntaxException.getStartColumn());
@@ -740,7 +808,8 @@ public class StreamingTemplateEngine extends TemplateEngine {
                     //and now use the string section to mangle the line numbers so that they refer to the
                     //appropriate line in the source template data
                     if (precedingSection != null) {
-                        //if the error was thrown on the same row as where the last string section ended, fix column value
+                        //if the error was thrown on the same row as where the last string section
+                        //ended, fix column value
                         offsetPositionFromSection(errorPosition, precedingSection);
                         //the below being true indicates that we had an unterminated ${ or <% sequence and
                         //the column is thus meaningless, we reset it to where the %{ or <% starts to at
@@ -750,7 +819,8 @@ public class StreamingTemplateEngine extends TemplateEngine {
                         }
 
                         String message = mangleExceptionMessage(e.getMessage(), errorPosition);
-                        result = new GroovyRuntimeException(message);
+
+                        result = new TemplateParseException(message, e, errorPosition.row, errorPosition.column);
                     }
                 }
             }
@@ -770,7 +840,7 @@ public class StreamingTemplateEngine extends TemplateEngine {
             for (char c : result.toCharArray()) {
                 if (c == ':') {
                     count++;
-                    if (count == 2) {
+                    if (count == 3) {
                         result = result.substring(index + 2);
                         break;
                     }
@@ -778,7 +848,16 @@ public class StreamingTemplateEngine extends TemplateEngine {
                 index++;
             }
 
-            return "Template parse error '" + result + "' at line " + p.row + ", column " + p.column;
+            String msg = "Template parse error '" + result + "' at line " + p.row + ", column " + p.column;
+            try {
+                msg += "\n" + getErrorContext(p.row);
+
+            } catch (IOException e) {
+                //we opt for not doing anthing here...we just do not get context if
+                //this happens
+            }
+
+            return msg;
         }
 
         private void offsetPositionFromSection(Position p, StringSection s) {
diff --git a/subprojects/groovy-templates/src/main/groovy/groovy/text/TemplateParseException.java b/subprojects/groovy-templates/src/main/groovy/groovy/text/TemplateParseException.java
new file mode 100644
index 0000000000..0a5c5376b7
--- /dev/null
+++ b/subprojects/groovy-templates/src/main/groovy/groovy/text/TemplateParseException.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2003-2013 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package groovy.text;
+
+/**
+ * A custom exception class to flag template parsing errors
+ */
+public class TemplateParseException extends RuntimeException {
+    private int lineNumber;
+    private int column;
+
+    public TemplateParseException(int lineNumber, int column) {
+        super();
+        this.lineNumber = lineNumber;
+        this.column = column;
+    }
+
+    public TemplateParseException(String message, int lineNumber, int column) {
+        super(message);
+        this.lineNumber = lineNumber;
+        this.column = column;
+    }
+
+    public TemplateParseException(String message, Throwable cause, int lineNumber, int column) {
+        super(message, cause);
+        this.lineNumber = lineNumber;
+        this.column = column;
+    }
+
+    public TemplateParseException(Throwable t, int lineNumber, int column) {
+        super(t);
+        this.lineNumber = lineNumber;
+        this.column = column;
+    }
+
+    public int getLineNumber() {
+        return lineNumber;
+    }
+
+    public int getColumn() {
+        return column;
+    }
+}
diff --git a/subprojects/groovy-templates/src/test/groovy/groovy/text/StreamingTemplateEngineSpecification.groovy b/subprojects/groovy-templates/src/test/groovy/groovy/text/StreamingTemplateEngineSpecification.groovy
index 4a1087f931..bf2a1bcfd4 100644
--- a/subprojects/groovy-templates/src/test/groovy/groovy/text/StreamingTemplateEngineSpecification.groovy
+++ b/subprojects/groovy-templates/src/test/groovy/groovy/text/StreamingTemplateEngineSpecification.groovy
@@ -250,7 +250,7 @@ class StreamingTemplateEngineSpecification extends Specification {
       streaming == gString
   }
 
-  def "should throw exception with correct line number on template errors"() {
+  def "should throw exception with correct line number on template execution error in mid template"() {
     setup:
       def binding = [firstname : "Grace",
                      lastname  : "Hopper",
@@ -266,16 +266,135 @@ class StreamingTemplateEngineSpecification extends Specification {
         '''.stripMargin()
 
     when:
-      String result = template(STREAMING, text, binding)
+      template(STREAMING, text, binding)
 
     then:
       def e = thrown(TemplateExecutionException)
       e.lineNumber == 4
   }
 
+  def "should throw exception with correct line number on template execution error at start of template"() {
+    setup:
+      def binding = [firstname : "Grace",
+                     lastname  : "Hopper",
+                     accepted  : false,
+                     title     : 'Groovy for COBOL programmers']
+      def text = '''\
+          |$txitle Dear <% out.print firstname %> ${lastname},
+          |
+          |We <% if (accepted) out.print 'are pleased' else out.print 'regret' %> to inform you that your paper entitled
+          |'$title' was ${ accepted ? 'accepted' : 'rejected' }.
+          |
+          |The conference committee.
+          '''.stripMargin()
+
+    when:
+      template(STREAMING, text, binding)
+
+    then:
+      def e = thrown(TemplateExecutionException)
+      e.lineNumber == 1
+  }
+
+  def "should throw exception with correct line number on template execution error at end of template"() {
+    setup:
+    def binding = [firstname : "Grace",
+                   lastname  : "Hopper",
+                   accepted  : false,
+                   title     : 'Groovy for COBOL programmers']
+    def text = '''\
+        |Dear <% out.print firstname %> ${lastname},
+        |
+        |We <% if (accepted) out.print 'are pleased' else out.print 'regret' %> to inform you that your paper entitled
+        |'$title' was ${ accepted ? 'accepted' : 'rejected' }.
+        |
+        |The conference committee.
+        |$txitle'''.stripMargin()
+
+    when:
+    template(STREAMING, text, binding)
+
+    then:
+    def e = thrown(TemplateExecutionException)
+    e.lineNumber == 7
+  }
+
+
+  def "should throw exception with correct line number on template parse error in mid template"() {
+    setup:
+      def binding = [firstname : "Grace",
+                     lastname  : "Hopper",
+                     accepted  : false,
+                     title     : 'Groovy for COBOL programmers']
+    def text = '''\
+        |Dear <% out.print firstname %> ${lastname},
+        |
+        |We <% if (accepted) out.print 'are pleased' else out.print 'regret' %> to inform you that your paper entitled
+        |<% -- %> was ${ accepted ? 'accepted' : 'rejected' }.
+        |
+        |The conference committee.
+        '''.stripMargin()
+
+    when:
+      template(STREAMING, text, binding)
+
+    then:
+      def e = thrown(TemplateParseException)
+      e.lineNumber == 4
+  }
+
+  def "should throw exception with correct line number on template parse error at start of template"() {
+    setup:
+      def binding = [firstname : "Grace",
+                     lastname  : "Hopper",
+                     accepted  : false,
+                     title     : 'Groovy for COBOL programmers']
+      def text = '''\
+          ||<% -- %> Dear <% out.print firstname %> ${lastname},
+          |
+          |We <% if (accepted) out.print 'are pleased' else out.print 'regret' %> to inform you that your paper entitled
+          |'$title' was ${ accepted ? 'accepted' : 'rejected' }.
+          |
+          |The conference committee.
+          '''.stripMargin()
+
+    when:
+      template(STREAMING, text, binding)
+
+    then:
+      def e = thrown(TemplateParseException)
+      e.lineNumber == 1
+  }
+
+  def "should throw exception with correct line number on template parse error at end of template"() {
+    setup:
+      def binding = [firstname : "Grace",
+                     lastname  : "Hopper",
+                     accepted  : false,
+                     title     : 'Groovy for COBOL programmers']
+      def text = '''\
+          |Dear <% out.print firstname %> ${lastname},
+          |
+          |We <% if (accepted) out.print 'are pleased' else out.print 'regret' %> to inform you that your paper entitled
+          |'$title' was ${ accepted ? 'accepted' : 'rejected' }.
+          |
+          |The conference committee.
+          ||<% -- %>'''.stripMargin()
+
+    when:
+      template(STREAMING, text, binding)
+
+    then:
+      def e = thrown(TemplateParseException)
+      e.lineNumber == 7
+  }
+
+
+
   @Unroll
   def "should evaluate adjacent expressions '#expression' to '#expected'"() {
     expect:
+      //noinspection GroovyAssignabilityCheck
       template(STREAMING, expression, defaultBinding) == expected
 
     where:
@@ -289,7 +408,7 @@ class StreamingTemplateEngineSpecification extends Specification {
         ['<%= queen %>'           , 'Queen'],
         ['<% out << desk %>'      , 'writing desk'],
       ].permutations().collect { p ->
-        p.inject(['','']) { acc, val ->
+        p.inject(['','']) { List acc, val ->
           acc[0] += val[0]
           acc[1] += val[1]
           acc
