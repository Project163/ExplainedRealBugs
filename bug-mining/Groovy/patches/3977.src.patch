diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index a3c3be1d21..07c57f43e3 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -1825,9 +1825,13 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                         init
                 );
                 bexp.setSourcePosition(init);
-                typeCheckAssignment(bexp, left, node.getOriginType(), init, getType(init));
+                ClassNode lType = getType(node), rType = getType(init);
+                typeCheckAssignment(bexp, left, lType, init, getResultType(lType, ASSIGN, rType, bexp));
+
                 if (init instanceof ConstructorCallExpression) {
-                    inferDiamondType((ConstructorCallExpression) init, node.getOriginType());
+                    inferDiamondType((ConstructorCallExpression) init, lType);
+                } else if (init instanceof ClosureExpression && isFunctionalInterface(lType)) {
+                    inferParameterAndReturnTypesOfClosureOnRHS(lType, (ClosureExpression) init);
                 }
             }
         } finally {
@@ -4414,7 +4418,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
         // extract the generics from the return type
         Map<GenericsTypeName, GenericsType> connections = new HashMap<>();
-        extractGenericsConnections(connections, getInferredReturnType(closureExpression), abstractMethod.getReturnType());
+        extractGenericsConnections(connections, getWrapper(getInferredReturnType(closureExpression)), abstractMethod.getReturnType());
 
         // next we get the block parameter types and set the generics
         // information just like before
@@ -4422,7 +4426,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         if (closureExpression.isParameterSpecified()) {
             Parameter[] closureParams = closureExpression.getParameters();
             Parameter[] methodParams = abstractMethod.getParameters();
-            for (int i = 0, n = closureParams.length; i < n; i += 1) {
+            for (int i = 0, n = Math.min(closureParams.length, methodParams.length); i < n; i += 1) {
                 ClassNode closureParamType = closureParams[i].getType();
                 ClassNode methodParamType = methodParams[i].getType();
                 extractGenericsConnections(connections, closureParamType, methodParamType);
diff --git a/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy b/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy
index 272327c9c4..e56e248eb3 100644
--- a/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy
+++ b/src/test/groovy/transform/stc/FieldsAndPropertiesSTCTest.groovy
@@ -275,9 +275,9 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
     void testFieldInitShouldPass() {
         assertScript '''
             class Foo {
-                int x = 1
+                int bar = 1
             }
-            1
+            new Foo()
         '''
     }
 
@@ -285,9 +285,9 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
     void testFieldInitShouldNotPassBecauseOfIncompatibleTypes() {
         shouldFailWithMessages '''
             class Foo {
-                int x = new Date()
+                int bar = new Date()
             }
-            1
+            new Foo()
         ''', 'Cannot assign value of type java.util.Date to variable of type int'
     }
 
@@ -295,12 +295,40 @@ class FieldsAndPropertiesSTCTest extends StaticTypeCheckingTestCase {
     void testFieldInitShouldNotPassBecauseOfIncompatibleTypesWithClosure() {
         shouldFailWithMessages '''
             class Foo {
-                Closure<List> cls = { Date aDate ->  aDate.getTime() }
+                Closure<List> bar = { Date date -> date.getTime() }
             }
-            1
+            new Foo()
         ''', 'Incompatible generic argument types. Cannot assign groovy.lang.Closure <java.lang.Long> to: groovy.lang.Closure <List>'
     }
 
+    void testFieldInitShouldNotPassBecauseOfIncompatibleTypesWithClosure2() {
+        shouldFailWithMessages '''
+            class Foo {
+                java.util.function.Supplier<String> bar = { 123 }
+            }
+            new Foo()
+        ''', 'Incompatible generic argument types. Cannot assign java.util.function.Supplier <java.lang.Integer> to: java.util.function.Supplier <String>'
+    }
+
+    // GROOVY-9882
+    void testFieldInitShouldPassForCcompatibleTypesWithClosure() {
+        assertScript '''
+            class Foo {
+                java.util.function.Supplier<String> bar = { 'abc' }
+            }
+            assert new Foo().bar.get() == 'abc'
+        '''
+    }
+
+    void testFieldInitClosureParameterMismatch() {
+        shouldFailWithMessages '''
+            class Foo {
+                java.util.function.Supplier<String> bar = { a -> '' }
+            }
+            new Foo()
+        ''', 'Wrong number of parameters'
+    }
+
     // GROOVY-5517
     void testShouldFindStaticPropertyEvenIfObjectImplementsMap() {
         assertScript '''
