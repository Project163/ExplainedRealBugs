diff --git a/src/main/org/codehaus/groovy/classgen/asm/BinaryExpressionMultiTypeDispatcher.java b/src/main/org/codehaus/groovy/classgen/asm/BinaryExpressionMultiTypeDispatcher.java
index bd4fa0d37c..707d25d610 100644
--- a/src/main/org/codehaus/groovy/classgen/asm/BinaryExpressionMultiTypeDispatcher.java
+++ b/src/main/org/codehaus/groovy/classgen/asm/BinaryExpressionMultiTypeDispatcher.java
@@ -259,7 +259,15 @@ public class BinaryExpressionMultiTypeDispatcher extends BinaryExpressionHelper
             int operationType = getOperandConversionType(leftType,rightType);
             BinaryExpressionWriter bew = binExpWriter[operationType];
             
-            if (bew.write(operation, true)) {
+            if (   (operation==LEFT_SHIFT || operation==RIGHT_SHIFT) && 
+                    bew.write(operation, true)) 
+            {
+                leftExp.visit(acg);
+                os.doGroovyCast(bew.getNormalOpResultType());
+                rightExp.visit(acg);
+                os.doGroovyCast(int_TYPE);
+                bew.write(operation, false);
+            } else if (bew.write(operation, true)) {
                 leftExp.visit(acg);
                 os.doGroovyCast(bew.getNormalOpResultType());
                 rightExp.visit(acg);
diff --git a/src/test/org/codehaus/groovy/classgen/asm/AbstractBytecodeTestCase.groovy b/src/test/org/codehaus/groovy/classgen/asm/AbstractBytecodeTestCase.groovy
index 7431a7d7e9..a45de14ad0 100644
--- a/src/test/org/codehaus/groovy/classgen/asm/AbstractBytecodeTestCase.groovy
+++ b/src/test/org/codehaus/groovy/classgen/asm/AbstractBytecodeTestCase.groovy
@@ -7,6 +7,7 @@ import org.objectweb.asm.FieldVisitor
 import org.objectweb.asm.ClassReader
 import org.codehaus.groovy.control.Phases
 import org.objectweb.asm.commons.EmptyVisitor
+import java.util.List;
 
 /**
  * Abstract test case to extend to check the instructions we generate in the bytecode of groovy programs.
@@ -77,20 +78,18 @@ class InstructionSequence {
      */
     boolean hasSequence(List<String> pattern, int offset = 0, boolean strict = false) {
         if (pattern.size() == 0) return true
-
-        def idx = indexOf(pattern[0], offset)
-        if (idx > -1) {
+        def idx = offset
+        while (true) {
+            idx = indexOf(pattern[0], idx)
+            if (idx == -1) break
             // not the first call with offset 0 and check that the next instruction match
             // is the exact following instruction in the pattern and in the bytecode instructions
-            if (strict && offset > 0 && idx - offset > 1) {
-                return false
-            } else {
-                return hasSequence(pattern.tail(), idx, strict)
-            }
-        } else {
-            return false
-        }
-    }
+            if (strict && offset > 0 && idx != offset) return false
+            if (hasSequence(pattern.tail(), idx+1, strict)) return true
+            idx++
+        } 
+        return false
+    }    
 
     /**
      * Find a strict sub-sequence of instructions of the list of instructions.
diff --git a/src/test/org/codehaus/groovy/classgen/asm/BinaryIntOperationsTest.groovy b/src/test/org/codehaus/groovy/classgen/asm/BinaryOperationsTest.groovy
similarity index 74%
rename from src/test/org/codehaus/groovy/classgen/asm/BinaryIntOperationsTest.groovy
rename to src/test/org/codehaus/groovy/classgen/asm/BinaryOperationsTest.groovy
index 1480f16e9d..d12a9c95d8 100644
--- a/src/test/org/codehaus/groovy/classgen/asm/BinaryIntOperationsTest.groovy
+++ b/src/test/org/codehaus/groovy/classgen/asm/BinaryOperationsTest.groovy
@@ -3,7 +3,7 @@ package org.codehaus.groovy.classgen.asm
 /**
  * @author Guillaume Laforge
  */
-class BinaryIntOperationsTest extends AbstractBytecodeTestCase {
+class BinaryOperationsTest extends AbstractBytecodeTestCase {
     
     void testIntPlus() {
         assert compile("""\
@@ -38,4 +38,14 @@ class BinaryIntOperationsTest extends AbstractBytecodeTestCase {
             true
         """
     }
+    
+    void testLongLeftShift() {
+        assert compile("""\
+            long a = 1
+            long b = a << 32
+        """).hasStrictSequence([
+                "LDC 32",
+                "LSHL"
+        ])
+    }
 }
diff --git a/src/test/org/codehaus/groovy/classgen/asm/InstructionSequenceHelperClassTest.groovy b/src/test/org/codehaus/groovy/classgen/asm/InstructionSequenceHelperClassTest.groovy
index f5d2852a48..9e9fa982b6 100644
--- a/src/test/org/codehaus/groovy/classgen/asm/InstructionSequenceHelperClassTest.groovy
+++ b/src/test/org/codehaus/groovy/classgen/asm/InstructionSequenceHelperClassTest.groovy
@@ -92,4 +92,19 @@ class InstructionSequenceHelperClassTest extends GroovyTestCase {
                 "IADD"
         ])
     }
+    
+    void testStrictSequencePatternPrefixRepetition() {
+        def instrs = new InstructionSequence(instructions: [
+                "A", "A", "B",
+                "A", "A", "C",
+        ])
+
+        assert instrs.hasStrictSequence([
+                "A", "A", "B"
+        ])
+        assert instrs.hasStrictSequence([
+                "A", "A", "C"
+        ])
+    }
+    
 }
