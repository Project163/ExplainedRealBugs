diff --git a/src/main/groovy/util/ProxyGenerator.java b/src/main/groovy/util/ProxyGenerator.java
index 8cefe485ef..d94cb776d2 100644
--- a/src/main/groovy/util/ProxyGenerator.java
+++ b/src/main/groovy/util/ProxyGenerator.java
@@ -19,6 +19,7 @@ import groovy.lang.*;
 import org.codehaus.groovy.runtime.*;
 import org.codehaus.groovy.runtime.memoize.LRUCache;
 import org.codehaus.groovy.runtime.typehandling.GroovyCastException;
+import org.codehaus.groovy.transform.trait.Traits;
 
 import java.lang.ref.WeakReference;
 import java.lang.reflect.Modifier;
@@ -235,8 +236,12 @@ public class ProxyGenerator {
     }
     
     private static final class CacheKey {
-        private static final Comparator<Class> CLASSNAME_COMPARATOR = new Comparator<Class>() {
+        private static final Comparator<Class> INTERFACE_COMPARATOR = new Comparator<Class>() {
             public int compare(final Class o1, final Class o2) {
+                // Traits order *must* be preserved
+                // See GROOVY-7285
+                if (Traits.isTrait(o1)) return -1;
+                if (Traits.isTrait(o2)) return 1;
                 return o1.getName().compareTo(o2.getName());
             }
         };
@@ -254,9 +259,11 @@ public class ProxyGenerator {
             this.emptyMethods = emptyMethods;
             this.interfaces = interfaces == null ? null : new ClassReference[interfaces.length];
             if (interfaces != null) {
-                Arrays.sort(interfaces, CLASSNAME_COMPARATOR);
-                for (int i = 0; i < interfaces.length; i++) {
-                    Class anInterface = interfaces[i];
+                Class[] interfacesCopy = new Class[interfaces.length];
+                System.arraycopy(interfaces, 0, interfacesCopy, 0, interfaces.length);
+                Arrays.sort(interfacesCopy, INTERFACE_COMPARATOR);
+                for (int i = 0; i < interfacesCopy.length; i++) {
+                    Class anInterface = interfacesCopy[i];
                     this.interfaces[i] = new ClassReference(anInterface);
                 }
             }
diff --git a/src/test/org/codehaus/groovy/transform/traitx/Groovy7285Bug.groovy b/src/test/org/codehaus/groovy/transform/traitx/Groovy7285Bug.groovy
new file mode 100644
index 0000000000..6e822718c8
--- /dev/null
+++ b/src/test/org/codehaus/groovy/transform/traitx/Groovy7285Bug.groovy
@@ -0,0 +1,60 @@
+/*
+ * Copyright 2003-2015 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+
+
+
+package org.codehaus.groovy.transform.traitx
+
+class Groovy7285Bug extends GroovyTestCase {
+    void testRuntimeStackableTraits() {
+        assertScript '''trait D {
+    void methodA() { ref << "D"; super.methodA() }
+}
+trait C {
+    void methodA() { ref << "C"; super.methodA() }
+}
+trait B {
+    void methodA() { ref << "B"; super.methodA() }
+}
+trait A {
+    void methodA() { ref << "A" }
+}
+
+class M implements A, D, C, B { List ref = [] }
+class Q {  List ref = []  }
+
+def direct = new M()
+
+println "Static: ${direct.methodA();direct.ref}"
+
+def runtime = new Q().withTraits(A,D,C,B)
+
+// we need another test to make sure that 2 proxies with the same set of traits are different
+// because the traits ordering is different
+def runtime2 = new Q().withTraits(A,D,C,B)
+
+println "Dynamic: ${runtime.methodA();runtime.ref}"
+println "Dynamic 2: ${runtime2.methodA();runtime2.ref}"
+
+assert direct.ref == ['B','C','D','A']
+assert direct.ref == runtime.ref
+assert runtime2.ref == ['B','C','D','A']
+
+'''
+    }
+}
