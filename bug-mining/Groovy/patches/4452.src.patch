diff --git a/src/main/java/org/codehaus/groovy/ast/tools/GenericsUtils.java b/src/main/java/org/codehaus/groovy/ast/tools/GenericsUtils.java
index ccede732f1..51275fb1fb 100644
--- a/src/main/java/org/codehaus/groovy/ast/tools/GenericsUtils.java
+++ b/src/main/java/org/codehaus/groovy/ast/tools/GenericsUtils.java
@@ -58,6 +58,7 @@ import static groovy.lang.Tuple.tuple;
 import static org.apache.groovy.util.SystemUtil.getSystemPropertySafe;
 import static org.codehaus.groovy.runtime.DefaultGroovyMethods.plus;
 import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.implementsInterfaceOrIsSubclassOf;
+import static org.codehaus.groovy.transform.stc.StaticTypeCheckingSupport.isUnboundedWildcard;
 
 /**
  * Utility methods to deal with generic types.
@@ -255,11 +256,11 @@ public class GenericsUtils {
      * arguments. This method allows returning a parameterized interface given the parameterized class
      * node which implements this interface.
      *
-     * @param hint   the class node where generics types are parameterized
+     * @param hint   the ClassNode where generics types are parameterized
      * @param target the interface we want to parameterize generics types
-     * @return a parameterized interface class node
+     * @return a parameterized interface ClassNode
      */
-    public static ClassNode parameterizeType(final ClassNode hint, final ClassNode target) {
+    public static ClassNode parameterizeType(ClassNode hint, final ClassNode target) {
         if (hint.isArray()) {
             if (target.isArray()) {
                 return parameterizeType(hint.getComponentType(), target.getComponentType()).makeArray();
@@ -273,20 +274,29 @@ public class GenericsUtils {
         if (target.redirect().getGenericsTypes() == null) {
             return target;
         }
-        if (!target.equals(hint) && implementsInterfaceOrIsSubclassOf(target, hint)) {
-            ClassNode nextSuperClass = ClassHelper.getNextSuperClass(target, hint);
-            if (!hint.equals(nextSuperClass)) {
-                Map<String, ClassNode> genericsSpec = createGenericsSpec(hint);
-                extractSuperClassGenerics(hint, nextSuperClass, genericsSpec);
-                ClassNode result = correctToGenericsSpecRecurse(genericsSpec, nextSuperClass);
-                return parameterizeType(result, target);
-            }
+
+        ClassNode cn = target;
+        Map<String, ClassNode> gt;
+
+        // relationship may be reversed for cases like "Iterable<String> x = []"
+        if (!cn.equals(hint) && implementsInterfaceOrIsSubclassOf(target, hint)) {
+            do { // walk target type hierarchy towards hint
+                cn = ClassHelper.getNextSuperClass(cn, hint);
+                if (hasUnresolvedGenerics(cn)) {
+                    gt = createGenericsSpec(hint);
+                    extractSuperClassGenerics(hint, cn, gt);
+                    cn = correctToGenericsSpecRecurse(gt, cn);
+                }
+            } while (!cn.equals(hint));
+
+            hint = cn;
         }
-        Map<String, ClassNode> genericsSpec = createGenericsSpec(hint);
-        ClassNode targetRedirect = target.redirect();
-        genericsSpec = createGenericsSpec(targetRedirect, genericsSpec);
-        extractSuperClassGenerics(hint, targetRedirect, genericsSpec);
-        return correctToGenericsSpecRecurse(genericsSpec, targetRedirect);
+
+        cn = target.redirect();
+        gt = createGenericsSpec(hint);
+        gt = createGenericsSpec(cn, gt);
+        extractSuperClassGenerics(hint, cn, gt);
+        return correctToGenericsSpecRecurse(gt, cn);
     }
 
     public static ClassNode nonGeneric(final ClassNode type) {
@@ -438,18 +448,17 @@ public class GenericsUtils {
     }
 
     public static ClassNode correctToGenericsSpec(Map<String, ClassNode> genericsSpec, GenericsType type) {
-        ClassNode ret = null;
-        if (type.isPlaceholder()) {
-            String name = type.getName();
-            ret = genericsSpec.get(name);
-        } else if (type.isWildcard()) { // GROOVY-9891
-          //ret = type.getLowerBound(); // use lower or upper
-            if (ret == null && type.getUpperBounds() != null) {
-                ret = type.getUpperBounds()[0]; // ? supports 1
-            }
+        ClassNode cn = null; String name = type.getName();
+        if (type.isPlaceholder() && name.charAt(0) != '#') {
+            cn = genericsSpec.get(name);
+        } else if (type.isWildcard()) {
+            if (type.getUpperBounds() != null)
+                cn = type.getUpperBounds()[0]; // GROOVY-9891
+        }
+        if (cn == null) {
+            cn = type.getType();
         }
-        if (ret == null) ret = type.getType();
-        return ret;
+        return cn;
     }
 
     public static ClassNode correctToGenericsSpec(Map<String, ClassNode> genericsSpec, ClassNode type) {
@@ -468,36 +477,25 @@ public class GenericsUtils {
         return type;
     }
 
-    public static Map<String, ClassNode> createGenericsSpec(ClassNode current) {
-        return createGenericsSpec(current, Collections.emptyMap());
+    public static Map<String, ClassNode> createGenericsSpec(final ClassNode type) {
+        return createGenericsSpec(type, Collections.emptyMap());
     }
 
-    public static Map<String, ClassNode> createGenericsSpec(ClassNode current, Map<String, ClassNode> oldSpec) {
-        Map<String, ClassNode> ret = new HashMap<String, ClassNode>(oldSpec);
-        // ret contains the type specs, what we now need is the type spec for the
-        // current class. To get that we first apply the type parameters to the
-        // current class and then use the type names of the current class to reset
-        // the map. Example:
-        //   class A<V,W,X>{}
-        //   class B<T extends Number> extends A<T,Long,String> {}
-        // first we have:    T->Number
-        // we apply it to A<T,Long,String> -> A<Number,Long,String>
-        // resulting in:     V->Number,W->Long,X->String
+    public static Map<String, ClassNode> createGenericsSpec(final ClassNode type, final Map<String, ClassNode> oldSpec) {
+        // Example:
+        // abstract class A<X,Y,Z> { ... }
+        // class C<T extends Number> extends A<T,Object,String> { }
+        // the type "A<T,Object,String> -> A<X,Y,Z>" will produce [X:Number,Y:Object,Z:String]
 
-        GenericsType[] sgts = current.getGenericsTypes();
-        if (sgts != null) {
-            ClassNode[] spec = new ClassNode[sgts.length];
-            for (int i = 0; i < spec.length; i++) {
-                spec[i] = correctToGenericsSpec(ret, sgts[i]);
-            }
-            GenericsType[] newGts = current.redirect().getGenericsTypes();
-            if (newGts == null) return ret;
-            ret.clear();
-            for (int i = 0; i < spec.length; i++) {
-                ret.put(newGts[i].getName(), spec[i]);
+        GenericsType[] gt = type.getGenericsTypes(), rgt = type.redirect().getGenericsTypes();
+
+        Map<String, ClassNode> newSpec = new HashMap<>();
+        if (gt != null && rgt != null) {
+            for (int i = 0, n = gt.length; i < n; i += 1) {
+                newSpec.put(rgt[i].getName(), correctToGenericsSpec(oldSpec, gt[i]));
             }
         }
-        return ret;
+        return newSpec;
     }
 
     public static Map<String, ClassNode> addMethodGenerics(MethodNode current, Map<String, ClassNode> oldSpec) {
@@ -532,26 +530,41 @@ public class GenericsUtils {
         return newSpec;
     }
 
-    public static void extractSuperClassGenerics(ClassNode type, ClassNode target, Map<String, ClassNode> spec) {
-        // TODO: this method is very similar to StaticTypesCheckingSupport#extractGenericsConnections,
-        // but operates on ClassNodes instead of GenericsType
-        if (target == null || type == target) return;
-        if (type.isArray() && target.isArray()) {
+    // TODO: this is very similar to StaticTypesCheckingSupport#extractGenericsConnections, using ClassNode instead of GenericsType
+    public static void extractSuperClassGenerics(final ClassNode type, final ClassNode target, final Map<String, ClassNode> spec) {
+        if (target == null || target == type) return;
+        if (target.isGenericsPlaceHolder()) {
+            spec.put(target.getUnresolvedName(), type);
+        } else if (type.isArray() && target.isArray()) {
             extractSuperClassGenerics(type.getComponentType(), target.getComponentType(), spec);
-        } else if (type.isArray() && JAVA_LANG_OBJECT.equals(target.getName())) {
-            // Object is superclass of arrays but no generics involved
-        } else if (target.isGenericsPlaceHolder() || type.equals(target) || !implementsInterfaceOrIsSubclassOf(type, target)) {
-            // structural match route
-            if (target.isGenericsPlaceHolder()) {
-                spec.put(target.getGenericsTypes()[0].getName(), type);
-            } else {
-                extractSuperClassGenerics(type.getGenericsTypes(), target.getGenericsTypes(), spec);
-            }
+        } else if (type.isArray() && target.getName().equals(JAVA_LANG_OBJECT)) {
+            // Object is the superclass of an array, but no generics are involved
+        } else if (type.equals(target) || !implementsInterfaceOrIsSubclassOf(type, target)) {
+            extractSuperClassGenerics(type.getGenericsTypes(), target.getGenericsTypes(), spec);
         } else {
-            // find matching super class or interface
             ClassNode superClass = getSuperClass(type, target);
             if (superClass != null) {
-                extractSuperClassGenerics(correctToGenericsSpecRecurse(createGenericsSpec(type), superClass), target, spec);
+                if (hasUnresolvedGenerics(superClass)) {
+                    GenericsType[] tp = type.redirect().getGenericsTypes();
+                    if (tp != null) {
+                        GenericsType[] ta = type.getGenericsTypes();
+                        boolean noTypeArguments = ta == null || ta.length == 0 || !type.isRedirectNode();
+                        Map<String, ClassNode> genericsSpec = new HashMap<>();
+                        for (int i = 0, n = tp.length; i < n; i += 1) {
+                            ClassNode cn;
+                            if (noTypeArguments || isUnboundedWildcard(ta[i])) { // GROOVY-10651
+                                GenericsType gt = tp[i];
+                                cn = gt.getUpperBounds() != null ? gt.getUpperBounds()[0] : gt.getType().redirect();
+                            } else {
+                                GenericsType gt = ta[i];
+                                cn = gt.isWildcard() && gt.getUpperBounds() != null ? gt.getUpperBounds()[0] : gt.getType();
+                            }
+                            genericsSpec.put(tp[i].getName(), cn);
+                        }
+                        superClass = correctToGenericsSpecRecurse(genericsSpec, superClass);
+                    }
+                }
+                extractSuperClassGenerics(superClass, target, spec);
             } else {
                 // if we reach here, we have an unhandled case
                 throw new GroovyBugError("The type " + type + " seems not to normally extend " + target + ". Sorry, I cannot handle this.");
diff --git a/src/main/java/org/codehaus/groovy/transform/InheritConstructorsASTTransformation.java b/src/main/java/org/codehaus/groovy/transform/InheritConstructorsASTTransformation.java
index c70db6d2f0..02a1fbd2b9 100644
--- a/src/main/java/org/codehaus/groovy/transform/InheritConstructorsASTTransformation.java
+++ b/src/main/java/org/codehaus/groovy/transform/InheritConstructorsASTTransformation.java
@@ -22,11 +22,11 @@ import groovy.transform.InheritConstructors;
 import org.codehaus.groovy.ast.ASTNode;
 import org.codehaus.groovy.ast.AnnotatedNode;
 import org.codehaus.groovy.ast.AnnotationNode;
+import org.codehaus.groovy.ast.ClassHelper;
 import org.codehaus.groovy.ast.ClassNode;
 import org.codehaus.groovy.ast.ConstructorNode;
 import org.codehaus.groovy.ast.Parameter;
 import org.codehaus.groovy.ast.expr.Expression;
-import org.codehaus.groovy.ast.tools.ParameterUtils;
 import org.codehaus.groovy.control.CompilePhase;
 import org.codehaus.groovy.control.SourceUnit;
 
@@ -35,7 +35,6 @@ import java.util.List;
 import java.util.Map;
 
 import static org.apache.groovy.ast.tools.ClassNodeUtils.addGeneratedConstructor;
-import static org.codehaus.groovy.ast.ClassHelper.make;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.args;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.block;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.castX;
@@ -44,7 +43,7 @@ import static org.codehaus.groovy.ast.tools.GeneralUtils.param;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.varX;
 import static org.codehaus.groovy.ast.tools.GenericsUtils.correctToGenericsSpecRecurse;
 import static org.codehaus.groovy.ast.tools.GenericsUtils.createGenericsSpec;
-import static org.codehaus.groovy.ast.tools.GenericsUtils.extractSuperClassGenerics;
+import static org.codehaus.groovy.ast.tools.ParameterUtils.parametersEqual;
 
 /**
  * Handles generation of code for the {@code @}InheritConstructors annotation.
@@ -52,7 +51,7 @@ import static org.codehaus.groovy.ast.tools.GenericsUtils.extractSuperClassGener
 @GroovyASTTransformation(phase = CompilePhase.CANONICALIZATION)
 public class InheritConstructorsASTTransformation extends AbstractASTTransformation {
 
-    private static final ClassNode INHERIT_CONSTRUCTORS_TYPE = make(InheritConstructors.class);
+    private static final ClassNode INHERIT_CONSTRUCTORS_TYPE = ClassHelper.make(InheritConstructors.class);
     private static final String ANNOTATION = "@" + INHERIT_CONSTRUCTORS_TYPE.getNameWithoutPackage();
 
     @Override
@@ -87,17 +86,18 @@ public class InheritConstructorsASTTransformation extends AbstractASTTransformat
         }
     }
 
-    private void addConstructorUnlessAlreadyExisting(ClassNode classNode, ConstructorNode consNode, boolean copyConstructorAnnotations, boolean copyParameterAnnotations) {
-        Parameter[] origParams = consNode.getParameters();
-        if (consNode.isPrivate()) return;
-        Parameter[] params = new Parameter[origParams.length];
+    private void addConstructorUnlessAlreadyExisting(final ClassNode classNode, final ConstructorNode ctorNode, final boolean copyConstructorAnnotations, final boolean copyParameterAnnotations) {
+        if (ctorNode.isPrivate()) return;
+        Parameter[] oldParams = ctorNode.getParameters();
+        Parameter[] newParams = new Parameter[oldParams.length];
         Map<String, ClassNode> genericsSpec = createGenericsSpec(classNode);
-        extractSuperClassGenerics(classNode, classNode.getSuperClass(), genericsSpec);
-        List<Expression> theArgs = buildParams(origParams, params, genericsSpec, copyParameterAnnotations);
-        if (isExisting(classNode, params)) return;
-        ConstructorNode added = addGeneratedConstructor(classNode, consNode.getModifiers(), params, consNode.getExceptions(), block(ctorSuperS(args(theArgs))));
-        if (copyConstructorAnnotations) {
-            added.addAnnotations(copyAnnotatedNodeAnnotations(consNode, ANNOTATION, false));
+        genericsSpec = createGenericsSpec(classNode.getUnresolvedSuperClass());
+        List<Expression> theArgs = buildParams(oldParams, newParams, genericsSpec, copyParameterAnnotations);
+        if (!isExisting(classNode, newParams)) {
+            ConstructorNode added = addGeneratedConstructor(classNode, ctorNode.getModifiers(), newParams, ctorNode.getExceptions(), block(ctorSuperS(args(theArgs))));
+            if (copyConstructorAnnotations) {
+                added.addAnnotations(copyAnnotatedNodeAnnotations(ctorNode, ANNOTATION, false));
+            }
         }
     }
 
@@ -116,11 +116,7 @@ public class InheritConstructorsASTTransformation extends AbstractASTTransformat
         return theArgs;
     }
 
-    private static boolean isExisting(ClassNode classNode, Parameter[] params) {
-        return classNode.getDeclaredConstructors().stream().anyMatch(ctor -> matchingTypes(params, ctor.getParameters()));
-    }
-
-    private static boolean matchingTypes(Parameter[] params, Parameter[] existingParams) {
-        return ParameterUtils.parametersEqual(params, existingParams);
+    private static boolean isExisting(final ClassNode classNode, final Parameter[] params) {
+        return classNode.getDeclaredConstructors().stream().anyMatch(ctor -> parametersEqual(params, ctor.getParameters()));
     }
 }
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
index 649d6f988c..dd687fa3a3 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
@@ -100,7 +100,6 @@ import static org.codehaus.groovy.ast.ClassHelper.char_TYPE;
 import static org.codehaus.groovy.ast.ClassHelper.double_TYPE;
 import static org.codehaus.groovy.ast.ClassHelper.findSAM;
 import static org.codehaus.groovy.ast.ClassHelper.float_TYPE;
-import static org.codehaus.groovy.ast.ClassHelper.getNextSuperClass;
 import static org.codehaus.groovy.ast.ClassHelper.getUnwrapper;
 import static org.codehaus.groovy.ast.ClassHelper.getWrapper;
 import static org.codehaus.groovy.ast.ClassHelper.int_TYPE;
@@ -1746,25 +1745,14 @@ public abstract class StaticTypeCheckingSupport {
         } else if (type.equals(CLOSURE_TYPE) && isSAMType(target)) {
             // GROOVY-9974, GROOVY-10052: Lambda, Closure, Pointer or Reference for SAM-type receiver
             ClassNode returnType = StaticTypeCheckingVisitor.wrapTypeIfNecessary(GenericsUtils.parameterizeSAM(target).getV2());
-            extractGenericsConnections(connections, type.getGenericsTypes(), new GenericsType[] {returnType.asGenericsType()});
+            extractGenericsConnections(connections, type.getGenericsTypes(), new GenericsType[]{returnType.asGenericsType()});
 
         } else if (type.equals(target)) {
             extractGenericsConnections(connections, type.getGenericsTypes(), target.getGenericsTypes());
 
         } else if (implementsInterfaceOrIsSubclassOf(type, target)) {
-            ClassNode superClass = getNextSuperClass(type, target);
-            if (superClass != null) {
-                if (GenericsUtils.hasUnresolvedGenerics(superClass)) {
-                    Map<String, ClassNode> spec = GenericsUtils.createGenericsSpec(type);
-                    if (!spec.isEmpty()) {
-                        superClass = GenericsUtils.correctToGenericsSpecRecurse(spec, superClass);
-                    }
-                }
-                extractGenericsConnections(connections, superClass, target);
-            } else {
-                // if we reach here, we have an unhandled case
-                throw new GroovyBugError("The type " + type + " seems not to normally extend " + target + ". Sorry, I cannot handle this.");
-            }
+            ClassNode goal = GenericsUtils.parameterizeType(type, target);
+            extractGenericsConnections(connections, goal.getGenericsTypes(), target.getGenericsTypes());
         }
     }
 
diff --git a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 5c4ba09dc2..64a898ee24 100644
--- a/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -5975,20 +5975,25 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
 
     /**
      * Wrapper for a Parameter so it can be treated like a VariableExpression
-     * and tracked in the ifElseForWhileAssignmentTracker.
-     * <p>
-     * This class purposely does not adhere to the normal equals and hashCode
-     * contract on the Object class and delegates those calls to the wrapped
-     * variable.
+     * and tracked in the {@code ifElseForWhileAssignmentTracker}.
      */
-    private static class ParameterVariableExpression extends VariableExpression {
+    private class ParameterVariableExpression extends VariableExpression {
 
         private final Parameter parameter;
 
         ParameterVariableExpression(final Parameter parameter) {
             super(parameter);
             this.parameter = parameter;
-            this.parameter.getNodeMetaData(INFERRED_TYPE, x -> parameter.getOriginType());
+
+            ClassNode inferredType = getNodeMetaData(INFERRED_TYPE);
+            if (inferredType == null) {
+                inferredType = typeCheckingContext.controlStructureVariables.get(parameter); // for/catch/closure
+                if (inferredType == null) {
+                    TypeCheckingContext.EnclosingClosure enclosingClosure = typeCheckingContext.getEnclosingClosure();
+                    if (enclosingClosure != null) inferredType = getTypeFromClosureArguments(parameter, enclosingClosure);
+                }
+                setNodeMetaData(INFERRED_TYPE, inferredType != null ? inferredType : parameter.getType()); // GROOVY-10651
+            }
         }
 
         @Override
diff --git a/src/test/groovy/bugs/Groovy7204Bug.groovy b/src/test/groovy/bugs/Groovy7204Bug.groovy
index 1816b39bdc..59254ff8b1 100644
--- a/src/test/groovy/bugs/Groovy7204Bug.groovy
+++ b/src/test/groovy/bugs/Groovy7204Bug.groovy
@@ -18,562 +18,531 @@
  */
 package groovy.bugs
 
-import groovy.test.GroovyTestCase
+import org.junit.Test
 
-class Groovy7204Bug extends GroovyTestCase {
-    void testTypeChecked1() {
-        assertScript '''
-        import java.io.Serializable;
+import static groovy.test.GroovyAssert.assertScript
 
-        import groovy.transform.CompileStatic;
-        import groovy.transform.TypeChecked;
+final class Groovy7204Bug {
 
-        @TypeChecked
-        public class MyClass {
-            static MyRepository factory() {
-                return new MyRepositoryImpl()
-            }
+    private final GroovyShell shell = GroovyShell.withConfig {
+        imports { star 'groovy.transform' }
+    }
 
-            static void main(String[] args) {
-                MyRepository r = factory()
-                r.delete('foo')
-            }
-        }
+    @Test
+    void testTypeChecked1() {
+        assertScript shell, '''
+            @TypeChecked
+            public class MyClass {
+                static MyRepository factory() {
+                    return new MyRepositoryImpl()
+                }
 
-        @TypeChecked
-        interface CrudRepository<T, S extends Serializable> {
-            void delete(T arg);
-            void delete(S arg);
-        }
+                static void main(String[] args) {
+                    MyRepository r = factory()
+                    r.delete('foo')
+                }
+            }
 
-        @TypeChecked
-        interface MyRepository extends CrudRepository<String, Long> {
-        }
+            @TypeChecked
+            interface CrudRepository<T, S extends Serializable> {
+                void delete(T arg)
+                void delete(S arg)
+            }
 
-        @TypeChecked
-        class MyRepositoryImpl implements MyRepository {
-            @Override
-            public void delete(String arg) {
-                System.out.println("String");
-                assert true
+            @TypeChecked
+            interface MyRepository extends CrudRepository<String, Long> {
             }
 
-            @Override
-            public void delete(Long arg) {
-                System.out.println("Long");
-                assert false: 'wrong method invoked'
+            @TypeChecked
+            class MyRepositoryImpl implements MyRepository {
+                @Override
+                public void delete(String arg) {
+                    System.out.println('String')
+                    assert true
+                }
+
+                @Override
+                public void delete(Long arg) {
+                    System.out.println('Long')
+                    assert false: 'wrong method invoked'
+                }
             }
-        }
         '''
     }
 
+    @Test
     void testTypeChecked2() {
-        assertScript '''
-        import java.io.Serializable;
+        assertScript shell, '''
+            @TypeChecked
+            public class MyClass {
+                static MyRepository factory() {
+                    return new MyRepositoryImpl()
+                }
 
-        import groovy.transform.CompileStatic;
-        import groovy.transform.TypeChecked;
-
-        @TypeChecked
-        public class MyClass {
-            static MyRepository factory() {
-                return new MyRepositoryImpl()
+                static void main(String[] args) {
+                    MyRepository r = factory()
+                    r.delete('foo')
+                }
             }
 
-            static void main(String[] args) {
-                MyRepository r = factory()
-                r.delete('foo')
+            @TypeChecked
+            abstract class CrudRepository<T, S extends Serializable> {
+                abstract void delete(T arg)
+                abstract void delete(S arg)
             }
-        }
-
-        @TypeChecked
-        abstract class CrudRepository<T, S extends Serializable> {
-            abstract void delete(T arg);
-            abstract void delete(S arg);
-        }
-
-        @TypeChecked
-        abstract class MyRepository extends CrudRepository<String, Long> {
-        }
 
-        @TypeChecked
-        class MyRepositoryImpl extends MyRepository {
-            @Override
-            public void delete(String arg) {
-                System.out.println("String");
-                assert true
+            @TypeChecked
+            abstract class MyRepository extends CrudRepository<String, Long> {
             }
 
-            @Override
-            public void delete(Long arg) {
-                System.out.println("Long");
-                assert false: 'wrong method invoked'
+            @TypeChecked
+            class MyRepositoryImpl extends MyRepository {
+                @Override
+                public void delete(String arg) {
+                    System.out.println('String')
+                    assert true
+                }
+
+                @Override
+                public void delete(Long arg) {
+                    System.out.println('Long')
+                    assert false: 'wrong method invoked'
+                }
             }
-        }
         '''
     }
 
+    @Test
     void testTypeChecked3() {
-        assertScript '''
-        import java.io.Serializable;
-
-        import groovy.transform.CompileStatic;
-        import groovy.transform.TypeChecked;
+        assertScript shell, '''
+            @TypeChecked
+            public class MyClass {
+                static MyRepository factory() {
+                    return new MyRepositoryImpl()
+                }
 
-        @TypeChecked
-        public class MyClass {
-            static MyRepository factory() {
-                return new MyRepositoryImpl()
+                static void main(String[] args) {
+                    MyRepository r = factory()
+                    r.delete('foo')
+                }
             }
 
-            static void main(String[] args) {
-                MyRepository r = factory()
-                r.delete('foo')
+            @TypeChecked
+            interface CrudRepository<T, S extends Serializable> {
+                void delete(T arg)
+                void delete(S arg)
             }
-        }
-
-        @TypeChecked
-        interface CrudRepository<T, S extends Serializable> {
-            void delete(T arg);
-            void delete(S arg);
-        }
 
-        @TypeChecked
-        interface MyRepository2 extends CrudRepository<String, Long> {
-        }
-
-        @TypeChecked
-        interface MyRepository extends MyRepository2 {
-        }
+            @TypeChecked
+            interface MyRepository2 extends CrudRepository<String, Long> {
+            }
 
-        @TypeChecked
-        class MyRepositoryImpl implements MyRepository {
-            @Override
-            public void delete(String arg) {
-                System.out.println("String");
-                assert true
+            @TypeChecked
+            interface MyRepository extends MyRepository2 {
             }
 
-            @Override
-            public void delete(Long arg) {
-                System.out.println("Long");
-                assert false: 'wrong method invoked'
+            @TypeChecked
+            class MyRepositoryImpl implements MyRepository {
+                @Override
+                public void delete(String arg) {
+                    System.out.println('String')
+                    assert true
+                }
+
+                @Override
+                public void delete(Long arg) {
+                    System.out.println('Long')
+                    assert false: 'wrong method invoked'
+                }
             }
-        }
         '''
     }
 
+    @Test
     void testTypeChecked4() {
-        assertScript '''
-        import java.io.Serializable;
+        assertScript shell, '''
+            @TypeChecked
+            public class MyClass {
+                static MyRepository factory() {
+                    return new MyRepositoryImpl()
+                }
 
-        import groovy.transform.CompileStatic;
-        import groovy.transform.TypeChecked;
-
-        @TypeChecked
-        public class MyClass {
-            static MyRepository factory() {
-                return new MyRepositoryImpl()
+                static void main(String[] args) {
+                    MyRepository r = factory()
+                    r.delete('foo')
+                }
             }
 
-            static void main(String[] args) {
-                MyRepository r = factory()
-                r.delete('foo')
+            @TypeChecked
+            abstract class CrudRepository<T, S extends Serializable> {
+                abstract void delete(T arg)
+                abstract void delete(S arg)
             }
-        }
 
-        @TypeChecked
-        abstract class CrudRepository<T, S extends Serializable> {
-            abstract void delete(T arg);
-            abstract void delete(S arg);
-        }
-
-        @TypeChecked
-        abstract class MyRepository2 extends CrudRepository<String, Long> {
-        }
-
-        @TypeChecked
-        abstract class MyRepository extends MyRepository2 {
-        }
+            @TypeChecked
+            abstract class MyRepository2 extends CrudRepository<String, Long> {
+            }
 
-        @TypeChecked
-        class MyRepositoryImpl extends MyRepository {
-            @Override
-            public void delete(String arg) {
-                System.out.println("String");
-                assert true
+            @TypeChecked
+            abstract class MyRepository extends MyRepository2 {
             }
 
-            @Override
-            public void delete(Long arg) {
-                System.out.println("Long");
-                assert false: 'wrong method invoked'
+            @TypeChecked
+            class MyRepositoryImpl extends MyRepository {
+                @Override
+                public void delete(String arg) {
+                    System.out.println('String')
+                    assert true
+                }
+
+                @Override
+                public void delete(Long arg) {
+                    System.out.println('Long')
+                    assert false: 'wrong method invoked'
+                }
             }
-        }
         '''
     }
 
+    @Test
     void testTypeChecked5() {
-        assertScript '''
-        import java.io.Serializable;
+        assertScript shell, '''
+            @TypeChecked
+            public class MyClass {
+                static MyRepository factory() {
+                    return new MyRepositoryImpl()
+                }
 
-        import groovy.transform.CompileStatic;
-        import groovy.transform.TypeChecked;
-
-        @TypeChecked
-        public class MyClass {
-            static MyRepository factory() {
-                return new MyRepositoryImpl()
+                static void main(String[] args) {
+                    MyRepository r = factory()
+                    r.delete('foo')
+                }
             }
 
-            static void main(String[] args) {
-                MyRepository r = factory()
-                r.delete('foo')
+            @TypeChecked
+            interface CrudRepository<T, S extends Serializable> {
+                void delete(T arg)
+                void delete(S arg)
             }
-        }
-
-        @TypeChecked
-        interface CrudRepository<T, S extends Serializable> {
-            void delete(T arg);
-            void delete(S arg);
-        }
-
-        @TypeChecked
-        abstract class MyRepository2 implements CrudRepository<String, Long> {
-        }
 
-        @TypeChecked
-        abstract class MyRepository extends MyRepository2 {
-        }
+            @TypeChecked
+            abstract class MyRepository2 implements CrudRepository<String, Long> {
+            }
 
-        @TypeChecked
-        class MyRepositoryImpl extends MyRepository {
-            @Override
-            public void delete(String arg) {
-                System.out.println("String");
-                assert true
+            @TypeChecked
+            abstract class MyRepository extends MyRepository2 {
             }
 
-            @Override
-            public void delete(Long arg) {
-                System.out.println("Long");
-                assert false: 'wrong method invoked'
+            @TypeChecked
+            class MyRepositoryImpl extends MyRepository {
+                @Override
+                public void delete(String arg) {
+                    System.out.println('String')
+                    assert true
+                }
+
+                @Override
+                public void delete(Long arg) {
+                    System.out.println('Long')
+                    assert false: 'wrong method invoked'
+                }
             }
-        }
         '''
     }
 
+    //
 
+    @Test
     void testCompileStatic1() {
-        assertScript '''
-        import java.io.Serializable;
+        assertScript shell, '''
+            @CompileStatic
+            public class MyClass {
+                static MyRepository factory() {
+                    return new MyRepositoryImpl()
+                }
 
-        import groovy.transform.CompileStatic;
-        import groovy.transform.TypeChecked;
-
-        @CompileStatic
-        public class MyClass {
-            static MyRepository factory() {
-                return new MyRepositoryImpl()
+                static void main(String[] args) {
+                    MyRepository r = factory()
+                    r.delete('foo')
+                }
             }
 
-            static void main(String[] args) {
-                MyRepository r = factory()
-                r.delete('foo')
+            @CompileStatic
+            interface CrudRepository<T, S extends Serializable> {
+                void delete(T arg)
+                void delete(S arg)
             }
-        }
 
-        @CompileStatic
-        interface CrudRepository<T, S extends Serializable> {
-            void delete(T arg);
-            void delete(S arg);
-        }
-
-        @CompileStatic
-        interface MyRepository extends CrudRepository<String, Long> {
-        }
-
-        @CompileStatic
-        class MyRepositoryImpl implements MyRepository {
-            @Override
-            public void delete(String arg) {
-                System.out.println("String");
-                assert true
+            @CompileStatic
+            interface MyRepository extends CrudRepository<String, Long> {
             }
 
-            @Override
-            public void delete(Long arg) {
-                System.out.println("Long");
-                assert false: 'wrong method invoked'
+            @CompileStatic
+            class MyRepositoryImpl implements MyRepository {
+                @Override
+                public void delete(String arg) {
+                    System.out.println('String')
+                    assert true
+                }
+
+                @Override
+                public void delete(Long arg) {
+                    System.out.println('Long')
+                    assert false: 'wrong method invoked'
+                }
             }
-        }
         '''
     }
 
+    @Test
     void testCompileStatic2() {
-        assertScript '''
-        import java.io.Serializable;
+        assertScript shell, '''
+            @CompileStatic
+            public class MyClass {
+                static MyRepository factory() {
+                    return new MyRepositoryImpl()
+                }
 
-        import groovy.transform.CompileStatic;
-        import groovy.transform.TypeChecked;
-
-        @CompileStatic
-        public class MyClass {
-            static MyRepository factory() {
-                return new MyRepositoryImpl()
+                static void main(String[] args) {
+                    MyRepository r = factory()
+                    r.delete('foo')
+                }
             }
 
-            static void main(String[] args) {
-                MyRepository r = factory()
-                r.delete('foo')
+            @CompileStatic
+            abstract class CrudRepository<T, S extends Serializable> {
+                abstract void delete(T arg)
+                abstract void delete(S arg)
             }
-        }
 
-        @CompileStatic
-        abstract class CrudRepository<T, S extends Serializable> {
-            abstract void delete(T arg);
-            abstract void delete(S arg);
-        }
-
-        @CompileStatic
-        abstract class MyRepository extends CrudRepository<String, Long> {
-        }
-
-        @CompileStatic
-        class MyRepositoryImpl extends MyRepository {
-            @Override
-            public void delete(String arg) {
-                System.out.println("String");
-                assert true
+            @CompileStatic
+            abstract class MyRepository extends CrudRepository<String, Long> {
             }
 
-            @Override
-            public void delete(Long arg) {
-                System.out.println("Long");
-                assert false: 'wrong method invoked'
+            @CompileStatic
+            class MyRepositoryImpl extends MyRepository {
+                @Override
+                public void delete(String arg) {
+                    System.out.println('String')
+                    assert true
+                }
+
+                @Override
+                public void delete(Long arg) {
+                    System.out.println('Long')
+                    assert false: 'wrong method invoked'
+                }
             }
-        }
         '''
     }
 
+    @Test
     void testCompileStatic3() {
-        assertScript '''
-        import java.io.Serializable;
-
-        import groovy.transform.CompileStatic;
-        import groovy.transform.TypeChecked;
+        assertScript shell, '''
+            @CompileStatic
+            public class MyClass {
+                static MyRepository factory() {
+                    return new MyRepositoryImpl()
+                }
 
-        @CompileStatic
-        public class MyClass {
-            static MyRepository factory() {
-                return new MyRepositoryImpl()
+                static void main(String[] args) {
+                    MyRepository r = factory()
+                    r.delete('foo')
+                }
             }
 
-            static void main(String[] args) {
-                MyRepository r = factory()
-                r.delete('foo')
+            @CompileStatic
+            interface CrudRepository<T, S extends Serializable> {
+                void delete(T arg)
+                void delete(S arg)
             }
-        }
-
-        @CompileStatic
-        interface CrudRepository<T, S extends Serializable> {
-            void delete(T arg);
-            void delete(S arg);
-        }
 
-        @CompileStatic
-        interface MyRepository2 extends CrudRepository<String, Long> {
-        }
-
-        @CompileStatic
-        interface MyRepository extends MyRepository2 {
-        }
+            @CompileStatic
+            interface MyRepository2 extends CrudRepository<String, Long> {
+            }
 
-        @CompileStatic
-        class MyRepositoryImpl implements MyRepository {
-            @Override
-            public void delete(String arg) {
-                System.out.println("String");
-                assert true
+            @CompileStatic
+            interface MyRepository extends MyRepository2 {
             }
 
-            @Override
-            public void delete(Long arg) {
-                System.out.println("Long");
-                assert false: 'wrong method invoked'
+            @CompileStatic
+            class MyRepositoryImpl implements MyRepository {
+                @Override
+                public void delete(String arg) {
+                    System.out.println('String')
+                    assert true
+                }
+
+                @Override
+                public void delete(Long arg) {
+                    System.out.println('Long')
+                    assert false: 'wrong method invoked'
+                }
             }
-        }
         '''
     }
 
+    @Test
     void testCompileStatic4() {
-        assertScript '''
-        import java.io.Serializable;
-
-        import groovy.transform.CompileStatic;
-        import groovy.transform.TypeChecked;
+        assertScript shell, '''
+            @CompileStatic
+            public class MyClass {
+                static MyRepository factory() {
+                    return new MyRepositoryImpl()
+                }
 
-        @CompileStatic
-        public class MyClass {
-            static MyRepository factory() {
-                return new MyRepositoryImpl()
+                static void main(String[] args) {
+                    MyRepository r = factory()
+                    r.delete('foo')
+                }
             }
 
-            static void main(String[] args) {
-                MyRepository r = factory()
-                r.delete('foo')
+            @CompileStatic
+            abstract class CrudRepository<T, S extends Serializable> {
+                abstract void delete(T arg)
+                abstract void delete(S arg)
             }
-        }
-
-        @CompileStatic
-        abstract class CrudRepository<T, S extends Serializable> {
-            abstract void delete(T arg);
-            abstract void delete(S arg);
-        }
 
-        @CompileStatic
-        abstract class MyRepository2 extends CrudRepository<String, Long> {
-        }
-
-        @CompileStatic
-        abstract class MyRepository extends MyRepository2 {
-        }
+            @CompileStatic
+            abstract class MyRepository2 extends CrudRepository<String, Long> {
+            }
 
-        @CompileStatic
-        class MyRepositoryImpl extends MyRepository {
-            @Override
-            public void delete(String arg) {
-                System.out.println("String");
-                assert true
+            @CompileStatic
+            abstract class MyRepository extends MyRepository2 {
             }
 
-            @Override
-            public void delete(Long arg) {
-                System.out.println("Long");
-                assert false: 'wrong method invoked'
+            @CompileStatic
+            class MyRepositoryImpl extends MyRepository {
+                @Override
+                public void delete(String arg) {
+                    System.out.println('String')
+                    assert true
+                }
+
+                @Override
+                public void delete(Long arg) {
+                    System.out.println('Long')
+                    assert false: 'wrong method invoked'
+                }
             }
-        }
         '''
     }
 
+    @Test
     void testCompileStatic5() {
-        assertScript '''
-        import java.io.Serializable;
+        assertScript shell, '''
+            @CompileStatic
+            public class MyClass {
+                static MyRepository factory() {
+                    return new MyRepositoryImpl()
+                }
 
-        import groovy.transform.CompileStatic;
-        import groovy.transform.TypeChecked;
-
-        @CompileStatic
-        public class MyClass {
-            static MyRepository factory() {
-                return new MyRepositoryImpl()
+                static void main(String[] args) {
+                    MyRepository r = factory()
+                    r.delete('foo')
+                }
             }
 
-            static void main(String[] args) {
-                MyRepository r = factory()
-                r.delete('foo')
+            @CompileStatic
+            interface CrudRepository<T, S extends Serializable> {
+                void delete(T arg)
+                void delete(S arg)
             }
-        }
 
-        @CompileStatic
-        interface CrudRepository<T, S extends Serializable> {
-            void delete(T arg);
-            void delete(S arg);
-        }
-
-        @CompileStatic
-        abstract class MyRepository2 implements CrudRepository<String, Long> {
-        }
-
-        @CompileStatic
-        abstract class MyRepository extends MyRepository2 {
-        }
+            @CompileStatic
+            abstract class MyRepository2 implements CrudRepository<String, Long> {
+            }
 
-        @CompileStatic
-        class MyRepositoryImpl extends MyRepository {
-            @Override
-            public void delete(String arg) {
-                System.out.println("String");
-                assert true
+            @CompileStatic
+            abstract class MyRepository extends MyRepository2 {
             }
 
-            @Override
-            public void delete(Long arg) {
-                System.out.println("Long");
-                assert false: 'wrong method invoked'
+            @CompileStatic
+            class MyRepositoryImpl extends MyRepository {
+                @Override
+                public void delete(String arg) {
+                    System.out.println('String')
+                    assert true
+                }
+
+                @Override
+                public void delete(Long arg) {
+                    System.out.println('Long')
+                    assert false: 'wrong method invoked'
+                }
             }
-        }
         '''
     }
 
+    @Test
     void testCompileStatic6() {
-        assertScript '''
-        import java.io.Serializable;
-        import groovy.transform.CompileStatic;
-
-        @CompileStatic
-        class Repository<T, S extends Serializable> {
-            void delete(T arg) { assert true }
-            void delete(S arg) { assert false: 'wrong method invoked' }
-        }
-
-        @CompileStatic
-        def test() {
-            Repository<String, Long> r = new Repository<String, Long>()
-            r.delete('foo')
-        }
-
-        test()
+        assertScript shell, '''
+            @CompileStatic
+            class Repository<T, S extends Serializable> {
+                void delete(T arg) { assert true }
+                void delete(S arg) { assert false: 'wrong method invoked' }
+            }
+
+            @CompileStatic
+            def test() {
+                Repository<String, Long> r = new Repository<String, Long>()
+                r.delete('foo')
+            }
+
+            test()
         '''
     }
 
+    @Test
     void testCompileStatic7() {
-        assertScript '''
-        @groovy.transform.CompileStatic
-        class Trie<T> {}
+        assertScript shell, '''
+            @CompileStatic
+            class Trie<T> {
+            }
 
-        @groovy.transform.CompileStatic
-        class Base<T> {
-            protected List<Trie<T>> list
+            @CompileStatic
+            class Base<T> {
+                protected List<Trie<T>> list
 
-            Base() {
-                list = new ArrayList<Trie<T>>()
-                list.add(new Trie<String>())
+                Base() {
+                    list = new ArrayList<Trie<T>>()
+                    list.add(new Trie<String>()) // should fail?
+                }
             }
-        }
 
-        @groovy.transform.CompileStatic
-        class Derived extends Base<String> {
-            Trie<String> getFirstElement() {
-                list.get(0)
+            @CompileStatic
+            class Derived extends Base<String> {
+                Trie<String> getFirstElement() {
+                    list.get(0)
+                }
             }
-        }
 
-        assert new Derived().getFirstElement() instanceof Trie
+            assert new Derived().getFirstElement() instanceof Trie
         '''
     }
 
+    @Test
     void testCompileStatic8() {
-        assertScript '''
-        @groovy.transform.CompileStatic
-        class Trie<T> {}
-
-        @groovy.transform.CompileStatic
-        class Base<T> extends ArrayList<Trie<T>> {
+        assertScript shell, '''
+            @CompileStatic
+            class Trie<T> {
+            }
 
-            Base() {
-                this.add(new Trie<String>())
+            @CompileStatic
+            class Base<T> extends ArrayList<Trie<T>> {
             }
-        }
 
-        @groovy.transform.CompileStatic
-        class Derived extends Base<String> {
-            Trie<String> getFirstElement() {
-                this.get(0)
+            @groovy.transform.CompileStatic
+            class Derived extends Base<String> {
+                Derived() {
+                    add(new Trie<String>())
+                }
+                Trie<String> getFirstElement() {
+                    get(0)
+                }
             }
-        }
 
-        assert new Derived().getFirstElement() instanceof Trie
+            assert new Derived().firstElement instanceof Trie
         '''
     }
 }
diff --git a/src/test/groovy/transform/stc/ClosureParamTypeInferenceSTCTest.groovy b/src/test/groovy/transform/stc/ClosureParamTypeInferenceSTCTest.groovy
index 112394283d..65a9cda04b 100644
--- a/src/test/groovy/transform/stc/ClosureParamTypeInferenceSTCTest.groovy
+++ b/src/test/groovy/transform/stc/ClosureParamTypeInferenceSTCTest.groovy
@@ -95,66 +95,66 @@ class ClosureParamTypeInferenceSTCTest extends StaticTypeCheckingTestCase {
 
     void testInferenceForDGM_collectManyUsingFirstSignature() {
         assertScript '''
-def map = [bread:3, milk:5, butter:2]
-def result = map.collectMany{ k, v -> k.startsWith('b') ? k.toList() : [] }
-assert result == ['b', 'r', 'e', 'a', 'd', 'b', 'u', 't', 't', 'e', 'r']
-'''
+            def map = [bread:3, milk:5, butter:2]
+            def result = map.collectMany{ k, v -> k.startsWith('b') ? k.toList() : [] }
+            assert result == ['b', 'r', 'e', 'a', 'd', 'b', 'u', 't', 't', 'e', 'r']
+        '''
     }
 
     void testInferenceForDGM_collectManyUsingSecondSignature() {
         assertScript '''
-def map = [bread:3, milk:5, butter:2]
-def result = map.collectMany{ e -> e.key.startsWith('b') ? e.key.toList() : [] }
-assert result == ['b', 'r', 'e', 'a', 'd', 'b', 'u', 't', 't', 'e', 'r']
-'''
+            def map = [bread:3, milk:5, butter:2]
+            def result = map.collectMany{ e -> e.key.startsWith('b') ? e.key.toList() : [] }
+            assert result == ['b', 'r', 'e', 'a', 'd', 'b', 'u', 't', 't', 'e', 'r']
+        '''
     }
 
     void testInferenceForDGM_collectManyUsingSecondSignatureAndImplicitIt() {
         assertScript '''
-def map = [bread:3, milk:5, butter:2]
-def result = map.collectMany{ it.key.startsWith('b') ? it.key.toList() : [] }
-assert result == ['b', 'r', 'e', 'a', 'd', 'b', 'u', 't', 't', 'e', 'r']
-'''
+            def map = [bread:3, milk:5, butter:2]
+            def result = map.collectMany{ it.key.startsWith('b') ? it.key.toList() : [] }
+            assert result == ['b', 'r', 'e', 'a', 'd', 'b', 'u', 't', 't', 'e', 'r']
+        '''
     }
 
-    void testInferenceForDGM_CollectMap() {
+    void testInferenceForDGM_collectMap() {
         assertScript '''
-        assert [a: 'foo',b:'bar'].collect { k,v -> k+v } == ['afoo','bbar']
-        assert [a: 'foo',b:'bar'].collect { e -> e.key+e.value } == ['afoo','bbar']
-        assert [a: 'foo',b:'bar'].collect { it.key+it.value } == ['afoo','bbar']
-'''
+            assert [a: 'foo',b:'bar'].collect { k,v -> k+v } == ['afoo','bbar']
+            assert [a: 'foo',b:'bar'].collect { e -> e.key+e.value } == ['afoo','bbar']
+            assert [a: 'foo',b:'bar'].collect { it.key+it.value } == ['afoo','bbar']
+        '''
     }
 
-    void testInferenceForDGM_CollectMapWithCollection() {
+    void testInferenceForDGM_collectMapWithCollection() {
         assertScript '''
-        assert [a: 'foo',b:'bar'].collect([]) { k,v -> k+v } == ['afoo','bbar']
-        assert [a: 'foo',b:'bar'].collect([]) { e -> e.key+e.value } == ['afoo','bbar']
-        assert [a: 'foo',b:'bar'].collect([]) { it.key+it.value } == ['afoo','bbar']
-'''
+            assert [a: 'foo',b:'bar'].collect([]) { k,v -> k+v } == ['afoo','bbar']
+            assert [a: 'foo',b:'bar'].collect([]) { e -> e.key+e.value } == ['afoo','bbar']
+            assert [a: 'foo',b:'bar'].collect([]) { it.key+it.value } == ['afoo','bbar']
+        '''
     }
 
     void testInferenceForDGM_collectEntries() {
         assertScript '''
             assert ['a','b','c'].collectEntries { [it, it.toUpperCase() ]} == [a:'A',b:'B',c:'C']
-'''
+        '''
     }
 
     void testInferenceForDGM_collectEntriesWithCollector() {
         assertScript '''
             assert ['a','b','c'].collectEntries([:]) { [it, it.toUpperCase() ]} == [a:'A',b:'B',c:'C']
-'''
+        '''
     }
 
     void testInferenceForDGM_collectEntriesIterator() {
         assertScript '''
             assert ['a','b','c'].iterator().collectEntries { [it, it.toUpperCase() ]} == [a:'A',b:'B',c:'C']
-'''
+        '''
     }
 
     void testInferenceForDGM_collectEntriesIteratorWithCollector() {
         assertScript '''
             assert ['a','b','c'].iterator().collectEntries([:]) { [it, it.toUpperCase() ]} == [a:'A',b:'B',c:'C']
-'''
+        '''
     }
 
     void testInferenceForDGM_collectEntriesOnMap() {
@@ -162,7 +162,7 @@ assert result == ['b', 'r', 'e', 'a', 'd', 'b', 'u', 't', 't', 'e', 'r']
             assert [a:'a',b:'b',c:'c'].collectEntries { k,v -> [k+k, v.toUpperCase() ]} == [aa:'A',bb:'B',cc:'C']
             assert [a:'a',b:'b',c:'c'].collectEntries { e -> [e.key+e.key, e.value.toUpperCase() ]} == [aa:'A',bb:'B',cc:'C']
             assert [a:'a',b:'b',c:'c'].collectEntries { [it.key+it.key, it.value.toUpperCase() ]} == [aa:'A',bb:'B',cc:'C']
-'''
+        '''
     }
 
     void testInferenceForDGM_collectEntriesOnMapWithCollector() {
@@ -170,39 +170,39 @@ assert result == ['b', 'r', 'e', 'a', 'd', 'b', 'u', 't', 't', 'e', 'r']
             assert [a:'a',b:'b',c:'c'].collectEntries([:]) { k,v -> [k+k, v.toUpperCase() ]} == [aa:'A',bb:'B',cc:'C']
             assert [a:'a',b:'b',c:'c'].collectEntries([:]) { e -> [e.key+e.key, e.value.toUpperCase() ]} == [aa:'A',bb:'B',cc:'C']
             assert [a:'a',b:'b',c:'c'].collectEntries([:]) { [it.key+it.key, it.value.toUpperCase() ]} == [aa:'A',bb:'B',cc:'C']
-'''
+        '''
     }
 
     void testInferenceForDGM_collectEntriesOnArray() {
         assertScript '''
             String[] array = ['a','b','c']
             assert array.collectEntries { [it, it.toUpperCase() ]} == [a:'A',b:'B',c:'C']
-'''
+        '''
     }
 
     void testInferenceForDGM_collectEntriesOnArrayWithCollector() {
         assertScript '''
             String[] array = ['a','b','c']
             assert array.collectEntries([:]) { [it, it.toUpperCase() ]} == [a:'A',b:'B',c:'C']
-'''
+        '''
     }
 
     void testInferenceForDGM_collectManyOnIterable() {
         assertScript '''
             assert (0..5).collectMany { [it, 2*it ]} == [0,0,1,2,2,4,3,6,4,8,5,10]
-'''
+        '''
     }
 
     void testInferenceForDGM_collectManyOnIterator() {
         assertScript '''
             assert (0..5).iterator().collectMany { [it, 2*it ]} == [0,0,1,2,2,4,3,6,4,8,5,10]
-'''
+        '''
     }
 
     void testInferenceForDGM_collectManyOnIterableWithCollector() {
         assertScript '''
             assert (0..5).collectMany([]) { [it, 2*it ]} == [0,0,1,2,2,4,3,6,4,8,5,10]
-'''
+        '''
     }
 
     void testInferenceForDGM_collectManyOnMap() {
@@ -210,7 +210,7 @@ assert result == ['b', 'r', 'e', 'a', 'd', 'b', 'u', 't', 't', 'e', 'r']
             assert [a:0,b:1,c:2].collectMany { k,v -> [v, 2*v ]} == [0,0,1,2,2,4]
             assert [a:0,b:1,c:2].collectMany { e -> [e.value, 2*e.value ]} == [0,0,1,2,2,4]
             assert [a:0,b:1,c:2].collectMany { [it.value, 2*it.value ]} == [0,0,1,2,2,4]
-'''
+        '''
     }
 
     void testInferenceForDGM_collectManyOnMapWithCollector() {
@@ -218,14 +218,14 @@ assert result == ['b', 'r', 'e', 'a', 'd', 'b', 'u', 't', 't', 'e', 'r']
             assert [a:0,b:1,c:2].collectMany([]) { k,v -> [v, 2*v ]} == [0,0,1,2,2,4]
             assert [a:0,b:1,c:2].collectMany([]) { e -> [e.value, 2*e.value ]} == [0,0,1,2,2,4]
             assert [a:0,b:1,c:2].collectMany([]) { [it.value, 2*it.value ]} == [0,0,1,2,2,4]
-'''
+        '''
     }
 
     void testInferenceForDGM_collectManyOnArray() {
         assertScript '''
             Integer[] arr = (0..5) as Integer[]
             assert arr.collectMany { [it, 2*it ]} == [0,0,1,2,2,4,3,6,4,8,5,10]
-'''
+        '''
     }
 
     void testInferenceOnNonExtensionMethod() {
@@ -620,31 +620,32 @@ assert result == ['b', 'r', 'e', 'a', 'd', 'b', 'u', 't', 't', 'e', 'r']
         '''
     }
 
-    void testInferenceForEachWithIndexOnMap() {
+    void testInferenceForDGM_eachWithIndexOnMap() {
         assertScript '''
             [a:'A',bb:'B',ccc:'C'].eachWithIndex { k,v,i -> assert k.toUpperCase() == v*(1+i) }
             [a:'A',bb:'B',ccc:'C'].eachWithIndex { e,i -> assert e.key.toUpperCase() == e.value*(1+i) }
         '''
     }
-    void testInferenceForEachWithIndexOnIterable() {
+    void testInferenceForDGM_eachWithIndexOnIterable() {
         assertScript '''
             ['1','2','3'].eachWithIndex { e,i -> assert e.toUpperCase() == String.valueOf(1+i) }
         '''
     }
-    void testInferenceForEachWithIndexOnIterator() {
+    void testInferenceForDGM_eachWithIndexOnIterator() {
         assertScript '''
             ['1','2','3'].iterator().eachWithIndex { e,i -> assert e.toUpperCase() == String.valueOf(1+i) }
         '''
     }
-
-    void testInferenceForDGM_everyOnMap() {
+    void testInferenceForDGM_eachWithIndexOnRecursiveIterable() { // GROOVY-10651
         assertScript '''
-            assert [a:'A',b:'B',cc:'CC'].every { String k, String v -> k == v.toLowerCase() }
-            assert [a:'A',b:'B',cc:'CC'].every { k, v -> k == v.toLowerCase() }
-            assert [a:'A',b:'B',cc:'CC'].every { e -> e.key == e.value.toLowerCase() }
-            assert [a:'A',b:'B',cc:'CC'].every { it.key == it.value.toLowerCase() }
+            void proc(groovy.transform.stc.TreeNode node) {
+                node.eachWithIndex { child, index ->
+                    proc(child) // recurse
+                }
+            }
         '''
     }
+
     void testInferenceForDGM_everyOnIterable() {
         assertScript '''
             assert ['foo','bar','baz'].every { String it -> it.length() == 3 }
@@ -666,6 +667,14 @@ assert result == ['b', 'r', 'e', 'a', 'd', 'b', 'u', 't', 't', 'e', 'r']
             assert items.every { String s -> s.length() == 3 }
         '''
     }
+    void testInferenceForDGM_everyOnMap() {
+        assertScript '''
+            assert [a:'A',b:'B',cc:'CC'].every { String k, String v -> k == v.toLowerCase() }
+            assert [a:'A',b:'B',cc:'CC'].every { k, v -> k == v.toLowerCase() }
+            assert [a:'A',b:'B',cc:'CC'].every { e -> e.key == e.value.toLowerCase() }
+            assert [a:'A',b:'B',cc:'CC'].every { it.key == it.value.toLowerCase() }
+        '''
+    }
 
     void testInferenceForDGM_findIndexOf() {
         assertScript '''
@@ -700,26 +709,6 @@ assert result == ['b', 'r', 'e', 'a', 'd', 'b', 'u', 't', 't', 'e', 'r']
         '''
     }
 
-    void testInferenceForDGM_findResult() {
-        assertScript '''
-            String[] items1 = ['foo','bar','baz']
-            assert items1.findResult { it.startsWith('ba') ? it : null } == 'bar'
-            def items2 = ['foo','bar','baz']
-            assert items2.findResult { it.startsWith('ba') ? it : null } == 'bar'
-            assert items2.iterator().findResult { it.startsWith('ba') ? it : null } == 'bar'
-        '''
-    }
-
-    void testInferenceForDGM_findResults() {
-        assertScript '''
-            String[] items1 = ['foo','bar','baz']
-            assert items1.findResults { it.startsWith('ba') ? it : null } == ['bar', 'baz']
-            def items2 = ['foo','bar','baz']
-            assert items2.findResults { it.startsWith('ba') ? it : null } == ['bar', 'baz']
-            assert items2.iterator().findResults { it.startsWith('ba') ? it : null } == ['bar', 'baz']
-        '''
-    }
-
     void testInferenceForDGM_split() {
         assertScript '''
             String[] items1 = ['foo','bar','baz']
@@ -816,6 +805,15 @@ assert result == ['b', 'r', 'e', 'a', 'd', 'b', 'u', 't', 't', 'e', 'r']
             assert [a:1, b:2, c:3].findResult('a') { "${it.key.toUpperCase()}$it.value"=='C4'?2*it.value:null } == 'a'
         '''
     }
+    void testInferenceForDGM_findResult() {
+        assertScript '''
+            String[] items1 = ['foo','bar','baz']
+            assert items1.findResult { it.startsWith('ba') ? it : null } == 'bar'
+            def items2 = ['foo','bar','baz']
+            assert items2.findResult { it.startsWith('ba') ? it : null } == 'bar'
+            assert items2.iterator().findResult { it.startsWith('ba') ? it : null } == 'bar'
+        '''
+    }
 
     void testInferenceForDGM_findResultsOnIterable() {
         assertScript '''
@@ -832,6 +830,15 @@ assert result == ['b', 'r', 'e', 'a', 'd', 'b', 'u', 't', 't', 'e', 'r']
             assert [a:1, b:2, c:3].findResults { "${it.key.toUpperCase()}$it.value"=='C3'?2*it.value:null } == [6]
         '''
     }
+    void testInferenceForDGM_findResults() {
+        assertScript '''
+            String[] items1 = ['foo','bar','baz']
+            assert items1.findResults { it.startsWith('ba') ? it : null } == ['bar', 'baz']
+            def items2 = ['foo','bar','baz']
+            assert items2.findResults { it.startsWith('ba') ? it : null } == ['bar', 'baz']
+            assert items2.iterator().findResults { it.startsWith('ba') ? it : null } == ['bar', 'baz']
+        '''
+    }
 
     void testInferenceForDGM_groupByIterable() {
         assertScript '''
diff --git a/src/test/groovy/transform/stc/DefaultGroovyMethodsSTCTest.groovy b/src/test/groovy/transform/stc/DefaultGroovyMethodsSTCTest.groovy
index a2b639a9ec..dc30227909 100644
--- a/src/test/groovy/transform/stc/DefaultGroovyMethodsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/DefaultGroovyMethodsSTCTest.groovy
@@ -172,11 +172,14 @@ class DefaultGroovyMethodsSTCTest extends StaticTypeCheckingTestCase {
     }
 
     // GROOVY-7283
-    void testListWithDefaultInfersInt() {
+    void testListWithDefault() {
         assertScript '''
             def list = [].withDefault{ it.longValue() }
+            //                         ^^ int parameter
             list[0] = list[3]
-            assert list[0] == 3 && list[0].class == Long
+
+            assert list[0].class == Long
+            assert list[0] === 3L
         '''
     }
 
diff --git a/src/test/groovy/transform/stc/LoopsSTCTest.groovy b/src/test/groovy/transform/stc/LoopsSTCTest.groovy
index e8542e1181..ea816ae039 100644
--- a/src/test/groovy/transform/stc/LoopsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/LoopsSTCTest.groovy
@@ -229,22 +229,41 @@ class LoopsSTCTest extends StaticTypeCheckingTestCase {
         '''
     }
 
-    void testShouldNotInferSoftReferenceAsComponentType() {
-        assertScript '''import java.lang.reflect.Field
-            import org.codehaus.groovy.ast.stmt.ForStatement
+    // GROOVY-10651
+    void testForInLoopOnRawTypeIterable() {
+        assertScript '''
+            void test(groovy.transform.stc.TreeNode node) {
+                for (child in node) {
+                    test(child) // Cannot find matching method #test(java.lang.Object)
+                }
+            }
+        '''
+    }
 
+    // GROOVY-10651
+    void testForInLoopOnUnboundedIterable() {
+        assertScript '''
+            void test(groovy.transform.stc.TreeNode<?> node) {
+                for (child in node) {
+                    test(child) // Cannot find matching method #test(java.lang.Object)
+                }
+            }
+        '''
+    }
+
+    void testShouldNotInferSoftReferenceAsElementType() {
+        assertScript '''
             @ASTTest(phase=INSTRUCTION_SELECTION, value={
-                def FIELD_ARRAY = make(Field).makeArray()
-                def forStmt = lookup('myLoop')[0]
-                assert forStmt instanceof ForStatement
-                def collectionType = forStmt.collectionExpression.getNodeMetaData(INFERRED_TYPE)
-                assert collectionType == FIELD_ARRAY
+                def loop = lookup('loop')[0]
+                assert loop instanceof org.codehaus.groovy.ast.stmt.ForStatement
+                def collectionType = loop.collectionExpression.getNodeMetaData(INFERRED_TYPE)
+                assert collectionType == make(java.lang.reflect.Field).makeArray()
             })
-            void forInTest() {
-                int i = 0;
-                myLoop:
+            void test() {
+                int i = 0
+                loop:
                 for (def field : String.class.declaredFields) {
-                    i++;
+                    i++
                 }
                 assert i > 0
             }
@@ -252,56 +271,53 @@ class LoopsSTCTest extends StaticTypeCheckingTestCase {
     }
 
     // GROOVY-5640
-    void testShouldInferComponentTypeAsIterableOfNodes() {
-        assertScript '''import org.codehaus.groovy.ast.stmt.ForStatement
-        class Node {}
-
-        interface Traverser {
-            Iterable<Node> nodes()
-        }
-
-        class MyTraverser implements Traverser {
-
-            Iterable<Node> nodes() {
-                []
+    void testShouldInferNodeElementTypeForIterableOfNodes() {
+        assertScript '''
+            class Node {
             }
-        }
-
-        @ASTTest(phase=INSTRUCTION_SELECTION, value= {
-            def forStmt = lookup('loop')[0]
-            assert forStmt instanceof ForStatement
-            def collectionType = forStmt.collectionExpression.getNodeMetaData(INFERRED_TYPE)
-            assert collectionType == make(Iterable)
-            assert collectionType.isUsingGenerics()
-            assert collectionType.genericsTypes.length == 1
-            assert collectionType.genericsTypes[0].type.name == 'Node'
-        })
-        void test() {
-            loop:
-            for (def node : new MyTraverser().nodes()) {
-                println node.class.name
+            interface Traverser {
+                Iterable<Node> nodes()
+            }
+            class MyTraverser implements Traverser {
+                Iterable<Node> nodes() {
+                    []
+                }
             }
-        }
 
+            @ASTTest(phase=INSTRUCTION_SELECTION, value={
+                def loop = lookup('loop')[0]
+                assert loop instanceof org.codehaus.groovy.ast.stmt.ForStatement
+                def collectionType = loop.collectionExpression.getNodeMetaData(INFERRED_TYPE)
+                assert collectionType == make(Iterable)
+                assert collectionType.isUsingGenerics()
+                assert collectionType.genericsTypes.length == 1
+                assert collectionType.genericsTypes[0].type.name == 'Node'
+            })
+            void test() {
+                loop:
+                for (def node : new MyTraverser().nodes()) {
+                    println node.class.name
+                }
+            }
         '''
     }
 
     // GROOVY-5641
     void testShouldInferLoopElementTypeWithUndeclaredType() {
-        assertScript '''import org.codehaus.groovy.ast.stmt.ForStatement
-        @ASTTest(phase=INSTRUCTION_SELECTION, value={
-            def forStmt = lookup('loop')[0]
-            assert forStmt instanceof ForStatement
-            def collectionType = forStmt.collectionExpression.getNodeMetaData(INFERRED_TYPE)
-            assert collectionType == make(IntRange)
-        })
-        void foo() {
-            int[] perm = new int[10]
-            loop:
-            for (i in 0..<10) {
-              assert perm[i-0] == 0
+        assertScript '''
+            @ASTTest(phase=INSTRUCTION_SELECTION, value={
+                def loop = lookup('loop')[0]
+                assert loop instanceof org.codehaus.groovy.ast.stmt.ForStatement
+                def collectionType = loop.collectionExpression.getNodeMetaData(INFERRED_TYPE)
+                assert collectionType == make(IntRange)
+            })
+            void test() {
+                int[] ints = new int[10]
+                loop:
+                for (i in 0..<10) {
+                  assert ints[i-0] == 0
+                }
             }
-        }
         '''
     }
 }
diff --git a/src/test/groovy/transform/stc/TreeNode.java b/src/test/groovy/transform/stc/TreeNode.java
new file mode 100644
index 0000000000..b794d2b5b6
--- /dev/null
+++ b/src/test/groovy/transform/stc/TreeNode.java
@@ -0,0 +1,23 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package groovy.transform.stc;
+
+public abstract class TreeNode<TN extends TreeNode<?>> implements Iterable<TN> {
+  //public java.util.Iterator<TN> iterator() { return null; }
+}
diff --git a/src/test/org/codehaus/groovy/ast/GenericsTypeTest.groovy b/src/test/org/codehaus/groovy/ast/GenericsTypeTest.groovy
index 858cdffa90..f26b177cfd 100644
--- a/src/test/org/codehaus/groovy/ast/GenericsTypeTest.groovy
+++ b/src/test/org/codehaus/groovy/ast/GenericsTypeTest.groovy
@@ -72,23 +72,22 @@ public class GenericsTypeTest extends GenericsTestCase {
     }
 
     void testNestedGenerics() {
-        def listStringType = extractTypesFromCode('List<String> type').type
-        def listInteger = extractTypesFromCode('List<Integer> type').type
-        def stringListType = extractTypesFromCode('org.codehaus.groovy.ast.GenericsTypeTest.StringList type').type
+        def listStringType  = extractTypesFromCode('List<String> type').type
+        def listIntegerType = extractTypesFromCode('List<Integer> type').type
+        def stringListType  = extractTypesFromCode('org.codehaus.groovy.ast.GenericsTypeTest.StringList type').type
         def integerListType = extractTypesFromCode('org.codehaus.groovy.ast.GenericsTypeTest.IntegerList type').type
+
         def typeinfo = extractTypesFromCode('List<? extends List<String>> type')
         def generics = typeinfo.generics[0]
+
         assert generics.toString() == '? extends java.util.List<java.lang.String>'
-        assert generics.isCompatibleWith(ClassHelper.LIST_TYPE)
-        assert generics.isCompatibleWith(ClassHelper.make(LinkedList))
-        assert !generics.isCompatibleWith(ClassHelper.OBJECT_TYPE)
         assert generics.isCompatibleWith(listStringType)
-        assert !generics.isCompatibleWith(listInteger)
+        assert !generics.isCompatibleWith(listIntegerType)
         assert generics.isCompatibleWith(stringListType)
         assert !generics.isCompatibleWith(integerListType)
-
-        def classNode = extractTypesFromCode('List<Integer> type').type
-        assert !generics.isCompatibleWith(classNode)
+        assert generics.isCompatibleWith(ClassHelper.LIST_TYPE.plainNodeReference)
+        assert generics.isCompatibleWith(ClassHelper.make(LinkedList).plainNodeReference)
+        assert !generics.isCompatibleWith(ClassHelper.OBJECT_TYPE)
     }
 
     void testNestedGenerics2() {
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/StaticCompileDGMTest.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/StaticCompileDGMTest.groovy
index a1f378c557..ad0dd6899a 100644
--- a/src/test/org/codehaus/groovy/classgen/asm/sc/StaticCompileDGMTest.groovy
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/StaticCompileDGMTest.groovy
@@ -23,7 +23,7 @@ import groovy.transform.stc.DefaultGroovyMethodsSTCTest
 /**
  * Unit tests for static compilation: default groovy methods.
  */
-class StaticCompileDGMTest extends DefaultGroovyMethodsSTCTest implements StaticCompilationTestSupport {
+final class StaticCompileDGMTest extends DefaultGroovyMethodsSTCTest implements StaticCompilationTestSupport {
 
     // GROOVY-10238
     void testMapWithDefault() {
@@ -35,7 +35,7 @@ class StaticCompileDGMTest extends DefaultGroovyMethodsSTCTest implements Static
                 @Canonical
                 @CompileStatic
                 static class Inner {
-                    Map<String,Object> map = [:].withDefault { new Object() } // NoSuchMethodError: java.util.Map.withDefault(Lgroovy/lang/Closure;)
+                    Map map = [:].withDefault { new Object() } // NoSuchMethodError: java.util.Map.withDefault(Lgroovy/lang/Closure;)
                 }
             }
 
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy6558Bug.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy6558Bug.groovy
index 8ca23afe16..cecc3d4e35 100644
--- a/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy6558Bug.groovy
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy6558Bug.groovy
@@ -21,37 +21,41 @@ package org.codehaus.groovy.classgen.asm.sc.bugs
 import groovy.transform.stc.StaticTypeCheckingTestCase
 import org.codehaus.groovy.classgen.asm.sc.StaticCompilationTestSupport
 
-class Groovy6558Bug extends StaticTypeCheckingTestCase implements StaticCompilationTestSupport {
+final class Groovy6558Bug extends StaticTypeCheckingTestCase implements StaticCompilationTestSupport {
 
-    void testShouldCompilePostfixPlusOnMap() {
-            assertScript '''
-    Map<String,Integer> frequencies = [a:0]
-    frequencies[ 'a' ]++
-    assert frequencies.a == 1
+    void testPostfixPlusOnMap() {
+        assertScript '''
+            Map<String, Integer> frequencies = [a:0]
+            frequencies['a']++
+
+            assert frequencies.a == 1
         '''
     }
 
-    void testShouldCompilePostfixPlusOnMapWithDefault() {
-            assertScript '''
-    Map<String,Integer> frequencies = [:].withDefault { 0 }
-    frequencies[ 'a' ]++
-    assert frequencies.a == 1
+    void testPostfixPlusOnMapWithDefault() {
+        assertScript '''
+            Map<String, Integer> frequencies = [:]
+            (frequencies.withDefault { 0 }['a'])++
+
+            assert frequencies.a == 1
         '''
     }
 
-    void testShouldCompilePrefixPlusOnMap() {
-            assertScript '''
-    Map<String,Integer> frequencies = [a:0]
-    ++frequencies[ 'a' ]
-    assert frequencies.a == 1
+    void testPrefixPlusOnMap() {
+        assertScript '''
+            Map<String, Integer> frequencies = [a:0]
+            ++frequencies['a']
+
+            assert frequencies.a == 1
         '''
     }
 
-    void testShouldCompilePrefixPlusOnMapWithDefault() {
-            assertScript '''
-    Map<String,Integer> frequencies = [:].withDefault { 0 }
-    ++frequencies[ 'a' ]
-    assert frequencies.a == 1
+    void testPrefixPlusOnMapWithDefault() {
+        assertScript '''
+            Map<String, Integer> frequencies = [:]
+            ++(frequencies.withDefault { 0 }['a'])
+
+            assert frequencies.a == 1
         '''
     }
 }
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy6564Bug.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy6564Bug.groovy
index b15a994ae3..2f6e97f087 100644
--- a/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy6564Bug.groovy
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy6564Bug.groovy
@@ -21,27 +21,29 @@ package org.codehaus.groovy.classgen.asm.sc.bugs
 import groovy.transform.stc.StaticTypeCheckingTestCase
 import org.codehaus.groovy.classgen.asm.sc.StaticCompilationTestSupport
 
-class Groovy6564Bug extends StaticTypeCheckingTestCase implements StaticCompilationTestSupport {
+final class Groovy6564Bug extends StaticTypeCheckingTestCase implements StaticCompilationTestSupport {
 
     void testShouldNotRequireIntermediateVariableToPass() {
         assertScript '''
             class Stream<T> implements Iterable<T> {
-                public static Stream<String> from(BufferedReader reader) { new Stream(data: ['a', 'b', 'c']) }
+                static Stream<String> from(BufferedReader reader) {
+                    new Stream<>(data: ['a', 'b', 'c'])
+                }
 
                 List<T> data
 
-                public Iterator<T> iterator() { data.iterator() }
+                Iterator<T> iterator() { data.iterator() }
 
-                public <U> Stream<U> flatMap(Closure<? extends Collection<U>> closure) {
-                    new Stream(data: data.collect(closure).flatten() as List)
+                def <U> Stream<U> flatMap(Closure<? extends Collection<U>> closure) {
+                    new Stream<U>(data: data.collect(closure).flatten() as List)
                 }
             }
 
-            Map<String, Integer> frequencies = [:].withDefault { 0 }
-            BufferedReader r = null
-            Stream.from(r)
-                .flatMap { String it -> it.toList() }
-                .each { String it -> frequencies[it.toUpperCase()]++ }
+            Map<String, Integer> frequencies = new HashMap<>()
+            frequencies = frequencies.withDefault { 0 }
+            Stream.from(null)
+                .flatMap { String s -> s.toList() }
+                .each { String s -> frequencies[s.toUpperCase()]++ }
             assert frequencies == [A:1, B:1, C:1]
         '''
     }
@@ -49,21 +51,23 @@ class Groovy6564Bug extends StaticTypeCheckingTestCase implements StaticCompilat
     void testShouldNotRequireIntermediateVariableToPassWithEachParamInference() {
         assertScript '''
             class Stream<T> implements Iterable<T> {
-                public static Stream<String> from(BufferedReader reader) { new Stream(data: ['a', 'b', 'c']) }
+                static Stream<String> from(BufferedReader reader) {
+                    new Stream<>(data: ['a', 'b', 'c'])
+                }
 
                 List<T> data
 
-                public Iterator<T> iterator() { data.iterator() }
+                Iterator<T> iterator() { data.iterator() }
 
-                public <U> Stream<U> flatMap(Closure<? extends Collection<U>> closure) {
-                    new Stream(data: data.collect(closure).flatten() as List)
+                def <U> Stream<U> flatMap(Closure<? extends Collection<U>> closure) {
+                    new Stream<U>(data: data.collect(closure).flatten() as List)
                 }
             }
 
-            Map<String, Integer> frequencies = [:].withDefault { 0 }
-            BufferedReader r = null
-            Stream.from(r)
-                .flatMap { String it -> it.toList() }
+            Map<String, Integer> frequencies = new HashMap<>()
+            frequencies = frequencies.withDefault { 0 }
+            Stream.from(null)
+                .flatMap { String s -> s.toList() }
                 .each { frequencies[it.toUpperCase()]++ }
             assert frequencies == [A:1, B:1, C:1]
         '''
diff --git a/src/test/org/codehaus/groovy/transform/InheritConstructorsTransformTest.groovy b/src/test/org/codehaus/groovy/transform/InheritConstructorsTransformTest.groovy
index 337893b09b..05e31a0f54 100644
--- a/src/test/org/codehaus/groovy/transform/InheritConstructorsTransformTest.groovy
+++ b/src/test/org/codehaus/groovy/transform/InheritConstructorsTransformTest.groovy
@@ -18,26 +18,37 @@
  */
 package org.codehaus.groovy.transform
 
-import groovy.test.GroovyShellTestCase
+import org.junit.Test
 
-class InheritConstructorsTransformTest extends GroovyShellTestCase {
+import static groovy.test.GroovyAssert.assertScript
+import static groovy.test.GroovyAssert.shouldFail
 
+final class InheritConstructorsTransformTest {
+
+    private final GroovyShell shell = GroovyShell.withConfig {
+        imports { star 'groovy.transform' }
+    }
+
+    @Test
     void testStandardCase() {
-        assertScript '''
-            import groovy.transform.InheritConstructors
-            @InheritConstructors class CustomException extends RuntimeException { }
+        assertScript shell, '''
+            @InheritConstructors
+            class CustomException extends RuntimeException {
+            }
+
             def ce = new CustomException('foo')
             assert ce.message == 'foo'
         '''
     }
 
+    @Test
     void testOverrideCase() {
-        assertScript '''
-            import groovy.transform.InheritConstructors
+        assertScript shell, '''
             @InheritConstructors
             class CustomException2 extends RuntimeException {
                 CustomException2() { super('bar') }
             }
+
             def ce = new CustomException2()
             assert ce.message == 'bar'
             ce = new CustomException2('foo')
@@ -45,37 +56,43 @@ class InheritConstructorsTransformTest extends GroovyShellTestCase {
         '''
     }
 
+    @Test
     void testChainedCase() {
-        assertScript '''
-            import groovy.transform.InheritConstructors
+        assertScript shell, '''
             @InheritConstructors
-            class CustomException5 extends CustomException4 {}
+            class CustomException5 extends CustomException4 {
+            }
             @InheritConstructors
-            class CustomException3 extends RuntimeException {}
+            class CustomException3 extends RuntimeException {
+            }
             @InheritConstructors
-            class CustomException4 extends CustomException3 {}
+            class CustomException4 extends CustomException3 {
+            }
+
             def ce = new CustomException5('baz')
             assert ce.message == 'baz'
         '''
     }
 
-    // GROOVY-7059
+    @Test // GROOVY-7059
     void testCopyAnnotations() {
-        assertScript '''
+        assertScript shell, '''
             import java.lang.annotation.*
-            import groovy.transform.InheritConstructors
 
             @Retention(RetentionPolicy.RUNTIME)
             @Target([ElementType.CONSTRUCTOR])
-            public @interface Foo1 {}
+            public @interface Foo1 {
+            }
 
             @Retention(RetentionPolicy.SOURCE)
             @Target([ElementType.CONSTRUCTOR])
-            public @interface Foo2 {}
+            public @interface Foo2 {
+            }
 
             @Retention(RetentionPolicy.RUNTIME)
             @Target([ElementType.PARAMETER])
-            public @interface Foo3 {}
+            public @interface Foo3 {
+            }
 
             class Bar {
                 @Foo1 @Foo2
@@ -91,7 +108,8 @@ class InheritConstructorsTransformTest extends GroovyShellTestCase {
             }
 
             @InheritConstructors(constructorAnnotations=true, parameterAnnotations=true)
-            class Baz extends Bar {}
+            class Baz extends Bar {
+            }
 
             new Baz().class.constructors.each { cons ->
                 def ans = cons.annotations.toString() + cons.parameterAnnotations.toString()
@@ -113,9 +131,9 @@ class InheritConstructorsTransformTest extends GroovyShellTestCase {
         '''
     }
 
+    @Test
     void testInnerClassUsage() {
-        assertScript '''
-            import groovy.transform.InheritConstructors
+        assertScript shell, '''
             @InheritConstructors
             class Outer extends RuntimeException {
                 @InheritConstructors
@@ -142,10 +160,29 @@ class InheritConstructorsTransformTest extends GroovyShellTestCase {
         '''
     }
 
-    // GROOVY-6874
-    void testParametersWithGenericsAndCompileStatic() {
-        assertScript '''
-            import groovy.transform.*
+    @Test // GROOVY-6874
+    void testParametersWithGenericsAndCompileStatic1() {
+        assertScript shell, '''
+            abstract class A<X, Y> {
+                A(Set<Y> set) {
+                }
+            }
+
+            @CompileStatic
+            @InheritConstructors
+            class C<Z> extends A<Integer, Z> {
+                void test() {
+                    new C<Z>(new HashSet<Z>())
+                }
+            }
+
+            new C<String>().test()
+        '''
+    }
+
+    @Test // GROOVY-6874
+    void testParametersWithGenericsAndCompileStatic2() {
+        assertScript shell, '''
             import java.math.RoundingMode
 
             @CompileStatic
@@ -184,10 +221,9 @@ class InheritConstructorsTransformTest extends GroovyShellTestCase {
         '''
     }
 
-    // GROOVY-6874
-    void testParametersWithGenericsAndCompileStatic_errors() {
-        def message = shouldFail '''
-            import groovy.transform.*
+    @Test // GROOVY-6874
+    void testParametersWithGenericsAndCompileStatic3() {
+        def err = shouldFail shell, '''
             import java.math.RoundingMode
 
             @CompileStatic
@@ -223,24 +259,23 @@ class InheritConstructorsTransformTest extends GroovyShellTestCase {
             op.bar(RoundingMode.DOWN)
             assert op.toString() == '3|DOWN'
         '''
-        assert message.contains('Cannot call OrderPublisher#<init>(java.util.Deque<java.lang.Integer>) with arguments [java.util.LinkedList<java.lang.String>]')
-        assert message.contains('Cannot find matching method OrderPublisher#<init>(java.util.Date)')
-        assert message.contains('Cannot call OrderPublisher#<init>(java.util.Set<java.math.RoundingMode>) with arguments [java.util.HashSet<java.util.Date>]')
+        assert err.message.contains('Cannot call OrderPublisher#<init>(java.util.Deque<java.lang.Integer>) with arguments [java.util.LinkedList<java.lang.String>]')
+        assert err.message.contains('Cannot find matching method OrderPublisher#<init>(java.util.Date)')
+        assert err.message.contains('Cannot call OrderPublisher#<init>(java.util.Set<java.math.RoundingMode>) with arguments [java.util.HashSet<java.util.Date>]')
     }
 
-    // GROOVY-9323
+    @Test // GROOVY-9323
     void testAnnotationsCopiedForConstructorsFromPrecompiledClass() {
-        assertScript '''
-            @groovy.transform.InheritConstructors(constructorAnnotations=true)
-            class MyChildException extends org.codehaus.groovy.transform.MyException9323 {}
+        assertScript shell, """
+            @InheritConstructors(constructorAnnotations=true)
+            class MyChildException extends ${this.class.name}.MyException9323 {}
 
             def annos = MyChildException.constructors[0].annotations*.annotationType().simpleName
             assert annos.contains('Generated') && annos.contains('Deprecated')
-        '''
+        """
     }
-}
 
-class MyException9323 extends RuntimeException {
-    @Deprecated
-    MyException9323() {}
+    static class MyException9323 extends RuntimeException {
+        @Deprecated MyException9323() {}
+    }
 }
diff --git a/src/test/org/codehaus/groovy/transform/ReadWriteLockTransformTest.groovy b/src/test/org/codehaus/groovy/transform/ReadWriteLockTransformTest.groovy
index 29a1ed5999..91b19a7e7d 100644
--- a/src/test/org/codehaus/groovy/transform/ReadWriteLockTransformTest.groovy
+++ b/src/test/org/codehaus/groovy/transform/ReadWriteLockTransformTest.groovy
@@ -18,26 +18,30 @@
  */
 package org.codehaus.groovy.transform
 
-import groovy.test.GroovyShellTestCase
+import org.junit.Test
 
-class ReadWriteLockTransformTest extends GroovyShellTestCase {
+import static groovy.test.GroovyAssert.assertScript
+
+final class ReadWriteLockTransformTest {
+
+    @Test
     void testSingleton() {
-        assertScript """
+        assertScript '''
             import groovy.transform.*
 
             @CompileStatic
             class Counters {
-                public final Map<String,Integer> map = [:].withDefault { 0 }
+                private final Map<String,Integer> map = [:]
 
                 @WithReadLock
                 int get(String id) {
-                    map.get(id)
+                    map.getOrDefault(id, 0)
                 }
 
                 @WithWriteLock
-                void add(String id, int num) {
+                void add(String id, int number) {
                     Thread.sleep(100) // emulate long computation
-                    map.put(id, map.get(id)+num)
+                    map.put(id, map.getOrDefault(id, 0) + number)
                 }
             }
 
@@ -53,6 +57,6 @@ class ReadWriteLockTransformTest extends GroovyShellTestCase {
                 }
                 t.join(250)
             }
-        """
+        '''
     }
 }
