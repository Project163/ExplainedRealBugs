diff --git a/src/main/java/groovy/lang/MetaClassImpl.java b/src/main/java/groovy/lang/MetaClassImpl.java
index 244c822844..ebaba99916 100644
--- a/src/main/java/groovy/lang/MetaClassImpl.java
+++ b/src/main/java/groovy/lang/MetaClassImpl.java
@@ -124,7 +124,6 @@ import static org.apache.groovy.util.Arrays.concat;
 import static org.codehaus.groovy.ast.tools.GeneralUtils.inSamePackage;
 import static org.codehaus.groovy.reflection.ReflectionCache.isAssignableFrom;
 import static org.codehaus.groovy.reflection.ReflectionUtils.parameterTypeMatches;
-import static org.codehaus.groovy.runtime.MetaClassHelper.castArgumentsToClassArray;
 
 /**
  * Allows methods to be dynamically added to existing classes at runtime
@@ -133,7 +132,7 @@ import static org.codehaus.groovy.runtime.MetaClassHelper.castArgumentsToClassAr
  */
 public class MetaClassImpl implements MetaClass, MutableMetaClass {
 
-    public static final Object[] EMPTY_ARGUMENTS = {};
+    public static final Object[] EMPTY_ARGUMENTS = MetaClassHelper.EMPTY_ARRAY;
 
     protected static final String STATIC_METHOD_MISSING = "$static_methodMissing";
     protected static final String STATIC_PROPERTY_MISSING = "$static_propertyMissing";
@@ -265,12 +264,8 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
      */
     @Override
     public List<MetaMethod> respondsTo(final Object obj, final String name, final Object[] argTypes) {
-        Class[] classes = castArgumentsToClassArray(argTypes);
-        MetaMethod m = getMetaMethod(name, classes);
-        if (m != null) {
-            return Collections.singletonList(m);
-        }
-        return Collections.emptyList();
+        MetaMethod m = getMetaMethod(name, MetaClassHelper.castArgumentsToClassArray(argTypes));
+        return (m != null ? Collections.singletonList(m) : Collections.emptyList());
     }
 
     /**
@@ -325,8 +320,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
      */
     @Override
     public MetaMethod getStaticMetaMethod(final String name, final Object[] argTypes) {
-        Class[] classes = castArgumentsToClassArray(argTypes);
-        return pickStaticMethod(name, classes);
+        return pickStaticMethod(name, MetaClassHelper.castArgumentsToClassArray(argTypes));
     }
 
     /**
@@ -334,8 +328,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
      */
     @Override
     public MetaMethod getMetaMethod(final String name, final Object[] argTypes) {
-        Class[] classes = castArgumentsToClassArray(argTypes);
-        return pickMethod(name, classes);
+        return pickMethod(name, MetaClassHelper.castArgumentsToClassArray(argTypes));
     }
 
     /**
@@ -781,7 +774,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
     @Override
     public Object invokeMethod(final Object object, final String methodName, final Object arguments) {
         if (arguments == null) {
-            return invokeMethod(object, methodName, MetaClassHelper.EMPTY_ARRAY);
+            return invokeMethod(object, methodName, EMPTY_ARGUMENTS);
         }
         if (arguments instanceof Tuple) {
             return invokeMethod(object, methodName, ((Tuple<?>) arguments).toArray());
@@ -889,7 +882,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
         if (theClass != instanceKlazz && theClass.isAssignableFrom(instanceKlazz))
             instanceKlazz = theClass;
 
-        Class<?>[] argClasses = castArgumentsToClassArray(arguments);
+        Class<?>[] argClasses = MetaClassHelper.convertToTypeArray(arguments);
 
         MetaMethod method = findMixinMethod(methodName, argClasses);
         if (method != null) {
@@ -1096,7 +1089,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
             if (isCallToSuper) {
                 if (lookup == null) throw mme;
                 MethodHandles.Lookup theLookup = lookup;
-                MethodHandle methodHandle = findMethod(sender.getSuperclass(), methodName, castArgumentsToClassArray(arguments), method -> {
+                MethodHandle methodHandle = findMethod(sender.getSuperclass(), methodName, MetaClassHelper.convertToTypeArray(arguments), method -> {
                     try {
                         return theLookup.unreflectSpecial(method, receiverClass);
                     } catch (IllegalAccessException e) {
@@ -1128,7 +1121,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
                 }
             }
             MethodHandles.Lookup theLookup = lookup;
-            MethodHandle methodHandle = findMethod(receiverClass, methodName, castArgumentsToClassArray(arguments), method -> {
+            MethodHandle methodHandle = findMethod(receiverClass, methodName, MetaClassHelper.convertToTypeArray(arguments), method -> {
                 try {
                     return spyFound ? theLookup.unreflectSpecial(method, receiverClass) : theLookup.unreflect(method);
                 } catch (IllegalAccessException e) {
@@ -1189,9 +1182,6 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
         }
 
         final Object[] arguments = originalArguments == null ? EMPTY_ARGUMENTS : originalArguments;
-//        final Class[] argClasses = MetaClassHelper.convertToTypeArray(arguments);
-//
-//        unwrap(arguments);
 
         MetaMethod method = getMetaMethod(sender, object, methodName, isCallToSuper, arguments);
 
@@ -1575,7 +1565,6 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
         }
 
         if (arguments == null) arguments = EMPTY_ARGUMENTS;
-//        Class[] argClasses = MetaClassHelper.convertToTypeArray(arguments);
 
         MetaMethod method = retrieveStaticMethod(methodName, arguments);
         // let's try to use the cache to find the method
diff --git a/src/main/java/org/codehaus/groovy/runtime/MetaClassHelper.java b/src/main/java/org/codehaus/groovy/runtime/MetaClassHelper.java
index 3e4b3fec8d..af4b3e133d 100644
--- a/src/main/java/org/codehaus/groovy/runtime/MetaClassHelper.java
+++ b/src/main/java/org/codehaus/groovy/runtime/MetaClassHelper.java
@@ -49,9 +49,10 @@ import static org.codehaus.groovy.reflection.stdclasses.CachedSAMClass.getSAMMet
 public class MetaClassHelper {
 
     public static final Object[] EMPTY_ARRAY = {};
-    public static final Class[] EMPTY_TYPE_ARRAY = {};
-    public static final Object[] ARRAY_WITH_NULL = {null};
-    protected static final Logger LOG = Logger.getLogger(MetaClassHelper.class.getName());
+    public static final Class [] EMPTY_TYPE_ARRAY = {};
+    public static final Class [] EMPTY_CLASS_ARRAY = EMPTY_TYPE_ARRAY;
+    public static final Object[] ARRAY_WITH_NULL = {null}; // mutable!
+
     private static final int MAX_ARG_LEN = 12;
     private static final int
             OBJECT_SHIFT = 23, INTERFACE_SHIFT = 0,
@@ -63,8 +64,6 @@ public class MetaClassHelper {
     * 44-48: vargs penalty
     */
 
-    public static final Class[] EMPTY_CLASS_ARRAY = new Class[0];
-
     public static boolean accessibleToConstructor(final Class at, final Constructor constructor) {
         boolean accessible = false;
         final int modifiers = constructor.getModifiers();
@@ -171,7 +170,6 @@ public class MetaClassHelper {
         return ret;
     }
 
-
     /**
      * @param list          the original list
      * @param parameterType the resulting array type
@@ -633,21 +631,19 @@ public class MetaClassHelper {
     }
 
     /**
-     * param instance array to the type array
+     * Converts array of values (incl. {@code null}) to their respective types.
      *
-     * @param args the arguments
+     * @param arguments the arguments
      * @return the types of the arguments
      */
-    public static Class[] convertToTypeArray(Object[] args) {
-        if (args == null)
-            return null;
-        int s = args.length;
-        Class[] ans = new Class[s];
-        for (int i = 0; i < s; i++) {
-            Object o = args[i];
-            ans[i] = getClassWithNullAndWrapper(o);
+    public static Class[] convertToTypeArray(final Object[] arguments) {
+        if (arguments == null) return null;
+        int n = arguments.length;
+        Class[] types = new Class[n];
+        for (int i = 0; i < n; i += 1) {
+            types[i] = getClassWithNullAndWrapper(arguments[i]);
         }
-        return ans;
+        return types;
     }
 
     public static Object makeCommonArray(Object[] arguments, int offset, Class fallback) {
@@ -977,24 +973,25 @@ public class MetaClassHelper {
 
     public static boolean sameClass(Class[] params, Object arg) {
         return params[0] == getClassWithNullAndWrapper(arg);
-
     }
 
-    public static Class[] castArgumentsToClassArray(Object[] argTypes) {
-        if (argTypes == null) return EMPTY_CLASS_ARRAY;
-        Class[] classes = new Class[argTypes.length];
-        for (int i = 0; i < argTypes.length; i++) {
-            Object argType = argTypes[i];
-            if (argType instanceof Class) {
-                classes[i] = (Class) argType;
-            } else if (argType == null) {
-                classes[i] = null;
+    /**
+     * @param arguments an array of classes, values, or nulls
+     */
+    public static Class[] castArgumentsToClassArray(final Object[] arguments) {
+        if (arguments == null || arguments.length == 0) return EMPTY_CLASS_ARRAY;
+        Class[] types = new Class[arguments.length];
+        for (int i = 0; i < arguments.length; ++i) {
+            Object argument = arguments[i];
+            if (argument instanceof Class) {
+                types[i] = (Class<?>) argument;
+            } else if (argument != null) {
+                types[i] = argument.getClass();
             } else {
-//                throw new IllegalArgumentException("Arguments to method [respondsTo] must be of type java.lang.Class!");
-                classes[i] = argType.getClass();
+                types[i] = null;
             }
         }
-        return classes;
+        return types;
     }
 
     public static void unwrap(Object[] arguments) {
diff --git a/src/test/groovy/bugs/Groovy4097.groovy b/src/test/groovy/bugs/Groovy4097.groovy
new file mode 100644
index 0000000000..05d6cd11c9
--- /dev/null
+++ b/src/test/groovy/bugs/Groovy4097.groovy
@@ -0,0 +1,71 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+package groovy.bugs
+
+import groovy.test.NotYetImplemented
+import org.junit.Test
+
+import static groovy.test.GroovyAssert.assertScript
+
+final class Groovy4097 {
+
+    @Test
+    void testMethodSelection1() {
+        assertScript '''
+            class C {
+                String getSomething(Class<?> clazz) {
+                    'Class: ' + clazz.simpleName
+                }
+                String getSomething(String string) {
+                    'String: ' + string
+                }
+            }
+
+            C c = new C()
+
+            def method = c.getMetaClass().getMetaMethod('getSomething', String)
+            def result = method.invoke(c, 'string')
+            assert result == 'String: string'
+
+            method = c.getMetaClass().getMetaMethod('getSomething', Class)
+            result = method.invoke(c, String)
+            assert result == 'Class: String'
+        '''
+    }
+
+    @NotYetImplemented @Test
+    void testMethodSelection2() {
+        assertScript '''
+            abstract class A {}
+            class C extends A {
+                static String getSuperclass() {
+                    'This was the wrong method'
+                }
+            }
+
+            C c = new C()
+            def registry = GroovySystem.getMetaClassRegistry()
+            MetaClass mc = registry.getMetaClass(c.getClass())
+            registry.setMetaClass(c.getClass(), new DelegatingMetaClass(mc))
+
+            Class  cls = c.getClass()
+            assert cls.getSuperclass() == A.class
+        '''
+    }
+}
diff --git a/src/test/org/codehaus/groovy/runtime/MetaClassHelperTest.java b/src/test/org/codehaus/groovy/runtime/MetaClassHelperTest.java
index 3baffd03d7..aee659f6e7 100644
--- a/src/test/org/codehaus/groovy/runtime/MetaClassHelperTest.java
+++ b/src/test/org/codehaus/groovy/runtime/MetaClassHelperTest.java
@@ -18,11 +18,14 @@
  */
 package org.codehaus.groovy.runtime;
 
-import junit.framework.TestCase;
+import org.junit.Test;
 
-public class MetaClassHelperTest extends TestCase {
+import static org.junit.Assert.assertNull;
+
+public final class MetaClassHelperTest {
+
+    @Test // GROOVY-1262
     public void testGetClassName() {
-        // GROOVY-1262
-        MetaClassHelper.getClassName(null);
+        assertNull(MetaClassHelper.getClassName(null));
     }
-}
\ No newline at end of file
+}
