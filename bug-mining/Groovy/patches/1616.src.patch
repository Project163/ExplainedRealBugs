diff --git a/src/main/org/codehaus/groovy/ast/GenericsType.java b/src/main/org/codehaus/groovy/ast/GenericsType.java
index f262a64c06..db9bbdf5dd 100644
--- a/src/main/org/codehaus/groovy/ast/GenericsType.java
+++ b/src/main/org/codehaus/groovy/ast/GenericsType.java
@@ -16,6 +16,8 @@
 
 package org.codehaus.groovy.ast;
 
+import org.codehaus.groovy.transform.stc.GenericsUtils;
+
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Map;
@@ -247,9 +249,9 @@ public class GenericsType extends ASTNode {
                             // class node are not parameterized. This means that we must create a
                             // new class node with the parameterized types that the current class node
                             // has defined.
-                            Map<String,ClassNode> parameters = new HashMap<String, ClassNode>();
-                            collectParameter(classNode, parameters);
-                            ClassNode node = ClassHelper.makeWithoutCaching(anInterface.getTypeClass(), false);
+                            Map<String,GenericsType> parameters = new HashMap<String, GenericsType>();
+                            GenericsUtils.extractPlaceholders(classNode, parameters);
+                            ClassNode node = anInterface.getPlainNodeReference();
                             GenericsType[] interfaceGTs = anInterface.getGenericsTypes();
                             GenericsType[] types = new GenericsType[interfaceGTs.length];
                             for (int i = 0; i < interfaceGTs.length; i++) {
@@ -258,7 +260,7 @@ public class GenericsType extends ASTNode {
                                 if (interfaceGT.isPlaceholder()) {
                                     String name = interfaceGT.getName();
                                     if (parameters.containsKey(name)) {
-                                        types[i] = new GenericsType(parameters.get(name));
+                                        types[i] = parameters.get(name);
                                     }
                                 }
                             }
@@ -275,61 +277,78 @@ public class GenericsType extends ASTNode {
                 // should not happen
                 return false;
             }
-            GenericsType[] uBTypes = bound.getGenericsTypes();
-            Map<String, ClassNode> resolvedPlaceholders = placeholderToParameterizedType();
+            GenericsType[] redirectBoundGenericTypes = bound.redirect().getGenericsTypes();
+            Map<String, GenericsType> classNodePlaceholders = GenericsUtils.extractPlaceholders(classNode);
+            Map<String, GenericsType> boundPlaceHolders = GenericsUtils.extractPlaceholders(bound);
             boolean match = true;
-            for (int i = 0; i < uBTypes.length && match; i++) {
-                GenericsType uBType = uBTypes[i];
-                GenericsType cnType = cnTypes[i];
-                if (cnType.isPlaceholder()) {
-                    String name = cnType.getName();
-                    if (resolvedPlaceholders.containsKey(name)) cnType=new GenericsType(resolvedPlaceholders.get(name));
+            for (int i = 0; i < redirectBoundGenericTypes.length && match; i++) {
+                GenericsType redirectBoundType = redirectBoundGenericTypes[i];
+                GenericsType classNodeType = cnTypes[i];
+                if (classNodeType.isWildcard()) {
+                    match = true;
+                } else if (classNodeType.isPlaceholder()) {
+                    if (redirectBoundType.isPlaceholder()) {
+                        match = classNodeType.getName().equals(redirectBoundType.getName());
+                    } else {
+                        String name = classNodeType.getName();
+                        if (classNodePlaceholders.containsKey(name)) classNodeType=classNodePlaceholders.get(name);
+                        match = classNodeType.isCompatibleWith(redirectBoundType.getType());
+                    }
+                } else {
+                    if (redirectBoundType.isPlaceholder()) {
+                        if (classNodeType.isPlaceholder()) {
+                            match = classNodeType.getName().equals(redirectBoundType.getName());
+                        } else {
+                            String name = redirectBoundType.getName();
+                            if (boundPlaceHolders.containsKey(name)) {
+                                redirectBoundType = boundPlaceHolders.get(name);
+                                boolean wildcard = redirectBoundType.isWildcard();
+                                boolean placeholder = redirectBoundType.isPlaceholder();
+                                if (placeholder || wildcard) {
+                                    // placeholder aliases, like Map<U,V> -> Map<K,V>
+//                                    redirectBoundType = classNodePlaceholders.get(name);
+                                    if (wildcard) {
+                                        // ex: Comparable<Integer> <=> Comparable<? super T>
+                                        if (redirectBoundType.lowerBound!=null) {
+                                            GenericsType gt = new GenericsType(redirectBoundType.lowerBound);
+                                            if (gt.isPlaceholder()) {
+                                                // check for recursive generic typedef, like in
+                                                // <T extends Comparable<? super T>>
+                                                if (classNodePlaceholders.containsKey(gt.getName())) {
+                                                    gt = classNodePlaceholders.get(gt.getName());
+                                                }
+                                            }
+                                            match = gt.getType().isDerivedFrom(classNodeType.getType());
+                                        }
+                                        if (match && redirectBoundType.upperBounds!=null) {
+                                            for (ClassNode upperBound : redirectBoundType.upperBounds) {
+                                                GenericsType gt = new GenericsType(upperBound);
+                                                if (gt.isPlaceholder()) {
+                                                    // check for recursive generic typedef, like in
+                                                    // <T extends Comparable<? super T>>
+                                                    if (classNodePlaceholders.containsKey(gt.getName())) {
+                                                        gt = classNodePlaceholders.get(gt.getName());
+                                                    }
+                                                }
+                                                match = match && classNodeType.getType().isDerivedFrom(gt.getType());
+                                            }
+                                        }
+                                        return match;
+                                    } else {
+                                        redirectBoundType = classNodePlaceholders.get(name);
+                                    }
+
+                                }
+                            }
+                            match = redirectBoundType.isCompatibleWith(classNodeType.getType());
+                        }
+                    } else {
+                        match = classNodeType.isCompatibleWith(redirectBoundType.getType());
+                    }
                 }
-                match = uBType.isWildcard() || uBType.isPlaceholder() || cnType.isCompatibleWith(uBType.getType());
             }
             if (!match) return false;
             return true;
         }
-
-        /**
-         * Iterates through the type, its upper and lower bounds, and returns a map
-         * which has for key a placeholder name, and as a value the corresponding
-         * parameterized type. For example, E -> java.lang.String
-         * @return
-         */
-        private Map<String,ClassNode> placeholderToParameterizedType() {
-            Map<String, ClassNode> result = new HashMap<String, ClassNode>();
-            collectParameter(type, result);
-            if (upperBounds!=null) {
-                for (ClassNode upperBound : upperBounds) {
-                    collectParameter(upperBound, result);
-                }
-            }
-            if (lowerBound!=null) {
-                collectParameter(lowerBound, result);
-            }
-            return result;
-        }
-
-        /**
-         * For a given classnode, fills in the supplied map with the parameterized
-         * types it defines.
-         * @param node
-         * @param map
-         */
-        private void collectParameter(ClassNode node, Map<String, ClassNode> map) {
-            if (node == null) return;
-            if (!node.isUsingGenerics() || !node.isRedirectNode()) return;
-            GenericsType[] parameterized = node.getGenericsTypes();
-            if (parameterized == null) return;
-            GenericsType[] genericsTypes = node.redirect().getGenericsTypes();
-            for (int i = 0; i < genericsTypes.length; i++) {
-                GenericsType genericsType = genericsTypes[i];
-                if (genericsType.isPlaceholder()) {
-                    String name = genericsType.getName();
-                    map.put(name, parameterized[i].getType());
-                }
-            }
-        }
     }
 }
diff --git a/src/main/org/codehaus/groovy/ast/tools/WideningCategories.java b/src/main/org/codehaus/groovy/ast/tools/WideningCategories.java
index 1844ad84b3..589ada020a 100644
--- a/src/main/org/codehaus/groovy/ast/tools/WideningCategories.java
+++ b/src/main/org/codehaus/groovy/ast/tools/WideningCategories.java
@@ -20,7 +20,7 @@ import static org.codehaus.groovy.ast.ClassHelper.*;
 import org.codehaus.groovy.ast.ClassHelper;
 import org.codehaus.groovy.ast.ClassNode;
 
-import java.util.List;
+import java.util.*;
 
 /**
  * This class provides helper methods to determine the type from a widening 
@@ -36,6 +36,7 @@ import java.util.List;
  * in the list is long, and since both apply to long, the result type is a long.<br/>
  * 
  * @author <a href="mailto:blackdrag@gmx.org">Jochen "blackdrag" Theodorou</a>
+ * @author Cedric Champeau
  */
 public class WideningCategories {
     /**
@@ -93,8 +94,9 @@ public class WideningCategories {
      * @return first common supertype
      */
     public static ClassNode firstCommonSuperType(ClassNode a, ClassNode b) {
-        if (a == null || b == null) return ClassHelper.OBJECT_TYPE;
+        if (a == null || b == null) return OBJECT_TYPE;
         if (a == b || a.equals(b)) return a;
+        if (OBJECT_TYPE.equals(a)||OBJECT_TYPE.equals(b)) return OBJECT_TYPE;
         if (isPrimitiveType(a) && !isPrimitiveType(b)) {
             if (isNumberType(a) && isNumberType(b)) {
                 return firstCommonSuperType(ClassHelper.getWrapper(a), b);
diff --git a/src/main/org/codehaus/groovy/transform/stc/GenericsUtils.java b/src/main/org/codehaus/groovy/transform/stc/GenericsUtils.java
index 0f5a5f51cb..def5bc2ddd 100644
--- a/src/main/org/codehaus/groovy/transform/stc/GenericsUtils.java
+++ b/src/main/org/codehaus/groovy/transform/stc/GenericsUtils.java
@@ -19,6 +19,9 @@ import org.codehaus.groovy.ast.ClassHelper;
 import org.codehaus.groovy.ast.ClassNode;
 import org.codehaus.groovy.ast.GenericsType;
 
+import java.util.HashMap;
+import java.util.Map;
+
 /**
  * Utility methods to deal with generic types.
  *
@@ -42,18 +45,33 @@ public class GenericsUtils {
         if (parameterizedTypes==null || parameterizedTypes.length==0) return alignmentTarget;
         GenericsType[] generics = new GenericsType[alignmentTarget.length];
         for (int i = 0, scgtLength = alignmentTarget.length; i < scgtLength; i++) {
-            final GenericsType superGenericType = alignmentTarget[i];
+            final GenericsType currentTarget = alignmentTarget[i];
             GenericsType match = null;
             if (redirectGenericTypes!=null) {
                 for (int j = 0; j < redirectGenericTypes.length && match == null; j++) {
                     GenericsType redirectGenericType = redirectGenericTypes[j];
-                    if (redirectGenericType.isCompatibleWith(superGenericType.getType())) {
+                    if (redirectGenericType.isCompatibleWith(currentTarget.getType())) {
                         match = parameterizedTypes[j];
+                        if (currentTarget.isWildcard()) {
+                            // if alignment target is a wildcard type
+                            // then we must make best effort to return a parameterized
+                            // wildcard
+                            ClassNode lower = currentTarget.getLowerBound()!=null?match.getType():null;
+                            ClassNode[] currentUpper = currentTarget.getUpperBounds();
+                            ClassNode[] upper = currentUpper !=null?new ClassNode[currentUpper.length]:null;
+                            if (upper!=null) {
+                                for (int k = 0; k < upper.length; k++) {
+                                    upper[k] = currentUpper[k].isGenericsPlaceHolder()?match.getType():currentUpper[k];
+                                }
+                            }
+                            match = new GenericsType(ClassHelper.makeWithoutCaching("?"), upper, lower);
+                            match.setWildcard(true);
+                        }
                     }
                 }
             }
             if (match == null) {
-                match = superGenericType;
+                match = currentTarget;
             }
             generics[i]=match;
         }
@@ -72,4 +90,31 @@ public class GenericsUtils {
         gt.setWildcard(true);
         return gt;
     }
+
+    public static Map<String, GenericsType> extractPlaceholders(ClassNode cn) {
+        HashMap<String, GenericsType> ret = new HashMap<String, GenericsType>();
+        extractPlaceholders(cn, ret);
+        return ret;
+    }
+
+    /**
+     * For a given classnode, fills in the supplied map with the parameterized
+     * types it defines.
+     * @param node
+     * @param map
+     */
+    public static void extractPlaceholders(ClassNode node, Map<String, GenericsType> map) {
+        if (node == null) return;
+        if (!node.isUsingGenerics() || !node.isRedirectNode()) return;
+        GenericsType[] parameterized = node.getGenericsTypes();
+        if (parameterized == null) return;
+        GenericsType[] redirectGenericsTypes = node.redirect().getGenericsTypes();
+        for (int i = 0; i < redirectGenericsTypes.length; i++) {
+            GenericsType redirectType = redirectGenericsTypes[i];
+            if (redirectType.isPlaceholder()) {
+                String name = redirectType.getName();
+                if (!map.containsKey(name)) map.put(name, parameterized[i]);
+            }
+        }
+    }
 }
diff --git a/src/test/groovy/transform/stc/GenericsSTCTest.groovy b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
index 717faa792d..45c31346df 100644
--- a/src/test/groovy/transform/stc/GenericsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
@@ -112,20 +112,23 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
         '''
     }
 
+    void testDiamondInferrenceFromConstructorWithoutAssignment() {
+        assertScript '''
+            new HashSet<>(Arrays.asList(0L,0L));
+        '''
+    }
+
     void testDiamondInferrenceFromConstructor2() {
         shouldFailWithMessages '''
             Set< Number > s3 = new HashSet<>(Arrays.asList(0L,0L));
         ''', 'Cannot assign java.util.HashSet <java.lang.Long> to: java.util.Set <Number>'
     }
 
-    /*
-        todo: this one should not fail
-        
     void testDiamondInferrenceFromConstructor3() {
         assertScript '''
             Set<Number> s4 = new HashSet<Number>(Arrays.asList(0L,0L))
         '''
-    }*/
+    }
 
 
     void testLinkedListWithListArgument() {
@@ -167,6 +170,12 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
             list.add 'world'
         '''
     }
+
+    void testAssignmentShouldFailBecauseOfLowerBound() {
+        shouldFailWithMessages '''
+            List<? super Number> list = ['string']
+        ''', 'Number'
+    }
     
     static class MyList extends LinkedList<String> {}
 }
diff --git a/src/test/org/codehaus/groovy/ast/GenericsTypeTest.groovy b/src/test/org/codehaus/groovy/ast/GenericsTypeTest.groovy
index ef99219881..9baaea9f7f 100644
--- a/src/test/org/codehaus/groovy/ast/GenericsTypeTest.groovy
+++ b/src/test/org/codehaus/groovy/ast/GenericsTypeTest.groovy
@@ -21,6 +21,8 @@ import org.codehaus.groovy.control.CompilePhase
 import org.codehaus.groovy.control.CompilerConfiguration
 import org.codehaus.groovy.control.SourceUnit
 import org.codehaus.groovy.control.customizers.CompilationCustomizer
+import org.codehaus.groovy.ast.tools.WideningCategories
+import org.codehaus.groovy.transform.stc.GenericsUtils
 
 /**
  * Various tests aimed at testing the {@link GenericsType} class.
@@ -47,6 +49,7 @@ public class GenericsTypeTest extends GroovyTestCase {
         assert generics.toString() == '? super java.lang.Number'
         assert generics.isCompatibleWith(ClassHelper.Number_TYPE)
         assert !generics.isCompatibleWith(ClassHelper.Integer_TYPE)
+        assert !generics.isCompatibleWith(ClassHelper.STRING_TYPE)
         assert generics.isCompatibleWith(ClassHelper.OBJECT_TYPE)
 
     }
@@ -133,6 +136,28 @@ public class GenericsTypeTest extends GroovyTestCase {
         assert !generics.isCompatibleWith(incorrectType)
     }
 
+    void testPlaceholderExtract() {
+        def type = extractTypesFromCode("List<String> type").type
+        def placeholders = GenericsUtils.extractPlaceholders(type)
+        assert placeholders.E?.type == ClassHelper.STRING_TYPE
+    }
+
+    void testPlaceholderExtract2() {
+        def type = extractTypesFromCode("Map<String,Integer> type").type
+        def placeholders = GenericsUtils.extractPlaceholders(type)
+        assert placeholders.K?.type == ClassHelper.STRING_TYPE
+        assert placeholders.V?.type == ClassHelper.Integer_TYPE
+    }
+
+    void testPlaceholderExtract3() {
+        def type = extractTypesFromCode("List<Map<String,Integer>> type").type
+        def placeholders = GenericsUtils.extractPlaceholders(type)
+        assert placeholders.E?.type == ClassHelper.MAP_TYPE
+        placeholders = GenericsUtils.extractPlaceholders(placeholders.E.type)
+        assert placeholders.K?.type == ClassHelper.STRING_TYPE
+        assert placeholders.V?.type == ClassHelper.Integer_TYPE
+    }
+
     // ------------------ Support methods -------------------------
 
     def extractTypesFromCode(String string) {
