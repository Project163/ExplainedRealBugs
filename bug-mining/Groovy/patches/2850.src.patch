diff --git a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java
index cb6b4e2674..2b410bc0c2 100644
--- a/src/main/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java
+++ b/src/main/org/codehaus/groovy/classgen/asm/sc/StaticInvocationWriter.java
@@ -268,20 +268,18 @@ public class StaticInvocationWriter extends InvocationWriter {
                 return true;
             }
             if (target.isPrivate()) {
-                ClassNode declaringClass = target.getDeclaringClass();
-                if ((isPrivateBridgeMethodsCallAllowed(declaringClass, classNode) || isPrivateBridgeMethodsCallAllowed(classNode, declaringClass))
-                        && declaringClass.getNodeMetaData(PRIVATE_BRIDGE_METHODS) != null
-                        && !declaringClass.equals(classNode)) {
-                    if (tryBridgeMethod(target, receiver, implicitThis, args)) {
-                        return true;
-                    } else if (declaringClass != classNode) {
-                        controller.getSourceUnit().addError(new SyntaxException("Cannot call private method " + (target.isStatic() ? "static " : "") +
-                                declaringClass.toString(false) + "#" + target.getName() + " from class " + classNode.toString(false), receiver.getLineNumber(), receiver.getColumnNumber(), receiver.getLastLineNumber(), receiver.getLastColumnNumber()));
-                    }
+                if (tryPrivateMethod(target, implicitThis, receiver, args, classNode)) return true;
+            } else if (target.isProtected()) {
+                ClassNode node = controller.getTypeChooser().resolveType(receiver, controller.getClassNode());
+                boolean isThisOrSuper = false;
+                if (receiver instanceof VariableExpression) {
+                    isThisOrSuper = ((VariableExpression) receiver).isThisExpression() || ((VariableExpression) receiver).isSuperExpression();
                 }
-                if (declaringClass != classNode) {
-                    controller.getSourceUnit().addError(new SyntaxException("Cannot call private method " + (target.isStatic() ? "static " : "") +
-                                                        declaringClass.toString(false) + "#" + target.getName() + " from class " + classNode.toString(false), receiver.getLineNumber(), receiver.getColumnNumber(), receiver.getLastLineNumber(), receiver.getLastColumnNumber()));
+                if (!implicitThis && !isThisOrSuper
+                        && StaticTypeCheckingSupport.implementsInterfaceOrIsSubclassOf(node,target.getDeclaringClass())) {
+                    controller.getSourceUnit().addError(
+                            new SyntaxException("Method " + target.getName() + " is protected in " + target.getDeclaringClass().toString(false),
+                                    receiver.getLineNumber(), receiver.getColumnNumber(), receiver.getLastLineNumber(), receiver.getLastColumnNumber()));
                 }
             }
             if (receiver != null) {
@@ -296,6 +294,25 @@ public class StaticInvocationWriter extends InvocationWriter {
         }
     }
 
+    private boolean tryPrivateMethod(final MethodNode target, final boolean implicitThis, final Expression receiver, final TupleExpression args, final ClassNode classNode) {
+        ClassNode declaringClass = target.getDeclaringClass();
+        if ((isPrivateBridgeMethodsCallAllowed(declaringClass, classNode) || isPrivateBridgeMethodsCallAllowed(classNode, declaringClass))
+                && declaringClass.getNodeMetaData(PRIVATE_BRIDGE_METHODS) != null
+                && !declaringClass.equals(classNode)) {
+            if (tryBridgeMethod(target, receiver, implicitThis, args)) {
+                return true;
+            } else if (declaringClass != classNode) {
+                controller.getSourceUnit().addError(new SyntaxException("Cannot call private method " + (target.isStatic() ? "static " : "") +
+                        declaringClass.toString(false) + "#" + target.getName() + " from class " + classNode.toString(false), receiver.getLineNumber(), receiver.getColumnNumber(), receiver.getLastLineNumber(), receiver.getLastColumnNumber()));
+            }
+        }
+        if (declaringClass != classNode) {
+            controller.getSourceUnit().addError(new SyntaxException("Cannot call private method " + (target.isStatic() ? "static " : "") +
+                                                declaringClass.toString(false) + "#" + target.getName() + " from class " + classNode.toString(false), receiver.getLineNumber(), receiver.getColumnNumber(), receiver.getLastLineNumber(), receiver.getLastColumnNumber()));
+        }
+        return false;
+    }
+
     protected static boolean isPrivateBridgeMethodsCallAllowed(ClassNode receiver, ClassNode caller) {
         if (receiver == null) return false;
         if (receiver.redirect() == caller) return true;
diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 9e281f3284..1b9a9b677a 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -2867,16 +2867,9 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                         MethodNode directMethodCallCandidate = mn.get(0);
                         if (chosenReceiver==null) {
                             chosenReceiver = Receiver.make(directMethodCallCandidate.getDeclaringClass());
-                            if (chosenReceiver==null) {
-                                chosenReceiver = owners.get(0);
-                            }
                         }
 
-                        ClassNode returnType = null;
-
-                        if (returnType == null) {
-                            returnType = getType(directMethodCallCandidate);
-                        }
+                        ClassNode returnType = getType(directMethodCallCandidate);
 
                         if (isUsingGenericsOrIsArrayUsingGenerics(returnType)) {
                             visitMethodCallArguments(chosenReceiver.getType(), argumentList, true, directMethodCallCandidate);
@@ -2895,7 +2888,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                             returnType = adjustWithTraits(directMethodCallCandidate,chosenReceiver.getType(), args, returnType);
                             storeType(call, returnType);
                             storeTargetMethod(call, directMethodCallCandidate);
-                            String data = chosenReceiver != null ? chosenReceiver.getData() : null;
+                            String data = chosenReceiver.getData();
                             if (data != null) {
                                 // the method which has been chosen is supposed to be a call on delegate or owner
                                 // so we store the information so that the static compiler may reuse it
diff --git a/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7325Bug.groovy b/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7325Bug.groovy
index ba1fe974b3..362025f2bd 100644
--- a/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7325Bug.groovy
+++ b/src/test/org/codehaus/groovy/classgen/asm/sc/bugs/Groovy7325Bug.groovy
@@ -22,6 +22,7 @@ import groovy.transform.stc.StaticTypeCheckingTestCase
 import org.codehaus.groovy.classgen.asm.sc.StaticCompilationTestSupport
 
 class Groovy7325Bug extends StaticTypeCheckingTestCase implements StaticCompilationTestSupport {
+
     void testGenericIdentityWithClosure() {
         assertScript '''
 public static <T> T identity(T self) { self }
@@ -37,4 +38,19 @@ Integer i = identity(2)
 Closure c = identity {'foo'}
 '''
     }
+
+    void testShouldNotThrowIllegalAccessToProtectedData() {
+        shouldFailWithMessages('''
+            class Test {
+              final Set<String> HISTORY = [] as HashSet
+
+              Set<String> getHistory() {
+                return HISTORY.clone() as HashSet<String>
+              }
+            }
+
+            Test test = new Test()
+            println test.history
+        ''', 'Method clone is protected in java.lang.Object')
+    }
 }
