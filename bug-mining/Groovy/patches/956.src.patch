diff --git a/src/main/groovy/swing/binding/JTextComponentProperties.java b/src/main/groovy/swing/binding/JTextComponentProperties.java
index e3cab5bb3b..7bcf59d6b3 100644
--- a/src/main/groovy/swing/binding/JTextComponentProperties.java
+++ b/src/main/groovy/swing/binding/JTextComponentProperties.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2007-2008 the original author or authors.
+ * Copyright 2007-2009 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -52,6 +52,7 @@ class JTextComponentTextBinding extends AbstractSyntheticBinding implements Prop
 
     public JTextComponentTextBinding(PropertyBinding source, TargetBinding target) {
         super(source, target, JTextComponent.class, "text");
+        source.setNonChangeCheck(true);
     }
 
     public synchronized void syntheticBind() {
diff --git a/src/main/groovy/swing/factory/BindFactory.groovy b/src/main/groovy/swing/factory/BindFactory.groovy
index 7d803660a6..aa69b3256b 100644
--- a/src/main/groovy/swing/factory/BindFactory.groovy
+++ b/src/main/groovy/swing/factory/BindFactory.groovy
@@ -1,5 +1,5 @@
 /*
- * Copyright 2007-2008 the original author or authors.
+ * Copyright 2007-2009 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -38,38 +38,38 @@ public class BindFactory extends AbstractFactory {
         // covers JTextPane.text
         // covers JTextArea.text
         // covers JEditorPane.text
-        syntheticBindings.putAll(JTextComponentProperties.getSyntheticProperties())
+        syntheticBindings.putAll(JTextComponentProperties.syntheticProperties)
 
         // covers JCheckBox.selected
         // covers JChecBoxMenuItem.selected
         // covers JRadioButton.selected
         // covers JRadioButtonMenuItem.selected
         // covers JToggleButton.selected
-        syntheticBindings.putAll(AbstractButtonProperties.getSyntheticProperties())
+        syntheticBindings.putAll(AbstractButtonProperties.syntheticProperties)
 
         // covers JSlider.value
-        syntheticBindings.putAll(JSliderProperties.getSyntheticProperties())
+        syntheticBindings.putAll(JSliderProperties.syntheticProperties)
 
         // covers JScrollBar.value
-        syntheticBindings.putAll(JScrollBarProperties.getSyntheticProperties())
+        syntheticBindings.putAll(JScrollBarProperties.syntheticProperties)
 
         // JComboBox.elements / items
         // JComboBox.selectedElement / selectedItem
-        syntheticBindings.putAll(JComboBoxProperties.getSyntheticProperties())
+        syntheticBindings.putAll(JComboBoxProperties.syntheticProperties)
 
         // JList.elements
         // JList.selectedElement
         // JList.selectedElements
-        //syntheticBindings.putAll(JListProperties.getSyntheticProperties())
+        //syntheticBindings.putAll(JListProperties.syntheticProperties)
 
         // JSpinner.value
-        //syntheticBindings.putAll(JSpinnerProperties.getSyntheticProperties())
+        //syntheticBindings.putAll(JSpinnerProperties.syntheticProperties)
 
         // other properties handled in JSR-295
         // JTable.elements
         // JTable.selectedElement
         // JTable.selectedElements
-        syntheticBindings.putAll(JTableProperties.getSyntheticProperties());
+        syntheticBindings.putAll(JTableProperties.syntheticProperties);
 
         // JTree.root
         // JTree.selectedElement
@@ -103,15 +103,21 @@ public class BindFactory extends AbstractFactory {
 
         TargetBinding tb = null
         if (target != null) {
-            String targetProperty = (String) attributes.remove("targetProperty") ?: value
+            String targetProperty = attributes.remove("targetProperty") ?: value
             tb = new PropertyBinding(target, targetProperty)
             if (source == null) {
                 // if we have a target but no source assume the build context is the source and return
+                def result
+                if (attributes.remove("mutual")) {
+                  result = new MutualPropertyBinding(null, null, tb, this.&getTriggerBinding)
+                } else {
+                  result = tb
+                }
                 def newAttributes = [:]
                 newAttributes.putAll(attributes)
-                bindContext.put(tb, newAttributes)
+                bindContext.put(result, newAttributes)
                 attributes.clear()
-                return tb
+                return result
             }
         }
 
@@ -129,7 +135,7 @@ public class BindFactory extends AbstractFactory {
             fb = etb.createBinding(csb, tb)
         } else if (spa && !(sea && sva)) {
             // partially property driven binding
-            String property = (String) attributes.remove("sourceProperty") ?: value
+            String property = attributes.remove("sourceProperty") ?: value
             PropertyBinding pb = new PropertyBinding(source, property)
 
             TriggerBinding trigger
@@ -153,13 +159,9 @@ public class BindFactory extends AbstractFactory {
                 sb = pb
             }
 
-            if (!sea && !sva) {
-                // check for a mutual binding (bi-directional)
-                if (attributes.remove("mutual")) {
-                    fb = new MutualPropertyBinding(sb, tb)
-                } else {
-                    fb = trigger.createBinding(sb, tb)
-                }
+            // check for a mutual binding (bi-directional)
+            if (attributes.remove("mutual")) {
+                fb = new MutualPropertyBinding(trigger, sb, tb, this.&getTriggerBinding)
             } else {
                 fb = trigger.createBinding(sb, tb)
             }
@@ -254,50 +256,26 @@ public class BindFactory extends AbstractFactory {
             }
 
             FullBinding fb
-            if (value instanceof FullBinding) {
+            if (value instanceof MutualPropertyBinding) {
+                fb = (FullBinding) value
+                PropertyBinding psb = new PropertyBinding(node, property)
+                if (fb.sourceBinding == null) {
+                    fb.sourceBinding = psb
+                    finishContextualBinding(fb, builder, bindAttrs, id)
+                } else if (fb.targetBinding == null) {
+                    fb.targetBinding = psb
+                }
+            } else if (value instanceof FullBinding) {
                 fb = (FullBinding) value
-                fb.setTargetBinding(new PropertyBinding(node, property))
+                fb.targetBinding = new PropertyBinding(node, property)
             } else  if (value instanceof TargetBinding) {
                 PropertyBinding psb = new PropertyBinding(node, property)
                 fb = getTriggerBinding(psb).createBinding(psb, value)
-
-                Object bindValue = bindAttrs.remove("bind")
-                bindAttrs.each{k, v -> fb."$k" = v}
-
-                if (    (bindValue == null)
-                    || ((bindValue instanceof Boolean) && ((Boolean)bindValue).booleanValue()))
-                {
-                    fb.bind()
-                }
-                fb.update()
-
-                builder.addDisposalClosure(fb.&unbind)
-
-                // replaces ourselves in the variables
-                // id: is lost to us by now, so we just assume that any storage of us is a goner as well
-                //builder.getVariables().each{ Map.Entry me -> if (value.is(me.value)) me.setValue fb}
-                if (id) builder.setVariable(id, fb)
+                finishContextualBinding(fb, builder, bindAttrs, id)
             } else if (value instanceof ClosureTriggerBinding) {
                 PropertyBinding psb = new PropertyBinding(node, property)
                 fb = value.createBinding(value, psb);
-
-                Object o = bindAttrs.remove("bind")
-
-                if (    (o == null)
-                    || ((o instanceof Boolean) && ((Boolean)o).booleanValue()))
-                {
-                    fb.bind()
-                }
-                fb.update()
-
-                bindAttrs.each{k, v -> fb."$k" = v}
-
-                builder.addDisposalClosure(fb.&unbind)
-
-                // replaces ourselves in the variables
-                // id: is lost to us by now, so we just assume that any storage of us is a goner as well
-                //builder.getVariables().each{ Map.Entry me -> if (value.is(me.value)) me.setValue fb}
-                if (id) builder.setVariable(id, fb)
+                finishContextualBinding(fb, builder, bindAttrs, id)
             } else {
                 continue
             }
@@ -316,4 +294,22 @@ public class BindFactory extends AbstractFactory {
         }
     }
 
+  private def finishContextualBinding(FullBinding fb, FactoryBuilderSupport builder, bindAttrs, id) {
+
+    Object bindValue = bindAttrs.remove("bind")
+    bindAttrs.each {k, v -> fb."$k" = v}
+
+    if ((bindValue == null)
+            || ((bindValue instanceof Boolean) && ((Boolean) bindValue).booleanValue())) {
+      fb.bind()
+    }
+
+    builder.addDisposalClosure(fb.&unbind)
+
+    // replaces ourselves in the variables
+    // id: is lost to us by now, so we just assume that any storage of us is a goner as well
+    //builder.getVariables().each{ Map.Entry me -> if (value.is(me.value)) me.setValue fb}
+    if (id) builder.setVariable(id, fb)
+  }
+
 }
diff --git a/src/main/org/codehaus/groovy/binding/MutualPropertyBinding.java b/src/main/org/codehaus/groovy/binding/MutualPropertyBinding.java
index e0f29ef107..5c0fdb32a3 100644
--- a/src/main/org/codehaus/groovy/binding/MutualPropertyBinding.java
+++ b/src/main/org/codehaus/groovy/binding/MutualPropertyBinding.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2007 the original author or authors.
+ * Copyright 2007-2009 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -15,12 +15,7 @@
  */
 package org.codehaus.groovy.binding;
 
-import groovy.lang.MissingMethodException;
-import org.codehaus.groovy.runtime.InvokerHelper;
-
-import java.beans.PropertyChangeEvent;
-import java.beans.PropertyChangeListener;
-
+import groovy.lang.Closure;
 
 /**
  * @author <a href="mailto:shemnon@yahoo.com">Danno Ferrin</a>
@@ -28,130 +23,158 @@ import java.beans.PropertyChangeListener;
  * @since Groovy 1.6
  */
 
-public class MutualPropertyBinding extends AbstractFullBinding implements PropertyChangeListener {
+public class MutualPropertyBinding implements FullBinding {
 
     boolean bound;
 
-    Object sourceBoundBean;
-    String sourceBoundProperty;
-    boolean sourceBoundToProperty;
-    Object targetBoundBean;
-    String targetBoundProperty;
-    boolean targetBoundToProperty;
+    PropertyBinding sourceBinding;
+    PropertyBinding targetBinding;
+    Closure validator;
+    Closure converter;
+    Closure reverseConverter;
+
+    Closure triggerFactory;
 
-    MutualPropertyBinding(SourceBinding source, TargetBinding target) {
-        setSourceBinding(source);
+    TriggerBinding forwardTriggerBinding;
+    FullBinding forwardBinding;
+    TriggerBinding reverseTriggerBinding;
+    FullBinding reverseBinding;
+
+    MutualPropertyBinding(TriggerBinding forwardTrigger, PropertyBinding source, PropertyBinding target, Closure triggerFactory) {
+        // order matters here!
+        this.triggerFactory = triggerFactory;
+        sourceBinding = source;
+        forwardTriggerBinding = forwardTrigger;
         setTargetBinding(target);
+        rebuildBindings();
     }
 
-    public void propertyChange(PropertyChangeEvent event) {
-        if (event.getSource() == targetBoundBean) {
-            if (sourceBoundToProperty || event.getPropertyName().equals(sourceBoundProperty)) {
-                update();
-            }
-        } else if (event.getSource() == sourceBoundBean) {
-            if (targetBoundToProperty || event.getPropertyName().equals(targetBoundProperty)) {
-                reverseUpdate();
-            }
-        }
+    public SourceBinding getSourceBinding() {
+        return sourceBinding;
+    }
+
+    public TargetBinding getTargetBinding() {
+        return targetBinding;
     }
 
     public void setSourceBinding(SourceBinding sourceBinding) {
-        if (sourceBinding instanceof PropertyBinding) {
-            if (bound && sourceBoundBean != null) {
-                unbindProperty(sourceBoundBean, sourceBoundToProperty ? sourceBoundProperty : (String) null, this);
-                sourceBoundBean = null;
-                sourceBoundProperty = null;
-            }
-            super.setSourceBinding(sourceBinding);
-            if (bound) {
-                sourceBoundBean = ((PropertyBinding)sourceBinding).bean;
-                sourceBoundProperty = bindProperty(sourceBoundBean, ((PropertyBinding)sourceBinding).propertyName, this);
-                sourceBoundToProperty = sourceBoundProperty != null;
+        try {
+            if (sourceBinding == null) {
+                forwardTriggerBinding = null;
+            } else {
+                forwardTriggerBinding = (TriggerBinding) triggerFactory.call(sourceBinding);
             }
-        } else {
-            throw new RuntimeException("Only PropertyBindings can be set in a Mutual Property Binding");
+            this.sourceBinding = (PropertyBinding) sourceBinding;
+        } catch (RuntimeException re) {
+            throw new UnsupportedOperationException("Mutual Bindings may only change source bindings to other PropertyBindings");
         }
+        rebuildBindings();
     }
 
     public void setTargetBinding(TargetBinding targetBinding) {
-        if (targetBinding instanceof PropertyBinding) {
-            if (bound && targetBoundBean != null) {
-                unbindProperty(targetBoundBean, targetBoundToProperty ? targetBoundProperty : (String) null, this);
-                targetBoundBean = null;
-                targetBoundProperty = null;
-            }
-            super.setTargetBinding(targetBinding);
-            if (bound) {
-                targetBoundBean = ((PropertyBinding)targetBinding).bean;
-                targetBoundProperty = bindProperty(targetBoundBean, ((PropertyBinding)targetBinding).propertyName, this);
-                targetBoundToProperty = targetBoundProperty != null;
+        try {
+            if (targetBinding == null) {
+                reverseTriggerBinding = null;
+            } else {
+                reverseTriggerBinding = (TriggerBinding) triggerFactory.call(targetBinding);
             }
-        } else if (targetBinding != null) {
-            throw new RuntimeException("Only PropertyBindings can be set in a Mutual Property Binding");
+            this.targetBinding = (PropertyBinding) targetBinding;
+        } catch (RuntimeException re) {
+            throw new UnsupportedOperationException("Mutual Bindings may only change target bindings to other PropertyBindings");
         }
+        rebuildBindings();
     }
 
-    public static String bindProperty(Object bean, String propertyName, PropertyChangeListener that) {
-        try {
-            InvokerHelper.invokeMethodSafe(bean, "addPropertyChangeListener", new Object[] {propertyName, that});
-            return propertyName;
-        } catch (MissingMethodException mme) {
-            try {
-                InvokerHelper.invokeMethodSafe(bean, "addPropertyChangeListener", new Object[] {that});
-                return null;
-            } catch (MissingMethodException mme2) {
-                throw new RuntimeException("Properties in beans of type " + bean.getClass().getName() + " are not observable in any capacity (no PropertyChangeListener support).");
-            }
-        }
+    public void setValidator(Closure validator) {
+        this.validator = validator;
+        rebuildBindings();
+    }
+
+    public Closure getValidator() {
+        return validator;
+    }
+
+    public void setConverter(Closure converter) {
+        this.converter = converter;
+        rebuildBindings();
+    }
+
+    public Closure getConverter() {
+        return converter;
+    }
+
+    public void setReverseConverter(Closure reverseConverter) {
+       this.reverseConverter = reverseConverter;
+        rebuildBindings();
+    }
+
+    public Closure getReverseConverter() {
+        return reverseConverter;
     }
 
-    public static void unbindProperty(Object bean, String propertyName, PropertyChangeListener that) {
-        if (propertyName != null) {
-            try {
-                InvokerHelper.invokeMethodSafe(bean, "removePropertyChangeListener", new Object[] {propertyName, that});
-            } catch (MissingMethodException mme) {
-                // ignore, too bad so sad they don't follow conventions, we'll just leave the listener attached
+    protected void rebuildBindings() {
+        // tear stuff down, even if we are half built
+        if (bound) {
+            if (forwardBinding != null) {
+                forwardBinding.unbind();
             }
-        } else {
-            try {
-                InvokerHelper.invokeMethodSafe(bean, "removePropertyChangeListener", new Object[] {that});
-            } catch (MissingMethodException mme2) {
-                // ignore, too bad so sad they don't follow conventions, we'll just leave the listener attached
+            if (reverseBinding != null) {
+                reverseBinding.unbind();
             }
         }
+
+        // check for all pieces, if we don't have the triad quit silently
+        if (forwardTriggerBinding == null || sourceBinding == null || reverseTriggerBinding == null || targetBinding == null) {
+            return;
+        }
+
+        // build the pieces
+        forwardBinding = forwardTriggerBinding.createBinding(sourceBinding, targetBinding);
+        reverseBinding = reverseTriggerBinding.createBinding(targetBinding, sourceBinding);
+
+        // add the anciliary pieces
+        if ((converter != null) && (reverseConverter != null)) {
+            forwardBinding.setConverter(converter);
+            reverseBinding.setConverter(reverseConverter);
+        }
+        if (validator != null) {
+            forwardBinding.setValidator(validator);
+        }
+
+        // rebind if we were bound
+        if (bound) {
+            forwardBinding.bind();
+            reverseBinding.bind();
+        }
+
     }
 
     public void bind() {
         if (!bound) {
             bound = true;
-            if (sourceBinding != null) {
-                sourceBoundBean = ((PropertyBinding)sourceBinding).bean;
-                sourceBoundProperty = bindProperty(sourceBoundBean, ((PropertyBinding)sourceBinding).propertyName, this);
-                sourceBoundToProperty = sourceBoundProperty != null;
-            }
+            //guard checks
 
-            if (targetBinding != null) {
-                targetBoundBean = ((PropertyBinding)targetBinding).bean;
-                targetBoundProperty = bindProperty(targetBoundBean, ((PropertyBinding)targetBinding).propertyName, this);
-                targetBoundToProperty = targetBoundProperty != null;
+            // both converter and reverseConverter must be set or not
+            if ((converter == null) != (reverseConverter == null)) {
+                throw new RuntimeException("Both converter or reverseConverter must be set or unset to bind.  Only "
+                        + ((converter != null) ? "converter": "reverseConverter") + " is set.");
             }
+            // don't bind if we are half set up, quitly stop
+            if (forwardBinding == null || reverseBinding == null) {
+                // don't worry about the bind state, if the binding
+                // is completed we will bind in rebuild
+                return;
+            }
+
+            forwardBinding.bind();
+            reverseBinding.bind();
         }
     }
 
     public void unbind() {
         if (bound) {
-            if (sourceBoundBean != null) {
-                unbindProperty(sourceBoundBean, sourceBoundToProperty ? sourceBoundProperty : (String) null, this);
-                sourceBoundBean = null;
-                sourceBoundProperty = null;
-            }
-
-            if (targetBoundBean != null) {
-                unbindProperty(targetBoundBean, targetBoundToProperty ? targetBoundProperty : (String) null, this);
-                targetBoundBean = null;
-                targetBoundProperty = null;
-            }
+            forwardBinding.unbind();
+            reverseBinding.unbind();
             bound = false;
         }
     }
@@ -163,5 +186,12 @@ public class MutualPropertyBinding extends AbstractFullBinding implements Proper
         }
     }
 
+    public void update() {
+        forwardBinding.update();
+    }
+
+    public void reverseUpdate() {
+        reverseBinding.update();
+    }
 }
 
diff --git a/src/main/org/codehaus/groovy/binding/PropertyBinding.java b/src/main/org/codehaus/groovy/binding/PropertyBinding.java
index 776659754e..e7ea3eca23 100644
--- a/src/main/org/codehaus/groovy/binding/PropertyBinding.java
+++ b/src/main/org/codehaus/groovy/binding/PropertyBinding.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2007 the original author or authors.
+ * Copyright 2007-2009 the original author or authors.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -17,6 +17,7 @@ package org.codehaus.groovy.binding;
 
 import groovy.lang.MissingMethodException;
 import org.codehaus.groovy.runtime.InvokerHelper;
+import org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation;
 
 import java.beans.PropertyChangeEvent;
 import java.beans.PropertyChangeListener;
@@ -31,6 +32,7 @@ public class PropertyBinding implements SourceBinding, TargetBinding, TriggerBin
 
     Object bean;
     String propertyName;
+    boolean nonChangeCheck;
 
     public PropertyBinding(Object bean, String propertyName) {
         this.bean = bean;
@@ -38,9 +40,23 @@ public class PropertyBinding implements SourceBinding, TargetBinding, TriggerBin
     }
 
     public void updateTargetValue(Object newValue) {
+        if (nonChangeCheck) {
+            if (DefaultTypeTransformation.compareEqual(getSourceValue(), newValue)) {
+                // not a change, don't fire it
+                return;
+            }
+        }
         InvokerHelper.setProperty(bean, propertyName, newValue);
     }
 
+    public boolean isNonChangeCheck() {
+        return nonChangeCheck;
+    }
+
+    public void setNonChangeCheck(boolean nonChangeCheck) {
+        this.nonChangeCheck = nonChangeCheck;
+    }
+
     public Object getSourceValue() {
         return InvokerHelper.getPropertySafe(bean, propertyName);
     }
diff --git a/src/test/groovy/swing/SwingBuilderBindingsTest.groovy b/src/test/groovy/swing/SwingBuilderBindingsTest.groovy
index c11e96f4cf..dcf02748bf 100644
--- a/src/test/groovy/swing/SwingBuilderBindingsTest.groovy
+++ b/src/test/groovy/swing/SwingBuilderBindingsTest.groovy
@@ -672,55 +672,196 @@ public class SwingBuilderBindingsTest extends GroovySwingTestCase {
       }
     }
 
+    def mutualPropertyShortWorkout = { source, sourceProperty, sourceMutators,
+        target, targetProperty, targetMutators, binding ->
+
+      sourceMutators[0]()
+      targetMutators[0]()
+
+      // test forward binding
+      assert source[sourceProperty] == target[targetProperty]
+      sourceMutators[1]()
+      assert source[sourceProperty] == target[targetProperty]
+      sourceMutators[0]()
+      assert source[sourceProperty] == target[targetProperty]
+                                                                                                                        
+      // test reverse binding
+      targetMutators[1]()
+      assert source[sourceProperty] == target[targetProperty]
+      targetMutators[0]()
+      assert source[sourceProperty] == target[targetProperty]
+    }
+
+    def mutualPropertyWorkout = { source, sourceProperty, sourceMutators,
+      target, targetProperty, targetMutators, binding ->
+
+      mutualPropertyShortWorkout(source, sourceProperty, sourceMutators,
+        target, targetProperty, targetMutators, binding)
+
+      // test rebound
+      binding.rebind()
+      targetMutators[1]()
+      assert source[sourceProperty] == target[targetProperty]
+      sourceMutators[0]()
+      assert source[sourceProperty] == target[targetProperty]
+
+      // test unbound not updating
+      binding.unbind()
+      sourceMutators[1]()
+      assert source[sourceProperty] != target[targetProperty]
+      targetMutators[1]()
+      assert source[sourceProperty] == target[targetProperty]
+      sourceMutators[0]()
+      assert source[sourceProperty] != target[targetProperty]
+
+      // test manual forward update
+      sourceMutators[0]()
+      assert source[sourceProperty] != target[targetProperty]
+      binding.update()
+      assert source[sourceProperty] == target[targetProperty]
+
+      // test manual reverse update
+      sourceMutators[1]()
+      assert source[sourceProperty] != target[targetProperty]
+      binding.reverseUpdate()
+      assert source[sourceProperty] == target[targetProperty]
+    }
+  
     public void testMutualPropertyBinding() {
       testInEDT {
-        SwingBuilder swing = new SwingBuilder()
-
-        swing.actions() {
-            bean(new BindableBean(), id:'cb')
-            textField(id:'txt', enabled:bind(source:cb, sourceProperty:'enabled', id:'binding', mutual:true))
+        ['full', 'source', 'target'].each { mode -> // contextual bind mode
+          ['prop', 'synth'].each { target -> // target binding
+            ['prop', 'synth'].each { source -> // source binding
+              println "Trying $mode binding on $source source and $target target"
+
+              SwingBuilder swing = new SwingBuilder()
+
+              def sProp, tProp
+              swing.actions() {
+                switch (source) {
+                  case 'prop':
+                    sProp = 'enabled'
+                    st = new BindableBean(text:'Baz')
+                    break
+                  case 'synth':
+                    sProp = 'selected'
+                    st = textField(text:'Baz')
+                    break
+                  default: fail()
+                }
+                switch (target) {
+                  case 'prop':
+                    tProp = 'enabled'
+                    tt = new BindableBean(text:'Baz')
+                    break
+                  case 'synth':
+                    tProp = 'selected'
+                    tt = textField(text:'Baz')
+                    break
+                  default: fail()
+                }
+                
+                switch (mode) {
+                  case 'full':
+                    checkBox(id:'cb1')
+                    checkBox(id:'cb2')
+                    bind(source: cb1, sourceProperty: sProp,
+                         target: cb2, targetProperty: tProp,
+                         id:'binding', mutual:'true')
+
+                    bind('text', source: st, target: tt,
+                         id:'textBinding', mutual:'true')
+
+                    break
+                  case 'source':
+                    checkBox(id:'cb2')
+                    checkBox(id:'cb1', "$sProp": bind(
+                         target: cb2, targetProperty:tProp,
+                         id:'binding', mutual:'true'))
+
+                    bean(st, text:bind(
+                         target: tt, 'text',
+                         id:'textBinding', mutual:'true'))
+                    break
+                  case 'target':
+                    checkBox(id:'cb1')
+                    checkBox(id:'cb2', "$tProp": bind(
+                         source: cb1, sourceProperty:sProp,
+                         id:'binding', mutual:'true'))
+
+                    bean(tt, text:bind(
+                         source: st, 'text',
+                         id:'textBinding', mutual:'true'))
+                  break
+                  default: fail()
+                }
+              }
+              mutualPropertyWorkout(swing.cb1, sProp, [{swing.cb1[sProp] = true}, {swing.cb1[sProp] = false}],
+                swing.cb2, tProp, [{swing.cb2[tProp] = true}, {swing.cb2[tProp] = false}],
+                swing.binding)
+
+              mutualPropertyWorkout(swing.st, 'text', [{swing.st.text = "Foo"}, {swing.st.text = "Bar"}],
+                swing.tt, 'text', [{swing.tt.text = "Foo"}, {swing.tt.text = "Bar"}],
+                swing.textBinding)
+            }
+            if (mode != 'source') {
+              println "Trying $mode binding on event source and $target target"
+
+              SwingBuilder swing = new SwingBuilder()
+
+              def tProp
+              swing.actions() {
+                st = button(actionCommand:'Baz')
+
+                switch (target) {
+                  case 'prop':
+                    tProp = 'enabled'
+                    tt = new BindableBean(text:'Baz')
+                    break
+                  case 'synth':
+                    tProp = 'selected'
+                    tt = textField(text:'Baz')
+                    break
+                  default: fail()
+                }
+                switch (mode) {
+                  case 'full':
+                    checkBox(id:'cb1')
+                    checkBox(id:'cb2')
+                    bind(source: cb1, sourceEvent: 'actionPerformed', sourceProperty: 'borderPaintedFlat',
+                         target: cb2, targetProperty: tProp,
+                         id:'binding', mutual:'true')
+
+                    bind('text', source: st, sourceEvent: 'actionPerformed', sourceProperty:'actionCommand', target: tt,
+                         id:'textBinding', mutual:'true')
+
+                    break
+                  case 'target':
+                    checkBox(id:'cb1')
+                    checkBox(id:'cb2', "$tProp": bind(  source: cb1,
+                         sourceEvent: 'actionPerformed', sourceProperty: 'borderPaintedFlat',
+                         id:'binding', mutual:'true'))
+
+                    bean(tt, text:bind(
+                         source: st, 'actionCommand', sourceEvent: 'actionPerformed',
+                         id:'textBinding', mutual:'true'))
+                  break
+                  default: fail()
+                }
+                mutualPropertyShortWorkout(swing.cb1, 'borderPaintedFlat', [{swing.cb1.borderPaintedFlat = true; swing.cb1.doClick()}, {swing.cb1.borderPaintedFlat = false; swing.cb1.doClick()}],
+                  swing.cb2, tProp, [{swing.cb2[tProp] = true}, {swing.cb2[tProp] = false}],
+                  swing.binding)
+
+                mutualPropertyShortWorkout(swing.st, 'actionCommand', [{swing.st.actionCommand = "Foo"; swing.st.doClick()}, {swing.st.actionCommand = "Bar"; swing.st.doClick()}],
+                  swing.tt, 'text', [{swing.tt.text = "Foo"}, {swing.tt.text = "Bar"}],
+                  swing.textBinding)
+              }
+            }
+          }
         }
 
-          // test gorward binding
-        assert swing.txt.enabled == swing.cb.enabled
-        swing.cb.enabled = !swing.cb.enabled
-        assert swing.txt.enabled == swing.cb.enabled
-        swing.cb.enabled = !swing.cb.enabled
-        assert swing.txt.enabled == swing.cb.enabled
-
-          // test reverse binding
-        swing.txt.enabled = !swing.txt.enabled
-        assert swing.txt.enabled == swing.cb.enabled
-        swing.txt.enabled = !swing.txt.enabled
-        assert swing.txt.enabled == swing.cb.enabled
-
-        // test rebound
-        swing.binding.rebind()
-        swing.cb.enabled = !swing.cb.enabled
-        assert swing.txt.enabled == swing.cb.enabled
-        swing.txt.enabled = !swing.txt.enabled
-        assert swing.txt.enabled == swing.cb.enabled
-
-        // test unbound not updating
-        swing.binding.unbind()
-        swing.cb.enabled = !swing.cb.enabled
-        assert swing.txt.enabled != swing.cb.enabled
-        swing.txt.enabled = !swing.txt.enabled
-        assert swing.txt.enabled == swing.cb.enabled
-        swing.txt.enabled = !swing.txt.enabled
-        assert swing.txt.enabled != swing.cb.enabled
-
-        // test manual forward update
-        swing.txt.enabled = !swing.cb.enabled
-        assert swing.txt.enabled != swing.cb.enabled
-        swing.binding.update()
-        assert swing.txt.enabled == swing.cb.enabled
+        println "finished all permutations successfully"
 
-        // test manual reverse update
-        swing.txt.enabled = !swing.cb.enabled
-        assert swing.txt.enabled != swing.cb.enabled
-        swing.binding.reverseUpdate()
-        assert swing.txt.enabled == swing.cb.enabled
       }
     }
 
@@ -781,9 +922,10 @@ public class SwingBuilderBindingsTest extends GroovySwingTestCase {
     }
 }
 
-class BindableBean {
-    @Bindable boolean enabled
-    @Bindable Integer value
-    @Bindable float floatValue
-    @Bindable int pvalue
+@Bindable class BindableBean {
+    boolean enabled
+    Integer value
+    float floatValue
+    int pvalue
+    String text
 }
