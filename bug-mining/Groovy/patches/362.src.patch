diff --git a/src/main/groovy/lang/MetaClassImpl.java b/src/main/groovy/lang/MetaClassImpl.java
index 97496b19d1..fc7e9e03ed 100644
--- a/src/main/groovy/lang/MetaClassImpl.java
+++ b/src/main/groovy/lang/MetaClassImpl.java
@@ -811,7 +811,7 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
        if (sender==Class.class) {
            return invokeMethod(object,methodName,arguments);
        }
-       
+
        if (arguments==null) arguments = EMPTY_ARGUMENTS;
        Class[] argClasses = MetaClassHelper.convertToTypeArray(arguments);
        Object[] originalArguments = (Object[]) arguments.clone();
@@ -831,19 +831,37 @@ public class MetaClassImpl implements MetaClass, MutableMetaClass {
        }
 
        if (prop instanceof Closure) {
-           Closure closure = (Closure) prop;
-           MetaClass delegateMetaClass = closure.getMetaClass();
-           return delegateMetaClass.invokeMethod(closure.getClass(),closure, CLOSURE_DO_CALL_METHOD,originalArguments,false,false);
+           return invokeStaticClosureProperty(originalArguments, prop);
        }
 
        Class superClass = sender.getSuperclass();
-       if (superClass != Object.class && superClass != null) {
-           return invokeStaticMethod(sender.getSuperclass(), methodName, arguments);
+       while(superClass != Object.class && superClass != null) {
+           MetaClass mc = registry.getMetaClass(superClass);
+           method = mc.getStaticMetaMethod(methodName, argClasses);
+           if(method!=null)return MetaClassHelper.doMethodInvoke(object, method, arguments);
+
+           try {
+               prop = mc.getProperty(superClass, superClass, methodName, false, false);
+           }  catch (MissingPropertyException mpe) {
+               // ignore
+           }
+
+           if (prop instanceof Closure) {
+               return invokeStaticClosureProperty(originalArguments, prop);
+           }
+
+           superClass = superClass.getSuperclass();
        }
 
        return invokeStaticMissingMethod(sender, methodName, arguments);
    }
 
+    private Object invokeStaticClosureProperty(Object[] originalArguments, Object prop) {
+        Closure closure = (Closure) prop;
+        MetaClass delegateMetaClass = closure.getMetaClass();
+        return delegateMetaClass.invokeMethod(closure.getClass(),closure, CLOSURE_DO_CALL_METHOD,originalArguments,false,false);
+    }
+
     private Object invokeStaticMissingMethod(Class sender, String methodName, Object[] arguments) {
         MetaMethod metaMethod = getStaticMetaMethod(METHOD_MISSING, METHOD_MISSING_ARGS);
         if(metaMethod!=null) {
diff --git a/src/test/groovy/lang/MethodMissingTest.groovy b/src/test/groovy/lang/MethodMissingTest.groovy
index 3bf38f397a..bbd396dfd6 100644
--- a/src/test/groovy/lang/MethodMissingTest.groovy
+++ b/src/test/groovy/lang/MethodMissingTest.groovy
@@ -12,6 +12,16 @@
 package groovy.lang
 class MethodMissingTest extends GroovyTestCase {
 
+    void testMethodMissingWithInheritance() {
+         assertEquals "world",MMTest6.hello()
+         assertEquals "cruel world",MMTest6.goodbye()
+         assertEquals "foo",MMTest6.bar()
+
+         shouldFail(MissingMethodException) {
+             MMTest5.bar()
+         }
+    }
+
     void testSimpleMethodMissing() {
         def t = new MMTest()
         assertEquals "world", t.hello()
@@ -85,3 +95,10 @@ class MMTest4 {
         "bar"
     }
 }
+class MMTest5 {
+    static hello() { "world" }
+}
+class MMTest6 extends MMTest5 {
+    static goodbye() { "cruel world" }
+    static methodMissing(String name, args) { "foo" }
+}
\ No newline at end of file
