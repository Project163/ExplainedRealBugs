diff --git a/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java b/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
index 58c9a56c29..2bc618d443 100644
--- a/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
+++ b/src/main/java/org/codehaus/groovy/control/ResolveVisitor.java
@@ -332,7 +332,7 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
         if (type.isRedirectNode() || !type.isPrimaryClassNode()) {
             visitTypeAnnotations(type); // JSR 308 support
         }
-        if (preferImports) {
+        if (preferImports && !type.isResolved() && !type.isPrimaryClassNode()) {
             resolveGenericsTypes(type.getGenericsTypes());
             if (resolveAliasFromModule(type)) return;
         }
@@ -597,9 +597,9 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
     }
 
     private boolean resolveAliasFromModule(final ClassNode type) {
-        // In case of getting a ConstructedClassWithPackage here we do not do checks for partial
-        // matches with imported classes. The ConstructedClassWithPackage is already a constructed
-        // node and any subclass resolving will then take place elsewhere
+        // In case of getting a ConstructedClassWithPackage here we do not check
+        // for partial matches with imported classes. ConstructedClassWithPackage
+        // is already a constructed node and subclass resolving takes place elsewhere.
         if (type instanceof ConstructedClassWithPackage) return false;
 
         ModuleNode module = currentClass.getModule();
@@ -666,50 +666,64 @@ public class ResolveVisitor extends ClassCodeExpressionTransformer {
     }
 
     protected boolean resolveFromModule(final ClassNode type, final boolean testModuleImports) {
-        if (type instanceof ConstructedNestedClass) return false;
+        ModuleNode module = currentClass.getModule();
+        if (module == null) return false;
 
-        // we decided if we have a vanilla name starting with a lower case
+        if (type instanceof ConstructedNestedClass) return false;
+        // We decided if we have a vanilla name starting with a lower case
         // letter that we will not try to resolve this name against .*
         // imports. Instead a full import is needed for these.
         // resolveAliasFromModule will do this check for us. This method
         // does also check the module contains a class in the same package
         // of this name. This check is not done for vanilla names starting
-        // with a lower case letter anymore
-        if (type instanceof LowerCaseClass) {
-            return resolveAliasFromModule(type);
-        }
+        // with a lower case letter anymore.
+        if (type instanceof LowerCaseClass) return resolveAliasFromModule(type);
 
         String name = type.getName();
-        ModuleNode module = currentClass.getModule();
-        if (module == null) return false;
-
-        boolean newNameUsed = false;
-        // we add a package if there is none yet and the module has one. But we
-        // do not add that if the type is a ConstructedClassWithPackage. The code in ConstructedClassWithPackage
-        // hasPackageName() will return true if ConstructedClassWithPackage#className has no dots.
-        // but since the prefix may have them and the code there does ignore that
-        // fact. We check here for ConstructedClassWithPackage.
-        if (!type.hasPackageName() && module.hasPackageName() && !(type instanceof ConstructedClassWithPackage)) {
-            type.setName(module.getPackageName() + name);
-            newNameUsed = true;
-        }
-        // look into the module node if there is a class with that name
-        List<ClassNode> moduleClasses = module.getClasses();
-        for (ClassNode mClass : moduleClasses) {
-            if (mClass.getName().equals(type.getName())) {
-                if (mClass != type) type.setRedirect(mClass);
+        boolean type_setName = false;
+        if (!type.hasPackageName()) {
+            if (testModuleImports) { // GROOVY-8254
+                ImportNode importNode = module.getImport(name);
+                if (importNode != null && importNode != currentImport && !importNode.getAlias().equals(importNode.getType().getNameWithoutPackage())) {
+                    type.setRedirect(importNode.getType());
+                    return true;
+                }
+                importNode = module.getStaticImports().get(name);
+                if (importNode != null && importNode != currentImport && !importNode.getAlias().equals(importNode.getFieldName())) {
+                    ClassNode tmp = new ConstructedNestedClass(importNode.getType(), importNode.getFieldName());
+                    if (resolve(tmp, false, false, true) && Modifier.isStatic(tmp.getModifiers())) {
+                        type.setRedirect(tmp.redirect());
+                        return true;
+                    }
+                }
+            }
+            // We add a package if there is none yet and the module has one. But we
+            // do not add that if the type is a ConstructedClassWithPackage. The code in ConstructedClassWithPackage
+            // hasPackageName() will return true if ConstructedClassWithPackage#className has no dots.
+            // but since the prefix may have them and the code there does ignore that fact.
+            if (module.hasPackageName() && !(type instanceof ConstructedClassWithPackage)) {
+                type.setName(module.getPackageName() + name);
+                type_setName = true;
+            }
+        }
+        // check the module node for a class with the name
+        for (ClassNode localClass : module.getClasses()) {
+            if (localClass.getName().equals(type.getName())) {
+                if (localClass != type) type.setRedirect(localClass);
                 return true;
             }
         }
-        if (newNameUsed) type.setName(name);
+        if (type_setName) type.setName(name);
 
         if (testModuleImports) {
-            if (resolveAliasFromModule(type)) return true;
-
+            // check regular imports
+            if (resolveAliasFromModule(type)) {
+                return true;
+            }
+            // check enclosing package
             if (module.hasPackageName()) {
-                // check package this class is defined in. The usage of ConstructedClassWithPackage here
-                // means, that the module package will not be involved when the
-                // compiler tries to find an inner class.
+                // The usage of ConstructedClassWithPackage indicates the module
+                // package will not be involved when the compiler tries to find an inner class.
                 ClassNode tmp = new ConstructedClassWithPackage(module.getPackageName(), name);
                 if (resolve(tmp, false, false, false)) {
                     ambiguousClass(type, tmp, name);
diff --git a/src/spec/test/TraitsSpecificationTest.groovy b/src/spec/test/TraitsSpecificationTest.groovy
index 7f918e1b8c..528d099911 100644
--- a/src/spec/test/TraitsSpecificationTest.groovy
+++ b/src/spec/test/TraitsSpecificationTest.groovy
@@ -353,8 +353,7 @@ d.methodFromB()                     // <5>
     }
 
     void testSAMCoercion() {
-        assertScript '''import org.codehaus.groovy.runtime.Greeter
-
+        assertScript '''
 // tag::sam_trait[]
 trait Greeter {
     String greet() { "Hello $name" }        // <1>
diff --git a/src/test/gls/innerClass/InnerClassTest.groovy b/src/test/gls/innerClass/InnerClassTest.groovy
index 102f148469..7e4e68fd83 100644
--- a/src/test/gls/innerClass/InnerClassTest.groovy
+++ b/src/test/gls/innerClass/InnerClassTest.groovy
@@ -45,6 +45,31 @@ final class InnerClassTest {
         '''
     }
 
+    @Test // GROOVY-8254
+    void testAliasAIC() {
+        assertScript '''import Foo as Bar
+            class Foo {}
+            class Bar {}
+
+            def regular = new Bar()
+            def anonymous = new Bar() {}
+            assert regular.class.name == 'Foo'
+            assert anonymous.class.superclass.name == 'Foo'
+        '''
+
+        assertScript '''import static Baz.Foo as Bar
+            class Bar {}
+            class Baz {
+                static class Foo {}
+            }
+
+            def regular = new Bar()
+            def anonymous = new Bar() {}
+            assert regular.class.name == 'Baz$Foo'
+            assert anonymous.class.superclass.name == 'Baz$Foo'
+        '''
+    }
+
     @Test // GROOVY-10840
     void testArrayAIC() {
         assertScript '''
diff --git a/src/test/groovy/transform/stc/MethodCallsSTCTest.groovy b/src/test/groovy/transform/stc/MethodCallsSTCTest.groovy
index 0d05b66df4..06575bdf5a 100644
--- a/src/test/groovy/transform/stc/MethodCallsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/MethodCallsSTCTest.groovy
@@ -106,7 +106,7 @@ class MethodCallsSTCTest extends StaticTypeCheckingTestCase {
     void testStaticMethodCallWithInheritance() {
         assertScript '''
             String echo = B.echo 'echo'
-            assert  echo == 'echo'
+            assert echo == 'echo'
         '''
     }
 
@@ -130,7 +130,7 @@ class MethodCallsSTCTest extends StaticTypeCheckingTestCase {
         assertScript '''
             String[] arr = ['3','2','1']
             Arrays.sort(arr)
-            assert arr == ['1','2','3']  as String[]
+            assert arr == ['1','2','3'] as String[]
         '''
     }
 
@@ -153,7 +153,7 @@ class MethodCallsSTCTest extends StaticTypeCheckingTestCase {
     void testPlusStaticMethodCall() {
         assertScript '''
             static int foo() { 1 }
-            assert 1+foo() == 2
+            assert 1 + foo() == 2
         '''
     }
 
@@ -307,12 +307,12 @@ class MethodCallsSTCTest extends StaticTypeCheckingTestCase {
                     return t
                 }
             }
-            class C implements I<String> {
+            class C10494 implements I<String> {
                 @Override m(String s) {
                     I.super.m(s)
                 }
             }
-            String result = new C().m('works')
+            String result = new C10494().m('works')
             assert result == 'works'
         '''
 
@@ -321,7 +321,7 @@ class MethodCallsSTCTest extends StaticTypeCheckingTestCase {
                 default void m(T t) {
                 }
             }
-            class C implements I<String> {
+            class C10494 implements I<String> {
                 @Override void m(String s) {
                     super.m(s)
                 }
@@ -1014,39 +1014,39 @@ class MethodCallsSTCTest extends StaticTypeCheckingTestCase {
 
     void testShouldNotAllowMethodCallFromStaticInitializer() {
         shouldFailWithMessages '''
-            class A {
+            class Foo {
                 void instanceMethod() {}
                 static {
                     instanceMethod()
                 }
             }
-            new A()
+            new Foo()
         ''',
-        'Non-static method A#instanceMethod cannot be called from static context'
+        'Non-static method Foo#instanceMethod cannot be called from static context'
     }
 
     void testShouldNotAllowMethodCallFromStaticMethod() {
         shouldFailWithMessages '''
-            class A {
+            class Foo {
                 void instanceMethod() {}
                 static void staticMethod() {
                     instanceMethod()
                 }
             }
-            A.staticMethod()
+            Foo.staticMethod()
         ''',
-        'Non-static method A#instanceMethod cannot be called from static context'
+        'Non-static method Foo#instanceMethod cannot be called from static context'
     }
 
     void testShouldNotAllowMethodCallFromStaticField() {
         shouldFailWithMessages '''
-            class A {
+            class Foo {
                 boolean instanceMethod() {}
                 static FOO = instanceMethod()
             }
-            new A()
+            new Foo()
         ''',
-        'Non-static method A#instanceMethod cannot be called from static context'
+        'Non-static method Foo#instanceMethod cannot be called from static context'
     }
 
     // GROOVY-5495
@@ -1054,17 +1054,17 @@ class MethodCallsSTCTest extends StaticTypeCheckingTestCase {
         assertScript '''
             class ClassUnderTest {
                 void methodFromString(SecondInterface si) {
-                    si.methodFromSecondInterface();
-                    si.methodFromFirstInterface();
+                    si.methodFromSecondInterface()
+                    si.methodFromFirstInterface()
                 }
             }
 
             interface FirstInterface {
-                void methodFromFirstInterface();
+                void methodFromFirstInterface()
             }
 
             interface SecondInterface extends FirstInterface {
-                void methodFromSecondInterface();
+                void methodFromSecondInterface()
             }
 
             new ClassUnderTest()
@@ -1112,7 +1112,7 @@ class MethodCallsSTCTest extends StaticTypeCheckingTestCase {
     // GROOVY-5540
     void testChoosePublicMethodInHierarchy() {
         assertScript '''import groovy.transform.stc.MethodCallsSTCTest.Child2
-            class A {
+            class Foo {
                 int delegate() {
                     @ASTTest(phase=INSTRUCTION_SELECTION, value={
                         def md = node.rightExpression.getNodeMetaData(DIRECT_METHOD_CALL_TARGET)
@@ -1122,7 +1122,7 @@ class MethodCallsSTCTest extends StaticTypeCheckingTestCase {
                     res
                 }
             }
-            assert new A().delegate() == 2
+            assert new Foo().delegate() == 2
         '''
     }
 
@@ -1301,32 +1301,32 @@ class MethodCallsSTCTest extends StaticTypeCheckingTestCase {
     void testSpreadArgsRestrictedInConstructorCall() {
         // GROOVY-10597
         assertScript '''
-            class C {
-                C(String one, String... zeroOrMore) {
+            class Foo {
+                Foo(String one, String... zeroOrMore) {
                     String result = one + zeroOrMore.join('')
                     assert result == 'ABC'
                 }
             }
-            new C('A', *['B'], 'C')
+            new Foo('A', *['B'], 'C')
         '''
 
         shouldFailWithMessages '''
-            class C {
-                C(String one, String... zeroOrMore) {
+            class Foo {
+                Foo(String one, String... zeroOrMore) {
                 }
             }
-            new C(*['A','B'])
+            new Foo(*['A','B'])
         ''',
         'The spread operator cannot be used as argument of method or closure calls with static type checking because the number of arguments cannot be determined at compile time'
 
         shouldFailWithMessages '''
-            class C {
-                C(String a, String b) {
+            class Foo {
+                Foo(String a, String b) {
                 }
             }
-            new C(*['A','B'])
+            new Foo(*['A','B'])
         ''',
-        'Cannot find matching constructor C(',
+        'Cannot find matching constructor Foo(',
         'The spread operator cannot be used as argument of method or closure calls with static type checking because the number of arguments cannot be determined at compile time'
     }
 
@@ -1366,7 +1366,7 @@ class MethodCallsSTCTest extends StaticTypeCheckingTestCase {
         '''
 
         shouldFailWithMessages '''
-            class C {
+            class Foo {
                 def m1(long l) { Long.valueOf(l) }
                 def m2(int i) { new Integer(i) }
                 void test() {
@@ -1375,11 +1375,11 @@ class MethodCallsSTCTest extends StaticTypeCheckingTestCase {
                 }
             }
         ''',
-        'Cannot find matching method C#m1(java.math.BigDecimal)',
-        'Cannot find matching method C#m2(java.math.BigDecimal)'
+        'Cannot find matching method Foo#m1(java.math.BigDecimal)',
+        'Cannot find matching method Foo#m2(java.math.BigDecimal)'
 
         shouldFailWithMessages '''
-            class C {
+            class Foo {
                 def m1(long l) { Long.valueOf(l) }
                 def m2(int i) { new Integer(i) }
                 void test() {
@@ -1388,8 +1388,8 @@ class MethodCallsSTCTest extends StaticTypeCheckingTestCase {
                 }
             }
         ''',
-        'Cannot find matching method C#m1(java.math.BigInteger)',
-        'Cannot find matching method C#m2(java.math.BigInteger)'
+        'Cannot find matching method Foo#m1(java.math.BigInteger)',
+        'Cannot find matching method Foo#m2(java.math.BigInteger)'
     }
 
     void testBoxingShouldCostMore() {
@@ -1758,35 +1758,35 @@ class MethodCallsSTCTest extends StaticTypeCheckingTestCase {
 
     void testShouldFindSetProperty() {
         assertScript '''
-            class C {
+            class Foo {
                 int p
                 void m() {
                     this.setProperty('p', 1)
                 }
             }
-            def c = new C()
-            c.m()
-            assert c.p == 1
+            def o = new Foo()
+            o.m()
+            assert o.p == 1
         '''
     }
 
     // GROOVY-5888
     void testStaticContext1() {
         assertScript '''
-            class C {
+            class Foo {
                 static List p = 'a,b,c'.split(/,/)*.trim()
             }
-            assert C.p == ['a','b','c']
+            assert Foo.p == ['a','b','c']
         '''
     }
 
     // GROOVY-11195
     void testStaticContext2() {
         assertScript '''
-            class C {
+            class Foo {
                 static String p = this.getName() // instance method of Class
             }
-            assert C.p == 'C'
+            assert Foo.p == 'Foo'
         '''
     }
 
