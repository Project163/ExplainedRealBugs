<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Wed Nov 12 01:01:28 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[GROOVY-9058] each parameter type not correctly inferenced</title>
                <link>https://issues.apache.org/jira/browse/GROOVY-9058</link>
                <project id="12318123" key="GROOVY">Groovy</project>
                    <description>&lt;p&gt;Consider this Java class:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;package&lt;/span&gt; test51;

&lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; java.util.List;

&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;Foo {
&#160;&#160; &#160;&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; List&amp;lt;&lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;[]&amp;gt; bar() { &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;; }
}&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&#160;and this Groovy class:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;package&lt;/span&gt; test51

&lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; groovy.transform.CompileStatic

@CompileStatic
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;Test51 {
&#160;&#160; &#160;&lt;span class=&quot;code-keyword&quot;&gt;protected&lt;/span&gt; void foo() {
&#160;&#160; &#160;&#160;&#160; &#160;List&amp;lt;&lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;[]&amp;gt; foo = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Foo().bar()
&#160;&#160; &#160;&#160;&#160; &#160;foo.each { row -&amp;gt;
&#160;&#160; &#160;&#160;&#160; &#160;&#160;&#160; &#160;def o = row[0]
&#160;&#160; &#160;&#160;&#160; &#160;}
&#160;&#160; &#160;}
&#160;&#160; &#160;
&#160;&#160; &#160;List bar() {
&#160;&#160; &#160;}
}&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This produces a compiler error because&#160;&lt;tt&gt;row&lt;/tt&gt; is resolved as&#160;&lt;tt&gt;Object&lt;/tt&gt; rather than &lt;tt&gt;Object[]&lt;/tt&gt;.&lt;/p&gt;

&lt;p&gt;A workaround is to declare &lt;tt&gt;row&lt;/tt&gt; as &lt;tt&gt;Object[] row&lt;/tt&gt; in the closure parameter list.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13224353">GROOVY-9058</key>
            <summary>each parameter type not correctly inferenced</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="paulk">Paul King</assignee>
                                    <reporter username="mauromol">Mauro Molinari</reporter>
                        <labels>
                    </labels>
                <created>Wed, 27 Mar 2019 16:08:08 +0000</created>
                <updated>Mon, 20 May 2019 07:31:32 +0000</updated>
                            <resolved>Sat, 4 May 2019 05:20:10 +0000</resolved>
                                    <version>2.5.6</version>
                                    <fixVersion>3.0.0-beta-1</fixVersion>
                    <fixVersion>2.5.7</fixVersion>
                                    <component>Static compilation</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>4</watches>
                                                    <progress percentage="100">
                                    <originalProgress>
                                                    <row percentage="0" backgroundColor="#89afd7"/>
                                                    <row percentage="100" backgroundColor="transparent"/>
                                            </originalProgress>
                                                    <currentProgress>
                                                    <row percentage="100" backgroundColor="#51a825"/>
                                                    <row percentage="0" backgroundColor="#ec8e00"/>
                                            </currentProgress>
                            </progress>
                                    <aggregateprogress percentage="100">
                                    <originalProgress>
                                                    <row percentage="0" backgroundColor="#89afd7"/>
                                                    <row percentage="100" backgroundColor="transparent"/>
                                            </originalProgress>
                                                    <currentProgress>
                                                    <row percentage="100" backgroundColor="#51a825"/>
                                                    <row percentage="0" backgroundColor="#ec8e00"/>
                                            </currentProgress>
                            </aggregateprogress>
                                            <timeestimate seconds="0">0h</timeestimate>
                            <timespent seconds="1200">20m</timespent>
                                <comments>
                            <comment id="16803107" author="emilles" created="Wed, 27 Mar 2019 17:28:59 +0000"  >&lt;p&gt;I think the issue lies within &lt;tt&gt;StaticTypeCheckingVisitor.doInferClosureParameterTypes&lt;/tt&gt;.  STC has determined that the type of the closure parameter is Object[] however, lastArg is true and the array&apos;s component type matches the origin type of the parameter (Object since no explicit type was given in the source). So Object is saved instead of Object[].&lt;/p&gt;

&lt;p&gt;Adding a check &lt;tt&gt;!closureParam.isDynamicTyped()&lt;/tt&gt; seems to be the ticket.  Not sure if this causes any undesirable effects.&lt;/p&gt;


&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
                    &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; lastArg = (i == length - 1);
                    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (lastArg &amp;amp;&amp;amp; inferredType.isArray()) {
                        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;code-comment&quot;&gt;/*GRECLIPSE add*/&lt;/span&gt;!closureParam.isDynamicTyped() &amp;amp;&amp;amp; &lt;span class=&quot;code-comment&quot;&gt;/*GRECLIPSE end*/&lt;/span&gt;inferredType.getComponentType().equals(originType)) {
                            inferredType = originType;
                        }
                    } &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!typeCheckMethodArgumentWithGenerics(originType, inferredType, lastArg)) {
                        addError(&lt;span class=&quot;code-quote&quot;&gt;&quot;Expected parameter of type &quot;&lt;/span&gt; + inferredType.toString(&lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;) + &lt;span class=&quot;code-quote&quot;&gt;&quot; but got &quot;&lt;/span&gt; + originType.toString(&lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;), closureParam.getType());
                    }
                    typeCheckingContext.controlStructureVariables.put(closureParam, inferredType);
                }
            }
        }
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="16807916" author="emilles" created="Tue, 2 Apr 2019 16:51:01 +0000"  >&lt;p&gt;Before the compiler gets to the above, &lt;tt&gt;StaticTypeCheckingVisitor.visitBinaryExpression&lt;/tt&gt; runs and this appears to be where &lt;tt&gt;Type x = y&lt;/tt&gt; is ignoring &lt;tt&gt;Type&lt;/tt&gt; and saving &lt;tt&gt;typeof y&lt;/tt&gt; as the inferred static type of &lt;tt&gt;x&lt;/tt&gt;.&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void visitBinaryExpression(BinaryExpression expression) {
        &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; op = expression.getOperation().getType();
        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (op == COMPARE_IDENTICAL || op == COMPARE_NOT_IDENTICAL) {
            &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt;; &lt;span class=&quot;code-comment&quot;&gt;// we&apos;ll report those as errors later
&lt;/span&gt;        }
        BinaryExpression enclosingBinaryExpression = typeCheckingContext.getEnclosingBinaryExpression();
        typeCheckingContext.pushEnclosingBinaryExpression(expression);
        &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
            &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; Expression leftExpression = expression.getLeftExpression();
            &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; Expression rightExpression = expression.getRightExpression();
            ...
            ClassNode lType = getType(leftExpression);
            ClassNode rType = getType(rightExpression);
            ...
            &lt;span class=&quot;code-comment&quot;&gt;// In the &lt;span class=&quot;code-keyword&quot;&gt;case&lt;/span&gt; of &lt;span class=&quot;code-quote&quot;&gt;&quot;List&amp;lt;&lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;[]&amp;gt; foo = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Foo().bar()&quot;&lt;/span&gt;, lType is &lt;span class=&quot;code-quote&quot;&gt;&quot;List&amp;lt;&lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;[]&amp;gt;&quot;&lt;/span&gt; and rType is &lt;span class=&quot;code-quote&quot;&gt;&quot;List&quot;&lt;/span&gt;.  resultType is &lt;span class=&quot;code-quote&quot;&gt;&quot;List&quot;&lt;/span&gt; after the next line.  I think &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; is why &lt;span class=&quot;code-quote&quot;&gt;&quot;Map map = [a:1, b:2]&quot;&lt;/span&gt; is resulting in STC bugs like &lt;span class=&quot;code-quote&quot;&gt;&quot;LinkedHashMap&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;&amp;gt; is not a valid substitute &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; ...&quot;&lt;/span&gt;.
&lt;/span&gt;            ClassNode resultType = op==KEYWORD_IN
                    ?getResultType(rType,op,lType,reversedBinaryExpression)
                    :getResultType(lType, op, rType, expression);
            ...
            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (resultType == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
                resultType = lType;
            }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="16807927" author="emilles" created="Tue, 2 Apr 2019 17:07:38 +0000"  >&lt;p&gt;&lt;tt&gt;left&lt;/tt&gt; is &lt;tt&gt;List&amp;lt;Object[]&amp;gt;&lt;/tt&gt;, &lt;tt&gt;right&lt;/tt&gt; is &lt;tt&gt;List&lt;/tt&gt;, &lt;tt&gt;op&lt;/tt&gt; is &lt;tt&gt;ASSIGN&lt;/tt&gt;, and &lt;tt&gt;expr&lt;/tt&gt; is a &lt;tt&gt;DeclarationExpression&lt;/tt&gt;.  &lt;b&gt;In the case of a declaration expression with an explicit type (aka &lt;tt&gt;List&amp;lt;Object[]&amp;gt; foo = new Foo().bar()&lt;/tt&gt;), should the explicit type always be returned here?&lt;/b&gt;&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
    &lt;span class=&quot;code-keyword&quot;&gt;protected&lt;/span&gt; ClassNode getResultType(ClassNode left, &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; op, ClassNode right, BinaryExpression expr) {
        ClassNode leftRedirect = left.redirect();
        ClassNode rightRedirect = right.redirect();

        Expression leftExpression = expr.getLeftExpression();
        Expression rightExpression = expr.getRightExpression();
        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (op == ASSIGN || op == ASSIGNMENT_OPERATOR) {
            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (leftRedirect.isArray() &amp;amp;&amp;amp; implementsInterfaceOrIsSubclassOf(rightRedirect, Collection_TYPE)) &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; leftRedirect;
            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (leftRedirect.implementsInterface(Collection_TYPE) &amp;amp;&amp;amp; rightRedirect.implementsInterface(Collection_TYPE)) {
                &lt;span class=&quot;code-comment&quot;&gt;// because of type inferrence, we must perform an additional check &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; the right expression
&lt;/span&gt;                &lt;span class=&quot;code-comment&quot;&gt;// is an empty list expression ([]). In that &lt;span class=&quot;code-keyword&quot;&gt;case&lt;/span&gt; and only in that &lt;span class=&quot;code-keyword&quot;&gt;case&lt;/span&gt;, the inferred type
&lt;/span&gt;                &lt;span class=&quot;code-comment&quot;&gt;// will be wrong, so we will prefer the left type
&lt;/span&gt;                &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (rightExpression &lt;span class=&quot;code-keyword&quot;&gt;instanceof&lt;/span&gt; ListExpression) {
                    List&amp;lt;Expression&amp;gt; list = ((ListExpression) rightExpression).getExpressions();
                    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (list.isEmpty()) &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; left;
                }
                &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; right; &lt;span class=&quot;code-comment&quot;&gt;// returns &lt;span class=&quot;code-quote&quot;&gt;&quot;java.util.List&quot;&lt;/span&gt; from here
&lt;/span&gt;            }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="16808150" author="emilles" created="Tue, 2 Apr 2019 20:55:31 +0000"  >&lt;p&gt;If I rewrite the upper half of &lt;tt&gt;getResultType&lt;/tt&gt;&#160;(everything before &lt;tt&gt;isBoolIntrinsicOp&lt;/tt&gt;), like this:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
    &lt;span class=&quot;code-keyword&quot;&gt;protected&lt;/span&gt; ClassNode getResultType(ClassNode left, &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; op, ClassNode right, BinaryExpression expr) {
        ClassNode leftRedirect = left.redirect();
        ClassNode rightRedirect = right.redirect();

        Expression leftExpression = expr.getLeftExpression();
        Expression rightExpression = expr.getRightExpression();

        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (op == ASSIGN || op == ASSIGNMENT_OPERATOR) {
            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (rightExpression &lt;span class=&quot;code-keyword&quot;&gt;instanceof&lt;/span&gt; ClosureExpression &amp;amp;&amp;amp; rightRedirect.isDerivedFrom(CLOSURE_TYPE) &amp;amp;&amp;amp; isSAMType(leftRedirect)) {
                &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; inferSAMTypeGenericsInAssignment(left, findSAM(left), right, (ClosureExpression) rightExpression);
            }

            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (leftExpression &lt;span class=&quot;code-keyword&quot;&gt;instanceof&lt;/span&gt; VariableExpression) {
                ClassNode initialType = getOriginalDeclarationType(leftExpression).redirect();

                &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (isPrimitiveType(right) &amp;amp;&amp;amp; initialType.isDerivedFrom(Number_TYPE)) {
                    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; getWrapper(right);
                }

                &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (isPrimitiveType(initialType) &amp;amp;&amp;amp; rightRedirect.isDerivedFrom(Number_TYPE)) {
                    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; getUnwrapper(right);
                }

                /* GRECLIPSE edit
                &lt;span class=&quot;code-comment&quot;&gt;// as anything can be assigned to a &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;code-object&quot;&gt;Class&lt;/span&gt; or [Bb]oolean, &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; the left type instead
&lt;/span&gt;                &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (STRING_TYPE.equals(initialType)
                        || CLASS_Type.equals(initialType)
                        || Boolean_TYPE.equals(initialType)
                        || boolean_TYPE.equals(initialType)) {
                    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; initialType;
                }
                */
                &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!((VariableExpression) leftExpression).isDynamicTyped()) {
                    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; initialType;
                }
            }

            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (rightRedirect.implementsInterface(Collection_TYPE)) {
                &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (leftRedirect.isArray()) {
                    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; leftRedirect;
                }
                &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (leftRedirect.implementsInterface(Collection_TYPE) &amp;amp;&amp;amp;
                        rightExpression &lt;span class=&quot;code-keyword&quot;&gt;instanceof&lt;/span&gt; ListExpression &amp;amp;&amp;amp; isEmptyCollection(rightExpression)) {
                    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; left;
                }
            }

            &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; right;
        }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I think it does everything it did before, except assignments to non-dynamic variables will return the variable type instead of the RHS type.  &lt;em&gt;Can someone try this out in groovy core and run the tests?&lt;/em&gt;&lt;/p&gt;


&lt;p&gt;With these changes, code like this will use `Object[]` instead of `PortableProperties[]` for the type of `array`.  So I would change `Object[]` to `def` in this case.&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-groovy&quot;&gt;
        &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;[] array = properties.getProperty(VALUES_PROPERTY_NAME) &lt;span class=&quot;code-keyword&quot;&gt;as&lt;/span&gt; PortableProperties[]
        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (array)
        {
            values = array.collect { PortableProperties pp -&amp;gt; ValueComparison.fromPortableProperties(pp) }
        }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;


&lt;p&gt;And code like this will use `Multimap&amp;lt;A, B&amp;gt;` instead of `LinkedHashMultimap` for the type of `facets`.  So I would add typecasts to `entry.key` and `entry.value.values()` since I am no longer putting to a raw-typed multimap.&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-groovy&quot;&gt;
        Multimap&amp;lt;A, B&amp;gt; facets = LinkedHashMultimap.create()
        &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (entry &lt;span class=&quot;code-keyword&quot;&gt;in&lt;/span&gt; appliedAttributes)
        {
            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (entry.key &lt;span class=&quot;code-keyword&quot;&gt;instanceof&lt;/span&gt; A)
            {
                facets.putAll(entry.key, entry.value.values())
            }
        }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Since these are breaking changes to compilation/type-checking, I would suggest changes to Groovy 3 only.&lt;/p&gt;</comment>
                            <comment id="16808215" author="emilles" created="Tue, 2 Apr 2019 22:56:03 +0000"  >&lt;p&gt;However, the addition of &lt;tt&gt;if (!((VariableExpression) leftExpression).isDynamicTyped()) return initialType;&lt;/tt&gt; causes this type of situation to stop reporting an error for incompatible assignment:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-groovy&quot;&gt;
&lt;span class=&quot;code-object&quot;&gt;Number&lt;/span&gt; foo() {
  &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;.valueOf(1)
}
@CompileStatic
&lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt; bar() {
  &lt;span class=&quot;code-comment&quot;&gt;// Cannot assign value of type &lt;span class=&quot;code-object&quot;&gt;Number&lt;/span&gt; to variable of type &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;:
&lt;/span&gt;  &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt; result = foo()
  result
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="16808751" author="emilles" created="Wed, 3 Apr 2019 14:05:51 +0000"  >&lt;p&gt;In order to preserve the type checking of assignments, I think it best to make some kind of change after &lt;tt&gt;typeCheckAssignment&lt;/tt&gt; in &lt;tt&gt;StaticTypeCheckingVisitor.visitBinaryExpression&lt;/tt&gt;, instead of suggested changes to &lt;tt&gt;getResultType&lt;/tt&gt;.  Here is the current code for handling assignments:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!isEmptyDeclaration &amp;amp;&amp;amp; isAssignment(op)) {
                &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (rightExpression &lt;span class=&quot;code-keyword&quot;&gt;instanceof&lt;/span&gt; ConstructorCallExpression) {
                    inferDiamondType((ConstructorCallExpression) rightExpression, lType);
                }

                ClassNode originType = getOriginalDeclarationType(leftExpression);
                typeCheckAssignment(expression, leftExpression, originType, rightExpression, resultType);
                &lt;span class=&quot;code-comment&quot;&gt;// &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; assignment succeeds but result type is not a subtype of original type, then we are in a special &lt;span class=&quot;code-keyword&quot;&gt;cast&lt;/span&gt; handling
&lt;/span&gt;                &lt;span class=&quot;code-comment&quot;&gt;// and we must update the result type
&lt;/span&gt;                &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!implementsInterfaceOrIsSubclassOf(getWrapper(resultType), getWrapper(originType))) {
                    resultType = originType;
                } &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (lType.isUsingGenerics() &amp;amp;&amp;amp; !lType.isEnum() &amp;amp;&amp;amp; hasRHSIncompleteGenericTypeInfo(resultType)) {
                    &lt;span class=&quot;code-comment&quot;&gt;// &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; example, LHS is List&amp;lt;ConcreteClass&amp;gt; and RHS is List&amp;lt;T&amp;gt; where T is a placeholder
&lt;/span&gt;                    resultType = lType;
                }

                &lt;span class=&quot;code-comment&quot;&gt;// make sure we keep primitive types
&lt;/span&gt;                &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (isPrimitiveType(originType) &amp;amp;&amp;amp; resultType.equals(getWrapper(originType))) {
                    resultType = originType;
                }

                &lt;span class=&quot;code-comment&quot;&gt;// &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; we are in an &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;/&lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; branch, keep track of assignment
&lt;/span&gt;                &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (typeCheckingContext.ifElseForWhileAssignmentTracker != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; leftExpression &lt;span class=&quot;code-keyword&quot;&gt;instanceof&lt;/span&gt; VariableExpression
                        &amp;amp;&amp;amp; !isNullConstant(rightExpression)) {
                    Variable accessedVariable = ((VariableExpression) leftExpression).getAccessedVariable();
                    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (accessedVariable &lt;span class=&quot;code-keyword&quot;&gt;instanceof&lt;/span&gt; Parameter) {
                        accessedVariable = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ParameterVariableExpression((Parameter) accessedVariable);
                    }
                    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (accessedVariable &lt;span class=&quot;code-keyword&quot;&gt;instanceof&lt;/span&gt; VariableExpression) {
                        VariableExpression &lt;span class=&quot;code-keyword&quot;&gt;var&lt;/span&gt; = (VariableExpression) accessedVariable;
                        List&amp;lt;ClassNode&amp;gt; types = typeCheckingContext.ifElseForWhileAssignmentTracker.get(&lt;span class=&quot;code-keyword&quot;&gt;var&lt;/span&gt;);
                        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (types == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) {
                            types = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; LinkedList&amp;lt;ClassNode&amp;gt;();
                            ClassNode type = &lt;span class=&quot;code-keyword&quot;&gt;var&lt;/span&gt;.getNodeMetaData(StaticTypesMarker.INFERRED_TYPE);
                            types.add(type);
                            typeCheckingContext.ifElseForWhileAssignmentTracker.put(&lt;span class=&quot;code-keyword&quot;&gt;var&lt;/span&gt;, types);
                        }
                        types.add(resultType);
                    }
                }
                storeType(leftExpression, resultType);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;To preserve the declared type of a variable, another check should be added after typeCheckAssignment.  &lt;em&gt;Does it seem sensible that the inferred type of both the variable and the binary expression as a whole should be the declared type (that is &lt;tt&gt;Type&lt;/tt&gt; in &lt;tt&gt;Type var = value&lt;/tt&gt; and not whatever &lt;tt&gt;value&lt;/tt&gt; infers to)?&lt;/em&gt;  If yes, &lt;tt&gt;resultType&lt;/tt&gt; needs to be set to &lt;tt&gt;originType&lt;/tt&gt; or &lt;tt&gt;lType&lt;/tt&gt; under some new condition.&lt;/p&gt;</comment>
                            <comment id="16808788" author="emilles" created="Wed, 3 Apr 2019 14:41:03 +0000"  >&lt;p&gt;This is what I am trying out:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
                ClassNode originType = getOriginalDeclarationType(leftExpression);
                typeCheckAssignment(expression, leftExpression, originType, rightExpression, resultType);
                &lt;span class=&quot;code-comment&quot;&gt;// &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; assignment succeeds but result type is not a subtype of original type, then we are in a special &lt;span class=&quot;code-keyword&quot;&gt;cast&lt;/span&gt; handling and we must update the result type
&lt;/span&gt;                &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;code-comment&quot;&gt;/*GRECLIPSE add*/&lt;/span&gt;(leftExpression &lt;span class=&quot;code-keyword&quot;&gt;instanceof&lt;/span&gt; VariableExpression &amp;amp;&amp;amp; !((VariableExpression) leftExpression).isDynamicTyped()) ||&lt;span class=&quot;code-comment&quot;&gt;/*GRECLIPSE end*/&lt;/span&gt;!implementsInterfaceOrIsSubclassOf(getWrapper(resultType), getWrapper(originType))) {
                    resultType = originType;
                } &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!lType.isEnum() &amp;amp;&amp;amp; lType.isUsingGenerics() &amp;amp;&amp;amp; hasRHSIncompleteGenericTypeInfo(resultType)) {
                    &lt;span class=&quot;code-comment&quot;&gt;// &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; example, LHS is List&amp;lt;ConcreteClass&amp;gt; and RHS is List&amp;lt;T&amp;gt; where T is a placeholder
&lt;/span&gt;                    resultType = lType;
                }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It covers the reported case, but does not handle assignments to properties, like &lt;tt&gt;foo.bar = value&lt;/tt&gt;.  A check for &lt;tt&gt;leftExpression instanceof PropertyExpression&lt;/tt&gt; could be added in front of the variable expression check.  Not sure if either of these two changes has any impact on chained assignments like &lt;tt&gt;baz = foo.bar = value&lt;/tt&gt;.&lt;/p&gt;</comment>
                            <comment id="16808810" author="emilles" created="Wed, 3 Apr 2019 15:04:26 +0000"  >&lt;p&gt;In case of nested assignments like &lt;tt&gt;foo = bar = baz&lt;/tt&gt; and &lt;tt&gt;foo(bar = baz)&lt;/tt&gt;, the binary expression should continue to infer to the type of the RHS.  So the above change does not work.  I&apos;m going to attempt a guard around &lt;tt&gt;storeType(leftExpression, resultType);&lt;/tt&gt;, which should only impact the inferred type of the variable or property.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Please note the change suggested in the first comment should be enough to handle the exact issue stated by the original submitter.  Everything after has been for a slightly altered case where declared variable and assigned value types do not exactly align, for example if the method &lt;tt&gt;bar&lt;/tt&gt; in the original post returned &lt;tt&gt;List&lt;/tt&gt; and not &lt;tt&gt;List&amp;lt;Object[]&amp;gt;&lt;/tt&gt;.&lt;/b&gt;&lt;/p&gt;</comment>
                            <comment id="16810894" author="blackdrag" created="Fri, 5 Apr 2019 14:40:29 +0000"  >&lt;p&gt;Don&apos;t your suggested changes break flow typing?&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
                        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (inferredType.getComponentType().equals(originType)) {
                            inferredType = originType;
                        }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;What happens if you make your change with !isDynamicTyped here? because row starts with Object, that is returning true, the condition does then not apply and we basically skip this line where we the inferredType to the originType. What I do not understand right now is... why is it there in the first place? Why should I ever involve the originType here? Looks to me like a fix gone wrong.&lt;/p&gt;</comment>
                            <comment id="16810895" author="blackdrag" created="Fri, 5 Apr 2019 14:42:18 +0000"  >&lt;p&gt;a general comment about isDynamicTyped(). I think all uses of that method should be removed. It is a left-over from pre-Groovy1 and was supposed to be used only if the type is Object anyway. What is there now does no longer make sense since we are now using the metadata stuff.&lt;/p&gt;</comment>
                            <comment id="16810904" author="emilles" created="Fri, 5 Apr 2019 14:50:43 +0000"  >&lt;p&gt;I tried to make the minimal change since I do not have groovy core downloaded to run the tests.  The &lt;tt&gt;if (lastArg &amp;amp;&amp;amp; inferredType.isArray())&lt;/tt&gt; seems to have something to do with vargs handling.  I&apos;m not sure its exact purpose without some examples.&lt;/p&gt;

&lt;p&gt;In the case of this bug, &lt;tt&gt;originType&lt;/tt&gt; is &lt;tt&gt;Object&lt;/tt&gt; and &lt;tt&gt;inferredType&lt;/tt&gt; is &lt;tt&gt;Object[]&lt;/tt&gt;.  We want to keep it as &lt;tt&gt;Object[]&lt;/tt&gt; since that is the element type of the collection being iterated over.  All I can say with confidence is that this block is where the incorrect inference type is being set.&lt;/p&gt;</comment>
                            <comment id="16832417" author="paulk" created="Fri, 3 May 2019 10:36:05 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=emilles&quot; class=&quot;user-hover&quot; rel=&quot;emilles&quot;&gt;emilles&lt;/a&gt; I think &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=blackdrag&quot; class=&quot;user-hover&quot; rel=&quot;blackdrag&quot;&gt;blackdrag&lt;/a&gt; is correct here and that the whole if statement should be deleted rather than augmented with your proposed change. I suspect that the if statement was needed at some point but became obsolete when some other parts of the type checker were improved and handled the case it was trying to deal with. Certainly the tests committed along with that if statement and the one here (and the whole test suite) all pass with the if statement removed. I&apos;ll create a PR.&lt;/p&gt;</comment>
                            <comment id="16832995" author="paulk" created="Sat, 4 May 2019 05:20:10 +0000"  >&lt;p&gt;Proposed PR merged.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            6 years, 28 weeks, 3 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|z015yg:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </customfields>
    </item>
</channel>
</rss>