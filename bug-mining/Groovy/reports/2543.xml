<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Wed Nov 12 00:40:10 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[GROOVY-6692] trait&apos;s groovyProxy class doesn&apos;t dispatch String#toString()</title>
                <link>https://issues.apache.org/jira/browse/GROOVY-6692</link>
                <project id="12318123" key="GROOVY">Groovy</project>
                    <description>&lt;p&gt;following code(attached):&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;DynamicTraitTest &lt;span class=&quot;code-keyword&quot;&gt;extends&lt;/span&gt; GroovyTestCase {
  @groovy.transform.TypeChecked
  void testTraitTest() {
      def x = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;(&lt;span class=&quot;code-quote&quot;&gt;&quot;hello&quot;&lt;/span&gt;) as Helloable
      x.hello()
      &lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; !(x &lt;span class=&quot;code-keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;)
      &lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; x.toUpperCase() == &lt;span class=&quot;code-quote&quot;&gt;&quot;HELLO&quot;&lt;/span&gt; &lt;span class=&quot;code-comment&quot;&gt;// exptected
&lt;/span&gt;      &lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; x.toString() == &lt;span class=&quot;code-quote&quot;&gt;&quot;hello&quot;&lt;/span&gt; &lt;span class=&quot;code-comment&quot;&gt;// fails
&lt;/span&gt;  }
}

trait Helloable {
    void hello() { println &lt;span class=&quot;code-quote&quot;&gt;&quot;hello&quot;&lt;/span&gt; }
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;generate following exception:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;% groovy dynamictrait.groovy&lt;br/&gt;
 groovy dynamictrait.groovy&lt;br/&gt;
 .hello&lt;br/&gt;
 E&lt;br/&gt;
 Time: 0.13&lt;br/&gt;
 There was 1 error:&lt;br/&gt;
 1) testTraitTest(DynamicTraitTest)Assertion failed: &lt;/p&gt;

&lt;p&gt; assert x.toString() == &quot;hello&quot; // fails&lt;br/&gt;
\        | |          |&lt;br/&gt;
\        | |          false&lt;br/&gt;
\        | String1_groovyProxy@24269709&lt;br/&gt;
\        String1_groovyProxy@24269709&lt;/p&gt;

&lt;p&gt;     at org.codehaus.groovy.runtime.InvokerHelper.assertFailed(InvokerHelper.java:398)&lt;br/&gt;
     at org.codehaus.groovy.runtime.ScriptBytecodeAdapter.assertFailed(ScriptBytecodeAdapter.java:646)&lt;br/&gt;
     at DynamicTraitTest.testTraitTest(dynamictrait.groovy:8)&lt;br/&gt;
     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&lt;br/&gt;
     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)&lt;br/&gt;
     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)&lt;br/&gt;
     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&lt;br/&gt;
     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)&lt;br/&gt;
     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)&lt;br/&gt;
     at org.codehaus.groovy.reflection.CachedMethod.invoke(CachedMethod.java:90)&lt;br/&gt;
     at groovy.lang.MetaMethod.doMethodInvoke(MetaMethod.java:233)&lt;br/&gt;
     at groovy.lang.MetaClassImpl.invokeStaticMethod(MetaClassImpl.java:1318)&lt;br/&gt;
     at org.codehaus.groovy.runtime.InvokerHelper.invokeStaticMethod(InvokerHelper.java:927)&lt;br/&gt;
     at org.codehaus.groovy.runtime.InvokerHelper.invokeStaticMethod(InvokerHelper.java:77)&lt;br/&gt;
     at groovy.lang.GroovyShell.runJUnit3Test(GroovyShell.java:353)&lt;br/&gt;
     at groovy.lang.GroovyShell.runScriptOrMainOrTestOrRunnable(GroovyShell.java:273)&lt;br/&gt;
     at groovy.lang.GroovyShell.run(GroovyShell.java:502)&lt;br/&gt;
     at groovy.lang.GroovyShell.run(GroovyShell.java:491)&lt;br/&gt;
     at groovy.ui.GroovyMain.processOnce(GroovyMain.java:627)&lt;br/&gt;
     at groovy.ui.GroovyMain.run(GroovyMain.java:379)&lt;br/&gt;
     at groovy.ui.GroovyMain.process(GroovyMain.java:365)&lt;br/&gt;
     at groovy.ui.GroovyMain.processArgs(GroovyMain.java:124)&lt;br/&gt;
     at groovy.ui.GroovyMain.main(GroovyMain.java:104)&lt;br/&gt;
     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&lt;br/&gt;
     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)&lt;br/&gt;
     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)&lt;br/&gt;
     at org.codehaus.groovy.tools.GroovyStarter.rootLoader(GroovyStarter.java:106)&lt;br/&gt;
     at org.codehaus.groovy.tools.GroovyStarter.main(GroovyStarter.java:128)&lt;/p&gt;

&lt;p&gt; FAILURES!!!&lt;br/&gt;
 Tests run: 1,  Failures: 0,  Errors: 1&lt;/p&gt;&lt;/blockquote&gt;


&lt;p&gt;I don&apos;t know precise behavior of above case, but metaClass.mixin works with this code:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;DynamicMixinTest &lt;span class=&quot;code-keyword&quot;&gt;extends&lt;/span&gt; GroovyTestCase {
  void testTraitTest() {
      &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;.metaClass.mixin Helloable
      def x = &lt;span class=&quot;code-quote&quot;&gt;&quot;hello&quot;&lt;/span&gt;.asType(Helloable)
      x.hello()
      &lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; !(x &lt;span class=&quot;code-keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;)
      &lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; x.toUpperCase() == &lt;span class=&quot;code-quote&quot;&gt;&quot;HELLO&quot;&lt;/span&gt; &lt;span class=&quot;code-comment&quot;&gt;// exptected
&lt;/span&gt;      &lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; x.toString() == &lt;span class=&quot;code-quote&quot;&gt;&quot;hello&quot;&lt;/span&gt; &lt;span class=&quot;code-comment&quot;&gt;// fails
&lt;/span&gt;  }
}

&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;Helloable {
    void hello() { println &lt;span class=&quot;code-quote&quot;&gt;&quot;hello&quot;&lt;/span&gt; }
}

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</description>
                <environment>% groovy -v&lt;br/&gt;
Groovy Version: 2.2.0-rc-3 JVM: 1.8.0 Vendor: Oracle Corporation OS: Mac OS X&lt;br/&gt;
% java -version&lt;br/&gt;
java version &amp;quot;1.8.0&amp;quot;&lt;br/&gt;
Java(TM) SE Runtime Environment (build 1.8.0-b132)&lt;br/&gt;
Java HotSpot(TM) 64-Bit Server VM (build 25.0-b70, mixed mode)</environment>
        <key id="12818296">GROOVY-6692</key>
            <summary>trait&apos;s groovyProxy class doesn&apos;t dispatch String#toString()</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="melix">C&#233;dric Champeau</assignee>
                                    <reporter username="uehaj">UEHARA Junji</reporter>
                        <labels>
                    </labels>
                <created>Thu, 10 Apr 2014 01:35:53 +0000</created>
                <updated>Thu, 24 Apr 2014 19:00:10 +0000</updated>
                            <resolved>Wed, 16 Apr 2014 06:59:40 +0000</resolved>
                                    <version>2.3.0-beta-1</version>
                                    <fixVersion>2.3.0-rc-1</fixVersion>
                                    <component>Compiler</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>2</watches>
                                                                                                                <comments>
                            <comment id="14475715" author="melix" created="Thu, 10 Apr 2014 02:50:37 +0000"  >&lt;p&gt;I&apos;m not sure it should be considered as a bug actually. What do others think? Should a proxy delegate the Object methods to the delegate?&lt;/p&gt;</comment>
                            <comment id="14475674" author="uehaj" created="Sat, 12 Apr 2014 02:36:51 +0000"  >&lt;p&gt;I have small question about specification of trait.&lt;/p&gt;

&lt;p&gt;Follwing code is based on a sample from &lt;a href=&quot;http://beta.groovy-lang.org/docs/groovy-2.3.0-SNAPSHOT/html/documentation/core-traits.html#_runtime_implementation_of_traits&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;html/documentation/core-traits.html&lt;/a&gt;.&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;trait Extra {
    &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; extra() { &lt;span class=&quot;code-quote&quot;&gt;&quot;I&apos;m an extra method&quot;&lt;/span&gt; }            
}
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;Something {                                       
    &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; doSomething() { &lt;span class=&quot;code-quote&quot;&gt;&apos;Something&apos;&lt;/span&gt; }                
}
&lt;span class=&quot;code-comment&quot;&gt;// @groovy.transform.TypeChecked
&lt;/span&gt;def foo() {
  def s = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Something() as Extra
  s.extra()
  s.doSomething()  &lt;span class=&quot;code-comment&quot;&gt;// (1) [Static type checking] - Cannot find matching method Extra#doSomething(). Please check &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; the declared type is right and &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; the method exists.
&lt;/span&gt;}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;(1) is stc error(definitly you know).&lt;br/&gt;
We can avoid this with follwing workaround.&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;trait Extra {
    &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; extra() { &lt;span class=&quot;code-quote&quot;&gt;&quot;I&apos;m an extra method&quot;&lt;/span&gt; }            
}
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;Something {                                       
    &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; doSomething() { &lt;span class=&quot;code-quote&quot;&gt;&apos;Something&apos;&lt;/span&gt; }                
}
@groovy.transform.TypeChecked
def foo() {
  Something orig = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Something()
  def s = orig as Extra
  s.extra()
  orig.doSomething() &lt;span class=&quot;code-comment&quot;&gt;// OK
&lt;/span&gt;}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;But if so what is the raison d&apos;etre of dispatching method like doSomething() to base object?&lt;br/&gt;
At least, in current trait specification, to mimic original object with proxy class looks not clear.&lt;br/&gt;
It looks incomplete because:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;(1) the proxy is not &apos;instanceof&apos; of proxy target class(as mentioned in the Groovy trait spec)&lt;/li&gt;
	&lt;li&gt;(2) the proxy is not DGM complient (&lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-6695&quot; title=&quot;trait&amp;#39;s groovyProxy is not DGM compatible&quot; class=&quot;issue-link&quot; data-issue-key=&quot;GROOVY-6695&quot;&gt;&lt;del&gt;GROOVY-6695&lt;/del&gt;&lt;/a&gt;)&lt;/li&gt;
	&lt;li&gt;(3) method call to Object method(or any method which defined on parent class?) is not works expectedly(this &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-6692&quot; title=&quot;trait&amp;#39;s groovyProxy class doesn&amp;#39;t dispatch String#toString()&quot; class=&quot;issue-link&quot; data-issue-key=&quot;GROOVY-6692&quot;&gt;&lt;del&gt;GROOVY-6692&lt;/del&gt;&lt;/a&gt;)&lt;/li&gt;
	&lt;li&gt;(4) call to original method is not STC safe(above example)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;If so, it might be better to remove dispatching method?&lt;br/&gt;
If you want to use proxy target object, you can use it directly(like above workaround).&lt;/p&gt;

&lt;p&gt;Probably you know, as contrasted with grooty&apos;s trait, Scala&apos;s runtime trait instantiation is:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;trait Extra {
    def extra():&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; = &lt;span class=&quot;code-quote&quot;&gt;&quot;I&apos;m an extra method&quot;&lt;/span&gt;
}
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;Something {                                       
    def doSomething():&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; = &lt;span class=&quot;code-quote&quot;&gt;&quot;Something&quot;&lt;/span&gt;
}

val s = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Something() with Extra
&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt;(s.extra() == &lt;span class=&quot;code-quote&quot;&gt;&quot;I&apos;m an extra method&quot;&lt;/span&gt;)
&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt;(s.doSomething() == &lt;span class=&quot;code-quote&quot;&gt;&quot;Something&quot;&lt;/span&gt;)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Of course this is not &quot;decorate&quot; an existing object like groovy&apos;s&lt;br/&gt;
trait, but object instaciation variant(this is a syntax sugar of&lt;br/&gt;
static class definition which which mixins trait(s)). But in this&lt;br/&gt;
scala code, about variable s:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;(1) s is &apos;instanceof&apos; of Something&lt;/li&gt;
	&lt;li&gt;(3) method call to Object method works expectedly&lt;/li&gt;
	&lt;li&gt;(4) typesafe&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;I&apos;d like to propose another new feature request, I hope if available the way to instanciate new object which &apos;implements&apos; trait(s) like:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt; ... = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Something() withTrait Extra;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is syntax suger of:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; class $SubClassOf_Something &lt;span class=&quot;code-keyword&quot;&gt;extends&lt;/span&gt; Something &lt;span class=&quot;code-keyword&quot;&gt;implements&lt;/span&gt; Extra {}
  ...
 ... = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; $SubClassOf_Something()
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;(in above code, &apos;withTrait&apos; is not method. it should be new keyword or probably &quot;implements&quot; is can be used for this purpose).&lt;br/&gt;
This is same as Scala&apos;s:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt; ... = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Something() with Extra;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If you already considered, i&apos;m happy if you tell me why you did not choose this approach.&lt;/p&gt;</comment>
                            <comment id="14475734" author="uehaj" created="Sat, 12 Apr 2014 03:43:24 +0000"  >&lt;p&gt;The work around which I mentioned above comment which uses original object variable is hard to use if you have to pass the decorator proxy object to another method as a parameter.&lt;/p&gt;

&lt;p&gt;I think if there is a way to get proxy target object from proxy object, most of problem might be solved.&lt;/p&gt;

&lt;p&gt;For example, make proxy object to have a method named getProxyTarget()which returns &quot;original coerced object&quot;, so you can write like:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;trait Extra {
    &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; extra() { &lt;span class=&quot;code-quote&quot;&gt;&quot;I&apos;m an extra method&quot;&lt;/span&gt; }            
}
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;Something {                                       
    &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; doSomething() { &lt;span class=&quot;code-quote&quot;&gt;&apos;Something&apos;&lt;/span&gt; }                
}
@groovy.transform.TypeChecked
def foo() {
  def s = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Something() as Extra
  s.extra()
  ((Something)s.getProxyTarget()).doSomething()
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;of course proxy object base class have Object getProxyTarget() method. I think any trait definition implicitly have to have Object getProxyTarget() method.&lt;/p&gt;

&lt;p&gt;or asType(TargetClass) is more elegant?&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;trait Extra {
    &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; extra() { &lt;span class=&quot;code-quote&quot;&gt;&quot;I&apos;m an extra method&quot;&lt;/span&gt; }            
}
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;Something {                                       
    &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; doSomething() { &lt;span class=&quot;code-quote&quot;&gt;&apos;Something&apos;&lt;/span&gt; }                
}
@groovy.transform.TypeChecked
def foo() {
  def s = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Something() as Extra
  s.extra()
  (s as Something).doSomething()
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;how about this?&lt;/p&gt;</comment>
                            <comment id="14475632" author="melix" created="Sat, 12 Apr 2014 11:48:54 +0000"  >&lt;p&gt;I will comment on your proposal (which makes sense) later, but just to be clear: Scala doesn&apos;t have &quot;runtime&quot; traits like &lt;tt&gt;withTraits&lt;/tt&gt;. It&apos;s a shorthand notation for an anonymous inner class, which is very different. For example, you can&apos;t write : &lt;tt&gt;val foo = bar with Baz&lt;/tt&gt;. The equivalent in Groovy would be to create an inner class. The &lt;tt&gt;withTraits&lt;/tt&gt; method really allows decorating an object with some traits at runtime, which gives a different perspective.&lt;/p&gt;</comment>
                            <comment id="14475699" author="melix" created="Sat, 12 Apr 2014 12:00:40 +0000"  >&lt;p&gt;Also what you describe is not different from &lt;b&gt;any&lt;/b&gt; proxy generated by Groovy, using the &lt;tt&gt;as&lt;/tt&gt; keyword. The trait implementation just follows this behavior. The reason we can&apos;t make a special handling for &lt;tt&gt;toString&lt;/tt&gt;, for example, is that &lt;tt&gt;toString&lt;/tt&gt; is not the only method which causes problem: what about &lt;tt&gt;equals&lt;/tt&gt; and &lt;tt&gt;hashCode&lt;/tt&gt;. If &lt;tt&gt;equals&lt;/tt&gt; is implemented in the target object &lt;b&gt;and&lt;/b&gt; that the proxy delegates to it, then a proxy would be &lt;b&gt;equal to&lt;/b&gt; the target object. This breaks the contract of &lt;tt&gt;equals&lt;/tt&gt;.&lt;/p&gt;</comment>
                            <comment id="14475759" author="melix" created="Sat, 12 Apr 2014 12:10:47 +0000"  >&lt;p&gt;So regarding the &lt;tt&gt;getProxyTarget&lt;/tt&gt; method, I think it&apos;s an interesting idea. It should be doable and compatible with type checking. It also has the advantage of working with the traditional proxies. Just to make my previous comment more explicit, try this in a groovy console:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;Foo {
    void foo() { println &lt;span class=&quot;code-quote&quot;&gt;&quot;Foooooo&quot;&lt;/span&gt; }
    &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; toString() { &lt;span class=&quot;code-quote&quot;&gt;&apos;FOO&apos;&lt;/span&gt; }
}
&lt;span class=&quot;code-keyword&quot;&gt;interface&lt;/span&gt; Bar {}
def f = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Foo()
println f
def b = f as Bar
println b
b.foo()
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now, it doesn&apos;t make sense that a &lt;b&gt;trait&lt;/b&gt; implements this, because &lt;b&gt;only&lt;/b&gt; runtime traits are using a proxy. If you implement a trait normally, there&apos;s no such thing as a proxy target, so this would really be for runtime generated proxies.&lt;/p&gt;</comment>
                            <comment id="14475752" author="uehaj" created="Sat, 12 Apr 2014 19:47:24 +0000"  >&lt;p&gt;Thank you for clarification and background information.&lt;/p&gt;

&lt;p&gt;I completely understand that Scala&apos;s new .. with syntax should not be called &lt;b&gt;runtime&lt;/b&gt; trait instantiation. It&apos;s my misunderstanding.&lt;/p&gt;

&lt;p&gt;And I know now the new Groovy&apos;s &quot;runtime implementation of traits&quot; is based on the traditional Groovy feature of runtime implementation interface with coercing. As just interest, Is there a way of runtime multiple interface implementing syntax?&lt;/p&gt;

&lt;p&gt;So I&apos;d like to drop my proposal about &quot; it might be better to remove dispatching method&quot;.&lt;br/&gt;
Introducing Scala like &quot;new..with&quot; syntax to groovy could make sense but I have no actual use case or special needs so I would like to drop it also &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;I see also the needs of distinct between the result of &quot;runtime implementation of trait&quot; and &quot;statically normally trait implementing class&apos;s instance&quot;. You mean on point to consider is where is the best place defining the method.&lt;/p&gt;

&lt;p&gt;I have enough knowledge so as just one my idea, how about &quot;runtime implementation of trait&quot; do implement another trait like &quot;RuntimeTrait&quot; implicitly?&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;trait RuntimeTrait {
   &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; asType(&lt;span class=&quot;code-object&quot;&gt;Class&lt;/span&gt; clazz) {
      &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (clazz.isInstanceof(getProxyTarget())) {
         &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; getProxyTarget();
      }
      &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; {
         &lt;span class=&quot;code-comment&quot;&gt;// Cannnot Cast Exception
&lt;/span&gt;      }
   }
   &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; getProxyTarget() {
       &lt;span class=&quot;code-comment&quot;&gt;// NO IDEA how implement &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;!!
&lt;/span&gt;   }
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;best regards,&lt;/p&gt;</comment>
                            <comment id="14475760" author="melix" created="Mon, 14 Apr 2014 11:27:25 +0000"  >&lt;p&gt;I am in favor of adding &lt;tt&gt;getProxyTarget&lt;/tt&gt;. My idea is to make the proxy implement the following interface:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;/**
 * An &lt;span class=&quot;code-keyword&quot;&gt;interface&lt;/span&gt; implemented by some Groovy proxies which gives access to the proxied object. In particular, dynamically
 * generated proxies that implement traits will implement &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;interface&lt;/span&gt; in order to give access to the proxied
 * instance.
 *
 * @author Cedric Champeau
 * @since 2.3.0
 */
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;interface&lt;/span&gt; GeneratedGroovyProxy {
    /**
     * @&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; the proxy target.
     */
    &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; getProxyTarget();
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I have a working implementation here. Now, I am not 100% convinced &lt;tt&gt;asType&lt;/tt&gt; is necessary, because of one reason: the result of the &lt;tt&gt;asType&lt;/tt&gt; operation as you suggest here may return the proxy object &lt;b&gt;or&lt;/b&gt; fail. There&apos;s actually no reason to fail, as the target class may be another interface or trait. If it doesn&apos;t fail, then it would mean that sometimes, &lt;tt&gt;asType&lt;/tt&gt; returns a decorated object, sometimes not. For that reason, I would give a -1.&lt;/p&gt;</comment>
                            <comment id="14475684" author="uehaj" created="Mon, 14 Apr 2014 20:19:01 +0000"  >&lt;p&gt;Thank you for response.&lt;/p&gt;

&lt;p&gt;The reasons I prefer asType is, &lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;(1) concise code under @TypeChecked
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;@groovy.transform.TypeChecked
def foo() {
    def y = &lt;span class=&quot;code-quote&quot;&gt;&quot;abc&quot;&lt;/span&gt; as SomeTrait
    println (((&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;)y.getProxyTarget()).toUpperCase()) &lt;span class=&quot;code-comment&quot;&gt;// emits &lt;span class=&quot;code-quote&quot;&gt;&quot;ABC&quot;&lt;/span&gt;
&lt;/span&gt;    println ((y as &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;).toUpperCase()) &lt;span class=&quot;code-comment&quot;&gt;// emits &lt;span class=&quot;code-quote&quot;&gt;&quot;ABC&quot;&lt;/span&gt;
&lt;/span&gt;}

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;(2) if you have only getProxyTarget, you have to do following separated two operations.
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;A) Get proxy target&lt;/li&gt;
		&lt;li&gt;B) Cast to required class&lt;br/&gt;
Under the TypeChecked context, B) is always needed so A) and B) is indivisible.&lt;br/&gt;
(Type inference is not possible in this situation I believe, isn&apos;t it)?&lt;br/&gt;
On the other hand, Under dynamic groovy, there might be a situation where B) is not needed.&lt;br/&gt;
But there is no big penalty. There should be no special reason to prevent to use coerce&lt;br/&gt;
Because you  already  use it to make runtime trait implement!&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
	&lt;li&gt;(3) It feels symmetric for me that use both it to convert to proxy and convert from proxy.&lt;br/&gt;
      But it may be only subjective feeling.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;So, IMHO, i faver &quot;asType&quot; solution(+1). And in addition, getProxyTarget() is not needed?&lt;/p&gt;</comment>
                            <comment id="14475664" author="uehaj" created="Mon, 14 Apr 2014 20:52:10 +0000"  >&lt;p&gt;&amp;gt; (Type inference is not possible in this situation I believe, isn&apos;t it)?&lt;/p&gt;

&lt;p&gt;It might be possible when you implement special handling of &quot;getProxyTarget()&quot;.&lt;br/&gt;
But already we have special handling on &quot;as&quot; syntax. the result of as operation&lt;br/&gt;
guaranteed to have type of specified class at compile time. So we groovy users&lt;br/&gt;
can use it without surprise.&lt;/p&gt;</comment>
                            <comment id="14475717" author="melix" created="Tue, 15 Apr 2014 01:32:12 +0000"  >&lt;p&gt;I understand your motivations. Really, the problem I have with &lt;tt&gt;asType&lt;/tt&gt; as suggested is that if you do &lt;tt&gt;asType&lt;/tt&gt; on the original type, it will return the proxied object, that is to say that you loose the decoration. You will have to handle that at some point:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;def a = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; A()
def decorated = a as SomeTrait
void method(SomeTrait x) {
   def a = x as A
   a.methodFromTrait() &lt;span class=&quot;code-comment&quot;&gt;// fail
&lt;/span&gt;}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="14475729" author="uehaj" created="Tue, 15 Apr 2014 02:08:28 +0000"  >&lt;p&gt;Could you let me clarify the problem you mentioned.&lt;br/&gt;
In following code,&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;A {
    &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; asType(&lt;span class=&quot;code-object&quot;&gt;Class&lt;/span&gt; clazz) { &lt;span class=&quot;code-comment&quot;&gt;// (1)
&lt;/span&gt;        .................
    }
    void methodOfOriginalA() {
        println &lt;span class=&quot;code-quote&quot;&gt;&quot;methodOfOriginalA&quot;&lt;/span&gt;
    }
}

trait SomeTrait {
    void methodFromTrait() {
        println &lt;span class=&quot;code-quote&quot;&gt;&quot;methodFromTrait&quot;&lt;/span&gt;
    }
    &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; asType(&lt;span class=&quot;code-object&quot;&gt;Class&lt;/span&gt; clazz) {
        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; A()
    }
}

a = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; A()
decorated = a as SomeTrait  &lt;span class=&quot;code-comment&quot;&gt;// (2)
&lt;/span&gt;void method(SomeTrait x) {
    x.methodFromTrait()
    def a = x as A &lt;span class=&quot;code-comment&quot;&gt;// (3)
&lt;/span&gt;    a.methodOfOriginalA()
}

method(decorated)

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;If you define asType at (1), decorated class can&apos;t be cast back to original proxy target from proxied object at (3) ?&lt;/p&gt;

&lt;p&gt;If this is the problem, I quite agree, but you cant try to (3) because you cant get the proxied object at (2) because (1) is called instead of get proxied object.&lt;br/&gt;
So this is actually safe if there is no other way to get proxied object.&lt;/p&gt;

&lt;p&gt;For example, proxy object which is emerged from withTrait() could be the case. Hmm.&lt;br/&gt;
or withTrait() calls asType() mechanism internally?&lt;/p&gt;</comment>
                            <comment id="14475737" author="uehaj" created="Tue, 15 Apr 2014 02:10:48 +0000"  >&lt;p&gt;Anyway, if trait can be used for the place the asType() is defined,&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;@ForceOrverride
&lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; asType() {
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Could override the original object&apos;s asType?&lt;/p&gt;</comment>
                            <comment id="14475761" author="melix" created="Tue, 15 Apr 2014 02:32:03 +0000"  >&lt;p&gt;Yes, implementing a trait that supports the conversion is one of my ideas. It would look like this:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;trait ProxyConvertible &lt;span class=&quot;code-keyword&quot;&gt;implements&lt;/span&gt; GeneratedGroovyProxy {
    @groovy.transform.ForceOverride
    &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; asType(&lt;span class=&quot;code-object&quot;&gt;Class&lt;/span&gt; target) {
        println &lt;span class=&quot;code-quote&quot;&gt;&quot;Converting to $target&quot;&lt;/span&gt;
        def proxy = getProxyInstance()
        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (target.isAssignableFrom(proxy.class)) {
            &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; proxy
        }
        DefaultGroovyMethods.asType(&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;, target)
    }
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Unfortunatly, in your example, we can&apos;t use &lt;tt&gt;asType&lt;/tt&gt;, because of Groovy internal coercion mechanisms. Even if you implement &lt;tt&gt;asType&lt;/tt&gt;, independently of traits I mean, on any class, and that the target type is &lt;tt&gt;String&lt;/tt&gt;, then it&apos;s &lt;tt&gt;toString&lt;/tt&gt; which is used internally, not your &lt;tt&gt;asType&lt;/tt&gt; implementation.&lt;/p&gt;</comment>
                            <comment id="14475665" author="melix" created="Tue, 15 Apr 2014 05:02:55 +0000"  >&lt;p&gt;The only thing I can think of right now would be a helper method like in this snippet (focus on &lt;tt&gt;getAsType&lt;/tt&gt;):&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; org.codehaus.groovy.transform.trait.Traits
trait Helloable &lt;span class=&quot;code-keyword&quot;&gt;implements&lt;/span&gt; CharSequence {
    void hello() { println &lt;span class=&quot;code-quote&quot;&gt;&quot;hello&quot;&lt;/span&gt; }
}
def str = &lt;span class=&quot;code-quote&quot;&gt;&quot;hello&quot;&lt;/span&gt;
def x = str as Helloable
x.hello()
&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; !(x &lt;span class=&quot;code-keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;)
&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; x &lt;span class=&quot;code-keyword&quot;&gt;instanceof&lt;/span&gt; Helloable
&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; x &lt;span class=&quot;code-keyword&quot;&gt;instanceof&lt;/span&gt; GeneratedGroovyProxy
&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; x.toUpperCase() == &lt;span class=&quot;code-quote&quot;&gt;&quot;HELLO&quot;&lt;/span&gt; &lt;span class=&quot;code-comment&quot;&gt;// expected
&lt;/span&gt;&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; x.proxyTarget.tr(&lt;span class=&quot;code-quote&quot;&gt;&apos;h&apos;&lt;/span&gt;,&lt;span class=&quot;code-quote&quot;&gt;&apos;*&apos;&lt;/span&gt;) == &lt;span class=&quot;code-quote&quot;&gt;&quot;*ello&quot;&lt;/span&gt;
def proxyTarget = x.proxyTarget
&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; proxyTarget.is(str)
def converted = Traits.getAsType(x,&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;)
&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; converted.is(str)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I have this working already. Again, think that what you are asking for is already a problem in Groovy with objects coerced to interfaces. The advantage of using &lt;tt&gt;Traits.getAsType&lt;/tt&gt; here is that we don&apos;t go through the regular &lt;tt&gt;as&lt;/tt&gt; coercion so we can bypass the fact that Groovy will handle the &lt;tt&gt;String&lt;/tt&gt; case separately. Also the name &lt;tt&gt;getAsType&lt;/tt&gt; is chosen so that you can add a static import without having a name clash with the traditional &lt;tt&gt;asType&lt;/tt&gt; method.&lt;/p&gt;</comment>
                            <comment id="14475776" author="uehaj" created="Tue, 15 Apr 2014 07:31:39 +0000"  >&lt;p&gt;Thank you for consideration.&lt;/p&gt;

&lt;p&gt;If the return type of &lt;tt&gt;Traits.getAsType()&lt;/tt&gt; is &lt;tt&gt;java.lang.Object&lt;/tt&gt;, the result of it has to be casted to String.&lt;br/&gt;
The reason I want to use asType() is I want to use &apos;as&apos;.&lt;br/&gt;
The reason I want to use &apos;as&apos; is I want to remove a cast for the return value from it.&lt;br/&gt;
The reasons I want to remove the cast are:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;(1) shorten the code under static groovy (@TypeChecked,@CompileStatic) because cast is removed&lt;/li&gt;
	&lt;li&gt;(2) If trait is &quot;compatible with static type checking/compilation&quot; so less cast is ideal.&lt;br/&gt;
      I imagine the reason why the closure parameter type inference wanted,&lt;br/&gt;
      it&apos;s because cast of &apos;it&quot; parameter is not only boiler plate, but also it makes a difference of dynamic groovy code.&lt;br/&gt;
      When we only add @TypeChecked, if I have to change the code to add a cast, Its not ideal.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;So if the getAsType returns Object type, there is no difference to getProxyTarget() so I think there is no need to implement it.&lt;/p&gt;

</comment>
                            <comment id="14475676" author="melix" created="Tue, 15 Apr 2014 07:36:38 +0000"  >&lt;p&gt;No, getAsType returns T:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; T getAsType(&lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; self, &lt;span class=&quot;code-object&quot;&gt;Class&lt;/span&gt;&amp;lt;T&amp;gt; clazz)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="14475718" author="uehaj" created="Tue, 15 Apr 2014 07:57:07 +0000"  >&lt;p&gt;Oh, I misunderstand if so it&apos;s looks pretty nice&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;br/&gt;
Is it possible following method?&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;interface&lt;/span&gt; GeneratedGroovyProxy {
    /**
     * @&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; the proxy target.
     */
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; T getProxyTargetAs(Calss&amp;lt;T&amp;gt; clazz);
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="14475730" author="melix" created="Tue, 15 Apr 2014 08:04:33 +0000"  >&lt;p&gt;It seems redundant, isn&apos;t it? To call it, you would need to know you have a &lt;tt&gt;GeneratedGroovyProxy&lt;/tt&gt;, whereas &lt;tt&gt;Traits.getAsType&lt;/tt&gt; doesn&apos;t make any assumption:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; T getAsType(&lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; self, &lt;span class=&quot;code-object&quot;&gt;Class&lt;/span&gt;&amp;lt;T&amp;gt; clazz) {
        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (self &lt;span class=&quot;code-keyword&quot;&gt;instanceof&lt;/span&gt; GeneratedGroovyProxy) {
            &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; proxyTarget = ((GeneratedGroovyProxy)self).getProxyTarget();
            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (clazz.isAssignableFrom(proxyTarget.getClass())) {
                &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; (T) proxyTarget;
            }
        }
        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; DefaultGroovyMethods.asType(self, clazz);
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="14475719" author="uehaj" created="Tue, 15 Apr 2014 09:31:36 +0000"  >&lt;p&gt;I probably misunderstand again.&lt;br/&gt;
Could you tell me the type signature of getProxyTarget()?&lt;br/&gt;
Is it like following?&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;interface&lt;/span&gt; GeneratedGroovyProxy {
    /**
     * @&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; the proxy target.
     */
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; T getProxyTarget();
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If so I really satisfied. This is enough and reasonable solution I think.&lt;/p&gt;

&lt;p&gt;If this is not the case,  the return type of getProxyTarget is java.lang.Object,&lt;br/&gt;
the point is difference between&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;def converted = Traits.getAsType(x,&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;) &lt;span class=&quot;code-comment&quot;&gt;// (1)&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;and&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;def converted = x.getProxyTargetAs(&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;) &lt;span class=&quot;code-comment&quot;&gt;// (2)&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I feel (2) is better because&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;(A) It looks like variation of getProxyTarget() and it is.&lt;/li&gt;
	&lt;li&gt;(B) no need of import  org.codehaus.groovy.transform.trait.Traits&lt;/li&gt;
	&lt;li&gt;(C) For the case of (1), the method has no meaning of solid &apos;asType&apos; anymore. At least It might be renamed something like &apos;static &amp;lt;T&amp;gt; T getProxyTargetAsType(Class&amp;lt;T&amp;gt; clazz)&apos;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;But I think it might just only my subjective feeling.&lt;/p&gt;</comment>
                            <comment id="14475755" author="melix" created="Tue, 15 Apr 2014 09:58:40 +0000"  >&lt;p&gt;No, &lt;tt&gt;getProxyTarget&lt;/tt&gt; can&apos;t be parametrized. It&apos;s:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;0bject getProxyTarget()
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The reason is that it&apos;s a runtime thing. You never know at compile time what will be the type of the proxied object. Take this example:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;SomeTrait doSomethingMagic(o) {
    o as SomeTrait &lt;span class=&quot;code-comment&quot;&gt;// proxy target is of type &lt;span class=&quot;code-quote&quot;&gt;&quot;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;&quot;&lt;/span&gt;, but not known statically
&lt;/span&gt;}
def doSomethingWithTrait(SomeTrait t) {
   t.proxyTarget &lt;span class=&quot;code-comment&quot;&gt;// &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; may fail, because not every trait is a proxy!
&lt;/span&gt;}
def converted = doSomethingMagic(&lt;span class=&quot;code-quote&quot;&gt;&apos;string&apos;&lt;/span&gt;) &lt;span class=&quot;code-comment&quot;&gt;// we only know that the &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; type is &lt;span class=&quot;code-quote&quot;&gt;&quot;SomeTrait&quot;&lt;/span&gt;, but could be either a Proxy or a regular trait
&lt;/span&gt;def other = doSomethingMagic(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Foo())

&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="14475790" author="melix" created="Tue, 15 Apr 2014 10:07:28 +0000"  >&lt;p&gt;BTW, all &lt;tt&gt;getProxyTargetAsType&lt;/tt&gt; would do would be delegating to &lt;tt&gt;Traits.getAsType&lt;/tt&gt;. Since we already have one method &lt;tt&gt;getProxyTarget&lt;/tt&gt; (which is necessary to get the proxy target), that would mean generating two methods instead of one, for the sake of avoiding an import. Is it really worth it? I&apos;m not convinced so far...&lt;/p&gt;</comment>
                            <comment id="14475731" author="uehaj" created="Tue, 15 Apr 2014 16:34:24 +0000"  >&lt;p&gt;I convinced. Yes you are right.&lt;/p&gt;

&lt;p&gt;(A) When following two methods (1) (2) are both exists:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;(1)Object GeneratedGroovyProxy#getProxyTarget()&lt;/li&gt;
	&lt;li&gt;(2)T GeneratedGroovyProxy#getProxyTargetAsType() or Trait#getProxyTargetAsType()&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Under static groovy, programmer&apos;s choices:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;get the target proxy by (1) and cast to original type&lt;/li&gt;
	&lt;li&gt;get the target proxy by (2), and don&apos;t cast&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;contrary,  under the dynamic groovy, you have one more choice.&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;get the target proxy by (1) and cast to original type&lt;/li&gt;
	&lt;li&gt;get the target proxy by (2), and don&apos;t cast&lt;/li&gt;
	&lt;li&gt;get the target proxy by (1), and don&apos;t cast&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;(B) if we have no (1), only have (2), choices are following:&lt;/p&gt;

&lt;p&gt;under static groovy:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;get the target proxy by (2), and don&apos;t cast&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;under dynamic groovy:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;get the target proxy by (2), and don&apos;t cast&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;(C) if we have only (1), no (2), choices are following:&lt;/p&gt;

&lt;p&gt;under static groovy:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;get the target proxy by (1) and cast to original type&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;under dynamic groovy:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;get the target proxy by (1) and cast to original type&lt;/li&gt;
	&lt;li&gt;get the target proxy by (1), and don&apos;t cast&lt;/li&gt;
&lt;/ul&gt;



&lt;p&gt;I thought (B) is better than (C) because of following reason.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;(2) If trait is &quot;compatible with static type checking/compilation&quot; so less cast is ideal.&lt;br/&gt;
I imagine the reason why the closure parameter type inference wanted,&lt;br/&gt;
it&apos;s because cast of &apos;it&quot; parameter is not only boiler plate, but also &lt;b&gt;it makes a difference of dynamic groovy code.&lt;/b&gt;&lt;br/&gt;
When we only add @TypeChecked, if I have to change the code to add a cast, Its not ideal.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;From point of view of this, getTargetProxy() should be hidden. But if it is impossible for the reason of implementation, (C) is better than (A).&lt;br/&gt;
If there is Traits.getAsType already,  for the reason of implementation,  we don&apos;t need to additionally implement GeneratedGroovyProxy#getProxyTargetAsType(). Because (2) is recommended to &lt;b&gt;don&apos;t use it&lt;/b&gt; from programmer.&lt;br/&gt;
(C) must be the real situation.&lt;/p&gt;

&lt;p&gt;thanks.&lt;/p&gt;</comment>
                            <comment id="14475720" author="melix" created="Wed, 16 Apr 2014 06:59:40 +0000"  >&lt;p&gt;Thanks for your comments, I have pushed it onto master. It should be available in the next build.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                            <attachment id="12722668" name="dynamictrait.groovy" size="367" author="uehaj" created="Thu, 10 Apr 2014 01:35:53 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>1.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            11 years, 31 weeks, 6 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i2c3xz:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </customfields>
    </item>
</channel>
</rss>