<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Wed Nov 12 00:24:20 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[GROOVY-5238] Methods belonging to a different source unit get visited and report errors at the wrong place</title>
                <link>https://issues.apache.org/jira/browse/GROOVY-5238</link>
                <project id="12318123" key="GROOVY">Groovy</project>
                    <description>&lt;p&gt;If a method call expression references a method from another class, the method called gets visited (if it is statically checked) even if the class doesn&apos;t belong to the same source unit. This triggers incorrect error reporting (errors in the wrong file).&lt;/p&gt;

&lt;p&gt;Fixing completely this requires a large amount of work, so return type inference will only work for methods in the same source unit at first.&lt;/p&gt;

&lt;p&gt;See TODO in StaticTypeCheckingVisitor.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12816074">GROOVY-5238</key>
            <summary>Methods belonging to a different source unit get visited and report errors at the wrong place</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="melix">C&#233;dric Champeau</assignee>
                                    <reporter username="melix">C&#233;dric Champeau</reporter>
                        <labels>
                    </labels>
                <created>Fri, 6 Jan 2012 06:02:32 +0000</created>
                <updated>Sun, 13 May 2012 03:30:04 +0000</updated>
                            <resolved>Fri, 6 Jan 2012 08:13:47 +0000</resolved>
                                    <version>2.0-beta-2</version>
                                    <fixVersion>2.0-beta-3</fixVersion>
                                    <component>Static Type Checker</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                                                                <comments>
                            <comment id="14472285" author="melix" created="Fri, 6 Jan 2012 08:13:47 +0000"  >&lt;p&gt;Partially resolved, see &lt;a href=&quot;https://github.com/groovy/groovy-core/commit/455b8a10b1790a53f8f6b0c9ba808769c885302c&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/groovy/groovy-core/commit/455b8a10b1790a53f8f6b0c9ba808769c885302c&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Especially the TODO. Copy of a discussion by mail:&lt;/p&gt;


&lt;p&gt;The general problem to be solved is that one:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;@AnnotationTriggeringTypeChecking
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;A {
   def foo() { ... b.bar() ... }
}
@AnotherAnnotationTriggeringTypeChecking
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;B {
   def bar() { ... a.foo() ...}
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;In most situations, both annotations will either be &lt;tt&gt;@TypeChecked&lt;/tt&gt; or &lt;tt&gt;@CompileStatic&lt;/tt&gt;, but you can have a mix, or custom annotations (including &lt;tt&gt;@TypeChecked&lt;/tt&gt; or &lt;tt&gt;@CompileStatic&lt;/tt&gt; with custom plugin factories). When class A is visited, it eventually discovers a call to b.bar(). B is not defined in the same source unit and we need to infer the return type of b.bar(). It is necessary to determine the return type of bar() at the time of the visit of foo() because the result operation can be chained. Without recursion, think of :&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;A { def foo() { b.bar().toUpperCase() } }
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;B { def bar() { &lt;span class=&quot;code-quote&quot;&gt;&apos;bar&apos;&lt;/span&gt; } }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Also, the return type of bar() may include generic type information that must be inferred at that time too. Note that type inference must be triggered if, and only if, the target method is itself type checked. This means that when b.bar() is checked, we must:&lt;/p&gt;

&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;determine if method bar() is type checked&lt;/li&gt;
	&lt;li&gt;launch type checking, and only type checking, at that moment&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;We cannot use the visitor used by A for two reasons:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;as the annotations for A and B can be different, there&apos;s no reason why A and B should be type checked the same way. Worse, it may introduce failures.&lt;/li&gt;
	&lt;li&gt;error reporting will not use the correct source unit&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The second point can easily be solved. The first one is the trickiest. Imagine B uses &lt;tt&gt;@CompileStatic&lt;/tt&gt;. The visitor from A could check every annotation bar() or its declaring class (as well as possible outer classes), and verify that the transformation class used by this annotation is derived from StaticTypesTransformation. This is the case, for example, of the &lt;tt&gt;@CompileStatic&lt;/tt&gt; annotation, which defines its own transformation class extending StaticTypesTransformation. This transformation does multiple things:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;add node metadata (static compilation flags, custom writer factory)&lt;/li&gt;
	&lt;li&gt;override  protected StaticTypeCheckingVisitor newVisitor(final SourceUnit unit, final ClassNode node, final TypeCheckerPluginFactory pluginFactory) to provide a static compilation visitor which performs type checking and specialized checks for static compilation&lt;/li&gt;
	&lt;li&gt;performs AST modifications in order to facilitate static compilation&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;If the transformation does not extend StaticTypesTransformation but uses a type checking visitor (that&apos;s possible), then there&apos;s not much we can do...&lt;/p&gt;

&lt;p&gt;Obviously, there are things that must &lt;b&gt;not&lt;/b&gt; be done by a transformation triggered from a type checking only step. We need a way to separate those operations and this is not always easy to do. For example, if the static type checker only called the newVisitor() method on the AST transformation class, it would get a visitor which does exactly what&apos;s needed, but also checks that every method call has a target method set... More, the visitor from A cannot know by advance what parameters should be provided to newVisitor(), especially the plugin factory part, because the logic of that is in the &lt;tt&gt;public void visit(final ASTNode[] nodes, final SourceUnit source)&lt;/tt&gt; method of the AST transformation.&lt;/p&gt;

&lt;p&gt;We could imagine that we forget this and use the same visitor as the visitor from A. That would help:&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;detecting cycles (as every visited method is remembered)&lt;/li&gt;
	&lt;li&gt;doing type checking only&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;But we would have a type checking result different from what we would obtain if we compiled B alone, with its own annotation... Another problem is that performing type checking on a node (be it a class node or a method node) &quot;pollutes&quot; it with type checking meta data. If the visitor which is used is not correct, or not instantiated with the correct configuration, then the AST of B will contain erroneous type information. Second (and this is a problem which exists in any case), the type checking step will be started a second time when the compiler will compile class B. If type information is already present in the AST of B, the result of type checking is very likely to be wrong. To be short, we need either a way of remembering the state of the AST before the visitor from A generates a visitor for B and adds metadata, or we need to work on a clone of the AST of B, so that when the visit ends, even if, for example, the @CompileStatic annotation transforms the AST, the original AST of B remains untouched. Unfortunately, cloning an AST is not necessarily easy...&lt;/p&gt;

&lt;p&gt;Last but not least, we must also consider the case where the AST of B represents a precompiled node. In that case, the code of method will be empty, and type inference would fail. This means that we must add type inference metadata at the bytecode level (in any encoded form) which can be used in that situation.&lt;/p&gt;

&lt;p&gt;As the problem is complex, I will only commit a &quot;hotfix&quot; for now, which should be suitable for most situations, which implies only methods from the same source unit can have their return type inferred (which is not perfect). This shouldn&apos;t be a problem in most situations, and as I will have some work on presentations to do, it will let me some time to work on more critical bugs.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            13 years, 46 weeks, 4 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i2c3vr:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </customfields>
    </item>
</channel>
</rss>