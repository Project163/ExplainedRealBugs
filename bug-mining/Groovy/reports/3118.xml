<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Wed Nov 12 00:53:12 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[GROOVY-7683] Memory leak when using Groovy as JSR-223 scripting language.</title>
                <link>https://issues.apache.org/jira/browse/GROOVY-7683</link>
                <project id="12318123" key="GROOVY">Groovy</project>
                    <description>&lt;p&gt;We have a Java EE 7 web application in production that when handling single HTTP request can load and execute up to several Groovy scripts using the jsr-223 API. This application is deployed to GlassFish 4.1 server cluster with 4 instances, each having 8 GB of RAM available (Xmx=8g). We have to restart them every couple of days (3-4), because of leaking memory. After analyzing a couple of heap dumps, our main suspect is Groovy with its MetaMethodIndex$Entry class (the below table shows the top object from one of the heap dumps).&lt;/p&gt;

&lt;div class=&apos;table-wrap&apos;&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;Class Name&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;Objects&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;Shallow Heap&lt;/th&gt;
&lt;th class=&apos;confluenceTh&apos;&gt;Retained Heap&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;MetaMethodIndex$Entry&lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; 3&#160;360&#160;001 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt;  188&#160;160&#160;056 &lt;/td&gt;
&lt;td class=&apos;confluenceTd&apos;&gt; &amp;gt;= 305&#160;408&#160;024&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;


&lt;p&gt;To confirm our suspicions, I created simple Maven project with a single test case. The project is available on &lt;a href=&quot;https://github.com/jigga/groovy-jsr223-leak&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;GitHub&lt;/a&gt;. The test case executes 10 different scripts (minimal differences) obtained from a single template 20000 times in 64 worker threads (the main thread is put to sleep for 10 seconds before starting worker threads, so that one can attach JVisualVM to the test process). After all threads are done, System.gc() is called to provoke full GC. Attaching to the process in which tests are run with JVisualVM reveals that the memory is not reclaimed.&lt;/p&gt;

&lt;p&gt;To run the test in your local environment, simply clone the &lt;a href=&quot;https://github.com/jigga/groovy-jsr223-leak&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;GitHub&lt;/a&gt; project and run:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;mvn test
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The same test can be run with the &lt;b&gt;-Dlanguage=javascript&lt;/b&gt; system option, which switches ScriptEngine from Groovy to Nashorn and uses slightly modified script template (only syntactical differences).&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;mvn -Dlanguage=javascript test
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Running the test case using built-in Nashorn engine reveals no problems - all allocated memory is reclaimed after full GC.&lt;/p&gt;

&lt;p&gt;I know that the test case is run in Java SE environment, but I guess that it clearly reflects the issue. If it&apos;s not enough, I can create an arquillian test case.&lt;/p&gt;

&lt;p&gt;This may be a possible duplicate of &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-7109&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;GROOVY-7109&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Any workarounds for this issue would be greatly appreciated.&lt;/p&gt;</description>
                <environment>OS: tested on Mac OS X El Capitan and Windows 10.&lt;br/&gt;
JVM: tested on 1.8.0_60 and 1.8.0_65.</environment>
        <key id="12915354">GROOVY-7683</key>
            <summary>Memory leak when using Groovy as JSR-223 scripting language.</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="jwagenleitner">John Wagenleitner</assignee>
                                    <reporter username="jigga">Arkadiusz Gasinski</reporter>
                        <labels>
                            <label>jsr-223</label>
                    </labels>
                <created>Mon, 23 Nov 2015 14:56:46 +0000</created>
                <updated>Tue, 23 May 2017 10:13:06 +0000</updated>
                            <resolved>Sun, 11 Sep 2016 04:03:16 +0000</resolved>
                                    <version>2.4.5</version>
                                    <fixVersion>2.4.8</fixVersion>
                                    <component>GroovyScriptEngine</component>
                        <due></due>
                            <votes>9</votes>
                                    <watches>18</watches>
                                                                                                                <comments>
                            <comment id="15022733" author="blackdrag" created="Mon, 23 Nov 2015 18:55:42 +0000"  >&lt;p&gt;It could also be related to &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-7591&quot; title=&quot;Use of ClassValue causes major memory leak&quot; class=&quot;issue-link&quot; data-issue-key=&quot;GROOVY-7591&quot;&gt;&lt;del&gt;GROOVY-7591&lt;/del&gt;&lt;/a&gt;. This can be verified by setting the system property groovy.use.classvalue and see if the memory leak still happens&lt;/p&gt;</comment>
                            <comment id="15022838" author="jigga" created="Mon, 23 Nov 2015 19:42:37 +0000"  >&lt;p&gt;Unfortunately, adding &lt;b&gt;-Dgroovy.use.classvalue=false&lt;/b&gt; system property when running the test did not help - the memory was not reclaimed after the full GC. Any other options? &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="15023924" author="jigga" created="Tue, 24 Nov 2015 07:44:27 +0000"  >&lt;p&gt;The other thing that bothers me is that each time the test is run, there are always 20000 different script classes loaded (Script1 to Script20000), even though there&apos;s only 10 variations of the script. Is this the expected behavior? The good thing tough is that there are no instances of the script classes, only the script classes themselves.&lt;/p&gt;</comment>
                            <comment id="15030280" author="jwagenleitner" created="Fri, 27 Nov 2015 22:28:02 +0000"  >&lt;blockquote&gt;&lt;p&gt;there are always 20000 different script classes loaded (Script1 to Script20000), even though there&apos;s only 10 variations of the script. Is this the expected behavior?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Since the test project creates 20,000 engines and since the script class cache is per engine this will create 20k classes.  This also creates lots of classloader instances and global cached methods.  In this particular case it seems like creating a single engine with a logger binding and then using the &lt;tt&gt;context&lt;/tt&gt; bean parameter to pass the &lt;tt&gt;taskId&lt;/tt&gt; and receive the &lt;tt&gt;result&lt;/tt&gt; would be the way to go.  I realize the test project may have crafted to show the leak and not a real world example.  A global class cache would help here, but I&apos;m not sure if there are reasons (i.e., classloader) to keep it per instance.  I&apos;m not that familiar with JSR-223 so may be misunderstanding the use-case here.&lt;/p&gt;

&lt;p&gt;As for the large number of uncollected &lt;tt&gt;MetaMethodIndex$Entry&lt;/tt&gt; instances I wonder if this might be similar to the issue reported in &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-7083&quot; title=&quot;PermGen memory leak in ConfigSlurper.parse(Script script, URL location)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;GROOVY-7083&quot;&gt;&lt;del&gt;GROOVY-7083&lt;/del&gt;&lt;/a&gt;, since the &lt;a href=&quot;https://github.com/apache/incubator-groovy/blob/aa5fa948de5222abc570d9e1c41dcea6799964cf/subprojects/groovy-jsr223/src/main/java/org/codehaus/groovy/jsr223/GroovyScriptEngineImpl.java#L317&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;script metaclass is modified&lt;/a&gt; and this might be why the classes are not unloaded.&lt;/p&gt;</comment>
                            <comment id="15030440" author="blackdrag" created="Sat, 28 Nov 2015 09:09:20 +0000"  >&lt;p&gt;Thanks John. From the javadoc for ScriptEngineFactory:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;ScriptEngine getScriptEngine()

Returns an instance of the ScriptEngine associated with &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; ScriptEngineFactory. A &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ScriptEngine is generally returned, but implementations may pool, share or reuse engines.&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;So it is not wrong to have 20k engines can happen... But of course this should still not cause a memory leak. As for the setting the meta class... The case in &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-7083&quot; title=&quot;PermGen memory leak in ConfigSlurper.parse(Script script, URL location)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;GROOVY-7083&quot;&gt;&lt;del&gt;GROOVY-7083&lt;/del&gt;&lt;/a&gt; sets a meta class in the registry, which forces the registry to keep a reference to this class at all times. But in the case here we set the meta class directly on the object, which only that object will have a reference to the meta class. So this should not have an effect and the object along with the meta class should be collectable (independent of the class and the classloader)&lt;/p&gt;</comment>
                            <comment id="15030676" author="jwagenleitner" created="Sat, 28 Nov 2015 22:24:21 +0000"  >&lt;p&gt;I tested the sample project with Groovy 2.3.11 and after the gc() call it unloaded all but about 2k classes.   The MetaMethodIndex$Entry instance count dropped to 522.  Tested with 2.4.0 and it behaves similar to 2.4.5 by not unloading the script classes.&lt;/p&gt;

&lt;p&gt;It looks like &lt;a href=&quot;https://github.com/apache/incubator-groovy/commit/97d78e9e52deb52c8e66db501ef208f30384d014&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;commit 97d78e9e52deb52c8e66db501ef208f30384d014&lt;/a&gt; may have introduced a hard reference to the class (klazz) in combination of the ClassValue whereas I think it was a soft reference prior.  In analyzing the heap dump it looks like&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;java.lang.&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;
- &amp;lt;Java Local&amp;gt;, contextClassLoader sun.misc.Launcher$AppClassLoader
    &apos;- classes java.util.Vector
      &apos;- elementData java.lang.&lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;[1280]
         &apos;- [822] &lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;org.codehaus.groovy.reflection.ClassInfo
            &apos;- globalClassValue org.codehaus.groovy.reflection.GroovyClassValuePreJava7
               &apos;- map org.codehaus.groovy.reflection.GroovyClassValuePreJava7$GroovyClassValuePreJava7Map
                  &apos;- segments org.codehaus.groovy.util.AbstractConcurrentMapBase$Segment[16]
                     &apos;- [8] org.codehaus.groovy.reflection.GroovyClassValuePreJava7$GroovyClassValuePreJava7Segment
                        &apos;- table java.lang.&lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;[2048]  
                           &apos;- [1127] org.codehaus.groovy.reflection.GroovyClassValuePreJava7$EntryWithValue
                              &apos;- value org.codehaus.groovy.reflection.ClassInfo 
                                 &apos;- klazz &lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;Script15965                                        
                                    &apos;- &amp;lt;classloader&amp;gt; groovy.lang.GroovyClassLoader$InnerLoader
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I&apos;m not sure, but wanted to point it out since it seems to be a significant change between 2.3.x and 2.4.x that may have an affect on this issue.&lt;/p&gt;</comment>
                            <comment id="15030866" author="blackdrag" created="Sun, 29 Nov 2015 09:27:36 +0000"  >&lt;p&gt;the change you mention was made to use ClassValue, yes. But because of &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-7591&quot; title=&quot;Use of ClassValue causes major memory leak&quot; class=&quot;issue-link&quot; data-issue-key=&quot;GROOVY-7591&quot;&gt;&lt;del&gt;GROOVY-7591&lt;/del&gt;&lt;/a&gt; (and &lt;a href=&quot;https://bugs.openjdk.java.net/browse/JDK-8136353&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://bugs.openjdk.java.net/browse/JDK-8136353&lt;/a&gt;) Groovy 2.4.5 does not use ClassValue by default anymore... and it does not show up in the dump you show here as well. But yes... if those are all hard references (and it looks like it), then it is not right.&lt;/p&gt;</comment>
                            <comment id="15058025" author="jkemnade" created="Tue, 15 Dec 2015 13:06:52 +0000"  >&lt;p&gt;I&apos;m also experiencing those leaks.&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;this     - value: org.codehaus.groovy.reflection.ClassInfo #392
 &amp;lt;- value     - class: org.codehaus.groovy.reflection.GroovyClassValuePreJava7$EntryWithValue, value: org.codehaus.groovy.reflection.ClassInfo #392
  &amp;lt;- [65]     - class: java.lang.Object[], value: org.codehaus.groovy.reflection.GroovyClassValuePreJava7$EntryWithValue #317
   &amp;lt;- table     - class: org.codehaus.groovy.reflection.GroovyClassValuePreJava7$GroovyClassValuePreJava7Segment, value: java.lang.Object[] #424042
    &amp;lt;- [11]     - class: org.codehaus.groovy.util.AbstractConcurrentMapBase$Segment[], value: org.codehaus.groovy.reflection.GroovyClassValuePreJava7$GroovyClassValuePreJava7Segment #5
     &amp;lt;- segments     - class: org.codehaus.groovy.reflection.GroovyClassValuePreJava7$GroovyClassValuePreJava7Map, value: org.codehaus.groovy.util.AbstractConcurrentMapBase$Segment[] #2
      &amp;lt;- map     - class: org.codehaus.groovy.reflection.GroovyClassValuePreJava7, value: org.codehaus.groovy.reflection.GroovyClassValuePreJava7$GroovyClassValuePreJava7Map #1
       &amp;lt;- globalClassValue     - class: org.codehaus.groovy.reflection.ClassInfo, value: org.codehaus.groovy.reflection.GroovyClassValuePreJava7 #1
        &amp;lt;- [8080]     - class: java.lang.Object[], value: org.codehaus.groovy.reflection.ClassInfo class ClassInfo
         &amp;lt;- elementData     - class: java.util.Vector, value: java.lang.Object[] #78509
          &amp;lt;- classes     - class: org.apache.catalina.loader.WebappClassLoader, value: java.util.Vector #242
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt; Can we do something about them for 2.4.6? I&apos;d try to help with a patch but I&apos;m afraid that this part of the Groovy code is still over my head.&lt;/p&gt;</comment>
                            <comment id="15060084" author="jkemnade" created="Wed, 16 Dec 2015 14:52:49 +0000"  >&lt;p&gt;If it&apos;s just a matter of replacing the hard reference by a soft one, here&apos;s a patch. If not, maybe someone can give a hint as to how this should be solved.&lt;/p&gt;</comment>
                            <comment id="15060116" author="blackdrag" created="Wed, 16 Dec 2015 15:15:12 +0000"  >&lt;p&gt;normally the ClassInfo object does not only refer to the class directly, but also indirectly using hard references, for example through method methods, which are based on the real methods of the class, which are based on reflection, which then have direct references to classes again, of which usually the class in question is one. If a patch like this fixes the problem so should enabling CMS. So frankly I would not expect this patch to work, in fact I would be quite surprised if it does. But if someone has this problem and can try out if the patch changes anything, I am curious to hear about the results. I would help even if the patch would not work out&lt;/p&gt;</comment>
                            <comment id="15060170" author="jkemnade" created="Wed, 16 Dec 2015 15:38:59 +0000"  >&lt;p&gt;This does not seem to fix &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-7083&quot; title=&quot;PermGen memory leak in ConfigSlurper.parse(Script script, URL location)&quot; class=&quot;issue-link&quot; data-issue-key=&quot;GROOVY-7083&quot;&gt;&lt;del&gt;GROOVY-7083&lt;/del&gt;&lt;/a&gt; however.&lt;/p&gt;</comment>
                            <comment id="15060173" author="jkemnade" created="Wed, 16 Dec 2015 15:43:16 +0000"  >&lt;p&gt;Oh, I read your comment too late. Yes, apparently it doesn&apos;t fix the problem. Maybe I misunderstood your comment about the hard references.&lt;/p&gt;</comment>
                            <comment id="15060964" author="jwagenleitner" created="Wed, 16 Dec 2015 21:54:54 +0000"  >&lt;p&gt;I tested the referenced Github LeakTest project again and this time created some memory pressure after the loop by calling the following method:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;    &lt;span class=&quot;code-comment&quot;&gt;// Create memory pressure to force soft reference collection
&lt;/span&gt;    &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; void createOOM() {
        List&amp;lt;&lt;span class=&quot;code-object&quot;&gt;Long&lt;/span&gt;[]&amp;gt; buffer = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&lt;span class=&quot;code-object&quot;&gt;Long&lt;/span&gt;[]&amp;gt;(100);
        &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; chunk = 128 * 1024 * 1024;
        &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; limit = 50000;
        &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
            &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; i = 0; i &amp;lt; limit; i++) {
                buffer.add(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Long&lt;/span&gt;[chunk]);
            }
        } &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (OutOfMemoryError oom) {
            buffer.clear();
            &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt;;
        }
        &lt;span class=&quot;code-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; RuntimeException(&lt;span class=&quot;code-quote&quot;&gt;&quot;OOM expected&quot;&lt;/span&gt;);
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Using the default setting with &lt;tt&gt;ClassValue&lt;/tt&gt; disabled things looked pretty much the same as before.  However, enabling &lt;tt&gt;ClassValue&lt;/tt&gt; by adding the following to the static initializer:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.setProperty(&lt;span class=&quot;code-quote&quot;&gt;&quot;groovy.use.classvalue&quot;&lt;/span&gt;, &lt;span class=&quot;code-quote&quot;&gt;&quot;&lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Seemed to dramatically reduce the heap size. &lt;/p&gt;

&lt;p&gt;Size: 60mb vs 1.2G&lt;br/&gt;
Classes: 2.6k vs 22.6k&lt;br/&gt;
Objects: 1.5m vs 18.2m&lt;br/&gt;
Class Loader: 6 vs 40k&lt;/p&gt;

&lt;p&gt;So I think &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=blackdrag&quot; class=&quot;user-hover&quot; rel=&quot;blackdrag&quot;&gt;blackdrag&lt;/a&gt; original suggestion to try enabling ClassValue is worth a try.  You might still see heap usage creep up over time but I would expect as memory pressure builds close to the 8G max you&apos;ll see GC work and should experience a lot less severe leak than without using it.&lt;/p&gt;</comment>
                            <comment id="15061672" author="jkemnade" created="Thu, 17 Dec 2015 07:50:03 +0000"  >&lt;p&gt;Yes, the classes are properly cleaned up with &lt;tt&gt;groovy.use.classvalue=true&lt;/tt&gt;, so I guess the problem must be in &lt;tt&gt;GroovyClassValuePreJava7&lt;/tt&gt;.&lt;br/&gt;
Err, this may be a stupid question, but, is &lt;tt&gt;GroovyClassValue.remove(Class)&lt;/tt&gt; ever called?&lt;/p&gt;</comment>
                            <comment id="15065742" author="pascalschumacher" created="Sun, 20 Dec 2015 13:14:39 +0000"  >&lt;p&gt;If the problem is in GroovyClassValuePreJava7 one could compare &lt;a href=&quot;https://github.com/apache/groovy/blob/master/src/main/org/codehaus/groovy/reflection/GroovyClassValuePreJava7.java&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/groovy/blob/master/src/main/org/codehaus/groovy/reflection/GroovyClassValuePreJava7.java&lt;/a&gt; and &lt;a href=&quot;http://hg.openjdk.java.net/jdk8u/jdk8u60-dev/jdk/file/tip/src/share/classes/java/lang/ClassValue.java&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://hg.openjdk.java.net/jdk8u/jdk8u60-dev/jdk/file/tip/src/share/classes/java/lang/ClassValue.java&lt;/a&gt; for differences.&lt;/p&gt;</comment>
                            <comment id="15065750" author="pascalschumacher" created="Sun, 20 Dec 2015 13:25:53 +0000"  >&lt;p&gt;Intellij can not find any usages of GroovyClassValue.remove(Class). I do not know anything about this part of Groovy so no idea were it&apos;s supposed to be used.&lt;/p&gt;</comment>
                            <comment id="15066871" author="jwagenleitner" created="Mon, 21 Dec 2015 18:52:51 +0000"  >&lt;p&gt;With &lt;tt&gt;GroovyClassValuePreJava7&lt;/tt&gt; I don&apos;t think &lt;tt&gt;GroovyClassValue.remove(Class)&lt;/tt&gt; is designed to be called directly, I think it would be enough if the cached Entry in the ManagedConcurrentMap was collected due to its weakly held key (Class) being collected.  I believe the issue is that the cached value in the map (ClassInfo) stores a &lt;a href=&quot;https://github.com/apache/groovy/blob/73f5979a468f1508134eba20ce503630b0fe0cc7/src/main/org/codehaus/groovy/reflection/ClassInfo.java#L47&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;strong reference to the cached key (Class)&lt;/a&gt;.  So I don&apos;t think the Entry ever gets cleared.  I think changing this to a weak ref would allow the cache entry to be cleared, but hard to tell what problems that might cause or if it would ever be possible for the Class to be collected while the ClassInfo is used causing the weak ref to return null for the Class.&lt;/p&gt;

&lt;p&gt;I also think the &lt;a href=&quot;https://github.com/apache/groovy/blob/73f5979a468f1508134eba20ce503630b0fe0cc7/src/main/org/codehaus/groovy/reflection/ClassInfo.java#L77&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;ClassInfoCleanup&lt;/a&gt; is not &lt;a href=&quot;https://github.com/apache/groovy/blob/73f5979a468f1508134eba20ce503630b0fe0cc7/src/main/org/codehaus/groovy/reflection/ClassInfo.java#L477-L489&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;doing what it&apos;s expected to do for cleanup&lt;/a&gt;.  Since it&apos;s not stored it goes out of scope immediately and will be collected long before the ClassInfo it&apos;s meant to clean up after is eligible for collection.&lt;/p&gt;

&lt;p&gt;I&apos;m not familiar with this part of the code, so might be way off.&lt;/p&gt;</comment>
                            <comment id="15067388" author="blackdrag" created="Tue, 22 Dec 2015 01:17:10 +0000"  >&lt;p&gt;How things on the JVM are supposed to be working is the following... imagine a class that is nowhere referenced anymore, but in an equally otherwise non-referenced class loader and another object. Imagine this other object is softly reachable, meaning no strong/weak/phantom reference is pointing to it.This is supposed to mean, that the class is softly reachable as well. So in theory, as long as the ClassInfo object is not strongly reachable, the ClassInfo object could be collected along with the class.&lt;br/&gt;
In the practice though, things do not always work like that. I know for sure, that the IBM JVM for example needs special options given to it, to even check such a case. For the Oracle JVM enabling CMS used to help with this problem. For the Oracle JVM the problem is that normally the garbage collection for classes and the garbage collection for instances is not done together. So unless the ClassInfo object is collected it happens that the class will stay. Since ClassInfo objects are normally softly referenced, they will stay till the very last moment, increasing the probability of the problem to occur. The fact, that there is a multitude of objects referenced by ClassInfo, which hold strong references to the class (for example a reflective method object could be one, but the type information in the meta methods is already enough) does not help the garbage collector at all.&lt;br/&gt;
As bad as it sounds, in the end it depends on the implementation of the garbage collector if that object can be collected. So it is supposed to work, but can for several reasons not sometimes.&lt;/p&gt;

&lt;p&gt;Of course that is all theory and past experience. It is very possible, that there is somewhere a strong reference, where it should not be. But as I tried to explain above, changing ClassInfo to use a weak key for the Class is not something I would expect to really help. The patch that is attached here, tries it with a SoftReference. WeakReference could be better, but frankly there are still many many strong references to the class through other objects hard referenced by the ClassInfo object. Could be, that this decreases the number of hard references just enough to not be over some threshold optimization in the garbage collector and then allows the garbage collector to collect. Or it might not have any effect. My expectation is that it won&apos;t change anything.&lt;/p&gt;

&lt;p&gt;As for the ClassInfoCleanup.. it is not right that it is not stored. When you create a Soft/WeakReference, then there will be a reference object and a ReferenceQueue. The queue will know the reference. And it is not that those references simply vanish. In fact, if you don&apos;t clean up the queue, you will get a memory leak from that side, even if the objects you reference would be collected. But for Weak/SoftReference this is not actually the case, you would need PhantomReference for that. On the other hand, you are right, that this code has almost zero relevance when it comes to the automatic removal of ClassInfo. If the ClassInfo has a strong reference set, the ClassInfo object itself will not be weak referenced. Same for the cleanups... there are more to support garbage collection a little, than that they are really needed. The real code managing the reference is in ManagedLinkedList as far as GlobalClassSet is concerned. Or the manged hashmap in GroovyClassValuePreJava7.&lt;/p&gt;

&lt;p&gt;Oh, one correction... ClassInfo is mostly weakly reachable in those structures, not softly. cachedClassRef and artifactClassLoader are should be soft reachable, same for the entries of LocalMap&lt;/p&gt;</comment>
                            <comment id="15067764" author="githubbot" created="Tue, 22 Dec 2015 08:51:17 +0000"  >&lt;p&gt;GitHub user jwagenleitner opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/groovy/pull/219&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/groovy/pull/219&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-7683&quot; title=&quot;Memory leak when using Groovy as JSR-223 scripting language.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;GROOVY-7683&quot;&gt;&lt;del&gt;GROOVY-7683&lt;/del&gt;&lt;/a&gt; - Memory leak when using Groovy as JSR-223 scripting language&lt;/p&gt;

&lt;p&gt;    I am unsure what if any problems making the Class a `WeakReference` might have but thought I&apos;d put this out there for review. &lt;/p&gt;

&lt;p&gt;    I also tested against &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-7646&quot; title=&quot;Classes generated by Eval() never collected from Permgen/Metaspace&quot; class=&quot;issue-link&quot; data-issue-key=&quot;GROOVY-7646&quot;&gt;&lt;del&gt;GROOVY-7646&lt;/del&gt;&lt;/a&gt;(&lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-7646&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/GROOVY-7646&lt;/a&gt;) which was consistently throwing OOME after &amp;lt;2 mins prior to these changes and ran to completion with changes.&lt;/p&gt;

&lt;p&gt;    Another thing I noticed in looking at this class is that &lt;span class=&quot;error&quot;&gt;&amp;#91;uses a `PhantomReference`&amp;#93;&lt;/span&gt;(&lt;a href=&quot;https://github.com/apache/groovy/blob/73f5979a468f1508134eba20ce503630b0fe0cc7/src/main/org/codehaus/groovy/reflection/ClassInfo.java#L405&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/groovy/blob/73f5979a468f1508134eba20ce503630b0fe0cc7/src/main/org/codehaus/groovy/reflection/ClassInfo.java#L405&lt;/a&gt;) and attempts &lt;span class=&quot;error&quot;&gt;&amp;#91;to use the value from `get()`&amp;#93;&lt;/span&gt;(&lt;a href=&quot;https://github.com/apache/groovy/blob/73f5979a468f1508134eba20ce503630b0fe0cc7/src/main/org/codehaus/groovy/reflection/ClassInfo.java#L435&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/groovy/blob/73f5979a468f1508134eba20ce503630b0fe0cc7/src/main/org/codehaus/groovy/reflection/ClassInfo.java#L435&lt;/a&gt;).  However, this will always return `null` so the code path never executes.&lt;/p&gt;

&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/jwagenleitner/groovy&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/jwagenleitner/groovy&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-7683&quot; title=&quot;Memory leak when using Groovy as JSR-223 scripting language.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;GROOVY-7683&quot;&gt;&lt;del&gt;GROOVY-7683&lt;/del&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/groovy/pull/219.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/groovy/pull/219.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #219&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit 10689a29cbf167c40b05c38aa5c144724045eeb0&lt;br/&gt;
Author: John Wagenleitner &amp;lt;jwagenleitner@apache.org&amp;gt;&lt;br/&gt;
Date:   2015-12-17T00:44:29Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-7683&quot; title=&quot;Memory leak when using Groovy as JSR-223 scripting language.&quot; class=&quot;issue-link&quot; data-issue-key=&quot;GROOVY-7683&quot;&gt;&lt;del&gt;GROOVY-7683&lt;/del&gt;&lt;/a&gt; - Memory leak when using Groovy as JSR-223 scripting language&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="15067788" author="jwagenleitner" created="Tue, 22 Dec 2015 09:10:38 +0000"  >&lt;p&gt;Created a PR, this is scary and unfamiliar part of the code but thought I&apos;d put it out there for review. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;  Am really interested in learning more about this part of the code so appreciate the comments so far.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;As for the ClassInfoCleanup.. it is not right that it is not stored. When you create a Soft/WeakReference, then there will be a reference object and a ReferenceQueue. The queue will know the reference. And it is not that those references simply vanish.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;My understanding is that the ReferenceQueue will know of the reference (ClassInfoCleanup) when the referent (ClassInfo) is no longer reachable by strong or soft references.  However, in order for the reference (ClassInfoCleanup) to be enqueued it must be alive when this happens.  But I don&apos;t see any reason why the GC would hold on to this object (the ClassInfoCleanup) after the constructor completes.  So that&apos;s why I believe that ClassInfoCleanup and DebugRef will never run the finalize method.  Not to mention that both do not override the &lt;tt&gt;ManagedReference#finalizeReference&lt;/tt&gt; but instead have it named &lt;tt&gt;finalizeRef&lt;/tt&gt;.&lt;/p&gt;</comment>
                            <comment id="15067895" author="blackdrag" created="Tue, 22 Dec 2015 10:10:25 +0000"  >&lt;p&gt;John, you are right... I should not write comments on JIRA at 2:00 in the morning. The Reference has to be alive to be enqueued, you are fully right there. The conclusion that ClassInfoCleanup is then doing about nothing is most likely right as well, some for DebugRef. Those have been handled different before the ClassValue rewrite.&lt;/p&gt;</comment>
                            <comment id="15266908" author="githubbot" created="Mon, 2 May 2016 16:19:10 +0000"  >&lt;p&gt;Github user blackdrag commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/groovy/pull/219#discussion_r61761426&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/groovy/pull/219#discussion_r61761426&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/main/org/codehaus/groovy/util/ManagedReference.java &amp;#8212;&lt;br/&gt;
    @@ -46,7 +46,6 @@ public final T get() {&lt;/p&gt;

&lt;p&gt;         public final void clear() {&lt;br/&gt;
             ref.clear();&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;manager.removeStallEntries();
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Why did you remove this call?&lt;/p&gt;</comment>
                            <comment id="15266912" author="githubbot" created="Mon, 2 May 2016 16:22:28 +0000"  >&lt;p&gt;Github user blackdrag commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/groovy/pull/219#discussion_r61761881&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/groovy/pull/219#discussion_r61761881&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/main/org/codehaus/groovy/reflection/ClassInfo.java &amp;#8212;&lt;br/&gt;
    @@ -35,13 +36,13 @@&lt;br/&gt;
      *&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@author Alex.Tkachman&lt;br/&gt;
      */&lt;br/&gt;
    -public class ClassInfo {&lt;br/&gt;
    +public class ClassInfo implements Finalizable {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         private final LazyCachedClassRef cachedClassRef;&lt;br/&gt;
         private final LazyClassLoaderRef artifactClassLoader;&lt;br/&gt;
         private final LockableObject lock = new LockableObject();&lt;br/&gt;
         public final int hash = -1;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private final Class klazz;&lt;br/&gt;
    +    private final WeakReference&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; klazz;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    I wonder what we should do if the referenced class has been collected. At least in the non - ClassValue version, it might be, that the ClassInfo still exists. And if then somebody tries to get the meta class using that ClassInfo things will blow up&lt;/p&gt;</comment>
                            <comment id="15266940" author="githubbot" created="Mon, 2 May 2016 16:38:56 +0000"  >&lt;p&gt;Github user jwagenleitner commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/groovy/pull/219#discussion_r61764022&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/groovy/pull/219#discussion_r61764022&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/main/org/codehaus/groovy/util/ManagedReference.java &amp;#8212;&lt;br/&gt;
    @@ -46,7 +46,6 @@ public final T get() {&lt;/p&gt;

&lt;p&gt;         public final void clear() {&lt;br/&gt;
             ref.clear();&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;manager.removeStallEntries();
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    `ClassInfo#finalizeReference` calls `setStrongMetaClass(null)` which in turn calls `replaceWeakMetaClassRef(null)` which calls `weakRef#clear` which is on ManagedReference.  This causes a recursive call back into the queue can can lead to stackoverflow if there are lots of ClassInfo ManagedReferences in the Reference Queue.&lt;/p&gt;

&lt;p&gt;    A related PR that attempts to prevent this reentrant processing is PR #298.&lt;/p&gt;</comment>
                            <comment id="15266951" author="githubbot" created="Mon, 2 May 2016 16:45:41 +0000"  >&lt;p&gt;Github user jwagenleitner commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/groovy/pull/219#discussion_r61764947&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/groovy/pull/219#discussion_r61764947&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/main/org/codehaus/groovy/reflection/ClassInfo.java &amp;#8212;&lt;br/&gt;
    @@ -35,13 +36,13 @@&lt;br/&gt;
      *&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@author Alex.Tkachman&lt;br/&gt;
      */&lt;br/&gt;
    -public class ClassInfo {&lt;br/&gt;
    +public class ClassInfo implements Finalizable {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         private final LazyCachedClassRef cachedClassRef;&lt;br/&gt;
         private final LazyClassLoaderRef artifactClassLoader;&lt;br/&gt;
         private final LockableObject lock = new LockableObject();&lt;br/&gt;
         public final int hash = -1;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private final Class klazz;&lt;br/&gt;
    +    private final WeakReference&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; klazz;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    That&apos;s the question I&apos;ve struggled with too.  My assumption here is that only the Groovy Runtime should ever ask for ClassInfo objects and in most places I can find they do so either with a Class or an instance of the Class which I think would mean it wouldn&apos;t have been collected.  But it&apos;s been difficult for me to be certain that the case can never happen.  Best I can think of is maybe check if the ref is null and throw a `GroovyBugError`.&lt;/p&gt;</comment>
                            <comment id="15267002" author="githubbot" created="Mon, 2 May 2016 17:15:00 +0000"  >&lt;p&gt;Github user blackdrag commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/groovy/pull/219#discussion_r61768963&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/groovy/pull/219#discussion_r61768963&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/main/org/codehaus/groovy/util/ManagedReference.java &amp;#8212;&lt;br/&gt;
    @@ -46,7 +46,6 @@ public final T get() {&lt;/p&gt;

&lt;p&gt;         public final void clear() {&lt;br/&gt;
             ref.clear();&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;manager.removeStallEntries();
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    ok, I +1ed PR #298 &lt;/p&gt;</comment>
                            <comment id="15267011" author="githubbot" created="Mon, 2 May 2016 17:19:18 +0000"  >&lt;p&gt;Github user blackdrag commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/groovy/pull/219#discussion_r61769520&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/groovy/pull/219#discussion_r61769520&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/main/org/codehaus/groovy/reflection/ClassInfo.java &amp;#8212;&lt;br/&gt;
    @@ -35,13 +36,13 @@&lt;br/&gt;
      *&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;@author Alex.Tkachman&lt;br/&gt;
      */&lt;br/&gt;
    -public class ClassInfo {&lt;br/&gt;
    +public class ClassInfo implements Finalizable {&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;         private final LazyCachedClassRef cachedClassRef;&lt;br/&gt;
         private final LazyClassLoaderRef artifactClassLoader;&lt;br/&gt;
         private final LockableObject lock = new LockableObject();&lt;br/&gt;
         public final int hash = -1;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;private final Class klazz;&lt;br/&gt;
    +    private final WeakReference&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; klazz;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    I think it would be sufficent to add to each method an according javadoc comment, as well as a class comment, that it is not safe to use  without a Class associated with this ClassInfo. I would even consider a method to get the referenced Class, so people can check/ensure it will continue to exist. In that case we can probably avoid the checks and exceptions&lt;/p&gt;</comment>
                            <comment id="15268014" author="githubbot" created="Tue, 3 May 2016 03:17:11 +0000"  >&lt;p&gt;Github user jwagenleitner commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/groovy/pull/219#discussion_r61834705&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/groovy/pull/219#discussion_r61834705&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/main/org/codehaus/groovy/util/ManagedReference.java &amp;#8212;&lt;br/&gt;
    @@ -46,7 +46,6 @@ public final T get() {&lt;/p&gt;

&lt;p&gt;         public final void clear() {&lt;br/&gt;
             ref.clear();&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;manager.removeStallEntries();
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    Thanks for reviewing that other PR.  I merged that PR and will rebase this and leave the call to manager.removeStallEntries().&lt;/p&gt;</comment>
                            <comment id="15420705" author="vguna" created="Mon, 15 Aug 2016 07:49:09 +0000"  >&lt;p&gt;Any news on this?&lt;/p&gt;

&lt;p&gt;I also encountered the mentioned problem, that MetaMethodIndex$Entry classes are growing quickly without being able to be GCed.&lt;br/&gt;
My scenario is during loadtests on the client side. I use restassured 2.9.0 (uses groovy 2.4.6) to perform json parsing. I could track it down to this little snippet&lt;br/&gt;
to reproduce the behavior:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;...
&lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; com.jayway.restassured.path.json.JsonPath;
...
	&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; void main(&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;[] args) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; InterruptedException {
		&lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; ci = 0; ci &amp;lt; 100000; ci++) {
			JsonPath.from(&lt;span class=&quot;code-quote&quot;&gt;&quot;{\&quot;&lt;/span&gt;id\&lt;span class=&quot;code-quote&quot;&gt;&quot;: \&quot;&lt;/span&gt;&lt;span class=&quot;code-quote&quot;&gt;&quot; + UUID.randomUUID().toString() + &quot;&lt;/span&gt;\&lt;span class=&quot;code-quote&quot;&gt;&quot;}&quot;&lt;/span&gt;).getUUID(&lt;span class=&quot;code-quote&quot;&gt;&quot;id&quot;&lt;/span&gt;);
			&lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;.sleep(1);
		}
	}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Simply take a look using jvisualvm and you see the results.&lt;br/&gt;
I also tried the latest 2.4.x groovy version and latest 2.3.x with the same results.&lt;/p&gt;</comment>
                            <comment id="15423787" author="gsandrew" created="Wed, 17 Aug 2016 03:03:56 +0000"  >&lt;p&gt;I&apos;ve been tracking/trying to isolate this memory leak for a while now.  I was running Grails 2.5.3 (using Groovy 2.4.4) on Heroku monitoring with New Relic.  First I ran into New Relic&apos;s leaky agent with issues around async servlets, upgraded to their latest agent, and then I started running into this. &lt;/p&gt;

&lt;p&gt;I&apos;ve since forced Grails 2.5.3 to load Groovy 2.4.5 when I was seeing a massive amount of ClassInfo&apos;s hanging around and the &quot;Expando&quot; class.  Recently I&apos;ve been seeing a ton of java.ref.lang.Finalizer&apos;s..  &lt;/p&gt;

&lt;p&gt;Anyhow, I wanted to comment that I&apos;ve played around with toggling groovy.use.classvalue and the image I attached is when I switched it to true.  It&apos;s an interesting visualization to how the GC is behaving and how my non-heap memory is continuing to creep higher and higher although it appears to be at a slower pace than without it set.&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;image-wrap&quot; style=&quot;&quot;&gt;&lt;img src=&quot;https://issues.apache.org/jira/secure/attachment/12824056/12824056_Screen+Shot+2016-08-16+at+10.53.04+PM.png&quot; style=&quot;border: 0px solid black&quot; /&gt;&lt;/span&gt;&lt;/p&gt;</comment>
                            <comment id="15447782" author="gsandrew" created="Tue, 30 Aug 2016 02:34:46 +0000"  >&lt;p&gt;Linking to &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-7623&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;Groovy-7623&lt;/a&gt; as it claims to be a possible solution path to this memory leak issue. &lt;/p&gt;</comment>
                            <comment id="15449142" author="gsandrew" created="Tue, 30 Aug 2016 14:20:29 +0000"  >&lt;p&gt;Also linking because I added a walkthrough on how I got that JDK to play nice with my grails project.&lt;/p&gt;</comment>
                            <comment id="15480909" author="githubbot" created="Sun, 11 Sep 2016 03:07:49 +0000"  >&lt;p&gt;Github user asfgit closed the pull request at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/groovy/pull/219&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/groovy/pull/219&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="15480974" author="jwagenleitner" created="Sun, 11 Sep 2016 04:03:16 +0000"  >&lt;p&gt;Thanks for reporting the issue.  I believe the referenced PR will fix the issue, but please re-open if you find that to not be the case.&lt;/p&gt;</comment>
                            <comment id="15481100" author="gsandrew" created="Sun, 11 Sep 2016 05:39:15 +0000"  >&lt;p&gt;Any idea when the expected 2.4.8 release date is?&lt;/p&gt;</comment>
                            <comment id="15527902" author="jwagenleitner" created="Wed, 28 Sep 2016 00:26:03 +0000"  >&lt;p&gt;Not sure, but there&apos;s been some talk about it on the dev mailing list which is usually a sign that it&apos;s not too far off.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="12817755">GROOVY-7109</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12931658">GROOVY-7731</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12998804">GROOVY-7913</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="13071940">GROOVY-8189</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12903831">GROOVY-7623</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12907505">GROOVY-7646</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="13074147">GROOVY-8199</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12778009" name="0001-GROOVY-7683-replace-hard-reference-from-ClassInfo-to.patch" size="2503" author="jkemnade" created="Wed, 16 Dec 2015 14:52:49 +0000"/>
                            <attachment id="12824056" name="Screen Shot 2016-08-16 at 10.53.04 PM.png" size="59675" author="gsAndrew" created="Wed, 17 Aug 2016 03:03:56 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310250" key="com.atlassian.jira.plugin.system.customfieldtypes:multicheckboxes">
                        <customfieldname>Flags</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10431"><![CDATA[Important]]></customfieldvalue>
    
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            9 years, 8 weeks ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i2oshr:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </customfields>
    </item>
</channel>
</rss>