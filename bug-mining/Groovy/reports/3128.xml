<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Wed Nov 12 00:53:23 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[GROOVY-7922] Static type checking not strict enough in the presence of ambiguous method matching</title>
                <link>https://issues.apache.org/jira/browse/GROOVY-7922</link>
                <project id="12318123" key="GROOVY">Groovy</project>
                    <description>&lt;p&gt;This example:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; groovy.transform.CompileStatic

&lt;span class=&quot;code-keyword&quot;&gt;interface&lt;/span&gt; FooA {}
&lt;span class=&quot;code-keyword&quot;&gt;interface&lt;/span&gt; FooB {}
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;FooAB &lt;span class=&quot;code-keyword&quot;&gt;implements&lt;/span&gt; FooA, FooB {}
@CompileStatic
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;TestGroovy {
    &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; void test() { println &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; TestGroovy().foo(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; FooAB()) }
    def foo(FooB x) { 43 }
    def foo(FooA x) { 42 }
}

TestGroovy.test()
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Should probably throw some kind of ambiguous method error during compilation to match Java (and dynamic Groovy&apos;s runtime error).&lt;/p&gt;</description>
                <environment></environment>
        <key id="13000963">GROOVY-7922</key>
            <summary>Static type checking not strict enough in the presence of ambiguous method matching</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="jwagenleitner">John Wagenleitner</assignee>
                                    <reporter username="paulk">Paul King</reporter>
                        <labels>
                    </labels>
                <created>Mon, 29 Aug 2016 13:05:30 +0000</created>
                <updated>Wed, 1 Feb 2017 23:19:01 +0000</updated>
                            <resolved>Tue, 20 Sep 2016 03:32:21 +0000</resolved>
                                                    <fixVersion>2.4.8</fixVersion>
                                    <component>Static Type Checker</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>3</watches>
                                                                                                                <comments>
                            <comment id="15496084" author="githubbot" created="Fri, 16 Sep 2016 11:38:10 +0000"  >&lt;p&gt;GitHub user blindpirate opened a pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/groovy/pull/422&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/groovy/pull/422&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-7922&quot; title=&quot;Static type checking not strict enough in the presence of ambiguous method matching&quot; class=&quot;issue-link&quot; data-issue-key=&quot;GROOVY-7922&quot;&gt;&lt;del&gt;GROOVY-7922&lt;/del&gt;&lt;/a&gt;: Static type checking not strict enough in the presence o&#8230;&lt;/p&gt;

&lt;p&gt;    &#8230;f ambiguous method matching&lt;/p&gt;


&lt;p&gt;    the issue has been resolved and some refactor are done&lt;/p&gt;

&lt;p&gt;You can merge this pull request into a Git repository by running:&lt;/p&gt;

&lt;p&gt;    $ git pull &lt;a href=&quot;https://github.com/blindpirate/groovy&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/blindpirate/groovy&lt;/a&gt; groovy7922bug&lt;/p&gt;

&lt;p&gt;Alternatively you can review and apply these changes as the patch at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/groovy/pull/422.patch&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/groovy/pull/422.patch&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To close this pull request, make a commit to your master/trunk branch&lt;br/&gt;
with (at least) the following in the commit message:&lt;/p&gt;

&lt;p&gt;    This closes #422&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;commit b2d84738986fc83a589e78ec205bb206318a1e4a&lt;br/&gt;
Author: zhangbo &amp;lt;zhangbo@nanchao.org&amp;gt;&lt;br/&gt;
Date:   2016-09-16T00:29:11Z&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-7922&quot; title=&quot;Static type checking not strict enough in the presence of ambiguous method matching&quot; class=&quot;issue-link&quot; data-issue-key=&quot;GROOVY-7922&quot;&gt;&lt;del&gt;GROOVY-7922&lt;/del&gt;&lt;/a&gt;: Static type checking not strict enough in the presence of ambiguous method matching&lt;/p&gt;

&lt;hr /&gt;</comment>
                            <comment id="15497145" author="githubbot" created="Fri, 16 Sep 2016 19:19:12 +0000"  >&lt;p&gt;Github user jwagenleitner commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/groovy/pull/422#discussion_r79234404&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/groovy/pull/422#discussion_r79234404&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java &amp;#8212;&lt;br/&gt;
    @@ -1157,6 +1141,56 @@ private static ClassNode makeRawType(final ClassNode receiver) &lt;/p&gt;
{
             return result;
         }

&lt;p&gt;    +    private static void removeMethodInSuperInterface(List&amp;lt;MethodNode&amp;gt; toBeRemoved, MethodNode one, MethodNode two) {&lt;br/&gt;
    +        ClassNode oneDC=one.getDeclaringClass();&lt;br/&gt;
    +        ClassNode twoDC=two.getDeclaringClass();&lt;br/&gt;
    +        if(oneDC.implementsInterface(twoDC))&lt;/p&gt;
{
    +            toBeRemoved.add(two);
    +        }else{
    +            toBeRemoved.add(one);
    +        }&lt;br/&gt;
    +    }&lt;br/&gt;
    +&lt;br/&gt;
    +    private static boolean areEquivalentInterfaceMethods(MethodNode one, MethodNode two, Parameter[] onePars, Parameter[] twoPars) {
    +        return one.getName().equals(two.getName())
    +                &amp;amp;&amp;amp; one.getDeclaringClass().isInterface()
    +                &amp;amp;&amp;amp; two.getDeclaringClass().isInterface()
    +                &amp;amp;&amp;amp; allParameterTypesAreSame(onePars, twoPars);
    +    }&lt;br/&gt;
    +&lt;br/&gt;
    +    private static void removeSyntheticMethodIfOne(List&amp;lt;MethodNode&amp;gt; toBeRemoved, MethodNode one, MethodNode two) {&lt;br/&gt;
    +        if (one.isSynthetic() &amp;amp;&amp;amp; !two.isSynthetic()) {    +            toBeRemoved.add(one);    +        } else if (two.isSynthetic() &amp;amp;&amp;amp; !one.isSynthetic()) {    +            toBeRemoved.add(two);    +        }
&lt;p&gt;    +    }&lt;br/&gt;
    +&lt;br/&gt;
    +    private static void removeMethodWithSuperReturnType(List&amp;lt;MethodNode&amp;gt; toBeRemoved, MethodNode one, MethodNode two) {&lt;br/&gt;
    +        ClassNode oneRT = one.getReturnType();&lt;br/&gt;
    +        ClassNode twoRT = two.getReturnType();&lt;br/&gt;
    +        if (oneRT.isDerivedFrom(twoRT) || oneRT.implementsInterface(twoRT)) &lt;/p&gt;
{
    +            toBeRemoved.add(two);
    +        }
&lt;p&gt; else if (twoRT.isDerivedFrom(oneRT) || twoRT.implementsInterface(oneRT)) &lt;/p&gt;
{
    +            toBeRemoved.add(one);
    +        }
&lt;p&gt;    +    }&lt;br/&gt;
    +&lt;br/&gt;
    +    private static boolean areOverloadMethodsInSameClass(MethodNode one, MethodNode two)&lt;/p&gt;
{
    +        return one.getName().equals(two.getName()) &amp;amp;&amp;amp; one.getDeclaringClass()==two.getDeclaringClass();
    +    }
&lt;p&gt;    +&lt;br/&gt;
    +    private static boolean allParameterTypesAreSame(Parameter[] onePars, Parameter[] twoPars) {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Might be able to use [`ParameterUtils#parametersEqual(Parameter[],Parameter[])`] (&lt;a href=&quot;https://github.com/apache/groovy/blob/14266ad5b7c265b55334c029e87b1d79ebd2210e/src/main/org/codehaus/groovy/ast/tools/ParameterUtils.java#L26-L38&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/groovy/blob/14266ad5b7c265b55334c029e87b1d79ebd2210e/src/main/org/codehaus/groovy/ast/tools/ParameterUtils.java#L26-L38&lt;/a&gt;) instead of this new method.&lt;/p&gt;</comment>
                            <comment id="15497886" author="githubbot" created="Sat, 17 Sep 2016 01:06:30 +0000"  >&lt;p&gt;Github user blindpirate commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/groovy/pull/422#discussion_r79272298&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/groovy/pull/422#discussion_r79272298&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java &amp;#8212;&lt;br/&gt;
    @@ -1157,6 +1141,56 @@ private static ClassNode makeRawType(final ClassNode receiver) &lt;/p&gt;
{
             return result;
         }

&lt;p&gt;    +    private static void removeMethodInSuperInterface(List&amp;lt;MethodNode&amp;gt; toBeRemoved, MethodNode one, MethodNode two) {&lt;br/&gt;
    +        ClassNode oneDC=one.getDeclaringClass();&lt;br/&gt;
    +        ClassNode twoDC=two.getDeclaringClass();&lt;br/&gt;
    +        if(oneDC.implementsInterface(twoDC))&lt;/p&gt;
{
    +            toBeRemoved.add(two);
    +        }else{
    +            toBeRemoved.add(one);
    +        }&lt;br/&gt;
    +    }&lt;br/&gt;
    +&lt;br/&gt;
    +    private static boolean areEquivalentInterfaceMethods(MethodNode one, MethodNode two, Parameter[] onePars, Parameter[] twoPars) {
    +        return one.getName().equals(two.getName())
    +                &amp;amp;&amp;amp; one.getDeclaringClass().isInterface()
    +                &amp;amp;&amp;amp; two.getDeclaringClass().isInterface()
    +                &amp;amp;&amp;amp; allParameterTypesAreSame(onePars, twoPars);
    +    }&lt;br/&gt;
    +&lt;br/&gt;
    +    private static void removeSyntheticMethodIfOne(List&amp;lt;MethodNode&amp;gt; toBeRemoved, MethodNode one, MethodNode two) {&lt;br/&gt;
    +        if (one.isSynthetic() &amp;amp;&amp;amp; !two.isSynthetic()) {    +            toBeRemoved.add(one);    +        } else if (two.isSynthetic() &amp;amp;&amp;amp; !one.isSynthetic()) {    +            toBeRemoved.add(two);    +        }
&lt;p&gt;    +    }&lt;br/&gt;
    +&lt;br/&gt;
    +    private static void removeMethodWithSuperReturnType(List&amp;lt;MethodNode&amp;gt; toBeRemoved, MethodNode one, MethodNode two) {&lt;br/&gt;
    +        ClassNode oneRT = one.getReturnType();&lt;br/&gt;
    +        ClassNode twoRT = two.getReturnType();&lt;br/&gt;
    +        if (oneRT.isDerivedFrom(twoRT) || oneRT.implementsInterface(twoRT)) &lt;/p&gt;
{
    +            toBeRemoved.add(two);
    +        }
&lt;p&gt; else if (twoRT.isDerivedFrom(oneRT) || twoRT.implementsInterface(oneRT)) &lt;/p&gt;
{
    +            toBeRemoved.add(one);
    +        }
&lt;p&gt;    +    }&lt;br/&gt;
    +&lt;br/&gt;
    +    private static boolean areOverloadMethodsInSameClass(MethodNode one, MethodNode two)&lt;/p&gt;
{
    +        return one.getName().equals(two.getName()) &amp;amp;&amp;amp; one.getDeclaringClass()==two.getDeclaringClass();
    +    }
&lt;p&gt;    +&lt;br/&gt;
    +    private static boolean allParameterTypesAreSame(Parameter[] onePars, Parameter[] twoPars) {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Oh, you&apos;re right. I will use this method instead.&lt;/p&gt;</comment>
                            <comment id="15499259" author="githubbot" created="Sat, 17 Sep 2016 16:03:32 +0000"  >&lt;p&gt;Github user blackdrag commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/groovy/pull/422#discussion_r79286871&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/groovy/pull/422#discussion_r79286871&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java &amp;#8212;&lt;br/&gt;
    @@ -1157,6 +1141,56 @@ private static ClassNode makeRawType(final ClassNode receiver) &lt;/p&gt;
{
             return result;
         }

&lt;p&gt;    +    private static void removeMethodInSuperInterface(List&amp;lt;MethodNode&amp;gt; toBeRemoved, MethodNode one, MethodNode two) {&lt;br/&gt;
    +        ClassNode oneDC=one.getDeclaringClass();&lt;br/&gt;
    +        ClassNode twoDC=two.getDeclaringClass();&lt;br/&gt;
    +        if(oneDC.implementsInterface(twoDC))&lt;/p&gt;
{
    +            toBeRemoved.add(two);
    +        }else{
    +            toBeRemoved.add(one);
    +        }&lt;br/&gt;
    +    }&lt;br/&gt;
    +&lt;br/&gt;
    +    private static boolean areEquivalentInterfaceMethods(MethodNode one, MethodNode two, Parameter[] onePars, Parameter[] twoPars) {
    +        return one.getName().equals(two.getName())
    +                &amp;amp;&amp;amp; one.getDeclaringClass().isInterface()
    +                &amp;amp;&amp;amp; two.getDeclaringClass().isInterface()
    +                &amp;amp;&amp;amp; allParameterTypesAreSame(onePars, twoPars);
    +    }&lt;br/&gt;
    +&lt;br/&gt;
    +    private static void removeSyntheticMethodIfOne(List&amp;lt;MethodNode&amp;gt; toBeRemoved, MethodNode one, MethodNode two) {&lt;br/&gt;
    +        if (one.isSynthetic() &amp;amp;&amp;amp; !two.isSynthetic()) {    +            toBeRemoved.add(one);    +        } else if (two.isSynthetic() &amp;amp;&amp;amp; !one.isSynthetic()) {    +            toBeRemoved.add(two);    +        }
&lt;p&gt;    +    }&lt;br/&gt;
    +&lt;br/&gt;
    +    private static void removeMethodWithSuperReturnType(List&amp;lt;MethodNode&amp;gt; toBeRemoved, MethodNode one, MethodNode two) {&lt;br/&gt;
    +        ClassNode oneRT = one.getReturnType();&lt;br/&gt;
    +        ClassNode twoRT = two.getReturnType();&lt;br/&gt;
    +        if (oneRT.isDerivedFrom(twoRT) || oneRT.implementsInterface(twoRT)) &lt;/p&gt;
{
    +            toBeRemoved.add(two);
    +        }
&lt;p&gt; else if (twoRT.isDerivedFrom(oneRT) || twoRT.implementsInterface(oneRT)) &lt;/p&gt;
{
    +            toBeRemoved.add(one);
    +        }
&lt;p&gt;    +    }&lt;br/&gt;
    +&lt;br/&gt;
    +    private static boolean areOverloadMethodsInSameClass(MethodNode one, MethodNode two)&lt;/p&gt;
{
    +        return one.getName().equals(two.getName()) &amp;amp;&amp;amp; one.getDeclaringClass()==two.getDeclaringClass();
    +    }
&lt;p&gt;    +&lt;br/&gt;
    +    private static boolean allParameterTypesAreSame(Parameter[] onePars, Parameter[] twoPars) {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    I think I can +1 it after the change John suggested&lt;/p&gt;</comment>
                            <comment id="15500311" author="githubbot" created="Sun, 18 Sep 2016 05:30:12 +0000"  >&lt;p&gt;Github user jwagenleitner commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/groovy/pull/422#discussion_r79297750&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/groovy/pull/422#discussion_r79297750&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java &amp;#8212;&lt;br/&gt;
    @@ -1157,6 +1142,45 @@ private static ClassNode makeRawType(final ClassNode receiver) &lt;/p&gt;
{
             return result;
         }

&lt;p&gt;    +    private static void removeMethodInSuperInterface(List&amp;lt;MethodNode&amp;gt; toBeRemoved, MethodNode one, MethodNode two) {&lt;br/&gt;
    +        ClassNode oneDC=one.getDeclaringClass();&lt;br/&gt;
    +        ClassNode twoDC=two.getDeclaringClass();&lt;br/&gt;
    +        if(oneDC.implementsInterface(twoDC))&lt;/p&gt;
{
    +            toBeRemoved.add(two);
    +        }
&lt;p&gt;else&lt;/p&gt;
{
    +            toBeRemoved.add(one);
    +        }
&lt;p&gt;    +    }&lt;br/&gt;
    +&lt;br/&gt;
    +    private static boolean areEquivalentInterfaceMethods(MethodNode one, MethodNode two, Parameter[] onePars, Parameter[] twoPars) {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    I think it would simplify things if this just took 2 MethodNode&apos;s, the parameters can be gotten from the nodes so no need to pass them in I think?&lt;/p&gt;</comment>
                            <comment id="15500312" author="githubbot" created="Sun, 18 Sep 2016 05:30:12 +0000"  >&lt;p&gt;Github user jwagenleitner commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/groovy/pull/422#discussion_r79297788&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/groovy/pull/422#discussion_r79297788&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java &amp;#8212;&lt;br/&gt;
    @@ -1116,39 +1117,23 @@ private static ClassNode makeRawType(final ClassNode receiver) {&lt;br/&gt;
                 for (int j=i+1;j&amp;lt;list.size();j++) {&lt;br/&gt;
                     MethodNode two = list.get(j);&lt;br/&gt;
                     if (toBeRemoved.contains(two)) continue;&lt;/p&gt;
&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
	&lt;li&gt;if (one.getName().equals(two.getName()) &amp;amp;&amp;amp; one.getDeclaringClass()==two.getDeclaringClass()) {&lt;/li&gt;
	&lt;li&gt;Parameter[] onePars = one.getParameters();&lt;/li&gt;
	&lt;li&gt;Parameter[] twoPars = two.getParameters();&lt;/li&gt;
	&lt;li&gt;if (onePars.length == twoPars.length) {&lt;/li&gt;
	&lt;li&gt;boolean sameTypes = true;&lt;/li&gt;
	&lt;li&gt;for (int k = 0; k &amp;lt; onePars.length; k++) {&lt;/li&gt;
	&lt;li&gt;Parameter onePar = onePars&lt;span class=&quot;error&quot;&gt;&amp;#91;k&amp;#93;&lt;/span&gt;;&lt;/li&gt;
	&lt;li&gt;Parameter twoPar = twoPars&lt;span class=&quot;error&quot;&gt;&amp;#91;k&amp;#93;&lt;/span&gt;;&lt;/li&gt;
	&lt;li&gt;if (!onePar.getType().equals(twoPar.getType())) 
{
    -                                sameTypes = false;
    -                                break;
    -                            }&lt;/li&gt;
	&lt;li&gt;}&lt;/li&gt;
	&lt;li&gt;if (sameTypes) {&lt;/li&gt;
	&lt;li&gt;ClassNode oneRT = one.getReturnType();&lt;/li&gt;
	&lt;li&gt;ClassNode twoRT = two.getReturnType();&lt;/li&gt;
	&lt;li&gt;if (oneRT.isDerivedFrom(twoRT) || oneRT.implementsInterface(twoRT)) 
{
    -                                toBeRemoved.add(two);
    -                            }
&lt;p&gt; else if (twoRT.isDerivedFrom(oneRT) || twoRT.implementsInterface(oneRT)) &lt;/p&gt;
{
    -                                toBeRemoved.add(one);
    -                            }
&lt;p&gt;    +                Parameter[] onePars = one.getParameters();&lt;br/&gt;
    +                Parameter[] twoPars = two.getParameters();&lt;br/&gt;
    +                if (onePars.length == twoPars.length) {&lt;br/&gt;
    +                    if (areOverloadMethodsInSameClass(one,two)) {&lt;br/&gt;
    +                        if (ParameterUtils.parametersEqual(onePars, twoPars)){&lt;/p&gt;
	&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
		&lt;li&gt;
		&lt;ul class=&quot;alternate&quot; type=&quot;square&quot;&gt;
			&lt;li&gt;End diff &amp;#8211;&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;    If the `Parameter[]` parameters are removed from `areEquivalentInterfaceMethods` method I think these arguments can be replaced with `one.getParameters(), two.getParameters()` and then the local variables wouldn&apos;t be needed.  Just a suggestion.&lt;/p&gt;</comment>
                            <comment id="15500423" author="githubbot" created="Sun, 18 Sep 2016 06:52:52 +0000"  >&lt;p&gt;Github user blindpirate commented on a diff in the pull request:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/groovy/pull/422#discussion_r79298948&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/groovy/pull/422#discussion_r79298948&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &amp;#8212; Diff: src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java &amp;#8212;&lt;br/&gt;
    @@ -1157,6 +1142,45 @@ private static ClassNode makeRawType(final ClassNode receiver) &lt;/p&gt;
{
             return result;
         }

&lt;p&gt;    +    private static void removeMethodInSuperInterface(List&amp;lt;MethodNode&amp;gt; toBeRemoved, MethodNode one, MethodNode two) {&lt;br/&gt;
    +        ClassNode oneDC=one.getDeclaringClass();&lt;br/&gt;
    +        ClassNode twoDC=two.getDeclaringClass();&lt;br/&gt;
    +        if(oneDC.implementsInterface(twoDC))&lt;/p&gt;
{
    +            toBeRemoved.add(two);
    +        }
&lt;p&gt;else&lt;/p&gt;
{
    +            toBeRemoved.add(one);
    +        }
&lt;p&gt;    +    }&lt;br/&gt;
    +&lt;br/&gt;
    +    private static boolean areEquivalentInterfaceMethods(MethodNode one, MethodNode two, Parameter[] onePars, Parameter[] twoPars) {&lt;br/&gt;
    &amp;#8212; End diff &amp;#8211;&lt;/p&gt;

&lt;p&gt;    Yes, good suggestion. I will do that.&lt;/p&gt;</comment>
                            <comment id="15505449" author="githubbot" created="Tue, 20 Sep 2016 03:26:01 +0000"  >&lt;p&gt;Github user asfgit closed the pull request at:&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;https://github.com/apache/groovy/pull/422&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/groovy/pull/422&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="15505457" author="jwagenleitner" created="Tue, 20 Sep 2016 03:32:22 +0000"  >&lt;p&gt;Proposed PR merged.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            9 years, 9 weeks ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i32y4f:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </customfields>
    </item>
</channel>
</rss>