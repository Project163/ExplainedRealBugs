<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Wed Nov 12 01:20:05 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[GROOVY-8788] Inconsistency in extension method selection with @CompileStatic</title>
                <link>https://issues.apache.org/jira/browse/GROOVY-8788</link>
                <project id="12318123" key="GROOVY">Groovy</project>
                    <description>&lt;p&gt;Given properly registered extension class:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeHeader panelHeader&quot; style=&quot;border-bottom-width: 1px;&quot;&gt;&lt;b&gt;MyExtensions.java&lt;/b&gt;&lt;/div&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;MyExtensions {

    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; void foo(&lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; self, &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; s) {
        &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.println(&lt;span class=&quot;code-quote&quot;&gt;&quot;&lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;#foo(&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;)&quot;&lt;/span&gt;);
    }

    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; void foo(&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; self, &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; o) {
        &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.println(&lt;span class=&quot;code-quote&quot;&gt;&quot;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;#foo(&lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;)&quot;&lt;/span&gt;);
    }
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Run&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeHeader panelHeader&quot; style=&quot;border-bottom-width: 1px;&quot;&gt;&lt;b&gt;playground.groovy&lt;/b&gt;&lt;/div&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
void usageExt() {
    &lt;span class=&quot;code-quote&quot;&gt;&quot;&quot;.foo(&quot;&lt;/span&gt;&lt;span class=&quot;code-quote&quot;&gt;&quot;) &lt;span class=&quot;code-comment&quot;&gt;// prints &quot;&lt;/span&gt;&lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;#foo(&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;)&quot; which is correct
&lt;/span&gt;}

@groovy.transform.CompileStatic
void usageExtStatic() {
    &lt;span class=&quot;code-quote&quot;&gt;&quot;&quot;.foo(&quot;&lt;/span&gt;&lt;span class=&quot;code-quote&quot;&gt;&quot;) &lt;span class=&quot;code-comment&quot;&gt;// prints &quot;&lt;/span&gt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;#foo(&lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;)&quot; which is questionable
&lt;/span&gt;}

usageExt()
usageExtStatic()
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</description>
                <environment></environment>
        <key id="13184876">GROOVY-8788</key>
            <summary>Inconsistency in extension method selection with @CompileStatic</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="emilles">Eric Milles</assignee>
                                    <reporter username="daniilo">Daniil Ovchinnikov</reporter>
                        <labels>
                            <label>breaking</label>
                    </labels>
                <created>Thu, 13 Sep 2018 11:58:24 +0000</created>
                <updated>Wed, 23 Aug 2023 09:11:21 +0000</updated>
                            <resolved>Tue, 23 Aug 2022 20:50:20 +0000</resolved>
                                    <version>2.4.15</version>
                    <version>2.5.2</version>
                                    <fixVersion>5.0.0-alpha-1</fixVersion>
                                    <component>Static compilation</component>
                    <component>Static Type Checker</component>
                        <due></due>
                            <votes>1</votes>
                                    <watches>4</watches>
                                                                                                                <comments>
                            <comment id="16613377" author="daniilo" created="Thu, 13 Sep 2018 11:59:08 +0000"  >&lt;p&gt;Possibly the same cause.&lt;/p&gt;</comment>
                            <comment id="17580951" author="emilles" created="Wed, 17 Aug 2022 19:01:15 +0000"  >&lt;p&gt;I can fix this by updating &lt;tt&gt;StaticTypeCheckingSupport#chooseBestMethod&lt;/tt&gt; (see below).  There are a number of cases that stretch intuition and may result in breaking existing code.  In both cases the method on the left is chosen by the static compiler and the method on the right is chosen by the dynamic runtime and the new static compiler (with updated chooseBestMethod).&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-groovy&quot;&gt;
@groovy.transform.CompileStatic void test(Set one, Set two) {
  one.intersect(two) &lt;span class=&quot;code-comment&quot;&gt;// Set#intersect(Iterable) vs. Collection#intersect(Collection)
&lt;/span&gt;}
@groovy.transform.CompileStatic void test(Map&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;,&lt;span class=&quot;code-object&quot;&gt;Number&lt;/span&gt;&amp;gt; map, &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; key) {
  &lt;span class=&quot;code-object&quot;&gt;Number&lt;/span&gt; num = map[key] &lt;span class=&quot;code-comment&quot;&gt;// Map#getAt(&lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;) vs. &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;#getAt(&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;)
&lt;/span&gt;}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The dynamic runtime has preference for parameter matching and the static compiler prefers receiver matching.  This is the source of the problem described in the original post.  Changing this preference will bring closer alignment for the two modes but has some consequences.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=paulk&quot; class=&quot;user-hover&quot; rel=&quot;paulk&quot;&gt;paulk&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=blackdrag&quot; class=&quot;user-hover&quot; rel=&quot;blackdrag&quot;&gt;blackdrag&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
    /**
     * Returns the method(s) which best fit the argument types.
     *
     * @&lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; zero or more results
     */
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; List&amp;lt;MethodNode&amp;gt; chooseBestMethod(&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; ClassNode receiver, &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; Collection&amp;lt;MethodNode&amp;gt; methods, &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; ClassNode... argumentTypes) {
        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!asBoolean(methods)) {
            &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; Collections.emptyList();
        }

        &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; bestDist = &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;.MAX_VALUE;
        List&amp;lt;MethodNode&amp;gt; bestChoices = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;();
        &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; noCulling = methods.size() &amp;lt;= 1 || &lt;span class=&quot;code-quote&quot;&gt;&quot;&amp;lt;init&amp;gt;&quot;&lt;/span&gt;.equals(methods.iterator().next().getName());
        Iterable&amp;lt;MethodNode&amp;gt; candidates = noCulling ? methods : removeCovariantsAndInterfaceEquivalents(methods);

        &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (MethodNode candidate : candidates) {
            MethodNode safeNode = candidate;
            ClassNode[] safeArgs = argumentTypes;
            &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; isExtensionMethod = candidate &lt;span class=&quot;code-keyword&quot;&gt;instanceof&lt;/span&gt; ExtensionMethodNode;
            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (isExtensionMethod) {
                &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; nArgs = argumentTypes.length;
                safeArgs = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; ClassNode[nArgs + 1];
                &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.arraycopy(argumentTypes, 0, safeArgs, 1, nArgs);
                safeArgs[0] = receiver; &lt;span class=&quot;code-comment&quot;&gt;// prepend self-type as first argument
&lt;/span&gt;                safeNode = ((ExtensionMethodNode) candidate).getExtensionMethodNode();
            }

            /* TODO: corner &lt;span class=&quot;code-keyword&quot;&gt;case&lt;/span&gt;
                &lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;B &lt;span class=&quot;code-keyword&quot;&gt;extends&lt;/span&gt; A {}
                Animal foo(A a) {}
                Person foo(B b) {}

                B b = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; B()
                Person p = foo(b)
            */

            ClassNode declaringClass = candidate.getDeclaringClass();
            ClassNode actualReceiver = receiver != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; ? receiver : declaringClass;

            Map&amp;lt;GenericsType, GenericsType&amp;gt; spec;
            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;code-comment&quot;&gt;/*!isExtensionMethod &amp;amp;&amp;amp; */&lt;/span&gt;candidate.isStatic()) {
                spec = Collections.emptyMap(); &lt;span class=&quot;code-comment&quot;&gt;// none visible
&lt;/span&gt;            } &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; {
                spec = GenericsUtils.makeDeclaringAndActualGenericsTypeMapOfExactType(declaringClass, actualReceiver);
                GenericsType[] methodGenerics = candidate.getGenericsTypes();
                &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;code-comment&quot;&gt;/*!isExtensionMethod &amp;amp;&amp;amp; */&lt;/span&gt;methodGenerics != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) { &lt;span class=&quot;code-comment&quot;&gt;// GROOVY-10322: remove hidden type parameters
&lt;/span&gt;                    &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; i = 0, n = methodGenerics.length; i &amp;lt; n &amp;amp;&amp;amp; !spec.isEmpty(); i += 1) {
                        &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (Iterator&amp;lt;GenericsType&amp;gt; it = spec.keySet().iterator(); it.hasNext(); ) {
                            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (it.next().getName().equals(methodGenerics[i].getName())) it.remove();
                        }
                    }
                }
            }

            Parameter[] params = makeRawTypes(safeNode.getParameters(), spec);
            &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; dist = measureParametersAndArgumentsDistance(params, safeArgs);
            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (dist &amp;gt;= 0) {
                &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!isExtensionMethod) { &lt;span class=&quot;code-comment&quot;&gt;// GROOVY-6849, GROOVY-8788, et al.
&lt;/span&gt;                    dist += (1 + getClassDistance(declaringClass, actualReceiver));
                }
                &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (dist &amp;lt; bestDist) {
                    bestDist = dist;
                    bestChoices.clear();
                    bestChoices.add(candidate);
                } &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (dist == bestDist) {
                    bestChoices.add(candidate);
                }
            }
        }
        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (bestChoices.size() &amp;gt; 1) {
            &lt;span class=&quot;code-comment&quot;&gt;// GROOVY-6849: prefer extension method in &lt;span class=&quot;code-keyword&quot;&gt;case&lt;/span&gt; of ambiguity
&lt;/span&gt;            List&amp;lt;MethodNode&amp;gt; onlyExtensionMethods = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;();
            &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (MethodNode choice : bestChoices) {
                &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (choice &lt;span class=&quot;code-keyword&quot;&gt;instanceof&lt;/span&gt; ExtensionMethodNode) {
                    onlyExtensionMethods.add(choice);
                }
            }
            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (onlyExtensionMethods.size() &amp;gt; 1) {
                &lt;span class=&quot;code-comment&quot;&gt;// GROOVY-8788: prefer closer parameter match over closer self-type match
&lt;/span&gt;                bestDist = &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;.MAX_VALUE; List&amp;lt;MethodNode&amp;gt; bestExtensions = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;();
                &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (MethodNode extension : onlyExtensionMethods) { &lt;span class=&quot;code-comment&quot;&gt;// exclude self-type from distance checking
&lt;/span&gt;                    &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; dist = measureParametersAndArgumentsDistance(extension.getParameters(), argumentTypes);
                    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (dist &amp;lt; bestDist) {
                        bestDist = dist;
                        bestExtensions.clear();
                        bestExtensions.add(extension);
                    } &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (dist == bestDist) {
                        bestExtensions.add(extension);
                    }
                }
                onlyExtensionMethods = bestExtensions;
            }
            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (onlyExtensionMethods.size() == 1) {
                &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; onlyExtensionMethods;
            }
        }
        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; bestChoices;
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="17580956" author="emilles" created="Wed, 17 Aug 2022 19:10:16 +0000"  >&lt;p&gt;One thing that would reduce the impact of this change is to add &lt;tt&gt;getAt(Map,String)&lt;/tt&gt; extension method to step in front of &lt;tt&gt;getAt(Object,String)&lt;/tt&gt;.&lt;/p&gt;</comment>
                            <comment id="17580975" author="githubbot" created="Wed, 17 Aug 2022 19:54:19 +0000"  >&lt;p&gt;eric-milles opened a new pull request, #1766:&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/groovy/pull/1766&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/groovy/pull/1766&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;   Given choice between extension methods `m(String,Object)` and `m(Object,String)`, prefer closer parameter matching.  This aligns with the method selection of the dynamic runtime.  So there are some edge cases that were giving false STC errors or missing them.&lt;/p&gt;

&lt;p&gt;   This is a breaking change!  `getAt(Map,String)` was added to prevent STC errors for `Type obj = map&lt;span class=&quot;error&quot;&gt;&amp;#91;str&amp;#93;&lt;/span&gt;` expressions.&lt;/p&gt;

&lt;p&gt;   &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-8788&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/GROOVY-8788&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;   &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-6504&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/GROOVY-6504&lt;/a&gt;&lt;br/&gt;
   &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-6849&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/GROOVY-6849&lt;/a&gt;&lt;br/&gt;
   &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-6970&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/GROOVY-6970&lt;/a&gt;&lt;br/&gt;
   &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-8787&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/GROOVY-8787&lt;/a&gt;&lt;br/&gt;
   &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-9069&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/GROOVY-9069&lt;/a&gt;&lt;br/&gt;
   &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-9420&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/GROOVY-9420&lt;/a&gt;&lt;/p&gt;

</comment>
                            <comment id="17581022" author="githubbot" created="Wed, 17 Aug 2022 20:54:59 +0000"  >&lt;p&gt;sonatype-lift&lt;span class=&quot;error&quot;&gt;&amp;#91;bot&amp;#93;&lt;/span&gt; commented on code in PR #1766:&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/groovy/pull/1766#discussion_r948409220&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/groovy/pull/1766#discussion_r948409220&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;##########&lt;br/&gt;
src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java:&lt;br/&gt;
##########&lt;br/&gt;
@@ -1103,6 +1104,21 @@ Person foo(B b) {}&lt;br/&gt;
                     onlyExtensionMethods.add(choice);&lt;br/&gt;
                 }&lt;br/&gt;
             }&lt;br/&gt;
+            if (onlyExtensionMethods.size() &amp;gt; 1) {&lt;br/&gt;
+                // &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-8788&quot; title=&quot;Inconsistency in extension method selection with @CompileStatic&quot; class=&quot;issue-link&quot; data-issue-key=&quot;GROOVY-8788&quot;&gt;&lt;del&gt;GROOVY-8788&lt;/del&gt;&lt;/a&gt;: prefer closer parameter match over closer self-type match&lt;br/&gt;
+                bestDist = Integer.MAX_VALUE; List&amp;lt;MethodNode&amp;gt; bestExtensions = new LinkedList&amp;lt;&amp;gt;();&lt;/p&gt;

&lt;p&gt;Review Comment:&lt;br/&gt;
   *&lt;span class=&quot;error&quot;&gt;&amp;#91;JdkObsolete&amp;#93;&lt;/span&gt;(&lt;a href=&quot;https://errorprone.info/bugpattern/JdkObsolete):*&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://errorprone.info/bugpattern/JdkObsolete):*&lt;/a&gt;  It is very rare for LinkedList to out-perform ArrayList or ArrayDeque. Avoid it unless you&apos;re willing to invest a lot of time into benchmarking. Caveat: LinkedList supports null elements, but ArrayDeque does not.&lt;/p&gt;

&lt;p&gt;   &amp;#8212;&lt;/p&gt;


&lt;p&gt;   ```suggestion&lt;br/&gt;
                   bestDist = Integer.MAX_VALUE; List&amp;lt;MethodNode&amp;gt; bestExtensions = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;
   ```&lt;/p&gt;



&lt;p&gt;   &amp;#8212;&lt;/p&gt;

&lt;p&gt;   Reply with &lt;b&gt;&quot;&lt;/b&gt;&lt;b&gt;@sonatype-lift help&lt;/b&gt;&lt;b&gt;&quot;&lt;/b&gt; for info about LiftBot commands.&lt;br/&gt;
   Reply with &lt;b&gt;&quot;&lt;/b&gt;&lt;b&gt;@sonatype-lift ignore&lt;/b&gt;&lt;b&gt;&quot;&lt;/b&gt; to tell LiftBot to leave out the above finding from this PR.&lt;br/&gt;
   Reply with &lt;b&gt;&quot;&lt;/b&gt;&lt;b&gt;@sonatype-lift ignoreall&lt;/b&gt;&lt;b&gt;&quot;&lt;/b&gt; to tell LiftBot to leave out all the findings from this PR and from the status bar in Github.&lt;/p&gt;

&lt;p&gt;   When talking to LiftBot, you need to *&lt;b&gt;refresh&lt;/b&gt;* the page to see its response. &lt;span class=&quot;error&quot;&gt;&amp;#91;Click here&amp;#93;&lt;/span&gt;(&lt;a href=&quot;https://help.sonatype.com/lift/talking-to-lift&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://help.sonatype.com/lift/talking-to-lift&lt;/a&gt;) to get to know more about LiftBot commands.&lt;/p&gt;

&lt;p&gt;   &amp;#8212;&lt;/p&gt;

&lt;p&gt;   Was this a good recommendation?&lt;br/&gt;
   [ &lt;span class=&quot;error&quot;&gt;&amp;#91;&#128577; Not relevant&amp;#93;&lt;/span&gt;(&lt;a href=&quot;https://www.sonatype.com/lift-comment-rating?comment=317131720&amp;amp;lift_comment_rating=1&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://www.sonatype.com/lift-comment-rating?comment=317131720&amp;amp;lift_comment_rating=1&lt;/a&gt;) ] - [ &lt;span class=&quot;error&quot;&gt;&amp;#91;&#128533; Won&amp;#39;t fix&amp;#93;&lt;/span&gt;(&lt;a href=&quot;https://www.sonatype.com/lift-comment-rating?comment=317131720&amp;amp;lift_comment_rating=2&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://www.sonatype.com/lift-comment-rating?comment=317131720&amp;amp;lift_comment_rating=2&lt;/a&gt;) ] - [ &lt;span class=&quot;error&quot;&gt;&amp;#91;&#128529; Not critical, will fix&amp;#93;&lt;/span&gt;(&lt;a href=&quot;https://www.sonatype.com/lift-comment-rating?comment=317131720&amp;amp;lift_comment_rating=3&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://www.sonatype.com/lift-comment-rating?comment=317131720&amp;amp;lift_comment_rating=3&lt;/a&gt;) ] - [ &lt;span class=&quot;error&quot;&gt;&amp;#91;&#128578; Critical, will fix&amp;#93;&lt;/span&gt;(&lt;a href=&quot;https://www.sonatype.com/lift-comment-rating?comment=317131720&amp;amp;lift_comment_rating=4&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://www.sonatype.com/lift-comment-rating?comment=317131720&amp;amp;lift_comment_rating=4&lt;/a&gt;) ] - [ &lt;span class=&quot;error&quot;&gt;&amp;#91;&#128522; Critical, fixing now&amp;#93;&lt;/span&gt;(&lt;a href=&quot;https://www.sonatype.com/lift-comment-rating?comment=317131720&amp;amp;lift_comment_rating=5&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://www.sonatype.com/lift-comment-rating?comment=317131720&amp;amp;lift_comment_rating=5&lt;/a&gt;) ]&lt;/p&gt;


</comment>
                            <comment id="17581448" author="githubbot" created="Thu, 18 Aug 2022 17:16:09 +0000"  >&lt;p&gt;eric-milles commented on PR #1766:&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/groovy/pull/1766#issuecomment-1219738720&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/groovy/pull/1766#issuecomment-1219738720&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;   With the addition of `getAt(Map,String)` a small change in `StaticTypeCheckingSupport#getDistance` can resolve the `map&lt;span class=&quot;error&quot;&gt;&amp;#91;&amp;quot;$key&amp;quot;&amp;#93;&lt;/span&gt;` issues.  I know Cedric stated in 6668 that this should be an STC error, but if there is just one method and it accepts String, it will be chosen for a GString argument.  This changes just closes the distance between GString and String so that `m(String)` is selected over `m(Object)`.&lt;/p&gt;

&lt;p&gt;   &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-6668&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/GROOVY-6668&lt;/a&gt;&lt;br/&gt;
   &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-8212&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/GROOVY-8212&lt;/a&gt;&lt;/p&gt;

</comment>
                            <comment id="17581698" author="githubbot" created="Fri, 19 Aug 2022 07:17:34 +0000"  >&lt;p&gt;daniellansun commented on PR #1766:&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/groovy/pull/1766#issuecomment-1220335936&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/groovy/pull/1766#issuecomment-1220335936&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;   I am keen to vote +1&lt;/p&gt;


</comment>
                            <comment id="17581874" author="blackdrag" created="Fri, 19 Aug 2022 14:02:35 +0000"  >&lt;p&gt;From the comments I am not sure the fix goes in the right direction - of course I could be totally wrong here.&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;A {
  def m(o){1}
}
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;B &lt;span class=&quot;code-keyword&quot;&gt;extends&lt;/span&gt; A {
  def m(&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; s) {2}
}
def a = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; A()
&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; a.m(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;())  == 1
def b = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; B()
&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; b.m(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;()) == 1
&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; b.m(&quot;&quot;) == 2
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;in this case it is obvious that the assert should be fulfilled this way. Extension methods are kind of overlays for the class.&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;MExt {
  &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; m(A self, &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; s) {1}
  &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; m(B self, &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; o) {2}
}

&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;A {}
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;B &lt;span class=&quot;code-keyword&quot;&gt;extends&lt;/span&gt; A {}

@groovy.transform.CompileStatic
void usageExtStatic() {
  def b = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; B()
  &lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; b.m(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;()) == 2
  &lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; b.m(&quot;&quot;) == 1
}
usageExtStatic()
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;m(Object) is to be seen as if it is a method of B. m(String) is to be seen as if a method of A. Since B extends A and since B does not define a new m(String), the extension method for A has to be chosen here.&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;MExt {
  &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; m(A self, &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; s) {1}
  &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; m(B self, &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; o) {2}
}

&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;A {}
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;B &lt;span class=&quot;code-keyword&quot;&gt;extends&lt;/span&gt; A {
  def m(&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; s){3}
}

@groovy.transform.CompileStatic
void usageExtStatic() {
  def b = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; B()
  &lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; b.m(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;()) == 2
  &lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; b.m(&quot;&quot;) == 3
}
usageExtStatic()
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;In this case m(String) exists on A as extension method, but B defined its own m(String), which &quot;overwrites&quot; m(String) from A. Neither overwrite nor overload are the right terms for this I guess.&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;MExt {
  &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; m(A self, &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; s) {1} 
  &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; m(B self, &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; o) {2}
}
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;A {
  def m(&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; s){4}
}
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;B &lt;span class=&quot;code-keyword&quot;&gt;extends&lt;/span&gt; A {}
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;C &lt;span class=&quot;code-keyword&quot;&gt;extends&lt;/span&gt; B {}

@groovy.transform.CompileStatic
void usageExtStatic() {
  def b = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; B()
  &lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; b.m(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;()) == 2
  &lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; b.m(&quot;&quot;) == 1
  def c = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; C()
  &lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; c.m(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;()) == 2
  &lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; c.m(&quot;&quot;) == 1
} 
usageExtStatic()&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here, even though A defines m(String), the extension method &quot;shadows&quot; it and inherits it to B. For C again it is the extension methods only.&lt;/p&gt;

&lt;p&gt;I know very long comment, but well... the above was for the issue described here, to show how it is supposed to work - and does in the dynamic case. The fix though involves getAt(Map,String) and GString:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;Container {
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; someObject = &quot;&quot;
  &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; toString(){ &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-quote&quot;&gt;&quot;Container_&quot;&lt;/span&gt; +someObject}
  &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; hashCode() { &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; 42 + someObject.hashCode() }
  &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; equals(o) {
     &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; o!=&lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; o.class==Container &amp;amp;&amp;amp; o.someObject == someObject
  }
  void newObject(o) {&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.someObject = o}
}
def m = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; HashMap()
def container = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Container(someObject: &lt;span class=&quot;code-quote&quot;&gt;&quot;1&quot;&lt;/span&gt;)
m.put(container, 1)
&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; m.get(container) == 1
container.newObject(&lt;span class=&quot;code-quote&quot;&gt;&quot;2&quot;&lt;/span&gt;)
&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; m.get(container) == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Here the second get fails even though container itself did not change really. But since the contained Object did, you cannot access the map value using that same reference. This is given by Java.&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;Container {
  &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; someObject = &quot;&quot;
  &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; toString(){ &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-quote&quot;&gt;&quot;Container_&quot;&lt;/span&gt; +someObject}
  &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; hashCode() { &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; 42 + someObject.hashCode() }
  &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; equals(o) {
     &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; o!=&lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; o.class==Container &amp;amp;&amp;amp; o.someObject == someObject
  }
  void newObject(o) {&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;.someObject = o}
}
def m = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; HashMap()
def container = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Container(someObject: &lt;span class=&quot;code-quote&quot;&gt;&quot;1&quot;&lt;/span&gt;)
m.put(&lt;span class=&quot;code-quote&quot;&gt;&quot;$container&quot;&lt;/span&gt;, 1)
&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; m.get(&lt;span class=&quot;code-quote&quot;&gt;&quot;$container&quot;&lt;/span&gt;) == 1
container.newObject(&lt;span class=&quot;code-quote&quot;&gt;&quot;2&quot;&lt;/span&gt;)
&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; m.get(&lt;span class=&quot;code-quote&quot;&gt;&quot;$container&quot;&lt;/span&gt;) == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;In this version it is a similar situation to before, the only change is that we create now a ton of GString objects. GString though has the same problem that Container has, hashcode and equals depend on the contained object, which is subject to change. Examples are GStrings made from Closures and GStrings made of containers like here. the more idiomatic usage would be:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-comment&quot;&gt;// Container like before
&lt;/span&gt;def m = [:]
def container = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Container(someObject: &lt;span class=&quot;code-quote&quot;&gt;&quot;1&quot;&lt;/span&gt;)
m[&lt;span class=&quot;code-quote&quot;&gt;&quot;$container&quot;&lt;/span&gt;] = 1  &lt;span class=&quot;code-comment&quot;&gt;//putAt
&lt;/span&gt;&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; m[&lt;span class=&quot;code-quote&quot;&gt;&quot;$container&quot;&lt;/span&gt;] == 1  &lt;span class=&quot;code-comment&quot;&gt;//getAt
&lt;/span&gt;container.newObject(&lt;span class=&quot;code-quote&quot;&gt;&quot;2&quot;&lt;/span&gt;)
&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; m[&lt;span class=&quot;code-quote&quot;&gt;&quot;$container&quot;&lt;/span&gt;] == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;  &lt;span class=&quot;code-comment&quot;&gt;//getAt&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This proofed to be difficult to understand for the people, which is why we said we do not allow that for the static compiler.&lt;/p&gt;

&lt;p&gt;I noticed you added getAt(Map,String), to allow assert map&lt;span class=&quot;error&quot;&gt;&amp;#91;&amp;quot;a&amp;quot;&amp;#93;&lt;/span&gt; == 1 // not &apos;x&apos;&lt;br/&gt;
But what about the putAt? This will go through InvokerHelper, thus map&lt;span class=&quot;error&quot;&gt;&amp;#91;&amp;quot;a&amp;quot;&amp;#93;&lt;/span&gt; = 1 will set the property. I think one is not complete without the other. Right now&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;HM &lt;span class=&quot;code-keyword&quot;&gt;extends&lt;/span&gt; HashMap {
   &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; a = &lt;span class=&quot;code-quote&quot;&gt;&apos;x&apos;&lt;/span&gt;
}
def map = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; HM()
map[&lt;span class=&quot;code-quote&quot;&gt;&quot;a&quot;&lt;/span&gt;] = 1
&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; map[&lt;span class=&quot;code-quote&quot;&gt;&quot;a&quot;&lt;/span&gt;] == 1
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;will fail Groovy because map&lt;span class=&quot;error&quot;&gt;&amp;#91;&amp;quot;a&amp;quot;&amp;#93;&lt;/span&gt; sets the property, while map&lt;span class=&quot;error&quot;&gt;&amp;#91;&amp;quot;a&amp;quot;&amp;#93;&lt;/span&gt; gets the map value.&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;HM &lt;span class=&quot;code-keyword&quot;&gt;extends&lt;/span&gt; HashMap {
   &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; a = &lt;span class=&quot;code-quote&quot;&gt;&apos;x&apos;&lt;/span&gt;
}
def map = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; HM()
def x = &lt;span class=&quot;code-quote&quot;&gt;&quot;a&quot;&lt;/span&gt;
map[&lt;span class=&quot;code-quote&quot;&gt;&quot;$x&quot;&lt;/span&gt;] = 1
&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; map[&lt;span class=&quot;code-quote&quot;&gt;&quot;$x&quot;&lt;/span&gt;] == 1
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;did behave just the same. The reason is that in dynamic Groovy putAt(Object, String) exists as extension method and is preferred over putAt(Map, Object), since GString is kind of a String. Now before the fix it seems the static compiler was not seeing GString as a kind of String, thus the Object method is taken. But if you fixed that, then there is no need to add that getAt method. There is already one for this case.&lt;/p&gt;</comment>
                            <comment id="17581945" author="emilles" created="Fri, 19 Aug 2022 16:26:21 +0000"  >&lt;p&gt;I did look at putAt.  It is declared as &quot;public &amp;lt;K,V&amp;gt; V putAt(Map&amp;lt;K,V&amp;gt; map, K key, V val)&quot;.  So there is some difference as far as the static compiler is concerned.  For &quot;Map&amp;lt;String,?&amp;gt;&quot; it says that GString is not compatible with String.  &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-9420&quot; title=&quot;Incorrect type inference on map[key]&quot; class=&quot;issue-link&quot; data-issue-key=&quot;GROOVY-9420&quot;&gt;&lt;del&gt;GROOVY-9420&lt;/del&gt;&lt;/a&gt; changed this same error for getAt, which now accepts Object like Map#get does.&lt;/p&gt;

&lt;p&gt;Is there a way to break all this down and proceed with stepwise refinements?  8788 is about inconsistent selection of extension methods.  I can make the static compiler select like the dynamic compiler does (the PR) but there would be consequences for map access and some other things like set intersect.  It sounds like you explicitly wanted the static compiler to work differently in this space.  So is there a play to bring the dynamic compiler in line or should we just close this out and accept the difference in bahavior?&lt;/p&gt;</comment>
                            <comment id="17582251" author="blackdrag" created="Sat, 20 Aug 2022 15:33:35 +0000"  >&lt;p&gt;Point A is that consistency. The static compiler should behave the same for extension methods and non extension methods in terms of what extension methods mean (I made examples above). This is not specific to map of course.&lt;/p&gt;

&lt;p&gt;But the trouble here already starts with Point B. From what I gathered Map&amp;lt;String,?&amp;gt;&#160; would convert GString keys to String. But then in case of Map&amp;lt;?,?&amp;gt; I got from your comment that this is not the case. If GString would really extend String, then this would not matter, but since it does not extend it we get a problem that does not exist for example in Java. GString-&amp;gt;String is no cast, it is a conversion. Such exist in Java as widening and as boxing. But since you cannot use a different key for Map&amp;lt;?,?&amp;gt; than for Map&amp;lt;Integer,?&amp;gt; boxing does not matter. Potentially there would be a problem with trying to use an int for Map&amp;lt;?,?&amp;gt; and Map&amp;lt;Long,?&amp;gt;, but I have not checked if that is actually legal without using any cast. there are also Lambda expressions... but since they have no specific type on their own the problem does not exist here as well.&lt;/p&gt;

&lt;p&gt;I think you can do Point A, Point B+ is a can of worms.&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;</comment>
                            <comment id="17582532" author="emilles" created="Sun, 21 Aug 2022 11:22:46 +0000"  >&lt;p&gt;Let me see if I can break this down from your examples, with some small edits of mine.&lt;/p&gt;

&lt;p&gt;1. overload is more specific &amp;#8211; nothing surprising here&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-groovy&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;A {
  &lt;span class=&quot;code-keyword&quot;&gt;def&lt;/span&gt; m(&lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; o) {1}
}
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;B &lt;span class=&quot;code-keyword&quot;&gt;extends&lt;/span&gt; A {
  &lt;span class=&quot;code-keyword&quot;&gt;def&lt;/span&gt; m(&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; s) {2}
}
&lt;span class=&quot;code-keyword&quot;&gt;def&lt;/span&gt; a = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; A()
&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; a.m(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;()) == 1
&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; a.m(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;()) == 1
&lt;span class=&quot;code-keyword&quot;&gt;def&lt;/span&gt; b = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; B()
&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; b.m(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;()) == 1
&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; b.m(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;()) == 2
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;2. overload is more general &amp;#8211; selection is based on argument type&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-groovy&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; static groovy.test.GroovyAssert.shouldFail
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;A {
  &lt;span class=&quot;code-keyword&quot;&gt;def&lt;/span&gt; m(&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; s) {1}
}
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;B &lt;span class=&quot;code-keyword&quot;&gt;extends&lt;/span&gt; A {
  &lt;span class=&quot;code-keyword&quot;&gt;def&lt;/span&gt; m(&lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; o) {2}
}
&lt;span class=&quot;code-keyword&quot;&gt;def&lt;/span&gt; a = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; A()
shouldFail(MissingMethodException) { a.m(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;()) }
&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; a.m(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;()) == 1
&lt;span class=&quot;code-keyword&quot;&gt;def&lt;/span&gt; b = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; B()
&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; b.m(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;()) == 2
&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; b.m(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;()) == 1
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;3. category/extension overloads &amp;#8211; same behavior as declared methods; OP expects this behavior&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-groovy&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;A { }
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;B &lt;span class=&quot;code-keyword&quot;&gt;extends&lt;/span&gt; A { }
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;Cat {
  static m(A self, &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; s) {1}
  static m(B self, &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; o) {2}
}
use (Cat) {
  &lt;span class=&quot;code-keyword&quot;&gt;def&lt;/span&gt; a = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; A()
  &lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; a.m(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;()) == 1
  &lt;span class=&quot;code-keyword&quot;&gt;def&lt;/span&gt; b = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; B()
  &lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; b.m(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;()) == 2
  &lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; b.m(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;()) == 1
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Hopefully nothing surprising so far.  #1 and #2 run the same under static compilation.  #3 requires a little more work since &lt;tt&gt;use&lt;/tt&gt; cannot be used under static compilation.&lt;/p&gt;

&lt;p&gt;Under static compilation, &lt;tt&gt;b.m(new String())&lt;/tt&gt; returns 2.  This is the inconsistency the OP refers to.  Separate from all the map stuff, do you agree that selection of &lt;tt&gt;m(Object)&lt;/tt&gt; over &lt;tt&gt;m(String)&lt;/tt&gt; by the static compiler is the incorrect choice? &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=blackdrag&quot; class=&quot;user-hover&quot; rel=&quot;blackdrag&quot;&gt;blackdrag&lt;/a&gt; &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=paulk&quot; class=&quot;user-hover&quot; rel=&quot;paulk&quot;&gt;paulk&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Under your second example, you state &quot;m(Object) is to be seen as if it is a method of B. m(String) is to be seen as if a method of A. Since B extends A and since B does not define a new m(String), the extension method for A has to be chosen here&quot; which confirms for me that OP and you and I agree, the static compiler is selecting the wrong method.&lt;/p&gt;</comment>
                            <comment id="17582540" author="emilles" created="Sun, 21 Aug 2022 11:53:43 +0000"  >&lt;p&gt;4. overload and override &amp;#8211; I think we all expect &lt;tt&gt;b.m(new String())&lt;/tt&gt; to return 3 now and Groovy follows suit&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-groovy&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;A { }
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;B &lt;span class=&quot;code-keyword&quot;&gt;extends&lt;/span&gt; A { }
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;Cat {
  static m(A self, &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; s) {1}
  static m(B self, &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; o) {2}
  static m(B self, &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; s) {3}
}
use (Cat) {
  &lt;span class=&quot;code-keyword&quot;&gt;def&lt;/span&gt; b = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; B()
  &lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; b.m(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;()) == 2
  &lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; b.m(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;()) == 3
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;5. mixed declaration and extension&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-groovy&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;A { &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; m(&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; s) {4} }
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;B &lt;span class=&quot;code-keyword&quot;&gt;extends&lt;/span&gt; A { }
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;Cat {
  static m(A self, &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; s) {1}
  static m(B self, &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; o) {2}
}
use (Cat) {
  &lt;span class=&quot;code-keyword&quot;&gt;def&lt;/span&gt; a = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; A()
  &lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; a.m(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;()) == 1
  &lt;span class=&quot;code-keyword&quot;&gt;def&lt;/span&gt; b = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; B()
  &lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; b.m(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;()) == 2
  &lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; b.m(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;()) == 1
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here we have something interesting and new.  Groovy chooses extension method &lt;tt&gt;m(String)&lt;/tt&gt; over declared method &lt;tt&gt;m(String)&lt;/tt&gt;.  I think this is how &lt;tt&gt;String toString(Object self)&lt;/tt&gt; works.  Even in this case for &lt;tt&gt;b.m(new String())&lt;/tt&gt;, the static compiler selects &lt;tt&gt;m(Object)&lt;/tt&gt; given two &lt;tt&gt;m(String)&lt;/tt&gt; options.  Further confirmation for me that SC is improperly weighting the self type B.&lt;/p&gt;</comment>
                            <comment id="17582543" author="emilles" created="Sun, 21 Aug 2022 12:07:22 +0000"  >&lt;p&gt;If my understanding of #1-#5 is consistent, this commit does work to fix the self-type weighting of STC/SC: &lt;a href=&quot;https://github.com/apache/groovy/pull/1766/commits/488f8a8f336efae32349317f219a8f8df8994114&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/groovy/pull/1766/commits/488f8a8f336efae32349317f219a8f8df8994114&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I can separate out the getAt change if that helps.  There will be some fallout to having &lt;tt&gt;getAt(Object,String)&lt;/tt&gt; selected over &lt;tt&gt;getAt(Map&amp;lt;K,V&amp;gt;,Object)&lt;/tt&gt; by the type checker.&lt;/p&gt;

&lt;p&gt;And based on all this, I actually noticed that the javadoc assertions for &lt;tt&gt;getAt(Map&amp;lt;K,V&amp;gt;,Object)&lt;/tt&gt; are not even targeting that method.  They go to &lt;tt&gt;getAt(Object,String)&lt;/tt&gt; because they use string keys.&lt;/p&gt;

&lt;p&gt;Further, because &lt;tt&gt;getAt(Object,String)&lt;/tt&gt; is implemented via getProperty, there is an edge case where you can extend map and declare a property, which is what this refers to (edited to reflect current behavior):&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-groovy&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;HM &lt;span class=&quot;code-keyword&quot;&gt;extends&lt;/span&gt; HashMap {
  &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; a = &lt;span class=&quot;code-quote&quot;&gt;&apos;x&apos;&lt;/span&gt;
}
map = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; HM()
map.put(&lt;span class=&quot;code-quote&quot;&gt;&quot;a&quot;&lt;/span&gt;,1)
&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; map[&lt;span class=&quot;code-quote&quot;&gt;&quot;a&quot;&lt;/span&gt;] == &lt;span class=&quot;code-quote&quot;&gt;&apos;x&apos;&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="17582550" author="emilles" created="Sun, 21 Aug 2022 13:13:19 +0000"  >&lt;p&gt;6. mixed declaration and extension (pt.2)&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-groovy&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;A { &lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; m(&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; s) {4} }
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;B &lt;span class=&quot;code-keyword&quot;&gt;extends&lt;/span&gt; A { }
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;C &lt;span class=&quot;code-keyword&quot;&gt;extends&lt;/span&gt; B { }
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;Ext {
  static m(B self, &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; o) {2}
}
use (Ext) {
  &lt;span class=&quot;code-keyword&quot;&gt;def&lt;/span&gt; a = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; A()
  &lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; a.m(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;()) == 4
  &lt;span class=&quot;code-keyword&quot;&gt;def&lt;/span&gt; b = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; B()
  &lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; b.m(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;()) == 2
  &lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; b.m(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;()) == 4
  &lt;span class=&quot;code-keyword&quot;&gt;def&lt;/span&gt; c = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; C()
  &lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; c.m(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;()) == 2
  &lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; c.m(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;()) == 4
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This case behaves under dynamic and static compilation.  So no change required. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Update:&lt;/b&gt; the commit changes the selection for &lt;tt&gt;c.m(new String())&lt;/tt&gt;; I am investigating&lt;/p&gt;</comment>
                            <comment id="17582672" author="githubbot" created="Mon, 22 Aug 2022 00:42:36 +0000"  >&lt;p&gt;eric-milles opened a new pull request, #1768:&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/groovy/pull/1768&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/groovy/pull/1768&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;   Given choice between methods m(String,Object) and m(Object,String), prefer closer parameter matching. This aligns with the method selection of the dynamic runtime.  There is much more discussion of the various test cases in the ticket.&lt;/p&gt;

&lt;p&gt;   With proper selection of `getAt(Object,String)` over `getAt(Map,Object)` and `putAt(Object,String,Object)` over `putAt(Map,K,V)` there are quite a few STC test issues.  Not sure if I should separate them out to a test script just for 8788 or mitigate them with some minor changes or something else.  I&apos;d be interested to hear how this sits now.  @blackdrag @paulk-asert &lt;/p&gt;

&lt;p&gt;   &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-8788&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/GROOVY-8788&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;   &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-6504&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/GROOVY-6504&lt;/a&gt;&lt;br/&gt;
   &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-6849&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/GROOVY-6849&lt;/a&gt;&lt;br/&gt;
   &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-6970&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/GROOVY-6970&lt;/a&gt;&lt;br/&gt;
   &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-8787&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/GROOVY-8787&lt;/a&gt;&lt;br/&gt;
   &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-9069&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/GROOVY-9069&lt;/a&gt;&lt;br/&gt;
   &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-9420&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/GROOVY-9420&lt;/a&gt;&lt;/p&gt;

</comment>
                            <comment id="17582677" author="githubbot" created="Mon, 22 Aug 2022 01:05:35 +0000"  >&lt;p&gt;eric-milles closed pull request #1766: &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-8788&quot; title=&quot;Inconsistency in extension method selection with @CompileStatic&quot; class=&quot;issue-link&quot; data-issue-key=&quot;GROOVY-8788&quot;&gt;&lt;del&gt;GROOVY-8788&lt;/del&gt;&lt;/a&gt;: STC: prefer closer parameter match over self-type match&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/groovy/pull/1766&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/groovy/pull/1766&lt;/a&gt;&lt;/p&gt;

</comment>
                            <comment id="17582810" author="blackdrag" created="Mon, 22 Aug 2022 08:36:14 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=emilles&quot; class=&quot;user-hover&quot; rel=&quot;emilles&quot;&gt;emilles&lt;/a&gt; I think your analysis so far is very spot on.  Sorry for writing so much text all the time, but I think it is important that I explain you a bit my thinking, not only the result.&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
void testPutWithWrongValueType() {
        shouldFailWithMessages &apos;&apos;&apos;
            def map = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; HashMap&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;, &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;&amp;gt;()
            map.put(&lt;span class=&quot;code-quote&quot;&gt;&apos;hello&apos;&lt;/span&gt;, &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;())
        &apos;&apos;&apos;,
        &lt;span class=&quot;code-quote&quot;&gt;&apos;Cannot find matching method java.util.HashMap#put(java.lang.&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;, java.lang.&lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;). Please check &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; the declared type is correct and &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; the method exists.&apos;&lt;/span&gt;
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This test passes now, but should have failed. It is not about getAt though. Map#put(K,V) is then not the selected method here - which makes sense, since it is not fitting. But there is no DGM for this either. So what method is actually selected here?  There might be more like this.&lt;/p&gt;

&lt;p&gt;Of course the majority is, as you mentioned because of Object#getAt(String):Object being selected over Map&amp;lt;K,V&amp;gt;#getAt(Object):V&lt;/p&gt;

&lt;p&gt;To solve this I see a couple of possibilities which I all don&apos;t like all that much. The problem is that the tests IMHO show the desired behavior. Changing them would not only mean breaking existing code most likely, but also - to avoid that - further work. So I am not really for this, unless we make that a blocking issue for the next release. So my take on this is, fix the tests if you want this PR going through, but document all the failing tests with a new blocking issue and there is the danger of having to revert more than just the test changes. What I would prefer is adding commits to this PR to try find a solution. but I think some more discussion is required. So maybe may thoughts on possible solutions:&lt;/p&gt;

&lt;p&gt;(1) replace Map&amp;lt;K,V&amp;gt;#getAt(Object):V with Map&amp;lt;K,V&amp;gt;#getAt(K):V. This raises of course the question of if this even shadows (and even should do so) the Object method. A Map&amp;lt;?,V&amp;gt; could be super troublesome here. And of course this signature is not aligned with the normal get-method Map has. I personally think that having getAt more specific would be no problem, you still have get for the strange things where you use a key from a different class with same hashcode and accordingly behaving equals method - which should be super rare. And I do not see a requirement to honor the old contract of Map here. But as I said.. should this really be preferred over the Object variant in case of Map&amp;lt;?,V&amp;gt;. Or maybe it would be worth it, even if this fails in method selection? I think it would. It is kind of my preferred solution without knowing all the implications of course&lt;/p&gt;

&lt;p&gt;(2) change Object#getAt(String) to Object#getAt(Object). This change would require that we try to convert the argument to String in the getAt method. As in (1) Map&amp;lt;String,V&amp;gt; would then be no problem. And as in (1) Map&amp;lt;?,V&amp;gt; could be a problem. Actually again we have to ask what method is preferred by the static compiler and which should be. And again I do not care about a method selection error during compile time here. But this would be a breaking change whenever somebody made at getAt(String) method with @Override - unless our implementation of this does not check for DGM. though the question here is then if that is correct.&lt;/p&gt;

&lt;p&gt;(3) add Map&amp;lt;K, V&amp;gt;#getAt(String). This would mean to have it additionally to Map&amp;lt;K,V&amp;gt;#getAt(Object). Here we would have to clear if there is a case of Map#get(String) being called instead of Object#getAt(String) as part of the MOP is possible. It is not get, but getAt, so there might be no conflict. But there are direct calls to getAt as part of the meta class to map property/attribute access I think. And is it then right to call Object#getAt(String) instead of Map#getAt(String)? &lt;/p&gt;

&lt;p&gt;For me all 3 of them have potential of breaking code.&lt;/p&gt;</comment>
                            <comment id="17582993" author="emilles" created="Mon, 22 Aug 2022 14:00:32 +0000"  >&lt;p&gt;First of all, thank you for taking the time to read through all this and provide feedback.&lt;/p&gt;

&lt;p&gt;Now we come to the hard decisions.  &lt;tt&gt;getAt(Object,String)&lt;/tt&gt; is chosen over &lt;tt&gt;getAt(Map,Object)&lt;/tt&gt; for dynamic runtime and now STC for String input.  As you can see from all the test failures, this goes against expectations because the inferred return type is Object not the map&apos;s value type.  There is an edge case where this bears out now:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-groovy&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;A { }
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;B { }
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;HM &lt;span class=&quot;code-keyword&quot;&gt;extends&lt;/span&gt; HashMap&amp;lt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;,A&amp;gt; {
  B b = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; B()
}
map = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; HM()
map[&lt;span class=&quot;code-quote&quot;&gt;&apos;a&apos;&lt;/span&gt;] = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; A()
A value = map[&lt;span class=&quot;code-quote&quot;&gt;&apos;a&apos;&lt;/span&gt;]
  value = map[&lt;span class=&quot;code-quote&quot;&gt;&apos;b&apos;&lt;/span&gt;] &lt;span class=&quot;code-comment&quot;&gt;// Groovy 5 returns the property declared by HM (GROOVY-5001, GROOVY-5491, GROOVY-6144)&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/apache/groovy/blame/c18411fe233bd60d4d045d65d9bb04b459f95e12/src/main/java/groovy/lang/MetaClassImpl.java#L1966&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/groovy/blame/c18411fe233bd60d4d045d65d9bb04b459f95e12/src/main/java/groovy/lang/MetaClassImpl.java#L1966&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="17583001" author="emilles" created="Mon, 22 Aug 2022 14:19:42 +0000"  >&lt;p&gt;So I can think of a few options to move forward from this point:&lt;/p&gt;

&lt;p&gt;1. Add &lt;tt&gt;getAt(Map,String)&lt;/tt&gt; and &lt;tt&gt;putAt(Map,String,V)&lt;/tt&gt; extension methods.  This gets in front of the getProperty/setProperty behavior.  But it means &quot;map&lt;span class=&quot;error&quot;&gt;&amp;#91;&amp;#39;key&amp;#39;&amp;#93;&lt;/span&gt;&quot; diverges from &quot;map.key&quot;.  I tried this option in the &lt;a href=&quot;https://github.com/apache/groovy/pull/1766&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;previous PR&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2. Add special-case logic in STC to select &lt;tt&gt;getAt(Map,Object)&lt;/tt&gt; for string argument and map receiver (and same for putAt).  This lets type-checker work like before.  But the public property case described above will still be a cast exception for SC at least.&lt;/p&gt;

&lt;p&gt;3. Add type inference logic to STC for left-square-bracket binary expression with map receiver and String key.  This overrides the type information provided by method selection.&lt;/p&gt;

&lt;p&gt;4. You mentioned changing &lt;tt&gt;getAt(Map,Object)&lt;/tt&gt; back to &lt;tt&gt;getAt(Map,K)&lt;/tt&gt; (&lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-9420&quot; title=&quot;Incorrect type inference on map[key]&quot; class=&quot;issue-link&quot; data-issue-key=&quot;GROOVY-9420&quot;&gt;&lt;del&gt;GROOVY-9420&lt;/del&gt;&lt;/a&gt; was the source of the change in the other direction) and updating selection logic.  I did experiment with how to get chooseBestMethod to do this, so I have the code for it.&lt;/p&gt;

&lt;p&gt;Update: &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-5700&quot; title=&quot;STC: different behavior w/ map subscript and property access when using elvis&quot; class=&quot;issue-link&quot; data-issue-key=&quot;GROOVY-5700&quot;&gt;&lt;del&gt;GROOVY-5700&lt;/del&gt;&lt;/a&gt; added special type inference handling for &quot;map.key&quot; property expressions.  I&apos;ll see if routing through existsProperty gives a better result than looking for getAt/putAt method.&lt;/p&gt;</comment>
                            <comment id="17583055" author="emilles" created="Mon, 22 Aug 2022 16:05:23 +0000"  >&lt;p&gt;It is this excerpt of &lt;a href=&quot;https://github.com/apache/groovy/blob/7f6fcb2f81b58a54bc7beef33ac382cb50a79cb4/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java#L4522&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;StaticTypeCheckingVisitor#getResultType&lt;/a&gt; that determines the type of &quot;x = map&lt;span class=&quot;error&quot;&gt;&amp;#91;&amp;#39;key&amp;#39;&amp;#93;&lt;/span&gt;&quot; and &quot;map&lt;span class=&quot;error&quot;&gt;&amp;#91;&amp;#39;key&amp;#39;&amp;#93;&lt;/span&gt; = x&quot;.  Yes, it only looks for getAt...&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (isArrayOp(op)) {
            Expression copy = binX(leftExpression, expr.getOperation(), rightExpression);
            copy.setSourcePosition(expr); &lt;span class=&quot;code-comment&quot;&gt;// &lt;span class=&quot;code-keyword&quot;&gt;do&lt;/span&gt; not propagate BINARY_EXP_TARGET, etc.
&lt;/span&gt;            MethodNode method = findMethodOrFail(copy, left, &lt;span class=&quot;code-quote&quot;&gt;&quot;getAt&quot;&lt;/span&gt;, rightRedirect);
            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (method != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !isNumberCategory(getWrapper(rightRedirect))) {
                &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; inferReturnTypeGenerics(left, method, rightExpression);
            }
            &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; inferComponentType(left, right);
        }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;When method selection changes, it determines Object not Type for Map&amp;lt;String,Type&amp;gt;.  I can add a special case for Map left expression and String right expression.&lt;/p&gt;

&lt;p&gt;For put, type checking is done via this block in &lt;a href=&quot;https://github.com/apache/groovy/blob/7f6fcb2f81b58a54bc7beef33ac382cb50a79cb4/src/main/java/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java#L820&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;StaticTypeCheckingVisitor#visitBinaryExpression&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (isArrayOp(op)) {
                ...
                &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!lType.isArray()
                        &amp;amp;&amp;amp; enclosingBinaryExpression != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;
                        &amp;amp;&amp;amp; enclosingBinaryExpression.getLeftExpression() == expression
                        &amp;amp;&amp;amp; isAssignment(enclosingBinaryExpression.getOperation().getType())) {
                    &lt;span class=&quot;code-comment&quot;&gt;// left hand side of a subscript assignment: map[&lt;span class=&quot;code-quote&quot;&gt;&apos;foo&apos;&lt;/span&gt;] = ...
&lt;/span&gt;                    Expression enclosingExpressionRHS = enclosingBinaryExpression.getRightExpression();
                    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!(enclosingExpressionRHS &lt;span class=&quot;code-keyword&quot;&gt;instanceof&lt;/span&gt; ClosureExpression)) {
                        enclosingExpressionRHS.visit(&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;);
                    }
                    ClassNode[] arguments = {rType, getType(enclosingExpressionRHS)};
                    List&amp;lt;MethodNode&amp;gt; methods = findMethod(lType, &lt;span class=&quot;code-quote&quot;&gt;&quot;putAt&quot;&lt;/span&gt;, arguments);
                    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (methods.size() == 1) {
                        typeCheckMethodsWithGenericsOrFail(lType, arguments, methods.get(0), enclosingExpressionRHS);
                    } &lt;span class=&quot;code-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (methods.isEmpty()) {
                        addNoMatchingMethodError(lType, &lt;span class=&quot;code-quote&quot;&gt;&quot;putAt&quot;&lt;/span&gt;, arguments, enclosingBinaryExpression);
                    }
                }
            }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It relies on method selection to produce &quot;Cannot call #putAt(Map,K,V) with arguments ...&quot; errors.  Since &lt;tt&gt;putAt(Object,String,Object)&lt;/tt&gt; is now selected for string keys, this block checks nothing.  However, the result type allows &quot;Cannot assign value of type X to variable of type Y&quot; to be produced. So value type checking is preserved.  Key type checking is gone as demonstrated by GenericsSTCTest#testInferDiamondForAssignmentWithDatesAndIllegalKeyUsingSquareBracket.&lt;/p&gt;</comment>
                            <comment id="17583059" author="emilles" created="Mon, 22 Aug 2022 16:13:54 +0000"  >&lt;p&gt;Since basically everything allows get/put property using string for property name via &lt;tt&gt;getAt(Object,String)&lt;/tt&gt; and &lt;tt&gt;putAt(Object,String,Object)&lt;/tt&gt; maybe an optional type checking extension should be created, much like was done for regular expressions.&lt;/p&gt;</comment>
                            <comment id="17583097" author="emilles" created="Mon, 22 Aug 2022 17:08:31 +0000"  >&lt;p&gt;The pull request has been updated with mitigation for type checking of map value read and write.  The one item that suffered is string key type checking, as noted above.&lt;/p&gt;</comment>
                            <comment id="17583845" author="githubbot" created="Tue, 23 Aug 2022 20:48:32 +0000"  >&lt;p&gt;eric-milles merged PR #1768:&lt;br/&gt;
URL: &lt;a href=&quot;https://github.com/apache/groovy/pull/1768&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/groovy/pull/1768&lt;/a&gt;&lt;/p&gt;

</comment>
                            <comment id="17583848" author="emilles" created="Tue, 23 Aug 2022 20:50:20 +0000"  >&lt;p&gt;&lt;a href=&quot;https://github.com/apache/groovy/commit/14946ff27a60d74b5d07c1b9a63f02624283c863&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/groovy/commit/14946ff27a60d74b5d07c1b9a63f02624283c863&lt;/a&gt;&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12816525">GROOVY-5700</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12817278">GROOVY-6504</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12813428">GROOVY-6849</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="12817668">GROOVY-6970</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="13184873">GROOVY-8787</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="13226382">GROOVY-9069</issuekey>
        </issuelink>
            <issuelink>
            <issuekey id="13287446">GROOVY-9420</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            3 years, 12 weeks ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3y1xr:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </customfields>
    </item>
</channel>
</rss>