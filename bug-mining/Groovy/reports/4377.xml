<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Wed Nov 12 01:17:44 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[GROOVY-9472] Static import causes unresolved reference to become resolved</title>
                <link>https://issues.apache.org/jira/browse/GROOVY-9472</link>
                <project id="12318123" key="GROOVY">Groovy</project>
                    <description>&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeHeader panelHeader&quot; style=&quot;border-bottom-width: 1px;&quot;&gt;&lt;b&gt;com/foo/Person.groovy&lt;/b&gt;&lt;/div&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-groovy&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;package&lt;/span&gt; com.foo

@groovy.transform.builder.Builder
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;Person {
    &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; name
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;1.&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeHeader panelHeader&quot; style=&quot;border-bottom-width: 1px;&quot;&gt;&lt;b&gt;Main.groovy&lt;/b&gt;&lt;/div&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-groovy&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; com.foo.Person

&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;Main {
    static void main(&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;[] args) {
        Person.PersonBuilder pb = Person.builder() 
        println(pb.build())
    }
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Trying to use it without a static import yields &lt;tt&gt;unable to resolve class Person.PersonBuilder&lt;/tt&gt;, which is another issue.&lt;/p&gt;

&lt;p&gt;2. Let&apos;s add a static import&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeHeader panelHeader&quot; style=&quot;border-bottom-width: 1px;&quot;&gt;&lt;b&gt;Main.groovy&lt;/b&gt;&lt;/div&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-groovy&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; com.foo.Person
&lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; static com.foo.Person.PersonBuilder

&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;Main {
    static void main(&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;[] args) {
        PersonBuilder pb = Person.builder()
        println(pb.build())
    }
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The code compiles, but fails with &lt;tt&gt;java.lang.NoClassDefFoundError: PersonBuilder&lt;/tt&gt; when run.&lt;/p&gt;

&lt;p&gt;3. Let&apos;s add &lt;tt&gt;@CompileStatic&lt;/tt&gt;&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeHeader panelHeader&quot; style=&quot;border-bottom-width: 1px;&quot;&gt;&lt;b&gt;Main.groovy&lt;/b&gt;&lt;/div&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-groovy&quot;&gt;
&lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; com.foo.Person
&lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; static com.foo.Person.PersonBuilder
&lt;span class=&quot;code-keyword&quot;&gt;import&lt;/span&gt; groovy.transform.CompileStatic

@CompileStatic
&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;Main {
    static void main(&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;[] args) {
        PersonBuilder pb = Person.builder()
        println(pb.build())
    }
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Compilation fails with: &lt;br/&gt;
 &lt;tt&gt;Cannot assign value of type com.foo.Person$PersonBuilder to variable of type PersonBuilder&lt;/tt&gt; and &lt;tt&gt;Cannot find matching method PersonBuilder#build()&lt;/tt&gt;&lt;/p&gt;</description>
                <environment></environment>
        <key id="13292077">GROOVY-9472</key>
            <summary>Static import causes unresolved reference to become resolved</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="emilles">Eric Milles</assignee>
                                    <reporter username="daniilo">Daniil Ovchinnikov</reporter>
                        <labels>
                    </labels>
                <created>Mon, 16 Mar 2020 22:01:16 +0000</created>
                <updated>Wed, 27 Apr 2022 08:38:43 +0000</updated>
                            <resolved>Sun, 13 Mar 2022 18:17:21 +0000</resolved>
                                    <version>2.5.10</version>
                                    <fixVersion>4.0.0</fixVersion>
                                    <component>Compiler</component>
                    <component>Static Type Checker</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>4</watches>
                                                                                                                <comments>
                            <comment id="17160209" author="emilles" created="Fri, 17 Jul 2020 21:03:09 +0000"  >&lt;p&gt;Is &quot;import static a.B.C&quot; supposed to work for type C nested within type B?  Or is it reserved for fields, methods and properties?&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-9471?focusedCommentId=17152320&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-17152320&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://issues.apache.org/jira/browse/GROOVY-9471?focusedCommentId=17152320&amp;amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-17152320&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="17160211" author="emilles" created="Fri, 17 Jul 2020 21:06:09 +0000"  >&lt;p&gt;It is this block in &lt;tt&gt;ResolveVisitor&lt;/tt&gt; that adds type resolution for static imports:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
    &lt;span class=&quot;code-comment&quot;&gt;// GROOVY-7812(#1): Static &lt;span class=&quot;code-keyword&quot;&gt;inner&lt;/span&gt; classes cannot be accessed from other files when running by &lt;span class=&quot;code-quote&quot;&gt;&apos;groovy&apos;&lt;/span&gt; command
&lt;/span&gt;    &lt;span class=&quot;code-comment&quot;&gt;// &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; the type to resolve is an &lt;span class=&quot;code-keyword&quot;&gt;inner&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;and it is in an &lt;span class=&quot;code-keyword&quot;&gt;outer&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;which is not resolved,
&lt;/span&gt;    &lt;span class=&quot;code-comment&quot;&gt;// we set the resolved type to a placeholder &lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;node, i.e. a ConstructedOuterNestedClass instance
&lt;/span&gt;    &lt;span class=&quot;code-comment&quot;&gt;// when resolving the &lt;span class=&quot;code-keyword&quot;&gt;outer&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;later, we set the resolved type of ConstructedOuterNestedClass instance to the actual &lt;span class=&quot;code-keyword&quot;&gt;inner&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;node(SEE GROOVY-7812(#2))
&lt;/span&gt;    &lt;span class=&quot;code-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; resolveToOuterNested(&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; ClassNode type) {
        CompileUnit compileUnit = currentClass.getCompileUnit();
        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (compileUnit == &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;;
        &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; typeName = type.getName();

        BiConsumer&amp;lt;ConstructedOuterNestedClassNode, ClassNode&amp;gt; setRedirectListener = (s, c) -&amp;gt; type.setRedirect(s);

        ModuleNode module = currentClass.getModule();
        &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (ImportNode importNode : module.getStaticImports().values()) {
            &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; importFieldName = importNode.getFieldName();
            &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; importAlias = importNode.getAlias();

            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (!typeName.equals(importAlias)) &lt;span class=&quot;code-keyword&quot;&gt;continue&lt;/span&gt;;

            ConstructedOuterNestedClassNode constructedOuterNestedClassNode = tryToConstructOuterNestedClassNodeViaStaticImport(compileUnit, importNode, importFieldName, setRedirectListener);
            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt; != constructedOuterNestedClassNode) {
                compileUnit.addClassNodeToResolve(constructedOuterNestedClassNode);
                &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;;
            }
        }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</comment>
                            <comment id="17505889" author="emilles" created="Sun, 13 Mar 2022 18:17:21 +0000"  >&lt;p&gt;&lt;tt&gt;com.foo.Person.PersonBuilder&lt;/tt&gt; is uniformly not resolvable as of Groovy 4.  The &lt;tt&gt;Builder&lt;/tt&gt; transform runs at the end of &lt;tt&gt;SEMANTIC_ANALYSIS&lt;/tt&gt; phase, which is after class resolution.  In order to make the inner class resolve, &lt;tt&gt;Person&lt;/tt&gt; needs to move to another project (or other artifact) that compiles completely before &lt;tt&gt;Main&lt;/tt&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/apache/groovy/commit/7d838089c94b9afd37b5892b9756a396db6865ff&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://github.com/apache/groovy/commit/7d838089c94b9afd37b5892b9756a396db6865ff&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="17506756" author="blackdrag" created="Tue, 15 Mar 2022 07:44:17 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=emilles&quot; class=&quot;user-hover&quot; rel=&quot;emilles&quot;&gt;emilles&lt;/a&gt; what did change so that PersonBuilder cannot be resolved anymore? Is it only the class itself or all the transform does? I assume InitializerStrategy will also not work. If it is a general problem of the transform, then it woulld be meaning none of the strategies are working. &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=emilles&quot; class=&quot;user-hover&quot; rel=&quot;emilles&quot;&gt;emilles&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=paulk&quot; class=&quot;user-hover&quot; rel=&quot;paulk&quot;&gt;paulk&lt;/a&gt; shouldn&apos;t that be added to the documentation?&lt;/p&gt;</comment>
                            <comment id="17507015" author="emilles" created="Tue, 15 Mar 2022 16:04:50 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-10300&quot; title=&quot;Rework runtime script member resolution&quot; class=&quot;issue-link&quot; data-issue-key=&quot;GROOVY-10300&quot;&gt;&lt;del&gt;GROOVY-10300&lt;/del&gt;&lt;/a&gt; changes replaced the &lt;tt&gt;ConstructedOuterNestedClassNode&lt;/tt&gt; stuff cited above.  And &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-8729&quot; title=&quot;Eliminate the additional resolving phase of compilation for better performance&quot; class=&quot;issue-link&quot; data-issue-key=&quot;GROOVY-8729&quot;&gt;&lt;del&gt;GROOVY-8729&lt;/del&gt;&lt;/a&gt; / &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-10248&quot; title=&quot;Groovy ResolveVisitor runs twice&quot; class=&quot;issue-link&quot; data-issue-key=&quot;GROOVY-10248&quot;&gt;&lt;del&gt;GROOVY-10248&lt;/del&gt;&lt;/a&gt; / &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-10466&quot; title=&quot;Compilation error on Spock expectation&quot; class=&quot;issue-link&quot; data-issue-key=&quot;GROOVY-10466&quot;&gt;&lt;del&gt;GROOVY-10466&lt;/del&gt;&lt;/a&gt; changes reduced &lt;tt&gt;ResolveVisitor&lt;/tt&gt; / &lt;tt&gt;VariableScopeVisitor&lt;/tt&gt; to a single pass.&lt;/p&gt;

&lt;p&gt;As far as the general problem, any transform that generates types, methods, etc. after another part of the compiler expects them is a long-standing issue.  &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-3683&quot; title=&quot;groovyc can&amp;#39;t joint compile a Java class that uses a delegate method from a Groovy class with an @Delegate property annotation&quot; class=&quot;issue-link&quot; data-issue-key=&quot;GROOVY-3683&quot;&gt;GROOVY-3683&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-7764&quot; title=&quot;Joint compilation does not work with AST-transformed Groovy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;GROOVY-7764&quot;&gt;GROOVY-7764&lt;/a&gt; are examples.&lt;/p&gt;</comment>
                            <comment id="17507373" author="paulk" created="Wed, 16 Mar 2022 06:51:46 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=blackdrag&quot; class=&quot;user-hover&quot; rel=&quot;blackdrag&quot;&gt;blackdrag&lt;/a&gt; I don&apos;t think anything has changed w.r.t the normal compilation path/usage for @Builder which has been identified as a potential issue before (&lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-8803&quot; title=&quot;Can&amp;#39;t refer class declared with @Builder annotation&quot; class=&quot;issue-link&quot; data-issue-key=&quot;GROOVY-8803&quot;&gt;GROOVY-8803&lt;/a&gt;). In dynamic style (the context assumed in the design of most of the current strategies), you might rarely need to reference the builder class and can proceed as normal. For static typing scenarios or cases like the @Delegate combination mentioned in &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-8803&quot; title=&quot;Can&amp;#39;t refer class declared with @Builder annotation&quot; class=&quot;issue-link&quot; data-issue-key=&quot;GROOVY-8803&quot;&gt;GROOVY-8803&lt;/a&gt;, it would be good to have access to the builder class. We could take some steps forward by making something like a Buildable&amp;lt;T&amp;gt; interface (would be Buildable&amp;lt;Person&amp;gt; in the above example). The Default and External strategies could add this interface for example and we&apos;d need a way to make that happen early, e.g. CONVERSION. A similar trick might fix the similar @Delegate with joint compilation issue discussed previously (&lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-8105&quot; title=&quot;@Builder isn&amp;#39;t useful for java interop&quot; class=&quot;issue-link&quot; data-issue-key=&quot;GROOVY-8105&quot;&gt;GROOVY-8105&lt;/a&gt;) if we could get it to work. This might not address all use cases but might be a very useful step forward.&lt;/p&gt;</comment>
                            <comment id="17507387" author="blackdrag" created="Wed, 16 Mar 2022 07:29:21 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=paulk&quot; class=&quot;user-hover&quot; rel=&quot;paulk&quot;&gt;paulk&lt;/a&gt; I never used the annotation because frankly I have no use for it. But if it is that &quot;complicated&quot; to use then (playing a new user&apos;s side here) I would expect its limitations been documented. That some things don&apos;t work with joint compilation is a big problem, but this does not work if it is in the same compilation Unit and it is not even specific to @CompileStatic. As soon as you reference the class in the same CompilationUnit in normal source code&#160; you get a problem. For me this points to that the resolution of classes should not be a single pass process if new sources are picked up during resolution, at least not if we want to resolve an inner class of that. Of course I am aware of this being complicated and introducing complications.&lt;/p&gt;</comment>
                            <comment id="17507389" author="blackdrag" created="Wed, 16 Mar 2022 07:34:11 +0000"  >&lt;p&gt;I have to add: Of course a normally declared inner class would have been picked up, because the compiler does of course forward the added source unit to the same phase. But maybe it should not stop at the same phase, maybe it should complete the phase. Then we would still get a problem in circular references of classes generated in that phase, but I think something like that should be really a special problem&lt;/p&gt;</comment>
                            <comment id="17507462" author="paulk" created="Wed, 16 Mar 2022 10:09:40 +0000"  >&lt;p&gt;Yes, there are definitely two sides to the situation.&lt;/p&gt;

&lt;p&gt;On the one hand, it isn&apos;t &quot;complicated&quot; when you use the feature in the standard way. The documentation shows the standard way. In some sense, the fact that an inner class is used as part of the building process for some strategies is an internal detail that can usually be ignored. For a few of the strategies, you call the &lt;tt&gt;builder()&lt;/tt&gt; method to get the builder and the builder has a &lt;tt&gt;build()&lt;/tt&gt; method. For other strategies, no inner class is used or the other details may differ. So by design, since the inner class is an internal detail not mentioned in the source code anywhere, it is a class you should not be referencing. The &lt;tt&gt;ExternalStrategy&lt;/tt&gt; is by design one which mentions the builder class and the preferred option when you want to use the class elsewhere.&lt;/p&gt;

&lt;p&gt;On the other hand, the strategies align with some of the more common builder strategies which Java folks use and there are expectations around how they work and things which can be made to work if you were doing it by hand in Java. With that in mind, I agree it would be good to consider more sophistication in the resolution process.&lt;/p&gt;</comment>
                            <comment id="17507476" author="blackdrag" created="Wed, 16 Mar 2022 10:41:11 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=paulk&quot; class=&quot;user-hover&quot; rel=&quot;paulk&quot;&gt;paulk&lt;/a&gt; not sure I completely agree. For me the situation is as follows:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;dynamic mode works fine as long as you do not reference the Builder class by name.&lt;/li&gt;
	&lt;li&gt;static mode should just completely fail to use this annotation even with default strategy, because even without the builder class reference it has to be in bytecode as soon as you call for example Person.builder().firstName(&quot;Robert&quot;). Because without the Builder class being available, we cannot resolve the firstName method. But since this actually depends on method resolution it will still work as long as you do not reference the class by name like in dynamic mode. Not sure if saving the builder in a local variable and then calling methods on it is safe. It probably works.&lt;/li&gt;
	&lt;li&gt;joint compilation fails for this if the usage is in the same compilation and in Java&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Still I think these things should be mentioned in the javadoc. Or if on our website, then a reference should be done from the javadoc.&lt;/p&gt;</comment>
                            <comment id="17507515" author="paulk" created="Wed, 16 Mar 2022 11:22:50 +0000"  >&lt;p&gt;&amp;gt; * dynamic mode works fine as long as you do not reference the Builder class by name.&lt;/p&gt;

&lt;p&gt;The JavaDoc for &lt;tt&gt;DefaultStrategy&lt;/tt&gt; could certainly be expanded. I am unsure if it is needed for &lt;tt&gt;InitializerStrategy&lt;/tt&gt;. It is N/A for the other strategies.&lt;/p&gt;

&lt;p&gt;&amp;gt; * static mode should just completely fail to use this annotation&#160;&lt;/p&gt;

&lt;p&gt;There are currently unit tests for &lt;tt&gt;@CompileStatic&lt;/tt&gt; with all strategies including using a local variable for the builder. None of these tests ever reference the builder classname at compile time but inference stores the correct classes names for subsequent static compilation.&lt;/p&gt;

&lt;p&gt;&amp;gt; * joint compilation fails for this if the usage is in the same compilation and in Java&lt;/p&gt;

&lt;p&gt;We have the general disclaimer that traits may not work in conjunction with some AST transforms, we should probably have something similar for joint compilation and AST transforms.&lt;/p&gt;</comment>
                            <comment id="17507786" author="daniilo" created="Wed, 16 Mar 2022 18:09:34 +0000"  >&lt;p&gt;More general problem: there should be &lt;b&gt;zero&lt;/b&gt; difference in compilation of file1 and file2 together in one run and file1 followed by file2 in two subsequent runs (= two different compilation units). I&apos;ve encountered this problem multiple times. The problem hits incremental recompilation, when e.g. file1 is unchanged, and we only want to recompile file2. I&apos;m not sure how it works in Gradle, but it&apos;s one major pita in IJ, e.g. in this particular case the first compilation run would compile Person.groovy and fail with an error in Main.groovy, then the next run would compile Main.groovy successfully, so users come and ask why IJ cannot do it in one go.&#160;&lt;/p&gt;</comment>
                            <comment id="17507909" author="emilles" created="Thu, 17 Mar 2022 00:20:21 +0000"  >&lt;p&gt;If you include the class or classes that file1 generates on the classpath when compiling file2 there can be a significant difference. When compiled together, source units are brought through compile phases in lockstep. In case of Builder, the inner class is not generated before resolution of type references.&lt;/p&gt;</comment>
                            <comment id="17508065" author="blackdrag" created="Thu, 17 Mar 2022 09:06:40 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=emilles&quot; class=&quot;user-hover&quot; rel=&quot;emilles&quot;&gt;emilles&lt;/a&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=paulk&quot; class=&quot;user-hover&quot; rel=&quot;paulk&quot;&gt;paulk&lt;/a&gt;&lt;br/&gt;
Maybe a solution would be to make the resolution multiple steps. Try to complete the resolution phase for all source units for this phase. If they fail in class resolution do not progress the phase for these (obviously), but also do not fail compilation right away. If some units completed and added new classes or sources to the AST, then repeat. If nothing was added, then fail compilation with the class reference errors.  Usually partially resolved class reference in a SourceUnit with missing resolved class references are kept and they won&apos;t be resolved again. Maybe even the unresolved references do not have to go through all the cases completely if we keep the failed resolves and first resolve against the AST classes (which I think we do anyway).&lt;/p&gt;

&lt;p&gt;Of course this would make this phase different from other phases, but I don&apos;t see how this kind of logic would make sense in other phases, especially with the split of transforms. &lt;/p&gt;

&lt;p&gt;I was wondering if adding a new phase (ignoring the compatibility problems) between conversion and semantic analysis would be the way to go. But then this phase would have only the ResolveVisitor running and no transforms and this would not solve the problem at hand. On the other hand, if we could first resolve everything and run the transforms on the groovy files to only then generate stubs Then I think we could actually solve the problem of referencing generated classes of transforms in Java. In theory we could by repeating even get chain s of groovy referencing java and java referencing Groovy working... though that would get quite expensive. And most likely has a completely new set of problems coming along.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=daniilo&quot; class=&quot;user-hover&quot; rel=&quot;daniilo&quot;&gt;daniilo&lt;/a&gt;Since you are kind of a compiler expert having to deal with the Groovy compiler in Intellij so much I would like to hear your opinion on this very much. Could be I am completely on the wrong track here. &lt;/p&gt;</comment>
                            <comment id="17508139" author="daniilo" created="Thu, 17 Mar 2022 11:16:48 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=emilles&quot; class=&quot;user-hover&quot; rel=&quot;emilles&quot;&gt;emilles&lt;/a&gt;&#160;&lt;/p&gt;

&lt;p&gt;&amp;gt; If you include the class or classes that file1 generates on the classpath when compiling file2 there can be a significant difference&lt;/p&gt;

&lt;p&gt;Yes, this difference is the problem.&#160;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=blackdrag&quot; class=&quot;user-hover&quot; rel=&quot;blackdrag&quot;&gt;blackdrag&lt;/a&gt;&#160;&lt;/p&gt;

&lt;p&gt;&amp;gt; If some units completed and added new classes or sources to the AST, then repeat.&lt;/p&gt;

&lt;p&gt;Repeat re-trying to resolve references which were not resolved previously, i.e. if a reference got resolved, then it stays resolved.&lt;/p&gt;

&lt;p&gt;I&apos;d expect the resolution to work like this:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;Resolve resolvable member types/annotations&lt;/li&gt;
	&lt;li&gt;Run transformations&#160;&lt;/li&gt;
	&lt;li&gt;Resolve unresolved references in members&lt;/li&gt;
	&lt;li&gt;Resolve the references in bodies (both AST and generated, both types and variables/methods/fields)&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;The output of the second step is fixed after its completion, no more members are guaranteed to appear. The output of the third step is enough to do any static analysis in &lt;tt&gt;@CompileStatic&lt;/tt&gt; mode, and it is enough to generate the stubs for the joint compilation. This approach aligns well with what IDEs do, and what other compilers do.&lt;/p&gt;

&lt;p&gt;I&apos;d also split transformation run into two separate steps: instead of 2, run transformations to determine the set of members and types, then generate method bodies between 3 and 4.&lt;/p&gt;</comment>
                            <comment id="17508220" author="emilles" created="Thu, 17 Mar 2022 15:04:34 +0000"  >&lt;p&gt;&amp;gt;&amp;gt; If you include the class or classes that file1 generates on the classpath when compiling file2 there can be a significant difference&lt;br/&gt;
&amp;gt; Yes, this difference is the problem.&lt;/p&gt;

&lt;p&gt;So if the compiler is invoked with a compilation unit that contains a single source unit and a classpath for satisfying references, it is supposed to somehow guess that some of those class files are really source units that should be added to the compilation unit and compiled as well?  Why not just send in both source units in the first place if that is what you expect?&lt;/p&gt;

&lt;p&gt;Breaking up the compilation process with an extra phase or a new two-phase approach is a huge effort with many risks.  And there are idempotency/performance concerns with running resolve and transforms multiple times.  And the dependencies between transforms can be much more complex than the builder scenario described here.  Transforms can be assigned to any phase, so after which phase should resolve be run again?&lt;/p&gt;</comment>
                            <comment id="17508266" author="daniilo" created="Thu, 17 Mar 2022 15:55:18 +0000"  >&lt;p&gt;&amp;gt; it is supposed to somehow guess that some of those class files are really source units that should be added to the compilation unit and compiled as well&lt;/p&gt;

&lt;p&gt;Exactly the opposite. The compiler should not care about whether a dependency comes from another source unit or a library or an arbitrary class on the classpath.&#160;&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;&amp;gt;&#160;Why not just send in both source units in the first place if that is what you expect?&lt;/p&gt;

&lt;p&gt;Because the compilation will not be incremental if all files are recompiled each time.&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;&amp;gt; running resolve and transforms multiple times&lt;/p&gt;

&lt;p&gt;Not multiple times, but in multiple steps. If a reference gets resolved at some step, it stays resolved to this exact entity in all subsequent steps. The transforms should only be run once (or in multiple steps).&#160;&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;

&lt;p&gt;&amp;gt; Transforms can be assigned to any phase.&#160;&lt;/p&gt;

&lt;p&gt;Just as before, a transform is run once during requested phase, and that&apos;s it, no phase re-running. I&apos;ve thought we are discussing how to deal with transforms running in SEMANTIC_ANALYSIS.&#160;&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            3 years, 34 weeks, 5 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|z0clco:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </customfields>
    </item>
</channel>
</rss>