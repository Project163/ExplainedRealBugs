<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Wed Nov 12 00:07:44 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[GROOVY-2875] MetaClassRegistryImpl constantMetaClasses map is leaking resources</title>
                <link>https://issues.apache.org/jira/browse/GROOVY-2875</link>
                <project id="12318123" key="GROOVY">Groovy</project>
                    <description>&lt;p&gt;The GroovySystem is a class that resides in the AppClassLoader. It&apos;s final and only contains static attributes and methods.&lt;br/&gt;
Inside it, we find a MetaClassRegistry static property, that is initialized with a MetaClassRegistryImpl instance.&lt;br/&gt;
The MetaClassRegistryImpl contains a ConcurrentReaderHashMap wich holds references to all Expando classes, and metaclasses.&lt;/p&gt;

&lt;p&gt;And that&apos;s the problem. Since the ExpandoClasses and MetaClasses are usually created via script by a GroovyClassLoader, this map prevents them be garbage collected, as well as its GroovyClassLoader.&lt;/p&gt;

&lt;p&gt;In our application, we use a schema similar to a web server. We create a different class loader for each executed script. This is necessary since users want to modificate scripts and see the results imediatelly. We&apos;ve even tried to use the GroovyScriptEngine in the past, but it has a very big flaw. its performance is terrible in a network (I even opened another issue for this). Also, we like the benefit of having a different class loader per script, since we may have different execution environments.&lt;/p&gt;

&lt;p&gt;As a result, we are suffering the &quot;the dreaded &quot;java.lang.OutOfMemoryError: PermGen space&quot; exception&quot;, as described in this article:&lt;br/&gt;
&lt;a href=&quot;http://blogs.sun.com/fkieviet/entry/classloader_leaks_the_dreaded_java&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://blogs.sun.com/fkieviet/entry/classloader_leaks_the_dreaded_java&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To simulate the problem, run the above java program with -Xmx500m option:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-style: solid;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeHeader panelHeader&quot; style=&quot;border-bottom-width: 1px;border-bottom-style: solid;&quot;&gt;&lt;b&gt;Test.java&lt;/b&gt;&lt;/div&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;Test {
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; void main(&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;[] args) &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; Exception {
        &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; i = 0; i &amp;lt; &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;.MAX_VALUE; i++) {
            GroovyClassLoader gcl = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; GroovyClassLoader();
            Leak leak = (Leak)gcl.parseClass(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; File(&lt;span class=&quot;code-quote&quot;&gt;&quot;ResourceLeak.groovy&quot;&lt;/span&gt;)).newInstance();
            leak.leakResources();
            &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (i % 1000 == 0) {
                &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.out.println(i);
                &lt;span class=&quot;code-object&quot;&gt;System&lt;/span&gt;.gc();
            }
        }
    }
    
    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;interface&lt;/span&gt; Leak {
        void leakResources();
    }
} &lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It uses this script:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-style: solid;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeHeader panelHeader&quot; style=&quot;border-bottom-width: 1px;border-bottom-style: solid;&quot;&gt;&lt;b&gt;ResourceLeak.groovy&lt;/b&gt;&lt;/div&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;ResourceLeak &lt;span class=&quot;code-keyword&quot;&gt;implements&lt;/span&gt; Teste.Leak {
    void leakResources() {
		ResourceLeak.metaClass.&lt;span class=&quot;code-quote&quot;&gt;&apos;&lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt;&apos;&lt;/span&gt;.test = { 
			&lt;span class=&quot;code-comment&quot;&gt;//Do nothing 
&lt;/span&gt;		}
		ResourceLeak.test()		
    }
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The problem will occur after 7000 executions. In this sample, we need 500Mb heap, otherwise, the heap space will go out of memory before the permgen space. But in our real situation (with bigger classes, and more classes in the class loader) 200Mb heap is enough, since the permgen space is consumed faster.&lt;/p&gt;</description>
                <environment>java 1.5.0_14 and java 1.6.0_04</environment>
        <key id="12817821">GROOVY-2875</key>
            <summary>MetaClassRegistryImpl constantMetaClasses map is leaking resources</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="1" iconUrl="https://issues.apache.org/jira/images/icons/priorities/blocker.svg">Blocker</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="blackdrag">Jochen Theodorou</assignee>
                                    <reporter username="vinigodoy">Vin&#237;cius Godoy de Mendon&#231;a</reporter>
                        <labels>
                    </labels>
                <created>Fri, 30 May 2008 12:47:47 +0000</created>
                <updated>Mon, 1 Sep 2008 10:39:15 +0000</updated>
                            <resolved>Mon, 1 Sep 2008 10:39:15 +0000</resolved>
                                    <version>1.5.6</version>
                                    <fixVersion>1.5.7</fixVersion>
                    <fixVersion>1.6-beta-2</fixVersion>
                                    <component>groovy-jdk</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>2</watches>
                                                                                                                <comments>
                            <comment id="14464918" author="blackdrag" created="Mon, 2 Jun 2008 07:40:51 +0000"  >&lt;p&gt;This is a non trivial problem in respect to many cases. Currently the MetaClassImpl is designed to keep the default MetaClass as long as it is needed, that means the default can be collected. But as soon as a user sets a custom MetaClass the default is to keep it until the dead come back or the VM is terminated. &lt;/p&gt;

&lt;p&gt;Our problem is that we can not know if the MetaClass will be needed or not. The standard case in Groovy is that you execute many scripts that somehow interact with each other. So there is no defined process of script creation, execution and removing resources which I could use to clear the registry. I could now for example say, that the MetaClass should not prevent ResourceLeak from being collected and the MetaClass should be collected along with it. That&apos;s true, but for this we would need a reference from the class to the MetaClass. Which could be done for classes created by Groovy, but not for classes from Java. So you could for example create a Java class each time the script is run and change its MetaClass like above and we would get the same problem again. Any solution that tries some kind of tracking or referencing the class as well as the MetaClass failed in more earlier attempts. &lt;/p&gt;

&lt;p&gt;But there are solutions to your problem as well. One way would be to use different class loaders loading the Groovy classes with them, so that you can discard all of them together with the registry. Another solution would be to remove each MetaClass you added. To keep track of this I would suggest to exchange the getMetaClass method on Class with a version that allows you to track the added classes. The second version is not threadsafe of course.&lt;/p&gt;

&lt;p&gt;ah, yes... why don&apos;t you cache the class? There wouldn&apos;t be a leak in that case.&lt;/p&gt;
</comment>
                            <comment id="14464855" author="vinigodoy" created="Mon, 2 Jun 2008 07:56:27 +0000"  >&lt;p&gt;Okay, I see that this problem is really tricky. &lt;/p&gt;

&lt;p&gt;But, the second situation you mentioned above (creating a Java class, changing it&apos;s metaclass) is requires a much more explicit action by the programmer. The sample I gave you when I created this issue is a very simple one, and no one is expecting that in such trivial case groovy will leak resources.&lt;/p&gt;

&lt;p&gt;Since this can be done for classes created by groovy (and that&apos;s my case), I think it&apos;s a good idea to do it.&lt;/p&gt;

&lt;p&gt;Now, talking about the solution you proposed. The creation of a new classloader I could understand, but the caching solution not. How can I cache a class?&lt;/p&gt;</comment>
                            <comment id="14464909" author="blackdrag" created="Mon, 2 Jun 2008 08:14:44 +0000"  >&lt;p&gt;much more explicit action for java classes? &lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;               &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;.metaClass.&lt;span class=&quot;code-quote&quot;&gt;&apos;&lt;span class=&quot;code-keyword&quot;&gt;static&lt;/span&gt;&apos;&lt;/span&gt;.test = { 
			&lt;span class=&quot;code-comment&quot;&gt;//Do nothing 
&lt;/span&gt;		}
		&lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;.test()
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt; that is not any more explicit than your code.&lt;/p&gt;

&lt;p&gt;About caching... you do &lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;GroovyClassLoader gcl = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; GroovyClassLoader();
Leak leak = (Leak)gcl.parseClass(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; File(&lt;span class=&quot;code-quote&quot;&gt;&quot;ResourceLeak.groovy&quot;&lt;/span&gt;)).newInstance();&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt; Which means you create a new class loader and a new class each time. gcl.parseClass(new File(&quot;ResourceLeak.groovy&quot;)) will give you the class which you could cache... for example you could use a map and say for this file I use this class. I think GCL supports this after enabling it. Even with recompilation... but with recompilation comes the real problem here: you have to track what classes are used by the script and test your class if it needs recompilation if any class it depends on has been changed. That&apos;s one ofthe reasons GroovyScriptEngine is as slow as it is.&lt;/p&gt;</comment>
                            <comment id="14464885" author="vinigodoy" created="Mon, 2 Jun 2008 08:23:37 +0000"  >&lt;p&gt;Oh... now I see, you are talking about java classes in the groovy code. I thought about Java classes created in Java, and sent to the script. Sorry, but I can&apos;t see the other problems as fast as you can do, since my groovy knowledge is limited to a little more than I use here.&lt;/p&gt;

&lt;p&gt;The caching has a problem, which made me create multiple classloaders in the first place. If the script changes, a rerun will not see this change. &lt;br/&gt;
I tried to recompilate the class without success. How can I do it?&lt;/p&gt;

&lt;p&gt;I&apos;ll try creating a new classloader, as you suggested.&lt;/p&gt;

&lt;p&gt;About the issue. Will you close it? How are you planning to solve it?&lt;/p&gt;</comment>
                            <comment id="14464974" author="graemerocher" created="Tue, 3 Jun 2008 06:17:05 +0000"  >&lt;p&gt;This issue is not really resolvable by Groovy, you could have similar issues in a Java program if you compiled java classes at runtime. At the end of the day in this case you are wanting to add dynamic behaviour to classes that get loaded dynamically, this dynamic behaviour has to be kept somewhere by Groovy in order for the behaviour of your program to stay consistent. &lt;/p&gt;

&lt;p&gt;Groovy is doing the right thing by keeping this behaviour around. Your program is doing the wrong thing by not cleaning up this new behaviour you add to dynamically loaded classes. If you added the following code to your example program the issue would go away:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;def theClass = gcl.parseClass(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; File(&lt;span class=&quot;code-quote&quot;&gt;&quot;ResourceLeak.groovy&quot;&lt;/span&gt;))
Leak leak = (Leak)theClass.newInstance()
            leak.leakResources();

GroovySystem.metaClass.registry.removeMetaClass(theClass)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We have to do this for example in Grails in the destroy() method of the Grails servlet to make sure Grails classes don&apos;t hang around when you undeploy a Grails web application&lt;/p&gt;</comment>
                            <comment id="14464951" author="graemerocher" created="Tue, 3 Jun 2008 06:21:38 +0000"  >&lt;p&gt;On a side note Groovy 1.6 may solve this issue for you if you add new behaviour using per instance meta classes rather than global meta classes as you are doing here. In Groovy 1.6 you could do something like:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;leak.metaClass.mixin MyNewMethods
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Then when the instance goes away so does its meta class&lt;/p&gt;</comment>
                            <comment id="14464911" author="vinigodoy" created="Tue, 3 Jun 2008 07:05:13 +0000"  >&lt;p&gt;Couldn&apos;t you create a clear method of the metaclassregistry? &lt;br/&gt;
This whould be much simpler than calling removing class-by-class.&lt;/p&gt;

&lt;p&gt;This is useful since I don&apos;t know exactly what other metaclasses the script may have created. Also, it allow me to call the method without changing the scripts. Most part of the scripts that my app runs are not written by me, or by any member of my team.&lt;/p&gt;</comment>
                            <comment id="14464935" author="blackdrag" created="Tue, 3 Jun 2008 07:34:52 +0000"  >&lt;p&gt;but a clear method is not thread safe... for example imagine you change the MetaClass in one thread (A) and then execute code based on that in the same thread, while in another thread (B) you call clear and it is executed right after the first thread (A) has changed the MetaClass. The result would be that execution of the code in the first thread (A) will fail, because the expected MetaClass got deleted!&lt;/p&gt;

&lt;p&gt;So do you have a safe point where you can simply clear the registry?&lt;/p&gt;</comment>
                            <comment id="14464800" author="vinigodoy" created="Tue, 3 Jun 2008 07:46:00 +0000"  >&lt;p&gt;But this same problem can occur with the suggested remove implementation, right?&lt;/p&gt;</comment>
                            <comment id="14464900" author="blackdrag" created="Tue, 3 Jun 2008 08:09:50 +0000"  >&lt;p&gt;you mean if a metaclass is set for an arbitrary class? Yes, I guess that&apos;s true. That&apos;s why using Groovy on a per Thread and class loader base would be better for your app. But ok, given that that should not be used, what could be done? &lt;/p&gt;

&lt;p&gt;If the removal should be done manually and not be triggered by garbage collection, but by an explicit method call of some kind and if this should try to not to affect other threads as best as possible, then we need a better way to track the metaclass setting actions.&lt;/p&gt;

&lt;p&gt;what would be if we had a listener at the registry that informs you when a new global metaclass is set? You would then have a reference to the new MetaClass and the Class that the MetaClass is used for. You could then for example store in what thread that happened and after the script is done you could remove all the classes in the registry. Or you could track the classloader that was used for this and remove all classes that are using a certain classloader.&lt;/p&gt;

&lt;p&gt;Another way would be that we change Groovy to allow the user to set a new registry. Then you could have a thread local registry and simply call clear later. But I think this solution is probably more difficult.&lt;/p&gt;</comment>
                            <comment id="14464952" author="vinigodoy" created="Tue, 3 Jun 2008 09:30:24 +0000"  >&lt;p&gt;Both of the latest solutions are fine for me. We also think that the listener solution is the finest one.&lt;/p&gt;</comment>
                            <comment id="14465050" author="ait" created="Mon, 23 Jun 2008 04:33:30 +0000"  >&lt;p&gt;It is by-design behavior.&lt;br/&gt;
You should remove meta class manually when you don&apos;t need it any more.&lt;/p&gt;</comment>
                            <comment id="14464993" author="vinigodoy" created="Mon, 23 Jun 2008 07:36:57 +0000"  >&lt;p&gt;How about the listener we discussed before? Will it be implemented?&lt;br/&gt;
Otherwise, it&apos;s almost impossible to know what classes should be manually removed!&lt;/p&gt;</comment>
                            <comment id="14465051" author="vinigodoy" created="Mon, 23 Jun 2008 15:40:58 +0000"  >&lt;p&gt;For those who have the same problem of me, there&apos;s a dangerous, yet usefull workaround.&lt;br/&gt;
You can use reflection to manually clear the groovy class cache. This is sensitive to groovy code changes, and should only be used while the listener solution is not implemented.&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;boolean&lt;/span&gt; clearGroovyClassesCache() {
        &lt;span class=&quot;code-keyword&quot;&gt;try&lt;/span&gt; {
            &lt;span class=&quot;code-comment&quot;&gt;// Retrieve the fields we will manipulate
&lt;/span&gt;            &lt;span class=&quot;code-object&quot;&gt;Class&lt;/span&gt;&amp;lt;MetaClassRegistryImpl&amp;gt; mcriClass = MetaClassRegistryImpl.class;

            Field constantMetaClassesField = mcriClass.getDeclaredField(&lt;span class=&quot;code-quote&quot;&gt;&quot;constantMetaClasses&quot;&lt;/span&gt;);
            constantMetaClassesField.setAccessible(&lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;);

            Field constantMetaClassCountField = mcriClass.getDeclaredField(&lt;span class=&quot;code-quote&quot;&gt;&quot;constantMetaClassCount&quot;&lt;/span&gt;);
            constantMetaClassCountField.setAccessible(&lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;);

            &lt;span class=&quot;code-comment&quot;&gt;// Retrieve the object to be manipulate
&lt;/span&gt;            &lt;span class=&quot;code-object&quot;&gt;Class&lt;/span&gt;&amp;lt;GroovySystem&amp;gt; gsClass = GroovySystem.class;
            Field metaClassRegistryField = gsClass.getDeclaredField(&lt;span class=&quot;code-quote&quot;&gt;&quot;META_CLASS_REGISTRY&quot;&lt;/span&gt;);
            metaClassRegistryField.setAccessible(&lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;);
            MetaClassRegistryImpl mcri = (MetaClassRegistryImpl) metaClassRegistryField.get(&lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;);
            ConcurrentReaderHashMap constantMetaClasses = (ConcurrentReaderHashMap) constantMetaClassesField.get(mcri);

            &lt;span class=&quot;code-comment&quot;&gt;// Clears the map
&lt;/span&gt;            constantMetaClasses.clear();
            constantMetaClassCountField.set(mcri, 0);
            
            &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;true&lt;/span&gt;;
        }  &lt;span class=&quot;code-keyword&quot;&gt;catch&lt;/span&gt; (Exception e) {
            &lt;span class=&quot;code-comment&quot;&gt;//Log &lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt; exception. It indicates that the code changed.
&lt;/span&gt;            &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;false&lt;/span&gt;;
        }
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This code is obviously not thread-safe. &lt;br/&gt;
So users must ensure that it is safe to use it before doing so.&lt;/p&gt;</comment>
                            <comment id="14465062" author="blackdrag" created="Thu, 26 Jun 2008 09:25:51 +0000"  >&lt;p&gt;once I have my internet connection back, you will get the listener and a thread safe way of iterating them too.&lt;/p&gt;</comment>
                            <comment id="14465100" author="blackdrag" created="Fri, 1 Aug 2008 12:16:28 +0000"  >&lt;p&gt;I added an iterator that you can use, and I added listener that you could use as well.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            17 years, 17 weeks, 4 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i2cny7:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12312220" key="com.atlassian.jira.plugin.system.customfieldtypes:radiobuttons">
                        <customfieldname>Testcase included</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="11060"><![CDATA[Yes]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                        </customfields>
    </item>
</channel>
</rss>