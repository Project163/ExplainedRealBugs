<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Wed Nov 12 00:04:39 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[GROOVY-2749] eachLine and splitEachLine work without encoding</title>
                <link>https://issues.apache.org/jira/browse/GROOVY-2749</link>
                <project id="12318123" key="GROOVY">Groovy</project>
                    <description>&lt;p&gt;several methods where added named eachLine and splitEachLine. But on InputStream no encoding is given, thus a InputStreamReader created there uses the default encoding, which might be wrong in many case. I personally would add the methods with the encoding variant and remove the ones without encoding for InputStream and URL.  not using an encoding makes sense for String, because the encoding is already done then, in fact using an ecoding there could be seen as wrong. But not using an encoding on InputStream is wrong too. It is not portable and will kick you later. This means:&lt;/p&gt;

&lt;p&gt;eachLine:&lt;/p&gt;

&lt;p&gt;InputStream.eachLine(Closure) --&amp;gt; should be removed&lt;br/&gt;
InputStream.eachLine(String encoding, Closure) --&amp;gt; should be added&lt;br/&gt;
URL.eachLine(Closure) --&amp;gt; should be removed&lt;br/&gt;
URL.eachLine(String encoding, Closure) --&amp;gt; could be added, but I would prefer:&lt;br/&gt;
URL.toInputStream() ---&amp;gt; I prefer that, because then eachLine from InputStream can be used&lt;/p&gt;

&lt;p&gt;splitEachLine:&lt;/p&gt;

&lt;p&gt;InputStream.splitEachLine(String sep, Closure closure)  --&amp;gt; should be removed&lt;br/&gt;
InputStream.splitEachLine(String encoding, String sep, Closure closure)  --&amp;gt; should be added&lt;br/&gt;
URL.splitEachLine(String sep, Closure closure)  --&amp;gt; should be removed&lt;br/&gt;
URL.splitEachLine(String encoding, String sep, Closure closure)  --&amp;gt; could be added, again I prefer URL.toInputStream().. or URL.input&lt;/p&gt;

&lt;p&gt;then all these each method should not return void, instead they should return what the closure returns the last time it was called. This allows writing a collecting closure which has to be added.. something like this&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;Collector &lt;span class=&quot;code-keyword&quot;&gt;extends&lt;/span&gt; Closure {
  def closure
  def values = []
  def doCall(&lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt;[] args) {
    &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (closure!=&lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;) closure(*args)
    values &amp;lt;&amp;lt; args
    &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; values
  }
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
</description>
                <environment></environment>
        <key id="12817788">GROOVY-2749</key>
            <summary>eachLine and splitEachLine work without encoding</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="paulk">Paul King</assignee>
                                    <reporter username="blackdrag">Jochen Theodorou</reporter>
                        <labels>
                    </labels>
                <created>Mon, 14 Apr 2008 06:03:58 +0000</created>
                <updated>Mon, 16 Jun 2008 16:25:17 +0000</updated>
                            <resolved>Wed, 16 Apr 2008 17:07:13 +0000</resolved>
                                    <version>1.5.5</version>
                                    <fixVersion>1.5.6</fixVersion>
                    <fixVersion>1.6-beta-1</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>1</watches>
                                                                                                                <comments>
                            <comment id="14464625" author="paulk" created="Mon, 14 Apr 2008 07:17:56 +0000"  >&lt;p&gt;Changes made as requested. It does beg the question though, we sometimes are going to return the last closure result. Other times we return the self object to allow chaining. It would be nice to have a consistent rule for this.&lt;/p&gt;</comment>
                            <comment id="14478065" author="paulk" created="Mon, 14 Apr 2008 23:53:15 +0000"  >&lt;p&gt;I&apos;ll add back in the non-encoding versions this evening. I won&apos;t default them to UTF-8, I&apos;ll just put them back the way they were.&lt;/p&gt;</comment>
                            <comment id="14464596" author="russel" created="Tue, 15 Apr 2008 01:20:49 +0000"  >&lt;p&gt;This is/was a breaking change and should not have appeared in 1.5.5.&lt;/p&gt;</comment>
                            <comment id="14478075" author="paulk" created="Tue, 15 Apr 2008 01:46:31 +0000"  >&lt;p&gt;Yes, it was an oversight that they were removed. I made some additions which should have caused no problems then at the last minute, we refactored some of the additions and two existing methods were caught up in that by accident. Jochen probably didn&apos;t realise that the methods were existing when he asked me to remove/refactor them (I moved all of the eachLine methods together in the source file which no doubt made that harder to detect). I should have realised this too when I did the change. The last minute nature of this change didn&apos;t help.&lt;/p&gt;

&lt;p&gt;I don&apos;t see this as a major catastrophe. Just one of those things that happen sometimes. My take on this is that we really do need to have formal release candidates even on minor releases (though they could be over much shorter durations than we do for major releases).&lt;/p&gt;</comment>
                            <comment id="14478097" author="paulk" created="Tue, 15 Apr 2008 01:48:25 +0000"  >&lt;p&gt;The other lesson for me is that we need to up the coverage of our tests. If this change had caused a test to fail, it would have been spotted immediately and not have slipped through undetected.&lt;/p&gt;</comment>
                            <comment id="14464547" author="russel" created="Tue, 15 Apr 2008 01:54:16 +0000"  >&lt;p&gt;Agreed on all points &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;So I guess the question is whether:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;def process = command.execute ( )
process.in.eachLine ( doSomething )
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;should work or not.&lt;/p&gt;</comment>
                            <comment id="14464582" author="guillaume" created="Tue, 15 Apr 2008 02:51:03 +0000"  >&lt;p&gt;Despite the discussions on why System.in.readLine() was deprecated a while ago, perhaps we could also revisit this.&lt;br/&gt;
By default, System.in.readLine() could be restored and use the default system encoding, and we could add variants which also explicitely take an encoding in parameter.&lt;br/&gt;
System.in.readLine() is pretty handy.&lt;/p&gt;</comment>
                            <comment id="14478117" author="paulk" created="Tue, 15 Apr 2008 06:32:19 +0000"  >&lt;p&gt;OK, added back in the two accidentally refactored-out-of-existence methods.&lt;/p&gt;

&lt;p&gt;For good measure, I also added &lt;tt&gt;InputStream.splitEachLine(String sep, Closure closure)&lt;/tt&gt; back in as it was now a hole in the set of available methods. Caveat Emptor as for all the other methods without the charset.&lt;/p&gt;

&lt;p&gt;I also added in these as they can help deal with the issues around StreamDecoder usage with InputStreamReader:&lt;br/&gt;
&lt;tt&gt;withReader(URL url, String charset, Closure closure)&lt;/tt&gt;&lt;br/&gt;
&lt;tt&gt;withReader(InputStream in, String charset, Closure closure)&lt;/tt&gt;&lt;br/&gt;
&lt;tt&gt;newReader(InputStream self, String charset)&lt;/tt&gt;&lt;/p&gt;

&lt;p&gt;I am not sure how to handle &lt;tt&gt;System.in.readLine()&lt;/tt&gt;. In hindsight, if I was starting from scratch with such methods in Groovy, I would probably get rid of all line processing methods on InputStreams and URLs and just have ways to get Readers from them and have all line processing in terms of readers.&lt;/p&gt;</comment>
                            <comment id="14464966" author="veita" created="Sun, 15 Jun 2008 06:12:17 +0000"  >&lt;p&gt;File and URL have an eachLine method. So I wonder why File and URL do not have an encoding property.&lt;/p&gt;

&lt;p&gt;This would be quite natural, in my opinion, since Groovy extends the java.io.File semantics to also cover the file contents.&lt;/p&gt;

&lt;p&gt;For File this could probably be done by implementing groovy.io.File extends java.io.File.&lt;/p&gt;
</comment>
                            <comment id="14478197" author="paulk" created="Sun, 15 Jun 2008 06:47:07 +0000"  >&lt;p&gt;I guess it might be possible but eachLine etc. sets up a reader under the covers and it is that reader that has an encoding. You could just as easily do an eachByte on a File or URL in which case no encoding would be involved.&lt;/p&gt;</comment>
                            <comment id="14465021" author="veita" created="Sun, 15 Jun 2008 16:27:34 +0000"  >&lt;p&gt;Yes, the reader is being constructed from the File via the CharsetToolkit.&lt;/p&gt;

&lt;p&gt;If I understand the code correctly, CharsetToolkit tries to determine the encoding from byte order marks or the file character data. This is a good approach for text/plain files even though it may fail for non-unicode charsets. If Groovy would provide File with a charset property (by deriving an own File class from java.io.File or by a generic property extension mechanism) this, if present, could override the charset choosen by CharsetToolkit.&lt;/p&gt;

&lt;p&gt;I do not know if the benefits of may proposal would outweigh the drawbacks of increased complexity in the Groovy runtime. So I think it needs some more discussion.&lt;/p&gt;

</comment>
                            <comment id="14464981" author="blackdrag" created="Sun, 15 Jun 2008 17:41:29 +0000"  >&lt;p&gt;How would such a Groovy specific file class be better than the encoding property java uses to set the file default encoding?&lt;/p&gt;</comment>
                            <comment id="14465022" author="veita" created="Mon, 16 Jun 2008 02:32:21 +0000"  >&lt;p&gt;For the same reason as InputStreamReader has constructors with charsets.&lt;/p&gt;

&lt;p&gt;The default file encoding is a per-VM property whereas the files a VM processes may have many different encodings.&lt;/p&gt;</comment>
                            <comment id="14465004" author="blackdrag" created="Mon, 16 Jun 2008 09:37:34 +0000"  >&lt;p&gt;I guess I did not explain myself very good...  there are different concepts of files and in Java a file is more like a reference to something that might exist on the file system. For the contents of the file you have streams and reader. Therefor the encoding is something the reader and/or stream have to handle, not the file itself. There is a property to support a default encoding, so he lazy programmer does not have to use the encoding all other the place. I must  say, I personally prefer the explicit usage of the encoding, because I am often on systems using multiple encodings and relaying on the default encoding has often been proofed to be a bad idea. To say it more strict, I generally dislike the usage of a default encoding in any kind... but well, it is not really my job to educate other people here. Only, when adding a new concept to Groovy I would of course prefer one that has not this kind of thinking error built in. now your &quot;files&quot; differ from the Java concept. They are a concept on their own, and it seems you want to use them instead of normal files. But in this case it is nothing we have to add to java.io.File. No, not right... you want to use it in places where File is used. Right? But we can not change the bytecode for for example InputStreamReader, that if it uses a FileInputStream, that uses &quot;our&quot; files, that not the default encoding for Java is used, but the encoding you did set on the file. So this would only work well in the Groovy sphere.. and in that case.. why use java.io.File directly? It would be so easy to write a small File handling API for reading ext files on its own . &lt;/p&gt;

&lt;p&gt;So to answer your question why File and URL have no encoding property: Because they are references to things that may or may not exist, and that may or not be text data in a certain encoding. They could be binary data as well. And not to forget, that encoded text might be read as binary data too!&lt;/p&gt;

&lt;p&gt;From the technical side we have the problem, that we can not attach foreign per instance properties. We can also not change the bytecode of libs, just to support an idea of files that conflicts with the original idea of files in Java.&lt;/p&gt;</comment>
                            <comment id="14464931" author="veita" created="Mon, 16 Jun 2008 16:25:17 +0000"  >&lt;p&gt;I fully agree with what you say about Java file objects as references (names) and the explicit usage of encodings with streams.&lt;/p&gt;

&lt;p&gt;As said above, methods like File.eachLine, File.append, and so on, seemingly extend the file semantics to also cover the contents of the file. This was the reason to think about file properties such as charset that might complete the notion of file = name + metadata + content.&lt;/p&gt;

&lt;p&gt;Technically a extension to java.io.File (and other classes) could be achieved e.g. by providing a class that extends java.io.File, or through a more general approach, by aggregating per instance properties to arbitrary objects. The latter could be implemented without any changes to bytecode, e.g. using weak hash maps with the object instances as keys. However, as already said, I&apos;m not quite sure if one would like to have such constructs in the implementation of a programming language since they increase complexity and lead to additional synchronization overhead.&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            17 years, 24 weeks, 1 day ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i2c4uv:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </customfields>
    </item>
</channel>
</rss>