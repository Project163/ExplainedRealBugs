<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Wed Nov 12 00:09:48 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[GROOVY-3173] Assignment to array elements is inconsistent with assignment to fields and variables</title>
                <link>https://issues.apache.org/jira/browse/GROOVY-3173</link>
                <project id="12318123" key="GROOVY">Groovy</project>
                    <description>&lt;p&gt;As detailed in the specific case of char[] in &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-3165&quot; title=&quot;Regression in assignment of single character strings to char array element&quot; class=&quot;issue-link&quot; data-issue-key=&quot;GROOVY-3165&quot;&gt;&lt;del&gt;GROOVY-3165&lt;/del&gt;&lt;/a&gt;, assignment to array elements in a value context is inconsistent with the same operations on fields and variables.&lt;/p&gt;

&lt;p&gt;Generally these should all be true:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;T x
def v = (x = &amp;lt;any&amp;gt;)

&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; x.is(v)

T[] x = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; T[1]
def V = (X[0] = &amp;lt;any&amp;gt;)

&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; X[0].is(V)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;In the case of primitive types, then equality rather than identity should be true.&lt;/p&gt;
</description>
                <environment></environment>
        <key id="12814413">GROOVY-3173</key>
            <summary>Assignment to array elements is inconsistent with assignment to fields and variables</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="2">Won&apos;t Fix</resolution>
                                        <assignee username="blackdrag">Jochen Theodorou</assignee>
                                    <reporter username="jimwhite">James P. White</reporter>
                        <labels>
                    </labels>
                <created>Thu, 27 Nov 2008 11:31:36 +0000</created>
                <updated>Fri, 7 Jan 2011 05:47:58 +0000</updated>
                            <resolved>Fri, 7 Jan 2011 05:47:57 +0000</resolved>
                                    <version>1.6</version>
                                                        <due></due>
                            <votes>0</votes>
                                    <watches>1</watches>
                                                                                                                <comments>
                            <comment id="14465863" author="roshandawrani" created="Fri, 5 Dec 2008 15:33:26 +0000"  >&lt;p&gt;Hi,&lt;br/&gt;
Now that it is a generic issue related to assignments to elements of all array types (all sub-classes of ArrayPutAtMetaMethod) and no specific issue has been cited, I wanted some inputs on how to go identifying regression issues related to array element assignment between 1.5.8(DGM) and 1.6/1.7(*ArrayPutAtMetaMethod).&lt;/p&gt;

&lt;p&gt;1) Do I just look a putAt(..) in 1.5.8 DGM implementation and make sure that the corresponding *ArrayPutAtMetaMethod has the exact some implementation or not. If a difference in implementation is found, how do I be sure that the change was an oversight and not an intentional change?&lt;/p&gt;

&lt;p&gt;2) Shall I try to run ArrayTest.groovy from 1.5.8 and run it on 1.6/1.7 to identify which assignments are failing and fix those?&lt;/p&gt;

&lt;p&gt;rgds,&lt;br/&gt;
Roshan&lt;/p&gt;</comment>
                            <comment id="14465911" author="blackdrag" created="Thu, 11 Dec 2008 15:20:10 +0000"  >&lt;p&gt;If the implementation would differ, then we need to discuss he difference. Afaik the change was not intentional. The test looks ok to me, so running it against all actual versions sure gives a good inpput about the differences&lt;/p&gt;</comment>
                            <comment id="14465777" author="roshandawrani" created="Tue, 16 Dec 2008 12:45:22 +0000"  >&lt;p&gt;I think this issue has side-tracked from the issues that it is related to (which really started the issue).&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-3165&quot; title=&quot;Regression in assignment of single character strings to char array element&quot; class=&quot;issue-link&quot; data-issue-key=&quot;GROOVY-3165&quot;&gt;&lt;del&gt;GROOVY-3165&lt;/del&gt;&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-3167&quot; title=&quot;Integers not automatically converted to Bytes&quot; class=&quot;issue-link&quot; data-issue-key=&quot;GROOVY-3167&quot;&gt;&lt;del&gt;GROOVY-3167&lt;/del&gt;&lt;/a&gt; are about regression related issues in assignment to array elements whereas this issue is talking about something different - it is talking about making assignment to array elements consistent with assignment to variables. Should this one be un-linked from &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-3165&quot; title=&quot;Regression in assignment of single character strings to char array element&quot; class=&quot;issue-link&quot; data-issue-key=&quot;GROOVY-3165&quot;&gt;&lt;del&gt;GROOVY-3165&lt;/del&gt;&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-3167&quot; title=&quot;Integers not automatically converted to Bytes&quot; class=&quot;issue-link&quot; data-issue-key=&quot;GROOVY-3167&quot;&gt;&lt;del&gt;GROOVY-3167&lt;/del&gt;&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;From the regression point of view, if assignment to array elements in 1.5.x is different from 1.6 or 1.7, it is an issue. &lt;/p&gt;

&lt;p&gt;Array element and variable assignments are not consistent in 1.5.x too. So, from that inconsistency point of view, it is not a regression issue.&lt;/p&gt;

&lt;p&gt;I am really unclear about the scope of all these 3 related issues &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-3165&quot; title=&quot;Regression in assignment of single character strings to char array element&quot; class=&quot;issue-link&quot; data-issue-key=&quot;GROOVY-3165&quot;&gt;&lt;del&gt;GROOVY-3165&lt;/del&gt;&lt;/a&gt; / &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-3167&quot; title=&quot;Integers not automatically converted to Bytes&quot; class=&quot;issue-link&quot; data-issue-key=&quot;GROOVY-3167&quot;&gt;&lt;del&gt;GROOVY-3167&lt;/del&gt;&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-3173&quot; title=&quot;Assignment to array elements is inconsistent with assignment to fields and variables&quot; class=&quot;issue-link&quot; data-issue-key=&quot;GROOVY-3173&quot;&gt;&lt;del&gt;GROOVY-3173&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;</comment>
                            <comment id="14465974" author="jimwhite" created="Tue, 16 Dec 2008 16:03:23 +0000"  >&lt;p&gt;I stated the problem this way because &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-3165&quot; title=&quot;Regression in assignment of single character strings to char array element&quot; class=&quot;issue-link&quot; data-issue-key=&quot;GROOVY-3165&quot;&gt;&lt;del&gt;GROOVY-3165&lt;/del&gt;&lt;/a&gt; and &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-3167&quot; title=&quot;Integers not automatically converted to Bytes&quot; class=&quot;issue-link&quot; data-issue-key=&quot;GROOVY-3167&quot;&gt;&lt;del&gt;GROOVY-3167&lt;/del&gt;&lt;/a&gt; were regressions that were also symptoms of a somewhat larger issue that exists in Groovy 1.5.x too.&lt;/p&gt;

&lt;p&gt;If I thought that the fix used for &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-3165&quot; title=&quot;Regression in assignment of single character strings to char array element&quot; class=&quot;issue-link&quot; data-issue-key=&quot;GROOVY-3165&quot;&gt;&lt;del&gt;GROOVY-3165&lt;/del&gt;&lt;/a&gt; was the right way to go, then that approach could simply be extended to modifying all the affected types, as you started to do with &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-3167&quot; title=&quot;Integers not automatically converted to Bytes&quot; class=&quot;issue-link&quot; data-issue-key=&quot;GROOVY-3167&quot;&gt;&lt;del&gt;GROOVY-3167&lt;/del&gt;&lt;/a&gt;.  &lt;/p&gt;

&lt;p&gt;If the assignment is to a stringish variable (char, Character, or String) then the GString is toStringed and that is also the value of the expression.  I believe we all agree that is the correct behavior.  With the current fix for 3167 though the value of the expression is the original GString object which is not at all the same thing as what the array element has in it.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-3167&quot; title=&quot;Integers not automatically converted to Bytes&quot; class=&quot;issue-link&quot; data-issue-key=&quot;GROOVY-3167&quot;&gt;&lt;del&gt;GROOVY-3167&lt;/del&gt;&lt;/a&gt; shows that the same sort of problem exists with conversions amongst the various numbers (both primitive and Number implementations) and the stringish things.&lt;/p&gt;

&lt;p&gt;If the implementation is changed to satisfy this issue&apos;s tests, the problem for the various types will be fixed.  And because I think it is likely you will need to take a different approach, those issues are dependent because the fix will be different. Certainly we&apos;ll have to test them, along with filling out the tests for this issue to cover all the type/conversion combinations - or at least enough to convince everyone it is really fixed.&lt;/p&gt;
</comment>
                            <comment id="14465931" author="roshandawrani" created="Tue, 16 Dec 2008 23:39:20 +0000"  >&lt;p&gt;I am not trying to say that the issues you are highlighting are invalid. I am trying to say that at JIRA level, it will help if different kind of things are not mixed and scope/context does not change much.&lt;/p&gt;

&lt;p&gt;Can we agree that if something related to array element assignment works in 1.5.x but does not work in 1.6.x and trunk, it is part of this issue, otherwise not?&lt;/p&gt;

&lt;p&gt;My difficulty in going ahead with 3173 at the moment is that it has both regression and non-regression issues mixed up. Inconsistency between &quot;assignment to variables&quot; and &quot;assignment to array elements&quot; behaviors is not a regression issue as this issue is also present in 1.5.x branch. For regression issues, I can take up 1.5.x as the base and try to fix the issues on 1.6 and trunk but the non-regression issues like making the 2 behaviors consistent in all the branches (1.5.x, 1.6.x, trunk) is something that may need much discussion first.&lt;/p&gt;

&lt;p&gt;If they can be separated and this JIRA is limited to regression issues, I can probably move much faster on the &quot;regression&quot; issues related to array element assignment.&lt;/p&gt;</comment>
                            <comment id="14465968" author="jimwhite" created="Thu, 18 Dec 2008 18:10:02 +0000"  >&lt;p&gt;If you just want to fix the regressions then go ahead.  That is what the 3165/3167 issues are about.  &lt;/p&gt;

&lt;p&gt;If you do that you need to reopen them or create a new issue that covers all the affected types: char[], int[], String[], Character[], Integer[], long/Long[], etc...&lt;/p&gt;

&lt;p&gt;The reason I recommend fixing what I consider to be the &quot;real&quot; problem is that all that work will probably prove to have been unneccessary, and that fixing the logic that is dispatching down to those methods is quite possibly no harder to do.&lt;/p&gt;</comment>
                            <comment id="14466056" author="roshandawrani" created="Sat, 20 Dec 2008 07:21:06 +0000"  >&lt;p&gt;Hi,&lt;/p&gt;

&lt;p&gt;I have partially fixed this JIRA (point 1) but I need inputs on point 2 and 3 to proceed further.&lt;/p&gt;

&lt;p&gt;This JIRA  mainly has 3 requirements (collected from the testcase attached and the description).&lt;/p&gt;

&lt;p&gt;1)  Being able to assign single-character String/GString to Character[] elements.&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;This I have implemented as a partial fix for now.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;2)  Being able to assign single-character String (GString ?) to Integer[] elements.&lt;/p&gt;

    &lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;    &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;[] ia = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;[1]
    ia[0] = &lt;span class=&quot;code-quote&quot;&gt;&apos;c&apos;&lt;/span&gt;
    &lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; ia[0] == 99
    &lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
	&lt;li&gt;For consistency sake, should &apos;c&apos; be assignable to int[]/long[]/Long[]/short[]/Short[] elements too? Any others? Should single character GStrings be supported too? (To me, it looks a little odd being able to assign &quot;x&quot;, &apos;x&apos;, &quot;$x&quot; to int/Integer, etc)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;3)  Value of the expression that assign values to array elements, as in &quot;def a = (x&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;=y)&quot;&lt;/p&gt;

&lt;p&gt;    What you expect to be the correct behavior is:&lt;/p&gt;
    &lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;    &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;[] ca = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;[1]
    v = (ca[0] = x)
    &lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; v.is(ca[0])
    &lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;    Currently, in all the branches, v gets x, v.is&lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/error.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; is true, and v.is(ca&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;) is false.&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Jochen noted earlier in 3165 that value of the assignment expression is ignored (so return values of DGM putAt() and XXXArrayPutAtMethodMethod.invoke() calls do not matter) and assignment of x to v in&lt;br/&gt;
    &quot;v = (ca&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt; = x)&quot; gets done with a compiler transformation.&lt;/li&gt;
&lt;/ul&gt;


&lt;ul&gt;
	&lt;li&gt;Right now I am not sure how big a change it will be to switch from compiler transformation to return values of the putAt() and XXXArrayPutAtMethodMethod.invoke(). Before starting to look into it, I wanted to check if the understanding &quot;assert v.is(ca&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;)&quot; is correct for &quot;v = (ca&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt; = x)&quot;. Even the current implementation where v gets x looks correct.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;rgds,&lt;br/&gt;
Roshan&lt;/p&gt;</comment>
                            <comment id="14466037" author="blackdrag" created="Sat, 20 Dec 2008 08:22:17 +0000"  >&lt;p&gt;(2) we said a string of length 1 is equal to char, so anything that is valid for char as value should be valid for the string as well. That means int,long,short,double,float the wrapper types of these and BigDecimal and BigInteger... in short any native number groovy supports.&lt;/p&gt;

&lt;p&gt;(3)  &lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;[] ca = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;[1]
    v = (ca[0] = x)
    &lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; v.is(ca[0])
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt; is only valid if x and v were Integers (or Number/Object) as well or else you have to use == instead of &quot;is&quot;. You say v gets the value of x, but ca&lt;span class=&quot;error&quot;&gt;&amp;#91;o&amp;#93;&lt;/span&gt; is not x. That probably means the value is unboxed and boxed again... maybe that should not happen.&lt;/p&gt;

&lt;p&gt;If you have a=b, then he compiler won&apos;t use the return value of that expression, since that expression usually has none. Instead it evaluates the right side first, saves the value, executes what is needed for the left side and then it will give the saved value as &quot;return value&quot;. If that where not the case a &quot;return a=b&quot; would not work. Currently I don&apos;t understand why this should be change if we have a&lt;span class=&quot;error&quot;&gt;&amp;#91;x&amp;#93;&lt;/span&gt;=b.&lt;/p&gt;</comment>
                            <comment id="14465903" author="roshandawrani" created="Sat, 20 Dec 2008 08:41:14 +0000"  >&lt;p&gt;regarding your reply to point 3)&lt;/p&gt;

&lt;p&gt;    I am not sure why &quot;return a = b&quot; would stop working if &quot;return value&quot; were to be changed as per this JIRA. Right now &quot;a = b&quot; returns b whereas as per this JIRA, it should return &quot;a&quot;. (&quot;a&quot; and &quot;b&quot; can be different because of type conversions that can happen)&lt;/p&gt;

&lt;p&gt;    If a = b were to return &quot;a&quot; and not &quot;b&quot;, wouldn&apos;t &quot;return a = b&quot; still work but just return a possible different value/type if conversion has happened?&lt;/p&gt;

&lt;p&gt;Whether it is correct to return &quot;a&quot; or &quot;b&quot; as a result of the expression &quot;a = b&quot; is a different  and is what is in contention here.&lt;/p&gt;</comment>
                            <comment id="14465988" author="roshandawrani" created="Sat, 20 Dec 2008 08:43:10 +0000"  >&lt;p&gt;So, single-character GStrings is also deemed equivalent to a char and single-char String and should be supported, right?&lt;/p&gt;</comment>
                            <comment id="14465958" author="blackdrag" created="Sun, 21 Dec 2008 06:59:29 +0000"  >&lt;p&gt;if you have &quot;return a=b&quot; then if we don&apos;t use the evaluation of b we get all the side effects when resolving a. There was for example an issue where a was a write-only property. The assignment then works without problem, but of course we cannot get the value of a, since there is none we can read. The result is a exception complaining about a read-only property a in &quot;return a=b&quot;. &lt;/p&gt;

&lt;p&gt;In case of &quot;return a&lt;span class=&quot;error&quot;&gt;&amp;#91;x&amp;#93;&lt;/span&gt;=b&quot; you would then have to call putAt, but you don&apos;t want to call getAt? Isn&apos;t that inconsistent? Also even if a can be read, it does not have to provide a fitting putAt and a getAt method at the same time. &lt;/p&gt;

&lt;p&gt;Would we use the return value of putAt, then  we would have to use the return value of a method call for &quot;a=b&quot; as well. Only what is that method? If a is a property, then it is a setter call, which usually returns nothing... so is it null? null would surely mean &quot;return a=b&quot; stops working in some cases. That&apos;s why I chose the more simple route of using the rval for the return. IMHO it is more consistent and just because putAt could have a return value, does not justify its usage&lt;/p&gt;

&lt;p&gt;As for GStrings... They are to be seen as kind of subclass of String, so what is done for String should be done for GString too&lt;/p&gt;</comment>
                            <comment id="14465973" author="roshandawrani" created="Sun, 21 Dec 2008 15:50:47 +0000"  >&lt;p&gt;Hi,&lt;br/&gt;
    In another partial fix, I have fixed the assignment of character / 1-char String / 1-char GString to number array elements (primitive and wrapper types).&lt;/p&gt;

&lt;p&gt;There are no more regression issues I can find. I have run ArrayTest of 1.5 on 1.6 and 1.7 too.&lt;/p&gt;

&lt;p&gt;So the only issue remaining is whether in &quot;v = x&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt; = y&quot;, &quot;v.is( y ) = true&quot;(when x&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt; and y are of different types) change has to be made or not. Jochen has highlighted some issues with that requirement in the comments above. Can we take a call on whether it needs to be done or not?&lt;/p&gt;

&lt;p&gt;Regarding the remaining work, let me know if I have missed out anything. As far as I understand, it is done.&lt;/p&gt;

&lt;p&gt;Thanks,&lt;br/&gt;
Roshan&lt;/p&gt;</comment>
                            <comment id="14466014" author="roshandawrani" created="Fri, 26 Dec 2008 11:29:09 +0000"  >&lt;p&gt;Hi guys,&lt;br/&gt;
Any more work required on this (more detailed question asked in previous comment &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; )?&lt;/p&gt;

&lt;p&gt;Else I can get it out of my plate. Can someone please confirm - one way or other?&lt;/p&gt;

&lt;p&gt;thanks,&lt;br/&gt;
Roshan&lt;/p&gt;</comment>
                            <comment id="14466124" author="roshandawrani" created="Tue, 30 Dec 2008 20:58:58 +0000"  >&lt;p&gt;Hi,&lt;br/&gt;
Since&lt;br/&gt;
1)  &quot;changing the return value of the expression&quot; is a change that will interfere with workings in other scenarios (as cited in comments above), and&lt;br/&gt;
2)  my multiple attempts to know if anything else is required on the remaining scope of this JIRA have not fetched any response, and no other regression issue has been highlighted,&lt;br/&gt;
I am assuming that in the remaining scope (apart from expression return value thing), no other change is required.&lt;/p&gt;

&lt;p&gt;So, I marking this issue as Fixed. Whatever was clearly communicated and all the regression issues I could find - has been fixed in the multiple partial fixes done for this JIRA.&lt;/p&gt;

&lt;p&gt;rgds,&lt;br/&gt;
Roshan&lt;/p&gt;</comment>
                            <comment id="14466024" author="jimwhite" created="Wed, 31 Dec 2008 01:00:03 +0000"  >&lt;p&gt;Trunk does not pass test case submitted for this issue.&lt;/p&gt;</comment>
                            <comment id="14466063" author="jimwhite" created="Wed, 31 Dec 2008 01:01:22 +0000"  >&lt;p&gt;The original patch can&apos;t be applied to trunk now.  Updated patch so it can be.&lt;/p&gt;</comment>
                            <comment id="14466125" author="roshandawrani" created="Wed, 31 Dec 2008 01:17:35 +0000"  >&lt;p&gt;I almost knew this is how it would pan out.&lt;/p&gt;

&lt;p&gt;Your requirement about changing the return value of expressions is in question, which I referred to many times but you did not get back/comment back on that. Apart from that, your remaining test case goes through.&lt;/p&gt;

&lt;p&gt;It will help if the focus is on providing information requested to proceed in a timely manner rather than on waiting and waiting and then re-opening the issue.&lt;/p&gt;</comment>
                            <comment id="14466078" author="roshandawrani" created="Wed, 31 Dec 2008 05:58:33 +0000"  >&lt;p&gt;Since the change requested in return value of the expression is in question and the rest of the request is done, I am un-assigning it so that rest of it can be handled as deemed fit.&lt;/p&gt;</comment>
                            <comment id="14466110" author="jimwhite" created="Wed, 31 Dec 2008 11:14:02 +0000"  >&lt;p&gt;I wasn&apos;t aware of any fix being available to test.  As soon as you indicated there was I tried it.  I didn&apos;t understand your not understanding the nature of this issue.  The need for assignment expressions for array elements to behave consistently with that for assignment to variables is not in question AFAIK.  Jochen agreed that the test case looked like what we want.&lt;/p&gt;</comment>
                            <comment id="14466025" author="roshandawrani" created="Wed, 31 Dec 2008 14:06:26 +0000"  >&lt;p&gt;Alright. I got a different impression from Jochen&apos;s comments. Maybe someone who understands the nature of the issue and the comments too can look at the return value of the expression change. I can spend my time elsewhere &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Wish you a happy 2009.&lt;/p&gt;</comment>
                            <comment id="14466089" author="blackdrag" created="Mon, 5 Jan 2009 06:56:49 +0000"  >&lt;p&gt;what exactly is left for this issue? Maybe an example of a edge case that I want to work:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;[] foo = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;[1]
def x = 1
GString bar = (foo[0] = &lt;span class=&quot;code-quote&quot;&gt;&quot;$x&quot;&lt;/span&gt;)

&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; foo[0] == &lt;span class=&quot;code-quote&quot;&gt;&quot;1&quot;&lt;/span&gt;
&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; bar.getValue(0) == x
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;since there is no path GString-&amp;gt;String-&amp;gt;GString that keeps the structure information it is required in this case that the expression foo&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt; = &quot;$x&quot; does return the unchanged GString. That means putAt for String[] would have to return the object it got without modification as would most such methods do. Therefor I think it is better if the the return value is ignored and the compiler is doing that stuff instead. This allows the user to be sure about this expression and it aligns with the normal assignment.&lt;/p&gt;

&lt;p&gt;So if nothing is left I would like to close this issue&lt;/p&gt;</comment>
                            <comment id="14466186" author="jimwhite" created="Tue, 6 Jan 2009 11:59:38 +0000"  >&lt;p&gt;There is a patch with the test case for this issue.  It&apos;s been updated recently so it should still apply for the trunk.  It doesn&apos;t cover all the conversion types, but it does address &lt;tt&gt;GString&lt;/tt&gt;.&lt;/p&gt;</comment>
                            <comment id="14466167" author="blackdrag" created="Tue, 6 Jan 2009 12:19:32 +0000"  >&lt;p&gt;so what is left is applying the patch?&lt;/p&gt;</comment>
                            <comment id="14466214" author="jimwhite" created="Tue, 6 Jan 2009 21:16:05 +0000"  >&lt;p&gt;Well, if you apply the patch for the test case then the build will break because this problem isn&apos;t fixed.&lt;/p&gt;</comment>
                            <comment id="14466144" author="roshandawrani" created="Thu, 8 Jan 2009 02:56:34 +0000"  >&lt;p&gt;The test case that is attached in the patch still has checks like &lt;/p&gt;

&lt;p&gt;Integer[] ca = new Integer&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;&lt;br/&gt;
v = (ca&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt; = 2.0)&lt;br/&gt;
assert ca&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;.is(v)&lt;/p&gt;

&lt;p&gt;If, as Jochen has mentioned, putAt returns the value unmodified, then ca&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt; gets the (possibly)modified value, whereas v gets the unmodified one. So. ca&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;.is(v) won&apos;t go through. That is what I have been highlighting for long now. Just this point has been in contention for a long time and is what is remaining.&lt;/p&gt;

&lt;p&gt;Apart from the in-contention return value thing, is there any other conversion type that is not covered? (Even this I have asked many times now)&lt;/p&gt;</comment>
                            <comment id="14466293" author="jimwhite" created="Fri, 9 Jan 2009 17:46:24 +0000"  >&lt;p&gt;I haven&apos;t enumerated every possible failure because they all have the same pattern.  &lt;/p&gt;

&lt;p&gt;Any assignment to an array element in which the &lt;tt&gt;XXXPutAtMetaMethod&lt;/tt&gt; does a conversion to the value is going to fail.  That is because it creates a new object (or a primitive value) that is different than the one returned by the assignment expression.  &lt;/p&gt;

&lt;p&gt;The behavior of assignment to a variable (or field) is what assignment to an array element should have.  That means the assignment expression returns the identical value that is put into the destination.  There is no way you&apos;re gonna fix this by having conversions inside the &lt;tt&gt;XXXPutAtMetaMethod&lt;/tt&gt; (unless you use a return value).   So either we have to do the conversion before the call or use a return value.&lt;/p&gt;

&lt;p&gt;I think the right approach is to put the array element type into the signature of the metamethod (&lt;tt&gt;PARAM_CLASS_ARR&lt;/tt&gt;) so that the conversion can be applied before the call (and thus available for the expression result if needed).  It should be able to use the same logic as the variable/field assignment code.  I started down that path when I first encountered this bug, but I discovered that changing the signature wasn&apos;t enough and that the compiler code would need to change as well, and I don&apos;t have time to dig into that.&lt;/p&gt;</comment>
                            <comment id="14466217" author="blackdrag" created="Sun, 11 Jan 2009 05:51:34 +0000"  >&lt;p&gt;I think that &lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;[] ca = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;[1]
v = (ca[0] = 2.0)
&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; ca[0].is(v)&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt; should be changed to&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;[] ca = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;[1]
v = (ca[0] = 2.0)
&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; ca[0] == v&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As I have shown with the GString example there are situations were any conversion done by the putAt method does not make sense. I don&apos;t think that keeping the referential identity for numbers, that is not even guaranteed in normal code&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;def a =1
def b=1
&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; a.is(b) &lt;span class=&quot;code-comment&quot;&gt;// might fail&lt;/span&gt;&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt; is something we should enforce here. I think an expression a = (b&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt; = c) should (with A being the static type of A and B being the static element type of b and (A) being a Groovy-cast to A) be &lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;def tmp = c
b[i] = (B) tmp
a = (A) tmp&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt; The cast is something we do for typed variables anyway, so that is not new. tmp is needed because c might be an expression that should be evaluated only once. If A and B are the same types, then the compiler has the &lt;b&gt;option&lt;/b&gt; to remove one cast, but that is no must do I would say.&lt;/p&gt;

&lt;p&gt;Also the type for a and/or be might be unknown if these are fields/properties. In case of fields/properties the field/property is responsible for the type conversion, because the only place we know for sure the type is the MetaClass in this case. So the expansion above becomes:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;def tmp = c
b[i] = (B) tmp
a = tmp
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now coming back to your Integer example... if a is a property, maybe not even known to what it actually resolves to yet, but let us assume it is an Integer.... how do you guarantee b&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt;.is(a)? Since putAt does not know the type at the time the method is called, transporting the type will not do. Doing the conversion before won&apos;t do either, because when you look at my GString example, then you see, that the conversion from GString to String is a one way road only and the a, that would accept the GString would get a incompatible String instead.&lt;/p&gt;

&lt;p&gt;I think instead of trying to find here a pattern that works in some special cases it is much better to have a general working solution with relaxed constraints. One such constraint is, that b&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt;.is(a) might not be true, but b&lt;span class=&quot;error&quot;&gt;&amp;#91;i&amp;#93;&lt;/span&gt;==a should be true for A==B.&lt;/p&gt;

&lt;p&gt;Can we agree to this?&lt;/p&gt;</comment>
                            <comment id="14466294" author="jimwhite" created="Sun, 11 Jan 2009 19:17:35 +0000"  >&lt;p&gt;No, I don&apos;t agree.  I believe the behavior that Groovy has for variables and fields is correct.&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt; a 
def b

b = (a = 1)
&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; b.is(a)

b = (a = &lt;span class=&quot;code-quote&quot;&gt;&apos;1&apos;&lt;/span&gt;)
&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; b.is(a)

&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; c

b = (c = &lt;span class=&quot;code-quote&quot;&gt;&quot;$a&quot;&lt;/span&gt;)
&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; b.is(c)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Therefore we should have the test case I started this issue with pass, which is this:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;[] a = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;[1]
def b

b = (a[0] = 1)
&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; b.is(a[0])

b = (a[0] = &lt;span class=&quot;code-quote&quot;&gt;&apos;1&apos;&lt;/span&gt;)
&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; b.is(a[0])

&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;[] c = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;[1]

b = (c[0] = &lt;span class=&quot;code-quote&quot;&gt;&quot;$a&quot;&lt;/span&gt;)
&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; b.is(c[0])
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This whole problem no doubt arises because the compiler treats the variable/field case differently than array elements.  If you&apos;d roll the array assignment handling into the code for variable/field assignment then this problem would be fixed.&lt;/p&gt;
</comment>
                            <comment id="14466253" author="blackdrag" created="Sun, 11 Jan 2009 21:23:53 +0000"  >&lt;p&gt;I think we have here 3 cases we should look at:&lt;/p&gt;

&lt;p&gt;case 1:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt; a
def b
b = (a=1l)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;case 2:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;[] a = [&lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;]
def b
b = (a[0]=1l)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;case 3:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;class &lt;/span&gt;X {
  &lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt; a
}
def x = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; X()
def b
b = (x.a=1l)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Currently case 2+3 will cause b to be the Long 1, where in case 1 the value will be Integer 1. case 3 is equal to field assignment, so field assignment and variable assignment behave different. Now my position is that because of the possible problems we should say that case 2+3 are right and case 1 is in fact a bug. My reason for this is that for example in the property version (case 3) the actual transformation will happen in the setter which usually is void. So strictly using the return value of that would mean that x.a=1l returns null. And that is of course a suboptimal solution. Even if we would align case2 with case3 we would still have the problem that case 3 behaves totally different. And I don&apos;t see an easy solution to this.&lt;/p&gt;

&lt;p&gt;I really think we should change case1&lt;/p&gt;
</comment>
                            <comment id="14466146" author="jimwhite" created="Sun, 11 Jan 2009 23:48:39 +0000"  >&lt;p&gt;I see it the opposite way.  Your rationale is based on the current implementation rather than what is defined for the languages whose tradition Groovy inherits.  In this situation we also have the boxing behavior of Java for guidance.  Consider this Java:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt; a;
&lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; b;
b = (a = 1);  
&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; b == a;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The primitive int literal 1 gets boxed into an Integer which is assigned to &apos;a&apos; and is the value of the assignment.&lt;/p&gt;

&lt;p&gt;That should be the behavior of any assignment that does conversion.  Object identity is extremely important and failing to produce the expected results leads to subtle and surprising bugs.  The reason for the idioms &lt;tt&gt;b = (a = v))&lt;/tt&gt; and &lt;tt&gt;b = (a&lt;span class=&quot;error&quot;&gt;&amp;#91;x&amp;#93;&lt;/span&gt; = v)&lt;/tt&gt;  occurs exactly because the programmer wants the exact value in the inner assignment without the overhead (and verbosity) of accessing that location again (just like the  benefit of &lt;tt&gt;a?:b&lt;/tt&gt; over &lt;tt&gt;a?a:b&lt;/tt&gt;).&lt;/p&gt;</comment>
                            <comment id="14466216" author="blackdrag" created="Mon, 12 Jan 2009 05:06:07 +0000"  >&lt;p&gt;Jim, what in your eyes should then &quot;return x.a=1l&quot; return?&lt;/p&gt;</comment>
                            <comment id="14466295" author="jimwhite" created="Mon, 12 Jan 2009 08:51:43 +0000"  >&lt;p&gt;That will be the &lt;tt&gt;Integer&lt;/tt&gt; in &apos;a&apos; (assuming the return type of the method doesn&apos;t cause a further conversion).&lt;/p&gt;

&lt;p&gt;The value of an assignment expression is the identical value stored into the location of the LHS.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://java.sun.com/docs/books/jls/third_edition/html/expressions.html#15.26&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://java.sun.com/docs/books/jls/third_edition/html/expressions.html#15.26&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Thus, a=b=c means a=(b=c), which assigns the value of c to b and then assigns the value of b to a.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;At run time, the result of the assignment expression is the value of the variable after the assignment has occurred.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;So the type of an assignment expression value has nothing to do with the RHS, it is defined strictly in terms of the type of the LHS.&lt;/p&gt;</comment>
                            <comment id="14466184" author="blackdrag" created="Tue, 13 Jan 2009 05:58:51 +0000"  >&lt;p&gt;The return type for X#setA is usually void. So the return value would be null. That means if you go after the return type, then &quot;return x.a=1l&quot; would have to return null. &lt;/p&gt;

&lt;p&gt;Pulling out the JLS won&apos;t help, because that is for Java, for a static typed language. There we know at compile time the types of a,b and c. Then we can do of course all conversions before the actual assignment. In the case of Groovy we often do not know the real type until we actually do the assignment. In Java the compiler is responsible for making the conversions, in Groovy they happen as soon as the target type is known... and that usually means not only at runtime, but also inside the method that does the actual assignment.&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Thus, a=b=c means a=(b=c), which assigns the value of c to b and then assigns the value of b to a.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;We tried to follow that in earlier versions of groovy, but in the end this means that the variable b has to be read again. For local variables this is no problem, but for properties... imagine in &quot;return x.a = 1l&quot; that a is a write-only property.. the result of reading a again means that we will get an exception, because the property cannot be read. We had issues for this in here. I can search for them if you want.  Not to forget that reading a property might have side effects.&lt;/p&gt;

&lt;p&gt;So if we want to avoid that, then we cannot return the value of b, instead we have to return the value of c. Ideally this is the same value as b, but since conversions may happen during the assignment it may not be the same. So I would say:&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Thus, a=b=c means a=(b=c), which assigns the value of c to b and then assigns the value of c to a.&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;&lt;p&gt;At run time, the result of the assignment expression is the value of the RHS&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;For your example &lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt; a 
def b
b = (a = 1)
&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; b.is(a)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt; This still means it should work and it should work regardless if a is a property assignment or array assignment. But that also means that in&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt; a
def b
def x = 1
b = (a=&lt;span class=&quot;code-quote&quot;&gt;&quot;$x&quot;&lt;/span&gt;)
&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; a == &lt;span class=&quot;code-quote&quot;&gt;&quot;1&quot;&lt;/span&gt;
&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; b == &lt;span class=&quot;code-quote&quot;&gt;&quot;1&quot;&lt;/span&gt;
&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; a == b
&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; b instance of GString
&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; a instance of &lt;span class=&quot;code-object&quot;&gt;String&lt;/span&gt;
&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; !a.is(b)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;If we use the RHS value, then of course the conversion for GString to String won&apos;t happen on the RHS. That means a gets the String and b gets the unconverted GString. Being more in Java land:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-object&quot;&gt;double&lt;/span&gt; a
&lt;span class=&quot;code-object&quot;&gt;float&lt;/span&gt; b
b=(a=1f)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt; This won&apos;t do in Java, because 1f gets converted to double and then the assignment to float won&apos;t work, as float has a lower precession. Following what I said for Groovy this would work since b does not get the value of a, but the value 1f&lt;/p&gt;
</comment>
                            <comment id="14466200" author="jimwhite" created="Tue, 13 Jan 2009 20:29:45 +0000"  >&lt;p&gt;I would rather see Groovy have an assignment expression that works correctly everywhere than it can with semantics consistent with not only Java, but the whole lineage of languages that have made Groovy possible.&lt;/p&gt;

&lt;p&gt;So for variables and arrays there is no problem to do this consistent with Java because the setter mechanism is entirely within Groovy&apos;s implementation.&lt;/p&gt;

&lt;p&gt;For properties where the LHS is using a &lt;tt&gt;Map&lt;/tt&gt;, bean property, or some MOP property, then I think the solution is to exactly interpret assignment within a value context as a write (set) followed by a read (get).  In the exceptional case of a write-only property, they&apos;ll get an exception.&lt;/p&gt;

&lt;p&gt;That way the semantics are good, predictable, and unsurprising.  The divergence with tradition is only areas where Groovy does something that generalizes the previous capability and can only do the best that it can.  That is groovy.&lt;/p&gt;</comment>
                            <comment id="14466183" author="blackdrag" created="Wed, 14 Jan 2009 11:07:58 +0000"  >&lt;p&gt;Do you know every language of that lineage and so much in detail that you can actually say how they behave here? I am very sure that most of these language either have a static type system or a dynamic one, and no dynamic language with optional static typing like we have it in Groovy. But the type transformation is exactly the reason for all this here. So I understand that you want Groovy to be compatible here, but you should consider, that Groovy is simply its own category here.&lt;/p&gt;

&lt;p&gt;You say for arrays there is no problem, because it is entirely in Groovy&apos;s implementation. but in fact this is only a putAt method, that the user can replace or add to something that is no array. On the compiler level we don&apos;t know if it is an array or not. So if we depend on the return value of that method, then we will get what the user gives us. And of course that means that we have a semantic difference from how it works now. IMHO that alone would be enough to schedule the issue for 1.7 only.&lt;/p&gt;

&lt;p&gt;If you follow the write and then read semantic, then why not do so for arrays to? Why not make a putAt followed by a getAt? If the exception is fine for properties, why it is not fine for array like access? Also don&apos;t forget we have entries for the property to work like it does now... &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-393&quot; title=&quot;cannot update a write-only property&quot; class=&quot;issue-link&quot; data-issue-key=&quot;GROOVY-393&quot;&gt;&lt;del&gt;GROOVY-393&lt;/del&gt;&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-1150&quot; title=&quot;Strange behavior on property setter&quot; class=&quot;issue-link&quot; data-issue-key=&quot;GROOVY-1150&quot;&gt;&lt;del&gt;GROOVY-1150&lt;/del&gt;&lt;/a&gt;, &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-2244&quot; title=&quot;Write-only JavaBeans properties cannot be set via the &amp;#39;=&amp;#39; operator&quot; class=&quot;issue-link&quot; data-issue-key=&quot;GROOVY-2244&quot;&gt;&lt;del&gt;GROOVY-2244&lt;/del&gt;&lt;/a&gt;, surely much more.&lt;/p&gt;

&lt;p&gt;So while you say that your semantic makes sense from the java point of view it user is surprising for users because of the optional return.&lt;/p&gt;

&lt;p&gt;If we follow the semantics I suggested, then we can avoid the exception, have a consistent way for all kind of assignments, but it won&apos;t be exactly as in Java. In my opinion it is good to follow the example of Java, but only if it fits the language and IHMO this is not the case here.&lt;/p&gt;</comment>
                            <comment id="14466297" author="jimwhite" created="Wed, 14 Jan 2009 14:05:02 +0000"  >&lt;blockquote&gt;&lt;p&gt;Do you know every language of that lineage and so much in detail that you can actually say how they behave here? ...&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Pretty much.  My programming experience goes back to 1975 and I&apos;ve either used or studied extensively most major languages, especially those in Groovy&apos;s lineage including Algol, Simula-67 (the first O-O language), BCPL (the predecessor to C) on the static side, and Smalltalk-80 and many flavors of LISP (CLOS originated the MOP, although I&apos;ve always preferred Schemish stuff) on the dynamic side.  And there&apos;s APL which is a little in-between.   I&apos;ve worked a &lt;b&gt;lot&lt;/b&gt; with FORTH (which I think of as a LISP for constrained environments and arguably the first compiled dynamic language) and Kawa (&quot;the best thing for Java that no one&apos;s ever heard of&quot; - for it&apos;s first ten years anyhow) which are noteworthy (to me anyhow) because they both hit that programming language sweet spot that Groovy does.   (I omit the &lt;em&gt;really&lt;/em&gt; long list of languages that didn&apos;t originate significant innovations leading to Groovy).&lt;/p&gt;

&lt;p&gt;Your point is a good one, so lets look at the dynamic language heritage.  And there we see exactly the problem, and it is as you describe.  The dynamic languages Smalltalk-80 and CLOS define their APIs so that all setters (primarily &lt;tt&gt;put&lt;/tt&gt; and &lt;tt&gt;setf&lt;/tt&gt; respectively) return the new value.   The Smalltalk-80 book (Goldberg &amp;amp; Robson) makes an important point about returning values (Chapter 1:Messages:Returning Values), which is that there is &lt;em&gt;always&lt;/em&gt; a return value for any operation, even if it is not used for any purpose other than to communicate that the message response is completed.&lt;/p&gt;

&lt;p&gt;Unfortunately Groovy is stuck with a ton of Java APIs that use methods returning &lt;tt&gt;void&lt;/tt&gt;.  And there is even the notable case of &lt;tt&gt;Map.put&lt;/tt&gt; where we get the &lt;em&gt;previous&lt;/em&gt; value.  &lt;b&gt;sigh&lt;/b&gt;. &lt;/p&gt;

&lt;p&gt;Now as I said earlier, I thought that the array assignment issue could be solved by changing the signature for the array &lt;tt&gt;putAt&lt;/tt&gt; methods so that the new value parameter is the same type as the array element (rather than &lt;tt&gt;Object&lt;/tt&gt;), so that the caller would make the appropriate assignment type conversion, just like for any other method.  But if that&apos;s not the case, then it is indeed left with the same problem as properties.&lt;/p&gt;

&lt;p&gt;So that means to get assignment to work correctly from a language perspective we&apos;ll need &lt;tt&gt;putAt&lt;/tt&gt; to return the new value, just like the setters for Smalltalk-80 and CLOS.&lt;/p&gt;

&lt;p&gt;I&apos;ve just checked the Ruby and Python docs and Ruby does return the new value from setters (&lt;tt&gt;[]=&lt;/tt&gt;) although Python (&lt;tt&gt;&amp;#95;setitem&amp;#95;&lt;/tt&gt;) does not.&lt;/p&gt;

&lt;p&gt;If we really can&apos;t fix array element assignment (which is what this issue is about because it is a Java feature and I see Groovy&apos;s special value as being that for the features that are the same as Java it does things the Java way) without changing &lt;tt&gt;putAt&lt;/tt&gt; globally, then I agree that this is a 1.7+ (likely 2.0) issue.&lt;/p&gt;</comment>
                            <comment id="14466219" author="blackdrag" created="Wed, 14 Jan 2009 19:11:52 +0000"  >&lt;p&gt;A method returning void means it returns null in Groovy. The problem with property setter methods in Groovy is, that they have the Java tradition to be void. On the one hand we could ask why it is better to break with the traditions for []= but not for void setter methods. And the thing is that for []= we can define something on the compiler level, but setter methods are written by the user and may not follow the right convention... especially since that convention has no tradition coming from Java. &lt;/p&gt;

&lt;p&gt;Now the difference in the way I suggest and the way Java does it, is only the type conversion. In a=(b=c) there is no problem at all if the value can be assigned without coercion... in fact it is enough if b=c can be done without type transformation.  So naturally there is no problem if there are no static types.&lt;/p&gt;

&lt;p&gt;If you program exactly as in Java, or if you program without static types, then there is no difference too, because any type transformation there happens only for primitive types using cast. Not to forget, that there is no &quot;is&quot; method for them too. In fact Groovy has primitive types only by name, so that is not relevant at all. That leaves an area where Groovy is different from Java anyway. for example allowing float f = 1d without cast and other implicit conversions. If the conversion is done explicit like in a=(b=(String) c), where c is a GString, then the transformation has already become part of the RHS.&lt;/p&gt;

&lt;p&gt;So comparing my suggestion and the Java way the difference can be reduced to the cases where implicit type transformations do happen. I made this suggestion because I think that this is special enough to not to surprise most users.&lt;/p&gt;</comment>
                            <comment id="14466201" author="jimwhite" created="Wed, 14 Jan 2009 20:50:50 +0000"  >&lt;p&gt;You miss my point.  If the &lt;tt&gt;putAt&lt;/tt&gt; methods in the array metamethod classes (&lt;tt&gt;DGM.additionals&lt;/tt&gt;) were specialized so that the new value parameter was the same type as the array element then the caller would have to make the type conversion (and we&apos;re not just talking about boxing, it is also the string/gstring/number stuff - we got here because of &lt;a href=&quot;https://issues.apache.org/jira/browse/GROOVY-3165&quot; title=&quot;Regression in assignment of single character strings to char array element&quot; class=&quot;issue-link&quot; data-issue-key=&quot;GROOVY-3165&quot;&gt;&lt;del&gt;GROOVY-3165&lt;/del&gt;&lt;/a&gt;) before the call and would therefore have the converted object to return as the result.  We would add &lt;tt&gt;StringArrayPutAtMetaMethod&lt;/tt&gt;, &lt;tt&gt;IntegerArrayPutAtMetaMethod&lt;/tt&gt;, and friends as needed.&lt;/p&gt;

&lt;p&gt;In the future it seems Groovy could generalize covariant return types (being dynamically typed and all) so that we could deal with &lt;tt&gt;putAt&lt;/tt&gt; returning things other than &lt;tt&gt;void&lt;/tt&gt;, which would provide the needed backwards compatibility for dealing with properties.&lt;/p&gt;
</comment>
                            <comment id="14466288" author="blackdrag" created="Thu, 15 Jan 2009 09:50:38 +0000"  >&lt;p&gt;I did indeed not see that point... ok, so now we are talking about the conversions done for method calls, especially for the putAt method. But if you think about the two levels runtime and compiler and if you think about the fact that we may not know the type till we execute the method, then it should be clear to you, that the compiler can&apos;t do the type conversions beforehand. And if the compiler can&apos;t do that, then &lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-object&quot;&gt;Integer&lt;/span&gt;[] a = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Long&lt;/span&gt;[1]
def b

b = (a[0] = 1234234 &lt;span class=&quot;code-comment&quot;&gt;/* uncached &lt;span class=&quot;code-object&quot;&gt;Long&lt;/span&gt; */&lt;/span&gt;)   
&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; b.is(a[0])
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt; may fail, because we have here two conversions, with one conversion hidden in the execution of the putAt method for a&lt;span class=&quot;error&quot;&gt;&amp;#91;0&amp;#93;&lt;/span&gt;. From the perspective of the runtime the putAt method is just like any other method, so there is no reason to do anything special here... like returning a value the method does not return itself.&lt;/p&gt;

&lt;p&gt;It is the same for properties...  if we are going to sue the return value of the method for putAt, then we should do the same for the property setter execution as well. Meaning that in most case it would return null, meaning also that this would not align with what Java does. For example for &quot;a=(foo.b=1)&quot;. In Java a gets the value of &quot;foo.b=1&quot;, and it is valid if b is for example a field.  If we transfer this to properties then &quot;foo.b=1&quot; would usually call a setter method that by convention in Java is void, thus it would return null and a would have to store the value null.&lt;/p&gt;

&lt;p&gt;Also we should not forget, that atm GroovyObject has a method void setProperty(String name, Object arg). that means that any dynamic property would return null, because it goes through the void set Property method.  And inside closures any property write goes through that, so you would get always null.&lt;/p&gt;

&lt;p&gt;I think I now remember also why for example char[].putAt did not return the value it does set. And that is for performance reasons. Called though reflection it means that the method has to box the return value which is ignored in 99% of all cases. At last if it returns char or Character.&lt;/p&gt;

&lt;p&gt;Anyway... I am not going for the performance line here. I am interested in having a consistent way for all three cases (remember my earlier post) and combinations of these. If we are going to make the change to let the method return the value and use that value, then we have to find a solution for property write methods as well. And one that works with dynamic properties of course. If such a solution means to modify for example GroovyObject, then this issue qualifies itself automatically as a 2.0 issue. If we find no suitable solution for this, then I think that my way is the only one left. Also my way is doable without changing half of the runtime and with only a small change in the compiler for case1. &lt;/p&gt;</comment>
                            <comment id="14466309" author="blackdrag" created="Thu, 15 Jan 2009 09:52:16 +0000"  >&lt;p&gt;I am setting the fix versions to 1.7 and 2.0 for now, because our discussion suggests, that any solution will be a breaking change in the semantics and therefore is possibly not for 1.5.x or 1.6.x&lt;/p&gt;</comment>
                            <comment id="14479418" author="paulk" created="Fri, 7 Jan 2011 03:35:11 +0000"  >&lt;p&gt;bumping fix version - should possibly be even 1.9.x&lt;/p&gt;</comment>
                            <comment id="14470616" author="blackdrag" created="Fri, 7 Jan 2011 05:47:58 +0000"  >&lt;p&gt;Since the interest is dimished I will close the issue. Jim, if you can give me an example where &lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;U x1
V v1 = (x1 = &amp;lt;any&amp;gt;)

&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; x1 == v1

U[] x2 = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; U[1]
V   v2 = (x2[0] = &amp;lt;any&amp;gt;)

&lt;span class=&quot;code-keyword&quot;&gt;assert&lt;/span&gt; x2[0] ==  v2
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;is fulfilled in Java, but not in Groovy, then we can reopen this issue of course.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10001">
                    <name>dependent</name>
                                                                <inwardlinks description="is depended upon by">
                                        <issuelink>
            <issuekey id="12814452">GROOVY-3165</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12722024" name="groovy-3165-test-diff-20081230.txt" size="1690" author="jimwhite" created="Wed, 31 Dec 2008 01:01:22 +0000"/>
                            <attachment id="12722088" name="groovy-3165-test-diff.txt" size="2033" author="jimwhite" created="Thu, 27 Nov 2008 11:31:36 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            14 years, 46 weeks, 4 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i2bziv:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12312220" key="com.atlassian.jira.plugin.system.customfieldtypes:radiobuttons">
                        <customfieldname>Testcase included</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="11060"><![CDATA[Yes]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                        </customfields>
    </item>
</channel>
</rss>