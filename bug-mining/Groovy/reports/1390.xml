<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Wed Nov 12 00:17:51 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[GROOVY-4182] very bad performance in GroovyCategorySupport because of static AtomicInteger use</title>
                <link>https://issues.apache.org/jira/browse/GROOVY-4182</link>
                <project id="12318123" key="GROOVY">Groovy</project>
                    <description>&lt;p&gt;Profiler shows average 1ms per call in our multi-threaded (20 threads) application in most of the calls to PojoMetaClassSite.call()&lt;br/&gt;
because of static atomic Inreger is used (categoriesInUse) in GroovyCategorySupport.hasCategoryInCurrentThread():&lt;/p&gt;

&lt;p&gt;    public static boolean hasCategoryInCurrentThread() &lt;/p&gt;
{
        return categoriesInUse.get() != 0 &amp;amp;&amp;amp; threadInfo.getInfo().level != 0;
    }</description>
                <environment></environment>
        <key id="12815099">GROOVY-4182</key>
            <summary>very bad performance in GroovyCategorySupport because of static AtomicInteger use</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="2" iconUrl="https://issues.apache.org/jira/images/icons/priorities/critical.svg">Critical</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="blackdrag">Jochen Theodorou</assignee>
                                    <reporter username="vkorehov">Vladislavs Korehovs</reporter>
                        <labels>
                    </labels>
                <created>Wed, 28 Apr 2010 06:25:36 +0000</created>
                <updated>Tue, 14 Dec 2010 10:43:48 +0000</updated>
                            <resolved>Tue, 14 Dec 2010 10:43:48 +0000</resolved>
                                                    <fixVersion>1.8-beta-3</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                                                                <comments>
                            <comment id="14469266" author="blackdrag" created="Wed, 28 Apr 2010 12:37:03 +0000"  >&lt;p&gt;funny, just a few days ago I had a look at this method. I replaced it locally with a simple boolean instead of the usage of the AtomicIntger. But the performance was going up by maybe 1% in my test only, with a very big range of times, so that this 1% might be below the border an effect gets really measurable. AtomicInteger#get does read from a volatile, an action that people say can be realized on SPARC and Ix86/Ix64 architecture by a simple load without memory fences and thus without wait times for the value. A volatile read can cost much if it is on a different architecture. Is that the case for you? If yes, then my boolean version may help you, since it does not use any volatiles or atomics. But if you are on one of the architectures metioned above, it will not make a major difference. &lt;/p&gt;

&lt;p&gt;The matter is entirely different if you actually use categories. I have assumed you do not.&lt;/p&gt;

&lt;p&gt;Are you sure the AtomicInteger#get is responsible for the timing you see?&lt;/p&gt;</comment>
                            <comment id="14469301" author="vkorehov" created="Wed, 28 Apr 2010 14:25:59 +0000"  >&lt;p&gt;Ubuntu 9.10 Linux Sun JDK 1.6&lt;br/&gt;
NetBeans profiler shows total 35ms spent in method GroovyCategorySupport.hasCategoryInCurrentThread() for about 30 calls.&lt;br/&gt;
And this is for trivial 30 field xml dom access in 40 line groovy script.&lt;/p&gt;

&lt;p&gt;GroovyCategorySupport.hasCategoryInCurrentThread eats 95% of the whole processing time.&lt;/p&gt;

&lt;p&gt;As I mention I have 20 threads running concurrently and doing same task in groovy (dom access).&lt;br/&gt;
And this is EXTREMELY important!&lt;br/&gt;
With a single threaded test you will never be able to see real performance impact.&lt;/p&gt;

&lt;p&gt;Not sure if u&apos;re up to date on volatile implementation in Java 5: &lt;a href=&quot;http://www.javamex.com/tutorials/synchronization_volatile_java_5.shtml&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.javamex.com/tutorials/synchronization_volatile_java_5.shtml&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;So it&apos;s essentially a global lock now.&lt;br/&gt;
I&apos;m pretty sure it can be avoided easily in your case.&lt;/p&gt;</comment>
                            <comment id="14469342" author="vkorehov" created="Wed, 28 Apr 2010 14:28:41 +0000"  >&lt;p&gt;CPU: x86&lt;/p&gt;</comment>
                            <comment id="14469369" author="blackdrag" created="Wed, 28 Apr 2010 15:50:55 +0000"  >&lt;p&gt;The test I did was calculating a fibonacci number in a couple of threads in parallel. My test was on Sun JDK6 on a 64bit machine on Ubuntu. I am aware of the Java Memory Model as it exists since Java5. The information I gave you about the volatile read is according to that memory model and from several people from the concurrent area (including Doug Lea). A volatile read does not need a hardware lock because of the memory model the CPUs use on those platforms.&lt;/p&gt;

&lt;p&gt;But I get the feeling that in your case the program does not run long enough to be compiled by hotspot. You can add these JVM parameters &lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;-XX:+UnlockDiagnosticVMOptions -XX:PrintAssemblyOptions=hsdis-print-bytes -XX:CompileCommand=print,org/codehaus/groovy/runtime/GroovyCategorySupport.hasCategoryInCurrentThread&lt;br/&gt;
{code]&lt;br/&gt;
to see if you get some assembler code for the method. This way you could be sure it is really compiled.&lt;/p&gt;

&lt;p&gt;But as I said, giving an example I can use to reproduce the problem would help me.&lt;/p&gt;</comment>
                            <comment id="14469343" author="vkorehov" created="Mon, 3 May 2010 11:06:42 +0000"  >&lt;p&gt;Hi,&lt;br/&gt;
I&apos;m running on 32bit x86 architecture not 64bit.&lt;br/&gt;
Memory barrier is essentially a lock for a duration of memory operation, but just a hardware based lock and all this is quantitative rather then qualitative difference...&lt;br/&gt;
Unfortunately I cannot attach test case because it is part of application.&lt;br/&gt;
In thread payloads I&apos;m just reading XML similar to this:&lt;br/&gt;
&lt;a href=&quot;http://groovy.codehaus.org/Reading+XML+using+Groovy&amp;#39;s+XmlParser&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://groovy.codehaus.org/Reading+XML+using+Groovy&apos;s+XmlParser&lt;/a&gt;&lt;br/&gt;
While Fibbonachi calculation is a syntetic test.&lt;/p&gt;

&lt;p&gt;But does use of this lock is totally necessary from the design point of view? cannot be enough with thread local?&lt;br/&gt;
It is very easy to add locks and it is very difficult to remove them after.&lt;/p&gt;</comment>
                            <comment id="14469365" author="blackdrag" created="Wed, 5 May 2010 07:07:56 +0000"  >&lt;p&gt;A memory barrier is a bit more, since it requires are synchronization of the main memory with the processor cache. This operation is of course much slower, than just reading from the CPU cache. In that regard, there is of course a major difference between reading from the local cache and having to sync. Of course a cache miss may cause something like that too.&lt;/p&gt;

&lt;p&gt;A volatile has in general better performance than a ThreadLocal, at least if you have to get the ThreadLocal on each request.&lt;/p&gt;

&lt;p&gt;As for the test case.. I was hoping you cold provide something that exhibits the same problem. It doesn&apos;t have to be exactly what you do in your application. But as it is, it may very well be, that my change from the volatile boolean to not being volatile will not have any effect.&lt;/p&gt;</comment>
                            <comment id="14469317" author="vkorehov" created="Sat, 8 May 2010 06:39:22 +0000"  >&lt;p&gt;Excuse me, but this is complete nonsense!&lt;br/&gt;
First of all memory barriers not only involve cache synchronizations but the also serialize the memory operations by different contexts.&lt;br/&gt;
&lt;a href=&quot;http://en.wikipedia.org/wiki/Memory_barrier&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://en.wikipedia.org/wiki/Memory_barrier&lt;/a&gt;&lt;br/&gt;
Please re-read this arcicle &lt;a href=&quot;http://www.javamex.com/tutorials/synchronization_volatile_java_5.shtml&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://www.javamex.com/tutorials/synchronization_volatile_java_5.shtml&lt;/a&gt; which clearly states that  volatile keyword semantics DID CHANGE in Java 5, which reduced concurrency and now is comparable with synchronized().&lt;/p&gt;

&lt;p&gt;Your statement about ThreadLocal just shows major incompetence in the subject!&lt;br/&gt;
ThreadLocal is using simple non-synchronized memory access from thread local storage. This is a simple read operation, in comparison to a synchronized read which is implemented! This memory is part of thread storage space allocated by oerating system. This is the SAME memory as the stack or heap is using! there is NO any performance penalty on accesing this memory!&lt;br/&gt;
&lt;a href=&quot;http://en.wikipedia.org/wiki/Thread-local_storage&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;http://en.wikipedia.org/wiki/Thread-local_storage&lt;/a&gt;&lt;/p&gt;</comment>
                            <comment id="14469429" author="blackdrag" created="Sat, 8 May 2010 07:12:10 +0000"  >&lt;p&gt;Don&apos;t get me wrong, I am talking here only about java5, not before. I am aware that it changed and I am not questioning that. Not sure were you got this idea from. What I was saying is, that volatile read can be done on x86 without going through a memory barrier, because of the memory model used. This is not my personal believe. Some comments from the concurrency-interest list: Hans Boehm, April 27, 2010: &quot;On X86 or SPARC TSO or similar, there no memory fence/barrier instruction is needed on the read side, even if volatiles are used.  Ever.&quot;. I could verify that by looking at the assembler code generated for such a volatile access. My statement that ThreadLocal is slower than a volatile depends on personal experience and confirmation from several sides. ThreadLocal can be equally fast, if not faster than volatile, if, and only if you don&apos;t have to go and get the ThreadLocal object anew - meaning you don&apos;t have to get the thread local space first. I am not talking about object creation here. ThreadLocal has kind of a map that stores the thread local spaces and getting the current thread and using that to go through the map to finally get the thread local storage is what slows it down. Since exactly that would have to be done at the place in question, you will end up slower than with using a volatile. And yes, I tested this. We are not talking about a big difference here of course, but it is a difference.&lt;/p&gt;

&lt;p&gt;But who cares. I announced I will replace categoriesInUse.get() with a simple boolean I already said. Then it is a direct memory access for sure. I only warned that in my tests this was not giving a major improvement. That is also why I asked for a testcase.&lt;/p&gt;

&lt;p&gt;Another reasons I was asking for one is, because I think the time is not spend in the AtomicBoolean, I think it is spend in the threadInfo.getInfo().level part. Which should be only the case if you have categories active in your code while this part is handled. &lt;/p&gt;

&lt;p&gt;But ok... since we seem to have a major difference somewhere, there is a simple way of testing if the approach will be ok or not. I can give you a patch or something like that and you test it on your system. Are you willing to do that?&lt;/p&gt;</comment>
                            <comment id="14469417" author="vkorehov" created="Sun, 9 May 2010 07:37:35 +0000"  >&lt;p&gt;Hi.&lt;br/&gt;
that would be great (patch).&lt;br/&gt;
I can teest. it will be much easier here. I can share profilig results after.&lt;br/&gt;
Thanks and regards.&lt;/p&gt;</comment>
                            <comment id="14470294" author="blackdrag" created="Fri, 15 Oct 2010 04:47:43 +0000"  >&lt;p&gt;took quite some time, sorry.... trunk would now contain a fixed version for this... you want to try it?&lt;/p&gt;</comment>
                            <comment id="14470438" author="blackdrag" created="Tue, 14 Dec 2010 10:43:48 +0000"  >&lt;p&gt;I declare it as fixed until further notice. Vladislavs, should the issue not be fixed in your view, feel free to reopen the issue&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            14 years, 50 weeks ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i2covb:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </customfields>
    </item>
</channel>
</rss>