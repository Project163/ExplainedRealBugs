diff --git a/core/query/src/main/java/org/eclipse/rdf4j/query/QueryResults.java b/core/query/src/main/java/org/eclipse/rdf4j/query/QueryResults.java
index d1ee43cb41..0101e2fd25 100644
--- a/core/query/src/main/java/org/eclipse/rdf4j/query/QueryResults.java
+++ b/core/query/src/main/java/org/eclipse/rdf4j/query/QueryResults.java
@@ -7,6 +7,7 @@
  *******************************************************************************/
 package org.eclipse.rdf4j.query;
 
+import java.io.InputStream;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
@@ -14,6 +15,7 @@ import java.util.List;
 import java.util.Map;
 import java.util.NoSuchElementException;
 import java.util.Set;
+import java.util.concurrent.LinkedBlockingQueue;
 
 import javax.xml.datatype.XMLGregorianCalendar;
 
@@ -34,10 +36,16 @@ import org.eclipse.rdf4j.model.datatypes.XMLDatatypeUtil;
 import org.eclipse.rdf4j.model.impl.LinkedHashModel;
 import org.eclipse.rdf4j.model.util.Models;
 import org.eclipse.rdf4j.model.vocabulary.XMLSchema;
+import org.eclipse.rdf4j.query.impl.BackgroundGraphResult;
 import org.eclipse.rdf4j.query.impl.IteratingGraphQueryResult;
 import org.eclipse.rdf4j.query.impl.IteratingTupleQueryResult;
+import org.eclipse.rdf4j.query.impl.QueueCursor;
+import org.eclipse.rdf4j.rio.RDFFormat;
 import org.eclipse.rdf4j.rio.RDFHandler;
 import org.eclipse.rdf4j.rio.RDFHandlerException;
+import org.eclipse.rdf4j.rio.RDFParser;
+import org.eclipse.rdf4j.rio.Rio;
+import org.eclipse.rdf4j.rio.UnsupportedRDFormatException;
 
 /**
  * Utility methods related to query results.
@@ -138,9 +146,11 @@ public class QueryResults extends Iterations {
 	 * @param limit
 	 *        the maximum number of solutions to return. If set to 0 or lower, no limit will be applied.
 	 * @param offset
-	 *        the number of solutions to skip at the beginning. If set to 0 or lower, no offset will be applied.
+	 *        the number of solutions to skip at the beginning. If set to 0 or lower, no offset will be
+	 *        applied.
 	 * @return A {@link TupleQueryResult} that will at return at most the specified maximum number of
-	 *         solutions. If neither {@code limit} nor {@code offset} are applied, this returns the original {@code queryResult}.
+	 *         solutions. If neither {@code limit} nor {@code offset} are applied, this returns the original
+	 *         {@code queryResult}.
 	 */
 	public static TupleQueryResult limitResults(TupleQueryResult queryResult, long limit, long offset) {
 		CloseableIteration<BindingSet, QueryEvaluationException> iter = queryResult;
@@ -166,9 +176,11 @@ public class QueryResults extends Iterations {
 	 * @param limit
 	 *        the maximum number of solutions to return. If set to 0 or lower, no limit will be applied.
 	 * @param offset
-	 *        the number of solutions to skip at the beginning. If set to 0 or lower, no offset will be applied.
+	 *        the number of solutions to skip at the beginning. If set to 0 or lower, no offset will be
+	 *        applied.
 	 * @return A {@link GraphQueryResult} that will at return at most the specified maximum number of
-	 *         solutions. If neither {@code limit} nor {@code offset} are applied, this returns the original {@code queryResult}.
+	 *         solutions. If neither {@code limit} nor {@code offset} are applied, this returns the original
+	 *         {@code queryResult}.
 	 */
 	public static GraphQueryResult limitResults(GraphQueryResult queryResult, long limit, long offset) {
 		CloseableIteration<Statement, QueryEvaluationException> iter = queryResult;
@@ -185,6 +197,40 @@ public class QueryResults extends Iterations {
 		return (GraphQueryResult)iter;
 	}
 
+	/**
+	 * Parses an RDF document and returns it as a GraphQueryResult object, with parsing done on a separate
+	 * thread in the background.<br>
+	 * IMPORTANT: As this method will spawn a new thread in the background, it is vitally important that it be
+	 * closed consistently when it is no longer required, to prevent resource leaks.
+	 * 
+	 * @param in
+	 *        The {@link InputStream} containing the RDF document.
+	 * @param baseURI
+	 *        The base URI for the RDF document.
+	 * @param format
+	 *        The {@link RDFFormat} of the RDF document.
+	 * @return A {@link GraphQueryResult} that parses in the background.
+	 */
+	public static GraphQueryResult parseGraphBackground(InputStream in, String baseURI, RDFFormat format)
+		throws UnsupportedRDFormatException
+	{
+		RDFParser parser = Rio.createParser(format);
+
+		BackgroundGraphResult result = new BackgroundGraphResult(
+				new QueueCursor<>(new LinkedBlockingQueue<>(1)), parser, in, format.getCharset(), baseURI);
+		boolean allGood = false;
+		try {
+			new Thread(result).start();
+			allGood = true;
+		}
+		finally {
+			if (!allGood) {
+				result.close();
+			}
+		}
+		return result;
+	}
+
 	/**
 	 * Reports a tuple query result to a {@link TupleQueryResultHandler}. <br>
 	 * The {@link TupleQueryResult#close()} method will always be called before this method returns. <br>
diff --git a/core/query/src/main/java/org/eclipse/rdf4j/query/impl/BackgroundGraphResult.java b/core/query/src/main/java/org/eclipse/rdf4j/query/impl/BackgroundGraphResult.java
new file mode 100644
index 0000000000..4c43d3a814
--- /dev/null
+++ b/core/query/src/main/java/org/eclipse/rdf4j/query/impl/BackgroundGraphResult.java
@@ -0,0 +1,244 @@
+/*******************************************************************************
+ * Copyright (c) 2015 Eclipse RDF4J contributors, Aduna, and others.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Distribution License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/org/documents/edl-v10.php.
+ *******************************************************************************/
+package org.eclipse.rdf4j.query.impl;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.lang.reflect.UndeclaredThrowableException;
+import java.nio.charset.Charset;
+import java.util.Collections;
+import java.util.Map;
+import java.util.NoSuchElementException;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.CountDownLatch;
+
+import org.eclipse.rdf4j.common.iteration.IterationWrapper;
+import org.eclipse.rdf4j.model.Statement;
+import org.eclipse.rdf4j.query.GraphQueryResult;
+import org.eclipse.rdf4j.query.QueryEvaluationException;
+import org.eclipse.rdf4j.rio.RDFHandler;
+import org.eclipse.rdf4j.rio.RDFHandlerException;
+import org.eclipse.rdf4j.rio.RDFParser;
+
+/**
+ * Provides concurrent access to statements as they are being parsed when instances of this class are run as
+ * Threads.
+ * 
+ * @author James Leigh
+ */
+public class BackgroundGraphResult extends IterationWrapper<Statement, QueryEvaluationException>
+		implements GraphQueryResult, Runnable, RDFHandler
+{
+
+	private final RDFParser parser;
+
+	private final Charset charset;
+
+	private final InputStream in;
+
+	private final String baseURI;
+
+	private final CountDownLatch namespacesReady = new CountDownLatch(1);
+
+	private final Map<String, String> namespaces = new ConcurrentHashMap<String, String>();
+
+	private final QueueCursor<Statement> queue;
+
+	public BackgroundGraphResult(RDFParser parser, InputStream in, Charset charset, String baseURI) {
+		this(new QueueCursor<Statement>(10), parser, in, charset, baseURI);
+	}
+
+	public BackgroundGraphResult(QueueCursor<Statement> queue, RDFParser parser, InputStream in,
+			Charset charset, String baseURI)
+	{
+		super(queue);
+		this.queue = queue;
+		this.parser = parser;
+		this.in = in;
+		this.charset = charset;
+		this.baseURI = baseURI;
+	}
+
+	@Override
+	public boolean hasNext()
+		throws QueryEvaluationException
+	{
+		if (isClosed()) {
+			return false;
+		}
+		if (Thread.currentThread().isInterrupted()) {
+			close();
+			return false;
+		}
+
+		boolean result = queue.hasNext();
+		if (!result) {
+			close();
+		}
+		return result;
+	}
+
+	@Override
+	public Statement next()
+		throws QueryEvaluationException
+	{
+		if (isClosed()) {
+			throw new NoSuchElementException("The iteration has been closed.");
+		}
+		if (Thread.currentThread().isInterrupted()) {
+			close();
+			throw new NoSuchElementException("The iteration has been closed.");
+		}
+
+		try {
+			return queue.next();
+		}
+		catch (NoSuchElementException e) {
+			close();
+			throw e;
+		}
+	}
+
+	@Override
+	public void remove()
+		throws QueryEvaluationException
+	{
+		if (isClosed()) {
+			throw new IllegalStateException("The iteration has been closed.");
+		}
+		if (Thread.currentThread().isInterrupted()) {
+			close();
+			throw new IllegalStateException("The iteration has been closed.");
+		}
+
+		try {
+			queue.remove();
+		}
+		catch (IllegalStateException e) {
+			close();
+			throw e;
+		}
+	}
+
+	@Override
+	protected void handleClose()
+		throws QueryEvaluationException
+	{
+		try {
+			try {
+				super.handleClose();
+			}
+			finally {
+				try {
+					// After checking that we ourselves cannot possibly be generating an NPE ourselves, 
+					// attempt to close the input stream we were given
+					InputStream toClose = in;
+					if (toClose != null) {
+						toClose.close();
+					}
+				}
+				catch (NullPointerException e) {
+					// Swallow NullPointerException that Apache HTTPClient is hiding behind a NotThreadSafe annotation
+				}
+			}
+		}
+		catch (IOException e) {
+			throw new QueryEvaluationException(e);
+		}
+		finally {
+			queue.close();
+		}
+	}
+
+	@Override
+	public void run() {
+		try {
+			parser.setRDFHandler(this);
+			if (charset == null) {
+				parser.parse(in, baseURI);
+			}
+			else {
+				parser.parse(new InputStreamReader(in, charset), baseURI);
+			}
+		}
+		catch (RDFHandlerException e) {
+			// parsing was cancelled or interrupted
+			close();
+		}
+		catch (Exception e) {
+			queue.toss(e);
+			close();
+		}
+		finally {
+			queue.done();
+			namespacesReady.countDown();
+		}
+	}
+
+	@Override
+	public void startRDF()
+		throws RDFHandlerException
+	{
+		// no-op
+	}
+
+	@Override
+	public Map<String, String> getNamespaces() {
+		try {
+			namespacesReady.await();
+			// Show the user an unmodifiable view on the map but we can still change it here
+			return Collections.unmodifiableMap(namespaces);
+		}
+		catch (InterruptedException e) {
+			Thread.currentThread().interrupt();
+			close();
+			throw new UndeclaredThrowableException(e);
+		}
+	}
+
+	@Override
+	public void handleComment(String comment)
+		throws RDFHandlerException
+	{
+		// ignore
+	}
+
+	@Override
+	public void handleNamespace(String prefix, String uri)
+		throws RDFHandlerException
+	{
+		namespaces.put(prefix, uri);
+	}
+
+	@Override
+	public void handleStatement(Statement st)
+		throws RDFHandlerException
+	{
+		namespacesReady.countDown();
+		try {
+			queue.put(st);
+		}
+		catch (InterruptedException e) {
+			Thread.currentThread().interrupt();
+			close();
+			throw new RDFHandlerException(e);
+		}
+		if (isClosed()) {
+			throw new RDFHandlerException("Result closed");
+		}
+	}
+
+	@Override
+	public void endRDF()
+		throws RDFHandlerException
+	{
+		namespacesReady.countDown();
+	}
+
+}
diff --git a/core/query/src/main/java/org/eclipse/rdf4j/query/impl/QueueCursor.java b/core/query/src/main/java/org/eclipse/rdf4j/query/impl/QueueCursor.java
index 5bc83abac8..3f0894e2ea 100644
--- a/core/query/src/main/java/org/eclipse/rdf4j/query/impl/QueueCursor.java
+++ b/core/query/src/main/java/org/eclipse/rdf4j/query/impl/QueueCursor.java
@@ -7,6 +7,9 @@
  *******************************************************************************/
 package org.eclipse.rdf4j.query.impl;
 
+import java.util.concurrent.ArrayBlockingQueue;
+import java.util.concurrent.BlockingQueue;
+
 import org.eclipse.rdf4j.common.iteration.QueueIteration;
 import org.eclipse.rdf4j.query.QueryEvaluationException;
 
@@ -41,6 +44,19 @@ public class QueueCursor<E> extends QueueIteration<E, QueryEvaluationException>
 		super(capacity, fair);
 	}
 
+	/**
+	 * Creates an <tt>QueueCursor</tt> with the given {@link BlockingQueue} as its backing queue.<br>
+	 * It may not be threadsafe to modify or access the given {@link BlockingQueue} from other locations. This
+	 * method only enables the default {@link ArrayBlockingQueue} to be overridden.
+	 * 
+	 * @param queue
+	 *        A BlockingQueue that is not used in other locations, but will be used as the backing Queue
+	 *        implementation for this cursor.
+	 */
+	public QueueCursor(BlockingQueue<E> queue) {
+		super(queue);
+	}
+
 	@Override
 	protected QueryEvaluationException convert(Exception e) {
 		throw new QueryEvaluationException(e);
