diff --git a/code/core/src/test/preview.ts b/code/core/src/test/preview.ts
index e2e8cfafd4a..b37dbd5fe97 100644
--- a/code/core/src/test/preview.ts
+++ b/code/core/src/test/preview.ts
@@ -108,14 +108,14 @@ const enhanceContext: LoaderFunction = async (context) => {
       configurable: true,
     });
 
+    // Must save a real, original `focus` method outside of the patch beforehand
+    const originalFocus = HTMLElement.prototype.focus;
     let currentFocus = HTMLElement.prototype.focus;
 
+    // Use a Set to track elements that are currently undergoing a focus operation
+    const focusingElements = new Set();
+
     if (!patchedFocus) {
-      // We need to patch the focus method of HTMLElement.prototype to make it settable.
-      // Testing library "setup" defines a custom focus method on HTMLElement.prototype that is not settable.
-      // Libraries like chakra-ui also wants to define a custom focus method on HTMLElement.prototype
-      // which is not settable if we don't do this.
-      // Related issue: https://github.com/storybookjs/storybook/issues/31243
       Object.defineProperties(HTMLElement.prototype, {
         focus: {
           configurable: true,
@@ -123,7 +123,21 @@ const enhanceContext: LoaderFunction = async (context) => {
             currentFocus = newFocus;
             patchedFocus = true;
           },
-          get: () => {
+          get() {
+            // 'this' here refers to the DOM element being operated on
+            if (focusingElements.has(this)) {
+              // Recursive call detected; to break the loop, return the original focus method.
+              return originalFocus;
+            }
+
+            // Add protection marker
+            focusingElements.add(this);
+
+            // Use setTimeout(..., 0) to defer the "remove marker" operation to the next event loop.
+            // This ensures the marker persists for the entire synchronous call chain (including all recursive calls).
+            setTimeout(() => focusingElements.delete(this), 0);
+
+            // Return the focus method that should currently be used
             return currentFocus;
           },
         },
