diff --git a/code/addons/test/src/components/TestProviderRender.tsx b/code/addons/test/src/components/TestProviderRender.tsx
index fcff6d1d325..22ba567a9a3 100644
--- a/code/addons/test/src/components/TestProviderRender.tsx
+++ b/code/addons/test/src/components/TestProviderRender.tsx
@@ -245,10 +245,13 @@ export const TestProviderRender: FC<TestProviderRenderProps> = ({
                 onClick={() =>
                   store.send({
                     type: 'TRIGGER_RUN',
-                    payload: {
-                      indexUrl: new URL('index.json', window.location.href).toString(),
-                      storyIds: entryId ? api.findAllLeafStoryIds(entryId) : undefined,
-                    },
+                    ...(entryId
+                      ? {
+                          payload: {
+                            storyIds: api.findAllLeafStoryIds(entryId),
+                          },
+                        }
+                      : {}),
                   })
                 }
                 disabled={false}
diff --git a/code/addons/test/src/constants.ts b/code/addons/test/src/constants.ts
index f8d1ba3b51a..b5d4dbb073d 100644
--- a/code/addons/test/src/constants.ts
+++ b/code/addons/test/src/constants.ts
@@ -32,6 +32,7 @@ export const storeOptions = {
     watching: false,
     cancelling: false,
     fatalError: undefined,
+    indexUrl: undefined,
     currentRun: {
       coverage: false,
       a11y: false,
diff --git a/code/addons/test/src/manager.tsx b/code/addons/test/src/manager.tsx
index 48be384b1e9..3705a91e253 100644
--- a/code/addons/test/src/manager.tsx
+++ b/code/addons/test/src/manager.tsx
@@ -36,9 +36,14 @@ addons.register(ADDON_ID, (api) => {
     testProviderStore.onRunAll(() => {
       store.send({
         type: 'TRIGGER_RUN',
-        payload: { indexUrl: new URL('index.json', window.location.href).toString() },
       });
     });
+    store.untilReady().then(() => {
+      store.setState((state) => ({
+        ...state,
+        indexUrl: new URL('index.json', window.location.href).toString(),
+      }));
+    });
 
     addons.add(TEST_PROVIDER_ID, {
       type: Addon_TypesEnum.experimental_TEST_PROVIDER,
@@ -71,9 +76,6 @@ addons.register(ADDON_ID, (api) => {
                 setModalOpen(false);
                 store.send({
                   type: 'TRIGGER_RUN',
-                  payload: {
-                    indexUrl: new URL('index.json', window.location.href).toString(),
-                  },
                 });
               }}
             />
diff --git a/code/addons/test/src/node/test-manager.ts b/code/addons/test/src/node/test-manager.ts
index 9b54c341bfa..43b51d45c19 100644
--- a/code/addons/test/src/node/test-manager.ts
+++ b/code/addons/test/src/node/test-manager.ts
@@ -117,50 +117,39 @@ export class TestManager {
   }
 
   async handleTriggerRunEvent(event: TriggerRunEvent) {
-    this.componentTestStatusStore.unset(event.payload.storyIds);
-    this.a11yStatusStore.unset(event.payload.storyIds);
-
-    this.testProviderStore.runWithState(async () => {
-      try {
-        this.store.setState((s) => ({
-          ...s,
-          currentRun: {
-            ...storeOptions.initialState.currentRun,
-            startedAt: Date.now(),
-            storyIds: event.payload.storyIds,
-            coverage: s.config.coverage,
-            a11y: s.config.a11y,
-          },
-        }));
-
-        const state = this.store.getState();
-
-        /*
-        If we're only running a subset of stories, we have to temporarily disable coverage,
-        as a coverage report for a subset of stories is not useful.
-        */
-        const temporarilyDisableCoverage =
-          state.config.coverage && !state.watching && (event.payload.storyIds ?? []).length > 0;
-        if (temporarilyDisableCoverage) {
-          await this.vitestManager.restartVitest({
-            coverage: false,
-          });
-        } else {
-          await this.vitestManager.vitestRestartPromise;
+    return this.runTestsWithState({
+      storyIds: event.payload?.storyIds,
+      callback: async () => {
+        try {
+          const state = this.store.getState();
+
+          /*
+            If we're only running a subset of stories, we have to temporarily disable coverage,
+            as a coverage report for a subset of stories is not useful.
+          */
+          const temporarilyDisableCoverage =
+            state.config.coverage && !state.watching && (event.payload?.storyIds ?? []).length > 0;
+          if (temporarilyDisableCoverage) {
+            await this.vitestManager.restartVitest({
+              coverage: false,
+            });
+          } else {
+            await this.vitestManager.vitestRestartPromise;
+          }
+
+          await this.vitestManager.runTests(event.payload);
+
+          const stateAfterRun = this.store.getState();
+
+          if (temporarilyDisableCoverage && stateAfterRun.config.coverage) {
+            // Re-enable coverage if it was temporarily disabled because of a subset of stories was run
+            await this.vitestManager.restartVitest({ coverage: stateAfterRun.config.coverage });
+          }
+        } catch (err) {
+          this.reportFatalError('Failed to run tests', err);
+          throw err;
         }
-
-        await this.vitestManager.runTests(event.payload);
-
-        const stateAfterRun = this.store.getState();
-
-        if (temporarilyDisableCoverage && stateAfterRun.config.coverage) {
-          // Re-enable coverage if it was temporarily disabled because of a subset of stories was run
-          await this.vitestManager.restartVitest({ coverage: stateAfterRun.config.coverage });
-        }
-      } catch (err) {
-        this.reportFatalError('Failed to run tests', err);
-        throw err;
-      }
+      },
     });
   }
 
@@ -181,6 +170,29 @@ export class TestManager {
     }
   }
 
+  async runTestsWithState({
+    storyIds,
+    callback,
+  }: {
+    storyIds?: string[];
+    callback: () => Promise<void>;
+  }) {
+    this.componentTestStatusStore.unset(storyIds);
+    this.a11yStatusStore.unset(storyIds);
+
+    this.store.setState((s) => ({
+      ...s,
+      currentRun: {
+        ...storeOptions.initialState.currentRun,
+        startedAt: Date.now(),
+        storyIds: storyIds,
+        coverage: s.config.coverage,
+        a11y: s.config.a11y,
+      },
+    }));
+    return this.testProviderStore.runWithState(callback);
+  }
+
   onTestModuleCollected(collectedTestCount: number) {
     this.store.setState((s) => ({
       ...s,
diff --git a/code/addons/test/src/node/vitest-manager.ts b/code/addons/test/src/node/vitest-manager.ts
index 9a3d98db375..4d85b9a3f38 100644
--- a/code/addons/test/src/node/vitest-manager.ts
+++ b/code/addons/test/src/node/vitest-manager.ts
@@ -10,7 +10,12 @@ import type {
 } from 'vitest/node';
 
 import { resolvePathInStorybookCache } from 'storybook/internal/common';
-import type { DocsIndexEntry, StoryIndex, StoryIndexEntry } from 'storybook/internal/types';
+import type {
+  DocsIndexEntry,
+  StoryId,
+  StoryIndex,
+  StoryIndexEntry,
+} from 'storybook/internal/types';
 
 import { findUp } from 'find-up';
 import path, { dirname, join, normalize } from 'pathe';
@@ -153,7 +158,13 @@ export class VitestManager {
     });
   }
 
-  private async fetchStories(indexUrl: string, requestStoryIds?: string[]) {
+  private async fetchStories(requestStoryIds?: string[]) {
+    const indexUrl = this.testManager.store.getState().indexUrl;
+    if (!indexUrl) {
+      throw new Error(
+        'Tried to fetch stories to test, but the index URL was not set in the store yet.'
+      );
+    }
     try {
       const index = (await Promise.race([
         fetch(indexUrl).then((res) => res.json()),
@@ -195,9 +206,9 @@ export class VitestManager {
 
     this.resetGlobalTestNamePattern();
 
-    const stories = await this.fetchStories(runPayload.indexUrl, runPayload.storyIds);
+    const stories = await this.fetchStories(runPayload?.storyIds);
     const vitestTestSpecs = await this.getStorybookTestSpecs();
-    const isSingleStoryRun = runPayload.storyIds?.length === 1;
+    const isSingleStoryRun = runPayload?.storyIds.length === 1;
 
     const { filteredTestFiles, totalTestCount } = vitestTestSpecs.reduce(
       (acc, spec) => {
@@ -329,11 +340,26 @@ export class VitestManager {
       }
     }
 
-    if (triggerAffectedTests.length) {
-      await this.vitest.cancelCurrentRun('keyboard-input');
-      await this.runningPromise;
-      await this.vitest!.runTestSpecifications(triggerAffectedTests, false);
-    }
+    const stories = this.testManager.store.getState().indexUrl ? await this.fetchStories() : [];
+
+    const affectedStoryIds = triggerAffectedTests
+      .map((spec) =>
+        stories
+          .filter((story) => join(process.cwd(), story.importPath) === spec.moduleId)
+          .map((story) => story.id)
+      )
+      .flat();
+
+    await this.testManager.runTestsWithState({
+      storyIds: affectedStoryIds,
+      callback: async () => {
+        if (triggerAffectedTests.length) {
+          await this.vitest!.cancelCurrentRun('keyboard-input');
+          await this.runningPromise;
+          await this.vitest!.runTestSpecifications(triggerAffectedTests, false);
+        }
+      },
+    });
   }
 
   async runAffectedTestsAfterChange(file: string) {
diff --git a/code/addons/test/src/types.ts b/code/addons/test/src/types.ts
index b5bdd802323..a85c8e01d36 100644
--- a/code/addons/test/src/types.ts
+++ b/code/addons/test/src/types.ts
@@ -35,6 +35,9 @@ export type StoreState = {
   };
   watching: boolean;
   cancelling: boolean;
+  // TODO: Avoid needing to do a fetch request server-side to retrieve the index
+  // e.g. http://localhost:6006/index.json
+  indexUrl: string | undefined;
   fatalError:
     | {
         message: string | undefined;
@@ -63,10 +66,8 @@ export type CachedState = Pick<StoreState, 'config' | 'watching'>;
 
 export type TriggerRunEvent = {
   type: 'TRIGGER_RUN';
-  payload: {
-    // TODO: Avoid needing to do a fetch request server-side to retrieve the index
-    indexUrl: string; // e.g. http://localhost:6006/index.json
-    storyIds?: string[]; // ['button--primary', 'button--secondary']
+  payload?: {
+    storyIds: string[];
   };
 };
 export type CancelRunEvent = {
