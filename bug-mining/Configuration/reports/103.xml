<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Sat Nov 08 17:37:40 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[CONFIGURATION-390] AbstractHierarchicalFileConfiguration is not thread safe</title>
                <link>https://issues.apache.org/jira/browse/CONFIGURATION-390</link>
                <project id="12310467" key="CONFIGURATION">Commons Configuration</project>
                    <description>&lt;p&gt;AbstractHierarchicalFileConfiguration doesn&apos;t implement the same locking mechanism found in AbstractFileConfiguration. The consequence is that getting a property while the configuration is being reloaded by another thread can return an invalid result.&lt;/p&gt;

&lt;p&gt;This can be demonstrated by changing testDeadlockWithReload() in TestCombinedConfiguration to use an XMLConfiguration instead of a PropertiesConfiguration.&lt;/p&gt;

&lt;p&gt;Here is a reduced test case:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void testConcurrentGetAndReload() &lt;span class=&quot;code-keyword&quot;&gt;throws&lt;/span&gt; Exception
{
    &lt;span class=&quot;code-comment&quot;&gt;//&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; FileConfiguration config = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; PropertiesConfiguration(&lt;span class=&quot;code-quote&quot;&gt;&quot;test.properties&quot;&lt;/span&gt;);
&lt;/span&gt;    &lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; FileConfiguration config = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; XMLConfiguration(&lt;span class=&quot;code-quote&quot;&gt;&quot;test.xml&quot;&lt;/span&gt;);
    config.setReloadingStrategy(&lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; FileAlwaysReloadingStrategy());

    assertTrue(&lt;span class=&quot;code-quote&quot;&gt;&quot;Property not found&quot;&lt;/span&gt;, config.getProperty(&lt;span class=&quot;code-quote&quot;&gt;&quot;test.&lt;span class=&quot;code-object&quot;&gt;short&lt;/span&gt;&quot;&lt;/span&gt;) != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;);

    &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Thread&lt;/span&gt;()
    {
        &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; void run()
        {
            &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; i = 0; i &amp;lt; 1000; i++)
            {
                config.reload();
            }
        }
    }.start();
    
    &lt;span class=&quot;code-keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-object&quot;&gt;int&lt;/span&gt; i = 0; i &amp;lt; 1000; i++)
    {
        assertTrue(&lt;span class=&quot;code-quote&quot;&gt;&quot;Property not found&quot;&lt;/span&gt;, config.getProperty(&lt;span class=&quot;code-quote&quot;&gt;&quot;test.&lt;span class=&quot;code-object&quot;&gt;short&lt;/span&gt;&quot;&lt;/span&gt;) != &lt;span class=&quot;code-keyword&quot;&gt;null&lt;/span&gt;); &lt;span class=&quot;code-comment&quot;&gt;// failure here
&lt;/span&gt;    }
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The test doesn&apos;t always fail. It does about 50% of the time.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12428678">CONFIGURATION-390</key>
            <summary>AbstractHierarchicalFileConfiguration is not thread safe</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="1" iconUrl="https://issues.apache.org/jira/images/icons/statuses/open.png" description="The issue is open and ready for the assignee to start work on it.">Open</status>
                    <statusCategory id="2" key="new" colorName="blue-gray"/>
                                    <resolution id="-1">Unresolved</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="ebourg">Emmanuel Bourg</reporter>
                        <labels>
                    </labels>
                <created>Tue, 23 Jun 2009 15:49:10 +0000</created>
                <updated>Mon, 21 Oct 2013 23:21:26 +0000</updated>
                                            <version>1.6</version>
                                                    <component>File reloading</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                                                                <comments>
                            <comment id="12759635" author="shkinser" created="Fri, 25 Sep 2009 17:26:21 +0000"  >&lt;p&gt;I hit this same problem, though with a CombinedConfiguration made up of multiple XMLConfigurations. I am attaching a small maven project that demonstrates the problem, and fails about 50% of the time.&lt;/p&gt;</comment>
                            <comment id="12759641" author="shkinser" created="Fri, 25 Sep 2009 17:30:42 +0000"  >&lt;p&gt;I also get this problem randomly when multithreaded, though I don&apos;t know if this belongs in a different JIRA:&lt;/p&gt;

&lt;p&gt;testMultiThreadedAccess(TestReloading)  Time elapsed: 0.018 sec  &amp;lt;&amp;lt;&amp;lt; FAILURE!&lt;br/&gt;
java.lang.IllegalStateException: Node cannot be modified when added to a parent!&lt;br/&gt;
        at org.apache.commons.configuration.tree.DefaultConfigurationNode.checkState(DefaultConfigurationNode.java:454)&lt;br/&gt;
        at org.apache.commons.configuration.tree.DefaultConfigurationNode.setAttribute(DefaultConfigurationNode.java:290)&lt;br/&gt;
        at org.apache.commons.configuration.tree.DefaultConfigurationNode.addChild(DefaultConfigurationNode.java:184)&lt;br/&gt;
        at org.apache.commons.configuration.tree.ViewNode.addChild(ViewNode.java:78)&lt;br/&gt;
        at org.apache.commons.configuration.tree.ViewNode.appendChildren(ViewNode.java:114)&lt;br/&gt;
        at org.apache.commons.configuration.CombinedConfiguration$ConfigData.getTransformedRoot(CombinedConfiguration.java:847)&lt;br/&gt;
        at org.apache.commons.configuration.CombinedConfiguration.constructCombinedNode(CombinedConfiguration.java:699)&lt;br/&gt;
        at org.apache.commons.configuration.CombinedConfiguration.getRootNode(CombinedConfiguration.java:542)&lt;br/&gt;
        at org.apache.commons.configuration.HierarchicalConfiguration.fetchNodeList(HierarchicalConfiguration.java:926)&lt;br/&gt;
        at org.apache.commons.configuration.CombinedConfiguration.fetchNodeList(CombinedConfiguration.java:653)&lt;br/&gt;
        at org.apache.commons.configuration.HierarchicalConfiguration.getProperty(HierarchicalConfiguration.java:332)&lt;br/&gt;
        at org.apache.commons.configuration.AbstractConfiguration.resolveContainerStore(AbstractConfiguration.java:1160)&lt;br/&gt;
        at org.apache.commons.configuration.AbstractConfiguration.getString(AbstractConfiguration.java:1035)&lt;br/&gt;
        at org.apache.commons.configuration.AbstractConfiguration.getString(AbstractConfiguration.java:1018)&lt;br/&gt;
        at TestReloading.testMultiThreadedAccess(TestReloading.java:73)&lt;/p&gt;</comment>
                            <comment id="12759854" author="ralph.goers@dslextreme.com" created="Sat, 26 Sep 2009 03:57:55 +0000"  >&lt;p&gt;Thanks for reporting this. It just so happens that I am also experience problems that are most likely due to reloading not being thread safe and was going to create a test case. It looks like you saved me the effort.&lt;/p&gt;</comment>
                            <comment id="12759907" author="oliver.heger@t-online.de" created="Sat, 26 Sep 2009 14:52:35 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/browse/CONFIGURATION-344&quot; title=&quot;Deadlock during refresh properties&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CONFIGURATION-344&quot;&gt;&lt;del&gt;CONFIGURATION-344&lt;/del&gt;&lt;/a&gt; contains some comments about threading problems with reload operations in general. They also are valid for this issue.&lt;/p&gt;</comment>
                            <comment id="12759911" author="oliver.heger@t-online.de" created="Sat, 26 Sep 2009 15:35:51 +0000"  >&lt;p&gt;I have created a unit test that fails more reliably and a proposed fix.&lt;/p&gt;

&lt;p&gt;The idea is that the lock used by the &lt;tt&gt;reload()&lt;/tt&gt; method is exposed so that external synchronization can be performed. &lt;tt&gt;AbstractHierarchicalFileConfiguration&lt;/tt&gt; now synchronizes at this lock in its &lt;tt&gt;getProperty()&lt;/tt&gt; method. This does not fix all problems with this architecture, e.g. other methods like &lt;tt&gt;isEmpty()&lt;/tt&gt; or &lt;tt&gt;containsKey()&lt;/tt&gt; should be treated in a similar way. But concurrent property reads should now be possible.&lt;/p&gt;</comment>
                            <comment id="12759925" author="ralph.goers@dslextreme.com" created="Sat, 26 Sep 2009 17:34:43 +0000"  >&lt;p&gt;Oliver, I have created a very similar patch but I am using the reloading lock on a lot more methods such as containsKey(), etc. This is necessary because all these methods are at risk of having the underlying structure change, not just getProperty.&lt;/p&gt;

&lt;p&gt;However, CombinedConfiguration seems to be a tougher nut to crack. The test I am using is below and is a variation on the XMLConfiguration test case and was added to TestCombinedConfiguration and fails every time.&lt;br/&gt;
    public void testConcurrentGetAndReload() throws Exception&lt;br/&gt;
    {&lt;br/&gt;
        config.setForceReloadCheck(true);&lt;br/&gt;
        config.setNodeCombiner(new MergeCombiner());&lt;br/&gt;
        //final FileConfiguration config = new PropertiesConfiguration(&quot;test.properties&quot;);&lt;br/&gt;
        final XMLConfiguration xml = new XMLConfiguration(&quot;test.xml&quot;);&lt;br/&gt;
        xml.setReloadingStrategy(new FileAlwaysReloadingStrategy());&lt;br/&gt;
        config.addConfiguration(xml);&lt;/p&gt;

&lt;p&gt;        assertTrue(&quot;Property not found&quot;, config.getProperty(&quot;test.short&quot;) != null);&lt;/p&gt;

&lt;p&gt;        Thread testThreads[] = new Thread&lt;span class=&quot;error&quot;&gt;&amp;#91;5&amp;#93;&lt;/span&gt;;&lt;/p&gt;

&lt;p&gt;        for (int i = 0; i &amp;lt; testThreads.length; ++i)&lt;/p&gt;
        {
            testThreads[i] = new ReloadThread(xml);
            testThreads[i].start();
        }

&lt;p&gt;        for (int i = 0; i &amp;lt; 2000; i++)&lt;/p&gt;
        {
            assertTrue(&quot;Property not found&quot;, config.getProperty(&quot;test.short&quot;) != null);
        }

&lt;p&gt;        for (int i = 0; i &amp;lt; testThreads.length; ++i)&lt;/p&gt;
        {
            testThreads[i].join();
        }
&lt;p&gt;    }&lt;/p&gt;

&lt;p&gt;    private class ReloadThread extends Thread&lt;br/&gt;
    {&lt;br/&gt;
        FileConfiguration config;&lt;/p&gt;

&lt;p&gt;        ReloadThread(FileConfiguration config)&lt;/p&gt;
        {
            this.config = config;
        }
&lt;p&gt;        public void run()&lt;br/&gt;
        {&lt;br/&gt;
            for (int i = 0; i &amp;lt; 1000; i++)&lt;/p&gt;
            {
                config.reload();
            }
&lt;p&gt;        }&lt;br/&gt;
    }&lt;/p&gt;</comment>
                            <comment id="12759942" author="oliver.heger@t-online.de" created="Sat, 26 Sep 2009 20:03:54 +0000"  >&lt;p&gt;Okay, using the reloading lock for all methods that might be affected is certainly the way to go (I was only too lazy to do this &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt; But to be consistent, analogous changes should be applied to &lt;tt&gt;AbstractFileConfiguration&lt;/tt&gt;: Here we have the same pattern that methods first call &lt;tt&gt;reload()&lt;/tt&gt; and then do something with the data, which might already be invalid due to another &lt;tt&gt;reload()&lt;/tt&gt; operation.&lt;/p&gt;

&lt;p&gt;Just an idea: Would it make sense to have a method like &lt;tt&gt;syncReload(Accessor acc)&lt;/tt&gt; in &lt;tt&gt;AbstractFileConfiguration&lt;/tt&gt; like the following:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;interface&lt;/span&gt; Accessor
{
    &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; access(FileConfiguration config);
}

&lt;span class=&quot;code-keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; syncReload(Accessor acc)
{
    &lt;span class=&quot;code-keyword&quot;&gt;synchronized&lt;/span&gt;(reloadLock)
    {
        reload();
        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; acc.access(&lt;span class=&quot;code-keyword&quot;&gt;this&lt;/span&gt;);
    }
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Maybe this would reduce the clutter in the affected methods a bit and allow a more closure-oriented programming.&lt;/p&gt;

&lt;p&gt;Now to &lt;tt&gt;CombinedConfiguration&lt;/tt&gt;: AFAICT the problem lies in the &lt;tt&gt;getTransformedRoot()&lt;/tt&gt; method of the helper class &lt;tt&gt;ConfigData&lt;/tt&gt;. We have here the following code:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-comment&quot;&gt;// Copy data of the root node to the &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; path
&lt;/span&gt;rootNode = ConfigurationUtils.convertToHierarchical(getConfiguration(),
    getConversionExpressionEngine()).getRootNode();
atParent.appendChildren(rootNode);
atParent.appendAttributes(rootNode);
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;To be save, this fragment has to be executed with the reload lock of the processed configuration hold. A dirty hack could be to add the &lt;tt&gt;getReloadLock()&lt;/tt&gt; method to the &lt;tt&gt;FileConfiguration&lt;/tt&gt; interface and check whether the configuration implements this interface:&lt;/p&gt;

&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt;(getConfiguration() &lt;span class=&quot;code-keyword&quot;&gt;instanceof&lt;/span&gt; FileConfiguration)
{
    &lt;span class=&quot;code-keyword&quot;&gt;synchronized&lt;/span&gt;(((FileConfiguration) getConfiguration()).getReloadLock())
    {
        &lt;span class=&quot;code-comment&quot;&gt;// Copy data of the root node to the &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; path
&lt;/span&gt;        ...
    }
}
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;However, changing the &lt;tt&gt;FileConfiguration&lt;/tt&gt; interface is a binary incompatible change. So we might have to introduce an additional interface solely for this purpose.&lt;/p&gt;

&lt;p&gt;WDYT?&lt;/p&gt;</comment>
                            <comment id="12759947" author="ralph.goers@dslextreme.com" created="Sat, 26 Sep 2009 20:37:30 +0000"  >&lt;p&gt;I don&apos;t understand the Accessor thing. The issue is that various operations have to be synchronized since the underlying structure might change while the operation is being performed. I&apos;m not sure how this construct helps.&lt;/p&gt;

&lt;p&gt;With CombinedConfiguration I also have focused on that bit of code and syncrhonized there pretty much the way you have suggested but the use case I posted above still fails. From what I can tell this is because in an XMLConfiguration the root node is cleared and then reloaded. Apparently getTransformedRoot() adds the nodes from the actual HierarchicalConfiguration into the CombinedConfiguration instead of making copies of them. This means that once the reloadLock is released the CombinedConfiguration can be modified asynchronously.&lt;/p&gt;

&lt;p&gt;The above shouldn&apos;t be a problem if it simply isn&apos;t allowed to use a Configuration object directly once it is incorporated into a combined configuration.&lt;/p&gt;</comment>
                            <comment id="12759970" author="ralph.goers@dslextreme.com" created="Sun, 27 Sep 2009 00:35:14 +0000"  >&lt;p&gt;After a few more minutes of thought I think even this restriction won&apos;t solve the problem.  If two threads access the Combined Configuration, one may get through getRootNode and start working with it. The second thread will detect a reload and start into constructCombinedNode and that will screw up the thread that is working with it even though they will have different &quot;combinedRoot&quot; nodes, because the underlying Nodes from the configurations being combined are being messed with.&lt;/p&gt;

&lt;p&gt;I should also mention that I took configtest.tar.gz attached to this issue and tried it with the modifications to lock both getRootNode() and the actual HierarchicalConfiguration in getTransformedRoot() and it made absolutely no difference. It still fails most of the time.&lt;/p&gt;

&lt;p&gt;I can only think of two ways out of this:&lt;br/&gt;
1. Clone the underlying configurations. This is a really ugly solution as something like MultiFileHierachicalConfiguration won&apos;t be pretty to clone.&lt;br/&gt;
2. Synchronize the public methods that need access to the root node more or less the same as is needed in XMLConfiguration. Again, this can be optimized in 2.0 by using Read/Write locks. I&apos;d love to do this in 1.7 but I really don&apos;t want to introduce a dependency on util.concurrent. &lt;/p&gt;</comment>
                            <comment id="12759991" author="ralph.goers@dslextreme.com" created="Sun, 27 Sep 2009 06:26:16 +0000"  >&lt;p&gt;I was able to get my test to pass by synchronizing the public methods.  This gets even more interesting because of SubnodeConfiguration objects.&lt;/p&gt;

&lt;p&gt;I&apos;m beginning to think that AbstractHierarchicalFileConfiguration, CombinedConfiguration and SubnodeConfiguration all need to extend a new class named HierarchicalReloadableConfiguration. This class would provide the reload lock object (or set it to the lock provided by the parent) and then lock all the appropriate methods. Subclasses wouldn&apos;t then have to provide overrides for all the methods and would be able to lock with the appropriate lock when they do override methods.&lt;/p&gt;</comment>
                            <comment id="12760089" author="oliver.heger@t-online.de" created="Sun, 27 Sep 2009 19:38:14 +0000"  >&lt;p&gt;A common base class that handles the locking stuff sounds like a good solution.&lt;/p&gt;

&lt;p&gt;I fear, in its current state the code is hardly maintainable. A lot of methods have to aware of the reloading functionality, and if a synchronization is missing, this will lead to trouble. So maybe for 2.0 we should think about a radical different approach to reloading?&lt;/p&gt;</comment>
                            <comment id="12760099" author="ralph.goers@dslextreme.com" created="Sun, 27 Sep 2009 20:47:32 +0000"  >&lt;p&gt;Yes, I agree. &lt;/p&gt;

&lt;p&gt;I am going to commit some code that I believe fixes this shortly. Unfortunately, I&apos;ve been working on other stuff and that is going to get committed as well, so I am thinking I will create a branch for this so it can be inspected before it gets merged to trunk. I will be opening a separate jira issue for the other stuff I&apos;ve been working on.&lt;/p&gt;

&lt;p&gt;A large part of the problem seems to be how hierarchical configurations are represented in memory and how they are being shared in a combined configuration. Also, I&apos;m not even sure a &quot;combined configuration&quot; is really the right way to go. The composite configuration would probably be easier to deal with. Since that is all DefaultConfigurationBuilder will work with though, there isn&apos;t a lot of choice.&lt;/p&gt;</comment>
                            <comment id="12760122" author="ralph.goers@dslextreme.com" created="Sun, 27 Sep 2009 22:46:24 +0000"  >&lt;p&gt;I have committed my changes to &lt;a href=&quot;https://svn.apache.org/repos/asf/commons/proper/configuration/branches/CONFIGURATION_390&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;https://svn.apache.org/repos/asf/commons/proper/configuration/branches/CONFIGURATION_390&lt;/a&gt;.  Please inspect the changes and test.&lt;/p&gt;

&lt;p&gt;1. CombinedConfiguration and SubnodeConfiguration both extend HierarchicalReloadableConfiguration.&lt;br/&gt;
2. HierarchicalReloadableConfiguration implements Reloadable.&lt;br/&gt;
3. AbstractHierarchicalFileConfiguration implements Reloadable as delegate.getReloadLock().&lt;br/&gt;
4. AbstractHierarchicalFileConfiguration wraps many of the methods with synchronized(delegate.getReloadLock()).&lt;br/&gt;
5. HierarchicalReloadableConfiguration has a constructor that can be passed the lock to synchronize on. If no lock is passed a new Object is used.&lt;br/&gt;
6. SubnodeConfiguration&apos;s constructor gets the parents lock object if the parent is Reloadable and passes it to HierarchicalReloadableConfiguraton&apos;s constructor. This should cause any SubnodeConfiguration for XMLConfiguration or CombinedConfiguration to use the lock of its parent.&lt;/p&gt;</comment>
                            <comment id="12760370" author="oliver.heger@t-online.de" created="Mon, 28 Sep 2009 20:19:52 +0000"  >&lt;p&gt;Ralph, your changes look good to me. I have the following questions/remarks:&lt;/p&gt;

&lt;ul&gt;
	&lt;li&gt;Can we be sure that the problem described in &lt;a href=&quot;https://issues.apache.org/jira/browse/CONFIGURATION-344&quot; title=&quot;Deadlock during refresh properties&quot; class=&quot;issue-link&quot; data-issue-key=&quot;CONFIGURATION-344&quot;&gt;&lt;del&gt;CONFIGURATION-344&lt;/del&gt;&lt;/a&gt; does not pop up again? With the lock used by the CombinedConfiguration and the locks used by child configurations there are multiple locks involved which may be prone to dead lock under certain circumstances.&lt;/li&gt;
	&lt;li&gt;I wonder whether SubnodeConfiguration.getRootNode() needs locking, too. Probably not, because it is mainly called internally by methods that should already have the lock. But I am not sure.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="12760496" author="ralph.goers@dslextreme.com" created="Tue, 29 Sep 2009 05:05:27 +0000"  >&lt;p&gt;Ultimately, we have to find a better solution than this.&lt;/p&gt;

&lt;p&gt;And I guess I&apos;m not done yet. Now that we know how we can make this happen in our production system. Unfortunately, even with these changes it is still happening. We use DynamicCombinedConfiguration and MultiFileHierarchicalConfiguration so I&apos;m going to have to include those into the mix.&lt;/p&gt;</comment>
                            <comment id="12760774" author="ralph.goers@dslextreme.com" created="Tue, 29 Sep 2009 23:44:13 +0000"  >&lt;p&gt;I&apos;ve made some more changes on the branch. I was getting out of memory errors in some unit tests because clear was not creating a new root node. I also included DynamicCombinedConfiguration in the locking and now it passes all the tests.&lt;/p&gt;

&lt;p&gt;Although I may push this to trunk I am going to keep looking into this to see if there is a better way to deal with this as it is going to impact performance.&lt;/p&gt;</comment>
                            <comment id="12762067" author="ralph.goers@dslextreme.com" created="Mon, 5 Oct 2009 02:12:45 +0000"  >&lt;p&gt;More changes on the branch. I&apos;ve been able to fix the problem without having to resort to locking all the method calls. When a combined configuration is constructed a copy of each participating configuration is used and locking is now done in appropriate places. This allows the reload to take place without affecting other threads as they will continue using a different tree until a subsequent getRootNode() call is made.&lt;/p&gt;</comment>
                            <comment id="12762326" author="oliver.heger@t-online.de" created="Mon, 5 Oct 2009 19:34:44 +0000"  >&lt;p&gt;This sounds good. I guess creating copies of the configurations may be an issue for large data sets, but in most typical applications the amount of configuration data should be limited. And it is certainly preferable to get rid of all that locking spread all over the code.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="12407513">CONFIGURATION-344</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12420579" name="TestSuite.txt" size="236275" author="shkinser" created="Fri, 25 Sep 2009 17:30:42 +0000"/>
                            <attachment id="12420628" name="commons-configuration-390.patch" size="5128" author="oheger" created="Sat, 26 Sep 2009 15:35:51 +0000"/>
                            <attachment id="12420578" name="configtest.tar.gz" size="2023" author="shkinser" created="Fri, 25 Sep 2009 17:30:42 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>3.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>61986</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            16 years, 7 weeks, 4 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i19xbj:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>266032</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </customfields>
    </item>
</channel>
</rss>