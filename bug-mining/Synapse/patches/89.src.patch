diff --git a/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/Axis2HttpRequest.java b/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/Axis2HttpRequest.java
index 1497e4d6a..a76c5977b 100644
--- a/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/Axis2HttpRequest.java
+++ b/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/Axis2HttpRequest.java
@@ -18,31 +18,35 @@
  */
 package org.apache.synapse.transport.nhttp;
 
-import org.apache.axis2.addressing.EndpointReference;
-import org.apache.axis2.context.MessageContext;
+import org.apache.axiom.om.OMOutputFormat;
 import org.apache.axis2.AxisFault;
 import org.apache.axis2.Constants;
-import org.apache.synapse.transport.nhttp.util.PipeImpl;
-import org.apache.synapse.transport.nhttp.util.RESTUtil;
-import org.apache.synapse.transport.nhttp.util.MessageFormatterDecoratorFactory;
-import org.apache.axis2.transport.http.HTTPConstants;
+import org.apache.axis2.addressing.EndpointReference;
+import org.apache.axis2.context.MessageContext;
 import org.apache.axis2.transport.MessageFormatter;
-import org.apache.http.*;
+import org.apache.axis2.transport.http.HTTPConstants;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.http.Header;
+import org.apache.http.HttpHost;
+import org.apache.http.HttpRequest;
+import org.apache.http.HttpVersion;
+import org.apache.http.entity.BasicHttpEntity;
 import org.apache.http.message.BasicHttpEntityEnclosingRequest;
 import org.apache.http.message.BasicHttpRequest;
 import org.apache.http.protocol.HTTP;
-import org.apache.http.entity.BasicHttpEntity;
-import org.apache.axiom.om.OMOutputFormat;
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
+import org.apache.synapse.transport.nhttp.util.MessageFormatterDecoratorFactory;
+import org.apache.synapse.transport.nhttp.util.PipeImpl;
+import org.apache.synapse.transport.nhttp.util.RESTUtil;
 
+import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.OutputStream;
-import java.io.ByteArrayOutputStream;
 import java.nio.channels.Channels;
 import java.nio.channels.ReadableByteChannel;
-import java.util.Map;
+import java.nio.channels.WritableByteChannel;
 import java.util.Iterator;
+import java.util.Map;
 
 /**
  * Represents an outgoing Axis2 HTTP/s request. It holds the EPR of the destination, the
@@ -190,6 +194,17 @@ public class Axis2HttpRequest {
         return pipe.source();
     }
 
+    /**
+     * Return the sink channel of the pipe that bridges the serialized output to the socket
+     * @return sink channel to read serialized message contents
+     */
+    public WritableByteChannel getSinkChannel() {
+        if (log.isDebugEnabled()) {
+            log.debug("get sink channel of the pipe on which the outgoing response is written");
+        }
+        return pipe.sink();
+    }
+
     /**
      * Start streaming the message into the Pipe, so that the contents could be read off the source
      * channel returned by getSourceChannel()
diff --git a/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/ClientHandler.java b/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/ClientHandler.java
index 7b2a58422..f62eb2013 100644
--- a/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/ClientHandler.java
+++ b/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/ClientHandler.java
@@ -49,6 +49,7 @@ import org.apache.synapse.transport.nhttp.util.PipeImpl;
 
 import java.io.IOException;
 import java.nio.ByteBuffer;
+import java.nio.channels.Channel;
 import java.nio.channels.Channels;
 import java.nio.channels.ReadableByteChannel;
 import java.nio.channels.WritableByteChannel;
@@ -82,7 +83,9 @@ public class ClientHandler implements NHttpClientHandler {
     private static final String RESPONSE_BUFFER = "response-buffer";
     private static final String OUTGOING_MESSAGE_CONTEXT = "axis2_message_context";
     private static final String REQUEST_SOURCE_CHANNEL = "request-source-channel";
-    private static final String RESPONSE_SINK_CHANNEL = "request-sink-channel";
+    private static final String RESPONSE_SINK_CHANNEL = "response-sink-channel";
+    private static final String REQUEST_SINK_CHANNEL = "request-sink-channel";
+    private static final String RESPONSE_SOURCE_CHANNEL = "response-source-channel";
 
     private static final String AXIS2_HTTP_REQUEST = "synapse.axis2-http-request";
     private static final String CONTENT_TYPE = "Content-Type";
@@ -132,6 +135,7 @@ public class ClientHandler implements NHttpClientHandler {
 
             context.setAttribute(OUTGOING_MESSAGE_CONTEXT, axis2Req.getMsgContext());
             context.setAttribute(REQUEST_SOURCE_CHANNEL, axis2Req.getSourceChannel());
+            context.setAttribute(REQUEST_SINK_CHANNEL, axis2Req.getSinkChannel());
 
             HttpRequest request = axis2Req.getRequest();
             request.setParams(new DefaultedHttpParams(request.getParams(), this.params));
@@ -172,6 +176,7 @@ public class ClientHandler implements NHttpClientHandler {
 
             context.setAttribute(OUTGOING_MESSAGE_CONTEXT, axis2Req.getMsgContext());
             context.setAttribute(REQUEST_SOURCE_CHANNEL, axis2Req.getSourceChannel());
+            context.setAttribute(REQUEST_SINK_CHANNEL, axis2Req.getSinkChannel());
 
             HttpRequest request = axis2Req.getRequest();
             request.setParams(new DefaultedHttpParams(request.getParams(), this.params));
@@ -189,11 +194,30 @@ public class ClientHandler implements NHttpClientHandler {
 
     public void closed(final NHttpClientConnection conn) {
     	checkAxisRequestComplete(conn, "Abnormal connection close", null);
+
+        // Check sink and source channels and close them if they aren't closed already.
+        // Normally these should be closed by inputReady() and outputReady(). A null request
+        // or response will not hit inputReady and outputReady however.
+
+        HttpContext context = conn.getContext();
+        closeChannel((ReadableByteChannel) context.getAttribute(REQUEST_SOURCE_CHANNEL));
+        closeChannel((ReadableByteChannel) context.getAttribute(RESPONSE_SOURCE_CHANNEL));
+        closeChannel((WritableByteChannel) context.getAttribute(RESPONSE_SINK_CHANNEL));
+        closeChannel((WritableByteChannel) context.getAttribute(REQUEST_SINK_CHANNEL));
+        
         if (log.isTraceEnabled()) {
             log.trace("Connection closed");
         }
     }
 
+    private void closeChannel(Channel chn) {
+        try {
+            if (chn != null && chn.isOpen()) {
+                chn.close();
+            }
+        } catch (IOException ignore) {}
+    }
+
     /**
      * Handle connection timeouts by shutting down the connections
      * @param conn the connection being processed
@@ -408,9 +432,8 @@ public class ClientHandler implements NHttpClientHandler {
                                 getMessageContext(WSDL2Constants.MESSAGE_LABEL_IN);
                         if (responseMsgCtx == null ||
                                 outMsgCtx.getOptions().isUseSeparateListener()) {
-                            // to support Sandesha.. however, this means that we received a
-                            // 202 accepted for an out-only , for which we do not need a
-                            // dummy message anyway
+                            // This means that we received a 202 accepted for an out-only ,
+                            // for which we do not need a dummy message anyway
                             return;
                         }
                         responseMsgCtx.setServerSide(true);
@@ -534,6 +557,7 @@ public class ClientHandler implements NHttpClientHandler {
         try {
             PipeImpl responsePipe = new PipeImpl();
             context.setAttribute(RESPONSE_SINK_CHANNEL, responsePipe.sink());
+            context.setAttribute(RESPONSE_SOURCE_CHANNEL, responsePipe.source());
 
             BasicHttpEntity entity = new BasicHttpEntity();
             if (response.getStatusLine().getProtocolVersion().greaterEquals(HttpVersion.HTTP_1_1)) {
diff --git a/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/ServerHandler.java b/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/ServerHandler.java
index 7ed7eae0a..bc5a0aabe 100644
--- a/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/ServerHandler.java
+++ b/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/ServerHandler.java
@@ -43,6 +43,7 @@ import java.nio.ByteBuffer;
 import java.nio.channels.Channels;
 import java.nio.channels.WritableByteChannel;
 import java.nio.channels.ReadableByteChannel;
+import java.nio.channels.Channel;
 
 /**
  * The server connection handler. An instance of this class is used by each IOReactor, to
@@ -76,6 +77,8 @@ public class ServerHandler implements NHttpServiceHandler {
 
     private static final String REQUEST_SINK_CHANNEL = "request-sink-channel";
     private static final String RESPONSE_SOURCE_CHANNEL = "response-source-channel";
+    private static final String REQUEST_SOURCE_CHANNEL = "request-source-channel";
+    private static final String RESPONSE_SINK_CHANNEL = "response-sink-channel";
     private static final String REQUEST_BUFFER = "request-buffer";
     private static final String RESPONSE_BUFFER = "response-buffer";
 
@@ -117,7 +120,9 @@ public class ServerHandler implements NHttpServiceHandler {
             PipeImpl requestPipe  = new PipeImpl(); // the pipe used to process the request
             PipeImpl responsePipe = new PipeImpl(); // the pipe used to process the response
             context.setAttribute(REQUEST_SINK_CHANNEL, requestPipe.sink());
+            context.setAttribute(REQUEST_SOURCE_CHANNEL, requestPipe.source());
             context.setAttribute(RESPONSE_SOURCE_CHANNEL, responsePipe.source());
+            context.setAttribute(RESPONSE_SINK_CHANNEL, responsePipe.sink());
 
             // create the default response to this request
             ProtocolVersion httpVersion = request.getRequestLine().getProtocolVersion();
@@ -273,11 +278,30 @@ public class ServerHandler implements NHttpServiceHandler {
     }
 
     public void closed(final NHttpServerConnection conn) {
+
+        // Check sink and source channels and close them if they aren't closed already.
+        // Normally these should be closed by inputReady() and outputReady(). A null request
+        // or response will not hit inputReady and outputReady however.
+
+        HttpContext context = conn.getContext();
+        closeChannel((ReadableByteChannel) context.getAttribute(REQUEST_SOURCE_CHANNEL));
+        closeChannel((ReadableByteChannel) context.getAttribute(RESPONSE_SOURCE_CHANNEL));
+        closeChannel((WritableByteChannel) context.getAttribute(RESPONSE_SINK_CHANNEL));
+        closeChannel((WritableByteChannel) context.getAttribute(REQUEST_SINK_CHANNEL));
+
         if (log.isTraceEnabled()) {
             log.trace("Connection closed");
         }
     }
 
+    private void closeChannel(Channel chn) {
+        try {
+            if (chn != null && chn.isOpen()) {
+                chn.close();
+            }
+        } catch (IOException ignore) {}
+    }
+
     /**
      * Handle HTTP Protocol violations with an error response
      * @param conn the connection being processed
