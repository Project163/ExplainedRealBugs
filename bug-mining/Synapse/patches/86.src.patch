diff --git a/java/modules/core/src/main/java/org/apache/synapse/core/axis2/DynamicAxisOperation.java b/java/modules/core/src/main/java/org/apache/synapse/core/axis2/DynamicAxisOperation.java
index ab1124dbc..718944b15 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/core/axis2/DynamicAxisOperation.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/core/axis2/DynamicAxisOperation.java
@@ -21,6 +21,7 @@ package org.apache.synapse.core.axis2;
 
 import org.apache.axiom.soap.SOAPEnvelope;
 import org.apache.axis2.AxisFault;
+import org.apache.axis2.Constants;
 import org.apache.axis2.addressing.EndpointReference;
 import org.apache.axis2.client.OperationClient;
 import org.apache.axis2.client.Options;
@@ -37,6 +38,7 @@ import org.apache.axis2.transport.TransportUtils;
 import org.apache.axis2.util.TargetResolver;
 import org.apache.axis2.wsdl.WSDLConstants;
 import org.apache.synapse.SynapseConstants;
+import org.apache.synapse.transport.nhttp.NhttpConstants;
 
 import javax.xml.namespace.QName;
 
@@ -123,8 +125,8 @@ public class DynamicAxisOperation extends OutInAxisOperation {
 			outMsgCtx.setTransportOut(transportOut);
 
 			if (options.getTransportIn() == null && outMsgCtx.getTransportIn() == null) {
-				outMsgCtx.setTransportIn(
-                    ClientUtils.inferInTransport(cfgCtx.getAxisConfiguration(), options, outMsgCtx));
+				outMsgCtx.setTransportIn(ClientUtils.inferInTransport(
+                        cfgCtx.getAxisConfiguration(), options, outMsgCtx));
 			} else if (outMsgCtx.getTransportIn() == null) {
 				outMsgCtx.setTransportIn(options.getTransportIn());
 			}
@@ -134,41 +136,36 @@ public class DynamicAxisOperation extends OutInAxisOperation {
 
             if (options.isUseSeparateListener()) {
 
-                /* TODO - review and finalise this - asankha 22 feb 2007
-				// options.setTransportInProtocol(Constants.TRANSPORT_HTTP);
 				options.setTransportIn(outMsgCtx.getConfigurationContext()
-						.getAxisConfiguration().getTransportIn(
-								new QName(Constants.TRANSPORT_HTTP)));
-
-				SynapseCallbackReceiver callbackReceiver = (SynapseCallbackReceiver) axisOp
-						.getMessageReceiver();
-				callbackReceiver.addCallback(outMsgCtx.getMessageID(), callback);
-				EndpointReference replyToFromTransport = outMsgCtx
-						.getConfigurationContext().getListenerManager()
-						.getEPRforService(sc.getAxisService().getKey(),
-								axisOp.getKey().getLocalPart(),
-								outMsgCtx.getTransportOut().getKey().getLocalPart());
+						.getAxisConfiguration().getTransportIn(Constants.TRANSPORT_HTTP));
+
+				SynapseCallbackReceiver callbackReceiver =
+                        (SynapseCallbackReceiver) axisOp.getMessageReceiver();
+                
+                ((Axis2MessageContext)((AsyncCallback)
+                        axisCallback).getSynapseOutMsgCtx()).getAxis2MessageContext().setProperty(
+                        NhttpConstants.IGNORE_SC_ACCEPTED, Constants.VALUE_TRUE);
+                callbackReceiver.addCallback(outMsgCtx.getMessageID(), axisCallback);
+                
+                EndpointReference replyToFromTransport = outMsgCtx.getConfigurationContext()
+                        .getListenerManager().getEPRforService(sc.getAxisService().getName(),
+                        axisOp.getName().getLocalPart(), outMsgCtx.getTransportOut().getName());
 
 				if (outMsgCtx.getReplyTo() == null) {
 					outMsgCtx.setReplyTo(replyToFromTransport);
 				} else {
-					outMsgCtx.getReplyTo().setAddress(
-							replyToFromTransport.getAddress());
+					outMsgCtx.getReplyTo().setAddress(replyToFromTransport.getAddress());
 				}
-				// if dont do this , this guy will wait till its gets HTTP 202
-				// in the case
-				// HTTP
-				outMsgCtx.addFeature(MessageContext.TRANSPORT_NON_BLOCKING,
-						Boolean.TRUE);
-				AxisEngine engine = new AxisEngine(cfgCtx);
+
+                outMsgCtx.setProperty(NhttpConstants.IGNORE_SC_ACCEPTED, Constants.VALUE_TRUE);
 				outMsgCtx.getConfigurationContext().registerOperationContext(
 						outMsgCtx.getMessageID(), oc);
-				engine.send(outMsgCtx);
+
+                AxisEngine.send(outMsgCtx);
 
 				// Options object reused so soapAction needs to be removed so
 				// that soapAction+wsa:Action on response don't conflict
 				options.setAction("");
-                */
 
 			} else {
 
@@ -186,7 +183,8 @@ public class DynamicAxisOperation extends OutInAxisOperation {
             // envelope does not contain addressing headers
             MessageContext responseMessageContext = new MessageContext();
             responseMessageContext.setMessageID(msgctx.getMessageID());
-            responseMessageContext.setProperty(SynapseConstants.RELATES_TO_FOR_POX, msgctx.getMessageID());
+            responseMessageContext.setProperty(
+                    SynapseConstants.RELATES_TO_FOR_POX, msgctx.getMessageID());
             responseMessageContext.setOptions(options);
 			addMessageContext(responseMessageContext);
 
@@ -240,7 +238,8 @@ public class DynamicAxisOperation extends OutInAxisOperation {
                             sc.setTargetEPR(responseMessageContext.getReplyTo());
                         }
                     } else {
-                        throw new AxisFault(Messages.getMessage("blockingInvocationExpectsResponse"));
+                        throw new AxisFault(
+                                Messages.getMessage("blockingInvocationExpectsResponse"));
                     }
                 }
             }
diff --git a/java/modules/core/src/main/java/org/apache/synapse/core/axis2/SynapseCallbackReceiver.java b/java/modules/core/src/main/java/org/apache/synapse/core/axis2/SynapseCallbackReceiver.java
index 9731ae22d..af7b15f27 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/core/axis2/SynapseCallbackReceiver.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/core/axis2/SynapseCallbackReceiver.java
@@ -23,7 +23,10 @@ import org.apache.axiom.soap.SOAPEnvelope;
 import org.apache.axiom.soap.SOAPFault;
 import org.apache.axiom.soap.SOAPFaultReason;
 import org.apache.axis2.AxisFault;
+import org.apache.axis2.Constants;
+import org.apache.axis2.transport.RequestResponseTransport;
 import org.apache.axis2.addressing.AddressingConstants;
+import org.apache.axis2.addressing.AddressingHelper;
 import org.apache.axis2.addressing.EndpointReference;
 import org.apache.axis2.addressing.RelatesTo;
 import org.apache.axis2.client.Options;
@@ -266,6 +269,10 @@ public class SynapseCallbackReceiver implements MessageReceiver {
             response.setReplyTo(axisOutMsgCtx.getReplyTo());
             response.setFaultTo(axisOutMsgCtx.getFaultTo());
 
+            if (axisOutMsgCtx.isPropertyTrue(NhttpConstants.IGNORE_SC_ACCEPTED)) {
+                response.setProperty(NhttpConstants.FORCE_SC_ACCEPTED, Constants.VALUE_TRUE);
+            }
+
             // create the synapse message context for the response
             Axis2MessageContext synapseInMessageContext =
                     new Axis2MessageContext(
diff --git a/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/ClientHandler.java b/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/ClientHandler.java
index 8539baa39..9ca99c07b 100644
--- a/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/ClientHandler.java
+++ b/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/ClientHandler.java
@@ -406,7 +406,8 @@ public class ClientHandler implements NHttpClientHandler {
                     try {
                         MessageContext responseMsgCtx = outMsgCtx.getOperationContext().
                                 getMessageContext(WSDL2Constants.MESSAGE_LABEL_IN);
-                        if (responseMsgCtx == null) {
+                        if (responseMsgCtx == null
+                                || outMsgCtx.getOperationContext().isComplete()) {
                             // to support Sandesha.. however, this means that we received a
                             // 202 accepted for an out-only , for which we do not need a
                             // dummy message anyway
diff --git a/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/HttpCoreNIOSender.java b/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/HttpCoreNIOSender.java
index cbbadf3ad..411b56633 100644
--- a/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/HttpCoreNIOSender.java
+++ b/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/HttpCoreNIOSender.java
@@ -40,6 +40,7 @@ import org.apache.axis2.util.MessageContextBuilder;
 import org.apache.axis2.util.Utils;
 import org.apache.axis2.addressing.AddressingConstants;
 import org.apache.axis2.addressing.EndpointReference;
+import org.apache.axis2.addressing.AddressingHelper;
 import org.apache.axis2.context.ConfigurationContext;
 import org.apache.axis2.context.MessageContext;
 import org.apache.axis2.description.TransportOutDescription;
@@ -243,6 +244,12 @@ public class HttpCoreNIOSender extends AbstractHandler implements TransportSende
         // remove unwanted HTTP headers (if any from the current message)
         removeUnwantedHeaders(msgContext);
 
+        if (AddressingHelper.isReplyRedirected(msgContext)
+                && !msgContext.getReplyTo().hasNoneAddress()) {
+
+            msgContext.setProperty(NhttpConstants.IGNORE_SC_ACCEPTED, Constants.VALUE_TRUE);
+        }
+
         EndpointReference epr = NhttpUtils.getDestinationEPR(msgContext);
         if (epr != null) {
             if (!AddressingConstants.Final.WSA_NONE_URI.equals(epr.getAddress())) {
@@ -251,6 +258,7 @@ public class HttpCoreNIOSender extends AbstractHandler implements TransportSende
                 handleException("Cannot send message to " + AddressingConstants.Final.WSA_NONE_URI);
             }
         } else {
+
             if (msgContext.getProperty(Constants.OUT_TRANSPORT_INFO) != null) {
                 if (msgContext.getProperty(Constants.OUT_TRANSPORT_INFO) instanceof ServerWorker) {
                     sendAsyncResponse(msgContext);
diff --git a/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/NhttpConstants.java b/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/NhttpConstants.java
index f43457f07..a5b66ebe8 100644
--- a/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/NhttpConstants.java
+++ b/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/NhttpConstants.java
@@ -25,6 +25,7 @@ public class NhttpConstants {
     public static final String SENDING_FAULT = "sending_fault";
     public static final String FORCE_HTTP_1_0 = "FORCE_HTTP_1.0";
     public static final String IGNORE_SC_ACCEPTED = "IGNORE_SC_ACCEPTED";
+    public static final String FORCE_SC_ACCEPTED = "FORCE_SC_ACCEPTED";
 
     public static final String WSDL_EPR_PREFIX = "WSDLEPRPrefix";
     public static final String REMOTE_HOST ="REMOTE_HOST";
diff --git a/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/ServerWorker.java b/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/ServerWorker.java
index 5af274480..575a43c74 100644
--- a/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/ServerWorker.java
+++ b/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/ServerWorker.java
@@ -196,7 +196,7 @@ public class ServerWorker implements Runnable {
             handleException("Unsupported method : " + method, null);
         }
 
-        // here the RequestResponseTransport place an important role when it comes to
+        // here the RequestResponseTransport plays an important role when it comes to
         // dual channel invocation. This is becasue we need to ACK to the request once the request
         // is received to synapse. Otherwise we will not be able to support the single channel
         // invocation within the actual service and synapse for a dual channel request from the
@@ -207,7 +207,8 @@ public class ServerWorker implements Runnable {
                         msgContext.getOperationContext().getProperty(Constants.RESPONSE_WRITTEN)))
                         || (((RequestResponseTransport) msgContext.getProperty(
                         RequestResponseTransport.TRANSPORT_CONTROL)).getStatus()
-                        == RequestResponseTransport.RequestResponseTransportStatus.ACKED))) {
+                        == RequestResponseTransport.RequestResponseTransportStatus.ACKED)
+                        || msgContext.isPropertyTrue(NhttpConstants.FORCE_SC_ACCEPTED))) {
 
             response.setStatusCode(HttpStatus.SC_ACCEPTED);
             serverHandler.commitResponse(conn, response);
