diff --git a/java/modules/transports/core/nhttp/pom.xml b/java/modules/transports/core/nhttp/pom.xml
index 4aa4ecbb9..28e142098 100644
--- a/java/modules/transports/core/nhttp/pom.xml
+++ b/java/modules/transports/core/nhttp/pom.xml
@@ -158,6 +158,11 @@
             <groupId>commons-lang</groupId>
             <artifactId>commons-lang</artifactId>
         </dependency>
+        
+       <dependency>
+        <groupId>commons-collections</groupId>
+        <artifactId>commons-collections</artifactId>
+      </dependency>
 
         <!-- BouncyCastle API which is required when validating Certificates. -->
         <dependency>
diff --git a/java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/NhttpConstants.java b/java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/NhttpConstants.java
index 1967cd480..f5cc34254 100644
--- a/java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/NhttpConstants.java
+++ b/java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/nhttp/NhttpConstants.java
@@ -166,4 +166,10 @@ public class NhttpConstants {
 
     //property name of nhttp log directory
     public static final String NHTTP_LOG_DIRECTORY = "nhttp.log.directory";
+    
+    /**
+     * This holds a MultiValue Map, which keeps transport headers' values other than last value
+     * (in order they appear) against the transport header.
+     */
+    public static final String EXCESS_TRANSPORT_HEADERS = "EXCESS_TRANSPORT_HEADERS";
 }
diff --git a/java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/ClientWorker.java b/java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/ClientWorker.java
index 7ac4e9e54..d5a19d9d4 100644
--- a/java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/ClientWorker.java
+++ b/java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/ClientWorker.java
@@ -69,6 +69,7 @@ public class ClientWorker implements Runnable {
         this.expectEntityBody = response.isExpectResponseBody();
 
         Map<String,String> headers = response.getHeaders();
+        Map excessHeaders = response.getExcessHeaders();
       
 		String oriURL = headers.get(PassThroughConstants.LOCATION);
 		
@@ -141,6 +142,7 @@ public class ClientWorker implements Runnable {
             headerMap.put(headerEntry.getKey(), headerEntry.getValue());
         }
         responseMsgCtx.setProperty(MessageContext.TRANSPORT_HEADERS, headerMap);
+        responseMsgCtx.setProperty(NhttpConstants.EXCESS_TRANSPORT_HEADERS, excessHeaders);
         if (headerMap.get(HTTP.CONTENT_LEN) != null){
             responseMsgCtx.setProperty(PassThroughConstants.ORIGINAL_CONTENT_LENGTH,
                     headerMap.get(HTTP.CONTENT_LEN));
diff --git a/java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughConstants.java b/java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughConstants.java
index f5c5b9462..b14529dfa 100644
--- a/java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughConstants.java
+++ b/java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/PassThroughConstants.java
@@ -135,4 +135,7 @@ public class PassThroughConstants {
     public static final String COPY_CONTENT_LENGTH_FROM_INCOMING="COPY_CONTENT_LENGTH_FROM_INCOMING";
     
     public static final String ORIGINAL_CONTENT_LENGTH ="ORIGINAL_CONTENT_LENGTH";
+    
+    //Http method type constants to be used in synapse
+    public static final String HTTP_HEAD = "HEAD";
 }
diff --git a/java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/ServerWorker.java b/java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/ServerWorker.java
index 0a22ea575..ca6dac615 100644
--- a/java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/ServerWorker.java
+++ b/java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/ServerWorker.java
@@ -430,6 +430,7 @@ public class ServerWorker implements Runnable {
      * @return the Axis2 message context created
      */
     private MessageContext createMessageContext(SourceRequest request) {
+    	Map excessHeaders = request.getExcessHeaders();
         ConfigurationContext cfgCtx = sourceConfiguration.getConfigurationContext();
         MessageContext msgContext =
                 new MessageContext();
@@ -477,6 +478,8 @@ public class ServerWorker implements Runnable {
             headers.put(entry.getKey(), entry.getValue());
         }
         msgContext.setProperty(MessageContext.TRANSPORT_HEADERS, headers);
+        msgContext.setProperty(NhttpConstants.EXCESS_TRANSPORT_HEADERS, excessHeaders);
+        
         if (headers.get(HTTP.CONTENT_LEN) != null){
             msgContext.setProperty(PassThroughConstants.ORIGINAL_CONTENT_LENGTH,
                     headers.get(HTTP.CONTENT_LEN));
diff --git a/java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SourceRequest.java b/java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SourceRequest.java
index 3a8a12a92..92eb9f441 100644
--- a/java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SourceRequest.java
+++ b/java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SourceRequest.java
@@ -20,6 +20,7 @@
 
 package org.apache.synapse.transport.passthru;
 
+import org.apache.commons.collections.map.MultiValueMap;
 import org.apache.http.*;
 import org.apache.http.message.BasicHttpResponse;
 import org.apache.http.nio.ContentDecoder;
@@ -65,6 +66,10 @@ public class SourceRequest {
 
     /** The connection from the client */
     private NHttpServerConnection connection = null;
+    
+    /** Excess headers of the request */
+    private Map excessHeaders = new MultiValueMap();
+
 
     public SourceRequest(SourceConfiguration sourceConfiguration,
                          HttpRequest request,
@@ -87,9 +92,13 @@ public class SourceRequest {
         Header[] headers = request.getAllHeaders();
         if (headers != null) {
             for (Header header : headers) {
-                this.headers.put(header.getName(), header.getValue());
-            }
-        }
+                if(this.headers.containsKey(header.getName())) {
+	                 addExcessHeader(header);
+	            } else {
+	                 this.headers.put(header.getName(), header.getValue());
+	            }
+	        }
+	    }
     }
 
     /**
@@ -181,4 +190,12 @@ public class SourceRequest {
     public boolean isEntityEnclosing() {
         return entityEnclosing;
     }
+    
+    public Map getExcessHeaders() {
+        return this.excessHeaders;
+   }
+    
+    public void addExcessHeader(Header h) {
+        this.excessHeaders.put(h.getName(), h.getValue());
+   }
 }
diff --git a/java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SourceResponse.java b/java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SourceResponse.java
index d749de370..7a0a03d6d 100644
--- a/java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SourceResponse.java
+++ b/java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/SourceResponse.java
@@ -31,15 +31,17 @@ import org.apache.synapse.transport.passthru.util.PassThroughTransportUtils;
 
 import java.io.IOException;
 import java.util.HashMap;
+import java.util.Iterator;
 import java.util.Map;
 import java.util.Set;
+import java.util.TreeSet;
 
 public class SourceResponse {
 
     private Pipe pipe = null;
 
     /** Transport headers */
-    private Map<String, String> headers = new HashMap<String, String>();
+    private Map<String, TreeSet<String>> headers = new HashMap<String, TreeSet<String>>();
 
     /** Status of the response */
     private int status = HttpStatus.SC_OK;
@@ -58,6 +60,7 @@ public class SourceResponse {
 
     private SourceRequest request = null;
 
+    
     public SourceResponse(SourceConfiguration config, int status, SourceRequest request) {
         this(config, status, null, request);
     }
@@ -99,7 +102,11 @@ public class SourceResponse {
         BasicHttpEntity entity = new BasicHttpEntity();
 
         int contentLength = -1;
-        String contentLengthHeader = headers.get(HTTP.CONTENT_LEN);
+    	String contentLengthHeader = null; 
+        if(headers.get(HTTP.CONTENT_LEN) != null && headers.get(HTTP.CONTENT_LEN).size() > 0) {
+        	contentLengthHeader = headers.get(HTTP.CONTENT_LEN).first();
+        } 
+
         if (contentLengthHeader != null) {
             contentLength = Integer.parseInt(contentLengthHeader);
 
@@ -116,13 +123,17 @@ public class SourceResponse {
         response.setEntity(entity);
 
         // set any transport headers
-        Set<Map.Entry<String, String>> entries = headers.entrySet();
-
-        for (Map.Entry<String, String> entry : entries) {
-            if (entry.getKey() != null) {
-                response.addHeader(entry.getKey(), entry.getValue());
+        Set<Map.Entry<String, TreeSet<String>>> entries = headers.entrySet();
+
+        for (Map.Entry<String, TreeSet<String>> entry : entries) {
+            if (entry.getKey() != null) {     
+            	Iterator<String> i = entry.getValue().iterator();
+                while(i.hasNext()) {
+                	response.addHeader(entry.getKey(), i.next());
+                }   
             }
         }
+        
 
         SourceContext.updateState(conn, ProtocolState.RESPONSE_HEAD);
 
@@ -163,10 +174,18 @@ public class SourceResponse {
     }
 
     public void addHeader(String name, String value) {
-        headers.put(name, value);
+    	if(headers.get(name) == null) {
+    		TreeSet<String> values = new TreeSet<String>(); 
+    		values.add(value);
+    		headers.put(name, values);
+    	} else {
+    		TreeSet<String> values = headers.get(name);
+    		values.add(value);
+    	}
     }
 
     public void setStatus(int status) {
         this.status = status;
-    }        
+    } 
+
 }
diff --git a/java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/TargetRequest.java b/java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/TargetRequest.java
index e2cdc47a8..b62575aa1 100644
--- a/java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/TargetRequest.java
+++ b/java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/TargetRequest.java
@@ -45,8 +45,10 @@ import java.io.IOException;
 import java.io.OutputStream;
 import java.net.URL;
 import java.util.HashMap;
+import java.util.Iterator;
 import java.util.Map;
 import java.util.Set;
+import java.util.TreeSet;
 
 import javax.xml.stream.XMLStreamException;
 
@@ -61,8 +63,8 @@ public class TargetRequest {
     private Pipe pipe = null;
 
     /** Headers map */
-    private Map<String, String> headers = new HashMap<String, String>();
-
+    private Map<String, TreeSet<String>> headers = new HashMap<String, TreeSet<String>>();
+    
     /** URL */
     private URL url;
 
@@ -125,11 +127,17 @@ public class TargetRequest {
                     (url.getQuery() != null ? "?" + url.getQuery() : "");
 
         long contentLength = -1;
-        String contentLengthHeader = headers.get(HTTP.CONTENT_LEN);
+        String contentLengthHeader = null;
+        
+        if(headers.get(HTTP.CONTENT_LEN) != null && headers.get(HTTP.CONTENT_LEN).size() > 0) {
+	        contentLengthHeader = headers.get(HTTP.CONTENT_LEN).first();
+	    }
+         
         if (contentLengthHeader != null) {
             contentLength = Integer.parseInt(contentLengthHeader);
             headers.remove(HTTP.CONTENT_LEN);
         }
+  
         
         MessageContext requestMsgCtx = TargetContext.get(conn).getRequestMsgCtx();
         Long lengthValue = (Long) requestMsgCtx.getProperty(
@@ -152,7 +160,7 @@ public class TargetRequest {
                     !requestMsgCtx.isPropertyTrue(PassThroughConstants.MESSAGE_BUILDER_INVOKED)) {
                     // If the message is multipart/related but it hasn't been built
                     // we can copy the content-type header of the request
-                    headers.put(HTTP.CONTENT_TYPE, trpContentType);
+                	addHeader(HTTP.CONTENT_TYPE, trpContentType);
                 }
             }
         }
@@ -184,10 +192,16 @@ public class TargetRequest {
                     version != null ? version : HttpVersion.HTTP_1_1);
         }
 
-        Set<Map.Entry<String, String>> entries = headers.entrySet();
-        for (Map.Entry<String, String> entry : entries) {
-            request.setHeader(entry.getKey(), entry.getValue());
-        }
+        
+        Set<Map.Entry<String, TreeSet<String>>> entries = headers.entrySet();
+        for (Map.Entry<String, TreeSet<String>> entry : entries) {
+             if (entry.getKey() != null) {
+                Iterator<String> i = entry.getValue().iterator();
+                 while(i.hasNext()) {
+                        request.addHeader(entry.getKey(), i.next());
+                 }
+             }
+         }
         
         //setup wsa action..
         if (request != null){
@@ -235,6 +249,29 @@ public class TargetRequest {
         }
     }
 
+    
+    public void addHeader(String name, String value) {
+		if (headers.get(name) == null) {
+			TreeSet<String> values = new TreeSet<String>();
+			values.add(value);
+			if (HTTP.CONTENT_TYPE.equalsIgnoreCase(name)) {
+				headers.put(HTTP.CONTENT_TYPE, values);
+			} else {
+				headers.put(name, values);
+			}
+		} else {
+			if (HTTP.CONTENT_TYPE.equalsIgnoreCase(name)) {
+				headers.remove(HTTP.CONTENT_TYPE);
+				TreeSet<String> values = new TreeSet<String>();
+				values.add(value);
+				headers.put(HTTP.CONTENT_TYPE, values);
+			} else {
+				TreeSet<String> values = headers.get(name);
+				values.add(value);
+			}
+		}
+	}
+    
 	/**
 	 * Handles the chunking messages in PassThough context, create a temporary buffer and
      * calculate the message size before writing to the external buffer, which is required the
@@ -312,9 +349,6 @@ public class TargetRequest {
         return hasEntityBody;
     }
 
-	public void addHeader(String name, String value) {
-        headers.put(name, value);
-    }
 
     public String getMethod() {
         return method;
diff --git a/java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/TargetResponse.java b/java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/TargetResponse.java
index 0d80944e2..73acf3eeb 100644
--- a/java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/TargetResponse.java
+++ b/java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/TargetResponse.java
@@ -29,6 +29,7 @@ import org.apache.synapse.transport.passthru.util.PassThroughTransportUtils;
 import java.io.IOException;
 import java.util.HashMap;
 import java.util.Map;
+import org.apache.commons.collections.map.MultiValueMap;
 
 /**
  * This class represents a response coming from the target server.
@@ -40,6 +41,9 @@ public class TargetResponse {
 
     /** Headers of the response */
     private Map<String, String> headers = new HashMap<String, String>();
+    
+    /** Excess headers of the response */ 
+    private Map excessHeaders = new MultiValueMap();
 
     /** The status of the response */
     private int status = HttpStatus.SC_OK;
@@ -77,9 +81,13 @@ public class TargetResponse {
         Header[] headers = response.getAllHeaders();
         if (headers != null) {
             for (Header header : headers) {
-                this.headers.put(header.getName(), header.getValue());
-            }
-        }
+            	if(this.headers.containsKey(header.getName())) {
+            		addExcessHeader(header);
+            	} else {
+            		this.headers.put(header.getName(), header.getValue());
+            	}
+             }        
+        }   
 
         this.expectResponseBody = expectResponseBody;
     }    
@@ -140,6 +148,14 @@ public class TargetResponse {
         return headers;
     }
 
+    public Map getExcessHeaders() {
+    	return this.excessHeaders;
+    }
+    
+    public void addExcessHeader(Header h) {
+    	this.excessHeaders.put(h.getName(), h.getValue());
+    }
+
     public Pipe getPipe() {
         return pipe;
     }
diff --git a/java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/PassThroughTransportUtils.java b/java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/PassThroughTransportUtils.java
index a40b63f78..4b0a76a0c 100644
--- a/java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/PassThroughTransportUtils.java
+++ b/java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/PassThroughTransportUtils.java
@@ -33,6 +33,7 @@ import org.apache.http.protocol.HTTP;
 import org.apache.http.HttpStatus;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
+import org.apache.synapse.transport.nhttp.NhttpConstants;
 import org.apache.synapse.transport.passthru.PassThroughConstants;
 import org.apache.synapse.transport.passthru.ProtocolState;
 import org.apache.synapse.transport.passthru.SourceContext;
@@ -117,6 +118,8 @@ public class PassThroughTransportUtils {
                                              boolean preserveServerHeader,
                                              boolean preserveUserAgentHeader) {
         Map headers = (Map) msgContext.getProperty(MessageContext.TRANSPORT_HEADERS);
+        Map excessHeaders = (Map) msgContext.getProperty(NhttpConstants.EXCESS_TRANSPORT_HEADERS);
+
 
         if (headers == null || headers.isEmpty()) {
             return;
@@ -141,6 +144,7 @@ public class PassThroughTransportUtils {
                 iter.remove();
             }
         }
+
     }
 
     /**
diff --git a/java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/SourceResponseFactory.java b/java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/SourceResponseFactory.java
index 4bee55fe1..0738a496c 100644
--- a/java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/SourceResponseFactory.java
+++ b/java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/SourceResponseFactory.java
@@ -26,12 +26,15 @@ import org.apache.http.protocol.HTTP;
 import org.apache.synapse.transport.nhttp.NhttpConstants;
 import org.apache.synapse.transport.nhttp.util.MessageFormatterDecoratorFactory;
 import org.apache.synapse.transport.nhttp.util.NhttpUtil;
+import org.apache.synapse.transport.passthru.Pipe;
 import org.apache.synapse.transport.passthru.SourceRequest;
 import org.apache.synapse.transport.passthru.SourceResponse;
 import org.apache.synapse.transport.passthru.config.SourceConfiguration;
 import org.apache.synapse.transport.passthru.PassThroughConstants;
 
+import java.util.Collection;
 import java.util.HashMap;
+import java.util.Iterator;
 import java.util.Map;
 
 public class SourceResponseFactory {
@@ -54,7 +57,6 @@ public class SourceResponseFactory {
             sourceResponse.addHeader(HTTP.CONTENT_LEN,
                     (String) msgContext.getProperty(PassThroughConstants.ORIGINAL_CONTENT_LENGTH));
         }
-
         if (transportHeaders != null) {
             addResponseHeader(sourceResponse, transportHeaders);
         } else {
@@ -70,8 +72,21 @@ public class SourceResponseFactory {
              }
         	 
         }
-        return sourceResponse;
-    }
+
+		// Add excess response header.
+		String excessProp = NhttpConstants.EXCESS_TRANSPORT_HEADERS;
+		Map excessHeaders = (Map) msgContext.getProperty(excessProp);
+		if (excessHeaders != null) {
+			for (Iterator iterator = excessHeaders.keySet().iterator(); iterator.hasNext();) {
+				String key = (String) iterator.next();
+				for (String excessVal : (Collection<String>) excessHeaders.get(key)) {
+					sourceResponse.addHeader(key, (String) excessVal);
+				}
+			}
+		}
+		
+		return sourceResponse;
+	}
 
 	private static void addResponseHeader(SourceResponse sourceResponse, Map transportHeaders) {
 	    for (Object entryObj : transportHeaders.entrySet()) {
diff --git a/java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/TargetRequestFactory.java b/java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/TargetRequestFactory.java
index d27ce80ab..2fa598441 100644
--- a/java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/TargetRequestFactory.java
+++ b/java/modules/transports/core/nhttp/src/main/java/org/apache/synapse/transport/passthru/util/TargetRequestFactory.java
@@ -39,6 +39,8 @@ import org.apache.synapse.transport.passthru.config.TargetConfiguration;
 
 import java.net.MalformedURLException;
 import java.net.URL;
+import java.util.Collection;
+import java.util.Iterator;
 import java.util.Map;
 
 public class TargetRequestFactory {
@@ -126,6 +128,18 @@ public class TargetRequestFactory {
             if ("true".equals(fullUrl)) {
                 request.setFullUrl(true);                
             }
+            
+            // Add excess respsonse header.
+            String excessProp = NhttpConstants.EXCESS_TRANSPORT_HEADERS;
+            Map excessHeaders = (Map) msgContext.getProperty(excessProp);
+            if (excessHeaders != null) {
+                    for (Iterator iterator = excessHeaders.keySet().iterator(); iterator.hasNext();) {
+                            String key = (String) iterator.next();
+                            for (String excessVal : (Collection<String>) excessHeaders.get(key)) {
+                                    request.addHeader(key, (String) excessVal);
+                            }
+                    }
+            }
 
             return request;
         } catch (MalformedURLException e) {
