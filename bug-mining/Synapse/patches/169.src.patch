diff --git a/java/modules/core/src/main/java/org/apache/synapse/FaultHandler.java b/java/modules/core/src/main/java/org/apache/synapse/FaultHandler.java
index 8ac9e7411..d1dae1795 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/FaultHandler.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/FaultHandler.java
@@ -71,26 +71,33 @@ public abstract class FaultHandler {
         boolean traceOn = synCtx.getTracingState() == SynapseConstants.TRACING_ON;
         boolean traceOrDebugOn = traceOn || log.isDebugEnabled();
 
-        synCtx.setProperty(SynapseConstants.ERROR_CODE, "00000");
-        // use only the first line as the message for multiline exception messages (Axis2 has these)
-        synCtx.setProperty(SynapseConstants.ERROR_MESSAGE, e.getMessage().split("\n")[0]);
-
-        synCtx.setProperty(SynapseConstants.ERROR_DETAIL, getStackTrace(e));
-        synCtx.setProperty(SynapseConstants.ERROR_EXCEPTION, e);
+        if (e != null && synCtx.getProperty(SynapseConstants.ERROR_CODE) == null) {
+            synCtx.setProperty(SynapseConstants.ERROR_CODE, SynapseConstants.DEFAULT_ERROR);
+            // use only the first line as the message for multiline exception messages (Axis2 has these)
+            synCtx.setProperty(SynapseConstants.ERROR_MESSAGE, e.getMessage().split("\n")[0]);
+            synCtx.setProperty(SynapseConstants.ERROR_DETAIL, getStackTrace(e));
+            synCtx.setProperty(SynapseConstants.ERROR_EXCEPTION, e);
+        }
 
         if (traceOrDebugOn) {
-            traceOrDebugWarn(traceOn, "Fault handler - setting ERROR_MESSAGE : " +
+            traceOrDebugWarn(traceOn, "ERROR_CODE : " +
+                synCtx.getProperty(SynapseConstants.ERROR_CODE));
+            traceOrDebugWarn(traceOn, "ERROR_MESSAGE : " +
                 synCtx.getProperty(SynapseConstants.ERROR_MESSAGE));
-            traceOrDebugWarn(traceOn, "Fault handler - setting ERROR_DETAIL : " +
+            traceOrDebugWarn(traceOn, "ERROR_DETAIL : " +
                 synCtx.getProperty(SynapseConstants.ERROR_DETAIL));
-            traceOrDebugWarn(traceOn, "Fault handler - setting ERROR_EXCEPTION : " +
+            traceOrDebugWarn(traceOn, "ERROR_EXCEPTION : " +
                 synCtx.getProperty(SynapseConstants.ERROR_EXCEPTION));
         }
 
-        synCtx.getServiceLog().warn("Fault handler - setting ERROR_MESSAGE : " +
+        synCtx.getServiceLog().warn("ERROR_CODE : " +
+            synCtx.getProperty(SynapseConstants.ERROR_CODE) + " ERROR_MESSAGE : " + 
             synCtx.getProperty(SynapseConstants.ERROR_MESSAGE));
 
         try {
+            if (traceOrDebugOn) {
+                traceOrDebugWarn(traceOn, "FaultHandler : " + this);
+            }
             onFault(synCtx);
 
         } catch (SynapseException se) {
diff --git a/java/modules/core/src/main/java/org/apache/synapse/ServerManager.java b/java/modules/core/src/main/java/org/apache/synapse/ServerManager.java
index 6f89a1d85..e6da4f02f 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/ServerManager.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/ServerManager.java
@@ -34,6 +34,9 @@ import org.apache.synapse.config.SynapseConfiguration;
 import org.apache.synapse.core.SynapseEnvironment;
 import org.apache.synapse.util.ClasspathURLStreamHandler;
 import org.apache.synapse.util.RMIRegistryController;
+import org.apache.synapse.util.datasource.InMemoryDataSourceRegistry;
+import org.apache.synapse.util.datasource.JNDIBasedDataSourceRegistry;
+import org.apache.synapse.endpoints.dispatch.SALSessions;
 
 import java.io.File;
 import java.net.*;
@@ -159,10 +162,12 @@ public class ServerManager {
                 }
             }
 
+            synConfig.init(configctx);
+
             log.info("Ready for processing");
 
         } catch (Throwable t) {
-            log.fatal("Synaps startup failed...", t);
+            log.fatal("Synapse startup failed...", t);
             throw new SynapseException("Synapse startup failed", t);
         }
     }
@@ -180,8 +185,7 @@ public class ServerManager {
      * stop all the listeners
      */
     public void stop() {
-        try {
-            RMIRegistryController.getInstance().removeLocalRegistry();
+        try {                 
 
             // stop all services
             if (configctx != null && configctx.getAxisConfiguration() != null) {
@@ -204,6 +208,17 @@ public class ServerManager {
                 listenerManager.stop();
                 listenerManager.destroy();
             }
+
+            // clear session information used for SA load balancing
+            try {
+                RMIRegistryController.getInstance().removeLocalRegistry();
+                SALSessions.getInstance().reset();
+                InMemoryDataSourceRegistry.getInstance().clear();
+                JNDIBasedDataSourceRegistry registry = JNDIBasedDataSourceRegistry.getInstance();
+                if (registry.isInitialized()) {
+                    registry.clear();
+                }
+            } catch (Throwable ignored) {}
             
             // we need to call this method to clean the temp files we created.
             if (configctx != null) {
diff --git a/java/modules/core/src/main/java/org/apache/synapse/SynapseConstants.java b/java/modules/core/src/main/java/org/apache/synapse/SynapseConstants.java
index 1a4776739..d92980fbd 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/SynapseConstants.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/SynapseConstants.java
@@ -128,6 +128,8 @@ public final class SynapseConstants {
         public static final String OUT_ONLY = "OUT_ONLY";
 
         //-- error handling --
+        /** An Axis2 message context property indicating a transport send failure */
+        public static final String SENDING_FAULT = "SENDING_FAULT";
         /** The message context property name which holds the error code for the last encountered exception */
         public static final String ERROR_CODE = "ERROR_CODE";
         /** The MC property name which holds the error message for the last encountered exception */
@@ -136,6 +138,8 @@ public final class SynapseConstants {
         public static final String ERROR_DETAIL = "ERROR_DETAIL";
         /** The message context property name which holds the exception (if any) for the last encountered exception */
         public static final String ERROR_EXCEPTION = "ERROR_EXCEPTION";
+        /** The default/generic error code */
+        public static final int DEFAULT_ERROR= 0;
 
         /** Mercury last message property name */
         public static final String MERCURY_LAST_MESSAGE = "MercuryLastMessage";
@@ -144,6 +148,9 @@ public final class SynapseConstants {
         /** Mercury WS-RM specification version property name */
         public static final String MERCURY_SPEC_VERSION = "MercuryRMSpecVersion";
 
+    /** An Axis2 message context property that indicates the maximum time to spend on sending the message */
+    public static final String SEND_TIMEOUT = "SEND_TIMEOUT";
+
     //- Axis2 Message Context Properties used by Synapse -
     /** an axis2 message context property set to hold the relates to for POX responses */
     public static final String RELATES_TO_FOR_POX = "synapse.RelatesToForPox";
@@ -183,6 +190,11 @@ public final class SynapseConstants {
          */
         public static final long DEFAULT_TIMEOUT_HANDLER_INTERVAL = 15000;
 
+        /**
+         * The default endpoint suspend duration on failure (i hour)
+         */
+        public static final long DEFAULT_ENDPOINT_SUSPEND_TIME = 60 * 60 * 1000;
+
         /**
          * This is a system wide interval for handling otherwise non-expiring callbacks to
          * ensure system stability over a period of time 
@@ -213,19 +225,41 @@ public final class SynapseConstants {
         /**
          * Error codes for message sending. We go with closest HTTP fault codes.
          */
-        public static final String TIME_OUT = "504";
-        public static final String SENDING_FAULT = "503";
+        public static final int HANDLER_TIME_OUT = 504;
 
     //- Endpoints processing constants -
     /** Property name to store the last endpoint through which the message has flowed */
-    public static final String PROCESSED_ENDPOINT = "processed_endpoint";
+    public static final String LAST_ENDPOINT = "last_endpoint";
     
     /** A name to use for anonymous endpoints */
     public static final String ANONYMOUS_ENDPOINT = "AnonymousEndpoint";
 
+    /* Constants related to the SAL endpoints */
+
+    public static final String PROP_SAL_ENDPOINT_FIRST_MESSAGE_IN_SESSION
+            = "synapse.sal.first_message_in_session";
+
+    public static final String PROP_SAL_ENDPOINT_ENDPOINT_LIST
+            = "synapse.sal.endpoint.list";
+    
+    public static final String PROP_SAL_CURRENT_SESSION_INFORMATION
+            = "synapse.sal.endpoint.current.sessioninformation";
+
+    public static final String PROP_SAL_ENDPOINT_CURRENT_ENDPOINT_LIST
+            = "synapse.sal.current.endpoint.list";
+
+    public static final String PROP_SAL_ENDPOINT_CURRENT_DISPATCHER
+            = "synape.sal.endpoints.dispatcher";   
+
+    public static final String PROP_SAL_ENDPOINT_DEFAULT_SESSION_TIMEOUT
+            = "synapse.sal.endpoints.sesssion.timeout.default";    
+
+    public static final long SAL_ENDPOINTS_DEFAULT_SESSION_TIMEOUT = 120000;
+    
+
     /** A name to use for anonymous sequences in the sequence stack */
     public static final String ANONYMOUS_SEQUENCE = "AnonymousSequence";
-    
+
     /** Message format values in EndpointDefinition. Used by address, wsdl endpoints */
     public static final String FORMAT_POX = "pox";
     public static final String FORMAT_GET = "get";
@@ -267,4 +301,30 @@ public final class SynapseConstants {
     
     public static final String TEMP_FILE_SUFIX = "synapse.tempfile.sufix";
 
+    // Known transport error codes
+    public static final int RCV_IO_ERROR_SENDING     = 101000;
+    public static final int RCV_IO_ERROR_RECEIVING   = 101001;
+
+    public static final int SND_IO_ERROR_SENDING     = 101500;
+    public static final int SND_IO_ERROR_RECEIVING   = 101501;
+
+    public static final int NHTTP_CONNECTION_FAILED  = 101503;
+    public static final int NHTTP_CONNECTION_TIMEOUT = 101504;
+    public static final int NHTTP_CONNECTION_CLOSED  = 101505;
+    public static final int NHTTP_PROTOCOL_VIOLATION = 101506;
+    public static final int NHTTP_CONNECT_CANCEL     = 101507;
+    public static final int NHTTP_CONNECT_TIMEOUT    = 101508;
+
+    // Endpoint failures
+    public static final int ENDPOINT_LB_NONE_READY   = 303000;
+    public static final int ENDPOINT_FO_NONE_READY   = 303000;
+    // Failure on endpoint in the session 
+    public static final int ENDPOINT_SAL_NOT_READY = 309001;
+    public static final int ENDPOINT_SAL_INVALID_PATH = 309002;
+    public static final int ENDPOINT_SAL_FAILED_SESSION = 309003;
+
+    // endpoints, non fatal warnings etc
+    public static final int ENDPOINT_LB_FAIL_OVER    = 303100;
+    public static final int ENDPOINT_FO_FAIL_OVER    = 304100;
+
 }
diff --git a/java/modules/core/src/main/java/org/apache/synapse/config/SynapseConfiguration.java b/java/modules/core/src/main/java/org/apache/synapse/config/SynapseConfiguration.java
index 2642c213e..dc9b38c98 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/config/SynapseConfiguration.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/config/SynapseConfiguration.java
@@ -20,16 +20,27 @@
 package org.apache.synapse.config;
 
 import org.apache.axis2.AxisFault;
+import org.apache.axis2.context.ConfigurationContext;
 import org.apache.axis2.engine.AxisConfiguration;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 import org.apache.synapse.*;
 import org.apache.synapse.config.xml.MediatorFactoryFinder;
+import org.apache.synapse.config.xml.SwitchCase;
 import org.apache.synapse.config.xml.endpoints.XMLToEndpointMapper;
 import org.apache.synapse.core.SynapseEnvironment;
 import org.apache.synapse.core.axis2.ProxyService;
 import org.apache.synapse.endpoints.Endpoint;
 import org.apache.synapse.mediators.base.SequenceMediator;
+import org.apache.synapse.mediators.ListMediator;
+import org.apache.synapse.mediators.AbstractMediator;
+import org.apache.synapse.mediators.eip.splitter.CloneMediator;
+import org.apache.synapse.mediators.eip.splitter.IterateMediator;
+import org.apache.synapse.mediators.eip.Target;
+import org.apache.synapse.mediators.eip.aggregator.AggregateMediator;
+import org.apache.synapse.mediators.filters.SwitchMediator;
+import org.apache.synapse.mediators.builtin.SendMediator;
+import org.apache.synapse.mediators.builtin.CacheMediator;
 import org.apache.synapse.registry.Registry;
 
 import javax.xml.namespace.QName;
@@ -807,7 +818,7 @@ public class SynapseConfiguration implements ManagedLifecycle {
     public void init(SynapseEnvironment se) {
         
         if (log.isDebugEnabled()) {
-            log.debug("Initializing the Synapse Configuration");
+            log.debug("Initializing the Synapse Configuration using the SynapseEnvironment");
         }
 
         // initialize registry
@@ -839,6 +850,53 @@ public class SynapseConfiguration implements ManagedLifecycle {
         }
     }
 
+    public void init(ConfigurationContext cc) {
+
+        if (log.isDebugEnabled()) {
+            log.debug("Initializing the Synapse Configuration using the ConfigurationContext");
+        }
+
+        // Initialize endpoints
+        for (Endpoint e : getDefinedEndpoints().values()) {
+            initEndpoint(e, cc);
+        }
+
+        for (SequenceMediator s : getDefinedSequences().values()) {
+            initEndpointsOfChildren(s, cc);
+        }
+
+        for (ProxyService p : getProxyServices()) {
+            if (p.getTargetInLineEndpoint() != null) {
+                initEndpoint(p.getTargetInLineEndpoint(), cc);
+            }
+
+            if (p.getTargetInLineInSequence() != null) {
+                initEndpointsOfChildren(p.getTargetInLineInSequence(), cc);
+            }
+
+            if (p.getTargetInLineOutSequence() != null) {
+                initEndpointsOfChildren(p.getTargetInLineOutSequence(), cc);
+            }
+
+            if (p.getTargetInLineFaultSequence() != null) {
+                initEndpointsOfChildren(p.getTargetInLineFaultSequence(), cc);
+            }
+        }
+    }
+
+    private void initEndpointsOfChildren(ListMediator s, ConfigurationContext cc) {
+        for (Mediator m : s.getList()) {
+            if (m instanceof AbstractMediator) {
+                ((AbstractMediator)m).init(cc);
+            } 
+        }
+    }
+    
+    private void initEndpoint(Endpoint e, ConfigurationContext cc) {
+        e.init(cc);
+    }
+
+
     private void handleException(String msg) {
 		log.error(msg);
 		throw new SynapseException(msg);
diff --git a/java/modules/core/src/main/java/org/apache/synapse/config/xml/XMLConfigConstants.java b/java/modules/core/src/main/java/org/apache/synapse/config/xml/XMLConfigConstants.java
index 7dfa739f3..16aa2a18e 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/config/xml/XMLConfigConstants.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/config/xml/XMLConfigConstants.java
@@ -75,10 +75,21 @@ public class XMLConfigConstants {
 	/** The statistics value 'disable' */
 	public static final String STATISTICS_DISABLE = "disable";
 
-	public static final String SUSPEND_DURATION_ON_FAILURE = "suspendDurationOnFailure";
+    public static final String SUSPEND_ON_FAILURE = "suspendOnFailure";
+    public static final String SUSPEND_INITIAL_DURATION = "initialDuration";
+    public static final String SUSPEND_PROGRESSION_FACTOR = "progressionFactor";
+    public static final String SUSPEND_MAXIMUM_DURATION = "maximumDuration";
+    public static final String ERROR_CODES = "errorCodes";
+    public static final String MARK_FOR_SUSPENSION = "markForSuspension";
+    public static final String RETRIES_BEFORE_SUSPENSION = "retriesBeforeSuspension";
+    public static final String RETRY_DELAY = "retryDelay";
+
 	public static final String LOADBALANCE_POLICY = "policy";
 	public static final String LOADBALANCE_ALGORITHM = "algorithm";
 
+    //TODO FIX-RUWAN
+    public static final String ALGORITHM_NAME = "policy";
+
     public static final String ONREJECT = "onReject";
 	public static final String ONACCEPT = "onAccept";
 
diff --git a/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/AddressEndpointFactory.java b/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/AddressEndpointFactory.java
index 081642018..d0a7b5556 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/AddressEndpointFactory.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/AddressEndpointFactory.java
@@ -25,7 +25,7 @@ import org.apache.synapse.SynapseConstants;
 import org.apache.synapse.config.xml.XMLConfigConstants;
 import org.apache.synapse.endpoints.AddressEndpoint;
 import org.apache.synapse.endpoints.Endpoint;
-import org.apache.synapse.endpoints.utils.EndpointDefinition;
+import org.apache.synapse.endpoints.EndpointDefinition;
 
 import javax.xml.namespace.QName;
 
@@ -83,7 +83,7 @@ public class AddressEndpointFactory extends DefaultEndpointFactory {
                 new QName(SynapseConstants.SYNAPSE_NAMESPACE, "address"));
         if (addressElement != null) {
             EndpointDefinition endpoint = createEndpointDefinition(addressElement);
-            addressEndpoint.setEndpoint(endpoint);
+            addressEndpoint.setDefinition(endpoint);
         }
         processAuditStatus(addressEndpoint, epConfig);
         return addressEndpoint;
diff --git a/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/AddressEndpointSerializer.java b/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/AddressEndpointSerializer.java
index 8abcc2096..06fd5d590 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/AddressEndpointSerializer.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/AddressEndpointSerializer.java
@@ -25,7 +25,7 @@ import org.apache.synapse.SynapseConstants;
 import org.apache.synapse.SynapseException;
 import org.apache.synapse.endpoints.AddressEndpoint;
 import org.apache.synapse.endpoints.Endpoint;
-import org.apache.synapse.endpoints.utils.EndpointDefinition;
+import org.apache.synapse.endpoints.EndpointDefinition;
 
 /**
  * Serializes {@link AddressEndpoint} to XML.
@@ -51,7 +51,7 @@ public class AddressEndpointSerializer extends DefaultEndpointSerializer {
             endpointElement.addAttribute("name", name, null);
         }
 
-        EndpointDefinition epAddress = addressEndpoint.getEndpoint();
+        EndpointDefinition epAddress = addressEndpoint.getDefinition();
         OMElement addressElement = serializeEndpointDefinition(epAddress);
         endpointElement.addChild(addressElement);
 
diff --git a/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/DefaultEndpointFactory.java b/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/DefaultEndpointFactory.java
index 33a2e4d36..c6b88d631 100755
--- a/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/DefaultEndpointFactory.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/DefaultEndpointFactory.java
@@ -26,7 +26,7 @@ import org.apache.synapse.audit.AuditConfigurable;
 import org.apache.synapse.config.xml.XMLConfigConstants;
 import org.apache.synapse.endpoints.DefaultEndpoint;
 import org.apache.synapse.endpoints.Endpoint;
-import org.apache.synapse.endpoints.utils.EndpointDefinition;
+import org.apache.synapse.endpoints.EndpointDefinition;
 
 import javax.xml.namespace.QName;
 
@@ -82,7 +82,7 @@ public class DefaultEndpointFactory extends EndpointFactory {
                 new QName(SynapseConstants.SYNAPSE_NAMESPACE, "default"));
         if (defaultElement != null) {
             EndpointDefinition endpoint = createEndpointDefinition(defaultElement);
-            defaultEndpoint.setEndpoint(endpoint);
+            defaultEndpoint.setDefinition(endpoint);
         }
         processAuditStatus(defaultEndpoint, defaultElement);
         return defaultEndpoint;
diff --git a/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/DefaultEndpointSerializer.java b/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/DefaultEndpointSerializer.java
index 67739ddcf..804e783b2 100755
--- a/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/DefaultEndpointSerializer.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/DefaultEndpointSerializer.java
@@ -25,7 +25,7 @@ import org.apache.synapse.SynapseConstants;
 import org.apache.synapse.SynapseException;
 import org.apache.synapse.endpoints.DefaultEndpoint;
 import org.apache.synapse.endpoints.Endpoint;
-import org.apache.synapse.endpoints.utils.EndpointDefinition;
+import org.apache.synapse.endpoints.EndpointDefinition;
 
 /**
  * Serializes {@link DefaultEndpoint} to XML.
@@ -50,7 +50,7 @@ public class DefaultEndpointSerializer extends EndpointSerializer {
             endpointElement.addAttribute("name", name, null);
         }
 
-        EndpointDefinition epAddress = defaultEndpoint.getEndpoint();
+        EndpointDefinition epAddress = defaultEndpoint.getDefinition();
         OMElement defaultElement = serializeEndpointDefinition(epAddress);
         endpointElement.addChild(defaultElement);
 
diff --git a/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/DynamicLoadbalanceEndpointFactory.java b/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/DynamicLoadbalanceEndpointFactory.java
index ccbeaf7e7..0fd86b9fe 100755
--- a/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/DynamicLoadbalanceEndpointFactory.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/DynamicLoadbalanceEndpointFactory.java
@@ -49,85 +49,85 @@ import java.util.Properties;
  * &lt;/endpoint&gt;
  * </pre>
  */
-public class DynamicLoadbalanceEndpointFactory extends EndpointFactory {
-
-    private static final Log log = LogFactory.getLog(DynamicLoadbalanceEndpointFactory.class);
-    private static DynamicLoadbalanceEndpointFactory instance =
-            new DynamicLoadbalanceEndpointFactory();
-
-    private DynamicLoadbalanceEndpointFactory() {
-    }
-
-    public static DynamicLoadbalanceEndpointFactory getInstance() {
-        return instance;
-    }
-
-    protected Endpoint createEndpoint(OMElement epConfig, boolean anonymousEndpoint) {
-
-        OMElement loadbalanceElement =
-                epConfig.getFirstChildWithName(new QName(SynapseConstants.SYNAPSE_NAMESPACE,
-                                                         "dynamicLoadbalance"));
-
-        if (loadbalanceElement != null) {
-
-            DynamicLoadbalanceEndpoint loadbalanceEndpoint = new DynamicLoadbalanceEndpoint();
-
-            // set endpoint name
-            OMAttribute name =
-                    epConfig.getAttribute(new QName(XMLConfigConstants.NULL_NAMESPACE, "name"));
-
-            if (name != null) {
-                loadbalanceEndpoint.setName(name.getAttributeValue());
-            }
-
-            //TODO: Handle session affinity
-
-            // set if failover is turned off
-            String failover = loadbalanceElement.getAttributeValue(new QName("failover"));
-            if (failover != null && failover.equalsIgnoreCase("false")) {
-                loadbalanceEndpoint.setFailover(false);
-            }
-
-            OMElement eventHandler =
-                    loadbalanceElement.
-                            getFirstChildWithName(new QName(SynapseConstants.SYNAPSE_NAMESPACE,
-                                                            "membershipHandler"));
-            if (eventHandler != null) {
-                String clazz =
-                        eventHandler.getAttributeValue(new QName(XMLConfigConstants.NULL_NAMESPACE,
-                                                                 "class")).trim();
-                try {
-                    LoadBalanceMembershipHandler lbMembershipHandler =
-                            (LoadBalanceMembershipHandler) Class.forName(clazz).newInstance();
-                    Properties properties = new Properties();
-                    for (Iterator props = eventHandler.getChildrenWithName(new QName(
-                            SynapseConstants.SYNAPSE_NAMESPACE, "property")); props.hasNext();) {
-                        OMElement prop = (OMElement) props.next();
-                        String propName =
-                                prop.getAttributeValue(new QName(XMLConfigConstants.NULL_NAMESPACE,
-                                                                 "name")).trim();
-                        String propValue =
-                                prop.getAttributeValue(new QName(XMLConfigConstants.NULL_NAMESPACE,
-                                                                 "value")).trim();
-                        properties.put(propName, propValue);
-                    }
-
-                    // Set load balance algorithm
-                    LoadbalanceAlgorithm algorithm =
-                            LoadbalanceAlgorithmFactory.
-                                    createLoadbalanceAlgorithm(loadbalanceElement);
-                    lbMembershipHandler.init(properties, algorithm);
-                    loadbalanceEndpoint.setLoadBalanceMembershipHandler(lbMembershipHandler);
-                } catch (Exception e) {
-                    String msg = "Could not instantiate " +
-                            "LoadBalanceMembershipHandler implementation " + clazz;
-                    log.error(msg, e);
-                    throw new SynapseException(msg, e);
-                }
-            }
-
-            return loadbalanceEndpoint;
-        }
-        return null;
-    }
-}
+//public class DynamicLoadbalanceEndpointFactory extends EndpointFactory {
+//    TODO FIX-RUWAN
+//    private static final Log log = LogFactory.getLog(DynamicLoadbalanceEndpointFactory.class);
+//    private static DynamicLoadbalanceEndpointFactory instance =
+//            new DynamicLoadbalanceEndpointFactory();
+//
+//    private DynamicLoadbalanceEndpointFactory() {
+//    }
+//
+//    public static DynamicLoadbalanceEndpointFactory getInstance() {
+//        return instance;
+//    }
+//
+//    protected Endpoint createEndpoint(OMElement epConfig, boolean anonymousEndpoint) {
+//
+//        OMElement loadbalanceElement =
+//                epConfig.getFirstChildWithName(new QName(SynapseConstants.SYNAPSE_NAMESPACE,
+//                                                         "dynamicLoadbalance"));
+//
+//        if (loadbalanceElement != null) {
+//
+//            DynamicLoadbalanceEndpoint loadbalanceEndpoint = new DynamicLoadbalanceEndpoint();
+//
+//            // set endpoint name
+//            OMAttribute name =
+//                    epConfig.getAttribute(new QName(XMLConfigConstants.NULL_NAMESPACE, "name"));
+//
+//            if (name != null) {
+//                loadbalanceEndpoint.setName(name.getAttributeValue());
+//            }
+//
+//            //TODO: Handle session affinity
+//
+//            // set if failover is turned off
+//            String failover = loadbalanceElement.getAttributeValue(new QName("failover"));
+//            if (failover != null && failover.equalsIgnoreCase("false")) {
+//                loadbalanceEndpoint.setFailover(false);
+//            }
+//
+//            OMElement eventHandler =
+//                    loadbalanceElement.
+//                            getFirstChildWithName(new QName(SynapseConstants.SYNAPSE_NAMESPACE,
+//                                                            "membershipHandler"));
+//            if (eventHandler != null) {
+//                String clazz =
+//                        eventHandler.getAttributeValue(new QName(XMLConfigConstants.NULL_NAMESPACE,
+//                                                                 "class")).trim();
+//                try {
+//                    LoadBalanceMembershipHandler lbMembershipHandler =
+//                            (LoadBalanceMembershipHandler) Class.forName(clazz).newInstance();
+//                    Properties properties = new Properties();
+//                    for (Iterator props = eventHandler.getChildrenWithName(new QName(
+//                            SynapseConstants.SYNAPSE_NAMESPACE, "property")); props.hasNext();) {
+//                        OMElement prop = (OMElement) props.next();
+//                        String propName =
+//                                prop.getAttributeValue(new QName(XMLConfigConstants.NULL_NAMESPACE,
+//                                                                 "name")).trim();
+//                        String propValue =
+//                                prop.getAttributeValue(new QName(XMLConfigConstants.NULL_NAMESPACE,
+//                                                                 "value")).trim();
+//                        properties.put(propName, propValue);
+//                    }
+//
+//                    // Set load balance algorithm
+//                    LoadbalanceAlgorithm algorithm =
+//                            LoadbalanceAlgorithmFactory.
+//                                    createLoadbalanceAlgorithm(loadbalanceElement);
+//                    lbMembershipHandler.init(properties, algorithm);
+//                    loadbalanceEndpoint.setLoadBalanceMembershipHandler(lbMembershipHandler);
+//                } catch (Exception e) {
+//                    String msg = "Could not instantiate " +
+//                            "LoadBalanceMembershipHandler implementation " + clazz;
+//                    log.error(msg, e);
+//                    throw new SynapseException(msg, e);
+//                }
+//            }
+//
+//            return loadbalanceEndpoint;
+//        }
+//        return null;
+//    }
+//}
diff --git a/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/EndpointFactory.java b/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/EndpointFactory.java
index d3e0f2068..41e646263 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/EndpointFactory.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/EndpointFactory.java
@@ -30,11 +30,12 @@ import org.apache.synapse.config.XMLToObjectMapper;
 import org.apache.synapse.config.xml.XMLConfigConstants;
 import org.apache.synapse.endpoints.Endpoint;
 import org.apache.synapse.endpoints.IndirectEndpoint;
-import org.apache.synapse.endpoints.utils.EndpointDefinition;
+import org.apache.synapse.endpoints.EndpointDefinition;
 
 import javax.xml.namespace.QName;
 import java.util.ArrayList;
 import java.util.Iterator;
+import java.util.StringTokenizer;
 
 /**
  * All endpoint factories should extend from this abstract class. Use EndpointFactory to obtain the
@@ -208,8 +209,8 @@ public abstract class EndpointFactory implements XMLToObjectMapper {
                 String d = duration.getText();
                 if (d != null) {
                     try {
-                        long timeoutSeconds = Long.parseLong(d.trim());
-                        definition.setTimeoutDuration(timeoutSeconds * 1000);
+                        long timeoutMilliSeconds = Long.parseLong(d.trim());
+                        definition.setTimeoutDuration(timeoutMilliSeconds);
                     } catch (NumberFormatException e) {
                         handleException("Endpoint timeout duration expected as a " +
                                 "number but was not a number");
@@ -244,17 +245,131 @@ public abstract class EndpointFactory implements XMLToObjectMapper {
             }
         }
 
-        // set the suspend on fail duration.
-        OMElement suspendElement = elem.getFirstChildWithName(new QName(
+        OMElement markAsTimedout = elem.getFirstChildWithName(new QName(
+            SynapseConstants.SYNAPSE_NAMESPACE,
+            XMLConfigConstants.MARK_FOR_SUSPENSION));
+
+        if (markAsTimedout != null) {
+
+            OMElement timeoutCodes = markAsTimedout.getFirstChildWithName(new QName(
                 SynapseConstants.SYNAPSE_NAMESPACE,
-                XMLConfigConstants.SUSPEND_DURATION_ON_FAILURE));
-        if (suspendElement != null && suspendElement.getText() != null) {
+                XMLConfigConstants.ERROR_CODES));
+            if (timeoutCodes != null && timeoutCodes.getText() != null) {
+                StringTokenizer st = new StringTokenizer(timeoutCodes.getText().trim(), ", ");
+                while (st.hasMoreTokens()) {
+                    String s = st.nextToken();
+                    try {
+                        definition.addTimeoutErrorCode(Integer.parseInt(s));
+                    } catch (NumberFormatException e) {
+                        handleException("The timeout error codes should be specified " +
+                            "as valid numbers separated by commas : " + timeoutCodes.getText(), e);
+                    }
+                }
+            }
+
+            OMElement retriesBeforeSuspend = markAsTimedout.getFirstChildWithName(new QName(
+                SynapseConstants.SYNAPSE_NAMESPACE,
+                XMLConfigConstants.RETRIES_BEFORE_SUSPENSION));
+            if (retriesBeforeSuspend != null && retriesBeforeSuspend.getText() != null) {
+                try {
+                    definition.setRetriesOnTimeoutBeforeSuspend(
+                        Integer.parseInt(retriesBeforeSuspend.getText().trim()));
+                } catch (NumberFormatException e) {
+                    handleException("The retries before suspend [for timeouts] should be " +
+                        "specified as a valid number : " + retriesBeforeSuspend.getText(), e);
+                }
+            }
+
+            OMElement retryDelay = markAsTimedout.getFirstChildWithName(new QName(
+                SynapseConstants.SYNAPSE_NAMESPACE,
+                XMLConfigConstants.RETRY_DELAY));
+            if (retryDelay != null && retryDelay.getText() != null) {
+                try {
+                    definition.setRetryDurationOnTimeout(
+                        Integer.parseInt(retryDelay.getText().trim()));
+                } catch (NumberFormatException e) {
+                    handleException("The retry delay for timeouts should be specified " +
+                        "as a valid number : " + retryDelay.getText(), e);
+                }
+            }
+        }
+
+        // support backwards compatibility with Synapse 1.2 - for suspendDurationOnFailure
+        OMElement suspendDurationOnFailure = elem.getFirstChildWithName(new QName(
+            SynapseConstants.SYNAPSE_NAMESPACE, "suspendDurationOnFailure"));
+        if (suspendDurationOnFailure != null && suspendDurationOnFailure.getText() != null) {
+
+            log.warn("Configuration uses deprecated style for endpoint 'suspendDurationOnFailure'");
             try {
-                long suspendDuration = Long.parseLong(suspendElement.getText().trim());
-                definition.setSuspendOnFailDuration(suspendDuration * 1000);
+                definition.setInitialSuspendDuration(
+                    1000 * Integer.parseInt(suspendDurationOnFailure.getText().trim()));
+                definition.setSuspendProgressionFactor((float) 1.0);
             } catch (NumberFormatException e) {
-                handleException("The suspend duration should be specified as a valid number :: "
-                        + e.getMessage(), e);
+                handleException("The initial suspend duration should be specified " +
+                    "as a valid number : " + suspendDurationOnFailure.getText(), e);
+            }
+        }
+
+        OMElement suspendOnFailure = elem.getFirstChildWithName(new QName(
+            SynapseConstants.SYNAPSE_NAMESPACE,
+            XMLConfigConstants.SUSPEND_ON_FAILURE));
+
+        if (suspendOnFailure != null) {
+
+            OMElement suspendCodes = suspendOnFailure.getFirstChildWithName(new QName(
+                SynapseConstants.SYNAPSE_NAMESPACE,
+                XMLConfigConstants.ERROR_CODES));
+            if (suspendCodes != null && suspendCodes.getText() != null) {
+
+                StringTokenizer st = new StringTokenizer(suspendCodes.getText().trim(), ", ");
+                while (st.hasMoreTokens()) {
+                    String s = st.nextToken();
+                    try {
+                        definition.addSuspendErrorCode(Integer.parseInt(s));
+                    } catch (NumberFormatException e) {
+                        handleException("The suspend error codes should be specified " +
+                            "as valid numbers separated by commas : " + suspendCodes.getText(), e);
+                    }
+                }
+            }
+
+            OMElement initialDuration = suspendOnFailure.getFirstChildWithName(new QName(
+                SynapseConstants.SYNAPSE_NAMESPACE,
+                XMLConfigConstants.SUSPEND_INITIAL_DURATION));
+            if (initialDuration != null && initialDuration.getText() != null) {
+                try {
+                    definition.setInitialSuspendDuration(
+                        Integer.parseInt(initialDuration.getText().trim()));
+                } catch (NumberFormatException e) {
+                    handleException("The initial suspend duration should be specified " +
+                        "as a valid number : " + initialDuration.getText(), e);
+                }
+            }
+
+            OMElement progressionFactor = suspendOnFailure.getFirstChildWithName(new QName(
+                SynapseConstants.SYNAPSE_NAMESPACE,
+                XMLConfigConstants.SUSPEND_PROGRESSION_FACTOR));
+            if (progressionFactor != null && progressionFactor.getText() != null) {
+                try {
+                    definition.setSuspendProgressionFactor(
+                        Float.parseFloat(progressionFactor.getText().trim()));
+                } catch (NumberFormatException e) {
+                    handleException("The suspend duration progression factor should be specified " +
+                        "as a valid float : " + progressionFactor.getText(), e);
+                }
+            }
+
+            OMElement maximumDuration = suspendOnFailure.getFirstChildWithName(new QName(
+                SynapseConstants.SYNAPSE_NAMESPACE,
+                XMLConfigConstants.SUSPEND_MAXIMUM_DURATION));
+            if (maximumDuration != null && maximumDuration.getText() != null) {
+                try {
+                    definition.setSuspendMaximumDuration(
+                        Long.parseLong(maximumDuration.getText().trim()));
+                } catch (NumberFormatException e) {
+                    handleException("The maximum suspend duration should be specified " +
+                        "as a valid number : " + maximumDuration.getText(), e);
+                }
             }
         }
     }
@@ -312,7 +427,8 @@ public abstract class EndpointFactory implements XMLToObjectMapper {
                 (new QName(SynapseConstants.SYNAPSE_NAMESPACE, "dynamicLoadbalance"));
         if (dlbElement != null) {
             //TODO: Handle Session affinitiy & failover
-            return DynamicLoadbalanceEndpointFactory.getInstance();
+//            TODO FIX-RUWAN
+//            return DynamicLoadbalanceEndpointFactory.getInstance();
         }
 
         OMElement foElement = configElement.getFirstChildWithName
diff --git a/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/EndpointSerializer.java b/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/EndpointSerializer.java
index c7a2dac40..70bff4b7f 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/EndpointSerializer.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/EndpointSerializer.java
@@ -27,7 +27,7 @@ import org.apache.synapse.SynapseConstants;
 import org.apache.synapse.SynapseException;
 import org.apache.synapse.config.xml.XMLConfigConstants;
 import org.apache.synapse.endpoints.*;
-import org.apache.synapse.endpoints.utils.EndpointDefinition;
+import org.apache.synapse.endpoints.EndpointDefinition;
 
 /**
  * All endpoint serializers should implement this interface. Use EndpointSerializer to
@@ -138,7 +138,8 @@ public abstract class EndpointSerializer {
             element.addChild(sec);
         }
 
-        if (endpointDefinition.getTimeoutAction() != SynapseConstants.NONE) {
+        if (endpointDefinition.getTimeoutAction() != SynapseConstants.NONE ||
+                endpointDefinition.getTimeoutDuration() > 0) {
 
             OMElement timeout = fac.createOMElement(
                     "timeout", SynapseConstants.SYNAPSE_OMNAMESPACE);
@@ -146,7 +147,7 @@ public abstract class EndpointSerializer {
 
             OMElement duration = fac.createOMElement(
                     "duration", SynapseConstants.SYNAPSE_OMNAMESPACE);
-            duration.setText(Long.toString(endpointDefinition.getTimeoutDuration() / 1000));
+            duration.setText(Long.toString(endpointDefinition.getTimeoutDuration()));
             timeout.addChild(duration);
 
             OMElement action = fac.createOMElement("action", SynapseConstants.SYNAPSE_OMNAMESPACE);
@@ -159,15 +160,83 @@ public abstract class EndpointSerializer {
             timeout.addChild(action);
         }
 
-        long suspendDuration = endpointDefinition.getSuspendOnFailDuration();
-        if (suspendDuration != -1) {
-            // user has set some value for this. let's serialize it.
-            OMElement suspendElement = fac.createOMElement(
-                    org.apache.synapse.config.xml.XMLConfigConstants.SUSPEND_DURATION_ON_FAILURE,
+        if (endpointDefinition.getInitialSuspendDuration() != -1 ||
+            !endpointDefinition.getSuspendErrorCodes().isEmpty()) {
+
+            OMElement suspendOnFailure = fac.createOMElement(
+                org.apache.synapse.config.xml.XMLConfigConstants.SUSPEND_ON_FAILURE,
+                SynapseConstants.SYNAPSE_OMNAMESPACE);
+
+            if (!endpointDefinition.getSuspendErrorCodes().isEmpty()) {
+                OMElement errorCodes = fac.createOMElement(
+                    org.apache.synapse.config.xml.XMLConfigConstants.ERROR_CODES,
+                    SynapseConstants.SYNAPSE_OMNAMESPACE);
+                errorCodes.setText(endpointDefinition.getSuspendErrorCodes().
+                    toString().replaceAll("[\\[\\] ]", ""));
+                suspendOnFailure.addChild(errorCodes);
+            }
+
+            if (endpointDefinition.getInitialSuspendDuration() != -1) {
+                OMElement initialDuration = fac.createOMElement(
+                    org.apache.synapse.config.xml.XMLConfigConstants.SUSPEND_INITIAL_DURATION,
                     SynapseConstants.SYNAPSE_OMNAMESPACE);
+                initialDuration.setText(Long.toString(endpointDefinition.getInitialSuspendDuration()));
+                suspendOnFailure.addChild(initialDuration);
+            }
 
-            suspendElement.setText(Long.toString(suspendDuration / 1000));
-            element.addChild(suspendElement);
+            if (endpointDefinition.getSuspendProgressionFactor() != -1) {
+                OMElement progressionFactor = fac.createOMElement(
+                    org.apache.synapse.config.xml.XMLConfigConstants.SUSPEND_PROGRESSION_FACTOR,
+                    SynapseConstants.SYNAPSE_OMNAMESPACE);
+                progressionFactor.setText(Float.toString(endpointDefinition.getSuspendProgressionFactor()));
+                suspendOnFailure.addChild(progressionFactor);
+            }
+
+            if (endpointDefinition.getSuspendMaximumDuration() != -1 &&
+                    endpointDefinition.getSuspendMaximumDuration() != Long.MAX_VALUE) {
+                OMElement suspendMaximum = fac.createOMElement(
+                    org.apache.synapse.config.xml.XMLConfigConstants.SUSPEND_MAXIMUM_DURATION,
+                    SynapseConstants.SYNAPSE_OMNAMESPACE);
+                suspendMaximum.setText(Long.toString(endpointDefinition.getSuspendMaximumDuration()));
+                suspendOnFailure.addChild(suspendMaximum);
+            }
+
+            element.addChild(suspendOnFailure);
+        }
+
+        if (endpointDefinition.getRetryDurationOnTimeout() > 0 ||
+            !endpointDefinition.getTimeoutErrorCodes().isEmpty()) {
+
+            OMElement markAsTimedout = fac.createOMElement(
+                org.apache.synapse.config.xml.XMLConfigConstants.MARK_FOR_SUSPENSION,
+                SynapseConstants.SYNAPSE_OMNAMESPACE);
+
+            if (!endpointDefinition.getTimeoutErrorCodes().isEmpty()) {
+                OMElement errorCodes = fac.createOMElement(
+                    org.apache.synapse.config.xml.XMLConfigConstants.ERROR_CODES,
+                    SynapseConstants.SYNAPSE_OMNAMESPACE);
+                errorCodes.setText(endpointDefinition.getTimeoutErrorCodes().
+                    toString().replaceAll("[\\[\\] ]", ""));
+                markAsTimedout.addChild(errorCodes);
+            }
+
+            if (endpointDefinition.getRetriesOnTimeoutBeforeSuspend() > 0) {
+                OMElement retries = fac.createOMElement(
+                    org.apache.synapse.config.xml.XMLConfigConstants.RETRIES_BEFORE_SUSPENSION,
+                    SynapseConstants.SYNAPSE_OMNAMESPACE);
+                retries.setText(Long.toString(endpointDefinition.getRetriesOnTimeoutBeforeSuspend()));
+                markAsTimedout.addChild(retries);
+            }
+
+            if (endpointDefinition.getRetryDurationOnTimeout() > 0) {
+                OMElement retryDelay = fac.createOMElement(
+                    org.apache.synapse.config.xml.XMLConfigConstants.RETRY_DELAY,
+                    SynapseConstants.SYNAPSE_OMNAMESPACE);
+                retryDelay.setText(Long.toString(endpointDefinition.getRetryDurationOnTimeout()));
+                markAsTimedout.addChild(retryDelay);
+            }
+
+            element.addChild(markAsTimedout);
         }
     }
 
@@ -198,10 +267,10 @@ public abstract class EndpointSerializer {
             return new WSDLEndpointSerializer();
         } else if (endpoint instanceof IndirectEndpoint) {
             return new IndirectEndpointSerializer();
-        } else if (endpoint instanceof LoadbalanceEndpoint) {
-            return new LoadbalanceEndpointSerializer();
         } else if (endpoint instanceof SALoadbalanceEndpoint) {
             return new SALoadbalanceEndpointSerializer();
+        } else if (endpoint instanceof LoadbalanceEndpoint) {
+            return new LoadbalanceEndpointSerializer();
         } else if (endpoint instanceof FailoverEndpoint) {
             return new FailoverEndpointSerializer();
         }
diff --git a/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/FailoverEndpointFactory.java b/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/FailoverEndpointFactory.java
index c862b954f..e5b6b541f 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/FailoverEndpointFactory.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/FailoverEndpointFactory.java
@@ -58,7 +58,7 @@ public class FailoverEndpointFactory extends EndpointFactory {
                 failoverEndpoint.setName(name);
             }
             // set endpoints and return
-            failoverEndpoint.setEndpoints(getEndpoints(failoverElement, failoverEndpoint));
+            failoverEndpoint.setChildren(getEndpoints(failoverElement, failoverEndpoint));
             return failoverEndpoint;
         }
         return null;
diff --git a/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/FailoverEndpointSerializer.java b/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/FailoverEndpointSerializer.java
index c4666eb8e..22aed84f2 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/FailoverEndpointSerializer.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/FailoverEndpointSerializer.java
@@ -53,7 +53,7 @@ public class FailoverEndpointSerializer extends EndpointSerializer {
             endpointElement.addAttribute("name", name, null);
         }
 
-        for (Endpoint childEndpoint : failoverEndpoint.getEndpoints()) {
+        for (Endpoint childEndpoint : failoverEndpoint.getChildren()) {
             failoverElement.addChild(EndpointSerializer.getElementFromEndpoint(childEndpoint));
         }
 
diff --git a/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/LoadbalanceEndpointFactory.java b/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/LoadbalanceEndpointFactory.java
index afcb3bcc1..594aac022 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/LoadbalanceEndpointFactory.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/LoadbalanceEndpointFactory.java
@@ -34,6 +34,7 @@ import javax.xml.namespace.QName;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Iterator;
+import java.util.List;
 
 /**
  * Creates {@link LoadbalanceEndpoint} using an XML configuration.
@@ -91,7 +92,7 @@ public class LoadbalanceEndpointFactory extends EndpointFactory {
                 }
                 List<Endpoint> endpoints
                         = getEndpoints(loadbalanceElement, loadbalanceEndpoint);
-                loadbalanceEndpoint.setEndpoints(endpoints);
+                loadbalanceEndpoint.setChildren(endpoints);
                 algorithm =
                         LoadbalanceAlgorithmFactory.
                                 createLoadbalanceAlgorithm(loadbalanceElement, endpoints);
@@ -105,12 +106,13 @@ public class LoadbalanceEndpointFactory extends EndpointFactory {
                     log.error(msg);
                     throw new SynapseException(msg);
                 }
-                List<Member> members = getMembers(loadbalanceElement);
-                loadbalanceEndpoint.setMembers(members);
-                algorithm =
-                        LoadbalanceAlgorithmFactory.
-                                createLoadbalanceAlgorithm2(loadbalanceElement, members);
-                loadbalanceEndpoint.startApplicationMembershipTimer();
+//                TODO FIX-RUWAN
+//                List<Member> members = getMembers(loadbalanceElement);
+//                loadbalanceEndpoint.setMembers(members);
+//                algorithm =
+//                        LoadbalanceAlgorithmFactory.
+//                                createLoadbalanceAlgorithm2(loadbalanceElement, members);
+//                loadbalanceEndpoint.startApplicationMembershipTimer();
             }
 
             // set load balance algorithm
diff --git a/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/LoadbalanceEndpointSerializer.java b/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/LoadbalanceEndpointSerializer.java
index 1f82799c8..5b38ae575 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/LoadbalanceEndpointSerializer.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/LoadbalanceEndpointSerializer.java
@@ -67,21 +67,22 @@ public class LoadbalanceEndpointSerializer extends EndpointSerializer {
         }
 
         // Serialize endpoint elements which are children of the loadbalance element
-        for (Endpoint childEndpoint : loadbalanceEndpoint.getEndpoints()) {
+        for (Endpoint childEndpoint : loadbalanceEndpoint.getChildren()) {
             loadbalanceElement.addChild(EndpointSerializer.getElementFromEndpoint(childEndpoint));
         }
 
-        // Serialize member elements which are children of the loadbalance element
-        for (Member member : loadbalanceEndpoint.getAllMembers()) {
-            OMElement memberEle =
-                    fac.createOMElement("member",
-                                        SynapseConstants.SYNAPSE_OMNAMESPACE, loadbalanceElement);
-            memberEle.addAttribute(fac.createOMAttribute("hostName", null, member.getHostName()));
-            memberEle.addAttribute(fac.createOMAttribute("httpPort", null,
-                                                         String.valueOf(member.getHttpPort())));
-            memberEle.addAttribute(fac.createOMAttribute("httpsPort", null,
-                                                         String.valueOf(member.getHttpsPort())));
-        }
+//      TODO FIX_RUWAN        
+//        // Serialize member elements which are children of the loadbalance element
+//        for (Member member : loadbalanceEndpoint.getAllMembers()) {
+//            OMElement memberEle =
+//                    fac.createOMElement("member",
+//                                        SynapseConstants.SYNAPSE_OMNAMESPACE, loadbalanceElement);
+//            memberEle.addAttribute(fac.createOMAttribute("hostName", null, member.getHostName()));
+//            memberEle.addAttribute(fac.createOMAttribute("httpPort", null,
+//                                                         String.valueOf(member.getHttpPort())));
+//            memberEle.addAttribute(fac.createOMAttribute("httpsPort", null,
+//                                                         String.valueOf(member.getHttpsPort())));
+//        }
 
         return endpointElement;
     }
diff --git a/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/SALoadbalanceEndpointFactory.java b/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/SALoadbalanceEndpointFactory.java
index 1d221a215..c9a52b305 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/SALoadbalanceEndpointFactory.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/SALoadbalanceEndpointFactory.java
@@ -64,6 +64,18 @@ public class SALoadbalanceEndpointFactory extends EndpointFactory {
                 getFirstChildWithName(new QName(SynapseConstants.SYNAPSE_NAMESPACE, "session"));
         if (sessionElement != null) {
 
+            OMElement sessionTimeout = sessionElement.getFirstChildWithName(
+                    new QName(SynapseConstants.SYNAPSE_NAMESPACE, "sessionTimeout"));
+
+            if (sessionTimeout != null) {
+                try {
+                    loadbalanceEndpoint.setSessionTimeout(Long.parseLong(
+                            sessionTimeout.getText().trim()));
+                } catch (NumberFormatException nfe) {
+                    handleException("Invalid session timeout value : " + sessionTimeout.getText());
+                }
+            }
+            
             String type = sessionElement.getAttributeValue(new QName("type"));
 
             if (type.equalsIgnoreCase("soap")) {
@@ -99,7 +111,7 @@ public class SALoadbalanceEndpointFactory extends EndpointFactory {
 
             // set endpoints
             List<Endpoint> endpoints = getEndpoints(loadbalanceElement, loadbalanceEndpoint);
-            loadbalanceEndpoint.setEndpoints(endpoints);
+            loadbalanceEndpoint.setChildren(endpoints);
 
             // set load balance algorithm
             LoadbalanceAlgorithm algorithm = LoadbalanceAlgorithmFactory.
diff --git a/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/SALoadbalanceEndpointSerializer.java b/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/SALoadbalanceEndpointSerializer.java
index aed3d6043..3bddce889 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/SALoadbalanceEndpointSerializer.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/SALoadbalanceEndpointSerializer.java
@@ -57,23 +57,26 @@ public class SALoadbalanceEndpointSerializer extends EndpointSerializer {
         }
 
         Dispatcher dispatcher = loadbalanceEndpoint.getDispatcher();
-
-        if (dispatcher instanceof SoapSessionDispatcher) {
-            OMElement sessionElement
-                    = fac.createOMElement("session", SynapseConstants.SYNAPSE_OMNAMESPACE);
-            sessionElement.addAttribute("type", "soap", null);
-            endpointElement.addChild(sessionElement);
-
-        } else if (dispatcher instanceof HttpSessionDispatcher) {
-            OMElement sessionElement
-                    = fac.createOMElement("session", SynapseConstants.SYNAPSE_OMNAMESPACE);
-            sessionElement.addAttribute("type", "http", null);
-            endpointElement.addChild(sessionElement);
-
-        } else if (dispatcher instanceof SimpleClientSessionDispatcher) {
-            OMElement sessionElement
-                    = fac.createOMElement("session", SynapseConstants.SYNAPSE_OMNAMESPACE);
-            sessionElement.addAttribute("type", "simpleClientSession", null);
+        if (dispatcher != null) {
+
+            OMElement sessionElement = fac.createOMElement("session", SynapseConstants.SYNAPSE_OMNAMESPACE);
+            if (dispatcher instanceof SoapSessionDispatcher) {
+                sessionElement.addAttribute("type", "soap", null);
+            } else if (dispatcher instanceof HttpSessionDispatcher) {
+                sessionElement.addAttribute("type", "http", null);
+            } else if (dispatcher instanceof SimpleClientSessionDispatcher) {
+                sessionElement.addAttribute("type", "simpleClientSession", null);
+            } else {
+                handleException("invalid session dispatcher : " + dispatcher.getClass().getName());
+            }
+
+            long sessionTimeout = loadbalanceEndpoint.getSessionTimeout();
+            if (sessionTimeout != -1) {
+                OMElement sessionTimeoutElement = fac.createOMElement("sessionTimeout",
+                        SynapseConstants.SYNAPSE_OMNAMESPACE);
+                sessionTimeoutElement.setText(String.valueOf(sessionTimeout));
+                sessionElement.addChild(sessionTimeoutElement);
+            }
             endpointElement.addChild(sessionElement);
         }
 
@@ -88,7 +91,7 @@ public class SALoadbalanceEndpointSerializer extends EndpointSerializer {
         }
         loadbalanceElement.addAttribute("algorithm", algorithmName, null);
 
-        for (Endpoint childEndpoint : loadbalanceEndpoint.getEndpoints()) {
+        for (Endpoint childEndpoint : loadbalanceEndpoint.getChildren()) {
             loadbalanceElement.addChild(EndpointSerializer.getElementFromEndpoint(childEndpoint));
         }
 
diff --git a/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/WSDLEndpointFactory.java b/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/WSDLEndpointFactory.java
index bf5fc6319..dcde935fb 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/WSDLEndpointFactory.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/WSDLEndpointFactory.java
@@ -30,7 +30,7 @@ import org.apache.synapse.config.SynapseConfigUtils;
 import org.apache.synapse.config.xml.endpoints.utils.WSDL11EndpointBuilder;
 import org.apache.synapse.endpoints.Endpoint;
 import org.apache.synapse.endpoints.WSDLEndpoint;
-import org.apache.synapse.endpoints.utils.EndpointDefinition;
+import org.apache.synapse.endpoints.EndpointDefinition;
 
 import javax.xml.namespace.QName;
 import java.io.File;
@@ -165,7 +165,7 @@ public class WSDLEndpointFactory extends EndpointFactory {
                 // for now, QOS information has to be provided explicitly.
                 extractCommonEndpointProperties(endpoint, wsdlElement);
                 extractSpecificEndpointProperties(endpoint, wsdlElement);
-                wsdlEndpoint.setEndpoint(endpoint);
+                wsdlEndpoint.setDefinition(endpoint);
             } else {
                 handleException("WSDL is not specified for WSDL endpoint.");
             }
diff --git a/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/WSDLEndpointSerializer.java b/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/WSDLEndpointSerializer.java
index b6dbe3414..c79f4036c 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/WSDLEndpointSerializer.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/WSDLEndpointSerializer.java
@@ -24,7 +24,7 @@ import org.apache.axiom.om.OMElement;
 import org.apache.synapse.SynapseConstants;
 import org.apache.synapse.endpoints.Endpoint;
 import org.apache.synapse.endpoints.WSDLEndpoint;
-import org.apache.synapse.endpoints.utils.EndpointDefinition;
+import org.apache.synapse.endpoints.EndpointDefinition;
 
 /**
  * Serializes an {@link WSDLEndpoint} to an XML configuration.
@@ -73,7 +73,7 @@ public class WSDLEndpointSerializer extends EndpointSerializer {
         // currently, we have to get QOS information from the endpoint definition and set them as
         // special elements under the wsdl element. in future, these information should be
         // extracted from the wsdl.
-        EndpointDefinition epDefinition = wsdlEndpoint.getEndpoint();
+        EndpointDefinition epDefinition = wsdlEndpoint.getDefinition();
         serializeCommonEndpointProperties(epDefinition, wsdlElement);
         serializeSpecificEndpointProperties(epDefinition, wsdlElement);
         endpointElement.addChild(wsdlElement);
diff --git a/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/utils/LoadbalanceAlgorithmFactory.java b/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/utils/LoadbalanceAlgorithmFactory.java
index bf65ca500..665bf59e4 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/utils/LoadbalanceAlgorithmFactory.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/utils/LoadbalanceAlgorithmFactory.java
@@ -19,18 +19,14 @@
 
 package org.apache.synapse.config.xml.endpoints.utils;
 
-import org.apache.axiom.om.OMAttribute;
 import org.apache.axiom.om.OMElement;
-import org.apache.axis2.clustering.Member;
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.synapse.SynapseException;
-import org.apache.synapse.config.xml.XMLConfigConstants;
-import org.apache.synapse.endpoints.Endpoint;
+import org.apache.axiom.om.OMAttribute;
 import org.apache.synapse.endpoints.algorithms.LoadbalanceAlgorithm;
 import org.apache.synapse.endpoints.algorithms.RoundRobin;
+import org.apache.synapse.config.xml.XMLConfigConstants;
 
 import javax.xml.namespace.QName;
+import java.util.ArrayList;
 import java.util.List;
 
 /**
@@ -39,60 +35,20 @@ import java.util.List;
  */
 public class LoadbalanceAlgorithmFactory {
 
-    private static final Log log = LogFactory.getLog(LoadbalanceAlgorithmFactory.class);
-
-    public static LoadbalanceAlgorithm createLoadbalanceAlgorithm(OMElement loadbalanceElement) {
-        return getLoadbalanceAlgorithm(loadbalanceElement);
-    }
-
-    public static LoadbalanceAlgorithm createLoadbalanceAlgorithm(OMElement loadbalanceElement,
-                                                                  List<Endpoint> endpoints) {
-        LoadbalanceAlgorithm algorithm = getLoadbalanceAlgorithm(loadbalanceElement);
-        algorithm.setEndpoints(endpoints);
-        return algorithm;
-    }
+    public static LoadbalanceAlgorithm createLoadbalanceAlgorithm(OMElement loadbalanceElement, List endpoints) {
 
-    public static LoadbalanceAlgorithm createLoadbalanceAlgorithm2(OMElement loadbalanceElement,
-                                                                   List<Member> members) {
+        LoadbalanceAlgorithm algorithm = null;
 
-        LoadbalanceAlgorithm algorithm = getLoadbalanceAlgorithm(loadbalanceElement);
-        algorithm.setApplicationMembers(members);
-        return algorithm;
-    }
-
-    private static LoadbalanceAlgorithm getLoadbalanceAlgorithm(OMElement loadbalanceElement) {
-        LoadbalanceAlgorithm algorithm = new RoundRobin();  // Default algorithm is round-robin
-        OMAttribute policyAtt =
-                loadbalanceElement.getAttribute(new QName(null,
-                                                          XMLConfigConstants.LOADBALANCE_POLICY));
-        OMAttribute algorithmAtt =
-                loadbalanceElement.getAttribute(new QName(null,
-                                                          XMLConfigConstants.LOADBALANCE_ALGORITHM));
-        if (policyAtt != null && algorithmAtt != null) {
-            String msg = "You cannot specify both the 'policy' & 'algorithm' in the configuration. " +
-                         "It is sufficient to provide only the 'algorithm'.";
-            log.fatal(msg); // We cannot continue execution. Hence it is logged at fatal level
-            throw new SynapseException(msg);
+        String algorithmName = "roundRobin";
+        OMAttribute algoAttribute = loadbalanceElement.getAttribute(new QName(null, XMLConfigConstants.ALGORITHM_NAME));
+        if(algoAttribute != null) {
+            algorithmName = algoAttribute.getAttributeValue();
         }
-        if (algorithmAtt != null) {
-            String algorithmStr = algorithmAtt.getAttributeValue().trim();
-            try {
-                algorithm = (LoadbalanceAlgorithm) Class.forName(algorithmStr).newInstance();
-            } catch (Exception e) {
-                String msg = "Cannot instantiate LoadbalanceAlgorithm implementation class " +
-                             algorithmStr;
-                log.fatal(msg, e); // We cannot continue execution. Hence it is logged at fatal level
-                throw new SynapseException(msg, e);
-            }
-        } else if (policyAtt != null) {
-            if (!policyAtt.getAttributeValue().trim().equals("roundRobin")) {
-                String msg = "Unsupported algorithm " + policyAtt.getAttributeValue().trim() +
-                             " specified. Please use the 'algorithm' attribute to specify the " +
-                             "correct loadbalance algorithm implementation.";
-                log.fatal(msg); // We cannot continue execution. Hence it is logged at fatal level
-                throw new SynapseException(msg);
-            }
+
+        if(algorithmName.equalsIgnoreCase("roundRobin")) {
+                algorithm = new RoundRobin(endpoints);
         }
+
         return algorithm;
     }
 }
diff --git a/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/utils/WSDL11EndpointBuilder.java b/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/utils/WSDL11EndpointBuilder.java
index 327f9f8e1..6f2f0a852 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/utils/WSDL11EndpointBuilder.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/utils/WSDL11EndpointBuilder.java
@@ -26,7 +26,7 @@ import org.apache.commons.logging.LogFactory;
 import org.apache.synapse.SynapseConstants;
 import org.apache.synapse.SynapseException;
 import org.apache.synapse.core.axis2.CustomWSDLLocator;
-import org.apache.synapse.endpoints.utils.EndpointDefinition;
+import org.apache.synapse.endpoints.EndpointDefinition;
 import org.w3c.dom.Document;
 import org.xml.sax.InputSource;
 import org.xml.sax.SAXException;
diff --git a/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/utils/WSDL20EndpointBuilder.java b/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/utils/WSDL20EndpointBuilder.java
index 0707eccff..720bd2bde 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/utils/WSDL20EndpointBuilder.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/config/xml/endpoints/utils/WSDL20EndpointBuilder.java
@@ -19,19 +19,6 @@
 
 package org.apache.synapse.config.xml.endpoints.utils;
 
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.synapse.SynapseException;
-import org.apache.synapse.endpoints.utils.EndpointDefinition;
-import org.apache.woden.WSDLException;
-import org.apache.woden.WSDLFactory;
-import org.apache.woden.WSDLReader;
-import org.apache.woden.types.NCName;
-import org.apache.woden.wsdl20.Description;
-import org.apache.woden.wsdl20.Endpoint;
-import org.apache.woden.wsdl20.Service;
-
-import javax.xml.namespace.QName;
 import java.net.URI;
 
 /**
@@ -42,7 +29,7 @@ import java.net.URI;
  * documents.
  */
 public class WSDL20EndpointBuilder {
-
+    /* COMMENT DUE TO BUILD FAILURE - TO BE FIXED LATER WHEN WSDL 2.0 SUPPORT IS OFFICIALLY IN
     private static Log log = LogFactory.getLog(WSDL20EndpointBuilder.class);
 
     public EndpointDefinition createEndpointDefinitionFromWSDL(String wsdlURI, String serviceName,
@@ -103,4 +90,5 @@ public class WSDL20EndpointBuilder {
         log.error(msg);
         throw new SynapseException(msg);
     }
+    */
 }
diff --git a/java/modules/core/src/main/java/org/apache/synapse/core/LoadBalanceMembershipHandler.java b/java/modules/core/src/main/java/org/apache/synapse/core/LoadBalanceMembershipHandler.java
index 47e867c7c..906c059cf 100755
--- a/java/modules/core/src/main/java/org/apache/synapse/core/LoadBalanceMembershipHandler.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/core/LoadBalanceMembershipHandler.java
@@ -30,35 +30,35 @@ import java.util.Properties;
  * Generally, this interface will work with a GCF or other membership discovery mechanism
  */
 public interface LoadBalanceMembershipHandler {
-
-    /**
-     * Initialize this
-     *
-     * @param properties The properties specific to this LoadBalanceMembershipHandler
-     * @param algorithm  The load balancing algorithm
-     */
-    void init(Properties properties, LoadbalanceAlgorithm algorithm);
-
-    /**
-     * Set the Axis2 ConfigurationContext
-     *
-     * @param configCtx Axis2 ConfigurationContext
-     */
-    void setConfigurationContext(ConfigurationContext configCtx);
-
-    /**
-     * Get the Axis2 ConfigurationContext
-     *
-     * @return Axis2 ConfigurationContext
-     */
-    ConfigurationContext getConfigurationContext();
-
-    /**
-     * Get the next application member to whom the message has to be sent to
-     *
-     * @param context The AlgorithmContext which holds information needed for the algorithm
-     * @return Next application member to whom the message has to be sent to
-     */
-     Member getNextApplicationMember(AlgorithmContext context);
-
+//    TODO FIX-RUWAN
+//    /**
+//     * Initialize this
+//     *
+//     * @param properties The properties specific to this LoadBalanceMembershipHandler
+//     * @param algorithm  The load balancing algorithm
+//     */
+//    void init(Properties properties, LoadbalanceAlgorithm algorithm);
+//
+//    /**
+//     * Set the Axis2 ConfigurationContext
+//     *
+//     * @param configCtx Axis2 ConfigurationContext
+//     */
+//    void setConfigurationContext(ConfigurationContext configCtx);
+//
+//    /**
+//     * Get the Axis2 ConfigurationContext
+//     *
+//     * @return Axis2 ConfigurationContext
+//     */
+//    ConfigurationContext getConfigurationContext();
+//
+//    /**
+//     * Get the next application member to whom the message has to be sent to
+//     *
+//     * @param context The AlgorithmContext which holds information needed for the algorithm
+//     * @return Next application member to whom the message has to be sent to
+//     */
+//     Member getNextApplicationMember(AlgorithmContext context);
+//
 }
diff --git a/java/modules/core/src/main/java/org/apache/synapse/core/SynapseEnvironment.java b/java/modules/core/src/main/java/org/apache/synapse/core/SynapseEnvironment.java
index 6942b1a0d..c218d6247 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/core/SynapseEnvironment.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/core/SynapseEnvironment.java
@@ -21,7 +21,7 @@ package org.apache.synapse.core;
 
 import org.apache.synapse.MessageContext;
 import org.apache.synapse.config.SynapseConfiguration;
-import org.apache.synapse.endpoints.utils.EndpointDefinition;
+import org.apache.synapse.endpoints.EndpointDefinition;
 import org.apache.synapse.mediators.base.SequenceMediator;
 import org.apache.synapse.audit.statistics.StatisticsCollector;
 import org.apache.synapse.util.TemporaryData;
diff --git a/java/modules/core/src/main/java/org/apache/synapse/core/axis2/Axis2FlexibleMEPClient.java b/java/modules/core/src/main/java/org/apache/synapse/core/axis2/Axis2FlexibleMEPClient.java
index 64812e6b0..fd2efac8c 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/core/axis2/Axis2FlexibleMEPClient.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/core/axis2/Axis2FlexibleMEPClient.java
@@ -40,7 +40,7 @@ import org.apache.axis2.wsdl.WSDLConstants;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 import org.apache.synapse.SynapseConstants;
-import org.apache.synapse.endpoints.utils.EndpointDefinition;
+import org.apache.synapse.endpoints.EndpointDefinition;
 import org.apache.synapse.util.MessageHelper;
 
 import javax.xml.namespace.QName;
@@ -268,6 +268,11 @@ public class Axis2FlexibleMEPClient {
         axisOutMsgCtx.setAxisMessage(
             axisAnonymousOperation.getMessage(WSDLConstants.MESSAGE_LABEL_OUT_VALUE));
 
+        // set the SEND_TIMEOUT for transport sender
+        if (endpoint != null && endpoint.getTimeoutDuration() > 0) {
+            axisOutMsgCtx.setProperty(SynapseConstants.SEND_TIMEOUT, endpoint.getTimeoutDuration());
+        }
+
         if (!outOnlyMessage) {
             // always set a callback as we decide if the send it blocking or non blocking within
             // the MEP client. This does not cause an overhead, as we simply create a 'holder'
diff --git a/java/modules/core/src/main/java/org/apache/synapse/core/axis2/Axis2LoadBalanceMembershipHandler.java b/java/modules/core/src/main/java/org/apache/synapse/core/axis2/Axis2LoadBalanceMembershipHandler.java
index b8ce2e2b4..0c20ccf61 100755
--- a/java/modules/core/src/main/java/org/apache/synapse/core/axis2/Axis2LoadBalanceMembershipHandler.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/core/axis2/Axis2LoadBalanceMembershipHandler.java
@@ -86,8 +86,9 @@ public class Axis2LoadBalanceMembershipHandler implements LoadBalanceMembershipH
      * @param context The AlgorithmContext
      * @return The current member
      */
-    public Member getNextApplicationMember(AlgorithmContext context) {
-        algorithm.setApplicationMembers(lbEventHandler.getMembers());
-        return algorithm.getNextApplicationMember(context);
-    }
+//    TODO FIX-RUWAN
+//    public Member getNextApplicationMember(AlgorithmContext context) {
+//        algorithm.setApplicationMembers(lbEventHandler.getMembers());
+//        return algorithm.getNextApplicationMember(context);
+//    }
 }
diff --git a/java/modules/core/src/main/java/org/apache/synapse/core/axis2/Axis2MessageContext.java b/java/modules/core/src/main/java/org/apache/synapse/core/axis2/Axis2MessageContext.java
index 2738fe563..29f8a8878 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/core/axis2/Axis2MessageContext.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/core/axis2/Axis2MessageContext.java
@@ -172,6 +172,10 @@ public class Axis2MessageContext implements MessageContext {
     }
 
     public void setProperty(String key, Object value) {
+        if (value == null) {
+            return;
+        }
+        
         properties.put(key, value);
 
         // do not commit response by default in the server process
diff --git a/java/modules/core/src/main/java/org/apache/synapse/core/axis2/Axis2Sender.java b/java/modules/core/src/main/java/org/apache/synapse/core/axis2/Axis2Sender.java
index 4ef3ccae8..23d87015e 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/core/axis2/Axis2Sender.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/core/axis2/Axis2Sender.java
@@ -32,7 +32,7 @@ import org.apache.commons.logging.LogFactory;
 import org.apache.rampart.handler.WSSHandlerConstants;
 import org.apache.synapse.SynapseConstants;
 import org.apache.synapse.SynapseException;
-import org.apache.synapse.endpoints.utils.EndpointDefinition;
+import org.apache.synapse.endpoints.EndpointDefinition;
 import org.apache.synapse.transport.nhttp.NhttpConstants;
 import org.apache.synapse.util.MessageHelper;
 import org.apache.synapse.util.POXUtils;
diff --git a/java/modules/core/src/main/java/org/apache/synapse/core/axis2/Axis2SynapseEnvironment.java b/java/modules/core/src/main/java/org/apache/synapse/core/axis2/Axis2SynapseEnvironment.java
index 170653423..0e4f0b063 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/core/axis2/Axis2SynapseEnvironment.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/core/axis2/Axis2SynapseEnvironment.java
@@ -34,7 +34,8 @@ import org.apache.synapse.audit.statistics.StatisticsCollector;
 import org.apache.synapse.audit.AuditHelper;
 import org.apache.synapse.config.SynapseConfiguration;
 import org.apache.synapse.core.SynapseEnvironment;
-import org.apache.synapse.endpoints.utils.EndpointDefinition;
+import org.apache.synapse.endpoints.EndpointDefinition;
+import org.apache.synapse.endpoints.dispatch.Dispatcher;
 import org.apache.synapse.mediators.MediatorWorker;
 import org.apache.synapse.mediators.base.SequenceMediator;
 import org.apache.synapse.util.TemporaryData;
diff --git a/java/modules/core/src/main/java/org/apache/synapse/core/axis2/SynapseCallbackReceiver.java b/java/modules/core/src/main/java/org/apache/synapse/core/axis2/SynapseCallbackReceiver.java
index 9bbd79d66..c9a5b4b13 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/core/axis2/SynapseCallbackReceiver.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/core/axis2/SynapseCallbackReceiver.java
@@ -19,9 +19,7 @@
 
 package org.apache.synapse.core.axis2;
 
-import org.apache.axiom.soap.SOAPEnvelope;
-import org.apache.axiom.soap.SOAPFault;
-import org.apache.axiom.soap.SOAPFaultReason;
+import org.apache.axiom.om.OMException;
 import org.apache.axis2.AxisFault;
 import org.apache.axis2.Constants;
 import org.apache.axis2.addressing.AddressingConstants;
@@ -42,6 +40,7 @@ import org.apache.synapse.audit.statistics.StatisticsReporter;
 import org.apache.synapse.audit.AuditConfigurable;
 import org.apache.synapse.config.SynapseConfiguration;
 import org.apache.synapse.endpoints.Endpoint;
+import org.apache.synapse.endpoints.dispatch.Dispatcher;
 import org.apache.synapse.transport.nhttp.NhttpConstants;
 import org.apache.synapse.util.ResponseAcceptEncodingProcessor;
 
@@ -157,12 +156,12 @@ public class SynapseCallbackReceiver implements MessageReceiver {
         org.apache.synapse.MessageContext synapseOutMsgCtx) throws AxisFault {
 
         Endpoint endpoint = (Endpoint) synapseOutMsgCtx.getProperty(
-                SynapseConstants.PROCESSED_ENDPOINT);
+                SynapseConstants.LAST_ENDPOINT);
         if (endpoint instanceof AuditConfigurable) {
             StatisticsReporter.report(synapseOutMsgCtx, (AuditConfigurable) endpoint);
         }
         
-        Object o = response.getProperty(NhttpConstants.SENDING_FAULT);
+        Object o = response.getProperty(SynapseConstants.SENDING_FAULT);
         if (o != null && Boolean.TRUE.equals(o)) {
 
             StatisticsReporter.reportFault(synapseOutMsgCtx);
@@ -170,33 +169,28 @@ public class SynapseCallbackReceiver implements MessageReceiver {
 
             Stack faultStack = synapseOutMsgCtx.getFaultStack();
             if (faultStack != null && !faultStack.isEmpty()) {
-                SOAPEnvelope envelope = response.getEnvelope();
-                if (envelope != null) {
-                    SOAPFault fault = envelope.getBody().getFault();
-                    if (fault != null) {
-                        Exception e = fault.getException();
-                        if (e == null) {
-                            SOAPFaultReason reason = fault.getReason();
-                            if (reason != null) {
-                                e = new Exception(reason.getText());
-                            }
-                        }
-                        // set an error code to the message context, so that error sequences can
-                        // filter using that property to determine the cause of error
-                        synapseOutMsgCtx.setProperty(SynapseConstants.ERROR_CODE,
-                            SynapseConstants.SENDING_FAULT);
-                        SOAPFaultReason faultReason = fault.getReason();
-                        if (faultReason != null) {
-                            synapseOutMsgCtx.setProperty(SynapseConstants.ERROR_MESSAGE,
-                                    faultReason.getText());
-                        }
-                        if (fault.getException() != null) {
-                            synapseOutMsgCtx.setProperty(SynapseConstants.ERROR_EXCEPTION,
-                                    fault.getException());
-                        }
-                        ((FaultHandler) faultStack.pop()).handleFault(synapseOutMsgCtx, e);
-                    }
-                }
+
+                // if we have access to the full synapseOutMsgCtx.getEnvelope(), then let
+                // it flow with the error details. Else, replace its envelope with the
+                // fault envelope
+                try {
+                    synapseOutMsgCtx.getEnvelope().build();
+                } catch (OMException x) {
+                    synapseOutMsgCtx.setEnvelope(response.getEnvelope());
+                  }
+
+                Exception e = (Exception) response.getProperty(SynapseConstants.ERROR_EXCEPTION);
+
+                synapseOutMsgCtx.setProperty(SynapseConstants.SENDING_FAULT, Boolean.TRUE);
+                synapseOutMsgCtx.setProperty(SynapseConstants.ERROR_CODE,
+                    response.getProperty(SynapseConstants.ERROR_CODE));
+                synapseOutMsgCtx.setProperty(SynapseConstants.ERROR_MESSAGE,
+                    response.getProperty(SynapseConstants.ERROR_MESSAGE));
+                synapseOutMsgCtx.setProperty(SynapseConstants.ERROR_DETAIL,
+                    response.getProperty(SynapseConstants.ERROR_DETAIL));
+                synapseOutMsgCtx.setProperty(SynapseConstants.ERROR_EXCEPTION, e);
+
+                ((FaultHandler) faultStack.pop()).handleFault(synapseOutMsgCtx, null);
             }
 
         } else {
@@ -206,7 +200,8 @@ public class SynapseCallbackReceiver implements MessageReceiver {
             Stack faultStack = synapseOutMsgCtx.getFaultStack();
             if (faultStack !=null && !faultStack.isEmpty()
                 && faultStack.peek() instanceof Endpoint) {
-                faultStack.pop();
+                Endpoint successfulEndpoint = (Endpoint) faultStack.pop();
+                successfulEndpoint.onSuccess();
             }
             if (log.isDebugEnabled()) {
                 log.debug("Synapse received an asynchronous response message");
diff --git a/java/modules/core/src/main/java/org/apache/synapse/core/axis2/TimeoutHandler.java b/java/modules/core/src/main/java/org/apache/synapse/core/axis2/TimeoutHandler.java
index 9d4fe2b56..dcf4d9ca7 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/core/axis2/TimeoutHandler.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/core/axis2/TimeoutHandler.java
@@ -25,6 +25,7 @@ import org.apache.synapse.FaultHandler;
 import org.apache.synapse.MessageContext;
 import org.apache.synapse.SynapseConstants;
 import org.apache.synapse.ServerManager;
+import org.apache.synapse.endpoints.dispatch.SALSessions;
 
 import java.util.Iterator;
 import java.util.Map;
@@ -81,7 +82,10 @@ public class TimeoutHandler extends TimerTask {
         }
     }
 
-    private void processCallbacks() {
+    private void processCallbacks() {       
+        
+        //clear all the expired sessions
+        SALSessions.getInstance().clearSessions();
 
         // checks if callback store contains at least one entry before proceeding. otherwise getting
         // the time for doing nothing would be a inefficient task.
@@ -112,7 +116,7 @@ public class TimeoutHandler extends TimerTask {
 
                                 // add an error code to the message context, so that error sequences
                                 // can identify the cause of error
-                                msgContext.setProperty(SynapseConstants.ERROR_CODE, SynapseConstants.TIME_OUT);
+                                msgContext.setProperty(SynapseConstants.ERROR_CODE, SynapseConstants.HANDLER_TIME_OUT);
                                 msgContext.setProperty(SynapseConstants.ERROR_MESSAGE, "Send timeout");
 
                                 Stack faultStack = msgContext.getFaultStack();
diff --git a/java/modules/core/src/main/java/org/apache/synapse/endpoints/AbstractEndpoint.java b/java/modules/core/src/main/java/org/apache/synapse/endpoints/AbstractEndpoint.java
new file mode 100755
index 000000000..d204c30f2
--- /dev/null
+++ b/java/modules/core/src/main/java/org/apache/synapse/endpoints/AbstractEndpoint.java
@@ -0,0 +1,410 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.endpoints;
+
+import org.apache.synapse.MessageContext;
+import org.apache.synapse.SynapseConstants;
+import org.apache.synapse.FaultHandler;
+import org.apache.synapse.SynapseException;
+import org.apache.synapse.audit.statistics.StatisticsReporter;
+import org.apache.axis2.transport.base.BaseConstants;
+import org.apache.synapse.core.axis2.Axis2MessageContext;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.axis2.context.ConfigurationContext;
+import org.apache.axis2.clustering.ClusterManager;
+
+import javax.management.MBeanServer;
+import javax.management.ObjectName;
+import java.util.Stack;
+import java.util.List;
+import java.util.Set;
+import java.lang.management.ManagementFactory;
+
+/**
+ * An abstract base class for all Endpoint implementations
+ */
+public abstract class AbstractEndpoint extends FaultHandler implements Endpoint {
+
+    protected Log log;
+    protected static final Log trace = LogFactory.getLog(SynapseConstants.TRACE_LOGGER);
+
+    /** Hold the logical name of an endpoint */
+    private String endpointName = null;
+
+    /** The parent endpoint for this endpoint */
+    private Endpoint parentEndpoint = null;
+
+    /** The child endpoints of this endpoint - if any */
+    private List<Endpoint> children = null;
+
+    /** The Endpoint definition for this endpoint - i.e. holds all static endpoint information */
+    private EndpointDefinition definition = null;
+
+    /** Has this endpoint been initialized ? */
+    protected boolean initialized = false;
+
+    /** The endpoint context - if applicable - that will hold the runtime state of the endpoint */
+    private EndpointContext context = null;
+
+    /** Is clustering enabled */
+    protected Boolean isClusteringEnabled = null;
+
+    /** The MBean managing the endpoint */
+    EndpointView metricsMBean = null;
+
+    protected AbstractEndpoint() {
+        log = LogFactory.getLog(this.getClass());
+    }
+
+    //------------------------------- getters and setters ------------------------------------------
+
+    public EndpointView getMetricsMBean() {
+        return metricsMBean;
+    }
+
+    public EndpointContext getContext() {
+        return context;
+    }
+
+    public String getName() {
+        return endpointName;
+    }
+
+    public boolean isInitialized() {
+        return initialized;
+    }
+
+    public EndpointDefinition getDefinition() {
+        return definition;
+    }
+
+    public void setDefinition(EndpointDefinition definition) {
+        this.definition = definition;
+        definition.setLeafEndpoint(this);
+    }
+
+    public Endpoint getParentEndpoint() {
+        return parentEndpoint;
+    }
+
+    public void setParentEndpoint(Endpoint parentEndpoint) {
+        this.parentEndpoint = parentEndpoint;
+    }
+
+    public List<Endpoint> getChildren() {
+        return children;
+    }
+
+    public void setChildren(List<Endpoint> children) {
+        this.children = children;
+    }
+
+    public String toString() {
+        if (endpointName != null) {
+            return "Endpoint [" + endpointName + "]";
+        }
+        return SynapseConstants.ANONYMOUS_ENDPOINT;
+    }
+
+    public void setName(String endpointName) {
+        this.endpointName = endpointName;
+        // register with JMX
+        MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
+        String jmxAgentName = System.getProperty("jmx.agent.name");
+        if (jmxAgentName == null || "".equals(jmxAgentName)) {
+            jmxAgentName = "org.apache.synapse";
+        }
+        String name;
+        try {
+            name = jmxAgentName + ":Type=Endpoint,Name=" + endpointName;
+            metricsMBean = new EndpointView(endpointName, this);
+            registerMBean(mbs, metricsMBean, name);
+        } catch (Exception e) {
+            log.warn("Error registering endpoint : " + endpointName + " for JMX management", e);
+        }
+    }
+
+    //----------------------- default method implementations and common code -----------------------
+
+    public synchronized void init(ConfigurationContext cc) {
+        if (!initialized) {
+            // The check for clustering environment
+            ClusterManager clusterManager = cc.getAxisConfiguration().getClusterManager();
+            if (clusterManager != null && clusterManager.getContextManager() != null) {
+                isClusteringEnabled = Boolean.TRUE;
+            } else {
+                isClusteringEnabled = Boolean.FALSE;
+            }
+
+            context = new EndpointContext(getName(), getDefinition(), isClusteringEnabled, cc);
+        }
+        initialized = true;
+
+        if (children != null) {
+            for (Endpoint e : children) {
+                e.init(cc);
+            }
+        }
+    }
+
+    public boolean readyToSend() {
+        return !initialized || context == null || context.readyToSend();
+    }
+
+    public void send(MessageContext synCtx) {
+
+        boolean traceOn = isTraceOn(synCtx);
+        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);
+
+        prepareForEndpointStatistics(synCtx);
+
+        if (traceOrDebugOn) {
+            String address = definition.getAddress();
+            if (address == null && synCtx.getTo() != null && synCtx.getTo().getAddress() != null) {
+                // compute address for the default endpoint only for logging purposes
+                address = synCtx.getTo().getAddress();
+            }
+
+            traceOrDebug(traceOn, "Sending message through endpoint : " +
+                    getName() + " resolving to address = " + address);
+            traceOrDebug(traceOn, "SOAPAction: " + (synCtx.getSoapAction() != null ?
+                    synCtx.getSoapAction() : "null"));
+            traceOrDebug(traceOn, "WSA-Action: " + (synCtx.getWSAAction() != null ?
+                    synCtx.getWSAAction() : "null"));
+            if (traceOn && trace.isTraceEnabled()) {
+                trace.trace("Envelope : \n" + synCtx.getEnvelope());
+            }
+        }
+
+        // register this as the immediate fault handler for this message.
+        synCtx.pushFaultHandler(this);
+        // add this as the last endpoint to process this message - used by statistics counting code
+        synCtx.setProperty(SynapseConstants.LAST_ENDPOINT, this);
+        // set message level metrics collector
+        ((Axis2MessageContext) synCtx).getAxis2MessageContext().setProperty(
+            BaseConstants.METRICS_COLLECTOR, metricsMBean);
+        // Send the message through this endpoint
+        synCtx.getEnvironment().send(definition, synCtx);
+    }
+
+    /**
+     * Is this a leaf level endpoint? or parent endpoint that has children?
+     * @return
+     */
+    public boolean isLeafEndpoint() {
+        return children == null || children.size() == 0;
+    }
+
+    public void onChildEndpointFail(Endpoint endpoint, MessageContext synMessageContext) {
+        // do nothing, the LB/FO endpoints will override this
+    }
+
+    /**
+     * Is this [fault] message a timeout?
+     * @param synCtx the current fault message
+     * @return true if this is defined as a timeout
+     */
+    protected boolean isTimeout(MessageContext synCtx) {
+        Integer errorCode = (Integer) synCtx.getProperty(SynapseConstants.ERROR_CODE);
+        if (errorCode != null) {
+            if (definition.getTimeoutErrorCodes().isEmpty()) {
+                // if timeout codes are not defined, assume only HTTP timeout and connection close
+                boolean isTimeout = SynapseConstants.NHTTP_CONNECTION_TIMEOUT == errorCode;
+                boolean isClosed = SynapseConstants.NHTTP_CONNECTION_CLOSED == errorCode;
+                
+                if (isTimeout || isClosed) {
+
+                    if (log.isDebugEnabled()) {
+                        log.debug("Encountered a default HTTP connection " +
+                                (isClosed ? "close" : "timeout") + " error : " + errorCode);
+                    }
+                    return true;
+                }
+            } else {
+                if (definition.getTimeoutErrorCodes().contains(errorCode)) {
+                    if (log.isDebugEnabled()) {
+                        log.debug("Encountered a mark for suspension error : " + errorCode + " defined " +
+                            "error codes are : " + definition.getTimeoutErrorCodes());    
+                    }
+                    return true;
+                }
+            }
+        }
+
+        if (log.isDebugEnabled()) {
+            log.debug("Encountered a non-timeout error sending to endpoint : " + endpointName +
+                " error code : " + errorCode);
+        }
+        return false;
+    }
+
+    /**
+     * Is this a fault that should put the endpoint on SUSPEND? or is this a fault to ignore?
+     * @param synCtx the current fault message
+     * @return true if this fault should suspend the endpoint
+     */
+    protected boolean isSuspendFault(MessageContext synCtx) {
+        Integer errorCode = (Integer) synCtx.getProperty(SynapseConstants.ERROR_CODE);
+        if (errorCode != null) {
+            if (definition.getSuspendErrorCodes().isEmpty()) {
+                // if suspend codes are not defined, any error will be fatal for the endpoint
+                if (log.isDebugEnabled()) {
+                    log.debug("Endpoint : " + endpointName + " encountered a fatal error : " + errorCode);
+                }
+                return true;
+
+            } else {
+                if (definition.getSuspendErrorCodes().contains(errorCode)) {
+                    if (log.isDebugEnabled()) {
+                        log.debug("Encountered a suspend error : " + errorCode +
+                            " defined suspend codes are : " + definition.getSuspendErrorCodes());
+                    }
+                    return true;
+                }
+            }
+        }
+
+        if (log.isDebugEnabled()) {
+            log.debug("Encountered a non-fatal error sending to endpoint : " + endpointName +
+                " error code : " + errorCode + " Error will be handled, but endpoint will not fail");
+        }
+        return false;
+    }
+
+    /**
+     * On a fault, propagate to parent if any, or call into the fault handler
+     * @param synCtx the message at hand
+     */
+    public void onFault(MessageContext synCtx) {
+        Stack faultStack = synCtx.getFaultStack();
+        if (!faultStack.isEmpty()) {
+            Object faultHandler = faultStack.pop();
+            if (faultHandler instanceof Endpoint) {
+                // This is the parent . need to inform parent with fault child
+                ((Endpoint) faultHandler).onChildEndpointFail(this, synCtx);
+            } else {
+                ((FaultHandler) faultHandler).handleFault(synCtx);
+            }
+        }
+    }
+
+    /**
+     * The SynapseCallback Receiver notifies an endpoint, if a message was successfully processed
+     * to give it a chance to clear up or reset its state to active
+     */
+    public void onSuccess() {
+        // do nothing
+    }
+
+
+    /**
+     * Should this mediator perform tracing? True if its explicitly asked to
+     * trace, or its parent has been asked to trace and it does not reject it
+     *
+     * @param msgCtx the current message
+     * @return true if tracing should be performed
+     */
+    protected boolean isTraceOn(MessageContext msgCtx) {
+        return definition != null &&
+               ((definition.getTraceState() == SynapseConstants.TRACING_ON) ||
+                (definition.getTraceState() == SynapseConstants.TRACING_UNSET &&
+                    msgCtx.getTracingState() == SynapseConstants.TRACING_ON));
+    }
+
+    /**
+     * Is tracing or debug logging on?
+     *
+     * @param isTraceOn is tracing known to be on?
+     * @return true, if either tracing or debug logging is on
+     */
+    protected boolean isTraceOrDebugOn(boolean isTraceOn) {
+        return isTraceOn || log.isDebugEnabled();
+    }
+
+    /**
+     * Perform Trace and Debug logging of a message @INFO (trace) and DEBUG (log)
+     *
+     * @param traceOn is runtime trace on for this message?
+     * @param msg     the message to log/trace
+     */
+    protected void traceOrDebug(boolean traceOn, String msg) {
+        if (traceOn) {
+            trace.info(msg);
+        }
+        if (log.isDebugEnabled()) {
+            log.debug(msg);
+        }
+    }
+
+    /**
+     * Process statistics for this message
+     * @param synCtx the current message
+     */
+    protected void prepareForEndpointStatistics(MessageContext synCtx) {
+    // Setting Required property to collect the End Point audit
+        if (definition != null && definition.isStatisticsEnable()) {
+            StatisticsReporter.collect(synCtx, definition);
+        }
+    }
+
+    /**
+     * Helper methods to handle errors.
+     *
+     * @param msg The error message
+     */
+    protected void handleException(String msg) {
+        log.error(msg);
+        throw new SynapseException(msg);
+    }
+
+    /**
+     * Helper methods to handle errors.
+     *
+     * @param msg The error message
+     * @param e   The exception
+     */
+    protected void handleException(String msg, Exception e) {
+        log.error(msg, e);
+        throw new SynapseException(msg, e);
+    }
+
+    /**
+     * Utiliry method to register an MBean
+     * @param mbs server
+     * @param mbeanInstance bean
+     * @param objectName name
+     */
+    private void registerMBean(MBeanServer mbs, Object mbeanInstance, String objectName) {
+        try {
+            ObjectName name = new ObjectName(objectName);
+            Set set = mbs.queryNames(name, null);
+            if (set != null && set.isEmpty()) {
+                mbs.registerMBean(mbeanInstance, name);
+            } else {
+                mbs.unregisterMBean(name);
+                mbs.registerMBean(mbeanInstance, name);
+            }
+        } catch (Exception e) {
+            log.warn("Error registering a MBean with objectname ' " + objectName +
+                " ' for JMX management", e);
+        }
+    }
+}
diff --git a/java/modules/core/src/main/java/org/apache/synapse/endpoints/AddressEndpoint.java b/java/modules/core/src/main/java/org/apache/synapse/endpoints/AddressEndpoint.java
index f78666472..8b57da9f6 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/endpoints/AddressEndpoint.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/endpoints/AddressEndpoint.java
@@ -24,166 +24,33 @@ import org.apache.axis2.context.ConfigurationContext;
 import org.apache.synapse.MessageContext;
 import org.apache.synapse.SynapseConstants;
 import org.apache.synapse.core.axis2.Axis2MessageContext;
-import org.apache.synapse.endpoints.utils.EndpointDefinition;
-import org.apache.synapse.audit.statistics.StatisticsReporter;
+import org.apache.synapse.endpoints.EndpointDefinition;
 
 /**
  * This class represents an actual endpoint to send the message. It is responsible for sending the
  * message, performing retries if a failure occurred and informing the parent endpoint if a failure
  * couldn't be recovered.
  */
-public class AddressEndpoint extends DefaultEndpoint {
+public class AddressEndpoint extends AbstractEndpoint {
 
-    /**
-     * The endpoint context , place holder for keep any runtime states related to the endpoint
-     */
-    private final EndpointContext endpointContext = new EndpointContext();
-
-    /**
-     * Checks if the endpoint is active (failed or not). If endpoint is in failed state and
-     * suspendOnFailDuration has elapsed, it will be set to active.
-     *
-     * @param synMessageContext MessageContext of the current message. This is not used here.
-     * @return true if endpoint is active. false otherwise.
-     */
-    public boolean isActive(MessageContext synMessageContext) {
-
-        boolean active = endpointContext.isActive();
-        if (!active) {
-
-            long recoverOn = endpointContext.getRecoverOn();
-            if (System.currentTimeMillis() > recoverOn) {
-                active = true;
-                endpointContext.setActive(true);
-                endpointContext.setRecoverOn(0);                       
-
-            }
-        }
-
-        if (log.isDebugEnabled()) {
-            log.debug("AddressEndpoint with name '" + getName() + "' is in "
-                    + (active ? "active" : "inactive") + " state");
-        }
-
-        return active;
-    }
-
-    /**
-     * Sets if endpoint active or not. if endpoint is set as failed (active = false), the recover on
-     * time is calculated so that it will be activated after the recover on time.
-     *
-     * @param active            true if active. false otherwise.
-     * @param synMessageContext MessageContext of the current message. This is not used here.
-     */
-    public synchronized void setActive(boolean active, MessageContext synMessageContext) {
-
-        // this is synchronized as recoverOn can be set to unpredictable values if two threads call
-        // this method simultaneously.
-
-        if (!active) {
-            EndpointDefinition endpoint = getEndpoint();
-            if (endpoint.getSuspendOnFailDuration() != -1) {
-                // Calculating a new value by adding suspendOnFailDuration to current time.
-                // as the endpoint is set as failed
-                endpointContext.setRecoverOn(
-                        System.currentTimeMillis() + endpoint.getSuspendOnFailDuration());
-            } else {
-                endpointContext.setRecoverOn(Long.MAX_VALUE);
-            }
-        }
-
-        this.endpointContext.setActive(active);
-    }
-
-    /**
-     * Sends the message through this endpoint. This method just handles statistics related
-     * functions and gives the message to the Synapse environment to send. It does not add any
-     * endpoint specific details to the message context. These details are added only to the cloned
-     * message context by the Axis2FlexibleMepClient. So that we can reuse the original message
-     * context for resending through different endpoints.
-     *
-     * @param synCtx MessageContext sent by client to Synapse
-     */
-    public void send(MessageContext synCtx) {
-
-        boolean traceOn = isTraceOn(synCtx);
-        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);
-
-        if (traceOrDebugOn) {
-            traceOrDebug(traceOn, "Start : Address Endpoint");
-
-            if (traceOn && trace.isTraceEnabled()) {
-                trace.trace("Message : " + synCtx.getEnvelope());
-            }
-        }
-
-        boolean isClusteringEnable = false;
-        // get Axis2 MessageContext and ConfigurationContext
-        org.apache.axis2.context.MessageContext axisMC =
-                ((Axis2MessageContext) synCtx).getAxis2MessageContext();
-        ConfigurationContext cc = axisMC.getConfigurationContext();
-
-        //The check for clustering environment
-
-        ClusterManager clusterManager = cc.getAxisConfiguration().getClusterManager();
-        if (clusterManager != null &&
-                clusterManager.getContextManager() != null) {
-            isClusteringEnable = true;
-        }
-
-        String endPointName = this.getName();
-        if (endPointName == null) {
-
-            if (traceOrDebugOn && isClusteringEnable) {
-                log.warn(SALoadbalanceEndpoint.WARN_MESSAGE);
-            }
-            endPointName = SynapseConstants.ANONYMOUS_ENDPOINT;
-        }
-
-        if (isClusteringEnable) {
-
-            // if this is a cluster environment , then set configuration context to endpoint context
-            if (endpointContext.getConfigurationContext() == null) {
-                endpointContext.setConfigurationContext(cc);
-                endpointContext.setContextID(endPointName); // The context ID
-            }
-        }
-
-        EndpointDefinition endpoint = getEndpoint();
-        // Setting Required property to collect the End Point audit
-        if (isStatisticsEnable()) {
-            StatisticsReporter.collect(synCtx, this);
-        }
-
-        if (endpoint.getAddress() != null) {
-            if (traceOrDebugOn) {
-                traceOrDebug(traceOn, "Sending message to endpoint : " +
-                        endPointName + " resolves to address = " + endpoint.getAddress());
-                traceOrDebug(traceOn, "SOAPAction: " + (synCtx.getSoapAction() != null ?
-                        synCtx.getSoapAction() : "null"));
-                traceOrDebug(traceOn, "WSA-Action: " + (synCtx.getWSAAction() != null ?
-                        synCtx.getWSAAction() : "null"));
+    public void onFault(MessageContext synCtx) {
 
-                if (traceOn && trace.isTraceEnabled()) {
-                    trace.trace("Envelope : \n" + synCtx.getEnvelope());
-                }
-            }
+        // is this really a fault or a timeout/connection close etc?
+        if (isTimeout(synCtx)) {
+            getContext().onTimeout();
+        } else if (isSuspendFault(synCtx)) {
+            getContext().onFault();
         }
 
-        // register this as the immediate fault handler for this message.
-        synCtx.pushFaultHandler(this);
-
-        // add this as the last endpoint to process this message. it is used by audit code.
-        synCtx.setProperty(SynapseConstants.PROCESSED_ENDPOINT, this);
-
-        synCtx.getEnvironment().send(endpoint, synCtx);
+        // this should be an ignored error if we get here
+        synCtx.setProperty(SynapseConstants.ERROR_CODE, null);
+        synCtx.setProperty(SynapseConstants.ERROR_MESSAGE, null);
+        synCtx.setProperty(SynapseConstants.ERROR_DETAIL, null);
+        synCtx.setProperty(SynapseConstants.ERROR_EXCEPTION, null);
+        super.onFault(synCtx);
     }
 
-    public void onFault(MessageContext synCtx) {
-        // perform retries here
-
-        // if this endpoint has actually failed, inform the parent.
-        setActive(false, synCtx);
-        super.onFault(synCtx);
+    public void onSuccess() {
+        getContext().onSuccess();
     }
 }
diff --git a/java/modules/core/src/main/java/org/apache/synapse/endpoints/DefaultEndpoint.java b/java/modules/core/src/main/java/org/apache/synapse/endpoints/DefaultEndpoint.java
index dde6ad0e5..12fe9b245 100755
--- a/java/modules/core/src/main/java/org/apache/synapse/endpoints/DefaultEndpoint.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/endpoints/DefaultEndpoint.java
@@ -19,226 +19,14 @@
 
 package org.apache.synapse.endpoints;
 
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.synapse.FaultHandler;
 import org.apache.synapse.MessageContext;
 import org.apache.synapse.SynapseConstants;
-import org.apache.synapse.endpoints.utils.EndpointDefinition;
-import org.apache.synapse.audit.AuditConfigurable;
-import org.apache.synapse.audit.statistics.StatisticsReporter;
-import org.apache.synapse.audit.AuditConfiguration;
-
-
-import java.util.Stack;
 
 /**
- * This class represents an endpoint with epr as addressing to header of the message. It is
- * responsible for sending the message to the epr specified in the message To header, performing
- * retries if a failure occurred and informing the parent endpoint if a failure couldn't be
- * recovered.
+ * This class represents an endpoint with the EPR as the 'To' header of the message. It is
+ * responsible for sending the message to this EPR, performing retries etc on failure and
+ * using any QOS etc as specified
  */
-public class DefaultEndpoint extends FaultHandler implements Endpoint, AuditConfigurable{
-
-    protected Log log;
-    
-    protected static final Log trace = LogFactory.getLog(SynapseConstants.TRACE_LOGGER);
-
-    /**
-     * Name of the endpoint. Used for named endpoints which can be referred using the key attribute
-     * of indirect endpoints.
-     */
-    private String name = null;
-
-    /**
-     * Stores the endpoint details for this endpoint. Details include EPR, WS-Addressing
-     * information, WS-Security information, etc.
-     */
-    private EndpointDefinition endpoint = null;
-
-    /**
-     * Parent endpoint of this endpoint if this used inside another endpoint. Possible parents are
-     * LoadbalanceEndpoint, SALoadbalanceEndpoint and FailoverEndpoint objects.
-     */
-    private Endpoint parentEndpoint = null;
-
-    private final AuditConfigurable auditConfigurable = new AuditConfiguration(SynapseConstants.ANONYMOUS_ENDPOINT);
-
-    public DefaultEndpoint() {
-        log = LogFactory.getLog(this.getClass());
-    }
-
-    public EndpointDefinition getEndpoint() {
-        return endpoint;
-    }
-
-    public void setEndpoint(EndpointDefinition endpoint) {
-        this.endpoint = endpoint;
-    }
-
-    public String getName() {
-        return name;
-    }
-
-    public void setName(String name) {
-        this.name = name.trim();
-        this.auditConfigurable.setAuditId(this.name);
-    }
-
-    /**
-     * This will always return true, because the endpoint epr is dependent on the message being
-     * processed
-     *
-     * @param synMessageContext not being used
-     * @return true
-     */
-    public boolean isActive(MessageContext synMessageContext) {
-        return true;
-    }
-
-    /**
-     * since this is a virtual representation of an endpoint and the epr changes from message
-     * to message setting active state doesn't have a meaning
-     *
-     * @param active            not being used
-     * @param synMessageContext not being used
-     */
-    public synchronized void setActive(boolean active, MessageContext synMessageContext) {
-        // no implementation according to the behavior
-    }
-
-    /**
-     * Sends the message through this endpoint. This method just handles statistics related
-     * functions and gives the message to the Synapse environment to send. It does not add any
-     * endpoint specific details to the message context. These details are added only to the cloned
-     * message context by the Axis2FlexibleMepClient. So that we can reuse the original message
-     * context for resending through different endpoints.
-     *
-     * @param synCtx MessageContext sent by client to Synapse
-     */
-    public void send(MessageContext synCtx) {
-
-        boolean traceOn = isTraceOn(synCtx);
-        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);
-
-        if (traceOrDebugOn) {
-            traceOrDebug(traceOn, "Start : Default Endpoint");
-
-            if (traceOn && trace.isTraceEnabled()) {
-                trace.trace("Message : " + synCtx.getEnvelope());
-            }
-        }
-
-        String endPointName = this.getName();
-        if (endPointName == null) {
-            endPointName = SynapseConstants.ANONYMOUS_ENDPOINT;
-        }
-
-        // Setting Required property to collect the End Point audit
-        if (isStatisticsEnable()) {
-            StatisticsReporter.collect(synCtx, this);
-        }
-
-        if (synCtx.getTo() != null && synCtx.getTo().getAddress() != null) {
-            if (traceOrDebugOn) {
-                traceOrDebug(traceOn, "Sending message to endpoint : " +
-                        endPointName + " resolves to address = " + synCtx.getTo().getAddress());
-                traceOrDebug(traceOn, "SOAPAction: " + (synCtx.getSoapAction() != null ?
-                        synCtx.getSoapAction() : "null"));
-                traceOrDebug(traceOn, "WSA-Action: " + (synCtx.getWSAAction() != null ?
-                        synCtx.getWSAAction() : "null"));
-
-                if (traceOn && trace.isTraceEnabled()) {
-                    trace.trace("Envelope : \n" + synCtx.getEnvelope());
-                }
-            }
-        }
-
-        // register this as the immediate fault handler for this message.
-        synCtx.pushFaultHandler(this);
-
-        // add this as the last endpoint to process this message. it is used by audit code.
-        synCtx.setProperty(SynapseConstants.PROCESSED_ENDPOINT, this);
-
-        synCtx.getEnvironment().send(endpoint, synCtx);
-    }
-
-    public void onChildEndpointFail(Endpoint endpoint, MessageContext synMessageContext) {
-        // nothing to do as this is a leaf level endpoint
-    }
-
-    public void setParentEndpoint(Endpoint parentEndpoint) {
-        this.parentEndpoint = parentEndpoint;
-    }
-
-    public void onFault(MessageContext synCtx) {
-        // perform retries here
-
-        if (parentEndpoint != null) {
-            parentEndpoint.onChildEndpointFail(this, synCtx);
-        } else {
-            Stack faultStack = synCtx.getFaultStack();
-            if (!faultStack.isEmpty()) {
-                ((FaultHandler) faultStack.pop()).handleFault(synCtx);
-            }
-        }
-    }
-
-    /**
-     * Should this mediator perform tracing? True if its explicitly asked to
-     * trace, or its parent has been asked to trace and it does not reject it
-     *
-     * @param msgCtx the current message
-     * @return true if tracing should be performed
-     */
-    protected boolean isTraceOn(MessageContext msgCtx) {
-        return (endpoint.getTraceState() == SynapseConstants.TRACING_ON) ||
-                (endpoint.getTraceState() == SynapseConstants.TRACING_UNSET &&
-                        msgCtx.getTracingState() == SynapseConstants.TRACING_ON);
-    }
-
-    /**
-     * Is tracing or debug logging on?
-     *
-     * @param isTraceOn is tracing known to be on?
-     * @return true, if either tracing or debug logging is on
-     */
-    protected boolean isTraceOrDebugOn(boolean isTraceOn) {
-        return isTraceOn || log.isDebugEnabled();
-    }
-
-    /**
-     * Perform Trace and Debug logging of a message @INFO (trace) and DEBUG (log)
-     *
-     * @param traceOn is runtime trace on for this message?
-     * @param msg     the message to log/trace
-     */
-    protected void traceOrDebug(boolean traceOn, String msg) {
-        if (traceOn) {
-            trace.info(msg);
-        }
-        if (log.isDebugEnabled()) {
-            log.debug(msg);
-        }
-    }
-
-    public boolean isStatisticsEnable() {
-        return this.auditConfigurable.isStatisticsEnable();
-    }
-
-    public void disableStatistics() {
-        this.auditConfigurable.disableStatistics();
-    }
-
-    public void enableStatistics() {
-        this.auditConfigurable.disableStatistics();
-    }
-
-    public String getAuditId() {
-        return this.auditConfigurable.getAuditId();
-    }
-
-    public void setAuditId(String id) {
-        this.auditConfigurable.setAuditId(id);
-    }
+public class DefaultEndpoint extends AbstractEndpoint {
+    // do nothing :)!
 }
diff --git a/java/modules/core/src/main/java/org/apache/synapse/endpoints/DynamicLoadbalanceEndpoint.java b/java/modules/core/src/main/java/org/apache/synapse/endpoints/DynamicLoadbalanceEndpoint.java
index 89fce05ea..453258b8e 100755
--- a/java/modules/core/src/main/java/org/apache/synapse/endpoints/DynamicLoadbalanceEndpoint.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/endpoints/DynamicLoadbalanceEndpoint.java
@@ -29,7 +29,6 @@ import org.apache.synapse.SynapseException;
 import org.apache.synapse.core.LoadBalanceMembershipHandler;
 import org.apache.synapse.core.axis2.Axis2MessageContext;
 import org.apache.synapse.endpoints.algorithms.AlgorithmContext;
-import org.apache.synapse.endpoints.utils.EndpointDefinition;
 
 import java.net.MalformedURLException;
 import java.net.URL;
@@ -40,113 +39,114 @@ import java.net.URL;
  */
 public class DynamicLoadbalanceEndpoint extends LoadbalanceEndpoint {
 
-    private static final Log log = LogFactory.getLog(DynamicLoadbalanceEndpoint.class);
-
-    /**
-     * The algorithm context , place holder for keep any runtime states related to the load balance
-     * algorithm
-     */
-    private final AlgorithmContext algorithmContext = new AlgorithmContext();
-
-    private LoadBalanceMembershipHandler lbMembershipHandler;
-
-    public DynamicLoadbalanceEndpoint() {
-    }
-
-    public void setLoadBalanceMembershipHandler(LoadBalanceMembershipHandler lbMembershipHandler) {
-        this.lbMembershipHandler = lbMembershipHandler;
-    }
-
-    public void send(MessageContext synCtx) {
-        EndpointReference to = synCtx.getTo();
-        DynamicLoadbalanceFaultHandler faultHandler = new DynamicLoadbalanceFaultHandler(to);
-        if (failover) {
-            synCtx.pushFaultHandler(faultHandler);
-        }
-        ConfigurationContext configCtx =
-                ((Axis2MessageContext) synCtx).getAxis2MessageContext().getConfigurationContext();
-        if (lbMembershipHandler.getConfigurationContext() == null) {
-            lbMembershipHandler.setConfigurationContext(configCtx);
-        }
-        algorithmContext.setConfigurationContext(configCtx);
-        sendToApplicationMember(synCtx, to, faultHandler);
-    }
-
-    public void setName(String name) {
-        super.setName(name);
-        algorithmContext.setContextID(name);
-    }
-
-    private void sendToApplicationMember(MessageContext synCtx,
-                                         EndpointReference to,
-                                         DynamicLoadbalanceFaultHandler faultHandler) {
-        org.apache.axis2.context.MessageContext axis2MsgCtx =
-                ((Axis2MessageContext) synCtx).getAxis2MessageContext();
-
-        String transport = axis2MsgCtx.getTransportIn().getName();
-        Member currentMember =
-                lbMembershipHandler.getNextApplicationMember(algorithmContext);
-        faultHandler.setCurrentMember(currentMember);
-        if (currentMember != null) {
-
-            // URL rewrite
-            if (transport.equals("http") || transport.equals("https")) {
-                String address = to.getAddress();
-                if (address.indexOf(":") != -1) {
-                    try {
-                        address = new URL(address).getPath();
-                    } catch (MalformedURLException e) {
-                        String msg = "URL " + address + " is malformed";
-                        log.error(msg, e);
-                        throw new SynapseException(msg, e);
-                    }
-                }
-                EndpointReference epr =
-                        new EndpointReference(transport + "://" + currentMember.getHostName() +
-                                              ":" + currentMember.getHttpPort() + address);
-                synCtx.setTo(epr);
-                if (failover) {
-                    synCtx.getEnvelope().build();
-                }
-
-                AddressEndpoint endpoint = new AddressEndpoint();
-                EndpointDefinition definition = new EndpointDefinition();
-                endpoint.setEndpoint(definition);
-                endpoint.send(synCtx);
-            } else {
-                log.error("Cannot load balance for non-HTTP/S transport " + transport);
-            }
-        } else {
-            synCtx.getFaultStack().pop(); // Remove the DynamicLoadbalanceFaultHandler
-            String msg = "No application members available";
-            log.error(msg);
-            throw new SynapseException(msg);
-        }
-    }
-
-    /**
-     * This FaultHandler will try to resend the message to another member if an error occurs
-     * while sending to some member. This is a failover mechanism
-     */
-    private class DynamicLoadbalanceFaultHandler extends FaultHandler {
-
-        private EndpointReference to;
-        private Member currentMember;
-
-        public void setCurrentMember(Member currentMember) {
-            this.currentMember = currentMember;
-        }
-
-        private DynamicLoadbalanceFaultHandler(EndpointReference to) {
-            this.to = to;
-        }
-
-        public void onFault(MessageContext synCtx) {
-            if (currentMember == null) {
-                return;
-            }
-            synCtx.pushFaultHandler(this);
-            sendToApplicationMember(synCtx, to, this);
-        }
-    }
+//    TODO FIX-RUWAN
+//    private static final Log log = LogFactory.getLog(DynamicLoadbalanceEndpoint.class);
+//
+//    /**
+//     * The algorithm context , place holder for keep any runtime states related to the load balance
+//     * algorithm
+//     */
+//    private final AlgorithmContext algorithmContext = new AlgorithmContext();
+//
+//    private LoadBalanceMembershipHandler lbMembershipHandler;
+//
+//    public DynamicLoadbalanceEndpoint() {
+//    }
+//
+//    public void setLoadBalanceMembershipHandler(LoadBalanceMembershipHandler lbMembershipHandler) {
+//        this.lbMembershipHandler = lbMembershipHandler;
+//    }
+//
+//    public void send(MessageContext synCtx) {
+//        EndpointReference to = synCtx.getTo();
+//        DynamicLoadbalanceFaultHandler faultHandler = new DynamicLoadbalanceFaultHandler(to);
+//        if (failover) {
+//            synCtx.pushFaultHandler(faultHandler);
+//        }
+//        ConfigurationContext configCtx =
+//                ((Axis2MessageContext) synCtx).getAxis2MessageContext().getConfigurationContext();
+//        if (lbMembershipHandler.getConfigurationContext() == null) {
+//            lbMembershipHandler.setConfigurationContext(configCtx);
+//        }
+//        algorithmContext.setConfigurationContext(configCtx);
+//        sendToApplicationMember(synCtx, to, faultHandler);
+//    }
+//
+//    public void setName(String name) {
+//        super.setName(name);
+//        algorithmContext.setContextID(name);
+//    }
+//
+//    private void sendToApplicationMember(MessageContext synCtx,
+//                                         EndpointReference to,
+//                                         DynamicLoadbalanceFaultHandler faultHandler) {
+//        org.apache.axis2.context.MessageContext axis2MsgCtx =
+//                ((Axis2MessageContext) synCtx).getAxis2MessageContext();
+//
+//        String transport = axis2MsgCtx.getTransportIn().getName();
+//        Member currentMember =
+//                lbMembershipHandler.getNextApplicationMember(algorithmContext);
+//        faultHandler.setCurrentMember(currentMember);
+//        if (currentMember != null) {
+//
+//            // URL rewrite
+//            if (transport.equals("http") || transport.equals("https")) {
+//                String address = to.getAddress();
+//                if (address.indexOf(":") != -1) {
+//                    try {
+//                        address = new URL(address).getPath();
+//                    } catch (MalformedURLException e) {
+//                        String msg = "URL " + address + " is malformed";
+//                        log.error(msg, e);
+//                        throw new SynapseException(msg, e);
+//                    }
+//                }
+//                EndpointReference epr =
+//                        new EndpointReference(transport + "://" + currentMember.getHostName() +
+//                                              ":" + currentMember.getHttpPort() + address);
+//                synCtx.setTo(epr);
+//                if (failover) {
+//                    synCtx.getEnvelope().build();
+//                }
+//
+//                AddressEndpoint endpoint = new AddressEndpoint();
+//                EndpointDefinition definition = new EndpointDefinition();
+//                endpoint.setEndpoint(definition);
+//                endpoint.send(synCtx);
+//            } else {
+//                log.error("Cannot load balance for non-HTTP/S transport " + transport);
+//            }
+//        } else {
+//            synCtx.getFaultStack().pop(); // Remove the DynamicLoadbalanceFaultHandler
+//            String msg = "No application members available";
+//            log.error(msg);
+//            throw new SynapseException(msg);
+//        }
+//    }
+//
+//    /**
+//     * This FaultHandler will try to resend the message to another member if an error occurs
+//     * while sending to some member. This is a failover mechanism
+//     */
+//    private class DynamicLoadbalanceFaultHandler extends FaultHandler {
+//
+//        private EndpointReference to;
+//        private Member currentMember;
+//
+//        public void setCurrentMember(Member currentMember) {
+//            this.currentMember = currentMember;
+//        }
+//
+//        private DynamicLoadbalanceFaultHandler(EndpointReference to) {
+//            this.to = to;
+//        }
+//
+//        public void onFault(MessageContext synCtx) {
+//            if (currentMember == null) {
+//                return;
+//            }
+//            synCtx.pushFaultHandler(this);
+//            sendToApplicationMember(synCtx, to, this);
+//        }
+//    }
 }
diff --git a/java/modules/core/src/main/java/org/apache/synapse/endpoints/Endpoint.java b/java/modules/core/src/main/java/org/apache/synapse/endpoints/Endpoint.java
index bc6197b55..d9a7521fc 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/endpoints/Endpoint.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/endpoints/Endpoint.java
@@ -20,6 +20,9 @@
 package org.apache.synapse.endpoints;
 
 import org.apache.synapse.MessageContext;
+import org.apache.axis2.context.ConfigurationContext;
+
+import java.util.List;
 
 /**
  * Endpoint defines the behavior common to all Synapse endpoints. Synapse endpoints should be able
@@ -74,25 +77,44 @@ public interface Endpoint {
     public void setName(String name);
 
     /**
-     * Returns if the endpoint is currently active or not. Messages should not be sent to inactive
-     * endpoints.
-     *
-     * @param synMessageContext MessageContext for the current message. This is required for
-     *                          IndirectEndpoints where the actual endpoint is retrieved from the MessageContext. Other
-     *                          Endpoint implementations may ignore this parameter.
-     * @return true if the endpoint is in active state. false otherwise.
+     * An event notification whenever endpoint invocation is successful
+     * Can be used to clear a timeout status etc
      */
-    public boolean isActive(MessageContext synMessageContext);
+    public void onSuccess();
 
     /**
-     * Sets the endpoint as active or inactive. If an endpoint is detected as failed, it should be
-     * set as inactive. But endpoints may be eventually set as active by the endpoint refresher to
-     * avoid ignoring endpoints forever.
-     *
-     * @param active            true if active. false otherwise.
-     * @param synMessageContext MessageContext for the current message. This is required for
-     *                          IndirectEndpoints where the actual endpoint is retrieved from the MessageContext. Other
-     *                          Endpoint implementations may ignore this parameter.
+     * Returns true to indicate that the endpoint is ready to service requests
+     * @return true if endpoint is ready to service requests
+     */
+    public boolean readyToSend();
+
+    /**
+     * Initialize the endpoint, using this configuration context
+     * @param cc the axis2 configuration context
+     */
+    public void init(ConfigurationContext cc);
+
+    /**
+     * Has this Endpoint initialized?
+     * @return true if the endpoint is initialized
+     */
+    public boolean isInitialized();
+
+    /**
+     * Get the EndpointContext that has the run-time state of this endpoint
+     * @return the runtime context
+     */
+    public EndpointContext getContext();
+
+    /**
+     * Get the children of this endpoint
+     * @return the child endpoints
+     */
+    public List<Endpoint> getChildren();
+
+    /**
+     * Get a reference to the metrics MBean for this endpoint
+     * @return
      */
-    public void setActive(boolean active, MessageContext synMessageContext);
+    public EndpointView getMetricsMBean();
 }
diff --git a/java/modules/core/src/main/java/org/apache/synapse/endpoints/EndpointContext.java b/java/modules/core/src/main/java/org/apache/synapse/endpoints/EndpointContext.java
index 10ae64ef2..c23539330 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/endpoints/EndpointContext.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/endpoints/EndpointContext.java
@@ -18,204 +18,445 @@
 */
 package org.apache.synapse.endpoints;
 
+import org.apache.axis2.clustering.ClusteringFault;
+import org.apache.axis2.clustering.context.Replicator;
 import org.apache.axis2.context.ConfigurationContext;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 import org.apache.synapse.SynapseException;
-import org.apache.synapse.util.Replicator;
+import org.apache.synapse.SynapseConstants;
+import org.apache.synapse.endpoints.EndpointDefinition;
+
+import java.util.Date;
 
 /**
- * Keeps the states of the endpoint.This hides where those states are kept .For a cluster
- * environment,all states are kept in the axis2 configuration context in order to replicate those
- * states so that other synapse instance in the same cluster can see those changes . This class can
- * be evolved to keep any run time states related to the endpoint .For a non-clustered environment,
- * all data are kept locally.
- * <p/>
- * This class provide the abstraction need to separate the dynamic data from the static data and
- * improve the  high cohesion and provides capability to replicate only required state at
- * a given time. This improves the performance when replicate data.
+ * This class is one of the key classes of the Endpoint management in Synapse. It maintains the
+ * runtime state of an endpoint for local and clustered endpoint configurations.
  */
 public class EndpointContext {
 
     private static final Log log = LogFactory.getLog(EndpointContext.class);
 
-    /* The  static constant only for construct key prefix for each property in endpoint context
-     * as it is need when those property state going to replicate in a cluster env. */
-    private static final String ACTIVE = "active";
-    private static final String RECOVER_ON = "recover_on";
-    private static final String UNDERSCORE_STRING = "_";
-
-    /* Determines if this endpoint is active or not. This variable have to be loaded always from the
-     * memory as multiple threads could access it.*/
-    private boolean active = true;
+    private static final String KEY_PREFIX = "synapse.endpoint.";
+    private static final String STATE = ".state";
+    private static final String NEXT_RETRY_TIME = ".next_retry_time";
+    private static final String REMAINING_RETRIES = ".remaining_retries";
+    private static final String LAST_SUSPEND_DURATION = ".last_suspend_duration";
+
+    // The different states an endpoint could exist at any point in time
+    /** And active endpoint known to be functioning properly */
+    public static final int ST_ACTIVE      = 1;
+    /** An endpoint which timed out - but now maybe ready to retry depending on the current time */
+    public static final int ST_TIMEOUT     = 2;
+    /** An endpoint put into the suspended state by the system. Will retry after an applicable delay */
+    public static final int ST_SUSPENDED   = 3;
+    /** An endpoint manually switched off into maintenence - it will never change state automatically */
+    public static final int ST_OFF = 4;
+
+    /** The state of the endpoint at present */
+    private int  localState = ST_ACTIVE;
+    /** The time in ms, until the next retry - depending on a timeout or suspension */
+    private long localNextRetryTime = -1;
+    /** The number of attempts left for timeout failures, until they make the endpoint suspended */
+    private int  localRemainingRetries = -1;
+    /** The duration in ms for the last suspension */
+    private long localLastSuspendDuration = -1;
+
+    /** Is the environment clustered ? */
+    private boolean isClustered = false;
+    /** Name of the endpoint - mainly for logging */
+    private String endpointName = SynapseConstants.ANONYMOUS_ENDPOINT;
+    /** The Axis2 configuration context - to replicate state in a cluster */
+    private ConfigurationContext cfgCtx = null;
+    /** The endpoint definition that holds static endpoint information */
+    private EndpointDefinition definition = null;
+
+    // for clustered mode operation, keys pre-computed and used for replication
+    private final String STATE_KEY;
+    private final String NEXT_RETRY_TIME_KEY;
+    private final String REMAINING_RETRIES_KEY;
+    private final String LAST_SUSPEND_DURATION_KEY;
 
-    /* Time to recover a failed endpoint.*/
-    private long recoverOn = Long.MAX_VALUE;
+    /**
+     * Create an EndpointContext to hold runtime state of an Endpoint
+     * @param endpointName the name of the endpoint (mainly for logging)
+     * @param endpointDefinition the definition of the endpoint (e.g. retry time, suspend duration..)
+     * @param clustered is the environment clustered?
+     * @param cfgCtx the Axis2 configurationContext for clustering
+     */
+    public EndpointContext(String endpointName, EndpointDefinition endpointDefinition,
+        boolean clustered, ConfigurationContext cfgCtx) {
 
-    /* The axis configuration context-  this will hold the all callers states
-     * when doing throttling in a clustered environment. */
-    private ConfigurationContext configCtx;
+        if (clustered) {
+            if (endpointName == null) {
+                handleException("For proper clustered mode operation, all endpoints should be uniquely named");
+            }
+            this.isClustered = true;
+            this.cfgCtx = cfgCtx;
+        }
 
-    /* The key for 'active' attribute and this is used when this attribute value being replicated */
-    private String activePropertyKey;
-    /* The key for 'recoverOn' attribute and this is used when this attribute value being
-     * replicated */
-    private String recoverOnPropertyKey;
+        this.definition = endpointDefinition;
+        if (endpointName != null) {
+            this.endpointName = endpointName;
+        } else if (endpointDefinition != null) {
+            this.endpointName = endpointDefinition.toString();
+        }
 
-    /* Is this env. support clustering*/
-    private boolean isClusteringEnable = false;
+        STATE_KEY                 = KEY_PREFIX + endpointName + STATE;
+        NEXT_RETRY_TIME_KEY       = KEY_PREFIX + endpointName + NEXT_RETRY_TIME;
+        REMAINING_RETRIES_KEY     = KEY_PREFIX + endpointName + REMAINING_RETRIES;
+        LAST_SUSPEND_DURATION_KEY = KEY_PREFIX + endpointName + LAST_SUSPEND_DURATION;
+    }
 
     /**
-     * Checks if the endpoint is active (failed or not)
-     *
-     * @return Returns true if the endpoint is active , otherwise , false will be returned
+     * Update the internal state of the endpoint
+     * @param state the new state of the endpoint
      */
-    public boolean isActive() {
+    private void setState(int state) {
+
+        if (isClustered) {
+            setAndReplicateState(STATE_KEY, state);
+            switch (state) {
+                case ST_ACTIVE : {
+                    setAndReplicateState(REMAINING_RETRIES_KEY,
+                        definition.getRetriesOnTimeoutBeforeSuspend());
+                    setAndReplicateState(LAST_SUSPEND_DURATION_KEY, null);
+                    break;
+                }
+                case ST_TIMEOUT : {
+                    Integer retries = (Integer) cfgCtx.getPropertyNonReplicable(REMAINING_RETRIES_KEY);
+                    if (retries == null) {
+                        retries = definition.getRetriesOnTimeoutBeforeSuspend();
+                    }
+
+                    if (retries <= 0) {
+                        log.info("Endpoint : " + endpointName + " has been marked for SUSPENSION," +
+                                " but no further retries remain. Thus it will be SUSPENDED.");
+
+                        setState(ST_SUSPENDED);
+
+                    } else {
+                        setAndReplicateState(REMAINING_RETRIES_KEY, (retries-1));
+                        long nextRetry = System.currentTimeMillis() + definition.getRetryDurationOnTimeout();
+                        setAndReplicateState(NEXT_RETRY_TIME_KEY, nextRetry);
+
+                        if (log.isDebugEnabled()) {
+                            log.debug("Endpoint : " + endpointName + " is marked as TIMEOUT and " +
+                                "will be retried : " + (retries-1) + " more time/s after : " +
+                                new Date(nextRetry) + " until its marked SUSPENDED for failure");
+                        }
+                    }
+                    break;
+                }
+                case ST_SUSPENDED : {
+                    computeNextRetryTimeForSuspended();
+                    break;
+                }
+                case ST_OFF: {
+                    // mark as in maintenence, and reset all other information
+                    setAndReplicateState(REMAINING_RETRIES_KEY,
+                        definition == null ? -1 : definition.getRetriesOnTimeoutBeforeSuspend());
+                    setAndReplicateState(LAST_SUSPEND_DURATION_KEY, null);
+                    break;
+                }
+            }
 
-        if (this.isClusteringEnable) {  // if this is a clustering env.
+        } else {
 
-            if (this.activePropertyKey == null || "".equals(this.activePropertyKey)) {
-                handleException("Cannot find the required key to find the " +
-                        "shared state of 'active' attribute");
+            localState = state;
+            switch (state) {
+                case ST_ACTIVE: {
+                    localRemainingRetries = definition.getRetriesOnTimeoutBeforeSuspend();
+                    localLastSuspendDuration = -1;
+                    break;
+                }
+                case ST_TIMEOUT : {
+                    int retries = localRemainingRetries;
+                    if (retries == -1) {
+                        retries = definition.getRetriesOnTimeoutBeforeSuspend();
+                    }
+
+                    if (retries <= 0) {
+                        log.info("Endpoint : " + endpointName + " has been marked for SUSPENSION, " +
+                                "but no further retries remain. Thus it will be SUSPENDED.");
+
+                        setState(ST_SUSPENDED);
+
+                    } else {
+                        localRemainingRetries = retries -1;
+                        localNextRetryTime =
+                            System.currentTimeMillis() + definition.getRetryDurationOnTimeout();
+
+                        if (log.isDebugEnabled()) {
+                            log.debug("Endpoint : " + endpointName + " is marked as TIMEOUT and " +
+                                "will be retried : " + localRemainingRetries + " more time/s after : " +
+                                new Date(localNextRetryTime) + " until its marked SUSPENDED for failure");
+                        }
+                    }
+                    break;
+                }
+                case ST_SUSPENDED : {
+                    computeNextRetryTimeForSuspended();
+                    break;
+                }
+                case ST_OFF: {
+                    // mark as in maintenence, and reset all other information
+                    localRemainingRetries = definition == null ?
+                        -1 : definition.getRetriesOnTimeoutBeforeSuspend();
+                    localLastSuspendDuration = -1;
+                    break;
+                }
             }
+        }
+    }
 
-            // gets the value from configuration context (The shared state across all instances )
-            Object value = this.configCtx.getPropertyNonReplicable(this.activePropertyKey);
-            if (value == null) {
-                return true;
-            }
-            if (value instanceof Boolean) {
-                return ((Boolean) value).booleanValue();
-            } else if (value instanceof String) {
-                return Boolean.parseBoolean((String) value);
-            } else {
-                handleException("Unsupported object type for value" + value);
+    /**
+     * Endpoint has processed a message successfully
+     */
+    public void onSuccess() {
+        if (isClustered) {
+            Integer state = (Integer) cfgCtx.getPropertyNonReplicable(STATE_KEY);
+            if (state != ST_ACTIVE && state != ST_OFF) {
+                setState(ST_ACTIVE);
             }
-
         } else {
-            return active;
+            if (localState != ST_ACTIVE && localState != ST_OFF) {
+                log.info("Endpoint : " + endpointName + " currently " + getStateAsString() +
+                    " will now be marked active since it processed its last message");
+                setState(ST_ACTIVE);
+            }
         }
+    }
 
-        throw new SynapseException("Invalid states in endpoint context");
+    /**
+     *  Endpoint failed processing a message
+     */
+    public void onFault() {
+        log.warn("Endpoint : " + endpointName + " will be marked SUSPENDED as it failed");
+        setState(ST_SUSPENDED);
+    }
 
+    /**
+     *  Endpoint timeout processing a message
+     */
+    public void onTimeout() {
+        if (log.isDebugEnabled()) {
+            log.debug("Endpoint : " + endpointName + " will be marked for " +
+                    "SUSPENSION due to the occurrence of one of the configured errors");
+        }
+        setState(ST_TIMEOUT);
     }
 
     /**
-     * Sets if endpoint active or not.
-     *
-     * @param active True for make endpoint active , false for make it inactive
+     * Compute the suspension duration according to the geometric series parameters defined
      */
-    public synchronized void setActive(boolean active) {
+    private void computeNextRetryTimeForSuspended() {
+        boolean notYetSuspended = true;
+        long lastSuspendDuration = definition.getInitialSuspendDuration();
+        if (isClustered) {
+            Long lastDuration = (Long) cfgCtx.getPropertyNonReplicable(LAST_SUSPEND_DURATION_KEY);
+            if (lastDuration != null) {
+                lastSuspendDuration = lastDuration;
+                notYetSuspended = false;
+            }
+        } else if (localLastSuspendDuration > 0) {
+            lastSuspendDuration = localLastSuspendDuration;
+            notYetSuspended = false;
+        }
+
+        long nextSuspendDuration = (notYetSuspended ?
+            definition.getInitialSuspendDuration() :
+            (long) (lastSuspendDuration * definition.getSuspendProgressionFactor()));
 
-        if (this.isClusteringEnable) {  // if this is a clustering env.
-            // replicates the state so that all instances across cluster can see this state
-            Replicator.setAndReplicateState(this.activePropertyKey, active, configCtx);
+        if (nextSuspendDuration > definition.getSuspendMaximumDuration()) {
+            nextSuspendDuration = definition.getSuspendMaximumDuration();
+        } else if (nextSuspendDuration < 0) {
+            nextSuspendDuration = SynapseConstants.DEFAULT_ENDPOINT_SUSPEND_TIME;
+        }
+
+        long nextRetryTime = System.currentTimeMillis() + nextSuspendDuration;
+
+        if (isClustered) {
+            setAndReplicateState(LAST_SUSPEND_DURATION_KEY, nextSuspendDuration);
+            setAndReplicateState(NEXT_RETRY_TIME_KEY, nextRetryTime);
         } else {
-            this.active = active;
+            localLastSuspendDuration = nextSuspendDuration;
+            localNextRetryTime = nextRetryTime;
         }
 
+        if (log.isDebugEnabled()) {
+            log.debug("Suspending endpoint : " + endpointName +
+                (notYetSuspended ? " -" :
+                    " - last suspend duration was : " + lastSuspendDuration + "ms and") +
+                " current suspend duration is : " + nextSuspendDuration + "ms - " +
+                "Next retry after : " + new Date(nextRetryTime));
+        }
     }
 
     /**
-     * Time to recover a failed endpoint.
+     * Checks if the endpoint is in the state ST_ACTIVE. In a clustered environment, the non
+     * availability of a clustered STATE_KEY implies that this endpoint is active
      *
-     * @return Returns time to recover a failed endpoint.
+     * @return Returns true if the endpoint should be considered as active
      */
-    public long getRecoverOn() {
+    public boolean readyToSend() {
 
-        if (this.isClusteringEnable) {    // if this is a clustering env.
+        if (log.isDebugEnabled()) {
+            log.debug("Checking if endpoint : " + endpointName + " currently at state " +
+                getStateAsString() + " can be used now?");
+        }
 
-            if (this.recoverOnPropertyKey == null || "".equals(this.recoverOnPropertyKey)) {
-                handleException("Cannot find the required key to find the " +
-                        "shared state of 'recoveOn' attribute");
-            }
+        if (isClustered) {
+            
+            // gets the value from configuration context (The shared state across all instances)
+            Integer state = (Integer) cfgCtx.getPropertyNonReplicable(STATE_KEY);
+            Integer remainingRetries = (Integer) cfgCtx.getPropertyNonReplicable(REMAINING_RETRIES_KEY);
+            Long nextRetryTime = (Long) cfgCtx.getPropertyNonReplicable(NEXT_RETRY_TIME_KEY);
+
+            if (state == null) {
+                // state has not yet been replicated.. first replication occurs on first timeout or fault
+                return true;
 
-            // gets the value from configuration context (The shared state across all instances )
-            Object value = this.configCtx.getPropertyNonReplicable(this.recoverOnPropertyKey);
-            if (value == null) {
-                return Long.MAX_VALUE;
-            }
-            if (value instanceof Long) {
-                return ((Long) value).longValue();
-            } else if (value instanceof String) {
-                try {
-                    return Long.parseLong((String) value);
-                } catch (NumberFormatException e) {
-                    return Long.MAX_VALUE;
-                }
             } else {
-                handleException("Unsupported object type for value" + value);
+                if (state == ST_ACTIVE) {
+                    return true;
+
+                } else if (state == ST_OFF) {
+                    return false;
+
+                } else if (System.currentTimeMillis() > nextRetryTime) {
+                    // if we are not active, but reached the next retry time, return true but do not
+                    // make a state change. We will make the state change on a successful send
+                    // if we are in the ST_TIMEOUT state, reduce a remaining retry
+                    if (state == ST_TIMEOUT) {
+                        remainingRetries--;
+                        setAndReplicateState(REMAINING_RETRIES_KEY, remainingRetries);
+
+                        if (log.isDebugEnabled()) {
+                            log.debug("Endpoint : " + endpointName + " currently in timeout state" +
+                                " is ready to retry. Remaining retries before suspension : " + remainingRetries);
+                        }
+                        
+                    } else {
+                        if (log.isDebugEnabled()) {
+                            log.debug("Endpoint : " + endpointName + " currently SUSPENDED," +
+                                " is ready to retry now");
+                        }
+                    }
+                    return true;
+                }
             }
 
         } else {
-            return recoverOn;
-        }
-        throw new SynapseException("Invalid states in endpoint context");
-    }
 
-    /**
-     * Sets time to recover a failed endpoint.
-     *
-     * @param recoverOn The value for recover time
-     */
-    public void setRecoverOn(long recoverOn) {
+            if (localState == ST_ACTIVE) {
+                return true;
 
-        if (this.isClusteringEnable) { // if this is a clustering env.
-            // replicates the state so that all instances across cluster can see this state
-            Replicator.setAndReplicateState(this.recoverOnPropertyKey, recoverOn, configCtx);
-        } else {
-            this.recoverOn = recoverOn;
+            } else if (localState == ST_OFF) {
+                return false;
+
+            } else if (System.currentTimeMillis() > localNextRetryTime) {
+
+                // if we are not active, but reached the next retry time, return true but do not
+                // make a state change. We will make the state change on a successful send
+                // if we are in the ST_TIMEOUT state, reduce a remaining retry
+                if (localState == ST_TIMEOUT) {
+                    localRemainingRetries--;
+
+                    if (log.isDebugEnabled()) {
+                        log.debug("Endpoint : " + endpointName + " currently in timeout state" +
+                            " is ready to retry. Remaining retries before suspension : " + localRemainingRetries);
+                    }
+
+                } else {
+                    if (log.isDebugEnabled()) {
+                        log.debug("Endpoint : " + endpointName + " currently SUSPENDED," +
+                            " is ready to retry now");
+                    }
+                }
+                return true;
+            }
+        }
+
+        if (log.isDebugEnabled()) {
+            log.debug("Endpoint : " + endpointName + " not ready and is currently : " +
+                getStateAsString() + " Next retry will be after : " + new Date(localNextRetryTime));
         }
+
+        return false;
     }
 
     /**
-     * Get the configuration context instance . This is only available for cluster env.
-     *
-     * @return Returns the ConfigurationContext instance
+     * Manually turn off this endpoint (e.g. for maintenence)
      */
-    public ConfigurationContext getConfigurationContext() {
-        return configCtx;
+    public void switchOff() {
+        log.info("Manually switching off endpoint : " + endpointName);
+        setState(ST_OFF);
     }
 
     /**
-     * Sets the  ConfigurationContext instance . This is only used for cluster env.
-     * By setting this , indicates that this is a cluster env.
-     *
-     * @param configCtx The ConfigurationContext instance
+     * Activate this endpoint manually (i.e. from an automatic suspend or manual switch off)
      */
-    public void setConfigurationContext(ConfigurationContext configCtx) {
+    public void switchOn() {
+        log.info("Manually activating endpoint : " + endpointName);
+        setState(ST_ACTIVE);
+    }
 
-        if (configCtx == null) {
-            handleException("The ConfigurationContext cannot be null" +
-                    " when system in a cluster environment");
+    public boolean isState(int s) {
+        if (isClustered) {
+            Integer state = (Integer) cfgCtx.getPropertyNonReplicable(STATE_KEY);
+            // state has not yet been replicated.. first replication occurs on first timeout or fault
+            return state == null || state == s;
+        } else {
+            return localState == s;
         }
+    }
+
 
-        this.configCtx = configCtx;
-        this.isClusteringEnable = true; // Now, the environment is considered as a cluster
+    /**
+     * Private method to return the current state as a loggable string
+     * @return the current state as a string
+     */
+    private String getStateAsString() {
+        Integer state = localState;
+        if (isClustered) {
+            state = (Integer) cfgCtx.getPropertyNonReplicable(STATE_KEY);
+            if (state == null) {
+                return "ACTIVE";
+            }
+        }
+        switch (state) {
+            case ST_ACTIVE : return "ACTIVE";
+            case ST_TIMEOUT : return "TIMEOUT";
+            case ST_SUSPENDED : return "SUSPENDED";
+            case ST_OFF: return "MAINTNENCE";
+            default: return "UNKNOWN";
+        }
     }
 
     /**
-     * Sets the identifier for this endpoint context , so that , this can be identified
-     * uniquely across the cluster. The id will be the name of the endpoint
+     * Helper method to replicates states of the property with given key
+     * replicates  the given state so that all instances across cluster can see this state
      *
-     * @param contextID The Id for this endpoint context
+     * @param key   The key of the property
+     * @param value The value of the property
      */
-    public void setContextID(String contextID) {
-
-        if (contextID == null || "".equals(contextID)) {
-            handleException("The Context ID cannot be null when system in a cluster environment");
-        }
+    private void setAndReplicateState(String key, Object value) {
 
-        //Making required key for each property in the endpoint context - Those will be used when
-        //replicating states
-        StringBuffer buffer = new StringBuffer();
-        buffer.append(contextID);
-        buffer.append(UNDERSCORE_STRING);
-        String prefix = buffer.toString();
+        if (cfgCtx != null && key != null && value != null) {
 
-        this.recoverOnPropertyKey = prefix + RECOVER_ON;
-        this.activePropertyKey = prefix + ACTIVE;
+            try {
+                if (log.isDebugEnabled()) {
+                    log.debug("Replicating property key : " + key + " as : " + value);
+                }
+                cfgCtx.setProperty(key, value);
+                Replicator.replicate(cfgCtx, new String[]{key});
 
+            } catch (ClusteringFault clusteringFault) {
+                handleException("Error replicating property : " + key + " as : " +
+                    value, clusteringFault);
+            }
+        }
     }
 
     /**
@@ -227,4 +468,15 @@ public class EndpointContext {
         log.error(msg);
         throw new SynapseException(msg);
     }
+
+    /**
+     * Helper methods for handle errors.
+     *
+     * @param msg The error message
+     * @param e   The exception
+     */
+    private void handleException(String msg, Exception e) {
+        log.error(msg, e);
+        throw new SynapseException(msg, e);
+    }
 }
\ No newline at end of file
diff --git a/java/modules/core/src/main/java/org/apache/synapse/endpoints/utils/EndpointDefinition.java b/java/modules/core/src/main/java/org/apache/synapse/endpoints/EndpointDefinition.java
old mode 100644
new mode 100755
similarity index 70%
rename from java/modules/core/src/main/java/org/apache/synapse/endpoints/utils/EndpointDefinition.java
rename to java/modules/core/src/main/java/org/apache/synapse/endpoints/EndpointDefinition.java
index d8889253d..9118ce27a
--- a/java/modules/core/src/main/java/org/apache/synapse/endpoints/utils/EndpointDefinition.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/endpoints/EndpointDefinition.java
@@ -17,19 +17,24 @@
  *  under the License.
  */
 
-package org.apache.synapse.endpoints.utils;
+package org.apache.synapse.endpoints;
 
 import org.apache.synapse.SynapseConstants;
+import org.apache.synapse.audit.AuditConfigurable;
+import org.apache.synapse.audit.AuditConfiguration;
+
+import java.util.List;
+import java.util.ArrayList;
 
 
 /**
- * Endpoint definition contains the information about an web services endpoint. It is used by leaf
- * level endpoints to keep these information (e.g. AddressEndpoint and WSDLEndpoint). An
- * EndpointDefinition object is used by only one endpoint and they cannot be looked up in the
- * registry.
+ * An Endpoint definition contains the information about an endpoint. It is used by leaf
+ * level endpoints to store this information (e.g. AddressEndpoint and WSDLEndpoint).
  */
-public class EndpointDefinition {
+public class EndpointDefinition implements AuditConfigurable {
 
+    /** Who is the leaf level Endpoint which uses me? */
+    private Endpoint leafEndpoint = null;
     /**
      * The simple address this endpoint resolves to - if explicitly specified
      */
@@ -98,15 +103,15 @@ public class EndpointDefinition {
      * Endpoint message format. pox/soap11/soap12
      */
     private String format = null;
-    
+
     /**
      * The charset encoding for messages sent to the endpoint.
      */
     private String charSetEncoding;
-    
+
     /**
-     * timeout duration for waiting for a response. if the user has set some timeout action and
-     * the timeout duration is not set, default is set to 0 seconds. note that if the user has
+     * timeout duration for waiting for a response in ms. if the user has set some timeout action
+     * and the timeout duration is not set, default is set to 0. note that if the user has
      * not set any timeout configuration, default timeout action is set to NONE, which won't do
      * anything for timeouts.
      */
@@ -117,13 +122,23 @@ public class EndpointDefinition {
      */
     private int timeoutAction = SynapseConstants.NONE;
 
-    /**
-     * Leaf level endpoints will be suspended for the specified time by this variable, after a
-     * failure. If this is not explicitly set, it is set to -1, which causes endpoints to
-     * suspended forever.
-     */
-    private long suspendOnFailDuration = -1;
-   
+    /** The initial suspend duration when an endpoint is marked inactive */
+    private long initialSuspendDuration = -1;
+    /** The suspend duration ratio for the next duration - this is the geometric series multipler */
+    private float suspendProgressionFactor = 1;
+    /** This is the maximum duration for which a node will be suspended */
+    private long suspendMaximumDuration = Long.MAX_VALUE;
+    /** A list of error codes, which directly puts an endpoint into suspend mode */
+    private final List<Integer> suspendErrorCodes = new ArrayList<Integer>();
+
+    /** No of retries to attempt on timeout, before an endpoint is makred inactive */
+    private int retriesOnTimeoutBeforeSuspend = 0;
+    /** The delay between retries for a timeout out endpoint */
+    private int retryDurationOnTimeout = 0;
+    /** A list of error codes which puts the endpoint into timeout mode */
+    private final List<Integer> timeoutErrorCodes = new ArrayList<Integer>();
+
+    private AuditConfigurable auditConfigurable = new AuditConfiguration(SynapseConstants.ANONYMOUS_ENDPOINT);
     /**
      * The variable that indicate tracing on or off for the current mediator
      */
@@ -357,7 +372,7 @@ public class EndpointDefinition {
 
     /**
      * Set the timeout duration.
-     * 
+     *
      * @param timeoutDuration a duration in milliseconds
      */
     public void setTimeoutDuration(long timeoutDuration) {
@@ -391,8 +406,8 @@ public class EndpointDefinition {
 
     /**
      * Set the charset encoding for messages sent to the endpoint.
-     * 
-     * @param charSetEncoding the charset encoding or <code>null</code> 
+     *
+     * @param charSetEncoding the charset encoding or <code>null</code>
      */
     public void setCharSetEncoding(String charSetEncoding) {
         this.charSetEncoding = charSetEncoding;
@@ -403,18 +418,18 @@ public class EndpointDefinition {
      *
      * @return suspendOnFailDuration
      */
-    public long getSuspendOnFailDuration() {
-        return suspendOnFailDuration;
+    public long getInitialSuspendDuration() {
+        return initialSuspendDuration;
     }
 
     /**
      * Set the suspend on fail duration.
      *
-     * @param suspendOnFailDuration a duration in milliseconds
+     * @param initialSuspendDuration a duration in milliseconds
      */
-    public void setSuspendOnFailDuration(long suspendOnFailDuration) {
-        this.suspendOnFailDuration = suspendOnFailDuration;
-    }   
+    public void setInitialSuspendDuration(long initialSuspendDuration) {
+        this.initialSuspendDuration = initialSuspendDuration;
+    }
 
     public int getTraceState() {
         return traceState;
@@ -423,4 +438,85 @@ public class EndpointDefinition {
     public void setTraceState(int traceState) {
         this.traceState = traceState;
     }
-}
+
+    public float getSuspendProgressionFactor() {
+        return suspendProgressionFactor;
+    }
+
+    public void setSuspendProgressionFactor(float suspendProgressionFactor) {
+        this.suspendProgressionFactor = suspendProgressionFactor;
+    }
+
+    public long getSuspendMaximumDuration() {
+        return suspendMaximumDuration;
+    }
+
+    public void setSuspendMaximumDuration(long suspendMaximumDuration) {
+        this.suspendMaximumDuration = suspendMaximumDuration;
+    }
+
+    public int getRetriesOnTimeoutBeforeSuspend() {
+        return retriesOnTimeoutBeforeSuspend;
+    }
+
+    public void setRetriesOnTimeoutBeforeSuspend(int retriesOnTimeoutBeforeSuspend) {
+        this.retriesOnTimeoutBeforeSuspend = retriesOnTimeoutBeforeSuspend;
+    }
+
+    public int getRetryDurationOnTimeout() {
+        return retryDurationOnTimeout;
+    }
+
+    public void setRetryDurationOnTimeout(int retryDurationOnTimeout) {
+        this.retryDurationOnTimeout = retryDurationOnTimeout;
+    }
+
+    public List<Integer> getSuspendErrorCodes() {
+        return suspendErrorCodes;
+    }
+
+    public List<Integer> getTimeoutErrorCodes() {
+        return timeoutErrorCodes;
+    }
+
+    public void addSuspendErrorCode(int code) {
+        suspendErrorCodes.add(code);
+    }
+
+    public void addTimeoutErrorCode(int code) {
+        timeoutErrorCodes.add(code);
+    }
+
+    public String toString() {
+        if (leafEndpoint != null) {
+            return leafEndpoint.toString();
+        } else if (address != null) {
+            return "Address [" + address + "]";
+        }
+        return "[unknown endpoint]";
+    }
+
+    public void setLeafEndpoint(Endpoint leafEndpoint) {
+        this.leafEndpoint = leafEndpoint;
+    }
+
+    public String getAuditId() {
+        return this.auditConfigurable.getAuditId();
+    }
+
+    public void setAuditId(String id) {
+        this.auditConfigurable.setAuditId(id);
+    }
+
+    public boolean isStatisticsEnable() {
+        return this.auditConfigurable.isStatisticsEnable();
+    }
+
+    public void disableStatistics() {
+        this.auditConfigurable.disableStatistics();
+    }
+
+    public void enableStatistics() {
+        this.auditConfigurable.enableStatistics();
+    }
+}
\ No newline at end of file
diff --git a/java/modules/core/src/main/java/org/apache/synapse/endpoints/EndpointView.java b/java/modules/core/src/main/java/org/apache/synapse/endpoints/EndpointView.java
new file mode 100755
index 000000000..0e2081f37
--- /dev/null
+++ b/java/modules/core/src/main/java/org/apache/synapse/endpoints/EndpointView.java
@@ -0,0 +1,702 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.endpoints;
+
+import org.apache.commons.logging.LogFactory;
+import org.apache.commons.logging.Log;
+import org.apache.axis2.transport.base.MessageLevelMetricsCollector;
+
+import java.util.Map;
+import java.util.HashMap;
+import java.util.Collections;
+
+/**
+ * This class is the metrics collector and JMX control point for Endpoints
+ */
+public class EndpointView implements EndpointViewMBean, MessageLevelMetricsCollector {
+
+    private static final Log log = LogFactory.getLog(EndpointView.class);
+    private static final Long ONE = (long) 1;
+
+    /** The name of the endpoint */
+    private String endpointName = null;
+    /** The actual Endpoint implementation we manage */
+    private Endpoint endpoint = null;
+
+    // metrics collected / maintained
+    private long messagesReceived;
+    private long faultsReceiving;
+    private long timeoutsReceiving;
+    private long bytesReceived;
+    private long minSizeReceived;
+    private long maxSizeReceived;
+    private double avgSizeReceived;
+    private final Map<Integer, Long> receivingFaultTable =
+        Collections.synchronizedMap(new HashMap<Integer, Long>());
+
+    private long messagesSent;
+    private long faultsSending;
+    private long timeoutsSending;
+    private long bytesSent;
+    private long minSizeSent;
+    private long maxSizeSent;
+    private double avgSizeSent;
+    private final Map<Integer, Long> sendingFaultTable =
+        Collections.synchronizedMap(new HashMap<Integer, Long>());
+
+    private final Map<Integer, Long> responseCodeTable =
+        Collections.synchronizedMap(new HashMap<Integer, Long>());
+
+    private long lastResetTime = System.currentTimeMillis();
+
+    /**
+     * Create a new MBean to manage the given endpoint
+     * @param endpointName the name of the endpoint
+     * @param endpoint the actual endpoint
+     */
+    public EndpointView(String endpointName, Endpoint endpoint) {
+        this.endpointName = endpointName;
+        this.endpoint = endpoint;
+    }
+
+    // --- endpoint control ---
+    /**
+     * Switch on a leaf endpoint, or all endpoints on a group - from maintenence
+     * @throws Exception
+     */
+    public void switchOn() throws Exception {
+        if (endpoint.getChildren() != null) {
+            for (Endpoint e : endpoint.getChildren()) {
+                e.getMetricsMBean().switchOn();
+            }
+        } else {
+            if (endpoint.getContext() != null) {
+                endpoint.getContext().switchOn();
+            }
+        }
+    }
+
+    /**
+     * Switch off a leaf endpoint, or all endpoints of a group - for maintenence
+     * @throws Exception
+     */
+    public void switchOff() throws Exception {
+        if (endpoint.getChildren() != null) {
+            for (Endpoint e : endpoint.getChildren()) {
+                e.getMetricsMBean().switchOff();
+            }
+        } else {
+            if (endpoint.getContext() != null) {
+                endpoint.getContext().switchOff();
+            }
+        }
+    }
+
+    // --- endpoint status check ---
+    /**
+     * Is a leaf level endpoint active? For a group endpoint this means at least one is active
+     * @return true if at least one is active in a group endpoint; for a leaf - if it is currently active
+     * @throws Exception
+     */
+    public boolean isActive() throws Exception {
+        if (endpoint.getChildren() != null) {
+            return getActiveChildren() > 0;
+        } else if (endpoint.getContext() != null) {
+            return endpoint.getContext().isState(EndpointContext.ST_ACTIVE);
+        }
+        return false;
+    }
+
+    /**
+     * Is this leaf level endpoint in timeout state? For a group, has all endpoints timed out?
+     * @return true if a leaf level endpoint has timedout, For a group, has all endpoints timed out?
+     * @throws Exception
+     */
+    public boolean isTimedout() throws Exception {
+        return isEndpointInState(EndpointContext.ST_TIMEOUT);
+    }
+
+    /**
+     * Is this leaf level endpoint in suspend state?
+     * @return true if a leaf level endpoint is suspended, false for group endpoints and non-suspend
+     * @throws Exception
+     */
+    public boolean isSuspended() throws Exception {
+        return isEndpointInState(EndpointContext.ST_SUSPENDED);
+    }
+
+    /**
+     * Is this leaf level endpoint switched off?
+     * @return true if a leaf level endpoint is off, false for group endpoints and non-off
+     * @throws Exception
+     */
+    public boolean isSwitchedOff() throws Exception {
+        return isEndpointInState(EndpointContext.ST_OFF);
+    }
+
+    /**
+     * Return number of children for this endpoint
+     * @return the number of children for this endpoint
+     * @throws Exception
+     */
+    public int getTotalChildren() throws Exception {
+        return (endpoint.getChildren() == null ? 0 : endpoint.getChildren().size());
+    }
+
+    /**
+     * Return the number of active children for this endpoint
+     * @return the number of active children for this endpoint
+     * @throws Exception
+     */
+    public int getActiveChildren() throws Exception {
+        if (endpoint.getChildren() == null) {
+            return 0;
+        } else {
+            int activeCount = 0;
+            for (Endpoint e : endpoint.getChildren()) {
+                if (e.getContext().isState(EndpointContext.ST_ACTIVE)) {
+                    activeCount++;
+                }
+            }
+            return activeCount;
+        }
+    }
+
+    /**
+     * Return the number of ready children for this endpoint
+     * @return the number of ready children for this endpoint
+     * @throws Exception
+     */
+    public int getReadyChildren() throws Exception {
+        if (endpoint.getChildren() == null) {
+            return 0;
+        } else {
+            int readyCount = 0;
+            for (Endpoint e : endpoint.getChildren()) {
+                if (e.getContext().readyToSend()) {
+                    readyCount++;
+                }
+            }
+            return readyCount;
+        }
+    }
+
+    // --- endpoint metrics ---
+    /**
+     * Time when statistics was last reset for this leaf endpoint
+     * @return the time when statistics was last reset for this leaf endpoint, or -1 for group endpoints
+     */
+    public long getLastResetTime() {
+        return (endpoint.getChildren() != null ? -1 : lastResetTime);
+    }
+
+    /**
+     * Time since statistics was last reset for this leaf endpoint
+     * @return the time since statistics was last reset for this leaf endpoint, or -1 for group endpoints
+     */
+    public long getMetricsWindow() {
+        return (endpoint.getChildren() != null ? -1 : System.currentTimeMillis() - lastResetTime);
+    }
+
+    /**
+     * A Map of receive faults with the error code and count
+     * @return a Map of receive faults
+     */
+    public Map<Integer, Long> getReceivingFaultTable() {
+        if (endpoint.getChildren() != null) {
+            Map<Integer, Long> receivingFaultTable = new HashMap<Integer, Long>();
+            for (Endpoint e : endpoint.getChildren()) {
+                if (e.getMetricsMBean() != null) {
+                    addTableMaps(receivingFaultTable, e.getMetricsMBean().getReceivingFaultTable());
+                }
+            }
+            addTableMaps(receivingFaultTable, this.receivingFaultTable);
+            return receivingFaultTable;
+        } else {
+            return receivingFaultTable;
+        }
+    }
+
+    /**
+     * A Map of send faults with the error code and count
+     * @return a Map of send faults
+     */
+    public Map<Integer, Long> getSendingFaultTable() {
+        if (endpoint.getChildren() != null) {
+            Map<Integer, Long> sendingFaultTable = new HashMap<Integer, Long>();
+            for (Endpoint e : endpoint.getChildren()) {
+                if (e.getMetricsMBean() != null) {
+                    addTableMaps(sendingFaultTable, e.getMetricsMBean().getSendingFaultTable());
+                }
+            }
+            addTableMaps(sendingFaultTable, this.sendingFaultTable);
+            return sendingFaultTable;
+        } else {
+            return sendingFaultTable;
+        }
+    }
+
+    /**
+     * A Map of response codes and counts
+     * @return a Map of response codes and counts
+     */
+    public Map<Integer, Long> getResponseCodeTable() {
+        if (endpoint.getChildren() != null) {
+            Map<Integer, Long> responseCodeTable = new HashMap<Integer, Long>();
+            for (Endpoint e : endpoint.getChildren()) {
+                if (e.getMetricsMBean() != null) {
+                    addTableMaps(responseCodeTable, e.getMetricsMBean().getResponseCodeTable());
+                }
+            }
+            return responseCodeTable;
+        } else {
+            return responseCodeTable;
+        }
+    }
+
+    /**
+     * Number of messages (ie replies) received
+     * @return # of messages (replies) received
+     */
+    public long getMessagesReceived() {
+        if (endpoint.getChildren() != null) {
+            long messagesReceived = 0;
+            for (Endpoint e : endpoint.getChildren()) {
+                if (e.getMetricsMBean() != null) {
+                    messagesReceived += e.getMetricsMBean().getMessagesReceived();
+                }
+            }
+            return messagesReceived;
+        } else {
+            return messagesReceived;
+        }
+    }
+
+    /**
+     * Number of faults, receiving replies
+     * @return # of faults, receiving replies
+     */
+    public long getFaultsReceiving() {
+        if (endpoint.getChildren() != null) {
+            long faultsReceiving = 0;
+            for (Endpoint e : endpoint.getChildren()) {
+                if (e.getMetricsMBean() != null) {
+                    faultsReceiving += e.getMetricsMBean().getFaultsReceiving();
+                }
+            }
+            return faultsReceiving;
+        } else {
+            return faultsReceiving;
+        }
+    }
+
+    /**
+     * Number of timeouts, receiving replies
+     * @return # of timeouts, receiving replies
+     */
+    public long getTimeoutsReceiving() {
+        if (endpoint.getChildren() != null) {
+            long timeoutsReceiving = 0;
+            for (Endpoint e : endpoint.getChildren()) {
+                if (e.getMetricsMBean() != null) {
+                    timeoutsReceiving += e.getMetricsMBean().getTimeoutsReceiving();
+                }
+            }
+            return timeoutsReceiving;
+        } else {
+            return timeoutsReceiving;
+        }
+    }
+
+    /**
+     * Number of bytes received, receiving replies
+     * @return # of byted received, receiving replies
+     */
+    public long getBytesReceived() {
+        if (endpoint.getChildren() != null) {
+            long bytesReceived = 0;
+            for (Endpoint e : endpoint.getChildren()) {
+                if (e.getMetricsMBean() != null) {
+                    bytesReceived += e.getMetricsMBean().getBytesReceived();
+                }
+            }
+            return bytesReceived;
+        } else {
+            return bytesReceived;
+        }
+    }
+
+    /**
+     * Number of messages sent
+     * @return # of messages sent
+     */
+    public long getMessagesSent() {
+        if (endpoint.getChildren() != null) {
+            long messagesSent = 0;
+            for (Endpoint e : endpoint.getChildren()) {
+                if (e.getMetricsMBean() != null) {
+                    messagesSent += e.getMetricsMBean().getMessagesSent();
+                }
+            }
+            return messagesSent;
+        } else {
+            return messagesSent;
+        }
+    }
+
+    /**
+     * Number of faults sending
+     * @return # of faults sending
+     */
+    public long getFaultsSending() {
+        if (endpoint.getChildren() != null) {
+            long faultsSending = 0;
+            for (Endpoint e : endpoint.getChildren()) {
+                if (e.getMetricsMBean() != null) {
+                    faultsSending += e.getMetricsMBean().getFaultsSending();
+                }
+            }
+            return faultsSending;
+        } else {
+            return faultsSending;
+        }
+    }
+
+    /**
+     * Number of timeouts, sending
+     * @return # of timeouts, sending
+     */
+    public long getTimeoutsSending() {
+        if (endpoint.getChildren() != null) {
+            long timeoutsSending = 0;
+            for (Endpoint e : endpoint.getChildren()) {
+                if (e.getMetricsMBean() != null) {
+                    timeoutsSending += e.getMetricsMBean().getTimeoutsSending();
+                }
+            }
+            return timeoutsSending;
+        } else {
+            return timeoutsSending;
+        }
+    }
+
+    /**
+     * Number of bytes sent
+     * @return # of bytes sent
+     */
+    public long getBytesSent() {
+        if (endpoint.getChildren() != null) {
+            long bytesSent = 0;
+            for (Endpoint e : endpoint.getChildren()) {
+                if (e.getMetricsMBean() != null) {
+                    bytesSent += e.getMetricsMBean().getBytesSent();
+                }
+            }
+            return bytesSent;
+        } else {
+            return bytesSent;
+        }
+    }
+
+    public long getMinSizeReceived() {
+        if (endpoint.getChildren() != null) {
+            long minSizeReceived = 0;
+            for (Endpoint e : endpoint.getChildren()) {
+                if (e.getMetricsMBean() != null) {
+                    if (minSizeReceived == 0) {
+                        minSizeReceived = e.getMetricsMBean().getMinSizeReceived();
+                    } else if (e.getMetricsMBean().getMinSizeReceived() < minSizeReceived) {
+                        minSizeReceived = e.getMetricsMBean().getMinSizeReceived();
+                    }
+                }
+            }
+            return minSizeReceived;
+        } else {
+            return minSizeReceived;
+        }
+    }
+
+    public long getMaxSizeReceived() {
+        if (endpoint.getChildren() != null) {
+            long maxSizeReceived = 0;
+            for (Endpoint e : endpoint.getChildren()) {
+                if (e.getMetricsMBean() != null) {
+                    if (maxSizeReceived == 0) {
+                        maxSizeReceived = e.getMetricsMBean().getMaxSizeReceived();
+                    } else if (e.getMetricsMBean().getMaxSizeReceived() > maxSizeReceived) {
+                        maxSizeReceived = e.getMetricsMBean().getMaxSizeReceived();
+                    }
+                }
+            }
+            return maxSizeReceived;
+        } else {
+            return maxSizeReceived;
+        }
+    }
+
+    public long getMinSizeSent() {
+        if (endpoint.getChildren() != null) {
+            long minSizeSent = 0;
+            for (Endpoint e : endpoint.getChildren()) {
+                if (e.getMetricsMBean() != null) {
+                    if (minSizeSent == 0) {
+                        minSizeSent = e.getMetricsMBean().getMinSizeSent();
+                    } else if (e.getMetricsMBean().getMinSizeSent() < minSizeSent) {
+                        minSizeSent = e.getMetricsMBean().getMinSizeSent();
+                    }
+                }
+            }
+            return minSizeSent;
+        } else {
+            return minSizeSent;
+        }
+    }
+
+    public long getMaxSizeSent() {
+        if (endpoint.getChildren() != null) {
+            long maxSizeSent = 0;
+            for (Endpoint e : endpoint.getChildren()) {
+                if (e.getMetricsMBean() != null) {
+                    if (maxSizeSent == 0) {
+                        maxSizeSent = e.getMetricsMBean().getMaxSizeSent();
+                    } else if (e.getMetricsMBean().getMaxSizeSent() > maxSizeSent) {
+                        maxSizeSent = e.getMetricsMBean().getMaxSizeSent();
+                    }
+                }
+            }
+            return maxSizeSent;
+        } else {
+            return maxSizeSent;
+        }
+    }
+
+    public double getAvgSizeReceived() {
+        if (endpoint.getChildren() != null) {
+            double avgSizeReceived = 0;
+            for (Endpoint e : endpoint.getChildren()) {
+                double epValue =
+                    e.getMetricsMBean() == null ? 0 : e.getMetricsMBean().getAvgSizeReceived();
+                if (epValue > 0) {
+                    avgSizeReceived =
+                        (avgSizeReceived == 0 ? epValue : (avgSizeReceived + epValue) / 2);
+                }
+            }
+            return avgSizeReceived;
+        } else {
+            return avgSizeReceived;
+        }
+    }
+
+    public double getAvgSizeSent() {
+        if (endpoint.getChildren() != null) {
+            double avgSizeSent = 0;
+            for (Endpoint e : endpoint.getChildren()) {
+                double epValue =
+                    e.getMetricsMBean() == null ? 0 : e.getMetricsMBean().getAvgSizeSent();
+                if (epValue > 0) {
+                    avgSizeSent = (avgSizeSent == 0 ? epValue : (avgSizeSent + epValue) / 2);
+                }
+            }
+            return avgSizeSent;
+        } else {
+            return avgSizeSent;
+        }
+    }
+
+    // --- MessageLevelMetricsCollector methods ---
+    public void resetStatistics() {
+
+        messagesReceived  = 0;
+        faultsReceiving   = 0;
+        timeoutsReceiving = 0;
+        bytesReceived     = 0;
+        minSizeReceived   = 0;
+        maxSizeReceived   = 0;
+        avgSizeReceived   = 0;
+        receivingFaultTable.clear();
+
+        messagesSent      = 0;
+        faultsSending     = 0;
+        timeoutsSending   = 0;
+        bytesSent         = 0;
+        minSizeSent       = 0;
+        maxSizeSent       = 0;
+        avgSizeSent       = 0;
+        sendingFaultTable.clear();
+
+        responseCodeTable.clear();
+        lastResetTime = System.currentTimeMillis();
+
+        if (endpoint.getChildren() != null) {
+            for (Endpoint e : endpoint.getChildren()) {
+                if (e.getMetricsMBean() != null) {
+                    e.getMetricsMBean().resetStatistics();
+                }
+            }
+        }
+        log.info("Endpoint statistics reset for : " + endpointName + " (and/or its children)");
+    }
+
+    public synchronized void incrementMessagesReceived() {
+        messagesReceived++;
+    }
+
+    public synchronized void incrementFaultsReceiving(int errorCode) {
+        faultsReceiving++;
+        Object o = receivingFaultTable.get(errorCode);
+        if (o == null) {
+            receivingFaultTable.put(errorCode, ONE);
+        } else {
+            receivingFaultTable.put(errorCode, (Long) o + 1);
+        }
+    }
+
+    public synchronized void incrementTimeoutsReceiving() {
+        timeoutsReceiving++;
+    }
+
+    public synchronized void incrementBytesReceived(long size) {
+        bytesReceived += size;
+    }
+
+    public synchronized void incrementMessagesSent() {
+        messagesSent++;
+    }
+
+    public synchronized void incrementFaultsSending(int errorCode) {
+        faultsSending++;
+        Object o = sendingFaultTable.get(errorCode);
+        if (o == null) {
+            sendingFaultTable.put(errorCode, ONE);
+        } else {
+            sendingFaultTable.put(errorCode, (Long) o + 1);
+        }
+    }
+
+    public synchronized void incrementTimeoutsSending() {
+        timeoutsSending++;
+    }
+
+    public synchronized void incrementBytesSent(long size) {
+        bytesSent += size;
+    }
+
+    public synchronized void notifyReceivedMessageSize(long size) {
+        if (minSizeReceived == 0 || size < minSizeReceived) {
+            minSizeReceived = size;
+        }
+        if (size > maxSizeReceived) {
+            maxSizeReceived = size;
+        }
+        avgSizeReceived = (avgSizeReceived == 0 ? size : (avgSizeReceived + size) / 2);
+    }
+
+    public synchronized void notifySentMessageSize(long size) {
+        if (minSizeSent == 0 || size < minSizeSent) {
+            minSizeSent = size;
+        }
+        if (size > maxSizeSent) {
+            maxSizeSent = size;
+        }
+        avgSizeSent = (avgSizeSent == 0 ? size : (avgSizeSent + size) / 2);
+    }
+
+    /**
+     * Report a/an [typically non-fatal] error to the sending fault table, without incrementing
+     * the sendingFault count e.g. to report a successful fail-over etc
+     * @param errorCode the code to report
+     */
+    public void reportSendingFault(int errorCode) {
+        synchronized(sendingFaultTable) {
+            Object o = sendingFaultTable.get(errorCode);
+            if (o == null) {
+                sendingFaultTable.put(errorCode, ONE);
+            } else {
+                sendingFaultTable.put(errorCode, (Long) o + 1);
+            }
+        }
+    }
+
+    /**
+     * Report a/an [typically non-fatal] error to the receiving fault table, without incrementing
+     * the receivingFault count
+     * @param errorCode the code to report
+     */
+    public void reportReceivingFault(int errorCode) {
+        synchronized(receivingFaultTable) {
+            Object o = receivingFaultTable.get(errorCode);
+            if (o == null) {
+                receivingFaultTable.put(errorCode, ONE);
+            } else {
+                receivingFaultTable.put(errorCode, (Long) o + 1);
+            }
+        }
+    }
+
+    /**
+     * Collect response code statistics
+     * @param respCode response code
+     */
+    public void reportResponseCode(int respCode) {
+        synchronized(responseCodeTable) {
+            Object o = responseCodeTable.get(respCode);
+            if (o == null) {
+                responseCodeTable.put(respCode, ONE);
+            } else {
+                responseCodeTable.put(respCode, (Long) o + 1);
+            }
+        }
+    }
+
+    //---------- utility methods ---------------
+    private static void addTableMaps(Map<Integer, Long> t, Map<Integer, Long> s) {
+        for (Integer o : s.keySet()) {
+            if (t.containsKey(o)) {
+                t.put(o, t.get(o) + s.get(o));
+            } else {
+                t.put(o, s.get(o));
+            }
+        }
+    }
+
+    /**
+     * Is the endpoint considered to be in the given state?
+     * @param state the state to consider
+     * @return true if all endpoints in a group are of the given state, or if a leaf endpoint is in the given state
+     * @throws Exception
+     */
+    public boolean isEndpointInState(int state) throws Exception {
+        if (endpoint.getChildren() != null) {
+            int count = 0, total = 0;
+            for (Endpoint e : endpoint.getChildren()) {
+                if (e.getContext().isState(state)) {
+                    count++;
+                }
+                total++;
+            }
+            return count == total;
+
+        } else if (endpoint.getContext() != null) {
+            return endpoint.getContext().isState(state);
+        }
+        return false;
+    }
+
+}
diff --git a/java/modules/core/src/main/java/org/apache/synapse/endpoints/EndpointViewMBean.java b/java/modules/core/src/main/java/org/apache/synapse/endpoints/EndpointViewMBean.java
new file mode 100755
index 000000000..2027339f0
--- /dev/null
+++ b/java/modules/core/src/main/java/org/apache/synapse/endpoints/EndpointViewMBean.java
@@ -0,0 +1,62 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.endpoints;
+
+import java.util.Map;
+
+public interface EndpointViewMBean {
+
+    // JMX Attributes
+    public long getMessagesReceived();
+    public long getFaultsReceiving();
+    public long getTimeoutsReceiving();
+    public long getBytesReceived();
+    public long getMinSizeReceived();
+    public long getMaxSizeReceived();
+    public double getAvgSizeReceived();
+    public Map getReceivingFaultTable();
+
+    public long getMessagesSent();
+    public long getFaultsSending();
+    public long getTimeoutsSending();
+    public long getBytesSent();
+    public long getMinSizeSent();
+    public long getMaxSizeSent();
+    public double getAvgSizeSent();
+    public Map getSendingFaultTable();
+    public Map getResponseCodeTable();
+
+    // JMX Operations
+    public void switchOn() throws Exception;
+    public void switchOff() throws Exception;
+
+    public boolean isActive() throws Exception;
+    public boolean isTimedout() throws Exception;
+    public boolean isSuspended() throws Exception;
+    public boolean isSwitchedOff() throws Exception;
+
+    public int getTotalChildren() throws Exception;
+    public int getActiveChildren() throws Exception;
+    public int getReadyChildren() throws Exception;
+
+    public void resetStatistics();
+    public long getLastResetTime();
+    public long getMetricsWindow();
+}
diff --git a/java/modules/core/src/main/java/org/apache/synapse/endpoints/FailoverEndpoint.java b/java/modules/core/src/main/java/org/apache/synapse/endpoints/FailoverEndpoint.java
index b127b8f12..4f03a5a8d 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/endpoints/FailoverEndpoint.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/endpoints/FailoverEndpoint.java
@@ -19,16 +19,8 @@
 
 package org.apache.synapse.endpoints;
 
-import org.apache.axis2.clustering.ClusterManager;
-import org.apache.axis2.context.ConfigurationContext;
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.synapse.FaultHandler;
 import org.apache.synapse.MessageContext;
 import org.apache.synapse.SynapseConstants;
-import org.apache.synapse.core.axis2.Axis2MessageContext;
-
-import java.util.List;
 
 /**
  * FailoverEndpoint can have multiple child endpoints. It will always try to send messages to
@@ -39,171 +31,77 @@ import java.util.List;
  * If parent endpoint is not available it will pop the next FaultHandler and delegate the problem
  * to that.
  */
-public class FailoverEndpoint implements Endpoint {
-
-    private static final Log log = LogFactory.getLog(FailoverEndpoint.class);
-
-    /**
-     * Name of the endpoint. Used for named endpoints which can be referred using the key attribute
-     * of indirect endpoints.
-     */
-    private String name = null;
-    /**
-     * List of child endpoints. Failover sending is done among these. Any object implementing the
-     * Endpoint interface can be a child.
-     */
-    private List<Endpoint> endpoints = null;
+public class FailoverEndpoint extends AbstractEndpoint {
 
-    /**
-     * Endpoint for which currently sending the SOAP traffic.
-     */
+    /** Endpoint for which is currently used */
     private Endpoint currentEndpoint = null;
 
-    /**
-     * Parent endpoint of this endpoint if this used inside another endpoint. Possible parents are
-     * LoadbalanceEndpoint, SALoadbalanceEndpoint and FailoverEndpoint objects. But use of
-     * SALoadbalanceEndpoint as the parent is the logical scenario.
-     */
-    private Endpoint parentEndpoint = null;
-
-    /**
-     * The endpoint context , place holder for keep any runtime states related to the endpoint
-     */
-    private final EndpointContext endpointContext = new EndpointContext();
-
-    public void send(MessageContext synMessageContext) {
+    public void send(MessageContext synCtx) {
 
         if (log.isDebugEnabled()) {
-            log.debug("Start : Failover Endpoint");
+            log.debug("Failover Endpoint : " + getName());
         }
 
-        boolean isClusteringEnable = false;
-        // get Axis2 MessageContext and ConfigurationContext
-        org.apache.axis2.context.MessageContext axisMC =
-                ((Axis2MessageContext) synMessageContext).getAxis2MessageContext();
-        ConfigurationContext cc = axisMC.getConfigurationContext();
-
-        //The check for clustering environment 
-
-        ClusterManager clusterManager = cc.getAxisConfiguration().getClusterManager();
-        if (clusterManager != null &&
-                clusterManager.getContextManager() != null) {
-            isClusteringEnable = true;
+        boolean isARetry = false;
+        if (synCtx.getProperty(SynapseConstants.LAST_ENDPOINT) == null) {
+            // If not yet a retry, we have to build the envelope since we need to support failover
+            synCtx.getEnvelope().build();
+        } else {
+            isARetry = true;
         }
 
-        String endPointName = this.getName();
-        if (endPointName == null) {
-
-            if (log.isDebugEnabled() && isClusteringEnable) {
-                log.warn("In a clustering environment , the endpoint  name should be specified" +
-                        "even for anonymous endpoints. Otherwise , the clustering would not be " +
-                        "functioned correctly if there are more than one anonymous endpoints. ");
-            }
-            endPointName = SynapseConstants.ANONYMOUS_ENDPOINT;
+        if (currentEndpoint == null) {
+            currentEndpoint = getChildren().get(0);
         }
 
-        if (isClusteringEnable) {
-            // if this is a cluster environment , then set configuration context to endpoint context
-            if (endpointContext.getConfigurationContext() == null) {
-                endpointContext.setConfigurationContext(cc);
-                endpointContext.setContextID(endPointName);
+        if (currentEndpoint.readyToSend()) {
+            if (isARetry) {
+                metricsMBean.reportSendingFault(SynapseConstants.ENDPOINT_FO_FAIL_OVER);
             }
-        }
-
-        // We have to build the envelop if we are supporting failover.
-        // Failover should sent the original message multiple times if failures occur. So we have to
-        // access the envelop multiple times.        
-        synMessageContext.getEnvelope().build();
+            synCtx.pushFaultHandler(this);
+            currentEndpoint.send(synCtx);
 
-        if (currentEndpoint.isActive(synMessageContext)) {
-            currentEndpoint.send(synMessageContext);
         } else {
-
             boolean foundEndpoint = false;
-            for (Endpoint endpoint : endpoints) {
-                if (endpoint.isActive(synMessageContext)) {
+            for (Endpoint endpoint : getChildren()) {
+                if (endpoint.readyToSend()) {
                     foundEndpoint = true;
                     currentEndpoint = endpoint;
-                    currentEndpoint.send(synMessageContext);
+                    if (isARetry) {
+                        metricsMBean.reportSendingFault(SynapseConstants.ENDPOINT_FO_FAIL_OVER);
+                    }
+                    synCtx.pushFaultHandler(this);
+                    currentEndpoint.send(synCtx);
                     break;
                 }
             }
 
             if (!foundEndpoint) {
-                // there are no active child endpoints. so mark this endpoint as failed.
-                setActive(false, synMessageContext);
-
-                if (parentEndpoint != null) {
-                    parentEndpoint.onChildEndpointFail(this, synMessageContext);
-                } else {
-                    Object o = synMessageContext.getFaultStack().pop();
-                    if (o != null) {
-                        ((FaultHandler) o).handleFault(synMessageContext);
-                    }
+                // if this is not a retry
+                if (synCtx.getProperty(SynapseConstants.LAST_ENDPOINT) == null) {
+                    synCtx.setProperty(SynapseConstants.ERROR_CODE, SynapseConstants.ENDPOINT_FO_NONE_READY);
+                    synCtx.setProperty(SynapseConstants.ERROR_MESSAGE,
+                        "Failover endpoint : " + getName() + " - no ready child endpoints");
+                    synCtx.setProperty(SynapseConstants.ERROR_DETAIL,
+                        "Failover endpoint : " + getName() + " - no ready child endpoints");
+                    synCtx.setProperty(SynapseConstants.ERROR_EXCEPTION, null);
                 }
+                super.onFault(synCtx);
             }
         }
     }
 
-    public String getName() {
-        return this.name;
-    }
-
-    public void setName(String name) {
-        this.name = name.trim();
-    }
-
-    /**
-     * If this endpoint is in inactive state, checks if all immediate child endpoints are still
-     * failed. If so returns false. If at least one child endpoint is in active state, sets this
-     * endpoint's state to active and returns true.
-     *
-     * @param synMessageContext MessageContext of the current message. This is not used here.
-     * @return true if active. false otherwise.
-     */
-    public boolean isActive(MessageContext synMessageContext) {
-        boolean active = endpointContext.isActive();
-        if (!active) {
-            for (Endpoint endpoint : endpoints) {
-                if (endpoint.isActive(synMessageContext)) {
-                    active = true;
-                    endpointContext.setActive(true);
-
-                    // don't break the loop though we found one active endpoint. calling isActive()
-                    // on all child endpoints will update their active state. so this is a good
-                    // time to do that.
-                }
-            }
-        }
-        
-        if (log.isDebugEnabled()) {
-            log.debug("Endpoint  '" + name + "' is in state ' " + active + " '");
-        }
-
-        return active;
-    }
-
-    public void setActive(boolean active, MessageContext synMessageContext) {
-        // setting a volatile boolean value is thread safe.
-        this.endpointContext.setActive(active);
-    }
-
-    public List<Endpoint> getEndpoints() {
-        return endpoints;
-    }
-
-    public void setEndpoints(List<Endpoint> endpoints) {
-        this.endpoints = endpoints;
-        if (endpoints.size() > 0) {
-            currentEndpoint = endpoints.get(0);
-        }
-    }
-
     public void onChildEndpointFail(Endpoint endpoint, MessageContext synMessageContext) {
         send(synMessageContext);
     }
 
-    public void setParentEndpoint(Endpoint parentEndpoint) {
-        this.parentEndpoint = parentEndpoint;
-    }
+    public boolean readyToSend() {
+        for (Endpoint endpoint : getChildren()) {
+            if (endpoint.readyToSend()) {
+                currentEndpoint = endpoint;
+                return true;
+            }
+        }
+        return false;
+    }        
 }
diff --git a/java/modules/core/src/main/java/org/apache/synapse/endpoints/IndirectEndpoint.java b/java/modules/core/src/main/java/org/apache/synapse/endpoints/IndirectEndpoint.java
index a6779245f..47987ba76 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/endpoints/IndirectEndpoint.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/endpoints/IndirectEndpoint.java
@@ -19,70 +19,29 @@
 
 package org.apache.synapse.endpoints;
 
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.synapse.FaultHandler;
+import org.apache.axis2.context.ConfigurationContext;
+import org.apache.axis2.description.Parameter;
 import org.apache.synapse.MessageContext;
 import org.apache.synapse.SynapseConstants;
-import org.apache.synapse.SynapseException;
-import org.apache.synapse.endpoints.utils.EndpointDefinition;
+import org.apache.synapse.config.SynapseConfiguration;
+
+import java.util.List;
 
 /**
- * This class represents the endpoints referred by keys. It does not store the actual referred
- * endpoint as a private variable as it could expire. Therefore, it only stores the key and gets the
- * actual endpoint from the synapse configuration.
- * <p/>
- * As this is also an instance of endpoint, this can be used any place, where a normal endpoint is
- * used.
+ * This class represents a real endpoint referred by a key. An Indirect endpoint does not really
+ * have a life, but merely acts as a virtual endpoint for the actual endpoint refferred.
  */
-public class IndirectEndpoint extends FaultHandler implements Endpoint {
-
-    private static final Log trace = LogFactory.getLog(SynapseConstants.TRACE_LOGGER);
-    private static final Log log = LogFactory.getLog(IndirectEndpoint.class);
+public class IndirectEndpoint extends AbstractEndpoint {
 
-    private String name = null;
     private String key = null;
-    private Endpoint parentEndpoint = null;
-
-    public void send(MessageContext synMessageContext) {
-
-        // get the actual endpoint and send
-        Endpoint endpoint = synMessageContext.getEndpoint(key);
-        if (endpoint == null) {
-            handleException("Reference to non-existent endpoint for key : " + key);
-        }
-
-        assert endpoint != null;
-        if (endpoint.isActive(synMessageContext)) {
-             // register this as the immediate fault handler for this message.
-            synMessageContext.pushFaultHandler(this);
-            endpoint.send(synMessageContext);
-        } else {
-            // if this is a child of some other endpoint, inform parent about the failure.
-            // if not, inform to the next fault handler.
-            if (parentEndpoint != null) {
-                auditWarn("Endpoint : " + endpoint.getName() + " is currently inactive" +
-                        " - invoking parent endpoint", synMessageContext);
-                parentEndpoint.onChildEndpointFail(this, synMessageContext);
+    private Endpoint realEndpoint = null;
 
-            } else {
-                auditWarn("Endpoint : " + endpoint.getName() + " is currently inactive" +
-                        " - invoking fault handler / assuming failure", synMessageContext);
-
-                Object o = synMessageContext.getFaultStack().pop();
-                if (o != null) {
-                    ((FaultHandler) o).handleFault(synMessageContext);
-                }
-            }
-        }
-    }
-
-    public String getName() {
-        return name;
-    }
-
-    public void setName(String name) {
-        this.name = name.trim();
+    /**
+     * Send by calling to the real endpoint
+     * @param synCtx the message to send
+     */
+    public void send(MessageContext synCtx) {
+        realEndpoint.send(synCtx);
     }
 
     public String getKey() {
@@ -93,100 +52,58 @@ public class IndirectEndpoint extends FaultHandler implements Endpoint {
         this.key = key;
     }
 
+    @Override
     /**
-     * IndirectEndpoints are active if its referref endpoint is active and vise versa. Therefore,
-     * this returns if its referred endpoint is active or not.
-     *
-     * @param synMessageContext MessageContext of the current message.
-     * @return true if the referred endpoint is active. false otherwise.
+     * Ready to send, if the real endpoint is ready
      */
-    public boolean isActive(MessageContext synMessageContext) {
-        Endpoint endpoint = synMessageContext.getEndpoint(key);
-        if (endpoint == null) {
-            handleException("Reference to non-existent endpoint for key : " + key);
-        }
-
-        assert endpoint != null;
-        return endpoint.isActive(synMessageContext);
+    public boolean readyToSend() {
+        return realEndpoint.readyToSend();
     }
 
-    /**
-     * Activating or deactivating an IndirectEndpoint is the activating or deactivating its
-     * referref endpoint. Therefore, this sets the active state of its referred endpoint.
-     *
-     * @param active            true if active. false otherwise.
-     * @param synMessageContext MessageContext of the current message.
-     */
-    public void setActive(boolean active, MessageContext synMessageContext) {
-        Endpoint endpoint = synMessageContext.getEndpoint(key);
-        if (endpoint == null) {
-            handleException("Reference to non-existent endpoint for key : " + key);
-        }
-
-        assert endpoint != null;
-        endpoint.setActive(active, synMessageContext);
+    @Override
+    public void setName(String endpointName) {
+        // do nothing, also prevent this endpoint from binding to JMX
     }
 
-    public void setParentEndpoint(Endpoint parentEndpoint) {
-        this.parentEndpoint = parentEndpoint;
+    @Override
+    public EndpointContext getContext() {
+        return realEndpoint.getContext();
     }
 
-    public void onChildEndpointFail(Endpoint endpoint, MessageContext synMessageContext) {
-
-        // if this is a child of some other endpoint, inform parent about the failure.
-        // if not, inform to the next fault handler.
-        if (parentEndpoint != null) {
-            parentEndpoint.onChildEndpointFail(this, synMessageContext);
-        } else {
-            Object o = synMessageContext.getFaultStack().pop();
-            if (o != null) {
-                ((FaultHandler) o).handleFault(synMessageContext);
-            }
-        }
+    @Override
+    public List<Endpoint> getChildren() {
+        return realEndpoint.getChildren();
     }
 
-    private void handleException(String msg) {
-        log.error(msg);
-        throw new SynapseException(msg);
+    @Override
+    /**
+     * Since an Indirect never sends messages for real, it has no moetrics.. but those of its
+     * actual endpoint
+     */
+    public EndpointView getMetricsMBean() {
+        return realEndpoint.getMetricsMBean();
     }
 
-    protected void auditWarn(String msg, MessageContext msgContext) {
-        log.warn(msg);
-        if (msgContext.getServiceLog() != null) {
-            msgContext.getServiceLog().warn(msg);
+    @Override
+    /**
+     * Figure out the real endpoint we proxy for, and make sure its initialized
+     */
+    public synchronized void init(ConfigurationContext cc) {
+        Parameter param = cc.getAxisConfiguration().getParameter(SynapseConstants.SYNAPSE_CONFIG);
+        if (param != null && param.getValue() instanceof SynapseConfiguration) {
+            SynapseConfiguration synCfg = (SynapseConfiguration) param.getValue();
+            realEndpoint = synCfg.getEndpoint(key);
         }
-        if (shouldTrace(msgContext)) {
-            trace.warn(msg);
+        if (realEndpoint == null) {
+            handleException("Unable to load endpoint with key : " + key);
         }
-    }
-
-    public boolean shouldTrace(MessageContext synCtx) {
-        Endpoint endpoint = synCtx.getEndpoint(key);
-        EndpointDefinition endptDefn = null;
-        if (endpoint instanceof AddressEndpoint) {
-            AddressEndpoint addEndpt = (AddressEndpoint) endpoint;
-            endptDefn = addEndpt.getEndpoint();
-        } else if (endpoint instanceof WSDLEndpoint) {
-            WSDLEndpoint wsdlEndpt = (WSDLEndpoint) endpoint;
-            endptDefn = wsdlEndpt.getEndpoint();
+        if (!realEndpoint.isInitialized()) {
+            realEndpoint.init(cc);
         }
-
-        return endptDefn != null && ((endptDefn.getTraceState() == SynapseConstants.TRACING_ON) ||
-                (endptDefn.getTraceState() == SynapseConstants.TRACING_UNSET &&
-                        synCtx.getTracingState() == SynapseConstants.TRACING_ON));
     }
 
-    public void onFault(MessageContext synMessageContext) {
-        // At this point,child endpoint is in inactive state
-        // if this is a child of some other endpoint, inform parent about the failure.
-        // if not, inform to the next fault handler.
-        if (parentEndpoint != null) {
-            parentEndpoint.onChildEndpointFail(this, synMessageContext);
-        } else {
-            Object o = synMessageContext.getFaultStack().pop();
-            if (o != null) {
-                ((FaultHandler) o).handleFault(synMessageContext);
-            }
-        }
+    @Override
+    public String toString() {
+        return "[Indirect Endpoint [ " + key + "]]";
     }
 }
diff --git a/java/modules/core/src/main/java/org/apache/synapse/endpoints/LoadbalanceEndpoint.java b/java/modules/core/src/main/java/org/apache/synapse/endpoints/LoadbalanceEndpoint.java
index 40619bfed..3a616e36e 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/endpoints/LoadbalanceEndpoint.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/endpoints/LoadbalanceEndpoint.java
@@ -19,333 +19,106 @@
 
 package org.apache.synapse.endpoints;
 
-import org.apache.axis2.addressing.EndpointReference;
-import org.apache.axis2.clustering.ClusterManager;
-import org.apache.axis2.clustering.Member;
 import org.apache.axis2.context.ConfigurationContext;
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
 import org.apache.synapse.FaultHandler;
 import org.apache.synapse.MessageContext;
 import org.apache.synapse.SynapseConstants;
-import org.apache.synapse.SynapseException;
-import org.apache.synapse.core.axis2.Axis2MessageContext;
 import org.apache.synapse.endpoints.algorithms.AlgorithmContext;
 import org.apache.synapse.endpoints.algorithms.LoadbalanceAlgorithm;
-import org.apache.synapse.endpoints.utils.EndpointDefinition;
-
-import java.net.MalformedURLException;
-import java.net.URL;
-import java.net.InetAddress;
-import java.net.SocketAddress;
-import java.net.InetSocketAddress;
-import java.net.Socket;
-import java.util.List;
-import java.util.TimerTask;
-import java.util.Timer;
-import java.util.ArrayList;
-import java.io.IOException;
 
 /**
- * Load balance endpoint can have multiple endpoints. It will route messages according to the
+ * A Load balance endpoint contains multiple child endpoints. It routes messages according to the
  * specified load balancing algorithm. This will assume that all immediate child endpoints are
  * identical in state (state is replicated) or state is not maintained at those endpoints. If an
- * endpoint is failing, the failed endpoint is marked as inactive and the message to the next
- * endpoint obtained using the load balancing algorithm. If all the endpoints have failed and the
+ * endpoint is failing, the failed endpoint is marked as inactive and the message sent to the next
+ * endpoint obtained using the load balancing algorithm. If all the endpoints have failed and a
  * parent endpoint is available, onChildEndpointFail(...) method of parent endpoint is called. If
- * parent is not available, this will call next FaultHandler for the message context.
+ * a parent is not available, this will call next FaultHandler for the message context.
  */
-public class LoadbalanceEndpoint implements Endpoint {
-
-    private static final Log log = LogFactory.getLog(LoadbalanceEndpoint.class);
-    /**
-     * Name of the endpoint. Used for named endpoints which can be referred using the key attribute
-     * of indirect endpoints.
-     */
-    private String name = null;
-
-    /**
-     * List of endpoints among which the load is distributed. Any object implementing the Endpoint
-     * interface could be used.
-     */
-    private List<Endpoint> endpoints = null;
-
-    /**
-     * List of currently available application members amongst which the load is distributed
-     */
-    private List<Member> activeMembers = null;
+public class LoadbalanceEndpoint extends AbstractEndpoint {
 
-    /**
-     * List of currently unavailable members
-     */
-    private List<Member> inactiveMembers = null;
-
-    /**
-     * Algorithm used for selecting the next endpoint to direct the load. Default is RoundRobin.
-     */
+    /** Should this load balancer fail over as well? */
+    private boolean failover = true;
+    /** The algorithm used for selecting the next endpoint */
     private LoadbalanceAlgorithm algorithm = null;
-
-    /**
-     * If this supports load balancing with failover. If true, request will be directed to the next
-     * endpoint if the current one is failing.
-     */
-    protected boolean failover = true;
-
-    /**
-     * Parent endpoint of this endpoint if this used inside another endpoint. Possible parents are
-     * LoadbalanceEndpoint, SALoadbalanceEndpoint and FailoverEndpoint objects.
-     */
-    private Endpoint parentEndpoint = null;
-
-    /**
-     * The endpoint context , place holder for keep any runtime states related to the endpoint
-     */
-    private final EndpointContext endpointContext = new EndpointContext();
-
-    /**
-     * The algorithm context , place holder for keep any runtime states related to the load balance
-     * algorithm
-     */
-    private final AlgorithmContext algorithmContext = new AlgorithmContext();
-
-    public void startApplicationMembershipTimer(){
-        Timer timer = new Timer();
-        timer.scheduleAtFixedRate(new MemberActivatorTask(), 1000, 500);
-    }
-
-    public void send(MessageContext synMessageContext) {
-
-        if (log.isDebugEnabled()) {
-            log.debug("Start : Load-balance Endpoint");
-        }
-
-        boolean isClusteringEnable = false;
-        // get Axis2 MessageContext and ConfigurationContext
-        org.apache.axis2.context.MessageContext axisMC =
-                ((Axis2MessageContext) synMessageContext).getAxis2MessageContext();
-        ConfigurationContext cc = axisMC.getConfigurationContext();
-
-        //The check for clustering environment
-
-        ClusterManager clusterManager = cc.getAxisConfiguration().getClusterManager();
-        if (clusterManager != null &&
-            clusterManager.getContextManager() != null) {
-            isClusteringEnable = true;
-        }
-
-        String endPointName = this.getName();
-        if (endPointName == null) {
-
-            if (isClusteringEnable) {
-                log.warn("In a clustering environment , the endpoint  name should be specified" +
-                         "even for anonymous endpoints. Otherwise , the clustering would not be " +
-                         "functioned correctly if there are more than one anonymous endpoints. ");
-            }
-            endPointName = SynapseConstants.ANONYMOUS_ENDPOINT;
-        }
-
-        if (isClusteringEnable) {
-
-            // if this is a cluster environment , then set configuration context to endpoint context
-            if (endpointContext.getConfigurationContext() == null) {
-                endpointContext.setConfigurationContext(cc);
-                endpointContext.setContextID(endPointName);
-
-            }
-            // if this is a cluster environment , then set configuration context to load balance
-            //  algorithm context
-            if (algorithmContext.getConfigurationContext() == null) {
-                algorithmContext.setConfigurationContext(cc);
-                algorithmContext.setContextID(endPointName);
+    /** The algorithm context to hold runtime state related to the load balance algorithm */
+    private AlgorithmContext algorithmContext = null;
+
+    public void init(ConfigurationContext cc) {
+        if (!initialized) {
+            super.init(cc);
+            if (algorithmContext == null) {
+                algorithmContext = new AlgorithmContext(isClusteringEnabled, cc, getName());
             }
         }
-
-        if (endpoints != null) {
-            sendToEndpoint(synMessageContext);
-        } else if (activeMembers != null) {
-            EndpointReference to = synMessageContext.getTo();
-            LoadbalanceFaultHandler faultHandler = new LoadbalanceFaultHandler(to);
-            if (failover) {
-                synMessageContext.pushFaultHandler(faultHandler);
-            }
-            sendToApplicationMember(synMessageContext, to, faultHandler);
-        }
     }
 
-    private void sendToEndpoint(MessageContext synMessageContext) {
-        Endpoint endpoint = algorithm.getNextEndpoint(synMessageContext, algorithmContext);
-        if (endpoint != null) {
+    public void send(MessageContext synCtx) {
 
-            // We have to build the envelop if we are supporting failover.
-            // Failover should sent the original message multiple times if failures occur. So we
-            // have to access the envelop multiple times.
-            if (failover) {
-                synMessageContext.getEnvelope().build();
-            }
-
-            endpoint.send(synMessageContext);
-
-        } else {
-            // there are no active child endpoints. so mark this endpoint as failed.
-            setActive(false, synMessageContext);
-
-            if (parentEndpoint != null) {
-                parentEndpoint.onChildEndpointFail(this, synMessageContext);
-            } else {
-                Object o = synMessageContext.getFaultStack().pop();
-                if (o != null) {
-                    ((FaultHandler) o).handleFault(synMessageContext);
-                }
-            }
+        if (log.isDebugEnabled()) {
+            log.debug("Load-balance Endpoint :  " + getName());
         }
-    }
-
-    private void sendToApplicationMember(MessageContext synCtx,
-                                         EndpointReference to,
-                                         LoadbalanceFaultHandler faultHandler) {
-        org.apache.axis2.context.MessageContext axis2MsgCtx =
-                ((Axis2MessageContext) synCtx).getAxis2MessageContext();
 
-        String transport = axis2MsgCtx.getTransportIn().getName();
-        algorithm.setApplicationMembers(activeMembers);
-        Member currentMember = algorithm.getNextApplicationMember(algorithmContext);
-        faultHandler.setCurrentMember(currentMember);
+        Endpoint endpoint = getNextChild(synCtx); 
 
-        if (currentMember != null) {
-
-            // URL rewrite
-            if (transport.equals("http") || transport.equals("https")) {
-                String address = to.getAddress();
-                if (address.indexOf(":") != -1) {
-                    try {
-                        address = new URL(address).getPath();
-                    } catch (MalformedURLException e) {
-                        String msg = "URL " + address + " is malformed";
-                        log.error(msg, e);
-                        throw new SynapseException(msg, e);
-                    }
-                }
-                EndpointReference epr =
-                        new EndpointReference(transport + "://" + currentMember.getHostName() +
-                                              ":" + currentMember.getHttpPort() + address);
-                synCtx.setTo(epr);
+        if (endpoint != null) {
+            // if this is not a retry
+            if (synCtx.getProperty(SynapseConstants.LAST_ENDPOINT) == null) {
+                // We have to build the envelop when we are supporting failover, as we
+                // may have to retry this message for failover support
                 if (failover) {
                     synCtx.getEnvelope().build();
                 }
-
-                AddressEndpoint endpoint = new AddressEndpoint();
-                EndpointDefinition definition = new EndpointDefinition();
-                endpoint.setEndpoint(definition);
-                endpoint.send(synCtx);
             } else {
-                log.error("Cannot load balance for non-HTTP/S transport " + transport);
+                // this is a retry, where we are now failing over to an active node
+                metricsMBean.reportSendingFault(SynapseConstants.ENDPOINT_LB_FAIL_OVER);
             }
-        } else {
-            synCtx.getFaultStack().pop(); // Remove the LoadbalanceFaultHandler
-            String msg = "No application members available";
-            log.error(msg);
-            throw new SynapseException(msg);
-        }
-    }
-
-    public String getName() {
-        return name;
-    }
-
-    public void setName(String name) {
-        this.name = name.trim();
-    }
-
-    public LoadbalanceAlgorithm getAlgorithm() {
-        return algorithm;
-    }
-
-    public void setAlgorithm(LoadbalanceAlgorithm algorithm) {
-        this.algorithm = algorithm;
-    }
-
-    public void setMembers(List<Member> members) {
-        this.activeMembers = members;
-        this.inactiveMembers = new ArrayList<Member>();
-    }
+            synCtx.pushFaultHandler(this);
+            endpoint.send(synCtx);
 
-    public List<Member> getAllMembers() {
-        List<Member> members = new ArrayList<Member>();
-        if (activeMembers != null) {
-            for (Member member:activeMembers) {
-                if(!members.contains(member)){
-                    members.add(member);
-                }
-            }
-        }
-        if (inactiveMembers != null) {
-            for (Member member:inactiveMembers) {
-                if(!members.contains(member)){
-                    members.add(member);
-                }
+        } else {
+            // if this is not a retry
+            if (synCtx.getProperty(SynapseConstants.LAST_ENDPOINT) == null) {
+                synCtx.setProperty(SynapseConstants.ERROR_CODE, SynapseConstants.ENDPOINT_LB_NONE_READY);
+                synCtx.setProperty(SynapseConstants.ERROR_MESSAGE,
+                    "Loadbalance endpoint : " + getName() + " - no ready child endpoints");
+                synCtx.setProperty(SynapseConstants.ERROR_DETAIL,
+                    "Loadbalance endpoint : " + getName() + " - no ready child endpoints");
+                synCtx.setProperty(SynapseConstants.ERROR_EXCEPTION, null);
             }
+            super.onFault(synCtx);
         }
-        return members;
     }
-    
+
     /**
      * If this endpoint is in inactive state, checks if all immediate child endpoints are still
      * failed. If so returns false. If at least one child endpoint is in active state, sets this
      * endpoint's state to active and returns true. As this a sessionless load balancing endpoint
      * having one active child endpoint is enough to consider this as active.
      *
-     * @param synMessageContext MessageContext of the current message. This is not used here.
      * @return true if active. false otherwise.
      */
-    public boolean isActive(MessageContext synMessageContext) {
-        boolean active = endpointContext.isActive();
-        if (!active && endpoints != null) {
-            for (Endpoint endpoint : endpoints) {
-                if (endpoint.isActive(synMessageContext)) {
-                    active = true;
-                    endpointContext.setActive(true);
-
-                    // don't break the loop though we found one active endpoint. calling isActive()
-                    // on all child endpoints will update their active state. so this is a good
-                    // time to do that.
+    public boolean readyToSend() {
+        for (Endpoint endpoint : getChildren()) {
+            if (endpoint.readyToSend()) {
+                if (log.isDebugEnabled()) {
+                    log.debug("Endpoint : " + getName() + " has at least one ready endpoint");
                 }
+                return true;
             }
         }
 
-        if (log.isDebugEnabled()) {
-            log.debug("Endpoint  '" + name + "' is in state ' " + active + " '");
-        }
-
-        return active;
-    }
-
-    public void setActive(boolean active, MessageContext synMessageContext) {
-        // setting a volatile boolean variable is thread safe.
-        endpointContext.setActive(active);
-    }
-
-    public boolean isFailover() {
-        return failover;
-    }
-
-    public void setFailover(boolean failover) {
-        this.failover = failover;
-    }
-
-    public List<Endpoint> getEndpoints() {
-        return endpoints;
-    }
-
-    public void setEndpoints(List<Endpoint> endpoints) {
-        this.endpoints = endpoints;
-    }
+        log.warn("Endpoint : " + getName() + " has no ready endpoints to process message");
 
-    public void setParentEndpoint(Endpoint parentEndpoint) {
-        this.parentEndpoint = parentEndpoint;
+        return false;
     }
 
     public void onChildEndpointFail(Endpoint endpoint, MessageContext synMessageContext) {
 
+        if (log.isDebugEnabled()) {
+            log.debug("child endpoind of load balance endpoint : " + getName() + " failed");
+        }
+
         // resend (to a different endpoint) only if we support failover
         if (failover) {
             send(synMessageContext);
@@ -361,94 +134,27 @@ public class LoadbalanceEndpoint implements Endpoint {
         }
     }
 
-    /**
-     * This FaultHandler will try to resend the message to another member if an error occurs
-     * while sending to some member. This is a failover mechanism
-     */
-    private class LoadbalanceFaultHandler extends FaultHandler {
-
-        private EndpointReference to;
-        private Member currentMember;
-
-        public void setCurrentMember(Member currentMember) {
-            this.currentMember = currentMember;
-        }
-
-        private LoadbalanceFaultHandler(EndpointReference to) {
-            this.to = to;
-        }
+    public boolean isFailover() {
+        return failover;
+    }
 
-        public void onFault(MessageContext synCtx) {
-            if (currentMember == null) {
-                return;
-            }
-            synCtx.pushFaultHandler(this);
-            activeMembers.remove(currentMember); // This member has to be inactivated
-            inactiveMembers.add(currentMember);
-            sendToApplicationMember(synCtx, to, this);
-        }
+    public void setFailover(boolean failover) {
+        this.failover = failover;
     }
 
-    /**
-     * The task which checks whther inactive members have become available again 
-     */
-    private class MemberActivatorTask extends TimerTask{
+    public LoadbalanceAlgorithm getAlgorithm() {
+        return algorithm;
+    }
 
-        public void run() {
-            try {
-                for(Member member: inactiveMembers){
-                    if(canConnect(member)){
-                        inactiveMembers.remove(member);
-                        activeMembers.add(member);
-                    }
-                }
-            } catch (Exception ignored) {
-                // Ignore all exceptions. The timer should continue to run
-            }
+    public void setAlgorithm(LoadbalanceAlgorithm algorithm) {
+        if (log.isDebugEnabled()) {
+            log.debug("Endpoint : " + getName() + " will be using the "
+                + algorithm.getName() + " for load distribution");
         }
+        this.algorithm = algorithm;
+    }
 
-        /**
-         * Before activating a member, we will try to verify whether we can connect to it
-         *
-         * @param member The member whose connectvity needs to be verified
-         * @return true, if the member can be contacted; false, otherwise.
-         */
-        private boolean canConnect(Member member) {
-            if(log.isDebugEnabled()){
-                log.debug("Trying to connect to member " + member.getHostName() + "...");
-            }
-            for (int retries = 30; retries > 0; retries--) {
-                try {
-                    InetAddress addr = InetAddress.getByName(member.getHostName());
-                    int httpPort = member.getHttpPort();
-                    if(log.isDebugEnabled()){
-                        log.debug("HTTP Port=" + httpPort);
-                    }
-                    if (httpPort != -1) {
-                        SocketAddress httpSockaddr = new InetSocketAddress(addr, httpPort);
-                        new Socket().connect(httpSockaddr, 10000);
-                    }
-                    int httpsPort = member.getHttpsPort();
-                    if(log.isDebugEnabled()){
-                        log.debug("HTTPS Port=" + httpPort);
-                    }
-                    if (httpsPort != -1) {
-                        SocketAddress httpsSockaddr = new InetSocketAddress(addr, httpsPort);
-                        new Socket().connect(httpsSockaddr, 10000);
-                    }
-                    return true;
-                } catch (IOException e) {
-                    if(log.isDebugEnabled()){
-                        log.debug("", e);
-                    }
-                    String msg = e.getMessage();
-                    if (msg.indexOf("Connection refused") == -1 &&
-                        msg.indexOf("connect timed out") == -1) {
-                        log.error("Cannot connect to member " + member, e);
-                    }
-                }
-            }
-            return false;
-        }
+    protected Endpoint getNextChild(MessageContext synCtx) {
+        return algorithm.getNextEndpoint(synCtx, algorithmContext);
     }
 }
diff --git a/java/modules/core/src/main/java/org/apache/synapse/endpoints/SALoadbalanceEndpoint.java b/java/modules/core/src/main/java/org/apache/synapse/endpoints/SALoadbalanceEndpoint.java
index 9bb63a239..cfffa3f2e 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/endpoints/SALoadbalanceEndpoint.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/endpoints/SALoadbalanceEndpoint.java
@@ -19,22 +19,18 @@
 
 package org.apache.synapse.endpoints;
 
-import org.apache.axis2.clustering.ClusterManager;
 import org.apache.axis2.context.ConfigurationContext;
-import org.apache.axis2.context.OperationContext;
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.synapse.FaultHandler;
 import org.apache.synapse.MessageContext;
 import org.apache.synapse.SynapseConstants;
-import org.apache.synapse.core.axis2.Axis2MessageContext;
 import org.apache.synapse.endpoints.algorithms.AlgorithmContext;
 import org.apache.synapse.endpoints.algorithms.LoadbalanceAlgorithm;
 import org.apache.synapse.endpoints.dispatch.Dispatcher;
-import org.apache.synapse.endpoints.dispatch.DispatcherContext;
+import org.apache.synapse.endpoints.dispatch.SALSessions;
+import org.apache.synapse.endpoints.dispatch.SessionInformation;
 
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Set;
 
 /**
  * SALoadbalanceEndpoint supports session affinity based load balancing. Each of this endpoint
@@ -55,443 +51,281 @@ import java.util.List;
  * send(...) method of that endpoint. If not it will find an endpoint using the load balancing
  * policy and send to that endpoint.
  */
-public class SALoadbalanceEndpoint implements Endpoint {
-
-    private static final Log log = LogFactory.getLog(SALoadbalanceEndpoint.class);
-
-    private static final String FIRST_MESSAGE_IN_SESSION = "first_message_in_session";
-    public static final String ENDPOINT_LIST = "endpointList";
-    public static final String ROOT_ENDPOINT = "rootendpoint";
-    public static final String ENDPOINT_NAME_LIST = "endpointNameList";
-    public static final String WARN_MESSAGE = "In a clustering environment, the endpoint " +
-            "name should be specified even for anonymous endpoints. Otherwise the clustering " +
-            "would not function properly, if there are more than one anonymous endpoints.";
-
-    /**
-     * Name of the endpoint. Used for named endpoints which can be referred using the key attribute
-     * of indirect endpoints.
-     */
-    private String name = null;
-
-    /**
-     * List of endpoints among which the load is distributed. Any object implementing the Endpoint
-     * interface could be used.
-     */
-    private List<Endpoint> endpoints = null;
-
-    /**
-     * Algorithm used for selecting the next endpoint to direct the first request of sessions.
-     * Default is RoundRobin.
-     */
-    private LoadbalanceAlgorithm algorithm = null;
-
-    /**
-     * Parent endpoint of this endpoint if this used inside another endpoint. Although any endpoint
-     * can be the parent, only SALoadbalanceEndpoint should be used here. Use of any other endpoint
-     * would invalidate the session.
-     */
-    private Endpoint parentEndpoint = null;
-
+public class SALoadbalanceEndpoint extends LoadbalanceEndpoint {
+  
     /**
      * Dispatcher used for session affinity.
      */
     private Dispatcher dispatcher = null;
 
-    /**
-     * The dispatcher context, place holder for keeping any runtime states that are used when
-     * finding endpoint for the session
-     */
-    private final DispatcherContext dispatcherContext = new DispatcherContext();
 
-    /**
-     * The endpoint context, place holder for keeping any runtime states related to the endpoint
-     */
-    private final EndpointContext endpointContext = new EndpointContext();
+    /* Sessions time out interval*/
+    private long sessionTimeout = -1;
 
-    /**
-     * The algorithm context, place holder for keeping any runtime states related to the load
-     * balance algorithm
-     */
-    private final AlgorithmContext algorithmContext = new AlgorithmContext();
+    public void init(ConfigurationContext cc) {
 
+        if (!initialized) {
 
-    public void send(MessageContext synMessageContext) {
+            super.init(cc);
+            // Initialize the SAL Sessions if already has not been initialized.
+            SALSessions salSessions = SALSessions.getInstance();
+            if (!salSessions.isInitialized()) {
+                salSessions.initialize(isClusteringEnabled, cc);
+            }
 
-        if (log.isDebugEnabled()) {
-            log.debug("Start : Session Affinity Load-balance Endpoint " + name);
-        }
+            //For each root level SAL endpoints , all children are registered 
+            // This is for cluttering as in clustering only endpoint names are replicated 
+            // and it needs way to pick endpoints by name
+            if (isClusteringEnabled && (this.getParentEndpoint() == null ||
+                    !(this.getParentEndpoint() instanceof SALoadbalanceEndpoint))) {
+                SALSessions.getInstance().registerChildren(this, getChildren());
+            }
 
-        boolean isClusteringEnable = false;
-        // get Axis2 MessageContext and ConfigurationContext
-        org.apache.axis2.context.MessageContext axisMC =
-                ((Axis2MessageContext) synMessageContext).getAxis2MessageContext();
-        ConfigurationContext cc = axisMC.getConfigurationContext();
-
-        //The check for clustering environment
-        ClusterManager clusterManager = cc.getAxisConfiguration().getClusterManager();
-        if (clusterManager != null &&
-                clusterManager.getContextManager() != null) {
-            isClusteringEnable = true;
         }
+    }
 
-        String endpointName = this.getName();
-        if (endpointName == null) {
-            if (isClusteringEnable) {
-                log.warn(WARN_MESSAGE);
-            }
-            if (log.isDebugEnabled()) {
-                log.debug("Using the name for the anonymous endpoint as : '"
-                        + SynapseConstants.ANONYMOUS_ENDPOINT + "'");
-            }
-            endpointName = SynapseConstants.ANONYMOUS_ENDPOINT;
+    public void send(MessageContext synCtx) {
+
+        if (log.isDebugEnabled()) {
+            log.debug("Start : Session Affinity Load-balance Endpoint " + getName());
         }
+        // first check if this session is associated with a session. if so, get the endpoint
+        // associated for that session.
 
-        if (isClusteringEnable) {
+        SessionInformation sessionInformation =
+                (SessionInformation) synCtx.getProperty(
+                        SynapseConstants.PROP_SAL_CURRENT_SESSION_INFORMATION);
 
-            // if this is a cluster environment, then set configuration context to endpoint context
-            if (endpointContext.getConfigurationContext() == null) {
+        List<Endpoint> endpoints = (List<Endpoint>) synCtx.getProperty(
+                SynapseConstants.PROP_SAL_ENDPOINT_CURRENT_ENDPOINT_LIST);
 
-                if (log.isDebugEnabled()) {
-                    log.debug("Setting the ConfigurationContext to " +
-                            "the EndpointContext with the name " + endpointName +
-                            " for replicating data on the cluster");
-                }
-                endpointContext.setConfigurationContext(cc);
-                endpointContext.setContextID(endpointName);
-            }
+        if (sessionInformation == null && endpoints == null) {
 
-            // if this is a cluster environment, then set configuration context to load balance
-            //  algorithm context
-            if (algorithmContext.getConfigurationContext() == null) {
+            sessionInformation = dispatcher.getSession(synCtx);
+            if (sessionInformation != null) {
 
                 if (log.isDebugEnabled()) {
-                    log.debug("Setting the ConfigurationContext to " +
-                            "the AlgorithmContext with the name " + endpointName +
-                            " for replicating data on the cluster");
+                    log.debug("Current session id : " + sessionInformation.getId());
                 }
-                algorithmContext.setConfigurationContext(cc);
-                algorithmContext.setContextID(endpointName);
-            }
-
-            // if this is a cluster environment, then set configuration context to session based
-            // endpoint dispatcher
-            if (dispatcherContext.getConfigurationContext() == null) {
-
+                endpoints =
+                        dispatcher.getEndpoints(sessionInformation);
                 if (log.isDebugEnabled()) {
-                    log.debug("Setting the ConfigurationContext to " +
-                            "the DispatcherContext with the name " + endpointName +
-                            " for replicating data on the cluster");
+                    log.debug("Endpoint sequence (path) on current session : " + this + endpoints);
                 }
-                dispatcherContext.setConfigurationContext(cc);
-                dispatcherContext.setContextID(endpointName);
 
-                if (log.isDebugEnabled()) {
-                    log.debug("Setting the endpoints to the DispatcherContext : " + endpoints);
-                }
-                dispatcherContext.setEndpoints(endpoints);
+                synCtx.setProperty(
+                        SynapseConstants.PROP_SAL_ENDPOINT_CURRENT_ENDPOINT_LIST, endpoints);
+                // This is for reliably recovery any session information if while response is getting ,
+                // session information has been removed by cleaner.
+                // This will not be a cost as  session information a not heavy data structure
+                synCtx.setProperty(
+                        SynapseConstants.PROP_SAL_CURRENT_SESSION_INFORMATION, sessionInformation);
             }
         }
 
-        // first check if this session is associated with a session. if so, get the endpoint
-        // associated for that session.
-        Endpoint endpoint = dispatcher.getEndpoint(synMessageContext, dispatcherContext);
-        if (endpoint == null) {
+        if (sessionInformation != null && endpoints != null) {
+            //send message on current session
+            sendMessageOnCurrentSession(sessionInformation.getId(), endpoints, synCtx);
+        } else {
+            // prepare for a new session 
+            sendMessageOnNewSession(synCtx);
+        }
+    }  
 
-            // there is no endpoint associated with this session. get a new endpoint using the
-            // load balance policy.
-            endpoint = algorithm.getNextEndpoint(synMessageContext, algorithmContext);
+    public Dispatcher getDispatcher() {
+        return dispatcher;
+    }
 
-            // this is a start of a new session. so update session map.
-            if (dispatcher.isServerInitiatedSession()) {
+    public void setDispatcher(Dispatcher dispatcher) {
+        this.dispatcher = dispatcher;
+    }
 
-                if (log.isDebugEnabled()) {
-                    log.debug("Adding a new server initiated session for the current message");
-                }
+    /**
+     * It is logically incorrect to failover a session affinity endpoint after the session has started.
+     * If we redirect a message belonging to a particular session, new endpoint is not aware of the
+     * session. So we can't handle anything more at the endpoint level. Therefore, this method just
+     * deactivate the failed endpoint and give the fault to the next fault handler.
+     * <p/>
+     * But if the session has not started (i.e. first message), the message will be resend by binding
+     * it to a different endpoint.
+     *
+     * @param endpoint          Failed endpoint.
+     * @param synCtx MessageContext of the failed message.
+     */
+    public void onChildEndpointFail(Endpoint endpoint, MessageContext synCtx) {
 
-                // add this endpoint to the endpoint sequence of operation context.
-                Axis2MessageContext axis2MsgCtx = (Axis2MessageContext) synMessageContext;
-                OperationContext opCtx = axis2MsgCtx.getAxis2MessageContext().getOperationContext();
+        Object o = synCtx.getProperty(
+                SynapseConstants.PROP_SAL_ENDPOINT_FIRST_MESSAGE_IN_SESSION);
 
-                if (isClusteringEnable) {
-                    // If running on a cluster keep endpoint names, because it is heavy to
-                    // replicate endpoint itself
+        if (o != null && Boolean.TRUE.equals(o)) {
 
-                    Object o = opCtx.getPropertyNonReplicable(ENDPOINT_NAME_LIST);
-                    List<String> epNameList;
-                    if (o instanceof List) {
-                        epNameList = (List<String>) o;
-                        epNameList.add(endpointName);
+            // this is the first message. so unbind the session with failed endpoint and start
+            // new one by resending.
+            
+            dispatcher.unbind(synCtx);
+            
+            // As going to be happened retry , we have to remove states related to the previous try 
+            
+            Object epListObj = synCtx.getProperty(SynapseConstants.PROP_SAL_ENDPOINT_ENDPOINT_LIST);
+            if (epListObj instanceof List) {
+                List<Endpoint> endpointList = (List<Endpoint>) epListObj;
+                if (!endpointList.isEmpty()) {
+                    if (endpointList.get(0) == this) {
+                        endpointList.clear();
                     } else {
-                        // this is the first endpoint in the heirachy. so create the queue and
-                        // insert this as the first element.
-                        epNameList = new ArrayList<String>();
-                        epNameList.add(endpointName);
-                        opCtx.setNonReplicableProperty(ROOT_ENDPOINT, this);
-                    }
-                    
-                    // if the next endpoint is not a session affinity one, endpoint sequence ends
-                    // here. but we have to add the next endpoint to the list.
-                    if (!(endpoint instanceof SALoadbalanceEndpoint)) {
-
-                        String name;
-                        if (endpoint instanceof IndirectEndpoint) {
-                            name = ((IndirectEndpoint) endpoint).getKey();
-                        } else {
-                            name = endpoint.getName();
-                        }
-
-                        if (name == null) {
-                            log.warn(WARN_MESSAGE);
-                            name = SynapseConstants.ANONYMOUS_ENDPOINT;
+                        if (endpointList.contains(this)) {
+                            int lastIndex = endpointList.indexOf(this);
+                            List<Endpoint> head = 
+                                    endpointList.subList(lastIndex , endpointList.size());       
+                            head.clear();
                         }
-                        epNameList.add(name);
-                    }
-
-                    if (log.isDebugEnabled()) {
-                        log.debug("Operating on a cluster. Setting the endpoint name list to " +
-                                "the OperationContext : " + epNameList);
-                    }
-                    opCtx.setProperty(ENDPOINT_NAME_LIST, epNameList);
-
-                } else {
-                    
-                    Object o = opCtx.getProperty(ENDPOINT_LIST);
-                    List<Endpoint> endpointList;
-                    if (o instanceof List) {
-                        endpointList = (List<Endpoint>) o;
-                        endpointList.add(this);
-                    } else {
-                        // this is the first endpoint in the heirachy. so create the queue and
-                        // insert this as the first element.
-                        endpointList = new ArrayList<Endpoint>();
-                        endpointList.add(this);
-                        opCtx.setProperty(ENDPOINT_LIST, endpointList);
-                    }
-                    
-                    // if the next endpoint is not a session affinity one, endpoint sequence ends
-                    // here. but we have to add the next endpoint to the list.
-                    if (!(endpoint instanceof SALoadbalanceEndpoint)) {
-                        endpointList.add(endpoint);
                     }
                 }
-
-            } else {
-                dispatcher.updateSession(synMessageContext, dispatcherContext, endpoint);
-            }
-
-            // this is the first request. so an endpoint has not been bound to this session and we
-            // are free to failover if the currently selected endpoint is not working. but for
-            // failover to work, we have to build the soap envelope.
-            synMessageContext.getEnvelope().build();
-
-            // we should also indicate that this is the first message in the session. so that
-            // onFault(...) method can resend only the failed attempts for the first message.
-            synMessageContext.setProperty(FIRST_MESSAGE_IN_SESSION, Boolean.TRUE);
-        }
-
-        if (endpoint != null) {
-
-            // endpoints given by session dispatchers may not be active. therefore, we have check
-            // it here.
-            if (endpoint.isActive(synMessageContext)) {
-                if (log.isDebugEnabled()) {
-                    log.debug("Using the endpoint on the session with "
-                            + ((endpoint instanceof IndirectEndpoint) ? "key : "
-                            + ((IndirectEndpoint) endpoint).getKey() : "name : "
-                            + endpoint.getName()) + " for sending the message");
-                }
-                endpoint.send(synMessageContext);
-            } else {
-                informFailure(synMessageContext);
             }
+            
+            send(synCtx);
 
         } else {
-
-            // all child endpoints have failed. so mark this also as failed.
-            if (log.isDebugEnabled()) {
-                log.debug("Marking the Endpoint as failed, " +
-                        "because all child endpoints has been failed");
-            }
-            setActive(false, synMessageContext);
-            informFailure(synMessageContext);
+            // session has already started. we can't failover.
+            informFailure(synCtx, SynapseConstants.ENDPOINT_SAL_FAILED_SESSION,
+                    "Failure an endpoint " + endpoint + "  in the  current session");
         }
     }
 
-    /**
-     * This will be called for the response of the first message of each server initiated session.
-     *
-     * @param responseMsgCtx
-     * @param endpointList
-     * @param isClusteringEnable
+    /*
+    * Helper method  that send message on the endpoint sequence on the current session
      */
-    public void updateSession(MessageContext responseMsgCtx, List endpointList,
-                              boolean isClusteringEnable) {
-
+    private void sendMessageOnCurrentSession(String sessionID, List<Endpoint> endpoints, MessageContext synCtx) {
+                
+        // get the next endpoint in the endpoint sequence
         Endpoint endpoint = null;
 
-        if (isClusteringEnable) {
-            // if this is a clustering env. only keep endpoint names, because, it is heavy to
-            // replicate endpoint itself
-            String epNameObj = (String) endpointList.remove(0);
-            for (Endpoint ep : endpoints) {
-                if (ep != null) {
-
-                    String name;
-                    if (ep instanceof IndirectEndpoint) {
-                        name = ((IndirectEndpoint) ep).getKey();
+        boolean invalidSequence = false;
+        if (endpoints.isEmpty()) {
+            invalidSequence = true;
+        } else {
+            if (endpoints.contains(this)) {
+                // This situation will come only if this endpoint is referred as an indirect endpoint.
+                //  All the path before this SAL endpoint are ignored.
+                int length = endpoints.size();
+                if (length > 1) {
+                    
+                    int beginIndex = endpoints.lastIndexOf(this) + 1;
+                    if (beginIndex == length) {
+                        invalidSequence = true;
                     } else {
-                        name = ep.getName();
-                    }
-
-                    if (name != null && name.equals(epNameObj)) {
-                        endpoint = ep;
-                        break;
+                        endpoints = endpoints.subList(beginIndex, length);
+                        if (!endpoints.isEmpty()) {
+                            endpoint = endpoints.remove(0);
+                        } else {
+                            invalidSequence = true;
+                        }
                     }
+                } else {
+                    invalidSequence = true;
                 }
-            }
-
-        } else {
-            endpoint = (Endpoint) endpointList.remove(0);
-        }
-
-        if (endpoint != null) {
 
-            dispatcher.updateSession(responseMsgCtx, dispatcherContext, endpoint);
-            if (endpoint instanceof SALoadbalanceEndpoint) {
-                ((SALoadbalanceEndpoint) endpoint).updateSession(
-                        responseMsgCtx, endpointList, isClusteringEnable);
+            } else {
+                endpoint = endpoints.remove(0);
             }
         }
-    }
-
-    public String getName() {
-        return name;
-    }
-
-    public void setName(String name) {
-        this.name = name.trim();
-    }
 
-    public LoadbalanceAlgorithm getAlgorithm() {
-        return algorithm;
-    }
-
-    public void setAlgorithm(LoadbalanceAlgorithm algorithm) {
-        this.algorithm = algorithm;
-    }
-
-    /**
-     * This is active in below conditions:
-     * If a session is not started AND at least one child endpoint is active.
-     * If a session is started AND the binding endpoint is active.
-     * <p/>
-     * This is not active for all other conditions.
-     *
-     * @param synMessageContext MessageContext of the current message. This is used to determine the
-     *                          session.
-     * @return true is active. false otherwise.
-     */
-    public boolean isActive(MessageContext synMessageContext) {
-        // todo: implement above
-        boolean active;
-        Endpoint endpoint = dispatcher.getEndpoint(synMessageContext, dispatcherContext);
-        if (endpoint == null) { // If a session is not started
-            active = endpointContext.isActive();
-            if (!active && endpoints != null) {
-                for (Endpoint ep : endpoints) {
-                    if (ep != null) {
-                        active = ep.isActive(synMessageContext);
-                        if (active) {    //AND at least one child endpoint is active
-                            endpointContext.setActive(active);
-                            // don't break the loop though we found one active endpoint. calling isActive()
-                            // on all child endpoints will update their active state. so this is a good
-                            // time to do that.
-                        }
-                    }
-                }
+        if (invalidSequence) {
+            informFailure(synCtx, SynapseConstants.ENDPOINT_SAL_INVALID_PATH,
+                    "Invalid endpoint sequence " + endpoints + " for session with id " + sessionID);
+            return;
+        }
+        // endpoints given by session dispatchers may not be active. therefore, we have check
+        // it here.
+        if (endpoint != null && endpoint.readyToSend()) {
+            if (log.isDebugEnabled()) {
+                log.debug("Using the endpoint " + endpoint + " for sending the message");
             }
+            synCtx.pushFaultHandler(this);
+            endpoint.send(synCtx);
         } else {
-            //If a session is started AND the binding endpoint is active.
-            active = endpoint.isActive(synMessageContext);
-            if (active) {
-                endpointContext.setActive(active);
-            }
+            informFailure(synCtx, SynapseConstants.ENDPOINT_SAL_NOT_READY,
+                    "The endpoint " + endpoint + " on the session with id " +
+                            sessionID + " is not ready.");
         }
-
-        if (log.isDebugEnabled()) {
-            log.debug("SALoadbalanceEndpoint with name '" + getName() + "' is in "
-                    + (active ? "active" : "inactive") + " state");
-        }
-
-        return active;
     }
 
-    public void setActive(boolean active, MessageContext synMessageContext) {
-        endpointContext.setActive(active);
-    }
+    /*
+     * Helper method that send message hoping to establish new session 
+     */
+    private void sendMessageOnNewSession(MessageContext synCtx) {
 
-    public List<Endpoint> getEndpoints() {
-        return endpoints;
-    }
+        // there is no endpoint associated with this session. get a new endpoint using the
+        // load balance policy.
+        Endpoint endpoint = getNextChild(synCtx);
+        if (endpoint == null) {
 
-    public void setEndpoints(List<Endpoint> endpoints) {
-        this.endpoints = endpoints;
-    }
+            informFailure(synCtx, SynapseConstants.ENDPOINT_LB_NONE_READY,
+                    "SLALoadbalance endpoint : " + getName() + " - no ready child endpoints");
+        } else {
 
-    public void setParentEndpoint(Endpoint parentEndpoint) {
-        this.parentEndpoint = parentEndpoint;
-    }
+            prepareEndPointSequence(synCtx, endpoint);
 
-    public Dispatcher getDispatcher() {
-        return dispatcher;
-    }
+            // this is the first request. so an endpoint has not been bound to this session and we
+            // are free to failover if the currently selected endpoint is not working. but for
+            // failover to work, we have to build the soap envelope.
+            synCtx.getEnvelope().build();
 
-    public void setDispatcher(Dispatcher dispatcher) {
-        this.dispatcher = dispatcher;
+            // we should also indicate that this is the first message in the session. so that
+            // onFault(...) method can resend only the failed attempts for the first message.
+            synCtx.setProperty(SynapseConstants.PROP_SAL_ENDPOINT_FIRST_MESSAGE_IN_SESSION, Boolean.TRUE);
+            synCtx.pushFaultHandler(this);
+            endpoint.send(synCtx);
+        }
     }
 
-    /**
-     * It is logically incorrect to failover a session affinity endpoint after the session has started.
-     * If we redirect a message belonging to a particular session, new endpoint is not aware of the
-     * session. So we can't handle anything more at the endpoint level. Therefore, this method just
-     * deactivate the failed endpoint and give the fault to the next fault handler.
-     * <p/>
-     * But if the session has not started (i.e. first message), the message will be resend by binding
-     * it to a different endpoint.
-     *
-     * @param endpoint          Failed endpoint.
-     * @param synMessageContext MessageContext of the failed message.
-     */
-    public void onChildEndpointFail(Endpoint endpoint, MessageContext synMessageContext) {
+    private void informFailure(MessageContext synCtx, int errorCode, String errorMsg) {
 
-        Object o = synMessageContext.getProperty(FIRST_MESSAGE_IN_SESSION);
+        if (synCtx.getProperty(SynapseConstants.LAST_ENDPOINT) == null) {
+            synCtx.setProperty(SynapseConstants.ERROR_CODE, errorCode);
+            synCtx.setProperty(SynapseConstants.ERROR_MESSAGE, errorMsg);
+            synCtx.setProperty(SynapseConstants.ERROR_DETAIL, errorMsg);
+            synCtx.setProperty(SynapseConstants.ERROR_EXCEPTION, null);
+        }
+        super.onFault(synCtx);
+    }
 
-        if (o != null && Boolean.TRUE.equals(o)) {
+    /*
+    * Preparing the endpoint sequence for a new session establishment request
+    */
+    private void prepareEndPointSequence(MessageContext synCtx, Endpoint endpoint) {
 
-            // this is the first message. so unbind the sesion with failed endpoint and start
-            // new one by resending.
-            dispatcher.unbind(synMessageContext, dispatcherContext);
-            send(synMessageContext);
+        Object o = synCtx.getProperty(SynapseConstants.PROP_SAL_ENDPOINT_ENDPOINT_LIST);
+        List<Endpoint> endpointList;
+        if (o instanceof List) {
+            endpointList = (List<Endpoint>) o;
+            endpointList.add(this);
 
         } else {
-
-            // session has already started. we can't failover.
-            informFailure(synMessageContext);
+            // this is the first endpoint in the hierarchy. so create the queue and
+            // insert this as the first element.
+            endpointList = new ArrayList<Endpoint>();
+            endpointList.add(this);
+            synCtx.setProperty(SynapseConstants.PROP_SAL_ENDPOINT_ENDPOINT_LIST, endpointList);
+            synCtx.setProperty(SynapseConstants.PROP_SAL_ENDPOINT_CURRENT_DISPATCHER, dispatcher);
         }
-    }
-
-    private void informFailure(MessageContext synMessageContext) {
 
-        log.warn("Failed to send using the selected endpoint, becasue it is inactive");
-        
-        if (parentEndpoint != null) {
-            parentEndpoint.onChildEndpointFail(this, synMessageContext);
-        } else {
-            Object o = synMessageContext.getFaultStack().pop();
-            if (o != null) {
-                ((FaultHandler) o).handleFault(synMessageContext);
+        // if the next endpoint is not a session affinity one, endpoint sequence ends
+        // here. but we have to add the next endpoint to the list.
+        if (!(endpoint instanceof SALoadbalanceEndpoint)) {
+            endpointList.add(endpoint);
+            // Clearing out if there any any session information with current message 
+            if (dispatcher.isServerInitiatedSession()) {
+                dispatcher.removeSessionID(synCtx);
             }
         }
     }
 
+    public long getSessionTimeout() {
+        return sessionTimeout;
+    }
+
+    public void setSessionTimeout(long sessionTimeout) {
+        this.sessionTimeout = sessionTimeout;
+    }
 }
diff --git a/java/modules/core/src/main/java/org/apache/synapse/endpoints/WSDLEndpoint.java b/java/modules/core/src/main/java/org/apache/synapse/endpoints/WSDLEndpoint.java
index e38aab4ba..724f56c5b 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/endpoints/WSDLEndpoint.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/endpoints/WSDLEndpoint.java
@@ -22,154 +22,38 @@ package org.apache.synapse.endpoints;
 import org.apache.axiom.om.OMElement;
 import org.apache.axis2.clustering.ClusterManager;
 import org.apache.axis2.context.ConfigurationContext;
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.synapse.FaultHandler;
 import org.apache.synapse.MessageContext;
 import org.apache.synapse.SynapseConstants;
 import org.apache.synapse.core.axis2.Axis2MessageContext;
-import org.apache.synapse.endpoints.utils.EndpointDefinition;
-
-import java.util.Stack;
 
 /**
- * WSDLEndpoint represents the endpoints built using a wsdl document. It stores the details about
- * the endpoint in a EndpointDefinition object. Once the WSDLEndpoint object is constructed, it
- * should not access the wsdl document at runtime to obtain endpoint information. If it is necessary
- * to create an endpoint using a dynamic wsdl, store the endpoint configuration in the registry and
- * create a dynamic wsdl endpoint using that registry key.
+ * WSDLEndpoint represents the endpoints built using a WSDL document. It stores the details about
+ * the endpoint in an EndpointDefinition object. Once the WSDLEndpoint object is constructed, it
+ * should not access the WSDL document at runtime to obtain endpoint information. If it is necessary
+ * to create an endpoint using a dynamic WSDL, store the endpoint configuration in the registry and
+ * create a dynamic WSDL endpoint using that registry key.
  * <p/>
  * TODO: This should allow various policies to be applied on fine grained level (e.g. operations).
  */
-public class WSDLEndpoint extends FaultHandler implements Endpoint {
-
-    private static final Log log = LogFactory.getLog(WSDLEndpoint.class);
-    private static final Log trace = LogFactory.getLog(SynapseConstants.TRACE_LOGGER);
+public class WSDLEndpoint extends AbstractEndpoint {
 
-    private String name = null;
     private String wsdlURI;
     private OMElement wsdlDoc;
     private String serviceName;
     private String portName;
 
-    private Endpoint parentEndpoint = null;
-    private EndpointDefinition endpoint = null;
-
-    /**
-     * The endpoint context , place holder for keep any runtime states related to the endpoint
-     */
-    private final EndpointContext endpointContext = new EndpointContext();
-
-    /**
-     * Sends the message through this endpoint. This method just handles statistics related
-     * functions and gives the message to the Synapse environment to send. It does not add any
-     * endpoint specific details to the message context. These details are added only to the cloned
-     * message context by the Axis2FlexibleMepClient. So that we can reuse the original message
-     * context for resending through different endpoints.
-     *
-     * @param synCtx MessageContext sent by client to Synapse
-     */
-    public void send(MessageContext synCtx) {
-
-        boolean traceOn = isTraceOn(synCtx);
-        boolean traceOrDebugOn = isTraceOrDebugOn(traceOn);
-
-        if (traceOrDebugOn) {
-            traceOrDebug(traceOn, "Start : WSDL Endpoint");
-
-            if (traceOn && trace.isTraceEnabled()) {
-                trace.trace("Message : " + synCtx.getEnvelope());
-            }
-        }
-
-        if (endpoint.getAddress() != null) {
-
-            String eprAddress = endpoint.getAddress();
-            boolean isClusteringEnable = false;
-            // get Axis2 MessageContext and ConfigurationContext
-            org.apache.axis2.context.MessageContext axisMC =
-                    ((Axis2MessageContext) synCtx).getAxis2MessageContext();
-            ConfigurationContext cc = axisMC.getConfigurationContext();
-
-            //The check for clustering environment
-            ClusterManager clusterManager = cc.getAxisConfiguration().getClusterManager();
-            if (clusterManager != null &&
-                    clusterManager.getContextManager() != null) {
-                isClusteringEnable = true;
-            }
-
-            String endPointName = this.getName();
-            if (endPointName == null) {
-
-                if (traceOrDebugOn && isClusteringEnable) {
-                    log.warn("In a clustering environment , the endpoint  name should be " +
-                            "specified even for anonymous endpoints. Otherwise, the clustering " +
-                            "would not be functioned correctly if there are more than one " +
-                            "anonymous endpoints. ");
-                }
-                endPointName = SynapseConstants.ANONYMOUS_ENDPOINT;
-            }
-
-            if (isClusteringEnable) {
-                // if this is a cluster environment , then set configuration context
-                // to endpoint context
-                if (endpointContext.getConfigurationContext() == null) {
-                    endpointContext.setConfigurationContext(cc);
-                    endpointContext.setContextID(endPointName);
-                }
-            }
-
-            // Setting Required property to collect the End Point audit
-           
-            if (traceOrDebugOn) {
-                traceOrDebug(traceOn, "Sending message to WSDL endpoint : " +
-                        endPointName + " resolves to address = " + eprAddress);
-                traceOrDebug(traceOn, "SOAPAction: " + (synCtx.getSoapAction() != null ?
-                        synCtx.getSoapAction() : "null"));
-                traceOrDebug(traceOn, "WSA-Action: " + (synCtx.getWSAAction() != null ?
-                        synCtx.getWSAAction() : "null"));
-
-                if (traceOn && trace.isTraceEnabled()) {
-                    trace.trace("Envelope : \n" + synCtx.getEnvelope());
-                }
-            }
-
-            // register this as the immediate fault handler for this message.
-            synCtx.pushFaultHandler(this);
-
-            // add this as the last endpoint to process this message. it is used by audit code.
-            synCtx.setProperty(SynapseConstants.PROCESSED_ENDPOINT, this);
-
-            synCtx.getEnvironment().send(endpoint, synCtx);
-        }
-    }
-
     public void onFault(MessageContext synCtx) {
-        // perform retries here
-
-        // if this endpoint has actually failed, inform the parent.
-        setActive(false, synCtx);
-
-        if (parentEndpoint != null) {
-            parentEndpoint.onChildEndpointFail(this, synCtx);
-        } else {
-            Stack faultStack = synCtx.getFaultStack();
-            if (!faultStack.isEmpty()) {
-                ((FaultHandler) faultStack.pop()).handleFault(synCtx);
-            }
+        // is this really a fault or a timeout/connection close etc?
+        if (isTimeout(synCtx)) {
+            getContext().onTimeout();
+        } else if (isSuspendFault(synCtx)) {
+            getContext().onFault();
         }
+        super.onFault(synCtx);
     }
 
-    public void onChildEndpointFail(Endpoint endpoint, MessageContext synMessageContext) {
-        // WSDLEndpoint does not contain any child endpoints. So this method will never be called.
-    }
-
-    public String getName() {
-        return name;
-    }
-
-    public void setName(String name) {
-        this.name = name.trim();
+    public void onSuccess() {
+        getContext().onSuccess();
     }
 
     public String getWsdlURI() {
@@ -203,103 +87,4 @@ public class WSDLEndpoint extends FaultHandler implements Endpoint {
     public void setPortName(String portName) {
         this.portName = portName;
     }
-
-    /**
-     * Checks if the endpoint is active (failed or not). If endpoint is in failed state and
-     * suspendOnFailDuration has elapsed, it will be set to active.
-     *
-     * @param synMessageContext MessageContext of the current message. This is not used here.
-     * @return true if endpoint is active. false otherwise.
-     */
-    public boolean isActive(MessageContext synMessageContext) {
-        boolean active = endpointContext.isActive();
-        if (!active) {
-            long recoverOn = endpointContext.getRecoverOn();
-            if (System.currentTimeMillis() > recoverOn) {
-                active = true;
-                endpointContext.setActive(true);
-            }
-        }
-
-        if (log.isDebugEnabled()) {
-            log.debug("WSDLEndpoint with name '" + name + "' is in "
-                    + (active ? "active" : "inactive") + " state");
-        }
-
-        return active;
-    }
-
-    /**
-     * Sets if endpoint active or not. if endpoint is set as failed (active = false), the recover on
-     * time is calculated so that it will be activated after the recover on time.
-     *
-     * @param active            true if active. false otherwise.
-     * @param synMessageContext MessageContext of the current message. This is not used here.
-     */
-    public void setActive(boolean active, MessageContext synMessageContext) {
-
-        if (!active) {
-            if (endpoint.getSuspendOnFailDuration() != -1) {
-                // Calculating a new value by adding suspendOnFailDuration to current time.
-                // as the endpoint is set as failed
-                endpointContext.setRecoverOn(
-                        System.currentTimeMillis() + endpoint.getSuspendOnFailDuration());
-            } else {
-                endpointContext.setRecoverOn(Long.MAX_VALUE);
-            }
-        }
-
-        endpointContext.setActive(true);
-    }
-
-    public void setParentEndpoint(Endpoint parentEndpoint) {
-        this.parentEndpoint = parentEndpoint;
-    }
-
-    public EndpointDefinition getEndpoint() {
-        return endpoint;
-    }
-
-    public void setEndpoint(EndpointDefinition endpoint) {
-        this.endpoint = endpoint;
-    }
-
-    /**
-     * Should this mediator perform tracing? True if its explicitly asked to
-     * trace, or its parent has been asked to trace and it does not reject it
-     *
-     * @param msgCtx the current message
-     * @return true if tracing should be performed
-     */
-    protected boolean isTraceOn(MessageContext msgCtx) {
-        return
-                (endpoint.getTraceState() == SynapseConstants.TRACING_ON) ||
-                        (endpoint.getTraceState() == SynapseConstants.TRACING_UNSET &&
-                                msgCtx.getTracingState() == SynapseConstants.TRACING_ON);
-    }
-
-    /**
-     * Is tracing or debug logging on?
-     *
-     * @param isTraceOn is tracing known to be on?
-     * @return true, if either tracing or debug logging is on
-     */
-    protected boolean isTraceOrDebugOn(boolean isTraceOn) {
-        return isTraceOn || log.isDebugEnabled();
-    }
-
-    /**
-     * Perform Trace and Debug logging of a message @INFO (trace) and DEBUG (log)
-     *
-     * @param traceOn is runtime trace on for this message?
-     * @param msg     the message to log/trace
-     */
-    protected void traceOrDebug(boolean traceOn, String msg) {
-        if (traceOn) {
-            trace.info(msg);
-        }
-        if (log.isDebugEnabled()) {
-            log.debug(msg);
-        }
-    }
 }
diff --git a/java/modules/core/src/main/java/org/apache/synapse/endpoints/algorithms/AlgorithmContext.java b/java/modules/core/src/main/java/org/apache/synapse/endpoints/algorithms/AlgorithmContext.java
index a694b23ac..308c678a4 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/endpoints/algorithms/AlgorithmContext.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/endpoints/algorithms/AlgorithmContext.java
@@ -18,73 +18,57 @@
 */
 package org.apache.synapse.endpoints.algorithms;
 
+import org.apache.axis2.clustering.ClusteringFault;
+import org.apache.axis2.clustering.context.Replicator;
 import org.apache.axis2.context.ConfigurationContext;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 import org.apache.synapse.SynapseException;
-import org.apache.synapse.util.Replicator;
 
 /**
- * Keeps the states of the load balance algorithm.This hides where those states are kept.For a
- * cluster environment ,all states are kept in the axis2 configuration context in order to replicate
- * those states so that other synapse instance in the same cluster can see those changes .
- * This class can be evolved to keep any run time states related to the endpoint .
- * For a non-clustered environment , all data are kept locally.
- * <p/>
- * This class provide the abstraction need to separate the dynamic data from the static data
- * and improve the  high cohesion and provides capability to replicate only required state at
- * a given time. This improves the performance when replicate data.
+ * Keeps the runtime state of the algorithm
  */
 public class AlgorithmContext {
 
     private static final Log log = LogFactory.getLog(AlgorithmContext.class);
 
-    /* The  static constant only for construct key prefix for each property in a dispatcher context
-     * as it is need when those property state going to replicate in a cluster env. */
-    private static final String UNDERSCORE_STRING = "_";
-    private static final String CURRENT_EPR = "currentEPR";
+    private static final String KEY_PREFIX = "synapse.endpoint.lb.algorithm.";
+    private static final String CURRENT_EPR = ".current_epr";
 
-    /* The axis configuration context-  this will hold the all callers states
-     * when doing throttling in a clustered environment. */
-    private ConfigurationContext configCtx;
+    /* The axis2 configuration context - this hold state in a clustered environment. */
+    private ConfigurationContext cfgCtx;
 
-    /* Is this env. support clustering*/
-    private boolean isClusteringEnable = false;
+    /* Are we supporting clustering ? */
+    private Boolean isClusteringEnabled = null;
 
-    /* The key for 'currentEPR' attribute and this is used when this attribute value being
-     * replicated */
-    private String currentEPRPropertyKey;
+    /* The key for 'currentEPR' attribute when replicated in a clsuter */
+    private String CURRENT_EPR_PROP_KEY;
 
     /* The pointer to current epr - The position of the current EPR */
     private int currentEPR = 0;
 
+    public AlgorithmContext(boolean clusteringEnabled, ConfigurationContext cfgCtx, String endpointName) {
+        this.cfgCtx = cfgCtx;
+        if (clusteringEnabled) {
+            isClusteringEnabled = Boolean.TRUE;
+        }
+        CURRENT_EPR_PROP_KEY = KEY_PREFIX + endpointName + CURRENT_EPR;
+    }
+
     /**
-     * To get the  position of the current EPR
-     * If there is no value and if there will not appear any errors , then '0' will be returned.
+     * To get the position of the current EPR for use. Default to 0 - i.e. first endpoint
      *
      * @return The  position of the current EPR
      */
     public int getCurrentEndpointIndex() {
 
-        if (this.isClusteringEnable) {  // if this is a clustering env.
-
-            if (this.currentEPRPropertyKey == null || "".equals(this.currentEPRPropertyKey)) {
-                handleException("Cannot find the required key to find the " +
-                        "shared state of the 'currentEPR' attribute");
-            }
+        if (Boolean.TRUE.equals(isClusteringEnabled)) {
 
-            Object value = this.configCtx.getPropertyNonReplicable(this.currentEPRPropertyKey);
+            Object value = cfgCtx.getPropertyNonReplicable(this.CURRENT_EPR_PROP_KEY);
             if (value == null) {
                 return 0;
-            }
-            try {
-                if (value instanceof Integer) {
-                    return (Integer) value;
-                } else if (value instanceof String) {
-                    return Integer.parseInt((String) value);
-                }
-            } catch (NumberFormatException e) {
-                handleException("The invalid value for the 'currentEPR' attribute");
+            } else if (value instanceof Integer) {
+                return ((Integer) value);
             }
         } else {
             return currentEPR;
@@ -97,21 +81,18 @@ public class AlgorithmContext {
      *
      * @param currentEPR The current position
      */
-    public void setCurrentEndpointIndex(int currentEPR) {
+    public void setCurrentEPR(int currentEPR) {
 
-        if (isClusteringEnable) {  // if this is a clustering env.
+        if (Boolean.TRUE.equals(isClusteringEnabled)) {
 
-            if (currentEPRPropertyKey != null) {
-                if (log.isDebugEnabled()) {
-                    log.debug("Setting the current EPR " + currentEPR
-                            + " with the key " + currentEPRPropertyKey);
-                }
-                // Sets the property and  replicates the current state  so that all instances
-                Replicator.setAndReplicateState(currentEPRPropertyKey, currentEPR, configCtx);
+            if (log.isDebugEnabled()) {
+                log.debug("Set EPR with key : " + CURRENT_EPR_PROP_KEY + " as : " + currentEPR);
             }
+            setAndReplicateState(CURRENT_EPR_PROP_KEY, currentEPR);
+
         } else {
             if (log.isDebugEnabled()) {
-                log.debug("Setting the current EPR " + currentEPR);
+                log.debug("Setting the current EPR as : " + currentEPR);
             }
             this.currentEPR = currentEPR;
         }
@@ -123,55 +104,54 @@ public class AlgorithmContext {
      * @return Returns the ConfigurationContext instance
      */
     public ConfigurationContext getConfigurationContext() {
-        return configCtx;
+        return cfgCtx;
     }
 
     /**
-     * Sets the  ConfigurationContext instance . This is only used for cluster env.
-     * By setting this , indicates that this is a cluster env.
+     * Helper methods for handle errors.
      *
-     * @param configCtx The ConfigurationContext instance
+     * @param msg The error message
      */
-    public void setConfigurationContext(ConfigurationContext configCtx) {
-
-        if (configCtx == null) {
-            handleException("The ConfigurationContext cannot be null when system " +
-                    "in a cluster environment");
-        }
-
-        this.configCtx = configCtx;
-        this.isClusteringEnable = true; // Now, the environment is considered as a cluster
+    protected void handleException(String msg) {
+        log.error(msg);
+        throw new SynapseException(msg);
     }
 
     /**
-     * Sets the identifier for this algorithm context , so that , this can be identified
-     * uniquely across the cluster. The id will be the name of the endpoint
+     * Helper methods for handle errors.
      *
-     * @param contextID The Id for this algorithm context
+     * @param msg The error message
+     * @param e   The exception
      */
-    public void setContextID(String contextID) {
-
-        if (contextID == null || "".equals(contextID)) {
-            handleException("The Context ID cannot be null when system in a cluster environment");
-        }
-
-        //Making required key for each property in the algorithm context- Those will be used when
-        //replicating states
-        StringBuffer buffer = new StringBuffer();
-        buffer.append(contextID);
-        buffer.append(UNDERSCORE_STRING);
-        buffer.append(CURRENT_EPR);
-        currentEPRPropertyKey = buffer.toString();
+    protected void handleException(String msg, Exception e) {
+        log.error(msg, e);
+        throw new SynapseException(msg, e);
     }
 
-
     /**
-     * Helper methods for handle errors.
+     * Helper method to replicates states of the property with given key
+     * Sets property and  replicates the current state  so that all instances
+     * across cluster can see this state
      *
-     * @param msg The error message
+     * @param key   The key of the property
+     * @param value The value of the property
      */
-    private void handleException(String msg) {
-        log.error(msg);
-        throw new SynapseException(msg);
+    private void setAndReplicateState(String key, Object value) {
+
+        if (cfgCtx != null && key != null && value != null) {
+
+            try {
+                if (log.isDebugEnabled()) {
+                    log.debug("Replicating property key : " + key + " as : " + value);
+                }
+                cfgCtx.setProperty(key, value);
+                Replicator.replicate(cfgCtx, new String[]{key});
+
+            } catch (ClusteringFault clusteringFault) {
+                handleException("Error replicating property : " + key + " as : " +
+                    value, clusteringFault);
+            }
+        }
     }
+
 }
\ No newline at end of file
diff --git a/java/modules/core/src/main/java/org/apache/synapse/endpoints/algorithms/LoadbalanceAlgorithm.java b/java/modules/core/src/main/java/org/apache/synapse/endpoints/algorithms/LoadbalanceAlgorithm.java
index d370fcdae..6183429dd 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/endpoints/algorithms/LoadbalanceAlgorithm.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/endpoints/algorithms/LoadbalanceAlgorithm.java
@@ -36,14 +36,15 @@ public interface LoadbalanceAlgorithm {
      *
      * @param members The application members
      */
-    void setApplicationMembers(List<Member> members);
-
-    /**
-     * Set the endpoints
-     *
-     * @param endpoints The endpoints
-     */
-    void setEndpoints(List<Endpoint> endpoints);
+//    TODO FIX-RUWAN
+//    void setApplicationMembers(List<Member> members);
+//
+//    /**
+//     * Set the endpoints
+//     *
+//     * @param endpoints The endpoints
+//     */
+//    void setEndpoints(List<Endpoint> endpoints);
 
     /**
      * This method returns the next node according to the algorithm implementation.
@@ -63,7 +64,8 @@ public interface LoadbalanceAlgorithm {
      * @param algorithmContext The context in which holds run time states related to the algorithm
      * @return Next application member to which the request has to be sent to
      */
-    Member getNextApplicationMember(AlgorithmContext algorithmContext);
+//    TODO FIX-RUWAN
+//    Member getNextApplicationMember(AlgorithmContext algorithmContext);
 
     /**
      * Resets the algorithm to its initial position. Initial position depends on the implementation.
@@ -71,4 +73,10 @@ public interface LoadbalanceAlgorithm {
      * @param algorithmContext The context in which holds run time states related to the algorithm
      */
     void reset(AlgorithmContext algorithmContext);
+
+    /**
+     * Return the name of the load balancing algorithm
+     * @return the name of the algorithm implemented
+     */
+    public String getName();
 }
diff --git a/java/modules/core/src/main/java/org/apache/synapse/endpoints/algorithms/RoundRobin.java b/java/modules/core/src/main/java/org/apache/synapse/endpoints/algorithms/RoundRobin.java
index caa769104..e04c1c1b6 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/endpoints/algorithms/RoundRobin.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/endpoints/algorithms/RoundRobin.java
@@ -19,12 +19,13 @@
 
 package org.apache.synapse.endpoints.algorithms;
 
-import org.apache.axis2.clustering.Member;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 import org.apache.synapse.MessageContext;
+import org.apache.synapse.SynapseConstants;
 import org.apache.synapse.endpoints.Endpoint;
 
+import java.util.ArrayList;
 import java.util.List;
 
 /**
@@ -38,21 +39,9 @@ public class RoundRobin implements LoadbalanceAlgorithm {
     /**
      * Endpoints list for the round robin algorithm
      */
-    private List<Endpoint> endpoints = null;
+    private List endpoints = null;
 
-    /**
-     * List of application members in the loadb balance group
-     */
-    private List<Member> members;
-
-    public RoundRobin() {
-    }
-
-    public void setApplicationMembers(List<Member> members) {
-        this.members = members;
-    }
-
-    public void setEndpoints(List<Endpoint> endpoints) {
+    public RoundRobin(List endpoints) {
         this.endpoints = endpoints;
     }
 
@@ -60,16 +49,12 @@ public class RoundRobin implements LoadbalanceAlgorithm {
      * Choose an active endpoint using the round robin algorithm. If there are no active endpoints
      * available, returns null.
      *
-     * @param synapseMessageContext MessageContext instance which holds all per-message properties
-     * @param algorithmContext The context in which holds run time states related to the algorithm
+     * @param synCtx MessageContext instance which holds all per-message properties
+     * @param  algorithmContext The context in which holds run time states related to the algorithm
      * @return endpoint to send the next message
      */
-    public Endpoint getNextEndpoint(MessageContext synapseMessageContext,
-                                    AlgorithmContext algorithmContext) {
-
-        if (log.isDebugEnabled()) {
-            log.debug("Using the Round Robin loadbalancing algorithm to select the next endpoint");
-        }
+    public Endpoint getNextEndpoint(MessageContext synCtx,
+        AlgorithmContext algorithmContext) {
 
         Endpoint nextEndpoint;
         int attempts = 0;
@@ -77,53 +62,34 @@ public class RoundRobin implements LoadbalanceAlgorithm {
         do {
             // two successive clients could get the same endpoint if not synchronized.
             synchronized (this) {
-                nextEndpoint = endpoints.get(currentEPR);
+                nextEndpoint = (Endpoint) endpoints.get(currentEPR);
 
                 if (currentEPR == endpoints.size() - 1) {
                     currentEPR = 0;
                 } else {
                     currentEPR++;
                 }
-                algorithmContext.setCurrentEndpointIndex(currentEPR);
+                algorithmContext.setCurrentEPR(currentEPR);
             }
 
             attempts++;
             if (attempts > endpoints.size()) {
-                log.warn("Couldn't find an endpoint from the Round Robin loadbalancing algorithm");
                 return null;
             }
 
-        } while (!nextEndpoint.isActive(synapseMessageContext));
+        } while (!nextEndpoint.readyToSend());
 
         return nextEndpoint;
     }
 
-    public Member getNextApplicationMember(AlgorithmContext algorithmContext) {
-        if (members.size() == 0) {
-            return null;
-        }
-        int currentMemberIndex = algorithmContext.getCurrentEndpointIndex();
-        if (currentMemberIndex >= members.size()) {
-            currentMemberIndex = 0;
-        }
-        Member current = members.get(currentMemberIndex);
-        if (currentMemberIndex == members.size() - 1) {
-            currentMemberIndex = 0;
-        } else {
-            currentMemberIndex++;
-        }
-        algorithmContext.setCurrentEndpointIndex(currentMemberIndex);
-        if(log.isDebugEnabled()) {
-            log.debug("Members       : " + members.size());
-            log.debug("Current member: " + current);
-        }
-        return current;
-    }
-
     public void reset(AlgorithmContext algorithmContext) {
         if (log.isDebugEnabled()) {
             log.debug("Resetting the Round Robin loadbalancing algorithm ...");
         }
-        algorithmContext.setCurrentEndpointIndex(0);
+        algorithmContext.setCurrentEPR(0);
+    }
+
+    public String getName() {
+        return "RoundRobin";
     }
 }
diff --git a/java/modules/core/src/main/java/org/apache/synapse/endpoints/dispatch/AbstractDispatcher.java b/java/modules/core/src/main/java/org/apache/synapse/endpoints/dispatch/AbstractDispatcher.java
new file mode 100755
index 000000000..0fc8587de
--- /dev/null
+++ b/java/modules/core/src/main/java/org/apache/synapse/endpoints/dispatch/AbstractDispatcher.java
@@ -0,0 +1,134 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.endpoints.dispatch;
+
+import org.apache.axiom.om.OMElement;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.synapse.MessageContext;
+import org.apache.synapse.core.axis2.Axis2MessageContext;
+import org.apache.synapse.endpoints.Endpoint;
+
+import javax.xml.namespace.QName;
+import java.util.List;
+import java.util.Map;
+
+/**
+ *
+ */
+public abstract class AbstractDispatcher implements Dispatcher {
+
+    protected Log log;
+    private final static String TRANSPORT_HEADERS = "TRANSPORT_HEADERS";
+
+    protected AbstractDispatcher() {
+        log = LogFactory.getLog(this.getClass());
+    }
+
+    public List<Endpoint> getEndpoints(SessionInformation sessionInformation) {
+        return SALSessions.getInstance().getChildEndpoints(sessionInformation);
+    }
+
+    protected String extractSessionID(OMElement header, QName keyQName) {
+
+        OMElement sgcIDElm = getHeaderBlock(header, keyQName);
+
+        if (sgcIDElm != null) {
+            String sgcID = sgcIDElm.getText();
+
+            if (sgcID != null && !"".equals(sgcID)) {
+                return sgcID.trim();
+            } else {
+                if (log.isDebugEnabled()) {
+                    log.debug(keyQName + " is null or empty");
+                }
+            }
+        } else {
+            if (log.isDebugEnabled()) {
+                log.debug("Couldn't find the " + keyQName + " SOAP header to find the session");
+            }
+        }
+        return null;
+    }
+
+    protected String extractSessionID(MessageContext synCtx, String key) {
+
+        if (key != null) {
+            Map headerMap = getTransportHeaderMap(synCtx);
+            if (headerMap != null) {
+
+                Object cookie = headerMap.get(key);
+
+                if (cookie instanceof String) {
+                    return (String) cookie;
+                } else {
+                    if (log.isDebugEnabled()) {
+                        log.debug("Couldn't find the " + key + " header to find the session");
+                    }
+                }
+            } else {
+                if (log.isDebugEnabled()) {
+                    log.debug("Couldn't find the TRANSPORT_HEADERS to find the session");
+                }
+
+            }
+        }
+        return null;
+    }
+
+    protected void removeSessionID(MessageContext synCtx, String key) {
+
+        if (key != null) {
+            Map headerMap = getTransportHeaderMap(synCtx);
+            if (headerMap != null) {
+                headerMap.remove(key);
+            }
+        }
+    }
+
+    protected void removeSessionID(OMElement header, QName keyQName) {
+
+        OMElement sgcIDElm = getHeaderBlock(header, keyQName);
+        if (sgcIDElm != null) {
+            sgcIDElm.detach();
+        }
+    }
+
+
+    private Map getTransportHeaderMap(MessageContext synCtx) {
+
+        org.apache.axis2.context.MessageContext axis2MessageContext =
+                ((Axis2MessageContext) synCtx).getAxis2MessageContext();
+
+        Object o = axis2MessageContext.getProperty(TRANSPORT_HEADERS);
+        if (o != null && o instanceof Map) {
+            return (Map) o;
+        }
+        return null;
+    }
+
+    private OMElement getHeaderBlock(OMElement soapHeader, QName keyQName) {
+
+        if (soapHeader != null) {
+            return soapHeader.getFirstChildWithName(keyQName);
+        }
+        return null;
+    }
+}
diff --git a/java/modules/core/src/main/java/org/apache/synapse/endpoints/dispatch/Dispatcher.java b/java/modules/core/src/main/java/org/apache/synapse/endpoints/dispatch/Dispatcher.java
index d28a52401..7d9aa3682 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/endpoints/dispatch/Dispatcher.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/endpoints/dispatch/Dispatcher.java
@@ -22,6 +22,8 @@ package org.apache.synapse.endpoints.dispatch;
 import org.apache.synapse.MessageContext;
 import org.apache.synapse.endpoints.Endpoint;
 
+import java.util.List;
+
 /**
  * Defines the behavior of session dispatchers. There can be two dispatcher types. Server initiated
  * session dispatchers and client initiated session dispatchers. In the former one, server generates
@@ -37,30 +39,25 @@ public interface Dispatcher {
      * synapseMessageContext is not found it should return null.
      *
      * @param synCtx client -> esb message context.
-     * @param dispatcherContext context for dispatching
      * @return Endpoint Endpoint associated with this session.
      */
-    public Endpoint getEndpoint(MessageContext synCtx, DispatcherContext dispatcherContext);
+    public SessionInformation getSession(MessageContext synCtx);
 
     /**
      * Updates the session maps. This will be called in the first client -> synapse -> server flow
      * for client initiated sessions. For server initiated sessions, this will be called in the
      * first server -> synapse -> client flow.
      *
-     * @param synCtx   SynapseMessageContext
-     * @param dispatcherContext context for dispatching
-     * @param endpoint Selected endpoint for this session.
+     * @param synCtx SynapseMessageContext
      */
-    public void updateSession(MessageContext synCtx, DispatcherContext dispatcherContext,
-        Endpoint endpoint);
+    public void updateSession(MessageContext synCtx);
 
     /**
      * Removes the session belonging to the given message context.
      *
      * @param synCtx MessageContext containing an session ID.
-     * @param dispatcherContext context for dispatching
      */
-    public void unbind(MessageContext synCtx, DispatcherContext dispatcherContext);
+    public void unbind(MessageContext synCtx);
 
     /**
      * Determine whether the session supported by the implementing dispatcher is initiated by the
@@ -69,4 +66,18 @@ public interface Dispatcher {
      * @return true, if the session is initiated by the server. false, otherwise.
      */
     public boolean isServerInitiatedSession();
+
+    /**
+     * Returns the endpoint sequence associated with current session with out root
+     *
+     * @param sessionInformation Current Session information
+     * @return Endpoint sequence
+     */
+    public List<Endpoint> getEndpoints(SessionInformation sessionInformation);
+
+    /**
+     * Remove the session Id - To clear out session information from current message
+     * @param syCtx MessageContext containing an session ID
+     */
+    public void removeSessionID(MessageContext syCtx);
 }
diff --git a/java/modules/core/src/main/java/org/apache/synapse/endpoints/dispatch/DispatcherContext.java b/java/modules/core/src/main/java/org/apache/synapse/endpoints/dispatch/DispatcherContext.java
deleted file mode 100644
index d62b869a2..000000000
--- a/java/modules/core/src/main/java/org/apache/synapse/endpoints/dispatch/DispatcherContext.java
+++ /dev/null
@@ -1,288 +0,0 @@
-/*
-*  Licensed to the Apache Software Foundation (ASF) under one
-*  or more contributor license agreements.  See the NOTICE file
-*  distributed with this work for additional information
-*  regarding copyright ownership.  The ASF licenses this file
-*  to you under the Apache License, Version 2.0 (the
-*  "License"); you may not use this file except in compliance
-*  with the License.  You may obtain a copy of the License at
-*
-*   http://www.apache.org/licenses/LICENSE-2.0
-*
-*  Unless required by applicable law or agreed to in writing,
-*  software distributed under the License is distributed on an
-*   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
-*  KIND, either express or implied.  See the License for the
-*  specific language governing permissions and limitations
-*  under the License.
-*/
-package org.apache.synapse.endpoints.dispatch;
-
-import org.apache.axis2.context.ConfigurationContext;
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.apache.synapse.SynapseConstants;
-import org.apache.synapse.SynapseException;
-import org.apache.synapse.endpoints.Endpoint;
-import org.apache.synapse.endpoints.IndirectEndpoint;
-import org.apache.synapse.endpoints.SALoadbalanceEndpoint;
-import org.apache.synapse.util.Replicator;
-
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-/**
- * Keeps the states of the dispatcher . This hides where those states are kept . For a cluster
- * environment , all states are kept in the axis2 configuration context in order to replicate
- * those states so that other synapse instance in the same cluster can see those changes .
- * This class can be evolved to keep any run time states related to the endpoint .
- * For a non-clustered environment , all data are kept locally.
- * <p/>
- * This class provide the abstraction need to separate the dynamic data from the static data and
- * improve the  high cohesion and provides capability to replicate only required state at a given
- * time. This improves the performance when replicate data.
- */
-public class DispatcherContext {
-
-    private static final Log log = LogFactory.getLog(DispatcherContext.class);
-
-    /* The  static constant only for construct key prefix for each property in a dispatcher context
-     *as it is need when those property state going to replicate in a cluster env. */
-    private static final String SESSION = "session";
-    private static final String UNDERSCORE_STRING = "_";
-
-    /* Map to store session -> endpoint mappings. Synchronized map is used as this is accessed by
-     * multiple threads (e.g. multiple clients different sessions).*/
-    private final Map<String, Endpoint> sessionMap
-            = Collections.synchronizedMap(new HashMap<String, Endpoint>());
-
-    /*The axis configuration context-  this will hold the all callers states
-     *when doing throttling in a clustered environment. */
-    private ConfigurationContext configCtx;
-
-    /* Is this env. support clustering*/
-    private boolean isClusteringEnable = false;
-
-    /*The key prefix for each session and this is used when this attribute value being replicated */
-    private String keyPrefix;
-
-    /*To keep all defined child endpoints  */
-    private final Map<String, Endpoint> endpointsMap = new HashMap<String, Endpoint>();
-
-    /**
-     * return the endpoint  for the given session.
-     * Null will be returned , if there is no endpoint for given session.
-     *
-     * @param sessionID The session identifier
-     * @return Returns the endpoint for the given session.
-     */
-    public Endpoint getEndpoint(String sessionID) {
-
-        if (isClusteringEnable) {    // if this is a clustering env.
-
-            if (keyPrefix == null || "".equals(keyPrefix)) {
-                handleException("Cannot find the required key prefix to find the " +
-                        "shared state of one of  'session'");
-            }
-            // gets the value from configuration context (The shared state across all instances)
-            Object value = this.configCtx.getPropertyNonReplicable(this.keyPrefix + sessionID);
-            if (value != null && value instanceof String) {
-                if (log.isDebugEnabled()) {
-                    log.debug("Retrieving the endpoint from the session id " + value);
-                }
-                return endpointsMap.get(value.toString());
-            }
-
-        } else {
-
-            synchronized (sessionMap) {
-                if (log.isDebugEnabled()) {
-                    log.debug("Retrieving the endpoint from the session id " + sessionID);
-                }
-                return sessionMap.get(sessionID);
-            }
-        }
-
-        return null;
-    }
-
-    /**
-     * Sets the given endpoint mapping with given the session id.
-     *
-     * @param sessionID The session identifier
-     * @param endpoint  The endpoint
-     */
-    public void setEndpoint(String sessionID, Endpoint endpoint) {
-
-        if (isClusteringEnable) {  // if this is a clustering env.
-
-            String endpointName;
-            if (endpoint instanceof IndirectEndpoint) {
-                endpointName = ((IndirectEndpoint) endpoint).getKey();
-            } else {
-                endpointName = endpoint.getName();
-            }
-
-            if (endpointName == null) {
-                if (log.isDebugEnabled() && isClusteringEnable()) {
-                    log.warn(SALoadbalanceEndpoint.WARN_MESSAGE);
-                }
-                endpointName = SynapseConstants.ANONYMOUS_ENDPOINT;
-            }
-
-            if (keyPrefix != null) {
-                if (log.isDebugEnabled()) {
-                    log.debug("Adding the enpoint " + endpointName + " with the session id "
-                            + keyPrefix + sessionID + " for replication to the session");
-                }
-                // replicates the state so that all instances across cluster can see this state
-                Replicator.setAndReplicateState(keyPrefix + sessionID, endpointName, configCtx);
-            }
-
-        } else {
-
-            synchronized (sessionMap) {
-                if (log.isDebugEnabled()) {
-                    log.debug("Adding the endpoint " + endpoint
-                            + " with the session id " + sessionID + " to the session");
-                }
-                sessionMap.put(sessionID, endpoint);
-            }
-        }
-
-    }
-
-    /**
-     * Removes the endpoint for the given session.
-     *
-     * @param id The session identifier
-     */
-    public void removeSession(String id) {
-
-        if (isClusteringEnable) {   // if this is a clustering env.
-
-            if (keyPrefix != null) {
-                if (log.isDebugEnabled()) {
-                    log.debug("Removing and replicating " +
-                            "the session with the session id " + keyPrefix + id);
-                }
-                //Removes the endpoint name and then replicates the current
-                //state so that all instances
-                Replicator.removeAndReplicateState(keyPrefix + id, configCtx);
-            }
-
-        } else {
-
-            synchronized (sessionMap) {
-                if (log.isDebugEnabled()) {
-                    log.debug("Removing the session with the session id " + id);
-                }
-                sessionMap.remove(id);
-            }
-        }
-    }
-
-    /**
-     * Get the configuration context instance . This is only available for cluster env.
-     *
-     * @return Returns the ConfigurationContext instance
-     */
-    public ConfigurationContext getConfigurationContext() {
-        return configCtx;
-    }
-
-    /**
-     * Sets the  ConfigurationContext instance . This is only used for cluster env.
-     * By setting this , indicates that this is a cluster env.
-     *
-     * @param configCtx The ConfigurationContext instance
-     */
-    public void setConfigurationContext(ConfigurationContext configCtx) {
-
-        if (configCtx == null) {
-            handleException("The ConfigurationContext cannot be null" +
-                    " when system in a cluster environment");
-        }
-
-        this.configCtx = configCtx;
-        this.isClusteringEnable = true; // Now, the environment is considered as a cluster
-    }
-
-    /**
-     * Sets the identifier for this dispatcher context , so that , this can be identified
-     * uniquely across the cluster. The id will be the name of the endpoint
-     *
-     * @param contextID The Id for this dispatcher context
-     */
-    public void setContextID(String contextID) {
-
-        if (contextID == null || "".equals(contextID)) {
-            handleException("The Context ID cannot be null when system in a cluster environment");
-        }
-
-        //Making required key for each property in the dispatcher context - Those will be used when
-        //replicating states
-        StringBuffer buffer = new StringBuffer();
-        buffer.append(contextID);
-        buffer.append(UNDERSCORE_STRING);
-        buffer.append(SESSION);
-        buffer.append(UNDERSCORE_STRING);
-        keyPrefix = buffer.toString();
-
-    }
-
-    /**
-     * Helper methods for handle errors.
-     *
-     * @param msg The error message
-     */
-    private void handleException(String msg) {
-        log.error(msg);
-        throw new SynapseException(msg);
-    }
-
-    /**
-     * Returns whether clustering is enable or not
-     *
-     * @return True - enable , false -> this is not a cluster env.
-     */
-    public boolean isClusteringEnable() {
-        return isClusteringEnable;
-    }
-
-    /**
-     * Sets the defined child endpoints
-     *
-     * @param endpoints The endpoint list
-     */
-    public void setEndpoints(List<Endpoint> endpoints) {
-
-        if (endpoints != null) {
-
-            for (Endpoint endpoint : endpoints) {
-
-                String endpointName;
-                if (endpoint instanceof IndirectEndpoint) {
-                    endpointName = ((IndirectEndpoint) endpoint).getKey();
-                } else {
-                    endpointName = endpoint.getName();
-                }
-
-                if (endpointName == null) {
-                    if (log.isDebugEnabled() && isClusteringEnable()) {
-                        log.warn(SALoadbalanceEndpoint.WARN_MESSAGE);
-                    }
-                    endpointName = SynapseConstants.ANONYMOUS_ENDPOINT;
-                }
-
-                if (log.isDebugEnabled()) {
-                    log.debug("Adding an endpoint with the name/key "
-                            + endpointName + " to the endpoints map");
-                }
-                endpointsMap.put(endpointName, endpoint);
-            }
-        }
-    }
-}
\ No newline at end of file
diff --git a/java/modules/core/src/main/java/org/apache/synapse/endpoints/dispatch/HttpSessionDispatcher.java b/java/modules/core/src/main/java/org/apache/synapse/endpoints/dispatch/HttpSessionDispatcher.java
index ff71023c1..cc9066e0e 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/endpoints/dispatch/HttpSessionDispatcher.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/endpoints/dispatch/HttpSessionDispatcher.java
@@ -19,24 +19,17 @@
 
 package org.apache.synapse.endpoints.dispatch;
 
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
 import org.apache.synapse.MessageContext;
-import org.apache.synapse.core.axis2.Axis2MessageContext;
-import org.apache.synapse.endpoints.Endpoint;
 
-import java.util.Map;
 
 /**
  * Dispatches sessions based on HTTP cookies. Session is initiated by the server in the first
  * response when it sends "Set-Cookie" HTTP header with the session ID. For all successive messages
  * client should send "Cookie" HTTP header with session ID send by the server.
  */
-public class HttpSessionDispatcher implements Dispatcher {
+public class HttpSessionDispatcher extends AbstractDispatcher {
 
-    private static final Log log = LogFactory.getLog(HttpSessionDispatcher.class);
 
-    private final static String TRANSPORT_HEADERS = "TRANSPORT_HEADERS";
     /*HTTP Headers  */
     private final static String COOKIE = "Cookie";
     private final static String SET_COOKIE = "Set-Cookie";
@@ -49,40 +42,8 @@ public class HttpSessionDispatcher implements Dispatcher {
      * @param synCtx MessageContext possibly containing a "Cookie" HTTP header.
      * @return Endpoint Server endpoint for the given HTTP session.
      */
-    public Endpoint getEndpoint(MessageContext synCtx, DispatcherContext dispatcherContext) {
-
-        Endpoint endpoint = null;
-
-        org.apache.axis2.context.MessageContext axis2MessageContext =
-                ((Axis2MessageContext) synCtx).getAxis2MessageContext();
-
-        Object o = axis2MessageContext.getProperty(TRANSPORT_HEADERS);
-        if (o != null && o instanceof Map) {
-            Map headerMap = (Map) o;
-            Object cookie = headerMap.get(COOKIE);
-
-            if (cookie != null && cookie instanceof String) {
-
-                if (log.isDebugEnabled()) {
-                    log.debug("Using the HTTP header 'Cookie: " + cookie
-                            + "' to retrieve the endpoint in the transport session");
-                }
-
-                Object ep = dispatcherContext.getEndpoint((String) cookie);
-                if (ep != null && ep instanceof Endpoint) {
-                    endpoint = (Endpoint) ep;
-                } else if (log.isDebugEnabled()) {
-                    log.debug("No endpoint found in the transport " +
-                            "session for the session id " + cookie);
-                }
-                
-            } else if (log.isDebugEnabled()) {
-                log.debug("No 'Cookie' HTTP headers found to extract the " +
-                        "endpoint from the transport session");
-            }
-        }
-
-        return endpoint;
+    public SessionInformation getSession(MessageContext synCtx) {
+        return SALSessions.getInstance().getSession(extractSessionID(synCtx, COOKIE));
     }
 
     /**
@@ -90,76 +51,39 @@ public class HttpSessionDispatcher implements Dispatcher {
      * session ID is not already in the session map update the session map by mapping the cookie
      * to the endpoint.
      *
-     * @param synCtx   MessageContext possibly containing the "Set-Cookie" HTTP header.
-     * @param endpoint Endpoint to be mapped to the session.
+     * @param synCtx MessageContext possibly containing the "Set-Cookie" HTTP header.
      */
-    public void updateSession(MessageContext synCtx, DispatcherContext dispatcherContext,
-        Endpoint endpoint) {
-
-        if (endpoint == null || dispatcherContext == null) {
-            return;
-        }
+    public void updateSession(MessageContext synCtx) {
+
+        Object cookie = extractSessionID(synCtx, SET_COOKIE);
+
+        if (cookie != null && cookie instanceof String) {
+
+            // extract the first name value pair of the Set-Cookie header, which is considered
+            // as the session id which will be sent back from the client with the Cookie header
+            // for example;
+            //      Set-Cookie: JSESSIONID=760764CB72E96A7221506823748CF2AE; Path=/
+            // will result in the session id "JSESSIONID=760764CB72E96A7221506823748CF2AE"
+            // and the client is expected to send the Cookie header as;
+            //      Cookie: JSESSIONID=760764CB72E96A7221506823748CF2AE
+            if (log.isDebugEnabled()) {
+                log.debug("Found the HTTP header 'Set-Cookie: "
+                        + cookie + "' for updating the session");
+            }
+            String sessionId = ((String) cookie).split(";")[0];
 
-        org.apache.axis2.context.MessageContext axis2MessageContext =
-                ((Axis2MessageContext) synCtx).getAxis2MessageContext();
-
-        Object o = axis2MessageContext.getProperty(TRANSPORT_HEADERS);
-        if (o != null && o instanceof Map) {
-            Map headerMap = (Map) o;
-            Object cookie = headerMap.get(SET_COOKIE);
-
-            if (cookie != null && cookie instanceof String) {
-                
-                // extract the first name value pair of the Set-Cookie header, which is considered
-                // as the session id which will be sent back from the client with the Cookie header
-                // for example;
-                //      Set-Cookie: JSESSIONID=760764CB72E96A7221506823748CF2AE; Path=/
-                // will result in the session id "JSESSIONID=760764CB72E96A7221506823748CF2AE"
-                // and the client is expected to send the Cookie header as;
-                //      Cookie: JSESSIONID=760764CB72E96A7221506823748CF2AE
-                if (log.isDebugEnabled()) {
-                    log.debug("Found the HTTP header 'Set-Cookie: "
-                            + cookie + "' for updating the session");
-                }
-                String sessionId = ((String) cookie).split(";")[0];
-
-                if (log.isDebugEnabled()) {
-                    log.debug("Using the session id '" + sessionId +
-                            "' extracted from the Set-Cookie header to update the session " +
-                            "with the endpoint " + endpoint);
-                }
-                dispatcherContext.setEndpoint(sessionId, endpoint);
-                
-            } else if (log.isDebugEnabled()) {
-                log.debug("No 'Set-Cookie' HTTP header is specified in " +
-                        "the message to update the session");
+            if (log.isDebugEnabled()) {
+                log.debug("Using the session id '" + sessionId +
+                        "' extracted from the Set-Cookie header ");
             }
+
+            SALSessions.getInstance().updateSession(synCtx, sessionId);
         }
+
     }
 
-    public void unbind(MessageContext synCtx, DispatcherContext dispatcherContext) {
-
-        org.apache.axis2.context.MessageContext axis2MessageContext =
-                ((Axis2MessageContext) synCtx).getAxis2MessageContext();
-
-        Object o = axis2MessageContext.getProperty(TRANSPORT_HEADERS);
-        if (o != null && o instanceof Map) {
-            Map headerMap = (Map) o;
-            Object cookie = headerMap.get(COOKIE);
-
-            if (cookie != null && cookie instanceof String) {
-                
-                if (log.isDebugEnabled()) {
-                    log.debug("Using the HTTP header 'Cookie: "
-                            + cookie + "' to unbind the session");
-                }
-                dispatcherContext.removeSession((String) cookie);
-                
-            } else if (log.isDebugEnabled()) {
-                log.debug("No 'Cookie' HTTP header is specified in " +
-                        "the message to unbind the session");
-            }
-        }
+    public void unbind(MessageContext synCtx) {
+        SALSessions.getInstance().removeSession(extractSessionID(synCtx, COOKIE));
     }
 
     /**
@@ -170,4 +94,8 @@ public class HttpSessionDispatcher implements Dispatcher {
     public boolean isServerInitiatedSession() {
         return true;
     }
+
+    public void removeSessionID(MessageContext syCtx) {
+        removeSessionID(syCtx, COOKIE);
+    }
 }
diff --git a/java/modules/core/src/main/java/org/apache/synapse/endpoints/dispatch/SALSessions.java b/java/modules/core/src/main/java/org/apache/synapse/endpoints/dispatch/SALSessions.java
new file mode 100755
index 000000000..c434a9252
--- /dev/null
+++ b/java/modules/core/src/main/java/org/apache/synapse/endpoints/dispatch/SALSessions.java
@@ -0,0 +1,554 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.endpoints.dispatch;
+
+import org.apache.axis2.context.ConfigurationContext;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.apache.synapse.MessageContext;
+import org.apache.synapse.SynapseConstants;
+import org.apache.synapse.SynapseException;
+import org.apache.synapse.endpoints.Endpoint;
+import org.apache.synapse.endpoints.IndirectEndpoint;
+import org.apache.synapse.endpoints.SALoadbalanceEndpoint;
+import org.apache.synapse.util.Replicator;
+
+import java.util.*;
+
+/**
+ * Keeps the states of the sessions
+ */
+public class SALSessions {
+
+    private static final SALSessions INSTANCE = new SALSessions();
+
+    private static final Log log = LogFactory.getLog(SALSessions.class);
+
+    private String SESSION_IDS = "synapse.salep.sessionids.";
+
+    private static ConfigurationContext configCtx;
+
+    /* Is this env. support clustering*/
+    private static boolean isClustered = false;
+
+    private static boolean initialized = false;
+
+    /*Cache all path with its endpoint sequence. This is only need for a clustered environment */
+    private final Map<List<String>, List<Endpoint>> namesToEndpointsMap =
+            new HashMap<List<String>, List<Endpoint>>();
+
+    /* Non- clustered environment , all the established sessions*/
+    private final Map<String, SessionInformation> establishedSessions =
+            new HashMap<String, SessionInformation>();
+    /* all child endpoints .  This is only need for a clustered environment*/
+    private final Map<String, Map<String, Endpoint>> childEndpoints =
+            new HashMap<String, Map<String, Endpoint>>();
+
+    private SALSessions() {
+    }
+
+    public static SALSessions getInstance() {
+        return INSTANCE;
+    }
+
+    /**
+     * Initialize SALSessions instance
+     *
+     * @param isClusteringEnable is this a clustered environment
+     * @param cc                 Axis config context
+     */
+    public void initialize(boolean isClusteringEnable, ConfigurationContext cc) {
+
+        if (!initialized) {
+            if (log.isDebugEnabled()) {
+                log.debug("Initializing SALSessions instance. Environment : " +
+                        (isClusteringEnable ? " clustered" : " local"));
+            }
+            if (isClusteringEnable) {
+                isClustered = isClusteringEnable;
+                configCtx = cc;
+            }
+            initialized = true;
+        }
+    }
+
+    /**
+     * This method only use in a clustered environment.
+     *
+     * @param endpoint  Root endpoint name
+     * @param endpoints children
+     */
+    public void registerChildren(Endpoint endpoint, List<Endpoint> endpoints) {
+
+        if (isClustered) {
+
+            String endpointName = endpoint.getName();
+
+            validateInput(endpointName);
+
+            if (log.isDebugEnabled()) {
+                log.debug("Registering endpoints " + endpoints + " of " + endpointName);
+            }
+
+            if (!childEndpoints.containsKey(endpointName)) {
+
+                Map<String, Endpoint> children = new HashMap<String, Endpoint>();
+                children.put(endpointName, endpoint);
+                fillMap(endpoints, children);
+                childEndpoints.put(endpointName, children);
+
+            }
+        }
+
+    }
+
+    /**
+     * Update or establish a session
+     *
+     * @param synCtx    Synapse MessageContext
+     * @param sessionID session id
+     */
+    public void updateSession(MessageContext synCtx, String sessionID) {
+
+        if (sessionID == null || "".equals(sessionID)) {
+            if (log.isDebugEnabled()) {
+                log.debug("Cannot find session ID .Returing null");
+            }
+            return;
+        }
+
+        boolean createSession = false;
+
+        //if this is related to the already established session
+        SessionInformation oldSession = (SessionInformation) synCtx.getProperty(
+                SynapseConstants.PROP_SAL_CURRENT_SESSION_INFORMATION);
+
+        List<Endpoint> endpoints = null;
+
+        if (oldSession == null) {
+
+            if (log.isDebugEnabled()) {
+                log.debug("Going to create a New session with id  " + sessionID);
+            }
+            endpoints = (List<Endpoint>) synCtx.getProperty(
+                    SynapseConstants.PROP_SAL_ENDPOINT_ENDPOINT_LIST);
+            createSession = true;
+
+        } else {
+
+            String oldSessionID = oldSession.getId();
+            if (!sessionID.equals(oldSessionID)) {
+
+                if (log.isDebugEnabled()) {
+                    log.debug("Renew the session : previous session id :" +
+                            oldSessionID + " new session id :" + sessionID);
+                }
+                removeSession(oldSessionID);
+                endpoints = oldSession.getEndpointList();
+                createSession = true;
+
+            } else {
+
+                SessionInformation information = getSessionInformation(oldSessionID);
+                if (information == null) {
+                    // This means , our session information has been removed during getting response.
+                    // Therefore, it is recovered using session information in the message context
+                    if (log.isDebugEnabled()) {
+                        log.debug("Recovering lost session information for session id " + sessionID);
+                    }
+                    endpoints = oldSession.getEndpointList();
+                    createSession = true;
+                } else {
+                    if (log.isDebugEnabled()) {
+                        log.debug("Session with id : " + sessionID + " is still live.");
+                    }
+                }
+            }
+        }
+
+        if (createSession) {
+
+            SessionInformation newInformation = createSessionInformation(
+                    synCtx, sessionID, endpoints);
+
+            if (log.isDebugEnabled()) {
+                log.debug("Establishing a session with id :" +
+                        sessionID + " and it's endpoint sequence : " + endpoints);
+            }
+
+            if (isClustered) {
+                Replicator.setAndReplicateState(SESSION_IDS + sessionID, newInformation, configCtx);
+            } else {
+                establishedSessions.put(sessionID, newInformation);
+            }
+        }
+    }
+
+    /**
+     * return the endpoint  for the given session.
+     * Null will be returned , if there is no endpoint for given session.
+     *
+     * @param sessionID The session identifier
+     * @return Returns the endpoint for the given session.
+     */
+    public SessionInformation getSession(String sessionID) {
+
+        if (sessionID == null || "".equals(sessionID)) {
+            if (log.isDebugEnabled()) {
+                log.debug("Cannot find session ID .Returing null");
+            }
+            return null;
+        }
+
+        if (log.isDebugEnabled()) {
+            log.debug("Retrieving the endpoint from the session id " + sessionID);
+        }
+
+        SessionInformation information = getSessionInformation(sessionID);
+        if (information == null) {
+            if (log.isDebugEnabled()) {
+                log.debug("Session information cannot be found for session id " + sessionID);
+            }
+            return null;
+        }
+
+        if (information.isExpired()) {
+            if (log.isDebugEnabled()) {
+                log.debug("Session has been expired for session with id: " + sessionID);
+            }
+            removeSession(sessionID);
+            return null;
+        }
+
+        return information;
+    }
+
+    /**
+     * Returns endpoint sequence related to the given session
+     *
+     * @param information Session information
+     * @return endpoint sequence
+     */
+    public List<Endpoint> getChildEndpoints(SessionInformation information) {
+
+        List<Endpoint> endpoints;
+        if (isClustered) {
+            endpoints =
+                    getEndpoints(information.getPath(), information.getRootEndpointName());
+        } else {
+            endpoints = information.getEndpointList();
+        }
+        if (log.isDebugEnabled()) {
+            log.debug("Retrieving endpoint sequence : " + endpoints +
+                    " for session " + information.getId());
+        }
+
+        if (endpoints == null || endpoints.isEmpty()) {
+            handleException("Session with id " + information.getId() + " is invalid ." +
+                    " A session must have a endpoint sequence associated with it");
+        }
+
+        List<Endpoint> toBeSent = new ArrayList<Endpoint>();
+        toBeSent.addAll(endpoints);
+        //remove the root as only expect children
+        toBeSent.remove(0);
+
+        return toBeSent;
+    }
+
+    /**
+     * Removes the endpoint for the given session.
+     *
+     * @param sessionId The session identifier
+     */
+    public void removeSession(String sessionId) {
+
+        if (sessionId == null || "".equals(sessionId)) {
+            if (log.isDebugEnabled()) {
+                log.debug("Session Id cannot be found.The session will not be removed.");
+            }
+            return;
+        }
+
+        if (log.isDebugEnabled()) {
+            log.debug("Removing the session with the session Id " + sessionId);
+        }
+
+        if (isClustered) {
+            Replicator.removeAndReplicateState(SESSION_IDS + sessionId, configCtx);
+
+        } else {
+            establishedSessions.remove(sessionId);
+        }
+    }
+
+    /**
+     * Clear all the expired sessions
+     */
+    public synchronized void clearSessions() {
+
+        if (!initialized) {
+            return;
+        }
+
+        try {
+            if (isClustered) {
+
+                List<String> toBeRemoved = new ArrayList<String>();
+                for (Iterator props = configCtx.getPropertyNames(); props.hasNext();) {
+                    Object name = props.next();
+
+                    if (name instanceof String && ((String) name).startsWith(SESSION_IDS)) {
+                        String key = (String) name;
+                        SessionInformation info = (SessionInformation) configCtx.getProperty(key);
+
+                        if (info != null && info.isExpired()) {
+                            if (log.isDebugEnabled()) {
+                                log.debug("Clustered Environment :" +
+                                        "Expired session with id :" + key);
+                            }
+
+                            toBeRemoved.add(key);
+                        }
+                    }
+                }
+
+                if (!toBeRemoved.isEmpty()) {
+                    log.info("Clearing expired sessions");
+
+                    for (String key : toBeRemoved) {
+                        Replicator.removeAndReplicateState(key, configCtx);
+                    }
+                }
+
+            } else {
+
+                List<String> toBeRemoved = new ArrayList<String>();
+                for (SessionInformation information : establishedSessions.values()) {
+
+                    if (information != null && information.isExpired()) {
+                        String id = information.getId();
+                        if (log.isDebugEnabled()) {
+                            log.debug("Expired session with id :" + id);
+                        }
+                        toBeRemoved.add(id);
+                    }
+                }
+
+                if (!toBeRemoved.isEmpty()) {
+                    log.info("Clearing expired sessions");
+                    establishedSessions.keySet().removeAll(toBeRemoved);
+                }
+            }
+        } catch (Throwable ignored) {
+            log.debug("Ignored error clearing sessions : Error " + ignored);
+        }
+    }
+
+    public boolean isInitialized() {
+        return initialized;
+    }
+
+    /**
+     * Helper methods for handle errors.
+     *
+     * @param msg The error message
+     */
+    private static void handleException(String msg) {
+        log.error(msg);
+        throw new SynapseException(msg);
+    }
+
+    public void reset() {
+        log.info("Clearing all states ");
+        initialized = false;
+        establishedSessions.clear();
+        namesToEndpointsMap.clear();
+        childEndpoints.clear();
+    }
+    /*
+     * Helper method to get a map from a list - This is for clustered env.
+     */
+    private void fillMap(List<Endpoint> endpoints, Map<String, Endpoint> endpointsMap) {
+
+        if (endpoints != null) {
+            for (Endpoint endpoint : endpoints) {
+
+                String endpointName = getEndpointName(endpoint);
+                if (endpointsMap.containsKey(endpointName)) {
+                    handleException("Endpoint Name with ' " + endpointName + "' already there. " +
+                            "Endpoint name must be unique.");
+                }
+                endpointsMap.put(endpointName, endpoint);
+                fillMap(endpoint.getChildren(), endpointsMap);
+            }
+        }
+    }
+
+    /*
+    * Helper method to get a name of endpoints from a endpoint list - This is for clustered env.
+    */
+    private List<String> getEndpointNames(List<Endpoint> endpoints) {
+
+        List<String> endpointNames = new ArrayList<String>();
+        for (Endpoint endpoint : endpoints) {
+            endpointNames.add(getEndpointName(endpoint));
+        }
+        return endpointNames;
+    }
+
+    /*
+     * Helper method to get a list of endpoints from a list of endpoint name maps - This is for clustered env.
+     */
+    private List<Endpoint> getEndpoints(List<String> endpointNames, String root) {
+
+        if (endpointNames == null || endpointNames.isEmpty()) {
+            handleException("Invalid session - path cannot be null.");
+
+        }
+        if (log.isDebugEnabled()) {
+            log.debug("Retrieving endpoint sequence for path " + endpointNames);
+        }
+        List<Endpoint> endpoints = new ArrayList<Endpoint>();
+        // First looking at cache - we cache path -> endpoint list . o.w It is a cost
+        // to each time calculate
+        if (namesToEndpointsMap.containsKey(endpointNames)) {
+            endpoints.addAll(namesToEndpointsMap.get(endpointNames));
+            return endpoints;
+        }
+
+        Map<String, Endpoint> map = childEndpoints.get(root);
+        for (String endpointName : endpointNames) {
+            Endpoint endpoint = null;
+            if (map != null) {
+                endpoint = map.get(endpointName);
+                if (endpoint == null || endpoints.contains(endpoint)) {
+                    map = childEndpoints.get(endpointName);
+                    if (map != null) {
+                        endpoint = map.get(endpointName);
+                    }
+                }
+            }
+            if (endpoint == null) {
+                handleException("Invalid session. Endpoint with name '" +
+                        endpointName + "' cannot found");
+            }
+            endpoints.add(endpoint);
+        }
+        //cache path(endpoint names) vs endpoint (instance) sequence
+        namesToEndpointsMap.put(endpointNames, endpoints);
+
+        return endpoints;
+    }
+
+    /*
+     * Validate endpoint name
+     */
+    private void validateInput(String endpointName) {
+
+        if (endpointName == null) {
+            handleException("For proper clustered mode operation, " +
+                    "all endpoints should be uniquely named");
+        }
+    }
+
+    /*
+     * Returns an endpoint name for the endpoint object -  This is for clustered env.
+     */
+    private String getEndpointName(Endpoint endpoint) {
+
+        if (endpoint == null) {
+            handleException("Endpoint cannot be null.");
+        }
+
+        String endpointName = endpoint.getName();
+        if (endpointName == null && endpoint instanceof IndirectEndpoint) {
+            endpointName = ((IndirectEndpoint) endpoint).getKey();
+        }
+        validateInput(endpointName);
+        return endpointName;
+    }
+
+    /*
+     * Returns a session information for given session id
+     */
+    private SessionInformation getSessionInformation(String sessionID) {
+
+        if (isClustered) {
+            return (SessionInformation)
+                    configCtx.getPropertyNonReplicable(SESSION_IDS + sessionID);
+        } else {
+            return establishedSessions.get(sessionID);
+        }
+    }
+
+    /*
+     * Factory method to create a session information using given endpoint list , session id and other informations
+     */
+    private SessionInformation createSessionInformation(MessageContext synCtx, String id, List<Endpoint> endpoints) {
+
+        if (endpoints == null || endpoints.isEmpty()) {
+            handleException("Invalid request to create sessions . Cannot find a endpoint sequence.");
+        }
+
+        if (log.isDebugEnabled()) {
+            log.debug("Creating a session information for given session id  " + id
+                    + " with endpoint sequence " + endpoints);
+        }
+
+        long expireTimeWindow = -1;
+        for (Endpoint endpoint : endpoints) {
+
+            if (endpoint instanceof SALoadbalanceEndpoint) {
+                long sessionsTimeout = ((SALoadbalanceEndpoint) endpoint).getSessionTimeout();
+
+                if (expireTimeWindow == -1) {
+                    expireTimeWindow = sessionsTimeout;
+                } else if (expireTimeWindow > sessionsTimeout) {
+                    expireTimeWindow = sessionsTimeout;
+                }
+            }
+        }
+
+        if (expireTimeWindow == -1) {
+            expireTimeWindow = synCtx.getConfiguration().getProperty(
+                    SynapseConstants.PROP_SAL_ENDPOINT_DEFAULT_SESSION_TIMEOUT,
+                    SynapseConstants.SAL_ENDPOINTS_DEFAULT_SESSION_TIMEOUT);
+        }
+
+        if (log.isDebugEnabled()) {
+            log.debug("For session with id " + id + " : expiry time interval : " + expireTimeWindow);
+        }
+
+        long expiryTime = System.currentTimeMillis() + expireTimeWindow;
+
+        Endpoint rootEndpoint = endpoints.get(0);
+
+        SessionInformation information = new SessionInformation(id,
+                endpoints, expiryTime);
+
+        if (isClustered) {
+            List<String> epNameList = getEndpointNames(endpoints);
+            information.setPath(epNameList);
+            information.setRootEndpointName(getEndpointName(rootEndpoint));
+        }
+        return information;
+    }
+}
\ No newline at end of file
diff --git a/java/modules/core/src/main/java/org/apache/synapse/endpoints/dispatch/SessionInformation.java b/java/modules/core/src/main/java/org/apache/synapse/endpoints/dispatch/SessionInformation.java
new file mode 100755
index 000000000..6abe1895d
--- /dev/null
+++ b/java/modules/core/src/main/java/org/apache/synapse/endpoints/dispatch/SessionInformation.java
@@ -0,0 +1,91 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.endpoints.dispatch;
+
+
+import org.apache.synapse.endpoints.Endpoint;
+
+import java.io.Serializable;
+import java.util.List;
+
+/**
+ * DataStructure for session information
+ */
+public class SessionInformation implements Serializable {
+
+    private static final long serialVersionUID = -3771579091940569938L;
+    private String id;
+    private String rootEndpointName;
+    private List<String> path;
+    private long expiryTime;
+    private transient List<Endpoint> endpointList;
+
+    public SessionInformation(String id, List<Endpoint> endpointList, long expiryTime) {
+        this.id = id;
+        this.endpointList = endpointList;
+        this.expiryTime = expiryTime;
+    }
+
+    public String getId() {
+        return id;
+    }
+
+    public void setId(String id) {
+        this.id = id;
+    }
+
+    public List<String> getPath() {
+        return path;
+    }
+
+    public void setPath(List<String> path) {
+        this.path = path;
+    }
+
+    public long getExpiryTime() {
+        return expiryTime;
+    }
+
+    public void setExpiryTime(long expiryTime) {
+        this.expiryTime = expiryTime;
+    }
+
+    public List<Endpoint> getEndpointList() {
+        return endpointList;
+    }
+
+    public void setEndpointList(List<Endpoint> endpointList) {
+        this.endpointList = endpointList;
+    }
+
+    public String getRootEndpointName() {
+        return rootEndpointName;
+    }
+
+    public void setRootEndpointName(String rootEndpointName) {
+        this.rootEndpointName = rootEndpointName;
+    }
+
+    public boolean isExpired() {
+        return expiryTime < System.currentTimeMillis();
+    }
+
+}
+
diff --git a/java/modules/core/src/main/java/org/apache/synapse/endpoints/dispatch/SimpleClientSessionDispatcher.java b/java/modules/core/src/main/java/org/apache/synapse/endpoints/dispatch/SimpleClientSessionDispatcher.java
index d177eef7e..3376440ac 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/endpoints/dispatch/SimpleClientSessionDispatcher.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/endpoints/dispatch/SimpleClientSessionDispatcher.java
@@ -19,12 +19,7 @@
 
 package org.apache.synapse.endpoints.dispatch;
 
-import org.apache.axiom.om.OMElement;
-import org.apache.axiom.soap.SOAPHeader;
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
 import org.apache.synapse.MessageContext;
-import org.apache.synapse.endpoints.Endpoint;
 
 import javax.xml.namespace.QName;
 
@@ -34,105 +29,33 @@ import javax.xml.namespace.QName;
  * request message. Therefore, above header has to be included in the request soap messages by the
  * client who wants to initiate and maintain a session.
  */
-public class SimpleClientSessionDispatcher implements Dispatcher {
+public class SimpleClientSessionDispatcher extends AbstractDispatcher {
 
-    private static final Log log = LogFactory.getLog(SimpleClientSessionDispatcher.class);
 
-    private static final QName CSID_QNAME
-            = new QName("http://ws.apache.org/ns/synapse", "ClientID", "syn");
+    private static final QName CSID_QNAME = new QName("http://ws.apache.org/ns/synapse",
+            "ClientID", "syn");
 
-    public Endpoint getEndpoint(MessageContext synCtx, DispatcherContext dispatcherContext) {
+    public SessionInformation getSession(MessageContext synCtx) {
 
-        SOAPHeader header = synCtx.getEnvelope().getHeader();
-
-        if (header != null) {
-            OMElement sgcIDElm = header.getFirstChildWithName(CSID_QNAME);
-
-            if (sgcIDElm != null) {
-                String sgcID = sgcIDElm.getText();
-
-                if (sgcID != null) {
-                    log.debug("Using the client session id : '"
-                            + sgcID + "' extracted from current message to retrieve endpoint");
-                    Object o = dispatcherContext.getEndpoint(sgcID);
-
-                    if (o != null && o instanceof Endpoint) {
-                        return (Endpoint) o;
-                    }
-                } else if (log.isDebugEnabled()) {
-                    log.debug("Couldn't find the client session id for the current message " +
-                            "to retrieve endpoint");
-                }
-            } else if (log.isDebugEnabled()) {
-                log.debug("Couldn't find a SOAP header with the QName " + CSID_QNAME +
-                        " for the current message to retrieve the endpoint");
-            }
-        }
-
-        return null;
+        return SALSessions.getInstance().getSession(
+                extractSessionID(synCtx.getEnvelope().getHeader(), CSID_QNAME));
     }
 
-    public void updateSession(MessageContext synCtx, DispatcherContext dispatcherContext,
-        Endpoint endpoint) {
-
-        if (endpoint == null || dispatcherContext == null) {
-            return;
-        }
-
-        SOAPHeader header = synCtx.getEnvelope().getHeader();
-
-        if (header != null) {
-            OMElement csIDElm = header.getFirstChildWithName(CSID_QNAME);
-
-            if (csIDElm != null) {
-                String csID = csIDElm.getText();
-
-                if (csID != null) {
-                    if (log.isDebugEnabled()) {
-                        log.debug("Using the client session id : '"
-                                + csID + "' extracted from current message to update the session");
-                    }
-                    dispatcherContext.setEndpoint(csID, endpoint);
-                } else if (log.isDebugEnabled()) {
-                    log.debug("Couldn't find the client session id for the current message " +
-                            "to update the session");
-                }
-            } else if (log.isDebugEnabled()) {
-                log.debug("Couldn't find a SOAP header with the QName " + CSID_QNAME +
-                        " for the current message to update the session");
-            }
-        }
+    public void updateSession(MessageContext synCtx) {
+        SALSessions.getInstance().updateSession(synCtx,
+                extractSessionID(synCtx.getEnvelope().getHeader(), CSID_QNAME));
     }
 
-
-    public void unbind(MessageContext synCtx, DispatcherContext dispatcherContext) {
-
-        if (dispatcherContext == null) {
-            return;
-        }
-
-        SOAPHeader header = synCtx.getEnvelope().getHeader();
-
-        if (header != null) {
-            OMElement csIDElm = header.getFirstChildWithName(CSID_QNAME);
-
-            if (csIDElm != null) {
-                String csID = csIDElm.getText();
-
-                if (csID != null) {
-                    dispatcherContext.removeSession(csID);
-                } else if (log.isDebugEnabled()) {
-                    log.debug("Couldn't find the client session id for the current message " +
-                            "to unbind the session");
-                }
-            } else if (log.isDebugEnabled()) {
-                log.debug("Couldn't find a SOAP header with the QName " + CSID_QNAME +
-                        " for the current message to unbind the session");
-            }
-        }
+    public void unbind(MessageContext synCtx) {
+        SALSessions.getInstance().removeSession(
+                extractSessionID(synCtx.getEnvelope().getHeader(), CSID_QNAME));
     }
 
     public boolean isServerInitiatedSession() {
         return false;
     }
+
+    public void removeSessionID(MessageContext syCtx) {
+        // no need to remove
+    }
 }
diff --git a/java/modules/core/src/main/java/org/apache/synapse/endpoints/dispatch/SoapSessionDispatcher.java b/java/modules/core/src/main/java/org/apache/synapse/endpoints/dispatch/SoapSessionDispatcher.java
index ca9fcc913..846900fcc 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/endpoints/dispatch/SoapSessionDispatcher.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/endpoints/dispatch/SoapSessionDispatcher.java
@@ -22,16 +22,12 @@ package org.apache.synapse.endpoints.dispatch;
 import org.apache.axiom.om.OMElement;
 import org.apache.axiom.soap.SOAPHeader;
 import org.apache.axis2.addressing.AddressingConstants;
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
 import org.apache.synapse.MessageContext;
-import org.apache.synapse.endpoints.Endpoint;
 
 import javax.xml.namespace.QName;
 
-public class SoapSessionDispatcher implements Dispatcher {
+public class SoapSessionDispatcher extends AbstractDispatcher {
 
-    private static final Log log = LogFactory.getLog(SoapSessionDispatcher.class);
 
     private static final QName QNAME_SERVICE_GROUP_ID
             = new QName("http://ws.apache.org/namespaces/axis2", "ServiceGroupId", "axis2");
@@ -44,31 +40,9 @@ public class SoapSessionDispatcher implements Dispatcher {
      *         message and if current message is not the first message of the session. Returns null,
      *         if an Endpoint could not be found for the session.
      */
-    public Endpoint getEndpoint(MessageContext synCtx, DispatcherContext dispatcherContext) {
-
-        Endpoint endpoint = null;
-        SOAPHeader header = synCtx.getEnvelope().getHeader();
-        
-        if (header != null) {
-            OMElement sgcElm = header.getFirstChildWithName(QNAME_SERVICE_GROUP_ID);
-
-            if (sgcElm != null) {
-                String sgcID = sgcElm.getText();
-
-                if (sgcID != null) {
-                    if (log.isDebugEnabled()) {
-                        log.debug("Using the ServiceGroupId SOAP header value "
-                                + sgcID + " to retrieve endpoint on the session");
-                    }
-                    endpoint = dispatcherContext.getEndpoint(sgcID);
-                }
-            } else if (log.isDebugEnabled()) {
-                log.debug("Couldn't find the ServiceQroupId SOAP " +
-                        "header to retrieve the endpoint on the session");
-            }
-        }
-
-        return endpoint;
+    public SessionInformation getSession(MessageContext synCtx) {
+        return SALSessions.getInstance().getSession(
+                extractSessionID(synCtx.getEnvelope().getHeader(), QNAME_SERVICE_GROUP_ID));
     }
 
     /**
@@ -76,20 +50,14 @@ public class SoapSessionDispatcher implements Dispatcher {
      * It extracts the service group context ID (if available) from the message and updates the
      * session (service group context ID) -> endpoint map.
      *
-     * @param synCtx   MessageContext of the response message.
-     * @param endpoint Endpoint to associate with the session.
+     * @param synCtx MessageContext of the response message.
      */
-    public void updateSession(MessageContext synCtx, DispatcherContext dispatcherContext,
-        Endpoint endpoint) {
+    public void updateSession(MessageContext synCtx) {
 
-        if (endpoint == null || dispatcherContext == null) {
-            return;
-        }
         // get the service group context id
         // check if service group context id is a key of any entry
         // if not, add an entry <service group context id, endpoint>
 
-
         SOAPHeader header = synCtx.getEnvelope().getHeader();
 
         if (header != null) {
@@ -101,24 +69,9 @@ public class SoapSessionDispatcher implements Dispatcher {
                         "http://www.w3.org/2005/08/addressing", "ReferenceParameters", "wsa"));
 
                 if (referenceParameters != null) {
-                    OMElement sgcElm
-                            = referenceParameters.getFirstChildWithName(QNAME_SERVICE_GROUP_ID);
-
-                    if (sgcElm != null) {
-                        // synchronized to avoid possible replacement of sessions
-                        String sgcID = sgcElm.getText();
-
-                        if (sgcID != null) {
-                            if (log.isDebugEnabled()) {
-                                log.debug("Using the ServiceGroupId value "
-                                        + sgcID + " to update the endpoint session");
-                            }
-                            dispatcherContext.setEndpoint(sgcID, endpoint);
-                        }
-                    } else if (log.isDebugEnabled()) {
-                        log.debug("Couldn't find the WSA ServiceQroupId on the " +
-                                "ReferenceParameters of the Reply-To header to update the session");
-                    }
+                    SALSessions.getInstance().updateSession(synCtx,
+                            extractSessionID(referenceParameters, QNAME_SERVICE_GROUP_ID));
+
                 } else if (log.isDebugEnabled()) {
                     log.debug("Couldn't find the WSA ReferenceParameters in the Reply-To " +
                             "header to retrieve the ServiceQroupId");
@@ -129,27 +82,9 @@ public class SoapSessionDispatcher implements Dispatcher {
         }
     }
 
-    public void unbind(MessageContext synCtx, DispatcherContext dispatcherContext) {
-
-        SOAPHeader header = synCtx.getEnvelope().getHeader();
-
-        if (header != null) {
-            OMElement sgcIDElm = header.getFirstChildWithName(QNAME_SERVICE_GROUP_ID);
-
-            if (sgcIDElm != null) {
-                String sgcID = sgcIDElm.getText();
-
-                if (sgcID != null) {
-                    if (log.isDebugEnabled()) {
-                        log.debug("Using the ServiceGroupId value "
-                                + sgcID + " to unbind session");
-                    }
-                    dispatcherContext.removeSession(sgcID);
-                }
-            } else if (log.isDebugEnabled()) {
-                log.debug("Couldn't find the ServiceQroupId SOAP header to unbind the session");
-            }
-        }
+    public void unbind(MessageContext synCtx) {
+        SALSessions.getInstance().removeSession(extractSessionID(synCtx.getEnvelope().getHeader(),
+                QNAME_SERVICE_GROUP_ID));
     }
 
     /**
@@ -160,4 +95,8 @@ public class SoapSessionDispatcher implements Dispatcher {
     public boolean isServerInitiatedSession() {
         return true;
     }
+
+    public void removeSessionID(MessageContext syCtx) {
+        removeSessionID(syCtx.getEnvelope().getHeader(), QNAME_SERVICE_GROUP_ID);
+    }
 }
diff --git a/java/modules/core/src/main/java/org/apache/synapse/mediators/AbstractListMediator.java b/java/modules/core/src/main/java/org/apache/synapse/mediators/AbstractListMediator.java
index 254c45197..59fe12fe5 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/mediators/AbstractListMediator.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/mediators/AbstractListMediator.java
@@ -23,6 +23,7 @@ import org.apache.synapse.ManagedLifecycle;
 import org.apache.synapse.Mediator;
 import org.apache.synapse.MessageContext;
 import org.apache.synapse.core.SynapseEnvironment;
+import org.apache.axis2.context.ConfigurationContext;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -123,4 +124,13 @@ public abstract class AbstractListMediator extends AbstractMediator
             }
         } 
     }
+
+    public void init(ConfigurationContext cc) {
+
+        for (Mediator m : mediators) {
+            if (m instanceof AbstractMediator) {
+                ((AbstractMediator) m).init(cc);
+            }
+        }
+    }
 }
diff --git a/java/modules/core/src/main/java/org/apache/synapse/mediators/AbstractMediator.java b/java/modules/core/src/main/java/org/apache/synapse/mediators/AbstractMediator.java
index 26ba4e3c6..a1041192f 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/mediators/AbstractMediator.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/mediators/AbstractMediator.java
@@ -28,6 +28,7 @@ import org.apache.synapse.audit.AuditConfigurable;
 import org.apache.synapse.audit.AuditConfiguration;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
+import org.apache.axis2.context.ConfigurationContext;
 
 /**
  * This is the superclass of all mediators, and defines common logging, tracing other aspects
@@ -256,4 +257,13 @@ public abstract class AbstractMediator implements Mediator, AuditConfigurable{
     public void setAuditId(String id) {
         this.auditConfigurable.setAuditId(id);
     }
+
+    /**
+     * Initialize  mediator with configuration context.
+     * By default nothing to initiate and let it to decide each mediator itself
+     *
+     * @param cc ConfigurationContext instance
+     */
+    public void init(ConfigurationContext cc) {
+    }
 }
diff --git a/java/modules/core/src/main/java/org/apache/synapse/mediators/ListMediator.java b/java/modules/core/src/main/java/org/apache/synapse/mediators/ListMediator.java
index d5e9612cb..82982caf0 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/mediators/ListMediator.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/mediators/ListMediator.java
@@ -73,5 +73,5 @@ public interface ListMediator extends Mediator, ManagedLifecycle {
      * Return the list of mediators of this List mediator instance
      * @return the child/sub mediator list
      */
-    public List getList();
+    public List<Mediator> getList();
 }
diff --git a/java/modules/core/src/main/java/org/apache/synapse/mediators/builtin/CacheMediator.java b/java/modules/core/src/main/java/org/apache/synapse/mediators/builtin/CacheMediator.java
index fb3549109..62a4bac34 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/mediators/builtin/CacheMediator.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/mediators/builtin/CacheMediator.java
@@ -481,4 +481,11 @@ public class CacheMediator extends AbstractMediator implements ManagedLifecycle
     public void setMaxMessageSize(int maxMessageSize) {
         this.maxMessageSize = maxMessageSize;
     }
+
+    public void init(ConfigurationContext cc) {
+        
+        if (onCacheHitSequence != null) {
+            onCacheHitSequence.init(cc);
+        }
+    }
 }
diff --git a/java/modules/core/src/main/java/org/apache/synapse/mediators/builtin/SendMediator.java b/java/modules/core/src/main/java/org/apache/synapse/mediators/builtin/SendMediator.java
index 590bd72fd..e97ae61e4 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/mediators/builtin/SendMediator.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/mediators/builtin/SendMediator.java
@@ -57,76 +57,6 @@ public class SendMediator extends AbstractMediator {
             synLog.traceTrace("Message : " + synCtx.getEnvelope());
         }
 
-        if (synCtx.isResponse()) {
-
-            Axis2MessageContext axis2MsgCtx = (Axis2MessageContext) synCtx;
-            OperationContext opCtx = axis2MsgCtx.getAxis2MessageContext().getOperationContext();
-
-            boolean isClusteringEnable = false;
-
-            // get Axis2 MessageContext and ConfigurationContext
-            org.apache.axis2.context.MessageContext axisMC =
-                    axis2MsgCtx.getAxis2MessageContext();
-            ConfigurationContext cc = axisMC.getConfigurationContext();
-
-            //The heck for clustering environment
-
-            ClusterManager clusterManager = cc.getAxisConfiguration().getClusterManager();
-            if (clusterManager != null &&
-                    clusterManager.getContextManager() != null) {
-                isClusteringEnable = true;
-            }
-
-            if (isClusteringEnable) {
-                // if this is a clustering env.
-                // Only keeps endpoint names , because , it is heavy task to
-                // replicate endpoint itself
-                Object epNames = opCtx.getPropertyNonReplicable(SALoadbalanceEndpoint.ENDPOINT_NAME_LIST);
-                if (epNames != null && epNames instanceof List) {
-
-                    List epNameList = (List) epNames;
-                    Object obj = epNameList.remove(0);
-                    if (obj != null && obj instanceof String) {
-                        Object rootEPObj = opCtx.getPropertyNonReplicable(
-                                SALoadbalanceEndpoint.ROOT_ENDPOINT);
-
-                        if (rootEPObj != null && rootEPObj instanceof Endpoint) {
-                            String name = ((Endpoint) rootEPObj).getName();
-
-                            if (name != null && name.equals(obj)) {
-                                Endpoint rootEP = ((Endpoint) rootEPObj);
-
-                                if (rootEP instanceof SALoadbalanceEndpoint) {
-                                    SALoadbalanceEndpoint salEP = (SALoadbalanceEndpoint) rootEP;
-                                    salEP.updateSession(synCtx, epNameList,
-                                            isClusteringEnable);
-                                }
-                            }
-                        }
-
-                    }
-                    opCtx.setProperty(SALoadbalanceEndpoint.ENDPOINT_NAME_LIST, epNames);
-                }
-
-            } else {
-                Object o = opCtx.getProperty(SALoadbalanceEndpoint.ENDPOINT_LIST);
-                if (o != null && o instanceof List) {
-                    // we are in the response of the first message of a server initiated session
-                    // so update all session maps
-                    List epList = (List) o;
-                    Object e = epList.remove(0);
-
-                    if (e != null) {
-                        if (e instanceof SALoadbalanceEndpoint) {
-                            SALoadbalanceEndpoint salEP = (SALoadbalanceEndpoint) e;
-                            salEP.updateSession(synCtx, epList, isClusteringEnable);
-                        }
-                    }
-                }
-            }
-
-        }
-
         // if no endpoints are defined, send where implicitly stated
         if (endpoint == null) {
 
@@ -162,4 +92,11 @@ public class SendMediator extends AbstractMediator {
     public void setEndpoint(Endpoint endpoint) {
         this.endpoint = endpoint;
     }
+
+    public void init(ConfigurationContext cc) {
+        
+        if (endpoint != null) {
+            endpoint.init(cc);
+        }
+    }
 }
diff --git a/java/modules/core/src/main/java/org/apache/synapse/mediators/eip/aggregator/Aggregate.java b/java/modules/core/src/main/java/org/apache/synapse/mediators/eip/aggregator/Aggregate.java
index 45e123d69..f549cb856 100755
--- a/java/modules/core/src/main/java/org/apache/synapse/mediators/eip/aggregator/Aggregate.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/mediators/eip/aggregator/Aggregate.java
@@ -21,6 +21,7 @@ package org.apache.synapse.mediators.eip.aggregator;
 
 import org.apache.synapse.MessageContext;
 import org.apache.synapse.SynapseConstants;
+import org.apache.synapse.core.SynapseEnvironment;
 import org.apache.synapse.mediators.eip.EIPConstants;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
@@ -52,6 +53,7 @@ public class Aggregate extends TimerTask {
     private List<MessageContext> messages = new ArrayList<MessageContext>();
     private boolean locked = false;
     private boolean completed = false;
+    private SynapseEnvironment synEnv = null;
 
     /**
      * Save aggregation properties and timeout
@@ -62,9 +64,10 @@ public class Aggregate extends TimerTask {
      * @param max the maximum number of messages to be aggregated
      * @param mediator
      */
-    public Aggregate(String corelation, long timeoutMillis, int min,
+    public Aggregate(SynapseEnvironment synEnv, String corelation, long timeoutMillis, int min,
         int max, AggregateMediator mediator) {
-        
+
+        this.synEnv = synEnv;
         this.correlation = corelation;
         if (timeoutMillis > 0) {
             expiryTimeMillis = System.currentTimeMillis() + timeoutMillis;
@@ -244,12 +247,23 @@ public class Aggregate extends TimerTask {
                     log.debug("Time : " + System.currentTimeMillis() + " and this aggregator " +
                             "expired at : " + expiryTimeMillis);
                 }
-                aggregateMediator.completeAggregate(this);
+                synEnv.getExecutorService().execute(new AggregateTimeout(this));
                 break;
             }
         }
     }
 
+    private class AggregateTimeout implements Runnable {
+        private Aggregate aggregate = null;
+        AggregateTimeout(Aggregate aggregate) {
+            this.aggregate = aggregate;
+        }
+
+        public void run() {
+            aggregateMediator.completeAggregate(aggregate);
+        }
+    }
+
     public synchronized boolean getLock() {
         return !locked;
     }
diff --git a/java/modules/core/src/main/java/org/apache/synapse/mediators/eip/aggregator/AggregateMediator.java b/java/modules/core/src/main/java/org/apache/synapse/mediators/eip/aggregator/AggregateMediator.java
index 60fd0b6f4..ac05550c0 100755
--- a/java/modules/core/src/main/java/org/apache/synapse/mediators/eip/aggregator/AggregateMediator.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/mediators/eip/aggregator/AggregateMediator.java
@@ -32,6 +32,7 @@ import org.apache.synapse.mediators.base.SequenceMediator;
 import org.apache.synapse.mediators.eip.EIPConstants;
 import org.apache.synapse.mediators.eip.EIPUtils;
 import org.apache.synapse.util.xpath.SynapseXPath;
+import org.apache.axis2.context.ConfigurationContext;
 import org.jaxen.JaxenException;
 
 import java.util.Collections;
@@ -162,6 +163,7 @@ public class AggregateMediator extends AbstractMediator implements ManagedLifecy
                             }
 
                             aggregate = new Aggregate(
+                                    synCtx.getEnvironment(),
                                     correlateExpression.toString(),
                                     completionTimeoutMillis,
                                     minMessagesToComplete,
@@ -208,14 +210,19 @@ public class AggregateMediator extends AbstractMediator implements ManagedLifecy
                                 }
                         
                                 aggregate = new Aggregate(
+                                        synCtx.getEnvironment(),
                                         correlation,
                                         completionTimeoutMillis,
                                         minMessagesToComplete,
                                         maxMessagesToComplete, this);
 
                                 if (completionTimeoutMillis > 0) {
-                                    synCtx.getConfiguration().getSynapseTimer().
-                                            schedule(aggregate, completionTimeoutMillis);
+                                    synchronized(aggregate) {
+                                        if (!aggregate.isCompleted()) {
+                                            synCtx.getConfiguration().getSynapseTimer().
+                                                schedule(aggregate, completionTimeoutMillis);
+                                        }
+                                    }
                                 }
                                 aggregate.getLock();
                                 activeAggregates.put(correlation, aggregate);
@@ -292,16 +299,31 @@ public class AggregateMediator extends AbstractMediator implements ManagedLifecy
      * itself
      * @param aggregate the timed out Aggregate that holds collected messages and properties
      */
-    public synchronized void completeAggregate(Aggregate aggregate) {
+    public void completeAggregate(Aggregate aggregate) {
+
+        boolean markedCompletedNow = false;
+        boolean wasComplete = aggregate.isCompleted();
+        if (wasComplete) {
+            return;
+        }
 
         if (log.isDebugEnabled()) {
             log.debug("Aggregation completed or timed out");
         }
 
         // cancel the timer
-        aggregate.cancel();
-        aggregate.setCompleted(true);
+        synchronized(this) {
+            if (!aggregate.isCompleted()) {
+                aggregate.cancel();
+                aggregate.setCompleted(true);
+                markedCompletedNow = true;
+            }
+        }
 
+        if (!markedCompletedNow) {
+            return;
+        }
+        
         MessageContext newSynCtx = getAggregatedMessage(aggregate);
         if (newSynCtx == null) {
             log.warn("An aggregation of messages timed out with no aggregated messages", null);
@@ -430,4 +452,11 @@ public class AggregateMediator extends AbstractMediator implements ManagedLifecy
     public Map getActiveAggregates() {
         return activeAggregates;
     }
+
+    public void init(ConfigurationContext cc) {
+        
+        if (onCompleteSequence != null) {
+            onCompleteSequence.init(cc);
+        }
+    }
 }
diff --git a/java/modules/core/src/main/java/org/apache/synapse/mediators/eip/splitter/CloneMediator.java b/java/modules/core/src/main/java/org/apache/synapse/mediators/eip/splitter/CloneMediator.java
index 1f0319b56..d5f1add33 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/mediators/eip/splitter/CloneMediator.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/mediators/eip/splitter/CloneMediator.java
@@ -21,6 +21,7 @@ package org.apache.synapse.mediators.eip.splitter;
 
 import org.apache.synapse.MessageContext;
 import org.apache.synapse.ManagedLifecycle;
+import org.apache.synapse.endpoints.Endpoint;
 import org.apache.synapse.core.axis2.Axis2MessageContext;
 import org.apache.synapse.core.SynapseEnvironment;
 import org.apache.synapse.util.MessageHelper;
@@ -31,6 +32,7 @@ import org.apache.synapse.mediators.eip.EIPConstants;
 import org.apache.axis2.AxisFault;
 import org.apache.axis2.Constants;
 import org.apache.axis2.context.OperationContext;
+import org.apache.axis2.context.ConfigurationContext;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -175,4 +177,21 @@ public class CloneMediator extends AbstractMediator implements ManagedLifecycle
         }
     }
 
+    public void init(ConfigurationContext cc) {
+        
+        for (Target target : targets) {
+            
+            if (target != null) {
+                
+                Endpoint endpoint = target.getEndpoint();
+                if (endpoint != null) {
+                    endpoint.init(cc);
+                }
+                SequenceMediator seq = target.getSequence();
+                if (seq != null) {
+                    seq.init(cc);
+                }
+            }
+        }
+    }
 }
diff --git a/java/modules/core/src/main/java/org/apache/synapse/mediators/eip/splitter/IterateMediator.java b/java/modules/core/src/main/java/org/apache/synapse/mediators/eip/splitter/IterateMediator.java
index ca982a28c..1c0619a53 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/mediators/eip/splitter/IterateMediator.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/mediators/eip/splitter/IterateMediator.java
@@ -25,11 +25,14 @@ import org.apache.axiom.soap.SOAPEnvelope;
 import org.apache.axis2.AxisFault;
 import org.apache.axis2.Constants;
 import org.apache.axis2.context.OperationContext;
+import org.apache.axis2.context.ConfigurationContext;
 import org.apache.synapse.ManagedLifecycle;
 import org.apache.synapse.MessageContext;
+import org.apache.synapse.endpoints.Endpoint;
 import org.apache.synapse.core.SynapseEnvironment;
 import org.apache.synapse.core.axis2.Axis2MessageContext;
 import org.apache.synapse.mediators.AbstractMediator;
+import org.apache.synapse.mediators.base.SequenceMediator;
 import org.apache.synapse.mediators.eip.EIPConstants;
 import org.apache.synapse.mediators.eip.EIPUtils;
 import org.apache.synapse.mediators.eip.Target;
@@ -265,4 +268,18 @@ public class IterateMediator extends AbstractMediator implements ManagedLifecycl
             target.getSequence().destroy();
         }
     }
+
+    public void init(ConfigurationContext cc) {
+
+        if (target != null) {
+            Endpoint endpoint = target.getEndpoint();
+            if (endpoint != null) {
+                endpoint.init(cc);
+            }
+            SequenceMediator seq = target.getSequence();
+            if (seq != null) {
+                seq.init(cc);
+            }
+        }
+    }
 }
diff --git a/java/modules/core/src/main/java/org/apache/synapse/mediators/ext/ClassMediator.java b/java/modules/core/src/main/java/org/apache/synapse/mediators/ext/ClassMediator.java
index 0c28084d9..8f16a4baf 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/mediators/ext/ClassMediator.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/mediators/ext/ClassMediator.java
@@ -72,12 +72,14 @@ public class ClassMediator extends AbstractMediator implements ManagedLifecycle
 			traceOrDebug(traceOn, "invoking : " + mediator.getClass() + ".mediate()");
 		}
 
-        boolean result = false;
+        boolean result;
 
         try {
 			result = mediator.mediate(synCtx);
         } catch (Exception e) {
-            handleException(e.getMessage(), e, synCtx);
+            // throw Synapse Exception for any exception in class meditor
+            // so that the fault handler will be invoked
+            throw new SynapseException("Error occured in the mediation of the class mediator", e);
         }
 
         if (traceOrDebugOn) {
diff --git a/java/modules/core/src/main/java/org/apache/synapse/mediators/ext/POJOCommandMediator.java b/java/modules/core/src/main/java/org/apache/synapse/mediators/ext/POJOCommandMediator.java
index ef2f1d271..5acc8f9e6 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/mediators/ext/POJOCommandMediator.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/mediators/ext/POJOCommandMediator.java
@@ -24,7 +24,6 @@ import org.apache.axiom.om.OMElement;
 import org.apache.axiom.om.OMNode;
 import org.apache.synapse.Command;
 import org.apache.synapse.MessageContext;
-import org.apache.synapse.SynapseException;
 import org.apache.synapse.mediators.AbstractMediator;
 import org.apache.synapse.mediators.eip.EIPUtils;
 import org.apache.synapse.util.xpath.SynapseXPath;
@@ -147,7 +146,8 @@ public class POJOCommandMediator extends AbstractMediator {
             try {
                 ((Command) commandObject).execute();
             } catch (Exception e) {
-                handleException(e.getMessage(), e, synCtx);
+                handleException("Error invoking POJO command class : "
+                    + command.getClass(), e, synCtx);
             }
 
         } else {
@@ -160,7 +160,8 @@ public class POJOCommandMediator extends AbstractMediator {
                 handleException("Cannot locate an execute() method on POJO class : " +
                     command.getClass(), e, synCtx);
             } catch (Exception e) {
-                handleException(e.getMessage(), e, synCtx);
+                handleException("Error invoking the execute() method on POJO class : " +
+                    command.getClass(), e, synCtx);
             }
         }
 
diff --git a/java/modules/core/src/main/java/org/apache/synapse/mediators/filters/SwitchMediator.java b/java/modules/core/src/main/java/org/apache/synapse/mediators/filters/SwitchMediator.java
index a673ced0f..543c88bd9 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/mediators/filters/SwitchMediator.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/mediators/filters/SwitchMediator.java
@@ -24,7 +24,9 @@ import org.apache.synapse.MessageContext;
 import org.apache.synapse.config.xml.SwitchCase;
 import org.apache.synapse.core.SynapseEnvironment;
 import org.apache.synapse.mediators.AbstractMediator;
+import org.apache.synapse.mediators.ListMediator;
 import org.apache.synapse.util.xpath.SynapseXPath;
+import org.apache.axis2.context.ConfigurationContext;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -189,4 +191,22 @@ public class SwitchMediator extends AbstractMediator implements ManagedLifecycle
     public void setDefaultCase(SwitchCase defaultCase) {
         this.defaultCase = defaultCase;
     }
+
+    public void init(ConfigurationContext cc) {
+        
+        for (SwitchCase aCase : cases) {
+            initCase(aCase, cc);
+        }
+        initCase(defaultCase, cc);
+    }
+
+    private void initCase(SwitchCase aCase, ConfigurationContext cc) {
+        
+        if (aCase != null) {
+            ListMediator listMediator = aCase.getCaseMediator();
+            if (listMediator instanceof AbstractMediator) {
+                ((AbstractMediator) listMediator).init(cc);
+            }
+        }
+    }
 }
diff --git a/java/modules/core/src/main/java/org/apache/synapse/util/datasource/DataSourceFinder.java b/java/modules/core/src/main/java/org/apache/synapse/util/datasource/DataSourceFinder.java
index 0ed191c30..986db8537 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/util/datasource/DataSourceFinder.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/util/datasource/DataSourceFinder.java
@@ -54,8 +54,11 @@ public class DataSourceFinder {
             return result;
         }
 
-        registry = JNDIBasedDataSourceRegistry.getInstance(null);
-        return registry.lookUp(name);
+        registry = JNDIBasedDataSourceRegistry.getInstance();
+        if (registry.isInitialized()) {
+            return registry.lookUp(name);
+        }
+        return null;
     }
 
     /**
diff --git a/java/modules/core/src/main/java/org/apache/synapse/util/datasource/DataSourceRegistrar.java b/java/modules/core/src/main/java/org/apache/synapse/util/datasource/DataSourceRegistrar.java
index 644e22f77..2194efe32 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/util/datasource/DataSourceRegistrar.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/util/datasource/DataSourceRegistrar.java
@@ -113,10 +113,14 @@ public class DataSourceRegistrar {
             DataSourceRegistry dataSourceRegistry;
 
             if (PROP_REGISTRY_JNDI.equals(registry)) {
+
                 if (jndiEvn == null) {
                     jndiEvn = createJNDIEnvironment(dsProperties, rootPrefix);
                 }
-                dataSourceRegistry = JNDIBasedDataSourceRegistry.getInstance(jndiEvn);
+                dataSourceRegistry = JNDIBasedDataSourceRegistry.getInstance();
+                if (!dataSourceRegistry.isInitialized()) {
+                    dataSourceRegistry.init(jndiEvn);
+                }
             } else {
                 dataSourceRegistry = InMemoryDataSourceRegistry.getInstance();
             }
diff --git a/java/modules/core/src/main/java/org/apache/synapse/util/datasource/DataSourceRegistry.java b/java/modules/core/src/main/java/org/apache/synapse/util/datasource/DataSourceRegistry.java
index bda2b67f5..2249bfe84 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/util/datasource/DataSourceRegistry.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/util/datasource/DataSourceRegistry.java
@@ -19,12 +19,27 @@
 package org.apache.synapse.util.datasource;
 
 import javax.sql.DataSource;
+import java.util.Properties;
 
 /**
  * Keep all DataSources defined in the Synapse
  */
 public interface DataSourceRegistry {
 
+    /**
+     * Initialization with given properties
+     *
+     * @param properties configuration properties
+     */
+    public void init(Properties properties);
+
+    /**
+     * Explicitly check for init
+     *
+     * @return True , if has already initialized
+     */
+    public boolean isInitialized();
+
     /**
      * Register a DataSource based on given information
      * Information is encapsulated in a  DataSourceInformation instance
@@ -41,4 +56,9 @@ public interface DataSourceRegistry {
      */
     DataSource lookUp(String name);
 
+    /**
+     * Clear already registered datasources
+     */
+    public void clear();
+
 }
diff --git a/java/modules/core/src/main/java/org/apache/synapse/util/datasource/InMemoryDataSourceRegistry.java b/java/modules/core/src/main/java/org/apache/synapse/util/datasource/InMemoryDataSourceRegistry.java
index 4519def2c..1defda706 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/util/datasource/InMemoryDataSourceRegistry.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/util/datasource/InMemoryDataSourceRegistry.java
@@ -29,6 +29,7 @@ import org.apache.synapse.util.datasource.factory.DataSourceFactory;
 import javax.sql.DataSource;
 import java.util.HashMap;
 import java.util.Map;
+import java.util.Properties;
 
 /**
  * Keeps all DataSources in the memory
@@ -91,6 +92,21 @@ public class InMemoryDataSourceRegistry implements DataSourceRegistry {
         return dataSources.get(name);
     }
 
+    public void init(Properties properties) {
+        // nothing
+    }
+
+    public boolean isInitialized() {
+        return true;
+    }
+
+    public void clear() {
+        if (!dataSources.isEmpty()) {
+            log.info("Clearing all in-memory datasources ");
+            dataSources.clear();
+        }
+    }
+
     private static void handleException(String msg) {
         log.error(msg);
         throw new SynapseException(msg);
diff --git a/java/modules/core/src/main/java/org/apache/synapse/util/datasource/JNDIBasedDataSourceRegistry.java b/java/modules/core/src/main/java/org/apache/synapse/util/datasource/JNDIBasedDataSourceRegistry.java
index 1b273e648..0cc600bcf 100644
--- a/java/modules/core/src/main/java/org/apache/synapse/util/datasource/JNDIBasedDataSourceRegistry.java
+++ b/java/modules/core/src/main/java/org/apache/synapse/util/datasource/JNDIBasedDataSourceRegistry.java
@@ -42,11 +42,15 @@ public class JNDIBasedDataSourceRegistry implements DataSourceRegistry {
             new JNDIBasedDataSourceRegistry();
     private static InitialContext initialContext;
     private static final Properties indiEnv = new Properties();
-    private static boolean initialize = false;
+    private boolean initialized = false;
 
-    public static JNDIBasedDataSourceRegistry getInstance(Properties jndiEnv) {
+    public static JNDIBasedDataSourceRegistry getInstance() {
+        return ourInstance;
+    }
 
-        if (!initialize) {
+    public void init(Properties jndiEnv) {
+
+        if (!initialized) {
 
             if (jndiEnv == null) {
                 handleException("JNDI environment properties cannot be found");
@@ -57,19 +61,18 @@ public class JNDIBasedDataSourceRegistry implements DataSourceRegistry {
             try {
 
                 if (log.isDebugEnabled()) {
-                    log.debug("Initilating a Naming conext with JNDI " +
+                    log.debug("Initiating a Naming context with JNDI " +
                             "environment properties :  " + jndiEnv);
                 }
 
                 initialContext = new InitialContext(jndiEnv);
-                initialize = true;
+                initialized = true;
 
             } catch (NamingException e) {
                 handleException("Error creating a InitialConext" +
                         " with JNDI env properties : " + jndiEnv);
             }
         }
-        return ourInstance;
     }
 
     private JNDIBasedDataSourceRegistry() {
@@ -82,6 +85,8 @@ public class JNDIBasedDataSourceRegistry implements DataSourceRegistry {
      */
     public void register(DataSourceInformation information) {
 
+        validateInitialized();
+
         String dsType = information.getType();
         String driver = information.getDriver();
         String url = information.getUrl();
@@ -211,12 +216,20 @@ public class JNDIBasedDataSourceRegistry implements DataSourceRegistry {
      */
     public DataSource lookUp(String dsName) {
 
+        validateInitialized();
+
         if (log.isDebugEnabled()) {
             log.debug("Getting a DataSource with name : " + dsName + " from the JNDI tree.");
         }
         return DataSourceFinder.find(dsName, initialContext);
     }
 
+    public void clear() {
+        initialized = false;
+        initialContext = null;
+        indiEnv.clear();
+    }
+
     /**
      * Helper method to set all default parameter for naming reference of data source
      *
@@ -356,4 +369,14 @@ public class JNDIBasedDataSourceRegistry implements DataSourceRegistry {
         log.error(msg, e);
         throw new SynapseException(msg, e);
     }
+
+    private void validateInitialized() {
+        if (!isInitialized()) {
+            handleException("Datasource registry has not been initialized yet");
+        }
+    }
+
+    public boolean isInitialized() {
+        return initialized;
+    }
 }
diff --git a/java/modules/core/src/test/java/org/apache/synapse/config/xml/SendMediatorSerializationTest.java b/java/modules/core/src/test/java/org/apache/synapse/config/xml/SendMediatorSerializationTest.java
index f76bcf9d8..d30be72e8 100644
--- a/java/modules/core/src/test/java/org/apache/synapse/config/xml/SendMediatorSerializationTest.java
+++ b/java/modules/core/src/test/java/org/apache/synapse/config/xml/SendMediatorSerializationTest.java
@@ -72,12 +72,12 @@ public class SendMediatorSerializationTest extends AbstractTestCase {
         AddressEndpoint ep2 = (AddressEndpoint) send2.getEndpoint();
 
         assertEquals("Address URI is not serialized properly",
-                ep1.getEndpoint().getAddress(), ep2.getEndpoint().getAddress());
+                ep1.getDefinition().getAddress(), ep2.getDefinition().getAddress());
 
         assertEquals(
                 "Addressing information is not serialized properly",
-                ep1.getEndpoint().isAddressingOn(),
-                ep2.getEndpoint().isAddressingOn());
+                ep1.getDefinition().isAddressingOn(),
+                ep2.getDefinition().isAddressingOn());
     }
 
     public void testWSDLEndpointSerialization() {
@@ -113,8 +113,8 @@ public class SendMediatorSerializationTest extends AbstractTestCase {
 
         assertEquals(
                 "Addressing information is not serialized properly",
-                ep1.getEndpoint().isAddressingOn(),
-                ep2.getEndpoint().isAddressingOn());
+                ep1.getDefinition().isAddressingOn(),
+                ep2.getDefinition().isAddressingOn());
     }
 
     public void testSimpleLoadbalanceSendSerialization() {
@@ -151,7 +151,7 @@ public class SendMediatorSerializationTest extends AbstractTestCase {
                 send2.getEndpoint() instanceof LoadbalanceEndpoint);
 
         LoadbalanceEndpoint endpoint = (LoadbalanceEndpoint) send2.getEndpoint();
-        List addresses = endpoint.getEndpoints();
+        List addresses = endpoint.getChildren();
         assertEquals("There should be 3 leaf level address endpoints", addresses.size(), 3);
 
         assertTrue("Leaf level endpoints should be address endpoints",
@@ -163,7 +163,7 @@ public class SendMediatorSerializationTest extends AbstractTestCase {
 
         AddressEndpoint addressEndpoint = (AddressEndpoint) addresses.get(0);
         assertTrue("URI of address endpoint is not serialized properly",
-                "http://localhost:9001/services/Service1".equals(addressEndpoint.getEndpoint().getAddress()));
+                "http://localhost:9001/services/Service1".equals(addressEndpoint.getDefinition().getAddress()));
     }
 
     public void testSimpleFailoverSendSerialization() {
@@ -200,7 +200,7 @@ public class SendMediatorSerializationTest extends AbstractTestCase {
                 send2.getEndpoint() instanceof FailoverEndpoint);
 
         FailoverEndpoint endpoint = (FailoverEndpoint) send2.getEndpoint();
-        List addresses = endpoint.getEndpoints();
+        List addresses = endpoint.getChildren();
         assertEquals("There should be 3 leaf level address endpoints", addresses.size(), 3);
 
         assertTrue("Leaf level endpoints should be address endpoints",
@@ -212,7 +212,7 @@ public class SendMediatorSerializationTest extends AbstractTestCase {
 
         AddressEndpoint addressEndpoint = (AddressEndpoint) addresses.get(0);
         assertTrue("URI of address endpoint is not serialized properly",
-                "http://localhost:9001/services/Service1".equals(addressEndpoint.getEndpoint().getAddress()));
+                "http://localhost:9001/services/Service1".equals(addressEndpoint.getDefinition().getAddress()));
     }
 
     public void testNestedLoadbalanceFailoverSendSerialization() {
@@ -254,7 +254,7 @@ public class SendMediatorSerializationTest extends AbstractTestCase {
 
         LoadbalanceEndpoint loadbalanceEndpoint = (LoadbalanceEndpoint) send2.getEndpoint();
 
-        List children = loadbalanceEndpoint.getEndpoints();
+        List children = loadbalanceEndpoint.getChildren();
         assertEquals("Top level endpoint should have 2 child endpoints.", children.size(), 2);
 
         assertTrue("First child should be a address endpoint",
@@ -264,7 +264,7 @@ public class SendMediatorSerializationTest extends AbstractTestCase {
                 children.get(1) instanceof FailoverEndpoint);
 
         FailoverEndpoint failoverEndpoint = (FailoverEndpoint) children.get(1);
-        List children2 = failoverEndpoint.getEndpoints();
+        List children2 = failoverEndpoint.getChildren();
 
         assertEquals("Fail over endpoint should have 2 children.", children2.size(), 2);
         assertTrue("Children of the fail over endpoint should be address endpoints.",
diff --git a/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/Axis2HttpRequest.java b/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/Axis2HttpRequest.java
index c8568bdbc..b39f45f9f 100644
--- a/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/Axis2HttpRequest.java
+++ b/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/Axis2HttpRequest.java
@@ -61,6 +61,8 @@ public class Axis2HttpRequest {
     private EndpointReference epr = null;
     /** the HttpHost that contains the HTTP connection information */
     private HttpHost httpHost = null;
+    /** The [socket | connect] timeout */
+    private int timeout = -1;
     /** the message context being sent */
     private MessageContext msgContext = null;
     /** The Axis2 MessageFormatter that will ensure proper serialization as per Axis2 semantics */
@@ -70,7 +72,12 @@ public class Axis2HttpRequest {
     private ContentOutputBuffer outputBuffer = null;
     /** ready to begin streaming? */
     private boolean readyToStream = false;
-    /** for request complete checking */
+    /** The sending of this request has fully completed */
+    private boolean sendingCompleted = false;
+    /**
+     * for request complete checking - request complete means the request has been fully sent
+     * and the response it fully received
+     */
     private boolean completed = false;
 
     public Axis2HttpRequest(EndpointReference epr, HttpHost httpHost, MessageContext msgContext) {
@@ -111,6 +118,14 @@ public class Axis2HttpRequest {
         return msgContext;
     }
 
+    public int getTimeout() {
+        return timeout;
+    }
+
+    public void setTimeout(int timeout) {
+        this.timeout = timeout;
+    }
+
     /**
      * Create and return a new HttpPost request to the destination EPR
      * @return the HttpRequest to be sent out
@@ -257,10 +272,18 @@ public class Axis2HttpRequest {
                             "SessionRequestCallback handles this exception");
                     }
                 } else {
-                    if (e instanceof AxisFault) {
-                        throw (AxisFault) e;
+                    Integer errorCode = msgContext == null ? null :
+                        (Integer) msgContext.getProperty(NhttpConstants.ERROR_CODE);
+                    if (errorCode == null || errorCode == NhttpConstants.SEND_ABORT) {
+                        if (log.isDebugEnabled()) {
+                            log.debug("Remote server aborted request being sent, and responded");
+                        }
                     } else {
-                        handleException("Error streaming message context", e);
+                        if (e instanceof AxisFault) {
+                            throw (AxisFault) e;
+                        } else {
+                            handleException("Error streaming message context", e);
+                        }
                     }
                 }
             }
@@ -271,6 +294,7 @@ public class Axis2HttpRequest {
                 } catch (IOException e) {
                     handleException("Error closing outgoing message stream", e);
                 }
+                setSendingCompleted(true);
             }
         }
     }
@@ -291,4 +315,12 @@ public class Axis2HttpRequest {
             this.notifyAll();
         }
     }
+
+    public boolean isSendingCompleted() {
+        return sendingCompleted;
+    }
+
+    public void setSendingCompleted(boolean sendingCompleted) {
+        this.sendingCompleted = sendingCompleted;
+    }
 }
diff --git a/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/ClientHandler.java b/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/ClientHandler.java
index 36f14298a..a54f7429f 100644
--- a/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/ClientHandler.java
+++ b/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/ClientHandler.java
@@ -20,6 +20,7 @@ package org.apache.synapse.transport.nhttp;
 
 import org.apache.axiom.soap.SOAP11Constants;
 import org.apache.axiom.soap.SOAP12Constants;
+import org.apache.axiom.soap.SOAPEnvelope;
 import org.apache.axiom.soap.impl.llom.soap11.SOAP11Factory;
 import org.apache.axiom.soap.impl.llom.soap12.SOAP12Factory;
 import org.apache.axis2.AxisFault;
@@ -38,16 +39,21 @@ import org.apache.commons.logging.LogFactory;
 import org.apache.http.*;
 import org.apache.http.entity.BasicHttpEntity;
 import org.apache.http.impl.DefaultConnectionReuseStrategy;
+import org.apache.http.impl.nio.DefaultNHttpClientConnection;
 import org.apache.http.nio.ContentDecoder;
 import org.apache.http.nio.ContentEncoder;
 import org.apache.http.nio.NHttpClientConnection;
 import org.apache.http.nio.NHttpClientHandler;
+import org.apache.http.nio.util.ByteBufferAllocator;
+import org.apache.http.nio.util.HeapByteBufferAllocator;
+import org.apache.http.nio.util.ContentOutputBuffer;
+import org.apache.http.nio.util.ContentInputBuffer;
 import org.apache.http.nio.entity.ContentInputStream;
-import org.apache.http.nio.util.*;
 import org.apache.http.params.DefaultedHttpParams;
 import org.apache.http.params.HttpParams;
 import org.apache.http.protocol.*;
 import org.apache.synapse.transport.nhttp.util.SharedInputBuffer;
+import org.apache.synapse.transport.nhttp.util.SharedOutputBuffer;
 
 import java.io.IOException;
 
@@ -123,35 +129,7 @@ public class ClientHandler implements NHttpClientHandler {
      * @param axis2Req the new request
      */
     public void submitRequest(final NHttpClientConnection conn, Axis2HttpRequest axis2Req) {
-
-        try {
-            HttpContext context = conn.getContext();
-            ContentOutputBuffer outputBuffer = new SharedOutputBuffer(cfg.getBufferSize(), conn, allocator);
-            axis2Req.setOutputBuffer(outputBuffer);
-            context.setAttribute(REQUEST_SOURCE_BUFFER, outputBuffer);            
-
-            context.setAttribute(AXIS2_HTTP_REQUEST, axis2Req);
-            context.setAttribute(ExecutionContext.HTTP_CONNECTION, conn);
-            context.setAttribute(ExecutionContext.HTTP_TARGET_HOST, axis2Req.getHttpHost());
-            context.setAttribute(OUTGOING_MESSAGE_CONTEXT, axis2Req.getMsgContext());
-
-            HttpRequest request = axis2Req.getRequest();
-            request.setParams(new DefaultedHttpParams(request.getParams(), this.params));
-            this.httpProcessor.process(request, context);
-
-            conn.submitRequest(request);
-            context.setAttribute(ExecutionContext.HTTP_REQUEST, request);
-
-            synchronized(axis2Req) {
-                axis2Req.setReadyToStream(true);
-                axis2Req.notifyAll();
-            }
-
-        } catch (IOException e) {
-            handleException("I/O Error : " + e.getMessage(), e, conn);
-        } catch (HttpException e) {
-            handleException("Unexpected HTTP protocol error: " + e.getMessage(), e, conn);
-        }
+        processConnection(conn, axis2Req);
     }
 
     /**
@@ -164,10 +142,21 @@ public class ClientHandler implements NHttpClientHandler {
         if (log.isDebugEnabled() ) {
             log.debug("ClientHandler connected : " + conn);
         }
+        processConnection(conn, (Axis2HttpRequest) attachment);
+    }
+
+    /**
+     * Process a new connection over an existing TCP connection or new
+     * @param conn
+     * @param axis2Req
+     */
+    private void processConnection(final NHttpClientConnection conn, final Axis2HttpRequest axis2Req) {
 
         try {
+            // Reset connection metrics
+            conn.getMetrics().reset();
+
             HttpContext context = conn.getContext();
-            Axis2HttpRequest axis2Req = (Axis2HttpRequest) attachment;
             ContentOutputBuffer outputBuffer = new SharedOutputBuffer(cfg.getBufferSize(), conn, allocator);
             axis2Req.setOutputBuffer(outputBuffer);
             context.setAttribute(REQUEST_SOURCE_BUFFER, outputBuffer);
@@ -180,48 +169,84 @@ public class ClientHandler implements NHttpClientHandler {
             HttpRequest request = axis2Req.getRequest();
             request.setParams(new DefaultedHttpParams(request.getParams(), this.params));
             this.httpProcessor.process(request, context);
-
+            if (axis2Req.getTimeout() > 0) {
+                conn.setSocketTimeout(axis2Req.getTimeout());
+            }
+            
             conn.submitRequest(request);
             context.setAttribute(ExecutionContext.HTTP_REQUEST, request);
 
+        } catch (IOException e) {
+            if (metrics != null) {
+                metrics.incrementFaultsSending();
+            }
+            handleException("I/O Error submitting request : " + e.getMessage(), e, conn);
+        } catch (HttpException e) {
+            if (metrics != null) {
+                metrics.incrementFaultsSending();
+            }
+            handleException("HTTP protocol error submitting request : " + e.getMessage(), e, conn);
+        } finally {
             synchronized(axis2Req) {
                 axis2Req.setReadyToStream(true);
                 axis2Req.notifyAll();
-            }
-
-        } catch (IOException e) {
-            handleException("I/O Error : " + e.getMessage(), e, conn);
-        } catch (HttpException e) {
-            handleException("Unexpected HTTP protocol error: " + e.getMessage(), e, conn);
+            }            
         }
     }
 
+    /**
+     * Handle connection close events
+     * @param conn
+     */
     public void closed(final NHttpClientConnection conn) {
         ConnectionPool.forget(conn);
-        checkAxisRequestComplete(conn, "Abnormal connection close", null);
+        String message = getErrorMessage("Connection close", conn);
+        if (log.isTraceEnabled()) {
+            log.trace(message);
+        }
+        Axis2HttpRequest axis2Request = (Axis2HttpRequest)
+            conn.getContext().getAttribute(AXIS2_HTTP_REQUEST);
+
+        if (axis2Request != null && !axis2Request.isCompleted()) {
+            checkAxisRequestComplete(conn, NhttpConstants.CONNECTION_CLOSED, message, null);
+        } else {
+            if (log.isDebugEnabled()) {
+                log.debug(getErrorMessage("Keep-alive connection closed", conn));
+            }
+        }
 
         HttpContext context = conn.getContext();
+        shutdownConnection(conn);
         context.removeAttribute(RESPONSE_SINK_BUFFER);
-        context.removeAttribute(REQUEST_SOURCE_BUFFER);        
-
-        if (log.isTraceEnabled()) {
-            log.trace("Connection closed");
-        }
+        context.removeAttribute(REQUEST_SOURCE_BUFFER);
     }
 
     /**
-     * Handle connection timeouts by shutting down the connections
+     * Handle connection timeouts by shutting down the connections. These are established
+     * that have reached the SO_TIMEOUT of the socket
      * @param conn the connection being processed
      */
     public void timeout(final NHttpClientConnection conn) {
+        String message = getErrorMessage("Connection timeout", conn);
         if (log.isDebugEnabled()) {
-            log.debug("Connection Timeout");
+            log.debug(message);
         }
-        if (metrics != null) {
-            metrics.incrementTimeoutsSending();
+
+        Axis2HttpRequest axis2Request = (Axis2HttpRequest)
+            conn.getContext().getAttribute(AXIS2_HTTP_REQUEST);
+
+        if (axis2Request != null && !axis2Request.isCompleted()) {
+            checkAxisRequestComplete(conn, NhttpConstants.CONNECTION_TIMEOUT, message, null);
+        } else {
+            if (log.isDebugEnabled()) {
+                log.debug(getErrorMessage("Keep-alive connection timed out", conn));
+            }
         }
-        checkAxisRequestComplete(conn, "Connection timeout", null);
+
+        HttpContext context = conn.getContext();
         shutdownConnection(conn);
+        context.removeAttribute(RESPONSE_SINK_BUFFER);
+        context.removeAttribute(REQUEST_SOURCE_BUFFER);
     }
 
     /**
@@ -230,12 +255,10 @@ public class ClientHandler implements NHttpClientHandler {
      * @param e the exception encountered
      */
     public void exception(final NHttpClientConnection conn, final HttpException e) {
-        log.error("HTTP protocol violation : " + e.getMessage());
-    	checkAxisRequestComplete(conn, null, e);
+        String message = getErrorMessage("HTTP protocol violation : " + e.getMessage(), conn);
+        log.error(message, e);
+    	checkAxisRequestComplete(conn, NhttpConstants.PROTOCOL_VIOLATION, message, e);
         shutdownConnection(conn);
-        if (metrics != null) {
-            metrics.incrementFaultsSending();
-        }
     }
 
     /**
@@ -244,12 +267,27 @@ public class ClientHandler implements NHttpClientHandler {
      * @param e the exception encountered
      */
     public void exception(final NHttpClientConnection conn, final IOException e) {
-        log.error("I/O error : " + e.getMessage(), e);
-    	checkAxisRequestComplete(conn, null, e);
+        String message = getErrorMessage("I/O error : " + e.getMessage(), conn);
+        log.error(message, e);
+    	checkAxisRequestComplete(conn, NhttpConstants.SND_IO_ERROR_SENDING, message, e);
         shutdownConnection(conn);
-        if (metrics != null) {
-            metrics.incrementFaultsSending();
+    }
+
+    /**
+     * Include remote host and port information to an error message
+     * @param message the initial message
+     * @param conn the connection encountering the error
+     * @return the updated error message
+     */
+    private String getErrorMessage(String message, NHttpClientConnection conn) {
+        if (conn != null && conn instanceof DefaultNHttpClientConnection) {
+            DefaultNHttpClientConnection c = ((DefaultNHttpClientConnection) conn);
+            if (c.getRemoteAddress() != null) {
+                return message + " for : " + c.getRemoteAddress().getHostAddress() + ":" +
+                    c.getRemotePort();
+            }
         }
+        return message;
     }
 
     /**
@@ -257,53 +295,97 @@ public class ClientHandler implements NHttpClientHandler {
      * notify an exception to the message-receiver
      *
      * @param conn the connection being checked for completion
+     * @param errorCode the error code to raise
      * @param errorMessage the text for an error message to be returned to the MR on failure
      * @param exceptionToRaise an Exception to be returned to the MR on failure
      */
     private void checkAxisRequestComplete(NHttpClientConnection conn,
-        final String errorMessage, final Exception exceptionToRaise) {
+        final int errorCode, final String errorMessage, final Exception exceptionToRaise) {
 
         Axis2HttpRequest axis2Request = (Axis2HttpRequest)
                 conn.getContext().getAttribute(AXIS2_HTTP_REQUEST);
-
         if (axis2Request != null && !axis2Request.isCompleted()) {
+            markRequestCompletedWithError(axis2Request, errorCode, errorMessage, exceptionToRaise);
+        }
+    }
+
+    /**
+     * Mark request to send failed with error
+     *
+     * @param axis2Request the Axis2HttpRequest to be marked as completed with an error
+     * @param errorCode the error code to raise
+     * @param errorMessage the text for an error message to be returned to the MR on failure
+     * @param exceptionToRaise an Exception to be returned to the MR on failure
+     */
+    protected void markRequestCompletedWithError(Axis2HttpRequest axis2Request, final int errorCode,
+        final String errorMessage, final Exception exceptionToRaise) {
+
+        axis2Request.setCompleted(true);
+        if (errorCode == -1 && errorMessage == null && exceptionToRaise == null) {
+            return; // no need to continue
+        }
 
-            axis2Request.setCompleted(true);
-            if (errorMessage == null && exceptionToRaise == null) {
-                return; // no need to continue
+        final MessageContext mc = axis2Request.getMsgContext();
+
+        if (mc.getAxisOperation() != null &&
+                mc.getAxisOperation().getMessageReceiver() != null) {
+
+            if (metrics != null) {
+                if (metrics.getLevel() == MetricsCollector.LEVEL_FULL) {
+                    if (errorCode == NhttpConstants.CONNECTION_TIMEOUT) {
+                        metrics.incrementTimeoutsReceiving(mc);
+                    } else {
+                        metrics.incrementFaultsSending(errorCode, mc);
+                    }
+                } else {
+                    if (errorCode == NhttpConstants.CONNECTION_TIMEOUT) {
+                        metrics.incrementTimeoutsReceiving();
+                    } else {
+                        metrics.incrementFaultsSending();
+                    }
+                }
             }
 
-            final MessageContext mc = axis2Request.getMsgContext();
-
-            if (mc.getAxisOperation() != null &&
-                    mc.getAxisOperation().getMessageReceiver() != null) {
-
-                workerPool.execute( new Runnable() {
-                    public void run() {
-                        MessageReceiver mr = mc.getAxisOperation().getMessageReceiver();
-                        try {
-                            MessageContext nioFaultMessageContext = null;
-                            if (errorMessage != null) {
-                                nioFaultMessageContext = MessageContextBuilder.createFaultMessageContext(
-                                    mc, new AxisFault(errorMessage));
-                            } else if (exceptionToRaise != null) {
-                                nioFaultMessageContext = MessageContextBuilder.createFaultMessageContext(
-                                    /** this is not a mistake I do NOT want getMessage()*/
-                                    mc, new AxisFault(exceptionToRaise.toString(), exceptionToRaise));
-                            }
-
-                            if (nioFaultMessageContext != null) {
-                                nioFaultMessageContext.setProperty(
-                                        NhttpConstants.SENDING_FAULT, Boolean.TRUE);
-                                mr.receive(nioFaultMessageContext);
-                            }
-
-                        } catch (AxisFault af) {
-                            log.error("Unable to report back failure to the message receiver", af);
+            workerPool.execute( new Runnable() {
+                public void run() {
+                    MessageReceiver mr = mc.getAxisOperation().getMessageReceiver();
+                    try {
+                        AxisFault axisFault = (exceptionToRaise != null ?
+                            new AxisFault(errorMessage, exceptionToRaise) :
+                            new AxisFault(errorMessage));
+
+                        MessageContext nioFaultMessageContext =
+                            MessageContextBuilder.createFaultMessageContext(mc, axisFault);
+
+                        SOAPEnvelope envelope = nioFaultMessageContext.getEnvelope();
+
+                        nioFaultMessageContext.setProperty(
+                            NhttpConstants.SENDING_FAULT, Boolean.TRUE);
+                        nioFaultMessageContext.setProperty(
+                                NhttpConstants.ERROR_MESSAGE, errorMessage);
+                        if (errorCode != -1) {
+                            nioFaultMessageContext.setProperty(
+                                NhttpConstants.ERROR_CODE, errorCode);
+                        }
+                        if (exceptionToRaise != null) {
+                            nioFaultMessageContext.setProperty(
+                                NhttpConstants.ERROR_DETAIL, exceptionToRaise.toString());
+                            nioFaultMessageContext.setProperty(
+                                NhttpConstants.ERROR_EXCEPTION, exceptionToRaise);
+                            envelope.getBody().getFault().getDetail().setText(
+                                exceptionToRaise.toString());
+                        } else {
+                            nioFaultMessageContext.setProperty(
+                                NhttpConstants.ERROR_DETAIL, errorMessage);
+                            envelope.getBody().getFault().getDetail().setText(errorMessage);
                         }
+                        mr.receive(nioFaultMessageContext);
+
+                    } catch (AxisFault af) {
+                        log.error("Unable to report back failure to the message receiver", af);
                     }
-                });
-            }
+                }
+            });
         }
     }
 
@@ -320,13 +402,29 @@ public class ClientHandler implements NHttpClientHandler {
         try {
             int bytesRead = inBuf.consumeContent(decoder);
             if (metrics != null && bytesRead > 0) {
-                metrics.incrementBytesReceived(bytesRead);
+                if (metrics.getLevel() == MetricsCollector.LEVEL_FULL) {
+                    metrics.incrementBytesReceived(getMessageContext(conn), bytesRead);
+                } else {
+                    metrics.incrementBytesReceived(bytesRead);
+                }
             }
 
             if (decoder.isCompleted()) {
                 if (metrics != null) {
-                    metrics.incrementMessagesReceived();
+                    if (metrics.getLevel() == MetricsCollector.LEVEL_FULL) {
+                        MessageContext mc = getMessageContext(conn);
+                        metrics.incrementMessagesReceived(mc);
+                        metrics.notifyReceivedMessageSize(mc, conn.getMetrics().getReceivedBytesCount());
+                        metrics.notifySentMessageSize(mc, conn.getMetrics().getSentBytesCount());
+                        metrics.reportResponseCode(mc, response.getStatusLine().getStatusCode());
+                    } else {
+                        metrics.incrementMessagesReceived();
+                        metrics.notifyReceivedMessageSize(conn.getMetrics().getReceivedBytesCount());
+                        metrics.notifySentMessageSize(conn.getMetrics().getSentBytesCount());
+                    }
                 }
+                // reset metrics on connection
+                conn.getMetrics().reset();
                 if (!connStrategy.keepAlive(response, context)) {
                     conn.close();
                 } else {
@@ -335,7 +433,15 @@ public class ClientHandler implements NHttpClientHandler {
             }
 
         } catch (IOException e) {
-            handleException("I/O Error : " + e.getMessage(), e, conn);
+            if (metrics != null) {
+                if (metrics.getLevel() == MetricsCollector.LEVEL_FULL) {
+                    metrics.incrementFaultsReceiving(
+                        NhttpConstants.SND_IO_ERROR_RECEIVING, getMessageContext(conn));
+                } else {
+                    metrics.incrementFaultsReceiving();
+                }
+            }
+            handleException("I/O Error at inputReady : " + e.getMessage(), e, conn);
         }
     }
 
@@ -348,21 +454,28 @@ public class ClientHandler implements NHttpClientHandler {
         HttpContext context = conn.getContext();
 
         ContentOutputBuffer outBuf = (ContentOutputBuffer) context.getAttribute(REQUEST_SOURCE_BUFFER);
+        if (outBuf == null) return;
 
         try {
             int bytesWritten = outBuf.produceContent(encoder);
             if (metrics != null && bytesWritten > 0) {
-                metrics.incrementBytesSent(bytesWritten);
-            }
-
-            if (encoder.isCompleted()) {
-                if (metrics != null) {
-                    metrics.incrementMessagesSent();
+                if (metrics.getLevel() == MetricsCollector.LEVEL_FULL) {
+                    metrics.incrementBytesSent(getMessageContext(conn), bytesWritten);
+                } else {
+                    metrics.incrementBytesSent(bytesWritten);
                 }
             }
 
         } catch (IOException e) {
-            handleException("I/O Error : " + e.getMessage(), e, conn);
+            if (metrics != null) {
+                if (metrics.getLevel() == MetricsCollector.LEVEL_FULL) {
+                    metrics.incrementFaultsSending(
+                        NhttpConstants.SND_IO_ERROR_SENDING, getMessageContext(conn));
+                } else {
+                    metrics.incrementFaultsSending();
+                }
+            }
+            handleException("I/O Error at outputReady : " + e.getMessage(), e, conn);
         }
     }
 
@@ -375,11 +488,26 @@ public class ClientHandler implements NHttpClientHandler {
         HttpContext context = conn.getContext();
         HttpResponse response = conn.getHttpResponse();
 
-        /*
-         * responsed received means the whole request has been complete sent to server or
-         * server doesn't need the left data of request
-         */
-    	checkAxisRequestComplete(conn, null, null);
+        // Have we sent out our request fully in the first place? if not, forget about it now..
+        Axis2HttpRequest req = (Axis2HttpRequest) conn.getContext().getAttribute(AXIS2_HTTP_REQUEST);
+        if (req != null && !req.isSendingCompleted()) {
+            req.getMsgContext().setProperty(NhttpConstants.ERROR_CODE, NhttpConstants.SEND_ABORT);
+            req.setCompleted(true);                                              
+            SharedOutputBuffer outputBuffer = (SharedOutputBuffer)
+                conn.getContext().getAttribute(REQUEST_SOURCE_BUFFER);
+            if (outputBuffer != null) {
+                outputBuffer.shutdown();
+            }
+            log.warn("Remote server aborted request being sent and replied : " + conn);
+            if (metrics != null) {
+                metrics.incrementFaultsSending(NhttpConstants.SEND_ABORT, req.getMsgContext());
+            }
+        }
+
+        if (req != null) {
+            req.setCompleted(true);
+        }
+
         switch (response.getStatusLine().getStatusCode()) {
             case HttpStatus.SC_ACCEPTED : {
                 if (log.isDebugEnabled()) {
@@ -571,7 +699,17 @@ public class ClientHandler implements NHttpClientHandler {
      * Shutdown the connection ignoring any IO errors during the process
      * @param conn the connection to be shutdown
      */
-    private void shutdownConnection(final HttpConnection conn) {
+    private void shutdownConnection(final NHttpClientConnection conn) {
+        SharedOutputBuffer outputBuffer = (SharedOutputBuffer)
+            conn.getContext().getAttribute(REQUEST_SOURCE_BUFFER);
+        if (outputBuffer != null) {
+            outputBuffer.close();
+        }
+        SharedInputBuffer inputBuffer = (SharedInputBuffer)
+            conn.getContext().getAttribute(RESPONSE_SINK_BUFFER);
+        if (inputBuffer != null) {
+            inputBuffer.close();
+        }
         try {
             conn.shutdown();
         } catch (IOException ignore) {}
@@ -598,4 +736,19 @@ public class ClientHandler implements NHttpClientHandler {
     public int getQueueSize() {
         return workerPool.getQueueSize();
     }
+        
+    public void stop() {
+        try {
+            workerPool.shutdown(1000);
+        } catch (InterruptedException ignore) {}
+    }
+
+    private MessageContext getMessageContext(final NHttpClientConnection conn) {
+        HttpContext context = conn.getContext();
+        Axis2HttpRequest axis2Req = (Axis2HttpRequest) context.getAttribute(AXIS2_HTTP_REQUEST);
+        if (axis2Req != null) {
+            return axis2Req.getMsgContext();
+        }
+        return null;
+    }
 }
\ No newline at end of file
diff --git a/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/ClientWorker.java b/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/ClientWorker.java
index 08df53e4e..8e1b9d174 100644
--- a/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/ClientWorker.java
+++ b/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/ClientWorker.java
@@ -172,14 +172,19 @@ public class ClientWorker implements Runnable {
                         contentType);
             } catch (OMException e) {
                 // handle non SOAP and POX/REST payloads (probably text/html)
-                log.warn("Unexpected response received : " + e.getMessage());
+                String errorMessage = "Unexpected response received. HTTP response code : "
+                    + this.response.getStatusLine().getStatusCode() + " HTTP status : "
+                    + this.response.getStatusLine().getReasonPhrase() + " exception : "
+                    + e.getMessage();
+
+                log.warn(errorMessage, e);
                 SOAPFactory factory = new SOAP11Factory();
                 envelope = factory.getDefaultFaultEnvelope();
                 SOAPFaultDetail detail = factory.createSOAPFaultDetail();
-                detail.setText("Unexpected response received : " + e.getMessage());
+                detail.setText(errorMessage);
                 envelope.getBody().getFault().setDetail(detail);
                 SOAPFaultReason reason = factory.createSOAPFaultReason();
-                reason.setText(this.response.getStatusLine().getReasonPhrase());
+                reason.setText(errorMessage);
                 envelope.getBody().getFault().setReason(reason);
                 SOAPFaultCode code = factory.createSOAPFaultCode();
                 code.setText(Integer.toString(this.response.getStatusLine().getStatusCode()));
diff --git a/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/ConnectionPool.java b/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/ConnectionPool.java
index c700aa525..428ab26ae 100644
--- a/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/ConnectionPool.java
+++ b/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/ConnectionPool.java
@@ -121,6 +121,8 @@ public class ConnectionPool {
         ctx.removeAttribute(ExecutionContext.HTTP_REQUEST);
         ctx.removeAttribute(ExecutionContext.HTTP_RESPONSE);
         ctx.removeAttribute(ExecutionContext.HTTP_CONNECTION);
+
+        conn.resetOutput();
     }
 
     public static void forget(NHttpClientConnection conn) {
diff --git a/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/HttpCoreNIOListener.java b/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/HttpCoreNIOListener.java
index aa6a7d0d1..d373a5b86 100644
--- a/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/HttpCoreNIOListener.java
+++ b/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/HttpCoreNIOListener.java
@@ -42,6 +42,7 @@ import org.apache.http.params.HttpConnectionParams;
 import org.apache.http.params.HttpParams;
 import org.apache.http.params.HttpProtocolParams;
 import org.apache.axiom.om.OMElement;
+import org.apache.axis2.transport.base.threads.NativeThreadFactory;
 
 import javax.net.ssl.SSLContext;
 import java.io.IOException;
@@ -237,8 +238,10 @@ public class HttpCoreNIOListener implements TransportListener, ManagementSupport
         // configure the IO reactor on the specified port
         HttpParams params = getServerParameters();
         try {
+            String prefix = (sslContext == null ? "http" : "https") + "-Listener I/O dispatcher";
             ioReactor = new DefaultListeningIOReactor(
-                NHttpConfiguration.getInstance().getServerIOWorkers(), params);
+                NHttpConfiguration.getInstance().getServerIOWorkers(),                
+                new NativeThreadFactory(new ThreadGroup(prefix + " thread group"), prefix), params);
 
             ioReactor.setExceptionHandler(new IOReactorExceptionHandler() {
                 public boolean handle(IOException ioException) {
@@ -331,9 +334,10 @@ public class HttpCoreNIOListener implements TransportListener, ManagementSupport
      * @throws AxisFault on error
      */
     public void stop() throws AxisFault {
-        if (state != BaseConstants.STARTED) return;
+        if (state == BaseConstants.STOPPED) return;
         try {
             ioReactor.shutdown();
+            handler.stop();
             state = BaseConstants.STOPPED;
             for (Object obj : cfgCtx.getAxisConfiguration().getServices().values()) {
                 removeServiceFfromURIMap((AxisService) obj);
@@ -577,4 +581,87 @@ public class HttpCoreNIOListener implements TransportListener, ManagementSupport
         }
         return -1;
     }
+
+    public long getTimeoutsReceiving() {
+        if (metrics != null) {
+            return metrics.getTimeoutsReceiving();
+        }
+        return -1;
+    }
+
+    public long getTimeoutsSending() {
+        if (metrics != null) {
+            return metrics.getTimeoutsSending();
+        }
+        return -1;
+    }
+
+    public long getMinSizeReceived() {
+        if (metrics != null) {
+            return metrics.getMinSizeReceived();
+        }
+        return -1;
+    }
+
+    public long getMaxSizeReceived() {
+        if (metrics != null) {
+            return metrics.getMaxSizeReceived();
+        }
+        return -1;
+    }
+
+    public double getAvgSizeReceived() {
+        if (metrics != null) {
+            return metrics.getAvgSizeReceived();
+        }
+        return -1;
+    }
+
+    public long getMinSizeSent() {
+        if (metrics != null) {
+            return metrics.getMinSizeSent();
+        }
+        return -1;
+    }
+
+    public long getMaxSizeSent() {
+        if (metrics != null) {
+            return metrics.getMaxSizeSent();
+        }
+        return -1;
+    }
+
+    public double getAvgSizeSent() {
+        if (metrics != null) {
+            return metrics.getAvgSizeSent();
+        }
+        return -1;
+    }
+
+    public Map getResponseCodeTable() {
+        if (metrics != null) {
+            return metrics.getResponseCodeTable();
+        }
+        return null;
+    }
+
+    public void resetStatistics() {
+        if (metrics != null) {
+            metrics.reset();
+        }
+    }
+
+    public long getLastResetTime() {
+        if (metrics != null) {
+            return metrics.getLastResetTime();
+        }
+        return -1;
+    }
+
+    public long getMetricsWindow() {
+        if (metrics != null) {
+            return System.currentTimeMillis() - metrics.getLastResetTime();
+        }
+        return -1;
+    }
 }
diff --git a/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/HttpCoreNIOSender.java b/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/HttpCoreNIOSender.java
index 8675bc19d..d320c46e4 100644
--- a/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/HttpCoreNIOSender.java
+++ b/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/HttpCoreNIOSender.java
@@ -27,7 +27,6 @@ import org.apache.axis2.addressing.EndpointReference;
 import org.apache.axis2.context.ConfigurationContext;
 import org.apache.axis2.context.MessageContext;
 import org.apache.axis2.description.TransportOutDescription;
-import org.apache.axis2.engine.MessageReceiver;
 import org.apache.axis2.handlers.AbstractHandler;
 import org.apache.axis2.transport.MessageFormatter;
 import org.apache.axis2.transport.OutTransportInfo;
@@ -36,12 +35,9 @@ import org.apache.axis2.transport.base.BaseConstants;
 import org.apache.axis2.transport.base.ManagementSupport;
 import org.apache.axis2.transport.base.MetricsCollector;
 import org.apache.axis2.transport.base.TransportMBeanSupport;
-import org.apache.axis2.util.MessageContextBuilder;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
-import org.apache.http.HttpHost;
-import org.apache.http.HttpResponse;
-import org.apache.http.HttpStatus;
+import org.apache.http.*;
 import org.apache.http.impl.nio.reactor.DefaultConnectingIOReactor;
 import org.apache.http.impl.nio.reactor.SSLIOSessionHandler;
 import org.apache.http.nio.NHttpClientConnection;
@@ -55,6 +51,7 @@ import org.apache.http.params.HttpConnectionParams;
 import org.apache.http.params.HttpParams;
 import org.apache.http.params.HttpProtocolParams;
 import org.apache.http.protocol.HTTP;
+import org.apache.axis2.transport.base.threads.NativeThreadFactory;
 import org.apache.synapse.transport.nhttp.util.MessageFormatterDecoratorFactory;
 
 import javax.net.ssl.SSLContext;
@@ -108,8 +105,10 @@ public class HttpCoreNIOSender extends AbstractHandler implements TransportSende
 
         HttpParams params = getClientParameters();
         try {
+            String prefix = (sslContext == null ? "http" : "https") + "-Sender I/O dispatcher";
             ioReactor = new DefaultConnectingIOReactor(
-                NHttpConfiguration.getInstance().getClientIOWorkers(), params);
+                NHttpConfiguration.getInstance().getClientIOWorkers(),
+                new NativeThreadFactory(new ThreadGroup(prefix + " thread group"), prefix), params);
             ioReactor.setExceptionHandler(new IOReactorExceptionHandler() {
                 public boolean handle(IOException ioException) {
                     log.warn("System may be unstable: IOReactor encountered a checked exception : " +
@@ -305,6 +304,10 @@ public class HttpCoreNIOSender extends AbstractHandler implements TransportSende
             HttpHost httpHost = new HttpHost(url.getHost(), port, url.getProtocol());
 
             Axis2HttpRequest axis2Req = new Axis2HttpRequest(epr, httpHost, msgContext);
+            Object timeout = msgContext.getProperty(NhttpConstants.SEND_TIMEOUT);
+            if (timeout != null && timeout instanceof Long) {
+                axis2Req.setTimeout( (int) ((Long) timeout).longValue());
+            }
 
             NHttpClientConnection conn = ConnectionPool.getConnection(url.getHost(), port);
 
@@ -315,18 +318,28 @@ public class HttpCoreNIOSender extends AbstractHandler implements TransportSende
                     log.debug("A new connection established to : " + url.getHost() + ":" + port);
                 }
             } else {
-                ((ClientHandler) handler).submitRequest(conn, axis2Req);
+                handler.submitRequest(conn, axis2Req);
                 if (log.isDebugEnabled()) {
                     log.debug("An existing connection reused to : " + url.getHost() + ":" + port);
                 }
             }
 
-            axis2Req.streamMessageContents();
+            try {
+                axis2Req.streamMessageContents();
+                if (metrics != null) {
+                    if (metrics.getLevel() == MetricsCollector.LEVEL_FULL) {
+                        metrics.incrementMessagesSent(msgContext);
+                    } else {
+                        metrics.incrementMessagesSent();
+                    }
+                }
+
+            } catch (AxisFault af) {
+                throw af;
+            }
 
         } catch (MalformedURLException e) {
             handleException("Malformed destination EPR : " + epr.getAddress(), e);
-        } catch (IOException e) {
-            handleException("IO Error while submiting request message for sending", e);
         }
     }
 
@@ -384,10 +397,13 @@ public class HttpCoreNIOSender extends AbstractHandler implements TransportSende
                 }
             }
         }
-        worker.getServiceHandler().commitResponse(worker.getConn(), response);
 
-        OutputStream out = worker.getOutputStream();
+        MetricsCollector lstMetrics = worker.getServiceHandler().getMetrics();
         try {
+            worker.getServiceHandler().commitResponse(worker.getConn(), response);
+            lstMetrics.reportResponseCode(response.getStatusLine().getStatusCode());
+            OutputStream out = worker.getOutputStream();
+
             if (msgContext.isPropertyTrue(NhttpConstants.SC_ACCEPTED)) {
                 // see comment above on the reasoning
                 out.write(new byte[0]);
@@ -395,13 +411,40 @@ public class HttpCoreNIOSender extends AbstractHandler implements TransportSende
                 messageFormatter.writeTo(msgContext, format, out, false);
             }
             out.close();
+            if (lstMetrics != null) {
+                lstMetrics.incrementMessagesSent();
+            }
+
+        } catch (HttpException e) {
+            if (lstMetrics != null) {
+                lstMetrics.incrementFaultsSending();
+            }
+            handleException("Unexpected HTTP protocol error : " + e.getMessage(), e);
+        } catch (ConnectionClosedException e) {
+            if (lstMetrics != null) {
+                lstMetrics.incrementFaultsSending();
+            }
+            log.warn("Connection closed by client (Connection closed)");
+        } catch (IllegalStateException e) {
+            if (lstMetrics != null) {
+                lstMetrics.incrementFaultsSending();
+            }
+            log.warn("Connection closed by client (Buffer closed)");
         } catch (IOException e) {
+            if (lstMetrics != null) {
+                lstMetrics.incrementFaultsSending();
+            }
             handleException("IO Error sending response message", e);
+        } catch (Exception e) {
+            if (lstMetrics != null) {
+                lstMetrics.incrementFaultsSending();
+            }
+            handleException("General Error sending response message", e);
         }
 
         try {
             worker.getIs().close();
-        } catch (IOException ignore) {}        
+        } catch (IOException ignore) {}
     }
 
     private void sendUsingOutputStream(MessageContext msgContext) throws AxisFault {
@@ -437,9 +480,10 @@ public class HttpCoreNIOSender extends AbstractHandler implements TransportSende
     }
 
     public void stop() {
-        if (state != BaseConstants.STARTED) return;
+        if (state == BaseConstants.STOPPED) return;
         try {
             ioReactor.shutdown();
+            handler.stop();
             state = BaseConstants.STOPPED;
         } catch (IOException e) {
             log.warn("Error shutting down IOReactor", e);
@@ -461,62 +505,29 @@ public class HttpCoreNIOSender extends AbstractHandler implements TransportSende
             }
 
             public void failed(SessionRequest request) {
-                handleError(request, false);
+                handleError(request, NhttpConstants.CONNECTION_FAILED,
+                    "Connection refused or failed for : " + request.getRemoteAddress());
             }
 
             public void timeout(SessionRequest request) {
-                handleError(request, true);
+                handleError(request, NhttpConstants.CONNECT_TIMEOUT,
+                    "Timeout connecting to : " + request.getRemoteAddress());
                 request.cancel();
             }
 
-            public void cancelled(SessionRequest sessionRequest) {
-
+            public void cancelled(SessionRequest request) {
+                handleError(request, NhttpConstants.CONNECT_CANCEL,
+                    "Connection cancelled for : " + request.getRemoteAddress());
             }
 
-            private void handleError(SessionRequest request, boolean isTimeout) {
+            private void handleError(SessionRequest request, int errorCode, String errorMessage) {
                 if (request.getAttachment() != null &&
                     request.getAttachment() instanceof Axis2HttpRequest) {
 
                     Axis2HttpRequest axis2Request = (Axis2HttpRequest) request.getAttachment();
                     if (!axis2Request.isCompleted()) {
-
-                        axis2Request.setCompleted(true);
-                        MessageContext mc = axis2Request.getMsgContext();
-                        final MessageReceiver mr = mc.getAxisOperation().getMessageReceiver();
-
-                        if (mr != null) {
-                            try {
-                                // this fault is NOT caused by the endpoint while processing. so we have to
-                                // inform that this is a sending error (e.g. endpoint failure) and handle it
-                                // differently at the message receiver.
-
-                                AxisFault axisFault;
-                                if (isTimeout) {
-                                    // In case of a timeout there is no exception
-                                    axisFault = new AxisFault("The connection timed out");
-                                } else {
-                                    Exception exception = request.getException();
-                                    /** this is not a mistake I do NOT want getMessage()*/
-                                    axisFault = new AxisFault(exception.toString(), exception);
-                                }
-                                final MessageContext nioFaultMessageContext =
-                                    MessageContextBuilder.createFaultMessageContext(mc, axisFault);
-                                nioFaultMessageContext.setProperty(NhttpConstants.SENDING_FAULT, Boolean.TRUE);
-
-                                handler.execute(new Runnable() {
-                                    public void run() {
-                                        try {
-                                            mr.receive(nioFaultMessageContext);
-                                        } catch (AxisFault af) {
-                                            log.error("Error processing fault message context", af);
-                                        }
-                                    }
-                                });
-
-                            } catch (AxisFault af) {
-                                log.error("Unable to report back failure to the message receiver", af);
-                            }
-                        }
+                        handler.markRequestCompletedWithError(
+                            axis2Request, errorCode,  errorMessage,  null);
                     }
                 }
             }
@@ -616,4 +627,87 @@ public class HttpCoreNIOSender extends AbstractHandler implements TransportSende
         }
         return -1;
     }
+
+    public long getTimeoutsReceiving() {
+        if (metrics != null) {
+            return metrics.getTimeoutsReceiving();
+        }
+        return -1;
+    }
+
+    public long getTimeoutsSending() {
+        if (metrics != null) {
+            return metrics.getTimeoutsSending();
+        }
+        return -1;
+    }
+
+    public long getMinSizeReceived() {
+        if (metrics != null) {
+            return metrics.getMinSizeReceived();
+        }
+        return -1;
+    }
+
+    public long getMaxSizeReceived() {
+        if (metrics != null) {
+            return metrics.getMaxSizeReceived();
+        }
+        return -1;
+    }
+
+    public double getAvgSizeReceived() {
+        if (metrics != null) {
+            return metrics.getAvgSizeReceived();
+        }
+        return -1;
+    }
+
+    public long getMinSizeSent() {
+        if (metrics != null) {
+            return metrics.getMinSizeSent();
+        }
+        return -1;
+    }
+
+    public long getMaxSizeSent() {
+        if (metrics != null) {
+            return metrics.getMaxSizeSent();
+        }
+        return -1;
+    }
+
+    public double getAvgSizeSent() {
+        if (metrics != null) {
+            return metrics.getAvgSizeSent();
+        }
+        return -1;
+    }
+
+    public Map getResponseCodeTable() {
+        if (metrics != null) {
+            return metrics.getResponseCodeTable();
+        }
+        return null;
+    }
+
+    public void resetStatistics() {
+        if (metrics != null) {
+            metrics.reset();
+        }
+    }
+
+    public long getLastResetTime() {
+        if (metrics != null) {
+            return metrics.getLastResetTime();
+        }
+        return -1;
+    }
+
+    public long getMetricsWindow() {
+        if (metrics != null) {
+            return System.currentTimeMillis() - metrics.getLastResetTime();
+        }
+        return -1;
+    }
 }
diff --git a/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/NhttpConstants.java b/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/NhttpConstants.java
index e4cf3278d..f1ded90d1 100644
--- a/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/NhttpConstants.java
+++ b/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/NhttpConstants.java
@@ -22,7 +22,6 @@ package org.apache.synapse.transport.nhttp;
 public class NhttpConstants {
     public static final String SC_ACCEPTED = "SC_ACCEPTED";
     public static final String HTTP_SC = "HTTP_SC";
-    public static final String SENDING_FAULT = "sending_fault";
     public static final String FORCE_HTTP_1_0 = "FORCE_HTTP_1.0";
     public static final String POST_TO_PATH = "POST_TO_PATH";
     public static final String IGNORE_SC_ACCEPTED = "IGNORE_SC_ACCEPTED";
@@ -35,4 +34,34 @@ public class NhttpConstants {
     public static final String EPR_TO_SERVICE_NAME_MAP = "service.epr.map";
     public static final String NON_BLOCKING_TRANSPORT = "NonBlockingTransport";
     public static final String SERIALIZED_BYTES = "SerializedBytes";
+    public static final String REQUEST_READ = "REQUEST_READ";
+
+    public static final String SEND_TIMEOUT = "SEND_TIMEOUT";
+
+    /** An Axis2 message context property indicating a transport send failure */
+    public static final String SENDING_FAULT = "SENDING_FAULT";
+    /** The message context property name which holds the error code for the last encountered exception */
+    public static final String ERROR_CODE = "ERROR_CODE";
+    /** The MC property name which holds the error message for the last encountered exception */
+    public static final String ERROR_MESSAGE = "ERROR_MESSAGE";
+    /** The message context property name which holds the error detail (stack trace) for the last encountered exception */
+    public static final String ERROR_DETAIL = "ERROR_DETAIL";
+    /** The message context property name which holds the exception (if any) for the last encountered exception */
+    public static final String ERROR_EXCEPTION = "ERROR_EXCEPTION";
+
+    // ********** DO NOT CHANGE THESE UNLESS CORRESPONDING SYNAPSE CONSTANT ARE CHANGED ************
+    public static final int RCV_IO_ERROR_SENDING   = 101000;
+    public static final int RCV_IO_ERROR_RECEIVING = 101001;
+
+    public static final int SND_IO_ERROR_SENDING   = 101500;
+    public static final int SND_IO_ERROR_RECEIVING = 101501;
+
+    public static final int CONNECTION_FAILED  = 101503;
+    public static final int CONNECTION_TIMEOUT = 101504;
+    public static final int CONNECTION_CLOSED  = 101505;
+    public static final int PROTOCOL_VIOLATION = 101506;
+    public static final int CONNECT_CANCEL     = 101507;
+    public static final int CONNECT_TIMEOUT    = 101508;
+    public static final int SEND_ABORT         = 101509;
+    // ********** DO NOT CHANGE THESE UNLESS CORRESPONDING SYNAPSE CONSTANT ARE CHANGED ************
 }
diff --git a/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/ServerHandler.java b/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/ServerHandler.java
index e33fc6615..0c42a538a 100644
--- a/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/ServerHandler.java
+++ b/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/ServerHandler.java
@@ -23,6 +23,7 @@ import org.apache.axis2.transport.base.MetricsCollector;
 import org.apache.axis2.transport.base.threads.WorkerPoolFactory;
 import org.apache.axis2.transport.base.threads.WorkerPool;
 import org.apache.synapse.transport.nhttp.util.SharedInputBuffer;
+import org.apache.synapse.transport.nhttp.util.SharedOutputBuffer;
 import org.apache.http.*;
 import org.apache.http.entity.BasicHttpEntity;
 import org.apache.http.entity.ByteArrayEntity;
@@ -32,10 +33,12 @@ import org.apache.http.nio.ContentDecoder;
 import org.apache.http.nio.ContentEncoder;
 import org.apache.http.nio.NHttpServerConnection;
 import org.apache.http.nio.NHttpServiceHandler;
-import org.apache.http.nio.reactor.IOSession;
+import org.apache.http.nio.util.ByteBufferAllocator;
+import org.apache.http.nio.util.HeapByteBufferAllocator;
+import org.apache.http.nio.util.ContentOutputBuffer;
+import org.apache.http.nio.util.ContentInputBuffer;
 import org.apache.http.nio.entity.ContentInputStream;
 import org.apache.http.nio.entity.ContentOutputStream;
-import org.apache.http.nio.util.*;
 import org.apache.http.params.HttpParams;
 import org.apache.http.protocol.*;
 import org.apache.http.util.EncodingUtils;
@@ -110,6 +113,9 @@ public class ServerHandler implements NHttpServiceHandler {
         HttpRequest request = conn.getHttpRequest();
         context.setAttribute(ExecutionContext.HTTP_REQUEST, request);
 
+        // Mark request as not yet fully read, to detect timeouts from harmless keepalive deaths
+        conn.getContext().setAttribute(NhttpConstants.REQUEST_READ, Boolean.FALSE);
+
         try {
             ContentInputBuffer inputBuffer = new SharedInputBuffer(cfg.getBufferSize(), conn, allocator);
             ContentOutputBuffer outputBuffer = new SharedOutputBuffer(cfg.getBufferSize(), conn, allocator);
@@ -136,6 +142,9 @@ public class ServerHandler implements NHttpServiceHandler {
                     response, new ContentOutputStream(outputBuffer)));
 
         } catch (Exception e) {
+            if (metrics != null) {
+                metrics.incrementFaultsReceiving();
+            }
             handleException("Error processing request received for : " +
                 request.getRequestLine().getUri(), e, conn);
         }
@@ -161,10 +170,16 @@ public class ServerHandler implements NHttpServiceHandler {
                 if (metrics != null) {
                     metrics.incrementMessagesReceived();
                 }
+                // remove the request we have fully read, to detect harmless keepalive timeouts from
+                // real timeouts while reading requests
+                context.setAttribute(NhttpConstants.REQUEST_READ, Boolean.TRUE);
             }
 
         } catch (IOException e) {
-            handleException("I/O Error : " + e.getMessage(), e, conn);
+            if (metrics != null) {
+                metrics.incrementFaultsReceiving();
+            }
+            handleException("I/O Error at inputReady : " + e.getMessage(), e, conn);
         }
     }
 
@@ -186,9 +201,6 @@ public class ServerHandler implements NHttpServiceHandler {
             }
 
             if (encoder.isCompleted()) {
-                if (metrics != null) {
-                    metrics.incrementMessagesSent();
-                }
                 if (!connStrategy.keepAlive(response, context)) {
                     conn.close();
                 } else {
@@ -197,17 +209,21 @@ public class ServerHandler implements NHttpServiceHandler {
             }
 
         } catch (IOException e) {
-            handleException("I/O Error : " + e.getMessage(), e, conn);
+            if (metrics != null) {
+                metrics.incrementFaultsSending();
+            }
+            handleException("I/O Error at outputReady : " + e.getMessage(), e, conn);
         }
     }
 
     /**
      * Commit the response to the connection. Processes the response through the configured
-     * HttpProcessor and submits it to be sent out
+     * HttpProcessor and submits it to be sent out. This method hides any exceptions and is targetted
+     * for non critical (i.e. browser requests etc) requests, which are not core messages
      * @param conn the connection being processed
      * @param response the response to commit over the connection
      */
-    public void commitResponse(final NHttpServerConnection conn, final HttpResponse response) {
+    public void commitResponseHideExceptions(final NHttpServerConnection conn, final HttpResponse response) {
         try {
             httpProcessor.process(response, conn.getContext());
             conn.submitResponse(response);
@@ -218,24 +234,45 @@ public class ServerHandler implements NHttpServiceHandler {
         }
     }
 
+    /**
+     * Commit the response to the connection. Processes the response through the configured
+     * HttpProcessor and submits it to be sent out. Re-Throws exceptions, after closing connections
+     * @param conn the connection being processed
+     * @param response the response to commit over the connection
+     * @throws IOException
+     * @throws HttpException
+     */
+    public void commitResponse(final NHttpServerConnection conn,
+        final HttpResponse response) throws IOException, HttpException {
+        try {
+            httpProcessor.process(response, conn.getContext());
+            conn.submitResponse(response);
+        } catch (HttpException e) {
+            shutdownConnection(conn);
+            throw e;
+        } catch (IOException e) {
+            shutdownConnection(conn);
+            throw e;
+        }
+    }
 
     /**
      * Handle connection timeouts by shutting down the connections
      * @param conn the connection being processed
      */
     public void timeout(final NHttpServerConnection conn) {
-        HttpRequest req = (HttpRequest) conn.getContext().getAttribute(
-                ExecutionContext.HTTP_REQUEST);
-        if (req != null) {
+        HttpContext context = conn.getContext();
+        Boolean read = (Boolean) context.getAttribute(NhttpConstants.REQUEST_READ);
+
+        if (read != null && read) {
             if (log.isDebugEnabled()) {
-                log.debug("Connection Timeout for request to : " + req.getRequestLine().getUri() +
-                        " Probably the keepalive connection was closed");
+                log.debug("Keepalive connection was closed");
             }
         } else {
-            log.warn("Connection Timeout");
+            log.error("Connection Timeout - before message body was fully read : " + conn);
             if (metrics != null) {
                 metrics.incrementTimeoutsReceiving();
-            }            
+            }
         }
         shutdownConnection(conn);
     }
@@ -247,6 +284,11 @@ public class ServerHandler implements NHttpServiceHandler {
     }
 
     public void responseReady(NHttpServerConnection conn) {
+
+        metrics.notifyReceivedMessageSize(conn.getMetrics().getReceivedBytesCount());
+        metrics.notifySentMessageSize(conn.getMetrics().getSentBytesCount());
+        conn.getMetrics().reset();
+
         if (log.isTraceEnabled()) {
             log.trace("Ready to send response");
         }
@@ -255,6 +297,7 @@ public class ServerHandler implements NHttpServiceHandler {
     public void closed(final NHttpServerConnection conn) {
 
         HttpContext context = conn.getContext();
+        shutdownConnection(conn);
         context.removeAttribute(REQUEST_SINK_BUFFER);
         context.removeAttribute(RESPONSE_SOURCE_BUFFER);
 
@@ -269,9 +312,16 @@ public class ServerHandler implements NHttpServiceHandler {
      * @param e the exception encountered
      */
     public void exception(final NHttpServerConnection conn, final HttpException e) {
+        if (metrics != null) {
+            metrics.incrementFaultsReceiving();
+        }
+
         HttpContext context = conn.getContext();
         HttpRequest request = conn.getHttpRequest();
-        ProtocolVersion ver = request.getRequestLine().getProtocolVersion();
+        ProtocolVersion ver = HttpVersion.HTTP_1_0;
+        if (request != null && request.getRequestLine() != null) {
+            ver = request.getRequestLine().getProtocolVersion();
+        }
         HttpResponse response = responseFactory.newHttpResponse(
             ver, HttpStatus.SC_BAD_REQUEST, context);
 
@@ -279,11 +329,9 @@ public class ServerHandler implements NHttpServiceHandler {
         ByteArrayEntity entity = new ByteArrayEntity(msg);
         entity.setContentType("text/plain; charset=US-ASCII");
         response.setEntity(entity);
-        commitResponse(conn, response);
-
-        if (metrics != null) {
-            metrics.incrementFaultsReceiving();
-        }        
+        try {
+            commitResponseHideExceptions(conn, response);
+        } catch (Exception ignore) {}        
     }
 
     /**
@@ -300,7 +348,7 @@ public class ServerHandler implements NHttpServiceHandler {
                         "was closed):" + e.getMessage());
             }
         } else {
-            log.error("I/O error: " + e.getMessage());
+            log.error("I/O error: " + e.getMessage(), e);
             if (metrics != null) {
                 metrics.incrementFaultsReceiving();
             }
@@ -321,7 +369,17 @@ public class ServerHandler implements NHttpServiceHandler {
      * Shutdown the connection ignoring any IO errors during the process
      * @param conn the connection to be shutdown
      */
-    private void shutdownConnection(final HttpConnection conn) {
+    private void shutdownConnection(final NHttpServerConnection conn) {
+        SharedOutputBuffer outputBuffer = (SharedOutputBuffer)
+            conn.getContext().getAttribute(RESPONSE_SOURCE_BUFFER);
+        if (outputBuffer != null) {
+            outputBuffer.close();
+        }
+        SharedInputBuffer inputBuffer = (SharedInputBuffer)
+            conn.getContext().getAttribute(REQUEST_SINK_BUFFER);
+        if (inputBuffer != null) {
+            inputBuffer.close();
+        }
         try {
             conn.shutdown();
         } catch (IOException ignore) {}
@@ -347,4 +405,14 @@ public class ServerHandler implements NHttpServiceHandler {
     public int getQueueSize() {
         return workerPool.getQueueSize();
     }
+
+    public MetricsCollector getMetrics() {
+        return metrics;
+    }
+
+    public void stop() {
+        try {
+            workerPool.shutdown(1000);
+        } catch (InterruptedException ignore) {}
+    }
 }
diff --git a/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/ServerWorker.java b/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/ServerWorker.java
index 877fd5518..42f226450 100644
--- a/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/ServerWorker.java
+++ b/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/ServerWorker.java
@@ -44,6 +44,7 @@ import org.apache.ws.commons.schema.XmlSchema;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.io.ByteArrayOutputStream;
 import java.net.InetAddress;
 import java.net.NetworkInterface;
 import java.net.SocketException;
@@ -218,7 +219,39 @@ public class ServerWorker implements Runnable {
                 }
 
                 response.setStatusCode(HttpStatus.SC_ACCEPTED);
-                serverHandler.commitResponse(conn, response);
+                if (metrics != null) {
+                    metrics.incrementMessagesSent();
+                }
+
+                try {
+                    serverHandler.commitResponse(conn, response);
+
+                } catch (HttpException e) {
+                    if (metrics != null) {
+                        metrics.incrementFaultsSending();
+                    }
+                    handleException("Unexpected HTTP protocol error : " + e.getMessage(), e);
+                } catch (ConnectionClosedException e) {
+                    if (metrics != null) {
+                        metrics.incrementFaultsSending();
+                    }
+                    log.warn("Connection closed by client (Connection closed)");
+                } catch (IllegalStateException e) {
+                    if (metrics != null) {
+                        metrics.incrementFaultsSending();
+                    }
+                    log.warn("Connection closed by client (Buffer closed)");
+                } catch (IOException e) {
+                    if (metrics != null) {
+                        metrics.incrementFaultsSending();
+                    }
+                    handleException("IO Error sending response message", e);
+                } catch (Exception e) {
+                    if (metrics != null) {
+                        metrics.incrementFaultsSending();
+                    }
+                    handleException("General Error sending response message", e);
+                }
 
                 try {
                     is.close();
@@ -311,27 +344,27 @@ public class ServerWorker implements Runnable {
         if (uri.equals("/favicon.ico")) {
             response.setStatusCode(HttpStatus.SC_MOVED_PERMANENTLY);
             response.addHeader(LOCATION, "http://ws.apache.org/favicon.ico");
-            serverHandler.commitResponse(conn,  response);
+            serverHandler.commitResponseHideExceptions(conn,  response);
 
         } else if (!uri.startsWith(servicePath)) {
             response.setStatusCode(HttpStatus.SC_MOVED_PERMANENTLY);
             response.addHeader(LOCATION, servicePath + "/");
-            serverHandler.commitResponse(conn, response);
+            serverHandler.commitResponseHideExceptions(conn, response);
 
         } else if (serviceName != null && parameters.containsKey("wsdl")) {
             AxisService service = (AxisService) cfgCtx.getAxisConfiguration().
                 getServices().get(serviceName);
             if (service != null) {
                 try {
+                    ByteArrayOutputStream baos = new ByteArrayOutputStream();
+                    service.printWSDL(baos, getIpAddress());
                     response.addHeader(CONTENT_TYPE, TEXT_XML);
-                    serverHandler.commitResponse(conn, response);
-                    service.printWSDL(os, getIpAddress());
+                    serverHandler.commitResponseHideExceptions(conn, response);
+                    os.write(baos.toByteArray());
 
-                } catch (AxisFault e) {
-                    handleException("Axis2 fault writing ?wsdl output", e);
-                    return;
-                } catch (SocketException e) {
-                    handleException("Error getting ip address for ?wsdl output", e);
+                } catch (Exception e) {
+                    handleBrowserException(
+                        "Error generating ?wsdl output for service : " + serviceName, e);
                     return;
                 }
             }
@@ -341,14 +374,15 @@ public class ServerWorker implements Runnable {
                 getServices().get(serviceName);
             if (service != null) {
                 try {
+                    ByteArrayOutputStream baos = new ByteArrayOutputStream();
+                    service.printWSDL2(baos, getIpAddress());
                     response.addHeader(CONTENT_TYPE, TEXT_XML);
-                    serverHandler.commitResponse(conn, response);
-                    service.printWSDL2(os, getIpAddress());
-                } catch (AxisFault e) {
-                    handleException("Axis2 fault writing ?wsdl2 output", e);
-                    return;
-                } catch (SocketException e) {
-                    handleException("Error getting ip address for ?wsdl2 output", e);
+                    serverHandler.commitResponseHideExceptions(conn, response);
+                    os.write(baos.toByteArray());
+
+                } catch (Exception e) {
+                    handleBrowserException(
+                        "Error generating ?wsdl2 output for service : " + serviceName, e);
                     return;
                 }
             }
@@ -359,12 +393,15 @@ public class ServerWorker implements Runnable {
                     .getServices().get(serviceName);
                 if (service != null) {
                     try {
+                        ByteArrayOutputStream baos = new ByteArrayOutputStream();
+                        service.printSchema(baos);
                         response.addHeader(CONTENT_TYPE, TEXT_XML);
-                        serverHandler.commitResponse(conn, response);
-                        service.printSchema(os);
+                        serverHandler.commitResponseHideExceptions(conn, response);
+                        os.write(baos.toByteArray());
 
-                    } catch (AxisFault axisFault) {
-                        handleException("Error writing ?xsd output to client", axisFault);
+                    } catch (Exception e) {
+                        handleBrowserException(
+                            "Error generating ?xsd output for service : " + serviceName, e);
                         return;
                     }
                 }
@@ -390,9 +427,17 @@ public class ServerWorker implements Runnable {
                     }
                     //schema found - write it to the stream
                     if (schema != null) {
-                        response.addHeader(CONTENT_TYPE, TEXT_XML);
-                        serverHandler.commitResponse(conn, response);
-                        schema.write(os);
+                        try {
+                            ByteArrayOutputStream baos = new ByteArrayOutputStream();
+                            schema.write(baos);
+                            response.addHeader(CONTENT_TYPE, TEXT_XML);
+                            serverHandler.commitResponseHideExceptions(conn, response);
+                            os.write(baos.toByteArray());
+                        } catch (Exception e) {
+                            handleBrowserException(
+                                "Error generating named ?xsd output for service : " + serviceName, e);
+                            return;
+                        }
 
                     } else {
                         // no schema available by that name  - send 404
@@ -407,28 +452,31 @@ public class ServerWorker implements Runnable {
                     getServices().get(serviceName);
             if (service != null) {
                 try {
+                    byte[] bytes =
+                        HTTPTransportReceiver.printServiceHTML(serviceName, cfgCtx).getBytes();
                     response.addHeader(CONTENT_TYPE, TEXT_HTML);
-                    serverHandler.commitResponse(conn, response);
-                    os.write(HTTPTransportReceiver.printServiceHTML(
-                            serviceName, cfgCtx).getBytes());
+                    serverHandler.commitResponseHideExceptions(conn, response);
+                    os.write(bytes);
 
                 } catch (IOException e) {
-                    handleException("Error writing service HTML to client", e);
+                    handleBrowserException(
+                        "Error generating service details page for : " + serviceName, e);
                     return;
                 }
             } else {
-                handleException("Invalid service : " + serviceName, null);
+                handleBrowserException("Invalid service : " + serviceName, null);
                 return;
             }
         } else if (serviceName == null || serviceName.length() == 0) {
 
             try {
+                byte[] bytes = getServicesHTML().getBytes();
                 response.addHeader(CONTENT_TYPE, TEXT_HTML);
-                serverHandler.commitResponse(conn, response);
-                os.write(getServicesHTML().getBytes());
+                serverHandler.commitResponseHideExceptions(conn, response);
+                os.write(bytes);
 
             } catch (IOException e) {
-                handleException("Error writing ? output to client", e);
+                handleBrowserException("Error generating services list", e);
             }
 
         } else {
@@ -454,6 +502,31 @@ public class ServerWorker implements Runnable {
         } catch (IOException ignore) {}
     }
 
+    private void handleBrowserException(String msg, Exception e) {
+
+        if (e == null) {
+            log.error(msg);
+        } else {
+            log.error(msg, e);
+        }
+
+        if (!response.containsHeader(HTTP.TRANSFER_ENCODING)) {
+            response.setStatusCode(HttpStatus.SC_INTERNAL_SERVER_ERROR);
+            response.setReasonPhrase(msg);
+            response.addHeader(CONTENT_TYPE, TEXT_HTML);
+            serverHandler.commitResponseHideExceptions(conn, response);
+            try {
+                os.write(msg.getBytes());
+                os.close();
+            } catch (IOException ignore) {}
+        }
+
+        if (conn != null) {
+            try {
+                conn.shutdown();
+            } catch (IOException ignore) {}
+        }
+    }
 
     private void handleException(String msg, Exception e) {
         
@@ -475,7 +548,7 @@ public class ServerWorker implements Runnable {
         } catch (Exception ex) {
             response.setStatusCode(HttpStatus.SC_INTERNAL_SERVER_ERROR);
             response.addHeader(CONTENT_TYPE, TEXT_XML);
-            serverHandler.commitResponse(conn, response);
+            serverHandler.commitResponseHideExceptions(conn, response);
 
             try {
                 os.write(msg.getBytes());
diff --git a/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/util/SharedInputBuffer.java b/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/util/SharedInputBuffer.java
index 6f3863bf0..a59a088e0 100644
--- a/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/util/SharedInputBuffer.java
+++ b/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/util/SharedInputBuffer.java
@@ -114,6 +114,16 @@ public class SharedInputBuffer extends ExpandableBuffer implements ContentInputB
         }
     }
 
+    public void close() {
+        if (this.shutdown) {
+            return;
+        }
+        this.endOfStream = true;
+        synchronized (this.mutex) {
+            this.mutex.notifyAll();
+        }
+    }
+
     public void shutdown() {
         if (this.shutdown) {
             return;
diff --git a/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/util/SharedOutputBuffer.java b/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/util/SharedOutputBuffer.java
new file mode 100755
index 000000000..29613229b
--- /dev/null
+++ b/java/modules/transports/src/main/java/org/apache/synapse/transport/nhttp/util/SharedOutputBuffer.java
@@ -0,0 +1,188 @@
+/*
+ *  Licensed to the Apache Software Foundation (ASF) under one
+ *  or more contributor license agreements.  See the NOTICE file
+ *  distributed with this work for additional information
+ *  regarding copyright ownership.  The ASF licenses this file
+ *  to you under the Apache License, Version 2.0 (the
+ *  "License"); you may not use this file except in compliance
+ *  with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing,
+ *  software distributed under the License is distributed on an
+ *   * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ *  KIND, either express or implied.  See the License for the
+ *  specific language governing permissions and limitations
+ *  under the License.
+ */
+
+package org.apache.synapse.transport.nhttp.util;
+
+import org.apache.http.nio.util.ExpandableBuffer;
+import org.apache.http.nio.util.ByteBufferAllocator;
+import org.apache.http.nio.util.ContentOutputBuffer;
+import org.apache.http.nio.IOControl;
+import org.apache.http.nio.ContentEncoder;
+
+import java.io.IOException;
+import java.io.InterruptedIOException;
+
+/**
+ * A copy of the SharedOutputBuffer implementation of Apache HttpComponents - HttpCore/NIO
+ * found at http://svn.apache.org/repos/asf/httpcomponents/httpcore/trunk/module-nio/
+ *  src/main/java/org/apache/http/nio/util/SharedOutputBuffer.java
+ *
+ * To include the fix described here : https://issues.apache.org/jira/browse/HTTPCORE-172
+ * with the HttpCore version 4.0-beta1
+ *
+ * TODO : This class to be removed as soon as we update the HttpCore dependency from 4.0-beta1
+ */
+public class SharedOutputBuffer extends ExpandableBuffer implements ContentOutputBuffer {
+
+    private final IOControl ioctrl;
+    private final Object mutex;
+
+    private volatile boolean shutdown = false;
+    private volatile boolean endOfStream;
+
+    public SharedOutputBuffer(int buffersize, final IOControl ioctrl, final ByteBufferAllocator allocator) {
+        super(buffersize, allocator);
+        if (ioctrl == null) {
+            throw new IllegalArgumentException("I/O content control may not be null");
+        }
+        this.ioctrl = ioctrl;
+        this.mutex = new Object();
+        this.endOfStream = false;
+    }
+
+    public void reset() {
+        if (this.shutdown) {
+            return;
+        }
+        synchronized (this.mutex) {
+            clear();
+            this.endOfStream = false;
+        }
+    }
+
+    public int produceContent(final ContentEncoder encoder) throws IOException {
+        if (this.shutdown) {
+            return -1;
+        }
+        synchronized (this.mutex) {
+            setOutputMode();
+            int bytesWritten = 0;
+            if (hasData()) {
+                bytesWritten = encoder.write(this.buffer);
+                if (encoder.isCompleted()) {
+                    this.endOfStream = true;
+                }
+            }
+            if (!hasData()) {
+                // No more buffered content
+                // If at the end of the stream, terminate
+                if (this.endOfStream && !encoder.isCompleted()) {
+                    encoder.complete();
+                }
+                if (!this.endOfStream) {
+                    // suspend output events
+                    this.ioctrl.suspendOutput();
+                }
+            }
+            this.mutex.notifyAll();
+            return bytesWritten;
+        }
+    }
+
+    public void close() {
+        if (this.shutdown) {
+            return;
+        }
+        writeCompleted();
+    }
+
+    public void shutdown() {
+        if (this.shutdown) {
+            return;
+        }
+        this.shutdown = true;
+        synchronized (this.mutex) {
+            this.mutex.notifyAll();
+        }
+    }
+
+    public void write(final byte[] b, int off, int len) throws IOException {
+        if (b == null) {
+            return;
+        }
+        synchronized (this.mutex) {
+            if (this.shutdown || this.endOfStream) {
+                throw new IllegalStateException("Buffer already closed for writing");
+            }
+            setInputMode();
+            int remaining = len;
+            while (remaining > 0) {
+                if (!this.buffer.hasRemaining()) {
+                    flushContent();
+                    setInputMode();
+                }
+                int chunk = Math.min(remaining, this.buffer.remaining());
+                this.buffer.put(b, off, chunk);
+                remaining -= chunk;
+                off += chunk;
+            }
+        }
+    }
+
+    public void write(final byte[] b) throws IOException {
+        if (b == null) {
+            return;
+        }
+        write(b, 0, b.length);
+    }
+
+    public void write(int b) throws IOException {
+        synchronized (this.mutex) {
+            if (this.shutdown || this.endOfStream) {
+                throw new IllegalStateException("Buffer already closed for writing");
+            }
+            setInputMode();
+            if (!this.buffer.hasRemaining()) {
+                flushContent();
+                setInputMode();
+            }
+            this.buffer.put((byte) b);
+        }
+    }
+
+    public void flush() throws IOException {
+    }
+
+    private void flushContent() throws IOException {
+        synchronized (this.mutex) {
+            try {
+                while (hasData()) {
+                    if (this.shutdown) {
+                        throw new InterruptedIOException("Output operation aborted");
+                    }
+                    this.ioctrl.requestOutput();
+                    this.mutex.wait();
+                }
+            } catch (InterruptedException ex) {
+                throw new IOException("Interrupted while flushing the content buffer");
+            }
+        }
+    }
+
+    public void writeCompleted() {
+        synchronized (this.mutex) {
+            if (this.endOfStream) {
+                return;
+            }
+            this.endOfStream = true;
+            this.ioctrl.requestOutput();
+        }
+    }
+
+}
