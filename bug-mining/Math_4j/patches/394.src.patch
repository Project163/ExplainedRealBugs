diff --git a/src/changes/changes.xml b/src/changes/changes.xml
index 0029df427..6cfa04775 100644
--- a/src/changes/changes.xml
+++ b/src/changes/changes.xml
@@ -55,10 +55,13 @@ This is a minor release: It combines bug fixes and new features.
   Changes to existing features were made in a backwards-compatible
   way such as to allow drop-in replacement of the v3.1[.1] JAR file.
 ">
+      <action dev="luc" type="fix" issue="MATH-947" >
+        Fixed infinite loop when NaN occurs in singular value decomposition.
+      </action>
       <action dev="luc" type="add" issue="MATH-460" due-to="Andrew Waterman">
         Added the LÃ©vy distribution.
       </action>
-        <action dev="luc" type="update"  >
+      <action dev="luc" type="update"  >
         Normal distribution now uses a direct implementation of the
         inverse error function to compute inverse cumulative probability
         instead of relying on a numerical solver. This is much faster,
diff --git a/src/main/java/org/apache/commons/math3/linear/SingularValueDecomposition.java b/src/main/java/org/apache/commons/math3/linear/SingularValueDecomposition.java
index ba2ed14c3..efbe8a215 100644
--- a/src/main/java/org/apache/commons/math3/linear/SingularValueDecomposition.java
+++ b/src/main/java/org/apache/commons/math3/linear/SingularValueDecomposition.java
@@ -285,10 +285,18 @@ public class SingularValueDecomposition {
                 final double threshold
                     = TINY + EPS * (FastMath.abs(singularValues[k]) +
                                     FastMath.abs(singularValues[k + 1]));
-                if (FastMath.abs(e[k]) <= threshold) {
+
+                // the following condition is written this way in order
+                // to break out of the loop when NaN occurs, writing it
+                // as "if (FastMath.abs(e[k]) <= threshold)" would loop
+                // indefinitely in case of NaNs because comparison on NaNs
+                // always return false, regardless of what is checked
+                // see issue MATH-947
+                if (!(FastMath.abs(e[k]) > threshold)) {
                     e[k] = 0;
                     break;
                 }
+
             }
 
             if (k == p - 2) {
diff --git a/src/test/java/org/apache/commons/math3/linear/SingularValueDecompositionTest.java b/src/test/java/org/apache/commons/math3/linear/SingularValueDecompositionTest.java
index 5d3d4ea19..40c33a7d0 100644
--- a/src/test/java/org/apache/commons/math3/linear/SingularValueDecompositionTest.java
+++ b/src/test/java/org/apache/commons/math3/linear/SingularValueDecompositionTest.java
@@ -316,4 +316,16 @@ public class SingularValueDecompositionTest {
         return u.multiply(d).multiply(v);
     }
 
+    @Test
+    public void testIssue947() {
+        double[][] nans = new double[][] {
+            { Double.NaN, Double.NaN },
+            { Double.NaN, Double.NaN }
+        };
+        RealMatrix m = new Array2DRowRealMatrix(nans, false);
+        SingularValueDecomposition svd = new SingularValueDecomposition(m);
+        Assert.assertTrue(Double.isNaN(svd.getSingularValues()[0]));
+        Assert.assertTrue(Double.isNaN(svd.getSingularValues()[1]));
+    }
+
 }
