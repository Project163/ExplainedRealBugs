diff --git a/src/main/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizer.java b/src/main/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizer.java
index 5c86efc60..72fe8577c 100644
--- a/src/main/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizer.java
+++ b/src/main/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizer.java
@@ -24,6 +24,8 @@ import org.apache.commons.math.analysis.solvers.UnivariateRealSolver;
 import org.apache.commons.math.exception.util.LocalizedFormats;
 import org.apache.commons.math.optimization.GoalType;
 import org.apache.commons.math.optimization.RealPointValuePair;
+import org.apache.commons.math.optimization.SimpleScalarValueChecker;
+import org.apache.commons.math.optimization.ConvergenceChecker;
 import org.apache.commons.math.util.FastMath;
 
 /**
@@ -43,47 +45,82 @@ public class NonLinearConjugateGradientOptimizer
     /** Update formula for the beta parameter. */
     private final ConjugateGradientFormula updateFormula;
     /** Preconditioner (may be null). */
-    private Preconditioner preconditioner;
+    private final Preconditioner preconditioner;
     /** solver to use in the line search (may be null). */
-    private UnivariateRealSolver solver;
+    private final UnivariateRealSolver solver;
     /** Initial step used to bracket the optimum in line search. */
     private double initialStep;
     /** Current point. */
     private double[] point;
 
     /**
-     * Simple constructor with default settings.
-     * The convergence check is set to a {@link
-     * org.apache.commons.math.optimization.SimpleVectorialValueChecker}.
+     * Constructor with default {@link SimpleScalarValueChecker checker},
+     * {@link BrentSolver line search solver} and
+     * {@link IdentityPreconditioner preconditioner}.
      *
      * @param updateFormula formula to use for updating the &beta; parameter,
      * must be one of {@link ConjugateGradientFormula#FLETCHER_REEVES} or {@link
-     * ConjugateGradientFormula#POLAK_RIBIERE}
+     * ConjugateGradientFormula#POLAK_RIBIERE}.
      */
     public NonLinearConjugateGradientOptimizer(final ConjugateGradientFormula updateFormula) {
-        this.updateFormula = updateFormula;
-        preconditioner     = null;
-        solver             = null;
-        initialStep        = 1.0;
+        this(updateFormula,
+             new SimpleScalarValueChecker());
     }
 
     /**
-     * Set the preconditioner.
-     * @param preconditioner preconditioner to use for next optimization,
-     * may be null to remove an already registered preconditioner
+     * Constructor with default {@link BrentSolver line search solver} and
+     * {@link IdentityPreconditioner preconditioner}.
+     *
+     * @param updateFormula formula to use for updating the &beta; parameter,
+     * must be one of {@link ConjugateGradientFormula#FLETCHER_REEVES} or {@link
+     * ConjugateGradientFormula#POLAK_RIBIERE}.
+     * @param checker Convergence checker.
      */
-    public void setPreconditioner(final Preconditioner preconditioner) {
-        this.preconditioner = preconditioner;
+    public NonLinearConjugateGradientOptimizer(final ConjugateGradientFormula updateFormula,
+                                               ConvergenceChecker<RealPointValuePair> checker) {
+        this(updateFormula,
+             checker,
+             new BrentSolver(),
+             new IdentityPreconditioner());
+    }
+
+
+    /**
+     * Constructor with default {@link IdentityPreconditioner preconditioner}.
+     *
+     * @param updateFormula formula to use for updating the &beta; parameter,
+     * must be one of {@link ConjugateGradientFormula#FLETCHER_REEVES} or {@link
+     * ConjugateGradientFormula#POLAK_RIBIERE}.
+     * @param checker Convergence checker.
+     * @param lineSearchSolver Solver to use during line search.
+     */
+    public NonLinearConjugateGradientOptimizer(final ConjugateGradientFormula updateFormula,
+                                               ConvergenceChecker<RealPointValuePair> checker,
+                                               final UnivariateRealSolver lineSearchSolver) {
+        this(updateFormula,
+             checker,
+             lineSearchSolver,
+             new IdentityPreconditioner());
     }
 
     /**
-     * Set the solver to use during line search.
-     * @param lineSearchSolver solver to use during line search, may be null
-     * to remove an already registered solver and fall back to the
-     * default {@link BrentSolver Brent solver}.
+     * @param updateFormula formula to use for updating the &beta; parameter,
+     * must be one of {@link ConjugateGradientFormula#FLETCHER_REEVES} or {@link
+     * ConjugateGradientFormula#POLAK_RIBIERE}.
+     * @param checker Convergence checker.
+     * @param lineSearchSolver Solver to use during line search.
+     * @param preconditioner Preconditioner.
      */
-    public void setLineSearchSolver(final UnivariateRealSolver lineSearchSolver) {
+    public NonLinearConjugateGradientOptimizer(final ConjugateGradientFormula updateFormula,
+                                               ConvergenceChecker<RealPointValuePair> checker,
+                                               final UnivariateRealSolver lineSearchSolver,
+                                               final Preconditioner preconditioner) {
+        super(checker);
+
+        this.updateFormula = updateFormula;
         solver = lineSearchSolver;
+        this.preconditioner = preconditioner;
+        initialStep = 1.0;
     }
 
     /**
@@ -107,13 +144,7 @@ public class NonLinearConjugateGradientOptimizer
     /** {@inheritDoc} */
     @Override
     protected RealPointValuePair doOptimize() {
-        // Initialization.
-        if (preconditioner == null) {
-            preconditioner = new IdentityPreconditioner();
-        }
-        if (solver == null) {
-            solver = new BrentSolver();
-        }
+        final ConvergenceChecker checker = getConvergenceChecker();
         point = getStartPoint();
         final GoalType goal = getGoalType();
         final int n = point.length;
@@ -143,7 +174,7 @@ public class NonLinearConjugateGradientOptimizer
             RealPointValuePair previous = current;
             current = new RealPointValuePair(point, objective);
             if (previous != null) {
-                if (getConvergenceChecker().converged(iter, previous, current)) {
+                if (checker.converged(iter, previous, current)) {
                     // We have found an optimum.
                     return current;
                 }
@@ -230,7 +261,7 @@ public class NonLinearConjugateGradientOptimizer
     }
 
     /** Default identity preconditioner. */
-    private static class IdentityPreconditioner implements Preconditioner {
+    public static class IdentityPreconditioner implements Preconditioner {
 
         /** {@inheritDoc} */
         public double[] precondition(double[] variables, double[] r) {
diff --git a/src/test/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizerTest.java b/src/test/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizerTest.java
index 95c04a3a8..0e286ef54 100644
--- a/src/test/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizerTest.java
+++ b/src/test/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizerTest.java
@@ -100,8 +100,8 @@ public class NonLinearConjugateGradientOptimizerTest {
         LinearProblem problem =
             new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });
         NonLinearConjugateGradientOptimizer optimizer =
-            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);
-        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));
+            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,
+                                                    new SimpleScalarValueChecker(1e-6, 1e-6));
         RealPointValuePair optimum =
             optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 0 });
         Assert.assertEquals(1.5, optimum.getPoint()[0], 1.0e-10);
@@ -115,8 +115,8 @@ public class NonLinearConjugateGradientOptimizerTest {
                               new double[] { 4.0, 6.0, 1.0 });
 
         NonLinearConjugateGradientOptimizer optimizer =
-            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);
-        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));
+            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,
+                                                    new SimpleScalarValueChecker(1e-6, 1e-6));
         RealPointValuePair optimum =
             optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 0, 0 });
         Assert.assertEquals(7.0, optimum.getPoint()[0], 1.0e-10);
@@ -136,8 +136,8 @@ public class NonLinearConjugateGradientOptimizerTest {
                 { 0, 0, 0, 0, 0, 2 }
         }, new double[] { 0.0, 1.1, 2.2, 3.3, 4.4, 5.5 });
         NonLinearConjugateGradientOptimizer optimizer =
-            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);
-        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));
+            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,
+                                                    new SimpleScalarValueChecker(1e-6, 1e-6));
         RealPointValuePair optimum =
             optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 0, 0, 0, 0, 0, 0 });
         for (int i = 0; i < problem.target.length; ++i) {
@@ -153,8 +153,8 @@ public class NonLinearConjugateGradientOptimizerTest {
                 {  0, -1, 1 }
         }, new double[] { 1, 1, 1});
         NonLinearConjugateGradientOptimizer optimizer =
-            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);
-        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));
+            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,
+                                                    new SimpleScalarValueChecker(1e-6, 1e-6));
         RealPointValuePair optimum =
             optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 0, 0, 0 });
         Assert.assertEquals(1.0, optimum.getPoint()[0], 1.0e-10);
@@ -175,22 +175,26 @@ public class NonLinearConjugateGradientOptimizerTest {
                 {  0,  0,   0,  0,       1, 1 }
         }, new double[] { 2, -9, 2, 2, 1 + epsilon * epsilon, 2});
 
-        NonLinearConjugateGradientOptimizer optimizer =
-            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);
-        optimizer.setPreconditioner(new Preconditioner() {
-            public double[] precondition(double[] point, double[] r) {
-                double[] d = r.clone();
-                d[0] /=  72.0;
-                d[1] /=  30.0;
-                d[2] /= 314.0;
-                d[3] /= 260.0;
-                d[4] /= 2 * (1 + epsilon * epsilon);
-                d[5] /= 4.0;
-                return d;
-            }
-        });
-        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-13, 1.0e-13));
+        final Preconditioner preconditioner
+            = new Preconditioner() {
+                    public double[] precondition(double[] point, double[] r) {
+                        double[] d = r.clone();
+                        d[0] /=  72.0;
+                        d[1] /=  30.0;
+                        d[2] /= 314.0;
+                        d[3] /= 260.0;
+                        d[4] /= 2 * (1 + epsilon * epsilon);
+                        d[5] /= 4.0;
+                        return d;
+                    }
+                };
 
+        NonLinearConjugateGradientOptimizer optimizer =
+            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,
+                                                    new SimpleScalarValueChecker(1e-13, 1e-13),
+                                                    new BrentSolver(),
+                                                    preconditioner);
+                                                    
         RealPointValuePair optimum =
             optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 0, 0, 0, 0, 0, 0 });
         Assert.assertEquals( 3.0, optimum.getPoint()[0], 1.0e-10);
@@ -210,8 +214,8 @@ public class NonLinearConjugateGradientOptimizerTest {
                 { -3, 0, -9 }
         }, new double[] { 1, 1, 1 });
         NonLinearConjugateGradientOptimizer optimizer =
-            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);
-        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));
+            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,
+                                                    new SimpleScalarValueChecker(1e-6, 1e-6));
         RealPointValuePair optimum =
                 optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 0, 0, 0 });
         Assert.assertTrue(optimum.getValue() > 0.5);
@@ -226,10 +230,9 @@ public class NonLinearConjugateGradientOptimizerTest {
                 {  7.0, 5.0,  9.0, 10.0 }
         }, new double[] { 32, 23, 33, 31 });
         NonLinearConjugateGradientOptimizer optimizer =
-            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);
-        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-13, 1.0e-13));
-        BrentSolver solver = new BrentSolver(1e-15, 1e-15);
-        optimizer.setLineSearchSolver(solver);
+            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,
+                                                    new SimpleScalarValueChecker(1e-13, 1e-13),
+                                                    new BrentSolver(1e-15, 1e-15));
         RealPointValuePair optimum1 =
             optimizer.optimize(200, problem1, GoalType.MINIMIZE, new double[] { 0, 1, 2, 3 });
         Assert.assertEquals(1.0, optimum1.getPoint()[0], 1.0e-4);
@@ -261,8 +264,8 @@ public class NonLinearConjugateGradientOptimizerTest {
         }, new double[] { 7.0, 3.0, 5.0 });
 
         NonLinearConjugateGradientOptimizer optimizer =
-            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);
-        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));
+            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,
+                                                    new SimpleScalarValueChecker(1e-6, 1e-6));
         RealPointValuePair optimum =
             optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 7, 6, 5, 4 });
         Assert.assertEquals(0, optimum.getValue(), 1.0e-10);
@@ -279,8 +282,8 @@ public class NonLinearConjugateGradientOptimizerTest {
                  { 0.0, 0.0,  0.0, -1.0, 1.0,  0.0 }
         }, new double[] { 3.0, 12.0, -1.0, 7.0, 1.0 });
         NonLinearConjugateGradientOptimizer optimizer =
-            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);
-        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));
+            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,
+                                                    new SimpleScalarValueChecker(1e-6, 1e-6));
         RealPointValuePair optimum =
             optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 2, 2, 2, 2, 2, 2 });
         Assert.assertEquals(0, optimum.getValue(), 1.0e-10);
@@ -295,8 +298,8 @@ public class NonLinearConjugateGradientOptimizerTest {
         }, new double[] { 3.0, 1.0, 5.0 });
 
         NonLinearConjugateGradientOptimizer optimizer =
-            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);
-        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));
+            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,
+                                                    new SimpleScalarValueChecker(1e-6, 1e-6));
         RealPointValuePair optimum =
             optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 1, 1 });
         Assert.assertEquals(2.0, optimum.getPoint()[0], 1.0e-8);
@@ -313,8 +316,8 @@ public class NonLinearConjugateGradientOptimizerTest {
         }, new double[] { 3.0, 1.0, 4.0 });
 
         NonLinearConjugateGradientOptimizer optimizer =
-            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);
-        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-6, 1.0e-6));
+            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,
+                                                    new SimpleScalarValueChecker(1e-6, 1e-6));
         RealPointValuePair optimum =
             optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 1, 1 });
         Assert.assertTrue(optimum.getValue() > 0.1);
@@ -330,10 +333,9 @@ public class NonLinearConjugateGradientOptimizerTest {
         circle.addPoint( 35.0,  15.0);
         circle.addPoint( 45.0,  97.0);
         NonLinearConjugateGradientOptimizer optimizer =
-            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE);
-        optimizer.setConvergenceChecker(new SimpleScalarValueChecker(1.0e-30, 1.0e-30));
-        UnivariateRealSolver solver = new BrentSolver(1e-15, 1e-13);
-        optimizer.setLineSearchSolver(solver);
+            new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,
+                                                    new SimpleScalarValueChecker(1e-30, 1e-30),
+                                                    new BrentSolver(1e-15, 1e-13));
         RealPointValuePair optimum =
             optimizer.optimize(100, circle, GoalType.MINIMIZE, new double[] { 98.680, 47.345 });
         Point2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);
