diff --git a/src/main/java/org/apache/commons/math/distribution/KolmogorovSmirnovDistributionImpl.java b/src/main/java/org/apache/commons/math/distribution/KolmogorovSmirnovDistributionImpl.java
index b82639e21..4f81e974b 100644
--- a/src/main/java/org/apache/commons/math/distribution/KolmogorovSmirnovDistributionImpl.java
+++ b/src/main/java/org/apache/commons/math/distribution/KolmogorovSmirnovDistributionImpl.java
@@ -24,6 +24,7 @@ import org.apache.commons.math.exception.MathArithmeticException;
 import org.apache.commons.math.exception.NotStrictlyPositiveException;
 import org.apache.commons.math.exception.util.LocalizedFormats;
 import org.apache.commons.math.fraction.BigFraction;
+import org.apache.commons.math.fraction.BigFractionField;
 import org.apache.commons.math.fraction.FractionConversionException;
 import org.apache.commons.math.linear.Array2DRowFieldMatrix;
 import org.apache.commons.math.linear.Array2DRowRealMatrix;
@@ -359,6 +360,6 @@ public class KolmogorovSmirnovDistributionImpl implements KolmogorovSmirnovDistr
             }
         }
 
-        return new Array2DRowFieldMatrix<BigFraction>(Hdata);
+        return new Array2DRowFieldMatrix<BigFraction>(BigFractionField.getInstance(), Hdata);
     }
 }
diff --git a/src/main/java/org/apache/commons/math/linear/AbstractFieldMatrix.java b/src/main/java/org/apache/commons/math/linear/AbstractFieldMatrix.java
index 4ede4e8bb..555ed23f1 100644
--- a/src/main/java/org/apache/commons/math/linear/AbstractFieldMatrix.java
+++ b/src/main/java/org/apache/commons/math/linear/AbstractFieldMatrix.java
@@ -538,7 +538,7 @@ public abstract class AbstractFieldMatrix<T extends FieldElement<T>>
 
     /** {@inheritDoc} */
     public FieldVector<T> getRowVector(final int row) {
-        return new ArrayFieldVector<T>(getRow(row), false);
+        return new ArrayFieldVector<T>(field, getRow(row), false);
     }
 
     /** {@inheritDoc} */
@@ -557,7 +557,7 @@ public abstract class AbstractFieldMatrix<T extends FieldElement<T>>
 
     /** {@inheritDoc} */
     public FieldVector<T> getColumnVector(final int column) {
-        return new ArrayFieldVector<T>(getColumn(column), false);
+        return new ArrayFieldVector<T>(field, getColumn(column), false);
     }
 
     /** {@inheritDoc} */
@@ -702,7 +702,7 @@ public abstract class AbstractFieldMatrix<T extends FieldElement<T>>
     /** {@inheritDoc} */
     public FieldVector<T> operate(final FieldVector<T> v) {
         try {
-            return new ArrayFieldVector<T>(operate(((ArrayFieldVector<T>) v).getDataRef()), false);
+            return new ArrayFieldVector<T>(field, operate(((ArrayFieldVector<T>) v).getDataRef()), false);
         } catch (ClassCastException cce) {
             final int nRows = getRowDimension();
             final int nCols = getColumnDimension();
@@ -719,7 +719,7 @@ public abstract class AbstractFieldMatrix<T extends FieldElement<T>>
                 out[row] = sum;
             }
 
-            return new ArrayFieldVector<T>(out, false);
+            return new ArrayFieldVector<T>(field, out, false);
         }
     }
 
@@ -747,7 +747,7 @@ public abstract class AbstractFieldMatrix<T extends FieldElement<T>>
     /** {@inheritDoc} */
     public FieldVector<T> preMultiply(final FieldVector<T> v) {
         try {
-            return new ArrayFieldVector<T>(preMultiply(((ArrayFieldVector<T>) v).getDataRef()), false);
+            return new ArrayFieldVector<T>(field, preMultiply(((ArrayFieldVector<T>) v).getDataRef()), false);
         } catch (ClassCastException cce) {
             final int nRows = getRowDimension();
             final int nCols = getColumnDimension();
@@ -764,7 +764,7 @@ public abstract class AbstractFieldMatrix<T extends FieldElement<T>>
                 out[col] = sum;
             }
 
-            return new ArrayFieldVector<T>(out, false);
+            return new ArrayFieldVector<T>(field, out, false);
         }
     }
 
diff --git a/src/main/java/org/apache/commons/math/linear/Array2DRowFieldMatrix.java b/src/main/java/org/apache/commons/math/linear/Array2DRowFieldMatrix.java
index 98c56b6ed..6b062f6f7 100644
--- a/src/main/java/org/apache/commons/math/linear/Array2DRowFieldMatrix.java
+++ b/src/main/java/org/apache/commons/math/linear/Array2DRowFieldMatrix.java
@@ -260,7 +260,7 @@ public class Array2DRowFieldMatrix<T extends FieldElement<T>>
             }
         }
 
-        return new Array2DRowFieldMatrix<T>(outData, false);
+        return new Array2DRowFieldMatrix<T>(getField(), outData, false);
 
     }
 
@@ -292,7 +292,7 @@ public class Array2DRowFieldMatrix<T extends FieldElement<T>>
             }
         }
 
-        return new Array2DRowFieldMatrix<T>(outData, false);
+        return new Array2DRowFieldMatrix<T>(getField(), outData, false);
 
     }
 
diff --git a/src/main/java/org/apache/commons/math/linear/ArrayFieldVector.java b/src/main/java/org/apache/commons/math/linear/ArrayFieldVector.java
index dab185f30..e87d99f9f 100644
--- a/src/main/java/org/apache/commons/math/linear/ArrayFieldVector.java
+++ b/src/main/java/org/apache/commons/math/linear/ArrayFieldVector.java
@@ -198,6 +198,29 @@ public class ArrayFieldVector<T extends FieldElement<T>> implements FieldVector<
         System.arraycopy(d, pos, data, 0, size);
     }
 
+    /**
+     * Construct a vector from part of a array.
+     *
+     * @param field Field to which the elements belong.
+     * @param d Array.
+     * @param pos Position of the first entry.
+     * @param size Number of entries to copy.
+     * @throws NullArgumentException if {@code d} is {@code null}.
+     * @throws NumberIsTooLargeException if the size of {@code d} is less
+     * than {@code pos + size}.
+     */
+    public ArrayFieldVector(Field<T> field, T[] d, int pos, int size) {
+        if (d == null) {
+            throw new NullArgumentException();
+        }
+        if (d.length < pos + size) {
+            throw new NumberIsTooLargeException(pos + size, d.length, true);
+        }
+        this.field = field;
+        data = buildArray(size);
+        System.arraycopy(d, pos, data, 0, size);
+    }
+
     /**
      * Construct a vector from another vector, using a deep copy.
      *
@@ -651,7 +674,7 @@ public class ArrayFieldVector<T extends FieldElement<T>> implements FieldVector<
 
     /** {@inheritDoc} */
     public FieldVector<T> projection(T[] v) {
-        return projection(new ArrayFieldVector<T>(v, false));
+        return projection(new ArrayFieldVector<T>(getField(), v, false));
     }
 
    /** Find the orthogonal projection of this vector onto another vector.
diff --git a/src/main/java/org/apache/commons/math/linear/BlockFieldMatrix.java b/src/main/java/org/apache/commons/math/linear/BlockFieldMatrix.java
index b90b6d00a..4d352dc08 100644
--- a/src/main/java/org/apache/commons/math/linear/BlockFieldMatrix.java
+++ b/src/main/java/org/apache/commons/math/linear/BlockFieldMatrix.java
@@ -985,7 +985,7 @@ public class BlockFieldMatrix<T extends FieldElement<T>> extends AbstractFieldMa
             outIndex += jWidth;
         }
 
-        return new ArrayFieldVector<T>(outData, false);
+        return new ArrayFieldVector<T>(getField(), outData, false);
     }
 
     /** {@inheritDoc} */
@@ -1017,7 +1017,7 @@ public class BlockFieldMatrix<T extends FieldElement<T>> extends AbstractFieldMa
             }
         }
 
-        return new ArrayFieldVector<T>(outData, false);
+        return new ArrayFieldVector<T>(getField(), outData, false);
     }
 
     /** {@inheritDoc} */
diff --git a/src/main/java/org/apache/commons/math/linear/FieldLUDecompositionImpl.java b/src/main/java/org/apache/commons/math/linear/FieldLUDecompositionImpl.java
index 740e92e60..df35ee162 100644
--- a/src/main/java/org/apache/commons/math/linear/FieldLUDecompositionImpl.java
+++ b/src/main/java/org/apache/commons/math/linear/FieldLUDecompositionImpl.java
@@ -333,7 +333,7 @@ public class FieldLUDecompositionImpl<T extends FieldElement<T>> implements Fiel
                     }
                 }
 
-                return new ArrayFieldVector<T>(bp, false);
+                return new ArrayFieldVector<T>(field, bp, false);
 
             }
         }
@@ -346,7 +346,7 @@ public class FieldLUDecompositionImpl<T extends FieldElement<T>> implements Fiel
          * @throws SingularMatrixException if the decomposed matrix is singular.
          */
         public ArrayFieldVector<T> solve(ArrayFieldVector<T> b) {
-            return new ArrayFieldVector<T>(solve(b.getDataRef()), false);
+            return new ArrayFieldVector<T>(field, solve(b.getDataRef()), false);
         }
 
         /** {@inheritDoc} */
@@ -400,7 +400,7 @@ public class FieldLUDecompositionImpl<T extends FieldElement<T>> implements Fiel
                 }
             }
 
-            return new Array2DRowFieldMatrix<T>(bp, false);
+            return new Array2DRowFieldMatrix<T>(field, bp, false);
 
         }
 
diff --git a/src/main/java/org/apache/commons/math/linear/MatrixUtils.java b/src/main/java/org/apache/commons/math/linear/MatrixUtils.java
index 2715a685b..48e45e60e 100644
--- a/src/main/java/org/apache/commons/math/linear/MatrixUtils.java
+++ b/src/main/java/org/apache/commons/math/linear/MatrixUtils.java
@@ -30,6 +30,7 @@ import org.apache.commons.math.exception.NoDataException;
 import org.apache.commons.math.exception.NumberIsTooSmallException;
 import org.apache.commons.math.exception.NullArgumentException;
 import org.apache.commons.math.exception.DimensionMismatchException;
+import org.apache.commons.math.exception.ZeroException;
 import org.apache.commons.math.exception.util.LocalizedFormats;
 import org.apache.commons.math.fraction.BigFraction;
 import org.apache.commons.math.fraction.Fraction;
@@ -181,7 +182,7 @@ public class MatrixUtils {
             Arrays.fill(dRow, zero);
             dRow[row] = one;
         }
-        return new Array2DRowFieldMatrix<T>(d, false);
+        return new Array2DRowFieldMatrix<T>(field, d, false);
     }
 
     /**
@@ -242,12 +243,16 @@ public class MatrixUtils {
      * @return a data.length FieldVector
      * @throws NoDataException if {@code data} is empty.
      * @throws NullArgumentException if {@code data} is {@code null}.
+     * @throws ZeroException if {@code data} has 0 elements
      */
     public static <T extends FieldElement<T>> FieldVector<T> createFieldVector(final T[] data) {
         if (data == null) {
             throw new NullArgumentException();
         }
-        return new ArrayFieldVector<T>(data, true);
+        if (data.length == 0) {
+            throw new ZeroException(LocalizedFormats.VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT);
+        }
+        return new ArrayFieldVector<T>(data[0].getField(), data, true);
     }
 
     /**
diff --git a/src/test/java/org/apache/commons/math/linear/ArrayFieldVectorTest.java b/src/test/java/org/apache/commons/math/linear/ArrayFieldVectorTest.java
index 8bd430029..01de15ad6 100644
--- a/src/test/java/org/apache/commons/math/linear/ArrayFieldVectorTest.java
+++ b/src/test/java/org/apache/commons/math/linear/ArrayFieldVectorTest.java
@@ -268,11 +268,11 @@ public class ArrayFieldVectorTest {
         Assert.assertEquals(5, v2.getDimension());
         Assert.assertEquals(new Fraction(123, 100), v2.getEntry(4));
 
-        ArrayFieldVector<Fraction> v3 = new ArrayFieldVector<Fraction>(vec1);
+        ArrayFieldVector<Fraction> v3 = new ArrayFieldVector<Fraction>(FractionField.getInstance(), vec1);
         Assert.assertEquals(3, v3.getDimension());
         Assert.assertEquals(new Fraction(2), v3.getEntry(1));
 
-        ArrayFieldVector<Fraction> v4 = new ArrayFieldVector<Fraction>(vec4, 3, 2);
+        ArrayFieldVector<Fraction> v4 = new ArrayFieldVector<Fraction>(FractionField.getInstance(), vec4, 3, 2);
         Assert.assertEquals(2, v4.getDimension());
         Assert.assertEquals(new Fraction(4), v4.getEntry(0));
         try {
diff --git a/src/test/java/org/apache/commons/math/linear/FieldLUDecompositionImplTest.java b/src/test/java/org/apache/commons/math/linear/FieldLUDecompositionImplTest.java
index 6cf90a819..a4fcd8fb9 100644
--- a/src/test/java/org/apache/commons/math/linear/FieldLUDecompositionImplTest.java
+++ b/src/test/java/org/apache/commons/math/linear/FieldLUDecompositionImplTest.java
@@ -56,7 +56,8 @@ public class FieldLUDecompositionImplTest {
     /** test dimensions */
     @Test
     public void testDimensions() {
-        FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(testData);
+        FieldMatrix<Fraction> matrix =
+            new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), testData);
         FieldLUDecomposition<Fraction> LU = new FieldLUDecompositionImpl<Fraction>(matrix);
         Assert.assertEquals(testData.length, LU.getL().getRowDimension());
         Assert.assertEquals(testData.length, LU.getL().getColumnDimension());
@@ -71,6 +72,7 @@ public class FieldLUDecompositionImplTest {
     @Test
     public void testNonSquare() {
         try {
+            // we don't use FractionField.getInstance() for testing purposes
             new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {
                     { Fraction.ZERO, Fraction.ZERO },
                     { Fraction.ZERO, Fraction.ZERO },
@@ -85,14 +87,14 @@ public class FieldLUDecompositionImplTest {
     /** test PA = LU */
     @Test
     public void testPAEqualLU() {
-        FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(testData);
+        FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), testData);
         FieldLUDecomposition<Fraction> lu = new FieldLUDecompositionImpl<Fraction>(matrix);
         FieldMatrix<Fraction> l = lu.getL();
         FieldMatrix<Fraction> u = lu.getU();
         FieldMatrix<Fraction> p = lu.getP();
         TestUtils.assertEquals(p.multiply(matrix), l.multiply(u));
 
-        matrix = new Array2DRowFieldMatrix<Fraction>(testDataMinus);
+        matrix = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), testDataMinus);
         lu = new FieldLUDecompositionImpl<Fraction>(matrix);
         l = lu.getL();
         u = lu.getU();
@@ -109,14 +111,14 @@ public class FieldLUDecompositionImplTest {
         p = lu.getP();
         TestUtils.assertEquals(p.multiply(matrix), l.multiply(u));
 
-        matrix = new Array2DRowFieldMatrix<Fraction>(singular);
+        matrix = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), singular);
         lu = new FieldLUDecompositionImpl<Fraction>(matrix);
         Assert.assertFalse(lu.getSolver().isNonSingular());
         Assert.assertNull(lu.getL());
         Assert.assertNull(lu.getU());
         Assert.assertNull(lu.getP());
 
-        matrix = new Array2DRowFieldMatrix<Fraction>(bigSingular);
+        matrix = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), bigSingular);
         lu = new FieldLUDecompositionImpl<Fraction>(matrix);
         Assert.assertFalse(lu.getSolver().isNonSingular());
         Assert.assertNull(lu.getL());
@@ -128,7 +130,7 @@ public class FieldLUDecompositionImplTest {
     /** test that L is lower triangular with unit diagonal */
     @Test
     public void testLLowerTriangular() {
-        FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(testData);
+        FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), testData);
         FieldMatrix<Fraction> l = new FieldLUDecompositionImpl<Fraction>(matrix).getL();
         for (int i = 0; i < l.getRowDimension(); i++) {
             Assert.assertEquals(Fraction.ONE, l.getEntry(i, i));
@@ -141,7 +143,7 @@ public class FieldLUDecompositionImplTest {
     /** test that U is upper triangular */
     @Test
     public void testUUpperTriangular() {
-        FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(testData);
+        FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), testData);
         FieldMatrix<Fraction> u = new FieldLUDecompositionImpl<Fraction>(matrix).getU();
         for (int i = 0; i < u.getRowDimension(); i++) {
             for (int j = 0; j < i; j++) {
@@ -153,7 +155,7 @@ public class FieldLUDecompositionImplTest {
     /** test that P is a permutation matrix */
     @Test
     public void testPPermutation() {
-        FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(testData);
+        FieldMatrix<Fraction> matrix = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), testData);
         FieldMatrix<Fraction> p   = new FieldLUDecompositionImpl<Fraction>(matrix).getP();
 
         FieldMatrix<Fraction> ppT = p.multiply(p.transpose());
@@ -210,11 +212,11 @@ public class FieldLUDecompositionImplTest {
     @Test
     public void testSingular() {
         FieldLUDecomposition<Fraction> lu =
-            new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(testData));
+            new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), testData));
         Assert.assertTrue(lu.getSolver().isNonSingular());
-        lu = new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(singular));
+        lu = new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), singular));
         Assert.assertFalse(lu.getSolver().isNonSingular());
-        lu = new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(bigSingular));
+        lu = new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), bigSingular));
         Assert.assertFalse(lu.getSolver().isNonSingular());
     }
 
@@ -222,18 +224,18 @@ public class FieldLUDecompositionImplTest {
     @Test
     public void testMatricesValues1() {
        FieldLUDecomposition<Fraction> lu =
-            new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(testData));
-        FieldMatrix<Fraction> lRef = new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {
+            new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), testData));
+        FieldMatrix<Fraction> lRef = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), new Fraction[][] {
                 { new Fraction(1), new Fraction(0), new Fraction(0) },
                 { new Fraction(2), new Fraction(1), new Fraction(0) },
                 { new Fraction(1), new Fraction(-2), new Fraction(1) }
         });
-        FieldMatrix<Fraction> uRef = new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {
+        FieldMatrix<Fraction> uRef = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), new Fraction[][] {
                 { new Fraction(1),  new Fraction(2), new Fraction(3) },
                 { new Fraction(0), new Fraction(1), new Fraction(-3) },
                 { new Fraction(0),  new Fraction(0), new Fraction(-1) }
         });
-        FieldMatrix<Fraction> pRef = new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {
+        FieldMatrix<Fraction> pRef = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), new Fraction[][] {
                 { new Fraction(1), new Fraction(0), new Fraction(0) },
                 { new Fraction(0), new Fraction(1), new Fraction(0) },
                 { new Fraction(0), new Fraction(0), new Fraction(1) }
@@ -263,18 +265,18 @@ public class FieldLUDecompositionImplTest {
     @Test
     public void testMatricesValues2() {
        FieldLUDecomposition<Fraction> lu =
-            new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(luData));
-        FieldMatrix<Fraction> lRef = new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {
+            new FieldLUDecompositionImpl<Fraction>(new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), luData));
+        FieldMatrix<Fraction> lRef = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), new Fraction[][] {
                 { new Fraction(1), new Fraction(0), new Fraction(0) },
                 { new Fraction(3), new Fraction(1), new Fraction(0) },
                 { new Fraction(1), new Fraction(0), new Fraction(1) }
         });
-        FieldMatrix<Fraction> uRef = new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {
+        FieldMatrix<Fraction> uRef = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), new Fraction[][] {
                 { new Fraction(2), new Fraction(3), new Fraction(3)    },
                 { new Fraction(0), new Fraction(-3), new Fraction(-1)  },
                 { new Fraction(0), new Fraction(0), new Fraction(4) }
         });
-        FieldMatrix<Fraction> pRef = new Array2DRowFieldMatrix<Fraction>(new Fraction[][] {
+        FieldMatrix<Fraction> pRef = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), new Fraction[][] {
                 { new Fraction(1), new Fraction(0), new Fraction(0) },
                 { new Fraction(0), new Fraction(0), new Fraction(1) },
                 { new Fraction(0), new Fraction(1), new Fraction(0) }
diff --git a/src/test/java/org/apache/commons/math/linear/MatrixUtilsTest.java b/src/test/java/org/apache/commons/math/linear/MatrixUtilsTest.java
index 1f7b470fb..7bf129f33 100644
--- a/src/test/java/org/apache/commons/math/linear/MatrixUtilsTest.java
+++ b/src/test/java/org/apache/commons/math/linear/MatrixUtilsTest.java
@@ -93,7 +93,7 @@ public final class MatrixUtilsTest {
     public void testcreateFieldMatrix() {
         Assert.assertEquals(new Array2DRowFieldMatrix<Fraction>(asFraction(testData)),
                      MatrixUtils.createFieldMatrix(asFraction(testData)));
-        Assert.assertEquals(new Array2DRowFieldMatrix<Fraction>(fractionColMatrix),
+        Assert.assertEquals(new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), fractionColMatrix),
                      MatrixUtils.createFieldMatrix(fractionColMatrix));
         try {
             MatrixUtils.createFieldMatrix(asFraction(new double[][] {{1}, {1,2}}));  // ragged
diff --git a/src/test/java/org/apache/commons/math/linear/SparseFieldMatrixTest.java b/src/test/java/org/apache/commons/math/linear/SparseFieldMatrixTest.java
index cd0ffab4f..45c8d227b 100644
--- a/src/test/java/org/apache/commons/math/linear/SparseFieldMatrixTest.java
+++ b/src/test/java/org/apache/commons/math/linear/SparseFieldMatrixTest.java
@@ -204,7 +204,7 @@ public class SparseFieldMatrixTest {
         SparseFieldMatrix<Fraction> m2 = createSparseMatrix(testData2);
         assertClose("inverse multiply", m.multiply(mInv), identity,
                 entryTolerance);
-        assertClose("inverse multiply", m.multiply(new Array2DRowFieldMatrix<Fraction>(testDataInv)), identity,
+        assertClose("inverse multiply", m.multiply(new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(), testDataInv)), identity,
                     entryTolerance);
         assertClose("inverse multiply", mInv.multiply(m), identity,
                 entryTolerance);
