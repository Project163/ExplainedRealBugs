diff --git a/src/main/java/org/apache/commons/math/analysis/BinaryFunction.java b/src/main/java/org/apache/commons/math/analysis/BinaryFunction.java
deleted file mode 100644
index 3511f5695..000000000
--- a/src/main/java/org/apache/commons/math/analysis/BinaryFunction.java
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.math.analysis;
-
-import org.apache.commons.math.exception.MathUserException;
-import org.apache.commons.math.util.FastMath;
-
-
-
-/**
- * Base class for {@link BivariateRealFunction} that can be composed with other functions.
- *
- * @since 2.1
- * @version $Revision$ $Date$
- * @deprecated in 2.2 (to be removed in 3.0). Please use the function classes
- * in the {@link org.apache.commons.math.analysis.function} package and the
- * methods in {@link FunctionUtils}.
- */
-@Deprecated
-public abstract class BinaryFunction implements BivariateRealFunction {
-    public static BinaryFunction make(final BivariateRealFunction f) {
-        return new BinaryFunction() {
-            /** {@inheritDoc} */
-            @Override
-                public double value(double x, double y) {
-                return f.value(x, y);
-            }
-        };
-    }
-
-    /** The + operator method wrapped as a {@link BinaryFunction}. */
-    public static final BinaryFunction ADD =
-        make(new org.apache.commons.math.analysis.function.Add());
-
-    /** The - operator method wrapped as a {@link BinaryFunction}. */
-    public static final BinaryFunction SUBTRACT =
-        make(new org.apache.commons.math.analysis.function.Subtract());
-
-    /** The * operator method wrapped as a {@link BinaryFunction}. */
-    public static final BinaryFunction MULTIPLY =
-        make(new org.apache.commons.math.analysis.function.Multiply());
-
-    /** The / operator method wrapped as a {@link BinaryFunction}. */
-    public static final BinaryFunction DIVIDE =
-        make(new org.apache.commons.math.analysis.function.Divide());
-
-    /** The {@code FastMath.pow} method wrapped as a {@link BinaryFunction}. */
-    public static final BinaryFunction POW =
-        make(new org.apache.commons.math.analysis.function.Pow());
-
-    /** The {@code FastMath.atan2} method wrapped as a {@link BinaryFunction}. */
-    public static final BinaryFunction ATAN2 =
-        make(new org.apache.commons.math.analysis.function.Atan2());
-
-    /** {@inheritDoc} */
-    public abstract double value(double x, double y) throws MathUserException;
-
-    /** Get a composable function by fixing the first argument of the instance.
-     * @param fixedX fixed value of the first argument
-     * @return a function such that {@code f.value(y) == value(fixedX, y)}
-     */
-    public ComposableFunction fix1stArgument(final double fixedX) {
-        return ComposableFunction.make(FunctionUtils.fix1stArgument(this, fixedX));
-    }
-
-    /** Get a composable function by fixing the second argument of the instance.
-     * @param fixedY fixed value of the second argument
-     * @return a function such that {@code f.value(x) == value(x, fixedY)}
-     */
-    public ComposableFunction fix2ndArgument(final double fixedY) {
-        return ComposableFunction.make(FunctionUtils.fix2ndArgument(this, fixedY));
-    }
-}
diff --git a/src/main/java/org/apache/commons/math/analysis/ComposableFunction.java b/src/main/java/org/apache/commons/math/analysis/ComposableFunction.java
deleted file mode 100644
index 99e631dac..000000000
--- a/src/main/java/org/apache/commons/math/analysis/ComposableFunction.java
+++ /dev/null
@@ -1,410 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.commons.math.analysis;
-
-import org.apache.commons.math.exception.MathUserException;
-import org.apache.commons.math.util.FastMath;
-
-
-/**
- * Base class for {@link UnivariateRealFunction} that can be composed with other functions.
- *
- * @since 2.1
- * @version $Revision$ $Date$
- * @deprecated in 2.2 (to be removed in 3.0). Please use the function classes
- * in the {@link org.apache.commons.math.analysis.function} package and the
- * methods in {@link FunctionUtils}.
- */
-@Deprecated
-public abstract class ComposableFunction implements UnivariateRealFunction {
-    public static ComposableFunction make(final UnivariateRealFunction f) {
-        return new ComposableFunction() {
-            /** {@inheritDoc} */
-            @Override
-            public double value(double x) {
-                return f.value(x);
-            }
-        };
-    }
-
-    /** The constant function always returning 0. */
-    public static final ComposableFunction ZERO =
-        make(new org.apache.commons.math.analysis.function.Constant(0));
-    
-    /** The constant function always returning 1. */
-    public static final ComposableFunction ONE = 
-        make(new org.apache.commons.math.analysis.function.Constant(1));
-
-    /** The identity function. */
-    public static final ComposableFunction IDENTITY =
-        make(new org.apache.commons.math.analysis.function.Identity());
-
-    /** The {@code FastMath.abs} method wrapped as a {@link ComposableFunction}. */
-    public static final ComposableFunction ABS =
-        make(new org.apache.commons.math.analysis.function.Abs());
-
-    /** The - operator wrapped as a {@link ComposableFunction}. */
-    public static final ComposableFunction NEGATE = 
-        make(new org.apache.commons.math.analysis.function.Minus());
-
-    /** The invert operator wrapped as a {@link ComposableFunction}. */
-    public static final ComposableFunction INVERT =
-        make(new org.apache.commons.math.analysis.function.Inverse());
-
-    /** The {@code FastMath.sin} method wrapped as a {@link ComposableFunction}. */
-    public static final ComposableFunction SIN =
-        make(new org.apache.commons.math.analysis.function.Sin());
-
-    /** The {@code FastMath.sqrt} method wrapped as a {@link ComposableFunction}. */
-    public static final ComposableFunction SQRT =
-        make(new org.apache.commons.math.analysis.function.Sqrt());
-
-    /** The {@code FastMath.sinh} method wrapped as a {@link ComposableFunction}. */
-    public static final ComposableFunction SINH =
-        make(new org.apache.commons.math.analysis.function.Sinh());
-
-    /** The {@code FastMath.exp} method wrapped as a {@link ComposableFunction}. */
-    public static final ComposableFunction EXP =
-        make(new org.apache.commons.math.analysis.function.Exp());
-
-    /** The {@code FastMath.expm1} method wrapped as a {@link ComposableFunction}. */
-    public static final ComposableFunction EXPM1 =
-        make(new org.apache.commons.math.analysis.function.Expm1());
-
-    /** The {@code FastMath.asin} method wrapped as a {@link ComposableFunction}. */
-    public static final ComposableFunction ASIN =
-        make(new org.apache.commons.math.analysis.function.Asin());
-
-    /** The {@code FastMath.atan} method wrapped as a {@link ComposableFunction}. */
-    public static final ComposableFunction ATAN =
-        make(new org.apache.commons.math.analysis.function.Atan());
-
-    /** The {@code FastMath.tan} method wrapped as a {@link ComposableFunction}. */
-    public static final ComposableFunction TAN =
-        make(new org.apache.commons.math.analysis.function.Tan());
-
-    /** The {@code FastMath.tanh} method wrapped as a {@link ComposableFunction}. */
-    public static final ComposableFunction TANH =
-        make(new org.apache.commons.math.analysis.function.Tanh());
-
-    /** The {@code FastMath.cbrt} method wrapped as a {@link ComposableFunction}. */
-    public static final ComposableFunction CBRT =
-        make(new org.apache.commons.math.analysis.function.Cbrt());
-
-    /** The {@code FastMath.ceil} method wrapped as a {@link ComposableFunction}. */
-    public static final ComposableFunction CEIL = new ComposableFunction() {
-        /** {@inheritDoc} */
-        @Override
-        public double value(double d) {
-            return FastMath.ceil(d);
-        }
-    };
-
-    /** The {@code FastMath.floor} method wrapped as a {@link ComposableFunction}. */
-    public static final ComposableFunction FLOOR = new ComposableFunction() {
-        /** {@inheritDoc} */
-        @Override
-        public double value(double d) {
-            return FastMath.floor(d);
-        }
-    };
-
-    /** The {@code FastMath.log} method wrapped as a {@link ComposableFunction}. */
-    public static final ComposableFunction LOG =
-        make(new org.apache.commons.math.analysis.function.Log());
-
-    /** The {@code FastMath.log10} method wrapped as a {@link ComposableFunction}. */
-    public static final ComposableFunction LOG10 =
-        make(new org.apache.commons.math.analysis.function.Log10());
-
-    /** The {@code FastMath.log1p} method wrapped as a {@link ComposableFunction}. */
-    public static final ComposableFunction LOG1P =
-        make(new org.apache.commons.math.analysis.function.Log1p());
-
-    /** The {@code FastMath.cos} method wrapped as a {@link ComposableFunction}. */
-    public static final ComposableFunction COS =
-        make(new org.apache.commons.math.analysis.function.Cos());
-
-    /** The {@code FastMath.abs} method wrapped as a {@link ComposableFunction}. */
-    public static final ComposableFunction ACOS =
-        make(new org.apache.commons.math.analysis.function.Acos());
-
-    /** The {@code FastMath.cosh} method wrapped as a {@link ComposableFunction}. */
-    public static final ComposableFunction COSH =
-        make(new org.apache.commons.math.analysis.function.Cosh());
-
-    /** The {@code FastMath.rint} method wrapped as a {@link ComposableFunction}. */
-    public static final ComposableFunction RINT = new ComposableFunction() {
-        /** {@inheritDoc} */
-        @Override
-        public double value(double d) {
-            return FastMath.rint(d);
-        }
-    };
-
-    /** The {@code FastMath.signum} method wrapped as a {@link ComposableFunction}. */
-    public static final ComposableFunction SIGNUM = new ComposableFunction() {
-        /** {@inheritDoc} */
-        @Override
-        public double value(double d) {
-            return FastMath.signum(d);
-        }
-    };
-
-    /** The {@code FastMath.ulp} method wrapped as a {@link ComposableFunction}. */
-    public static final ComposableFunction ULP = new ComposableFunction() {
-        /** {@inheritDoc} */
-        @Override
-        public double value(double d) {
-            return FastMath.ulp(d);
-        }
-    };
-
-    /** Precompose the instance with another function.
-     * <p>
-     * The composed function h created by {@code h = g.of(f)} is such
-     * that {@code h.value(x) == g.value(f.value(x))} for all x.
-     * </p>
-     * @param f function to compose with
-     * @return a new function which computes {@code this.value(f.value(x))}
-     * @see #postCompose(UnivariateRealFunction)
-     */
-    public ComposableFunction of(final UnivariateRealFunction f) {
-        return new ComposableFunction() {
-            @Override
-            /** {@inheritDoc} */
-            public double value(double x) throws MathUserException {
-                return ComposableFunction.this.value(f.value(x));
-            }
-        };
-    }
-
-    /** Postcompose the instance with another function.
-     * <p>
-     * The composed function h created by {@code h = g.postCompose(f)} is such
-     * that {@code h.value(x) == f.value(g.value(x))} for all x.
-     * </p>
-     * @param f function to compose with
-     * @return a new function which computes {@code f.value(this.value(x))}
-     * @see #of(UnivariateRealFunction)
-     */
-    public ComposableFunction postCompose(final UnivariateRealFunction f) {
-        return new ComposableFunction() {
-            @Override
-            /** {@inheritDoc} */
-            public double value(double x) throws MathUserException {
-                return f.value(ComposableFunction.this.value(x));
-            }
-        };
-    }
-
-    /**
-     * Return a function combining the instance and another function.
-     * <p>
-     * The function h created by {@code h = g.combine(f, combiner)} is such that
-     * {@code h.value(x) == combiner.value(g.value(x), f.value(x))} for all x.
-     * </p>
-     * @param f function to combine with the instance
-     * @param combiner bivariate function used for combining
-     * @return a new function which computes {@code combine.value(this.value(x), f.value(x))}
-     */
-    public ComposableFunction combine(final UnivariateRealFunction f,
-                                      final BivariateRealFunction combiner) {
-        return new ComposableFunction() {
-            @Override
-            /** {@inheritDoc} */
-            public double value(double x) throws MathUserException {
-                return combiner.value(ComposableFunction.this.value(x), f.value(x));
-            }
-        };
-    }
-
-    /**
-     * Return a function adding the instance and another function.
-     * @param f function to combine with the instance
-     * @return a new function which computes {@code this.value(x) + f.value(x)}
-     */
-    public ComposableFunction add(final UnivariateRealFunction f) {
-        return new ComposableFunction() {
-            @Override
-            /** {@inheritDoc} */
-            public double value(double x) throws MathUserException {
-                return ComposableFunction.this.value(x) + f.value(x);
-            }
-        };
-    }
-
-    /**
-     * Return a function adding a constant term to the instance.
-     * @param a term to add
-     * @return a new function which computes {@code this.value(x) + a}
-     */
-    public ComposableFunction add(final double a) {
-        return new ComposableFunction() {
-            @Override
-            /** {@inheritDoc} */
-            public double value(double x) throws MathUserException {
-                return ComposableFunction.this.value(x) + a;
-            }
-        };
-    }
-
-    /**
-     * Return a function subtracting another function from the instance.
-     * @param f function to combine with the instance
-     * @return a new function which computes {@code this.value(x) - f.value(x)}
-     */
-    public ComposableFunction subtract(final UnivariateRealFunction f) {
-        return new ComposableFunction() {
-            @Override
-            /** {@inheritDoc} */
-            public double value(double x) throws MathUserException {
-                return ComposableFunction.this.value(x) - f.value(x);
-            }
-        };
-    }
-
-    /**
-     * Return a function multiplying the instance and another function.
-     * @param f function to combine with the instance
-     * @return a new function which computes {@code this.value(x) * f.value(x)}
-     */
-    public ComposableFunction multiply(final UnivariateRealFunction f) {
-        return new ComposableFunction() {
-            @Override
-            /** {@inheritDoc} */
-            public double value(double x) throws MathUserException {
-                return ComposableFunction.this.value(x) * f.value(x);
-            }
-        };
-    }
-
-    /**
-     * Return a function scaling the instance by a constant factor.
-     * @param scaleFactor constant scaling factor
-     * @return a new function which computes {@code this.value(x) * scaleFactor}
-     */
-    public ComposableFunction multiply(final double scaleFactor) {
-        return new ComposableFunction() {
-            @Override
-            /** {@inheritDoc} */
-            public double value(double x) throws MathUserException {
-                return ComposableFunction.this.value(x) * scaleFactor;
-            }
-        };
-    }
-    /**
-     * Return a function dividing the instance by another function.
-     * @param f function to combine with the instance
-     * @return a new function which computes {@code this.value(x) / f.value(x)}
-     */
-    public ComposableFunction divide(final UnivariateRealFunction f) {
-        return new ComposableFunction() {
-            @Override
-            /** {@inheritDoc} */
-            public double value(double x) throws MathUserException {
-                return ComposableFunction.this.value(x) / f.value(x);
-            }
-        };
-    }
-
-    /**
-     * Generates a function that iteratively apply instance function on all
-     * elements of an array.
-     * <p>
-     * The generated function behaves as follows:
-     * <ul>
-     *   <li>initialize result = initialValue</li>
-     *   <li>iterate: {@code result = combiner.value(result,
-     *   this.value(nextMultivariateEntry));}</li>
-     *   <li>return result</li>
-     * </ul>
-     * </p>
-     * @param combiner combiner to use between entries
-     * @param initialValue initial value to use before first entry
-     * @return a new function that iteratively applie instance function on all
-     * elements of an array.
-     */
-    public MultivariateRealFunction asCollector(final BivariateRealFunction combiner,
-                                                final double initialValue) {
-        return new MultivariateRealFunction() {
-            /** {@inheritDoc} */
-            public double value(double[] point)
-                throws MathUserException, IllegalArgumentException {
-                double result = initialValue;
-                for (final double entry : point) {
-                    result = combiner.value(result, ComposableFunction.this.value(entry));
-                }
-                return result;
-            }
-        };
-    }
-
-    /**
-     * Generates a function that iteratively apply instance function on all
-     * elements of an array.
-     * <p>
-     * Calling this method is equivalent to call {@link
-     * #asCollector(BivariateRealFunction, double) asCollector(BivariateRealFunction, 0.0)}.
-     * </p>
-     * @param combiner combiner to use between entries
-     * @return a new function that iteratively applie instance function on all
-     * elements of an array.
-     * @see #asCollector(BivariateRealFunction, double)
-     */
-    public  MultivariateRealFunction asCollector(final BivariateRealFunction combiner) {
-        return asCollector(combiner, 0.0);
-    }
-
-    /**
-     * Generates a function that iteratively apply instance function on all
-     * elements of an array.
-     * <p>
-     * Calling this method is equivalent to call {@link
-     * #asCollector(BivariateRealFunction, double) asCollector(BinaryFunction.ADD, initialValue)}.
-     * </p>
-     * @param initialValue initial value to use before first entry
-     * @return a new function that iteratively applie instance function on all
-     * elements of an array.
-     * @see #asCollector(BivariateRealFunction, double)
-     * @see BinaryFunction#ADD
-     */
-    public  MultivariateRealFunction asCollector(final double initialValue) {
-        return asCollector(BinaryFunction.ADD, initialValue);
-    }
-
-    /**
-     * Generates a function that iteratively apply instance function on all
-     * elements of an array.
-     * <p>
-     * Calling this method is equivalent to call {@link
-     * #asCollector(BivariateRealFunction, double) asCollector(BinaryFunction.ADD, 0.0)}.
-     * </p>
-     * @return a new function that iteratively applie instance function on all
-     * elements of an array.
-     * @see #asCollector(BivariateRealFunction, double)
-     * @see BinaryFunction#ADD
-     */
-    public  MultivariateRealFunction asCollector() {
-        return asCollector(BinaryFunction.ADD, 0.0);
-    }
-
-    /** {@inheritDoc} */
-    public abstract double value(double x) throws MathUserException;
-
-}
diff --git a/src/test/java/org/apache/commons/math/analysis/BinaryFunctionTest.java b/src/test/java/org/apache/commons/math/analysis/BinaryFunctionTest.java
deleted file mode 100644
index 267af5dd9..000000000
--- a/src/test/java/org/apache/commons/math/analysis/BinaryFunctionTest.java
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.commons.math.analysis;
-
-import org.apache.commons.math.exception.MathUserException;
-import org.apache.commons.math.util.FastMath;
-import org.junit.Assert;
-import org.junit.Test;
-
-public class BinaryFunctionTest {
-
-    @Test
-    public void testAdd() throws MathUserException {
-        Assert.assertEquals(5.0, BinaryFunction.ADD.value(2, 3), 1.0e-15);
-        Assert.assertEquals(0.0, BinaryFunction.ADD.value(-1, 1), 1.0e-15);
-    }
-
-    @Test
-    public void testSubtract() throws MathUserException {
-        Assert.assertEquals(-1.0, BinaryFunction.SUBTRACT.value(2, 3), 1.0e-15);
-        Assert.assertEquals(-2.0, BinaryFunction.SUBTRACT.value(-1, 1), 1.0e-15);
-    }
-
-    @Test
-    public void testMultiply() throws MathUserException {
-        Assert.assertEquals(6.0, BinaryFunction.MULTIPLY.value(2, 3), 1.0e-15);
-        Assert.assertEquals(-1.0, BinaryFunction.MULTIPLY.value(-1, 1), 1.0e-15);
-    }
-
-    @Test
-    public void testDivide() throws MathUserException {
-        Assert.assertEquals(1.5, BinaryFunction.DIVIDE.value(3, 2), 1.0e-15);
-        Assert.assertEquals(-1.0, BinaryFunction.DIVIDE.value(-1, 1), 1.0e-15);
-    }
-
-    @Test
-    public void testPow() throws MathUserException {
-        Assert.assertEquals(9.0, BinaryFunction.POW.value(3, 2), 1.0e-15);
-        Assert.assertEquals(-1.0, BinaryFunction.POW.value(-1, 1), 1.0e-15);
-    }
-
-    @Test
-    public void testAtan2() throws MathUserException {
-        Assert.assertEquals(FastMath.PI / 4, BinaryFunction.ATAN2.value(1, 1), 1.0e-15);
-        Assert.assertEquals(-FastMath.PI / 4, BinaryFunction.ATAN2.value(-1, 1), 1.0e-15);
-    }
-
-    @Test
-    public void testFix1st() throws MathUserException {
-        ComposableFunction f = BinaryFunction.POW.fix1stArgument(2);
-        for (double x = 0.0; x < 1.0; x += 0.01) {
-            Assert.assertEquals(FastMath.pow(2.0, x), f.value(x), 1.0e-15);
-        }
-    }
-
-    @Test
-    public void testFix2nd() throws MathUserException {
-        ComposableFunction f = BinaryFunction.POW.fix2ndArgument(2);
-        for (double y = 0.0; y < 1.0; y += 0.01) {
-            Assert.assertEquals(y * y, f.value(y), 1.0e-15);
-        }
-    }
-
-}
diff --git a/src/test/java/org/apache/commons/math/analysis/ComposableFunctionTest.java b/src/test/java/org/apache/commons/math/analysis/ComposableFunctionTest.java
deleted file mode 100644
index e46cc5bd5..000000000
--- a/src/test/java/org/apache/commons/math/analysis/ComposableFunctionTest.java
+++ /dev/null
@@ -1,151 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.commons.math.analysis;
-
-import org.apache.commons.math.exception.MathUserException;
-import org.apache.commons.math.util.FastMath;
-import org.junit.Assert;
-import org.junit.Test;
-
-/**
- * @deprecated To be removed when the class {@link ComposableFunction} is removed.
- */
-@Deprecated
-public class ComposableFunctionTest {
-
-    @Test
-    public void testZero() throws MathUserException {
-        Assert.assertEquals(0.0, ComposableFunction.ZERO.value(1), 1.0e-15);
-        Assert.assertEquals(0.0, ComposableFunction.ZERO.value(2), 1.0e-15);
-    }
-
-    @Test
-    public void testOne() throws MathUserException {
-        Assert.assertEquals(1.0, ComposableFunction.ONE.value(1), 1.0e-15);
-        Assert.assertEquals(1.0, ComposableFunction.ONE.value(2), 1.0e-15);
-    }
-
-    @Test
-    public void testIdentity() throws MathUserException {
-        Assert.assertEquals(1.0, ComposableFunction.IDENTITY.value(1), 1.0e-15);
-        Assert.assertEquals(2.0, ComposableFunction.IDENTITY.value(2), 1.0e-15);
-    }
-
-    @Test
-    public void testRint() throws MathUserException {
-        Assert.assertEquals(1.0, ComposableFunction.RINT.value(0.9), 1.0e-15);
-        Assert.assertEquals(2.0, ComposableFunction.RINT.value(2.2), 1.0e-15);
-    }
-
-    @Test
-    public void testSignum() throws MathUserException {
-        Assert.assertEquals(1.0, ComposableFunction.SIGNUM.value(12.3), 1.0e-15);
-        Assert.assertEquals(-1.0, ComposableFunction.SIGNUM.value(-6), 1.0e-15);
-    }
-
-    @Test
-    public void testComposition() throws MathUserException {
-        ComposableFunction abs    = ComposableFunction.ABS;
-        ComposableFunction acos   = ComposableFunction.ACOS;
-        ComposableFunction asin   = ComposableFunction.ASIN;
-        ComposableFunction atan   = ComposableFunction.ATAN;
-        ComposableFunction cbrt   = ComposableFunction.CBRT;
-        ComposableFunction ceil   = ComposableFunction.CEIL;
-        ComposableFunction cos    = ComposableFunction.COS;
-        ComposableFunction cosh   = ComposableFunction.COSH;
-        ComposableFunction exp    = ComposableFunction.EXP;
-        ComposableFunction expm1  = ComposableFunction.EXPM1;
-        ComposableFunction floor  = ComposableFunction.FLOOR;
-        ComposableFunction id     = ComposableFunction.IDENTITY;
-        ComposableFunction log    = ComposableFunction.LOG;
-        ComposableFunction log10  = ComposableFunction.LOG10;
-        ComposableFunction negate = ComposableFunction.NEGATE;
-        ComposableFunction sin    = ComposableFunction.SIN;
-        ComposableFunction sinh   = ComposableFunction.SINH;
-        ComposableFunction sqrt   = ComposableFunction.SQRT;
-        ComposableFunction tan    = ComposableFunction.TAN;
-        ComposableFunction tanh   = ComposableFunction.TANH;
-        ComposableFunction ulp    = ComposableFunction.ULP;
-
-        ComposableFunction f1 = sqrt.of(abs.of(expm1.of(cbrt.of(tanh).of(id))));
-        for (double x = 0.1; x < 0.9; x += 0.01) {
-            Assert.assertEquals(FastMath.sqrt(FastMath.abs(FastMath.expm1(FastMath.cbrt(FastMath.tanh(x))))),
-                                f1.value(x), 1.0e-15);
-        }
-
-        ComposableFunction f2 = cosh.of(sinh.of(tanh.of(ceil.postCompose(log.postCompose(cosh)))));
-        for (double x = 0.1; x < 12.9; x += 1.0) {
-            Assert.assertEquals(FastMath.cosh(FastMath.sinh(FastMath.tanh(FastMath.cosh(FastMath.log(FastMath.ceil(x)))))),
-                                f2.value(x), 1.0e-15);
-        }
-
-        ComposableFunction f3 = cos.of(sin.of(tan.of(acos.of(asin.of(log10.of(log.of(ulp)))))));
-        for (double x = 1.0e16; x < 1.0e17; x += 1.0e16) {
-            Assert.assertEquals(FastMath.cos(FastMath.sin(FastMath.tan(FastMath.acos(FastMath.asin(FastMath.log10(FastMath.log(FastMath.ulp(x)))))))),
-                                f3.value(x), 1.0e-15);
-        }
-
-        ComposableFunction f4 = atan.of(exp.of(negate.of(floor)));
-        for (double x = 1.1; x < 10.2; x += 1.0) {
-            Assert.assertEquals(FastMath.atan(FastMath.exp(-FastMath.floor(x))),
-                                f4.value(x), 1.0e-15);
-        }
-
-    }
-
-    @Test
-    public void testCombine() throws MathUserException {
-
-        ComposableFunction f =
-            ComposableFunction.COS.combine(ComposableFunction.ASIN, BinaryFunction.POW);
-        for (double x = 0.1; x < 0.9; x += 0.01) {
-            Assert.assertEquals(FastMath.pow(FastMath.cos(x), FastMath.asin(x)), f.value(x), 1.0e-15);
-        }
-
-    }
-
-    @Test
-    public void testSimpleCombination() throws MathUserException {
-
-        ComposableFunction f1 = ComposableFunction.COS.add(3);
-        ComposableFunction f2 = ComposableFunction.COS.add(ComposableFunction.SIN);
-        ComposableFunction f3 = ComposableFunction.COS.subtract(ComposableFunction.SIN);
-        ComposableFunction f4 = ComposableFunction.COS.multiply(ComposableFunction.SIN);
-        ComposableFunction f5 = ComposableFunction.COS.multiply(5);
-        ComposableFunction f6 = ComposableFunction.COS.divide(ComposableFunction.SIN);
-        for (double x = 0.1; x < 0.9; x += 0.01) {
-            Assert.assertEquals(FastMath.cos(x) + 3, f1.value(x), 1.0e-15);
-            Assert.assertEquals(FastMath.cos(x) + FastMath.sin(x), f2.value(x), 1.0e-15);
-            Assert.assertEquals(FastMath.cos(x) - FastMath.sin(x), f3.value(x), 1.0e-15);
-            Assert.assertEquals(FastMath.cos(x) * FastMath.sin(x), f4.value(x), 1.0e-15);
-            Assert.assertEquals(FastMath.cos(x) * 5, f5.value(x), 1.0e-15);
-            Assert.assertEquals(FastMath.cos(x) / FastMath.sin(x), f6.value(x), 1.0e-15);
-        }
-
-    }
-
-    @Test
-    public void testCollector() throws MathUserException {
-
-        ComposableFunction f = BinaryFunction.POW.fix2ndArgument(2);
-        Assert.assertEquals(30, f.asCollector().value(new double[] { 1, 2, 3, 4 }), 1.0e-15);
-        Assert.assertEquals(33, f.asCollector(3).value(new double[] { 1, 2, 3, 4 }), 1.0e-15);
-        Assert.assertEquals(-30, f.asCollector(BinaryFunction.SUBTRACT).value(new double[] { 1, 2, 3, 4 }), 1.0e-15);
-        Assert.assertEquals(1152, f.asCollector(BinaryFunction.MULTIPLY, 2).value(new double[] { 1, 2, 3, 4 }), 1.0e-15);
-    }
-
-}
