<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Sat Nov 08 20:27:29 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[MATH-699] inverseCumulativeDistribution fails with cumulative distribution having a plateau</title>
                <link>https://issues.apache.org/jira/browse/MATH-699</link>
                <project id="12310485" key="MATH">Commons Math</project>
                    <description>&lt;p&gt;This bug report follows &lt;a href=&quot;https://issues.apache.org/jira/browse/MATH-692&quot; title=&quot;Cumulative probability and inverse cumulative probability inconsistencies&quot; class=&quot;issue-link&quot; data-issue-key=&quot;MATH-692&quot;&gt;&lt;del&gt;MATH-692&lt;/del&gt;&lt;/a&gt;. The attached unit test fails. As required by the definition in &lt;a href=&quot;https://issues.apache.org/jira/browse/MATH-692&quot; title=&quot;Cumulative probability and inverse cumulative probability inconsistencies&quot; class=&quot;issue-link&quot; data-issue-key=&quot;MATH-692&quot;&gt;&lt;del&gt;MATH-692&lt;/del&gt;&lt;/a&gt;, the lower-bound of the interval on which the cdf is constant should be returned. This is not so at the moment.&lt;/p&gt;</description>
                <environment></environment>
        <key id="12529630">MATH-699</key>
            <summary>inverseCumulativeDistribution fails with cumulative distribution having a plateau</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.svg">Minor</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="celestin">Sebastien Brisard</assignee>
                                    <reporter username="celestin">Sebastien Brisard</reporter>
                        <labels>
                    </labels>
                <created>Tue, 1 Nov 2011 08:35:34 +0000</created>
                <updated>Tue, 30 Nov 2021 23:58:51 +0000</updated>
                            <resolved>Mon, 5 Dec 2011 06:50:36 +0000</resolved>
                                    <version>2.2</version>
                                    <fixVersion>3.0</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>1</watches>
                                                                                                                <comments>
                            <comment id="13144256" author="celestin" created="Fri, 4 Nov 2011 19:13:06 +0000"  >&lt;h4&gt;&lt;a name=&quot;Shouldthisbeconsideredasanerror%3F&quot;&gt;&lt;/a&gt;Should this be considered as an error?&lt;/h4&gt;
&lt;p&gt;Please have a look to lines &lt;a href=&quot;http://commons.apache.org/math/xref/org/apache/commons/math/distribution/AbstractContinuousDistribution.html#103&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;103-108&lt;/a&gt; of &lt;tt&gt;AbstractContinuousDistribution&lt;/tt&gt;.&lt;br/&gt;
I think the logics is flawed, I have the feeling that &lt;tt&gt;rootFindingFunction.value(lowerBound)&lt;/tt&gt; should be compared with &lt;tt&gt;solver.getFunctionValueAccuracy()&lt;/tt&gt;, and not with &lt;tt&gt;getSolverAbsoluteAccuracy()&lt;/tt&gt;. The problem is that &lt;tt&gt;AbstractContinuousDistribution&lt;/tt&gt; should then have a method called &lt;tt&gt;getSolverFunctionValueAccuracy()&lt;/tt&gt;. Should I add one?&lt;br/&gt;
Thanks for your comments,&lt;br/&gt;
S&#233;bastien&lt;/p&gt;</comment>
                            <comment id="13144740" author="psteitz" created="Sat, 5 Nov 2011 16:21:04 +0000"  >&lt;p&gt;I agree that the wrong solver property is being used. I would say yes, add the property, possibly protected.  Assuming protected access, it might even be better to just expose the solver itself.&lt;/p&gt;</comment>
                            <comment id="13144761" author="cwinter" created="Sat, 5 Nov 2011 17:46:23 +0000"  >&lt;p&gt;I also agree that the mentioned code lines use the wrong property. But I&apos;m not sure whether the bracketing step is necessary and efficient at all. Maybe it&apos;s better to pass lowerBound and upperBound directly to the solving step because the solver will shrink the interval efficiently. The bracketing algorithm, however, is very inefficient in expanding the interval around the initial point to a bracket (At least the current implementation is inefficient as it makes linear steps. Geometrical steps would be better for distribution functions, but valid brackets might be missed for non-monotonic functions.). The only problem I see for the solver is if lowerBound or upperBound is infinite. The JavaDoc of getDomainLowerBound() and getDomainUpperBound() just could mention that an implementation must return a finite value.&lt;/p&gt;

&lt;p&gt;I&apos;m fine with protected access to the solver.&lt;/p&gt;</comment>
                            <comment id="13144927" author="celestin" created="Sun, 6 Nov 2011 06:04:45 +0000"  >&lt;p&gt;I think Christian has a point here. The bracketing step is superfluous. I&apos;ll propose a new impl getting rid of it, so that you can decide whether or not to restore it.&lt;/p&gt;

&lt;p&gt;However, we cannot forbit getDomainLowerBound() and getDomainUpperBound() to return &lt;tt&gt;Double.POSITIVE_INFINITY&lt;/tt&gt; (for &lt;tt&gt;p == 1&lt;/tt&gt;) or &lt;tt&gt;Double.NEGATIVE_INFINITY&lt;/tt&gt; (for &lt;tt&gt;p == 0&lt;/tt&gt;). I will prepare something along these lines.&lt;/p&gt;</comment>
                            <comment id="13144933" author="psteitz" created="Sun, 6 Nov 2011 06:12:45 +0000"  >&lt;p&gt;Be careful eliminating the bracketing step.  IIRC it is in there to resolve a bug involving some corner case.  In theory, the unit tests should pick up any regressions, but it would be a good idea to review the commit logs and issue reports for this class before ripping out the bracketing step.&lt;/p&gt;</comment>
                            <comment id="13144939" author="celestin" created="Sun, 6 Nov 2011 06:34:29 +0000"  >&lt;p&gt;OK, thanks for the tip. I will do so.&lt;br/&gt;
S&#233;bastien&lt;/p&gt;

&lt;p&gt;Additional note: Phil, you are referring to r141391. This was 7 years, 3 months ago, you do have a good memory! Will look into that more closely.&lt;/p&gt;</comment>
                            <comment id="13145211" author="celestin" created="Mon, 7 Nov 2011 04:04:06 +0000"  >&lt;p&gt;Hi,&lt;br/&gt;
I thought I would keep you up to date with the problems I&apos;m facing at the moment.&lt;/p&gt;

&lt;p&gt;First of all, I see no smart way to check that for sure, &lt;tt&gt;inverseCumulativeProbability(0)&lt;/tt&gt; (resp. &lt;tt&gt;inverseCumulativeProbability(1)&lt;/tt&gt;) should return &lt;tt&gt;Double.NEGATIVE_INFINITY&lt;/tt&gt; (resp. &lt;tt&gt;Double.POSITIVE_INFINITY&lt;/tt&gt;). What could be done would be to test for a neighbouring value, and check that the cumulative probability is slightly above zero (resp. below one). But this makes no sense, because the only neighbouring value which would make sense would be &lt;tt&gt;+/-Double.MAX_VALUE&lt;/tt&gt;, and this surely return 0.0 or 1.0. So this is my first problem.&lt;/p&gt;

&lt;p&gt;The way I see things is as follows: users might have no clue about the inverse cumulative probability, but they &lt;b&gt;must&lt;/b&gt; know the values of this inverse for p = 0 and p = 1. So I would suggest to change the contract of &lt;tt&gt;getInitialDomain(p)&lt;/tt&gt;. I would make clear in the javadoc that &lt;tt&gt;getInitialDomain(p)&lt;/tt&gt; should return &lt;tt&gt;Double.NEGATIVE_INFINITY&lt;/tt&gt; &lt;b&gt;if, and only if&lt;/b&gt; &lt;tt&gt;inverseCumulativeProbability(0) == Double.NEGATIVE_INFINITY&lt;/tt&gt;. Similarly, &lt;tt&gt;getInitialDomain(p)&lt;/tt&gt; should return &lt;tt&gt;Double.POSITIVE_INFINITY&lt;/tt&gt; &lt;b&gt;if, and only if&lt;/b&gt; &lt;tt&gt;inverseCumulativeProbability(1) == Double.POSITIVE_INFINITY&lt;/tt&gt;.&lt;/p&gt;

&lt;p&gt;My second problem is to check for the presence of plateaux, consistently with finite precision. Here is my initial idea. I first define the two absolute accuracies&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;&lt;tt&gt;dx = getSolverAbsoluteAccuracy()&lt;/tt&gt;,&lt;/li&gt;
	&lt;li&gt;&lt;tt&gt;dp = getSolverFunctionValueAccuracy()&lt;/tt&gt;.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Then, if &lt;tt&gt;x&lt;/tt&gt; is the root found by the solver: we do have &lt;tt&gt;cumulativeProbability( x ) == p&lt;/tt&gt; (within a specified accuracy). The problem is to check whether there is a &lt;b&gt;smaller&lt;/b&gt; value which also satisfies this requirement (in which case, the smallest such value must be returned).&lt;/p&gt;

&lt;p&gt;My initial test was &lt;tt&gt;cumulativeProbability(x - dx) == p&lt;/tt&gt;. Then, I tried &lt;tt&gt;FastMath.abs(cumulativeProbability(x - dx) - p) &amp;lt;= dp&lt;/tt&gt;. Although more consistent with finite precision, this is not fully satisfactory, because in simple cases (where there is no plateau), it might lead to the solver moving to a somewhat less good point. At the very least, it would lead to additional iterations... to finally get back to the initial point &lt;tt&gt;x&lt;/tt&gt;.&lt;/p&gt;

&lt;p&gt;Then, I thought of checking for &lt;b&gt;exact&lt;/b&gt; nullity of the pdf at x. The problem is that the pdf might have discontinuities, in which case, this simple test might fail (if &lt;tt&gt;x&lt;/tt&gt; turns out to be the higher-end of the plateau, and there is a slope discontinuity here).&lt;/p&gt;

&lt;p&gt;So, I&apos;m now back to this test: &lt;tt&gt;cumulativeProbability(x - dx) == cumulativeProbability( x )&lt;/tt&gt;. Please note&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;&lt;b&gt;exact&lt;/b&gt; equality test,&lt;/li&gt;
	&lt;li&gt;I&apos;m no longer testing for equality with the target value &lt;tt&gt;p&lt;/tt&gt;, but with its estimate &lt;tt&gt;cumulativeProbability( x )&lt;/tt&gt;.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;I would be grateful for some feedback on these issues. Also, I think it is clear that&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;my code will require careful reviewers!!!&lt;/li&gt;
	&lt;li&gt;it won&apos;t be completely fool-proof.&lt;/li&gt;
&lt;/ul&gt;
</comment>
                            <comment id="13145544" author="psteitz" created="Mon, 7 Nov 2011 15:11:10 +0000"  >&lt;p&gt;My inclination would be to keep the implementation in the base class as simple as possible, documenting what it does and pushing the responsibility for dealing with plateaus in the distribution to the implementations that have these.  I don&apos;t think any of the currently implemented real distributions have this problem.  Correct?  &lt;/p&gt;

&lt;p&gt;The invariant you are proposing for when to return infinities for domain lower and upper bounds would make sense if these were intended to be the bounds of support for the distribution, but this is not what these properties represent.  They are initial guesses for where to start when trying to bracket a root.  That means they have to be values that can be fed into the cumulative probability function. I may be missing the point that you and Christian are making, but the basic problem is that as Christian points out, we always need to start with finite values and that is what led to the somewhat inelegant construct of the domain lower/upper bounds as guesses and the need to do the bracketing step.  The code you reference is trying to do the bracketing, starting with the domain upper and lower bounds as initial guesses.  &lt;/p&gt;

&lt;p&gt;Remember to consider convergence problems when the actual parameter to inverse cum is close to or exactly equal to 0 or 1.  Per the comment in the code above the test that uses (or should use) the function value absolute accuracy, if the distribution has bounded support and the argument is 0 or 1, bracketing will fail.&lt;/p&gt;
</comment>
                            <comment id="13145718" author="celestin" created="Mon, 7 Nov 2011 19:18:01 +0000"  >&lt;blockquote&gt;
&lt;p&gt;I don&apos;t think any of the currently implemented real distributions have this problem. Correct?&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Maybe I misunderstood, but in &lt;a href=&quot;https://issues.apache.org/jira/browse/MATH-692&quot; title=&quot;Cumulative probability and inverse cumulative probability inconsistencies&quot; class=&quot;issue-link&quot; data-issue-key=&quot;MATH-692&quot;&gt;&lt;del&gt;MATH-692&lt;/del&gt;&lt;/a&gt; asked for a more precise definition of &lt;tt&gt;inverseCumulativeProbability&lt;/tt&gt; as inf&lt;/p&gt;
{x in R | P(X&amp;lt;=x) &amp;gt;= p}
&lt;p&gt;. If we exclude distribution with plateaus, I think that the current implementation is  satisfactory (but for the use of the wrong tolerance I&apos;ve already pointed out). But it was agreed that this implementation should be made more robust. So what was it exactly that needed improvement? What do you want me to do on this method?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;They are initial guesses for where to start when trying to bracket a root. That means they have to be values that can be fed into the cumulative probability function.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I&apos;m aware of that, but the current solver does fail when &lt;tt&gt;inverseCumulativeProbability(0)&lt;/tt&gt; should return -inf, or &lt;tt&gt;inverseCumulativeProbability(1)&lt;/tt&gt; should return +inf. See for example the implementation of &lt;tt&gt;NormalDistributionImpl&lt;/tt&gt;.&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;    &lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;double&lt;/span&gt; inverseCumulativeProbability(&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;double&lt;/span&gt; p)
     {
        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (p == 0) {
            &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Double&lt;/span&gt;.NEGATIVE_INFINITY;
        }
        &lt;span class=&quot;code-keyword&quot;&gt;if&lt;/span&gt; (p == 1) {
            &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Double&lt;/span&gt;.POSITIVE_INFINITY;
        }
        &lt;span class=&quot;code-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-keyword&quot;&gt;super&lt;/span&gt;.inverseCumulativeProbability(p);
    }
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;So currently, people who want to implement a distribution must be aware of the fact that the default implementation of &lt;tt&gt;inverseCumulativeProbability&lt;/tt&gt; &lt;b&gt;must&lt;/b&gt; be overriden. This rather unusual fact should be made clear in the Javadoc, unless a workaround can be thought of. I agree the one I proposed was far from perfect.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Remember to consider convergence problems when the actual parameter to inverse cum is close to or exactly equal to 0 or 1.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Thank you for pointing this out earlier. I do keep this important point in mind. But again, if we do not widen the scope of this method, I don&apos;t see what is required of me (appart from some cosmetic alterations to the Javadoc).&lt;/p&gt;</comment>
                            <comment id="13146060" author="psteitz" created="Tue, 8 Nov 2011 03:22:50 +0000"  >&lt;p&gt;I am sorry, Sebastien.  I am not being very helpful here. As I dig deeper into the code and archaeology, I am having a hard time seeing how we can really improve the default impl without knowledge of the underlying distribution.  I agree with you that we should clearly document its limitations, though, and fix the javadoc contracts everywhere to be correct and consistent.  The default impl was never really intended to be universal - just a simple solver-based impl that would work for well-behaved distributions. The normal distribution example above points to a slight improvement that could now be done.  When that code was written, we had yet to define the supportLowerBound and supportUpperBound properties.  Now that we have those, the test in the normal dist case could be moved up into the default impl, using the getters on the distribution for the return values.&lt;/p&gt;

&lt;p&gt;By all means if you can find a way to deal with plateaus or otherwise improve robustness of the default impl, go for it.  In particular, if you can come up with a better way to set up the solver, possibly eliminating the domainLower/upperBound methods, that would be great.  It has always seemed a little ugly to me that we had to implement these methods for every distribution just so we could get initial guesses for the inverse cum solver.&lt;/p&gt;

</comment>
                            <comment id="13146108" author="celestin" created="Tue, 8 Nov 2011 06:54:41 +0000"  >&lt;p&gt;I agree with you: however careful we are, the default implementation will never be perfect, and it should be clearly stated in the javadoc. I see (but haven&apos;t dug into it yet) there is an abstract test for continuous distributions. I&apos;ll try and make sure that most possible cases of failure of &lt;tt&gt;inverseCumulativeProbability&lt;/tt&gt; are tested in this abstract framework, so that users could be &lt;b&gt;strongly&lt;/b&gt; encouraged to implement this test for their very specific distribution.&lt;/p&gt;

&lt;p&gt;I do think we can widen a little bit the scope of the default implementation. I actually worked towards eliminating the bracketing step, but you convinced me that it should be the other way round: can we eliminate the domainLower/upperBound methods (which I agree are very efficient, but a little bit of a pain in the neck...).&lt;/p&gt;

&lt;p&gt;Here is an idea I&apos;m going to check (keeping in mind the accuracy issues you&apos;ve already pointed at)&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;for distributions with bounded support: maybe the bounds (possibly shifted if the bounds are not inclusive) of the support itself could be used as an initial bracketting range.&lt;/li&gt;
	&lt;li&gt;for distributions with unbounded support: start from &lt;b&gt;any&lt;/b&gt; (? or a better guess? average value?) point in the support, and do bracketting. However, I do agree with Christian, we should use geometric progressions in this case, instead of arithmetic progressions. This would probably lead to a very large interval, but it would provide us an interval more quickly, and the solver itself would probably be quite good at narrowing it very quickly. I can try some monitoring on this issue.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;As for plateaus, I think what I&apos;m currently working on is not too inefficient. I&apos;m sure it&apos;s not &lt;b&gt;the&lt;/b&gt; answer (which is, anyway, 42 &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;), but I&apos;m struggling to fail this algo... Don&apos;t worry, I&apos;ll break it. I think that what I&apos;ve done entails very little additional cost (maybe one more evaluation of cumulativeProbability) for distributions &lt;b&gt;without&lt;/b&gt; plateau, but I need to check that (we do not want to pay a heavy price for plateaus, since most of our distributions do not have one, as you rightly pointed out).&lt;/p&gt;

&lt;p&gt;I would be grateful for any idea on these topics, and will keep you informed. All the best for now,&lt;br/&gt;
S&#233;bastien&lt;/p&gt;</comment>
                            <comment id="13146614" author="cwinter" created="Tue, 8 Nov 2011 22:38:17 +0000"  >&lt;p&gt;Much discussion has happened here in the recent days. Thanks!&lt;/p&gt;

&lt;p&gt;Now I realize that it is hard to get rid of the bracketing step in the case of unbounded support. I guess a default bracket of &lt;tt&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;-Double.MAX_VALUE;+Double.MAX_VALUE&amp;#93;&lt;/span&gt;&lt;/tt&gt; for  &lt;tt&gt;0&amp;lt;p&amp;lt;1&lt;/tt&gt; isn&apos;t a good idea for such cases. Maybe we can move the bracketing step into a &lt;tt&gt;getBracket(double p)&lt;/tt&gt; method (only &lt;tt&gt;0&amp;lt;p&amp;lt;1&lt;/tt&gt; needs to be handled), which makes use of the support bounds where possible and performs an bracketing algorithm only as last option. For specific distributions this method can be overridden by providing brackets through precomputed cdf-values or clever estimations, which removes using an bracketing algorithm at all. Such a method allows to delete &lt;tt&gt;getDomainLowerBound&lt;/tt&gt;/&lt;tt&gt;getDomainUpperBound&lt;/tt&gt;/&lt;tt&gt;getInitialDomain&lt;/tt&gt;. However, this replacement doesn&apos;t remove the pain caused by &lt;tt&gt;getDomainLowerBound&lt;/tt&gt;/&lt;tt&gt;getDomainUpperBound&lt;/tt&gt;/&lt;tt&gt;getInitialDomain&lt;/tt&gt; completely. It is just a little mitigation to this pain as &lt;tt&gt;getBracket&lt;/tt&gt; doesn&apos;t have to be overridden (though it should be overridden to increase performance unless &lt;tt&gt;inverseCumulativeProbability&lt;/tt&gt; is overridden entirely).&lt;/p&gt;

&lt;p&gt;For the plateau issue I unfortunately don&apos;t see a way to avoid implementing a modified solver so that it approximates the solution by moving together &lt;tt&gt;x0&lt;/tt&gt; and &lt;tt&gt;x1&lt;/tt&gt; satisfying &lt;tt&gt;P(X&amp;lt;=x0) &amp;lt; p&lt;/tt&gt; and &lt;tt&gt;P(X&amp;lt;=x1) &amp;gt;= p&lt;/tt&gt;.&lt;/p&gt;</comment>
                            <comment id="13146627" author="cwinter" created="Tue, 8 Nov 2011 22:56:15 +0000"  >&lt;p&gt;A different idea for solving the bracketing issue: We could solve the inverse cdf calculation by transforming the domain &lt;span class=&quot;error&quot;&gt;&amp;#91;-&amp;infin;;+&amp;infin;&amp;#93;&lt;/span&gt; to &lt;span class=&quot;error&quot;&gt;&amp;#91;-1;+1&amp;#93;&lt;/span&gt; with arctan. More precisely, we could do the first iterations of the solving step on the transformed domain, and we can go back to original domain as soon as +/-1 aren&apos;t interval limits any more.&lt;/p&gt;</comment>
                            <comment id="13146739" author="psteitz" created="Wed, 9 Nov 2011 03:06:02 +0000"  >&lt;p&gt;Interesting idea.  Worth playing with.  One more archaeological fact that occurred to me is that the current setup with domain upper / lower bounds used in bracketing was developed before we required either mean or variance from distributions.  We now have getNumericalMean and getNumericalVariance.  When these both exist and are finite, inequalities such as Chebyshev&apos;s might be useful in setting up brackets.&lt;/p&gt;</comment>
                            <comment id="13146814" author="celestin" created="Wed, 9 Nov 2011 06:54:43 +0000"  >&lt;blockquote&gt;
&lt;p&gt;A different idea for solving the bracketing issue: We could solve the inverse cdf calculation by transforming the domain &lt;span class=&quot;error&quot;&gt;&amp;#91;-&#8734;;+&#8734;&amp;#93;&lt;/span&gt; to &lt;span class=&quot;error&quot;&gt;&amp;#91;-1;+1&amp;#93;&lt;/span&gt; with arctan. More precisely, we could do the first iterations of the solving step on the transformed domain, and we can go back to original domain as soon as +/-1 aren&apos;t interval limits any more.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Is it not a &quot;disguised&quot; bracketting step, with a somewhat more clever way of sampling the reals (as opposed to arithmetic progression)? In this case, maybe it would be just as simple to perform a bracketting step, with &lt;b&gt;geometric&lt;/b&gt; progression (as proposed by Christian), when one of the bounds of the support is not finite.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;only 0&amp;lt;p&amp;lt;1 needs to be handled&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I guess you mean by that that what should be done is&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;return &lt;tt&gt;getSupportLowerBound()&lt;/tt&gt; when &lt;tt&gt;p == 0&lt;/tt&gt;,&lt;/li&gt;
	&lt;li&gt;return &lt;tt&gt;getSupportUpperBound()&lt;/tt&gt; when &lt;tt&gt;p == 1&lt;/tt&gt;.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;This means that the contract of &lt;tt&gt;getSupportLowerBound()&lt;/tt&gt;/&lt;tt&gt;getSupportUpperBound()&lt;/tt&gt; &lt;b&gt;requires&lt;/b&gt; that the returned values are actually the &lt;b&gt;best&lt;/b&gt; bounds on the support. While I have no problem with this sound requirement, I don&apos;t think this is currently stated clearly in the Javadoc, but I&apos;m no native english speaker...&lt;/p&gt;</comment>
                            <comment id="13147315" author="cwinter" created="Wed, 9 Nov 2011 21:40:34 +0000"  >&lt;p&gt;The Javadoc of &lt;tt&gt;getSupportLowerBound()&lt;/tt&gt;/&lt;tt&gt;getSupportUpperBound()&lt;/tt&gt; in fact needs to be sharpened. I didn&apos;t see this before. If I didn&apos;t overlook anything, all current implementations already return the best bounds.&lt;/p&gt;

&lt;p&gt;Regarding the bracketing issue there are now several ideas (thanks for the Chebyshev idea, Phil). But I don&apos;t have a preference for a particular solution which can be built from these ideas. Thus, S&#233;bastien, just choose a strategy which you consider to be beneficial.&lt;/p&gt;</comment>
                            <comment id="13154924" author="celestin" created="Tue, 22 Nov 2011 07:33:05 +0000"  >&lt;p&gt;Hi,&lt;br/&gt;
please find attached a proposal for a new implementation of &lt;tt&gt;inverseCumulativeDistribution&lt;/tt&gt;. For the time being, this new implementation is implemented as a static (utility) class, as I would like you to check the logics before committing it.&lt;br/&gt;
Highlights are&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;use of Chebyshev&apos;s inequality (thanks Phil) to bracket the root&lt;/li&gt;
	&lt;li&gt;in cases where the random variable has no mean or no variance, and is not compactly supported, the method falls back to geometric bracketing, instead of arithmetic bracketing.&lt;/li&gt;
	&lt;li&gt;removal of calls to &lt;tt&gt;getDomainLowerBound(p)&lt;/tt&gt;, &lt;tt&gt;getDomainUpperBound(p)&lt;/tt&gt;, &lt;tt&gt;getInitialDomain(p)&lt;/tt&gt;.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;The attached class has a main() method which runs some performance checks (new impl vs old impl). The report on my machine (Intel Core i5 M540 @2.53GHz, 4Go RAM) tends to indicate that the new implementation is slightly quicker than the old one.&lt;/p&gt;

&lt;p&gt;Commented out is also a plateau detection which proves fairly robust (although I&apos;m sure we can fail it), but induces a slight decrease of the overall performances. I&apos;m just wondering if we should set a flag in the constructor, to indicate whether or not plateaux should be detected ? Alternatively, we could remove plateau detection altogether, and clearly state in the javadoc that the default impl &lt;b&gt;fails&lt;/b&gt; with plateaux.&lt;/p&gt;

&lt;p&gt;Looking forward to reading your comments,&lt;br/&gt;
S&#233;bastien&lt;/p&gt;</comment>
                            <comment id="13156897" author="cwinter" created="Thu, 24 Nov 2011 20:48:35 +0000"  >&lt;p&gt;Thanks for the patch, S&#233;bastien.&lt;br/&gt;
There is no need for a plateaux detection flag in the constructor. While dealing with the distribution classes and interfaces, I saw the method isSupportConnected(). This method will tell whether plateaux might occur because a plateau in the cdf corresponds to a gap in the support.&lt;/p&gt;</comment>
                            <comment id="13157310" author="psteitz" created="Fri, 25 Nov 2011 21:43:01 +0000"  >&lt;p&gt;Wow, we can really improve the code when we put our heads together &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Great observation by Christian - we can switch on plateau detection iff isSupportConnected is false.  Otherwise, I would say the &quot;new&quot; implementation is good to go.  I would also be happy to celebrate dropping all of the getXxx(p) methods, which are not needed any more.&lt;/p&gt;

&lt;p&gt;We can all thank Mikkel, btw, for suggesting a while back that we add the numerical mean, variance and connected support properties.  Came in very handy here!&lt;/p&gt;</comment>
                            <comment id="13157369" author="celestin" created="Sat, 26 Nov 2011 05:18:03 +0000"  >&lt;blockquote&gt;
&lt;p&gt;Great observation by Christian - we can switch on plateau detection iff isSupportConnected is false. Otherwise, I would say the &quot;new&quot; implementation is good to go.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Yes, it is indeed a very neat way to proceed. I&apos;ll make the changes once Christian&apos;s patch for &lt;a href=&quot;https://issues.apache.org/jira/browse/MATH-703&quot; title=&quot;Splitting up the distribution hierarchy&quot; class=&quot;issue-link&quot; data-issue-key=&quot;MATH-703&quot;&gt;&lt;del&gt;MATH-703&lt;/del&gt;&lt;/a&gt; is committed.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I would also be happy to celebrate dropping all of the getXxx(p) methods, which are not needed any more.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Good! So I do not need to post on the mailing list on this issue?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We can all thank Mikkel, btw, for suggesting a while back that we add the numerical mean, variance and connected support properties. Came in very handy here!&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;I would also thank the guy who suggested Chebyshev&apos;s inequality (I wonder who that is &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/wink.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;). Overall, I personnally enjoyed working on this issue, as it truly was team work.&lt;br/&gt;
S&#233;bastien&lt;/p&gt;</comment>
                            <comment id="13162169" author="celestin" created="Sat, 3 Dec 2011 16:28:12 +0000"  >&lt;p&gt;New implementation (+ unit tests) committed in &lt;tt&gt;r1209942&lt;/tt&gt;. &lt;tt&gt;getDomainLowerBound(double)&lt;/tt&gt;, &lt;tt&gt;getDomainUpperBound(double)&lt;/tt&gt; and &lt;tt&gt;getInitialDomain(double p)&lt;/tt&gt; have now become superfluous: removed in &lt;tt&gt;r1209963&lt;/tt&gt;.&lt;/p&gt;

&lt;p&gt;The same kind of approach might probably be adopted for &lt;tt&gt;IntegerDistribution&lt;/tt&gt;. I suggest we look into it before we resolve this issue.&lt;/p&gt;</comment>
                            <comment id="13162458" author="cwinter" created="Sun, 4 Dec 2011 20:14:46 +0000"  >&lt;p&gt;Yes, we can get rid of &lt;tt&gt;IntegerDistribution.getDomainLowerBound(double)&lt;/tt&gt; and &lt;tt&gt;IntegerDistribution.getDomainUpperBound(double)&lt;/tt&gt;. I will do this in the reimplementation of &lt;tt&gt;IntegerDistribution.inverseCumulativeProbability(double)&lt;/tt&gt; based on &lt;a href=&quot;https://issues.apache.org/jira/browse/MATH-692&quot; title=&quot;Cumulative probability and inverse cumulative probability inconsistencies&quot; class=&quot;issue-link&quot; data-issue-key=&quot;MATH-692&quot;&gt;&lt;del&gt;MATH-692&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Using Chebyshev&apos;s inequality also can be adopted. But a plateau detection step is not needed there because &lt;tt&gt;IntegerDistribution&lt;/tt&gt; requires its own solver for finding the inverse cumulative probability anyway. Thus this solver can apply the correct inequalities for finding the &quot;right&quot; quantile automatically. (Using the &quot;correct&quot; inequalies for the solver in &lt;tt&gt;RealDistribution&lt;/tt&gt; wasn&apos;t an option because an existing general purpose solver is utilized there.)&lt;/p&gt;</comment>
                            <comment id="13162638" author="celestin" created="Mon, 5 Dec 2011 06:50:36 +0000"  >&lt;p&gt;Thanks Christian for your help: this issue can therefore be considered as &quot;solved&quot;.&lt;/p&gt;</comment>
                            <comment id="13163297" author="celestin" created="Tue, 6 Dec 2011 02:59:13 +0000"  >&lt;p&gt;I&apos;ve realized that boundary cases (&lt;tt&gt;p == 0&lt;/tt&gt; and &lt;tt&gt;p == 1&lt;/tt&gt;) are now handled correctly: concrete instances of &lt;tt&gt;AbstractRealDistribution&lt;/tt&gt; no longer need to override this method, which are removed in rev &lt;tt&gt;1210756&lt;/tt&gt;.&lt;/p&gt;</comment>
                            <comment id="13232231" author="celestin" created="Sun, 18 Mar 2012 09:27:52 +0000"  >&lt;p&gt;Fixed in 3.0.&lt;/p&gt;</comment>
                    </comments>
                <issuelinks>
                            <issuelinktype id="10030">
                    <name>Reference</name>
                                            <outwardlinks description="relates to">
                                        <issuelink>
            <issuekey id="13411675">STATISTICS-48</issuekey>
        </issuelink>
                            </outwardlinks>
                                                                <inwardlinks description="is related to">
                                        <issuelink>
            <issuekey id="13414643">MATH-1636</issuekey>
        </issuelink>
                            </inwardlinks>
                                    </issuelinktype>
                    </issuelinks>
                <attachments>
                            <attachment id="12501747" name="AbstractContinuousDistributionTest.java" size="2936" author="celestin" created="Tue, 1 Nov 2011 08:36:50 +0000"/>
                            <attachment id="12504710" name="inv-cum-new-impl.zip" size="31792" author="celestin" created="Tue, 22 Nov 2011 07:33:05 +0000"/>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>2.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>215489</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            13 years, 35 weeks, 6 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i0aotr:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>60295</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </customfields>
    </item>
</channel>
</rss>