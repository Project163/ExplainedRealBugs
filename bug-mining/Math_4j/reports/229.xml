<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Sat Nov 08 20:27:11 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[MATH-632] NaN: Method &quot;equals&quot; in Complex not consistent with &quot;==&quot; for &quot;double&quot; primitive type</title>
                <link>https://issues.apache.org/jira/browse/MATH-632</link>
                <project id="12310485" key="MATH">Commons Math</project>
                    <description>&lt;p&gt;The following tests show several contradictions:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;double&lt;/span&gt; a = &lt;span class=&quot;code-object&quot;&gt;Double&lt;/span&gt;.NaN;
&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;double&lt;/span&gt; b = &lt;span class=&quot;code-object&quot;&gt;Double&lt;/span&gt;.NaN;
Assert.assertFalse(&lt;span class=&quot;code-quote&quot;&gt;&quot;a == b&quot;&lt;/span&gt;, a == b); &lt;span class=&quot;code-comment&quot;&gt;// (1)
&lt;/span&gt;Assert.assertEquals(&lt;span class=&quot;code-quote&quot;&gt;&quot;a != b&quot;&lt;/span&gt;, a, b, &lt;span class=&quot;code-object&quot;&gt;Double&lt;/span&gt;.MIN_VALUE); &lt;span class=&quot;code-comment&quot;&gt;// (2)
&lt;/span&gt;Assert.assertFalse(&lt;span class=&quot;code-quote&quot;&gt;&quot;a == b&quot;&lt;/span&gt;, MathUtils.equals(a, b, &lt;span class=&quot;code-object&quot;&gt;Double&lt;/span&gt;.MIN_VALUE)); &lt;span class=&quot;code-comment&quot;&gt;// (3)
&lt;/span&gt;Assert.assertFalse(&lt;span class=&quot;code-quote&quot;&gt;&quot;a == b&quot;&lt;/span&gt;, MathUtils.equals(a, b, &lt;span class=&quot;code-object&quot;&gt;Double&lt;/span&gt;.MIN_VALUE)); &lt;span class=&quot;code-comment&quot;&gt;// (4)
&lt;/span&gt;&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Double&lt;/span&gt; dA = &lt;span class=&quot;code-object&quot;&gt;Double&lt;/span&gt;.valueOf(a);
&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Double&lt;/span&gt; dB = &lt;span class=&quot;code-object&quot;&gt;Double&lt;/span&gt;.valueOf(b);
Assert.assertFalse(&lt;span class=&quot;code-quote&quot;&gt;&quot;dA == dB&quot;&lt;/span&gt;, dA.doubleValue() == dB.doubleValue()); &lt;span class=&quot;code-comment&quot;&gt;// (5)
&lt;/span&gt;Assert.assertTrue(&lt;span class=&quot;code-quote&quot;&gt;&quot;!dA.equals(dB)&quot;&lt;/span&gt;, dA.equals(dB)); &lt;span class=&quot;code-comment&quot;&gt;// (6)
&lt;/span&gt;&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; Complex cA = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Complex(a, 0);
&lt;span class=&quot;code-keyword&quot;&gt;final&lt;/span&gt; Complex cB = &lt;span class=&quot;code-keyword&quot;&gt;new&lt;/span&gt; Complex(b, 0);
Assert.assertTrue(&lt;span class=&quot;code-quote&quot;&gt;&quot;!cA.equals(cB)&quot;&lt;/span&gt;, cA.equals(cB));  &lt;span class=&quot;code-comment&quot;&gt;// (7)&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;They all pass; thus:&lt;/p&gt;
&lt;ol&gt;
	&lt;li&gt;&quot;Double&quot; does not behave as &quot;double&quot;: (1) and (5) vs (6)&lt;/li&gt;
	&lt;li&gt;Two NaNs are almost equal for Junit: (2)&lt;/li&gt;
	&lt;li&gt;Two NaNs are never equal for MathUtils: (3) and (4)&lt;/li&gt;
	&lt;li&gt;Complex.NaN is consistent with Object &quot;Double.valueOf(NaN)&quot; (hence not with primitive &quot;Double.NaN&quot;): (7)&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;This is quite confusing.&lt;/p&gt;

&lt;p&gt;In MathUtils, we chose to follow IEEE754 (and Java for primitive &quot;double&quot;), i.e. it is &quot;correct&quot; that assertion (1) is false. Do we want &quot;Complex&quot; to conform with this or with the inconsistent behaviour of &quot;Double&quot;?&lt;/p&gt;</description>
                <environment></environment>
        <key id="12515203">MATH-632</key>
            <summary>NaN: Method &quot;equals&quot; in Complex not consistent with &quot;==&quot; for &quot;double&quot; primitive type</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.svg">Minor</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="8">Not A Problem</resolution>
                                        <assignee username="-1">Unassigned</assignee>
                                    <reporter username="erans">Gilles Sadowski</reporter>
                        <labels>
                    </labels>
                <created>Sun, 24 Jul 2011 21:36:39 +0000</created>
                <updated>Sat, 24 Mar 2012 16:22:53 +0000</updated>
                            <resolved>Fri, 5 Aug 2011 22:08:40 +0000</resolved>
                                                    <fixVersion>3.0</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>0</watches>
                                                                                                                <comments>
                            <comment id="13070262" author="erans" created="Sun, 24 Jul 2011 21:44:02 +0000"  >&lt;p&gt;Tests committed in revision 1150496.&lt;/p&gt;</comment>
                            <comment id="13070265" author="psteitz" created="Sun, 24 Jul 2011 22:11:25 +0000"  >&lt;p&gt;Can anyone present a practical argument for changing the current documented behavior of Complex.equals?  There is no perfect solution here, given the way equals is defined for doubles in Java.  The current behavior is simple, well-documented and has been defined this way since version 1.0.  Changing it may break some code that depends on it, so we need to have good practical reasons to change. &lt;/p&gt;

&lt;p&gt;From my perspective, the current implementation of Complex equals, which is consistent with what we also do for ArrayRealVectors, is natural and convenient.  I don&apos;t see the examples as particularly relevant, since a Complex instance is not a pair of doubles, but an object that has two double-valued attributes. Once a Complex number has a NaN part, it is for all practical purposes NaN, so it makes sense to lump all instances with NaN parts into one equivalence class modulo equals.  IIRC, this was the rationale used to define the current implementation of Complex equals.   &lt;/p&gt;</comment>
                            <comment id="13070358" author="luc" created="Mon, 25 Jul 2011 08:04:18 +0000"  >&lt;p&gt;I have tried to find again some external references from C++ standard and C99 standard. They seem to only specify behavior of == as a logical (a.real == b.real) &amp;amp;&amp;amp; (a.imaginary == b.imaginary), which would lead to numbers with NaN never been equal to anything, including themselves.&lt;/p&gt;

&lt;p&gt;We don&apos;t use complex internally in &lt;span class=&quot;error&quot;&gt;&amp;#91;math&amp;#93;&lt;/span&gt; yet (at least I am not aware of it). However, some existing users do (at least Arne seems to, as he asked for several changes). Perhaps we should ask on the users list (not dev) for users comments on this, as most users will not be aware of this Jira issue here.&lt;/p&gt;

&lt;p&gt;We may need to use complex in &lt;span class=&quot;error&quot;&gt;&amp;#91;math&amp;#93;&lt;/span&gt; by ourselves for some algorithms we want to implement. I see at least to difference use cases: eigen value decomposition for non-symmetric matrices and root solvers. Do they use some standard definition ?&lt;/p&gt;</comment>
                            <comment id="13070737" author="erans" created="Mon, 25 Jul 2011 20:28:00 +0000"  >&lt;p&gt;The problem starts here:&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt; (x == x) is true, except when (x == NaN)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Some people advocate that this should not be so, i.e.&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt; (x == x) is true, always
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;but IEEE574 has chosen the former. And Java primitive &quot;double&quot; conforms to this.&lt;br/&gt;
I don&apos;t understand the rationale of having decided that &quot;Double&quot; should behave differently than &quot;double&quot;, but this is beyond our reach anyway &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;. But, &lt;em&gt;if&lt;/em&gt; you&apos;d have to define &quot;equals&quot; for &quot;Double&quot; wouldn&apos;t you check the equality of the &quot;double&quot; returned by &quot;doubleValue()&quot;? In the example reported by Luc, this is done similarly and two complex NaNs won&apos;t be equal.&lt;/p&gt;

&lt;p&gt;What bothers me, slightly &lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt;, is that CM is not consistent with itself: A &quot;Complex&quot; instance is an abstraction/approximation of a complex number, in the same way that a &quot;double&quot; is an abstraction/approximation of a real number. So why would you consider that&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt; it makes sense to lump all instances with NaN parts into one equivalence class modulo equals.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;and at the same time that CM should also follow IEEE754 for &quot;double&quot; (cf. &quot;MathUtils.equals&quot;), which is the opposite of the previous statement?&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;1&amp;#93;&lt;/span&gt; Personally, I never had to use NaN beyond being a signal that there was a bug in my code.&lt;/p&gt;</comment>
                            <comment id="13070746" author="psteitz" created="Mon, 25 Jul 2011 20:44:21 +0000"  >&lt;p&gt;The difference between Double and double, and Complex vs double is that the things with capital letters are &lt;b&gt;objects&lt;/b&gt;.  Jave &lt;b&gt;had&lt;/b&gt; to define Double equals to make NaN equal to NaN because equals has to be an equivalence relation, which means it has to be reflexive.  Personally, I don&apos;t see any problem with Complex equals behaving differently from what we now have in MathUtils.equals, which is a specialized method not intended to represent an equivalence relation on objects.  If we did for some reason define our own &quot;real&quot; object, I would expect it to behave as Double does - making NaN equal to itself.  The only reasonable alternative to the current implementation of Complex equals (and ArrayRealVector equals, for that matter) is to isolate every NaN-infected instance into its own equivalence class.  That is less convenient when dealing with collections of results.  Note that, like Double, we will still in any case have to make equals reflexive, which will make it appear &quot;inconsistent&quot; with the (in my mind irrelevant) examples above.&lt;/p&gt;</comment>
                            <comment id="13070770" author="erans" created="Mon, 25 Jul 2011 21:24:50 +0000"  >&lt;blockquote&gt;
&lt;p&gt;&lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt; equals has to be an equivalence relation &lt;span class=&quot;error&quot;&gt;&amp;#91;...&amp;#93;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;&quot;==&quot; &lt;em&gt;is&lt;/em&gt; an equivalence relation for real numbers. Nevertheless the IEEE574 deemed it important that it is broken when the floating point representation of a real number is NaN (which is not the representation of any real number).&lt;br/&gt;
IIUC correctly (and probably very partially), NaNs are supposedly useful in the implementations of algorithms (which is what CM does).&lt;/p&gt;

&lt;p&gt;The difference between &quot;Object&quot; and primitive is not relevant for deciding which is more important:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;The purpose of NaNs and conformance with a standard for the representation of real numbers, or&lt;/li&gt;
	&lt;li&gt;the equivalence relation of the representations of real numbers (&quot;Double&quot;, &quot;double&quot;, &quot;Complex&quot;).&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;To view it differently: &quot;double&quot; would/should not have existed in Java (as an OO language) if it had been possible to deal exclusively with objects without a significant loss of performance. CM uses (almost?) exclusively &quot;double&quot; and not &quot;Double&quot;; so I think that it makes sense to ask whether or not &quot;Complex&quot; should be consistent with &quot;double&quot; (making the examples quite relevant).&lt;/p&gt;

&lt;p&gt;I don&apos;t understand how collections interfere with this issue...&lt;/p&gt;</comment>
                            <comment id="13071329" author="psteitz" created="Tue, 26 Jul 2011 20:13:45 +0000"  >&lt;p&gt;Complex is an object, so has to have an equals implementation that is reflexive, symmetric and transitive.  Do you have an alternative implementation in mind?  And an explanation of why the alternative is better?&lt;/p&gt;

&lt;p&gt;My reference to collections comes from my own use in simulating complex dynamical systems.  Like floating point equals comparisons among doubles, I don&apos;t use Complex.equals much, and when I do it is either in test code or comparing results of divergent processes.  When processes diverge, it is convenient to be able to compare results wrt infinities and NaNs.  In that case, it is convenient to have equals return true for NaNs.&lt;/p&gt;</comment>
                            <comment id="13071390" author="erans" created="Tue, 26 Jul 2011 22:17:14 +0000"  >&lt;p&gt;The alternative implementation was reported by Luc from the C++ standard:&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;  (a.real == b.real) &amp;amp;&amp;amp; (a.imaginary == b.imaginary)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;It is better simply because it is consistent with whatever is defined by the constituents of the complex number.&lt;/p&gt;

&lt;p&gt;As I said, I don&apos;t really care whether NaN == NaN or NaN != NaN. But, I repeat, I&apos;m not knowledgeable enough in floating point intricacies to say that the standard is wrong or useless. Are you?&lt;/p&gt;

&lt;p&gt;Maybe we shouldn&apos;t care about IEEE574, and decide to ban any algorithm that would rely on NaN != NaN. And in that case, to be consistent, I would also propose to change &quot;MathUtils.equals&quot; so that it treats two NaNs as equal (and do away with the &quot;equalsIncludingNaN&quot; methods).&lt;/p&gt;

&lt;p&gt;Some time ago, we decided to conform with IEEE754; but if it is more convenient to not conform and if it doesn&apos;t hurt anyone...&lt;/p&gt;</comment>
                            <comment id="13071396" author="psteitz" created="Tue, 26 Jul 2011 22:30:27 +0000"  >&lt;p&gt;The definition above is not reflexive, so can&apos;t be implemented as equals in Java.  We would have to add a reference equality check to make it a legitimate equals implementation, making every NaN-infected instance an equals singleton.  Unless someone can provide a practical reason why this is better in applications, we should not change it, since it will break any applications that depend on the current implementation.&lt;/p&gt;</comment>
                            <comment id="13071455" author="psteitz" created="Wed, 27 Jul 2011 00:28:22 +0000"  >&lt;p&gt;I forgot about a couple of things that we considered in relation to this in the past.  The first is the status of the relevant &quot;spec,&quot; which is Annex G of the C99x spec for the C language.  We decided not to try to strictly adhere to this spec for reasons documented in &lt;a href=&quot;https://issues.apache.org/jira/browse/MATH-5&quot; title=&quot;[math] Complex arithmetic operations do not conform to C99x Annex G&quot; class=&quot;issue-link&quot; data-issue-key=&quot;MATH-5&quot;&gt;&lt;del&gt;MATH-5&lt;/del&gt;&lt;/a&gt;: a) it is a C language spec b) it is not open or freely available (we could not even get blanket approval to quote from the spec in our javadoc) c) when we last checked it was still not normative and d) trying to adhere strictly to the spec for arithmetic operations would kill performance.  Search the commons-dev archives for discussion.&lt;/p&gt;

&lt;p&gt;The second thing I forgot is that in this and some other decisions, we were influenced by Colt (the old com.imsl.math package), which took a practical approach.  The javadoc for equals in Colt&apos;s Complex (implemented the same way we do) points out that implementing equals this way makes Complex instances work correctly in hashtables.  This is another reason that we used the definition that we did.&lt;/p&gt;</comment>
                            <comment id="13071620" author="sebb@apache.org" created="Wed, 27 Jul 2011 09:27:13 +0000"  >&lt;p&gt;For future reference, we should mention these design decisions in the code comments.&lt;/p&gt;</comment>
                            <comment id="13071626" author="erans" created="Wed, 27 Jul 2011 09:43:39 +0000"  >&lt;blockquote&gt;
&lt;p&gt;The javadoc for equals in Colt&apos;s Complex (implemented the same way we do) points out that implementing equals this way makes Complex instances work correctly in hashtables.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Actually they probably copied the similar comment from &lt;a href=&quot;http://download.oracle.com/javase/6/docs/api/java/lang/Double.html#equals(java.lang.Object)&quot; class=&quot;external-link&quot; target=&quot;_blank&quot; rel=&quot;nofollow noopener&quot;&gt;here&lt;/a&gt;. &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;I&apos;m convinced that the ambiguity (Object/primitive) cannot be lifted, and I probably should not worry anymore that CM is not more consistent than Java itself...&lt;/p&gt;

&lt;p&gt;As Sebb mentions, one should not search the archive to get an explanation for such seemingly contradictory behaviour. It suffices to say that we follow IEEE754 for &quot;MathUtils.equals&quot; and that we don&apos;t for &lt;em&gt;any&lt;/em&gt; &quot;Object&quot; even though it would represent a (tuplet of) real numbers, on a par with what Java does.&lt;/p&gt;</comment>
                            <comment id="13080258" author="erans" created="Fri, 5 Aug 2011 22:08:40 +0000"  >&lt;p&gt;Clarifying note added in revision 1154392.&lt;/p&gt;</comment>
                            <comment id="13237592" author="luc" created="Sat, 24 Mar 2012 16:22:53 +0000"  >&lt;p&gt;changing status to closed as 3.0 has been released&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>65967</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            13 years, 35 weeks ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i0rtin:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>160426</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </customfields>
    </item>
</channel>
</rss>