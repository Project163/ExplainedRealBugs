diff --git a/documentation/src/docs/asciidoc/release-notes-5.0.0-M5.adoc b/documentation/src/docs/asciidoc/release-notes-5.0.0-M5.adoc
index 2dbf92d89..9a969f161 100644
--- a/documentation/src/docs/asciidoc/release-notes-5.0.0-M5.adoc
+++ b/documentation/src/docs/asciidoc/release-notes-5.0.0-M5.adoc
@@ -96,6 +96,9 @@ on GitHub.
 * If a `@ParameterizedTest` accepts an array as an argument, the string representation of
   the array will now be converted to a human readable format when generating the display
   name for invocations of the parameterized test.
+* The `@EnumSource` now provides an enum constant selection mode that controls how the names
+  are interpreted. Supported modes are: `INCLUDE_NAMES`, `EXCLUDE_NAMES` as well as regular
+  expression pattern matching modes `MATCHES_ALL` and `MATCHES_ANY`.
 * Extensions may now share state across top-level test classes by using the `Store` of the
   newly introduced engine-level `ExtensionContext`.
 * Argument providing methods referenced using `@MethodSource` may now return instances of
diff --git a/documentation/src/docs/asciidoc/writing-tests.adoc b/documentation/src/docs/asciidoc/writing-tests.adoc
index 8a0878a59..d3ff2cd4c 100644
--- a/documentation/src/docs/asciidoc/writing-tests.adoc
+++ b/documentation/src/docs/asciidoc/writing-tests.adoc
@@ -558,6 +558,25 @@ will be used like in the following example.
 include::{testDir}/example/ParameterizedTestDemo.java[tags=EnumSource_example]
 ----
 
+[source,java,indent=0]
+----
+include::{testDir}/example/ParameterizedTestDemo.java[tags=EnumSource_include_example]
+----
+
+The `@EnumSource` annotation also provides an optional `mode` parameter that lets fine-control
+which constants are passed to the test method. You can for example exclude names from the
+enum constant pool or specify regular expressions:
+
+[source,java,indent=0]
+----
+include::{testDir}/example/ParameterizedTestDemo.java[tags=EnumSource_exclude_example]
+----
+
+[source,java,indent=0]
+----
+include::{testDir}/example/ParameterizedTestDemo.java[tags=EnumSource_regex_example]
+----
+
 [[writing-tests-parameterized-tests-sources-MethodSource]]
 ===== @MethodSource
 
diff --git a/documentation/src/test/java/example/ParameterizedTestDemo.java b/documentation/src/test/java/example/ParameterizedTestDemo.java
index 574de4d31..e63bfb90f 100644
--- a/documentation/src/test/java/example/ParameterizedTestDemo.java
+++ b/documentation/src/test/java/example/ParameterizedTestDemo.java
@@ -13,6 +13,8 @@ package example;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertNotEquals;
 import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.params.provider.EnumSource.Mode.EXCLUDE_NAMES;
+import static org.junit.jupiter.params.provider.EnumSource.Mode.MATCHES_ALL;
 import static org.junit.jupiter.params.provider.ObjectArrayArguments.arguments;
 
 import java.time.LocalDate;
@@ -63,6 +65,30 @@ class ParameterizedTestDemo {
 	}
 	// end::EnumSource_example[]
 
+	// tag::EnumSource_include_example[]
+	@ParameterizedTest
+	@EnumSource(value = TimeUnit.class, names = { "DAYS", "HOURS" })
+	void testWithEnumSourceInclude(TimeUnit timeUnit) {
+		assertNotNull(timeUnit.name());
+	}
+	// end::EnumSource_include_example[]
+
+	// tag::EnumSource_exclude_example[]
+	@ParameterizedTest
+	@EnumSource(value = TimeUnit.class, mode = EXCLUDE_NAMES, names = { "DAYS", "HOURS" })
+	void testWithEnumSourceExclude(TimeUnit timeUnit) {
+		assertNotNull(timeUnit.name());
+	}
+	// end::EnumSource_exclude_example[]
+
+	// tag::EnumSource_regex_example[]
+	@ParameterizedTest
+	@EnumSource(value = TimeUnit.class, mode = MATCHES_ALL, names = "[M|N].+SECONDS")
+	void testWithEnumSourceRegex(TimeUnit timeUnit) {
+		assertNotNull(timeUnit.name());
+	}
+	// end::EnumSource_regex_example[]
+
 	// tag::simple_MethodSource_example[]
 	@ParameterizedTest
 	@MethodSource("stringProvider")
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/EnumArgumentsProvider.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/EnumArgumentsProvider.java
index 5eb2ec699..101503b73 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/EnumArgumentsProvider.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/EnumArgumentsProvider.java
@@ -14,6 +14,7 @@ import static java.util.Arrays.stream;
 import static java.util.stream.Collectors.toSet;
 
 import java.util.Collections;
+import java.util.EnumSet;
 import java.util.Set;
 import java.util.stream.Stream;
 
@@ -24,35 +25,33 @@ import org.junit.platform.commons.util.Preconditions;
 /**
  * @since 5.0
  */
-class EnumArgumentsProvider implements ArgumentsProvider, AnnotationConsumer<EnumSource> {
+class EnumArgumentsProvider<E extends Enum<E>> implements ArgumentsProvider, AnnotationConsumer<EnumSource> {
 
-	private Class<? extends Enum<?>> enumClass;
+	private Class<E> enumClass;
+	private EnumSource.Mode mode;
 	private Set<String> names = Collections.emptySet();
 
 	@Override
-	@SuppressWarnings("rawtypes")
+	@SuppressWarnings("unchecked")
 	public void accept(EnumSource enumSource) {
-		enumClass = enumSource.value();
+		this.enumClass = (Class<E>) enumSource.value();
+		this.mode = enumSource.mode();
+		// only set "names" field if the user provided at least one name
 		if (enumSource.names().length > 0) {
-
-			names = stream(enumSource.names()).collect(toSet());
+			this.names = stream(enumSource.names()).collect(toSet());
 			Preconditions.condition(names.size() == enumSource.names().length,
-				() -> "Duplicate enum constant name(s) found in annotation: " + enumSource);
-
-			Set<String> allSet = stream(enumClass.getEnumConstants()).map(Enum::name).collect(toSet());
-			Preconditions.condition(allSet.containsAll(names),
-				() -> "Invalid enum constant name(s) found in annotation: " + enumSource + ". Valid names include: "
-						+ allSet);
+				() -> "Duplicate enum constant name(s) found in: " + enumSource);
+			mode.validate(enumSource, names);
 		}
 	}
 
 	@Override
 	public Stream<? extends Arguments> provideArguments(ContainerExtensionContext context) {
-		return stream(enumClass.getEnumConstants()).filter(this::select).map(ObjectArrayArguments::arguments);
-	}
-
-	private boolean select(Enum<?> constant) {
-		return names == Collections.EMPTY_SET || names.contains(constant.name());
+		Stream<E> stream = EnumSet.allOf(enumClass).stream();
+		if (names != Collections.EMPTY_SET) {
+			stream = stream.filter(constant -> mode.select(constant, names));
+		}
+		return stream.map(ObjectArrayArguments::arguments);
 	}
 
 }
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/EnumSource.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/EnumSource.java
index 82411874a..7c4d96cae 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/EnumSource.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/EnumSource.java
@@ -10,6 +10,8 @@
 
 package org.junit.jupiter.params.provider;
 
+import static java.util.Arrays.stream;
+import static java.util.stream.Collectors.toSet;
 import static org.junit.platform.commons.meta.API.Usage.Experimental;
 
 import java.lang.annotation.Documented;
@@ -17,8 +19,15 @@ import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
+import java.util.Set;
+import java.util.function.BiConsumer;
+import java.util.function.BiPredicate;
+import java.util.regex.Pattern;
+import java.util.regex.PatternSyntaxException;
 
 import org.junit.platform.commons.meta.API;
+import org.junit.platform.commons.util.PreconditionViolationException;
+import org.junit.platform.commons.util.Preconditions;
 
 /**
  * {@code @EnumSource} is an {@link ArgumentsSource} for constants of a
@@ -43,18 +52,95 @@ public @interface EnumSource {
 
 	/**
 	 * The enum type that serves as the source of the enum constants.
-	 *
-	 * @see #names
 	 */
 	Class<? extends Enum<?>> value();
 
 	/**
-	 * The names of enum constants to provide.
+	 * The names of enum constants to provide or regular expressions.
 	 *
 	 * <p>If no names are specified, all declared enum constants will be provided.
+	*
+	* <p>The {@link Mode} determines how the names are interpreted.
 	 *
-	 * @see #value
+	* @see #mode()
 	 */
 	String[] names() default {};
 
+	/**
+	 * The enum constant selection mode.
+	 *
+	 * <p>Defaults to {@link Mode#INCLUDE_NAMES INCLUDE_NAMES}.
+	 *
+	 * @see #names()
+	 */
+	Mode mode() default Mode.INCLUDE_NAMES;
+
+	/**
+	 * The enum constant selection mode type definition.
+	 */
+	enum Mode {
+
+		/**
+		 * Select only those enum constants which name is listed in the {@linkplain #names} attribute.
+		 */
+		INCLUDE_NAMES(Mode::validateNames, (name, names) -> names.contains(name)),
+
+		/**
+		 * Select all declared enum constants except for those listed in the {@linkplain #names} attribute.
+		 */
+		EXCLUDE_NAMES(Mode::validateNames, (name, names) -> !names.contains(name)),
+
+		/**
+		 * Select only those enum constants which name matches all patterns listed by {@linkplain #names}.
+		*
+		* @see java.util.stream.Stream#allMatch(java.util.function.Predicate)
+		 */
+		MATCHES_ALL(Mode::validatePatterns, (name, patterns) -> patterns.stream().allMatch(name::matches)),
+
+		/**
+		 * Select only those enum constants which name matches any pattern listed by {@linkplain #names}.
+		 *
+		 * @see java.util.stream.Stream#anyMatch(java.util.function.Predicate)
+		 */
+		MATCHES_ANY(Mode::validatePatterns, (name, patterns) -> patterns.stream().anyMatch(name::matches));
+
+		final BiConsumer<EnumSource, Set<String>> validator;
+		final BiPredicate<String, Set<String>> selector;
+
+		Mode(BiConsumer<EnumSource, Set<String>> validator, BiPredicate<String, Set<String>> selector) {
+			this.validator = validator;
+			this.selector = selector;
+		}
+
+		void validate(EnumSource enumSource, Set<String> names) {
+			Preconditions.notNull(enumSource, "enumSource must not be null");
+			Preconditions.notNull(names, "names must not be null");
+
+			validator.accept(enumSource, names);
+		}
+
+		boolean select(Enum<?> constant, Set<String> names) {
+			Preconditions.notNull(constant, "constant must not be null");
+			Preconditions.notNull(names, "names must not be null");
+
+			return selector.test(constant.name(), names);
+		}
+
+		static void validateNames(EnumSource enumSource, Set<String> names) {
+			Set<String> allNames = stream(enumSource.value().getEnumConstants()).map(e -> e.name()).collect(toSet());
+			Preconditions.condition(allNames.containsAll(names),
+				() -> "Invalid enum constant name(s) in: " + enumSource + ". Valid names are: " + allNames);
+		}
+
+		static void validatePatterns(EnumSource enumSource, Set<String> names) {
+			try {
+				names.forEach(Pattern::compile);
+			}
+			catch (PatternSyntaxException e) {
+				throw new PreconditionViolationException(
+					"Pattern compilation failed in: " + enumSource + " due to " + e, e);
+			}
+		}
+	}
+
 }
diff --git a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/provider/EnumArgumentsProviderTests.java b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/provider/EnumArgumentsProviderTests.java
index 170e3b410..2112a0064 100644
--- a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/provider/EnumArgumentsProviderTests.java
+++ b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/provider/EnumArgumentsProviderTests.java
@@ -21,6 +21,7 @@ import java.util.Arrays;
 import java.util.stream.Stream;
 
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.provider.EnumSource.Mode;
 import org.junit.platform.commons.util.PreconditionViolationException;
 
 /**
@@ -59,22 +60,34 @@ class EnumArgumentsProviderTests {
 	@Test
 	void invalidConstantNameIsDetected() {
 		Exception exception = assertThrows(PreconditionViolationException.class,
-			() -> provideArguments(EnumWithTwoConstants.class, "F00", "B4R"));
-		assertThat(exception).hasMessageContaining("Invalid enum constant name(s) found");
+			() -> provideArguments(EnumWithTwoConstants.class, "FO0", "B4R"));
+		assertThat(exception).hasMessageContaining("Invalid enum constant name(s) in");
+	}
+
+	@Test
+	void invalidPatternIsDetected() {
+		Exception exception = assertThrows(PreconditionViolationException.class,
+			() -> provideArguments(EnumWithTwoConstants.class, Mode.MATCHES_ALL, "(", ")"));
+		assertThat(exception).hasMessageContaining("Pattern compilation failed");
 	}
 
 	enum EnumWithTwoConstants {
 		FOO, BAR
 	}
 
-	private Stream<Object[]> provideArguments(Class<? extends Enum<?>> enumClass, String... names) {
+	private <E extends Enum<E>> Stream<Object[]> provideArguments(Class<E> enumClass, String... names) {
+		return provideArguments(enumClass, Mode.INCLUDE_NAMES, names);
+	}
+
+	private <E extends Enum<E>> Stream<Object[]> provideArguments(Class<E> enumClass, Mode mode, String... names) {
 		EnumSource annotation = mock(EnumSource.class);
 		when(annotation.value()).thenAnswer(invocation -> enumClass);
+		when(annotation.mode()).thenAnswer(invocation -> mode);
 		when(annotation.names()).thenAnswer(invocation -> names);
-		when(annotation.toString()).thenReturn(String.format("@EnumSource(value=%s.class, names={%s})",
-			enumClass.getSimpleName(), Arrays.toString(names)));
+		when(annotation.toString()).thenReturn(String.format("@EnumSource(value=%s.class, mode=%s names={%s})",
+			enumClass.getSimpleName(), mode, Arrays.toString(names)));
 
-		EnumArgumentsProvider provider = new EnumArgumentsProvider();
+		EnumArgumentsProvider<E> provider = new EnumArgumentsProvider<>();
 		provider.accept(annotation);
 		return provider.provideArguments(null).map(Arguments::get);
 	}
diff --git a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/provider/EnumSourceTests.java b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/provider/EnumSourceTests.java
new file mode 100644
index 000000000..3546230a6
--- /dev/null
+++ b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/provider/EnumSourceTests.java
@@ -0,0 +1,105 @@
+/*
+ * Copyright 2015-2017 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v1.0 which
+ * accompanies this distribution and is available at
+ *
+ * http://www.eclipse.org/legal/epl-v10.html
+ */
+
+package org.junit.jupiter.params.provider;
+
+import static org.junit.jupiter.api.Assertions.assertAll;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.junit.jupiter.params.provider.EnumSource.Mode.EXCLUDE_NAMES;
+import static org.junit.jupiter.params.provider.EnumSource.Mode.INCLUDE_NAMES;
+import static org.junit.jupiter.params.provider.EnumSource.Mode.MATCHES_ALL;
+import static org.junit.jupiter.params.provider.EnumSource.Mode.MATCHES_ANY;
+import static org.junit.jupiter.params.provider.EnumSourceTests.EnumWithThreeConstants.BAR;
+import static org.junit.jupiter.params.provider.EnumSourceTests.EnumWithThreeConstants.BAZ;
+import static org.junit.jupiter.params.provider.EnumSourceTests.EnumWithThreeConstants.FOO;
+
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.EnumSet;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+
+import org.junit.jupiter.api.Test;
+
+/**
+ * @since 5.0
+ */
+class EnumSourceTests {
+
+	enum EnumWithThreeConstants {
+		FOO, BAR, BAZ;
+
+		Set<String> singleton() {
+			return Collections.singleton(name());
+		}
+	}
+
+	static Set<String> allOf(Function<EnumWithThreeConstants, String> mapper) {
+		return EnumSet.allOf(EnumWithThreeConstants.class).stream().map(mapper).collect(Collectors.toSet());
+	}
+
+	static Set<String> set(String... strings) {
+		return new HashSet<>(Arrays.asList(strings));
+	}
+
+	@Test
+	void includeNamesWithAll() {
+		assertAll("include names with all", //
+			() -> assertTrue(INCLUDE_NAMES.select(FOO, allOf(EnumWithThreeConstants::name))),
+			() -> assertTrue(INCLUDE_NAMES.select(BAR, allOf(EnumWithThreeConstants::name))),
+			() -> assertTrue(INCLUDE_NAMES.select(BAZ, allOf(EnumWithThreeConstants::name))));
+	}
+
+	@Test
+	void includeNamesWithSingleton() {
+		assertAll("include names with singleton", //
+			() -> assertTrue(INCLUDE_NAMES.select(FOO, FOO.singleton())),
+			() -> assertTrue(INCLUDE_NAMES.select(BAR, BAR.singleton())),
+			() -> assertTrue(INCLUDE_NAMES.select(BAZ, BAZ.singleton())));
+		assertAll("include names with singleton complement", //
+			() -> assertFalse(INCLUDE_NAMES.select(BAR, FOO.singleton())),
+			() -> assertFalse(INCLUDE_NAMES.select(BAZ, FOO.singleton())));
+	}
+
+	@Test
+	void excludeNames() {
+		assertAll("exclude name with none excluded", //
+			() -> assertTrue(EXCLUDE_NAMES.select(FOO, Collections.emptySet())),
+			() -> assertTrue(EXCLUDE_NAMES.select(BAR, Collections.emptySet())),
+			() -> assertTrue(EXCLUDE_NAMES.select(BAZ, Collections.emptySet())));
+		assertAll("exclude name with FOO excluded", //
+			() -> assertFalse(EXCLUDE_NAMES.select(FOO, FOO.singleton())),
+			() -> assertTrue(EXCLUDE_NAMES.select(BAR, FOO.singleton())),
+			() -> assertTrue(EXCLUDE_NAMES.select(BAZ, FOO.singleton())));
+	}
+
+	@Test
+	void matchesAll() {
+		assertAll("matches all", //
+			() -> assertTrue(MATCHES_ALL.select(FOO, Collections.singleton("F.."))),
+			() -> assertTrue(MATCHES_ALL.select(BAR, Collections.singleton("B.."))),
+			() -> assertTrue(MATCHES_ALL.select(BAZ, Collections.singleton("B.."))));
+		assertAll("matches all fails if not all match", //
+			() -> assertFalse(MATCHES_ALL.select(FOO, set("F..", "."))),
+			() -> assertFalse(MATCHES_ALL.select(BAR, set("B..", "."))),
+			() -> assertFalse(MATCHES_ALL.select(BAZ, set("B..", "."))));
+	}
+
+	@Test
+	void matchesAny() {
+		assertAll("matches any", //
+			() -> assertTrue(MATCHES_ANY.select(FOO, set("B..", "^F.*"))),
+			() -> assertTrue(MATCHES_ANY.select(BAR, set("B", "B.", "B.."))),
+			() -> assertTrue(MATCHES_ANY.select(BAZ, set(".*[z|Z]"))));
+	}
+}
