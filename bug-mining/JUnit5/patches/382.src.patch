diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.7.0-M2.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.7.0-M2.adoc
index de82cbd2a..42aed08cb 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.7.0-M2.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.7.0-M2.adoc
@@ -40,6 +40,8 @@ on GitHub.
 * Support `FilePosition` in `FileSelector` and `ClasspathResourceSelector`.
 * Custom `PostDiscoveryFilter` implementations can now be registered via Javaâ€™s
   `ServiceLoader` mechanism.
+* New `getJavaClass()` and `getJavaMethod()` methods in
+   `org.junit.platform.engine.support.descriptor.MethodSource`.
 
 [[release-notes-5.7.0-M2-junit-jupiter]]
 === JUnit Jupiter
diff --git a/junit-platform-engine/src/main/java/org/junit/platform/engine/support/descriptor/MethodSource.java b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/descriptor/MethodSource.java
index 3bf8d3036..0f10b3cea 100644
--- a/junit-platform-engine/src/main/java/org/junit/platform/engine/support/descriptor/MethodSource.java
+++ b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/descriptor/MethodSource.java
@@ -17,7 +17,10 @@ import java.lang.reflect.Method;
 import java.util.Objects;
 
 import org.apiguardian.api.API;
+import org.junit.platform.commons.PreconditionViolationException;
 import org.junit.platform.commons.util.Preconditions;
+import org.junit.platform.commons.util.ReflectionUtils;
+import org.junit.platform.commons.util.StringUtils;
 import org.junit.platform.commons.util.ToStringBuilder;
 import org.junit.platform.engine.TestSource;
 
@@ -104,6 +107,8 @@ public class MethodSource implements TestSource {
 	private final String className;
 	private final String methodName;
 	private final String methodParameterTypes;
+	private Class<?> javaClass;
+	private transient Method javaMethod;
 
 	private MethodSource(String className, String methodName) {
 		this(className, methodName, null);
@@ -130,6 +135,8 @@ public class MethodSource implements TestSource {
 		this.className = testClass.getName();
 		this.methodName = testMethod.getName();
 		this.methodParameterTypes = nullSafeToString(testMethod.getParameterTypes());
+		this.javaClass = testClass;
+		this.javaMethod = testMethod;
 	}
 
 	/**
@@ -167,6 +174,56 @@ public class MethodSource implements TestSource {
 				&& Objects.equals(this.methodParameterTypes, that.methodParameterTypes);
 	}
 
+	/**
+	 * Get the {@linkplain Class Java class} of this source.
+	 *
+	 * <p>If the {@link Class} was not provided, but only the name, this method
+	 * attempts to lazily load the {@link Class} based on its name and throws a
+	 * {@link PreconditionViolationException} if the class cannot be loaded.
+	 *
+	 * @since 1.7
+	 * @see #getClassName()
+	 */
+	@API(status = STABLE, since = "1.7")
+	public final Class<?> getJavaClass() {
+		if (this.javaClass == null) {
+			this.javaClass = ReflectionUtils.tryToLoadClass(this.className).getOrThrow(
+				cause -> new PreconditionViolationException("Could not load class with name: " + this.className,
+					cause));
+		}
+		return this.javaClass;
+	}
+
+	/**
+	 * Get the {@linkplain Method Java method} of this source.
+	 *
+	 * <p>If the {@link Method} was not provided, but only the name, this method
+	 * attempts to lazily load the {@code Method} based on its name and throws a
+	 * {@link PreconditionViolationException} if the method cannot be loaded.
+	 *
+	 * @since 1.7
+	 * @see #getMethodName()
+	 */
+	@API(status = STABLE, since = "1.7")
+	public Method getJavaMethod() {
+		if (this.javaMethod == null) {
+			if (StringUtils.isNotBlank(this.methodParameterTypes)) {
+				this.javaMethod = ReflectionUtils.findMethod(getJavaClass(), this.methodName,
+					this.methodParameterTypes).orElseThrow(
+						() -> new PreconditionViolationException(String.format(
+							"Could not find method with name [%s] and parameter types [%s] in class [%s].",
+							this.methodName, this.methodParameterTypes, getJavaClass().getName())));
+			}
+			else {
+				this.javaMethod = ReflectionUtils.findMethod(getJavaClass(), this.methodName).orElseThrow(
+					() -> new PreconditionViolationException(
+						String.format("Could not find method with name [%s] in class [%s].", this.methodName,
+							getJavaClass().getName())));
+			}
+		}
+		return this.javaMethod;
+	}
+
 	@Override
 	public int hashCode() {
 		return Objects.hash(this.className, this.methodName, this.methodParameterTypes);
diff --git a/platform-tests/src/test/java/org/junit/platform/engine/support/descriptor/MethodSourceTests.java b/platform-tests/src/test/java/org/junit/platform/engine/support/descriptor/MethodSourceTests.java
index b3533313d..d8562ccae 100644
--- a/platform-tests/src/test/java/org/junit/platform/engine/support/descriptor/MethodSourceTests.java
+++ b/platform-tests/src/test/java/org/junit/platform/engine/support/descriptor/MethodSourceTests.java
@@ -45,6 +45,8 @@ class MethodSourceTests extends AbstractTestSourceTests {
 		assertThat(source.getClassName()).isEqualTo(getClass().getName());
 		assertThat(source.getMethodName()).isEqualTo(testMethod.getName());
 		assertThat(source.getMethodParameterTypes()).isEqualTo(String.class.getName());
+		assertThat(source.getJavaClass()).isEqualTo(getClass());
+		assertThat(source.getJavaMethod()).isEqualTo(testMethod);
 	}
 
 	@Test
@@ -205,6 +207,66 @@ class MethodSourceTests extends AbstractTestSourceTests {
 		assertNotEquals(MethodSource.from(m1).hashCode(), MethodSource.from(m2).hashCode());
 	}
 
+	@Test
+	void getJavaClassFromString() {
+		MethodSource source = MethodSource.from(getClass().getName(), "method1");
+
+		assertThat(source.getJavaClass()).isEqualTo(getClass());
+	}
+
+	@Test
+	void getJavaClassShouldThrowExceptionIfClassNotFound() {
+		MethodSource source = MethodSource.from(getClass().getName() + "X", "method1");
+
+		assertThrows(PreconditionViolationException.class, source::getJavaClass);
+	}
+
+	@Test
+	void getJavaMethodShouldReturnGivenMethodIfOverloadExists() throws Exception {
+		Method testMethod = getMethod("method3");
+		MethodSource source = MethodSource.from(testMethod);
+
+		assertThat(source.getJavaMethod()).isEqualTo(testMethod);
+	}
+
+	@Test
+	void getJavaMethodFromStringShouldFindVoidMethod() throws Exception {
+		Method testMethod = getClass().getDeclaredMethod("methodVoid");
+		MethodSource source = MethodSource.from(getClass().getName(), testMethod.getName());
+
+		assertThat(source.getJavaMethod()).isEqualTo(testMethod);
+	}
+
+	@Test
+	void getJavaMethodFromStringShouldFindMethodWithParameter() throws Exception {
+		Method testMethod = getClass().getDeclaredMethod("method3", Integer.TYPE);
+		MethodSource source = MethodSource.from(getClass().getName(), testMethod.getName(),
+			testMethod.getParameterTypes());
+
+		assertThat(source.getJavaMethod()).isEqualTo(testMethod);
+	}
+
+	@Test
+	void getJavaMethodFromStringShouldThrowExceptionParameterTypesNotGiven() {
+		MethodSource source = MethodSource.from(getClass().getName(), "method3");
+
+		assertThrows(PreconditionViolationException.class, source::getJavaMethod);
+	}
+
+	@Test
+	void getJavaMethodFromStringShouldThrowExceptionIfParameterTypesDoNotMatch() {
+		MethodSource source = MethodSource.from(getClass().getName(), "method3", Double.TYPE);
+
+		assertThrows(PreconditionViolationException.class, source::getJavaMethod);
+	}
+
+	@Test
+	void getJavaMethodFromStringShouldThrowExceptionIfMethodDoesNotExist() {
+		MethodSource source = MethodSource.from(getClass().getName(), "methodX");
+
+		assertThrows(PreconditionViolationException.class, source::getJavaMethod);
+	}
+
 	private Method getMethod(String name) throws Exception {
 		return getClass().getDeclaredMethod(name, String.class);
 	}
@@ -217,4 +279,16 @@ class MethodSourceTests extends AbstractTestSourceTests {
 	void method2(String text) {
 	}
 
+	@SuppressWarnings("unused")
+	void method3(String text) {
+	}
+
+	@SuppressWarnings("unused")
+	void method3(int number) {
+	}
+
+	@SuppressWarnings("unused")
+	void methodVoid() {
+	}
+
 }
