diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.4.0-RC1.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.4.0-RC1.adoc
index 7fa662421..480fa3ff2 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.4.0-RC1.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.4.0-RC1.adoc
@@ -48,6 +48,8 @@ repository on GitHub.
 * `@RegisterExtension` fields that are `null` when evaluated are no longer silently
   ignored. Instead, the corresponding test class or test method now fails with an
   informative exception.
+* `@ParameterizedTest` now again supports `MessageFormat` patterns for individual
+  parameters (e.g. `{0,number,#.##}`).
 
 ==== Deprecations and Breaking Changes
 
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestNameFormatter.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestNameFormatter.java
index 929a3ad26..cfa0bb17a 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestNameFormatter.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestNameFormatter.java
@@ -15,6 +15,7 @@ import static org.junit.jupiter.params.ParameterizedTest.ARGUMENTS_PLACEHOLDER;
 import static org.junit.jupiter.params.ParameterizedTest.DISPLAY_NAME_PLACEHOLDER;
 import static org.junit.jupiter.params.ParameterizedTest.INDEX_PLACEHOLDER;
 
+import java.text.Format;
 import java.text.MessageFormat;
 import java.util.Arrays;
 import java.util.stream.IntStream;
@@ -36,9 +37,21 @@ class ParameterizedTestNameFormatter {
 	}
 
 	String format(int invocationIndex, Object... arguments) {
+		try {
+			return formatSafely(invocationIndex, arguments);
+		}
+		catch (Exception ex) {
+			String message = "The display name pattern defined for the parameterized test is invalid. "
+					+ "See nested exception for further details.";
+			throw new JUnitException(message, ex);
+		}
+	}
+
+	private String formatSafely(int invocationIndex, Object[] arguments) {
 		String pattern = prepareMessageFormatPattern(invocationIndex, arguments);
-		Object[] humanReadableArguments = makeReadable(arguments);
-		return formatSafely(pattern, humanReadableArguments);
+		MessageFormat format = new MessageFormat(pattern);
+		Object[] humanReadableArguments = makeReadable(format, arguments);
+		return format.format(humanReadableArguments);
 	}
 
 	private String prepareMessageFormatPattern(int invocationIndex, Object[] arguments) {
@@ -58,23 +71,15 @@ class ParameterizedTestNameFormatter {
 		return result;
 	}
 
-	private Object[] makeReadable(Object[] arguments) {
-		// Note: humanReadableArguments must be an Object[] in order to
-		// avoid varargs issues with non-Eclipse compilers.
-		Object[] humanReadableArguments = //
-			Arrays.stream(arguments).map(StringUtils::nullSafeToString).toArray(String[]::new);
-		return humanReadableArguments;
-	}
-
-	private String formatSafely(String pattern, Object[] arguments) {
-		try {
-			return MessageFormat.format(pattern, arguments);
-		}
-		catch (IllegalArgumentException ex) {
-			String message = "The display name pattern defined for the parameterized test is invalid. "
-					+ "See nested exception for further details.";
-			throw new JUnitException(message, ex);
+	private Object[] makeReadable(MessageFormat format, Object[] arguments) {
+		Format[] formats = format.getFormatsByArgumentIndex();
+		Object[] result = Arrays.copyOf(arguments, Math.min(arguments.length, formats.length));
+		for (int i = 0; i < result.length; i++) {
+			if (formats[i] == null) {
+				result[i] = StringUtils.nullSafeToString(arguments[i]);
+			}
 		}
+		return result;
 	}
 
 }
diff --git a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestNameFormatterTests.java b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestNameFormatterTests.java
index 522b9640e..a6712e423 100644
--- a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestNameFormatterTests.java
+++ b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestNameFormatterTests.java
@@ -20,9 +20,17 @@ import static org.junit.jupiter.params.ParameterizedTest.DEFAULT_DISPLAY_NAME;
 import static org.junit.jupiter.params.ParameterizedTest.DISPLAY_NAME_PLACEHOLDER;
 import static org.junit.jupiter.params.ParameterizedTest.INDEX_PLACEHOLDER;
 
+import java.math.BigDecimal;
+import java.sql.Date;
+import java.time.LocalDate;
+import java.time.LocalTime;
+import java.time.ZoneId;
 import java.util.Arrays;
+import java.util.Locale;
 
+import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.provider.CsvSource;
 import org.junit.platform.commons.JUnitException;
 
 /**
@@ -30,6 +38,13 @@ import org.junit.platform.commons.JUnitException;
  */
 class ParameterizedTestNameFormatterTests {
 
+	private Locale originalLocale = Locale.getDefault();
+
+	@AfterEach
+	void restoreLocale() {
+		Locale.setDefault(originalLocale);
+	}
+
 	@Test
 	void formatsDisplayName() {
 		ParameterizedTestNameFormatter formatter = new ParameterizedTestNameFormatter(DISPLAY_NAME_PLACEHOLDER,
@@ -119,6 +134,50 @@ class ParameterizedTestNameFormatterTests {
 		assertThat(formattedName).endsWith("foo");
 	}
 
+	@ParameterizedTest(name = "{0}")
+	@CsvSource(delimiter = '|', value = { "US | 42.23 is positive on 2019 Jan 13 at 12:34:56",
+			"DE | 42,23 is positive on 13.01.2019 at 12:34:56" })
+	void customFormattingExpressionsAreSupported(Locale locale, String expectedValue) {
+		var pattern = "[{index}] {1,number,#.##} is {1,choice,0<positive} on {0,date} at {0,time} even though {2}";
+		ParameterizedTestNameFormatter formatter = new ParameterizedTestNameFormatter(pattern, "enigma");
+		Locale.setDefault(Locale.US);
+
+		var date = Date.from(
+			LocalDate.of(2019, 1, 13).atTime(LocalTime.of(12, 34, 56)).atZone(ZoneId.systemDefault()).toInstant());
+		Locale.setDefault(locale);
+		String formattedName = formatter.format(1, date, new BigDecimal("42.23"), new ToStringThrowsException());
+
+		assertThat(formattedName).startsWith(
+			"[1] " + expectedValue + " even though " + ToStringThrowsException.class.getName() + "@");
+	}
+
+	@Test
+	void ignoresExcessPlaceholders() {
+		ParameterizedTestNameFormatter formatter = new ParameterizedTestNameFormatter("{0}, {1}", "enigma");
+
+		String formattedName = formatter.format(1, "foo");
+
+		assertThat(formattedName).isEqualTo("foo, {1}");
+	}
+
+	@Test
+	void placeholdersCanBeOmitted() {
+		ParameterizedTestNameFormatter formatter = new ParameterizedTestNameFormatter("{0}", "enigma");
+
+		String formattedName = formatter.format(1, "foo", "bar");
+
+		assertThat(formattedName).isEqualTo("foo");
+	}
+
+	@Test
+	void placeholdersCanBeSkipped() {
+		ParameterizedTestNameFormatter formatter = new ParameterizedTestNameFormatter("{0}, {2}", "enigma");
+
+		String formattedName = formatter.format(1, "foo", "bar", "baz");
+
+		assertThat(formattedName).isEqualTo("foo, baz");
+	}
+
 	private static class ToStringThrowsException {
 
 		@Override
