diff --git a/documentation/src/docs/asciidoc/link-attributes.adoc b/documentation/src/docs/asciidoc/link-attributes.adoc
index 7bc5bc848..dc101db70 100644
--- a/documentation/src/docs/asciidoc/link-attributes.adoc
+++ b/documentation/src/docs/asciidoc/link-attributes.adoc
@@ -138,6 +138,7 @@ endif::[]
 :TempDir:                                    {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/io/TempDir.html[@TempDir]
 // Jupiter Params
 :params-provider-package:                    {javadoc-root}/org.junit.jupiter.params/org/junit/jupiter/params/provider/package-summary.html[org.junit.jupiter.params.provider]
+:AnnotationBasedArgumentConverter:           {javadoc-root}/org.junit.jupiter.params/org/junit/jupiter/params/provider/AnnotationBasedArgumentConverter.html[AnnotationBasedArgumentConverter]
 :AnnotationBasedArgumentsProvider:           {javadoc-root}/org.junit.jupiter.params/org/junit/jupiter/params/provider/AnnotationBasedArgumentsProvider.html[AnnotationBasedArgumentsProvider]
 :ArgumentsAccessor:                          {javadoc-root}/org.junit.jupiter.params/org/junit/jupiter/params/aggregator/ArgumentsAccessor.html[ArgumentsAccessor]
 :ArgumentsAggregator:                        {javadoc-root}/org.junit.jupiter.params/org/junit/jupiter/params/aggregator/ArgumentsAggregator.html[ArgumentsAggregator]
diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.10.0-M1.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.10.0-M1.adoc
index 0a0b57d77..2f8ebd6bf 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.10.0-M1.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.10.0-M1.adoc
@@ -66,6 +66,8 @@ repository on GitHub.
   with a public no-arg constructor.
 * New `AnnotationBasedArgumentsProvider` that implements both `ArgumentsProvider` and
   `AnnotationConsumer` interfaces.
+* New `AnnotationBasedArgumentConverter` that implements both `ArgumentConverter` and
+  `AnnotationConsumer` interfaces.
 
 
 [[release-notes-5.10.0-M1-junit-vintage]]
diff --git a/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc b/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
index 4187c34d5..a0fc45f29 100644
--- a/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
+++ b/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
@@ -1772,6 +1772,10 @@ composed annotation `JavaTimeConversionPattern`.
 include::{testDir}/example/ParameterizedTestDemo.java[tags=explicit_java_time_converter]
 ----
 
+If you wish to implement a custom `ArgumentConverter` that also consumes an annotation
+(like `JavaTimeArgumentConverter`), you have the possibility to extend the
+`{AnnotationBasedArgumentConverter}` class.
+
 [[writing-tests-parameterized-tests-argument-aggregation]]
 ==== Argument Aggregation
 
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/converter/AnnotationBasedArgumentConverter.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/converter/AnnotationBasedArgumentConverter.java
new file mode 100644
index 000000000..964c0c236
--- /dev/null
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/converter/AnnotationBasedArgumentConverter.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright 2015-2023 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.params.converter;
+
+import static org.apiguardian.api.API.Status.EXPERIMENTAL;
+
+import java.lang.annotation.Annotation;
+
+import org.apiguardian.api.API;
+import org.junit.jupiter.api.extension.ParameterContext;
+import org.junit.jupiter.params.support.AnnotationConsumer;
+import org.junit.platform.commons.util.Preconditions;
+
+/**
+ * {@code SimpleArgumentConverter} is an abstract base class for
+ * {@link ArgumentConverter} implementations that also need to consume an
+ * annotation in order to perform the conversion.
+ *
+ * @since 5.10
+ * @see ArgumentConverter
+ * @see AnnotationConsumer
+ * @see SimpleArgumentConverter
+ */
+@API(status = EXPERIMENTAL, since = "5.10")
+public abstract class AnnotationBasedArgumentConverter<A extends Annotation>
+		implements ArgumentConverter, AnnotationConsumer<A> {
+
+	public AnnotationBasedArgumentConverter() {
+	}
+
+	private A annotation;
+
+	@Override
+	public final void accept(A annotation) {
+		Preconditions.notNull(annotation, "annotation must not be null");
+		this.annotation = annotation;
+	}
+
+	@Override
+	public final Object convert(Object source, ParameterContext context) throws ArgumentConversionException {
+		return convert(source, context.getParameter().getType(), annotation);
+	}
+
+	/**
+	 * Convert the supplied {@code source} object into the supplied
+	 * {@code targetType}.
+	 *
+	 * @param source the source object to convert; may be {@code null}
+	 * @param targetType the target type the source object should be converted
+	 * into; never {@code null}
+	 * @param annotation the annotation needed to convert the source; never {@code null}
+	 * @return the converted object; may be {@code null} but only if the target
+	 * type is a reference type
+	 * @throws ArgumentConversionException in case an error occurs during the
+	 * conversion
+	 */
+	protected abstract Object convert(Object source, Class<?> targetType, A annotation);
+
+}
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/converter/JavaTimeArgumentConverter.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/converter/JavaTimeArgumentConverter.java
index 7c1defaa3..aef6e5a44 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/converter/JavaTimeArgumentConverter.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/converter/JavaTimeArgumentConverter.java
@@ -27,13 +27,10 @@ import java.util.Collections;
 import java.util.LinkedHashMap;
 import java.util.Map;
 
-import org.junit.jupiter.params.support.AnnotationConsumer;
-
 /**
  * @since 5.0
  */
-class JavaTimeArgumentConverter extends SimpleArgumentConverter
-		implements AnnotationConsumer<JavaTimeConversionPattern> {
+class JavaTimeArgumentConverter extends AnnotationBasedArgumentConverter<JavaTimeConversionPattern> {
 
 	private static final Map<Class<?>, TemporalQuery<?>> TEMPORAL_QUERIES;
 	static {
@@ -52,15 +49,9 @@ class JavaTimeArgumentConverter extends SimpleArgumentConverter
 		TEMPORAL_QUERIES = Collections.unmodifiableMap(queries);
 	}
 
-	private String pattern;
-
-	@Override
-	public void accept(JavaTimeConversionPattern annotation) {
-		pattern = annotation.value();
-	}
-
 	@Override
-	public Object convert(Object input, Class<?> targetClass) throws ArgumentConversionException {
+	protected Object convert(Object input, Class<?> targetClass, JavaTimeConversionPattern annotation) {
+		String pattern = annotation.value();
 		if (!TEMPORAL_QUERIES.containsKey(targetClass)) {
 			throw new ArgumentConversionException("Cannot convert to " + targetClass.getName() + ": " + input);
 		}
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/support/AnnotationConsumerInitializer.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/support/AnnotationConsumerInitializer.java
index a5cf81304..83d9fd8fd 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/support/AnnotationConsumerInitializer.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/support/AnnotationConsumerInitializer.java
@@ -36,15 +36,10 @@ public final class AnnotationConsumerInitializer {
 		/* no-op */
 	}
 
-	private static final Predicate<Method> isAcceptOrProvideArgumentsMethod = method -> isAnnotationConsumerAcceptMethod(
-		method) || isAnnotationBasedArgumentsProviderMethod(method);
-
 	@SuppressWarnings({ "unchecked", "rawtypes" })
 	public static <T> T initialize(AnnotatedElement annotatedElement, T annotationConsumerInstance) {
 		if (annotationConsumerInstance instanceof AnnotationConsumer) {
-			Method method = findMethods(annotationConsumerInstance.getClass(), isAcceptOrProvideArgumentsMethod,
-				BOTTOM_UP).get(0);
-			Class<? extends Annotation> annotationType = getAnnotationType(method);
+			Class<? extends Annotation> annotationType = findAnnotationType(annotationConsumerInstance);
 			Annotation annotation = AnnotationUtils.findAnnotation(annotatedElement, annotationType) //
 					.orElseThrow(() -> new JUnitException(annotationConsumerInstance.getClass().getName()
 							+ " must be used with an annotation of type " + annotationType.getName()));
@@ -53,7 +48,25 @@ public final class AnnotationConsumerInitializer {
 		return annotationConsumerInstance;
 	}
 
-	private static boolean isAnnotationConsumerAcceptMethod(Method method) {
+	private static <T> Class<? extends Annotation> findAnnotationType(T annotationConsumerInstance) {
+		Predicate<Method> hasAnnotationParameter = method -> isAnnotationConsumerMethod(method)
+				|| isAnnotationBasedArgumentsProviderMethod(method) || isAnnotationBasedArgumentConverterMethod(method);
+		Method method = findMethods(annotationConsumerInstance.getClass(), hasAnnotationParameter, BOTTOM_UP).get(0);
+		return getAnnotationType(method);
+	}
+
+	@SuppressWarnings("unchecked")
+	private static Class<? extends Annotation> getAnnotationType(Method method) {
+		if (isAnnotationConsumerMethod(method)) {
+			return (Class<? extends Annotation>) method.getParameterTypes()[0];
+		}
+		if (isAnnotationBasedArgumentsProviderMethod(method)) {
+			return (Class<? extends Annotation>) method.getParameterTypes()[1];
+		}
+		return (Class<? extends Annotation>) method.getParameterTypes()[2];
+	}
+
+	private static boolean isAnnotationConsumerMethod(Method method) {
 		return isMethodWith(method, "accept", 1, 0);
 	}
 
@@ -61,22 +74,16 @@ public final class AnnotationConsumerInitializer {
 		return isMethodWith(method, "provideArguments", 2, 1);
 	}
 
-	// @formatter:off
+	private static boolean isAnnotationBasedArgumentConverterMethod(Method method) {
+		return isMethodWith(method, "convert", 3, 2);
+	}
+
 	private static boolean isMethodWith(Method method, String methodName, int parameterCount,
 			int annotationInParameterIndex) {
-		return method.getName().equals(methodName)
-				&& method.getParameterCount() == parameterCount
+		return method.getName().equals(methodName) //
+				&& method.getParameterCount() == parameterCount //
 				&& method.getParameterTypes()[annotationInParameterIndex].isAnnotation();
 	}
-	// @formatter:on
-
-	@SuppressWarnings({ "unchecked" })
-	private static Class<? extends Annotation> getAnnotationType(Method method) {
-		if (isAnnotationConsumerAcceptMethod(method)) {
-			return (Class<? extends Annotation>) method.getParameterTypes()[0];
-		}
-		return (Class<? extends Annotation>) method.getParameterTypes()[1];
-	}
 
 	private static <A extends Annotation> void initializeAnnotationConsumer(AnnotationConsumer<A> instance,
 			A annotation) {
diff --git a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/converter/JavaTimeArgumentConverterTests.java b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/converter/JavaTimeArgumentConverterTests.java
index 3bb890746..5e3a54e2d 100644
--- a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/converter/JavaTimeArgumentConverterTests.java
+++ b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/converter/JavaTimeArgumentConverterTests.java
@@ -114,9 +114,8 @@ class JavaTimeArgumentConverterTests {
 		var converter = new JavaTimeArgumentConverter();
 		var annotation = mock(JavaTimeConversionPattern.class);
 		when(annotation.value()).thenReturn(pattern);
-		converter.accept(annotation);
 
-		return converter.convert(input, targetClass);
+		return converter.convert(input, targetClass, annotation);
 	}
 
 }
diff --git a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/support/AnnotationConsumerInitializerTest.java b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/support/AnnotationConsumerInitializerTest.java
index 43da248a7..0c22504d9 100644
--- a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/support/AnnotationConsumerInitializerTest.java
+++ b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/support/AnnotationConsumerInitializerTest.java
@@ -14,13 +14,18 @@ import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.assertThatThrownBy;
 import static org.junit.jupiter.params.support.AnnotationConsumerInitializer.initialize;
 import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
 
+import java.time.LocalDate;
 import java.util.Arrays;
 import java.util.stream.Stream;
 
 import org.junit.jupiter.api.DisplayName;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.extension.ExtensionContext;
+import org.junit.jupiter.api.extension.ParameterContext;
+import org.junit.jupiter.params.converter.AnnotationBasedArgumentConverter;
+import org.junit.jupiter.params.converter.JavaTimeConversionPattern;
 import org.junit.jupiter.params.provider.AnnotationBasedArgumentsProvider;
 import org.junit.jupiter.params.provider.Arguments;
 import org.junit.jupiter.params.provider.CsvSource;
@@ -44,37 +49,74 @@ class AnnotationConsumerInitializerTest {
 	@Test
 	@DisplayName("should initialize annotation based arguments provider")
 	void shouldInitializeAnnotationBasedArgumentsProvider() throws NoSuchMethodException {
-		var instance = new SomeAnnotationBasedArgumentProvider();
+		var instance = new SomeAnnotationBasedArgumentsProvider();
 		var method = SubjectClass.class.getDeclaredMethod("foo");
 		var initialisedAnnotationConsumer = initialize(method, instance);
 
 		initialisedAnnotationConsumer.provideArguments(mock());
 
-		assertThat(initialisedAnnotationConsumer.assignedAnnotation) //
+		assertThat(initialisedAnnotationConsumer.annotation) //
 				.isInstanceOf(CsvSource.class) //
 				.matches(annotation -> Arrays.equals(annotation.value(), new String[] { "a", "b" }));
 	}
 
+	@Test
+	@DisplayName("should initialize annotation based argument converter")
+	void shouldInitializeAnnotationBasedArgumentConverter() throws NoSuchMethodException {
+		var instance = new SomeAnnotationBasedArgumentConverter();
+		var parameter = SubjectClass.class.getDeclaredMethod("bar", LocalDate.class).getParameters()[0];
+		var initialisedAnnotationConsumer = initialize(parameter, instance);
+
+		ParameterContext parameterContext = mock();
+		when(parameterContext.getParameter()).thenReturn(parameter);
+		initialisedAnnotationConsumer.convert("source", parameterContext);
+
+		assertThat(initialisedAnnotationConsumer.annotation) //
+				.isInstanceOf(JavaTimeConversionPattern.class) //
+				.matches(annotation -> annotation.value().equals("pattern"));
+	}
+
 	@Test
 	@DisplayName("should throw exception when method is not annotated")
 	void shouldThrowExceptionWhenMethodIsNotAnnotated() throws NoSuchMethodException {
 		var instance = new SomeAnnotationConsumer();
-		var method = SubjectClass.class.getDeclaredMethod("noAnnotation");
+		var method = SubjectClass.class.getDeclaredMethod("noAnnotation", String.class);
 
 		assertThatThrownBy(() -> initialize(method, instance)).isInstanceOf(JUnitException.class);
 	}
 
-	private static class SomeAnnotationBasedArgumentProvider extends AnnotationBasedArgumentsProvider<CsvSource> {
+	@Test
+	@DisplayName("should throw exception when parameter is not annotated")
+	void shouldThrowExceptionWhenParameterIsNotAnnotated() throws NoSuchMethodException {
+		var instance = new SomeAnnotationConsumer();
+		var parameter = SubjectClass.class.getDeclaredMethod("noAnnotation", String.class).getParameters()[0];
+
+		assertThatThrownBy(() -> initialize(parameter, instance)).isInstanceOf(JUnitException.class);
+	}
+
+	private static class SomeAnnotationBasedArgumentsProvider extends AnnotationBasedArgumentsProvider<CsvSource> {
 
-		CsvSource assignedAnnotation;
+		CsvSource annotation;
 
 		@Override
 		protected Stream<? extends Arguments> provideArguments(ExtensionContext context, CsvSource annotation) {
-			assignedAnnotation = annotation;
+			this.annotation = annotation;
 			return Stream.empty();
 		}
 	}
 
+	private static class SomeAnnotationBasedArgumentConverter
+			extends AnnotationBasedArgumentConverter<JavaTimeConversionPattern> {
+
+		JavaTimeConversionPattern annotation;
+
+		@Override
+		protected Object convert(Object source, Class<?> targetType, JavaTimeConversionPattern annotation) {
+			this.annotation = annotation;
+			return null;
+		}
+	}
+
 	private static class SomeAnnotationConsumer implements AnnotationConsumer<CsvSource> {
 
 		CsvSource annotation;
@@ -92,7 +134,11 @@ class AnnotationConsumerInitializerTest {
 
 		}
 
-		void noAnnotation() {
+		void bar(@JavaTimeConversionPattern("pattern") LocalDate date) {
+
+		}
+
+		void noAnnotation(String param) {
 
 		}
 	}
