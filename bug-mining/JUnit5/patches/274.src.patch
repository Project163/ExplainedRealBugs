diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.5.0-M2.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.5.0-M2.adoc
index 1b9cabb1e..e9734be6a 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.5.0-M2.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.5.0-M2.adoc
@@ -44,6 +44,7 @@ on GitHub.
   the log in order to allow reproducible builds.
 * Methods ordered with `MethodOrderer.Random` now execute using the `SAME_THREAD`
   concurrency mode instead of the `CONCURRENT` mode when no custom seed is provided.
+* New `emptyValue` attribute in `@CsvFileSource` and `@CsvSource`.
 
 
 [[release-notes-5.5.0-M2-junit-vintage]]
diff --git a/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc b/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
index 78b76aa0f..d373e7b7d 100644
--- a/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
+++ b/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
@@ -1134,9 +1134,9 @@ include::{testDir}/example/ParameterizedTestDemo.java[tags=CsvSource_example]
 
 `@CsvSource` uses a single quote `'` as its quote character. See the `'lemon, lime'` value
 in the example above and in the table below. An empty, quoted value `''` results in an
-empty `String`; whereas, an entirely _empty_ value is interpreted as a `null` reference.
-An `ArgumentConversionException` is raised if the target type of a `null` reference is a
-primitive type.
+empty `String` unless the `emptyValue` attribute is set; whereas, an entirely _empty_
+value is interpreted as a `null` reference. An `ArgumentConversionException` is raised if
+the target type of a `null` reference is a primitive type.
 
 [cols="50,50"]
 |===
@@ -1167,10 +1167,10 @@ include::{testResourcesDir}/two-column.csv[]
 
 NOTE: In contrast to the syntax used in `@CsvSource`, `@CsvFileSource` uses a double
 quote `"` as the quote character. See the `"United States of America"` value in the
-example above. An empty, quoted value `""` results in an empty `String`; whereas, an
-entirely _empty_ value is interpreted as a `null` reference. An
-`ArgumentConversionException` is raised if the target type of a `null` reference is a
-primitive type.
+example above. An empty, quoted value `""` results in an empty `String` unless the
+`emptyValue` attribute is set; whereas, an entirely _empty_ value is interpreted as a
+`null` reference. An `ArgumentConversionException` is raised if the target type of a
+`null` reference is a primitive type.
 
 [[writing-tests-parameterized-tests-sources-ArgumentsSource]]
 ===== @ArgumentsSource
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvArgumentsProvider.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvArgumentsProvider.java
index 857d659a1..050ef6fe4 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvArgumentsProvider.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvArgumentsProvider.java
@@ -45,7 +45,7 @@ class CsvArgumentsProvider implements ArgumentsProvider, AnnotationConsumer<CsvS
 		settings.getFormat().setLineSeparator(LINE_SEPARATOR);
 		settings.getFormat().setQuote('\'');
 		settings.getFormat().setQuoteEscape('\'');
-		settings.setEmptyValue("");
+		settings.setEmptyValue(this.annotation.emptyValue());
 		settings.setAutoConfigurationEnabled(false);
 		CsvParser csvParser = new CsvParser(settings);
 		AtomicLong index = new AtomicLong(0);
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvFileArgumentsProvider.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvFileArgumentsProvider.java
index c223472af..d29c40827 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvFileArgumentsProvider.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvFileArgumentsProvider.java
@@ -72,7 +72,7 @@ class CsvFileArgumentsProvider implements ArgumentsProvider, AnnotationConsumer<
 		settings.getFormat().setLineSeparator(annotation.lineSeparator());
 		settings.getFormat().setQuote('"');
 		settings.getFormat().setQuoteEscape('"');
-		settings.setEmptyValue("");
+		settings.setEmptyValue(annotation.emptyValue());
 		settings.setAutoConfigurationEnabled(false);
 	}
 
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvFileSource.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvFileSource.java
index 309fe8b49..2c332470a 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvFileSource.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvFileSource.java
@@ -76,7 +76,22 @@ public @interface CsvFileSource {
 	 * <p>Typically used to skip header lines.
 	 *
 	 * <p>Defaults to {@code 0}.
+	 *
+	 * @since 5.1
 	 */
+	@API(status = EXPERIMENTAL, since = "5.1")
 	int numLinesToSkip() default 0;
 
+	/**
+	 * The empty value to use when reading the CSV files.
+	 *
+	 * <p>This value replaces quoted empty strings read from the input.
+	 *
+	 * <p>Defaults to {@code ""}.
+	 *
+	 * @since 5.5
+	 */
+	@API(status = EXPERIMENTAL, since = "5.5")
+	String emptyValue() default "";
+
 }
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvSource.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvSource.java
index 713e8efce..51821ecff 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvSource.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvSource.java
@@ -55,4 +55,16 @@ public @interface CsvSource {
 	 */
 	char delimiter() default ',';
 
+	/**
+	 * The empty value to use when reading the {@linkplain #value lines}.
+	 *
+	 * <p>This value replaces quoted empty strings read from the input.
+	 *
+	 * <p>Defaults to {@code ""}.
+	 *
+	 * @since 5.5
+	 */
+	@API(status = EXPERIMENTAL, since = "5.5")
+	String emptyValue() default "";
+
 }
diff --git a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/provider/CsvArgumentsProviderTests.java b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/provider/CsvArgumentsProviderTests.java
index ec65e2633..6f8f33343 100644
--- a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/provider/CsvArgumentsProviderTests.java
+++ b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/provider/CsvArgumentsProviderTests.java
@@ -27,35 +27,35 @@ class CsvArgumentsProviderTests {
 
 	@Test
 	void providesSingleArgument() {
-		Stream<Object[]> arguments = provideArguments(',', "foo");
+		Stream<Object[]> arguments = provideArguments(',', "", "foo");
 
 		assertThat(arguments).containsExactly(new String[] { "foo" });
 	}
 
 	@Test
 	void providesMultipleArguments() {
-		Stream<Object[]> arguments = provideArguments(',', "foo", "bar");
+		Stream<Object[]> arguments = provideArguments(',', "", "foo", "bar");
 
 		assertThat(arguments).containsExactly(new String[] { "foo" }, new String[] { "bar" });
 	}
 
 	@Test
 	void splitsAndTrimsArguments() {
-		Stream<Object[]> arguments = provideArguments('|', " foo | bar ");
+		Stream<Object[]> arguments = provideArguments('|', "", " foo | bar ");
 
 		assertThat(arguments).containsExactly(new String[] { "foo", "bar" });
 	}
 
 	@Test
 	void understandsQuotes() {
-		Stream<Object[]> arguments = provideArguments(',', "'foo, bar'");
+		Stream<Object[]> arguments = provideArguments(',', "", "'foo, bar'");
 
 		assertThat(arguments).containsExactly(new String[] { "foo, bar" });
 	}
 
 	@Test
 	void understandsEscapeCharacters() {
-		Stream<Object[]> arguments = provideArguments(',', "'foo or ''bar''', baz");
+		Stream<Object[]> arguments = provideArguments(',', "", "'foo or ''bar''', baz");
 
 		assertThat(arguments).containsExactly(new String[] { "foo or 'bar'", "baz" });
 	}
@@ -63,43 +63,51 @@ class CsvArgumentsProviderTests {
 	@Test
 	void throwsExceptionOnInvalidCsv() {
 		JUnitException exception = assertThrows(JUnitException.class,
-			() -> provideArguments(',', "foo", "bar", "").toArray());
+			() -> provideArguments(',', "", "foo", "bar", "").toArray());
 
 		assertThat(exception).hasMessage("Line at index 2 contains invalid CSV: \"\"");
 	}
 
 	@Test
 	void emptyValueIsAnEmptyString() {
-		Stream<Object[]> arguments = provideArguments(',', "null , , empty , ''");
+		Stream<Object[]> arguments = provideArguments(',', "", "null , , empty , ''");
 
 		assertThat(arguments).containsExactly(new String[] { "null", null, "empty", "" });
 	}
 
+	@Test
+	void emptyValueIsAnEmptyWithCustomEmptyValueString() {
+		Stream<Object[]> arguments = provideArguments(',', "vacio", "null , , empty , ''");
+
+		assertThat(arguments).containsExactly(new String[] { "null", null, "empty", "vacio" });
+	}
+
 	@Test
 	void leadingSpacesAreTrimmed() {
-		Stream<Object[]> arguments = provideArguments(',', "'', 1", " '', 2", "'' , 3", " '' , 4");
+		Stream<Object[]> arguments = provideArguments(',', "", "'', 1", " '', 2", "'' , 3", " '' , 4");
 
 		assertThat(arguments).containsExactly(new Object[][] { { "", "1" }, { "", "2" }, { "", "3" }, { "", "4" } });
 	}
 
 	@Test
 	void trailingSpacesAreTrimmed() {
-		Stream<Object[]> arguments = provideArguments(',', "1,''", "2, ''", "3,'' ", "4, '' ");
+		Stream<Object[]> arguments = provideArguments(',', "", "1,''", "2, ''", "3,'' ", "4, '' ");
 
 		assertThat(arguments).containsExactly(new Object[][] { { "1", "" }, { "2", "" }, { "3", "" }, { "4", "" } });
 	}
 
 	@Test
 	void convertsEmptyValuesToNullInLinesAfterFirst() {
-		Stream<Object[]> arguments = provideArguments(',', "'', ''", " , ");
+		Stream<Object[]> arguments = provideArguments(',', "", "'', ''", " , ");
 
 		assertThat(arguments).containsExactly(new Object[][] { { "", "" }, { null, null } });
 	}
 
-	private Stream<Object[]> provideArguments(char delimiter, String... value) {
+	private Stream<Object[]> provideArguments(char delimiter, String emptyValue, String... value) {
 		CsvSource annotation = mock(CsvSource.class);
 		when(annotation.value()).thenReturn(value);
 		when(annotation.delimiter()).thenReturn(delimiter);
+		when(annotation.emptyValue()).thenReturn(emptyValue);
 
 		CsvArgumentsProvider provider = new CsvArgumentsProvider();
 		provider.accept(annotation);
diff --git a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/provider/CsvFileArgumentsProviderTests.java b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/provider/CsvFileArgumentsProviderTests.java
index fcf10e130..fc72e4c6a 100644
--- a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/provider/CsvFileArgumentsProviderTests.java
+++ b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/provider/CsvFileArgumentsProviderTests.java
@@ -34,14 +34,14 @@ class CsvFileArgumentsProviderTests {
 
 	@Test
 	void providesArgumentsForNewlineAndComma() {
-		Stream<Object[]> arguments = provideArguments("foo, bar \n baz, qux \n", "\n", ',');
+		Stream<Object[]> arguments = provideArguments("foo, bar \n baz, qux \n", "\n", ',', "");
 
 		assertThat(arguments).containsExactly(new Object[] { "foo", "bar" }, new Object[] { "baz", "qux" });
 	}
 
 	@Test
 	void providesArgumentsForCarriageReturnAndSemicolon() {
-		Stream<Object[]> arguments = provideArguments("foo; bar \r baz; qux", "\r", ';');
+		Stream<Object[]> arguments = provideArguments("foo; bar \r baz; qux", "\r", ';', "");
 
 		assertThat(arguments).containsExactly(new Object[] { "foo", "bar" }, new Object[] { "baz", "qux" });
 	}
@@ -57,7 +57,7 @@ class CsvFileArgumentsProviderTests {
 			}
 		};
 
-		Stream<Object[]> arguments = provideArguments(inputStream, "\n", ',');
+		Stream<Object[]> arguments = provideArguments(inputStream, "\n", ',', "");
 
 		assertThat(arguments.count()).isEqualTo(1);
 		assertThat(closed.get()).describedAs("closed").isTrue();
@@ -65,7 +65,7 @@ class CsvFileArgumentsProviderTests {
 
 	@Test
 	void readsFromSingleClasspathResource() {
-		CsvFileSource annotation = annotation("ISO-8859-1", "\n", ',', "/single-column.csv");
+		CsvFileSource annotation = annotation("ISO-8859-1", "\n", ',', "", "/single-column.csv");
 
 		Stream<Object[]> arguments = provide(new CsvFileArgumentsProvider(), annotation);
 
@@ -73,9 +73,19 @@ class CsvFileArgumentsProviderTests {
 			new Object[] { "qux" }, new Object[] { "" });
 	}
 
+	@Test
+	void readsFromSingleClasspathResourceWithCustomEmptyValue() {
+		CsvFileSource annotation = annotation("ISO-8859-1", "\n", ',', "vacio", "/single-column.csv");
+
+		Stream<Object[]> arguments = provide(new CsvFileArgumentsProvider(), annotation);
+
+		assertThat(arguments).containsExactly(new Object[] { "foo" }, new Object[] { "bar" }, new Object[] { "baz" },
+			new Object[] { "qux" }, new Object[] { "vacio" });
+	}
+
 	@Test
 	void readsFromMultipleClasspathResources() {
-		CsvFileSource annotation = annotation("ISO-8859-1", "\n", ',', "/single-column.csv", "/single-column.csv");
+		CsvFileSource annotation = annotation("ISO-8859-1", "\n", ',', "", "/single-column.csv", "/single-column.csv");
 
 		Stream<Object[]> arguments = provide(new CsvFileArgumentsProvider(), annotation);
 
@@ -84,7 +94,7 @@ class CsvFileArgumentsProviderTests {
 
 	@Test
 	void readsFromSingleClasspathResourceWithHeaders() {
-		CsvFileSource annotation = annotation("ISO-8859-1", "\n", ',', 1, "/single-column.csv");
+		CsvFileSource annotation = annotation("ISO-8859-1", "\n", ',', "", 1, "/single-column.csv");
 
 		Stream<Object[]> arguments = provide(new CsvFileArgumentsProvider(), annotation);
 
@@ -94,7 +104,7 @@ class CsvFileArgumentsProviderTests {
 
 	@Test
 	void readsFromSingleClasspathResourceWithMoreHeadersThanLines() {
-		CsvFileSource annotation = annotation("ISO-8859-1", "\n", ',', 10, "/single-column.csv");
+		CsvFileSource annotation = annotation("ISO-8859-1", "\n", ',', "", 10, "/single-column.csv");
 
 		Stream<Object[]> arguments = provide(new CsvFileArgumentsProvider(), annotation);
 
@@ -103,7 +113,8 @@ class CsvFileArgumentsProviderTests {
 
 	@Test
 	void readsFromMultipleClasspathResourcesWithHeaders() {
-		CsvFileSource annotation = annotation("ISO-8859-1", "\n", ',', 1, "/single-column.csv", "/single-column.csv");
+		CsvFileSource annotation = annotation("ISO-8859-1", "\n", ',', "", 1, "/single-column.csv",
+			"/single-column.csv");
 
 		Stream<Object[]> arguments = provide(new CsvFileArgumentsProvider(), annotation);
 
@@ -114,7 +125,7 @@ class CsvFileArgumentsProviderTests {
 
 	@Test
 	void throwsExceptionForMissingClasspathResource() {
-		CsvFileSource annotation = annotation("UTF-8", "\n", ',', "/does-not-exist.csv");
+		CsvFileSource annotation = annotation("UTF-8", "\n", ',', "", "/does-not-exist.csv");
 
 		PreconditionViolationException exception = assertThrows(PreconditionViolationException.class,
 			() -> provide(new CsvFileArgumentsProvider(), annotation).toArray());
@@ -124,7 +135,7 @@ class CsvFileArgumentsProviderTests {
 
 	@Test
 	void throwsExceptionForBlankClasspathResource() {
-		CsvFileSource annotation = annotation("UTF-8", "\n", ',', "    ");
+		CsvFileSource annotation = annotation("UTF-8", "\n", ',', "", "    ");
 
 		PreconditionViolationException exception = assertThrows(PreconditionViolationException.class,
 			() -> provide(new CsvFileArgumentsProvider(), annotation).toArray());
@@ -146,7 +157,7 @@ class CsvFileArgumentsProviderTests {
 
 	@Test
 	void throwsExceptionForInvalidCsvFormat() {
-		CsvFileSource annotation = annotation("UTF-8", "\n", ',', "/broken.csv");
+		CsvFileSource annotation = annotation("UTF-8", "\n", ',', "", "/broken.csv");
 
 		CsvParsingException exception = assertThrows(CsvParsingException.class,
 			() -> provide(new CsvFileArgumentsProvider(), annotation).toArray());
@@ -156,29 +167,33 @@ class CsvFileArgumentsProviderTests {
 				.hasRootCauseInstanceOf(ArrayIndexOutOfBoundsException.class);
 	}
 
-	private CsvFileSource annotation(String charset, String lineSeparator, char delimiter, String... resources) {
-		return annotation(charset, lineSeparator, delimiter, 0, resources);
+	private CsvFileSource annotation(String charset, String lineSeparator, char delimiter, String emptyValue,
+			String... resources) {
+		return annotation(charset, lineSeparator, delimiter, emptyValue, 0, resources);
 	}
 
-	private CsvFileSource annotation(String charset, String lineSeparator, char delimiter, int numLinesToSkip,
-			String... resources) {
+	private CsvFileSource annotation(String charset, String lineSeparator, char delimiter, String emptyValue,
+			int numLinesToSkip, String... resources) {
 
 		CsvFileSource annotation = mock(CsvFileSource.class);
 		when(annotation.resources()).thenReturn(resources);
 		when(annotation.encoding()).thenReturn(charset);
 		when(annotation.lineSeparator()).thenReturn(lineSeparator);
 		when(annotation.delimiter()).thenReturn(delimiter);
+		when(annotation.emptyValue()).thenReturn(emptyValue);
 		when(annotation.numLinesToSkip()).thenReturn(numLinesToSkip);
 		return annotation;
 	}
 
-	private Stream<Object[]> provideArguments(String content, String lineSeparator, char delimiter) {
-		return provideArguments(new ByteArrayInputStream(content.getBytes(UTF_8)), lineSeparator, delimiter);
+	private Stream<Object[]> provideArguments(String content, String lineSeparator, char delimiter, String emptyValue) {
+		return provideArguments(new ByteArrayInputStream(content.getBytes(UTF_8)), lineSeparator, delimiter,
+			emptyValue);
 	}
 
-	private Stream<Object[]> provideArguments(InputStream inputStream, String lineSeparator, char delimiter) {
+	private Stream<Object[]> provideArguments(InputStream inputStream, String lineSeparator, char delimiter,
+			String emptyValue) {
 		String expectedResource = "foo/bar";
-		CsvFileSource annotation = annotation("ISO-8859-1", lineSeparator, delimiter, expectedResource);
+		CsvFileSource annotation = annotation("ISO-8859-1", lineSeparator, delimiter, emptyValue, expectedResource);
 
 		CsvFileArgumentsProvider provider = new CsvFileArgumentsProvider((testClass, resource) -> {
 			assertThat(resource).isEqualTo(expectedResource);
