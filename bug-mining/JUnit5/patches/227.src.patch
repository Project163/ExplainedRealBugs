diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.4.0-M1.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.4.0-M1.adoc
index c0d0cd3ca..7820ea748 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.4.0-M1.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.4.0-M1.adoc
@@ -63,6 +63,8 @@ repository on GitHub.
 * When executing tests in parallel, lifecycle methods and callbacks called after a
   `@TestFactory` method are now always executed after the dynamic tests returned by the
   method.
+* Exceptions thrown during initialization of static `@RegisterExtension` fields now cause
+  the test class to fail instead of being silently swallowed.
 
 ==== Deprecations and Breaking Changes
 
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/ProgrammaticExtensionRegistrationTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/ProgrammaticExtensionRegistrationTests.java
index c4bf88995..de1ea2ba4 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/ProgrammaticExtensionRegistrationTests.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/ProgrammaticExtensionRegistrationTests.java
@@ -10,14 +10,20 @@
 
 package org.junit.jupiter.engine.extension;
 
+import static org.assertj.core.api.Assertions.allOf;
 import static org.junit.jupiter.api.Assertions.assertAll;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertNotNull;
 import static org.junit.jupiter.api.TestInstance.Lifecycle.PER_CLASS;
+import static org.junit.platform.testkit.engine.EventConditions.finishedWithFailure;
+import static org.junit.platform.testkit.engine.TestExecutionResultConditions.hasCause;
+import static org.junit.platform.testkit.engine.TestExecutionResultConditions.isA;
+import static org.junit.platform.testkit.engine.TestExecutionResultConditions.message;
 
 import java.lang.reflect.Field;
 import java.util.function.Predicate;
 
+import org.assertj.core.api.Condition;
 import org.junit.jupiter.api.AfterAll;
 import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.BeforeAll;
@@ -25,6 +31,7 @@ import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.TestInstance;
 import org.junit.jupiter.api.extension.ExtendWith;
+import org.junit.jupiter.api.extension.Extension;
 import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.api.extension.ParameterContext;
 import org.junit.jupiter.api.extension.ParameterResolver;
@@ -75,6 +82,28 @@ class ProgrammaticExtensionRegistrationTests extends AbstractJupiterTestEngineTe
 		assertOneTestSucceeded(ExtensionRegistrationFromInterfaceTestCase.class);
 	}
 
+	@Test
+	void propagatesCheckedExceptionThrownDuringInitializationOfStaticField() {
+		assertClassFails(ExplosiveCheckedExceptionTestCase.class,
+			allOf(isA(ExceptionInInitializerError.class), hasCause(allOf(isA(Exception.class), message("boom")))));
+	}
+
+	@Test
+	void propagatesUncheckedExceptionThrownDuringInitializationOfStaticField() {
+		assertClassFails(ExplosiveUncheckedExceptionTestCase.class, allOf(isA(ExceptionInInitializerError.class),
+			hasCause(allOf(isA(RuntimeException.class), message("boom")))));
+	}
+
+	@Test
+	void propagatesErrorThrownDuringInitializationOfStaticField() {
+		assertClassFails(ExplosiveErrorTestCase.class, allOf(isA(Error.class), message("boom")));
+	}
+
+	private void assertClassFails(Class<?> testClass, Condition<Throwable> boom) {
+		EngineExecutionResults executionResults = executeTestsForClass(testClass);
+		executionResults.containers().assertThatEvents().haveExactly(1, finishedWithFailure(boom));
+	}
+
 	private void assertOneTestSucceeded(Class<?> testClass) {
 		EngineExecutionResults executionResults = executeTestsForClass(testClass);
 		assertAll(//
@@ -269,6 +298,43 @@ class ProgrammaticExtensionRegistrationTests extends AbstractJupiterTestEngineTe
 
 	}
 
+	static class AbstractTestCase {
+
+		@Test
+		void test() {
+		}
+
+	}
+
+	static class ExplosiveCheckedExceptionTestCase extends AbstractTestCase {
+
+		@RegisterExtension
+		static Extension field = new ExplosiveExtension(new Exception("boom"));
+
+	}
+
+	static class ExplosiveUncheckedExceptionTestCase extends AbstractTestCase {
+
+		@RegisterExtension
+		static Extension field = new ExplosiveExtension(new RuntimeException("boom"));
+
+	}
+
+	static class ExplosiveErrorTestCase extends AbstractTestCase {
+
+		@RegisterExtension
+		static Extension field = new ExplosiveExtension(new Error("boom"));
+
+	}
+
+	static class ExplosiveExtension implements Extension {
+
+		ExplosiveExtension(Throwable t) {
+			throw ExceptionUtils.throwAsUncheckedException(t);
+		}
+
+	}
+
 	/**
 	 * Mimics a dependency injection framework such as Spring, Guice, CDI, etc.,
 	 * where the instance of the extension registered via
diff --git a/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/TestExecutionResultConditions.java b/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/TestExecutionResultConditions.java
index 0975ca9ad..72bcba087 100644
--- a/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/TestExecutionResultConditions.java
+++ b/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/TestExecutionResultConditions.java
@@ -58,6 +58,10 @@ public class TestExecutionResultConditions {
 			"suppressed at index %d matches %s", index, checked);
 	}
 
+	public static Condition<Throwable> hasCause(Condition<Throwable> checked) {
+		return new Condition<>(throwable -> checked.matches(throwable.getCause()), "cause matches %s", checked);
+	}
+
 	public static Condition<TestExecutionResult> cause(Condition<? super Throwable> condition) {
 		return new Condition<>(where(TestExecutionResult::getThrowable,
 			throwable -> throwable.isPresent() && condition.matches(throwable.get())), "cause where %s", condition);
