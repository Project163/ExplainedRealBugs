diff --git a/documentation/src/docs/asciidoc/link-attributes.adoc b/documentation/src/docs/asciidoc/link-attributes.adoc
index 1504f7fc0..ec6ce1494 100644
--- a/documentation/src/docs/asciidoc/link-attributes.adoc
+++ b/documentation/src/docs/asciidoc/link-attributes.adoc
@@ -112,12 +112,14 @@ endif::[]
 :Assumptions:                                {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/Assumptions.html[org.junit.jupiter.api.Assumptions]
 :AutoClose:                                  {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/AutoClose.html[@AutoClose]
 :ClassOrderer_ClassName:                     {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/ClassOrderer.ClassName.html[ClassOrderer.ClassName]
+:ClassOrderer_Default:                       {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/ClassOrderer.Default.html[ClassOrderer.Default]
 :ClassOrderer_DisplayName:                   {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/ClassOrderer.DisplayName.html[ClassOrderer.DisplayName]
 :ClassOrderer_OrderAnnotation:               {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/ClassOrderer.OrderAnnotation.html[ClassOrderer.OrderAnnotation]
 :ClassOrderer_Random:                        {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/ClassOrderer.Random.html[ClassOrderer.Random]
 :ClassOrderer:                               {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/ClassOrderer.html[ClassOrderer]
 :ClassTemplate:                              {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/ClassTemplate.html[@ClassTemplate]
 :Disabled:                                   {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/Disabled.html[@Disabled]
+:MethodOrderer_Default:                      {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/MethodOrderer.Default.html[MethodOrderer.Default]
 :MethodOrderer_DisplayName:                  {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/MethodOrderer.DisplayName.html[MethodOrderer.DisplayName]
 :MethodOrderer_MethodName:                   {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/MethodOrderer.MethodName.html[MethodOrderer.MethodName]
 :MethodOrderer_OrderAnnotation:              {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/MethodOrderer.OrderAnnotation.html[MethodOrderer.OrderAnnotation]
diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-6.0.0-RC1.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-6.0.0-RC1.adoc
index 448ee7e73..57be64795 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-6.0.0-RC1.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-6.0.0-RC1.adoc
@@ -75,6 +75,12 @@ repository on GitHub.
 * Non-printable control characters in display names are now replaced with alternative
   representations. Please refer to the
   <<../user-guide/index.adoc#writing-tests-display-names, User Guide>> for details.
+* For consistency with `@TestClassOrder`, `@TestMethodOrder` annotations specified on a
+  test class are now inherited by its `@Nested` inner classes, recursively.
+* Introduce `MethodOrderer.Default` and `ClassOrderer.Default` for reverting back to
+  default ordering on a `@Nested` class and its `@Nested` inner classes when an enclosing
+  class specifies a different orderer via `@TestMethodOrder` or `@TestClassOrder`,
+  respectively.
 
 
 [[release-notes-6.0.0-RC1-junit-vintage]]
diff --git a/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc b/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
index 32a533d3b..964968762 100644
--- a/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
+++ b/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
@@ -1037,6 +1037,11 @@ following built-in `MethodOrderer` implementations.
 * `{MethodOrderer_Random}`: orders test methods _pseudo-randomly_ and supports
   configuration of a custom _seed_
 
+The `MethodOrderer` configured on a test class is inherited by the `@Nested` test classes
+it contains, recursively. If you want to avoid that a `@Nested` test class uses the same
+`MethodOrderer` as its enclosing class, you can specify `{MethodOrderer_Default}` together
+with `{TestMethodOrder}`.
+
 NOTE: See also: <<extensions-execution-order-wrapping-behavior>>
 
 The following example demonstrates how to guarantee that test methods are executed in the
@@ -1125,6 +1130,8 @@ To configure test class execution order _locally_ for `@Nested` test classes, de
 want to order, and supply a class reference to the `ClassOrderer` implementation you would
 like to use directly in the `@TestClassOrder` annotation. The configured `ClassOrderer`
 will be applied recursively to `@Nested` test classes and their `@Nested` test classes.
+If you want to avoid that a `@Nested` test class uses the same `ClassOrderer` as its
+enclosing class, you can specify `{ClassOrderer_Default}` together with `@TestClassOrder`.
 Note that a local `@TestClassOrder` declaration always overrides an inherited
 `@TestClassOrder` declaration or a `ClassOrderer` configured globally via the
 `junit.jupiter.testclass.order.default` configuration parameter.
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/ClassOrderer.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/ClassOrderer.java
index 224c07fd3..55b405207 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/ClassOrderer.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/ClassOrderer.java
@@ -11,12 +11,14 @@
 package org.junit.jupiter.api;
 
 import static java.util.Comparator.comparingInt;
+import static org.apiguardian.api.API.Status.EXPERIMENTAL;
 import static org.apiguardian.api.API.Status.STABLE;
 
 import java.util.Collections;
 import java.util.Comparator;
 
 import org.apiguardian.api.API;
+import org.junit.platform.commons.JUnitException;
 import org.junit.platform.commons.logging.Logger;
 import org.junit.platform.commons.logging.LoggerFactory;
 
@@ -46,6 +48,7 @@ import org.junit.platform.commons.logging.LoggerFactory;
  *
  * <ul>
  * <li>{@link ClassOrderer.ClassName}</li>
+ * <li>{@link ClassOrderer.Default}</li>
  * <li>{@link ClassOrderer.DisplayName}</li>
  * <li>{@link ClassOrderer.OrderAnnotation}</li>
  * <li>{@link ClassOrderer.Random}</li>
@@ -97,6 +100,35 @@ public interface ClassOrderer {
 	 */
 	void orderClasses(ClassOrdererContext context);
 
+	/**
+	 * {@code ClassOrderer} that allows to explicitly specify that the default
+	 * ordering should be applied.
+	 *
+	 * <p>If the {@value #DEFAULT_ORDER_PROPERTY_NAME} is set, specifying this
+	 * {@code ClassOrderer} has the same effect as referencing the configured
+	 * class directly. Otherwise, it has the same effect as not specifying any
+	 * {@code ClassOrderer}.
+	 *
+	 * <p>This class can be used to reset the {@code ClassOrderer} for a
+	 * {@link Nested @Nested} class and its {@code @Nested} inner classes,
+	 * recursively, when a {@code ClassOrderer} is configured using
+	 * {@link TestClassOrder @TestClassOrder} on an enclosing class.
+	 *
+	 * @since 6.0
+	 */
+	@API(status = EXPERIMENTAL, since = "6.0")
+	final class Default implements ClassOrderer {
+
+		private Default() {
+			throw new JUnitException("This class must not be instantiated");
+		}
+
+		@Override
+		public void orderClasses(ClassOrdererContext context) {
+			// never called
+		}
+	}
+
 	/**
 	 * {@code ClassOrderer} that sorts classes alphanumerically based on their
 	 * fully qualified names using {@link String#compareTo(String)}.
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/MethodOrderer.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/MethodOrderer.java
index f1b60a0f4..6552e66aa 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/MethodOrderer.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/MethodOrderer.java
@@ -11,6 +11,7 @@
 package org.junit.jupiter.api;
 
 import static java.util.Comparator.comparingInt;
+import static org.apiguardian.api.API.Status.EXPERIMENTAL;
 import static org.apiguardian.api.API.Status.STABLE;
 
 import java.lang.reflect.Method;
@@ -20,6 +21,7 @@ import java.util.Optional;
 
 import org.apiguardian.api.API;
 import org.junit.jupiter.api.parallel.ExecutionMode;
+import org.junit.platform.commons.JUnitException;
 import org.junit.platform.commons.logging.Logger;
 import org.junit.platform.commons.logging.LoggerFactory;
 import org.junit.platform.commons.util.ClassUtils;
@@ -43,6 +45,7 @@ import org.junit.platform.commons.util.ClassUtils;
  * implementations.
  *
  * <ul>
+ * <li>{@link Default}</li>
  * <li>{@link MethodName}</li>
  * <li>{@link OrderAnnotation}</li>
  * <li>{@link Random}</li>
@@ -125,6 +128,35 @@ public interface MethodOrderer {
 		return Optional.of(ExecutionMode.SAME_THREAD);
 	}
 
+	/**
+	 * {@code MethodOrderer} that allows to explicitly specify that the default
+	 * ordering should be applied.
+	 *
+	 * <p>If the {@value #DEFAULT_ORDER_PROPERTY_NAME} is set, specifying this
+	 * {@code MethodOrderer} has the same effect as referencing the configured
+	 * class directly. Otherwise, it has the same effect as not specifying any
+	 * {@code MethodOrderer}.
+	 *
+	 * <p>This class can be used to reset the {@code MethodOrderer} for a
+	 * {@link Nested @Nested} class and its {@code @Nested} inner classes,
+	 * recursively, when a {@code MethodOrderer} is configured using
+	 * {@link TestMethodOrder @TestMethodOrder} on an enclosing class.
+	 *
+	 * @since 6.0
+	 */
+	@API(status = EXPERIMENTAL, since = "6.0")
+	final class Default implements MethodOrderer {
+
+		private Default() {
+			throw new JUnitException("This class must not be instantiated");
+		}
+
+		@Override
+		public void orderMethods(MethodOrdererContext context) {
+			// never called
+		}
+	}
+
 	/**
 	 * {@code MethodOrderer} that sorts methods alphanumerically based on their
 	 * names using {@link String#compareTo(String)}.
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/TestClassOrder.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/TestClassOrder.java
index 0f9ad73dd..3781188c9 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/TestClassOrder.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/TestClassOrder.java
@@ -29,7 +29,8 @@ import org.apiguardian.api.API;
  * <p>If {@code @TestClassOrder} is not explicitly declared on a test class,
  * inherited from a parent class, declared on a test interface implemented by
  * a test class, or inherited from an {@linkplain Class#getEnclosingClass() enclosing
- * class}, {@code @Nested} test classes will be executed in arbitrary order.
+ * class}, {@code @Nested} test classes will be ordered using a default
+ * algorithm that is deterministic but intentionally nonobvious.
  *
  * <p>As an alternative to {@code @TestClassOrder}, a global {@link ClassOrderer}
  * can be configured for the entire test suite via the
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/TestMethodOrder.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/TestMethodOrder.java
index c1df77510..18c54933d 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/TestMethodOrder.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/TestMethodOrder.java
@@ -32,8 +32,9 @@ import org.junit.jupiter.api.parallel.Execution;
  * {@code @TestFactory}, or {@code @TestTemplate}.
  *
  * <p>If {@code @TestMethodOrder} is not explicitly declared on a test class,
- * inherited from a parent class, or declared on a test interface implemented by
- * a test class, test methods will be ordered using a default algorithm that is
+ * inherited from a parent class, declared on a test interface implemented by
+ * a test class, or inherited from an {@linkplain Class#getEnclosingClass() enclosing
+ * class}, test methods will be ordered using a default algorithm that is
  * deterministic but intentionally nonobvious.
  *
  * <p>As an alternative to {@code @TestMethodOrder}, a global {@link MethodOrderer}
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/config/ConfigurationParameterConverter.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/config/ConfigurationParameterConverter.java
new file mode 100644
index 000000000..ea26a2cdc
--- /dev/null
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/config/ConfigurationParameterConverter.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright 2015-2025 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.engine.config;
+
+import java.util.Optional;
+
+import org.junit.platform.engine.ConfigurationParameters;
+
+/**
+ * @since 6.0
+ */
+interface ConfigurationParameterConverter<T> {
+
+	default T getOrDefault(ConfigurationParameters configParams, String key, T defaultValue) {
+		return get(configParams, key).orElse(defaultValue);
+	}
+
+	Optional<T> get(ConfigurationParameters configurationParameters, String key);
+
+}
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/config/DefaultJupiterConfiguration.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/config/DefaultJupiterConfiguration.java
index 081095399..5da69f98f 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/config/DefaultJupiterConfiguration.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/config/DefaultJupiterConfiguration.java
@@ -10,10 +10,12 @@
 
 package org.junit.jupiter.engine.config;
 
+import static java.util.function.Predicate.isEqual;
 import static org.apiguardian.api.API.Status.INTERNAL;
 import static org.junit.jupiter.api.io.CleanupMode.ALWAYS;
 import static org.junit.jupiter.api.io.TempDir.DEFAULT_CLEANUP_MODE_PROPERTY_NAME;
 import static org.junit.jupiter.api.io.TempDir.DEFAULT_FACTORY_PROPERTY_NAME;
+import static org.junit.jupiter.engine.config.FilteringConfigurationParameterConverter.exclude;
 
 import java.util.List;
 import java.util.Optional;
@@ -53,28 +55,30 @@ public class DefaultJupiterConfiguration implements JupiterConfiguration {
 		"junit.jupiter.params.arguments.conversion.locale.format" //
 	);
 
-	private static final EnumConfigurationParameterConverter<ExecutionMode> executionModeConverter = //
+	private static final ConfigurationParameterConverter<ExecutionMode> executionModeConverter = //
 		new EnumConfigurationParameterConverter<>(ExecutionMode.class, "parallel execution mode");
 
-	private static final EnumConfigurationParameterConverter<Lifecycle> lifecycleConverter = //
+	private static final ConfigurationParameterConverter<Lifecycle> lifecycleConverter = //
 		new EnumConfigurationParameterConverter<>(Lifecycle.class, "test instance lifecycle mode");
 
-	private static final InstantiatingConfigurationParameterConverter<DisplayNameGenerator> displayNameGeneratorConverter = //
+	private static final ConfigurationParameterConverter<DisplayNameGenerator> displayNameGeneratorConverter = //
 		new InstantiatingConfigurationParameterConverter<>(DisplayNameGenerator.class, "display name generator");
 
-	private static final InstantiatingConfigurationParameterConverter<MethodOrderer> methodOrdererConverter = //
-		new InstantiatingConfigurationParameterConverter<>(MethodOrderer.class, "method orderer");
+	private static final ConfigurationParameterConverter<MethodOrderer> methodOrdererConverter = //
+		exclude(isEqual(MethodOrderer.Default.class.getName()),
+			new InstantiatingConfigurationParameterConverter<>(MethodOrderer.class, "method orderer"));
 
-	private static final InstantiatingConfigurationParameterConverter<ClassOrderer> classOrdererConverter = //
-		new InstantiatingConfigurationParameterConverter<>(ClassOrderer.class, "class orderer");
+	private static final ConfigurationParameterConverter<ClassOrderer> classOrdererConverter = //
+		exclude(isEqual(ClassOrderer.Default.class.getName()),
+			new InstantiatingConfigurationParameterConverter<>(ClassOrderer.class, "class orderer"));
 
-	private static final EnumConfigurationParameterConverter<CleanupMode> cleanupModeConverter = //
+	private static final ConfigurationParameterConverter<CleanupMode> cleanupModeConverter = //
 		new EnumConfigurationParameterConverter<>(CleanupMode.class, "cleanup mode");
 
 	private static final InstantiatingConfigurationParameterConverter<TempDirFactory> tempDirFactoryConverter = //
 		new InstantiatingConfigurationParameterConverter<>(TempDirFactory.class, "temp dir factory");
 
-	private static final EnumConfigurationParameterConverter<ExtensionContextScope> extensionContextScopeConverter = //
+	private static final ConfigurationParameterConverter<ExtensionContextScope> extensionContextScopeConverter = //
 		new EnumConfigurationParameterConverter<>(ExtensionContextScope.class, "extension context scope");
 
 	private final ConfigurationParameters configurationParameters;
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/config/EnumConfigurationParameterConverter.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/config/EnumConfigurationParameterConverter.java
index 4121adece..a4c0d3b21 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/config/EnumConfigurationParameterConverter.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/config/EnumConfigurationParameterConverter.java
@@ -26,7 +26,7 @@ import org.junit.platform.engine.ConfigurationParameters;
  * @since 5.4
  */
 @API(status = INTERNAL, since = "5.8")
-public class EnumConfigurationParameterConverter<E extends Enum<E>> {
+public class EnumConfigurationParameterConverter<E extends Enum<E>> implements ConfigurationParameterConverter<E> {
 
 	private static final Logger logger = LoggerFactory.getLogger(EnumConfigurationParameterConverter.class);
 
@@ -38,14 +38,14 @@ public class EnumConfigurationParameterConverter<E extends Enum<E>> {
 		this.enumDisplayName = enumDisplayName;
 	}
 
-	public Optional<E> get(ExtensionContext extensionContext, String key) {
-		return extensionContext.getConfigurationParameter(key, value -> convert(key, value));
+	@Override
+	public Optional<E> get(ConfigurationParameters configParams, String key) {
+		return configParams.get(key) //
+				.map(value -> convert(key, value));
 	}
 
-	E getOrDefault(ConfigurationParameters configParams, String key, E defaultValue) {
-		return configParams.get(key) //
-				.map(value -> convert(key, value)) //
-				.orElse(defaultValue);
+	public Optional<E> get(ExtensionContext extensionContext, String key) {
+		return extensionContext.getConfigurationParameter(key, value -> convert(key, value));
 	}
 
 	private E convert(String key, String value) {
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/config/FilteringConfigurationParameterConverter.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/config/FilteringConfigurationParameterConverter.java
new file mode 100644
index 000000000..f70e390d5
--- /dev/null
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/config/FilteringConfigurationParameterConverter.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2015-2025 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.engine.config;
+
+import static java.util.function.Predicate.not;
+
+import java.util.Optional;
+import java.util.function.Predicate;
+
+import org.junit.platform.engine.ConfigurationParameters;
+
+/**
+ * @since 6.0
+ */
+class FilteringConfigurationParameterConverter<T> implements ConfigurationParameterConverter<T> {
+
+	private final Predicate<? super String> predicate;
+	private final ConfigurationParameterConverter<T> delegate;
+
+	static <T> FilteringConfigurationParameterConverter<T> exclude(Predicate<? super String> exclusion,
+			ConfigurationParameterConverter<T> delegate) {
+		return new FilteringConfigurationParameterConverter<>(not(exclusion), delegate);
+	}
+
+	private FilteringConfigurationParameterConverter(Predicate<? super String> predicate,
+			ConfigurationParameterConverter<T> delegate) {
+		this.predicate = predicate;
+		this.delegate = delegate;
+	}
+
+	@Override
+	public Optional<T> get(ConfigurationParameters configurationParameters, String key) {
+		return configurationParameters.get(key) //
+				.map(String::strip) //
+				.filter(predicate) //
+				.flatMap(__ -> delegate.get(configurationParameters, key));
+	}
+
+}
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/config/InstantiatingConfigurationParameterConverter.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/config/InstantiatingConfigurationParameterConverter.java
index 5e5d3f4e8..7315af7b9 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/config/InstantiatingConfigurationParameterConverter.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/config/InstantiatingConfigurationParameterConverter.java
@@ -22,7 +22,7 @@ import org.junit.platform.engine.ConfigurationParameters;
 /**
  * @since 5.5
  */
-class InstantiatingConfigurationParameterConverter<T> {
+class InstantiatingConfigurationParameterConverter<T> implements ConfigurationParameterConverter<T> {
 
 	private static final Logger logger = LoggerFactory.getLogger(InstantiatingConfigurationParameterConverter.class);
 
@@ -34,7 +34,8 @@ class InstantiatingConfigurationParameterConverter<T> {
 		this.name = name;
 	}
 
-	Optional<T> get(ConfigurationParameters configurationParameters, String key) {
+	@Override
+	public Optional<T> get(ConfigurationParameters configurationParameters, String key) {
 		return supply(configurationParameters, key).get();
 	}
 
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/AbstractOrderingVisitor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/AbstractOrderingVisitor.java
index 5dfedbc48..5f1ba08f8 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/AbstractOrderingVisitor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/AbstractOrderingVisitor.java
@@ -69,10 +69,10 @@ abstract class AbstractOrderingVisitor implements TestDescriptor.Visitor {
 	/**
 	 * @param <CHILD> the type of children (containers or tests) to order
 	 */
-	protected <CHILD extends TestDescriptor, WRAPPER extends AbstractAnnotatedDescriptorWrapper<?>> void orderChildrenTestDescriptors(
-			TestDescriptor parentTestDescriptor, Class<CHILD> matchingChildrenType,
-			Optional<Consumer<CHILD>> validationAction, Function<CHILD, WRAPPER> descriptorWrapperFactory,
-			DescriptorWrapperOrderer<?, WRAPPER> descriptorWrapperOrderer) {
+	protected <PARENT extends TestDescriptor, CHILD extends TestDescriptor, WRAPPER extends AbstractAnnotatedDescriptorWrapper<?>> void orderChildrenTestDescriptors(
+			PARENT parentTestDescriptor, Class<CHILD> matchingChildrenType, Optional<Consumer<CHILD>> validationAction,
+			Function<CHILD, WRAPPER> descriptorWrapperFactory,
+			DescriptorWrapperOrderer<PARENT, ?, WRAPPER> descriptorWrapperOrderer) {
 
 		Stream<CHILD> matchingChildren = parentTestDescriptor.getChildren()//
 				.stream()//
@@ -101,7 +101,7 @@ abstract class AbstractOrderingVisitor implements TestDescriptor.Visitor {
 			Stream<TestDescriptor> nonMatchingTestDescriptors = children.stream()//
 					.filter(childTestDescriptor -> !matchingChildrenType.isInstance(childTestDescriptor));
 
-			descriptorWrapperOrderer.orderWrappers(matchingDescriptorWrappers,
+			descriptorWrapperOrderer.orderWrappers(parentTestDescriptor, matchingDescriptorWrappers,
 				message -> reportWarning(parentTestDescriptor, message));
 
 			Stream<TestDescriptor> orderedTestDescriptors = matchingDescriptorWrappers.stream()//
@@ -128,27 +128,27 @@ abstract class AbstractOrderingVisitor implements TestDescriptor.Visitor {
 	/**
 	 * @param <WRAPPER> the wrapper type for the children to order
 	 */
-	protected static class DescriptorWrapperOrderer<ORDERER, WRAPPER> {
+	protected static class DescriptorWrapperOrderer<PARENT extends TestDescriptor, ORDERER, WRAPPER> {
 
-		private static final DescriptorWrapperOrderer<?, ?> NOOP = new DescriptorWrapperOrderer<>(null, null, __ -> "",
-			___ -> "");
+		private static final DescriptorWrapperOrderer<?, ?, ?> NOOP = new DescriptorWrapperOrderer<>(null, null,
+			(__, ___) -> "", (__, ___) -> "");
 
 		@SuppressWarnings("unchecked")
-		protected static <ORDERER, WRAPPER> DescriptorWrapperOrderer<ORDERER, WRAPPER> noop() {
-			return (DescriptorWrapperOrderer<ORDERER, WRAPPER>) NOOP;
+		static <PARENT extends TestDescriptor, ORDERER, WRAPPER extends AbstractAnnotatedDescriptorWrapper<?>> DescriptorWrapperOrderer<PARENT, ORDERER, WRAPPER> noop() {
+			return (DescriptorWrapperOrderer<PARENT, ORDERER, WRAPPER>) NOOP;
 		}
 
 		@Nullable
 		private final ORDERER orderer;
 		@Nullable
-		private final Consumer<List<WRAPPER>> orderingAction;
+		private final OrderingAction<PARENT, WRAPPER> orderingAction;
 
-		private final MessageGenerator descriptorsAddedMessageGenerator;
-		private final MessageGenerator descriptorsRemovedMessageGenerator;
+		private final MessageGenerator<PARENT> descriptorsAddedMessageGenerator;
+		private final MessageGenerator<PARENT> descriptorsRemovedMessageGenerator;
 
-		DescriptorWrapperOrderer(@Nullable ORDERER orderer, @Nullable Consumer<List<WRAPPER>> orderingAction,
-				MessageGenerator descriptorsAddedMessageGenerator,
-				MessageGenerator descriptorsRemovedMessageGenerator) {
+		DescriptorWrapperOrderer(@Nullable ORDERER orderer, @Nullable OrderingAction<PARENT, WRAPPER> orderingAction,
+				MessageGenerator<PARENT> descriptorsAddedMessageGenerator,
+				MessageGenerator<PARENT> descriptorsRemovedMessageGenerator) {
 
 			this.orderer = orderer;
 			this.orderingAction = orderingAction;
@@ -165,18 +165,18 @@ abstract class AbstractOrderingVisitor implements TestDescriptor.Visitor {
 			return this.orderingAction != null;
 		}
 
-		private void orderWrappers(List<WRAPPER> wrappers, Consumer<String> errorHandler) {
+		private void orderWrappers(PARENT parentTestDescriptor, List<WRAPPER> wrappers, Consumer<String> errorHandler) {
 			List<WRAPPER> orderedWrappers = new ArrayList<>(wrappers);
-			requireNonNull(this.orderingAction).accept(orderedWrappers);
+			requireNonNull(this.orderingAction).order(parentTestDescriptor, orderedWrappers);
 			Map<Object, Integer> distinctWrappersToIndex = distinctWrappersToIndex(orderedWrappers);
 
 			int difference = orderedWrappers.size() - wrappers.size();
 			int distinctDifference = distinctWrappersToIndex.size() - wrappers.size();
 			if (difference > 0) { // difference >= distinctDifference
-				reportDescriptorsAddedWarning(difference, errorHandler);
+				reportDescriptorsAddedWarning(difference, errorHandler, parentTestDescriptor);
 			}
 			if (distinctDifference < 0) { // distinctDifference <= difference
-				reportDescriptorsRemovedWarning(distinctDifference, errorHandler);
+				reportDescriptorsRemovedWarning(distinctDifference, errorHandler, parentTestDescriptor);
 			}
 
 			wrappers.sort(comparing(wrapper -> distinctWrappersToIndex.getOrDefault(wrapper, -1)));
@@ -194,20 +194,29 @@ abstract class AbstractOrderingVisitor implements TestDescriptor.Visitor {
 			return toIndex;
 		}
 
-		private void reportDescriptorsAddedWarning(int number, Consumer<String> errorHandler) {
-			errorHandler.accept(this.descriptorsAddedMessageGenerator.generateMessage(number));
+		private void reportDescriptorsAddedWarning(int number, Consumer<String> errorHandler,
+				PARENT parentTestDescriptor) {
+			errorHandler.accept(this.descriptorsAddedMessageGenerator.generateMessage(parentTestDescriptor, number));
 		}
 
-		private void reportDescriptorsRemovedWarning(int number, Consumer<String> errorHandler) {
-			errorHandler.accept(this.descriptorsRemovedMessageGenerator.generateMessage(Math.abs(number)));
+		private void reportDescriptorsRemovedWarning(int number, Consumer<String> errorHandler,
+				PARENT parentTestDescriptor) {
+			errorHandler.accept(
+				this.descriptorsRemovedMessageGenerator.generateMessage(parentTestDescriptor, Math.abs(number)));
 		}
 
 	}
 
 	@FunctionalInterface
-	protected interface MessageGenerator {
+	protected interface OrderingAction<PARENT extends TestDescriptor, WRAPPER> {
 
-		String generateMessage(int number);
+		void order(PARENT testDescriptor, List<WRAPPER> wrappers);
+	}
+
+	@FunctionalInterface
+	protected interface MessageGenerator<PARENT extends TestDescriptor> {
+
+		String generateMessage(PARENT testDescriptor, int number);
 	}
 
 }
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/ClassOrderingVisitor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/ClassOrderingVisitor.java
index b45250e06..27904f710 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/ClassOrderingVisitor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/ClassOrderingVisitor.java
@@ -12,16 +12,17 @@ package org.junit.jupiter.engine.discovery;
 
 import static org.junit.platform.commons.support.AnnotationSupport.isAnnotated;
 
-import java.util.List;
 import java.util.Optional;
 import java.util.function.Consumer;
 
+import org.jspecify.annotations.Nullable;
 import org.junit.jupiter.api.ClassOrderer;
 import org.junit.jupiter.api.Order;
 import org.junit.jupiter.api.TestClassOrder;
 import org.junit.jupiter.engine.config.JupiterConfiguration;
 import org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor;
 import org.junit.jupiter.engine.descriptor.JupiterEngineDescriptor;
+import org.junit.jupiter.engine.descriptor.TestClassAware;
 import org.junit.platform.commons.support.AnnotationSupport;
 import org.junit.platform.commons.support.ReflectionSupport;
 import org.junit.platform.commons.util.LruCache;
@@ -36,10 +37,10 @@ import org.junit.platform.engine.support.discovery.DiscoveryIssueReporter.Condit
  */
 class ClassOrderingVisitor extends AbstractOrderingVisitor {
 
-	private final LruCache<ClassBasedTestDescriptor, DescriptorWrapperOrderer<ClassOrderer, DefaultClassDescriptor>> ordererCache = new LruCache<>(
+	private final LruCache<ClassBasedTestDescriptor, DescriptorWrapperOrderer<TestDescriptor, ClassOrderer, DefaultClassDescriptor>> ordererCache = new LruCache<>(
 		10);
 	private final JupiterConfiguration configuration;
-	private final DescriptorWrapperOrderer<ClassOrderer, DefaultClassDescriptor> globalOrderer;
+	private final DescriptorWrapperOrderer<TestDescriptor, ClassOrderer, DefaultClassDescriptor> globalOrderer;
 	private final Condition<ClassBasedTestDescriptor> noOrderAnnotation;
 
 	ClassOrderingVisitor(JupiterConfiguration configuration, DiscoveryIssueReporter issueReporter) {
@@ -80,71 +81,82 @@ class ClassOrderingVisitor extends AbstractOrderingVisitor {
 		orderChildrenTestDescriptors(//
 			engineDescriptor, //
 			ClassBasedTestDescriptor.class, //
-			toValidationAction(globalOrderer), //
+			toValidationAction(globalOrderer.getOrderer()), //
 			DefaultClassDescriptor::new, //
 			globalOrderer);
 	}
 
 	private void orderNestedClasses(ClassBasedTestDescriptor descriptor) {
-		DescriptorWrapperOrderer<ClassOrderer, DefaultClassDescriptor> wrapperOrderer = createAndCacheClassLevelOrderer(
-			descriptor);
+		var wrapperOrderer = createAndCacheClassLevelOrderer(descriptor);
 		orderChildrenTestDescriptors(//
 			descriptor, //
 			ClassBasedTestDescriptor.class, //
-			toValidationAction(wrapperOrderer), //
+			toValidationAction(wrapperOrderer.getOrderer()), //
 			DefaultClassDescriptor::new, //
 			wrapperOrderer);
 	}
 
-	private DescriptorWrapperOrderer<ClassOrderer, DefaultClassDescriptor> createGlobalOrderer(
+	private DescriptorWrapperOrderer<TestDescriptor, ClassOrderer, DefaultClassDescriptor> createGlobalOrderer(
 			JupiterConfiguration configuration) {
 		ClassOrderer classOrderer = configuration.getDefaultTestClassOrderer().orElse(null);
 		return classOrderer == null ? DescriptorWrapperOrderer.noop() : createDescriptorWrapperOrderer(classOrderer);
 	}
 
-	private DescriptorWrapperOrderer<ClassOrderer, DefaultClassDescriptor> createAndCacheClassLevelOrderer(
+	private DescriptorWrapperOrderer<TestDescriptor, ClassOrderer, DefaultClassDescriptor> createAndCacheClassLevelOrderer(
 			ClassBasedTestDescriptor classBasedTestDescriptor) {
-		DescriptorWrapperOrderer<ClassOrderer, DefaultClassDescriptor> orderer = createClassLevelOrderer(
-			classBasedTestDescriptor);
+		var orderer = createClassLevelOrderer(classBasedTestDescriptor);
 		ordererCache.put(classBasedTestDescriptor, orderer);
 		return orderer;
 	}
 
-	private DescriptorWrapperOrderer<ClassOrderer, DefaultClassDescriptor> createClassLevelOrderer(
+	private DescriptorWrapperOrderer<TestDescriptor, ClassOrderer, DefaultClassDescriptor> createClassLevelOrderer(
 			ClassBasedTestDescriptor classBasedTestDescriptor) {
 		return AnnotationSupport.findAnnotation(classBasedTestDescriptor.getTestClass(), TestClassOrder.class)//
 				.map(TestClassOrder::value)//
-				.map(ReflectionSupport::newInstance)//
 				.map(this::createDescriptorWrapperOrderer)//
 				.orElseGet(() -> {
 					Object parent = classBasedTestDescriptor.getParent().orElse(null);
 					if (parent instanceof ClassBasedTestDescriptor parentClassTestDescriptor) {
-						DescriptorWrapperOrderer<ClassOrderer, DefaultClassDescriptor> cacheEntry = ordererCache.get(
-							parentClassTestDescriptor);
+						var cacheEntry = ordererCache.get(parentClassTestDescriptor);
 						return cacheEntry != null ? cacheEntry : createClassLevelOrderer(parentClassTestDescriptor);
 					}
 					return globalOrderer;
 				});
 	}
 
-	private DescriptorWrapperOrderer<ClassOrderer, DefaultClassDescriptor> createDescriptorWrapperOrderer(
+	private DescriptorWrapperOrderer<TestDescriptor, ClassOrderer, DefaultClassDescriptor> createDescriptorWrapperOrderer(
+			Class<? extends ClassOrderer> ordererClass) {
+		if (ordererClass == ClassOrderer.Default.class) {
+			return globalOrderer;
+		}
+		return createDescriptorWrapperOrderer(ReflectionSupport.newInstance(ordererClass));
+	}
+
+	private DescriptorWrapperOrderer<TestDescriptor, ClassOrderer, DefaultClassDescriptor> createDescriptorWrapperOrderer(
 			ClassOrderer classOrderer) {
-		Consumer<List<DefaultClassDescriptor>> orderingAction = classDescriptors -> classOrderer.orderClasses(
-			new DefaultClassOrdererContext(classDescriptors, this.configuration));
+		OrderingAction<TestDescriptor, DefaultClassDescriptor> orderingAction = (__,
+				classDescriptors) -> classOrderer.orderClasses(
+					new DefaultClassOrdererContext(classDescriptors, this.configuration));
 
-		MessageGenerator descriptorsAddedMessageGenerator = number -> "ClassOrderer [%s] added %s ClassDescriptor(s) which will be ignored.".formatted(
-			classOrderer.getClass().getName(), number);
-		MessageGenerator descriptorsRemovedMessageGenerator = number -> "ClassOrderer [%s] removed %s ClassDescriptor(s) which will be retained with arbitrary ordering.".formatted(
-			classOrderer.getClass().getName(), number);
+		MessageGenerator<TestDescriptor> descriptorsAddedMessageGenerator = (parent,
+				number) -> "ClassOrderer [%s] added %d %s which will be ignored.".formatted(
+					classOrderer.getClass().getName(), number, describeClassDescriptors(parent));
+		MessageGenerator<TestDescriptor> descriptorsRemovedMessageGenerator = (parent,
+				number) -> "ClassOrderer [%s] removed %d %s which will be retained with arbitrary ordering.".formatted(
+					classOrderer.getClass().getName(), number, describeClassDescriptors(parent));
 
 		return new DescriptorWrapperOrderer<>(classOrderer, orderingAction, descriptorsAddedMessageGenerator,
 			descriptorsRemovedMessageGenerator);
 	}
 
-	private Optional<Consumer<ClassBasedTestDescriptor>> toValidationAction(
-			DescriptorWrapperOrderer<ClassOrderer, DefaultClassDescriptor> wrapperOrderer) {
+	private static String describeClassDescriptors(TestDescriptor parent) {
+		return parent instanceof TestClassAware testClassAware //
+				? "nested ClassDescriptor(s) for test class [%s]".formatted(testClassAware.getTestClass().getName()) //
+				: "top-level ClassDescriptor(s)";
+	}
 
-		if (wrapperOrderer.getOrderer() instanceof ClassOrderer.OrderAnnotation) {
+	private Optional<Consumer<ClassBasedTestDescriptor>> toValidationAction(@Nullable ClassOrderer orderer) {
+		if (orderer instanceof ClassOrderer.OrderAnnotation) {
 			return Optional.empty();
 		}
 		return Optional.of(noOrderAnnotation::check);
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/DefaultMethodOrdererContext.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/DefaultMethodOrdererContext.java
index 3016f6940..f82701038 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/DefaultMethodOrdererContext.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/DefaultMethodOrdererContext.java
@@ -54,7 +54,7 @@ class DefaultMethodOrdererContext implements MethodOrdererContext {
 
 	@Override
 	public String toString() {
-		return new ToStringBuilder(this).append("testClass", this.testClass.getName()).toString();
+		return new ToStringBuilder(this).append("methodDescriptors", methodDescriptors).toString();
 	}
 
 }
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/MethodOrderingVisitor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/MethodOrderingVisitor.java
index 6d5e6e339..b570aa871 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/MethodOrderingVisitor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/MethodOrderingVisitor.java
@@ -11,7 +11,6 @@
 package org.junit.jupiter.engine.discovery;
 
 import static java.util.Comparator.comparing;
-import static org.junit.platform.commons.support.AnnotationSupport.findAnnotation;
 import static org.junit.platform.commons.support.AnnotationSupport.isAnnotated;
 
 import java.util.List;
@@ -19,6 +18,7 @@ import java.util.Optional;
 import java.util.function.Consumer;
 import java.util.function.UnaryOperator;
 
+import org.jspecify.annotations.Nullable;
 import org.junit.jupiter.api.MethodOrderer;
 import org.junit.jupiter.api.Order;
 import org.junit.jupiter.api.TestMethodOrder;
@@ -26,7 +26,9 @@ import org.junit.jupiter.engine.config.JupiterConfiguration;
 import org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor;
 import org.junit.jupiter.engine.descriptor.JupiterTestDescriptor;
 import org.junit.jupiter.engine.descriptor.MethodBasedTestDescriptor;
+import org.junit.platform.commons.support.AnnotationSupport;
 import org.junit.platform.commons.support.ReflectionSupport;
+import org.junit.platform.commons.util.LruCache;
 import org.junit.platform.engine.DiscoveryIssue;
 import org.junit.platform.engine.DiscoveryIssue.Severity;
 import org.junit.platform.engine.TestDescriptor;
@@ -38,7 +40,10 @@ import org.junit.platform.engine.support.discovery.DiscoveryIssueReporter.Condit
  */
 class MethodOrderingVisitor extends AbstractOrderingVisitor {
 
+	private final LruCache<ClassBasedTestDescriptor, DescriptorWrapperOrderer<ClassBasedTestDescriptor, MethodOrderer, DefaultMethodDescriptor>> ordererCache = new LruCache<>(
+		10);
 	private final JupiterConfiguration configuration;
+	private final DescriptorWrapperOrderer<ClassBasedTestDescriptor, MethodOrderer, DefaultMethodDescriptor> globalOrderer;
 	private final Condition<MethodBasedTestDescriptor> noOrderAnnotation;
 
 	// Not a static field to avoid initialization at build time for GraalVM
@@ -47,6 +52,7 @@ class MethodOrderingVisitor extends AbstractOrderingVisitor {
 	MethodOrderingVisitor(JupiterConfiguration configuration, DiscoveryIssueReporter issueReporter) {
 		super(issueReporter);
 		this.configuration = configuration;
+		this.globalOrderer = createGlobalOrderer(configuration);
 		this.noOrderAnnotation = issueReporter.createReportingCondition(
 			testDescriptor -> !isAnnotated(testDescriptor.getTestMethod(), Order.class), testDescriptor -> {
 				String message = """
@@ -63,8 +69,7 @@ class MethodOrderingVisitor extends AbstractOrderingVisitor {
 
 	@Override
 	public void visit(TestDescriptor testDescriptor) {
-		doWithMatchingDescriptor(ClassBasedTestDescriptor.class, testDescriptor,
-			descriptor -> orderContainedMethods(descriptor, descriptor.getTestClass()),
+		doWithMatchingDescriptor(ClassBasedTestDescriptor.class, testDescriptor, this::orderContainedMethods,
 			descriptor -> "Failed to order methods for " + descriptor.getTestClass());
 	}
 
@@ -75,66 +80,84 @@ class MethodOrderingVisitor extends AbstractOrderingVisitor {
 		return false;
 	}
 
-	/**
-	 * @since 5.4
-	 */
-	private void orderContainedMethods(ClassBasedTestDescriptor classBasedTestDescriptor, Class<?> testClass) {
-		Optional<MethodOrderer> methodOrderer = findAnnotation(testClass, TestMethodOrder.class)//
-				.map(TestMethodOrder::value)//
-				.<MethodOrderer> map(ReflectionSupport::newInstance) //
-				.or(configuration::getDefaultTestMethodOrderer);
-		orderContainedMethods(classBasedTestDescriptor, testClass, methodOrderer);
-	}
-
-	private void orderContainedMethods(ClassBasedTestDescriptor classBasedTestDescriptor, Class<?> testClass,
-			Optional<MethodOrderer> methodOrderer) {
+	private void orderContainedMethods(ClassBasedTestDescriptor descriptor) {
+		var wrapperOrderer = createAndCacheClassLevelOrderer(descriptor);
+		var methodOrderer = wrapperOrderer.getOrderer();
 
-		DescriptorWrapperOrderer<?, DefaultMethodDescriptor> descriptorWrapperOrderer = createDescriptorWrapperOrderer(
-			testClass, methodOrderer);
-
-		orderChildrenTestDescriptors(classBasedTestDescriptor, //
+		orderChildrenTestDescriptors(descriptor, //
 			MethodBasedTestDescriptor.class, //
 			toValidationAction(methodOrderer), //
 			DefaultMethodDescriptor::new, //
-			descriptorWrapperOrderer);
+			wrapperOrderer);
 
-		if (methodOrderer.isEmpty()) {
+		if (methodOrderer == null) {
 			// If there is an orderer, this is ensured by the call above
-			classBasedTestDescriptor.orderChildren(methodsBeforeNestedClassesOrderer);
+			descriptor.orderChildren(methodsBeforeNestedClassesOrderer);
+		}
+		else {
+			// Note: MethodOrderer#getDefaultExecutionMode() is guaranteed
+			// to be invoked after MethodOrderer#orderMethods().
+			methodOrderer.getDefaultExecutionMode() //
+					.map(JupiterTestDescriptor::toExecutionMode) //
+					.ifPresent(descriptor::setDefaultChildExecutionMode);
 		}
+	}
 
-		// Note: MethodOrderer#getDefaultExecutionMode() is guaranteed
-		// to be invoked after MethodOrderer#orderMethods().
-		methodOrderer //
-				.flatMap(it -> it.getDefaultExecutionMode().map(JupiterTestDescriptor::toExecutionMode)) //
-				.ifPresent(classBasedTestDescriptor::setDefaultChildExecutionMode);
+	private DescriptorWrapperOrderer<ClassBasedTestDescriptor, MethodOrderer, DefaultMethodDescriptor> createGlobalOrderer(
+			JupiterConfiguration configuration) {
+		MethodOrderer methodOrderer = configuration.getDefaultTestMethodOrderer().orElse(null);
+		return methodOrderer == null ? DescriptorWrapperOrderer.noop() : createDescriptorWrapperOrderer(methodOrderer);
 	}
 
-	private DescriptorWrapperOrderer<?, DefaultMethodDescriptor> createDescriptorWrapperOrderer(Class<?> testClass,
-			Optional<MethodOrderer> methodOrderer) {
+	private DescriptorWrapperOrderer<ClassBasedTestDescriptor, MethodOrderer, DefaultMethodDescriptor> createAndCacheClassLevelOrderer(
+			ClassBasedTestDescriptor classBasedTestDescriptor) {
+		var orderer = createClassLevelOrderer(classBasedTestDescriptor);
+		ordererCache.put(classBasedTestDescriptor, orderer);
+		return orderer;
+	}
 
-		return methodOrderer //
-				.map(it -> createDescriptorWrapperOrderer(testClass, it)) //
-				.orElseGet(DescriptorWrapperOrderer::noop);
+	private DescriptorWrapperOrderer<ClassBasedTestDescriptor, MethodOrderer, DefaultMethodDescriptor> createClassLevelOrderer(
+			ClassBasedTestDescriptor classBasedTestDescriptor) {
+		return AnnotationSupport.findAnnotation(classBasedTestDescriptor.getTestClass(), TestMethodOrder.class)//
+				.map(TestMethodOrder::value)//
+				.map(this::createDescriptorWrapperOrderer)//
+				.orElseGet(() -> {
+					Object parent = classBasedTestDescriptor.getParent().orElse(null);
+					if (parent instanceof ClassBasedTestDescriptor parentClassTestDescriptor) {
+						var cacheEntry = ordererCache.get(parentClassTestDescriptor);
+						return cacheEntry != null ? cacheEntry : createClassLevelOrderer(parentClassTestDescriptor);
+					}
+					return globalOrderer;
+				});
+	}
 
+	private DescriptorWrapperOrderer<ClassBasedTestDescriptor, MethodOrderer, DefaultMethodDescriptor> createDescriptorWrapperOrderer(
+			Class<? extends MethodOrderer> ordererClass) {
+		if (ordererClass == MethodOrderer.Default.class) {
+			return globalOrderer;
+		}
+		return createDescriptorWrapperOrderer(ReflectionSupport.newInstance(ordererClass));
 	}
 
-	private DescriptorWrapperOrderer<?, DefaultMethodDescriptor> createDescriptorWrapperOrderer(Class<?> testClass,
+	private DescriptorWrapperOrderer<ClassBasedTestDescriptor, MethodOrderer, DefaultMethodDescriptor> createDescriptorWrapperOrderer(
 			MethodOrderer methodOrderer) {
-		Consumer<List<DefaultMethodDescriptor>> orderingAction = methodDescriptors -> methodOrderer.orderMethods(
-			new DefaultMethodOrdererContext(testClass, methodDescriptors, this.configuration));
+		OrderingAction<ClassBasedTestDescriptor, DefaultMethodDescriptor> orderingAction = (parent,
+				methodDescriptors) -> methodOrderer.orderMethods(
+					new DefaultMethodOrdererContext(parent.getTestClass(), methodDescriptors, this.configuration));
 
-		MessageGenerator descriptorsAddedMessageGenerator = number -> "MethodOrderer [%s] added %s MethodDescriptor(s) for test class [%s] which will be ignored.".formatted(
-			methodOrderer.getClass().getName(), number, testClass.getName());
-		MessageGenerator descriptorsRemovedMessageGenerator = number -> "MethodOrderer [%s] removed %s MethodDescriptor(s) for test class [%s] which will be retained with arbitrary ordering.".formatted(
-			methodOrderer.getClass().getName(), number, testClass.getName());
+		MessageGenerator<ClassBasedTestDescriptor> descriptorsAddedMessageGenerator = (parent,
+				number) -> "MethodOrderer [%s] added %d MethodDescriptor(s) for test class [%s] which will be ignored.".formatted(
+					methodOrderer.getClass().getName(), number, parent.getTestClass().getName());
+		MessageGenerator<ClassBasedTestDescriptor> descriptorsRemovedMessageGenerator = (parent,
+				number) -> "MethodOrderer [%s] removed %d MethodDescriptor(s) for test class [%s] which will be retained with arbitrary ordering.".formatted(
+					methodOrderer.getClass().getName(), number, parent.getTestClass().getName());
 
 		return new DescriptorWrapperOrderer<>(methodOrderer, orderingAction, descriptorsAddedMessageGenerator,
 			descriptorsRemovedMessageGenerator);
 	}
 
-	private Optional<Consumer<MethodBasedTestDescriptor>> toValidationAction(Optional<MethodOrderer> methodOrderer) {
-		if (methodOrderer.orElse(null) instanceof MethodOrderer.OrderAnnotation) {
+	private Optional<Consumer<MethodBasedTestDescriptor>> toValidationAction(@Nullable MethodOrderer methodOrderer) {
+		if (methodOrderer instanceof MethodOrderer.OrderAnnotation) {
 			return Optional.empty();
 		}
 		return Optional.of(noOrderAnnotation::check);
diff --git a/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/OrderedClassTests.java b/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/OrderedClassTests.java
index dd76fa677..57ed8072b 100644
--- a/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/OrderedClassTests.java
+++ b/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/OrderedClassTests.java
@@ -200,6 +200,24 @@ class OrderedClassTests {
 				.containsSubsequence(classTemplate.getSimpleName(), otherClass.getSimpleName());
 	}
 
+	@Test
+	void nestedClassedCanUseDefaultOrder(@TrackLogRecords LogRecordListener logRecords) {
+		executeTests(null, selectClass(RevertingBackToDefaultOrderTestCase.Inner.class));
+		assertThat(callSequence).containsExactly("Test1", "Test2", "Test3", "Test4");
+		callSequence.clear();
+
+		executeTests(ClassOrderer.OrderAnnotation.class, selectClass(RevertingBackToDefaultOrderTestCase.Inner.class));
+		assertThat(callSequence).containsExactly("Test4", "Test2", "Test1", "Test3");
+		callSequence.clear();
+
+		executeTests(ClassOrderer.Default.class, selectClass(RevertingBackToDefaultOrderTestCase.Inner.class));
+		assertThat(callSequence).containsExactly("Test1", "Test2", "Test3", "Test4");
+		assertThat(logRecords.stream()) //
+				.filteredOn(it -> it.getLevel().intValue() >= Level.WARNING.intValue()) //
+				.map(LogRecord::getMessage) //
+				.isEmpty();
+	}
+
 	private static void assertIneffectiveOrderAnnotationIssues(List<DiscoveryIssue> discoveryIssues) {
 		assertThat(discoveryIssues).hasSize(2);
 		assertThat(discoveryIssues).extracting(DiscoveryIssue::severity).containsOnly(Severity.INFO);
@@ -437,4 +455,49 @@ class OrderedClassTests {
 		}
 	}
 
+	@TestClassOrder(ClassOrderer.DisplayName.class)
+	static class RevertingBackToDefaultOrderTestCase {
+
+		@Nested
+		@TestClassOrder(ClassOrderer.Default.class)
+		class Inner {
+
+			@Nested
+			@Order(3)
+			class Test1 {
+				@Test
+				void test() {
+					callSequence.add(getClass().getSimpleName());
+				}
+			}
+
+			@Nested
+			@Order(2)
+			class Test2 {
+				@Test
+				void test() {
+					callSequence.add(getClass().getSimpleName());
+				}
+			}
+
+			@Nested
+			@Order(4)
+			class Test3 {
+				@Test
+				void test() {
+					callSequence.add(getClass().getSimpleName());
+				}
+			}
+
+			@Nested
+			@Order(1)
+			class Test4 {
+				@Test
+				void test() {
+					callSequence.add(getClass().getSimpleName());
+				}
+			}
+		}
+	}
+
 }
diff --git a/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/OrderedMethodTests.java b/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/OrderedMethodTests.java
index 6c195553b..1a353645e 100644
--- a/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/OrderedMethodTests.java
+++ b/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/OrderedMethodTests.java
@@ -40,6 +40,7 @@ import org.junit.jupiter.api.DisplayName;
 import org.junit.jupiter.api.DynamicTest;
 import org.junit.jupiter.api.MethodDescriptor;
 import org.junit.jupiter.api.MethodOrderer;
+import org.junit.jupiter.api.MethodOrderer.Default;
 import org.junit.jupiter.api.MethodOrderer.MethodName;
 import org.junit.jupiter.api.MethodOrderer.OrderAnnotation;
 import org.junit.jupiter.api.MethodOrderer.Random;
@@ -53,6 +54,8 @@ import org.junit.jupiter.api.TestInfo;
 import org.junit.jupiter.api.TestMethodOrder;
 import org.junit.jupiter.api.TestReporter;
 import org.junit.jupiter.api.fixtures.TrackLogRecords;
+import org.junit.jupiter.api.parallel.Execution;
+import org.junit.jupiter.api.parallel.ExecutionMode;
 import org.junit.jupiter.engine.JupiterTestEngine;
 import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.ValueSource;
@@ -324,6 +327,24 @@ class OrderedMethodTests {
 				.containsSubsequence("test2()", "test4()");// removed item is re-added before ordered item
 	}
 
+	@Test
+	void nestedClassedCanUseDefaultOrder(@TrackLogRecords LogRecordListener logRecords) {
+		executeTestsInParallel(NestedClassWithDefaultOrderTestCase.NestedTests.class, null, Severity.WARNING);
+		assertThat(callSequence).containsExactly("test1()", "test2()", "test3()", "test4()");
+		callSequence.clear();
+
+		executeTestsInParallel(NestedClassWithDefaultOrderTestCase.NestedTests.class, OrderAnnotation.class);
+		assertThat(callSequence).containsExactly("test4()", "test2()", "test1()", "test3()");
+		callSequence.clear();
+
+		executeTestsInParallel(NestedClassWithDefaultOrderTestCase.NestedTests.class, Default.class, Severity.WARNING);
+		assertThat(callSequence).containsExactly("test1()", "test2()", "test3()", "test4()");
+		assertThat(logRecords.stream()) //
+				.filteredOn(it -> it.getLevel().intValue() >= Level.WARNING.intValue()) //
+				.map(LogRecord::getMessage) //
+				.isEmpty();
+	}
+
 	private EngineDiscoveryResults discoverTests(Class<?> testClass,
 			@Nullable Class<? extends MethodOrderer> defaultOrderer) {
 		return testKit(testClass, defaultOrderer, Severity.INFO).discover();
@@ -342,6 +363,7 @@ class OrderedMethodTests {
 
 	private static EngineTestKit.Builder testKit(Class<?> testClass,
 			@Nullable Class<? extends MethodOrderer> defaultOrderer, Severity criticalSeverity) {
+
 		var testKit = EngineTestKit.engine("junit-jupiter") //
 				.configurationParameter(PARALLEL_EXECUTION_ENABLED_PROPERTY_NAME, "true") //
 				.configurationParameter(DEFAULT_PARALLEL_EXECUTION_MODE, "concurrent") //
@@ -694,7 +716,6 @@ class OrderedMethodTests {
 
 	static class OrderAnnotationWithNestedClassTestCase extends OrderAnnotationTestCase {
 		@Nested
-		@TestMethodOrder(OrderAnnotation.class)
 		class NestedTests {
 
 			@BeforeEach
@@ -826,4 +847,38 @@ class OrderedMethodTests {
 	static class ClassTemplateTestCase extends WithoutTestMethodOrderTestCase {
 	}
 
+	static class NestedClassWithDefaultOrderTestCase extends OrderAnnotationTestCase {
+
+		@Nested
+		@TestMethodOrder(Default.class)
+		@Execution(ExecutionMode.SAME_THREAD)
+		class NestedTests {
+
+			@BeforeEach
+			void trackInvocations(TestInfo testInfo) {
+				callSequence.add(testInfo.getDisplayName());
+			}
+
+			@Test
+			@Order(3)
+			void test1() {
+			}
+
+			@Test
+			@Order(2)
+			void test2() {
+			}
+
+			@Test
+			@Order(4)
+			void test3() {
+			}
+
+			@Test
+			@Order(1)
+			void test4() {
+			}
+		}
+	}
+
 }
