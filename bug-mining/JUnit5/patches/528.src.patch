diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.10.0-M1.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.10.0-M1.adoc
index 15f400b83..6fd5d6d7e 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.10.0-M1.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.10.0-M1.adoc
@@ -62,6 +62,8 @@ repository on GitHub.
   `@ParameterizedTest` invocation.
 * `DisplayNameGenerator` methods are now allowed to return `null`, in order to signal
   to fall back to the default display name generator.
+* `@EmptySource` now supports additional types, including `Collection` and `Map` subtypes
+  with a public no-arg constructor.
 
 
 [[release-notes-5.10.0-M1-junit-vintage]]
diff --git a/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc b/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
index 7b0c29a35..62642cb68 100644
--- a/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
+++ b/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
@@ -1257,10 +1257,12 @@ for parameterized tests that accept a single argument.
   method.
    - `@NullSource` cannot be used for a parameter that has a primitive type.
 * `{EmptySource}`: provides a single _empty_ argument to the annotated `@ParameterizedTest`
-  method for parameters of the following types: `java.lang.String`, `java.util.List`,
-  `java.util.Set`, `java.util.Map`, primitive arrays (e.g., `int[]`, `char[][]`, etc.),
-  object arrays (e.g.,`String[]`, `Integer[][]`, etc.).
-   - Subtypes of the supported types are not supported.
+  method for parameters of the following types: `java.lang.String`, `java.util.Collection`
+  and subtypes with a public no-arg constructor, `java.util.List`, `java.util.Set`,
+  `java.util.SortedSet`, `java.util.NavigableSet`, `java.util.Map` and subtypes with a
+  public no-arg constructor, `java.util.SortedMap`, `java.util.NavigableMap`, primitive
+  arrays (e.g., `int[]`, `char[][]`, etc.), object arrays (e.g.,`String[]`, `Integer[][]`,
+  etc.).
 * `{NullAndEmptySource}`: a _composed annotation_ that combines the functionality of
   `@NullSource` and `@EmptySource`.
 
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/EmptyArgumentsProvider.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/EmptyArgumentsProvider.java
index 8debbb3a8..dc0f82b5b 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/EmptyArgumentsProvider.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/EmptyArgumentsProvider.java
@@ -11,13 +11,21 @@
 package org.junit.jupiter.params.provider;
 
 import static org.junit.jupiter.params.provider.Arguments.arguments;
+import static org.junit.platform.commons.util.ReflectionUtils.newInstance;
 
 import java.lang.reflect.Array;
+import java.lang.reflect.Constructor;
 import java.lang.reflect.Method;
+import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
 import java.util.Map;
+import java.util.NavigableMap;
+import java.util.NavigableSet;
+import java.util.Optional;
 import java.util.Set;
+import java.util.SortedMap;
+import java.util.SortedSet;
 import java.util.stream.Stream;
 
 import org.junit.jupiter.api.extension.ExtensionContext;
@@ -44,15 +52,36 @@ class EmptyArgumentsProvider implements ArgumentsProvider {
 		if (String.class.equals(parameterType)) {
 			return Stream.of(arguments(""));
 		}
+		if (Collection.class.equals(parameterType)) {
+			return Stream.of(arguments(Collections.emptySet()));
+		}
 		if (List.class.equals(parameterType)) {
 			return Stream.of(arguments(Collections.emptyList()));
 		}
 		if (Set.class.equals(parameterType)) {
 			return Stream.of(arguments(Collections.emptySet()));
 		}
+		if (SortedSet.class.equals(parameterType)) {
+			return Stream.of(arguments(Collections.emptySortedSet()));
+		}
+		if (NavigableSet.class.equals(parameterType)) {
+			return Stream.of(arguments(Collections.emptyNavigableSet()));
+		}
 		if (Map.class.equals(parameterType)) {
 			return Stream.of(arguments(Collections.emptyMap()));
 		}
+		if (SortedMap.class.equals(parameterType)) {
+			return Stream.of(arguments(Collections.emptySortedMap()));
+		}
+		if (NavigableMap.class.equals(parameterType)) {
+			return Stream.of(arguments(Collections.emptyNavigableMap()));
+		}
+		if (Collection.class.isAssignableFrom(parameterType) || Map.class.isAssignableFrom(parameterType)) {
+			Optional<Constructor<?>> defaultConstructor = getDefaultConstructor(parameterType);
+			if (defaultConstructor.isPresent()) {
+				return Stream.of(arguments(newInstance(defaultConstructor.get())));
+			}
+		}
 		if (parameterType.isArray()) {
 			Object array = Array.newInstance(parameterType.getComponentType(), 0);
 			return Stream.of(arguments(array));
@@ -63,4 +92,13 @@ class EmptyArgumentsProvider implements ArgumentsProvider {
 				testMethod.toGenericString(), parameterType.getName()));
 	}
 
+	private static Optional<Constructor<?>> getDefaultConstructor(Class<?> clazz) {
+		try {
+			return Optional.of(clazz.getConstructor());
+		}
+		catch (NoSuchMethodException e) {
+			return Optional.empty();
+		}
+	}
+
 }
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/EmptySource.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/EmptySource.java
index 553192a2d..cd1104a1d 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/EmptySource.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/EmptySource.java
@@ -27,13 +27,18 @@ import org.apiguardian.api.API;
  * <h2>Supported Parameter Types</h2>
  *
  * <p>This argument source will only provide an empty argument for the following
- * method parameter types. Subtypes of the supported types are not supported.
+ * method parameter types.
  *
  * <ul>
  * <li>{@link java.lang.String}</li>
+ * <li>{@link java.util.Collection} and subtypes with a public no-arg constructor</li>
  * <li>{@link java.util.List}</li>
  * <li>{@link java.util.Set}</li>
- * <li>{@link java.util.Map}</li>
+ * <li>{@link java.util.SortedSet}</li>
+ * <li>{@link java.util.NavigableSet}</li>
+ * <li>{@link java.util.Map} and subtypes with a public no-arg constructor</li>
+ * <li>{@link java.util.SortedMap}</li>
+ * <li>{@link java.util.NavigableMap}</li>
  * <li>primitive arrays &mdash; for example {@code int[]}, {@code char[][]}, etc.</li>
  * <li>object arrays &mdash; for example {@code String[]}, {@code Integer[][]}, etc.</li>
  * </ul>
diff --git a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestIntegrationTests.java b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestIntegrationTests.java
index 24d2a7119..e4da1e737 100644
--- a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestIntegrationTests.java
+++ b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestIntegrationTests.java
@@ -43,12 +43,21 @@ import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collection;
 import java.util.HashMap;
 import java.util.HashSet;
+import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
+import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
+import java.util.NavigableMap;
+import java.util.NavigableSet;
 import java.util.Set;
+import java.util.SortedMap;
+import java.util.SortedSet;
+import java.util.TreeMap;
+import java.util.TreeSet;
 import java.util.stream.Stream;
 
 import org.junit.jupiter.api.AfterAll;
@@ -459,24 +468,78 @@ class ParameterizedTestIntegrationTests {
 			results.testEvents().succeeded().assertEventsMatchExactly(event(test(), displayName("[1] argument=")));
 		}
 
+		/**
+		 * @since 5.10
+		 */
+		@Test
+		void executesWithEmptySourceForCollection() {
+			var results = execute("testWithEmptySourceForCollection", Collection.class);
+			results.testEvents().succeeded().assertEventsMatchExactly(event(test(), displayName("[1] argument=[]")));
+		}
+
 		@Test
 		void executesWithEmptySourceForList() {
 			var results = execute("testWithEmptySourceForList", List.class);
 			results.testEvents().succeeded().assertEventsMatchExactly(event(test(), displayName("[1] argument=[]")));
 		}
 
+		/**
+		 * @since 5.10
+		 */
+		@ParameterizedTest(name = "{1}")
+		@CsvSource({ //
+				"testWithEmptySourceForArrayList, java.util.ArrayList", //
+				"testWithEmptySourceForLinkedList, java.util.LinkedList"//
+		})
+		void executesWithEmptySourceForListSubtype(String methodName, Class<?> parameterType) {
+			var results = execute(methodName, parameterType);
+			results.testEvents().succeeded().assertEventsMatchExactly(event(test(), displayName("[1] argument=[]")));
+		}
+
 		@Test
 		void executesWithEmptySourceForSet() {
 			var results = execute("testWithEmptySourceForSet", Set.class);
 			results.testEvents().succeeded().assertEventsMatchExactly(event(test(), displayName("[1] argument=[]")));
 		}
 
+		/**
+		 * @since 5.10
+		 */
+		@ParameterizedTest(name = "{1}")
+		@CsvSource({ //
+				"testWithEmptySourceForSortedSet, java.util.SortedSet", //
+				"testWithEmptySourceForNavigableSet, java.util.NavigableSet", //
+				"testWithEmptySourceForHashSet, java.util.HashSet", //
+				"testWithEmptySourceForTreeSet, java.util.TreeSet", //
+				"testWithEmptySourceForLinkedHashSet, java.util.LinkedHashSet"//
+		})
+		void executesWithEmptySourceForSetSubtype(String methodName, Class<?> parameterType) {
+			var results = execute(methodName, parameterType);
+			results.testEvents().succeeded().assertEventsMatchExactly(event(test(), displayName("[1] argument=[]")));
+		}
+
 		@Test
 		void executesWithEmptySourceForMap() {
 			var results = execute("testWithEmptySourceForMap", Map.class);
 			results.testEvents().succeeded().assertEventsMatchExactly(event(test(), displayName("[1] argument={}")));
 		}
 
+		/**
+		 * @since 5.10
+		 */
+		@ParameterizedTest(name = "{1}")
+		@CsvSource({ //
+				"testWithEmptySourceForSortedMap, java.util.SortedMap", //
+				"testWithEmptySourceForNavigableMap, java.util.NavigableMap", //
+				"testWithEmptySourceForHashMap, java.util.HashMap", //
+				"testWithEmptySourceForTreeMap, java.util.TreeMap", //
+				"testWithEmptySourceForLinkedHashMap, java.util.LinkedHashMap"//
+		})
+		void executesWithEmptySourceForMapSubtype(String methodName, Class<?> parameterType) {
+			var results = execute(methodName, parameterType);
+			results.testEvents().succeeded().assertEventsMatchExactly(event(test(), displayName("[1] argument={}")));
+		}
+
 		@Test
 		void executesWithEmptySourceForOneDimensionalPrimitiveArray() {
 			var results = execute("testWithEmptySourceForOneDimensionalPrimitiveArray", int[].class);
@@ -515,10 +578,7 @@ class ParameterizedTestIntegrationTests {
 		@ParameterizedTest(name = "{1}")
 		@CsvSource({ //
 				"testWithEmptySourceForPrimitive, int", //
-				"testWithEmptySourceForUnsupportedReferenceType, java.lang.Integer", //
-				"testWithEmptySourceForUnsupportedListSubtype, java.util.ArrayList", //
-				"testWithEmptySourceForUnsupportedSetSubtype, java.util.HashSet", //
-				"testWithEmptySourceForUnsupportedMapSubtype, java.util.HashMap"//
+				"testWithEmptySourceForUnsupportedReferenceType, java.lang.Integer"//
 		})
 		void failsWithEmptySourceForUnsupportedType(String methodName, Class<?> parameterType) {
 			execute(methodName, parameterType).containerEvents().failed().assertEventsMatchExactly(//
@@ -561,6 +621,12 @@ class ParameterizedTestIntegrationTests {
 			assertNullAndEmpty(results);
 		}
 
+		@Test
+		void executesWithNullAndEmptySourceForArrayList() {
+			var results = execute("testWithNullAndEmptySourceForArrayList", ArrayList.class);
+			assertNullAndEmpty(results);
+		}
+
 		@Test
 		void executesWithNullAndEmptySourceForOneDimensionalPrimitiveArray() {
 			var results = execute("testWithNullAndEmptySourceForOneDimensionalPrimitiveArray", int[].class);
@@ -982,18 +1048,66 @@ class ParameterizedTestIntegrationTests {
 			assertThat(testInfo).isNotNull();
 		}
 
+		@ParameterizedTest
+		@EmptySource
+		void testWithEmptySourceForCollection(Collection<?> argument) {
+			assertThat(argument).isEmpty();
+		}
+
 		@ParameterizedTest
 		@EmptySource
 		void testWithEmptySourceForList(List<?> argument) {
 			assertThat(argument).isEmpty();
 		}
 
+		@ParameterizedTest
+		@EmptySource
+		void testWithEmptySourceForArrayList(ArrayList<?> argument) {
+			assertThat(argument).isEmpty();
+		}
+
+		@ParameterizedTest
+		@EmptySource
+		void testWithEmptySourceForLinkedList(LinkedList<?> argument) {
+			assertThat(argument).isEmpty();
+		}
+
 		@ParameterizedTest
 		@EmptySource
 		void testWithEmptySourceForSet(Set<?> argument) {
 			assertThat(argument).isEmpty();
 		}
 
+		@ParameterizedTest
+		@EmptySource
+		void testWithEmptySourceForSortedSet(SortedSet<?> argument) {
+			assertThat(argument).isEmpty();
+		}
+
+		@ParameterizedTest
+		@EmptySource
+		void testWithEmptySourceForNavigableSet(NavigableSet<?> argument) {
+			assertThat(argument).isEmpty();
+		}
+
+		@ParameterizedTest
+		@EmptySource
+		void testWithEmptySourceForHashSet(HashSet<?> argument) {
+			assertThat(argument).isEmpty();
+		}
+
+		@ParameterizedTest
+		@EmptySource
+		void testWithEmptySourceForTreeSet(TreeSet<?> argument) {
+			assertThat(argument).isEmpty();
+		}
+
+		@ParameterizedTest
+		@EmptySource
+		void testWithEmptySourceForLinkedHashSet(LinkedHashSet<?> argument) {
+			assertThat(argument).isEmpty();
+		}
+
 		@ParameterizedTest
 		@EmptySource
 		void testWithEmptySourceForMap(Map<?, ?> argument) {
@@ -1002,61 +1116,73 @@ class ParameterizedTestIntegrationTests {
 
 		@ParameterizedTest
 		@EmptySource
-		void testWithEmptySourceForOneDimensionalPrimitiveArray(int[] argument) {
+		void testWithEmptySourceForSortedMap(SortedMap<?, ?> argument) {
 			assertThat(argument).isEmpty();
 		}
 
 		@ParameterizedTest
 		@EmptySource
-		void testWithEmptySourceForOneDimensionalStringArray(String[] argument) {
+		void testWithEmptySourceForNavigableMap(NavigableMap<?, ?> argument) {
 			assertThat(argument).isEmpty();
 		}
 
 		@ParameterizedTest
 		@EmptySource
-		void testWithEmptySourceForTwoDimensionalPrimitiveArray(int[][] argument) {
+		void testWithEmptySourceForHashMap(HashMap<?, ?> argument) {
 			assertThat(argument).isEmpty();
 		}
 
 		@ParameterizedTest
 		@EmptySource
-		void testWithEmptySourceForTwoDimensionalStringArray(String[][] argument) {
+		void testWithEmptySourceForTreeMap(TreeMap<?, ?> argument) {
 			assertThat(argument).isEmpty();
 		}
 
 		@ParameterizedTest
 		@EmptySource
-		void testWithEmptySourceWithZeroFormalParameters() {
-			fail("should not have been executed");
+		void testWithEmptySourceForLinkedHashMap(LinkedHashMap<?, ?> argument) {
+			assertThat(argument).isEmpty();
 		}
 
 		@ParameterizedTest
 		@EmptySource
-		void testWithEmptySourceForPrimitive(int argument) {
-			fail("should not have been executed");
+		void testWithEmptySourceForOneDimensionalPrimitiveArray(int[] argument) {
+			assertThat(argument).isEmpty();
 		}
 
 		@ParameterizedTest
 		@EmptySource
-		void testWithEmptySourceForUnsupportedReferenceType(Integer argument) {
-			fail("should not have been executed");
+		void testWithEmptySourceForOneDimensionalStringArray(String[] argument) {
+			assertThat(argument).isEmpty();
 		}
 
 		@ParameterizedTest
 		@EmptySource
-		void testWithEmptySourceForUnsupportedListSubtype(ArrayList<?> argument) {
+		void testWithEmptySourceForTwoDimensionalPrimitiveArray(int[][] argument) {
+			assertThat(argument).isEmpty();
+		}
+
+		@ParameterizedTest
+		@EmptySource
+		void testWithEmptySourceForTwoDimensionalStringArray(String[][] argument) {
+			assertThat(argument).isEmpty();
+		}
+
+		@ParameterizedTest
+		@EmptySource
+		void testWithEmptySourceWithZeroFormalParameters() {
 			fail("should not have been executed");
 		}
 
 		@ParameterizedTest
 		@EmptySource
-		void testWithEmptySourceForUnsupportedSetSubtype(HashSet<?> argument) {
+		void testWithEmptySourceForPrimitive(int argument) {
 			fail("should not have been executed");
 		}
 
 		@ParameterizedTest
 		@EmptySource
-		void testWithEmptySourceForUnsupportedMapSubtype(HashMap<?, ?> argument) {
+		void testWithEmptySourceForUnsupportedReferenceType(Integer argument) {
 			fail("should not have been executed");
 		}
 
@@ -1083,6 +1209,12 @@ class ParameterizedTestIntegrationTests {
 			assertTrue(argument == null || argument.isEmpty());
 		}
 
+		@ParameterizedTest
+		@NullAndEmptySource
+		void testWithNullAndEmptySourceForArrayList(ArrayList<?> argument) {
+			assertTrue(argument == null || argument.isEmpty());
+		}
+
 		@ParameterizedTest
 		@NullAndEmptySource
 		void testWithNullAndEmptySourceForOneDimensionalPrimitiveArray(int[] argument) {
