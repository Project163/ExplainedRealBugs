diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.1.0-RC1.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.1.0-RC1.adoc
index d036f54d4..4c709b430 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.1.0-RC1.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.1.0-RC1.adoc
@@ -72,4 +72,13 @@ on GitHub.
 
 ==== New Features and Improvements
 
-* ‚ùì
+* Prior to this release, the Vintage test engine only returned a childless
+  `TestDescriptor` for test classes annotated with `@Ignore`. However, build tools like
+  Gradle need to show an accurate number of tests, i.e. they want to access and count the
+  test methods of a test class regardless whether it's ignored.
+  The Jupiter engine already discovers skipped containers, e.g. test classes annotated
+  with `@Disabled`, including their children and descendants. The Vintage engine now
+  adopts this approach and returns a full subtree of `TestDescriptors` for classes
+  annotated with `@Ignore`. During execution, it will only report the `TestDescriptor`
+  of the test class as skipped which is consistent with how the Jupiter engine reports
+  skipped containers.
diff --git a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/DefensiveAllDefaultPossibilitiesBuilder.java b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/DefensiveAllDefaultPossibilitiesBuilder.java
index b55c8ff38..57918fa8d 100644
--- a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/DefensiveAllDefaultPossibilitiesBuilder.java
+++ b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/DefensiveAllDefaultPossibilitiesBuilder.java
@@ -13,13 +13,17 @@ package org.junit.vintage.engine.discovery;
 import java.lang.reflect.Method;
 import java.util.function.Predicate;
 
+import org.junit.Ignore;
 import org.junit.internal.builders.AllDefaultPossibilitiesBuilder;
 import org.junit.internal.builders.AnnotatedBuilder;
+import org.junit.internal.builders.IgnoredBuilder;
+import org.junit.internal.builders.IgnoredClassRunner;
 import org.junit.internal.builders.JUnit4Builder;
 import org.junit.platform.commons.logging.Logger;
 import org.junit.platform.commons.logging.LoggerFactory;
 import org.junit.platform.commons.util.ReflectionUtils;
 import org.junit.runner.Runner;
+import org.junit.runner.manipulation.Filterable;
 import org.junit.runners.model.RunnerBuilder;
 
 /**
@@ -30,18 +34,48 @@ import org.junit.runners.model.RunnerBuilder;
  * @since 4.12
  * @see DefensiveAnnotatedBuilder
  * @see DefensiveJUnit4Builder
+ * @see IgnoredClassRunner
  */
 class DefensiveAllDefaultPossibilitiesBuilder extends AllDefaultPossibilitiesBuilder {
 
 	private static final Logger logger = LoggerFactory.getLogger(DefensiveAllDefaultPossibilitiesBuilder.class);
 
 	private final AnnotatedBuilder annotatedBuilder;
-	private final DefensiveJUnit4Builder defensiveJUnit4Builder;
+	private final JUnit4Builder junit4Builder;
+	private final IgnoredBuilder ignoredBuilder;
 
 	DefensiveAllDefaultPossibilitiesBuilder() {
 		super(true);
 		annotatedBuilder = new DefensiveAnnotatedBuilder(this);
-		defensiveJUnit4Builder = new DefensiveJUnit4Builder();
+		junit4Builder = new DefensiveJUnit4Builder();
+		ignoredBuilder = new NullIgnoredBuilder();
+	}
+
+	@Override
+	public Runner runnerForClass(Class<?> testClass) throws Throwable {
+		Runner runner = super.runnerForClass(testClass);
+		if (testClass.getAnnotation(Ignore.class) != null) {
+			if (runner == null) {
+				return new IgnoredClassRunner(testClass);
+			}
+			return decorateIgnoredTestClass(runner);
+		}
+		return runner;
+	}
+
+	/**
+	 * Instead of checking for the {@link Ignore} annotation and returning an
+	 * {@link IgnoredClassRunner} from {@link IgnoredBuilder}, we've let the
+	 * super class determine the regular runner that would have been used if
+	 * {@link Ignore} hadn't been present. Now, we decorate the runner to
+	 * override its runtime behavior (i.e. skip execution) but return its
+	 * regular {@link org.junit.runner.Description}.
+	 */
+	private Runner decorateIgnoredTestClass(Runner runner) {
+		if (runner instanceof Filterable) {
+			return new FilterableIgnoringRunnerDecorator(runner);
+		}
+		return new IgnoringRunnerDecorator(runner);
 	}
 
 	@Override
@@ -51,7 +85,12 @@ class DefensiveAllDefaultPossibilitiesBuilder extends AllDefaultPossibilitiesBui
 
 	@Override
 	protected JUnit4Builder junit4Builder() {
-		return defensiveJUnit4Builder;
+		return junit4Builder;
+	}
+
+	@Override
+	protected IgnoredBuilder ignoredBuilder() {
+		return ignoredBuilder;
 	}
 
 	/**
@@ -96,4 +135,16 @@ class DefensiveAllDefaultPossibilitiesBuilder extends AllDefaultPossibilitiesBui
 		}
 	}
 
+	/**
+	 * Customization of {@link IgnoredBuilder} that always returns {@code null}.
+	 *
+	 * @since 5.1
+	 */
+	private static class NullIgnoredBuilder extends IgnoredBuilder {
+		@Override
+		public Runner runnerForClass(Class<?> testClass) {
+			// don't ignore entire test classes just yet
+			return null;
+		}
+	}
 }
diff --git a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/FilterableIgnoringRunnerDecorator.java b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/FilterableIgnoringRunnerDecorator.java
new file mode 100644
index 000000000..501dc6ebd
--- /dev/null
+++ b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/FilterableIgnoringRunnerDecorator.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2015-2018 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * http://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.vintage.engine.discovery;
+
+import org.junit.platform.commons.util.Preconditions;
+import org.junit.runner.Runner;
+import org.junit.runner.manipulation.Filter;
+import org.junit.runner.manipulation.Filterable;
+import org.junit.runner.manipulation.NoTestsRemainException;
+
+/**
+ * {@link Filterable} {@link IgnoringRunnerDecorator}.
+ *
+ * @since 5.1
+ */
+class FilterableIgnoringRunnerDecorator extends IgnoringRunnerDecorator implements Filterable {
+
+	FilterableIgnoringRunnerDecorator(Runner runner) {
+		super(runner);
+		Preconditions.condition(runner instanceof Filterable,
+			() -> "Runner must be an instance of Filterable: " + runner.getClass().getName());
+	}
+
+	@Override
+	public void filter(Filter filter) throws NoTestsRemainException {
+		((Filterable) runner).filter(filter);
+	}
+}
diff --git a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/IgnoringRunnerDecorator.java b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/IgnoringRunnerDecorator.java
new file mode 100644
index 000000000..2241b6e30
--- /dev/null
+++ b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/IgnoringRunnerDecorator.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2015-2018 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * http://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.vintage.engine.discovery;
+
+import org.junit.platform.commons.util.Preconditions;
+import org.junit.runner.Description;
+import org.junit.runner.Runner;
+import org.junit.runner.notification.RunNotifier;
+
+/**
+ * Decorator for Runners that will be ignored completely.
+ *
+ * <p>Contrary to {@link org.junit.internal.builders.IgnoredClassRunner}, this
+ * runner returns a complete description including all children.
+ *
+ * @since 5.1
+ */
+class IgnoringRunnerDecorator extends Runner implements RunnerDecorator {
+
+	protected final Runner runner;
+
+	IgnoringRunnerDecorator(Runner runner) {
+		this.runner = Preconditions.notNull(runner, "Runner must not be null");
+	}
+
+	@Override
+	public Description getDescription() {
+		return runner.getDescription();
+	}
+
+	@Override
+	public void run(RunNotifier notifier) {
+		notifier.fireTestIgnored(getDescription());
+	}
+
+	@Override
+	public Runner getDecoratedRunner() {
+		return runner;
+	}
+}
diff --git a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/RunnerDecorator.java b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/RunnerDecorator.java
new file mode 100644
index 000000000..b3e701e43
--- /dev/null
+++ b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/RunnerDecorator.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright 2015-2018 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * http://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.vintage.engine.discovery;
+
+import org.junit.runner.Runner;
+
+public interface RunnerDecorator {
+
+	Runner getDecoratedRunner();
+
+}
diff --git a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/TestClassRequestResolver.java b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/TestClassRequestResolver.java
index c6619d8d8..7b198d8d6 100644
--- a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/TestClassRequestResolver.java
+++ b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/discovery/TestClassRequestResolver.java
@@ -69,7 +69,10 @@ class TestClassRequestResolver {
 				runnerTestDescriptor = createCompleteRunnerTestDescriptor(testClass, filteredRunner, engineId);
 			}
 			else {
-				logger.warn(() -> "Runner " + runner.getClass().getName() //
+				Runner runnerToReport = (runner instanceof RunnerDecorator)
+						? ((RunnerDecorator) runner).getDecoratedRunner()
+						: runner;
+				logger.warn(() -> "Runner " + runnerToReport.getClass().getName() //
 						+ " (used on " + testClass.getName() + ") does not support filtering" //
 						+ " and will therefore be run completely.");
 			}
diff --git a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/execution/RunListenerAdapter.java b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/execution/RunListenerAdapter.java
index f411c72c9..e2d0033c5 100644
--- a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/execution/RunListenerAdapter.java
+++ b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/execution/RunListenerAdapter.java
@@ -44,14 +44,6 @@ class RunListenerAdapter extends RunListener {
 		this.uniqueIdExtractor = new UniqueIdReader().andThen(new UniqueIdStringifier());
 	}
 
-	@Override
-	public void testRunStarted(Description description) {
-		// If it's not a suite it might be skipped entirely later on.
-		if (description.isSuite()) {
-			fireExecutionStarted(testRun.getRunnerTestDescriptor());
-		}
-	}
-
 	@Override
 	public void testIgnored(Description description) {
 		testIgnored(lookupOrRegisterTestDescriptor(description), determineReasonForIgnoredTest(description));
diff --git a/junit-vintage-engine/src/test/java/org/junit/vintage/engine/VintageTestEngineDiscoveryTests.java b/junit-vintage-engine/src/test/java/org/junit/vintage/engine/VintageTestEngineDiscoveryTests.java
index d5f76e152..e55884e08 100644
--- a/junit-vintage-engine/src/test/java/org/junit/vintage/engine/VintageTestEngineDiscoveryTests.java
+++ b/junit-vintage-engine/src/test/java/org/junit/vintage/engine/VintageTestEngineDiscoveryTests.java
@@ -40,7 +40,6 @@ import java.util.Base64;
 import java.util.List;
 import java.util.Set;
 
-import org.junit.jupiter.api.Assertions;
 import org.junit.jupiter.api.Test;
 import org.junit.platform.commons.util.ClassUtils;
 import org.junit.platform.engine.TestDescriptor;
@@ -57,9 +56,11 @@ import org.junit.vintage.engine.samples.junit4.Categories.Failing;
 import org.junit.vintage.engine.samples.junit4.Categories.Plain;
 import org.junit.vintage.engine.samples.junit4.Categories.Skipped;
 import org.junit.vintage.engine.samples.junit4.Categories.SkippedWithReason;
+import org.junit.vintage.engine.samples.junit4.EmptyIgnoredTestClass;
 import org.junit.vintage.engine.samples.junit4.IgnoredJUnit4TestCase;
 import org.junit.vintage.engine.samples.junit4.JUnit4SuiteWithPlainJUnit4TestCaseWithSingleTestWhichIsIgnored;
 import org.junit.vintage.engine.samples.junit4.JUnit4SuiteWithTwoTestCases;
+import org.junit.vintage.engine.samples.junit4.JUnit4TestCaseWithNotFilterableRunner;
 import org.junit.vintage.engine.samples.junit4.JUnit4TestCaseWithOverloadedMethod;
 import org.junit.vintage.engine.samples.junit4.JUnit4TestCaseWithRunnerWithCustomUniqueIds;
 import org.junit.vintage.engine.samples.junit4.ParameterizedTestCase;
@@ -94,17 +95,35 @@ class VintageTestEngineDiscoveryTests {
 	}
 
 	@Test
-	void resolvesIgnoredJUnit4TestClass() {
+	void resolvesIgnoredJUnit4TestClass() throws Exception {
 		Class<?> testClass = IgnoredJUnit4TestCase.class;
 		LauncherDiscoveryRequest discoveryRequest = discoveryRequestForClass(testClass);
 
 		TestDescriptor engineDescriptor = discoverTests(discoveryRequest);
 
+		TestDescriptor runnerDescriptor = getOnlyElement(engineDescriptor.getChildren());
+		assertRunnerTestDescriptor(runnerDescriptor, testClass);
+
+		assertThat(runnerDescriptor.getChildren()).hasSize(2);
+		List<? extends TestDescriptor> children = new ArrayList<>(runnerDescriptor.getChildren());
+		assertTestMethodDescriptor(children.get(0), testClass, "failingTest",
+			VintageUniqueIdBuilder.uniqueIdForClass(testClass));
+		assertTestMethodDescriptor(children.get(1), testClass, "succeedingTest",
+			VintageUniqueIdBuilder.uniqueIdForClass(testClass));
+	}
+
+	@Test
+	void resolvesEmptyIgnoredTestClass() {
+		Class<?> testClass = EmptyIgnoredTestClass.class;
+		LauncherDiscoveryRequest discoveryRequest = discoveryRequestForClass(testClass);
+
+		TestDescriptor engineDescriptor = discoverTests(discoveryRequest);
+
 		TestDescriptor runnerDescriptor = getOnlyElement(engineDescriptor.getChildren());
 		assertFalse(runnerDescriptor.isContainer());
 		assertTrue(runnerDescriptor.isTest());
 		assertEquals(testClass.getName(), runnerDescriptor.getDisplayName());
-		Assertions.assertEquals(VintageUniqueIdBuilder.uniqueIdForClass(testClass), runnerDescriptor.getUniqueId());
+		assertEquals(VintageUniqueIdBuilder.uniqueIdForClass(testClass), runnerDescriptor.getUniqueId());
 		assertThat(runnerDescriptor.getChildren()).isEmpty();
 	}
 
@@ -191,13 +210,13 @@ class VintageTestEngineDiscoveryTests {
 
 		TestDescriptor testMethodDescriptor = testMethodDescriptors.get(0);
 		assertEquals("theory", testMethodDescriptor.getDisplayName());
-		Assertions.assertEquals(VintageUniqueIdBuilder.uniqueIdForMethod(testClass, "theory", "0"),
+		assertEquals(VintageUniqueIdBuilder.uniqueIdForMethod(testClass, "theory", "0"),
 			testMethodDescriptor.getUniqueId());
 		assertClassSource(testClass, testMethodDescriptor);
 
 		testMethodDescriptor = testMethodDescriptors.get(1);
 		assertEquals("theory", testMethodDescriptor.getDisplayName());
-		Assertions.assertEquals(VintageUniqueIdBuilder.uniqueIdForMethod(testClass, "theory", "1"),
+		assertEquals(VintageUniqueIdBuilder.uniqueIdForMethod(testClass, "theory", "1"),
 			testMethodDescriptor.getUniqueId());
 		assertClassSource(testClass, testMethodDescriptor);
 	}
@@ -379,6 +398,22 @@ class VintageTestEngineDiscoveryTests {
 			VintageUniqueIdBuilder.uniqueIdForClass(testClass));
 	}
 
+	@Test
+	void resolvesMethodOfIgnoredJUnit4TestClass() throws Exception {
+		Class<?> testClass = IgnoredJUnit4TestCase.class;
+		LauncherDiscoveryRequest discoveryRequest = request().selectors(
+			selectMethod(testClass, testClass.getMethod("failingTest"))).build();
+
+		TestDescriptor engineDescriptor = discoverTests(discoveryRequest);
+
+		TestDescriptor runnerDescriptor = getOnlyElement(engineDescriptor.getChildren());
+		assertRunnerTestDescriptor(runnerDescriptor, testClass);
+
+		TestDescriptor childDescriptor = getOnlyElement(runnerDescriptor.getChildren());
+		assertTestMethodDescriptor(childDescriptor, testClass, "failingTest",
+			VintageUniqueIdBuilder.uniqueIdForClass(testClass));
+	}
+
 	@Test
 	void resolvesMethodSelectorForTwoMethodsOfSameClass() throws Exception {
 		Class<?> testClass = PlainJUnit4TestCaseWithFiveTestMethods.class;
@@ -420,7 +455,7 @@ class VintageTestEngineDiscoveryTests {
 	}
 
 	@Test
-	void resolvesUniqueIdSelectorForSingleClass() throws Exception {
+	void resolvesUniqueIdSelectorForSingleClass() {
 		Class<?> testClass = PlainJUnit4TestCaseWithFiveTestMethods.class;
 		LauncherDiscoveryRequest discoveryRequest = request().selectors(
 			selectUniqueId(VintageUniqueIdBuilder.uniqueIdForClass(testClass))).build();
@@ -495,7 +530,7 @@ class VintageTestEngineDiscoveryTests {
 	}
 
 	@Test
-	void doesNotResolveMissingUniqueIdSelectorForSingleClass() throws Exception {
+	void doesNotResolveMissingUniqueIdSelectorForSingleClass() {
 		Class<?> testClass = PlainJUnit4TestCaseWithFiveTestMethods.class;
 		LauncherDiscoveryRequest discoveryRequest = request().selectors(
 			selectUniqueId(VintageUniqueIdBuilder.uniqueIdForClass(testClass) + "/[test:doesNotExist]")).build();
@@ -591,11 +626,11 @@ class VintageTestEngineDiscoveryTests {
 	}
 
 	@Test
-	void resolvesClassForMethodSelectorForClassWithNonFilterableRunner() throws Exception {
-		Class<?> testClass = IgnoredJUnit4TestCase.class;
+	void resolvesClassForMethodSelectorForClassWithNonFilterableRunner() {
+		Class<?> testClass = JUnit4TestCaseWithNotFilterableRunner.class;
 		// @formatter:off
 		LauncherDiscoveryRequest request = request()
-				.selectors(selectMethod(testClass, testClass.getMethod("test")))
+				.selectors(selectUniqueId(VintageUniqueIdBuilder.uniqueIdForMethod(testClass, "Test #0")))
 				.build();
 		// @formatter:on
 
@@ -603,12 +638,12 @@ class VintageTestEngineDiscoveryTests {
 
 		TestDescriptor runnerDescriptor = getOnlyElement(engineDescriptor.getChildren());
 		assertEquals(testClass.getName(), runnerDescriptor.getDisplayName());
-		Assertions.assertEquals(VintageUniqueIdBuilder.uniqueIdForClass(testClass), runnerDescriptor.getUniqueId());
-		assertThat(runnerDescriptor.getChildren()).isEmpty();
+		assertEquals(VintageUniqueIdBuilder.uniqueIdForClass(testClass), runnerDescriptor.getUniqueId());
+		assertThat(runnerDescriptor.getChildren()).isNotEmpty();
 	}
 
 	@Test
-	void usesCustomUniqueIdsWhenPresent() throws Exception {
+	void usesCustomUniqueIdsWhenPresent() {
 		Class<?> testClass = JUnit4TestCaseWithRunnerWithCustomUniqueIds.class;
 		LauncherDiscoveryRequest request = request().selectors(selectClass(testClass)).build();
 
@@ -686,7 +721,7 @@ class VintageTestEngineDiscoveryTests {
 		assertTrue(runnerDescriptor.isContainer());
 		assertFalse(runnerDescriptor.isTest());
 		assertEquals(testClass.getName(), runnerDescriptor.getDisplayName());
-		Assertions.assertEquals(VintageUniqueIdBuilder.uniqueIdForClass(testClass), runnerDescriptor.getUniqueId());
+		assertEquals(VintageUniqueIdBuilder.uniqueIdForClass(testClass), runnerDescriptor.getUniqueId());
 		assertClassSource(testClass, runnerDescriptor);
 	}
 
@@ -695,7 +730,7 @@ class VintageTestEngineDiscoveryTests {
 		assertTrue(testMethodDescriptor.isTest());
 		assertFalse(testMethodDescriptor.isContainer());
 		assertEquals(methodName, testMethodDescriptor.getDisplayName());
-		Assertions.assertEquals(VintageUniqueIdBuilder.uniqueIdForMethod(uniqueContainerId, testClass, methodName),
+		assertEquals(VintageUniqueIdBuilder.uniqueIdForMethod(uniqueContainerId, testClass, methodName),
 			testMethodDescriptor.getUniqueId());
 		assertThat(testMethodDescriptor.getChildren()).isEmpty();
 		assertMethodSource(testClass.getMethod(methodName), testMethodDescriptor);
@@ -706,7 +741,7 @@ class VintageTestEngineDiscoveryTests {
 		assertTrue(containerDescriptor.isContainer());
 		assertFalse(containerDescriptor.isTest());
 		assertEquals(testClass.getName(), containerDescriptor.getDisplayName());
-		Assertions.assertEquals(VintageUniqueIdBuilder.uniqueIdForClasses(suiteClass, testClass),
+		assertEquals(VintageUniqueIdBuilder.uniqueIdForClasses(suiteClass, testClass),
 			containerDescriptor.getUniqueId());
 		assertClassSource(testClass, containerDescriptor);
 	}
@@ -716,7 +751,7 @@ class VintageTestEngineDiscoveryTests {
 		assertTrue(testDescriptor.isTest());
 		assertFalse(testDescriptor.isContainer());
 		assertEquals("initializationError", testDescriptor.getDisplayName());
-		Assertions.assertEquals(VintageUniqueIdBuilder.uniqueIdForErrorInClass(testClass, failingClass),
+		assertEquals(VintageUniqueIdBuilder.uniqueIdForErrorInClass(testClass, failingClass),
 			testDescriptor.getUniqueId());
 		assertThat(testDescriptor.getChildren()).isEmpty();
 		assertClassSource(failingClass, testDescriptor);
diff --git a/junit-vintage-engine/src/test/java/org/junit/vintage/engine/VintageTestEngineExecutionTests.java b/junit-vintage-engine/src/test/java/org/junit/vintage/engine/VintageTestEngineExecutionTests.java
index 6fe8ebd13..fc5aee3a5 100644
--- a/junit-vintage-engine/src/test/java/org/junit/vintage/engine/VintageTestEngineExecutionTests.java
+++ b/junit-vintage-engine/src/test/java/org/junit/vintage/engine/VintageTestEngineExecutionTests.java
@@ -43,6 +43,7 @@ import org.junit.runner.RunWith;
 import org.junit.runner.Runner;
 import org.junit.runner.notification.RunNotifier;
 import org.junit.vintage.engine.samples.junit3.PlainJUnit3TestCaseWithSingleTestWhichFails;
+import org.junit.vintage.engine.samples.junit4.EmptyIgnoredTestClass;
 import org.junit.vintage.engine.samples.junit4.EnclosedJUnit4TestCase;
 import org.junit.vintage.engine.samples.junit4.IgnoredJUnit4TestCase;
 import org.junit.vintage.engine.samples.junit4.JUnit4SuiteOfSuiteWithIgnoredJUnit4TestCase;
@@ -304,7 +305,19 @@ class VintageTestEngineExecutionTests {
 
 		assertRecordedExecutionEventsContainsExactly(executionEvents, //
 			event(engine(), started()), //
-			event(test(testClass.getName()), skippedWithReason("complete class is ignored")), //
+			event(container(testClass), skippedWithReason("complete class is ignored")), //
+			event(engine(), finishedSuccessfully()));
+	}
+
+	@Test
+	void executesEmptyIgnoredTestClass() {
+		Class<?> testClass = EmptyIgnoredTestClass.class;
+
+		List<ExecutionEvent> executionEvents = execute(testClass);
+
+		assertRecordedExecutionEventsContainsExactly(executionEvents, //
+			event(engine(), started()), //
+			event(test(testClass.getName()), skippedWithReason("empty")), //
 			event(engine(), finishedSuccessfully()));
 	}
 
@@ -337,7 +350,7 @@ class VintageTestEngineExecutionTests {
 			event(engine(), started()), //
 			event(container(suiteOfSuiteClass), started()), //
 			event(container(suiteClass), started()), //
-			event(test(testClass.getName()), skippedWithReason("complete class is ignored")), //
+			event(container(testClass), skippedWithReason("complete class is ignored")), //
 			event(container(suiteClass), finishedSuccessfully()), //
 			event(container(suiteOfSuiteClass), finishedSuccessfully()), //
 			event(engine(), finishedSuccessfully()));
diff --git a/junit-vintage-engine/src/test/java/org/junit/vintage/engine/discovery/TestClassRequestResolverTests.java b/junit-vintage-engine/src/test/java/org/junit/vintage/engine/discovery/TestClassRequestResolverTests.java
index f433a178d..154df2e19 100644
--- a/junit-vintage-engine/src/test/java/org/junit/vintage/engine/discovery/TestClassRequestResolverTests.java
+++ b/junit-vintage-engine/src/test/java/org/junit/vintage/engine/discovery/TestClassRequestResolverTests.java
@@ -10,8 +10,8 @@
 
 package org.junit.vintage.engine.discovery;
 
-import static java.util.Arrays.asList;
 import static java.util.Collections.emptyList;
+import static java.util.Collections.singletonList;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.runner.Description.createTestDescription;
 import static org.junit.runner.manipulation.Filter.matchMethodDescription;
@@ -21,12 +21,13 @@ import java.util.List;
 import java.util.logging.Level;
 import java.util.logging.LogRecord;
 
-import org.junit.internal.builders.IgnoredClassRunner;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.engine.TrackLogRecords;
 import org.junit.platform.commons.logging.LogRecordListener;
 import org.junit.vintage.engine.VintageUniqueIdBuilder;
 import org.junit.vintage.engine.samples.junit4.IgnoredJUnit4TestCase;
+import org.junit.vintage.engine.samples.junit4.IgnoredJUnit4TestCaseWithNotFilterableRunner;
+import org.junit.vintage.engine.samples.junit4.NotFilterableRunner;
 import org.junit.vintage.engine.samples.junit4.PlainJUnit4TestCaseWithFiveTestMethods;
 
 /**
@@ -43,7 +44,7 @@ class TestClassRequestResolverTests {
 		RunnerTestDescriptorAwareFilter filter = adapter(
 			matchMethodDescription(createTestDescription(testClass, "failingTest")));
 
-		resolve(new TestClassRequest(testClass, asList(filter)));
+		resolve(new TestClassRequest(testClass, singletonList(filter)));
 
 		assertThat(listener.stream(TestClassRequestResolver.class)).isEmpty();
 	}
@@ -60,20 +61,17 @@ class TestClassRequestResolverTests {
 
 	@Test
 	void logsWarningOnNonFilterableRunner(LogRecordListener listener) {
-		Class<?> testClass = IgnoredJUnit4TestCase.class;
+		Class<?> testClass = IgnoredJUnit4TestCaseWithNotFilterableRunner.class;
 		RunnerTestDescriptorAwareFilter filter = adapter(
-			matchMethodDescription(createTestDescription(testClass, "test")));
+			matchMethodDescription(createTestDescription(testClass, "failingTest")));
 
-		resolve(new TestClassRequest(testClass, asList(filter)));
+		resolve(new TestClassRequest(testClass, singletonList(filter)));
 
 		// @formatter:off
-		assertThat(listener.stream(TestClassRequestResolver.class, Level.WARNING)
-			.map(LogRecord::getMessage)
-			.filter(m -> m.equals("Runner " + IgnoredClassRunner.class.getName() //
-				+ " (used on " + testClass.getName() + ") does not support filtering" //
-				+ " and will therefore be run completely."))
-			.count()
-		).isEqualTo(1);
+		assertThat(listener.stream(TestClassRequestResolver.class, Level.WARNING).map(LogRecord::getMessage))
+				.containsOnlyOnce("Runner " + NotFilterableRunner.class.getName()
+						+ " (used on " + testClass.getName() + ") does not support filtering"
+						+ " and will therefore be run completely.");
 		// @formatter:on
 	}
 
diff --git a/junit-vintage-engine/src/test/java/org/junit/vintage/engine/samples/junit4/EmptyIgnoredTestClass.java b/junit-vintage-engine/src/test/java/org/junit/vintage/engine/samples/junit4/EmptyIgnoredTestClass.java
new file mode 100644
index 000000000..889e5cf33
--- /dev/null
+++ b/junit-vintage-engine/src/test/java/org/junit/vintage/engine/samples/junit4/EmptyIgnoredTestClass.java
@@ -0,0 +1,17 @@
+/*
+ * Copyright 2015-2018 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * http://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.vintage.engine.samples.junit4;
+
+import org.junit.Ignore;
+
+@Ignore("empty")
+public class EmptyIgnoredTestClass {
+}
diff --git a/junit-vintage-engine/src/test/java/org/junit/vintage/engine/samples/junit4/IgnoredJUnit4TestCase.java b/junit-vintage-engine/src/test/java/org/junit/vintage/engine/samples/junit4/IgnoredJUnit4TestCase.java
index 97997c5fc..355bb4319 100644
--- a/junit-vintage-engine/src/test/java/org/junit/vintage/engine/samples/junit4/IgnoredJUnit4TestCase.java
+++ b/junit-vintage-engine/src/test/java/org/junit/vintage/engine/samples/junit4/IgnoredJUnit4TestCase.java
@@ -11,7 +11,9 @@
 package org.junit.vintage.engine.samples.junit4;
 
 import static org.junit.Assert.fail;
+import static org.junit.runners.MethodSorters.NAME_ASCENDING;
 
+import org.junit.FixMethodOrder;
 import org.junit.Ignore;
 import org.junit.Test;
 
@@ -19,11 +21,16 @@ import org.junit.Test;
  * @since 4.12
  */
 @Ignore("complete class is ignored")
+@FixMethodOrder(NAME_ASCENDING)
 public class IgnoredJUnit4TestCase {
 
 	@Test
-	public void test() {
-		fail("this test is not even discovered");
+	public void failingTest() {
+		fail("this test is discovered, but skipped");
+	}
+
+	@Test
+	public void succeedingTest() {
 	}
 
 }
diff --git a/junit-vintage-engine/src/test/java/org/junit/vintage/engine/samples/junit4/IgnoredJUnit4TestCaseWithNotFilterableRunner.java b/junit-vintage-engine/src/test/java/org/junit/vintage/engine/samples/junit4/IgnoredJUnit4TestCaseWithNotFilterableRunner.java
new file mode 100644
index 000000000..523cae06f
--- /dev/null
+++ b/junit-vintage-engine/src/test/java/org/junit/vintage/engine/samples/junit4/IgnoredJUnit4TestCaseWithNotFilterableRunner.java
@@ -0,0 +1,20 @@
+/*
+ * Copyright 2015-2018 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * http://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.vintage.engine.samples.junit4;
+
+import org.junit.Ignore;
+
+/**
+ * @since 5.1
+ */
+@Ignore
+public class IgnoredJUnit4TestCaseWithNotFilterableRunner extends JUnit4TestCaseWithNotFilterableRunner {
+}
