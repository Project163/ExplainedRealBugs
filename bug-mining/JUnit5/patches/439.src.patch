diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.8.0-M2.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.8.0-M2.adoc
index bd7d93c2b..fc0b6c547 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.8.0-M2.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.8.0-M2.adoc
@@ -48,6 +48,8 @@ on GitHub.
 
 ==== New Features and Improvements
 
+* `@TempDir` now supports creating multiple temporary directories via an identifier
+  specified on the annotation (e.g. `@TempDir("a")` and `@TempDir("b")`).
 * New `named()` static factory method in the `Named` interface that serves as an
   _alias_ for `Named.of()`. `named()` is intended to be used via `import static`.
 
diff --git a/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc b/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
index a8d38cfbc..6e2df586b 100644
--- a/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
+++ b/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
@@ -2187,6 +2187,15 @@ its content.
 include::{testDir}/example/TempDirectoryDemo.java[tags=user_guide_parameter_injection]
 ----
 
+You can inject multiple temporary directories by specifying explicit identifiers via the
+annotation parameter.
+
+[source,java,indent=0]
+.A test method that requires multiple temporary directories
+----
+include::{testDir}/example/TempDirectoryDemo.java[tags=user_guide_multiple_directories]
+----
+
 WARNING: `@TempDir` is not supported on constructor parameters. If you wish to retain a
 single reference to a temp directory across lifecycle methods and the current test method,
 please use field injection, by annotating a non-private instance field with `@TempDir`.
diff --git a/documentation/src/test/java/example/TempDirectoryDemo.java b/documentation/src/test/java/example/TempDirectoryDemo.java
index 217977408..4eadfcb4a 100644
--- a/documentation/src/test/java/example/TempDirectoryDemo.java
+++ b/documentation/src/test/java/example/TempDirectoryDemo.java
@@ -35,6 +35,18 @@ class TempDirectoryDemo {
 	}
 	// end::user_guide_parameter_injection[]
 
+	// tag::user_guide_multiple_directories[]
+	@Test
+	void copyFileFromSourceToTarget(@TempDir("from") Path source, @TempDir("to") Path target) throws IOException {
+		Path sourceFile = source.resolve("test.txt");
+
+		new ListWriter(sourceFile).write("a", "b", "c");
+		Path targetFile = Files.copy(sourceFile, target.resolve("test.txt"));
+
+		assertEquals(singletonList("a,b,c"), Files.readAllLines(targetFile));
+	}
+	// end::user_guide_multiple_directories[]
+
 	static
 	// tag::user_guide_field_injection[]
 	class SharedTempDirectoryDemo {
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/io/TempDir.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/io/TempDir.java
index 3d9bf2f1c..ddd1ff243 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/io/TempDir.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/io/TempDir.java
@@ -30,16 +30,20 @@ import org.junit.jupiter.api.extension.ParameterResolutionException;
  * or a parameter in a lifecycle method or test method of type {@link Path} or
  * {@link File} that should be resolved into a temporary directory.
  *
+ * <p>Multiple temporary directories can be created by supplying different
+ * {@linkplain #value identifiers} on the annotation.
+ *
  * <p>Please note that {@code @TempDir} is not supported on constructor
  * parameters. Please use field injection instead, by annotating a non-private
  * instance field with {@code @TempDir}.
  *
  * <h3>Temporary Directory Creation</h3>
  *
- * <p>The temporary directory is only created if a field in a test class or a
- * parameter in a lifecycle method or test method is annotated with
- * {@code @TempDir}. If the field type or parameter type is neither {@link Path}
- * nor {@link File} or if the temporary directory cannot be created, an
+ * <p>The temporary directory with the supplied {@linkplain #value identifier}
+ * is only created if a field in a test class or a parameter in a lifecycle
+ * method or test method is annotated with {@code @TempDir}. If the field type
+ * or parameter type is neither {@link Path} nor {@link File} or if the
+ * temporary directory cannot be created, an
  * {@link ExtensionConfigurationException} or a
  * {@link ParameterResolutionException} will be thrown as appropriate. In
  * addition, a {@code ParameterResolutionException} will be thrown for a
@@ -48,23 +52,25 @@ import org.junit.jupiter.api.extension.ParameterResolutionException;
  * <h3>Temporary Directory Scope</h3>
  *
  * <p>The scope of the temporary directory depends on where the first
- * {@code @TempDir} annotation is encountered when executing a test class. The
- * temporary directory will be shared by all tests in a class when the
- * annotation is present on a {@code static} field or on a parameter of a
- * {@link org.junit.jupiter.api.BeforeAll @BeforeAll} method. Otherwise &mdash;
+ * {@code @TempDir} annotation with the supplied {@linkplain #value identifier}
+ * is encountered when executing a test class. The temporary directory with that
+ * identifier will be shared by all tests in a class when the annotation is
+ * present with the same identifier on a {@code static} field or on a parameter
+ * of a {@link org.junit.jupiter.api.BeforeAll @BeforeAll} method. Otherwise –
  * for example, when {@code @TempDir} is only used on instance fields or on
- * parameters in test, {@link org.junit.jupiter.api.BeforeEach @BeforeEach},
- * or {@link org.junit.jupiter.api.AfterEach @AfterEach} methods &mdash; each test
- * will use its own temporary directory.
+ * parameters in test, {@link org.junit.jupiter.api.BeforeEach @BeforeEach}, or
+ * {@link org.junit.jupiter.api.AfterEach @AfterEach} methods – each test will
+ * use its own temporary directory.
  *
  * <h3>Temporary Directory Deletion</h3>
  *
- * <p>When the end of the scope of a temporary directory is reached, i.e. when
- * the test method or class has finished execution, JUnit will attempt to
- * recursively delete all files and directories in the temporary directory
- * and, finally, the temporary directory itself. In case deletion of a file or
- * directory fails, an {@link IOException} will be thrown that will cause the
- * test or test class to fail.
+ * <p>When the end of the scope of a temporary directory with a certain
+ * {@linkplain #value identifier} is reached, i.e. when the test method or class
+ * has finished execution, JUnit will attempt to recursively delete all files
+ * and directories in the temporary directory and, finally, the temporary
+ * directory itself. In case deletion of a file or directory fails, an
+ * {@link IOException} will be thrown that will cause the test or test class to
+ * fail.
  *
  * @since 5.4
  */
@@ -73,4 +79,10 @@ import org.junit.jupiter.api.extension.ParameterResolutionException;
 @Documented
 @API(status = EXPERIMENTAL, since = "5.4")
 public @interface TempDir {
+	/**
+	 * The identifier of the temporary directory.
+	 *
+	 * @since 5.8
+	 */
+	String value() default "";
 }
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TempDirectory.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TempDirectory.java
index 6b25465bb..8926f9b4a 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TempDirectory.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/TempDirectory.java
@@ -13,6 +13,7 @@ package org.junit.jupiter.engine.extension;
 import static java.nio.file.FileVisitResult.CONTINUE;
 import static java.util.stream.Collectors.joining;
 import static org.junit.platform.commons.util.AnnotationUtils.findAnnotatedFields;
+import static org.junit.platform.commons.util.AnnotationUtils.findAnnotation;
 import static org.junit.platform.commons.util.ReflectionUtils.isPrivate;
 import static org.junit.platform.commons.util.ReflectionUtils.makeAccessible;
 
@@ -61,7 +62,6 @@ import org.junit.platform.commons.util.ReflectionUtils;
 class TempDirectory implements BeforeAllCallback, BeforeEachCallback, ParameterResolver {
 
 	private static final Namespace NAMESPACE = Namespace.create(TempDirectory.class);
-	private static final String KEY = "temp.dir";
 	private static final String TEMP_DIR_PREFIX = "junit";
 
 	/**
@@ -98,8 +98,9 @@ class TempDirectory implements BeforeAllCallback, BeforeEachCallback, ParameterR
 
 		findAnnotatedFields(testClass, TempDir.class, predicate).forEach(field -> {
 			assertValidFieldCandidate(field);
+			String id = findAnnotation(field, TempDir.class).map(TempDir::value).orElse("");
 			try {
-				makeAccessible(field).set(testInstance, getPathOrFile(field.getType(), context));
+				makeAccessible(field).set(testInstance, getPathOrFile(field.getType(), context, id));
 			}
 			catch (Throwable t) {
 				ExceptionUtils.throwAsUncheckedException(t);
@@ -136,7 +137,8 @@ class TempDirectory implements BeforeAllCallback, BeforeEachCallback, ParameterR
 	public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
 		Class<?> parameterType = parameterContext.getParameter().getType();
 		assertSupportedType("parameter", parameterType);
-		return getPathOrFile(parameterType, extensionContext);
+		String id = parameterContext.findAnnotation(TempDir.class).map(TempDir::value).orElse("");
+		return getPathOrFile(parameterType, extensionContext, id);
 	}
 
 	private void assertSupportedType(String target, Class<?> type) {
@@ -146,9 +148,9 @@ class TempDirectory implements BeforeAllCallback, BeforeEachCallback, ParameterR
 		}
 	}
 
-	private Object getPathOrFile(Class<?> type, ExtensionContext extensionContext) {
+	private Object getPathOrFile(Class<?> type, ExtensionContext extensionContext, String id) {
 		Path path = extensionContext.getStore(NAMESPACE) //
-				.getOrComputeIfAbsent(KEY, key -> createTempDir(), CloseablePath.class) //
+				.getOrComputeIfAbsent(id, __ -> createTempDir(), CloseablePath.class) //
 				.get();
 
 		return (type == Path.class) ? path : path.toFile();
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TempDirectoryTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TempDirectoryTests.java
index 7350a771c..0ea486877 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TempDirectoryTests.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TempDirectoryTests.java
@@ -10,6 +10,7 @@
 
 package org.junit.jupiter.engine.extension;
 
+import static java.util.Objects.requireNonNull;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertNotEquals;
@@ -70,6 +71,12 @@ class TempDirectoryTests extends AbstractJupiterTestEngineTests {
 		BaseSeparateTempDirsParameterInjectionTestCase.tempDirs.clear();
 	}
 
+	@Test
+	void supportsMultipleTempDirs() {
+		executeTestsForClass(MultipleTempDirsTestCase.class).allEvents()//
+				.assertStatistics(stats -> stats.started(3).succeeded(3));
+	}
+
 	@Test
 	@DisplayName("does not prevent constructor parameter resolution")
 	void tempDirectoryDoesNotPreventConstructorParameterResolution() {
@@ -884,4 +891,96 @@ class TempDirectoryTests extends AbstractJupiterTestEngineTests {
 			}
 		}
 	}
+
+	static class MultipleTempDirsTestCase {
+
+		@TempDir("a")
+		static Path A;
+		static Path B;
+
+		@BeforeAll
+		static void beforeAll(@TempDir("a") Path dir1, @TempDir("b") Path dir2) {
+			assertEquals(A, requireNonNull(dir1));
+			B = requireNonNull(dir2);
+			assertNotEquals(A, B);
+			assertTrue(Files.exists(A));
+			assertTrue(Files.exists(B));
+		}
+
+		@TempDir("c")
+		Path c;
+		static Path C, D, E;
+
+		@BeforeEach
+		void beforeEach(@TempDir("d") Path dir1, @TempDir("b") Path dir2, @TempDir("c") Path dir3,
+				@TempDir("a") Path dir4) {
+			assertEquals(A, dir4);
+			assertEquals(B, dir2);
+			assertEquals(c, dir3);
+
+			C = requireNonNull(dir3);
+			assertNotEquals(A, C);
+			assertNotEquals(B, C);
+
+			D = requireNonNull(dir1);
+			assertNotEquals(A, D);
+			assertNotEquals(B, D);
+			assertNotEquals(C, D);
+
+			assertTrue(Files.exists(A));
+			assertTrue(Files.exists(B));
+			assertTrue(Files.exists(C));
+			assertTrue(Files.exists(D));
+		}
+
+		@Test
+		void test(@TempDir("c") Path dir1, @TempDir("e") Path dir2, @TempDir("a") Path dir3, @TempDir("d") Path dir4,
+				@TempDir("b") Path dir5) {
+			assertEquals(A, dir3);
+			assertEquals(B, dir5);
+			assertEquals(C, dir1);
+			assertEquals(D, dir4);
+
+			E = requireNonNull(dir2);
+			assertNotEquals(A, E);
+			assertNotEquals(B, E);
+			assertNotEquals(C, E);
+			assertNotEquals(D, E);
+
+			assertTrue(Files.exists(A));
+			assertTrue(Files.exists(B));
+			assertTrue(Files.exists(C));
+			assertTrue(Files.exists(D));
+			assertTrue(Files.exists(E));
+		}
+
+		@AfterEach
+		void afterEach(@TempDir("b") Path dir1, @TempDir("a") Path dir2, @TempDir("c") Path dir3,
+				@TempDir("e") Path dir4, @TempDir("d") Path dir5) {
+			assertEquals(A, dir2);
+			assertEquals(B, dir1);
+			assertEquals(C, dir3);
+			assertEquals(D, dir5);
+			assertEquals(E, dir4);
+
+			assertTrue(Files.exists(A));
+			assertTrue(Files.exists(B));
+			assertTrue(Files.exists(C));
+			assertTrue(Files.exists(D));
+			assertTrue(Files.exists(E));
+		}
+
+		@AfterAll
+		static void afterAll(@TempDir("b") Path dir1, @TempDir("a") Path dir2) {
+			assertEquals(A, dir2);
+			assertEquals(B, dir1);
+
+			assertTrue(Files.exists(A));
+			assertTrue(Files.exists(B));
+
+			assertTrue(Files.notExists(C));
+			assertTrue(Files.notExists(D));
+			assertTrue(Files.notExists(E));
+		}
+	}
 }
