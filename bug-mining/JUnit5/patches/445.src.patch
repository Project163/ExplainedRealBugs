diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.8.0-M2.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.8.0-M2.adoc
index 103543a22..5c08cbc6a 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.8.0-M2.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.8.0-M2.adoc
@@ -41,11 +41,14 @@ on GitHub.
   supported on Java 8 Update 262 or higher, in addition to Java 11 or later. See
   <<../user-guide/index.adoc#running-tests, Flight Recorder Support>> for details.
 
+
 [[release-notes-5.8.0-M2-junit-jupiter]]
 === JUnit Jupiter
 
 ==== Bug Fixes
 
+* `@DisplayNameGeneration` and `@IndicativeSentencesGeneration` are now only inherited
+  from enclosing classes if the current class is a `@Nested` test class.
 * The `IndicativeSentences` `DisplayNameGenerator` no longer includes the display name of
   the enclosing class when generating an _indicative sentence_ if the enclosing class is
   not configured to use the `IndicativeSentences` display name generator as well.
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DisplayNameGeneration.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DisplayNameGeneration.java
index b9cb2ffbd..f12a81923 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DisplayNameGeneration.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DisplayNameGeneration.java
@@ -25,9 +25,14 @@ import org.apiguardian.api.API;
  * {@code @DisplayNameGeneration} is used to declare a custom display name
  * generator for the annotated test class.
  *
+ * <p>This annotation is <em>inherited</em> from superclasses and implemented
+ * interfaces. It is also inherited from {@linkplain Class#getEnclosingClass()
+ * enclosing classes} for {@link Nested @Nested} test classes.
+ *
  * @since 5.4
  * @see DisplayName
  * @see DisplayNameGenerator
+ * @see IndicativeSentencesGeneration
  */
 @Target(ElementType.TYPE)
 @Retention(RetentionPolicy.RUNTIME)
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DisplayNameGenerator.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DisplayNameGenerator.java
index 4aa6206f2..58a5038b1 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DisplayNameGenerator.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DisplayNameGenerator.java
@@ -13,14 +13,13 @@ package org.junit.jupiter.api;
 import static org.apiguardian.api.API.Status.EXPERIMENTAL;
 import static org.apiguardian.api.API.Status.STABLE;
 import static org.junit.platform.commons.support.ModifierSupport.isStatic;
+import static org.junit.platform.commons.util.AnnotationUtils.findAnnotation;
 
-import java.lang.annotation.Annotation;
 import java.lang.reflect.Method;
 import java.util.Optional;
 import java.util.function.Predicate;
 
 import org.apiguardian.api.API;
-import org.junit.platform.commons.support.AnnotationSupport;
 import org.junit.platform.commons.util.ClassUtils;
 import org.junit.platform.commons.util.Preconditions;
 import org.junit.platform.commons.util.ReflectionUtils;
@@ -228,7 +227,7 @@ public interface DisplayNameGenerator {
 		private String getSentenceBeginning(Class<?> testClass) {
 			Class<?> enclosingClass = testClass.getEnclosingClass();
 			boolean topLevelTestClass = (enclosingClass == null || isStatic(testClass));
-			Optional<String> displayName = AnnotationSupport.findAnnotation(testClass, DisplayName.class)//
+			Optional<String> displayName = findAnnotation(testClass, DisplayName.class)//
 					.map(DisplayName::value).map(String::trim);
 
 			if (topLevelTestClass) {
@@ -305,7 +304,7 @@ public interface DisplayNameGenerator {
 		 * @return an {@code Optional} containing the annotation, potentially empty if not found
 		 */
 		private static Optional<DisplayNameGeneration> findDisplayNameGeneration(Class<?> testClass) {
-			return findAnnotation(testClass, DisplayNameGeneration.class);
+			return findAnnotation(testClass, DisplayNameGeneration.class, true);
 		}
 
 		/**
@@ -317,31 +316,7 @@ public interface DisplayNameGenerator {
 		 * @return an {@code Optional} containing the annotation, potentially empty if not found
 		 */
 		private static Optional<IndicativeSentencesGeneration> findIndicativeSentencesGeneration(Class<?> testClass) {
-			return findAnnotation(testClass, IndicativeSentencesGeneration.class);
-		}
-
-		/**
-		 * Find the first annotation of the specified type that is either
-		 * <em>directly present</em>, <em>meta-present</em>, or <em>indirectly
-		 * present</em> on the supplied {@code testClass} or on an enclosing class.
-		 *
-		 * @param <A> the annotation type
-		 * @param testClass the test class on which to search for the annotation;
-		 * never {@code null}
-		 * @param annotationType the annotation type to search for; never {@code null}
-		 * @return an {@code Optional} containing the annotation; never {@code null} but
-		 * potentially empty
-		 */
-		private static <A extends Annotation> Optional<A> findAnnotation(Class<?> testClass, Class<A> annotationType) {
-			Class<?> candidate = testClass;
-			do {
-				Optional<A> annotation = AnnotationSupport.findAnnotation(candidate, annotationType);
-				if (annotation.isPresent()) {
-					return annotation;
-				}
-				candidate = candidate.getEnclosingClass();
-			} while (candidate != null);
-			return Optional.empty();
+			return findAnnotation(testClass, IndicativeSentencesGeneration.class, true);
 		}
 
 		private static Predicate<Class<?>> not(Class<?> clazz) {
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/IndicativeSentencesGeneration.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/IndicativeSentencesGeneration.java
index 183fb8c6d..a3ded3df9 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/IndicativeSentencesGeneration.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/IndicativeSentencesGeneration.java
@@ -32,10 +32,15 @@ import org.junit.jupiter.api.DisplayNameGenerator.IndicativeSentences;
  * {@code @IndicativeSentencesGeneration} or {@code @IndicativeSentencesGeneration()}
  * &mdash; the default configuration will be used.
  *
+ * <p>This annotation is <em>inherited</em> from superclasses and implemented
+ * interfaces. It is also inherited from {@linkplain Class#getEnclosingClass()
+ * enclosing classes} for {@link Nested @Nested} test classes.
+ *
  * @since 5.7
  * @see DisplayName
  * @see DisplayNameGenerator
  * @see DisplayNameGenerator.IndicativeSentences
+ * @see DisplayNameGeneration
  */
 @DisplayNameGeneration(IndicativeSentences.class)
 @Target({ ElementType.ANNOTATION_TYPE, ElementType.TYPE })
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DisplayNameUtils.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DisplayNameUtils.java
index 549fd19b5..10ee96527 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DisplayNameUtils.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DisplayNameUtils.java
@@ -27,6 +27,7 @@ import org.junit.jupiter.api.DisplayNameGenerator.Standard;
 import org.junit.jupiter.engine.config.JupiterConfiguration;
 import org.junit.platform.commons.logging.Logger;
 import org.junit.platform.commons.logging.LoggerFactory;
+import org.junit.platform.commons.util.AnnotationUtils;
 import org.junit.platform.commons.util.Preconditions;
 import org.junit.platform.commons.util.ReflectionUtils;
 import org.junit.platform.commons.util.StringUtils;
@@ -106,7 +107,7 @@ final class DisplayNameUtils {
 			JupiterConfiguration configuration) {
 		Preconditions.notNull(testClass, "Test class must not be null");
 
-		return getDisplayNameGeneration(testClass) //
+		return AnnotationUtils.findAnnotation(testClass, DisplayNameGeneration.class, true) //
 				.map(DisplayNameGeneration::value) //
 				.map(displayNameGeneratorClass -> {
 					if (displayNameGeneratorClass == Standard.class) {
@@ -126,21 +127,4 @@ final class DisplayNameUtils {
 				.orElseGet(configuration::getDefaultDisplayNameGenerator);
 	}
 
-	/**
-	 * Find the first {@code DisplayNameGeneration} annotation that is either
-	 * <em>directly present</em>, <em>meta-present</em>, or <em>indirectly present</em>
-	 * on the supplied {@code testClass} or on an enclosing class.
-	 */
-	private static Optional<DisplayNameGeneration> getDisplayNameGeneration(Class<?> testClass) {
-		Class<?> candidate = testClass;
-		do {
-			Optional<DisplayNameGeneration> generation = findAnnotation(candidate, DisplayNameGeneration.class);
-			if (generation.isPresent()) {
-				return generation;
-			}
-			candidate = candidate.getEnclosingClass();
-		} while (candidate != null);
-		return Optional.empty();
-	}
-
 }
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/DisplayNameGenerationInheritanceTestCase.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/DisplayNameGenerationInheritanceTestCase.java
new file mode 100644
index 000000000..ee9908085
--- /dev/null
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/DisplayNameGenerationInheritanceTestCase.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2015-2021 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.api;
+
+import org.junit.jupiter.api.DisplayNameGenerator.ReplaceUnderscores;
+
+/**
+ * @since 5.8
+ */
+@DisplayNameGeneration(ReplaceUnderscores.class)
+class DisplayNameGenerationInheritanceTestCase {
+
+	@Nested
+	class InnerNestedTestCase {
+
+		@Test
+		void this_is_a_test() {
+		}
+	}
+
+	static class StaticNestedTestCase {
+
+		@Test
+		void this_is_a_test() {
+		}
+	}
+
+}
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/DisplayNameGenerationTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/DisplayNameGenerationTests.java
index ba748df29..eff86d0a7 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/DisplayNameGenerationTests.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/DisplayNameGenerationTests.java
@@ -10,10 +10,9 @@
 
 package org.junit.jupiter.api;
 
-import static java.util.stream.Collectors.toList;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertFalse;
-import static org.junit.jupiter.api.Assertions.assertLinesMatch;
 import static org.junit.jupiter.api.Assertions.assertThrows;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 import static org.junit.platform.engine.discovery.DiscoverySelectors.selectClass;
@@ -21,7 +20,6 @@ import static org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder.r
 
 import java.lang.reflect.Method;
 import java.util.EmptyStackException;
-import java.util.List;
 import java.util.Stack;
 
 import org.junit.jupiter.engine.AbstractJupiterTestEngineTests;
@@ -39,7 +37,7 @@ class DisplayNameGenerationTests extends AbstractJupiterTestEngineTests {
 
 	@Test
 	void standardGenerator() {
-		check(DefaultStyleTestCase.class, List.of( //
+		check(DefaultStyleTestCase.class, //
 			"CONTAINER: DisplayNameGenerationTests$DefaultStyleTestCase", //
 			"TEST: @DisplayName prevails", //
 			"TEST: test()", //
@@ -48,12 +46,12 @@ class DisplayNameGenerationTests extends AbstractJupiterTestEngineTests {
 			"TEST: testUsingCamelCase_and_also_UnderScores()", //
 			"TEST: testUsingCamelCase_and_also_UnderScores_keepingParameterTypeNamesIntact(TestInfo)", //
 			"TEST: test_with_underscores()" //
-		));
+		);
 	}
 
 	@Test
 	void simpleGenerator() {
-		check(SimpleStyleTestCase.class, List.of( //
+		check(SimpleStyleTestCase.class, //
 			"CONTAINER: DisplayNameGenerationTests$SimpleStyleTestCase", //
 			"TEST: @DisplayName prevails", //
 			"TEST: test", //
@@ -62,28 +60,32 @@ class DisplayNameGenerationTests extends AbstractJupiterTestEngineTests {
 			"TEST: testUsingCamelCase_and_also_UnderScores", //
 			"TEST: testUsingCamelCase_and_also_UnderScores_keepingParameterTypeNamesIntact (TestInfo)", //
 			"TEST: test_with_underscores" //
-		));
+		);
 	}
 
 	@Test
 	void underscoreGenerator() {
-		var expectedDisplayNames = List.of( //
-			"CONTAINER: DisplayNameGenerationTests\\$UnderscoreStyle.*", //
-			"TEST: @DisplayName prevails", //
-			"TEST: test", //
-			"TEST: test (TestInfo)", //
-			"TEST: test with underscores", //
-			"TEST: testUsingCamelCase and also UnderScores", //
-			"TEST: testUsingCamelCase and also UnderScores keepingParameterTypeNamesIntact (TestInfo)", //
-			"TEST: testUsingCamelCaseStyle" //
-		);
+		var expectedDisplayNames = new String[] { //
+				"<replace me>", //
+				"TEST: @DisplayName prevails", //
+				"TEST: test", //
+				"TEST: test (TestInfo)", //
+				"TEST: test with underscores", //
+				"TEST: testUsingCamelCase and also UnderScores", //
+				"TEST: testUsingCamelCase and also UnderScores keepingParameterTypeNamesIntact (TestInfo)", //
+				"TEST: testUsingCamelCaseStyle" //
+		};
+
+		expectedDisplayNames[0] = "CONTAINER: DisplayNameGenerationTests$UnderscoreStyleTestCase";
 		check(UnderscoreStyleTestCase.class, expectedDisplayNames);
+
+		expectedDisplayNames[0] = "CONTAINER: DisplayNameGenerationTests$UnderscoreStyleInheritedFromSuperClassTestCase";
 		check(UnderscoreStyleInheritedFromSuperClassTestCase.class, expectedDisplayNames);
 	}
 
 	@Test
 	void indicativeSentencesGeneratorOnStaticNestedClass() {
-		var expectedDisplayNames = List.of( //
+		check(IndicativeStyleTestCase.class, //
 			"CONTAINER: DisplayNameGenerationTests$IndicativeStyleTestCase", //
 			"TEST: @DisplayName prevails", //
 			"TEST: DisplayNameGenerationTests$IndicativeStyleTestCase -> test", //
@@ -93,32 +95,29 @@ class DisplayNameGenerationTests extends AbstractJupiterTestEngineTests {
 			"TEST: DisplayNameGenerationTests$IndicativeStyleTestCase -> testUsingCamelCase and also UnderScores keepingParameterTypeNamesIntact (TestInfo)", //
 			"TEST: DisplayNameGenerationTests$IndicativeStyleTestCase -> testUsingCamelCaseStyle" //
 		);
-		check(IndicativeStyleTestCase.class, expectedDisplayNames);
 	}
 
 	@Test
 	void indicativeSentencesGeneratorOnTopLevelClass() {
-		var expectedDisplayNames = List.of( //
+		check(IndicativeSentencesTopLevelTestCase.class, //
 			"CONTAINER: IndicativeSentencesTopLevelTestCase", //
 			"CONTAINER: IndicativeSentencesTopLevelTestCase -> A year is a leap year", //
 			"TEST: IndicativeSentencesTopLevelTestCase -> A year is a leap year -> if it is divisible by 4 but not by 100" //
 		);
-		check(IndicativeSentencesTopLevelTestCase.class, expectedDisplayNames);
 	}
 
 	@Test
 	void indicativeSentencesGeneratorOnNestedClass() {
-		var expectedDisplayNames = List.of( //
-			"CONTAINER: A year is a leap year", //
+		check(IndicativeSentencesNestedTestCase.class, //
 			"CONTAINER: IndicativeSentencesNestedTestCase", //
+			"CONTAINER: A year is a leap year", //
 			"TEST: A year is a leap year -> if it is divisible by 4 but not by 100" //
 		);
-		check(IndicativeSentencesNestedTestCase.class, expectedDisplayNames);
 	}
 
 	@Test
 	void noNameGenerator() {
-		check(NoNameStyleTestCase.class, List.of( //
+		check(NoNameStyleTestCase.class, //
 			"CONTAINER: nn", //
 			"TEST: @DisplayName prevails", //
 			"TEST: nn", //
@@ -127,54 +126,81 @@ class DisplayNameGenerationTests extends AbstractJupiterTestEngineTests {
 			"TEST: nn", //
 			"TEST: nn", //
 			"TEST: nn" //
-		));
+		);
 	}
 
 	@Test
 	void checkDisplayNameGeneratedForTestingAStackDemo() {
-		check(StackTestCase.class, List.of( //
-			"CONTAINER: A new stack", //
+		check(StackTestCase.class, //
 			"CONTAINER: A stack", //
-			"CONTAINER: After pushing an element to an empty stack", //
-			"TEST: is empty", //
 			"TEST: is instantiated using its noarg constructor", //
+			"CONTAINER: A new stack", //
+			"TEST: throws an EmptyStackException when peeked", //
+			"TEST: throws an EmptyStackException when popped", //
+			"TEST: is empty", //
+			"CONTAINER: After pushing an element to an empty stack", //
 			"TEST: peek returns that element without removing it from the stack", //
 			"TEST: pop returns that element and leaves an empty stack", //
-			"TEST: the stack is no longer empty", //
-			"TEST: throws an EmptyStackException when peeked", //
-			"TEST: throws an EmptyStackException when popped" //
-		));
+			"TEST: the stack is no longer empty" //
+		);
 	}
 
 	@Test
 	void checkDisplayNameGeneratedForIndicativeGeneratorTestCase() {
-		check(IndicativeGeneratorTestCase.class, List.of( //
+		check(IndicativeGeneratorTestCase.class, //
 			"CONTAINER: A stack", //
+			"TEST: A stack, is instantiated with new constructor", //
 			"CONTAINER: A stack, when new", //
+			"TEST: A stack, when new, throws EmptyStackException when peeked", //
 			"CONTAINER: A stack, when new, after pushing an element to an empty stack", //
-			"TEST: A stack, is instantiated with new constructor", //
-			"TEST: A stack, when new, after pushing an element to an empty stack, is no longer empty", //
-			"TEST: A stack, when new, throws EmptyStackException when peeked" //
-		));
+			"TEST: A stack, when new, after pushing an element to an empty stack, is no longer empty" //
+		);
 	}
 
 	@Test
 	void checkDisplayNameGeneratedForIndicativeGeneratorWithCustomSeparatorTestCase() {
-		check(IndicativeGeneratorWithCustomSeparatorTestCase.class, List.of( //
+		check(IndicativeGeneratorWithCustomSeparatorTestCase.class, //
 			"CONTAINER: A stack", //
+			"TEST: A stack >> is instantiated with new constructor", //
 			"CONTAINER: A stack >> when new", //
+			"TEST: A stack >> when new >> throws EmptyStackException when peeked", //
 			"CONTAINER: A stack >> when new >> after pushing an element to an empty stack", //
-			"TEST: A stack >> is instantiated with new constructor", //
-			"TEST: A stack >> when new >> after pushing an element to an empty stack >> is no longer empty", //
-			"TEST: A stack >> when new >> throws EmptyStackException when peeked"//
-		));
+			"TEST: A stack >> when new >> after pushing an element to an empty stack >> is no longer empty" //
+		);
+	}
+
+	@Test
+	void displayNameGenerationInheritance() {
+		check(DisplayNameGenerationInheritanceTestCase.InnerNestedTestCase.class, //
+			"CONTAINER: DisplayNameGenerationInheritanceTestCase", //
+			"CONTAINER: InnerNestedTestCase", //
+			"TEST: this is a test"//
+		);
+
+		check(DisplayNameGenerationInheritanceTestCase.StaticNestedTestCase.class, //
+			"CONTAINER: DisplayNameGenerationInheritanceTestCase$StaticNestedTestCase", //
+			"TEST: this_is_a_test()"//
+		);
+	}
+
+	@Test
+	void indicativeSentencesGenerationInheritance() {
+		check(IndicativeSentencesGenerationInheritanceTestCase.InnerNestedTestCase.class, //
+			"CONTAINER: IndicativeSentencesGenerationInheritanceTestCase", //
+			"CONTAINER: IndicativeSentencesGenerationInheritanceTestCase -> InnerNestedTestCase", //
+			"TEST: IndicativeSentencesGenerationInheritanceTestCase -> InnerNestedTestCase -> this is a test"//
+		);
+
+		check(IndicativeSentencesGenerationInheritanceTestCase.StaticNestedTestCase.class, //
+			"CONTAINER: IndicativeSentencesGenerationInheritanceTestCase$StaticNestedTestCase", //
+			"TEST: this_is_a_test()"//
+		);
 	}
 
-	private void check(Class<?> testClass, List<String> expectedDisplayNames) {
+	private void check(Class<?> testClass, String... expectedDisplayNames) {
 		var request = request().selectors(selectClass(testClass)).build();
 		var descriptors = discoverTests(request).getDescendants();
-		var sortedNames = descriptors.stream().map(this::describe).sorted().collect(toList());
-		assertLinesMatch(expectedDisplayNames, sortedNames);
+		assertThat(descriptors).map(this::describe).containsExactlyInAnyOrder(expectedDisplayNames);
 	}
 
 	private String describe(TestDescriptor descriptor) {
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/IndicativeSentencesGenerationInheritanceTestCase.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/IndicativeSentencesGenerationInheritanceTestCase.java
new file mode 100644
index 000000000..5ade3aa36
--- /dev/null
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/IndicativeSentencesGenerationInheritanceTestCase.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2015-2021 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.api;
+
+import org.junit.jupiter.api.DisplayNameGenerator.ReplaceUnderscores;
+
+/**
+ * @since 5.8
+ */
+@IndicativeSentencesGeneration(separator = " -> ", generator = ReplaceUnderscores.class)
+class IndicativeSentencesGenerationInheritanceTestCase {
+
+	@Nested
+	class InnerNestedTestCase {
+
+		@Test
+		void this_is_a_test() {
+		}
+	}
+
+	static class StaticNestedTestCase {
+
+		@Test
+		void this_is_a_test() {
+		}
+	}
+
+}
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/IndicativeSentencesNestedTestCase.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/IndicativeSentencesNestedTestCase.java
index 018cd5255..a1790bdd2 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/IndicativeSentencesNestedTestCase.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/IndicativeSentencesNestedTestCase.java
@@ -17,6 +17,7 @@ import org.junit.jupiter.api.DisplayNameGenerator.ReplaceUnderscores;
  * that is nested directly within a top-level test class.
  *
  * @see IndicativeSentencesTopLevelTestCase
+ * @since 5.8
  */
 class IndicativeSentencesNestedTestCase {
 
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/IndicativeSentencesTopLevelTestCase.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/IndicativeSentencesTopLevelTestCase.java
index 03fd754bb..9e27bd45e 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/IndicativeSentencesTopLevelTestCase.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/IndicativeSentencesTopLevelTestCase.java
@@ -17,6 +17,7 @@ import org.junit.jupiter.api.DisplayNameGenerator.ReplaceUnderscores;
  * test class that contains a nested test class.
  *
  * @see IndicativeSentencesNestedTestCase
+ * @since 5.8
  */
 @IndicativeSentencesGeneration(separator = " -> ", generator = ReplaceUnderscores.class)
 class IndicativeSentencesTopLevelTestCase {
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/discovery/JupiterUniqueIdBuilder.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/discovery/JupiterUniqueIdBuilder.java
index 4ee8a5ee6..40166e222 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/discovery/JupiterUniqueIdBuilder.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/discovery/JupiterUniqueIdBuilder.java
@@ -10,13 +10,14 @@
 
 package org.junit.jupiter.engine.discovery;
 
+import static org.junit.platform.commons.util.ReflectionUtils.isInnerClass;
+
 import org.junit.jupiter.engine.descriptor.ClassTestDescriptor;
 import org.junit.jupiter.engine.descriptor.JupiterEngineDescriptor;
 import org.junit.jupiter.engine.descriptor.NestedClassTestDescriptor;
 import org.junit.jupiter.engine.descriptor.TestFactoryTestDescriptor;
 import org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor;
 import org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor;
-import org.junit.platform.commons.util.ReflectionUtils;
 import org.junit.platform.engine.UniqueId;
 
 /**
@@ -30,7 +31,7 @@ public class JupiterUniqueIdBuilder {
 
 	public static UniqueId uniqueIdForClass(Class<?> clazz) {
 		UniqueId containerId = engineId();
-		if (clazz.getEnclosingClass() != null && !ReflectionUtils.isStatic(clazz)) {
+		if (isInnerClass(clazz)) {
 			containerId = uniqueIdForClass(clazz.getEnclosingClass());
 			return containerId.append(NestedClassTestDescriptor.SEGMENT_TYPE, clazz.getSimpleName());
 		}
diff --git a/junit-platform-commons/src/main/java/org/junit/platform/commons/util/AnnotationUtils.java b/junit-platform-commons/src/main/java/org/junit/platform/commons/util/AnnotationUtils.java
index cab0dd735..849b12d85 100644
--- a/junit-platform-commons/src/main/java/org/junit/platform/commons/util/AnnotationUtils.java
+++ b/junit-platform-commons/src/main/java/org/junit/platform/commons/util/AnnotationUtils.java
@@ -13,6 +13,7 @@ package org.junit.platform.commons.util;
 import static java.util.Arrays.asList;
 import static org.apiguardian.api.API.Status.INTERNAL;
 import static org.junit.platform.commons.util.CollectionUtils.toUnmodifiableList;
+import static org.junit.platform.commons.util.ReflectionUtils.isInnerClass;
 
 import java.lang.annotation.Annotation;
 import java.lang.annotation.Inherited;
@@ -183,6 +184,45 @@ public final class AnnotationUtils {
 		return Optional.empty();
 	}
 
+	/**
+	 * Find the first annotation of the specified type that is either
+	 * <em>directly present</em>, <em>meta-present</em>, or <em>indirectly
+	 * present</em> on the supplied class, optionally searching recursively
+	 * through the enclosing class hierarchy if not found on the supplied class.
+	 *
+	 * <p>The enclosing class hierarchy will only be searched above an <em>inner
+	 * class</em> (i.e., a non-static member class).
+	 *
+	 * @param <A> the annotation type
+	 * @param clazz the class on which to search for the annotation; may be {@code null}
+	 * @param annotationType the annotation type to search for; never {@code null}
+	 * @param searchEnclosingClasses whether the enclosing class hierarchy should
+	 * be searched
+	 * @return an {@code Optional} containing the annotation; never {@code null} but
+	 * potentially empty
+	 * @since 1.8
+	 * @see #findAnnotation(AnnotatedElement, Class)
+	 */
+	public static <A extends Annotation> Optional<A> findAnnotation(Class<?> clazz, Class<A> annotationType,
+			boolean searchEnclosingClasses) {
+
+		Preconditions.notNull(annotationType, "annotationType must not be null");
+
+		if (!searchEnclosingClasses) {
+			return findAnnotation(clazz, annotationType);
+		}
+
+		Class<?> candidate = clazz;
+		while (candidate != null) {
+			Optional<A> annotation = findAnnotation(candidate, annotationType);
+			if (annotation.isPresent()) {
+				return annotation;
+			}
+			candidate = (isInnerClass(candidate) ? candidate.getEnclosingClass() : null);
+		}
+		return Optional.empty();
+	}
+
 	/**
 	 * @since 1.5
 	 * @see org.junit.platform.commons.support.AnnotationSupport#findRepeatableAnnotations(Optional, Class)
