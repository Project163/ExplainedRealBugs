diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.6.0-M1.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.6.0-M1.adoc
index f32950d20..0c3b5a724 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.6.0-M1.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.6.0-M1.adoc
@@ -32,6 +32,8 @@ on GitHub.
   module (in terms of the Java Module System). Specifically, a new internal utility has
   been introduced in `PackageUtils` that implements functionality equivalent to
   `javax.lang.model.SourceVersion.isName(CharSequence)` from the `java.compiler` module.
+* Exceptions thrown by test engines during discovery and execution are now reported to
+  `TestExecutionListeners`.
 
 
 [[release-notes-5.6.0-M1-junit-jupiter]]
diff --git a/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/DefaultLauncher.java b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/DefaultLauncher.java
index 4da3c62e3..950b3086b 100644
--- a/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/DefaultLauncher.java
+++ b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/DefaultLauncher.java
@@ -21,10 +21,12 @@ import org.junit.platform.commons.logging.LoggerFactory;
 import org.junit.platform.commons.util.BlacklistedExceptions;
 import org.junit.platform.commons.util.Preconditions;
 import org.junit.platform.engine.ConfigurationParameters;
+import org.junit.platform.engine.EngineExecutionListener;
 import org.junit.platform.engine.ExecutionRequest;
 import org.junit.platform.engine.FilterResult;
 import org.junit.platform.engine.TestDescriptor;
 import org.junit.platform.engine.TestEngine;
+import org.junit.platform.engine.TestExecutionResult;
 import org.junit.platform.engine.UniqueId;
 import org.junit.platform.launcher.Launcher;
 import org.junit.platform.launcher.LauncherDiscoveryRequest;
@@ -161,26 +163,28 @@ class DefaultLauncher implements Launcher {
 			logger.debug(() -> String.format("Discovering tests during Launcher %s phase in engine '%s'.", phase,
 				testEngine.getId()));
 
-			Optional<TestDescriptor> engineRoot = discoverEngineRoot(testEngine, discoveryRequest);
-			engineRoot.ifPresent(rootDescriptor -> root.add(testEngine, rootDescriptor));
+			TestDescriptor rootDescriptor = discoverEngineRoot(testEngine, discoveryRequest);
+			root.add(testEngine, rootDescriptor);
 		}
 		root.applyPostDiscoveryFilters(discoveryRequest);
 		root.prune();
 		return root;
 	}
 
-	private Optional<TestDescriptor> discoverEngineRoot(TestEngine testEngine,
-			LauncherDiscoveryRequest discoveryRequest) {
+	private TestDescriptor discoverEngineRoot(TestEngine testEngine, LauncherDiscoveryRequest discoveryRequest) {
 
 		UniqueId uniqueEngineId = UniqueId.forEngine(testEngine.getId());
 		try {
 			TestDescriptor engineRoot = testEngine.discover(discoveryRequest, uniqueEngineId);
 			discoveryResultValidator.validate(testEngine, engineRoot);
-			return Optional.of(engineRoot);
+			return engineRoot;
 		}
 		catch (Throwable throwable) {
-			handleThrowable(testEngine, "discover", throwable);
-			return Optional.empty();
+			BlacklistedExceptions.rethrowIfBlacklisted(throwable);
+			String message = String.format("TestEngine with ID '%s' failed to discover tests", testEngine.getId());
+			logger.error(throwable, () -> message);
+			JUnitException cause = new JUnitException(message, throwable);
+			return new EngineDiscoveryErrorDescriptor(uniqueEngineId, testEngine.getId(), cause);
 		}
 	}
 
@@ -193,9 +197,15 @@ class DefaultLauncher implements Launcher {
 			ExecutionListenerAdapter engineExecutionListener = new ExecutionListenerAdapter(internalTestPlan,
 				testExecutionListener);
 			for (TestEngine testEngine : root.getTestEngines()) {
-				TestDescriptor testDescriptor = root.getTestDescriptorFor(testEngine);
-				execute(testEngine,
-					new ExecutionRequest(testDescriptor, engineExecutionListener, configurationParameters));
+				TestDescriptor engineDescriptor = root.getTestDescriptorFor(testEngine);
+				if (engineDescriptor instanceof EngineDiscoveryErrorDescriptor) {
+					engineExecutionListener.executionStarted(engineDescriptor);
+					engineExecutionListener.executionFinished(engineDescriptor,
+						TestExecutionResult.failed(((EngineDiscoveryErrorDescriptor) engineDescriptor).getCause()));
+				}
+				else {
+					execute(engineDescriptor, engineExecutionListener, configurationParameters, testEngine);
+				}
 			}
 			testExecutionListener.testPlanExecutionFinished(internalTestPlan);
 		});
@@ -224,19 +234,19 @@ class DefaultLauncher implements Launcher {
 		return registry;
 	}
 
-	private void execute(TestEngine testEngine, ExecutionRequest executionRequest) {
+	private void execute(TestDescriptor engineDescriptor, EngineExecutionListener listener,
+			ConfigurationParameters configurationParameters, TestEngine testEngine) {
+		OutcomeDelayingEngineExecutionListener delayingListener = new OutcomeDelayingEngineExecutionListener(listener,
+			engineDescriptor);
 		try {
-			testEngine.execute(executionRequest);
+			testEngine.execute(new ExecutionRequest(engineDescriptor, delayingListener, configurationParameters));
+			delayingListener.reportEngineOutcome();
 		}
 		catch (Throwable throwable) {
-			handleThrowable(testEngine, "execute", throwable);
+			BlacklistedExceptions.rethrowIfBlacklisted(throwable);
+			delayingListener.reportEngineFailure(new JUnitException(
+				String.format("TestEngine with ID '%s' failed to execute tests", testEngine.getId()), throwable));
 		}
 	}
 
-	private void handleThrowable(TestEngine testEngine, String phase, Throwable throwable) {
-		BlacklistedExceptions.rethrowIfBlacklisted(throwable);
-		logger.warn(throwable,
-			() -> String.format("TestEngine with ID '%s' failed to %s tests", testEngine.getId(), phase));
-	}
-
 }
diff --git a/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/DelegatingEngineExecutionListener.java b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/DelegatingEngineExecutionListener.java
new file mode 100644
index 000000000..631c76171
--- /dev/null
+++ b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/DelegatingEngineExecutionListener.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright 2015-2019 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.platform.launcher.core;
+
+import org.junit.platform.engine.EngineExecutionListener;
+import org.junit.platform.engine.TestDescriptor;
+import org.junit.platform.engine.TestExecutionResult;
+import org.junit.platform.engine.reporting.ReportEntry;
+
+/**
+ * @since 5.6
+ */
+class DelegatingEngineExecutionListener implements EngineExecutionListener {
+
+	private EngineExecutionListener delegate;
+
+	DelegatingEngineExecutionListener(EngineExecutionListener delegate) {
+		this.delegate = delegate;
+	}
+
+	@Override
+	public void dynamicTestRegistered(TestDescriptor testDescriptor) {
+		delegate.dynamicTestRegistered(testDescriptor);
+	}
+
+	@Override
+	public void executionSkipped(TestDescriptor testDescriptor, String reason) {
+		delegate.executionSkipped(testDescriptor, reason);
+	}
+
+	@Override
+	public void executionStarted(TestDescriptor testDescriptor) {
+		delegate.executionStarted(testDescriptor);
+	}
+
+	@Override
+	public void executionFinished(TestDescriptor testDescriptor, TestExecutionResult testExecutionResult) {
+		delegate.executionFinished(testDescriptor, testExecutionResult);
+	}
+
+	@Override
+	public void reportingEntryPublished(TestDescriptor testDescriptor, ReportEntry entry) {
+		delegate.reportingEntryPublished(testDescriptor, entry);
+	}
+}
diff --git a/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/EngineDiscoveryErrorDescriptor.java b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/EngineDiscoveryErrorDescriptor.java
new file mode 100644
index 000000000..3c5737ae0
--- /dev/null
+++ b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/EngineDiscoveryErrorDescriptor.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2015-2019 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.platform.launcher.core;
+
+import org.junit.platform.engine.UniqueId;
+import org.junit.platform.engine.support.descriptor.AbstractTestDescriptor;
+
+/**
+ * Represents an error thrown by a {@link org.junit.platform.engine.TestEngine}
+ * during discovery.
+ *
+ * <p>The contained {@link Throwable} will be reported as the cause of a test
+ * failure by the {@link DefaultLauncher} when execution is started for this
+ * engine.
+ *
+ * @since 1.6
+ */
+class EngineDiscoveryErrorDescriptor extends AbstractTestDescriptor {
+
+	private final Throwable cause;
+
+	EngineDiscoveryErrorDescriptor(UniqueId uniqueId, String displayName, Throwable cause) {
+		super(uniqueId, displayName);
+		this.cause = cause;
+	}
+
+	Throwable getCause() {
+		return cause;
+	}
+
+	@Override
+	public Type getType() {
+		return Type.TEST;
+	}
+
+	@Override
+	public void prune() {
+		// prevent pruning
+	}
+}
diff --git a/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/InternalTestPlan.java b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/InternalTestPlan.java
index 3450a36d3..48f970276 100644
--- a/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/InternalTestPlan.java
+++ b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/InternalTestPlan.java
@@ -47,10 +47,6 @@ class InternalTestPlan extends TestPlan {
 		return root;
 	}
 
-	TestPlan getDelegate() {
-		return delegate;
-	}
-
 	@Override
 	@SuppressWarnings("deprecation")
 	public void add(TestIdentifier testIdentifier) {
diff --git a/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/OutcomeDelayingEngineExecutionListener.java b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/OutcomeDelayingEngineExecutionListener.java
new file mode 100644
index 000000000..8324dff79
--- /dev/null
+++ b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/OutcomeDelayingEngineExecutionListener.java
@@ -0,0 +1,86 @@
+/*
+ * Copyright 2015-2019 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.platform.launcher.core;
+
+import org.junit.platform.engine.EngineExecutionListener;
+import org.junit.platform.engine.TestDescriptor;
+import org.junit.platform.engine.TestExecutionResult;
+
+/**
+ * Delays reporting of engine skipped/finished events so that exceptions thrown
+ * by engines can be reported to listeners.
+ *
+ * @since 5.6
+ */
+class OutcomeDelayingEngineExecutionListener extends DelegatingEngineExecutionListener {
+
+	private final TestDescriptor engineDescriptor;
+
+	private volatile boolean engineStarted;
+	private volatile Outcome outcome;
+	private volatile String skipReason;
+	private volatile TestExecutionResult executionResult;
+
+	OutcomeDelayingEngineExecutionListener(EngineExecutionListener delegate, TestDescriptor engineDescriptor) {
+		super(delegate);
+		this.engineDescriptor = engineDescriptor;
+	}
+
+	public void executionSkipped(TestDescriptor testDescriptor, String reason) {
+		if (testDescriptor == engineDescriptor) {
+			outcome = Outcome.SKIPPED;
+			skipReason = reason;
+		}
+		else {
+			super.executionSkipped(testDescriptor, reason);
+		}
+	}
+
+	public void executionStarted(TestDescriptor testDescriptor) {
+		if (testDescriptor == engineDescriptor) {
+			engineStarted = true;
+		}
+		super.executionStarted(testDescriptor);
+	}
+
+	public void executionFinished(TestDescriptor testDescriptor, TestExecutionResult executionResult) {
+		if (testDescriptor == engineDescriptor) {
+			outcome = Outcome.FINISHED;
+			this.executionResult = executionResult;
+		}
+		else {
+			super.executionFinished(testDescriptor, executionResult);
+		}
+	}
+
+	void reportEngineOutcome() {
+		if (outcome == Outcome.FINISHED) {
+			super.executionFinished(engineDescriptor, executionResult);
+		}
+		else if (outcome == Outcome.SKIPPED) {
+			super.executionSkipped(engineDescriptor, skipReason);
+		}
+	}
+
+	void reportEngineFailure(Throwable throwable) {
+		if (!engineStarted) {
+			super.executionStarted(engineDescriptor);
+		}
+		if (executionResult != null && executionResult.getThrowable().isPresent()) {
+			throwable.addSuppressed(executionResult.getThrowable().get());
+		}
+		super.executionFinished(engineDescriptor, TestExecutionResult.failed(throwable));
+	}
+
+	private enum Outcome {
+		SKIPPED, FINISHED
+	}
+}
diff --git a/platform-tests/src/test/java/org/junit/platform/launcher/core/DefaultLauncherTests.java b/platform-tests/src/test/java/org/junit/platform/launcher/core/DefaultLauncherTests.java
index 93f277b36..09827e3d5 100644
--- a/platform-tests/src/test/java/org/junit/platform/launcher/core/DefaultLauncherTests.java
+++ b/platform-tests/src/test/java/org/junit/platform/launcher/core/DefaultLauncherTests.java
@@ -24,6 +24,7 @@ import static org.junit.platform.launcher.EngineFilter.includeEngines;
 import static org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder.request;
 import static org.junit.platform.launcher.core.LauncherFactoryForTestingPurposesOnly.createLauncher;
 import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.eq;
 import static org.mockito.ArgumentMatchers.same;
 import static org.mockito.Mockito.inOrder;
 import static org.mockito.Mockito.mock;
@@ -31,15 +32,19 @@ import static org.mockito.Mockito.times;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import java.lang.reflect.Constructor;
 import java.util.Optional;
 import java.util.logging.Level;
 import java.util.logging.LogRecord;
 
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.engine.TrackLogRecords;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.ValueSource;
 import org.junit.platform.commons.JUnitException;
 import org.junit.platform.commons.PreconditionViolationException;
 import org.junit.platform.commons.logging.LogRecordListener;
+import org.junit.platform.commons.util.ExceptionUtils;
 import org.junit.platform.engine.ConfigurationParameters;
 import org.junit.platform.engine.EngineDiscoveryRequest;
 import org.junit.platform.engine.EngineExecutionListener;
@@ -47,6 +52,7 @@ import org.junit.platform.engine.ExecutionRequest;
 import org.junit.platform.engine.FilterResult;
 import org.junit.platform.engine.TestDescriptor;
 import org.junit.platform.engine.TestEngine;
+import org.junit.platform.engine.TestExecutionResult;
 import org.junit.platform.engine.UniqueId;
 import org.junit.platform.engine.support.descriptor.EngineDescriptor;
 import org.junit.platform.engine.support.hierarchical.DemoHierarchicalTestDescriptor;
@@ -131,7 +137,7 @@ class DefaultLauncherTests {
 	}
 
 	@Test
-	void discoverTestPlanForEngineThatReturnsNullForItsRootDescriptor() {
+	void discoverTestPlanForEngineThatReturnsNullForItsRootDescriptor(LogRecordListener log) {
 		TestEngine engine = new TestEngineStub() {
 
 			@Override
@@ -141,35 +147,208 @@ class DefaultLauncherTests {
 		};
 
 		TestPlan testPlan = createLauncher(engine).discover(request().build());
-		assertThat(testPlan.getRoots()).hasSize(0);
+		assertThat(testPlan.getRoots()).hasSize(1);
+		assertThat(log.stream(DefaultLauncher.class, Level.SEVERE).map(LogRecord::getMessage)) //
+				.containsExactly("TestEngine with ID 'TestEngineStub' failed to discover tests");
 	}
 
-	@Test
-	void discoverTestPlanForEngineThatThrowsAnErrorInDiscoveryPhase() {
-		TestEngine engine = new TestEngineStub() {
+	@ParameterizedTest
+	@ValueSource(classes = { Error.class, RuntimeException.class })
+	void discoverErrorTestDescriptorForEngineThatThrowsInDiscoveryPhase(Class<? extends Throwable> throwableClass,
+			LogRecordListener log) {
+		TestEngine engine = new TestEngineStub("my-engine-id") {
 
 			@Override
 			public TestDescriptor discover(EngineDiscoveryRequest discoveryRequest, UniqueId uniqueId) {
-				throw new Error("ignored");
+				try {
+					Constructor<? extends Throwable> constructor = throwableClass.getDeclaredConstructor(String.class);
+					throw ExceptionUtils.throwAsUncheckedException(constructor.newInstance("ignored"));
+				}
+				catch (Exception ignored) {
+					return null;
+				}
 			}
 		};
 
-		TestPlan testPlan = createLauncher(engine).discover(request().build());
-		assertThat(testPlan.getRoots()).hasSize(0);
+		var launcher = createLauncher(engine);
+		var testPlan = launcher.discover(request().build());
+
+		assertThat(testPlan.getRoots()).hasSize(1);
+		assertThat(getOnlyElement(testPlan.getRoots()).getDisplayName()).isEqualTo("my-engine-id");
+		assertThat(log.stream(DefaultLauncher.class, Level.SEVERE).map(LogRecord::getMessage)) //
+				.containsExactly("TestEngine with ID 'my-engine-id' failed to discover tests");
+
+		var listener = mock(TestExecutionListener.class);
+		launcher.execute(testPlan, listener);
+
+		var engineIdentifier = getOnlyElement(testPlan.getRoots());
+		var testExecutionResult = ArgumentCaptor.forClass(TestExecutionResult.class);
+		verify(listener).executionStarted(engineIdentifier);
+		verify(listener).executionFinished(eq(engineIdentifier), testExecutionResult.capture());
+		assertThat(testExecutionResult.getValue().getThrowable()).isPresent();
+		assertThat(testExecutionResult.getValue().getThrowable().get()) //
+				.hasMessage("TestEngine with ID 'my-engine-id' failed to discover tests");
 	}
 
 	@Test
-	void discoverTestPlanForEngineThatThrowsRuntimeExceptionInDiscoveryPhase() {
-		TestEngine engine = new TestEngineStub() {
+	void reportsEngineExecutionFailuresWithoutPriorEvents() {
+		var rootCause = new RuntimeException("something went horribly wrong");
+		var engine = new TestEngineStub() {
+			@Override
+			public void execute(ExecutionRequest request) {
+				throw rootCause;
+			}
+		};
+
+		var listener = mock(TestExecutionListener.class);
+		createLauncher(engine).execute(request().build(), listener);
 
+		var testExecutionResult = ArgumentCaptor.forClass(TestExecutionResult.class);
+		verify(listener).executionStarted(any());
+		verify(listener).executionFinished(any(), testExecutionResult.capture());
+		assertThat(testExecutionResult.getValue().getThrowable()).isPresent();
+		assertThat(testExecutionResult.getValue().getThrowable().get()) //
+				.hasMessage("TestEngine with ID 'TestEngineStub' failed to execute tests") //
+				.hasCauseReference(rootCause);
+	}
+
+	@Test
+	void reportsEngineExecutionFailuresForSkippedEngine() {
+		var rootCause = new RuntimeException("something went horribly wrong");
+		var engine = new TestEngineStub() {
 			@Override
-			public TestDescriptor discover(EngineDiscoveryRequest discoveryRequest, UniqueId uniqueId) {
-				throw new RuntimeException("ignored");
+			public void execute(ExecutionRequest request) {
+				var engineDescriptor = request.getRootTestDescriptor();
+				request.getEngineExecutionListener().executionSkipped(engineDescriptor, "not today");
+				throw rootCause;
 			}
 		};
 
-		TestPlan testPlan = createLauncher(engine).discover(request().build());
-		assertThat(testPlan.getRoots()).hasSize(0);
+		var listener = mock(TestExecutionListener.class);
+		createLauncher(engine).execute(request().build(), listener);
+
+		var testExecutionResult = ArgumentCaptor.forClass(TestExecutionResult.class);
+		verify(listener).executionStarted(any());
+		verify(listener).executionFinished(any(), testExecutionResult.capture());
+		assertThat(testExecutionResult.getValue().getThrowable()).isPresent();
+		assertThat(testExecutionResult.getValue().getThrowable().get()) //
+				.hasMessage("TestEngine with ID 'TestEngineStub' failed to execute tests") //
+				.hasCauseReference(rootCause);
+	}
+
+	@Test
+	void reportsEngineExecutionFailuresForStartedEngine() {
+		var rootCause = new RuntimeException("something went horribly wrong");
+		var engine = new TestEngineStub() {
+			@Override
+			public void execute(ExecutionRequest request) {
+				var engineDescriptor = request.getRootTestDescriptor();
+				request.getEngineExecutionListener().executionStarted(engineDescriptor);
+				throw rootCause;
+			}
+		};
+
+		var listener = mock(TestExecutionListener.class);
+		createLauncher(engine).execute(request().build(), listener);
+
+		var testExecutionResult = ArgumentCaptor.forClass(TestExecutionResult.class);
+		verify(listener).executionStarted(any());
+		verify(listener).executionFinished(any(), testExecutionResult.capture());
+		assertThat(testExecutionResult.getValue().getThrowable()).isPresent();
+		assertThat(testExecutionResult.getValue().getThrowable().get()) //
+				.hasMessage("TestEngine with ID 'TestEngineStub' failed to execute tests") //
+				.hasCauseReference(rootCause);
+	}
+
+	@Test
+	void reportsEngineExecutionFailuresForSucessfullyFinishedEngine() {
+		var rootCause = new RuntimeException("something went horribly wrong");
+		var engine = new TestEngineStub() {
+			@Override
+			public void execute(ExecutionRequest request) {
+				var engineDescriptor = request.getRootTestDescriptor();
+				request.getEngineExecutionListener().executionStarted(engineDescriptor);
+				request.getEngineExecutionListener().executionFinished(engineDescriptor,
+					TestExecutionResult.successful());
+				throw rootCause;
+			}
+		};
+
+		var listener = mock(TestExecutionListener.class);
+		createLauncher(engine).execute(request().build(), listener);
+
+		var testExecutionResult = ArgumentCaptor.forClass(TestExecutionResult.class);
+		verify(listener).executionStarted(any());
+		verify(listener).executionFinished(any(), testExecutionResult.capture());
+		assertThat(testExecutionResult.getValue().getThrowable()).isPresent();
+		assertThat(testExecutionResult.getValue().getThrowable().get()) //
+				.hasMessage("TestEngine with ID 'TestEngineStub' failed to execute tests") //
+				.hasCauseReference(rootCause);
+	}
+
+	@Test
+	void reportsEngineExecutionFailuresForFailedFinishedEngine() {
+		var rootCause = new RuntimeException("something went horribly wrong");
+		var originalFailure = new RuntimeException("suppressed");
+		var engine = new TestEngineStub() {
+			@Override
+			public void execute(ExecutionRequest request) {
+				var engineDescriptor = request.getRootTestDescriptor();
+				var listener = request.getEngineExecutionListener();
+				listener.executionStarted(engineDescriptor);
+				listener.executionFinished(engineDescriptor, TestExecutionResult.failed(originalFailure));
+				throw rootCause;
+			}
+		};
+
+		var listener = mock(TestExecutionListener.class);
+		createLauncher(engine).execute(request().build(), listener);
+
+		var testExecutionResult = ArgumentCaptor.forClass(TestExecutionResult.class);
+		verify(listener).executionStarted(any());
+		verify(listener).executionFinished(any(), testExecutionResult.capture());
+		assertThat(testExecutionResult.getValue().getThrowable()).isPresent();
+		assertThat(testExecutionResult.getValue().getThrowable().get()) //
+				.hasMessage("TestEngine with ID 'TestEngineStub' failed to execute tests") //
+				.hasCauseReference(rootCause) //
+				.hasSuppressedException(originalFailure);
+	}
+
+	@Test
+	void reportsSkippedEngines() {
+		var engine = new TestEngineStub() {
+			@Override
+			public void execute(ExecutionRequest request) {
+				var engineDescriptor = request.getRootTestDescriptor();
+				request.getEngineExecutionListener().executionSkipped(engineDescriptor, "not today");
+			}
+		};
+
+		var listener = mock(TestExecutionListener.class);
+		createLauncher(engine).execute(request().build(), listener);
+
+		verify(listener).executionSkipped(any(TestIdentifier.class), eq("not today"));
+		verify(listener, times(0)).executionStarted(any());
+		verify(listener, times(0)).executionFinished(any(), any());
+	}
+
+	@Test
+	void reportsFinishedEngines() {
+		var engine = new TestEngineStub() {
+			@Override
+			public void execute(ExecutionRequest request) {
+				var engineDescriptor = request.getRootTestDescriptor();
+				var listener = request.getEngineExecutionListener();
+				listener.executionStarted(engineDescriptor);
+				listener.executionFinished(engineDescriptor, TestExecutionResult.successful());
+			}
+		};
+
+		var listener = mock(TestExecutionListener.class);
+		createLauncher(engine).execute(request().build(), listener);
+
+		verify(listener).executionStarted(any());
+		verify(listener).executionFinished(any(), eq(TestExecutionResult.successful()));
 	}
 
 	@Test
diff --git a/platform-tests/src/test/resources/log4j2-test.xml b/platform-tests/src/test/resources/log4j2-test.xml
index ec5fed0b3..d31e8503c 100644
--- a/platform-tests/src/test/resources/log4j2-test.xml
+++ b/platform-tests/src/test/resources/log4j2-test.xml
@@ -9,7 +9,7 @@
 		<Logger name="org.junit" level="warn" />
 		<Logger name="org.junit.platform.commons.util.ClasspathScanner" level="error" />
 		<Logger name="org.junit.platform.engine.support.descriptor.DemoClassTestDescriptor" level="error" />
-		<Logger name="org.junit.platform.launcher.core.DefaultLauncher" level="error" />
+		<Logger name="org.junit.platform.launcher.core.DefaultLauncher" level="fatal" />
 		<Logger name="org.junit.platform.launcher.core.InternalTestPlan" level="error" />
 		<Logger name="org.junit.platform.launcher.core.TestExecutionListenerRegistry" level="error" />
 		<Logger name="org.junit.ApiReportGenerator" level="error" />
