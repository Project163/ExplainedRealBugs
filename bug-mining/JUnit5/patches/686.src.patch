diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.12.0-RC2.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.12.0-RC2.adoc
index a3ac73cbf..0870c7513 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.12.0-RC2.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.12.0-RC2.adoc
@@ -1,7 +1,7 @@
 [[release-notes-5.12.0-RC2]]
 == 5.12.0-RC2
 
-*Date of Release:* ❓
+*Date of Release:* February 14, 2025
 
 *Scope:* Minor enhancements since JUnit 5.12.0-RC1.
 
@@ -64,4 +64,6 @@ repository on GitHub.
 [[release-notes-5.12.0-RC2-junit-vintage-new-features-and-improvements]]
 ==== New Features and Improvements
 
-* ❓
+* Support for executing test methods in parallel. Please refer to the
+  <<../user-guide/index.adoc#migrating-from-junit4-parallel-execution, User Guide>> for
+  more information.
diff --git a/documentation/src/docs/asciidoc/user-guide/migration-from-junit4.adoc b/documentation/src/docs/asciidoc/user-guide/migration-from-junit4.adoc
index 725b113de..292905327 100644
--- a/documentation/src/docs/asciidoc/user-guide/migration-from-junit4.adoc
+++ b/documentation/src/docs/asciidoc/user-guide/migration-from-junit4.adoc
@@ -39,13 +39,20 @@ discovered tests before executing them (see <<running-tests>> for details).
 [[migrating-from-junit4-parallel-execution]]
 === Parallel Execution
 
-The JUnit Vintage test engine supports parallel execution of top-level test classes,
+The JUnit Vintage test engine supports parallel execution of top-level test classes and test methods,
 allowing existing JUnit 3 and JUnit 4 tests to benefit from improved performance through
 concurrent test execution. It can be enabled and configured using the following
 <<running-tests-config-params, configuration parameters>>:
 
 `junit.vintage.execution.parallel.enabled=true|false`::
-  Enable/disable parallel execution (defaults to `false`).
+  Enable/disable parallel execution (defaults to `false`). Requires opt-in for `classes`
+  or `methods` to be executed in parallel using the configuration parameters below.
+
+`junit.vintage.execution.parallel.classes=true|false`::
+  Enable/disable parallel execution of test classes (defaults to `false`).
+
+`junit.vintage.execution.parallel.methods=true|false`::
+  Enable/disable parallel execution of test methods (defaults to `false`).
 
 `junit.vintage.execution.parallel.pool-size=<number>`::
   Specifies the size of the thread pool to be used for parallel execution. By default, the
@@ -56,6 +63,8 @@ Example configuration in `junit-platform.properties`:
 [source,properties]
 ----
 junit.vintage.execution.parallel.enabled=true
+junit.vintage.execution.parallel.classes=true
+junit.vintage.execution.parallel.methods=true
 junit.vintage.execution.parallel.pool-size=4
 ----
 
diff --git a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/Constants.java b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/Constants.java
index abb85e3eb..78e48d641 100644
--- a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/Constants.java
+++ b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/Constants.java
@@ -46,6 +46,28 @@ public final class Constants {
 	@API(status = EXPERIMENTAL, since = "5.12")
 	public static final String PARALLEL_POOL_SIZE = "junit.vintage.execution.parallel.pool-size";
 
+	/**
+	 * Indicates whether parallel execution is enabled for test classes in the JUnit Vintage engine.
+	 *
+	 * <p>Set this property to {@code true} to enable parallel execution of test classes.
+	 * Defaults to {@code false}.
+	 *
+	 * @since 5.12
+	 */
+	@API(status = EXPERIMENTAL, since = "5.12")
+	public static final String PARALLEL_CLASS_EXECUTION = "junit.vintage.execution.parallel.classes";
+
+	/**
+	 * Indicates whether parallel execution is enabled for test methods in the JUnit Vintage engine.
+	 *
+	 * <p>Set this property to {@code true} to enable parallel execution of test methods.
+	 * Defaults to {@code false}.
+	 *
+	 * @since 5.12
+	 */
+	@API(status = EXPERIMENTAL, since = "5.12")
+	public static final String PARALLEL_METHOD_EXECUTION = "junit.vintage.execution.parallel.methods";
+
 	private Constants() {
 		/* no-op */
 	}
diff --git a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/VintageTestEngine.java b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/VintageTestEngine.java
index 3d6840592..8d9279ae1 100644
--- a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/VintageTestEngine.java
+++ b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/VintageTestEngine.java
@@ -12,34 +12,20 @@ package org.junit.vintage.engine;
 
 import static org.apiguardian.api.API.Status.INTERNAL;
 import static org.junit.platform.engine.TestExecutionResult.successful;
-import static org.junit.vintage.engine.Constants.PARALLEL_EXECUTION_ENABLED;
-import static org.junit.vintage.engine.Constants.PARALLEL_POOL_SIZE;
 import static org.junit.vintage.engine.descriptor.VintageTestDescriptor.ENGINE_ID;
 
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
 import java.util.Optional;
-import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.ExecutionException;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import java.util.concurrent.TimeUnit;
 
 import org.apiguardian.api.API;
-import org.junit.platform.commons.logging.Logger;
-import org.junit.platform.commons.logging.LoggerFactory;
-import org.junit.platform.commons.util.ExceptionUtils;
 import org.junit.platform.engine.EngineDiscoveryRequest;
 import org.junit.platform.engine.EngineExecutionListener;
 import org.junit.platform.engine.ExecutionRequest;
 import org.junit.platform.engine.TestDescriptor;
 import org.junit.platform.engine.TestEngine;
 import org.junit.platform.engine.UniqueId;
-import org.junit.vintage.engine.descriptor.RunnerTestDescriptor;
 import org.junit.vintage.engine.descriptor.VintageEngineDescriptor;
 import org.junit.vintage.engine.discovery.VintageDiscoverer;
-import org.junit.vintage.engine.execution.RunnerExecutor;
+import org.junit.vintage.engine.execution.VintageExecutor;
 
 /**
  * The JUnit Vintage {@link TestEngine}.
@@ -49,11 +35,6 @@ import org.junit.vintage.engine.execution.RunnerExecutor;
 @API(status = INTERNAL, since = "4.12")
 public final class VintageTestEngine implements TestEngine {
 
-	private static final Logger logger = LoggerFactory.getLogger(VintageTestEngine.class);
-
-	private static final int DEFAULT_THREAD_POOL_SIZE = Runtime.getRuntime().availableProcessors();
-	private static final int SHUTDOWN_TIMEOUT_SECONDS = 30;
-
 	@Override
 	public String getId() {
 		return ENGINE_ID;
@@ -86,96 +67,7 @@ public final class VintageTestEngine implements TestEngine {
 		EngineExecutionListener engineExecutionListener = request.getEngineExecutionListener();
 		VintageEngineDescriptor engineDescriptor = (VintageEngineDescriptor) request.getRootTestDescriptor();
 		engineExecutionListener.executionStarted(engineDescriptor);
-		executeAllChildren(engineDescriptor, engineExecutionListener, request);
+		new VintageExecutor(engineDescriptor, engineExecutionListener, request).executeAllChildren();
 		engineExecutionListener.executionFinished(engineDescriptor, successful());
 	}
-
-	private void executeAllChildren(VintageEngineDescriptor engineDescriptor,
-			EngineExecutionListener engineExecutionListener, ExecutionRequest request) {
-		boolean parallelExecutionEnabled = getParallelExecutionEnabled(request);
-
-		if (parallelExecutionEnabled) {
-			if (executeInParallel(engineDescriptor, engineExecutionListener, request)) {
-				Thread.currentThread().interrupt();
-			}
-		}
-		else {
-			executeSequentially(engineDescriptor, engineExecutionListener);
-		}
-	}
-
-	private boolean executeInParallel(VintageEngineDescriptor engineDescriptor,
-			EngineExecutionListener engineExecutionListener, ExecutionRequest request) {
-		ExecutorService executorService = Executors.newFixedThreadPool(getThreadPoolSize(request));
-		RunnerExecutor runnerExecutor = new RunnerExecutor(engineExecutionListener);
-
-		List<CompletableFuture<Void>> futures = new ArrayList<>();
-		for (Iterator<TestDescriptor> iterator = engineDescriptor.getModifiableChildren().iterator(); iterator.hasNext();) {
-			TestDescriptor descriptor = iterator.next();
-			CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {
-				runnerExecutor.execute((RunnerTestDescriptor) descriptor);
-			}, executorService);
-
-			futures.add(future);
-			iterator.remove();
-		}
-
-		CompletableFuture<Void> allOf = CompletableFuture.allOf(futures.toArray(new CompletableFuture<?>[0]));
-		boolean wasInterrupted = false;
-		try {
-			allOf.get();
-		}
-		catch (InterruptedException e) {
-			logger.warn(e, () -> "Interruption while waiting for parallel test execution to finish");
-			wasInterrupted = true;
-		}
-		catch (ExecutionException e) {
-			throw ExceptionUtils.throwAsUncheckedException(e.getCause());
-		}
-		finally {
-			shutdownExecutorService(executorService);
-		}
-		return wasInterrupted;
-	}
-
-	private void shutdownExecutorService(ExecutorService executorService) {
-		try {
-			executorService.shutdown();
-			if (!executorService.awaitTermination(SHUTDOWN_TIMEOUT_SECONDS, TimeUnit.SECONDS)) {
-				logger.warn(() -> "Executor service did not terminate within the specified timeout");
-				executorService.shutdownNow();
-			}
-		}
-		catch (InterruptedException e) {
-			logger.warn(e, () -> "Interruption while waiting for executor service to shut down");
-			Thread.currentThread().interrupt();
-		}
-	}
-
-	private void executeSequentially(VintageEngineDescriptor engineDescriptor,
-			EngineExecutionListener engineExecutionListener) {
-		RunnerExecutor runnerExecutor = new RunnerExecutor(engineExecutionListener);
-		for (Iterator<TestDescriptor> iterator = engineDescriptor.getModifiableChildren().iterator(); iterator.hasNext();) {
-			runnerExecutor.execute((RunnerTestDescriptor) iterator.next());
-			iterator.remove();
-		}
-	}
-
-	private boolean getParallelExecutionEnabled(ExecutionRequest request) {
-		return request.getConfigurationParameters().getBoolean(PARALLEL_EXECUTION_ENABLED).orElse(false);
-	}
-
-	private int getThreadPoolSize(ExecutionRequest request) {
-		Optional<String> poolSize = request.getConfigurationParameters().get(PARALLEL_POOL_SIZE);
-		if (poolSize.isPresent()) {
-			try {
-				return Integer.parseInt(poolSize.get());
-			}
-			catch (NumberFormatException e) {
-				logger.warn(() -> "Invalid value for parallel pool size: " + poolSize.get());
-			}
-		}
-		return DEFAULT_THREAD_POOL_SIZE;
-	}
-
 }
diff --git a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/descriptor/RunnerTestDescriptor.java b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/descriptor/RunnerTestDescriptor.java
index 8d12fa032..05eb8ebfb 100644
--- a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/descriptor/RunnerTestDescriptor.java
+++ b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/descriptor/RunnerTestDescriptor.java
@@ -18,6 +18,11 @@ import java.util.HashSet;
 import java.util.List;
 import java.util.Optional;
 import java.util.Set;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Future;
+import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.function.Consumer;
 
 import org.apiguardian.api.API;
@@ -26,12 +31,16 @@ import org.junit.platform.commons.logging.Logger;
 import org.junit.platform.commons.logging.LoggerFactory;
 import org.junit.platform.engine.UniqueId;
 import org.junit.platform.engine.support.descriptor.ClassSource;
+import org.junit.platform.engine.support.hierarchical.OpenTest4JAwareThrowableCollector;
+import org.junit.platform.engine.support.hierarchical.ThrowableCollector;
 import org.junit.runner.Description;
 import org.junit.runner.Request;
 import org.junit.runner.Runner;
 import org.junit.runner.manipulation.Filter;
 import org.junit.runner.manipulation.Filterable;
 import org.junit.runner.manipulation.NoTestsRemainException;
+import org.junit.runners.ParentRunner;
+import org.junit.runners.model.RunnerScheduler;
 
 /**
  * @since 4.12
@@ -161,6 +170,47 @@ public class RunnerTestDescriptor extends VintageTestDescriptor {
 		return ignored;
 	}
 
+	public void setExecutorService(ExecutorService executorService) {
+		Runner runner = getRunnerToReport();
+		if (runner instanceof ParentRunner) {
+			((ParentRunner<?>) runner).setScheduler(new RunnerScheduler() {
+
+				private final List<Future<?>> futures = new CopyOnWriteArrayList<>();
+
+				@Override
+				public void schedule(Runnable childStatement) {
+					futures.add(executorService.submit(childStatement));
+				}
+
+				@Override
+				public void finished() {
+					ThrowableCollector collector = new OpenTest4JAwareThrowableCollector();
+					AtomicBoolean wasInterrupted = new AtomicBoolean(false);
+					for (Future<?> future : futures) {
+						collector.execute(() -> {
+							// We're calling `Future.get()` individually to allow for work stealing
+							// in case `ExecutorService` is a `ForkJoinPool`
+							try {
+								future.get();
+							}
+							catch (ExecutionException e) {
+								throw e.getCause();
+							}
+							catch (InterruptedException e) {
+								wasInterrupted.set(true);
+							}
+						});
+					}
+					collector.assertEmpty();
+					if (wasInterrupted.get()) {
+						logger.warn(() -> "Interrupted while waiting for runner to finish");
+						Thread.currentThread().interrupt();
+					}
+				}
+			});
+		}
+	}
+
 	private static class ExcludeDescriptionFilter extends Filter {
 
 		private final Description description;
diff --git a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/execution/VintageExecutor.java b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/execution/VintageExecutor.java
new file mode 100644
index 000000000..f20446863
--- /dev/null
+++ b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/execution/VintageExecutor.java
@@ -0,0 +1,189 @@
+/*
+ * Copyright 2015-2025 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.vintage.engine.execution;
+
+import static java.util.stream.Collectors.toList;
+import static org.apiguardian.api.API.Status.INTERNAL;
+import static org.junit.vintage.engine.Constants.PARALLEL_CLASS_EXECUTION;
+import static org.junit.vintage.engine.Constants.PARALLEL_EXECUTION_ENABLED;
+import static org.junit.vintage.engine.Constants.PARALLEL_METHOD_EXECUTION;
+import static org.junit.vintage.engine.Constants.PARALLEL_POOL_SIZE;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Optional;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+
+import org.apiguardian.api.API;
+import org.junit.platform.commons.logging.Logger;
+import org.junit.platform.commons.logging.LoggerFactory;
+import org.junit.platform.commons.util.ExceptionUtils;
+import org.junit.platform.engine.EngineExecutionListener;
+import org.junit.platform.engine.ExecutionRequest;
+import org.junit.platform.engine.TestDescriptor;
+import org.junit.vintage.engine.descriptor.RunnerTestDescriptor;
+import org.junit.vintage.engine.descriptor.VintageEngineDescriptor;
+
+/**
+ * @since 5.12
+ */
+@API(status = INTERNAL, since = "5.12")
+public class VintageExecutor {
+
+	private static final Logger logger = LoggerFactory.getLogger(VintageExecutor.class);
+
+	private static final int DEFAULT_THREAD_POOL_SIZE = Runtime.getRuntime().availableProcessors();
+	private static final int SHUTDOWN_TIMEOUT_SECONDS = 30;
+
+	private final VintageEngineDescriptor engineDescriptor;
+	private final EngineExecutionListener engineExecutionListener;
+	private final ExecutionRequest request;
+
+	private final boolean parallelExecutionEnabled;
+	private final boolean classes;
+	private final boolean methods;
+
+	public VintageExecutor(VintageEngineDescriptor engineDescriptor, EngineExecutionListener engineExecutionListener,
+			ExecutionRequest request) {
+		this.engineDescriptor = engineDescriptor;
+		this.engineExecutionListener = engineExecutionListener;
+		this.request = request;
+		this.parallelExecutionEnabled = request.getConfigurationParameters().getBoolean(
+			PARALLEL_EXECUTION_ENABLED).orElse(false);
+		this.classes = request.getConfigurationParameters().getBoolean(PARALLEL_CLASS_EXECUTION).orElse(false);
+		this.methods = request.getConfigurationParameters().getBoolean(PARALLEL_METHOD_EXECUTION).orElse(false);
+	}
+
+	public void executeAllChildren() {
+
+		if (!parallelExecutionEnabled) {
+			executeClassesAndMethodsSequentially();
+			return;
+		}
+
+		if (!classes && !methods) {
+			logger.warn(() -> "Parallel execution is enabled but no scope is defined. "
+					+ "Falling back to sequential execution.");
+			executeClassesAndMethodsSequentially();
+			return;
+		}
+
+		boolean wasInterrupted = executeInParallel();
+		if (wasInterrupted) {
+			Thread.currentThread().interrupt();
+		}
+	}
+
+	private void executeClassesAndMethodsSequentially() {
+		RunnerExecutor runnerExecutor = new RunnerExecutor(engineExecutionListener);
+		for (Iterator<TestDescriptor> iterator = engineDescriptor.getModifiableChildren().iterator(); iterator.hasNext();) {
+			runnerExecutor.execute((RunnerTestDescriptor) iterator.next());
+			iterator.remove();
+		}
+	}
+
+	private boolean executeInParallel() {
+		ExecutorService executorService = Executors.newWorkStealingPool(getThreadPoolSize());
+		RunnerExecutor runnerExecutor = new RunnerExecutor(engineExecutionListener);
+
+		List<RunnerTestDescriptor> runnerTestDescriptors = collectRunnerTestDescriptors(executorService);
+
+		if (!classes) {
+			executeClassesSequentially(runnerTestDescriptors, runnerExecutor);
+			return false;
+		}
+
+		return executeClassesInParallel(runnerTestDescriptors, runnerExecutor, executorService);
+	}
+
+	private int getThreadPoolSize() {
+		Optional<String> optionalPoolSize = request.getConfigurationParameters().get(PARALLEL_POOL_SIZE);
+		if (optionalPoolSize.isPresent()) {
+			try {
+				int poolSize = Integer.parseInt(optionalPoolSize.get());
+				if (poolSize > 0) {
+					return poolSize;
+				}
+				logger.warn(() -> "Invalid value for parallel pool size: " + poolSize);
+			}
+			catch (NumberFormatException e) {
+				logger.warn(() -> "Invalid value for parallel pool size: " + optionalPoolSize.get());
+			}
+		}
+		return DEFAULT_THREAD_POOL_SIZE;
+	}
+
+	private List<RunnerTestDescriptor> collectRunnerTestDescriptors(ExecutorService executorService) {
+		return engineDescriptor.getModifiableChildren().stream() //
+				.map(RunnerTestDescriptor.class::cast) //
+				.map(it -> methods ? parallelMethodExecutor(it, executorService) : it) //
+				.collect(toList());
+	}
+
+	private RunnerTestDescriptor parallelMethodExecutor(RunnerTestDescriptor runnerTestDescriptor,
+			ExecutorService executorService) {
+		runnerTestDescriptor.setExecutorService(executorService);
+		return runnerTestDescriptor;
+	}
+
+	private void executeClassesSequentially(List<RunnerTestDescriptor> runnerTestDescriptors,
+			RunnerExecutor runnerExecutor) {
+		for (RunnerTestDescriptor runnerTestDescriptor : runnerTestDescriptors) {
+			runnerExecutor.execute(runnerTestDescriptor);
+		}
+	}
+
+	private boolean executeClassesInParallel(List<RunnerTestDescriptor> runnerTestDescriptors,
+			RunnerExecutor runnerExecutor, ExecutorService executorService) {
+		List<CompletableFuture<Void>> futures = new ArrayList<>();
+		for (RunnerTestDescriptor runnerTestDescriptor : runnerTestDescriptors) {
+			CompletableFuture<Void> future = CompletableFuture.runAsync(
+				() -> runnerExecutor.execute(runnerTestDescriptor), executorService);
+			futures.add(future);
+		}
+
+		CompletableFuture<Void> allOf = CompletableFuture.allOf(futures.toArray(new CompletableFuture<?>[0]));
+		boolean wasInterrupted = false;
+		try {
+			allOf.get();
+		}
+		catch (InterruptedException e) {
+			logger.warn(e, () -> "Interruption while waiting for parallel test execution to finish");
+			wasInterrupted = true;
+		}
+		catch (ExecutionException e) {
+			throw ExceptionUtils.throwAsUncheckedException(e.getCause());
+		}
+		finally {
+			shutdownExecutorService(executorService);
+		}
+		return wasInterrupted;
+	}
+
+	private void shutdownExecutorService(ExecutorService executorService) {
+		try {
+			executorService.shutdown();
+			if (!executorService.awaitTermination(SHUTDOWN_TIMEOUT_SECONDS, TimeUnit.SECONDS)) {
+				logger.warn(() -> "Executor service did not terminate within the specified timeout");
+				executorService.shutdownNow();
+			}
+		}
+		catch (InterruptedException e) {
+			logger.warn(e, () -> "Interruption while waiting for executor service to shut down");
+			Thread.currentThread().interrupt();
+		}
+	}
+}
diff --git a/junit-vintage-engine/src/test/java/org/junit/vintage/engine/execution/ParallelExecutionIntegrationTests.java b/junit-vintage-engine/src/test/java/org/junit/vintage/engine/execution/ParallelExecutionIntegrationTests.java
index 9f535007a..41b96da2c 100644
--- a/junit-vintage-engine/src/test/java/org/junit/vintage/engine/execution/ParallelExecutionIntegrationTests.java
+++ b/junit-vintage-engine/src/test/java/org/junit/vintage/engine/execution/ParallelExecutionIntegrationTests.java
@@ -11,26 +11,38 @@
 package org.junit.vintage.engine.execution;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.jupiter.api.Assertions.assertTrue;
 import static org.junit.platform.testkit.engine.EventConditions.container;
 import static org.junit.platform.testkit.engine.EventConditions.event;
 import static org.junit.platform.testkit.engine.EventConditions.finishedSuccessfully;
 import static org.junit.platform.testkit.engine.EventConditions.started;
+import static org.junit.platform.testkit.engine.EventConditions.test;
+import static org.junit.vintage.engine.Constants.PARALLEL_CLASS_EXECUTION;
 import static org.junit.vintage.engine.Constants.PARALLEL_EXECUTION_ENABLED;
+import static org.junit.vintage.engine.Constants.PARALLEL_METHOD_EXECUTION;
 import static org.junit.vintage.engine.Constants.PARALLEL_POOL_SIZE;
 import static org.junit.vintage.engine.descriptor.VintageTestDescriptor.SEGMENT_TYPE_RUNNER;
-import static org.junit.vintage.engine.samples.junit4.JUnit4ParallelTestCase.AbstractBlockingTestCase;
-import static org.junit.vintage.engine.samples.junit4.JUnit4ParallelTestCase.FirstTestCase;
-import static org.junit.vintage.engine.samples.junit4.JUnit4ParallelTestCase.ThirdTestCase;
+import static org.junit.vintage.engine.descriptor.VintageTestDescriptor.SEGMENT_TYPE_TEST;
+import static org.junit.vintage.engine.samples.junit4.JUnit4ParallelClassesTestCase.FirstClassTestCase;
+import static org.junit.vintage.engine.samples.junit4.JUnit4ParallelClassesTestCase.SecondClassTestCase;
+import static org.junit.vintage.engine.samples.junit4.JUnit4ParallelClassesTestCase.ThirdClassTestCase;
+import static org.junit.vintage.engine.samples.junit4.JUnit4ParallelMethodsTestCase.FirstMethodTestCase;
+import static org.junit.vintage.engine.samples.junit4.JUnit4ParallelMethodsTestCase.SecondMethodTestCase;
+import static org.junit.vintage.engine.samples.junit4.JUnit4ParallelMethodsTestCase.ThirdMethodTestCase;
 
 import java.time.Instant;
 import java.util.Arrays;
 import java.util.HashSet;
 import java.util.List;
 import java.util.concurrent.CountDownLatch;
+import java.util.logging.Level;
+import java.util.logging.LogRecord;
 
 import org.assertj.core.api.Condition;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.TestReporter;
+import org.junit.jupiter.api.fixtures.TrackLogRecords;
+import org.junit.platform.commons.logging.LogRecordListener;
 import org.junit.platform.engine.discovery.ClassSelector;
 import org.junit.platform.engine.discovery.DiscoverySelectors;
 import org.junit.platform.launcher.LauncherDiscoveryRequest;
@@ -40,22 +52,23 @@ import org.junit.platform.testkit.engine.EngineTestKit;
 import org.junit.platform.testkit.engine.Event;
 import org.junit.platform.testkit.engine.Events;
 import org.junit.vintage.engine.VintageTestEngine;
-import org.junit.vintage.engine.samples.junit4.JUnit4ParallelTestCase.SecondTestCase;
+import org.junit.vintage.engine.samples.junit4.JUnit4ParallelClassesTestCase;
+import org.junit.vintage.engine.samples.junit4.JUnit4ParallelMethodsTestCase;
 
 class ParallelExecutionIntegrationTests {
 
 	@Test
 	void executesTestClassesInParallel(TestReporter reporter) {
-		AbstractBlockingTestCase.threadNames.clear();
-		AbstractBlockingTestCase.countDownLatch = new CountDownLatch(3);
+		JUnit4ParallelClassesTestCase.AbstractBlockingTestCase.threadNames.clear();
+		JUnit4ParallelClassesTestCase.AbstractBlockingTestCase.countDownLatch = new CountDownLatch(3);
 
-		var events = executeInParallelSuccessfully(3, FirstTestCase.class, SecondTestCase.class,
-			ThirdTestCase.class).list();
+		var events = executeInParallelSuccessfully(3, true, false, FirstClassTestCase.class, SecondClassTestCase.class,
+			ThirdClassTestCase.class).list();
 
 		var startedTimestamps = getTimestampsFor(events, event(container(SEGMENT_TYPE_RUNNER), started()));
 		var finishedTimestamps = getTimestampsFor(events,
 			event(container(SEGMENT_TYPE_RUNNER), finishedSuccessfully()));
-		var threadNames = new HashSet<>(AbstractBlockingTestCase.threadNames);
+		var threadNames = new HashSet<>(JUnit4ParallelClassesTestCase.AbstractBlockingTestCase.threadNames);
 
 		reporter.publishEntry("startedTimestamps", startedTimestamps.toString());
 		reporter.publishEntry("finishedTimestamps", finishedTimestamps.toString());
@@ -67,6 +80,85 @@ class ParallelExecutionIntegrationTests {
 		assertThat(threadNames).hasSize(3);
 	}
 
+	@Test
+	void executesTestMethodsInParallel(TestReporter reporter) {
+		JUnit4ParallelMethodsTestCase.AbstractBlockingTestCase.threadNames.clear();
+		JUnit4ParallelMethodsTestCase.AbstractBlockingTestCase.countDownLatch = new CountDownLatch(3);
+
+		var events = executeInParallelSuccessfully(3, false, true, FirstMethodTestCase.class).list();
+
+		var startedTimestamps = getTimestampsFor(events, event(test(SEGMENT_TYPE_TEST), started()));
+		var finishedTimestamps = getTimestampsFor(events, event(test(SEGMENT_TYPE_TEST), finishedSuccessfully()));
+		var threadNames = new HashSet<>(JUnit4ParallelMethodsTestCase.AbstractBlockingTestCase.threadNames);
+
+		reporter.publishEntry("startedTimestamps", startedTimestamps.toString());
+		reporter.publishEntry("finishedTimestamps", finishedTimestamps.toString());
+
+		assertThat(startedTimestamps).hasSize(3);
+		assertThat(finishedTimestamps).hasSize(3);
+		assertThat(startedTimestamps).allMatch(startTimestamp -> finishedTimestamps.stream().noneMatch(
+			finishedTimestamp -> finishedTimestamp.isBefore(startTimestamp)));
+		assertThat(threadNames).hasSize(3);
+	}
+
+	@Test
+	void executesTestClassesAndMethodsInParallel(TestReporter reporter) {
+		JUnit4ParallelMethodsTestCase.AbstractBlockingTestCase.threadNames.clear();
+		JUnit4ParallelMethodsTestCase.AbstractBlockingTestCase.countDownLatch = new CountDownLatch(9);
+
+		var events = executeInParallelSuccessfully(3, true, true, FirstMethodTestCase.class, SecondMethodTestCase.class,
+			ThirdMethodTestCase.class).list();
+
+		var startedClassesTimestamps = getTimestampsFor(events, event(container(SEGMENT_TYPE_RUNNER), started()));
+		var finishedClassesTimestamps = getTimestampsFor(events,
+			event(container(SEGMENT_TYPE_RUNNER), finishedSuccessfully()));
+		var startedMethodsTimestamps = getTimestampsFor(events, event(test(SEGMENT_TYPE_TEST), started()));
+		var finishedMethodsTimestamps = getTimestampsFor(events,
+			event(test(SEGMENT_TYPE_TEST), finishedSuccessfully()));
+
+		var threadNames = new HashSet<>(JUnit4ParallelMethodsTestCase.AbstractBlockingTestCase.threadNames);
+
+		reporter.publishEntry("startedClassesTimestamps", startedClassesTimestamps.toString());
+		reporter.publishEntry("finishedClassesTimestamps", finishedClassesTimestamps.toString());
+		reporter.publishEntry("startedMethodsTimestamps", startedMethodsTimestamps.toString());
+		reporter.publishEntry("finishedMethodsTimestamps", finishedMethodsTimestamps.toString());
+
+		assertThat(startedClassesTimestamps).hasSize(3);
+		assertThat(finishedClassesTimestamps).hasSize(3);
+		assertThat(startedMethodsTimestamps).hasSize(9);
+		assertThat(finishedMethodsTimestamps).hasSize(9);
+
+		assertThat(threadNames).hasSize(3);
+	}
+
+	@Test
+	void executesInParallelWhenNoScopeIsDefined(@TrackLogRecords LogRecordListener listener) {
+		JUnit4ParallelMethodsTestCase.AbstractBlockingTestCase.threadNames.clear();
+		JUnit4ParallelMethodsTestCase.AbstractBlockingTestCase.countDownLatch = new CountDownLatch(9);
+		execute(3, false, false, FirstMethodTestCase.class, SecondMethodTestCase.class, ThirdMethodTestCase.class);
+
+		// @formatter:off
+		assertTrue(listener.stream(Level.WARNING)
+				.map(LogRecord::getMessage)
+				.anyMatch(m -> m.startsWith(
+					"Parallel execution is enabled but no scope is defined. Falling back to sequential execution.")));
+		// @formatter:on
+
+		var threadNames = new HashSet<>(JUnit4ParallelMethodsTestCase.AbstractBlockingTestCase.threadNames);
+		assertThat(threadNames).hasSize(1);
+	}
+
+	@Test
+	void executesInParallelWhenInvalidPoolSizeIsDefined(@TrackLogRecords LogRecordListener listener) {
+		execute(-1, true, true, FirstMethodTestCase.class, SecondMethodTestCase.class, ThirdMethodTestCase.class);
+
+		// @formatter:off
+		assertTrue(listener.stream(Level.WARNING)
+				.map(LogRecord::getMessage)
+				.anyMatch(m -> m.startsWith("Invalid value for parallel pool size: -1")));
+		// @formatter:on
+	}
+
 	private List<Instant> getTimestampsFor(List<Event> events, Condition<Event> condition) {
 		// @formatter:off
 		return events.stream()
@@ -76,8 +168,9 @@ class ParallelExecutionIntegrationTests {
 		// @formatter:on
 	}
 
-	private Events executeInParallelSuccessfully(int poolSize, Class<?>... testClasses) {
-		var events = execute(poolSize, testClasses).allEvents();
+	private Events executeInParallelSuccessfully(int poolSize, boolean parallelClasses, boolean parallelMethods,
+			Class<?>... testClasses) {
+		var events = execute(poolSize, parallelClasses, parallelMethods, testClasses).allEvents();
 		try {
 			return events.assertStatistics(it -> it.failed(0));
 		}
@@ -87,11 +180,14 @@ class ParallelExecutionIntegrationTests {
 		}
 	}
 
-	private static EngineExecutionResults execute(int poolSize, Class<?>... testClass) {
-		return EngineTestKit.execute(new VintageTestEngine(), request(poolSize, testClass));
+	private static EngineExecutionResults execute(int poolSize, boolean parallelClasses, boolean parallelMethods,
+			Class<?>... testClass) {
+		return EngineTestKit.execute(new VintageTestEngine(),
+			request(poolSize, parallelClasses, parallelMethods, testClass));
 	}
 
-	private static LauncherDiscoveryRequest request(int poolSize, Class<?>... testClasses) {
+	private static LauncherDiscoveryRequest request(int poolSize, boolean parallelClasses, boolean parallelMethods,
+			Class<?>... testClasses) {
 		var classSelectors = Arrays.stream(testClasses) //
 				.map(DiscoverySelectors::selectClass) //
 				.toArray(ClassSelector[]::new);
@@ -100,6 +196,8 @@ class ParallelExecutionIntegrationTests {
 				.selectors(classSelectors) //
 				.configurationParameter(PARALLEL_EXECUTION_ENABLED, String.valueOf(true)) //
 				.configurationParameter(PARALLEL_POOL_SIZE, String.valueOf(poolSize)) //
+				.configurationParameter(PARALLEL_CLASS_EXECUTION, String.valueOf(parallelClasses)) //
+				.configurationParameter(PARALLEL_METHOD_EXECUTION, String.valueOf(parallelMethods)) //
 				.build();
 	}
 
diff --git a/junit-vintage-engine/src/testFixtures/java/org/junit/vintage/engine/samples/junit4/JUnit4ParallelTestCase.java b/junit-vintage-engine/src/testFixtures/java/org/junit/vintage/engine/samples/junit4/JUnit4ParallelClassesTestCase.java
similarity index 86%
rename from junit-vintage-engine/src/testFixtures/java/org/junit/vintage/engine/samples/junit4/JUnit4ParallelTestCase.java
rename to junit-vintage-engine/src/testFixtures/java/org/junit/vintage/engine/samples/junit4/JUnit4ParallelClassesTestCase.java
index 4e8e0c62c..d84a6fe34 100644
--- a/junit-vintage-engine/src/testFixtures/java/org/junit/vintage/engine/samples/junit4/JUnit4ParallelTestCase.java
+++ b/junit-vintage-engine/src/testFixtures/java/org/junit/vintage/engine/samples/junit4/JUnit4ParallelClassesTestCase.java
@@ -24,7 +24,7 @@ import org.junit.runner.Description;
 import org.junit.runner.RunWith;
 
 @RunWith(Enclosed.class)
-public class JUnit4ParallelTestCase {
+public class JUnit4ParallelClassesTestCase {
 
 	public static class AbstractBlockingTestCase {
 
@@ -56,12 +56,12 @@ public class JUnit4ParallelTestCase {
 		}
 	}
 
-	public static class FirstTestCase extends AbstractBlockingTestCase {
+	public static class FirstClassTestCase extends AbstractBlockingTestCase {
 	}
 
-	public static class SecondTestCase extends AbstractBlockingTestCase {
+	public static class SecondClassTestCase extends AbstractBlockingTestCase {
 	}
 
-	public static class ThirdTestCase extends AbstractBlockingTestCase {
+	public static class ThirdClassTestCase extends AbstractBlockingTestCase {
 	}
 }
diff --git a/junit-vintage-engine/src/testFixtures/java/org/junit/vintage/engine/samples/junit4/JUnit4ParallelMethodsTestCase.java b/junit-vintage-engine/src/testFixtures/java/org/junit/vintage/engine/samples/junit4/JUnit4ParallelMethodsTestCase.java
new file mode 100644
index 000000000..b9e553d82
--- /dev/null
+++ b/junit-vintage-engine/src/testFixtures/java/org/junit/vintage/engine/samples/junit4/JUnit4ParallelMethodsTestCase.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright 2015-2025 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.vintage.engine.samples.junit4;
+
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.CountDownLatch;
+
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.experimental.runners.Enclosed;
+import org.junit.rules.TestWatcher;
+import org.junit.runner.Description;
+import org.junit.runner.RunWith;
+
+@RunWith(Enclosed.class)
+public class JUnit4ParallelMethodsTestCase {
+
+	public static class AbstractBlockingTestCase {
+
+		public static final Set<String> threadNames = ConcurrentHashMap.newKeySet();
+		public static CountDownLatch countDownLatch;
+
+		@Rule
+		public final TestWatcher testWatcher = new TestWatcher() {
+			@Override
+			protected void starting(Description description) {
+				AbstractBlockingTestCase.threadNames.add(Thread.currentThread().getName());
+			}
+		};
+
+		@Test
+		public void fistTest() throws Exception {
+			countDownAndBlock(countDownLatch);
+		}
+
+		@Test
+		public void secondTest() throws Exception {
+			countDownAndBlock(countDownLatch);
+		}
+
+		@Test
+		public void thirdTest() throws Exception {
+			countDownAndBlock(countDownLatch);
+		}
+
+		@SuppressWarnings("ResultOfMethodCallIgnored")
+		private static void countDownAndBlock(CountDownLatch countDownLatch) throws InterruptedException {
+			countDownLatch.countDown();
+			countDownLatch.await(estimateSimulatedTestDurationInMilliseconds(), MILLISECONDS);
+		}
+
+		private static long estimateSimulatedTestDurationInMilliseconds() {
+			var runningInCi = Boolean.parseBoolean(System.getenv("CI"));
+			return runningInCi ? 1000 : 100;
+		}
+	}
+
+	public static class FirstMethodTestCase extends JUnit4ParallelMethodsTestCase.AbstractBlockingTestCase {
+	}
+
+	public static class SecondMethodTestCase extends JUnit4ParallelMethodsTestCase.AbstractBlockingTestCase {
+	}
+
+	public static class ThirdMethodTestCase extends JUnit4ParallelMethodsTestCase.AbstractBlockingTestCase {
+	}
+}
