diff --git a/documentation/src/docs/asciidoc/link-attributes.adoc b/documentation/src/docs/asciidoc/link-attributes.adoc
index 03c75a7b3..a994609b3 100644
--- a/documentation/src/docs/asciidoc/link-attributes.adoc
+++ b/documentation/src/docs/asciidoc/link-attributes.adoc
@@ -73,6 +73,7 @@ endif::[]
 :TestTemplate:                               {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/TestTemplate.html[@TestTemplate]
 // Jupiter Parallel API
 :Execution:                                  {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/parallel/Execution.html[@Execution]
+:Isolated:                                   {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/parallel/Isolated.html[@Isolated]
 :ResourceLock:                               {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/parallel/ResourceLock.html[@ResourceLock]
 :Resources:                                  {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/parallel/Resources.html[Resources]
 // Jupiter Extension APIs
diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.7.0-M2.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.7.0-M2.adoc
index 1eff93ccd..c65148727 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.7.0-M2.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.7.0-M2.adoc
@@ -61,6 +61,7 @@ on GitHub.
   classes that use `EngineExecutionListener`.
 * `ForkJoinPoolHierarchicalTestExecutorService` can now be constructed by supplying a
   `ParallelExecutionConfiguration`.
+* `HierarchicalTestEngine` now supports a global resource lock.
 
 
 [[release-notes-5.7.0-M2-junit-jupiter]]
@@ -121,6 +122,8 @@ on GitHub.
   reducing boilerplate type checks compared to implementing `ArgumentConverter` directly.
 * New `ExtensionContext.getConfigurationParameter(String, Function<String, T>)`
   convenience method for reading transformed configuration parameters from extensions.
+* New `@Isolated` annotation allows to run test classes in isolation of other test classes
+  when using parallel test execution.
 
 
 [[release-notes-5.7.0-M2-junit-vintage]]
diff --git a/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc b/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
index d241da866..ab1f92e8c 100644
--- a/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
+++ b/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
@@ -2023,10 +2023,19 @@ If the tests in the following example were run in parallel _without_ the use of
 would fail due to the inherent race condition of writing and then reading the same JVM
 System Property.
 
-When access to shared resources is declared using the {ResourceLock} annotation, the
+When access to shared resources is declared using the `{ResourceLock}` annotation, the
 JUnit Jupiter engine uses this information to ensure that no conflicting tests are run in
 parallel.
 
+[NOTE]
+.Running tests in isolation
+====
+If most of your test classes can be run in parallel without any synchronization but you
+have a some test classes that need to run in isolation, you can mark the latter with the
+`{Isolated}` annotation. Tests in such classes are executed sequentially without any other
+tests running at the same time.
+====
+
 In addition to the `String` that uniquely identifies the shared resource, you may specify
 an access mode. Two tests that require `READ` access to a shared resource may run in
 parallel with each other but not while any other test that requires `READ_WRITE` access
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/parallel/Execution.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/parallel/Execution.java
index d239debd7..ba98fa9b4 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/parallel/Execution.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/parallel/Execution.java
@@ -27,6 +27,7 @@ import org.apiguardian.api.API;
  * <p>Since JUnit Jupiter 5.4, this annotation is {@linkplain Inherited inherited}
  * within class hierarchies.
  *
+ * @see Isolated
  * @see ResourceLock
  * @since 5.3
  */
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/parallel/Isolated.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/parallel/Isolated.java
new file mode 100644
index 000000000..2ee7d318f
--- /dev/null
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/parallel/Isolated.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2015-2020 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.api.parallel;
+
+import static org.apiguardian.api.API.Status.EXPERIMENTAL;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Inherited;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+import org.apiguardian.api.API;
+
+/**
+ * {@code @Isolated} is used to declare that the annotated test class should be
+ * executed in isolation from other test classes.
+ *
+ * <p>When a test class is run in isolation, no other test class is executed
+ * concurrently. This can be used to enable parallel test execution for the
+ * entire test suite while running some tests in isolation (e.g. if they modify
+ * some global resource).
+ *
+ * @since 5.7
+ * @see ExecutionMode
+ * @see ResourceLock
+ */
+@API(status = EXPERIMENTAL, since = "5.7")
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.TYPE)
+@Inherited
+@ResourceLock("org.junit.platform.engine.support.hierarchical.ExclusiveResource.GLOBAL_KEY")
+public @interface Isolated {
+}
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/parallel/ResourceLock.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/parallel/ResourceLock.java
index 2356492a5..c07b32f00 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/parallel/ResourceLock.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/parallel/ResourceLock.java
@@ -40,6 +40,7 @@ import org.apiguardian.api.API;
  * <p>Since JUnit Jupiter 5.4, this annotation is {@linkplain Inherited inherited}
  * within class hierarchies.
  *
+ * @see Isolated
  * @see Resources
  * @see ResourceAccessMode
  * @see ResourceLocks
diff --git a/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/ExclusiveResource.java b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/ExclusiveResource.java
index 80d4419e8..72f54c396 100644
--- a/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/ExclusiveResource.java
+++ b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/ExclusiveResource.java
@@ -18,6 +18,7 @@ import java.util.concurrent.locks.ReadWriteLock;
 import org.apiguardian.api.API;
 import org.junit.platform.commons.util.Preconditions;
 import org.junit.platform.commons.util.ToStringBuilder;
+import org.junit.platform.engine.support.hierarchical.Node.ExecutionMode;
 
 /**
  * An exclusive resource identified by a key with a lock mode that is used to
@@ -29,6 +30,25 @@ import org.junit.platform.commons.util.ToStringBuilder;
 @API(status = EXPERIMENTAL, since = "1.3")
 public class ExclusiveResource {
 
+	/**
+	 * Key of the global resource lock that all direct children of the engine
+	 * descriptor acquire in {@linkplain LockMode#READ read mode} by default.
+	 *
+	 * <p>If any node {@linkplain Node#getExclusiveResources() requires} an
+	 * exclusive resource with the same key in
+	 * {@linkplain LockMode#READ_WRITE read-write mode}, the lock will be
+	 * coarsened to be acquired by the node's ancestor that is a direct child of
+	 * the engine descriptor and all of the ancestor's descendants will be
+	 * forced to run in the {@linkplain ExecutionMode#SAME_THREAD same thread}.
+	 *
+	 * @since 1.7
+	 */
+	@API(status = EXPERIMENTAL, since = "1.7")
+	public static final String GLOBAL_KEY = "org.junit.platform.engine.support.hierarchical.ExclusiveResource.GLOBAL_KEY";
+
+	static final ExclusiveResource GLOBAL_READ = new ExclusiveResource(GLOBAL_KEY, LockMode.READ);
+	static final ExclusiveResource GLOBAL_READ_WRITE = new ExclusiveResource(GLOBAL_KEY, LockMode.READ_WRITE);
+
 	private final String key;
 	private final LockMode lockMode;
 	private int hash;
diff --git a/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/LockManager.java b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/LockManager.java
index e9a8939a6..e2c79d8cd 100644
--- a/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/LockManager.java
+++ b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/LockManager.java
@@ -11,8 +11,11 @@
 package org.junit.platform.engine.support.hierarchical;
 
 import static java.util.Comparator.comparing;
+import static java.util.Comparator.naturalOrder;
 import static java.util.stream.Collectors.groupingBy;
 import static java.util.stream.Collectors.toList;
+import static org.junit.platform.commons.util.CollectionUtils.getOnlyElement;
+import static org.junit.platform.engine.support.hierarchical.ExclusiveResource.GLOBAL_KEY;
 import static org.junit.platform.engine.support.hierarchical.ExclusiveResource.LockMode.READ;
 
 import java.util.Collection;
@@ -30,16 +33,28 @@ import java.util.concurrent.locks.ReentrantReadWriteLock;
  */
 class LockManager {
 
-	private static final Comparator<ExclusiveResource> COMPARATOR = comparing(ExclusiveResource::getKey).thenComparing(
-		ExclusiveResource::getLockMode);
+	private static final Comparator<ExclusiveResource> COMPARATOR //
+		= comparing(ExclusiveResource::getKey, globalKeyFirst().thenComparing(naturalOrder())) //
+				.thenComparing(ExclusiveResource::getLockMode);
+
+	private static Comparator<String> globalKeyFirst() {
+		return comparing(key -> !GLOBAL_KEY.equals(key));
+	}
 
 	private final Map<String, ReadWriteLock> locksByKey = new ConcurrentHashMap<>();
 
 	ResourceLock getLockForResources(Collection<ExclusiveResource> resources) {
+		if (resources.size() == 1) {
+			return getLockForResource(getOnlyElement(resources));
+		}
 		List<Lock> locks = getDistinctSortedLocks(resources);
 		return toResourceLock(locks);
 	}
 
+	ResourceLock getLockForResource(ExclusiveResource resource) {
+		return new SingleLock(toLock(resource));
+	}
+
 	private List<Lock> getDistinctSortedLocks(Collection<ExclusiveResource> resources) {
 		// @formatter:off
 		Map<String, List<ExclusiveResource>> resourcesByKey = resources.stream()
@@ -49,24 +64,25 @@ class LockManager {
 
 		return resourcesByKey.values().stream()
 				.map(resourcesWithSameKey -> resourcesWithSameKey.get(0))
-				.map(resource -> {
-					ReadWriteLock lock = this.locksByKey.computeIfAbsent(resource.getKey(),
-							key -> new ReentrantReadWriteLock());
-					return resource.getLockMode() == READ ? lock.readLock() : lock.writeLock();
-				})
+				.map(this::toLock)
 				.collect(toList());
 		// @formatter:on
 	}
 
+	private Lock toLock(ExclusiveResource resource) {
+		ReadWriteLock lock = this.locksByKey.computeIfAbsent(resource.getKey(), key -> new ReentrantReadWriteLock());
+		return resource.getLockMode() == READ ? lock.readLock() : lock.writeLock();
+	}
+
 	private ResourceLock toResourceLock(List<Lock> locks) {
-		int size = locks.size();
-		if (size == 0) {
-			return NopLock.INSTANCE;
-		}
-		if (size == 1) {
-			return new SingleLock(locks.get(0));
+		switch (locks.size()) {
+			case 0:
+				return NopLock.INSTANCE;
+			case 1:
+				return new SingleLock(locks.get(0));
+			default:
+				return new CompositeLock(locks);
 		}
-		return new CompositeLock(locks);
 	}
 
 }
diff --git a/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/NodeTreeWalker.java b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/NodeTreeWalker.java
index 3135de2d9..3d09201c1 100644
--- a/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/NodeTreeWalker.java
+++ b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/NodeTreeWalker.java
@@ -10,12 +10,15 @@
 
 package org.junit.platform.engine.support.hierarchical;
 
+import static org.junit.platform.engine.support.hierarchical.ExclusiveResource.GLOBAL_READ;
+import static org.junit.platform.engine.support.hierarchical.ExclusiveResource.GLOBAL_READ_WRITE;
 import static org.junit.platform.engine.support.hierarchical.Node.ExecutionMode.SAME_THREAD;
 
 import java.util.HashSet;
 import java.util.Set;
 import java.util.function.Consumer;
 
+import org.junit.platform.commons.util.Preconditions;
 import org.junit.platform.engine.TestDescriptor;
 
 /**
@@ -23,18 +26,34 @@ import org.junit.platform.engine.TestDescriptor;
  */
 class NodeTreeWalker {
 
-	private final LockManager lockManager = new LockManager();
+	private final LockManager lockManager;
+	private final ResourceLock globalReadLock;
+	private final ResourceLock globalReadWriteLock;
 
-	NodeExecutionAdvisor walk(TestDescriptor testDescriptor) {
+	NodeTreeWalker() {
+		this(new LockManager());
+	}
+
+	NodeTreeWalker(LockManager lockManager) {
+		this.lockManager = lockManager;
+		this.globalReadLock = lockManager.getLockForResource(GLOBAL_READ);
+		this.globalReadWriteLock = lockManager.getLockForResource(GLOBAL_READ_WRITE);
+	}
+
+	NodeExecutionAdvisor walk(TestDescriptor rootDescriptor) {
+		Preconditions.condition(getExclusiveResources(rootDescriptor).isEmpty(),
+			"Engine descriptor must not declare exclusive resources");
 		NodeExecutionAdvisor advisor = new NodeExecutionAdvisor();
-		walk(testDescriptor, advisor);
+		rootDescriptor.getChildren().forEach(child -> walk(child, child, advisor));
 		return advisor;
 	}
 
-	private void walk(TestDescriptor testDescriptor, NodeExecutionAdvisor advisor) {
+	private void walk(TestDescriptor globalLockDescriptor, TestDescriptor testDescriptor,
+			NodeExecutionAdvisor advisor) {
 		Set<ExclusiveResource> exclusiveResources = getExclusiveResources(testDescriptor);
 		if (exclusiveResources.isEmpty()) {
-			testDescriptor.getChildren().forEach(child -> walk(child, advisor));
+			advisor.useResourceLock(testDescriptor, globalReadLock);
+			testDescriptor.getChildren().forEach(child -> walk(globalLockDescriptor, child, advisor));
 		}
 		else {
 			Set<ExclusiveResource> allResources = new HashSet<>(exclusiveResources);
@@ -43,6 +62,12 @@ class NodeTreeWalker {
 				allResources.addAll(getExclusiveResources(child));
 				advisor.forceDescendantExecutionMode(child, SAME_THREAD);
 			});
+			if (!globalLockDescriptor.equals(testDescriptor) && allResources.contains(GLOBAL_READ_WRITE)) {
+				advisor.forceDescendantExecutionMode(globalLockDescriptor, SAME_THREAD);
+				doForChildrenRecursively(globalLockDescriptor,
+					child -> advisor.forceDescendantExecutionMode(child, SAME_THREAD));
+				advisor.useResourceLock(globalLockDescriptor, globalReadWriteLock);
+			}
 			advisor.useResourceLock(testDescriptor, lockManager.getLockForResources(allResources));
 		}
 	}
diff --git a/platform-tests/src/test/java/org/junit/platform/engine/support/hierarchical/LockManagerTests.java b/platform-tests/src/test/java/org/junit/platform/engine/support/hierarchical/LockManagerTests.java
index c89a0807b..061a3945a 100644
--- a/platform-tests/src/test/java/org/junit/platform/engine/support/hierarchical/LockManagerTests.java
+++ b/platform-tests/src/test/java/org/junit/platform/engine/support/hierarchical/LockManagerTests.java
@@ -11,11 +11,10 @@
 package org.junit.platform.engine.support.hierarchical;
 
 import static java.util.Arrays.asList;
-import static java.util.Collections.emptyList;
 import static java.util.Collections.emptySet;
 import static java.util.Collections.singleton;
-import static java.util.Collections.singletonList;
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.platform.engine.support.hierarchical.ExclusiveResource.GLOBAL_KEY;
 import static org.junit.platform.engine.support.hierarchical.ExclusiveResource.LockMode.READ;
 import static org.junit.platform.engine.support.hierarchical.ExclusiveResource.LockMode.READ_WRITE;
 
@@ -26,6 +25,9 @@ import java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock;
 import java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock;
 
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.EnumSource;
+import org.junit.platform.engine.support.hierarchical.ExclusiveResource.LockMode;
 
 /**
  * @since 1.3
@@ -93,19 +95,32 @@ class LockManagerTests {
 		assertThat(locks.get(1)).isInstanceOf(WriteLock.class);
 	}
 
+	@ParameterizedTest
+	@EnumSource
+	void globalLockComesFirst(LockMode globalLockMode) {
+		Collection<ExclusiveResource> resources = asList( //
+			new ExclusiveResource("___foo", READ), //
+			new ExclusiveResource("foo", READ_WRITE), //
+			new ExclusiveResource(GLOBAL_KEY, globalLockMode), //
+			new ExclusiveResource("bar", READ_WRITE));
+
+		List<Lock> locks = getLocks(resources, CompositeLock.class);
+
+		assertThat(locks).hasSize(4);
+		assertThat(locks.get(0)).isEqualTo(getSingleLock(GLOBAL_KEY, globalLockMode));
+		assertThat(locks.get(1)).isEqualTo(getSingleLock("___foo", READ));
+		assertThat(locks.get(2)).isEqualTo(getSingleLock("bar", READ_WRITE));
+		assertThat(locks.get(3)).isEqualTo(getSingleLock("foo", READ_WRITE));
+	}
+
+	private Lock getSingleLock(String globalResourceLockKey, LockMode read) {
+		return getLocks(singleton(new ExclusiveResource(globalResourceLockKey, read)), SingleLock.class).get(0);
+	}
+
 	private List<Lock> getLocks(Collection<ExclusiveResource> resources, Class<? extends ResourceLock> type) {
 		ResourceLock lock = lockManager.getLockForResources(resources);
 		assertThat(lock).isInstanceOf(type);
-		return getLocks(lock);
+		return ResourceLockSupport.getLocks(lock);
 	}
 
-	private List<Lock> getLocks(ResourceLock resourceLock) {
-		if (resourceLock instanceof NopLock) {
-			return emptyList();
-		}
-		if (resourceLock instanceof SingleLock) {
-			return singletonList(((SingleLock) resourceLock).getLock());
-		}
-		return ((CompositeLock) resourceLock).getLocks();
-	}
 }
diff --git a/platform-tests/src/test/java/org/junit/platform/engine/support/hierarchical/NodeTreeWalkerIntegrationTests.java b/platform-tests/src/test/java/org/junit/platform/engine/support/hierarchical/NodeTreeWalkerIntegrationTests.java
index d82c1f4c0..0b89ce795 100644
--- a/platform-tests/src/test/java/org/junit/platform/engine/support/hierarchical/NodeTreeWalkerIntegrationTests.java
+++ b/platform-tests/src/test/java/org/junit/platform/engine/support/hierarchical/NodeTreeWalkerIntegrationTests.java
@@ -10,12 +10,20 @@
 
 package org.junit.platform.engine.support.hierarchical;
 
+import static java.util.Collections.emptyList;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.platform.commons.util.CollectionUtils.getOnlyElement;
 import static org.junit.platform.engine.discovery.DiscoverySelectors.selectClass;
+import static org.junit.platform.engine.support.hierarchical.ExclusiveResource.GLOBAL_READ;
+import static org.junit.platform.engine.support.hierarchical.ExclusiveResource.GLOBAL_READ_WRITE;
+import static org.junit.platform.engine.support.hierarchical.ExclusiveResource.LockMode.READ_WRITE;
+import static org.junit.platform.engine.support.hierarchical.Node.ExecutionMode.SAME_THREAD;
 import static org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder.request;
 
 import java.util.Iterator;
+import java.util.List;
+import java.util.concurrent.locks.Lock;
+import java.util.function.Function;
 
 import org.junit.jupiter.api.Nested;
 import org.junit.jupiter.api.Test;
@@ -23,7 +31,6 @@ import org.junit.jupiter.api.parallel.ResourceLock;
 import org.junit.jupiter.engine.JupiterTestEngine;
 import org.junit.platform.engine.TestDescriptor;
 import org.junit.platform.engine.UniqueId;
-import org.junit.platform.engine.support.hierarchical.Node.ExecutionMode;
 import org.junit.platform.launcher.LauncherDiscoveryRequest;
 
 /**
@@ -31,42 +38,85 @@ import org.junit.platform.launcher.LauncherDiscoveryRequest;
  */
 class NodeTreeWalkerIntegrationTests {
 
+	LockManager lockManager = new LockManager();
+	NodeTreeWalker nodeTreeWalker = new NodeTreeWalker(lockManager);
+
 	@Test
 	void pullUpExclusiveChildResourcesToTestClass() {
 		TestDescriptor engineDescriptor = discover(TestCaseWithResourceLock.class);
-		NodeExecutionAdvisor advisor = new NodeTreeWalker().walk(engineDescriptor);
+
+		NodeExecutionAdvisor advisor = nodeTreeWalker.walk(engineDescriptor);
 
 		TestDescriptor testClassDescriptor = getOnlyElement(engineDescriptor.getChildren());
-		assertThat(advisor.getResourceLock(testClassDescriptor)).isInstanceOf(CompositeLock.class);
+		assertThat(advisor.getResourceLock(testClassDescriptor)).extracting(allLocks()) //
+				.isEqualTo(List.of(getReadWriteLock("a"), getReadWriteLock("b")));
 		assertThat(advisor.getForcedExecutionMode(testClassDescriptor)).isEmpty();
 
 		TestDescriptor testMethodDescriptor = getOnlyElement(testClassDescriptor.getChildren());
-		assertThat(advisor.getResourceLock(testMethodDescriptor)).isInstanceOf(NopLock.class);
-		assertThat(advisor.getForcedExecutionMode(testMethodDescriptor)).contains(ExecutionMode.SAME_THREAD);
+		assertThat(advisor.getResourceLock(testMethodDescriptor)).extracting(allLocks()).isEqualTo(emptyList());
+		assertThat(advisor.getForcedExecutionMode(testMethodDescriptor)).contains(SAME_THREAD);
 	}
 
 	@Test
 	void leavesResourceLockOnTestMethodWhenClassDoesNotUseResource() {
 		TestDescriptor engineDescriptor = discover(TestCaseWithoutResourceLock.class);
-		NodeExecutionAdvisor advisor = new NodeTreeWalker().walk(engineDescriptor);
+
+		NodeExecutionAdvisor advisor = nodeTreeWalker.walk(engineDescriptor);
 
 		TestDescriptor testClassDescriptor = getOnlyElement(engineDescriptor.getChildren());
-		assertThat(advisor.getResourceLock(testClassDescriptor)).isInstanceOf(NopLock.class);
+		assertThat(advisor.getResourceLock(testClassDescriptor)).extracting(allLocks()) //
+				.isEqualTo(List.of(getLock(GLOBAL_READ)));
 		assertThat(advisor.getForcedExecutionMode(testClassDescriptor)).isEmpty();
 
 		assertThat(testClassDescriptor.getChildren()).hasSize(2);
 		Iterator<? extends TestDescriptor> children = testClassDescriptor.getChildren().iterator();
 		TestDescriptor testMethodDescriptor = children.next();
-		assertThat(advisor.getResourceLock(testMethodDescriptor)).isInstanceOf(SingleLock.class);
+		assertThat(advisor.getResourceLock(testMethodDescriptor)).extracting(allLocks()) //
+				.isEqualTo(List.of(getReadWriteLock("a")));
 		assertThat(advisor.getForcedExecutionMode(testMethodDescriptor)).isEmpty();
 
 		TestDescriptor nestedTestClassDescriptor = children.next();
-		assertThat(advisor.getResourceLock(nestedTestClassDescriptor)).isInstanceOf(CompositeLock.class);
+		assertThat(advisor.getResourceLock(nestedTestClassDescriptor)).extracting(allLocks()) //
+				.isEqualTo(List.of(getReadWriteLock("b"), getReadWriteLock("c")));
 		assertThat(advisor.getForcedExecutionMode(nestedTestClassDescriptor)).isEmpty();
 
 		TestDescriptor nestedTestMethodDescriptor = getOnlyElement(nestedTestClassDescriptor.getChildren());
-		assertThat(advisor.getResourceLock(nestedTestMethodDescriptor)).isInstanceOf(NopLock.class);
-		assertThat(advisor.getForcedExecutionMode(nestedTestMethodDescriptor)).contains(ExecutionMode.SAME_THREAD);
+		assertThat(advisor.getResourceLock(nestedTestMethodDescriptor)).extracting(allLocks()).isEqualTo(emptyList());
+		assertThat(advisor.getForcedExecutionMode(nestedTestMethodDescriptor)).contains(SAME_THREAD);
+	}
+
+	@Test
+	void coarsensGlobalLockToEngineDescriptorChild() {
+		TestDescriptor engineDescriptor = discover(TestCaseWithGlobalLockRequiringChild.class);
+
+		NodeExecutionAdvisor advisor = nodeTreeWalker.walk(engineDescriptor);
+
+		TestDescriptor testClassDescriptor = getOnlyElement(engineDescriptor.getChildren());
+		assertThat(advisor.getResourceLock(testClassDescriptor)).extracting(allLocks()) //
+				.isEqualTo(List.of(getLock(GLOBAL_READ_WRITE)));
+		assertThat(advisor.getForcedExecutionMode(testClassDescriptor)).isEmpty();
+
+		TestDescriptor nestedTestClassDescriptor = getOnlyElement(testClassDescriptor.getChildren());
+		assertThat(advisor.getResourceLock(nestedTestClassDescriptor)).extracting(allLocks()) //
+				.isEqualTo(List.of(getLock(GLOBAL_READ)));
+		assertThat(advisor.getForcedExecutionMode(nestedTestClassDescriptor)).contains(SAME_THREAD);
+
+		TestDescriptor testMethodDescriptor = getOnlyElement(nestedTestClassDescriptor.getChildren());
+		assertThat(advisor.getResourceLock(testMethodDescriptor)).extracting(allLocks()) //
+				.isEqualTo(List.of(getLock(GLOBAL_READ_WRITE)));
+		assertThat(advisor.getForcedExecutionMode(testMethodDescriptor)).contains(SAME_THREAD);
+	}
+
+	private static Function<org.junit.platform.engine.support.hierarchical.ResourceLock, List<Lock>> allLocks() {
+		return ResourceLockSupport::getLocks;
+	}
+
+	private Lock getReadWriteLock(String key) {
+		return getLock(new ExclusiveResource(key, READ_WRITE));
+	}
+
+	private Lock getLock(ExclusiveResource exclusiveResource) {
+		return getOnlyElement(ResourceLockSupport.getLocks(lockManager.getLockForResource(exclusiveResource)));
 	}
 
 	private TestDescriptor discover(Class<?> testClass) {
@@ -97,4 +147,14 @@ class NodeTreeWalkerIntegrationTests {
 			}
 		}
 	}
+
+	static class TestCaseWithGlobalLockRequiringChild {
+		@Nested
+		class NestedTestCaseWithResourceLock {
+			@Test
+			@ResourceLock(ExclusiveResource.GLOBAL_KEY)
+			void test() {
+			}
+		}
+	}
 }
diff --git a/platform-tests/src/test/java/org/junit/platform/engine/support/hierarchical/ParallelExecutionIntegrationTests.java b/platform-tests/src/test/java/org/junit/platform/engine/support/hierarchical/ParallelExecutionIntegrationTests.java
index b46f7a180..fb704bd33 100644
--- a/platform-tests/src/test/java/org/junit/platform/engine/support/hierarchical/ParallelExecutionIntegrationTests.java
+++ b/platform-tests/src/test/java/org/junit/platform/engine/support/hierarchical/ParallelExecutionIntegrationTests.java
@@ -62,6 +62,7 @@ import org.junit.jupiter.api.extension.AfterTestExecutionCallback;
 import org.junit.jupiter.api.extension.ExtendWith;
 import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.api.parallel.Execution;
+import org.junit.jupiter.api.parallel.Isolated;
 import org.junit.jupiter.api.parallel.ResourceLock;
 import org.junit.platform.engine.TestDescriptor;
 import org.junit.platform.engine.discovery.DiscoverySelectors;
@@ -222,6 +223,129 @@ class ParallelExecutionIntegrationTests {
 		assertThat(ThreadReporter.getThreadNames(getEventsOfChildren(results, testClassC))).hasSize(3);
 	}
 
+	@Test
+	void canRunTestsIsolatedFromEachOther() {
+		var events = executeConcurrently(2, IsolatedTestCase.class);
+
+		assertThat(events.stream().filter(event(test(), finishedWithFailure())::matches)).isEmpty();
+	}
+
+	@Test
+	void canRunTestsIsolatedFromEachOtherWithNestedCases() {
+		var events = executeConcurrently(4, NestedIsolatedTestCase.class);
+
+		assertThat(events.stream().filter(event(test(), finishedWithFailure())::matches)).isEmpty();
+	}
+
+	@Test
+	void canRunTestsIsolatedFromEachOtherAcrossClasses() {
+		var events = executeConcurrently(4, IndependentClasses.A.class, IndependentClasses.B.class);
+
+		assertThat(events.stream().filter(event(test(), finishedWithFailure())::matches)).isEmpty();
+	}
+
+	@Isolated
+	static class IsolatedTestCase {
+		static AtomicInteger sharedResource;
+		static CountDownLatch countDownLatch;
+
+		@BeforeAll
+		static void initialize() {
+			sharedResource = new AtomicInteger();
+			countDownLatch = new CountDownLatch(2);
+		}
+
+		@Test
+		void a() throws Exception {
+			incrementBlockAndCheck(sharedResource, countDownLatch);
+		}
+
+		@Test
+		void b() throws Exception {
+			storeAndBlockAndCheck(sharedResource, countDownLatch);
+		}
+	}
+
+	static class NestedIsolatedTestCase {
+		static AtomicInteger sharedResource;
+		static CountDownLatch countDownLatch;
+
+		@BeforeAll
+		static void initialize() {
+			sharedResource = new AtomicInteger();
+			countDownLatch = new CountDownLatch(6);
+		}
+
+		@Test
+		void a() throws Exception {
+			storeAndBlockAndCheck(sharedResource, countDownLatch);
+		}
+
+		@Test
+		void b() throws Exception {
+			storeAndBlockAndCheck(sharedResource, countDownLatch);
+		}
+
+		@Nested
+		class Inner {
+
+			@Test
+			void a() throws Exception {
+				storeAndBlockAndCheck(sharedResource, countDownLatch);
+			}
+
+			@Test
+			void b() throws Exception {
+				storeAndBlockAndCheck(sharedResource, countDownLatch);
+			}
+
+			@Nested
+			@Isolated
+			class InnerInner {
+
+				@Test
+				void a() throws Exception {
+					incrementBlockAndCheck(sharedResource, countDownLatch);
+				}
+
+				@Test
+				void b() throws Exception {
+					storeAndBlockAndCheck(sharedResource, countDownLatch);
+				}
+			}
+		}
+	}
+
+	static class IndependentClasses {
+		static AtomicInteger sharedResource = new AtomicInteger();
+		static CountDownLatch countDownLatch = new CountDownLatch(4);
+
+		static class A {
+			@Test
+			void a() throws Exception {
+				storeAndBlockAndCheck(sharedResource, countDownLatch);
+			}
+
+			@Test
+			void b() throws Exception {
+				storeAndBlockAndCheck(sharedResource, countDownLatch);
+			}
+		}
+
+		@Isolated
+		static class B {
+			@Test
+			void a() throws Exception {
+				incrementBlockAndCheck(sharedResource, countDownLatch);
+			}
+
+			@Test
+			void b() throws Exception {
+				storeAndBlockAndCheck(sharedResource, countDownLatch);
+			}
+		}
+	}
+
 	private List<Event> getEventsOfChildren(EngineExecutionResults results, TestDescriptor container) {
 		return results.testEvents().filter(
 			event -> event.getTestDescriptor().getParent().orElseThrow().equals(container)).collect(toList());
@@ -647,6 +771,14 @@ class ParallelExecutionIntegrationTests {
 		return value;
 	}
 
+	private static void storeAndBlockAndCheck(AtomicInteger sharedResource, CountDownLatch countDownLatch)
+			throws InterruptedException {
+		int value = sharedResource.get();
+		countDownLatch.countDown();
+		countDownLatch.await(100, MILLISECONDS);
+		assertEquals(value, sharedResource.get());
+	}
+
 	static class ThreadReporter implements AfterTestExecutionCallback {
 
 		private static Stream<String> getLoaderNames(List<Event> events) {
diff --git a/platform-tests/src/test/java/org/junit/platform/engine/support/hierarchical/ResourceLockSupport.java b/platform-tests/src/test/java/org/junit/platform/engine/support/hierarchical/ResourceLockSupport.java
new file mode 100644
index 000000000..caf8d85c8
--- /dev/null
+++ b/platform-tests/src/test/java/org/junit/platform/engine/support/hierarchical/ResourceLockSupport.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2015-2020 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.platform.engine.support.hierarchical;
+
+import java.util.List;
+import java.util.concurrent.locks.Lock;
+
+class ResourceLockSupport {
+
+	static List<Lock> getLocks(ResourceLock resourceLock) {
+		if (resourceLock instanceof NopLock) {
+			return List.of();
+		}
+		if (resourceLock instanceof SingleLock) {
+			return List.of(((SingleLock) resourceLock).getLock());
+		}
+		return ((CompositeLock) resourceLock).getLocks();
+	}
+}
