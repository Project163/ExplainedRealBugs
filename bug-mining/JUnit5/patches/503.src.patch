diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.9.0-M2.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.9.0-M2.adoc
index e15725f62..54c958842 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.9.0-M2.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.9.0-M2.adoc
@@ -18,6 +18,7 @@ on GitHub.
 * Absolute path entries are now supported in JUnit's Platform Console Launcher on Windows.
 * Attempts to load a `Class` for an invalid class name representing an extremely large
   multidimensional array now fail within a reasonable amount of time.
+* Fix concurrency issue in classpath scanning.
 
 ==== Deprecations and Breaking Changes
 
diff --git a/junit-platform-commons/src/main/java/org/junit/platform/commons/util/CloseablePath.java b/junit-platform-commons/src/main/java/org/junit/platform/commons/util/CloseablePath.java
index d3c9d457d..3ad49fe7f 100644
--- a/junit-platform-commons/src/main/java/org/junit/platform/commons/util/CloseablePath.java
+++ b/junit-platform-commons/src/main/java/org/junit/platform/commons/util/CloseablePath.java
@@ -14,12 +14,16 @@ import static java.util.Collections.emptyMap;
 
 import java.io.Closeable;
 import java.io.IOException;
+import java.io.UncheckedIOException;
 import java.net.URI;
 import java.net.URISyntaxException;
 import java.nio.file.FileSystem;
 import java.nio.file.FileSystems;
 import java.nio.file.Path;
 import java.nio.file.Paths;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.Function;
 
 /**
@@ -35,10 +39,12 @@ final class CloseablePath implements Closeable {
 	private static final Closeable NULL_CLOSEABLE = () -> {
 	};
 
+	private static final ConcurrentMap<URI, ManagedFileSystem> MANAGED_FILE_SYSTEMS = new ConcurrentHashMap<>();
+
 	private final Path path;
 	private final Closeable delegate;
 
-	static CloseablePath create(URI uri) throws IOException, URISyntaxException {
+	static CloseablePath create(URI uri) throws URISyntaxException {
 		if (JAR_URI_SCHEME.equals(uri.getScheme())) {
 			String[] parts = uri.toString().split(JAR_URI_SEPARATOR);
 			String jarUri = parts[0];
@@ -52,11 +58,12 @@ final class CloseablePath implements Closeable {
 		return new CloseablePath(Paths.get(uri), NULL_CLOSEABLE);
 	}
 
-	private static CloseablePath createForJarFileSystem(URI jarUri, Function<FileSystem, Path> pathProvider)
-			throws IOException {
-		FileSystem fileSystem = FileSystems.newFileSystem(jarUri, emptyMap());
-		Path path = pathProvider.apply(fileSystem);
-		return new CloseablePath(path, fileSystem);
+	private static CloseablePath createForJarFileSystem(URI jarUri, Function<FileSystem, Path> pathProvider) {
+		ManagedFileSystem managedFileSystem = MANAGED_FILE_SYSTEMS.compute(jarUri,
+			(__, oldValue) -> oldValue == null ? new ManagedFileSystem(jarUri) : oldValue.retain());
+		Path path = pathProvider.apply(managedFileSystem.fileSystem);
+		return new CloseablePath(path,
+			() -> MANAGED_FILE_SYSTEMS.compute(jarUri, (__, ___) -> managedFileSystem.release()));
 	}
 
 	private CloseablePath(Path path, Closeable delegate) {
@@ -72,4 +79,43 @@ final class CloseablePath implements Closeable {
 	public void close() throws IOException {
 		delegate.close();
 	}
+
+	private static class ManagedFileSystem {
+
+		private final AtomicInteger referenceCount = new AtomicInteger(1);
+		private final FileSystem fileSystem;
+		private final URI jarUri;
+
+		ManagedFileSystem(URI jarUri) {
+			this.jarUri = jarUri;
+			try {
+				fileSystem = FileSystems.newFileSystem(jarUri, emptyMap());
+			}
+			catch (IOException e) {
+				throw new UncheckedIOException("Failed to create file system for " + jarUri, e);
+			}
+		}
+
+		private ManagedFileSystem retain() {
+			referenceCount.incrementAndGet();
+			return this;
+		}
+
+		private ManagedFileSystem release() {
+			if (referenceCount.decrementAndGet() == 0) {
+				close();
+				return null;
+			}
+			return this;
+		}
+
+		private void close() {
+			try {
+				fileSystem.close();
+			}
+			catch (IOException e) {
+				throw new UncheckedIOException("Failed to close file system for " + jarUri, e);
+			}
+		}
+	}
 }
diff --git a/platform-tests/src/test/java/org/junit/platform/commons/util/ClasspathScannerTests.java b/platform-tests/src/test/java/org/junit/platform/commons/util/ClasspathScannerTests.java
index 787fee59a..e3de9a5f4 100644
--- a/platform-tests/src/test/java/org/junit/platform/commons/util/ClasspathScannerTests.java
+++ b/platform-tests/src/test/java/org/junit/platform/commons/util/ClasspathScannerTests.java
@@ -16,12 +16,15 @@ import static org.junit.jupiter.api.Assertions.assertSame;
 import static org.junit.jupiter.api.Assertions.assertThrows;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 import static org.junit.jupiter.api.Assumptions.assumeFalse;
+import static org.junit.platform.commons.test.ConcurrencyTestingUtils.executeConcurrently;
 
 import java.io.IOException;
 import java.lang.module.ModuleFinder;
 import java.net.URI;
 import java.net.URL;
 import java.net.URLClassLoader;
+import java.nio.file.FileSystemNotFoundException;
+import java.nio.file.FileSystems;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.nio.file.Paths;
@@ -223,17 +226,25 @@ class ClasspathScannerTests {
 	}
 
 	@Test
-	void findAllClassesInPackageWithinJarFile() throws Exception {
-		var jarfile = getClass().getResource("/jartest.jar");
+	void findAllClassesInPackageWithinJarFileConcurrently() throws Exception {
+		var jarFile = getClass().getResource("/jartest.jar");
+		var jarUri = URI.create("jar:" + jarFile);
 
-		try (var classLoader = new URLClassLoader(new URL[] { jarfile })) {
+		try (var classLoader = new URLClassLoader(new URL[] { jarFile })) {
 			var classpathScanner = new ClasspathScanner(() -> classLoader, ReflectionUtils::tryToLoadClass);
 
-			var classes = classpathScanner.scanForClassesInPackage("org.junit.platform.jartest.included", allClasses);
-			assertThat(classes).hasSize(2);
-			var classNames = classes.stream().map(Class::getSimpleName).collect(Collectors.toList());
-			assertTrue(classNames.contains("Included"));
-			assertTrue(classNames.contains("RecursivelyIncluded"));
+			var results = executeConcurrently(10,
+				() -> classpathScanner.scanForClassesInPackage("org.junit.platform.jartest.included", allClasses));
+
+			assertThrows(FileSystemNotFoundException.class, () -> FileSystems.getFileSystem(jarUri),
+				"FileSystem should be closed");
+
+			results.forEach(classes -> {
+				assertThat(classes).hasSize(2);
+				var classNames = classes.stream().map(Class::getSimpleName).toList();
+				assertTrue(classNames.contains("Included"));
+				assertTrue(classNames.contains("RecursivelyIncluded"));
+			});
 		}
 	}
 
