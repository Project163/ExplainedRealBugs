diff --git a/documentation/src/docs/asciidoc/link-attributes.adoc b/documentation/src/docs/asciidoc/link-attributes.adoc
index b1f9c13e4..8a45d4218 100644
--- a/documentation/src/docs/asciidoc/link-attributes.adoc
+++ b/documentation/src/docs/asciidoc/link-attributes.adoc
@@ -97,6 +97,7 @@ endif::[]
 :BeforeAllCallback:                          {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/extension/BeforeAllCallback.html[BeforeAllCallback]
 :BeforeEachCallback:                         {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/extension/BeforeEachCallback.html[BeforeEachCallback]
 :BeforeTestExecutionCallback:                {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/extension/BeforeTestExecutionCallback.html[BeforeTestExecutionCallback]
+:ExecutableInvoker:                          {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/extension/ExecutableInvoker.html[ExecutableInvoker]
 :ExecutionCondition:                         {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/extension/ExecutionCondition.html[ExecutionCondition]
 :ExtendWith:                                 {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/extension/ExtendWith.html[@ExtendWith]
 :ExtensionContext:                           {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/extension/ExtensionContext.html[ExtensionContext]
diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.9.0-M1.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.9.0-M1.adoc
index 595e077b0..6b88bd3ab 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.9.0-M1.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.9.0-M1.adoc
@@ -26,7 +26,9 @@ on GitHub.
 * `ConfigurationParameters` has now a `keySet()` method allowing to retrieve
   all configuration parameter keys.
 * New `IterationSelector` for selecting a subset of a test's or container's iterations.
-* JUnit OSGi bundles now contain `engine` and `launcher` requirements ensuring that at resolution time a fully running set of dependencies are calculated avoiding the need for these to be manually specified.
+* JUnit OSGi bundles now contain `engine` and `launcher` requirements ensuring that at
+  resolution time a fully running set of dependencies are calculated avoiding the need
+  for these to be manually specified.
 
 
 [[release-notes-5.9.0-M1-junit-jupiter]]
@@ -46,8 +48,10 @@ on GitHub.
   parameterized or dynamic tests.
 * Add support for `MATCH_NONE` mode in `EnumSource` that selects only those enum constants
   whose names match none of the supplied patterns.
-* A new extension `TestInstancePreConstructCallback` called prior to a test instance construction
-  (symmetric extension to `TestInstancePreDestroyCallback`).
+* A new extension `TestInstancePreConstructCallback` called prior to a test instance
+  construction (symmetric extension to `TestInstancePreDestroyCallback`).
+* Allow extensions to leverage registered `ParameterResolvers` for method and constructor
+  invocations, via the new `ExecutableInvoker` available in the `ExtensionContext`.
 
 
 [[release-notes-5.9.0-M1-junit-vintage]]
diff --git a/documentation/src/docs/asciidoc/user-guide/extensions.adoc b/documentation/src/docs/asciidoc/user-guide/extensions.adoc
index 4c80e2b2b..2656ce837 100644
--- a/documentation/src/docs/asciidoc/user-guide/extensions.adoc
+++ b/documentation/src/docs/asciidoc/user-guide/extensions.adoc
@@ -416,6 +416,13 @@ those provided in `java.lang.reflect.Parameter` in order to avoid this bug in th
 * `List<A> findRepeatableAnnotations(Class<A> annotationType)`
 ====
 
+[NOTE]
+====
+Other extensions can also leverage registered `ParameterResolvers` for method and
+constructor invocations, using the `{ExecutableInvoker}` available via the
+`getExecutableInvoker()` method in the `ExtensionContext`.
+====
+
 [[extensions-test-result-processing]]
 === Test Result Processing
 
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ExecutableInvoker.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ExecutableInvoker.java
new file mode 100644
index 000000000..f14d8cc1e
--- /dev/null
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ExecutableInvoker.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright 2015-2022 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.api.extension;
+
+import static org.apiguardian.api.API.Status.EXPERIMENTAL;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Method;
+
+import org.apiguardian.api.API;
+
+/**
+ * {@code ExecutableInvoker} allows invoking methods and constructors
+ * with support for dynamic resolution of parameters via
+ * {@link ParameterResolver ParameterResolvers}.
+ *
+ * @since 5.9
+ */
+@API(status = EXPERIMENTAL, since = "5.9")
+public interface ExecutableInvoker {
+
+	/**
+	 * Invoke the supplied {@code static} method with dynamic parameter resolution.
+	 *
+	 * @param method the method to invoke and resolve parameters for
+	 * @see #invoke(Method, Object)
+	 */
+	default Object invoke(Method method) {
+		return invoke(method, null);
+	}
+
+	/**
+	 * Invoke the supplied method with dynamic parameter resolution.
+	 *
+	 * @param method the method to invoke and resolve parameters for
+	 * @param target the target on which the executable will be invoked;
+	 * can be {@code null} for {@code static} methods
+	 */
+	Object invoke(Method method, Object target);
+
+	/**
+	 * Invoke the supplied top-level constructor with dynamic parameter resolution.
+	 *
+	 * @param constructor the constructor to invoke and resolve parameters for
+	 * @see #invoke(Constructor, Object)
+	 */
+	default <T> T invoke(Constructor<T> constructor) {
+		return invoke(constructor, null);
+	}
+
+	/**
+	 * Invoke the supplied constructor with the supplied outer instance and
+	 * dynamic parameter resolution.
+	 *
+	 * <p>Use this method when invoking the constructor for an <em>inner</em> class.
+	 *
+	 * @param constructor the constructor to invoke and resolve parameters for
+	 * @param outerInstance the outer instance to supply as the first argument
+	 * to the constructor; must be {@code null} for top-level classes
+	 * or {@code static} nested classes
+	 */
+	<T> T invoke(Constructor<T> constructor, Object outerInstance);
+
+}
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ExtensionContext.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ExtensionContext.java
index f573561c3..55c7fad2e 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ExtensionContext.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ExtensionContext.java
@@ -393,6 +393,15 @@ public interface ExtensionContext {
 	@API(status = STABLE, since = "5.8.1")
 	ExecutionMode getExecutionMode();
 
+	/**
+	 * Get an {@link ExecutableInvoker} to invoke methods and constructors
+	 * with support for dynamic resolution of parameters.
+	 *
+	 * @since 5.9
+	 */
+	@API(status = EXPERIMENTAL, since = "5.9")
+	ExecutableInvoker getExecutableInvoker();
+
 	/**
 	 * {@code Store} provides methods for extensions to save and retrieve data.
 	 */
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/AbstractExtensionContext.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/AbstractExtensionContext.java
index baaae959f..5ed8ce41c 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/AbstractExtensionContext.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/AbstractExtensionContext.java
@@ -20,6 +20,7 @@ import java.util.Optional;
 import java.util.Set;
 import java.util.function.Function;
 
+import org.junit.jupiter.api.extension.ExecutableInvoker;
 import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.api.parallel.ExecutionMode;
 import org.junit.jupiter.engine.config.JupiterConfiguration;
@@ -44,9 +45,11 @@ abstract class AbstractExtensionContext<T extends TestDescriptor> implements Ext
 	private final Set<String> tags;
 	private final JupiterConfiguration configuration;
 	private final ExtensionValuesStore valuesStore;
+	private final ExecutableInvoker executableInvoker;
 
 	AbstractExtensionContext(ExtensionContext parent, EngineExecutionListener engineExecutionListener, T testDescriptor,
-			JupiterConfiguration configuration) {
+			JupiterConfiguration configuration, ExecutableInvoker executableInvoker) {
+		this.executableInvoker = executableInvoker;
 
 		Preconditions.notNull(testDescriptor, "TestDescriptor must not be null");
 		Preconditions.notNull(configuration, "JupiterConfiguration must not be null");
@@ -136,6 +139,11 @@ abstract class AbstractExtensionContext<T extends TestDescriptor> implements Ext
 		return toJupiterExecutionMode(getPlatformExecutionMode());
 	}
 
+	@Override
+	public ExecutableInvoker getExecutableInvoker() {
+		return executableInvoker;
+	}
+
 	protected abstract Node.ExecutionMode getPlatformExecutionMode();
 
 	private ExecutionMode toJupiterExecutionMode(Node.ExecutionMode mode) {
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassBasedTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassBasedTestDescriptor.java
index b1a02844b..7dfa614dc 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassBasedTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassBasedTestDescriptor.java
@@ -37,6 +37,7 @@ import org.apiguardian.api.API;
 import org.junit.jupiter.api.TestInstance.Lifecycle;
 import org.junit.jupiter.api.extension.AfterAllCallback;
 import org.junit.jupiter.api.extension.BeforeAllCallback;
+import org.junit.jupiter.api.extension.ExecutableInvoker;
 import org.junit.jupiter.api.extension.Extension;
 import org.junit.jupiter.api.extension.ExtensionConfigurationException;
 import org.junit.jupiter.api.extension.ExtensionContext;
@@ -53,10 +54,11 @@ import org.junit.jupiter.api.function.Executable;
 import org.junit.jupiter.engine.config.JupiterConfiguration;
 import org.junit.jupiter.engine.execution.AfterEachMethodAdapter;
 import org.junit.jupiter.engine.execution.BeforeEachMethodAdapter;
+import org.junit.jupiter.engine.execution.DefaultExecutableInvoker;
 import org.junit.jupiter.engine.execution.DefaultTestInstances;
-import org.junit.jupiter.engine.execution.ExecutableInvoker;
-import org.junit.jupiter.engine.execution.ExecutableInvoker.ReflectiveInterceptorCall;
-import org.junit.jupiter.engine.execution.ExecutableInvoker.ReflectiveInterceptorCall.VoidMethodInterceptorCall;
+import org.junit.jupiter.engine.execution.InterceptingExecutableInvoker;
+import org.junit.jupiter.engine.execution.InterceptingExecutableInvoker.ReflectiveInterceptorCall;
+import org.junit.jupiter.engine.execution.InterceptingExecutableInvoker.ReflectiveInterceptorCall.VoidMethodInterceptorCall;
 import org.junit.jupiter.engine.execution.JupiterEngineExecutionContext;
 import org.junit.jupiter.engine.execution.TestInstancesProvider;
 import org.junit.jupiter.engine.extension.ExtensionRegistrar;
@@ -82,7 +84,7 @@ import org.junit.platform.engine.support.hierarchical.ThrowableCollector;
 @API(status = INTERNAL, since = "5.5")
 public abstract class ClassBasedTestDescriptor extends JupiterTestDescriptor {
 
-	private static final ExecutableInvoker executableInvoker = new ExecutableInvoker();
+	private static final InterceptingExecutableInvoker executableInvoker = new InterceptingExecutableInvoker();
 
 	private final Class<?> testClass;
 	protected final Set<TestTag> tags;
@@ -174,8 +176,10 @@ public abstract class ClassBasedTestDescriptor extends JupiterTestDescriptor {
 		this.afterAllMethods.forEach(method -> registerExtensionsFromExecutableParameters(registry, method));
 
 		ThrowableCollector throwableCollector = createThrowableCollector();
+		ExecutableInvoker executableInvoker = new DefaultExecutableInvoker(context);
 		ClassExtensionContext extensionContext = new ClassExtensionContext(context.getExtensionContext(),
-			context.getExecutionListener(), this, this.lifecycle, context.getConfiguration(), throwableCollector);
+			context.getExecutionListener(), this, this.lifecycle, context.getConfiguration(), throwableCollector,
+			executableInvoker);
 
 		// @formatter:off
 		return context.extend()
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassExtensionContext.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassExtensionContext.java
index 945bb6c46..5fbcb0e5f 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassExtensionContext.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassExtensionContext.java
@@ -15,6 +15,7 @@ import java.lang.reflect.Method;
 import java.util.Optional;
 
 import org.junit.jupiter.api.TestInstance.Lifecycle;
+import org.junit.jupiter.api.extension.ExecutableInvoker;
 import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.api.extension.TestInstances;
 import org.junit.jupiter.engine.config.JupiterConfiguration;
@@ -36,20 +37,22 @@ final class ClassExtensionContext extends AbstractExtensionContext<ClassBasedTes
 	/**
 	 * Create a new {@code ClassExtensionContext} with {@link Lifecycle#PER_METHOD}.
 	 *
-	 * @see #ClassExtensionContext(ExtensionContext, EngineExecutionListener, ClassBasedTestDescriptor, Lifecycle, JupiterConfiguration, ThrowableCollector)
+	 * @see #ClassExtensionContext(ExtensionContext, EngineExecutionListener, ClassBasedTestDescriptor,
+	 * Lifecycle, JupiterConfiguration, ThrowableCollector, ExecutableInvoker)
 	 */
 	ClassExtensionContext(ExtensionContext parent, EngineExecutionListener engineExecutionListener,
 			ClassBasedTestDescriptor testDescriptor, JupiterConfiguration configuration,
-			ThrowableCollector throwableCollector) {
+			ThrowableCollector throwableCollector, ExecutableInvoker executableInvoker) {
 
-		this(parent, engineExecutionListener, testDescriptor, Lifecycle.PER_METHOD, configuration, throwableCollector);
+		this(parent, engineExecutionListener, testDescriptor, Lifecycle.PER_METHOD, configuration, throwableCollector,
+			executableInvoker);
 	}
 
 	ClassExtensionContext(ExtensionContext parent, EngineExecutionListener engineExecutionListener,
 			ClassBasedTestDescriptor testDescriptor, Lifecycle lifecycle, JupiterConfiguration configuration,
-			ThrowableCollector throwableCollector) {
+			ThrowableCollector throwableCollector, ExecutableInvoker executableInvoker) {
 
-		super(parent, engineExecutionListener, testDescriptor, configuration);
+		super(parent, engineExecutionListener, testDescriptor, configuration, executableInvoker);
 
 		this.lifecycle = lifecycle;
 		this.throwableCollector = throwableCollector;
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DynamicExtensionContext.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DynamicExtensionContext.java
index 31aa82afc..4e0c3cb72 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DynamicExtensionContext.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DynamicExtensionContext.java
@@ -15,6 +15,7 @@ import java.lang.reflect.Method;
 import java.util.Optional;
 
 import org.junit.jupiter.api.TestInstance;
+import org.junit.jupiter.api.extension.ExecutableInvoker;
 import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.api.extension.TestInstances;
 import org.junit.jupiter.engine.config.JupiterConfiguration;
@@ -24,8 +25,9 @@ import org.junit.platform.engine.support.hierarchical.Node;
 class DynamicExtensionContext extends AbstractExtensionContext<DynamicNodeTestDescriptor> {
 
 	DynamicExtensionContext(ExtensionContext parent, EngineExecutionListener engineExecutionListener,
-			DynamicNodeTestDescriptor testDescriptor, JupiterConfiguration configuration) {
-		super(parent, engineExecutionListener, testDescriptor, configuration);
+			DynamicNodeTestDescriptor testDescriptor, JupiterConfiguration configuration,
+			ExecutableInvoker executableInvoker) {
+		super(parent, engineExecutionListener, testDescriptor, configuration, executableInvoker);
 	}
 
 	@Override
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DynamicNodeTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DynamicNodeTestDescriptor.java
index befabd78b..8619bb1fb 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DynamicNodeTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DynamicNodeTestDescriptor.java
@@ -12,6 +12,7 @@ package org.junit.jupiter.engine.descriptor;
 
 import org.junit.jupiter.api.DynamicNode;
 import org.junit.jupiter.engine.config.JupiterConfiguration;
+import org.junit.jupiter.engine.execution.DefaultExecutableInvoker;
 import org.junit.jupiter.engine.execution.JupiterEngineExecutionContext;
 import org.junit.platform.engine.TestDescriptor;
 import org.junit.platform.engine.TestSource;
@@ -45,7 +46,7 @@ abstract class DynamicNodeTestDescriptor extends JupiterTestDescriptor {
 	@Override
 	public JupiterEngineExecutionContext prepare(JupiterEngineExecutionContext context) {
 		DynamicExtensionContext extensionContext = new DynamicExtensionContext(context.getExtensionContext(),
-			context.getExecutionListener(), this, context.getConfiguration());
+			context.getExecutionListener(), this, context.getConfiguration(), new DefaultExecutableInvoker(context));
 		// @formatter:off
 		return context.extend()
 				.withExtensionContext(extensionContext)
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/JupiterEngineDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/JupiterEngineDescriptor.java
index 7793ce4cf..0aa9d9056 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/JupiterEngineDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/JupiterEngineDescriptor.java
@@ -14,8 +14,10 @@ import static org.apiguardian.api.API.Status.INTERNAL;
 import static org.junit.jupiter.engine.descriptor.JupiterTestDescriptor.toExecutionMode;
 
 import org.apiguardian.api.API;
+import org.junit.jupiter.api.extension.ExecutableInvoker;
 import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.engine.config.JupiterConfiguration;
+import org.junit.jupiter.engine.execution.DefaultExecutableInvoker;
 import org.junit.jupiter.engine.execution.JupiterEngineExecutionContext;
 import org.junit.jupiter.engine.extension.MutableExtensionRegistry;
 import org.junit.platform.engine.EngineExecutionListener;
@@ -51,8 +53,9 @@ public class JupiterEngineDescriptor extends EngineDescriptor implements Node<Ju
 		MutableExtensionRegistry extensionRegistry = MutableExtensionRegistry.createRegistryWithDefaultExtensions(
 			context.getConfiguration());
 		EngineExecutionListener executionListener = context.getExecutionListener();
+		ExecutableInvoker executableInvoker = new DefaultExecutableInvoker(context);
 		ExtensionContext extensionContext = new JupiterEngineExtensionContext(executionListener, this,
-			context.getConfiguration());
+			context.getConfiguration(), executableInvoker);
 
 		// @formatter:off
 		return context.extend()
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/JupiterEngineExtensionContext.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/JupiterEngineExtensionContext.java
index 87806cb24..14c042e3c 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/JupiterEngineExtensionContext.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/JupiterEngineExtensionContext.java
@@ -15,6 +15,7 @@ import java.lang.reflect.Method;
 import java.util.Optional;
 
 import org.junit.jupiter.api.TestInstance.Lifecycle;
+import org.junit.jupiter.api.extension.ExecutableInvoker;
 import org.junit.jupiter.api.extension.TestInstances;
 import org.junit.jupiter.engine.config.JupiterConfiguration;
 import org.junit.platform.engine.EngineExecutionListener;
@@ -26,9 +27,10 @@ import org.junit.platform.engine.support.hierarchical.Node;
 final class JupiterEngineExtensionContext extends AbstractExtensionContext<JupiterEngineDescriptor> {
 
 	JupiterEngineExtensionContext(EngineExecutionListener engineExecutionListener,
-			JupiterEngineDescriptor testDescriptor, JupiterConfiguration configuration) {
+			JupiterEngineDescriptor testDescriptor, JupiterConfiguration configuration,
+			ExecutableInvoker executableInvoker) {
 
-		super(null, engineExecutionListener, testDescriptor, configuration);
+		super(null, engineExecutionListener, testDescriptor, configuration, executableInvoker);
 	}
 
 	@Override
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/MethodExtensionContext.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/MethodExtensionContext.java
index 2843b4f7b..b10be186c 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/MethodExtensionContext.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/MethodExtensionContext.java
@@ -15,6 +15,7 @@ import java.lang.reflect.Method;
 import java.util.Optional;
 
 import org.junit.jupiter.api.TestInstance.Lifecycle;
+import org.junit.jupiter.api.extension.ExecutableInvoker;
 import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.api.extension.TestInstances;
 import org.junit.jupiter.engine.config.JupiterConfiguration;
@@ -33,9 +34,9 @@ final class MethodExtensionContext extends AbstractExtensionContext<TestMethodTe
 
 	MethodExtensionContext(ExtensionContext parent, EngineExecutionListener engineExecutionListener,
 			TestMethodTestDescriptor testDescriptor, JupiterConfiguration configuration,
-			ThrowableCollector throwableCollector) {
+			ThrowableCollector throwableCollector, ExecutableInvoker executableInvoker) {
 
-		super(parent, engineExecutionListener, testDescriptor, configuration);
+		super(parent, engineExecutionListener, testDescriptor, configuration, executableInvoker);
 
 		this.throwableCollector = throwableCollector;
 	}
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestFactoryTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestFactoryTestDescriptor.java
index 28e05067b..49461ccf6 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestFactoryTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestFactoryTestDescriptor.java
@@ -29,8 +29,8 @@ import org.junit.jupiter.api.DynamicTest;
 import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.api.extension.InvocationInterceptor;
 import org.junit.jupiter.engine.config.JupiterConfiguration;
-import org.junit.jupiter.engine.execution.ExecutableInvoker;
-import org.junit.jupiter.engine.execution.ExecutableInvoker.ReflectiveInterceptorCall;
+import org.junit.jupiter.engine.execution.InterceptingExecutableInvoker;
+import org.junit.jupiter.engine.execution.InterceptingExecutableInvoker.ReflectiveInterceptorCall;
 import org.junit.jupiter.engine.execution.JupiterEngineExecutionContext;
 import org.junit.platform.commons.JUnitException;
 import org.junit.platform.commons.PreconditionViolationException;
@@ -58,7 +58,7 @@ public class TestFactoryTestDescriptor extends TestMethodTestDescriptor implemen
 	public static final String DYNAMIC_TEST_SEGMENT_TYPE = "dynamic-test";
 
 	private static final ReflectiveInterceptorCall<Method, Object> interceptorCall = InvocationInterceptor::interceptTestFactoryMethod;
-	private static final ExecutableInvoker executableInvoker = new ExecutableInvoker();
+	private static final InterceptingExecutableInvoker executableInvoker = new InterceptingExecutableInvoker();
 
 	private final DynamicDescendantFilter dynamicDescendantFilter = new DynamicDescendantFilter();
 
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestMethodTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestMethodTestDescriptor.java
index fb3b9ada6..19daed95c 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestMethodTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestMethodTestDescriptor.java
@@ -23,6 +23,7 @@ import org.junit.jupiter.api.extension.AfterEachCallback;
 import org.junit.jupiter.api.extension.AfterTestExecutionCallback;
 import org.junit.jupiter.api.extension.BeforeEachCallback;
 import org.junit.jupiter.api.extension.BeforeTestExecutionCallback;
+import org.junit.jupiter.api.extension.ExecutableInvoker;
 import org.junit.jupiter.api.extension.Extension;
 import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.api.extension.InvocationInterceptor;
@@ -34,8 +35,9 @@ import org.junit.jupiter.api.extension.TestWatcher;
 import org.junit.jupiter.engine.config.JupiterConfiguration;
 import org.junit.jupiter.engine.execution.AfterEachMethodAdapter;
 import org.junit.jupiter.engine.execution.BeforeEachMethodAdapter;
-import org.junit.jupiter.engine.execution.ExecutableInvoker;
-import org.junit.jupiter.engine.execution.ExecutableInvoker.ReflectiveInterceptorCall;
+import org.junit.jupiter.engine.execution.DefaultExecutableInvoker;
+import org.junit.jupiter.engine.execution.InterceptingExecutableInvoker;
+import org.junit.jupiter.engine.execution.InterceptingExecutableInvoker.ReflectiveInterceptorCall;
 import org.junit.jupiter.engine.execution.JupiterEngineExecutionContext;
 import org.junit.jupiter.engine.extension.ExtensionRegistry;
 import org.junit.jupiter.engine.extension.MutableExtensionRegistry;
@@ -67,7 +69,7 @@ import org.junit.platform.engine.support.hierarchical.ThrowableCollector;
 public class TestMethodTestDescriptor extends MethodBasedTestDescriptor {
 
 	public static final String SEGMENT_TYPE = "method";
-	private static final ExecutableInvoker executableInvoker = new ExecutableInvoker();
+	private static final InterceptingExecutableInvoker executableInvoker = new InterceptingExecutableInvoker();
 	private static final ReflectiveInterceptorCall<Method, Void> defaultInterceptorCall = ReflectiveInterceptorCall.ofVoidMethod(
 		InvocationInterceptor::interceptTestMethod);
 
@@ -96,8 +98,9 @@ public class TestMethodTestDescriptor extends MethodBasedTestDescriptor {
 	public JupiterEngineExecutionContext prepare(JupiterEngineExecutionContext context) {
 		MutableExtensionRegistry registry = populateNewExtensionRegistry(context);
 		ThrowableCollector throwableCollector = createThrowableCollector();
+		ExecutableInvoker executableInvoker = new DefaultExecutableInvoker(context);
 		MethodExtensionContext extensionContext = new MethodExtensionContext(context.getExtensionContext(),
-			context.getExecutionListener(), this, context.getConfiguration(), throwableCollector);
+			context.getExecutionListener(), this, context.getConfiguration(), throwableCollector, executableInvoker);
 		throwableCollector.execute(() -> {
 			TestInstances testInstances = context.getTestInstancesProvider().getTestInstances(registry,
 				throwableCollector);
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestTemplateExtensionContext.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestTemplateExtensionContext.java
index aa16d6a7b..164552dea 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestTemplateExtensionContext.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestTemplateExtensionContext.java
@@ -15,6 +15,7 @@ import java.lang.reflect.Method;
 import java.util.Optional;
 
 import org.junit.jupiter.api.TestInstance.Lifecycle;
+import org.junit.jupiter.api.extension.ExecutableInvoker;
 import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.api.extension.TestInstances;
 import org.junit.jupiter.engine.config.JupiterConfiguration;
@@ -29,10 +30,10 @@ final class TestTemplateExtensionContext extends AbstractExtensionContext<TestTe
 	private final TestInstances testInstances;
 
 	TestTemplateExtensionContext(ExtensionContext parent, EngineExecutionListener engineExecutionListener,
-			TestTemplateTestDescriptor testDescriptor, JupiterConfiguration configuration,
-			TestInstances testInstances) {
+			TestTemplateTestDescriptor testDescriptor, JupiterConfiguration configuration, TestInstances testInstances,
+			ExecutableInvoker executableInvoker) {
 
-		super(parent, engineExecutionListener, testDescriptor, configuration);
+		super(parent, engineExecutionListener, testDescriptor, configuration, executableInvoker);
 		this.testInstances = testInstances;
 	}
 
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestTemplateInvocationTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestTemplateInvocationTestDescriptor.java
index 24c623d1a..a6bdd8c09 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestTemplateInvocationTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestTemplateInvocationTestDescriptor.java
@@ -20,7 +20,7 @@ import org.apiguardian.api.API;
 import org.junit.jupiter.api.extension.InvocationInterceptor;
 import org.junit.jupiter.api.extension.TestTemplateInvocationContext;
 import org.junit.jupiter.engine.config.JupiterConfiguration;
-import org.junit.jupiter.engine.execution.ExecutableInvoker.ReflectiveInterceptorCall;
+import org.junit.jupiter.engine.execution.InterceptingExecutableInvoker.ReflectiveInterceptorCall;
 import org.junit.jupiter.engine.execution.JupiterEngineExecutionContext;
 import org.junit.jupiter.engine.extension.MutableExtensionRegistry;
 import org.junit.platform.engine.TestDescriptor;
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestTemplateTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestTemplateTestDescriptor.java
index c3eb4cae8..8d44338c7 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestTemplateTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestTemplateTestDescriptor.java
@@ -21,11 +21,13 @@ import java.util.Optional;
 import java.util.concurrent.atomic.AtomicInteger;
 
 import org.apiguardian.api.API;
+import org.junit.jupiter.api.extension.ExecutableInvoker;
 import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.api.extension.TestInstances;
 import org.junit.jupiter.api.extension.TestTemplateInvocationContext;
 import org.junit.jupiter.api.extension.TestTemplateInvocationContextProvider;
 import org.junit.jupiter.engine.config.JupiterConfiguration;
+import org.junit.jupiter.engine.execution.DefaultExecutableInvoker;
 import org.junit.jupiter.engine.execution.JupiterEngineExecutionContext;
 import org.junit.jupiter.engine.extension.ExtensionRegistry;
 import org.junit.jupiter.engine.extension.MutableExtensionRegistry;
@@ -79,8 +81,9 @@ public class TestTemplateTestDescriptor extends MethodBasedTestDescriptor implem
 		// The test instance should be properly maintained by the enclosing class's ExtensionContext.
 		TestInstances testInstances = context.getExtensionContext().getTestInstances().orElse(null);
 
+		ExecutableInvoker executableInvoker = new DefaultExecutableInvoker(context);
 		ExtensionContext extensionContext = new TestTemplateExtensionContext(context.getExtensionContext(),
-			context.getExecutionListener(), this, context.getConfiguration(), testInstances);
+			context.getExecutionListener(), this, context.getConfiguration(), testInstances, executableInvoker);
 
 		// @formatter:off
 		return context.extend()
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/DefaultExecutableInvoker.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/DefaultExecutableInvoker.java
new file mode 100644
index 000000000..0c13e3ef0
--- /dev/null
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/DefaultExecutableInvoker.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2015-2022 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.engine.execution;
+
+import static org.apiguardian.api.API.Status.INTERNAL;
+import static org.junit.jupiter.engine.execution.ParameterResolutionUtils.resolveParameters;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Method;
+import java.util.Optional;
+
+import org.apiguardian.api.API;
+import org.junit.jupiter.api.extension.ExecutableInvoker;
+import org.junit.jupiter.api.extension.ExtensionContext;
+import org.junit.jupiter.engine.extension.ExtensionRegistry;
+import org.junit.platform.commons.util.ReflectionUtils;
+
+/**
+ * @since 5.9
+ */
+@API(status = INTERNAL, since = "5.9")
+public class DefaultExecutableInvoker implements ExecutableInvoker {
+
+	private final ExtensionContext extensionContext;
+	private final ExtensionRegistry extensionRegistry;
+
+	public DefaultExecutableInvoker(ExtensionContext extensionContext, ExtensionRegistry extensionRegistry) {
+		this.extensionContext = extensionContext;
+		this.extensionRegistry = extensionRegistry;
+	}
+
+	public DefaultExecutableInvoker(JupiterEngineExecutionContext context) {
+		this(context.getExtensionContext(), context.getExtensionRegistry());
+	}
+
+	@Override
+	public <T> T invoke(Constructor<T> constructor, Object outerInstance) {
+		Object[] arguments = resolveParameters(constructor, Optional.empty(), Optional.ofNullable(outerInstance),
+			extensionContext, extensionRegistry);
+		return ReflectionUtils.newInstance(constructor, arguments);
+	}
+
+	@Override
+	public Object invoke(Method method, Object target) {
+		Object[] arguments = resolveParameters(method, Optional.ofNullable(target), extensionContext,
+			extensionRegistry);
+		return ReflectionUtils.invokeMethod(method, target, arguments);
+	}
+
+}
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/InterceptingExecutableInvoker.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/InterceptingExecutableInvoker.java
new file mode 100644
index 000000000..50aaf7dba
--- /dev/null
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/InterceptingExecutableInvoker.java
@@ -0,0 +1,116 @@
+/*
+ * Copyright 2015-2022 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.engine.execution;
+
+import static org.apiguardian.api.API.Status.INTERNAL;
+import static org.junit.jupiter.engine.execution.ParameterResolutionUtils.resolveParameters;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Executable;
+import java.lang.reflect.Method;
+import java.util.Optional;
+
+import org.apiguardian.api.API;
+import org.junit.jupiter.api.extension.ExtensionContext;
+import org.junit.jupiter.api.extension.InvocationInterceptor;
+import org.junit.jupiter.api.extension.InvocationInterceptor.Invocation;
+import org.junit.jupiter.api.extension.ParameterResolver;
+import org.junit.jupiter.api.extension.ReflectiveInvocationContext;
+import org.junit.jupiter.engine.extension.ExtensionRegistry;
+
+/**
+ * {@code InterceptingExecutableInvoker} encapsulates the invocation of a
+ * {@link java.lang.reflect.Executable} (i.e., method or constructor),
+ * including support for dynamic resolution of method parameters via
+ * {@link ParameterResolver ParameterResolvers}.
+ *
+ * @since 5.0
+ */
+@API(status = INTERNAL, since = "5.0")
+public class InterceptingExecutableInvoker {
+
+	private static final InvocationInterceptorChain interceptorChain = new InvocationInterceptorChain();
+
+	/**
+	 * Invoke the supplied constructor with the supplied outer instance and
+	 * dynamic parameter resolution.
+	 *
+	 * @param constructor the constructor to invoke and resolve parameters for
+	 * @param outerInstance the outer instance to supply as the first argument
+	 * to the constructor; empty, for top-level classes
+	 * @param extensionContext the current {@code ExtensionContext}
+	 * @param extensionRegistry the {@code ExtensionRegistry} to retrieve
+	 * {@code ParameterResolvers} from
+	 * @param interceptorCall the call for intercepting this constructor
+	 * invocation via all registered {@linkplain InvocationInterceptor
+	 * interceptors}
+	 */
+	public <T> T invoke(Constructor<T> constructor, Optional<Object> outerInstance, ExtensionContext extensionContext,
+			ExtensionRegistry extensionRegistry, ReflectiveInterceptorCall<Constructor<T>, T> interceptorCall) {
+
+		Object[] arguments = resolveParameters(constructor, Optional.empty(), outerInstance, extensionContext,
+			extensionRegistry);
+		ConstructorInvocation<T> invocation = new ConstructorInvocation<>(constructor, arguments);
+		return invoke(invocation, invocation, extensionContext, extensionRegistry, interceptorCall);
+	}
+
+	/**
+	 * Invoke the supplied method with dynamic parameter resolution.
+	 *
+	 * @param method the method to invoke and resolve parameters for
+	 * @param target the target on which the executable will be invoked,
+	 * potentially wrapped in an {@link Optional}; can be {@code null} or an
+	 * empty {@code Optional} for a {@code static} method
+	 * @param extensionContext the current {@code ExtensionContext}
+	 * @param extensionRegistry the {@code ExtensionRegistry} to retrieve
+	 * {@code ParameterResolvers} from
+	 * @param interceptorCall the call for intercepting this method invocation
+	 * via all registered {@linkplain InvocationInterceptor interceptors}
+	 */
+	public <T> T invoke(Method method, Object target, ExtensionContext extensionContext,
+			ExtensionRegistry extensionRegistry, ReflectiveInterceptorCall<Method, T> interceptorCall) {
+
+		@SuppressWarnings("unchecked")
+		Optional<Object> optionalTarget = (target instanceof Optional ? (Optional<Object>) target
+				: Optional.ofNullable(target));
+		Object[] arguments = resolveParameters(method, optionalTarget, extensionContext, extensionRegistry);
+		MethodInvocation<T> invocation = new MethodInvocation<>(method, optionalTarget, arguments);
+		return invoke(invocation, invocation, extensionContext, extensionRegistry, interceptorCall);
+	}
+
+	private <E extends Executable, T> T invoke(Invocation<T> originalInvocation,
+			ReflectiveInvocationContext<E> invocationContext, ExtensionContext extensionContext,
+			ExtensionRegistry extensionRegistry, ReflectiveInterceptorCall<E, T> call) {
+		return interceptorChain.invoke(originalInvocation, extensionRegistry, (interceptor,
+				wrappedInvocation) -> call.apply(interceptor, wrappedInvocation, invocationContext, extensionContext));
+	}
+
+	public interface ReflectiveInterceptorCall<E extends Executable, T> {
+
+		T apply(InvocationInterceptor interceptor, Invocation<T> invocation,
+				ReflectiveInvocationContext<E> invocationContext, ExtensionContext extensionContext) throws Throwable;
+
+		static ReflectiveInterceptorCall<Method, Void> ofVoidMethod(VoidMethodInterceptorCall call) {
+			return ((interceptorChain, invocation, invocationContext, extensionContext) -> {
+				call.apply(interceptorChain, invocation, invocationContext, extensionContext);
+				return null;
+			});
+		}
+
+		interface VoidMethodInterceptorCall {
+			void apply(InvocationInterceptor interceptor, Invocation<Void> invocation,
+					ReflectiveInvocationContext<Method> invocationContext, ExtensionContext extensionContext)
+					throws Throwable;
+		}
+
+	}
+
+}
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/ExecutableInvoker.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/ParameterResolutionUtils.java
similarity index 59%
rename from junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/ExecutableInvoker.java
rename to junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/ParameterResolutionUtils.java
index 1d3641f4c..a2ebffad0 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/ExecutableInvoker.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/ParameterResolutionUtils.java
@@ -24,12 +24,9 @@ import java.util.Optional;
 
 import org.apiguardian.api.API;
 import org.junit.jupiter.api.extension.ExtensionContext;
-import org.junit.jupiter.api.extension.InvocationInterceptor;
-import org.junit.jupiter.api.extension.InvocationInterceptor.Invocation;
 import org.junit.jupiter.api.extension.ParameterContext;
 import org.junit.jupiter.api.extension.ParameterResolutionException;
 import org.junit.jupiter.api.extension.ParameterResolver;
-import org.junit.jupiter.api.extension.ReflectiveInvocationContext;
 import org.junit.jupiter.engine.extension.ExtensionRegistry;
 import org.junit.platform.commons.logging.Logger;
 import org.junit.platform.commons.logging.LoggerFactory;
@@ -38,92 +35,15 @@ import org.junit.platform.commons.util.StringUtils;
 import org.junit.platform.commons.util.UnrecoverableExceptions;
 
 /**
- * {@code ExecutableInvoker} encapsulates the invocation of a
- * {@link java.lang.reflect.Executable} (i.e., method or constructor),
- * including support for dynamic resolution of method parameters via
- * {@link ParameterResolver ParameterResolvers}.
+ * {@code ParameterResolutionUtils} provides support for dynamic resolution
+ * of executable parameters via {@link ParameterResolver ParameterResolvers}.
  *
- * @since 5.0
+ * @since 5.9
  */
-@API(status = INTERNAL, since = "5.0")
-public class ExecutableInvoker {
+@API(status = INTERNAL, since = "5.9")
+public class ParameterResolutionUtils {
 
-	private static final Logger logger = LoggerFactory.getLogger(ExecutableInvoker.class);
-	private static final InvocationInterceptorChain interceptorChain = new InvocationInterceptorChain();
-
-	/**
-	 * Invoke the supplied constructor with the supplied outer instance and
-	 * dynamic parameter resolution.
-	 *
-	 * <p>This method should only be used to invoke the constructor for
-	 * an inner class.
-	 *
-	 * @param constructor the constructor to invoke and resolve parameters for
-	 * @param outerInstance the outer instance to supply as the first argument
-	 * to the constructor; empty, for top-level classes
-	 * @param extensionContext the current {@code ExtensionContext}
-	 * @param extensionRegistry the {@code ExtensionRegistry} to retrieve
-	 * {@code ParameterResolvers} from
-	 * @param interceptorCall the call for intercepting this constructor
-	 * invocation via all registered {@linkplain InvocationInterceptor
-	 * interceptors}
-	 */
-	public <T> T invoke(Constructor<T> constructor, Optional<Object> outerInstance, ExtensionContext extensionContext,
-			ExtensionRegistry extensionRegistry, ReflectiveInterceptorCall<Constructor<T>, T> interceptorCall) {
-
-		Object[] arguments = resolveParameters(constructor, Optional.empty(), outerInstance, extensionContext,
-			extensionRegistry);
-		ConstructorInvocation<T> invocation = new ConstructorInvocation<>(constructor, arguments);
-		return invoke(invocation, invocation, extensionContext, extensionRegistry, interceptorCall);
-	}
-
-	/**
-	 * Invoke the supplied {@code static} method with dynamic parameter resolution.
-	 *
-	 * @param method the method to invoke and resolve parameters for
-	 * @param extensionContext the current {@code ExtensionContext}
-	 * @param extensionRegistry the {@code ExtensionRegistry} to retrieve
-	 * {@code ParameterResolvers} from
-	 * @param interceptorCall the call for intercepting this method invocation
-	 * via all registered {@linkplain InvocationInterceptor interceptors}
-	 */
-	public <T> T invoke(Method method, Object target, ExtensionContext extensionContext,
-			ExtensionRegistry extensionRegistry, ReflectiveInterceptorCall<Method, T> interceptorCall) {
-
-		@SuppressWarnings("unchecked")
-		Optional<Object> optionalTarget = (target instanceof Optional ? (Optional<Object>) target
-				: Optional.ofNullable(target));
-		Object[] arguments = resolveParameters(method, optionalTarget, extensionContext, extensionRegistry);
-		MethodInvocation<T> invocation = new MethodInvocation<>(method, optionalTarget, arguments);
-		return invoke(invocation, invocation, extensionContext, extensionRegistry, interceptorCall);
-	}
-
-	private <E extends Executable, T> T invoke(Invocation<T> originalInvocation,
-			ReflectiveInvocationContext<E> invocationContext, ExtensionContext extensionContext,
-			ExtensionRegistry extensionRegistry, ReflectiveInterceptorCall<E, T> call) {
-		return interceptorChain.invoke(originalInvocation, extensionRegistry, (interceptor,
-				wrappedInvocation) -> call.apply(interceptor, wrappedInvocation, invocationContext, extensionContext));
-	}
-
-	public interface ReflectiveInterceptorCall<E extends Executable, T> {
-
-		T apply(InvocationInterceptor interceptor, Invocation<T> invocation,
-				ReflectiveInvocationContext<E> invocationContext, ExtensionContext extensionContext) throws Throwable;
-
-		static ReflectiveInterceptorCall<Method, Void> ofVoidMethod(VoidMethodInterceptorCall call) {
-			return ((interceptorChain, invocation, invocationContext, extensionContext) -> {
-				call.apply(interceptorChain, invocation, invocationContext, extensionContext);
-				return null;
-			});
-		}
-
-		interface VoidMethodInterceptorCall {
-			void apply(InvocationInterceptor interceptor, Invocation<Void> invocation,
-					ReflectiveInvocationContext<Method> invocationContext, ExtensionContext extensionContext)
-					throws Throwable;
-		}
-
-	}
+	private static final Logger logger = LoggerFactory.getLogger(ParameterResolutionUtils.class);
 
 	/**
 	 * Resolve the array of parameters for the supplied method and target.
@@ -138,7 +58,7 @@ public class ExecutableInvoker {
 	 * @return the array of Objects to be used as parameters in the executable
 	 * invocation; never {@code null} though potentially empty
 	 */
-	private Object[] resolveParameters(Method method, Optional<Object> target, ExtensionContext extensionContext,
+	public static Object[] resolveParameters(Method method, Optional<Object> target, ExtensionContext extensionContext,
 			ExtensionRegistry extensionRegistry) {
 
 		return resolveParameters(method, target, Optional.empty(), extensionContext, extensionRegistry);
@@ -161,8 +81,8 @@ public class ExecutableInvoker {
 	 * @return the array of Objects to be used as parameters in the executable
 	 * invocation; never {@code null} though potentially empty
 	 */
-	private Object[] resolveParameters(Executable executable, Optional<Object> target, Optional<Object> outerInstance,
-			ExtensionContext extensionContext, ExtensionRegistry extensionRegistry) {
+	public static Object[] resolveParameters(Executable executable, Optional<Object> target,
+			Optional<Object> outerInstance, ExtensionContext extensionContext, ExtensionRegistry extensionRegistry) {
 
 		Preconditions.notNull(target, "target must not be null");
 
@@ -185,7 +105,7 @@ public class ExecutableInvoker {
 		return values;
 	}
 
-	private Object resolveParameter(ParameterContext parameterContext, Executable executable,
+	private static Object resolveParameter(ParameterContext parameterContext, Executable executable,
 			ExtensionContext extensionContext, ExtensionRegistry extensionRegistry) {
 
 		try {
@@ -240,7 +160,7 @@ public class ExecutableInvoker {
 		}
 	}
 
-	private void validateResolvedType(Parameter parameter, Object value, Executable executable,
+	private static void validateResolvedType(Parameter parameter, Object value, Executable executable,
 			ParameterResolver resolver) {
 
 		Class<?> type = parameter.getType();
@@ -270,4 +190,5 @@ public class ExecutableInvoker {
 	private static String asLabel(Executable executable) {
 		return executable instanceof Constructor ? "constructor" : "method";
 	}
+
 }
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/extension/ExecutableInvokerIntegrationTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/extension/ExecutableInvokerIntegrationTests.java
new file mode 100644
index 000000000..a9c25aff5
--- /dev/null
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/extension/ExecutableInvokerIntegrationTests.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright 2015-2022 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.api.extension;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.TestInfo;
+import org.junit.jupiter.engine.AbstractJupiterTestEngineTests;
+import org.junit.platform.testkit.engine.EngineExecutionResults;
+
+/**
+ * @since 5.9
+ */
+public class ExecutableInvokerIntegrationTests extends AbstractJupiterTestEngineTests {
+
+	@Test
+	void invokeConstructorViaExtensionContext() {
+		EngineExecutionResults results = executeTestsForClass(ExecuteConstructorTwiceTestCase.class);
+
+		assertEquals(1, results.testEvents().succeeded().count());
+		assertEquals(2, ExecuteConstructorTwiceTestCase.constructorInvocations);
+	}
+
+	@Test
+	void invokeMethodViaExtensionContext() {
+		EngineExecutionResults results = executeTestsForClass(ExecuteTestsTwiceTestCase.class);
+
+		assertEquals(1, results.testEvents().succeeded().count());
+		assertEquals(2, ExecuteTestsTwiceTestCase.testInvocations);
+	}
+
+	@ExtendWith(ExecuteTestsTwiceExtension.class)
+	static class ExecuteTestsTwiceTestCase {
+
+		static int testInvocations = 0;
+
+		@Test
+		void testWithResolvedParameter(TestInfo testInfo) {
+			assertNotNull(testInfo);
+			testInvocations++;
+		}
+
+	}
+
+	@ExtendWith(ExecuteConstructorTwiceExtension.class)
+	static class ExecuteConstructorTwiceTestCase {
+
+		static int constructorInvocations = 0;
+
+		public ExecuteConstructorTwiceTestCase(TestInfo testInfo) {
+			assertNotNull(testInfo);
+			constructorInvocations++;
+		}
+
+		@Test
+		void test() {
+
+		}
+
+	}
+
+	static class ExecuteTestsTwiceExtension implements AfterTestExecutionCallback {
+
+		@Override
+		public void afterTestExecution(ExtensionContext context) {
+			context.getExecutableInvoker() //
+					.invoke(context.getRequiredTestMethod(), context.getRequiredTestInstance());
+		}
+
+	}
+
+	static class ExecuteConstructorTwiceExtension implements BeforeAllCallback {
+
+		@Override
+		public void beforeAll(ExtensionContext context) throws Exception {
+			context.getExecutableInvoker() //
+					.invoke(context.getRequiredTestClass().getConstructor(TestInfo.class));
+		}
+
+	}
+
+}
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/descriptor/ExtensionContextTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/descriptor/ExtensionContextTests.java
index af9c7681d..61703eb25 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/descriptor/ExtensionContextTests.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/descriptor/ExtensionContextTests.java
@@ -74,7 +74,7 @@ public class ExtensionContextTests {
 			UniqueId.root("engine", "junit-jupiter"), configuration);
 
 		JupiterEngineExtensionContext engineContext = new JupiterEngineExtensionContext(null, engineTestDescriptor,
-			configuration);
+			configuration, null);
 
 		// @formatter:off
 		assertAll("engineContext",
@@ -100,7 +100,7 @@ public class ExtensionContextTests {
 		ClassTestDescriptor outerClassDescriptor = outerClassDescriptor(nestedClassDescriptor);
 
 		ClassExtensionContext outerExtensionContext = new ClassExtensionContext(null, null, outerClassDescriptor,
-			configuration, null);
+			configuration, null, null);
 
 		// @formatter:off
 		assertAll("outerContext",
@@ -118,7 +118,7 @@ public class ExtensionContextTests {
 		// @formatter:on
 
 		ClassExtensionContext nestedExtensionContext = new ClassExtensionContext(outerExtensionContext, null,
-			nestedClassDescriptor, configuration, null);
+			nestedClassDescriptor, configuration, null, null);
 		assertThat(nestedExtensionContext.getParent()).containsSame(outerExtensionContext);
 	}
 
@@ -131,18 +131,18 @@ public class ExtensionContextTests {
 		outerClassDescriptor.addChild(methodTestDescriptor);
 
 		ClassExtensionContext outerExtensionContext = new ClassExtensionContext(null, null, outerClassDescriptor,
-			configuration, null);
+			configuration, null, null);
 
 		assertThat(outerExtensionContext.getTags()).containsExactly("outer-tag");
 		assertThat(outerExtensionContext.getRoot()).isSameAs(outerExtensionContext);
 
 		ClassExtensionContext nestedExtensionContext = new ClassExtensionContext(outerExtensionContext, null,
-			nestedClassDescriptor, configuration, null);
+			nestedClassDescriptor, configuration, null, null);
 		assertThat(nestedExtensionContext.getTags()).containsExactlyInAnyOrder("outer-tag", "nested-tag");
 		assertThat(nestedExtensionContext.getRoot()).isSameAs(outerExtensionContext);
 
 		MethodExtensionContext methodExtensionContext = new MethodExtensionContext(outerExtensionContext, null,
-			methodTestDescriptor, configuration, new OpenTest4JAwareThrowableCollector());
+			methodTestDescriptor, configuration, new OpenTest4JAwareThrowableCollector(), null);
 		methodExtensionContext.setTestInstances(DefaultTestInstances.of(new OuterClass()));
 		assertThat(methodExtensionContext.getTags()).containsExactlyInAnyOrder("outer-tag", "method-tag");
 		assertThat(methodExtensionContext.getRoot()).isSameAs(outerExtensionContext);
@@ -161,11 +161,11 @@ public class ExtensionContextTests {
 		Method testMethod = methodTestDescriptor.getTestMethod();
 
 		JupiterEngineExtensionContext engineExtensionContext = new JupiterEngineExtensionContext(null, engineDescriptor,
-			configuration);
+			configuration, null);
 		ClassExtensionContext classExtensionContext = new ClassExtensionContext(engineExtensionContext, null,
-			classTestDescriptor, configuration, null);
+			classTestDescriptor, configuration, null, null);
 		MethodExtensionContext methodExtensionContext = new MethodExtensionContext(classExtensionContext, null,
-			methodTestDescriptor, configuration, new OpenTest4JAwareThrowableCollector());
+			methodTestDescriptor, configuration, new OpenTest4JAwareThrowableCollector(), null);
 		methodExtensionContext.setTestInstances(DefaultTestInstances.of(testInstance));
 
 		// @formatter:off
@@ -191,7 +191,7 @@ public class ExtensionContextTests {
 		ClassTestDescriptor classTestDescriptor = outerClassDescriptor(null);
 		EngineExecutionListener engineExecutionListener = Mockito.spy(EngineExecutionListener.class);
 		ExtensionContext extensionContext = new ClassExtensionContext(null, engineExecutionListener,
-			classTestDescriptor, configuration, null);
+			classTestDescriptor, configuration, null, null);
 
 		Map<String, String> map1 = Collections.singletonMap("key", "value");
 		Map<String, String> map2 = Collections.singletonMap("other key", "other value");
@@ -221,10 +221,10 @@ public class ExtensionContextTests {
 	void usingStore() {
 		TestMethodTestDescriptor methodTestDescriptor = methodDescriptor();
 		ClassTestDescriptor classTestDescriptor = outerClassDescriptor(methodTestDescriptor);
-		ExtensionContext parentContext = new ClassExtensionContext(null, null, classTestDescriptor, configuration,
+		ExtensionContext parentContext = new ClassExtensionContext(null, null, classTestDescriptor, configuration, null,
 			null);
 		MethodExtensionContext childContext = new MethodExtensionContext(parentContext, null, methodTestDescriptor,
-			configuration, new OpenTest4JAwareThrowableCollector());
+			configuration, new OpenTest4JAwareThrowableCollector(), null);
 		childContext.setTestInstances(DefaultTestInstances.of(new OuterClass()));
 
 		ExtensionContext.Store childStore = childContext.getStore(Namespace.GLOBAL);
@@ -274,9 +274,9 @@ public class ExtensionContextTests {
 			configuration);
 
 		return Stream.of( //
-			(ExtensionContext) new JupiterEngineExtensionContext(null, engineDescriptor, echo), //
-			new ClassExtensionContext(null, null, classTestDescriptor, echo, null), //
-			new MethodExtensionContext(null, null, methodTestDescriptor, echo, null) //
+			(ExtensionContext) new JupiterEngineExtensionContext(null, engineDescriptor, echo, null), //
+			new ClassExtensionContext(null, null, classTestDescriptor, echo, null, null), //
+			new MethodExtensionContext(null, null, methodTestDescriptor, echo, null, null) //
 		).map(context -> dynamicTest(context.getClass().getSimpleName(),
 			() -> assertEquals(expected, context.getConfigurationParameter(key))));
 	}
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/execution/AbstractExecutableInvokerTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/execution/AbstractExecutableInvokerTests.java
new file mode 100644
index 000000000..4841213b3
--- /dev/null
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/execution/AbstractExecutableInvokerTests.java
@@ -0,0 +1,98 @@
+/*
+ * Copyright 2015-2022 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.engine.execution;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.engine.execution.ParameterResolutionUtilsTests.ConfigurableParameterResolver;
+import static org.junit.jupiter.engine.execution.ParameterResolutionUtilsTests.ConstructorInjectionTestCase;
+import static org.junit.jupiter.engine.execution.ParameterResolutionUtilsTests.MethodSource;
+import static org.junit.jupiter.engine.execution.ParameterResolutionUtilsTests.NumberParameterResolver;
+import static org.junit.jupiter.engine.execution.ParameterResolutionUtilsTests.StringParameterResolver;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Method;
+
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtensionContext;
+import org.junit.jupiter.api.extension.ParameterResolver;
+import org.junit.jupiter.engine.config.JupiterConfiguration;
+import org.junit.jupiter.engine.extension.MutableExtensionRegistry;
+import org.junit.platform.commons.util.ReflectionUtils;
+
+/**
+ * @since 5.9
+ */
+abstract class AbstractExecutableInvokerTests {
+
+	private static final String ENIGMA = "enigma";
+
+	protected final MethodSource instance = mock(MethodSource.class);
+	protected Method method;
+
+	protected final ExtensionContext extensionContext = mock(ExtensionContext.class);
+
+	private final JupiterConfiguration configuration = mock(JupiterConfiguration.class);
+
+	protected final MutableExtensionRegistry extensionRegistry = MutableExtensionRegistry.createRegistryWithDefaultExtensions(
+		configuration);
+
+	@Test
+	void constructorInjection() {
+		register(new StringParameterResolver(), new NumberParameterResolver());
+
+		Class<ConstructorInjectionTestCase> outerClass = ConstructorInjectionTestCase.class;
+		Constructor<ConstructorInjectionTestCase> constructor = ReflectionUtils.getDeclaredConstructor(outerClass);
+		ConstructorInjectionTestCase outer = invokeConstructor(constructor, null);
+
+		assertNotNull(outer);
+		assertEquals(ENIGMA, outer.str);
+
+		Class<ConstructorInjectionTestCase.NestedTestCase> innerClass = ConstructorInjectionTestCase.NestedTestCase.class;
+		Constructor<ConstructorInjectionTestCase.NestedTestCase> innerConstructor = ReflectionUtils.getDeclaredConstructor(
+			innerClass);
+		ConstructorInjectionTestCase.NestedTestCase inner = invokeConstructor(innerConstructor, outer);
+
+		assertNotNull(inner);
+		assertEquals(42, inner.num);
+	}
+
+	@Test
+	void resolveArgumentsViaParameterResolver() {
+		testMethodWithASingleStringParameter();
+		thereIsAParameterResolverThatResolvesTheParameterTo("argument");
+
+		invokeMethod();
+
+		verify(instance).singleStringParameter("argument");
+	}
+
+	private void thereIsAParameterResolverThatResolvesTheParameterTo(Object argument) {
+		register(ConfigurableParameterResolver.supportsAndResolvesTo(parameterContext -> argument));
+	}
+
+	private void testMethodWithASingleStringParameter() {
+		this.method = ReflectionUtils.findMethod(this.instance.getClass(), "singleStringParameter", String.class).get();
+	}
+
+	private void register(ParameterResolver... resolvers) {
+		for (ParameterResolver resolver : resolvers) {
+			extensionRegistry.registerExtension(resolver, this);
+		}
+	}
+
+	abstract void invokeMethod();
+
+	abstract <T> T invokeConstructor(Constructor<T> constructor, Object outerInstance);
+
+}
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/execution/DefaultExecutableInvokerTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/execution/DefaultExecutableInvokerTests.java
new file mode 100644
index 000000000..aa1f264f7
--- /dev/null
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/execution/DefaultExecutableInvokerTests.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2015-2022 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.engine.execution;
+
+import java.lang.reflect.Constructor;
+
+/**
+ * Unit tests for {@link DefaultExecutableInvoker}.
+ *
+ * @since 5.9
+ */
+class DefaultExecutableInvokerTests extends AbstractExecutableInvokerTests {
+
+	@Override
+	void invokeMethod() {
+		newInvoker().invoke(this.method, this.instance);
+	}
+
+	@Override
+	<T> T invokeConstructor(Constructor<T> constructor, Object outerInstance) {
+		return newInvoker().invoke(constructor, outerInstance);
+	}
+
+	private DefaultExecutableInvoker newInvoker() {
+		return new DefaultExecutableInvoker(this.extensionContext, this.extensionRegistry);
+	}
+
+}
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/execution/InterceptingExecutableInvokerTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/execution/InterceptingExecutableInvokerTests.java
new file mode 100644
index 000000000..a270e28d4
--- /dev/null
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/execution/InterceptingExecutableInvokerTests.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2015-2022 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.engine.execution;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Executable;
+import java.util.Optional;
+
+import org.junit.jupiter.engine.execution.InterceptingExecutableInvoker.ReflectiveInterceptorCall;
+
+/**
+ * Unit tests for {@link InterceptingExecutableInvoker}.
+ *
+ * @since 5.0
+ */
+class InterceptingExecutableInvokerTests extends AbstractExecutableInvokerTests {
+
+	@Override
+	void invokeMethod() {
+		newInvoker().invoke(this.method, this.instance, this.extensionContext, this.extensionRegistry,
+			passthroughInterceptor());
+	}
+
+	@Override
+	<T> T invokeConstructor(Constructor<T> constructor, Object outerInstance) {
+		return newInvoker().invoke(constructor, Optional.ofNullable(outerInstance), extensionContext, extensionRegistry,
+			passthroughInterceptor());
+	}
+
+	private InterceptingExecutableInvoker newInvoker() {
+		return new InterceptingExecutableInvoker();
+	}
+
+	private static <E extends Executable, T> ReflectiveInterceptorCall<E, T> passthroughInterceptor() {
+		return (interceptor, invocation, invocationContext, extensionContext) -> invocation.proceed();
+	}
+
+}
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/execution/ExecutableInvokerTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/execution/ParameterResolutionUtilsTests.java
similarity index 78%
rename from junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/execution/ExecutableInvokerTests.java
rename to junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/execution/ParameterResolutionUtilsTests.java
index fb6ddb3d7..31dbb1657 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/execution/ExecutableInvokerTests.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/execution/ParameterResolutionUtilsTests.java
@@ -12,14 +12,12 @@ package org.junit.jupiter.engine.execution;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.jupiter.api.Assertions.assertEquals;
-import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertNull;
 import static org.junit.jupiter.api.Assertions.assertSame;
 import static org.junit.jupiter.api.Assertions.assertThrows;
 import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.verify;
 
 import java.lang.reflect.Constructor;
-import java.lang.reflect.Executable;
 import java.lang.reflect.Method;
 import java.math.BigDecimal;
 import java.util.Optional;
@@ -33,16 +31,15 @@ import org.junit.jupiter.api.extension.ParameterContext;
 import org.junit.jupiter.api.extension.ParameterResolutionException;
 import org.junit.jupiter.api.extension.ParameterResolver;
 import org.junit.jupiter.engine.config.JupiterConfiguration;
-import org.junit.jupiter.engine.execution.ExecutableInvoker.ReflectiveInterceptorCall;
 import org.junit.jupiter.engine.extension.MutableExtensionRegistry;
 import org.junit.platform.commons.util.ReflectionUtils;
 
 /**
- * Unit tests for {@link ExecutableInvoker}.
+ * Unit tests for {@link ParameterResolutionUtils}.
  *
- * @since 5.0
+ * @since 5.9
  */
-class ExecutableInvokerTests {
+class ParameterResolutionUtilsTests {
 
 	private static final String ENIGMA = "enigma";
 
@@ -53,38 +50,40 @@ class ExecutableInvokerTests {
 
 	private final JupiterConfiguration configuration = mock(JupiterConfiguration.class);
 
-	private MutableExtensionRegistry extensionRegistry = MutableExtensionRegistry.createRegistryWithDefaultExtensions(
+	private final MutableExtensionRegistry extensionRegistry = MutableExtensionRegistry.createRegistryWithDefaultExtensions(
 		configuration);
 
 	@Test
-	void constructorInjection() {
-		register(new StringParameterResolver(), new NumberParameterResolver());
+	void resolveConstructorArguments() {
+		register(new StringParameterResolver());
 
-		Class<ConstructorInjectionTestCase> outerClass = ConstructorInjectionTestCase.class;
-		Constructor<ConstructorInjectionTestCase> constructor = ReflectionUtils.getDeclaredConstructor(outerClass);
-		ConstructorInjectionTestCase outer = newInvoker().invoke(constructor, Optional.empty(), extensionContext,
-			extensionRegistry, passthroughInterceptor());
+		Class<ConstructorInjectionTestCase> topLevelClass = ConstructorInjectionTestCase.class;
+		Object[] arguments = resolveConstructorParameters(topLevelClass, null);
+
+		assertThat(arguments).containsExactly(ENIGMA);
+	}
+
+	@Test
+	void resolveNestedConstructorArguments() {
+		register(new NumberParameterResolver());
 
-		assertNotNull(outer);
-		assertEquals(ENIGMA, outer.str);
+		Class<ConstructorInjectionTestCase> outerClass = ConstructorInjectionTestCase.class;
+		ConstructorInjectionTestCase outer = ReflectionUtils.newInstance(outerClass, "str");
 
 		Class<ConstructorInjectionTestCase.NestedTestCase> innerClass = ConstructorInjectionTestCase.NestedTestCase.class;
-		Constructor<ConstructorInjectionTestCase.NestedTestCase> innerConstructor = ReflectionUtils.getDeclaredConstructor(
-			innerClass);
-		ConstructorInjectionTestCase.NestedTestCase inner = newInvoker().invoke(innerConstructor, Optional.of(outer),
-			extensionContext, extensionRegistry, passthroughInterceptor());
+		Object[] arguments = resolveConstructorParameters(innerClass, outer);
 
-		assertNotNull(inner);
-		assertEquals(42, inner.num);
+		assertThat(arguments).containsExactly(outer, 42);
 	}
 
 	@Test
-	void constructorInjectionWithMissingResolver() {
+	void resolveConstructorArgumentsWithMissingResolver() {
 		Constructor<ConstructorInjectionTestCase> constructor = ReflectionUtils.getDeclaredConstructor(
 			ConstructorInjectionTestCase.class);
 
-		Exception exception = assertThrows(ParameterResolutionException.class, () -> newInvoker().invoke(constructor,
-			Optional.empty(), extensionContext, extensionRegistry, passthroughInterceptor()));
+		Exception exception = assertThrows(ParameterResolutionException.class,
+			() -> ParameterResolutionUtils.resolveParameters(constructor, Optional.empty(), Optional.empty(),
+				extensionContext, extensionRegistry));
 
 		assertThat(exception.getMessage())//
 				.contains("No ParameterResolver registered for parameter [java.lang.String")//
@@ -93,13 +92,13 @@ class ExecutableInvokerTests {
 	}
 
 	@Test
-	void invokingMethodsWithoutParameterDoesNotDependOnParameterResolvers() {
+	void resolvingArgumentsForMethodsWithoutParameterDoesNotDependOnParameterResolvers() {
 		testMethodWithNoParameters();
 		throwDuringParameterResolution(new RuntimeException("boom!"));
 
-		invokeMethod();
+		Object[] arguments = resolveMethodParameters();
 
-		verify(instance).noParameter();
+		assertThat(arguments).isEmpty();
 	}
 
 	@Test
@@ -107,9 +106,9 @@ class ExecutableInvokerTests {
 		testMethodWithASingleStringParameter();
 		thereIsAParameterResolverThatResolvesTheParameterTo("argument");
 
-		invokeMethod();
+		Object[] arguments = resolveMethodParameters();
 
-		verify(instance).singleStringParameter("argument");
+		assertThat(arguments).containsExactly("argument");
 	}
 
 	@Test
@@ -126,9 +125,9 @@ class ExecutableInvokerTests {
 			}
 		}));
 
-		invokeMethod();
+		Object[] arguments = resolveMethodParameters();
 
-		verify(instance).multipleParameters("0", 1, 2.0);
+		assertThat(arguments).containsExactly("0", 1, 2.0);
 	}
 
 	@Test
@@ -137,9 +136,9 @@ class ExecutableInvokerTests {
 		thereIsAParameterResolverThatDoesNotSupportThisParameter();
 		thereIsAParameterResolverThatResolvesTheParameterTo("something");
 
-		invokeMethod();
+		Object[] arguments = resolveMethodParameters();
 
-		verify(instance).singleStringParameter("something");
+		assertThat(arguments).containsExactly("something");
 	}
 
 	@Test
@@ -148,7 +147,7 @@ class ExecutableInvokerTests {
 		ArgumentRecordingParameterResolver extension = new ArgumentRecordingParameterResolver();
 		register(extension);
 
-		invokeMethod();
+		resolveMethodParameters();
 
 		assertSame(extensionContext, extension.supportsArguments.extensionContext);
 		assertEquals(0, extension.supportsArguments.parameterContext.getIndex());
@@ -161,13 +160,13 @@ class ExecutableInvokerTests {
 	}
 
 	@Test
-	void invocationOfMethodsWithPrimitiveTypesIsSupported() {
+	void resolvingArgumentsForMethodsWithPrimitiveTypesIsSupported() {
 		testMethodWithASinglePrimitiveIntParameter();
 		thereIsAParameterResolverThatResolvesTheParameterTo(42);
 
-		invokeMethod();
+		Object[] arguments = resolveMethodParameters();
 
-		verify(instance).primitiveParameterInt(42);
+		assertThat(arguments).containsExactly(42);
 	}
 
 	@Test
@@ -175,9 +174,10 @@ class ExecutableInvokerTests {
 		testMethodWithASingleStringParameter();
 		thereIsAParameterResolverThatResolvesTheParameterTo(null);
 
-		invokeMethod();
+		Object[] arguments = resolveMethodParameters();
 
-		verify(instance).singleStringParameter(null);
+		assertThat(arguments).hasSize(1);
+		assertNull(arguments[0]);
 	}
 
 	@Test
@@ -185,7 +185,8 @@ class ExecutableInvokerTests {
 		testMethodWithASinglePrimitiveIntParameter();
 		thereIsAParameterResolverThatResolvesTheParameterTo(null);
 
-		ParameterResolutionException caught = assertThrows(ParameterResolutionException.class, this::invokeMethod);
+		ParameterResolutionException caught = assertThrows(ParameterResolutionException.class,
+			this::resolveMethodParameters);
 
 		// @formatter:off
 		assertThat(caught.getMessage())
@@ -199,7 +200,8 @@ class ExecutableInvokerTests {
 	void reportIfThereIsNoParameterResolverThatSupportsTheParameter() {
 		testMethodWithASingleStringParameter();
 
-		ParameterResolutionException caught = assertThrows(ParameterResolutionException.class, this::invokeMethod);
+		ParameterResolutionException caught = assertThrows(ParameterResolutionException.class,
+			this::resolveMethodParameters);
 
 		assertThat(caught.getMessage()).contains("parameter [java.lang.String").contains("in method");
 	}
@@ -210,7 +212,8 @@ class ExecutableInvokerTests {
 		thereIsAParameterResolverThatResolvesTheParameterTo("one");
 		thereIsAParameterResolverThatResolvesTheParameterTo("two");
 
-		ParameterResolutionException caught = assertThrows(ParameterResolutionException.class, this::invokeMethod);
+		ParameterResolutionException caught = assertThrows(ParameterResolutionException.class,
+			this::resolveMethodParameters);
 
 		String className = Pattern.quote(ConfigurableParameterResolver.class.getName());
 
@@ -226,7 +229,8 @@ class ExecutableInvokerTests {
 		testMethodWithASingleStringParameter();
 		thereIsAParameterResolverThatResolvesTheParameterTo(BigDecimal.ONE);
 
-		ParameterResolutionException caught = assertThrows(ParameterResolutionException.class, this::invokeMethod);
+		ParameterResolutionException caught = assertThrows(ParameterResolutionException.class,
+			this::resolveMethodParameters);
 
 		// @formatter:off
 		assertThat(caught.getMessage())
@@ -242,7 +246,8 @@ class ExecutableInvokerTests {
 		IllegalArgumentException cause = anyExceptionButParameterResolutionException();
 		throwDuringParameterResolution(cause);
 
-		ParameterResolutionException caught = assertThrows(ParameterResolutionException.class, this::invokeMethod);
+		ParameterResolutionException caught = assertThrows(ParameterResolutionException.class,
+			this::resolveMethodParameters);
 
 		assertSame(cause, caught.getCause(), () -> "cause should be present");
 		assertThat(caught.getMessage())//
@@ -250,12 +255,13 @@ class ExecutableInvokerTests {
 	}
 
 	@Test
-	void exceptionMessageContainsMessageFromEexceptionThrownDuringParameterResolution() {
+	void exceptionMessageContainsMessageFromExceptionThrownDuringParameterResolution() {
 		anyTestMethodWithAtLeastOneParameter();
 		RuntimeException cause = new RuntimeException("boom!");
 		throwDuringParameterResolution(cause);
 
-		ParameterResolutionException caught = assertThrows(ParameterResolutionException.class, this::invokeMethod);
+		ParameterResolutionException caught = assertThrows(ParameterResolutionException.class,
+			this::resolveMethodParameters);
 
 		assertSame(cause, caught.getCause(), () -> "cause should be present");
 		assertThat(caught.getMessage())//
@@ -268,7 +274,8 @@ class ExecutableInvokerTests {
 		ParameterResolutionException cause = new ParameterResolutionException("custom message");
 		throwDuringParameterResolution(cause);
 
-		ParameterResolutionException caught = assertThrows(ParameterResolutionException.class, this::invokeMethod);
+		ParameterResolutionException caught = assertThrows(ParameterResolutionException.class,
+			this::resolveMethodParameters);
 
 		assertSame(cause, caught);
 	}
@@ -315,25 +322,23 @@ class ExecutableInvokerTests {
 		}
 	}
 
-	private ExecutableInvoker newInvoker() {
-		return new ExecutableInvoker();
-	}
-
-	private void invokeMethod() {
-		newInvoker().invoke(this.method, this.instance, this.extensionContext, this.extensionRegistry,
-			passthroughInterceptor());
+	private <T> Object[] resolveConstructorParameters(Class<T> clazz, Object outerInstance) {
+		Constructor<T> constructor = ReflectionUtils.getDeclaredConstructor(clazz);
+		return ParameterResolutionUtils.resolveParameters(constructor, Optional.empty(),
+			Optional.ofNullable(outerInstance), extensionContext, extensionRegistry);
 	}
 
-	static <E extends Executable, T> ReflectiveInterceptorCall<E, T> passthroughInterceptor() {
-		return (interceptor, invocation, invocationContext, extensionContext) -> invocation.proceed();
+	private Object[] resolveMethodParameters() {
+		return ParameterResolutionUtils.resolveParameters(this.method, Optional.of(this.instance),
+			this.extensionContext, this.extensionRegistry);
 	}
 
 	// -------------------------------------------------------------------------
 
 	static class ArgumentRecordingParameterResolver implements ParameterResolver {
 
-		Arguments supportsArguments;
-		Arguments resolveArguments;
+		ArgumentRecordingParameterResolver.Arguments supportsArguments;
+		ArgumentRecordingParameterResolver.Arguments resolveArguments;
 
 		static class Arguments {
 
@@ -348,13 +353,13 @@ class ExecutableInvokerTests {
 
 		@Override
 		public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
-			supportsArguments = new Arguments(parameterContext, extensionContext);
+			supportsArguments = new ArgumentRecordingParameterResolver.Arguments(parameterContext, extensionContext);
 			return true;
 		}
 
 		@Override
 		public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
-			resolveArguments = new Arguments(parameterContext, extensionContext);
+			resolveArguments = new ArgumentRecordingParameterResolver.Arguments(parameterContext, extensionContext);
 			return null;
 		}
 	}
@@ -399,6 +404,7 @@ class ExecutableInvokerTests {
 		}
 	}
 
+	@SuppressWarnings("unused")
 	interface MethodSource {
 
 		void noParameter();
@@ -410,7 +416,7 @@ class ExecutableInvokerTests {
 		void multipleParameters(String first, Integer second, Double third);
 	}
 
-	private static class StringParameterResolver implements ParameterResolver {
+	static class StringParameterResolver implements ParameterResolver {
 
 		@Override
 		public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
@@ -423,7 +429,7 @@ class ExecutableInvokerTests {
 		}
 	}
 
-	private static class NumberParameterResolver implements ParameterResolver {
+	static class NumberParameterResolver implements ParameterResolver {
 
 		@Override
 		public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
@@ -436,7 +442,7 @@ class ExecutableInvokerTests {
 		}
 	}
 
-	private static class ConstructorInjectionTestCase {
+	static class ConstructorInjectionTestCase {
 
 		final String str;
 
diff --git a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestExtensionTests.java b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestExtensionTests.java
index 53f49adee..a02039e1a 100644
--- a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestExtensionTests.java
+++ b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestExtensionTests.java
@@ -30,6 +30,7 @@ import java.util.stream.Stream;
 
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.TestInstance.Lifecycle;
+import org.junit.jupiter.api.extension.ExecutableInvoker;
 import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.api.extension.TestInstances;
 import org.junit.jupiter.api.parallel.ExecutionMode;
@@ -273,6 +274,11 @@ class ParameterizedTestExtensionTests {
 			public ExecutionMode getExecutionMode() {
 				return ExecutionMode.SAME_THREAD;
 			}
+
+			@Override
+			public ExecutableInvoker getExecutableInvoker() {
+				return null;
+			}
 		};
 	}
 
