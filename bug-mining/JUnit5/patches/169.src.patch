diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/ScriptExecutionCondition.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/ScriptExecutionCondition.java
index 45f24ad66..1346004da 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/ScriptExecutionCondition.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/ScriptExecutionCondition.java
@@ -10,7 +10,6 @@
 
 package org.junit.jupiter.engine.extension;
 
-import static org.junit.jupiter.api.extension.ConditionEvaluationResult.disabled;
 import static org.junit.jupiter.api.extension.ConditionEvaluationResult.enabled;
 import static org.junit.platform.commons.util.AnnotationUtils.findAnnotation;
 
@@ -19,20 +18,13 @@ import java.util.ArrayList;
 import java.util.List;
 import java.util.Optional;
 
-import javax.script.Bindings;
-import javax.script.ScriptException;
-import javax.script.SimpleBindings;
-
 import org.junit.jupiter.api.condition.DisabledIf;
 import org.junit.jupiter.api.condition.EnabledIf;
 import org.junit.jupiter.api.extension.ConditionEvaluationResult;
 import org.junit.jupiter.api.extension.ExecutionCondition;
 import org.junit.jupiter.api.extension.ExtensionContext;
-import org.junit.jupiter.api.extension.ExtensionContext.Namespace;
 import org.junit.jupiter.api.extension.ScriptEvaluationException;
 import org.junit.jupiter.engine.script.Script;
-import org.junit.jupiter.engine.script.ScriptAccessor;
-import org.junit.jupiter.engine.script.ScriptExecutionManager;
 
 /**
  * {@link ExecutionCondition} that supports the {@link DisabledIf} and {@link EnabledIf} annotation.
@@ -48,9 +40,19 @@ class ScriptExecutionCondition implements ExecutionCondition {
 
 	private static final ConditionEvaluationResult ENABLED_NO_ANNOTATION = enabled("Annotation not present");
 
-	private static final ConditionEvaluationResult ENABLED_ALL = enabled("All results are enabled");
+	private static final String EVALUATOR_CLASS_NAME = "org.junit.jupiter.engine.extension.ScriptExecutionEvaluator";
+
+	private final Evaluator evaluator;
+
+	// Used by the ExtensionRegistry.
+	ScriptExecutionCondition() {
+		this(EVALUATOR_CLASS_NAME);
+	}
 
-	private static final Namespace NAMESPACE = Namespace.create(ScriptExecutionCondition.class);
+	// Used by tests.
+	ScriptExecutionCondition(String evaluatorImplementationName) {
+		this.evaluator = Evaluator.forName(evaluatorImplementationName);
+	}
 
 	@Override
 	public ConditionEvaluationResult evaluateExecutionCondition(ExtensionContext context) {
@@ -62,115 +64,116 @@ class ScriptExecutionCondition implements ExecutionCondition {
 		AnnotatedElement annotatedElement = element.get();
 
 		// Always try to create script instances.
-		List<Script> scripts = new ArrayList<>();
-		createDisabledIfScript(annotatedElement).ifPresent(scripts::add);
-		createEnabledIfScript(annotatedElement).ifPresent(scripts::add);
+		Script disabledScript = createDisabledIfScriptOrNull(annotatedElement);
+		Script enabledScript = createEnabledIfScriptOrNull(annotatedElement);
 
 		// If no scripts are created, no annotation of interest is attached to the underlying element.
-		if (scripts.isEmpty()) {
+		if (disabledScript == null && enabledScript == null) {
 			return ENABLED_NO_ANNOTATION;
 		}
 
-		// Delegate actual script execution to the globally cached manager instance.
-		ScriptExecutionManager scriptExecutionManager = getScriptExecutionManager(context);
-		Bindings bindings = createBindings(context);
-		for (Script script : scripts) {
-			ConditionEvaluationResult result = evaluate(scriptExecutionManager, script, bindings);
-			// Report the first result that is disabled, preventing evaluation of remaining scripts.
-			if (result.isDisabled()) {
-				return result;
-			}
+		// Prepare list with single or two script elements.
+		List<Script> scripts = new ArrayList<>();
+		if (disabledScript != null) {
+			scripts.add(disabledScript);
+		}
+		if (enabledScript != null) {
+			scripts.add(enabledScript);
 		}
 
-		return ENABLED_ALL;
+		// Let the evaluator do its work.
+		return evaluator.evaluate(context, scripts);
 	}
 
-	private Optional<Script> createDisabledIfScript(AnnotatedElement annotatedElement) {
+	private Script createDisabledIfScriptOrNull(AnnotatedElement annotatedElement) {
 		Optional<DisabledIf> disabled = findAnnotation(annotatedElement, DisabledIf.class);
 		if (!disabled.isPresent()) {
-			return Optional.empty();
+			return null;
 		}
 		DisabledIf annotation = disabled.get();
 		String source = createSource(annotation.value());
-		Script script = new Script(annotation, annotation.engine(), source, annotation.reason());
-		return Optional.of(script);
+		return new Script(annotation, annotation.engine(), source, annotation.reason());
 	}
 
-	private Optional<Script> createEnabledIfScript(AnnotatedElement annotatedElement) {
+	private Script createEnabledIfScriptOrNull(AnnotatedElement annotatedElement) {
 		Optional<EnabledIf> enabled = findAnnotation(annotatedElement, EnabledIf.class);
 		if (!enabled.isPresent()) {
-			return Optional.empty();
+			return null;
 		}
 		EnabledIf annotation = enabled.get();
 		String source = createSource(annotation.value());
-		Script script = new Script(annotation, annotation.engine(), source, annotation.reason());
-		return Optional.of(script);
+		return new Script(annotation, annotation.engine(), source, annotation.reason());
 	}
 
 	private String createSource(String[] lines) {
 		return String.join(System.lineSeparator(), lines);
 	}
 
-	private ScriptExecutionManager getScriptExecutionManager(ExtensionContext context) {
-		return context.getRoot().getStore(NAMESPACE).getOrComputeIfAbsent(ScriptExecutionManager.class);
-	}
-
-	private Bindings createBindings(ExtensionContext context) {
-		ScriptAccessor configurationParameterAccessor = new ScriptAccessor.ConfigurationParameterAccessor(context);
-		Bindings bindings = new SimpleBindings();
-		bindings.put(Script.BIND_JUNIT_TAGS, context.getTags());
-		bindings.put(Script.BIND_JUNIT_UNIQUE_ID, context.getUniqueId());
-		bindings.put(Script.BIND_JUNIT_DISPLAY_NAME, context.getDisplayName());
-		bindings.put(Script.BIND_JUNIT_CONFIGURATION_PARAMETER, configurationParameterAccessor);
-		return bindings;
-	}
-
-	ConditionEvaluationResult evaluate(ScriptExecutionManager manager, Script script, Bindings bindings) {
-		if (script == null) {
-			return null;
-		}
-		try {
-			Object result = manager.evaluate(script, bindings);
-			return computeConditionEvaluationResult(script, result);
+	/**
+	 * Evaluates scripts and returns a conditional evaluation result.
+	 */
+	interface Evaluator {
+
+		ConditionEvaluationResult evaluate(ExtensionContext context, List<Script> scripts);
+
+		/**
+		 * Create evaluator via reflection to hide the `javax.script` dependency.
+		 *
+		 * <p>This method may return a {@link ThrowingEvaluator} instance on JREs that
+		 * don't provide the "javax.script" package at all. It also returns such an
+		 * instance on JREs that are launched with an active module system using
+		 * insufficient module graphs, i.e. the application does not read
+		 * {@code java.scripting} module.
+		 *
+		 * @see Class#forName(String)
+		 */
+		static Evaluator forName(String name) {
+			// Assert that "javax.script.ScriptEngine" is loadable via basic reflection.
+			return forName("javax.script.ScriptEngine", name);
 		}
-		catch (ScriptException e) {
-			throw new ScriptEvaluationException("Script evaluation failed for: " + script.getAnnotationAsString(), e);
-		}
-	}
 
-	ConditionEvaluationResult computeConditionEvaluationResult(Script script, Object result) {
-		// Treat "null" result as an error.
-		if (result == null) {
-			throw new ScriptEvaluationException("Script returned `null`: " + script.getAnnotationAsString());
+		static Evaluator forName(String nameOfScriptEngine, String name) {
+			// Assert that precondition name is loadable via basic reflection.
+			try {
+				Class.forName(nameOfScriptEngine);
+			}
+			catch (Throwable cause) {
+				String message = "Class `" + nameOfScriptEngine + "` is not loadable, " //
+						+ "script-based test execution is disabled. " //
+						+ "If the originating cause is a `NoClassDefFoundError: javax/script/...` and " //
+						+ "the underlying runtime environment is executed with an activated module system " //
+						+ "(aka Jigsaw or JPMS) you need to add the `java.scripting` module to the " //
+						+ "root modules via `--add-modules ...,java.scripting`";
+				return new ThrowingEvaluator(message, cause);
+			}
+			// Now create the evaluator instance specified by its class name.
+			try {
+				return (Evaluator) Class.forName(name).getDeclaredConstructor().newInstance();
+			}
+			catch (ReflectiveOperationException cause) {
+				String message = "Creating instance of class `" + name + "` failed," //
+						+ "script-based test execution is disabled.";
+				return new ThrowingEvaluator(message, cause);
+			}
 		}
 
-		// Trivial case: script returned a custom ConditionEvaluationResult instance.
-		if (result instanceof ConditionEvaluationResult) {
-			return (ConditionEvaluationResult) result;
-		}
+	}
 
-		String resultAsString = String.valueOf(result);
-		String reason = script.toReasonString(resultAsString);
+	/**
+	 * Evaluator implementation that always throws an {@link ScriptEvaluationException}.
+	 */
+	static class ThrowingEvaluator implements Evaluator {
 
-		// Cast or parse result to a boolean value.
-		boolean isTrue;
-		if (result instanceof Boolean) {
-			isTrue = (Boolean) result;
-		}
-		else {
-			isTrue = Boolean.parseBoolean(resultAsString);
-		}
+		final ScriptEvaluationException exception;
 
-		// Flip enabled/disabled result based on the associated annotation type.
-		if (script.getAnnotationType() == EnabledIf.class) {
-			return isTrue ? enabled(reason) : disabled(reason);
-		}
-		if (script.getAnnotationType() == DisabledIf.class) {
-			return isTrue ? disabled(reason) : enabled(reason);
+		ThrowingEvaluator(String message, Throwable cause) {
+			this.exception = new ScriptEvaluationException(message, cause);
 		}
 
-		// Still here? Not so good.
-		throw new ScriptEvaluationException("Unsupported annotation type: " + script.getAnnotationType());
+		@Override
+		public ConditionEvaluationResult evaluate(ExtensionContext context, List<Script> scripts) {
+			throw exception;
+		}
 	}
 
 }
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/ScriptExecutionEvaluator.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/ScriptExecutionEvaluator.java
new file mode 100644
index 000000000..c1aeb26a6
--- /dev/null
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/ScriptExecutionEvaluator.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright 2015-2018 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * http://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.engine.extension;
+
+import static org.junit.jupiter.api.extension.ConditionEvaluationResult.disabled;
+import static org.junit.jupiter.api.extension.ConditionEvaluationResult.enabled;
+
+import java.util.List;
+
+import javax.script.Bindings;
+import javax.script.ScriptException;
+import javax.script.SimpleBindings;
+
+import org.junit.jupiter.api.condition.DisabledIf;
+import org.junit.jupiter.api.condition.EnabledIf;
+import org.junit.jupiter.api.extension.ConditionEvaluationResult;
+import org.junit.jupiter.api.extension.ExtensionContext;
+import org.junit.jupiter.api.extension.ScriptEvaluationException;
+import org.junit.jupiter.engine.script.Script;
+import org.junit.jupiter.engine.script.ScriptAccessor;
+import org.junit.jupiter.engine.script.ScriptExecutionManager;
+
+/**
+ * Encapsulates javax.script-related evaluation work.
+ *
+ * <p>This class is instantiated via reflection.
+ */
+class ScriptExecutionEvaluator implements ScriptExecutionCondition.Evaluator {
+
+	private static final ConditionEvaluationResult ENABLED_ALL = enabled("All results are enabled");
+
+	private final ScriptExecutionManager scriptExecutionManager = new ScriptExecutionManager();
+
+	@Override
+	public ConditionEvaluationResult evaluate(ExtensionContext context, List<Script> scripts) {
+		Bindings bindings = createBindings(context);
+		for (Script script : scripts) {
+			ConditionEvaluationResult result = evaluate(scriptExecutionManager, script, bindings);
+			// Report the first result that is disabled, preventing evaluation of remaining scripts.
+			if (result.isDisabled()) {
+				return result;
+			}
+		}
+
+		return ENABLED_ALL;
+	}
+
+	private Bindings createBindings(ExtensionContext context) {
+		ScriptAccessor configurationParameterAccessor = new ScriptAccessor.ConfigurationParameterAccessor(context);
+		Bindings bindings = new SimpleBindings();
+		bindings.put(Script.BIND_JUNIT_TAGS, context.getTags());
+		bindings.put(Script.BIND_JUNIT_UNIQUE_ID, context.getUniqueId());
+		bindings.put(Script.BIND_JUNIT_DISPLAY_NAME, context.getDisplayName());
+		bindings.put(Script.BIND_JUNIT_CONFIGURATION_PARAMETER, configurationParameterAccessor);
+		return bindings;
+	}
+
+	ConditionEvaluationResult evaluate(ScriptExecutionManager manager, Script script, Bindings bindings) {
+		if (script == null) {
+			return null;
+		}
+		try {
+			Object result = manager.evaluate(script, bindings);
+			return computeConditionEvaluationResult(script, result);
+		}
+		catch (ScriptException e) {
+			throw new ScriptEvaluationException("Script evaluation failed for: " + script.getAnnotationAsString(), e);
+		}
+	}
+
+	ConditionEvaluationResult computeConditionEvaluationResult(Script script, Object result) {
+		// Treat "null" result as an error.
+		if (result == null) {
+			throw new ScriptEvaluationException("Script returned `null`: " + script.getAnnotationAsString());
+		}
+
+		// Trivial case: script returned a custom ConditionEvaluationResult instance.
+		if (result instanceof ConditionEvaluationResult) {
+			return (ConditionEvaluationResult) result;
+		}
+
+		String resultAsString = String.valueOf(result);
+		String reason = script.toReasonString(resultAsString);
+
+		// Cast or parse result to a boolean value.
+		boolean isTrue;
+		if (result instanceof Boolean) {
+			isTrue = (Boolean) result;
+		}
+		else {
+			isTrue = Boolean.parseBoolean(resultAsString);
+		}
+
+		// Flip enabled/disabled result based on the associated annotation type.
+		if (script.getAnnotationType() == EnabledIf.class) {
+			return isTrue ? enabled(reason) : disabled(reason);
+		}
+		if (script.getAnnotationType() == DisabledIf.class) {
+			return isTrue ? disabled(reason) : enabled(reason);
+		}
+
+		// Still here? Not so good.
+		throw new ScriptEvaluationException("Unsupported annotation type: " + script.getAnnotationType());
+	}
+
+}
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/ScriptExecutionConditionTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/ScriptExecutionConditionTests.java
index f206ccd4c..10d5de141 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/ScriptExecutionConditionTests.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/ScriptExecutionConditionTests.java
@@ -11,14 +11,12 @@
 package org.junit.jupiter.engine.extension;
 
 import static org.assertj.core.api.Assertions.allOf;
-import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.jupiter.api.Assertions.assertAll;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertFalse;
 import static org.junit.jupiter.api.Assertions.assertThrows;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 import static org.junit.jupiter.api.Assertions.fail;
-import static org.junit.jupiter.api.DynamicTest.dynamicTest;
 import static org.junit.platform.engine.discovery.DiscoverySelectors.selectClass;
 import static org.junit.platform.engine.test.event.ExecutionEventConditions.assertRecordedExecutionEventsContainsExactly;
 import static org.junit.platform.engine.test.event.ExecutionEventConditions.event;
@@ -28,27 +26,21 @@ import static org.junit.platform.engine.test.event.TestExecutionResultConditions
 import static org.junit.platform.engine.test.event.TestExecutionResultConditions.message;
 import static org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder.request;
 
-import java.lang.reflect.Type;
-import java.util.Collections;
-import java.util.stream.Stream;
+import java.lang.reflect.AnnotatedElement;
+import java.util.Optional;
 
-import javax.script.Bindings;
-import javax.script.SimpleBindings;
-
-import org.junit.jupiter.api.DynamicTest;
 import org.junit.jupiter.api.Test;
-import org.junit.jupiter.api.TestFactory;
 import org.junit.jupiter.api.TestInfo;
 import org.junit.jupiter.api.condition.DisabledIf;
 import org.junit.jupiter.api.condition.EnabledIf;
 import org.junit.jupiter.api.extension.ConditionEvaluationResult;
+import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.api.extension.ScriptEvaluationException;
 import org.junit.jupiter.engine.AbstractJupiterTestEngineTests;
-import org.junit.jupiter.engine.script.Script;
-import org.junit.jupiter.engine.script.ScriptExecutionManager;
 import org.junit.platform.commons.JUnitException;
 import org.junit.platform.engine.test.event.ExecutionEventRecorder;
 import org.junit.platform.launcher.LauncherDiscoveryRequest;
+import org.mockito.Mockito;
 
 /**
  * Unit tests for {@link ScriptExecutionCondition}.
@@ -57,58 +49,6 @@ import org.junit.platform.launcher.LauncherDiscoveryRequest;
  */
 class ScriptExecutionConditionTests extends AbstractJupiterTestEngineTests {
 
-	private final Bindings bindings = createDefaultContextBindings();
-	private final ScriptExecutionCondition condition = new ScriptExecutionCondition();
-	private final ScriptExecutionManager manager = new ScriptExecutionManager();
-
-	@Test
-	void computeConditionEvaluationResultWithDefaultReasonMessage() {
-		Script script = script(EnabledIf.class, "?");
-		String actual = condition.computeConditionEvaluationResult(script, "!").getReason().orElseThrow(Error::new);
-		assertEquals("Script `?` evaluated to: !", actual);
-	}
-
-	@TestFactory
-	Stream<DynamicTest> computeConditionEvaluationResultFailsForUnsupportedAnnotationType() {
-		return Stream.of(Override.class, Deprecated.class, Object.class) //
-				.map(type -> dynamicTest("computationFailsFor(" + type + ")", //
-					() -> computeConditionEvaluationResultFailsForUnsupportedAnnotationType(type)));
-	}
-
-	private void computeConditionEvaluationResultFailsForUnsupportedAnnotationType(Type type) {
-		Script script = new Script(type, "annotation", "engine", "source", "reason");
-		Exception e = assertThrows(ScriptEvaluationException.class,
-			() -> condition.computeConditionEvaluationResult(script, "!"));
-		String expected = "Unsupported annotation type: " + type;
-		String actual = e.getMessage();
-		assertEquals(expected, actual);
-	}
-
-	@Test
-	void defaultConditionEvaluationResultProperties() {
-		Script script = script(EnabledIf.class, "true");
-		ConditionEvaluationResult result = condition.evaluate(manager, script, bindings);
-		assertFalse(result.isDisabled());
-		assertThat(result.toString()).contains("ConditionEvaluationResult", "enabled", "true", "reason");
-	}
-
-	@Test
-	void getJUnitConfigurationParameterWithJavaScript() {
-		Script script = script(EnabledIf.class, "junitConfigurationParameter.get('XXX')");
-		Exception exception = assertThrows(ScriptEvaluationException.class,
-			() -> condition.evaluate(manager, script, bindings));
-		assertThat(exception.getMessage()).contains("Script returned `null`");
-	}
-
-	@Test
-	void getJUnitConfigurationParameterWithJavaScriptAndCheckForNull() {
-		Script script = script(EnabledIf.class, "junitConfigurationParameter.get('XXX') != null");
-		ConditionEvaluationResult result = condition.evaluate(manager, script, bindings);
-		assertTrue(result.isDisabled());
-		String actual = result.getReason().orElseThrow(() -> new AssertionError("causeless"));
-		assertEquals("Script `junitConfigurationParameter.get('XXX') != null` evaluated to: false", actual);
-	}
-
 	@Test
 	void executeSimpleTestCases() {
 		LauncherDiscoveryRequest request = request().selectors(selectClass(SimpleTestCases.class)).build();
@@ -143,23 +83,59 @@ class ScriptExecutionConditionTests extends AbstractJupiterTestEngineTests {
 		assertEquals("Script `{source}` evaluated to: {result}", d.reason());
 	}
 
-	private Script script(Type type, String... lines) {
-		return new Script( //
-			type, //
-			"Mock for " + type, //
-			Script.DEFAULT_SCRIPT_ENGINE_NAME, //
-			String.join("\n", lines), //
-			Script.DEFAULT_SCRIPT_REASON_PATTERN //
-		);
+	@Test
+	void throwingEvaluatorExceptionMessage() {
+		String message = "Mock for message";
+		ReflectiveOperationException cause = new ReflectiveOperationException("Mock for ReflectiveOperationException");
+		ScriptExecutionCondition.Evaluator evaluator = new ScriptExecutionCondition.ThrowingEvaluator(message, cause);
+		Exception e = assertThrows(ScriptEvaluationException.class, () -> evaluator.evaluate(null, null));
+		assertEquals(message, e.getMessage());
+	}
+
+	@Test
+	void enabledDueToAnnotatedElementNotPresent() {
+		ScriptExecutionCondition condition = new ScriptExecutionCondition();
+		ExtensionContext context = Mockito.mock(ExtensionContext.class);
+		ConditionEvaluationResult result = condition.evaluateExecutionCondition(context);
+		assertFalse(result.isDisabled());
+		assertTrue(result.getReason().isPresent());
+		result.getReason().ifPresent(reason -> assertEquals("AnnotatedElement not present", reason));
 	}
 
-	private Bindings createDefaultContextBindings() {
-		Bindings bindings = new SimpleBindings();
-		bindings.put(Script.BIND_JUNIT_TAGS, Collections.emptySet());
-		bindings.put(Script.BIND_JUNIT_UNIQUE_ID, "Mock for UniqueId");
-		bindings.put(Script.BIND_JUNIT_DISPLAY_NAME, "Mock for DisplayName");
-		bindings.put(Script.BIND_JUNIT_CONFIGURATION_PARAMETER, Collections.emptyMap());
-		return bindings;
+	@Test
+	void enabledDueToAnnotationNotPresent() {
+		ScriptExecutionCondition condition = new ScriptExecutionCondition();
+		ExtensionContext context = Mockito.mock(ExtensionContext.class);
+		Optional<AnnotatedElement> optionalElement = Optional.of(ScriptExecutionConditionTests.class);
+		Mockito.when(context.getElement()).thenReturn(optionalElement);
+		ConditionEvaluationResult result = condition.evaluateExecutionCondition(context);
+		assertFalse(result.isDisabled());
+		assertTrue(result.getReason().isPresent());
+		result.getReason().ifPresent(reason -> assertEquals("Annotation not present", reason));
+	}
+
+	@Test
+	void throwingEvaluatorIsCreatedWhenScriptEngineIsNotAvailable() {
+		String nameOfScriptEngine = "javax.script.DoesNotExist";
+		String name = "org.junit.jupiter.engine.extension.ScriptExecutionEvaluator";
+		ScriptExecutionCondition.Evaluator evaluator = ScriptExecutionCondition.Evaluator.forName(nameOfScriptEngine,
+			name);
+		Exception e = assertThrows(Exception.class, () -> evaluator.evaluate(null, null));
+		String message = e.getMessage();
+		System.out.println(message);
+		assertTrue(message.startsWith("Class `" + nameOfScriptEngine + "` is not loadable"));
+		assertTrue(message.endsWith("`--add-modules ...,java.scripting`"));
+	}
+
+	@Test
+	void throwingEvaluatorIsCreatedWhenDefaultEvaluatorClassNameIsIllegal() throws ReflectiveOperationException {
+		String name = "illegal class name";
+		ScriptExecutionCondition condition = new ScriptExecutionCondition(name);
+		ExtensionContext context = Mockito.mock(ExtensionContext.class);
+		AnnotatedElement element = SimpleTestCases.class.getDeclaredMethod("testIsEnabled");
+		Mockito.when(context.getElement()).thenReturn(Optional.of(element));
+		Exception e = assertThrows(Exception.class, () -> condition.evaluateExecutionCondition(context));
+		assertTrue(e.getMessage().startsWith("Creating instance of class `" + name + "` failed"));
 	}
 
 	static class SimpleTestCases {
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/ScriptExecutionEvaluatorTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/ScriptExecutionEvaluatorTests.java
new file mode 100644
index 000000000..08b5fa420
--- /dev/null
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/ScriptExecutionEvaluatorTests.java
@@ -0,0 +1,125 @@
+/*
+ * Copyright 2015-2018 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * http://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.engine.extension;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertSame;
+import static org.junit.jupiter.api.Assertions.assertThrows;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.junit.jupiter.api.DynamicTest.dynamicTest;
+
+import java.lang.reflect.Type;
+import java.util.Collections;
+import java.util.stream.Stream;
+
+import javax.script.Bindings;
+import javax.script.SimpleBindings;
+
+import org.junit.jupiter.api.DynamicTest;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.TestFactory;
+import org.junit.jupiter.api.condition.DisabledIf;
+import org.junit.jupiter.api.condition.EnabledIf;
+import org.junit.jupiter.api.extension.ConditionEvaluationResult;
+import org.junit.jupiter.api.extension.ScriptEvaluationException;
+import org.junit.jupiter.engine.AbstractJupiterTestEngineTests;
+import org.junit.jupiter.engine.script.Script;
+import org.junit.jupiter.engine.script.ScriptExecutionManager;
+
+/**
+ * Unit tests for {@link ScriptExecutionEvaluator}.
+ *
+ * @since 5.1
+ */
+class ScriptExecutionEvaluatorTests extends AbstractJupiterTestEngineTests {
+
+	private final Bindings bindings = createDefaultContextBindings();
+	private final ScriptExecutionManager manager = new ScriptExecutionManager();
+	private final ScriptExecutionEvaluator evaluator = new ScriptExecutionEvaluator();
+
+	@Test
+	void nullAsScriptReturnsNullAsResult() {
+		assertSame(null, evaluate(null));
+	}
+
+	@Test
+	void computeConditionEvaluationResultWithDefaultReasonMessage() {
+		Script script = script(EnabledIf.class, "?");
+		String actual = evaluator.computeConditionEvaluationResult(script, "!").getReason().orElseThrow(Error::new);
+		assertEquals("Script `?` evaluated to: !", actual);
+	}
+
+	@TestFactory
+	Stream<DynamicTest> computeConditionEvaluationResultFailsForUnsupportedAnnotationType() {
+		return Stream.of(Override.class, Deprecated.class, Object.class) //
+				.map(type -> dynamicTest("computationFailsFor(" + type + ")", //
+					() -> computeConditionEvaluationResultFailsForUnsupportedAnnotationType(type)));
+	}
+
+	private void computeConditionEvaluationResultFailsForUnsupportedAnnotationType(Type type) {
+		Script script = new Script(type, "annotation", "engine", "source", "reason");
+		Exception e = assertThrows(ScriptEvaluationException.class,
+			() -> evaluator.computeConditionEvaluationResult(script, "!"));
+		String expected = "Unsupported annotation type: " + type;
+		String actual = e.getMessage();
+		assertEquals(expected, actual);
+	}
+
+	@Test
+	void defaultConditionEvaluationResultProperties() {
+		Script script = script(EnabledIf.class, "true");
+		ConditionEvaluationResult result = evaluate(script);
+		assertFalse(result.isDisabled());
+		assertThat(result.toString()).contains("ConditionEvaluationResult", "enabled", "true", "reason");
+	}
+
+	@Test
+	void getJUnitConfigurationParameterWithJavaScript() {
+		Script script = script(DisabledIf.class, "junitConfigurationParameter.get('XXX')");
+		Exception exception = assertThrows(ScriptEvaluationException.class, () -> evaluate(script));
+		assertThat(exception.getMessage()).contains("Script returned `null`");
+	}
+
+	@Test
+	void getJUnitConfigurationParameterWithJavaScriptAndCheckForNull() {
+		Script script = script(DisabledIf.class, "junitConfigurationParameter.get('XXX') == null");
+		ConditionEvaluationResult result = evaluate(script);
+		assertTrue(result.isDisabled());
+		String actual = result.getReason().orElseThrow(() -> new AssertionError("causeless"));
+		assertEquals("Script `junitConfigurationParameter.get('XXX') == null` evaluated to: true", actual);
+	}
+
+	private ConditionEvaluationResult evaluate(Script script) {
+		return evaluator.evaluate(manager, script, bindings);
+	}
+
+	private Script script(Type type, String... lines) {
+		return new Script( //
+			type, //
+			"Mock for " + type, //
+			Script.DEFAULT_SCRIPT_ENGINE_NAME, //
+			String.join("\n", lines), //
+			Script.DEFAULT_SCRIPT_REASON_PATTERN //
+		);
+	}
+
+	private Bindings createDefaultContextBindings() {
+		Bindings bindings = new SimpleBindings();
+		bindings.put(Script.BIND_JUNIT_TAGS, Collections.emptySet());
+		bindings.put(Script.BIND_JUNIT_UNIQUE_ID, "Mock for UniqueId");
+		bindings.put(Script.BIND_JUNIT_DISPLAY_NAME, "Mock for DisplayName");
+		bindings.put(Script.BIND_JUNIT_CONFIGURATION_PARAMETER, Collections.emptyMap());
+		return bindings;
+	}
+
+}
