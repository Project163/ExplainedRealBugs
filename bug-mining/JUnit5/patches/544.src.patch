diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.10.0-M1.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.10.0-M1.adoc
index 859021071..14d07a5f0 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.10.0-M1.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.10.0-M1.adoc
@@ -30,6 +30,12 @@ repository on GitHub.
   `@Suite` and related annotations, and others.
 * All utility methods in `ReflectionSupport` that return a `List` now have counterparts
   which return a `Stream`.
+* `ReflectionSupport.findMethod(Class<?>, String, String)` now uses the `ClassLoader` of
+  the supplied `Class` to load parameter types instead of using the _default_
+  `ClassLoader`. This allows parameter types to be resolved in non-standard `ClassLoader`
+  arrangements (such as OSGi). Consequently,
+  `DiscoverySelectors.selectMethod(Class<?>, String, String)` also now works properly in
+  non-standard `ClassLoader` arrangements.
 * For consistency with JUnit Jupiter lifecycle callbacks, listener method pairs for
   started/finished and opened/closed events are now invoked using "wrapping" semantics.
   This means that finished/closed event methods are invoked in reverse order compared to
diff --git a/junit-platform-commons/src/main/java/org/junit/platform/commons/support/ReflectionSupport.java b/junit-platform-commons/src/main/java/org/junit/platform/commons/support/ReflectionSupport.java
index dffe8ea50..6b6c98d3d 100644
--- a/junit-platform-commons/src/main/java/org/junit/platform/commons/support/ReflectionSupport.java
+++ b/junit-platform-commons/src/main/java/org/junit/platform/commons/support/ReflectionSupport.java
@@ -351,6 +351,11 @@ public final class ReflectionSupport {
 	 * interface and traversing up the type hierarchy until such a method is
 	 * found or the type hierarchy is exhausted.
 	 *
+	 * <p>As of JUnit Platform 1.10, this method uses the {@link ClassLoader} of
+	 * the supplied {@code clazz} to load parameter types instead of using the
+	 * <em>default</em> {@code ClassLoader}, which allows parameter types to be
+	 * resolved in different {@code ClassLoader} arrangements.
+	 *
 	 * <p>The algorithm does not search for methods in {@link java.lang.Object}.
 	 *
 	 * @param clazz the class or interface in which to find the method; never {@code null}
diff --git a/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java b/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java
index 71d51d534..c33f514f3 100644
--- a/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java
+++ b/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java
@@ -1375,8 +1375,13 @@ public final class ReflectionUtils {
 	}
 
 	private static Class<?> loadRequiredParameterType(Class<?> clazz, String methodName, String typeName) {
+		ClassLoader classLoader = clazz.getClassLoader();
+		if (classLoader == null) {
+			classLoader = ClassLoaderUtils.getDefaultClassLoader();
+		}
+
 		// @formatter:off
-		return tryToLoadClass(typeName)
+		return tryToLoadClass(typeName, classLoader)
 				.getOrThrow(cause -> new JUnitException(
 						String.format("Failed to load parameter type [%s] for method [%s] in class [%s].",
 								typeName, methodName, clazz.getName()), cause));
diff --git a/platform-tests/src/test/java/org/junit/platform/commons/util/ReflectionUtilsTests.java b/platform-tests/src/test/java/org/junit/platform/commons/util/ReflectionUtilsTests.java
index d667bce77..eac7ddf60 100644
--- a/platform-tests/src/test/java/org/junit/platform/commons/util/ReflectionUtilsTests.java
+++ b/platform-tests/src/test/java/org/junit/platform/commons/util/ReflectionUtilsTests.java
@@ -70,6 +70,7 @@ import org.junit.platform.commons.util.ReflectionUtilsTests.OuterClass.Recursive
 import org.junit.platform.commons.util.ReflectionUtilsTests.OuterClass.StaticNestedClass;
 import org.junit.platform.commons.util.ReflectionUtilsTests.OuterClass.StaticNestedSiblingClass;
 import org.junit.platform.commons.util.ReflectionUtilsTests.OuterClassImplementingInterface.InnerClassImplementingInterface;
+import org.junit.platform.commons.util.classes.CustomType;
 
 /**
  * Unit tests for {@link ReflectionUtils}.
@@ -1023,6 +1024,33 @@ class ReflectionUtilsTests {
 		assertFindMethodByParameterNames("methodWithMultidimensionalObjectArray", Double[][][][][].class);
 	}
 
+	/**
+	 * @since 5.10
+	 */
+	@Test
+	void findMethodByParameterNamesWithWithCustomTypeFromDifferentClassLoader() throws Exception {
+		var methodName = "customMethod";
+		var customTypeName = CustomType.class.getName();
+		var nestedTypeName = CustomType.NestedType.class.getName();
+
+		try (CustomTypeClassLoader customTypeClassLoader = new CustomTypeClassLoader()) {
+			var customType = customTypeClassLoader.loadClass(customTypeName);
+
+			var optional = findMethod(customType, methodName, nestedTypeName);
+			assertThat(optional).get().satisfies(method -> {
+				assertThat(method.getName()).isEqualTo(methodName);
+
+				var declaringClass = method.getDeclaringClass();
+				assertThat(declaringClass.getName()).isEqualTo(customTypeName);
+				assertThat(declaringClass).isNotEqualTo(CustomType.class);
+
+				var parameterTypes = method.getParameterTypes();
+				assertThat(parameterTypes).extracting(Class::getName).containsExactly(nestedTypeName);
+				assertThat(parameterTypes[0].getClass()).isNotEqualTo(CustomType.NestedType.class);
+			});
+		}
+	}
+
 	@Test
 	void findMethodByParameterNamesWithParameterizedMapParameter() throws Exception {
 		var methodName = "methodWithParameterizedMap";
@@ -1903,4 +1931,18 @@ class ReflectionUtilsTests {
 		}
 	}
 
+	private static class CustomTypeClassLoader extends URLClassLoader {
+
+		CustomTypeClassLoader() {
+			super(new URL[] { CustomTypeClassLoader.class.getProtectionDomain().getCodeSource().getLocation() },
+				getSystemClassLoader());
+		}
+
+		@Override
+		public Class<?> loadClass(String name) throws ClassNotFoundException {
+			return (name.startsWith(CustomType.class.getName()) ? findClass(name) : super.loadClass(name));
+		}
+
+	}
+
 }
diff --git a/platform-tests/src/test/java/org/junit/platform/commons/util/classes/CustomType.java b/platform-tests/src/test/java/org/junit/platform/commons/util/classes/CustomType.java
new file mode 100644
index 000000000..8a56cae42
--- /dev/null
+++ b/platform-tests/src/test/java/org/junit/platform/commons/util/classes/CustomType.java
@@ -0,0 +1,21 @@
+/*
+ * Copyright 2015-2023 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.platform.commons.util.classes;
+
+public class CustomType {
+
+	void customMethod(NestedType arg) {
+	}
+
+	public static class NestedType {
+	}
+
+}
