diff --git a/junit-platform-launcher/src/main/java/org/junit/platform/launcher/TagFilter.java b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/TagFilter.java
index 65c63b921..e3e273539 100644
--- a/junit-platform-launcher/src/main/java/org/junit/platform/launcher/TagFilter.java
+++ b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/TagFilter.java
@@ -16,9 +16,8 @@ import static org.junit.platform.commons.util.CollectionUtils.toUnmodifiableList
 
 import java.util.List;
 import java.util.Set;
-import java.util.function.BiPredicate;
-import java.util.function.Predicate;
-import java.util.stream.Stream;
+import java.util.function.Supplier;
+import java.util.stream.Collectors;
 
 import org.apiguardian.api.API;
 import org.junit.platform.commons.PreconditionViolationException;
@@ -86,7 +85,18 @@ public final class TagFilter {
 	 * @see TestTag#isValid(String)
 	 */
 	public static PostDiscoveryFilter includeTags(List<String> tagExpressions) throws PreconditionViolationException {
-		return includeMatching(tagExpressions, Stream::anyMatch);
+
+		return includeMatching(tagExpressions);
+	}
+
+	private static String inclusionReasonExpressionSatisfy(List<String> tagExpressions) {
+		return String.format("included because tags match expression(s): [%s]", formatToString(tagExpressions));
+	}
+
+	private static String exclusionReasonExpressionNotSatisfy(List<String> tagExpressions) {
+		return String.format("excluded because tags do not match tag expression(s): [%s]",
+			formatToString(tagExpressions));
+
 	}
 
 	/**
@@ -123,18 +133,49 @@ public final class TagFilter {
 	 * @see TestTag#isValid(String)
 	 */
 	public static PostDiscoveryFilter excludeTags(List<String> tagExpressions) throws PreconditionViolationException {
-		return includeMatching(tagExpressions, Stream::noneMatch);
+
+		return excludeMatching(tagExpressions);
+	}
+
+	private static String inclusionReasonExpressionNotSatisfy(List<String> tagExpressions) {
+		return String.format("Test included Because it does not satisfy expression(s): [%s]",
+			formatToString(tagExpressions));
+	}
+
+	private static String exclusionReasonExpressionSatisfy(List<String> tagExpressions) {
+		return String.format("Test excluded Because it satisfy expression(s): [%s]", formatToString(tagExpressions));
+	}
+
+	private static String formatToString(List<String> tagExpressions) {
+		return tagExpressions.stream().map(String::trim).sorted().collect(Collectors.joining(","));
+	}
+
+	private static PostDiscoveryFilter includeMatching(List<String> tagExpressions) {
+
+		Preconditions.notEmpty(tagExpressions, "list of tag expressions must not be null or empty");
+		Supplier<String> inclusionReason = () -> inclusionReasonExpressionSatisfy(tagExpressions);
+		Supplier<String> exclusionReason = () -> exclusionReasonExpressionNotSatisfy(tagExpressions);
+		List<TagExpression> parsedTagExpressions = parseAll(tagExpressions);
+		return descriptor -> {
+			Set<TestTag> tags = descriptor.getTags();
+			boolean included = parsedTagExpressions.stream().anyMatch(expression -> expression.evaluate(tags));
+
+			return FilterResult.includedIf(included, inclusionReason, exclusionReason);
+		};
 	}
 
-	private static PostDiscoveryFilter includeMatching(List<String> tagExpressions,
-			BiPredicate<Stream<TagExpression>, Predicate<TagExpression>> matcher) {
+	private static PostDiscoveryFilter excludeMatching(List<String> tagExpressions) {
 
 		Preconditions.notEmpty(tagExpressions, "list of tag expressions must not be null or empty");
+		Supplier<String> inclusionReason = () -> inclusionReasonExpressionNotSatisfy(tagExpressions);
+		Supplier<String> exclusionReason = () -> exclusionReasonExpressionSatisfy(tagExpressions);
+
 		List<TagExpression> parsedTagExpressions = parseAll(tagExpressions);
 		return descriptor -> {
 			Set<TestTag> tags = descriptor.getTags();
-			return FilterResult.includedIf(
-				matcher.test(parsedTagExpressions.stream(), expression -> expression.evaluate(tags)));
+			boolean included = parsedTagExpressions.stream().noneMatch(expression -> expression.evaluate(tags));
+
+			return FilterResult.includedIf(included, inclusionReason, exclusionReason);
 		};
 	}
 
diff --git a/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/Root.java b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/Root.java
index 622fcea2e..e008a80aa 100644
--- a/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/Root.java
+++ b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/Root.java
@@ -14,10 +14,17 @@ import static org.junit.platform.engine.Filter.composeFilters;
 
 import java.util.Collection;
 import java.util.LinkedHashMap;
+import java.util.LinkedList;
+import java.util.List;
 import java.util.Map;
+import java.util.Optional;
+import java.util.stream.Collectors;
 
+import org.junit.platform.commons.logging.Logger;
+import org.junit.platform.commons.logging.LoggerFactory;
 import org.junit.platform.engine.ConfigurationParameters;
 import org.junit.platform.engine.Filter;
+import org.junit.platform.engine.FilterResult;
 import org.junit.platform.engine.TestDescriptor;
 import org.junit.platform.engine.TestEngine;
 import org.junit.platform.launcher.LauncherDiscoveryRequest;
@@ -29,6 +36,7 @@ import org.junit.platform.launcher.LauncherDiscoveryRequest;
  * @since 1.0
  */
 class Root {
+	private static final Logger logger = LoggerFactory.getLogger(Root.class);
 
 	private final Map<TestEngine, TestDescriptor> testEngineDescriptors = new LinkedHashMap<>(4);
 	private final ConfigurationParameters configurationParameters;
@@ -62,12 +70,22 @@ class Root {
 
 	void applyPostDiscoveryFilters(LauncherDiscoveryRequest discoveryRequest) {
 		Filter<TestDescriptor> postDiscoveryFilter = composeFilters(discoveryRequest.getPostDiscoveryFilters());
+		Map<String, List<TestDescriptor>> excludedTestDescriptorsByReason = new LinkedHashMap<>();
 		TestDescriptor.Visitor removeExcludedTestDescriptors = descriptor -> {
-			if (!descriptor.isRoot() && isExcluded(descriptor, postDiscoveryFilter)) {
+			FilterResult filterResult = postDiscoveryFilter.apply(descriptor);
+			if (!descriptor.isRoot() && isExcluded(descriptor, filterResult)) {
+				populateExclusionReasonInMap(filterResult.getReason(), descriptor, excludedTestDescriptorsByReason);
 				descriptor.removeFromHierarchy();
 			}
 		};
 		acceptInAllTestEngines(removeExcludedTestDescriptors);
+		logTestDescriptorExclusionReasons(excludedTestDescriptorsByReason);
+	}
+
+	private void populateExclusionReasonInMap(Optional<String> reason, TestDescriptor testDescriptor,
+			Map<String, List<TestDescriptor>> excludedTestDescriptorsByReason) {
+		excludedTestDescriptorsByReason.computeIfAbsent(reason.orElse("Unknown"), list -> new LinkedList<>()).add(
+			testDescriptor);
 	}
 
 	/**
@@ -81,12 +99,25 @@ class Root {
 		acceptInAllTestEngines(TestDescriptor::prune);
 	}
 
-	private boolean isExcluded(TestDescriptor descriptor, Filter<TestDescriptor> postDiscoveryFilter) {
-		return descriptor.getChildren().isEmpty() && postDiscoveryFilter.apply(descriptor).excluded();
+	private boolean isExcluded(TestDescriptor descriptor, FilterResult filterResult) {
+
+		return descriptor.getChildren().isEmpty() && filterResult.excluded();
 	}
 
 	private void acceptInAllTestEngines(TestDescriptor.Visitor visitor) {
 		this.testEngineDescriptors.values().forEach(descriptor -> descriptor.accept(visitor));
 	}
 
+	private void logTestDescriptorExclusionReasons(Map<String, List<TestDescriptor>> excludedTestDescriptorsByReason) {
+		excludedTestDescriptorsByReason.forEach((exclusionReason, testDescriptors) -> {
+			String displayNames = testDescriptors.stream().map(TestDescriptor::getDisplayName).collect(
+				Collectors.joining(", "));
+			long containersCount = testDescriptors.stream().filter(TestDescriptor::isContainer).count();
+			long methodCount = testDescriptors.size() - containersCount;
+			logger.info(() -> String.format("%d containers and %d tests were %s", containersCount, methodCount,
+				exclusionReason));
+			logger.debug(() -> String.format("The following containers and tests were because %s: %s", exclusionReason,
+				displayNames));
+		});
+	}
 }
diff --git a/platform-tests/src/test/java/org/junit/platform/launcher/TagFilterTests.java b/platform-tests/src/test/java/org/junit/platform/launcher/TagFilterTests.java
index f43f8ce41..77a626015 100644
--- a/platform-tests/src/test/java/org/junit/platform/launcher/TagFilterTests.java
+++ b/platform-tests/src/test/java/org/junit/platform/launcher/TagFilterTests.java
@@ -23,6 +23,7 @@ import java.lang.annotation.RetentionPolicy;
 import org.junit.jupiter.api.Tag;
 import org.junit.jupiter.api.Test;
 import org.junit.platform.commons.PreconditionViolationException;
+import org.junit.platform.engine.FilterResult;
 import org.junit.platform.engine.TestDescriptor;
 import org.junit.platform.engine.UniqueId;
 import org.junit.platform.engine.support.descriptor.DemoClassTestDescriptor;
@@ -150,9 +151,20 @@ class TagFilterTests {
 		assertTrue(filter.apply(classWithTag1AndSurroundingWhitespace).included());
 		assertTrue(filter.apply(classWithBothTags).included());
 
+		assertReason(filter.apply(classWithTag1), "included because tags match expression(s): [tag1]");
+		assertReason(filter.apply(classWithTag1AndSurroundingWhitespace),
+			"included because tags match expression(s): [tag1]");
+		assertReason(filter.apply(classWithBothTags), "included because tags match expression(s): [tag1]");
+
 		assertTrue(filter.apply(classWithTag2).excluded());
 		assertTrue(filter.apply(classWithDifferentTags).excluded());
 		assertTrue(filter.apply(classWithNoTags).excluded());
+
+		assertReason(filter.apply(classWithTag2), "excluded because tags do not match tag expression(s): [tag1]");
+		assertReason(filter.apply(classWithDifferentTags),
+			"excluded because tags do not match tag expression(s): [tag1]");
+		assertReason(filter.apply(classWithNoTags), "excluded because tags do not match tag expression(s): [tag1]");
+
 	}
 
 	private void excludeSingleTag(PostDiscoveryFilter filter) {
@@ -160,9 +172,24 @@ class TagFilterTests {
 		assertTrue(filter.apply(classWithTag1AndSurroundingWhitespace).excluded());
 		assertTrue(filter.apply(classWithBothTags).excluded());
 
+		assertReason(filter.apply(classWithTag1), "Test excluded Because it satisfy expression(s): [tag1]");
+		assertReason(filter.apply(classWithTag1AndSurroundingWhitespace),
+			"Test excluded Because it satisfy expression(s): [tag1]");
+		assertReason(filter.apply(classWithBothTags), "Test excluded Because it satisfy expression(s): [tag1]");
+
 		assertTrue(filter.apply(classWithTag2).included());
 		assertTrue(filter.apply(classWithDifferentTags).included());
 		assertTrue(filter.apply(classWithNoTags).included());
+
+		assertReason(filter.apply(classWithTag2), "Test included Because it does not satisfy expression(s): [tag1]");
+		assertReason(filter.apply(classWithDifferentTags),
+			"Test included Because it does not satisfy expression(s): [tag1]");
+		assertReason(filter.apply(classWithNoTags), "Test included Because it does not satisfy expression(s): [tag1]");
+
+	}
+
+	private void assertReason(FilterResult filterResult, String expectedReason) {
+		assertThat(filterResult.getReason()).isPresent().contains(expectedReason);
 	}
 
 	// -------------------------------------------------------------------------
