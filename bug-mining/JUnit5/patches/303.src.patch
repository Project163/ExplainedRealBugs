diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassBasedTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassBasedTestDescriptor.java
index 01c0b6e36..c6b071d07 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassBasedTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassBasedTestDescriptor.java
@@ -54,7 +54,9 @@ import org.junit.jupiter.engine.execution.ExecutableInvoker.ReflectiveIntercepto
 import org.junit.jupiter.engine.execution.ExecutableInvoker.ReflectiveInterceptorCall.VoidMethodInterceptorCall;
 import org.junit.jupiter.engine.execution.JupiterEngineExecutionContext;
 import org.junit.jupiter.engine.execution.TestInstancesProvider;
+import org.junit.jupiter.engine.extension.ExtensionRegistrar;
 import org.junit.jupiter.engine.extension.ExtensionRegistry;
+import org.junit.jupiter.engine.extension.MutableExtensionRegistry;
 import org.junit.platform.commons.JUnitException;
 import org.junit.platform.commons.util.BlacklistedExceptions;
 import org.junit.platform.commons.util.ExceptionUtils;
@@ -135,7 +137,7 @@ public abstract class ClassBasedTestDescriptor extends JupiterTestDescriptor {
 
 	@Override
 	public JupiterEngineExecutionContext prepare(JupiterEngineExecutionContext context) {
-		ExtensionRegistry registry = populateNewExtensionRegistryFromExtendWithAnnotation(
+		MutableExtensionRegistry registry = populateNewExtensionRegistryFromExtendWithAnnotation(
 			context.getExtensionRegistry(), this.testClass);
 
 		// Register extensions from static fields here, at the class level but
@@ -159,7 +161,7 @@ public abstract class ClassBasedTestDescriptor extends JupiterTestDescriptor {
 
 		// @formatter:off
 		return context.extend()
-				.withTestInstancesProvider(testInstancesProvider(context, registry, extensionContext))
+				.withTestInstancesProvider(testInstancesProvider(context, extensionContext))
 				.withExtensionRegistry(registry)
 				.withExtensionContext(extensionContext)
 				.withThrowableCollector(throwableCollector)
@@ -177,7 +179,7 @@ public abstract class ClassBasedTestDescriptor extends JupiterTestDescriptor {
 			// and store the instance in the ExtensionContext.
 			ClassExtensionContext extensionContext = (ClassExtensionContext) context.getExtensionContext();
 			throwableCollector.execute(() -> extensionContext.setTestInstances(
-				context.getTestInstancesProvider().getTestInstances(Optional.empty())));
+				context.getTestInstancesProvider().getTestInstances(context.getExtensionRegistry())));
 		}
 
 		if (throwableCollector.isEmpty()) {
@@ -242,29 +244,26 @@ public abstract class ClassBasedTestDescriptor extends JupiterTestDescriptor {
 	}
 
 	private TestInstancesProvider testInstancesProvider(JupiterEngineExecutionContext parentExecutionContext,
-			ExtensionRegistry registry, ClassExtensionContext extensionContext) {
+			ClassExtensionContext extensionContext) {
 
-		TestInstancesProvider testInstancesProvider = childRegistry -> instantiateAndPostProcessTestInstance(
-			parentExecutionContext, extensionContext, childRegistry.orElse(registry));
-
-		return childRegistry -> extensionContext.getTestInstances().orElseGet(
-			() -> testInstancesProvider.getTestInstances(childRegistry));
+		return (registry, registrar) -> extensionContext.getTestInstances().orElseGet(
+			() -> instantiateAndPostProcessTestInstance(parentExecutionContext, extensionContext, registry, registrar));
 	}
 
 	private TestInstances instantiateAndPostProcessTestInstance(JupiterEngineExecutionContext parentExecutionContext,
-			ExtensionContext extensionContext, ExtensionRegistry registry) {
+			ExtensionContext extensionContext, ExtensionRegistry registry, ExtensionRegistrar registrar) {
 
-		TestInstances instances = instantiateTestClass(parentExecutionContext, registry, extensionContext);
+		TestInstances instances = instantiateTestClass(parentExecutionContext, registry, registrar, extensionContext);
 		invokeTestInstancePostProcessors(instances.getInnermostInstance(), registry, extensionContext);
 		// In addition, we register extensions from instance fields here since the
 		// best time to do that is immediately following test class instantiation
 		// and post processing.
-		registerExtensionsFromFields(registry, this.testClass, instances.getInnermostInstance());
+		registerExtensionsFromFields(registrar, this.testClass, instances.getInnermostInstance());
 		return instances;
 	}
 
 	protected abstract TestInstances instantiateTestClass(JupiterEngineExecutionContext parentExecutionContext,
-			ExtensionRegistry registry, ExtensionContext extensionContext);
+			ExtensionRegistry registry, ExtensionRegistrar registrar, ExtensionContext extensionContext);
 
 	protected TestInstances instantiateTestClass(Optional<TestInstances> outerInstances, ExtensionRegistry registry,
 			ExtensionContext extensionContext) {
@@ -420,12 +419,12 @@ public abstract class ClassBasedTestDescriptor extends JupiterTestDescriptor {
 				.forEach(extension -> throwableCollector.execute(() -> extension.afterAll(extensionContext)));
 	}
 
-	private void registerBeforeEachMethodAdapters(ExtensionRegistry registry) {
+	private void registerBeforeEachMethodAdapters(ExtensionRegistrar registrar) {
 		List<Method> beforeEachMethods = findBeforeEachMethods(this.testClass);
-		registerMethodsAsExtensions(beforeEachMethods, registry, this::synthesizeBeforeEachMethodAdapter);
+		registerMethodsAsExtensions(beforeEachMethods, registrar, this::synthesizeBeforeEachMethodAdapter);
 	}
 
-	private void registerAfterEachMethodAdapters(ExtensionRegistry registry) {
+	private void registerAfterEachMethodAdapters(ExtensionRegistrar registrar) {
 		// Make a local copy since findAfterEachMethods() returns an immutable list.
 		List<Method> afterEachMethods = new ArrayList<>(findAfterEachMethods(this.testClass));
 
@@ -435,13 +434,13 @@ public abstract class ClassBasedTestDescriptor extends JupiterTestDescriptor {
 		// we register them as synthesized extensions.
 		Collections.reverse(afterEachMethods);
 
-		registerMethodsAsExtensions(afterEachMethods, registry, this::synthesizeAfterEachMethodAdapter);
+		registerMethodsAsExtensions(afterEachMethods, registrar, this::synthesizeAfterEachMethodAdapter);
 	}
 
-	private void registerMethodsAsExtensions(List<Method> methods, ExtensionRegistry registry,
+	private void registerMethodsAsExtensions(List<Method> methods, ExtensionRegistrar registrar,
 			Function<Method, Extension> extensionSynthesizer) {
 
-		methods.forEach(method -> registry.registerExtension(extensionSynthesizer.apply(method), method));
+		methods.forEach(method -> registrar.registerExtension(extensionSynthesizer.apply(method), method));
 	}
 
 	private BeforeEachMethodAdapter synthesizeBeforeEachMethodAdapter(Method method) {
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTestDescriptor.java
index c97b26f9b..012735a0d 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTestDescriptor.java
@@ -22,6 +22,7 @@ import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.api.extension.TestInstances;
 import org.junit.jupiter.engine.config.JupiterConfiguration;
 import org.junit.jupiter.engine.execution.JupiterEngineExecutionContext;
+import org.junit.jupiter.engine.extension.ExtensionRegistrar;
 import org.junit.jupiter.engine.extension.ExtensionRegistry;
 import org.junit.platform.engine.TestDescriptor;
 import org.junit.platform.engine.TestTag;
@@ -65,7 +66,7 @@ public class ClassTestDescriptor extends ClassBasedTestDescriptor {
 
 	@Override
 	protected TestInstances instantiateTestClass(JupiterEngineExecutionContext parentExecutionContext,
-			ExtensionRegistry registry, ExtensionContext extensionContext) {
+			ExtensionRegistry registry, ExtensionRegistrar registrar, ExtensionContext extensionContext) {
 		return instantiateTestClass(Optional.empty(), registry, extensionContext);
 	}
 
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ExtensionUtils.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ExtensionUtils.java
index 2c29d732e..b09f65885 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ExtensionUtils.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ExtensionUtils.java
@@ -29,7 +29,8 @@ import org.junit.jupiter.api.Order;
 import org.junit.jupiter.api.extension.ExtendWith;
 import org.junit.jupiter.api.extension.Extension;
 import org.junit.jupiter.api.extension.RegisterExtension;
-import org.junit.jupiter.engine.extension.ExtensionRegistry;
+import org.junit.jupiter.engine.extension.ExtensionRegistrar;
+import org.junit.jupiter.engine.extension.MutableExtensionRegistry;
 import org.junit.platform.commons.util.Preconditions;
 import org.junit.platform.commons.util.ReflectionUtils;
 
@@ -37,7 +38,8 @@ import org.junit.platform.commons.util.ReflectionUtils;
  * Collection of utilities for working with extensions and the extension registry.
  *
  * @since 5.1
- * @see ExtensionRegistry
+ * @see ExtensionRegistrar
+ * @see MutableExtensionRegistry
  * @see ExtendWith
  * @see RegisterExtension
  */
@@ -48,7 +50,7 @@ final class ExtensionUtils {
 	}
 
 	/**
-	 * Populate a new {@link ExtensionRegistry} from extension types declared via
+	 * Populate a new {@link MutableExtensionRegistry} from extension types declared via
 	 * {@link ExtendWith @ExtendWith} on the supplied {@link AnnotatedElement}.
 	 *
 	 * @param parentRegistry the parent extension registry to set in the newly
@@ -59,8 +61,8 @@ final class ExtensionUtils {
 	 * @return the new extension registry; never {@code null}
 	 * @since 5.0
 	 */
-	static ExtensionRegistry populateNewExtensionRegistryFromExtendWithAnnotation(ExtensionRegistry parentRegistry,
-			AnnotatedElement annotatedElement) {
+	static MutableExtensionRegistry populateNewExtensionRegistryFromExtendWithAnnotation(
+			MutableExtensionRegistry parentRegistry, AnnotatedElement annotatedElement) {
 
 		Preconditions.notNull(parentRegistry, "Parent ExtensionRegistry must not be null");
 		Preconditions.notNull(annotatedElement, "AnnotatedElement must not be null");
@@ -72,7 +74,7 @@ final class ExtensionUtils {
 				.collect(toList());
 		// @formatter:on
 
-		return ExtensionRegistry.createRegistryFrom(parentRegistry, extensionTypes);
+		return MutableExtensionRegistry.createRegistryFrom(parentRegistry, extensionTypes);
 	}
 
 	/**
@@ -82,13 +84,13 @@ final class ExtensionUtils {
 	 * <p>The extensions will be sorted according to {@link Order @Order} semantics
 	 * prior to registration.
 	 *
-	 * @param registry the registry in which to register the extensions; never {@code null}
+	 * @param registrar the registrar with which to register the extensions; never {@code null}
 	 * @param clazz the class or interface in which to find the fields; never {@code null}
 	 * @param instance the instance of the supplied class; may be {@code null}
 	 * when searching for {@code static} fields in the class
 	 */
-	static void registerExtensionsFromFields(ExtensionRegistry registry, Class<?> clazz, Object instance) {
-		Preconditions.notNull(registry, "ExtensionRegistry must not be null");
+	static void registerExtensionsFromFields(ExtensionRegistrar registrar, Class<?> clazz, Object instance) {
+		Preconditions.notNull(registrar, "ExtensionRegistrar must not be null");
 		Preconditions.notNull(clazz, "Class must not be null");
 
 		Predicate<Field> predicate = (instance == null ? ReflectionUtils::isStatic : ReflectionUtils::isNotStatic);
@@ -108,7 +110,7 @@ final class ExtensionUtils {
 				Preconditions.condition(value instanceof Extension, () -> String.format(
 					"Failed to register extension via @RegisterExtension field [%s]: field value's type [%s] must implement an [%s] API.",
 					field, (value != null ? value.getClass().getName() : null), Extension.class.getName()));
-				registry.registerExtension((Extension) value, field);
+				registrar.registerExtension((Extension) value, field);
 			});
 		});
 	}
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/JupiterEngineDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/JupiterEngineDescriptor.java
index 16d7a9d02..b09155f58 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/JupiterEngineDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/JupiterEngineDescriptor.java
@@ -12,13 +12,12 @@ package org.junit.jupiter.engine.descriptor;
 
 import static org.apiguardian.api.API.Status.INTERNAL;
 import static org.junit.jupiter.engine.descriptor.JupiterTestDescriptor.toExecutionMode;
-import static org.junit.jupiter.engine.extension.ExtensionRegistry.createRegistryWithDefaultExtensions;
 
 import org.apiguardian.api.API;
 import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.engine.config.JupiterConfiguration;
 import org.junit.jupiter.engine.execution.JupiterEngineExecutionContext;
-import org.junit.jupiter.engine.extension.ExtensionRegistry;
+import org.junit.jupiter.engine.extension.MutableExtensionRegistry;
 import org.junit.platform.engine.EngineExecutionListener;
 import org.junit.platform.engine.UniqueId;
 import org.junit.platform.engine.support.descriptor.EngineDescriptor;
@@ -49,7 +48,8 @@ public class JupiterEngineDescriptor extends EngineDescriptor implements Node<Ju
 
 	@Override
 	public JupiterEngineExecutionContext prepare(JupiterEngineExecutionContext context) {
-		ExtensionRegistry extensionRegistry = createRegistryWithDefaultExtensions(context.getConfiguration());
+		MutableExtensionRegistry extensionRegistry = MutableExtensionRegistry.createRegistryWithDefaultExtensions(
+			context.getConfiguration());
 		EngineExecutionListener executionListener = context.getExecutionListener();
 		ExtensionContext extensionContext = new JupiterEngineExtensionContext(executionListener, this,
 			context.getConfiguration());
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/NestedClassTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/NestedClassTestDescriptor.java
index 38051244a..54a3171b4 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/NestedClassTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/NestedClassTestDescriptor.java
@@ -22,6 +22,7 @@ import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.api.extension.TestInstances;
 import org.junit.jupiter.engine.config.JupiterConfiguration;
 import org.junit.jupiter.engine.execution.JupiterEngineExecutionContext;
+import org.junit.jupiter.engine.extension.ExtensionRegistrar;
 import org.junit.jupiter.engine.extension.ExtensionRegistry;
 import org.junit.platform.engine.TestDescriptor;
 import org.junit.platform.engine.TestTag;
@@ -60,12 +61,12 @@ public class NestedClassTestDescriptor extends ClassBasedTestDescriptor {
 
 	@Override
 	protected TestInstances instantiateTestClass(JupiterEngineExecutionContext parentExecutionContext,
-			ExtensionRegistry registry, ExtensionContext extensionContext) {
+			ExtensionRegistry registry, ExtensionRegistrar registrar, ExtensionContext extensionContext) {
 
-		// Extensions registered for nested classes and below are not to be used for instantiating outer classes
-		Optional<ExtensionRegistry> childExtensionRegistryForOuterInstance = Optional.empty();
+		// Extensions registered for nested classes and below are not to be used for instantiating and initializing outer classes
+		ExtensionRegistry extensionRegistryForOuterInstanceCreation = parentExecutionContext.getExtensionRegistry();
 		TestInstances outerInstances = parentExecutionContext.getTestInstancesProvider().getTestInstances(
-			childExtensionRegistryForOuterInstance);
+			extensionRegistryForOuterInstanceCreation, registrar);
 		return instantiateTestClass(Optional.of(outerInstances), registry, extensionContext);
 	}
 
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestMethodTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestMethodTestDescriptor.java
index b0ba94fb7..3a0dacc2f 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestMethodTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestMethodTestDescriptor.java
@@ -38,6 +38,7 @@ import org.junit.jupiter.engine.execution.ExecutableInvoker;
 import org.junit.jupiter.engine.execution.ExecutableInvoker.ReflectiveInterceptorCall;
 import org.junit.jupiter.engine.execution.JupiterEngineExecutionContext;
 import org.junit.jupiter.engine.extension.ExtensionRegistry;
+import org.junit.jupiter.engine.extension.MutableExtensionRegistry;
 import org.junit.platform.commons.logging.Logger;
 import org.junit.platform.commons.logging.LoggerFactory;
 import org.junit.platform.commons.util.BlacklistedExceptions;
@@ -96,13 +97,13 @@ public class TestMethodTestDescriptor extends MethodBasedTestDescriptor {
 	// --- Node ----------------------------------------------------------------
 
 	@Override
-	public JupiterEngineExecutionContext prepare(JupiterEngineExecutionContext context) throws Exception {
-		ExtensionRegistry registry = populateNewExtensionRegistry(context);
+	public JupiterEngineExecutionContext prepare(JupiterEngineExecutionContext context) {
+		MutableExtensionRegistry registry = populateNewExtensionRegistry(context);
 		ThrowableCollector throwableCollector = createThrowableCollector();
 		MethodExtensionContext extensionContext = new MethodExtensionContext(context.getExtensionContext(),
 			context.getExecutionListener(), this, context.getConfiguration(), throwableCollector);
 		throwableCollector.execute(() -> {
-			TestInstances testInstances = context.getTestInstancesProvider().getTestInstances(Optional.of(registry));
+			TestInstances testInstances = context.getTestInstancesProvider().getTestInstances(registry);
 			extensionContext.setTestInstances(testInstances);
 		});
 
@@ -115,7 +116,7 @@ public class TestMethodTestDescriptor extends MethodBasedTestDescriptor {
 		// @formatter:on
 	}
 
-	protected ExtensionRegistry populateNewExtensionRegistry(JupiterEngineExecutionContext context) {
+	protected MutableExtensionRegistry populateNewExtensionRegistry(JupiterEngineExecutionContext context) {
 		return populateNewExtensionRegistryFromExtendWithAnnotation(context.getExtensionRegistry(), getTestMethod());
 	}
 
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestTemplateInvocationTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestTemplateInvocationTestDescriptor.java
index 01d129c53..c7972a406 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestTemplateInvocationTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestTemplateInvocationTestDescriptor.java
@@ -22,7 +22,7 @@ import org.junit.jupiter.api.extension.TestTemplateInvocationContext;
 import org.junit.jupiter.engine.config.JupiterConfiguration;
 import org.junit.jupiter.engine.execution.ExecutableInvoker.ReflectiveInterceptorCall;
 import org.junit.jupiter.engine.execution.JupiterEngineExecutionContext;
-import org.junit.jupiter.engine.extension.ExtensionRegistry;
+import org.junit.jupiter.engine.extension.MutableExtensionRegistry;
 import org.junit.platform.engine.TestDescriptor;
 import org.junit.platform.engine.UniqueId;
 import org.junit.platform.engine.support.hierarchical.ExclusiveResource;
@@ -63,8 +63,8 @@ public class TestTemplateInvocationTestDescriptor extends TestMethodTestDescript
 	}
 
 	@Override
-	protected ExtensionRegistry populateNewExtensionRegistry(JupiterEngineExecutionContext context) {
-		ExtensionRegistry registry = super.populateNewExtensionRegistry(context);
+	protected MutableExtensionRegistry populateNewExtensionRegistry(JupiterEngineExecutionContext context) {
+		MutableExtensionRegistry registry = super.populateNewExtensionRegistry(context);
 		invocationContext.getAdditionalExtensions().forEach(
 			extension -> registry.registerExtension(extension, invocationContext));
 		return registry;
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestTemplateTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestTemplateTestDescriptor.java
index 05e709bcf..32121b0b5 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestTemplateTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestTemplateTestDescriptor.java
@@ -27,6 +27,7 @@ import org.junit.jupiter.api.extension.TestTemplateInvocationContextProvider;
 import org.junit.jupiter.engine.config.JupiterConfiguration;
 import org.junit.jupiter.engine.execution.JupiterEngineExecutionContext;
 import org.junit.jupiter.engine.extension.ExtensionRegistry;
+import org.junit.jupiter.engine.extension.MutableExtensionRegistry;
 import org.junit.platform.commons.util.Preconditions;
 import org.junit.platform.engine.TestDescriptor;
 import org.junit.platform.engine.UniqueId;
@@ -71,7 +72,7 @@ public class TestTemplateTestDescriptor extends MethodBasedTestDescriptor implem
 
 	@Override
 	public JupiterEngineExecutionContext prepare(JupiterEngineExecutionContext context) throws Exception {
-		ExtensionRegistry registry = populateNewExtensionRegistryFromExtendWithAnnotation(
+		MutableExtensionRegistry registry = populateNewExtensionRegistryFromExtendWithAnnotation(
 			context.getExtensionRegistry(), getTestMethod());
 
 		// The test instance should be properly maintained by the enclosing class's ExtensionContext.
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/JupiterEngineExecutionContext.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/JupiterEngineExecutionContext.java
index 466beea0c..2f1bf2000 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/JupiterEngineExecutionContext.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/JupiterEngineExecutionContext.java
@@ -15,7 +15,7 @@ import static org.apiguardian.api.API.Status.INTERNAL;
 import org.apiguardian.api.API;
 import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.engine.config.JupiterConfiguration;
-import org.junit.jupiter.engine.extension.ExtensionRegistry;
+import org.junit.jupiter.engine.extension.MutableExtensionRegistry;
 import org.junit.platform.commons.JUnitException;
 import org.junit.platform.commons.logging.Logger;
 import org.junit.platform.commons.logging.LoggerFactory;
@@ -71,7 +71,7 @@ public class JupiterEngineExecutionContext implements EngineExecutionContext {
 		return this.state.testInstancesProvider;
 	}
 
-	public ExtensionRegistry getExtensionRegistry() {
+	public MutableExtensionRegistry getExtensionRegistry() {
 		return this.state.extensionRegistry;
 	}
 
@@ -125,7 +125,7 @@ public class JupiterEngineExecutionContext implements EngineExecutionContext {
 		final EngineExecutionListener executionListener;
 		final JupiterConfiguration configuration;
 		TestInstancesProvider testInstancesProvider;
-		ExtensionRegistry extensionRegistry;
+		MutableExtensionRegistry extensionRegistry;
 		ExtensionContext extensionContext;
 		ThrowableCollector throwableCollector;
 
@@ -160,7 +160,7 @@ public class JupiterEngineExecutionContext implements EngineExecutionContext {
 			return this;
 		}
 
-		public Builder withExtensionRegistry(ExtensionRegistry extensionRegistry) {
+		public Builder withExtensionRegistry(MutableExtensionRegistry extensionRegistry) {
 			newState().extensionRegistry = extensionRegistry;
 			return this;
 		}
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/TestInstancesProvider.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/TestInstancesProvider.java
index 94e0fae4f..7b38b34f1 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/TestInstancesProvider.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/TestInstancesProvider.java
@@ -12,11 +12,11 @@ package org.junit.jupiter.engine.execution;
 
 import static org.apiguardian.api.API.Status.INTERNAL;
 
-import java.util.Optional;
-
 import org.apiguardian.api.API;
 import org.junit.jupiter.api.extension.TestInstances;
+import org.junit.jupiter.engine.extension.ExtensionRegistrar;
 import org.junit.jupiter.engine.extension.ExtensionRegistry;
+import org.junit.jupiter.engine.extension.MutableExtensionRegistry;
 
 /**
  * @since 5.0
@@ -25,6 +25,10 @@ import org.junit.jupiter.engine.extension.ExtensionRegistry;
 @API(status = INTERNAL, since = "5.0")
 public interface TestInstancesProvider {
 
-	TestInstances getTestInstances(Optional<ExtensionRegistry> childExtensionRegistry);
+	default TestInstances getTestInstances(MutableExtensionRegistry extensionRegistry) {
+		return getTestInstances(extensionRegistry, extensionRegistry);
+	}
+
+	TestInstances getTestInstances(ExtensionRegistry extensionRegistry, ExtensionRegistrar extensionRegistrar);
 
 }
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/ExtensionRegistrar.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/ExtensionRegistrar.java
new file mode 100644
index 000000000..6d7bb970b
--- /dev/null
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/ExtensionRegistrar.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2015-2019 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.engine.extension;
+
+import static org.apiguardian.api.API.Status.INTERNAL;
+
+import org.apiguardian.api.API;
+import org.junit.jupiter.api.extension.Extension;
+
+/**
+ * An {@code ExtensionRegistrar} is used to register extension.
+ *
+ * @since 5.5
+ */
+@API(status = INTERNAL, since = "5.5")
+public interface ExtensionRegistrar {
+
+	/**
+	 * Register the supplied {@link Extension}, without checking if an extension
+	 * of that type already exists.
+	 *
+	 * <h4>Semantics for Source</h4>
+	 *
+	 * <p>If an extension is registered <em>declaratively</em> via
+	 * {@link org.junit.jupiter.api.extension.ExtendWith @ExtendWith}, the
+	 * {@code source} and the {@code extension} should be the same object.
+	 * However, if an extension is registered <em>programmatically</em> via
+	 * {@link org.junit.jupiter.api.extension.RegisterExtension @RegisterExtension},
+	 * the {@code source} object should be the {@link java.lang.reflect.Field}
+	 * that is annotated with {@code @RegisterExtension}. Similarly, if an
+	 * extension is registered <em>programmatically</em> as a lambda expression
+	 * or method reference, the {@code source} object should be the underlying
+	 * {@link java.lang.reflect.Method} that implements the extension API.
+	 *
+	 * @param extension the extension to register; never {@code null}
+	 * @param source the source of the extension; never {@code null}
+	 */
+	void registerExtension(Extension extension, Object source);
+
+}
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/ExtensionRegistry.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/ExtensionRegistry.java
index b6eb44633..a72659c96 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/ExtensionRegistry.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/ExtensionRegistry.java
@@ -11,131 +11,25 @@
 package org.junit.jupiter.engine.extension;
 
 import static java.util.stream.Collectors.toCollection;
-import static java.util.stream.Collectors.toList;
-import static java.util.stream.Stream.concat;
 import static org.apiguardian.api.API.Status.INTERNAL;
 
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collections;
-import java.util.LinkedHashSet;
 import java.util.List;
-import java.util.ServiceLoader;
-import java.util.Set;
 import java.util.stream.Stream;
-import java.util.stream.StreamSupport;
 
 import org.apiguardian.api.API;
 import org.junit.jupiter.api.extension.Extension;
-import org.junit.jupiter.engine.config.JupiterConfiguration;
-import org.junit.platform.commons.logging.Logger;
-import org.junit.platform.commons.logging.LoggerFactory;
-import org.junit.platform.commons.util.ClassLoaderUtils;
-import org.junit.platform.commons.util.Preconditions;
-import org.junit.platform.commons.util.ReflectionUtils;
 
 /**
  * An {@code ExtensionRegistry} holds all registered extensions (i.e.
  * instances of {@link Extension}) for a given
  * {@link org.junit.platform.engine.support.hierarchical.Node}.
  *
- * <p>A registry has a reference to its parent registry, and all lookups are
- * performed first in the current registry itself and then recursively in its
- * ancestors.
- *
  * @since 5.0
  */
 @API(status = INTERNAL, since = "5.0")
-public class ExtensionRegistry {
-
-	private static final Logger logger = LoggerFactory.getLogger(ExtensionRegistry.class);
-
-	private static final List<Extension> DEFAULT_EXTENSIONS = Collections.unmodifiableList(Arrays.asList(//
-		new DisabledCondition(), //
-		newScriptExecutionCondition(), //
-		new TempDirectory(), //
-		new TimeoutExtension(), //
-		new RepeatedTestExtension(), //
-		new TestInfoParameterResolver(), //
-		new TestReporterParameterResolver()));
-
-	@SuppressWarnings("deprecation")
-	private static Extension newScriptExecutionCondition() {
-		return new ScriptExecutionCondition();
-	}
-
-	/**
-	 * Factory for creating and populating a new root registry with the default
-	 * extensions.
-	 *
-	 * <p>If the {@link org.junit.jupiter.engine.Constants#EXTENSIONS_AUTODETECTION_ENABLED_PROPERTY_NAME}
-	 * configuration parameter has been set to {@code true}, extensions will be
-	 * auto-detected using Java's {@link ServiceLoader} mechanism and automatically
-	 * registered after the default extensions.
-	 *
-	 * @param configuration configuration parameters used to retrieve the extension
-	 * auto-detection flag; never {@code null}
-	 * @return a new {@code ExtensionRegistry}; never {@code null}
-	 */
-	public static ExtensionRegistry createRegistryWithDefaultExtensions(JupiterConfiguration configuration) {
-		ExtensionRegistry extensionRegistry = new ExtensionRegistry(null);
-
-		// @formatter:off
-		logger.trace(() -> "Registering default extensions: " + DEFAULT_EXTENSIONS.stream()
-						.map(extension -> extension.getClass().getName())
-						.collect(toList()));
-		// @formatter:on
-
-		DEFAULT_EXTENSIONS.forEach(extensionRegistry::registerDefaultExtension);
-
-		if (configuration.isExtensionAutoDetectionEnabled()) {
-			registerAutoDetectedExtensions(extensionRegistry);
-		}
-
-		return extensionRegistry;
-	}
-
-	private static void registerAutoDetectedExtensions(ExtensionRegistry extensionRegistry) {
-		Iterable<Extension> extensions = ServiceLoader.load(Extension.class, ClassLoaderUtils.getDefaultClassLoader());
-
-		// @formatter:off
-		logger.config(() -> "Registering auto-detected extensions: "
-				+ StreamSupport.stream(extensions.spliterator(), false)
-						.map(extension -> extension.getClass().getName())
-						.collect(toList()));
-		// @formatter:on
-
-		extensions.forEach(extensionRegistry::registerDefaultExtension);
-	}
-
-	/**
-	 * Factory for creating and populating a new registry from a list of
-	 * extension types and a parent registry.
-	 *
-	 * @param parentRegistry the parent registry
-	 * @param extensionTypes the types of extensions to be registered in
-	 * the new registry
-	 * @return a new {@code ExtensionRegistry}; never {@code null}
-	 */
-	public static ExtensionRegistry createRegistryFrom(ExtensionRegistry parentRegistry,
-			List<Class<? extends Extension>> extensionTypes) {
-
-		Preconditions.notNull(parentRegistry, "parentRegistry must not be null");
-
-		ExtensionRegistry registry = new ExtensionRegistry(parentRegistry);
-		extensionTypes.forEach(registry::registerExtension);
-		return registry;
-	}
-
-	private final ExtensionRegistry parent;
-
-	private final Set<Class<? extends Extension>> registeredExtensionTypes = new LinkedHashSet<>();
-
-	private final List<Extension> registeredExtensions = new ArrayList<>();
-
-	private ExtensionRegistry(ExtensionRegistry parent) {
-		this.parent = parent;
-	}
+public interface ExtensionRegistry {
 
 	/**
 	 * Stream all {@code Extensions} of the specified type that are present
@@ -145,29 +39,7 @@ public class ExtensionRegistry {
 	 * @see #getReversedExtensions(Class)
 	 * @see #getExtensions(Class)
 	 */
-	public <E extends Extension> Stream<E> stream(Class<E> extensionType) {
-		if (this.parent == null) {
-			return streamLocal(extensionType);
-		}
-		return concat(this.parent.stream(extensionType), streamLocal(extensionType));
-	}
-
-	/**
-	 * Stream all {@code Extensions} of the specified type that are present
-	 * in this registry.
-	 *
-	 * <p>Extensions in ancestors are ignored.
-	 *
-	 * @param extensionType the type of {@link Extension} to stream
-	 * @see #getReversedExtensions(Class)
-	 */
-	private <E extends Extension> Stream<E> streamLocal(Class<E> extensionType) {
-		// @formatter:off
-		return this.registeredExtensions.stream()
-				.filter(extensionType::isInstance)
-				.map(extensionType::cast);
-		// @formatter:on
-	}
+	<E extends Extension> Stream<E> stream(Class<E> extensionType);
 
 	/**
 	 * Get all {@code Extensions} of the specified type that are present
@@ -177,7 +49,7 @@ public class ExtensionRegistry {
 	 * @see #getReversedExtensions(Class)
 	 * @see #stream(Class)
 	 */
-	public <E extends Extension> List<E> getExtensions(Class<E> extensionType) {
+	default <E extends Extension> List<E> getExtensions(Class<E> extensionType) {
 		return stream(extensionType).collect(toCollection(ArrayList::new));
 	}
 
@@ -189,73 +61,10 @@ public class ExtensionRegistry {
 	 * @see #getExtensions(Class)
 	 * @see #stream(Class)
 	 */
-	public <E extends Extension> List<E> getReversedExtensions(Class<E> extensionType) {
+	default <E extends Extension> List<E> getReversedExtensions(Class<E> extensionType) {
 		List<E> extensions = getExtensions(extensionType);
 		Collections.reverse(extensions);
 		return extensions;
 	}
 
-	/**
-	 * Determine if the supplied type is already registered in this registry or in a
-	 * parent registry.
-	 */
-	private boolean isAlreadyRegistered(Class<? extends Extension> extensionType) {
-		return (this.registeredExtensionTypes.contains(extensionType)
-				|| (this.parent != null && this.parent.isAlreadyRegistered(extensionType)));
-	}
-
-	/**
-	 * Instantiate an extension of the given type using its default constructor
-	 * and register it in this registry.
-	 *
-	 * <p>A new {@link Extension} will not be registered if an extension of the
-	 * given type already exists in this registry or a parent registry.
-	 *
-	 * @param extensionType the type of extension to register
-	 */
-	void registerExtension(Class<? extends Extension> extensionType) {
-		if (!isAlreadyRegistered(extensionType)) {
-			registerExtension(ReflectionUtils.newInstance(extensionType));
-			this.registeredExtensionTypes.add(extensionType);
-		}
-	}
-
-	private void registerDefaultExtension(Extension extension) {
-		this.registeredExtensions.add(extension);
-		this.registeredExtensionTypes.add(extension.getClass());
-	}
-
-	private void registerExtension(Extension extension) {
-		registerExtension(extension, extension);
-	}
-
-	/**
-	 * Register the supplied {@link Extension} in this registry, without checking
-	 * if an extension of that type already exists in this registry.
-	 *
-	 * <h4>Semantics for Source</h4>
-	 *
-	 * <p>If an extension is registered <em>declaratively</em> via
-	 * {@link org.junit.jupiter.api.extension.ExtendWith @ExtendWith}, the
-	 * {@code source} and the {@code extension} should be the same object.
-	 * However, if an extension is registered <em>programmatically</em> via
-	 * {@link org.junit.jupiter.api.extension.RegisterExtension @RegisterExtension},
-	 * the {@code source} object should be the {@link java.lang.reflect.Field}
-	 * that is annotated with {@code @RegisterExtension}. Similarly, if an
-	 * extension is registered <em>programmatically</em> as a lambda expression
-	 * or method reference, the {@code source} object should be the underlying
-	 * {@link java.lang.reflect.Method} that implements the extension API.
-	 *
-	 * @param extension the extension to register; never {@code null}
-	 * @param source the source of the extension; never {@code null}
-	 */
-	public void registerExtension(Extension extension, Object source) {
-		Preconditions.notNull(extension, "Extension must not be null");
-		Preconditions.notNull(source, "source must not be null");
-
-		logger.trace(() -> String.format("Registering extension [%s] from source [%s].", extension, source));
-
-		this.registeredExtensions.add(extension);
-	}
-
 }
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/MutableExtensionRegistry.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/MutableExtensionRegistry.java
new file mode 100644
index 000000000..01ef5b92b
--- /dev/null
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/extension/MutableExtensionRegistry.java
@@ -0,0 +1,206 @@
+/*
+ * Copyright 2015-2019 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.engine.extension;
+
+import static java.util.stream.Collectors.toList;
+import static java.util.stream.Stream.concat;
+import static org.apiguardian.api.API.Status.INTERNAL;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.ServiceLoader;
+import java.util.Set;
+import java.util.stream.Stream;
+import java.util.stream.StreamSupport;
+
+import org.apiguardian.api.API;
+import org.junit.jupiter.api.extension.Extension;
+import org.junit.jupiter.engine.config.JupiterConfiguration;
+import org.junit.platform.commons.logging.Logger;
+import org.junit.platform.commons.logging.LoggerFactory;
+import org.junit.platform.commons.util.ClassLoaderUtils;
+import org.junit.platform.commons.util.Preconditions;
+import org.junit.platform.commons.util.ReflectionUtils;
+
+/**
+ * Default, mutable implementation of {@link ExtensionRegistry}.
+ *
+ * <p>A registry has a reference to its parent registry, and all lookups are
+ * performed first in the current registry itself and then recursively in its
+ * ancestors.
+ *
+ * @since 5.5
+ */
+@API(status = INTERNAL, since = "5.5")
+public class MutableExtensionRegistry implements ExtensionRegistry, ExtensionRegistrar {
+
+	private static final Logger logger = LoggerFactory.getLogger(MutableExtensionRegistry.class);
+
+	private static final List<Extension> DEFAULT_EXTENSIONS = Collections.unmodifiableList(Arrays.asList(//
+		new DisabledCondition(), //
+		newScriptExecutionCondition(), //
+		new TempDirectory(), //
+		new TimeoutExtension(), //
+		new RepeatedTestExtension(), //
+		new TestInfoParameterResolver(), //
+		new TestReporterParameterResolver()));
+
+	@SuppressWarnings("deprecation")
+	private static Extension newScriptExecutionCondition() {
+		return new ScriptExecutionCondition();
+	}
+
+	/**
+	 * Factory for creating and populating a new root registry with the default
+	 * extensions.
+	 *
+	 * <p>If the {@link org.junit.jupiter.engine.Constants#EXTENSIONS_AUTODETECTION_ENABLED_PROPERTY_NAME}
+	 * configuration parameter has been set to {@code true}, extensions will be
+	 * auto-detected using Java's {@link ServiceLoader} mechanism and automatically
+	 * registered after the default extensions.
+	 *
+	 * @param configuration configuration parameters used to retrieve the extension
+	 * auto-detection flag; never {@code null}
+	 * @return a new {@code ExtensionRegistry}; never {@code null}
+	 */
+	public static MutableExtensionRegistry createRegistryWithDefaultExtensions(JupiterConfiguration configuration) {
+		MutableExtensionRegistry extensionRegistry = new MutableExtensionRegistry(null);
+
+		// @formatter:off
+		logger.trace(() -> "Registering default extensions: " + DEFAULT_EXTENSIONS.stream()
+						.map(extension -> extension.getClass().getName())
+						.collect(toList()));
+		// @formatter:on
+
+		DEFAULT_EXTENSIONS.forEach(extensionRegistry::registerDefaultExtension);
+
+		if (configuration.isExtensionAutoDetectionEnabled()) {
+			registerAutoDetectedExtensions(extensionRegistry);
+		}
+
+		return extensionRegistry;
+	}
+
+	private static void registerAutoDetectedExtensions(MutableExtensionRegistry extensionRegistry) {
+		Iterable<Extension> extensions = ServiceLoader.load(Extension.class, ClassLoaderUtils.getDefaultClassLoader());
+
+		// @formatter:off
+		logger.config(() -> "Registering auto-detected extensions: "
+				+ StreamSupport.stream(extensions.spliterator(), false)
+						.map(extension -> extension.getClass().getName())
+						.collect(toList()));
+		// @formatter:on
+
+		extensions.forEach(extensionRegistry::registerDefaultExtension);
+	}
+
+	/**
+	 * Factory for creating and populating a new registry from a list of
+	 * extension types and a parent registry.
+	 *
+	 * @param parentRegistry the parent registry
+	 * @param extensionTypes the types of extensions to be registered in
+	 * the new registry
+	 * @return a new {@code ExtensionRegistry}; never {@code null}
+	 */
+	public static MutableExtensionRegistry createRegistryFrom(MutableExtensionRegistry parentRegistry,
+			List<Class<? extends Extension>> extensionTypes) {
+
+		Preconditions.notNull(parentRegistry, "parentRegistry must not be null");
+
+		MutableExtensionRegistry registry = new MutableExtensionRegistry(parentRegistry);
+		extensionTypes.forEach(registry::registerExtension);
+		return registry;
+	}
+
+	private final MutableExtensionRegistry parent;
+
+	private final Set<Class<? extends Extension>> registeredExtensionTypes = new LinkedHashSet<>();
+
+	private final List<Extension> registeredExtensions = new ArrayList<>();
+
+	private MutableExtensionRegistry(MutableExtensionRegistry parent) {
+		this.parent = parent;
+	}
+
+	@Override
+	public <E extends Extension> Stream<E> stream(Class<E> extensionType) {
+		if (this.parent == null) {
+			return streamLocal(extensionType);
+		}
+		return concat(this.parent.stream(extensionType), streamLocal(extensionType));
+	}
+
+	/**
+	 * Stream all {@code Extensions} of the specified type that are present
+	 * in this registry.
+	 *
+	 * <p>Extensions in ancestors are ignored.
+	 *
+	 * @param extensionType the type of {@link Extension} to stream
+	 * @see #getReversedExtensions(Class)
+	 */
+	private <E extends Extension> Stream<E> streamLocal(Class<E> extensionType) {
+		// @formatter:off
+		return this.registeredExtensions.stream()
+				.filter(extensionType::isInstance)
+				.map(extensionType::cast);
+		// @formatter:on
+	}
+
+	/**
+	 * Determine if the supplied type is already registered in this registry or in a
+	 * parent registry.
+	 */
+	private boolean isAlreadyRegistered(Class<? extends Extension> extensionType) {
+		return (this.registeredExtensionTypes.contains(extensionType)
+				|| (this.parent != null && this.parent.isAlreadyRegistered(extensionType)));
+	}
+
+	/**
+	 * Instantiate an extension of the given type using its default constructor
+	 * and register it in this registry.
+	 *
+	 * <p>A new {@link Extension} will not be registered if an extension of the
+	 * given type already exists in this registry or a parent registry.
+	 *
+	 * @param extensionType the type of extension to register
+	 */
+	void registerExtension(Class<? extends Extension> extensionType) {
+		if (!isAlreadyRegistered(extensionType)) {
+			registerExtension(ReflectionUtils.newInstance(extensionType));
+			this.registeredExtensionTypes.add(extensionType);
+		}
+	}
+
+	private void registerDefaultExtension(Extension extension) {
+		this.registeredExtensions.add(extension);
+		this.registeredExtensionTypes.add(extension.getClass());
+	}
+
+	private void registerExtension(Extension extension) {
+		registerExtension(extension, extension);
+	}
+
+	@Override
+	public void registerExtension(Extension extension, Object source) {
+		Preconditions.notNull(extension, "Extension must not be null");
+		Preconditions.notNull(source, "source must not be null");
+
+		logger.trace(() -> String.format("Registering extension [%s] from source [%s].", extension, source));
+
+		this.registeredExtensions.add(extension);
+	}
+
+}
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/descriptor/TestFactoryTestDescriptorTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/descriptor/TestFactoryTestDescriptorTests.java
index 810e461a1..15819ec6a 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/descriptor/TestFactoryTestDescriptorTests.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/descriptor/TestFactoryTestDescriptorTests.java
@@ -30,7 +30,7 @@ import org.junit.jupiter.api.TestFactory;
 import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.engine.config.JupiterConfiguration;
 import org.junit.jupiter.engine.execution.JupiterEngineExecutionContext;
-import org.junit.jupiter.engine.extension.ExtensionRegistry;
+import org.junit.jupiter.engine.extension.MutableExtensionRegistry;
 import org.junit.platform.engine.TestSource;
 import org.junit.platform.engine.UniqueId;
 import org.junit.platform.engine.support.descriptor.ClasspathResourceSource;
@@ -144,7 +144,7 @@ class TestFactoryTestDescriptorTests {
 					.extend() //
 					.withThrowableCollector(new OpenTest4JAwareThrowableCollector()) //
 					.withExtensionContext(extensionContext) //
-					.withExtensionRegistry(mock(ExtensionRegistry.class)) //
+					.withExtensionRegistry(mock(MutableExtensionRegistry.class)) //
 					.build();
 
 			Method testMethod = CustomStreamTestCase.class.getDeclaredMethod("customStream");
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/execution/ExecutableInvokerTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/execution/ExecutableInvokerTests.java
index a815594b9..c6816c299 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/execution/ExecutableInvokerTests.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/execution/ExecutableInvokerTests.java
@@ -34,7 +34,7 @@ import org.junit.jupiter.api.extension.ParameterResolutionException;
 import org.junit.jupiter.api.extension.ParameterResolver;
 import org.junit.jupiter.engine.config.JupiterConfiguration;
 import org.junit.jupiter.engine.execution.ExecutableInvoker.ReflectiveInterceptorCall;
-import org.junit.jupiter.engine.extension.ExtensionRegistry;
+import org.junit.jupiter.engine.extension.MutableExtensionRegistry;
 import org.junit.platform.commons.util.ReflectionUtils;
 
 /**
@@ -53,7 +53,8 @@ class ExecutableInvokerTests {
 
 	private final JupiterConfiguration configuration = mock(JupiterConfiguration.class);
 
-	private ExtensionRegistry extensionRegistry = ExtensionRegistry.createRegistryWithDefaultExtensions(configuration);
+	private MutableExtensionRegistry extensionRegistry = MutableExtensionRegistry.createRegistryWithDefaultExtensions(
+		configuration);
 
 	@Test
 	void constructorInjection() {
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/execution/JupiterEngineExecutionContextTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/execution/JupiterEngineExecutionContextTests.java
index f5182a71e..d5bd27f38 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/execution/JupiterEngineExecutionContextTests.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/execution/JupiterEngineExecutionContextTests.java
@@ -24,7 +24,7 @@ import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.engine.TrackLogRecords;
 import org.junit.jupiter.engine.config.JupiterConfiguration;
-import org.junit.jupiter.engine.extension.ExtensionRegistry;
+import org.junit.jupiter.engine.extension.MutableExtensionRegistry;
 import org.junit.platform.commons.logging.LogRecordListener;
 import org.junit.platform.engine.EngineExecutionListener;
 
@@ -52,7 +52,8 @@ class JupiterEngineExecutionContextTests {
 	@Test
 	void extendWithAllAttributes() {
 		ExtensionContext extensionContext = mock(ExtensionContext.class);
-		ExtensionRegistry extensionRegistry = ExtensionRegistry.createRegistryWithDefaultExtensions(configuration);
+		MutableExtensionRegistry extensionRegistry = MutableExtensionRegistry.createRegistryWithDefaultExtensions(
+			configuration);
 		TestInstancesProvider testInstancesProvider = mock(TestInstancesProvider.class);
 		JupiterEngineExecutionContext newContext = originalContext.extend() //
 				.withExtensionContext(extensionContext) //
@@ -68,7 +69,8 @@ class JupiterEngineExecutionContextTests {
 	@Test
 	void canOverrideAttributeWhenContextIsExtended() {
 		ExtensionContext extensionContext = mock(ExtensionContext.class);
-		ExtensionRegistry extensionRegistry = ExtensionRegistry.createRegistryWithDefaultExtensions(configuration);
+		MutableExtensionRegistry extensionRegistry = MutableExtensionRegistry.createRegistryWithDefaultExtensions(
+			configuration);
 		TestInstancesProvider testInstancesProvider = mock(TestInstancesProvider.class);
 		ExtensionContext newExtensionContext = mock(ExtensionContext.class);
 
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/ExtensionRegistryTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/ExtensionRegistryTests.java
index a84bba33d..bee614861 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/ExtensionRegistryTests.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/ExtensionRegistryTests.java
@@ -16,8 +16,8 @@ import static java.util.Collections.singletonList;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertFalse;
 import static org.junit.jupiter.api.Assertions.assertTrue;
-import static org.junit.jupiter.engine.extension.ExtensionRegistry.createRegistryFrom;
-import static org.junit.jupiter.engine.extension.ExtensionRegistry.createRegistryWithDefaultExtensions;
+import static org.junit.jupiter.engine.extension.MutableExtensionRegistry.createRegistryFrom;
+import static org.junit.jupiter.engine.extension.MutableExtensionRegistry.createRegistryWithDefaultExtensions;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
@@ -35,7 +35,7 @@ import org.junit.jupiter.api.extension.TestTemplateInvocationContextProvider;
 import org.junit.jupiter.engine.config.JupiterConfiguration;
 
 /**
- * Tests for the {@link ExtensionRegistry}.
+ * Tests for the {@link MutableExtensionRegistry}.
  *
  * @since 5.0
  */
@@ -45,7 +45,7 @@ class ExtensionRegistryTests {
 
 	private final JupiterConfiguration configuration = mock(JupiterConfiguration.class);
 
-	private ExtensionRegistry registry = createRegistryWithDefaultExtensions(configuration);
+	private MutableExtensionRegistry registry = createRegistryWithDefaultExtensions(configuration);
 
 	@Test
 	void newRegistryWithoutParentHasDefaultExtensions() {
@@ -101,10 +101,10 @@ class ExtensionRegistryTests {
 
 	@Test
 	void extensionsAreInheritedFromParent() {
-		ExtensionRegistry parent = registry;
+		MutableExtensionRegistry parent = registry;
 		parent.registerExtension(MyExtension.class);
 
-		ExtensionRegistry child = createRegistryFrom(parent, singletonList(YourExtension.class));
+		MutableExtensionRegistry child = createRegistryFrom(parent, singletonList(YourExtension.class));
 		assertExtensionRegistered(child, MyExtension.class);
 		assertExtensionRegistered(child, YourExtension.class);
 		assertEquals(2, countExtensions(child, MyExtensionApi.class));
@@ -117,11 +117,11 @@ class ExtensionRegistryTests {
 
 	@Test
 	void registeringSameExtensionImplementationInParentAndChildDoesNotResultInDuplicate() {
-		ExtensionRegistry parent = registry;
+		MutableExtensionRegistry parent = registry;
 		parent.registerExtension(MyExtension.class);
 		assertEquals(1, countExtensions(parent, MyExtensionApi.class));
 
-		ExtensionRegistry child = createRegistryFrom(parent, asList(MyExtension.class, YourExtension.class));
+		MutableExtensionRegistry child = createRegistryFrom(parent, asList(MyExtension.class, YourExtension.class));
 		assertExtensionRegistered(child, MyExtension.class);
 		assertExtensionRegistered(child, YourExtension.class);
 		assertEquals(2, countExtensions(child, MyExtensionApi.class));
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/ProgrammaticExtensionRegistrationTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/ProgrammaticExtensionRegistrationTests.java
index f4db31864..0fad64f2e 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/ProgrammaticExtensionRegistrationTests.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/ProgrammaticExtensionRegistrationTests.java
@@ -30,6 +30,7 @@ import org.junit.jupiter.api.AfterAll;
 import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.BeforeAll;
 import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Nested;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.TestInstance;
 import org.junit.jupiter.api.extension.BeforeEachCallback;
@@ -42,6 +43,7 @@ import org.junit.jupiter.api.extension.RegisterExtension;
 import org.junit.jupiter.api.extension.TestInstancePostProcessor;
 import org.junit.jupiter.engine.AbstractJupiterTestEngineTests;
 import org.junit.jupiter.engine.JupiterTestEngine;
+import org.junit.jupiter.engine.execution.injection.sample.LongParameterResolver;
 import org.junit.platform.commons.PreconditionViolationException;
 import org.junit.platform.commons.util.AnnotationUtils;
 import org.junit.platform.commons.util.ExceptionUtils;
@@ -271,6 +273,13 @@ class ProgrammaticExtensionRegistrationTests extends AbstractJupiterTestEngineTe
 		assertTestFails(InstanceLevelExplosiveErrorTestCase.class, allOf(instanceOf(Error.class), message("boom")));
 	}
 
+	@Test
+	void storesExtensionInRegistryOfNestedTestMethods() {
+		var results = executeTestsForClass(TwoNestedClassesTestCase.class);
+
+		results.tests().assertStatistics(stats -> stats.succeeded(4));
+	}
+
 	private void assertClassFails(Class<?> testClass, Condition<Throwable> causeCondition) {
 		EngineExecutionResults executionResults = executeTestsForClass(testClass);
 		executionResults.containers().assertThatEvents().haveExactly(1, finishedWithFailure(causeCondition));
@@ -711,4 +720,41 @@ class ProgrammaticExtensionRegistrationTests extends AbstractJupiterTestEngineTe
 
 	}
 
+	static class TwoNestedClassesTestCase {
+
+		@RegisterExtension
+		Extension extension = new LongParameterResolver();
+
+		@Nested
+		class A {
+
+			@Test
+			void first(Long n) {
+				assertEquals(42L, n);
+			}
+
+			@Test
+			void second(Long n) {
+				assertEquals(42L, n);
+			}
+
+		}
+
+		@Nested
+		class B {
+
+			@Test
+			void first(Long n) {
+				assertEquals(42L, n);
+			}
+
+			@Test
+			void second(Long n) {
+				assertEquals(42L, n);
+			}
+
+		}
+
+	}
+
 }
