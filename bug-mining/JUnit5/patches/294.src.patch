diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.5.0-RC1.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.5.0-RC1.adoc
index b6e19fd7f..0ca17d608 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.5.0-RC1.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.5.0-RC1.adoc
@@ -71,6 +71,11 @@ on GitHub.
   `@DisplayNameGeneration` is present.
 * `MethodOrderer.Random` now generates a default random seed only once and prints it to
   the log in order to allow reproducible builds.
+* The declared field type for an extension registered via `@RegisterExtension` is no
+  longer required to implement an `Extension` API. It is now sufficient if the extension
+  implementation can be assigned to the declared field type. This provides extension
+  authors greater flexibility as well as the ability to hide implementation details of the
+  user facing extension API.
 * Methods ordered with `MethodOrderer.Random` now execute using the `SAME_THREAD`
   concurrency mode instead of the `CONCURRENT` mode when no custom seed is provided.
 * New `emptyValue` attribute in `@CsvFileSource` and `@CsvSource`.
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ExtensionUtils.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ExtensionUtils.java
index 03b71cd1d..c0d12f268 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ExtensionUtils.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ExtensionUtils.java
@@ -14,7 +14,8 @@ import static java.util.stream.Collectors.toList;
 import static org.junit.platform.commons.util.AnnotationUtils.findAnnotatedFields;
 import static org.junit.platform.commons.util.AnnotationUtils.findAnnotation;
 import static org.junit.platform.commons.util.AnnotationUtils.findRepeatableAnnotations;
-import static org.junit.platform.commons.util.ReflectionUtils.isPrivate;
+import static org.junit.platform.commons.util.ReflectionUtils.isNotPrivate;
+import static org.junit.platform.commons.util.ReflectionUtils.isNotStatic;
 import static org.junit.platform.commons.util.ReflectionUtils.isStatic;
 import static org.junit.platform.commons.util.ReflectionUtils.tryToReadFieldValue;
 
@@ -43,8 +44,8 @@ import org.junit.platform.commons.util.Preconditions;
  */
 final class ExtensionUtils {
 
-	private static final Predicate<Field> isStaticExtension = new IsStaticExtensionField();
-	private static final Predicate<Field> isNonStaticExtension = new IsNonStaticExtensionField();
+	static final Predicate<Field> isNonPrivateStaticField = field -> isNotPrivate(field) && isStatic(field);
+	static final Predicate<Field> isNonPrivateInstanceField = field -> isNotPrivate(field) && isNotStatic(field);
 
 	private ExtensionUtils() {
 		/* no-op */
@@ -65,8 +66,8 @@ final class ExtensionUtils {
 	static ExtensionRegistry populateNewExtensionRegistryFromExtendWithAnnotation(ExtensionRegistry parentRegistry,
 			AnnotatedElement annotatedElement) {
 
-		Preconditions.notNull(annotatedElement, "AnnotatedElement must not be null");
 		Preconditions.notNull(parentRegistry, "Parent ExtensionRegistry must not be null");
+		Preconditions.notNull(annotatedElement, "AnnotatedElement must not be null");
 
 		// @formatter:off
 		List<Class<? extends Extension>> extensionTypes = findRepeatableAnnotations(annotatedElement, ExtendWith.class).stream()
@@ -91,10 +92,10 @@ final class ExtensionUtils {
 	 * when searching for {@code static} fields in the class
 	 */
 	static void registerExtensionsFromFields(ExtensionRegistry registry, Class<?> clazz, Object instance) {
-		Preconditions.notNull(clazz, "Class must not be null");
 		Preconditions.notNull(registry, "ExtensionRegistry must not be null");
+		Preconditions.notNull(clazz, "Class must not be null");
 
-		Predicate<Field> predicate = (instance == null) ? isStaticExtension : isNonStaticExtension;
+		Predicate<Field> predicate = (instance == null ? isNonPrivateStaticField : isNonPrivateInstanceField);
 
 		// Ensure that the list is modifiable, since findAnnotatedFields() returns an unmodifiable list.
 		List<Field> fields = new ArrayList<>(findAnnotatedFields(clazz, RegisterExtension.class, predicate));
@@ -104,11 +105,10 @@ final class ExtensionUtils {
 
 		fields.forEach(field -> {
 			tryToReadFieldValue(field, instance).ifSuccess(value -> {
-				Preconditions.notNull(value, () -> String.format(
-					"Failed to register extension via @RegisterExtension field [%s]: field must not be null when evaluated.",
-					field));
-				Extension extension = (Extension) value;
-				registry.registerExtension(extension, field);
+				Preconditions.condition(value instanceof Extension, () -> String.format(
+					"Failed to register extension via @RegisterExtension field [%s]: field value's type [%s] must implement an [%s] API.",
+					field, (value != null ? value.getClass().getName() : null), Extension.class.getName()));
+				registry.registerExtension((Extension) value, field);
 			});
 		});
 	}
@@ -126,40 +126,4 @@ final class ExtensionUtils {
 		return findAnnotation(field, Order.class).map(Order::value).orElse(Integer.MAX_VALUE);
 	}
 
-	static class IsNonStaticExtensionField implements Predicate<Field> {
-
-		@Override
-		public boolean test(Field field) {
-			// Please do not collapse the following into a single statement.
-			if (isStatic(field)) {
-				return false;
-			}
-			if (isPrivate(field)) {
-				return false;
-			}
-			if (!Extension.class.isAssignableFrom(field.getType())) {
-				return false;
-			}
-			return true;
-		}
-	}
-
-	static class IsStaticExtensionField implements Predicate<Field> {
-
-		@Override
-		public boolean test(Field field) {
-			// Please do not collapse the following into a single statement.
-			if (!isStatic(field)) {
-				return false;
-			}
-			if (isPrivate(field)) {
-				return false;
-			}
-			if (!Extension.class.isAssignableFrom(field.getType())) {
-				return false;
-			}
-			return true;
-		}
-	}
-
 }
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/descriptor/ExtensionUtilsTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/descriptor/ExtensionUtilsTests.java
index deb94387c..f12a49647 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/descriptor/ExtensionUtilsTests.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/descriptor/ExtensionUtilsTests.java
@@ -18,11 +18,8 @@ import java.util.function.Predicate;
 import java.util.stream.Stream;
 
 import org.junit.jupiter.api.DynamicTest;
-import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.TestFactory;
 import org.junit.jupiter.api.extension.Extension;
-import org.junit.jupiter.engine.descriptor.ExtensionUtils.IsNonStaticExtensionField;
-import org.junit.jupiter.engine.descriptor.ExtensionUtils.IsStaticExtensionField;
 
 /**
  * Unit tests for {@link ExtensionUtils}.
@@ -31,42 +28,43 @@ import org.junit.jupiter.engine.descriptor.ExtensionUtils.IsStaticExtensionField
  */
 class ExtensionUtilsTests {
 
-	private final Predicate<Field> isStaticExtension = new IsStaticExtensionField();
-	private final Predicate<Field> isInstanceExtension = new IsNonStaticExtensionField();
+	private static final Predicate<Field> isPotentialStaticExtension = ExtensionUtils.isNonPrivateStaticField;
+	private static final Predicate<Field> isPotentialInstanceExtension = ExtensionUtils.isNonPrivateInstanceField;
 
-	static Object staticObject = new Object();
-	Object instanceObject = new Object();
+	static Extension staticExtension = new DummyExtension();
+	Extension instanceExtension = new DummyExtension();
+
+	static Object staticObject = new DummyExtension();
+	Object instanceObject = new DummyExtension();
 
 	@SuppressWarnings("unused")
 	private static Extension privateStaticExtension = new DummyExtension();
+
 	@SuppressWarnings("unused")
 	private Extension privateInstanceExtension = new DummyExtension();
 
-	static Extension staticExtension = new DummyExtension();
-	Extension instanceExtension = new DummyExtension();
-
-	@Test
-	void isStaticExtension() {
-		assertThat(isStaticExtension).accepts(field("staticExtension"));
+	@TestFactory
+	Stream<DynamicTest> isPotentialStaticExtension() {
+		return Stream.of("staticExtension", "staticObject")//
+				.map(name -> dynamicTest(name, () -> assertThat(isPotentialStaticExtension).accepts(field(name))));
 	}
 
 	@TestFactory
 	Stream<DynamicTest> isNotStaticExtension() {
-		return Stream.of("privateStaticExtension", "staticObject", "instanceObject", "instanceExtension")//
-				.map(name -> dynamicTest(name, () -> assertThat(isStaticExtension).rejects(field(name))));
+		return Stream.of("privateStaticExtension", "instanceObject", "instanceExtension")//
+				.map(name -> dynamicTest(name, () -> assertThat(isPotentialStaticExtension).rejects(field(name))));
 	}
 
-	@Test
-	void isInstanceExtension() {
-		assertThat(isInstanceExtension).accepts(field("instanceExtension"));
+	@TestFactory
+	Stream<DynamicTest> isPotentialInstanceExtension() {
+		return Stream.of("instanceExtension", "instanceObject")//
+				.map(name -> dynamicTest(name, () -> assertThat(isPotentialInstanceExtension).accepts(field(name))));
 	}
 
 	@TestFactory
 	Stream<DynamicTest> isNotInstanceExtension() {
-		// @formatter:off
-		return Stream.of("privateStaticExtension", "staticObject", "instanceObject", "privateInstanceExtension")
-				.map(name -> dynamicTest(name, () -> assertThat(isInstanceExtension).rejects(field(name))));
-		// @formatter:on
+		return Stream.of("privateStaticExtension", "staticObject", "privateInstanceExtension")//
+				.map(name -> dynamicTest(name, () -> assertThat(isPotentialInstanceExtension).rejects(field(name))));
 	}
 
 	private Field field(String name) {
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/ProgrammaticExtensionRegistrationTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/ProgrammaticExtensionRegistrationTests.java
index 8d0eac02b..b3dc45c43 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/ProgrammaticExtensionRegistrationTests.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/ProgrammaticExtensionRegistrationTests.java
@@ -133,25 +133,63 @@ class ProgrammaticExtensionRegistrationTests extends AbstractJupiterTestEngineTe
 		);
 	}
 
+	/**
+	 * @since 5.5
+	 */
+	@Test
+	void instanceLevelWithFieldThatDoesNotImplementAnExtensionApi() {
+		callSequence.clear();
+		assertOneTestSucceeded(InstanceLevelCustomExtensionApiTestCase.class);
+		assertThat(callSequence).containsExactly( //
+			CustomExtensionImpl.class.getSimpleName() + " :: before test", //
+			CustomExtensionImpl.class.getSimpleName() + " :: doSomething()" //
+		);
+	}
+
+	/**
+	 * @since 5.5
+	 */
+	@Test
+	void classLevelWithFieldThatDoesNotImplementAnExtensionApi() {
+		callSequence.clear();
+		assertOneTestSucceeded(ClassLevelCustomExtensionApiTestCase.class);
+		assertThat(callSequence).containsExactly( //
+			CustomExtensionImpl.class.getSimpleName() + " :: before test", //
+			CustomExtensionImpl.class.getSimpleName() + " :: doSomething()" //
+		);
+	}
+
+	/**
+	 * @since 5.5
+	 */
+	@Test
+	void instanceLevelWithNonExtensionFieldValue() {
+		Class<?> testClass = InstanceLevelExtensionRegistrationWithNonExtensionFieldValueTestCase.class;
+
+		executeTestsForClass(testClass).tests().assertThatEvents().haveExactly(1, finishedWithFailure(
+			instanceOf(PreconditionViolationException.class), message(expectedMessage(testClass, String.class))));
+	}
+
 	@Test
 	void instanceLevelWithNullField() {
 		Class<?> testClass = InstanceLevelExtensionRegistrationWithNullFieldTestCase.class;
 
-		executeTestsForClass(testClass).tests().assertThatEvents().haveExactly(1,
-			finishedWithFailure(instanceOf(PreconditionViolationException.class), message(expectedMessage(testClass))));
+		executeTestsForClass(testClass).tests().assertThatEvents().haveExactly(1, finishedWithFailure(
+			instanceOf(PreconditionViolationException.class), message(expectedMessage(testClass, null))));
 	}
 
 	@Test
 	void classLevelWithNullField() {
 		Class<?> testClass = ClassLevelExtensionRegistrationWithNullFieldTestCase.class;
 
-		executeTestsForClass(testClass).containers().assertThatEvents().haveExactly(1,
-			finishedWithFailure(instanceOf(PreconditionViolationException.class), message(expectedMessage(testClass))));
+		executeTestsForClass(testClass).containers().assertThatEvents().haveExactly(1, finishedWithFailure(
+			instanceOf(PreconditionViolationException.class), message(expectedMessage(testClass, null))));
 	}
 
-	private String expectedMessage(Class<?> testClass) {
+	private String expectedMessage(Class<?> testClass, Class<?> valueType) {
 		return "Failed to register extension via @RegisterExtension field [" + field(testClass)
-				+ "]: field must not be null when evaluated.";
+				+ "]: field value's type [" + (valueType != null ? valueType.getName() : null) + "] must implement an ["
+				+ Extension.class.getName() + "] API.";
 	}
 
 	private Field field(Class<?> testClass) {
@@ -461,6 +499,52 @@ class ProgrammaticExtensionRegistrationTests extends AbstractJupiterTestEngineTe
 
 	}
 
+	/**
+	 * This interface intentionally does not implement a supported {@link Extension} API.
+	 */
+	interface CustomExtension {
+
+		void doSomething();
+
+	}
+
+	static class CustomExtensionImpl implements CustomExtension, BeforeEachCallback {
+
+		@Override
+		public void doSomething() {
+			callSequence.add(getClass().getSimpleName() + " :: doSomething()");
+		}
+
+		@Override
+		public void beforeEach(ExtensionContext context) throws Exception {
+			callSequence.add(getClass().getSimpleName() + " :: before " + context.getRequiredTestMethod().getName());
+		}
+	}
+
+	static class InstanceLevelCustomExtensionApiTestCase {
+
+		@RegisterExtension
+		CustomExtension extension = new CustomExtensionImpl();
+
+		@Test
+		void test() {
+			this.extension.doSomething();
+		}
+
+	}
+
+	static class ClassLevelCustomExtensionApiTestCase {
+
+		@RegisterExtension
+		static CustomExtension extension = new CustomExtensionImpl();
+
+		@Test
+		void test() {
+			extension.doSomething();
+		}
+
+	}
+
 	static class AbstractTestCase {
 
 		@Test
@@ -483,6 +567,13 @@ class ProgrammaticExtensionRegistrationTests extends AbstractJupiterTestEngineTe
 
 	}
 
+	static class InstanceLevelExtensionRegistrationWithNonExtensionFieldValueTestCase extends AbstractTestCase {
+
+		@RegisterExtension
+		Object extension = "not an extension type";
+
+	}
+
 	static class ClassLevelExplosiveCheckedExceptionTestCase extends AbstractTestCase {
 
 		@RegisterExtension
