diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/MethodArgumentsProvider.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/MethodArgumentsProvider.java
index b30cba705..b018ff166 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/MethodArgumentsProvider.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/MethodArgumentsProvider.java
@@ -24,7 +24,6 @@ import java.util.stream.Stream;
 
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.TestFactory;
-import org.junit.jupiter.api.TestInstance.Lifecycle;
 import org.junit.jupiter.api.TestTemplate;
 import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.platform.commons.JUnitException;
@@ -51,7 +50,7 @@ class MethodArgumentsProvider extends AnnotationBasedArgumentsProvider<MethodSou
 		// @formatter:off
 		return stream(methodNames)
 				.map(factoryMethodName -> findFactoryMethod(testClass, testMethod, factoryMethodName))
-				.map(factoryMethod -> validateFactoryMethod(context, factoryMethod))
+				.map(factoryMethod -> validateFactoryMethod(context, factoryMethod, testInstance))
 				.map(factoryMethod -> context.getExecutableInvoker().invoke(factoryMethod, testInstance))
 				.flatMap(CollectionUtils::toStream)
 				.map(MethodArgumentsProvider::toArguments);
@@ -176,8 +175,8 @@ class MethodArgumentsProvider extends AnnotationBasedArgumentsProvider<MethodSou
 			cause -> new JUnitException(format("Could not load class [%s]", className), cause));
 	}
 
-	private static Method validateFactoryMethod(ExtensionContext context, Method factoryMethod) {
-		if (isPerMethodLifecycle(context)) {
+	private static Method validateFactoryMethod(ExtensionContext context, Method factoryMethod, Object testInstance) {
+		if (!factoryMethod.getDeclaringClass().isInstance(testInstance)) {
 			Preconditions.condition(ReflectionUtils.isStatic(factoryMethod),
 				() -> format("Method '%s' must be static: local factory methods must be static unless "
 						+ "the test class is annotated with @TestInstance(Lifecycle.PER_CLASS); external "
@@ -187,10 +186,6 @@ class MethodArgumentsProvider extends AnnotationBasedArgumentsProvider<MethodSou
 		return factoryMethod;
 	}
 
-	private static boolean isPerMethodLifecycle(ExtensionContext context) {
-		return context.getTestInstanceLifecycle().orElse(Lifecycle.PER_CLASS) == Lifecycle.PER_METHOD;
-	}
-
 	private static Arguments toArguments(Object item) {
 
 		// Nothing to do except cast.
diff --git a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/provider/MethodArgumentsProviderTests.java b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/provider/MethodArgumentsProviderTests.java
index f3e91a6c7..0df033899 100644
--- a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/provider/MethodArgumentsProviderTests.java
+++ b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/provider/MethodArgumentsProviderTests.java
@@ -174,10 +174,38 @@ class MethodArgumentsProviderTests {
 	}
 
 	@Test
-	void throwsExceptionWhenNonStaticFactoryMethodIsReferencedAndStaticIsRequired() {
+	void throwsExceptionWhenNonStaticLocalFactoryMethodIsReferencedWithLifecyclePerMethodSemantics() {
+		var lifecyclePerClass = false;
 		var exception = assertThrows(PreconditionViolationException.class,
-			() -> provideArguments(NonStaticTestCase.class, null, false, "nonStaticStringStreamProvider").toArray());
+			() -> provideArguments(NonStaticTestCase.class, lifecyclePerClass,
+				"nonStaticStringStreamProvider").toArray());
 
+		assertStaticIsRequired(exception);
+	}
+
+	@Test
+	void throwsExceptionWhenNonStaticExternalFactoryMethodIsReferencedWithLifecyclePerMethodSemantics() {
+		var factoryClass = NonStaticTestCase.class.getName();
+		var factoryMethod = factoryClass + "#nonStaticStringStreamProvider";
+		var lifecyclePerClass = false;
+		var exception = assertThrows(PreconditionViolationException.class,
+			() -> provideArguments(TestCase.class, lifecyclePerClass, factoryMethod).toArray());
+
+		assertStaticIsRequired(exception);
+	}
+
+	@Test
+	void throwsExceptionWhenNonStaticExternalFactoryMethodIsReferencedWithLifecyclePerClassSemantics() {
+		var factoryClass = NonStaticTestCase.class.getName();
+		var factoryMethod = factoryClass + "#nonStaticStringStreamProvider";
+		boolean lifecyclePerClass = true;
+		var exception = assertThrows(PreconditionViolationException.class,
+			() -> provideArguments(TestCase.class, lifecyclePerClass, factoryMethod).toArray());
+
+		assertStaticIsRequired(exception);
+	}
+
+	private static void assertStaticIsRequired(PreconditionViolationException exception) {
 		assertThat(exception).hasMessageContainingAll("Method '",
 			"' must be static: local factory methods must be static ",
 			"unless the test class is annotated with @TestInstance(Lifecycle.PER_CLASS); ",
@@ -186,7 +214,7 @@ class MethodArgumentsProviderTests {
 
 	@Test
 	void providesArgumentsFromNonStaticFactoryMethodWhenStaticIsNotRequired() {
-		var arguments = provideArguments(NonStaticTestCase.class, null, true, "nonStaticStringStreamProvider");
+		var arguments = provideArguments(NonStaticTestCase.class, true, "nonStaticStringStreamProvider");
 
 		assertThat(arguments).containsExactly(array("foo"), array("bar"));
 	}
@@ -609,7 +637,7 @@ class MethodArgumentsProviderTests {
 			String factoryMethod = factoryClass + "#factoryWithInvalidReturnType";
 
 			var exception = assertThrows(PreconditionViolationException.class,
-				() -> provideArguments(TestCase.class, null, false, factoryMethod).toArray());
+				() -> provideArguments(TestCase.class, false, factoryMethod).toArray());
 
 			assertThat(exception.getMessage())//
 					.containsSubsequence("Could not find valid factory method [" + factoryMethod + "] for test class [",
@@ -676,30 +704,24 @@ class MethodArgumentsProviderTests {
 	}
 
 	private Stream<Object[]> provideArguments(String... factoryMethodNames) {
-		return provideArguments(TestCase.class, null, false, factoryMethodNames);
+		return provideArguments(TestCase.class, false, factoryMethodNames);
 	}
 
 	private Stream<Object[]> provideArguments(Method testMethod, String factoryMethodName) {
 		return provideArguments(TestCase.class, testMethod, false, factoryMethodName);
 	}
 
-	private Stream<Object[]> provideArguments(Class<?> testClass, Method testMethod, boolean allowNonStaticMethod,
+	private Stream<Object[]> provideArguments(Class<?> testClass, boolean allowNonStaticMethod,
 			String... factoryMethodNames) {
 
-		if (testMethod == null) {
-			try {
-				class DummyClass {
-					@SuppressWarnings("unused")
-					public void dummyMethod() {
-					};
-				}
-				// ensure we have a non-null method, even if it's not a real test method.
-				testMethod = DummyClass.class.getMethod("dummyMethod");
-			}
-			catch (Exception ex) {
-				throw new RuntimeException(ex);
-			}
-		}
+		// Ensure we have a non-null test method, even if it's not a real test method.
+		// If this throws an exception, make sure that the supplied test class defines a "void test()" method.
+		Method testMethod = ReflectionUtils.findMethod(testClass, "test").get();
+		return provideArguments(testClass, testMethod, allowNonStaticMethod, factoryMethodNames);
+	}
+
+	private Stream<Object[]> provideArguments(Class<?> testClass, Method testMethod, boolean allowNonStaticMethod,
+			String... factoryMethodNames) {
 
 		var methodSource = mock(MethodSource.class);
 
@@ -940,6 +962,9 @@ class MethodArgumentsProviderTests {
 	// This test case mimics @TestInstance(Lifecycle.PER_CLASS)
 	static class NonStaticTestCase {
 
+		void test() {
+		}
+
 		Stream<String> nonStaticStringStreamProvider() {
 			return Stream.of("foo", "bar");
 		}
