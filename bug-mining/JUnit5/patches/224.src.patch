diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.4.0-M1.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.4.0-M1.adoc
index 45977acbf..c3500e21f 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.4.0-M1.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.4.0-M1.adoc
@@ -52,6 +52,9 @@ repository on GitHub.
   loader (_TCCL_) that was set when creating the underlying executor service. This
   resolves `ClassNotFoundException` issues that only occur in parallel execution mode
   when a custom _TCCL_ is in place.
+* When executing tests in parallel, lifecycle methods and callbacks called after a
+  `@TestFactory` method are now always executed after the dynamic tests returned by the
+  method.
 
 ==== Deprecations and Breaking Changes
 
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestFactoryTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestFactoryTestDescriptor.java
index 2b096a675..b2cdac9e0 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestFactoryTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestFactoryTestDescriptor.java
@@ -100,6 +100,7 @@ public class TestFactoryTestDescriptor extends TestMethodTestDescriptor implemen
 			catch (ClassCastException ex) {
 				throw invalidReturnTypeException(ex);
 			}
+			dynamicTestExecutor.awaitFinished();
 		});
 	}
 
diff --git a/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/Node.java b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/Node.java
index edb3b9c9d..1abe5da32 100644
--- a/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/Node.java
+++ b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/Node.java
@@ -243,6 +243,17 @@ public interface Node<C extends EngineExecutionContext> {
 		 */
 		void execute(TestDescriptor testDescriptor);
 
+		/**
+		 * Block until all dynamic test descriptors submitted to this executor
+		 * are finished.
+		 *
+		 * <p>This method is useful if the node needs to perform actions in its
+		 * {@link #execute(EngineExecutionContext, DynamicTestExecutor)} method
+		 * after all its dynamic children have finished.
+		 *
+		 * @throws InterruptedException if interrupted while waiting
+		 */
+		void awaitFinished() throws InterruptedException;
 	}
 
 	/**
diff --git a/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/NodeTestTask.java b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/NodeTestTask.java
index 5cc28e27b..f834efe0e 100644
--- a/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/NodeTestTask.java
+++ b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/NodeTestTask.java
@@ -16,11 +16,14 @@ import static org.junit.platform.engine.TestExecutionResult.failed;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Set;
+import java.util.concurrent.ExecutionException;
 import java.util.concurrent.Future;
 
 import org.junit.platform.commons.JUnitException;
+import org.junit.platform.commons.util.ExceptionUtils;
 import org.junit.platform.engine.TestDescriptor;
 import org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutorService.TestTask;
+import org.junit.platform.engine.support.hierarchical.Node.DynamicTestExecutor;
 import org.junit.platform.engine.support.hierarchical.Node.ExecutionMode;
 import org.junit.platform.engine.support.hierarchical.Node.SkipResult;
 
@@ -101,39 +104,20 @@ class NodeTestTask<C extends EngineExecutionContext> implements TestTask {
 
 			context = node.before(context);
 
-			List<Future<?>> futures = new ArrayList<>();
-			context = node.execute(context,
-				dynamicTestDescriptor -> executeDynamicTest(dynamicTestDescriptor, futures));
+			DynamicTestExecutor dynamicTestExecutor = new DefaultDynamicTestExecutor();
+			context = node.execute(context, dynamicTestExecutor);
 
 			if (!children.isEmpty()) {
 				children.forEach(child -> child.setParentContext(context));
 				taskContext.getExecutorService().invokeAll(children);
 			}
 
-			// using a for loop for the sake for ForkJoinPool's work stealing
-			for (Future<?> future : futures) {
-				future.get();
-			}
+			dynamicTestExecutor.awaitFinished();
 		});
 
 		throwableCollector.execute(() -> node.after(context));
 	}
 
-	private void executeDynamicTest(TestDescriptor dynamicTestDescriptor, List<Future<?>> futures) {
-		taskContext.getListener().dynamicTestRegistered(dynamicTestDescriptor);
-		Set<ExclusiveResource> exclusiveResources = NodeUtils.asNode(dynamicTestDescriptor).getExclusiveResources();
-		if (!exclusiveResources.isEmpty()) {
-			taskContext.getListener().executionStarted(dynamicTestDescriptor);
-			String message = "Dynamic test descriptors must not declare exclusive resources: " + exclusiveResources;
-			taskContext.getListener().executionFinished(dynamicTestDescriptor, failed(new JUnitException(message)));
-		}
-		else {
-			NodeTestTask<C> nodeTestTask = new NodeTestTask<>(taskContext, dynamicTestDescriptor);
-			nodeTestTask.setParentContext(context);
-			futures.add(taskContext.getExecutorService().submit(nodeTestTask));
-		}
-	}
-
 	private void cleanUp() {
 		throwableCollector.execute(() -> node.cleanUp(context));
 
@@ -155,4 +139,35 @@ class NodeTestTask<C extends EngineExecutionContext> implements TestTask {
 		throwableCollector = null;
 	}
 
+	private class DefaultDynamicTestExecutor implements DynamicTestExecutor {
+		private final List<Future<?>> futures = new ArrayList<>();
+
+		@Override
+		public void execute(TestDescriptor dynamicTestDescriptor) {
+			taskContext.getListener().dynamicTestRegistered(dynamicTestDescriptor);
+			Set<ExclusiveResource> exclusiveResources = NodeUtils.asNode(dynamicTestDescriptor).getExclusiveResources();
+			if (!exclusiveResources.isEmpty()) {
+				taskContext.getListener().executionStarted(dynamicTestDescriptor);
+				String message = "Dynamic test descriptors must not declare exclusive resources: " + exclusiveResources;
+				taskContext.getListener().executionFinished(dynamicTestDescriptor, failed(new JUnitException(message)));
+			}
+			else {
+				NodeTestTask<C> nodeTestTask = new NodeTestTask<>(taskContext, dynamicTestDescriptor);
+				nodeTestTask.setParentContext(context);
+				futures.add(taskContext.getExecutorService().submit(nodeTestTask));
+			}
+		}
+
+		@Override
+		public void awaitFinished() throws InterruptedException {
+			for (Future<?> future : futures) {
+				try {
+					future.get();
+				}
+				catch (ExecutionException e) {
+					ExceptionUtils.throwAsUncheckedException(e.getCause());
+				}
+			}
+		}
+	}
 }
diff --git a/platform-tests/src/test/java/org/junit/platform/engine/support/hierarchical/ParallelExecutionIntegrationTests.java b/platform-tests/src/test/java/org/junit/platform/engine/support/hierarchical/ParallelExecutionIntegrationTests.java
index 93cde50f0..11b33a66d 100644
--- a/platform-tests/src/test/java/org/junit/platform/engine/support/hierarchical/ParallelExecutionIntegrationTests.java
+++ b/platform-tests/src/test/java/org/junit/platform/engine/support/hierarchical/ParallelExecutionIntegrationTests.java
@@ -35,6 +35,8 @@ import java.net.URLClassLoader;
 import java.time.Instant;
 import java.util.Arrays;
 import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.locks.ReentrantLock;
@@ -148,6 +150,15 @@ class ParallelExecutionIntegrationTests {
 		assertThat(ThreadReporter.getThreadNames(executionEvents)).hasSize(1);
 	}
 
+	@Test
+	void afterHooksAreCalledAfterConcurrentDynamicTestsAreFinished() {
+		List<ExecutionEvent> executionEvents = execute(3, ConcurrentDynamicTestCase.class);
+
+		assertThat(executionEvents.stream().filter(event(test(), finishedSuccessfully())::matches)).hasSize(1);
+		Map<String, Instant> events = ConcurrentDynamicTestCase.events;
+		assertThat(events.get("afterEach")).isAfterOrEqualTo(events.get("dynamicTestFinished"));
+	}
+
 	private List<Instant> getTimestampsFor(List<ExecutionEvent> executionEvents, Condition<ExecutionEvent> condition) {
 		// @formatter:off
 		return executionEvents.stream()
@@ -410,6 +421,29 @@ class ParallelExecutionIntegrationTests {
 		}
 	}
 
+	@Execution(CONCURRENT)
+	static class ConcurrentDynamicTestCase {
+		static Map<String, Instant> events;
+
+		@BeforeAll
+		static void beforeAll() {
+			events = new ConcurrentHashMap<>();
+		}
+
+		@AfterEach
+		void afterEach() {
+			events.put("afterEach", Instant.now());
+		}
+
+		@TestFactory
+		DynamicTest testFactory() {
+			return dynamicTest("slow", () -> {
+				Thread.sleep(100);
+				events.put("dynamicTestFinished", Instant.now());
+			});
+		}
+	}
+
 	private static void incrementBlockAndCheck(AtomicInteger sharedResource, CountDownLatch countDownLatch)
 			throws InterruptedException {
 		int value = incrementAndBlock(sharedResource, countDownLatch);
