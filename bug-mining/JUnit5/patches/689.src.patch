diff --git a/documentation/src/docs/asciidoc/link-attributes.adoc b/documentation/src/docs/asciidoc/link-attributes.adoc
index 4010e54b7..9862695d6 100644
--- a/documentation/src/docs/asciidoc/link-attributes.adoc
+++ b/documentation/src/docs/asciidoc/link-attributes.adoc
@@ -111,6 +111,7 @@ endif::[]
 :ClassOrderer_OrderAnnotation:               {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/ClassOrderer.OrderAnnotation.html[ClassOrderer.OrderAnnotation]
 :ClassOrderer_Random:                        {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/ClassOrderer.Random.html[ClassOrderer.Random]
 :ClassOrderer:                               {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/ClassOrderer.html[ClassOrderer]
+:ContainerTemplate:                          {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/ContainerTemplate.html[@ContainerTemplate]
 :Disabled:                                   {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/Disabled.html[@Disabled]
 :MethodOrderer_Alphanumeric:                 {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/MethodOrderer.Alphanumeric.html[MethodOrderer.Alphanumeric]
 :MethodOrderer_DisplayName:                  {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/MethodOrderer.DisplayName.html[MethodOrderer.DisplayName]
@@ -142,6 +143,8 @@ endif::[]
 :BeforeAllCallback:                          {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/extension/BeforeAllCallback.html[BeforeAllCallback]
 :BeforeEachCallback:                         {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/extension/BeforeEachCallback.html[BeforeEachCallback]
 :BeforeTestExecutionCallback:                {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/extension/BeforeTestExecutionCallback.html[BeforeTestExecutionCallback]
+:ContainerTemplateInvocationContext:         {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/extension/ContainerTemplateInvocationContext.html[ContainerTemplateInvocationContext]
+:ContainerTemplateInvocationContextProvider: {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/extension/ContainerTemplateInvocationContextProvider.html[ContainerTemplateInvocationContextProvider]
 :ExecutableInvoker:                          {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/extension/ExecutableInvoker.html[ExecutableInvoker]
 :ExecutionCondition:                         {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/extension/ExecutionCondition.html[ExecutionCondition]
 :ExtendWith:                                 {javadoc-root}/org.junit.jupiter.api/org/junit/jupiter/api/extension/ExtendWith.html[@ExtendWith]
diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.13.0-M1.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.13.0-M1.adoc
index e7614bc3a..15c3a64fb 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.13.0-M1.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.13.0-M1.adoc
@@ -45,7 +45,11 @@ repository on GitHub.
 [[release-notes-5.13.0-M1-junit-jupiter-new-features-and-improvements]]
 ==== New Features and Improvements
 
-* ❓
+* Introduce `@ContainerTemplate` and `ContainerTemplateInvocationContextProvider` that
+  allow declaring a top-level or `@Nested` test class as a template to be invoked multiple
+  times. This may be used, for example, to inject different parameters to be used by all
+  tests in the container template class or to set up each invocation of the container
+  template differently.
 
 
 [[release-notes-5.13.0-M1-junit-vintage]]
diff --git a/documentation/src/docs/asciidoc/user-guide/extensions.adoc b/documentation/src/docs/asciidoc/user-guide/extensions.adoc
index 11185fe05..47bbd8947 100644
--- a/documentation/src/docs/asciidoc/user-guide/extensions.adoc
+++ b/documentation/src/docs/asciidoc/user-guide/extensions.adoc
@@ -765,6 +765,46 @@ You may override the `getTestInstantiationExtensionContextScope(...)` method to
 on the test method level.
 ====
 
+[[extensions-container-templates]]
+=== Providing Invocation Contexts for Container Templates
+
+A `{ContainerTemplate}` class can only be executed when at least one
+`{ContainerTemplateInvocationContextProvider}` is registered. Each such provider is
+responsible for providing a `Stream` of `{ContainerTemplateInvocationContext}` instances.
+Each context may specify a custom display name and a list of additional extensions that
+will only be used for the next invocation of the `{ContainerTemplate}` class.
+
+The following example shows how to write a container template as well as how to register
+and implement a `{ContainerTemplateInvocationContextProvider}`.
+
+[source,java,indent=0]
+.A container template with accompanying extension
+----
+include::{testDir}/example/ContainerTemplateDemo.java[tags=user_guide]
+----
+
+In this example, the container template will be invoked twice, meaning all test methods in
+the container template class will be executed twice. The display names of the container
+invocations will be `apple` and `banana` as specified by the invocation context. Each
+invocation registers a custom `{TestInstancePostProcessor}` which is used to inject a
+value into a field. The output when using the `ConsoleLauncher` is as follows.
+
+....
+└─ ContainerTemplateDemo ✔
+   ├─ apple ✔
+   │  ├─ notNull() ✔
+   │  └─ wellKnown() ✔
+   └─ banana ✔
+      ├─ notNull() ✔
+      └─ wellKnown() ✔
+....
+
+The `{ContainerTemplateInvocationContextProvider}` extension API is primarily intended for
+implementing different kinds of tests that rely on repetitive invocation of _all_ test
+methods in a test class albeit in different contexts — for example, with different
+parameters, by preparing the test class instance differently, or multiple times without
+modifying the context.
+
 [[extensions-test-templates]]
 === Providing Invocation Contexts for Test Templates
 
diff --git a/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc b/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
index 8442461ae..7ea683a04 100644
--- a/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
+++ b/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
@@ -32,7 +32,7 @@ in the `junit-jupiter-api` module.
 | `@ParameterizedTest`     | Denotes that a method is a <<writing-tests-parameterized-tests, parameterized test>>. Such methods are inherited unless they are overridden.
 | `@RepeatedTest`          | Denotes that a method is a test template for a <<writing-tests-repeated-tests, repeated test>>. Such methods are inherited unless they are overridden.
 | `@TestFactory`           | Denotes that a method is a test factory for <<writing-tests-dynamic-tests, dynamic tests>>. Such methods are inherited unless they are overridden.
-| `@TestTemplate`          | Denotes that a method is a <<writing-tests-test-templates, template for test cases>> designed to be invoked multiple times depending on the number of invocation contexts returned by the registered <<extensions-test-templates, providers>>. Such methods are inherited unless they are overridden.
+| `@TestTemplate`          | Denotes that a method is a <<writing-tests-test-templates, template for a test case>> designed to be invoked multiple times depending on the number of invocation contexts returned by the registered <<extensions-test-templates, providers>>. Such methods are inherited unless they are overridden.
 | `@TestClassOrder`        | Used to configure the <<writing-tests-test-execution-order-classes, test class execution order>> for `@Nested` test classes in the annotated test class. Such annotations are inherited.
 | `@TestMethodOrder`       | Used to configure the <<writing-tests-test-execution-order-methods, test method execution order>> for the annotated test class; similar to JUnit 4's `@FixMethodOrder`. Such annotations are inherited.
 | `@TestInstance`          | Used to configure the <<writing-tests-test-instance-lifecycle, test instance lifecycle>> for the annotated test class. Such annotations are inherited.
@@ -42,6 +42,7 @@ in the `junit-jupiter-api` module.
 | `@AfterEach`             | Denotes that the annotated method should be executed _after_ *each* `@Test`, `@RepeatedTest`, `@ParameterizedTest`, or `@TestFactory` method in the current class; analogous to JUnit 4's `@After`. Such methods are inherited unless they are overridden.
 | `@BeforeAll`             | Denotes that the annotated method should be executed _before_ *all* `@Test`, `@RepeatedTest`, `@ParameterizedTest`, and `@TestFactory` methods in the current class; analogous to JUnit 4's `@BeforeClass`. Such methods are inherited unless they are overridden and must be `static` unless the "per-class" <<writing-tests-test-instance-lifecycle, test instance lifecycle>> is used.
 | `@AfterAll`              | Denotes that the annotated method should be executed _after_ *all* `@Test`, `@RepeatedTest`, `@ParameterizedTest`, and `@TestFactory` methods in the current class; analogous to JUnit 4's `@AfterClass`. Such methods are inherited unless they are overridden and must be `static` unless the "per-class" <<writing-tests-test-instance-lifecycle, test instance lifecycle>> is used.
+| `@ContainerTemplate`     | Denotes that the annotated class is a <<writing-tests-container-templates, template for a set of test cases>> designed to be executed multiple times depending on the number of invocation contexts returned by the registered <<extensions-container-templates, providers>>.
 | `@Nested`                | Denotes that the annotated class is a non-static <<writing-tests-nested,nested test class>>. On Java 8 through Java 15, `@BeforeAll` and `@AfterAll` methods cannot be used directly in a `@Nested` test class unless the "per-class" <<writing-tests-test-instance-lifecycle, test instance lifecycle>> is used. Beginning with Java 16, `@BeforeAll` and `@AfterAll` methods can be declared as `static` in a `@Nested` test class with either test instance lifecycle mode. Such annotations are not inherited.
 | `@Tag`                   | Used to declare <<writing-tests-tagging-and-filtering,tags for filtering tests>>, either at the class or method level; analogous to test groups in TestNG or Categories in JUnit 4. Such annotations are inherited at the class level but not at the method level.
 | `@Disabled`              | Used to <<writing-tests-disabling,disable>> a test class or test method; analogous to JUnit 4's `@Ignore`. Such annotations are not inherited.
@@ -2448,12 +2449,22 @@ lifecycle methods (e.g. `@BeforeEach`) and test class constructors.
 include::{testDir}/example/ParameterizedTestDemo.java[tags=ParameterResolver_example]
 ----
 
+[[writing-tests-container-templates]]
+=== Container Templates
+
+A `{ContainerTemplate}` class is not a regular test class but rather a template for the
+contained test cases. As such, it is designed to be invoked multiple times depending on
+invocation contexts returned by the registered providers. Thus, it must be used in
+conjunction with a registered `{ContainerTemplateInvocationContextProvider}` extension.
+Each invocation of a container template class behaves like the execution of a regular test
+class with full support for the same lifecycle callbacks and extensions. Please refer to
+<<extensions-container-templates>> for usage examples.
 
 [[writing-tests-test-templates]]
 === Test Templates
 
-A `{TestTemplate}` method is not a regular test case but rather a template for test
-cases. As such, it is designed to be invoked multiple times depending on the number of
+A `{TestTemplate}` method is not a regular test case but rather a template for a test
+case. As such, it is designed to be invoked multiple times depending on the number of
 invocation contexts returned by the registered providers. Thus, it must be used in
 conjunction with a registered `{TestTemplateInvocationContextProvider}` extension. Each
 invocation of a test template method behaves like the execution of a regular `@Test`
diff --git a/documentation/src/test/java/example/ContainerTemplateDemo.java b/documentation/src/test/java/example/ContainerTemplateDemo.java
new file mode 100644
index 000000000..4baadb340
--- /dev/null
+++ b/documentation/src/test/java/example/ContainerTemplateDemo.java
@@ -0,0 +1,99 @@
+/*
+ * Copyright 2015-2025 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package example;
+
+import static java.util.Collections.singletonList;
+import static java.util.Collections.unmodifiableList;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.stream.Stream;
+
+import example.ContainerTemplateDemo.MyContainerTemplateInvocationContextProvider;
+
+import org.junit.jupiter.api.ContainerTemplate;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ContainerTemplateInvocationContext;
+import org.junit.jupiter.api.extension.ContainerTemplateInvocationContextProvider;
+import org.junit.jupiter.api.extension.ExtendWith;
+import org.junit.jupiter.api.extension.Extension;
+import org.junit.jupiter.api.extension.ExtensionContext;
+import org.junit.jupiter.api.extension.TestInstancePostProcessor;
+
+// tag::user_guide[]
+@ContainerTemplate
+@ExtendWith(MyContainerTemplateInvocationContextProvider.class)
+class ContainerTemplateDemo {
+
+	static final List<String> WELL_KNOWN_FRUITS
+	// tag::custom_line_break[]
+		= unmodifiableList(Arrays.asList("apple", "banana", "lemon"));
+
+	private String fruit;
+
+	@Test
+	void notNull() {
+		assertNotNull(fruit);
+	}
+
+	@Test
+	void wellKnown() {
+		assertTrue(WELL_KNOWN_FRUITS.contains(fruit));
+	}
+
+	// end::user_guide[]
+	static
+	// tag::user_guide[]
+	public class MyContainerTemplateInvocationContextProvider
+			// tag::custom_line_break[]
+			implements ContainerTemplateInvocationContextProvider {
+
+		@Override
+		public boolean supportsContainerTemplate(ExtensionContext context) {
+			return true;
+		}
+
+		@Override
+		public Stream<ContainerTemplateInvocationContext>
+				// tag::custom_line_break[]
+				provideContainerTemplateInvocationContexts(ExtensionContext context) {
+
+			return Stream.of(invocationContext("apple"), invocationContext("banana"));
+		}
+
+		private ContainerTemplateInvocationContext invocationContext(String parameter) {
+			return new ContainerTemplateInvocationContext() {
+				@Override
+				public String getDisplayName(int invocationIndex) {
+					return parameter;
+				}
+
+				// end::user_guide[]
+				@SuppressWarnings("Convert2Lambda")
+				// tag::user_guide[]
+				@Override
+				public List<Extension> getAdditionalExtensions() {
+					return singletonList(new TestInstancePostProcessor() {
+						@Override
+						public void postProcessTestInstance(
+								// tag::custom_line_break[]
+								Object testInstance, ExtensionContext context) {
+							((ContainerTemplateDemo) testInstance).fruit = parameter;
+						}
+					});
+				}
+			};
+		}
+	}
+}
+// end::user_guide[]
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AfterAll.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AfterAll.java
index 171f530fb..bce909ae8 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AfterAll.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/AfterAll.java
@@ -25,7 +25,13 @@ import org.apiguardian.api.API;
  * executed <em>after</em> <strong>all</strong> tests in the current test class.
  *
  * <p>In contrast to {@link AfterEach @AfterEach} methods, {@code @AfterAll}
- * methods are only executed once for a given test class.
+ * methods are only executed once per execution of a given test class. If the
+ * test class is annotated with {@link ContainerTemplate @ContainerTemplate},
+ * the {@code @AfterAll} methods are executed once after the last invocation of
+ * the container template. If a {@link Nested @Nested} test class is declared in
+ * a {@link ContainerTemplate @ContainerTemplate} class, its {@code @AfterAll}
+ * methods are called once per execution of the nested test class, namely, once
+ * per invocation of the outer container template.
  *
  * <h2>Method Signatures</h2>
  *
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/BeforeAll.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/BeforeAll.java
index e327653c4..6b0332d66 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/BeforeAll.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/BeforeAll.java
@@ -25,7 +25,13 @@ import org.apiguardian.api.API;
  * executed <em>before</em> <strong>all</strong> tests in the current test class.
  *
  * <p>In contrast to {@link BeforeEach @BeforeEach} methods, {@code @BeforeAll}
- * methods are only executed once for a given test class.
+ * methods are only executed once per execution of a given test class. If the
+ * test class is annotated with {@link ContainerTemplate @ContainerTemplate},
+ * the {@code @BeforeAll} methods are executed once before the first invocation
+ * of the container template. If a {@link Nested @Nested} test class is declared
+ * in a {@link ContainerTemplate @ContainerTemplate} class, its
+ * {@code @BeforeAll} methods are called once per execution of the nested test
+ * class, namely, once per invocation of the outer container template.
  *
  * <h2>Method Signatures</h2>
  *
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/ContainerTemplate.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/ContainerTemplate.java
new file mode 100644
index 000000000..6330e63c3
--- /dev/null
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/ContainerTemplate.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2015-2025 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.api;
+
+import static org.apiguardian.api.API.Status.EXPERIMENTAL;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+import org.apiguardian.api.API;
+import org.junit.platform.commons.annotation.Testable;
+
+/**
+ * {@code @ContainerTemplate} is used to signal that the annotated class is a
+ * <em>container template</em>.
+ *
+ * <p>In contrast to regular test classes, a container template is not directly
+ * a test class but rather a template for a set of test cases. As such, it is
+ * designed to be invoked multiple times depending on the number of {@linkplain
+ * org.junit.jupiter.api.extension.ContainerTemplateInvocationContext invocation
+ * contexts} returned by the registered {@linkplain
+ * org.junit.jupiter.api.extension.ContainerTemplateInvocationContextProvider
+ * providers}. Must be used together with at least one provider. Otherwise,
+ * execution will fail.
+ *
+ * <p>Each invocation of a container template method behaves like the execution
+ * of a regular test class with full support for the same lifecycle callbacks
+ * and extensions.
+ *
+ * <p>{@code @ContainerTemplate} may be combined with {@link Nested @Nested} and
+ * a container template may contain regular nested test classes or nested
+ * container templates.
+ *
+ * <p>{@code @ContainerTemplate} may also be used as a meta-annotation in order
+ * to create a custom <em>composed annotation</em> that inherits the semantics
+ * of {@code @ContainerTemplate}.
+ *
+ * <h2>Inheritance</h2>
+ *
+ * <p>The {@code @ContainerTemplate} annotation is not inherited to subclasses
+ * but needs to be declared on each container template class individually.
+ *
+ * @since 5.13
+ * @see TestTemplate
+ * @see org.junit.jupiter.api.extension.ContainerTemplateInvocationContext
+ * @see org.junit.jupiter.api.extension.ContainerTemplateInvocationContextProvider
+ */
+@Target({ ElementType.ANNOTATION_TYPE, ElementType.TYPE })
+@Retention(RetentionPolicy.RUNTIME)
+@Documented
+@API(status = EXPERIMENTAL, since = "5.13")
+@Testable
+public @interface ContainerTemplate {
+}
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Nested.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Nested.java
index 4d9661823..476efdb83 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Nested.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/Nested.java
@@ -31,6 +31,9 @@ import org.junit.jupiter.api.TestInstance.Lifecycle;
  * <p>{@code @Nested} test classes may be ordered via
  * {@link TestClassOrder @TestClassOrder} or a global {@link ClassOrderer}.
  *
+ * <p>{@code @Nested} may be combined with
+ * {@link ContainerTemplate @ContainerTemplate}.
+ *
  * <h2>Test Instance Lifecycle</h2>
  *
  * <ul>
@@ -42,6 +45,7 @@ import org.junit.jupiter.api.TestInstance.Lifecycle;
  * </ul>
  *
  * @since 5.0
+ * @see ContainerTemplate
  * @see Test
  * @see TestInstance
  * @see TestClassOrder
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/TestInstance.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/TestInstance.java
index 80f904a41..0202e3017 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/TestInstance.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/TestInstance.java
@@ -86,7 +86,12 @@ public @interface TestInstance {
 
 		/**
 		 * When using this mode, a new test instance will be created once per
-		 * test class.
+		 * test or container template class.
+		 *
+		 * <p>For {@link Nested @Nested}</p> test classes declared inside an
+		 * enclosing {@link ContainerTemplate @ContainerTemplate} test class, an
+		 * instance of the {@code @Nested} class will be created for each
+		 * invocation of the {@code @ContainerTemplate} test class.
 		 *
 		 * @see #PER_METHOD
 		 */
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/TestTemplate.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/TestTemplate.java
index 9636a2d01..2a60a011e 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/TestTemplate.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/TestTemplate.java
@@ -79,6 +79,7 @@ import org.junit.platform.commons.annotation.Testable;
  *
  * @since 5.0
  * @see Test
+ * @see ContainerTemplate
  * @see org.junit.jupiter.api.extension.TestTemplateInvocationContext
  * @see org.junit.jupiter.api.extension.TestTemplateInvocationContextProvider
  */
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ContainerTemplateInvocationContext.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ContainerTemplateInvocationContext.java
new file mode 100644
index 000000000..41477537d
--- /dev/null
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ContainerTemplateInvocationContext.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright 2015-2025 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.api.extension;
+
+import static java.util.Collections.emptyList;
+import static org.apiguardian.api.API.Status.EXPERIMENTAL;
+
+import java.util.List;
+
+import org.apiguardian.api.API;
+
+/**
+ * {@code ContainerTemplateInvocationContext} represents the <em>context</em> of
+ * a single invocation of a {@linkplain org.junit.jupiter.api.ContainerTemplate
+ * container template}.
+ *
+ * <p>Each context is provided by a
+ * {@link ContainerTemplateInvocationContextProvider}.
+ *
+ * @since 5.13
+ * @see org.junit.jupiter.api.ContainerTemplate
+ * @see ContainerTemplateInvocationContextProvider
+ */
+@API(status = EXPERIMENTAL, since = "5.13")
+public interface ContainerTemplateInvocationContext {
+
+	/**
+	 * Get the display name for this invocation.
+	 *
+	 * <p>The supplied {@code invocationIndex} is incremented by the framework
+	 * with each container invocation. Thus, in the case of multiple active
+	 * {@linkplain ContainerTemplateInvocationContextProvider providers}, only
+	 * the first active provider receives indices starting with {@code 1}.
+	 *
+	 * <p>The default implementation returns the supplied {@code invocationIndex}
+	 * wrapped in brackets &mdash; for example, {@code [1]}, {@code [42]}, etc.
+	 *
+	 * @param invocationIndex the index of this invocation (1-based).
+	 * @return the display name for this invocation; never {@code null} or blank
+	 */
+	default String getDisplayName(int invocationIndex) {
+		return "[" + invocationIndex + "]";
+	}
+
+	/**
+	 * Get the additional {@linkplain Extension extensions} for this invocation.
+	 *
+	 * <p>The extensions provided by this method will only be used for this
+	 * invocation of the container template. Thus, it does not make sense to
+	 * return an extension that acts solely on the container level (e.g.
+	 * {@link BeforeAllCallback}).
+	 *
+	 * <p>The default implementation returns an empty list.
+	 *
+	 * @return the additional extensions for this invocation; never {@code null}
+	 * or containing {@code null} elements, but potentially empty
+	 */
+	default List<Extension> getAdditionalExtensions() {
+		return emptyList();
+	}
+
+}
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ContainerTemplateInvocationContextProvider.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ContainerTemplateInvocationContextProvider.java
new file mode 100644
index 000000000..f0b62eca9
--- /dev/null
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ContainerTemplateInvocationContextProvider.java
@@ -0,0 +1,121 @@
+/*
+ * Copyright 2015-2025 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.api.extension;
+
+import static org.apiguardian.api.API.Status.EXPERIMENTAL;
+
+import java.util.stream.Stream;
+
+import org.apiguardian.api.API;
+
+/**
+ * {@code ContainerTemplateInvocationContextProvider} defines the API for
+ * {@link Extension Extensions} that wish to provide one or multiple contexts
+ * for the invocation of a
+ * {@link org.junit.jupiter.api.ContainerTemplate @ContainerTemplate} class.
+ *
+ * <p>This extension point makes it possible to execute a container template in
+ * different contexts &mdash; for example, with different parameters, by
+ * preparing the test class instance differently, or multiple times without
+ * modifying the context.
+ *
+ * <p>This interface defines two main methods:
+ * {@link #supportsContainerTemplate} and
+ * {@link #provideContainerTemplateInvocationContexts}. The former is called by
+ * the framework to determine whether this extension wants to act on a container
+ * template that is about to be executed. If so, the latter is called and must
+ * return a {@link Stream} of {@link ContainerTemplateInvocationContext}
+ * instances. Otherwise, this provider is ignored for the execution of the
+ * current container template.
+ *
+ * <p>A provider that has returned {@code true} from its
+ * {@link #supportsContainerTemplate} method is called <em>active</em>. When
+ * multiple providers are active for a container template class, the
+ * {@code Streams} returned by their
+ * {@link #provideContainerTemplateInvocationContexts} methods will be chained,
+ * and the container template method will be invoked using the contexts of all
+ * active providers.
+ *
+ * <p>An active provider may return zero invocation contexts from its
+ * {@link #provideContainerTemplateInvocationContexts} method if it overrides
+ * {@link #mayReturnZeroContainerTemplateInvocationContexts} to return
+ * {@code true}.
+ *
+ * <h2>Constructor Requirements</h2>
+ *
+ * <p>Consult the documentation in {@link Extension} for details on
+ * constructor requirements.
+ *
+ * @since 5.13
+ * @see org.junit.jupiter.api.ContainerTemplate
+ * @see ContainerTemplateInvocationContext
+ */
+@API(status = EXPERIMENTAL, since = "5.13")
+public interface ContainerTemplateInvocationContextProvider extends Extension {
+
+	/**
+	 * Determine if this provider supports providing invocation contexts for the
+	 * container template class represented by the supplied {@code context}.
+	 *
+	 * @param context the extension context for the container template class
+	 * about to be invoked; never {@code null}
+	 * @return {@code true} if this provider can provide invocation contexts
+	 * @see #provideContainerTemplateInvocationContexts
+	 * @see ExtensionContext
+	 */
+	boolean supportsContainerTemplate(ExtensionContext context);
+
+	/**
+	 * Provide
+	 * {@linkplain ContainerTemplateInvocationContext invocation contexts} for
+	 * the container template class represented by the supplied
+	 * {@code context}.
+	 *
+	 * <p>This method is only called by the framework if
+	 * {@link #supportsContainerTemplate} previously returned {@code true} for
+	 * the same {@link ExtensionContext}; this method is allowed to return an
+	 * empty {@code Stream} but not {@code null}.
+	 *
+	 * <p>The returned {@code Stream} will be properly closed by calling
+	 * {@link Stream#close()}, making it safe to use a resource such as
+	 * {@link java.nio.file.Files#lines(java.nio.file.Path) Files.lines()}.
+	 *
+	 * @param context the extension context for the container template class
+	 * about to be invoked; never {@code null}
+	 * @return a {@code Stream} of {@code ContainerTemplateInvocationContext}
+	 * instances for the invocation of the container template class; never {@code null}
+	 * @see #supportsContainerTemplate
+	 * @see ExtensionContext
+	 */
+	Stream<? extends ContainerTemplateInvocationContext> provideContainerTemplateInvocationContexts(
+			ExtensionContext context);
+
+	/**
+	 * Signal that this provider may provide zero
+	 * {@linkplain ContainerTemplateInvocationContext invocation contexts} for
+	 * the container template class represented by the supplied {@code context}.
+	 *
+	 * <p>If this method returns {@code false} (which is the default) and the
+	 * provider returns an empty stream from
+	 * {@link #provideContainerTemplateInvocationContexts}, this will be considered
+	 * an execution error. Override this method to return {@code true} to ignore
+	 * the absence of invocation contexts for this provider.
+	 *
+	 * @param context the extension context for the container template class
+	 * about to be invoked; never {@code null}
+	 * @return {@code true} to allow zero contexts, {@code false} to fail
+	 * execution in case of zero contexts
+	 */
+	default boolean mayReturnZeroContainerTemplateInvocationContexts(ExtensionContext context) {
+		return false;
+	}
+
+}
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/parallel/ResourceLock.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/parallel/ResourceLock.java
index 24c85cb26..4619fe11d 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/parallel/ResourceLock.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/parallel/ResourceLock.java
@@ -21,6 +21,7 @@ import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
 
 import org.apiguardian.api.API;
+import org.junit.jupiter.api.ContainerTemplate;
 
 /**
  * {@code @ResourceLock} is used to declare that the annotated test class or test
@@ -70,6 +71,11 @@ import org.apiguardian.api.API;
  * attribute remains applicable, and the target of "dynamic" shared resources added
  * via implementations of {@link ResourceLocksProvider} is not changed.
  *
+ * <p>Shared resources declared on or provided for methods or nested test
+ * classes in a {@link ContainerTemplate @ContainerTemplate} are propagated as
+ * if they were declared on the outermost enclosing {@code @ContainerTemplate}
+ * class itself.
+ *
  * @see Isolated
  * @see Resources
  * @see ResourceAccessMode
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassBasedTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassBasedTestDescriptor.java
index 5c514362e..0077d5d7f 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassBasedTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassBasedTestDescriptor.java
@@ -82,7 +82,8 @@ import org.junit.platform.engine.support.hierarchical.ThrowableCollector;
  * @since 5.5
  */
 @API(status = INTERNAL, since = "5.5")
-public abstract class ClassBasedTestDescriptor extends JupiterTestDescriptor implements ResourceLockAware {
+public abstract class ClassBasedTestDescriptor extends JupiterTestDescriptor
+		implements ResourceLockAware, TestClassAware {
 
 	private static final InterceptingExecutableInvoker executableInvoker = new InterceptingExecutableInvoker();
 
@@ -107,37 +108,49 @@ public abstract class ClassBasedTestDescriptor extends JupiterTestDescriptor imp
 		this.exclusiveResourceCollector = ExclusiveResourceCollector.from(testClass);
 	}
 
-	// --- TestDescriptor ------------------------------------------------------
+	ClassBasedTestDescriptor(UniqueId uniqueId, Class<?> testClass, String displayName,
+			JupiterConfiguration configuration) {
+		super(uniqueId, displayName, ClassSource.from(testClass), configuration);
 
+		this.testClass = testClass;
+		this.tags = getTags(testClass);
+		this.lifecycle = getTestInstanceLifecycle(testClass, configuration);
+		this.defaultChildExecutionMode = (this.lifecycle == Lifecycle.PER_CLASS ? ExecutionMode.SAME_THREAD : null);
+		this.exclusiveResourceCollector = ExclusiveResourceCollector.from(testClass);
+	}
+
+	// --- TestClassAware ------------------------------------------------------
+
+	@Override
 	public final Class<?> getTestClass() {
 		return this.testClass;
 	}
 
-	public abstract List<Class<?>> getEnclosingTestClasses();
+	// --- TestDescriptor ------------------------------------------------------
 
 	@Override
-	public Type getType() {
+	public final Type getType() {
 		return Type.CONTAINER;
 	}
 
 	@Override
-	public String getLegacyReportingName() {
+	public final String getLegacyReportingName() {
 		return this.testClass.getName();
 	}
 
 	// --- Node ----------------------------------------------------------------
 
 	@Override
-	protected Optional<ExecutionMode> getExplicitExecutionMode() {
+	protected final Optional<ExecutionMode> getExplicitExecutionMode() {
 		return getExecutionModeFromAnnotation(getTestClass());
 	}
 
 	@Override
-	protected Optional<ExecutionMode> getDefaultChildExecutionMode() {
+	protected final Optional<ExecutionMode> getDefaultChildExecutionMode() {
 		return Optional.ofNullable(this.defaultChildExecutionMode);
 	}
 
-	public void setDefaultChildExecutionMode(ExecutionMode defaultChildExecutionMode) {
+	public final void setDefaultChildExecutionMode(ExecutionMode defaultChildExecutionMode) {
 		this.defaultChildExecutionMode = defaultChildExecutionMode;
 	}
 
@@ -147,7 +160,7 @@ public abstract class ClassBasedTestDescriptor extends JupiterTestDescriptor imp
 	}
 
 	@Override
-	public JupiterEngineExecutionContext prepare(JupiterEngineExecutionContext context) {
+	public final JupiterEngineExecutionContext prepare(JupiterEngineExecutionContext context) {
 		MutableExtensionRegistry registry = populateNewExtensionRegistryFromExtendWithAnnotation(
 			context.getExtensionRegistry(), this.testClass);
 
@@ -194,7 +207,7 @@ public abstract class ClassBasedTestDescriptor extends JupiterTestDescriptor imp
 	}
 
 	@Override
-	public JupiterEngineExecutionContext before(JupiterEngineExecutionContext context) {
+	public final JupiterEngineExecutionContext before(JupiterEngineExecutionContext context) {
 		ThrowableCollector throwableCollector = context.getThrowableCollector();
 
 		if (isPerClassLifecycle(context)) {
@@ -223,7 +236,7 @@ public abstract class ClassBasedTestDescriptor extends JupiterTestDescriptor imp
 	}
 
 	@Override
-	public void after(JupiterEngineExecutionContext context) {
+	public final void after(JupiterEngineExecutionContext context) {
 
 		ThrowableCollector throwableCollector = context.getThrowableCollector();
 		Throwable previousThrowable = throwableCollector.getThrowable();
@@ -303,8 +316,8 @@ public abstract class ClassBasedTestDescriptor extends JupiterTestDescriptor imp
 			ExtensionContextSupplier extensionContext, ExtensionRegistry registry,
 			JupiterEngineExecutionContext context);
 
-	protected TestInstances instantiateTestClass(Optional<TestInstances> outerInstances, ExtensionRegistry registry,
-			ExtensionContextSupplier extensionContext) {
+	protected final TestInstances instantiateTestClass(Optional<TestInstances> outerInstances,
+			ExtensionRegistry registry, ExtensionContextSupplier extensionContext) {
 
 		Optional<Object> outerInstance = outerInstances.map(TestInstances::getInnermostInstance);
 		invokeTestInstancePreConstructCallbacks(new DefaultTestInstanceFactoryContext(this.testClass, outerInstance),
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassExtensionContext.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassExtensionContext.java
index aace0e86e..546472781 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassExtensionContext.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassExtensionContext.java
@@ -34,20 +34,6 @@ final class ClassExtensionContext extends AbstractExtensionContext<ClassBasedTes
 
 	private TestInstances testInstances;
 
-	/**
-	 * Create a new {@code ClassExtensionContext} with {@link Lifecycle#PER_METHOD}.
-	 *
-	 * @see #ClassExtensionContext(ExtensionContext, EngineExecutionListener, ClassBasedTestDescriptor,
-	 * Lifecycle, JupiterConfiguration, ExtensionRegistry, ThrowableCollector)
-	 */
-	ClassExtensionContext(ExtensionContext parent, EngineExecutionListener engineExecutionListener,
-			ClassBasedTestDescriptor testDescriptor, JupiterConfiguration configuration,
-			ExtensionRegistry extensionRegistry, ThrowableCollector throwableCollector) {
-
-		this(parent, engineExecutionListener, testDescriptor, Lifecycle.PER_METHOD, configuration, extensionRegistry,
-			throwableCollector);
-	}
-
 	ClassExtensionContext(ExtensionContext parent, EngineExecutionListener engineExecutionListener,
 			ClassBasedTestDescriptor testDescriptor, Lifecycle lifecycle, JupiterConfiguration configuration,
 			ExtensionRegistry extensionRegistry, ThrowableCollector throwableCollector) {
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTestDescriptor.java
index e935db38e..43d5cd8a6 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTestDescriptor.java
@@ -19,6 +19,7 @@ import java.util.List;
 import java.util.Optional;
 import java.util.Set;
 import java.util.function.Function;
+import java.util.function.UnaryOperator;
 
 import org.apiguardian.api.API;
 import org.junit.jupiter.api.extension.TestInstances;
@@ -51,6 +52,19 @@ public class ClassTestDescriptor extends ClassBasedTestDescriptor {
 		super(uniqueId, testClass, createDisplayNameSupplierForClass(testClass, configuration), configuration);
 	}
 
+	private ClassTestDescriptor(UniqueId uniqueId, Class<?> testClass, String displayName,
+			JupiterConfiguration configuration) {
+		super(uniqueId, testClass, displayName, configuration);
+	}
+
+	// --- JupiterTestDescriptor -----------------------------------------------
+
+	@Override
+	protected ClassTestDescriptor withUniqueId(UnaryOperator<UniqueId> uniqueIdTransformer) {
+		return new ClassTestDescriptor(uniqueIdTransformer.apply(getUniqueId()), getTestClass(), getDisplayName(),
+			configuration);
+	}
+
 	// --- TestDescriptor ------------------------------------------------------
 
 	@Override
@@ -59,6 +73,8 @@ public class ClassTestDescriptor extends ClassBasedTestDescriptor {
 		return new LinkedHashSet<>(this.tags);
 	}
 
+	// --- TestClassAware ------------------------------------------------------
+
 	@Override
 	public List<Class<?>> getEnclosingTestClasses() {
 		return emptyList();
@@ -72,6 +88,8 @@ public class ClassTestDescriptor extends ClassBasedTestDescriptor {
 			() -> JupiterTestDescriptor.toExecutionMode(configuration.getDefaultClassesExecutionMode()));
 	}
 
+	// --- ClassBasedTestDescriptor --------------------------------------------
+
 	@Override
 	protected TestInstances instantiateTestClass(JupiterEngineExecutionContext parentExecutionContext,
 			ExtensionContextSupplier extensionContext, ExtensionRegistry registry,
@@ -79,6 +97,8 @@ public class ClassTestDescriptor extends ClassBasedTestDescriptor {
 		return instantiateTestClass(Optional.empty(), registry, extensionContext);
 	}
 
+	// --- ResourceLockAware ---------------------------------------------------
+
 	@Override
 	public Function<ResourceLocksProvider, Set<ResourceLocksProvider.Lock>> getResourceLocksProviderEvaluator() {
 		return provider -> provider.provideForClass(getTestClass());
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ContainerTemplateInvocationExtensionContext.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ContainerTemplateInvocationExtensionContext.java
new file mode 100644
index 000000000..82a045824
--- /dev/null
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ContainerTemplateInvocationExtensionContext.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright 2015-2025 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.engine.descriptor;
+
+import java.lang.reflect.AnnotatedElement;
+import java.lang.reflect.Method;
+import java.util.Optional;
+
+import org.junit.jupiter.api.TestInstance.Lifecycle;
+import org.junit.jupiter.api.extension.ExtensionContext;
+import org.junit.jupiter.api.extension.TestInstances;
+import org.junit.jupiter.engine.config.JupiterConfiguration;
+import org.junit.jupiter.engine.extension.ExtensionRegistry;
+import org.junit.platform.engine.EngineExecutionListener;
+import org.junit.platform.engine.support.hierarchical.Node;
+
+/**
+ * @since 5.13
+ */
+final class ContainerTemplateInvocationExtensionContext
+		extends AbstractExtensionContext<ContainerTemplateInvocationTestDescriptor> {
+
+	ContainerTemplateInvocationExtensionContext(ExtensionContext parent,
+			EngineExecutionListener engineExecutionListener, ContainerTemplateInvocationTestDescriptor testDescriptor,
+			JupiterConfiguration configuration, ExtensionRegistry extensionRegistry) {
+		super(parent, engineExecutionListener, testDescriptor, configuration, extensionRegistry);
+	}
+
+	@Override
+	public Optional<AnnotatedElement> getElement() {
+		return Optional.of(getTestDescriptor().getTestClass());
+	}
+
+	@Override
+	public Optional<Class<?>> getTestClass() {
+		return Optional.of(getTestDescriptor().getTestClass());
+	}
+
+	@Override
+	public Optional<Lifecycle> getTestInstanceLifecycle() {
+		return getParent().flatMap(ExtensionContext::getTestInstanceLifecycle);
+	}
+
+	@Override
+	public Optional<Object> getTestInstance() {
+		return getParent().flatMap(ExtensionContext::getTestInstance);
+	}
+
+	@Override
+	public Optional<TestInstances> getTestInstances() {
+		return getParent().flatMap(ExtensionContext::getTestInstances);
+	}
+
+	@Override
+	public Optional<Method> getTestMethod() {
+		return Optional.empty();
+	}
+
+	@Override
+	public Optional<Throwable> getExecutionException() {
+		return Optional.empty();
+	}
+
+	@Override
+	protected Node.ExecutionMode getPlatformExecutionMode() {
+		return getTestDescriptor().getExecutionMode();
+	}
+
+}
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ContainerTemplateInvocationTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ContainerTemplateInvocationTestDescriptor.java
new file mode 100644
index 000000000..64cbdbe42
--- /dev/null
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ContainerTemplateInvocationTestDescriptor.java
@@ -0,0 +1,141 @@
+/*
+ * Copyright 2015-2025 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.engine.descriptor;
+
+import static org.apiguardian.api.API.Status.INTERNAL;
+import static org.junit.jupiter.engine.extension.MutableExtensionRegistry.createRegistryFrom;
+
+import java.util.List;
+import java.util.Set;
+import java.util.function.Function;
+import java.util.function.UnaryOperator;
+import java.util.stream.Stream;
+
+import org.apiguardian.api.API;
+import org.junit.jupiter.api.extension.ContainerTemplateInvocationContext;
+import org.junit.jupiter.api.extension.Extension;
+import org.junit.jupiter.api.extension.ExtensionContext;
+import org.junit.jupiter.api.parallel.ResourceLocksProvider;
+import org.junit.jupiter.engine.config.JupiterConfiguration;
+import org.junit.jupiter.engine.execution.JupiterEngineExecutionContext;
+import org.junit.jupiter.engine.extension.MutableExtensionRegistry;
+import org.junit.platform.engine.TestSource;
+import org.junit.platform.engine.UniqueId;
+
+/**
+ * @since 5.13
+ */
+@API(status = INTERNAL, since = "5.13")
+public class ContainerTemplateInvocationTestDescriptor extends JupiterTestDescriptor
+		implements TestClassAware, ResourceLockAware {
+
+	public static final String SEGMENT_TYPE = "container-template-invocation";
+
+	private final ContainerTemplateTestDescriptor parent;
+	private ContainerTemplateInvocationContext invocationContext;
+	private final int index;
+
+	public ContainerTemplateInvocationTestDescriptor(UniqueId uniqueId, ContainerTemplateTestDescriptor parent,
+			ContainerTemplateInvocationContext invocationContext, int index, TestSource source,
+			JupiterConfiguration configuration) {
+		super(uniqueId, invocationContext.getDisplayName(index), source, configuration);
+		this.parent = parent;
+		this.invocationContext = invocationContext;
+		this.index = index;
+	}
+
+	public int getIndex() {
+		return index;
+	}
+
+	// --- JupiterTestDescriptor -----------------------------------------------
+
+	@Override
+	protected ContainerTemplateInvocationTestDescriptor withUniqueId(UnaryOperator<UniqueId> uniqueIdTransformer) {
+		return new ContainerTemplateInvocationTestDescriptor(uniqueIdTransformer.apply(getUniqueId()), parent,
+			this.invocationContext, this.index, getSource().orElse(null), this.configuration);
+	}
+
+	// --- TestDescriptor ------------------------------------------------------
+
+	@Override
+	public Type getType() {
+		return Type.CONTAINER;
+	}
+
+	@Override
+	public String getLegacyReportingName() {
+		return getTestClass().getName() + "[" + index + "]";
+	}
+
+	// --- TestClassAware ------------------------------------------------------
+
+	@Override
+	public Class<?> getTestClass() {
+		return parent.getTestClass();
+	}
+
+	@Override
+	public List<Class<?>> getEnclosingTestClasses() {
+		return parent.getEnclosingTestClasses();
+	}
+
+	// --- ResourceLockAware ---------------------------------------------------
+
+	@Override
+	public ExclusiveResourceCollector getExclusiveResourceCollector() {
+		return parent.getExclusiveResourceCollector();
+	}
+
+	@Override
+	public Function<ResourceLocksProvider, Set<ResourceLocksProvider.Lock>> getResourceLocksProviderEvaluator() {
+		return parent.getResourceLocksProviderEvaluator();
+	}
+
+	// --- Node ----------------------------------------------------------------
+
+	@Override
+	public SkipResult shouldBeSkipped(JupiterEngineExecutionContext context) {
+		return SkipResult.doNotSkip();
+	}
+
+	@Override
+	public JupiterEngineExecutionContext prepare(JupiterEngineExecutionContext context) {
+		MutableExtensionRegistry registry = context.getExtensionRegistry();
+		List<Extension> additionalExtensions = this.invocationContext.getAdditionalExtensions();
+		if (!additionalExtensions.isEmpty()) {
+			MutableExtensionRegistry childRegistry = createRegistryFrom(registry, Stream.empty());
+			additionalExtensions.forEach(
+				extension -> childRegistry.registerExtension(extension, this.invocationContext));
+			registry = childRegistry;
+		}
+		ExtensionContext extensionContext = new ContainerTemplateInvocationExtensionContext(
+			context.getExtensionContext(), context.getExecutionListener(), this, context.getConfiguration(), registry);
+		return context.extend() //
+				.withExtensionContext(extensionContext) //
+				.withExtensionRegistry(registry) //
+				.build();
+	}
+
+	@Override
+	public JupiterEngineExecutionContext execute(JupiterEngineExecutionContext context,
+			DynamicTestExecutor dynamicTestExecutor) throws Exception {
+		Visitor visitor = context.getExecutionListener()::dynamicTestRegistered;
+		getChildren().forEach(child -> child.accept(visitor));
+		return context;
+	}
+
+	@Override
+	public void cleanUp(JupiterEngineExecutionContext context) {
+		// forget invocationContext so it can be garbage collected
+		this.invocationContext = null;
+	}
+}
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ContainerTemplateTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ContainerTemplateTestDescriptor.java
new file mode 100644
index 000000000..d59debe38
--- /dev/null
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ContainerTemplateTestDescriptor.java
@@ -0,0 +1,263 @@
+/*
+ * Copyright 2015-2025 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.engine.descriptor;
+
+import static java.util.stream.Collectors.toCollection;
+import static java.util.stream.Collectors.toList;
+import static org.apiguardian.api.API.Status.INTERNAL;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.function.Function;
+import java.util.function.UnaryOperator;
+import java.util.stream.Stream;
+
+import org.apiguardian.api.API;
+import org.junit.jupiter.api.ContainerTemplate;
+import org.junit.jupiter.api.extension.ContainerTemplateInvocationContext;
+import org.junit.jupiter.api.extension.ContainerTemplateInvocationContextProvider;
+import org.junit.jupiter.api.extension.ExtensionContext;
+import org.junit.jupiter.api.extension.TestInstances;
+import org.junit.jupiter.api.parallel.ResourceLocksProvider;
+import org.junit.jupiter.engine.execution.ExtensionContextSupplier;
+import org.junit.jupiter.engine.execution.JupiterEngineExecutionContext;
+import org.junit.jupiter.engine.extension.ExtensionRegistry;
+import org.junit.platform.engine.TestDescriptor;
+import org.junit.platform.engine.TestTag;
+import org.junit.platform.engine.UniqueId;
+import org.junit.platform.engine.support.hierarchical.ExclusiveResource;
+import org.junit.platform.engine.support.hierarchical.Node;
+
+/**
+ * @since 5.13
+ */
+@API(status = INTERNAL, since = "5.13")
+public class ContainerTemplateTestDescriptor extends ClassBasedTestDescriptor implements Filterable {
+
+	public static final String STATIC_CLASS_SEGMENT_TYPE = "container-template";
+	public static final String NESTED_CLASS_SEGMENT_TYPE = "nested-container-template";
+
+	private final Map<Integer, Collection<? extends TestDescriptor>> childrenPrototypesByIndex = new HashMap<>();
+	private final List<TestDescriptor> childrenPrototypes = new ArrayList<>();
+	private final ClassBasedTestDescriptor delegate;
+	private final DynamicDescendantFilter dynamicDescendantFilter;
+
+	public ContainerTemplateTestDescriptor(UniqueId uniqueId, ClassBasedTestDescriptor delegate) {
+		this(uniqueId, delegate, new DynamicDescendantFilter());
+	}
+
+	private ContainerTemplateTestDescriptor(UniqueId uniqueId, ClassBasedTestDescriptor delegate,
+			DynamicDescendantFilter dynamicDescendantFilter) {
+		super(uniqueId, delegate.getTestClass(), delegate.getDisplayName(), delegate.configuration);
+		this.delegate = delegate;
+		this.dynamicDescendantFilter = dynamicDescendantFilter;
+	}
+
+	// --- TestDescriptor ------------------------------------------------------
+
+	@Override
+	public Set<TestTag> getTags() {
+		// return modifiable copy
+		return new LinkedHashSet<>(this.tags);
+	}
+
+	// --- Filterable ----------------------------------------------------------
+
+	@Override
+	public DynamicDescendantFilter getDynamicDescendantFilter() {
+		return dynamicDescendantFilter;
+	}
+
+	// --- JupiterTestDescriptor -----------------------------------------------
+
+	@Override
+	protected JupiterTestDescriptor copyIncludingDescendants(UnaryOperator<UniqueId> uniqueIdTransformer) {
+		ContainerTemplateTestDescriptor copy = (ContainerTemplateTestDescriptor) super.copyIncludingDescendants(
+			uniqueIdTransformer);
+		this.childrenPrototypes.forEach(oldChild -> {
+			TestDescriptor newChild = ((JupiterTestDescriptor) oldChild).copyIncludingDescendants(uniqueIdTransformer);
+			copy.childrenPrototypes.add(newChild);
+		});
+		this.childrenPrototypesByIndex.forEach((index, oldChildren) -> {
+			List<TestDescriptor> newChildren = oldChildren.stream() //
+					.map(oldChild -> ((JupiterTestDescriptor) oldChild).copyIncludingDescendants(uniqueIdTransformer)) //
+					.collect(toList());
+			copy.childrenPrototypesByIndex.put(index, newChildren);
+		});
+		return copy;
+	}
+
+	@Override
+	protected ContainerTemplateTestDescriptor withUniqueId(UnaryOperator<UniqueId> uniqueIdTransformer) {
+		return new ContainerTemplateTestDescriptor(uniqueIdTransformer.apply(getUniqueId()), this.delegate,
+			this.dynamicDescendantFilter.copy(uniqueIdTransformer));
+	}
+
+	@Override
+	public void prunePriorToFiltering() {
+		// do nothing to allow PostDiscoveryFilters to be applied first
+	}
+
+	// --- TestDescriptor ------------------------------------------------------
+
+	@Override
+	public void prune() {
+		super.prune();
+		this.children.forEach(child -> child.accept(TestDescriptor::prune));
+		// Second iteration to avoid processing children that were pruned in the first iteration
+		this.children.forEach(child -> {
+			if (child instanceof ContainerTemplateInvocationTestDescriptor) {
+				int index = ((ContainerTemplateInvocationTestDescriptor) child).getIndex();
+				this.dynamicDescendantFilter.allowIndex(index - 1);
+				this.childrenPrototypesByIndex.put(index, child.getChildren());
+			}
+			else {
+				this.childrenPrototypes.add(child);
+			}
+		});
+		this.children.clear();
+	}
+
+	@Override
+	public boolean mayRegisterTests() {
+		return !childrenPrototypes.isEmpty() || !childrenPrototypesByIndex.isEmpty();
+	}
+
+	// --- TestClassAware ------------------------------------------------------
+
+	@Override
+	public List<Class<?>> getEnclosingTestClasses() {
+		return delegate.getEnclosingTestClasses();
+	}
+
+	// --- ClassBasedTestDescriptor --------------------------------------------
+
+	@Override
+	public TestInstances instantiateTestClass(JupiterEngineExecutionContext parentExecutionContext,
+			ExtensionContextSupplier extensionContext, ExtensionRegistry registry,
+			JupiterEngineExecutionContext context) {
+		return delegate.instantiateTestClass(parentExecutionContext, extensionContext, registry, context);
+	}
+
+	// --- ResourceLockAware ---------------------------------------------------
+
+	@Override
+	public Function<ResourceLocksProvider, Set<ResourceLocksProvider.Lock>> getResourceLocksProviderEvaluator() {
+		return delegate.getResourceLocksProviderEvaluator();
+	}
+
+	// --- Node ----------------------------------------------------------------
+
+	@Override
+	public Set<ExclusiveResource> getExclusiveResources() {
+		Set<ExclusiveResource> result = determineExclusiveResources().collect(toCollection(HashSet::new));
+		Visitor visitor = testDescriptor -> {
+			if (testDescriptor instanceof Node) {
+				result.addAll(((Node<?>) testDescriptor).getExclusiveResources());
+			}
+		};
+		this.childrenPrototypes.forEach(child -> child.accept(visitor));
+		this.childrenPrototypesByIndex.values() //
+				.forEach(prototypes -> prototypes //
+						.forEach(child -> child.accept(visitor)));
+		return result;
+	}
+
+	@Override
+	public void cleanUp(JupiterEngineExecutionContext context) {
+		this.childrenPrototypes.clear();
+		this.childrenPrototypesByIndex.clear();
+		this.dynamicDescendantFilter.allowAll();
+	}
+
+	@Override
+	public JupiterEngineExecutionContext execute(JupiterEngineExecutionContext context,
+			DynamicTestExecutor dynamicTestExecutor) throws Exception {
+
+		new ContainerTemplateExecutor().execute(context, dynamicTestExecutor);
+		return context;
+	}
+
+	class ContainerTemplateExecutor
+			extends TemplateExecutor<ContainerTemplateInvocationContextProvider, ContainerTemplateInvocationContext> {
+
+		public ContainerTemplateExecutor() {
+			super(ContainerTemplateTestDescriptor.this, ContainerTemplateInvocationContextProvider.class);
+		}
+
+		@Override
+		boolean supports(ContainerTemplateInvocationContextProvider provider, ExtensionContext extensionContext) {
+			return provider.supportsContainerTemplate(extensionContext);
+		}
+
+		@Override
+		protected String getNoRegisteredProviderErrorMessage() {
+			return String.format("You must register at least one %s that supports @%s class [%s]",
+				ContainerTemplateInvocationContextProvider.class.getSimpleName(),
+				ContainerTemplate.class.getSimpleName(), getTestClass().getName());
+		}
+
+		@Override
+		Stream<? extends ContainerTemplateInvocationContext> provideContexts(
+				ContainerTemplateInvocationContextProvider provider, ExtensionContext extensionContext) {
+			return provider.provideContainerTemplateInvocationContexts(extensionContext);
+		}
+
+		@Override
+		boolean mayReturnZeroContexts(ContainerTemplateInvocationContextProvider provider,
+				ExtensionContext extensionContext) {
+			return provider.mayReturnZeroContainerTemplateInvocationContexts(extensionContext);
+		}
+
+		@Override
+		protected String getZeroContextsProvidedErrorMessage(ContainerTemplateInvocationContextProvider provider) {
+			return String.format(
+				"Provider [%s] did not provide any invocation contexts, but was expected to do so. "
+						+ "You may override mayReturnZeroContainerTemplateInvocationContexts() to allow this.",
+				provider.getClass().getSimpleName());
+		}
+
+		@Override
+		UniqueId createInvocationUniqueId(UniqueId parentUniqueId, int index) {
+			return parentUniqueId.append(ContainerTemplateInvocationTestDescriptor.SEGMENT_TYPE, "#" + index);
+		}
+
+		@Override
+		TestDescriptor createInvocationTestDescriptor(UniqueId uniqueId,
+				ContainerTemplateInvocationContext invocationContext, int index) {
+			ContainerTemplateInvocationTestDescriptor containerInvocationDescriptor = new ContainerTemplateInvocationTestDescriptor(
+				uniqueId, ContainerTemplateTestDescriptor.this, invocationContext, index, getSource().orElse(null),
+				ContainerTemplateTestDescriptor.this.configuration);
+
+			collectChildren(index, uniqueId) //
+					.forEach(containerInvocationDescriptor::addChild);
+
+			return containerInvocationDescriptor;
+		}
+
+		private Stream<? extends TestDescriptor> collectChildren(int index, UniqueId invocationUniqueId) {
+			if (ContainerTemplateTestDescriptor.this.childrenPrototypesByIndex.containsKey(index)) {
+				return ContainerTemplateTestDescriptor.this.childrenPrototypesByIndex.remove(index).stream();
+			}
+			UnaryOperator<UniqueId> transformer = new UniqueIdPrefixTransformer(getUniqueId(), invocationUniqueId);
+			return ContainerTemplateTestDescriptor.this.childrenPrototypes.stream() //
+					.map(JupiterTestDescriptor.class::cast) //
+					.map(it -> it.copyIncludingDescendants(transformer));
+		}
+	}
+
+}
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DynamicContainerTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DynamicContainerTestDescriptor.java
index 96b7d6e13..8f157b9f8 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DynamicContainerTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DynamicContainerTestDescriptor.java
@@ -14,6 +14,7 @@ import static org.junit.jupiter.engine.descriptor.TestFactoryTestDescriptor.crea
 
 import java.util.Optional;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.UnaryOperator;
 import java.util.stream.Stream;
 
 import org.junit.jupiter.api.DynamicContainer;
@@ -46,6 +47,12 @@ class DynamicContainerTestDescriptor extends DynamicNodeTestDescriptor {
 		this.dynamicDescendantFilter = dynamicDescendantFilter;
 	}
 
+	@Override
+	protected DynamicContainerTestDescriptor withUniqueId(UnaryOperator<UniqueId> uniqueIdTransformer) {
+		return new DynamicContainerTestDescriptor(uniqueIdTransformer.apply(getUniqueId()), this.index,
+			this.dynamicContainer, this.testSource, this.dynamicDescendantFilter, this.configuration);
+	}
+
 	@Override
 	public Type getType() {
 		return Type.CONTAINER;
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DynamicDescendantFilter.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DynamicDescendantFilter.java
index 15b059ca4..ded323498 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DynamicDescendantFilter.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DynamicDescendantFilter.java
@@ -15,6 +15,7 @@ import static org.apiguardian.api.API.Status.INTERNAL;
 import java.util.HashSet;
 import java.util.Set;
 import java.util.function.BiPredicate;
+import java.util.function.UnaryOperator;
 
 import org.apiguardian.api.API;
 import org.junit.platform.engine.TestDescriptor;
@@ -40,6 +41,12 @@ public class DynamicDescendantFilter implements BiPredicate<UniqueId, Integer> {
 		}
 	}
 
+	public void allowIndex(int index) {
+		if (this.mode == Mode.EXPLICIT) {
+			this.allowedIndices.add(index);
+		}
+	}
+
 	public void allowIndex(Set<Integer> indices) {
 		if (this.mode == Mode.EXPLICIT) {
 			this.allowedIndices.addAll(indices);
@@ -79,6 +86,18 @@ public class DynamicDescendantFilter implements BiPredicate<UniqueId, Integer> {
 		EXPLICIT, ALLOW_ALL
 	}
 
+	public DynamicDescendantFilter copy(UnaryOperator<UniqueId> uniqueIdTransformer) {
+		return configure(uniqueIdTransformer, new DynamicDescendantFilter());
+	}
+
+	protected DynamicDescendantFilter configure(UnaryOperator<UniqueId> uniqueIdTransformer,
+			DynamicDescendantFilter copy) {
+		this.allowedUniqueIds.stream().map(uniqueIdTransformer).forEach(copy.allowedUniqueIds::add);
+		copy.allowedIndices.addAll(this.allowedIndices);
+		copy.mode = this.mode;
+		return copy;
+	}
+
 	private class WithoutIndexFiltering extends DynamicDescendantFilter {
 
 		@Override
@@ -90,5 +109,10 @@ public class DynamicDescendantFilter implements BiPredicate<UniqueId, Integer> {
 		public DynamicDescendantFilter withoutIndexFiltering() {
 			return this;
 		}
+
+		@Override
+		public DynamicDescendantFilter copy(UnaryOperator<UniqueId> uniqueIdTransformer) {
+			return configure(uniqueIdTransformer, new WithoutIndexFiltering());
+		}
 	}
 }
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DynamicNodeTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DynamicNodeTestDescriptor.java
index c5e83da28..9ed1f81ca 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DynamicNodeTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DynamicNodeTestDescriptor.java
@@ -11,6 +11,7 @@
 package org.junit.jupiter.engine.descriptor;
 
 import org.junit.jupiter.api.DynamicNode;
+import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.engine.config.JupiterConfiguration;
 import org.junit.jupiter.engine.execution.JupiterEngineExecutionContext;
 import org.junit.platform.engine.TestDescriptor;
@@ -24,7 +25,7 @@ import org.junit.platform.engine.UniqueId;
  */
 abstract class DynamicNodeTestDescriptor extends JupiterTestDescriptor {
 
-	private final int index;
+	protected final int index;
 
 	DynamicNodeTestDescriptor(UniqueId uniqueId, int index, DynamicNode dynamicNode, TestSource testSource,
 			JupiterConfiguration configuration) {
@@ -44,7 +45,7 @@ abstract class DynamicNodeTestDescriptor extends JupiterTestDescriptor {
 
 	@Override
 	public JupiterEngineExecutionContext prepare(JupiterEngineExecutionContext context) {
-		DynamicExtensionContext extensionContext = new DynamicExtensionContext(context.getExtensionContext(),
+		ExtensionContext extensionContext = new DynamicExtensionContext(context.getExtensionContext(),
 			context.getExecutionListener(), this, context.getConfiguration(), context.getExtensionRegistry());
 		// @formatter:off
 		return context.extend()
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DynamicTestTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DynamicTestTestDescriptor.java
index e504b311a..9209b8c1f 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DynamicTestTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DynamicTestTestDescriptor.java
@@ -10,6 +10,8 @@
 
 package org.junit.jupiter.engine.descriptor;
 
+import java.util.function.UnaryOperator;
+
 import org.junit.jupiter.api.DynamicTest;
 import org.junit.jupiter.api.extension.DynamicTestInvocationContext;
 import org.junit.jupiter.api.extension.ExtensionContext;
@@ -41,6 +43,12 @@ class DynamicTestTestDescriptor extends DynamicNodeTestDescriptor {
 		this.dynamicTest = dynamicTest;
 	}
 
+	@Override
+	protected DynamicTestTestDescriptor withUniqueId(UnaryOperator<UniqueId> uniqueIdTransformer) {
+		return new DynamicTestTestDescriptor(uniqueIdTransformer.apply(getUniqueId()), this.index, this.dynamicTest,
+			this.getSource().orElse(null), this.configuration);
+	}
+
 	@Override
 	public Type getType() {
 		return Type.TEST;
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/JupiterTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/JupiterTestDescriptor.java
index 0101f9d2b..27344fc49 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/JupiterTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/JupiterTestDescriptor.java
@@ -26,11 +26,13 @@ import java.util.List;
 import java.util.Optional;
 import java.util.Set;
 import java.util.function.Supplier;
+import java.util.function.UnaryOperator;
 
 import org.apiguardian.api.API;
 import org.junit.jupiter.api.Tag;
 import org.junit.jupiter.api.extension.ConditionEvaluationResult;
 import org.junit.jupiter.api.extension.Extension;
+import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.api.parallel.Execution;
 import org.junit.jupiter.engine.config.JupiterConfiguration;
 import org.junit.jupiter.engine.execution.ConditionEvaluator;
@@ -202,7 +204,8 @@ public abstract class JupiterTestDescriptor extends AbstractTestDescriptor
 	}
 
 	/**
-	 * Must be overridden and return a new context so cleanUp() does not accidentally close the parent context.
+	 * Must be overridden and return a new context with a new {@link ExtensionContext}
+	 * so cleanUp() does not accidentally close the parent context.
 	 */
 	@Override
 	public abstract JupiterEngineExecutionContext prepare(JupiterEngineExecutionContext context) throws Exception;
@@ -212,6 +215,27 @@ public abstract class JupiterTestDescriptor extends AbstractTestDescriptor
 		context.close();
 	}
 
+	public void prunePriorToFiltering() {
+		prune();
+	}
+
+	/**
+	 * {@return a deep copy (with copies of children) of this descriptor with the supplied unique ID}
+	 */
+	protected JupiterTestDescriptor copyIncludingDescendants(UnaryOperator<UniqueId> uniqueIdTransformer) {
+		JupiterTestDescriptor result = withUniqueId(uniqueIdTransformer);
+		getChildren().forEach(oldChild -> {
+			TestDescriptor newChild = ((JupiterTestDescriptor) oldChild).copyIncludingDescendants(uniqueIdTransformer);
+			result.addChild(newChild);
+		});
+		return result;
+	}
+
+	/**
+	 * {@return shallow copy (without children) of this descriptor with the supplied unique ID}
+	 */
+	protected abstract JupiterTestDescriptor withUniqueId(UnaryOperator<UniqueId> uniqueIdTransformer);
+
 	/**
 	 * @since 5.5
 	 */
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/MethodBasedTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/MethodBasedTestDescriptor.java
index 3a5b78559..c38ecd72f 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/MethodBasedTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/MethodBasedTestDescriptor.java
@@ -108,9 +108,9 @@ public abstract class MethodBasedTestDescriptor extends JupiterTestDescriptor im
 
 	private List<Class<?>> getEnclosingTestClasses() {
 		return getParent() //
-				.filter(ClassBasedTestDescriptor.class::isInstance) //
-				.map(ClassBasedTestDescriptor.class::cast) //
-				.map(ClassBasedTestDescriptor::getEnclosingTestClasses) //
+				.filter(TestClassAware.class::isInstance) //
+				.map(TestClassAware.class::cast) //
+				.map(TestClassAware::getEnclosingTestClasses) //
 				.orElseGet(Collections::emptyList);
 	}
 
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/NestedClassTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/NestedClassTestDescriptor.java
index b0619fa09..aad262a66 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/NestedClassTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/NestedClassTestDescriptor.java
@@ -22,6 +22,7 @@ import java.util.Optional;
 import java.util.Set;
 import java.util.function.Function;
 import java.util.function.Supplier;
+import java.util.function.UnaryOperator;
 
 import org.apiguardian.api.API;
 import org.junit.jupiter.api.extension.TestInstances;
@@ -55,6 +56,19 @@ public class NestedClassTestDescriptor extends ClassBasedTestDescriptor {
 			createDisplayNameSupplierForNestedClass(enclosingInstanceTypes, testClass, configuration), configuration);
 	}
 
+	private NestedClassTestDescriptor(UniqueId uniqueId, Class<?> testClass, String displayName,
+			JupiterConfiguration configuration) {
+		super(uniqueId, testClass, displayName, configuration);
+	}
+
+	// --- JupiterTestDescriptor -----------------------------------------------
+
+	@Override
+	protected NestedClassTestDescriptor withUniqueId(UnaryOperator<UniqueId> uniqueIdTransformer) {
+		return new NestedClassTestDescriptor(uniqueIdTransformer.apply(getUniqueId()), getTestClass(), getDisplayName(),
+			configuration);
+	}
+
 	// --- TestDescriptor ------------------------------------------------------
 
 	@Override
@@ -65,6 +79,8 @@ public class NestedClassTestDescriptor extends ClassBasedTestDescriptor {
 		return allTags;
 	}
 
+	// --- TestClassAware ------------------------------------------------------
+
 	@Override
 	public List<Class<?>> getEnclosingTestClasses() {
 		return getEnclosingTestClasses(getParent().orElse(null));
@@ -72,8 +88,8 @@ public class NestedClassTestDescriptor extends ClassBasedTestDescriptor {
 
 	@API(status = INTERNAL, since = "5.12")
 	public static List<Class<?>> getEnclosingTestClasses(TestDescriptor parent) {
-		if (parent instanceof ClassBasedTestDescriptor) {
-			ClassBasedTestDescriptor parentClassDescriptor = (ClassBasedTestDescriptor) parent;
+		if (parent instanceof TestClassAware) {
+			TestClassAware parentClassDescriptor = (TestClassAware) parent;
 			List<Class<?>> result = new ArrayList<>(parentClassDescriptor.getEnclosingTestClasses());
 			result.add(parentClassDescriptor.getTestClass());
 			return result;
@@ -81,7 +97,7 @@ public class NestedClassTestDescriptor extends ClassBasedTestDescriptor {
 		return emptyList();
 	}
 
-	// --- Node ----------------------------------------------------------------
+	// --- ClassBasedTestDescriptor --------------------------------------------
 
 	@Override
 	protected TestInstances instantiateTestClass(JupiterEngineExecutionContext parentExecutionContext,
@@ -95,6 +111,8 @@ public class NestedClassTestDescriptor extends ClassBasedTestDescriptor {
 		return instantiateTestClass(Optional.of(outerInstances), registry, extensionContext);
 	}
 
+	// --- ResourceLockAware ---------------------------------------------------
+
 	@Override
 	public Function<ResourceLocksProvider, Set<ResourceLocksProvider.Lock>> getResourceLocksProviderEvaluator() {
 		return enclosingInstanceTypesDependentResourceLocksProviderEvaluator(this::getEnclosingTestClasses, (provider,
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TemplateExecutor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TemplateExecutor.java
new file mode 100644
index 000000000..649889636
--- /dev/null
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TemplateExecutor.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright 2015-2025 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.engine.descriptor;
+
+import static java.util.stream.Collectors.toList;
+
+import java.util.List;
+import java.util.Optional;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.stream.Stream;
+
+import org.junit.jupiter.api.extension.Extension;
+import org.junit.jupiter.api.extension.ExtensionContext;
+import org.junit.jupiter.engine.execution.JupiterEngineExecutionContext;
+import org.junit.jupiter.engine.extension.ExtensionRegistry;
+import org.junit.platform.commons.util.Preconditions;
+import org.junit.platform.engine.TestDescriptor;
+import org.junit.platform.engine.UniqueId;
+import org.junit.platform.engine.support.hierarchical.Node;
+
+abstract class TemplateExecutor<P extends Extension, C> {
+
+	private final TestDescriptor parent;
+	private final Class<P> providerType;
+	private final DynamicDescendantFilter dynamicDescendantFilter;
+
+	<T extends TestDescriptor & Filterable> TemplateExecutor(T parent, Class<P> providerType) {
+		this.parent = parent;
+		this.providerType = providerType;
+		this.dynamicDescendantFilter = parent.getDynamicDescendantFilter();
+	}
+
+	void execute(JupiterEngineExecutionContext context, Node.DynamicTestExecutor dynamicTestExecutor) {
+		ExtensionContext extensionContext = context.getExtensionContext();
+		List<P> providers = validateProviders(extensionContext, context.getExtensionRegistry());
+		AtomicInteger invocationIndex = new AtomicInteger();
+		for (P provider : providers) {
+			executeForProvider(provider, invocationIndex, dynamicTestExecutor, extensionContext);
+		}
+	}
+
+	private void executeForProvider(P provider, AtomicInteger invocationIndex,
+			Node.DynamicTestExecutor dynamicTestExecutor, ExtensionContext extensionContext) {
+
+		int initialValue = invocationIndex.get();
+
+		try (Stream<? extends C> stream = provideContexts(provider, extensionContext)) {
+			stream.forEach(invocationContext -> createInvocationTestDescriptor(invocationContext,
+				invocationIndex.incrementAndGet()) //
+						.ifPresent(testDescriptor -> execute(dynamicTestExecutor, testDescriptor)));
+		}
+
+		Preconditions.condition(
+			invocationIndex.get() != initialValue || mayReturnZeroContexts(provider, extensionContext),
+			getZeroContextsProvidedErrorMessage(provider));
+	}
+
+	private List<P> validateProviders(ExtensionContext extensionContext, ExtensionRegistry extensionRegistry) {
+		List<P> providers = extensionRegistry.stream(providerType) //
+				.filter(provider -> supports(provider, extensionContext)) //
+				.collect(toList());
+		return Preconditions.notEmpty(providers, this::getNoRegisteredProviderErrorMessage);
+	}
+
+	private Optional<TestDescriptor> createInvocationTestDescriptor(C invocationContext, int index) {
+		UniqueId invocationUniqueId = createInvocationUniqueId(parent.getUniqueId(), index);
+		if (this.dynamicDescendantFilter.test(invocationUniqueId, index - 1)) {
+			return Optional.of(createInvocationTestDescriptor(invocationUniqueId, invocationContext, index));
+		}
+		return Optional.empty();
+	}
+
+	private void execute(Node.DynamicTestExecutor dynamicTestExecutor, TestDescriptor testDescriptor) {
+		testDescriptor.setParent(parent);
+		dynamicTestExecutor.execute(testDescriptor);
+	}
+
+	abstract boolean supports(P provider, ExtensionContext extensionContext);
+
+	protected abstract String getNoRegisteredProviderErrorMessage();
+
+	abstract Stream<? extends C> provideContexts(P provider, ExtensionContext extensionContext);
+
+	abstract boolean mayReturnZeroContexts(P provider, ExtensionContext extensionContext);
+
+	protected abstract String getZeroContextsProvidedErrorMessage(P provider);
+
+	abstract UniqueId createInvocationUniqueId(UniqueId parentUniqueId, int index);
+
+	abstract TestDescriptor createInvocationTestDescriptor(UniqueId uniqueId, C invocationContext, int index);
+
+}
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestClassAware.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestClassAware.java
new file mode 100644
index 000000000..f337b53ca
--- /dev/null
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestClassAware.java
@@ -0,0 +1,29 @@
+/*
+ * Copyright 2015-2025 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.engine.descriptor;
+
+import static org.apiguardian.api.API.Status.INTERNAL;
+
+import java.util.List;
+
+import org.apiguardian.api.API;
+
+/**
+ * @since 5.13
+ */
+@API(status = INTERNAL, since = "5.13")
+public interface TestClassAware {
+
+	Class<?> getTestClass();
+
+	List<Class<?>> getEnclosingTestClasses();
+
+}
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestFactoryTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestFactoryTestDescriptor.java
index f0d37814b..f145e5531 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestFactoryTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestFactoryTestDescriptor.java
@@ -21,6 +21,7 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.Optional;
 import java.util.function.Supplier;
+import java.util.function.UnaryOperator;
 import java.util.stream.Stream;
 
 import org.apiguardian.api.API;
@@ -61,11 +62,27 @@ public class TestFactoryTestDescriptor extends TestMethodTestDescriptor implemen
 	private static final ReflectiveInterceptorCall<Method, Object> interceptorCall = InvocationInterceptor::interceptTestFactoryMethod;
 	private static final InterceptingExecutableInvoker executableInvoker = new InterceptingExecutableInvoker();
 
-	private final DynamicDescendantFilter dynamicDescendantFilter = new DynamicDescendantFilter();
+	private final DynamicDescendantFilter dynamicDescendantFilter;
 
 	public TestFactoryTestDescriptor(UniqueId uniqueId, Class<?> testClass, Method testMethod,
 			Supplier<List<Class<?>>> enclosingInstanceTypes, JupiterConfiguration configuration) {
 		super(uniqueId, testClass, testMethod, enclosingInstanceTypes, configuration);
+		this.dynamicDescendantFilter = new DynamicDescendantFilter();
+	}
+
+	private TestFactoryTestDescriptor(UniqueId uniqueId, String displayName, Class<?> testClass, Method testMethod,
+			JupiterConfiguration configuration, DynamicDescendantFilter dynamicDescendantFilter) {
+		super(uniqueId, displayName, testClass, testMethod, configuration);
+		this.dynamicDescendantFilter = dynamicDescendantFilter;
+	}
+
+	// --- JupiterTestDescriptor -----------------------------------------------
+
+	@Override
+	protected TestFactoryTestDescriptor withUniqueId(UnaryOperator<UniqueId> uniqueIdTransformer) {
+		// TODO #871 Check that dynamic descendant filter is copied correctly
+		return new TestFactoryTestDescriptor(uniqueIdTransformer.apply(getUniqueId()), getDisplayName(), getTestClass(),
+			getTestMethod(), this.configuration, this.dynamicDescendantFilter.copy(uniqueIdTransformer));
 	}
 
 	// --- Filterable ----------------------------------------------------------
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestMethodTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestMethodTestDescriptor.java
index 67fa136a5..8d3b14a82 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestMethodTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestMethodTestDescriptor.java
@@ -19,6 +19,7 @@ import static org.junit.platform.commons.util.CollectionUtils.forEachInReverseOr
 import java.lang.reflect.Method;
 import java.util.List;
 import java.util.function.Supplier;
+import java.util.function.UnaryOperator;
 
 import org.apiguardian.api.API;
 import org.junit.jupiter.api.TestInstance.Lifecycle;
@@ -82,12 +83,27 @@ public class TestMethodTestDescriptor extends MethodBasedTestDescriptor {
 		this.interceptorCall = defaultInterceptorCall;
 	}
 
+	TestMethodTestDescriptor(UniqueId uniqueId, String displayName, Class<?> testClass, Method testMethod,
+			JupiterConfiguration configuration) {
+		this(uniqueId, displayName, testClass, testMethod, configuration, defaultInterceptorCall);
+	}
+
 	TestMethodTestDescriptor(UniqueId uniqueId, String displayName, Class<?> testClass, Method testMethod,
 			JupiterConfiguration configuration, ReflectiveInterceptorCall<Method, Void> interceptorCall) {
 		super(uniqueId, displayName, testClass, testMethod, configuration);
 		this.interceptorCall = interceptorCall;
 	}
 
+	// --- JupiterTestDescriptor -----------------------------------------------
+
+	@Override
+	protected TestMethodTestDescriptor withUniqueId(UnaryOperator<UniqueId> uniqueIdTransformer) {
+		return new TestMethodTestDescriptor(uniqueIdTransformer.apply(getUniqueId()), getDisplayName(), getTestClass(),
+			getTestMethod(), this.configuration, interceptorCall);
+	}
+
+	// --- TestDescriptor ------------------------------------------------------
+
 	@Override
 	public Type getType() {
 		return Type.TEST;
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestTemplateInvocationTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestTemplateInvocationTestDescriptor.java
index cbb66f12d..2437c297b 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestTemplateInvocationTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestTemplateInvocationTestDescriptor.java
@@ -15,6 +15,7 @@ import static org.apiguardian.api.API.Status.INTERNAL;
 
 import java.lang.reflect.Method;
 import java.util.Set;
+import java.util.function.UnaryOperator;
 
 import org.apiguardian.api.API;
 import org.junit.jupiter.api.extension.InvocationInterceptor;
@@ -51,6 +52,16 @@ public class TestTemplateInvocationTestDescriptor extends TestMethodTestDescript
 		this.index = index;
 	}
 
+	// --- JupiterTestDescriptor -----------------------------------------------
+
+	@Override
+	protected TestTemplateInvocationTestDescriptor withUniqueId(UnaryOperator<UniqueId> uniqueIdTransformer) {
+		return new TestTemplateInvocationTestDescriptor(uniqueIdTransformer.apply(getUniqueId()), getTestClass(),
+			getTestMethod(), this.invocationContext, this.index, this.configuration);
+	}
+
+	// --- TestDescriptor ------------------------------------------------------
+
 	@Override
 	public Set<ExclusiveResource> getExclusiveResources() {
 		// Resources are already collected and returned by the enclosing container
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestTemplateTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestTemplateTestDescriptor.java
index e592ba3a6..05ef02c0c 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestTemplateTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestTemplateTestDescriptor.java
@@ -10,27 +10,24 @@
 
 package org.junit.jupiter.engine.descriptor;
 
-import static java.util.stream.Collectors.toList;
 import static org.apiguardian.api.API.Status.INTERNAL;
 import static org.junit.jupiter.engine.descriptor.ExtensionUtils.populateNewExtensionRegistryFromExtendWithAnnotation;
 
 import java.lang.reflect.Method;
 import java.util.List;
-import java.util.Optional;
-import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.Supplier;
+import java.util.function.UnaryOperator;
 import java.util.stream.Stream;
 
 import org.apiguardian.api.API;
+import org.junit.jupiter.api.TestTemplate;
 import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.api.extension.TestInstances;
 import org.junit.jupiter.api.extension.TestTemplateInvocationContext;
 import org.junit.jupiter.api.extension.TestTemplateInvocationContextProvider;
 import org.junit.jupiter.engine.config.JupiterConfiguration;
 import org.junit.jupiter.engine.execution.JupiterEngineExecutionContext;
-import org.junit.jupiter.engine.extension.ExtensionRegistry;
 import org.junit.jupiter.engine.extension.MutableExtensionRegistry;
-import org.junit.platform.commons.util.Preconditions;
 import org.junit.platform.engine.TestDescriptor;
 import org.junit.platform.engine.UniqueId;
 
@@ -44,11 +41,27 @@ import org.junit.platform.engine.UniqueId;
 public class TestTemplateTestDescriptor extends MethodBasedTestDescriptor implements Filterable {
 
 	public static final String SEGMENT_TYPE = "test-template";
-	private final DynamicDescendantFilter dynamicDescendantFilter = new DynamicDescendantFilter();
+	private final DynamicDescendantFilter dynamicDescendantFilter;
 
 	public TestTemplateTestDescriptor(UniqueId uniqueId, Class<?> testClass, Method templateMethod,
 			Supplier<List<Class<?>>> enclosingInstanceTypes, JupiterConfiguration configuration) {
 		super(uniqueId, testClass, templateMethod, enclosingInstanceTypes, configuration);
+		this.dynamicDescendantFilter = new DynamicDescendantFilter();
+	}
+
+	private TestTemplateTestDescriptor(UniqueId uniqueId, String displayName, Class<?> testClass, Method templateMethod,
+			JupiterConfiguration configuration, DynamicDescendantFilter dynamicDescendantFilter) {
+		super(uniqueId, displayName, testClass, templateMethod, configuration);
+		this.dynamicDescendantFilter = dynamicDescendantFilter;
+	}
+
+	// --- JupiterTestDescriptor -----------------------------------------------
+
+	@Override
+	protected TestTemplateTestDescriptor withUniqueId(UnaryOperator<UniqueId> uniqueIdTransformer) {
+		return new TestTemplateTestDescriptor(uniqueIdTransformer.apply(getUniqueId()), getDisplayName(),
+			getTestClass(), getTestMethod(), this.configuration,
+			this.dynamicDescendantFilter.copy(uniqueIdTransformer));
 	}
 
 	// --- Filterable ----------------------------------------------------------
@@ -95,65 +108,59 @@ public class TestTemplateTestDescriptor extends MethodBasedTestDescriptor implem
 	public JupiterEngineExecutionContext execute(JupiterEngineExecutionContext context,
 			DynamicTestExecutor dynamicTestExecutor) throws Exception {
 
-		ExtensionContext extensionContext = context.getExtensionContext();
-		List<TestTemplateInvocationContextProvider> providers = validateProviders(extensionContext,
-			context.getExtensionRegistry());
-		AtomicInteger invocationIndex = new AtomicInteger();
-		for (TestTemplateInvocationContextProvider provider : providers) {
-			executeForProvider(provider, invocationIndex, dynamicTestExecutor, extensionContext);
-		}
+		new TestTemplateExecutor().execute(context, dynamicTestExecutor);
 		return context;
 	}
 
-	private void executeForProvider(TestTemplateInvocationContextProvider provider, AtomicInteger invocationIndex,
-			DynamicTestExecutor dynamicTestExecutor, ExtensionContext extensionContext) {
-
-		int initialValue = invocationIndex.get();
+	private class TestTemplateExecutor
+			extends TemplateExecutor<TestTemplateInvocationContextProvider, TestTemplateInvocationContext> {
 
-		try (Stream<TestTemplateInvocationContext> stream = invocationContexts(provider, extensionContext)) {
-			stream.forEach(invocationContext -> toTestDescriptor(invocationContext, invocationIndex.incrementAndGet()) //
-					.ifPresent(testDescriptor -> execute(dynamicTestExecutor, testDescriptor)));
+		TestTemplateExecutor() {
+			super(TestTemplateTestDescriptor.this, TestTemplateInvocationContextProvider.class);
 		}
 
-		Preconditions.condition(
-			invocationIndex.get() != initialValue
-					|| provider.mayReturnZeroTestTemplateInvocationContexts(extensionContext),
-			String.format(
-				"Provider [%s] did not provide any invocation contexts, but was expected to do so. "
-						+ "You may override mayReturnZeroTestTemplateInvocationContexts() to allow this.",
-				provider.getClass().getSimpleName()));
-	}
+		@Override
+		boolean supports(TestTemplateInvocationContextProvider provider, ExtensionContext extensionContext) {
+			return provider.supportsTestTemplate(extensionContext);
+		}
 
-	private static Stream<TestTemplateInvocationContext> invocationContexts(
-			TestTemplateInvocationContextProvider provider, ExtensionContext extensionContext) {
-		return provider.provideTestTemplateInvocationContexts(extensionContext);
-	}
+		@Override
+		protected String getNoRegisteredProviderErrorMessage() {
+			return String.format("You must register at least one %s that supports @%s method [%s]",
+				TestTemplateInvocationContextProvider.class.getSimpleName(), TestTemplate.class.getSimpleName(),
+				getTestMethod());
+		}
 
-	private List<TestTemplateInvocationContextProvider> validateProviders(ExtensionContext extensionContext,
-			ExtensionRegistry extensionRegistry) {
+		@Override
+		Stream<? extends TestTemplateInvocationContext> provideContexts(TestTemplateInvocationContextProvider provider,
+				ExtensionContext extensionContext) {
+			return provider.provideTestTemplateInvocationContexts(extensionContext);
+		}
 
-		// @formatter:off
-		List<TestTemplateInvocationContextProvider> providers = extensionRegistry.stream(TestTemplateInvocationContextProvider.class)
-				.filter(provider -> provider.supportsTestTemplate(extensionContext))
-				.collect(toList());
-		// @formatter:on
+		@Override
+		boolean mayReturnZeroContexts(TestTemplateInvocationContextProvider provider,
+				ExtensionContext extensionContext) {
+			return provider.mayReturnZeroTestTemplateInvocationContexts(extensionContext);
+		}
 
-		return Preconditions.notEmpty(providers,
-			() -> String.format("You must register at least one %s that supports @TestTemplate method [%s]",
-				TestTemplateInvocationContextProvider.class.getSimpleName(), getTestMethod()));
-	}
+		@Override
+		protected String getZeroContextsProvidedErrorMessage(TestTemplateInvocationContextProvider provider) {
+			return String.format(
+				"Provider [%s] did not provide any invocation contexts, but was expected to do so. "
+						+ "You may override mayReturnZeroTestTemplateInvocationContexts() to allow this.",
+				provider.getClass().getSimpleName());
+		}
 
-	private Optional<TestDescriptor> toTestDescriptor(TestTemplateInvocationContext invocationContext, int index) {
-		UniqueId uniqueId = getUniqueId().append(TestTemplateInvocationTestDescriptor.SEGMENT_TYPE, "#" + index);
-		if (getDynamicDescendantFilter().test(uniqueId, index - 1)) {
-			return Optional.of(new TestTemplateInvocationTestDescriptor(uniqueId, getTestClass(), getTestMethod(),
-				invocationContext, index, configuration));
+		@Override
+		UniqueId createInvocationUniqueId(UniqueId parentUniqueId, int index) {
+			return parentUniqueId.append(TestTemplateInvocationTestDescriptor.SEGMENT_TYPE, "#" + index);
 		}
-		return Optional.empty();
-	}
 
-	private void execute(DynamicTestExecutor dynamicTestExecutor, TestDescriptor testDescriptor) {
-		testDescriptor.setParent(this);
-		dynamicTestExecutor.execute(testDescriptor);
+		@Override
+		TestDescriptor createInvocationTestDescriptor(UniqueId uniqueId,
+				TestTemplateInvocationContext invocationContext, int index) {
+			return new TestTemplateInvocationTestDescriptor(uniqueId, getTestClass(), getTestMethod(),
+				invocationContext, index, TestTemplateTestDescriptor.this.configuration);
+		}
 	}
 }
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/UniqueIdPrefixTransformer.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/UniqueIdPrefixTransformer.java
new file mode 100644
index 000000000..20a85ba13
--- /dev/null
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/UniqueIdPrefixTransformer.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2015-2025 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.engine.descriptor;
+
+import java.util.List;
+import java.util.function.UnaryOperator;
+
+import org.junit.platform.commons.util.Preconditions;
+import org.junit.platform.engine.UniqueId;
+
+/**
+ * @since 5.13
+ */
+class UniqueIdPrefixTransformer implements UnaryOperator<UniqueId> {
+
+	private final UniqueId oldPrefix;
+	private final UniqueId newPrefix;
+	private final int oldPrefixLength;
+
+	UniqueIdPrefixTransformer(UniqueId oldPrefix, UniqueId newPrefix) {
+		this.oldPrefix = oldPrefix;
+		this.newPrefix = newPrefix;
+		this.oldPrefixLength = oldPrefix.getSegments().size();
+	}
+
+	@Override
+	public UniqueId apply(UniqueId uniqueId) {
+		Preconditions.condition(uniqueId.hasPrefix(oldPrefix),
+			() -> String.format("Unique ID %s does not have the expected prefix %s", uniqueId, oldPrefix));
+		List<UniqueId.Segment> oldSegments = uniqueId.getSegments();
+		List<UniqueId.Segment> suffix = oldSegments.subList(oldPrefixLength, oldSegments.size());
+		UniqueId newValue = newPrefix;
+		for (UniqueId.Segment segment : suffix) {
+			newValue = newValue.append(segment);
+		}
+		return newValue;
+	}
+}
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/ClassSelectorResolver.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/ClassSelectorResolver.java
index 0f809dcbd..b39c36082 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/ClassSelectorResolver.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/ClassSelectorResolver.java
@@ -10,10 +10,13 @@
 
 package org.junit.jupiter.engine.discovery;
 
+import static java.util.Collections.emptyList;
 import static java.util.function.Predicate.isEqual;
 import static java.util.stream.Collectors.toCollection;
+import static java.util.stream.Collectors.toSet;
 import static org.junit.jupiter.engine.descriptor.NestedClassTestDescriptor.getEnclosingTestClasses;
 import static org.junit.jupiter.engine.discovery.predicates.IsTestClassWithTests.isTestOrTestFactoryOrTestTemplateMethod;
+import static org.junit.platform.commons.support.AnnotationSupport.isAnnotated;
 import static org.junit.platform.commons.support.HierarchyTraversalMode.TOP_DOWN;
 import static org.junit.platform.commons.support.ReflectionSupport.findMethods;
 import static org.junit.platform.commons.support.ReflectionSupport.streamNestedClasses;
@@ -27,14 +30,21 @@ import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Optional;
 import java.util.Set;
+import java.util.function.BiFunction;
 import java.util.function.Predicate;
 import java.util.function.Supplier;
 import java.util.stream.Stream;
 
+import org.junit.jupiter.api.ContainerTemplate;
+import org.junit.jupiter.api.extension.ContainerTemplateInvocationContext;
 import org.junit.jupiter.engine.config.JupiterConfiguration;
 import org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor;
 import org.junit.jupiter.engine.descriptor.ClassTestDescriptor;
+import org.junit.jupiter.engine.descriptor.ContainerTemplateInvocationTestDescriptor;
+import org.junit.jupiter.engine.descriptor.ContainerTemplateTestDescriptor;
+import org.junit.jupiter.engine.descriptor.Filterable;
 import org.junit.jupiter.engine.descriptor.NestedClassTestDescriptor;
+import org.junit.jupiter.engine.descriptor.TestClassAware;
 import org.junit.jupiter.engine.discovery.predicates.IsNestedTestClass;
 import org.junit.jupiter.engine.discovery.predicates.IsTestClassWithTests;
 import org.junit.platform.commons.support.ReflectionSupport;
@@ -43,6 +53,7 @@ import org.junit.platform.engine.TestDescriptor;
 import org.junit.platform.engine.UniqueId;
 import org.junit.platform.engine.discovery.ClassSelector;
 import org.junit.platform.engine.discovery.DiscoverySelectors;
+import org.junit.platform.engine.discovery.IterationSelector;
 import org.junit.platform.engine.discovery.NestedClassSelector;
 import org.junit.platform.engine.discovery.UniqueIdSelector;
 import org.junit.platform.engine.support.discovery.SelectorResolver;
@@ -54,6 +65,8 @@ class ClassSelectorResolver implements SelectorResolver {
 
 	private static final IsTestClassWithTests isTestClassWithTests = new IsTestClassWithTests();
 	private static final IsNestedTestClass isNestedTestClass = new IsNestedTestClass();
+	private static final Predicate<Class<?>> isAnnotatedWithContainerTemplate = testClass -> isAnnotated(testClass,
+		ContainerTemplate.class);
 
 	private final Predicate<String> classNameFilter;
 	private final JupiterConfiguration configuration;
@@ -70,12 +83,12 @@ class ClassSelectorResolver implements SelectorResolver {
 			// Nested tests are never filtered out
 			if (classNameFilter.test(testClass.getName())) {
 				return toResolution(
-					context.addToParent(parent -> Optional.of(newClassTestDescriptor(parent, testClass))));
+					context.addToParent(parent -> Optional.of(newStaticClassTestDescriptor(parent, testClass))));
 			}
 		}
 		else if (isNestedTestClass.test(testClass)) {
 			return toResolution(context.addToParent(() -> DiscoverySelectors.selectClass(testClass.getEnclosingClass()),
-				parent -> Optional.of(newNestedClassTestDescriptor(parent, testClass))));
+				parent -> Optional.of(newMemberClassTestDescriptor(parent, testClass))));
 		}
 		return unresolved();
 	}
@@ -84,7 +97,7 @@ class ClassSelectorResolver implements SelectorResolver {
 	public Resolution resolve(NestedClassSelector selector, Context context) {
 		if (isNestedTestClass.test(selector.getNestedClass())) {
 			return toResolution(context.addToParent(() -> selectClass(selector.getEnclosingClasses()),
-				parent -> Optional.of(newNestedClassTestDescriptor(parent, selector.getNestedClass()))));
+				parent -> Optional.of(newMemberClassTestDescriptor(parent, selector.getNestedClass()))));
 		}
 		return unresolved();
 	}
@@ -94,55 +107,177 @@ class ClassSelectorResolver implements SelectorResolver {
 		UniqueId uniqueId = selector.getUniqueId();
 		UniqueId.Segment lastSegment = uniqueId.getLastSegment();
 		if (ClassTestDescriptor.SEGMENT_TYPE.equals(lastSegment.getType())) {
-			String className = lastSegment.getValue();
-			return ReflectionSupport.tryToLoadClass(className).toOptional().filter(isTestClassWithTests).map(
-				testClass -> toResolution(
-					context.addToParent(parent -> Optional.of(newClassTestDescriptor(parent, testClass))))).orElse(
-						unresolved());
+			return resolveStaticClassUniqueId(context, lastSegment, __ -> true, this::newClassTestDescriptor);
+		}
+		if (ContainerTemplateTestDescriptor.STATIC_CLASS_SEGMENT_TYPE.equals(lastSegment.getType())) {
+			return resolveStaticClassUniqueId(context, lastSegment, isAnnotatedWithContainerTemplate,
+				this::newStaticContainerTemplateTestDescriptor);
 		}
 		if (NestedClassTestDescriptor.SEGMENT_TYPE.equals(lastSegment.getType())) {
-			String simpleClassName = lastSegment.getValue();
-			return toResolution(context.addToParent(() -> selectUniqueId(uniqueId.removeLastSegment()), parent -> {
-				if (parent instanceof ClassBasedTestDescriptor) {
-					Class<?> parentTestClass = ((ClassBasedTestDescriptor) parent).getTestClass();
-					return ReflectionSupport.findNestedClasses(parentTestClass,
-						isNestedTestClass.and(
-							where(Class::getSimpleName, isEqual(simpleClassName)))).stream().findFirst().flatMap(
-								testClass -> Optional.of(newNestedClassTestDescriptor(parent, testClass)));
-				}
-				return Optional.empty();
-			}));
+			return resolveNestedClassUniqueId(context, uniqueId, __ -> true, this::newNestedClassTestDescriptor);
+		}
+		if (ContainerTemplateTestDescriptor.NESTED_CLASS_SEGMENT_TYPE.equals(lastSegment.getType())) {
+			return resolveNestedClassUniqueId(context, uniqueId, isAnnotatedWithContainerTemplate,
+				this::newNestedContainerTemplateTestDescriptor);
+		}
+		if (ContainerTemplateInvocationTestDescriptor.SEGMENT_TYPE.equals(lastSegment.getType())) {
+			Optional<ContainerTemplateInvocationTestDescriptor> testDescriptor = context.addToParent(
+				() -> selectUniqueId(uniqueId.removeLastSegment()), parent -> {
+					int index = Integer.parseInt(lastSegment.getValue().substring(1));
+					return Optional.of(newDummyContainerTemplateInvocationTestDescriptor(parent, index));
+				});
+			return toInvocationMatch(testDescriptor) //
+					.map(Resolution::match) //
+					.orElse(unresolved());
+		}
+		return unresolved();
+	}
+
+	@Override
+	public Resolution resolve(IterationSelector selector, Context context) {
+		DiscoverySelector parentSelector = selector.getParentSelector();
+		if (parentSelector instanceof ClassSelector
+				&& isAnnotatedWithContainerTemplate.test(((ClassSelector) parentSelector).getJavaClass())) {
+			return resolveIterations(selector, context);
+		}
+		if (parentSelector instanceof NestedClassSelector
+				&& isAnnotatedWithContainerTemplate.test(((NestedClassSelector) parentSelector).getNestedClass())) {
+			return resolveIterations(selector, context);
 		}
 		return unresolved();
 	}
 
+	private Resolution resolveIterations(IterationSelector selector, Context context) {
+		DiscoverySelector parentSelector = selector.getParentSelector();
+		Set<Match> matches = selector.getIterationIndices().stream() //
+				.map(index -> context.addToParent(() -> parentSelector,
+					parent -> Optional.of(newDummyContainerTemplateInvocationTestDescriptor(parent, index + 1)))) //
+				.map(this::toInvocationMatch) //
+				.filter(Optional::isPresent) //
+				.map(Optional::get) //
+				.collect(toSet());
+		return matches.isEmpty() ? unresolved() : Resolution.matches(matches);
+	}
+
+	private Resolution resolveStaticClassUniqueId(Context context, UniqueId.Segment lastSegment,
+			Predicate<? super Class<?>> condition,
+			BiFunction<TestDescriptor, Class<?>, ClassBasedTestDescriptor> factory) {
+
+		String className = lastSegment.getValue();
+		return ReflectionSupport.tryToLoadClass(className).toOptional() //
+				.filter(isTestClassWithTests) //
+				.filter(condition) //
+				.map(testClass -> toResolution(
+					context.addToParent(parent -> Optional.of(factory.apply(parent, testClass))))) //
+				.orElse(unresolved());
+	}
+
+	private Resolution resolveNestedClassUniqueId(Context context, UniqueId uniqueId,
+			Predicate<? super Class<?>> condition,
+			BiFunction<TestDescriptor, Class<?>, ClassBasedTestDescriptor> factory) {
+
+		String simpleClassName = uniqueId.getLastSegment().getValue();
+		return toResolution(context.addToParent(() -> selectUniqueId(uniqueId.removeLastSegment()), parent -> {
+			Class<?> parentTestClass = ((TestClassAware) parent).getTestClass();
+			return ReflectionSupport.findNestedClasses(parentTestClass,
+				isNestedTestClass.and(where(Class::getSimpleName, isEqual(simpleClassName)))).stream() //
+					.findFirst() //
+					.filter(condition) //
+					.map(testClass -> factory.apply(parent, testClass));
+		}));
+	}
+
+	private ContainerTemplateInvocationTestDescriptor newDummyContainerTemplateInvocationTestDescriptor(
+			TestDescriptor parent, int index) {
+		UniqueId uniqueId = parent.getUniqueId().append(ContainerTemplateInvocationTestDescriptor.SEGMENT_TYPE,
+			"#" + index);
+		return new ContainerTemplateInvocationTestDescriptor(uniqueId, (ContainerTemplateTestDescriptor) parent,
+			DummyContainerTemplateInvocationContext.INSTANCE, index, parent.getSource().orElse(null), configuration);
+	}
+
+	private ClassBasedTestDescriptor newStaticClassTestDescriptor(TestDescriptor parent, Class<?> testClass) {
+		return isAnnotatedWithContainerTemplate.test(testClass) //
+				? newStaticContainerTemplateTestDescriptor(parent, testClass) //
+				: newClassTestDescriptor(parent, testClass);
+	}
+
+	private ContainerTemplateTestDescriptor newStaticContainerTemplateTestDescriptor(TestDescriptor parent,
+			Class<?> testClass) {
+		return newContainerTemplateTestDescriptor(parent, ContainerTemplateTestDescriptor.STATIC_CLASS_SEGMENT_TYPE,
+			newClassTestDescriptor(parent, testClass));
+	}
+
 	private ClassTestDescriptor newClassTestDescriptor(TestDescriptor parent, Class<?> testClass) {
 		return new ClassTestDescriptor(
 			parent.getUniqueId().append(ClassTestDescriptor.SEGMENT_TYPE, testClass.getName()), testClass,
 			configuration);
 	}
 
+	private ClassBasedTestDescriptor newMemberClassTestDescriptor(TestDescriptor parent, Class<?> testClass) {
+		return isAnnotatedWithContainerTemplate.test(testClass) //
+				? newNestedContainerTemplateTestDescriptor(parent, testClass) //
+				: newNestedClassTestDescriptor(parent, testClass);
+	}
+
+	private ContainerTemplateTestDescriptor newNestedContainerTemplateTestDescriptor(TestDescriptor parent,
+			Class<?> testClass) {
+		return newContainerTemplateTestDescriptor(parent, ContainerTemplateTestDescriptor.NESTED_CLASS_SEGMENT_TYPE,
+			newNestedClassTestDescriptor(parent, testClass));
+	}
+
 	private NestedClassTestDescriptor newNestedClassTestDescriptor(TestDescriptor parent, Class<?> testClass) {
 		UniqueId uniqueId = parent.getUniqueId().append(NestedClassTestDescriptor.SEGMENT_TYPE,
 			testClass.getSimpleName());
 		return new NestedClassTestDescriptor(uniqueId, testClass, () -> getEnclosingTestClasses(parent), configuration);
 	}
 
+	private ContainerTemplateTestDescriptor newContainerTemplateTestDescriptor(TestDescriptor parent,
+			String segmentType, ClassBasedTestDescriptor delegate) {
+
+		delegate.setParent(parent);
+		String segmentValue = delegate.getUniqueId().getLastSegment().getValue();
+		UniqueId uniqueId = parent.getUniqueId().append(segmentType, segmentValue);
+		return new ContainerTemplateTestDescriptor(uniqueId, delegate);
+	}
+
+	private Optional<Match> toInvocationMatch(Optional<ContainerTemplateInvocationTestDescriptor> testDescriptor) {
+		return testDescriptor //
+				.map(it -> Match.exact(it, expansionCallback(it,
+					() -> it.getParent().map(parent -> getTestClasses((TestClassAware) parent)).orElse(emptyList()))));
+	}
+
 	private Resolution toResolution(Optional<? extends ClassBasedTestDescriptor> testDescriptor) {
-		return testDescriptor.map(it -> {
-			Class<?> testClass = it.getTestClass();
-			List<Class<?>> testClasses = new ArrayList<>(it.getEnclosingTestClasses());
-			testClasses.add(testClass);
-			// @formatter:off
-			return Resolution.match(Match.exact(it, () -> {
-				Stream<DiscoverySelector> methods = findMethods(testClass, isTestOrTestFactoryOrTestTemplateMethod, TOP_DOWN).stream()
-						.map(method -> selectMethod(testClasses, method));
-				Stream<NestedClassSelector> nestedClasses = streamNestedClasses(testClass, isNestedTestClass)
-						.map(nestedClass -> DiscoverySelectors.selectNestedClass(testClasses, nestedClass));
-				return Stream.concat(methods, nestedClasses).collect(toCollection((Supplier<Set<DiscoverySelector>>) LinkedHashSet::new));
-			}));
-			// @formatter:on
-		}).orElse(unresolved());
+		return testDescriptor //
+				.map(it -> Resolution.match(Match.exact(it, expansionCallback(it)))) //
+				.orElse(unresolved());
+	}
+
+	private Supplier<Set<? extends DiscoverySelector>> expansionCallback(ClassBasedTestDescriptor testDescriptor) {
+		return expansionCallback(testDescriptor, () -> getTestClasses(testDescriptor));
+	}
+
+	private static List<Class<?>> getTestClasses(TestClassAware testDescriptor) {
+		List<Class<?>> testClasses = new ArrayList<>(testDescriptor.getEnclosingTestClasses());
+		testClasses.add(testDescriptor.getTestClass());
+		return testClasses;
+	}
+
+	private Supplier<Set<? extends DiscoverySelector>> expansionCallback(TestDescriptor testDescriptor,
+			Supplier<List<Class<?>>> testClassesSupplier) {
+		return () -> {
+			if (testDescriptor instanceof Filterable) {
+				Filterable filterable = (Filterable) testDescriptor;
+				filterable.getDynamicDescendantFilter().allowAll();
+			}
+			List<Class<?>> testClasses = testClassesSupplier.get();
+			Class<?> testClass = testClasses.get(testClasses.size() - 1);
+			Stream<DiscoverySelector> methods = findMethods(testClass, isTestOrTestFactoryOrTestTemplateMethod,
+				TOP_DOWN).stream().map(method -> selectMethod(testClasses, method));
+			Stream<NestedClassSelector> nestedClasses = streamNestedClasses(testClass, isNestedTestClass).map(
+				nestedClass -> DiscoverySelectors.selectNestedClass(testClasses, nestedClass));
+			return Stream.concat(methods, nestedClasses).collect(
+				toCollection((Supplier<Set<DiscoverySelector>>) LinkedHashSet::new));
+		};
 	}
 
 	private DiscoverySelector selectClass(List<Class<?>> classes) {
@@ -161,4 +296,7 @@ class ClassSelectorResolver implements SelectorResolver {
 		return DiscoverySelectors.selectNestedMethod(classes.subList(0, lastIndex), classes.get(lastIndex), method);
 	}
 
+	static class DummyContainerTemplateInvocationContext implements ContainerTemplateInvocationContext {
+		private static final DummyContainerTemplateInvocationContext INSTANCE = new DummyContainerTemplateInvocationContext();
+	}
 }
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/DiscoverySelectorResolver.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/DiscoverySelectorResolver.java
index a828889cc..97f4e8da2 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/DiscoverySelectorResolver.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/DiscoverySelectorResolver.java
@@ -13,11 +13,14 @@ package org.junit.jupiter.engine.discovery;
 import static org.apiguardian.api.API.Status.INTERNAL;
 
 import org.apiguardian.api.API;
+import org.junit.jupiter.engine.config.JupiterConfiguration;
 import org.junit.jupiter.engine.descriptor.JupiterEngineDescriptor;
+import org.junit.jupiter.engine.descriptor.JupiterTestDescriptor;
 import org.junit.jupiter.engine.discovery.predicates.IsTestClassWithTests;
 import org.junit.platform.engine.EngineDiscoveryRequest;
 import org.junit.platform.engine.TestDescriptor;
 import org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolver;
+import org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolver.InitializationContext;
 
 /**
  * {@code DiscoverySelectorResolver} resolves {@link TestDescriptor TestDescriptors}
@@ -33,16 +36,22 @@ import org.junit.platform.engine.support.discovery.EngineDiscoveryRequestResolve
 @API(status = INTERNAL, since = "5.0")
 public class DiscoverySelectorResolver {
 
-	// @formatter:off
-	private static final EngineDiscoveryRequestResolver<JupiterEngineDescriptor> resolver = EngineDiscoveryRequestResolver.<JupiterEngineDescriptor>builder()
-			.addClassContainerSelectorResolver(new IsTestClassWithTests())
-			.addSelectorResolver(context -> new ClassSelectorResolver(context.getClassNameFilter(), context.getEngineDescriptor().getConfiguration()))
-			.addSelectorResolver(context -> new MethodSelectorResolver(context.getEngineDescriptor().getConfiguration()))
-			.addTestDescriptorVisitor(context -> new ClassOrderingVisitor(context.getEngineDescriptor().getConfiguration()))
-			.addTestDescriptorVisitor(context -> new MethodOrderingVisitor(context.getEngineDescriptor().getConfiguration()))
-			.addTestDescriptorVisitor(context -> TestDescriptor::prune)
+	private static final EngineDiscoveryRequestResolver<JupiterEngineDescriptor> resolver = EngineDiscoveryRequestResolver.<JupiterEngineDescriptor> builder() //
+			.addClassContainerSelectorResolver(new IsTestClassWithTests()) //
+			.addSelectorResolver(ctx -> new ClassSelectorResolver(ctx.getClassNameFilter(), getConfiguration(ctx))) //
+			.addSelectorResolver(ctx -> new MethodSelectorResolver(getConfiguration(ctx))) //
+			.addTestDescriptorVisitor(ctx -> new ClassOrderingVisitor(getConfiguration(ctx))) //
+			.addTestDescriptorVisitor(ctx -> new MethodOrderingVisitor(getConfiguration(ctx))) //
+			.addTestDescriptorVisitor(ctx -> descriptor -> {
+				if (descriptor instanceof JupiterTestDescriptor) {
+					((JupiterTestDescriptor) descriptor).prunePriorToFiltering();
+				}
+			}) //
 			.build();
-	// @formatter:on
+
+	private static JupiterConfiguration getConfiguration(InitializationContext<JupiterEngineDescriptor> context) {
+		return context.getEngineDescriptor().getConfiguration();
+	}
 
 	public void resolveSelectors(EngineDiscoveryRequest request, JupiterEngineDescriptor engineDescriptor) {
 		resolver.resolve(request, engineDescriptor);
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/MethodSelectorResolver.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/MethodSelectorResolver.java
index 9d5af96aa..44479f7eb 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/MethodSelectorResolver.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/MethodSelectorResolver.java
@@ -30,8 +30,8 @@ import java.util.function.Supplier;
 import java.util.stream.Stream;
 
 import org.junit.jupiter.engine.config.JupiterConfiguration;
-import org.junit.jupiter.engine.descriptor.ClassBasedTestDescriptor;
 import org.junit.jupiter.engine.descriptor.Filterable;
+import org.junit.jupiter.engine.descriptor.TestClassAware;
 import org.junit.jupiter.engine.descriptor.TestFactoryTestDescriptor;
 import org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor;
 import org.junit.jupiter.engine.descriptor.TestTemplateInvocationTestDescriptor;
@@ -208,8 +208,7 @@ class MethodSelectorResolver implements SelectorResolver {
 				return Optional.empty();
 			}
 			return context.addToParent(() -> selectClass(enclosingClasses, testClass), //
-				parent -> Optional.of(
-					createTestDescriptor((ClassBasedTestDescriptor) parent, testClass, method, configuration)));
+				parent -> Optional.of(createTestDescriptor(parent, testClass, method, configuration)));
 		}
 
 		private DiscoverySelector selectClass(List<Class<?>> enclosingClasses, Class<?> testClass) {
@@ -225,11 +224,11 @@ class MethodSelectorResolver implements SelectorResolver {
 			if (segmentType.equals(lastSegment.getType())) {
 				return context.addToParent(() -> selectUniqueId(uniqueId.removeLastSegment()), parent -> {
 					String methodSpecPart = lastSegment.getValue();
-					Class<?> testClass = ((ClassBasedTestDescriptor) parent).getTestClass();
+					Class<?> testClass = ((TestClassAware) parent).getTestClass();
 					// @formatter:off
 					return methodFinder.findMethod(methodSpecPart, testClass)
 							.filter(methodPredicate)
-							.map(method -> createTestDescriptor((ClassBasedTestDescriptor) parent, testClass, method, configuration));
+							.map(method -> createTestDescriptor(parent, testClass, method, configuration));
 					// @formatter:on
 				});
 			}
@@ -239,10 +238,11 @@ class MethodSelectorResolver implements SelectorResolver {
 			return Optional.empty();
 		}
 
-		private TestDescriptor createTestDescriptor(ClassBasedTestDescriptor parent, Class<?> testClass, Method method,
+		private TestDescriptor createTestDescriptor(TestDescriptor parent, Class<?> testClass, Method method,
 				JupiterConfiguration configuration) {
 			UniqueId uniqueId = createUniqueId(method, parent);
-			return createTestDescriptor(uniqueId, testClass, method, parent::getEnclosingTestClasses, configuration);
+			return createTestDescriptor(uniqueId, testClass, method, ((TestClassAware) parent)::getEnclosingTestClasses,
+				configuration);
 		}
 
 		private UniqueId createUniqueId(Method method, TestDescriptor parent) {
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/ConditionEvaluator.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/ConditionEvaluator.java
index e1e0a4a89..e51126bec 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/ConditionEvaluator.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/ConditionEvaluator.java
@@ -72,7 +72,7 @@ public class ConditionEvaluator {
 
 	private void logResult(Class<?> conditionType, ConditionEvaluationResult result, ExtensionContext context) {
 		logger.trace(() -> format("Evaluation of condition [%s] on [%s] resulted in: %s", conditionType.getName(),
-			context.getElement().get(), result));
+			context.getElement().orElse(null), result));
 	}
 
 	private ConditionEvaluationException evaluationException(Class<?> conditionType, Exception ex) {
diff --git a/junit-jupiter-engine/src/testFixtures/java/org/junit/jupiter/engine/discovery/JupiterUniqueIdBuilder.java b/junit-jupiter-engine/src/testFixtures/java/org/junit/jupiter/engine/discovery/JupiterUniqueIdBuilder.java
index 063d05271..5504efad7 100644
--- a/junit-jupiter-engine/src/testFixtures/java/org/junit/jupiter/engine/discovery/JupiterUniqueIdBuilder.java
+++ b/junit-jupiter-engine/src/testFixtures/java/org/junit/jupiter/engine/discovery/JupiterUniqueIdBuilder.java
@@ -12,13 +12,18 @@ package org.junit.jupiter.engine.discovery;
 
 import static org.junit.platform.commons.util.ReflectionUtils.isInnerClass;
 
+import org.junit.jupiter.api.ContainerTemplate;
 import org.junit.jupiter.engine.descriptor.ClassTestDescriptor;
+import org.junit.jupiter.engine.descriptor.ContainerTemplateInvocationTestDescriptor;
+import org.junit.jupiter.engine.descriptor.ContainerTemplateTestDescriptor;
 import org.junit.jupiter.engine.descriptor.JupiterEngineDescriptor;
 import org.junit.jupiter.engine.descriptor.NestedClassTestDescriptor;
 import org.junit.jupiter.engine.descriptor.TestFactoryTestDescriptor;
 import org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor;
 import org.junit.jupiter.engine.descriptor.TestTemplateInvocationTestDescriptor;
 import org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor;
+import org.junit.platform.commons.support.AnnotationSupport;
+import org.junit.platform.commons.support.ReflectionSupport;
 import org.junit.platform.engine.UniqueId;
 
 /**
@@ -31,16 +36,30 @@ import org.junit.platform.engine.UniqueId;
 public class JupiterUniqueIdBuilder {
 
 	public static UniqueId uniqueIdForClass(Class<?> clazz) {
-		UniqueId containerId = engineId();
 		if (isInnerClass(clazz)) {
-			containerId = uniqueIdForClass(clazz.getEnclosingClass());
-			return containerId.append(NestedClassTestDescriptor.SEGMENT_TYPE, clazz.getSimpleName());
+			var segmentType = classSegmentType(clazz, NestedClassTestDescriptor.SEGMENT_TYPE,
+				ContainerTemplateTestDescriptor.NESTED_CLASS_SEGMENT_TYPE);
+			return uniqueIdForClass(clazz.getEnclosingClass()).append(segmentType, clazz.getSimpleName());
 		}
-		return containerId.append(ClassTestDescriptor.SEGMENT_TYPE, clazz.getName());
+		return uniqueIdForStaticClass(clazz.getName());
 	}
 
-	public static UniqueId uniqueIdForTopLevelClass(String className) {
-		return engineId().append(ClassTestDescriptor.SEGMENT_TYPE, className);
+	public static UniqueId uniqueIdForStaticClass(String className) {
+		return engineId().append(staticClassSegmentType(className), className);
+	}
+
+	private static String staticClassSegmentType(String className) {
+		return ReflectionSupport.tryToLoadClass(className).toOptional() //
+				.map(it -> classSegmentType(it, ClassTestDescriptor.SEGMENT_TYPE,
+					ContainerTemplateTestDescriptor.STATIC_CLASS_SEGMENT_TYPE)) //
+				.orElse(ClassTestDescriptor.SEGMENT_TYPE);
+	}
+
+	private static String classSegmentType(Class<?> clazz, String regularSegmentType,
+			String containerTemplateSegmentType) {
+		return AnnotationSupport.isAnnotated(clazz, ContainerTemplate.class) //
+				? containerTemplateSegmentType //
+				: regularSegmentType;
 	}
 
 	public static UniqueId uniqueIdForMethod(Class<?> clazz, String methodPart) {
@@ -59,6 +78,10 @@ public class JupiterUniqueIdBuilder {
 		return parentId.append(TestTemplateInvocationTestDescriptor.SEGMENT_TYPE, "#" + index);
 	}
 
+	public static UniqueId appendContainerTemplateInvocationSegment(UniqueId parentId, int index) {
+		return parentId.append(ContainerTemplateInvocationTestDescriptor.SEGMENT_TYPE, "#" + index);
+	}
+
 	public static UniqueId engineId() {
 		return UniqueId.forEngine(JupiterEngineDescriptor.ENGINE_ID);
 	}
diff --git a/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EventConditions.java b/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EventConditions.java
index 5f260fe3d..4be237c10 100644
--- a/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EventConditions.java
+++ b/junit-platform-testkit/src/main/java/org/junit/platform/testkit/engine/EventConditions.java
@@ -249,6 +249,32 @@ public final class EventConditions {
 		return allOf(type(DYNAMIC_TEST_REGISTERED), condition);
 	}
 
+	/**
+	 * Create a new {@link Condition} that matches if and only if the
+	 * {@linkplain TestDescriptor#getUniqueId() unique id} of an {@link Event}'s
+	 * {@linkplain Event#getTestDescriptor() test descriptor} is equal to the
+	 * {@link UniqueId} parsed from the supplied {@link String}.
+	 *
+	 * @since 1.13
+	 */
+	@API(status = EXPERIMENTAL, since = "1.13")
+	public static Condition<Event> uniqueId(String uniqueId) {
+		return uniqueId(UniqueId.parse(uniqueId));
+	}
+
+	/**
+	 * Create a new {@link Condition} that matches if and only if the
+	 * {@linkplain TestDescriptor#getUniqueId() unique id} of an {@link Event}'s
+	 * {@linkplain Event#getTestDescriptor() test descriptor} is equal to the
+	 * supplied {@link UniqueId}.
+	 *
+	 * @since 1.13
+	 */
+	@API(status = EXPERIMENTAL, since = "1.13")
+	public static Condition<Event> uniqueId(UniqueId uniqueId) {
+		return uniqueId(new Condition<>(isEqual(uniqueId), "equal to '%s'", uniqueId));
+	}
+
 	/**
 	 * Create a new {@link Condition} that matches if and only if the
 	 * {@linkplain TestDescriptor#getUniqueId() unique id} of an
@@ -260,11 +286,22 @@ public final class EventConditions {
 			String text = segment.getType() + ":" + segment.getValue();
 			return text.contains(uniqueIdSubstring);
 		};
+		return uniqueId(new Condition<>(uniqueId -> uniqueId.getSegments().stream().anyMatch(predicate),
+			"substring '%s'", uniqueIdSubstring));
+	}
 
-		return new Condition<>(
-			byTestDescriptor(
-				where(TestDescriptor::getUniqueId, uniqueId -> uniqueId.getSegments().stream().anyMatch(predicate))),
-			"descriptor with uniqueId substring '%s'", uniqueIdSubstring);
+	/**
+	 * Create a new {@link Condition} that matches if and only if the
+	 * {@linkplain TestDescriptor#getUniqueId() unique id} of an {@link Event}'s
+	 * {@linkplain Event#getTestDescriptor() test descriptor} matches the
+	 * supplied {@link Condition}.
+	 *
+	 * @since 1.13
+	 */
+	@API(status = EXPERIMENTAL, since = "1.13")
+	public static Condition<Event> uniqueId(Condition<? super UniqueId> condition) {
+		return new Condition<>(byTestDescriptor(where(TestDescriptor::getUniqueId, condition::matches)),
+			"descriptor with uniqueId %s", condition.description().value());
 	}
 
 	/**
@@ -315,6 +352,21 @@ public final class EventConditions {
 			"descriptor with display name '%s'", displayName);
 	}
 
+	/**
+	 * Create a new {@link Condition} that matches if and only if the
+	 * {@linkplain TestDescriptor#getLegacyReportingName()} () legacy reporting name}
+	 * of an {@link Event}'s {@linkplain Event#getTestDescriptor() test descriptor}
+	 * is equal to the supplied {@link String}.
+	 *
+	 * @since 1.13
+	 */
+	@API(status = EXPERIMENTAL, since = "1.13")
+	public static Condition<Event> legacyReportingName(String legacyReportingName) {
+		return new Condition<>(
+			byTestDescriptor(where(TestDescriptor::getLegacyReportingName, isEqual(legacyReportingName))),
+			"descriptor with legacy reporting name '%s'", legacyReportingName);
+	}
+
 	/**
 	 * Create a new {@link Condition} that matches if and only if an
 	 * {@link Event}'s {@linkplain Event#getType() type} is
diff --git a/jupiter-tests/src/test/java/org/junit/jupiter/api/DisplayNameGenerationTests.java b/jupiter-tests/src/test/java/org/junit/jupiter/api/DisplayNameGenerationTests.java
index 898dfc1ea..61550ce26 100644
--- a/jupiter-tests/src/test/java/org/junit/jupiter/api/DisplayNameGenerationTests.java
+++ b/jupiter-tests/src/test/java/org/junit/jupiter/api/DisplayNameGenerationTests.java
@@ -22,7 +22,12 @@ import java.lang.reflect.Method;
 import java.util.EmptyStackException;
 import java.util.List;
 import java.util.Stack;
+import java.util.stream.Stream;
 
+import org.junit.jupiter.api.extension.ContainerTemplateInvocationContext;
+import org.junit.jupiter.api.extension.ContainerTemplateInvocationContextProvider;
+import org.junit.jupiter.api.extension.ExtendWith;
+import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.engine.AbstractJupiterTestEngineTests;
 import org.junit.platform.engine.TestDescriptor;
 
@@ -225,6 +230,32 @@ class DisplayNameGenerationTests extends AbstractJupiterTestEngineTests {
 		);
 	}
 
+	@Test
+	void indicativeSentencesOnContainerTemplate() {
+		check(ContainerTemplateTestCase.class, //
+			"CONTAINER: Container template", //
+			"TEST: Container template, some test", //
+			"CONTAINER: Container template, Regular Nested Test Case", //
+			"TEST: Container template, Regular Nested Test Case, some nested test", //
+			"CONTAINER: Container template, Nested Container Template", //
+			"TEST: Container template, Nested Container Template, some nested test" //
+		);
+
+		assertThat(executeTestsForClass(ContainerTemplateTestCase.class).allEvents().started().stream()) //
+				.map(event -> event.getTestDescriptor().getDisplayName()) //
+				.containsExactly( //
+					"JUnit Jupiter", //
+					"Container template", //
+					"[1] Container template", //
+					"Container template, some test", //
+					"Container template, Regular Nested Test Case", //
+					"Container template, Regular Nested Test Case, some nested test", //
+					"Container template, Nested Container Template", //
+					"[1] Container template, Nested Container Template", //
+					"Container template, Nested Container Template, some nested test" //
+				);
+	}
+
 	private void check(Class<?> testClass, String... expectedDisplayNames) {
 		var request = request().selectors(selectClass(testClass)).build();
 		var descriptors = discoverTests(request).getDescendants();
@@ -470,4 +501,55 @@ class DisplayNameGenerationTests extends AbstractJupiterTestEngineTests {
 			}
 		}
 	}
+
+	@SuppressWarnings("JUnitMalformedDeclaration")
+	@ContainerTemplate
+	@ExtendWith(ContainerTemplateTestCase.Once.class)
+	@DisplayName("Container template")
+	@IndicativeSentencesGeneration(generator = DisplayNameGenerator.ReplaceUnderscores.class)
+	@TestClassOrder(ClassOrderer.OrderAnnotation.class)
+	static class ContainerTemplateTestCase {
+
+		@Test
+		void some_test() {
+		}
+
+		@Nested
+		@Order(1)
+		class Regular_Nested_Test_Case {
+			@Test
+			void some_nested_test() {
+			}
+		}
+
+		@Nested
+		@Order(2)
+		@ContainerTemplate
+		class Nested_Container_Template {
+			@Test
+			void some_nested_test() {
+			}
+		}
+
+		private static class Once implements ContainerTemplateInvocationContextProvider {
+
+			@Override
+			public boolean supportsContainerTemplate(ExtensionContext context) {
+				return true;
+			}
+
+			@Override
+			public Stream<ContainerTemplateInvocationContext> provideContainerTemplateInvocationContexts(
+					ExtensionContext context) {
+				return Stream.of(new ContainerTemplateInvocationContext() {
+					@Override
+					public String getDisplayName(int invocationIndex) {
+						return "%s %s".formatted(
+							ContainerTemplateInvocationContext.super.getDisplayName(invocationIndex),
+							context.getDisplayName());
+					}
+				});
+			}
+		}
+	}
 }
diff --git a/jupiter-tests/src/test/java/org/junit/jupiter/api/extension/KitchenSinkExtension.java b/jupiter-tests/src/test/java/org/junit/jupiter/api/extension/KitchenSinkExtension.java
index 0d77cac08..73c0e3edc 100644
--- a/jupiter-tests/src/test/java/org/junit/jupiter/api/extension/KitchenSinkExtension.java
+++ b/jupiter-tests/src/test/java/org/junit/jupiter/api/extension/KitchenSinkExtension.java
@@ -55,8 +55,9 @@ public class KitchenSinkExtension implements
 	// Conditional Test Execution
 	ExecutionCondition,
 
-	// @TestTemplate
+	// @TestTemplate and @ContainerTemplate
 	TestTemplateInvocationContextProvider,
+	ContainerTemplateInvocationContextProvider,
 
 	// Miscellaneous
 	TestWatcher,
@@ -174,6 +175,24 @@ public class KitchenSinkExtension implements
 		return false;
 	}
 
+	// --- @ContainerTemplate -------------------------------------------------------
+
+	@Override
+	public boolean supportsContainerTemplate(ExtensionContext context) {
+		return false;
+	}
+
+	@Override
+	public Stream<ContainerTemplateInvocationContext> provideContainerTemplateInvocationContexts(
+			ExtensionContext context) {
+		return null;
+	}
+
+	@Override
+	public boolean mayReturnZeroContainerTemplateInvocationContexts(ExtensionContext context) {
+		return false;
+	}
+
 	// --- TestWatcher ---------------------------------------------------------
 
 	@Override
diff --git a/jupiter-tests/src/test/java/org/junit/jupiter/api/parallel/ResourceLockAnnotationTests.java b/jupiter-tests/src/test/java/org/junit/jupiter/api/parallel/ResourceLockAnnotationTests.java
index 60e7c36b8..337224b61 100644
--- a/jupiter-tests/src/test/java/org/junit/jupiter/api/parallel/ResourceLockAnnotationTests.java
+++ b/jupiter-tests/src/test/java/org/junit/jupiter/api/parallel/ResourceLockAnnotationTests.java
@@ -12,6 +12,10 @@ package org.junit.jupiter.api.parallel;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.util.Throwables.getRootCause;
+import static org.junit.platform.commons.util.CollectionUtils.getOnlyElement;
+import static org.junit.platform.engine.discovery.DiscoverySelectors.selectClass;
+import static org.junit.platform.engine.discovery.DiscoverySelectors.selectIteration;
+import static org.junit.platform.engine.discovery.DiscoverySelectors.selectMethod;
 import static org.junit.platform.engine.support.hierarchical.ExclusiveResource.LockMode;
 import static org.junit.platform.testkit.engine.EventConditions.finishedWithFailure;
 import static org.junit.platform.testkit.engine.TestExecutionResultConditions.instanceOf;
@@ -25,6 +29,7 @@ import java.util.Set;
 import java.util.stream.Stream;
 
 import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.ContainerTemplate;
 import org.junit.jupiter.api.DisplayNameGenerator;
 import org.junit.jupiter.api.DynamicTest;
 import org.junit.jupiter.api.Nested;
@@ -34,12 +39,14 @@ import org.junit.jupiter.api.TestFactory;
 import org.junit.jupiter.engine.AbstractJupiterTestEngineTests;
 import org.junit.jupiter.engine.config.JupiterConfiguration;
 import org.junit.jupiter.engine.descriptor.ClassTestDescriptor;
+import org.junit.jupiter.engine.descriptor.JupiterTestDescriptor;
 import org.junit.jupiter.engine.descriptor.NestedClassTestDescriptor;
 import org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor;
 import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.MethodSource;
 import org.junit.jupiter.params.provider.ValueSource;
 import org.junit.platform.commons.JUnitException;
+import org.junit.platform.engine.TestDescriptor;
 import org.junit.platform.engine.TestExecutionResult;
 import org.junit.platform.engine.UniqueId;
 import org.junit.platform.engine.support.hierarchical.ExclusiveResource;
@@ -180,6 +187,76 @@ class ResourceLockAnnotationTests extends AbstractJupiterTestEngineTests {
 		// @formatter:on
 	}
 
+	@Test
+	void addSharedResourcesViaAnnotationValueAndProvidersForContainerTemplate() {
+		var engineDescriptor = discoverTests(
+			selectClass(SharedResourcesViaAnnotationValueAndProvidersContainerTemplateTestCase.class));
+		engineDescriptor.accept(TestDescriptor::prune);
+
+		var containerTemplateTestDescriptor = (JupiterTestDescriptor) getOnlyElement(engineDescriptor.getChildren());
+
+		var expectedResources = List.of( //
+			new ExclusiveResource("a1", LockMode.READ_WRITE), //
+			new ExclusiveResource("a2", LockMode.READ_WRITE), //
+			new ExclusiveResource("a3", LockMode.READ), //
+			new ExclusiveResource("b1", LockMode.READ), //
+			new ExclusiveResource("b2", LockMode.READ), //
+			new ExclusiveResource("c1", LockMode.READ_WRITE), //
+			new ExclusiveResource("c2", LockMode.READ_WRITE), //
+			new ExclusiveResource("c3", LockMode.READ_WRITE), //
+			new ExclusiveResource("d1", LockMode.READ_WRITE), //
+			new ExclusiveResource("d2", LockMode.READ) //
+		);
+
+		assertThat(containerTemplateTestDescriptor.getExclusiveResources()) //
+				.containsExactlyInAnyOrderElementsOf(expectedResources);
+	}
+
+	@Test
+	void addSharedResourcesViaAnnotationValueAndProvidersForContainerTemplateInvocation() {
+		var engineDescriptor = discoverTests(selectIteration(
+			selectClass(SharedResourcesViaAnnotationValueAndProvidersContainerTemplateTestCase.class), 0));
+		engineDescriptor.accept(TestDescriptor::prune);
+
+		var containerTemplateTestDescriptor = (JupiterTestDescriptor) getOnlyElement(engineDescriptor.getChildren());
+
+		var expectedResources = List.of( //
+			new ExclusiveResource("a1", LockMode.READ_WRITE), //
+			new ExclusiveResource("a2", LockMode.READ_WRITE), //
+			new ExclusiveResource("a3", LockMode.READ), //
+			new ExclusiveResource("b1", LockMode.READ), //
+			new ExclusiveResource("b2", LockMode.READ), //
+			new ExclusiveResource("c1", LockMode.READ_WRITE), //
+			new ExclusiveResource("c2", LockMode.READ_WRITE), //
+			new ExclusiveResource("c3", LockMode.READ_WRITE), //
+			new ExclusiveResource("d1", LockMode.READ_WRITE), //
+			new ExclusiveResource("d2", LockMode.READ) //
+		);
+
+		assertThat(containerTemplateTestDescriptor.getExclusiveResources()) //
+				.containsExactlyInAnyOrderElementsOf(expectedResources);
+	}
+
+	@Test
+	void addSharedResourcesViaAnnotationValueAndProvidersForMethodInContainerTemplate() {
+		var engineDescriptor = discoverTests(
+			selectMethod(SharedResourcesViaAnnotationValueAndProvidersContainerTemplateTestCase.class, "test"));
+		engineDescriptor.accept(TestDescriptor::prune);
+
+		var containerTemplateTestDescriptor = (JupiterTestDescriptor) getOnlyElement(engineDescriptor.getChildren());
+
+		var expectedResources = List.of( //
+			new ExclusiveResource("a1", LockMode.READ_WRITE), //
+			new ExclusiveResource("a2", LockMode.READ_WRITE), //
+			new ExclusiveResource("a3", LockMode.READ), //
+			new ExclusiveResource("b1", LockMode.READ), //
+			new ExclusiveResource("b2", LockMode.READ) //
+		);
+
+		assertThat(containerTemplateTestDescriptor.getExclusiveResources()) //
+				.containsExactlyInAnyOrderElementsOf(expectedResources);
+	}
+
 	@Test
 	void sharedResourcesHavingTheSameValueAndModeAreDeduplicated() {
 		// @formatter:off
@@ -523,4 +600,71 @@ class ResourceLockAnnotationTests extends AbstractJupiterTestEngineTests {
 		}
 	}
 
+	@SuppressWarnings("JUnitMalformedDeclaration")
+	@ContainerTemplate
+	@ResourceLock( //
+			value = "a1", //
+			providers = SharedResourcesViaAnnotationValueAndProvidersContainerTemplateTestCase.FirstClassLevelProvider.class //
+	)
+	@ResourceLock( //
+			value = "a2", //
+			target = ResourceLockTarget.CHILDREN, //
+			providers = SharedResourcesViaAnnotationValueAndProvidersContainerTemplateTestCase.SecondClassLevelProvider.class //
+	)
+	static class SharedResourcesViaAnnotationValueAndProvidersContainerTemplateTestCase {
+
+		@Test
+		@ResourceLock(value = "b1", mode = ResourceAccessMode.READ)
+		void test() {
+		}
+
+		@Nested
+		@ResourceLock(providers = NestedClassLevelProvider.class)
+		class NestedClass {
+			@Test
+			@ResourceLock("c1")
+			void test() {
+			}
+		}
+
+		@Nested
+		@ContainerTemplate
+		@ResourceLock(value = "d1", target = ResourceLockTarget.CHILDREN)
+		class NestedContainerTemplate {
+			@Test
+			@ResourceLock(value = "d2", mode = ResourceAccessMode.READ)
+			void test() {
+			}
+		}
+
+		static class FirstClassLevelProvider implements ResourceLocksProvider {
+
+			@Override
+			public Set<Lock> provideForClass(Class<?> testClass) {
+				return Set.of(new Lock("a3", ResourceAccessMode.READ));
+			}
+		}
+
+		static class SecondClassLevelProvider implements ResourceLocksProvider {
+
+			@Override
+			public Set<Lock> provideForMethod(List<Class<?>> enclosingInstanceTypes, Class<?> testClass,
+					Method testMethod) {
+				return Set.of(new Lock("b2", ResourceAccessMode.READ));
+			}
+
+			@Override
+			public Set<Lock> provideForNestedClass(List<Class<?>> enclosingInstanceTypes, Class<?> testClass) {
+				return Set.of(new Lock("c2"));
+			}
+		}
+
+		static class NestedClassLevelProvider implements ResourceLocksProvider {
+
+			@Override
+			public Set<Lock> provideForNestedClass(List<Class<?>> enclosingInstanceTypes, Class<?> testClass) {
+				return Set.of(new Lock("c3"));
+			}
+		}
+	}
 }
diff --git a/jupiter-tests/src/test/java/org/junit/jupiter/engine/AbstractJupiterTestEngineTests.java b/jupiter-tests/src/test/java/org/junit/jupiter/engine/AbstractJupiterTestEngineTests.java
index 3ec1035eb..194abc739 100644
--- a/jupiter-tests/src/test/java/org/junit/jupiter/engine/AbstractJupiterTestEngineTests.java
+++ b/jupiter-tests/src/test/java/org/junit/jupiter/engine/AbstractJupiterTestEngineTests.java
@@ -13,10 +13,12 @@ package org.junit.jupiter.engine;
 import static org.junit.jupiter.api.Assertions.fail;
 import static org.junit.platform.engine.discovery.DiscoverySelectors.selectClass;
 import static org.junit.platform.engine.discovery.DiscoverySelectors.selectMethod;
+import static org.junit.platform.launcher.LauncherConstants.STACKTRACE_PRUNING_ENABLED_PROPERTY_NAME;
 import static org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder.request;
 import static org.junit.platform.launcher.core.OutputDirectoryProviders.dummyOutputDirectoryProvider;
 
 import java.util.Set;
+import java.util.function.Consumer;
 
 import org.junit.platform.engine.DiscoverySelector;
 import org.junit.platform.engine.TestDescriptor;
@@ -40,7 +42,13 @@ public abstract class AbstractJupiterTestEngineTests {
 	}
 
 	protected EngineExecutionResults executeTests(DiscoverySelector... selectors) {
-		return executeTests(request().selectors(selectors).outputDirectoryProvider(dummyOutputDirectoryProvider()));
+		return executeTests(request -> request.selectors(selectors));
+	}
+
+	protected EngineExecutionResults executeTests(Consumer<LauncherDiscoveryRequestBuilder> configurer) {
+		var builder = defaultRequest();
+		configurer.accept(builder);
+		return executeTests(builder);
 	}
 
 	protected EngineExecutionResults executeTests(LauncherDiscoveryRequestBuilder builder) {
@@ -52,8 +60,13 @@ public abstract class AbstractJupiterTestEngineTests {
 	}
 
 	protected TestDescriptor discoverTests(DiscoverySelector... selectors) {
-		return discoverTests(
-			request().selectors(selectors).outputDirectoryProvider(dummyOutputDirectoryProvider()).build());
+		return discoverTests(defaultRequest().selectors(selectors).build());
+	}
+
+	private static LauncherDiscoveryRequestBuilder defaultRequest() {
+		return request() //
+				.outputDirectoryProvider(dummyOutputDirectoryProvider()) //
+				.configurationParameter(STACKTRACE_PRUNING_ENABLED_PROPERTY_NAME, String.valueOf(false));
 	}
 
 	protected TestDescriptor discoverTests(LauncherDiscoveryRequest request) {
diff --git a/jupiter-tests/src/test/java/org/junit/jupiter/engine/ContainerTemplateInvocationTests.java b/jupiter-tests/src/test/java/org/junit/jupiter/engine/ContainerTemplateInvocationTests.java
new file mode 100644
index 000000000..e621393f1
--- /dev/null
+++ b/jupiter-tests/src/test/java/org/junit/jupiter/engine/ContainerTemplateInvocationTests.java
@@ -0,0 +1,1257 @@
+/*
+ * Copyright 2015-2025 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.engine;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.jupiter.api.Assertions.assertAll;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertNotEquals;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.fail;
+import static org.junit.jupiter.api.DynamicTest.dynamicTest;
+import static org.junit.platform.engine.discovery.DiscoverySelectors.selectClass;
+import static org.junit.platform.engine.discovery.DiscoverySelectors.selectIteration;
+import static org.junit.platform.engine.discovery.DiscoverySelectors.selectMethod;
+import static org.junit.platform.engine.discovery.DiscoverySelectors.selectNestedClass;
+import static org.junit.platform.engine.discovery.DiscoverySelectors.selectNestedMethod;
+import static org.junit.platform.engine.discovery.DiscoverySelectors.selectUniqueId;
+import static org.junit.platform.launcher.TagFilter.excludeTags;
+import static org.junit.platform.launcher.TagFilter.includeTags;
+import static org.junit.platform.testkit.engine.EventConditions.container;
+import static org.junit.platform.testkit.engine.EventConditions.displayName;
+import static org.junit.platform.testkit.engine.EventConditions.dynamicTestRegistered;
+import static org.junit.platform.testkit.engine.EventConditions.engine;
+import static org.junit.platform.testkit.engine.EventConditions.event;
+import static org.junit.platform.testkit.engine.EventConditions.finishedSuccessfully;
+import static org.junit.platform.testkit.engine.EventConditions.finishedWithFailure;
+import static org.junit.platform.testkit.engine.EventConditions.legacyReportingName;
+import static org.junit.platform.testkit.engine.EventConditions.started;
+import static org.junit.platform.testkit.engine.EventConditions.test;
+import static org.junit.platform.testkit.engine.EventConditions.uniqueId;
+import static org.junit.platform.testkit.engine.TestExecutionResultConditions.message;
+
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+import java.util.stream.IntStream;
+import java.util.stream.Stream;
+
+import org.junit.jupiter.api.AfterAll;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.ContainerTemplate;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.api.DynamicTest;
+import org.junit.jupiter.api.Nested;
+import org.junit.jupiter.api.Tag;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.TestFactory;
+import org.junit.jupiter.api.TestInfo;
+import org.junit.jupiter.api.TestInstance;
+import org.junit.jupiter.api.TestReporter;
+import org.junit.jupiter.api.extension.BeforeAllCallback;
+import org.junit.jupiter.api.extension.ContainerTemplateInvocationContext;
+import org.junit.jupiter.api.extension.ContainerTemplateInvocationContextProvider;
+import org.junit.jupiter.api.extension.ExtendWith;
+import org.junit.jupiter.api.extension.Extension;
+import org.junit.jupiter.api.extension.ExtensionContext;
+import org.junit.jupiter.api.extension.ExtensionContext.Store.CloseableResource;
+import org.junit.jupiter.api.extension.ParameterContext;
+import org.junit.jupiter.api.extension.ParameterResolutionException;
+import org.junit.jupiter.api.extension.ParameterResolver;
+import org.junit.jupiter.engine.descriptor.ClassTestDescriptor;
+import org.junit.jupiter.engine.descriptor.ContainerTemplateInvocationTestDescriptor;
+import org.junit.jupiter.engine.descriptor.ContainerTemplateTestDescriptor;
+import org.junit.jupiter.engine.descriptor.JupiterEngineDescriptor;
+import org.junit.jupiter.engine.descriptor.NestedClassTestDescriptor;
+import org.junit.jupiter.engine.descriptor.TestFactoryTestDescriptor;
+import org.junit.jupiter.engine.descriptor.TestMethodTestDescriptor;
+import org.junit.jupiter.engine.descriptor.TestTemplateInvocationTestDescriptor;
+import org.junit.jupiter.engine.descriptor.TestTemplateTestDescriptor;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.ValueSource;
+import org.junit.platform.engine.UniqueId;
+import org.junit.platform.engine.discovery.DiscoverySelectors;
+import org.junit.platform.engine.reporting.ReportEntry;
+
+/**
+ * @since 5.13
+ */
+public class ContainerTemplateInvocationTests extends AbstractJupiterTestEngineTests {
+
+	@ParameterizedTest
+	@ValueSource(strings = { //
+			"class:org.junit.jupiter.engine.ContainerTemplateInvocationTests$TwoInvocationsTestCase", //
+			"uid:[engine:junit-jupiter]/[container-template:org.junit.jupiter.engine.ContainerTemplateInvocationTests$TwoInvocationsTestCase]" //
+	})
+	void executesContainerTemplateClassTwice(String selectorIdentifier) {
+		var engineId = UniqueId.forEngine(JupiterEngineDescriptor.ENGINE_ID);
+		var containerTemplateId = engineId.append(ContainerTemplateTestDescriptor.STATIC_CLASS_SEGMENT_TYPE,
+			TwoInvocationsTestCase.class.getName());
+		var invocationId1 = containerTemplateId.append(ContainerTemplateInvocationTestDescriptor.SEGMENT_TYPE, "#1");
+		var invocation1MethodAId = invocationId1.append(TestMethodTestDescriptor.SEGMENT_TYPE, "a()");
+		var invocation1NestedClassId = invocationId1.append(NestedClassTestDescriptor.SEGMENT_TYPE, "NestedTestCase");
+		var invocation1NestedMethodBId = invocation1NestedClassId.append(TestMethodTestDescriptor.SEGMENT_TYPE, "b()");
+		var invocationId2 = containerTemplateId.append(ContainerTemplateInvocationTestDescriptor.SEGMENT_TYPE, "#2");
+		var invocation2MethodAId = invocationId2.append(TestMethodTestDescriptor.SEGMENT_TYPE, "a()");
+		var invocation2NestedClassId = invocationId2.append(NestedClassTestDescriptor.SEGMENT_TYPE, "NestedTestCase");
+		var invocation2NestedMethodBId = invocation2NestedClassId.append(TestMethodTestDescriptor.SEGMENT_TYPE, "b()");
+
+		var results = executeTests(DiscoverySelectors.parse(selectorIdentifier).orElseThrow());
+
+		results.allEvents().assertEventsMatchExactly( //
+			event(engine(), started()), //
+			event(container(uniqueId(containerTemplateId)), started()), //
+
+			event(dynamicTestRegistered(uniqueId(invocationId1)), displayName("[1] A of TwoInvocationsTestCase"),
+				legacyReportingName("%s[1]".formatted(TwoInvocationsTestCase.class.getName()))), //
+			event(container(uniqueId(invocationId1)), started()), //
+			event(dynamicTestRegistered(uniqueId(invocation1MethodAId))), //
+			event(dynamicTestRegistered(uniqueId(invocation1NestedClassId))), //
+			event(dynamicTestRegistered(uniqueId(invocation1NestedMethodBId))), //
+			event(test(uniqueId(invocation1MethodAId)), started()), //
+			event(test(uniqueId(invocation1MethodAId)), finishedSuccessfully()), //
+			event(container(uniqueId(invocation1NestedClassId)), started()), //
+			event(test(uniqueId(invocation1NestedMethodBId)), started()), //
+			event(test(uniqueId(invocation1NestedMethodBId)), finishedSuccessfully()), //
+			event(container(uniqueId(invocation1NestedClassId)), finishedSuccessfully()), //
+			event(container(uniqueId(invocationId1)), finishedSuccessfully()), //
+
+			event(dynamicTestRegistered(uniqueId(invocationId2)), displayName("[2] B of TwoInvocationsTestCase"),
+				legacyReportingName("%s[2]".formatted(TwoInvocationsTestCase.class.getName()))), //
+			event(container(uniqueId(invocationId2)), started()), //
+			event(dynamicTestRegistered(uniqueId(invocation2MethodAId))), //
+			event(dynamicTestRegistered(uniqueId(invocation2NestedClassId))), //
+			event(dynamicTestRegistered(uniqueId(invocation2NestedMethodBId))), //
+			event(test(uniqueId(invocation2MethodAId)), started()), //
+			event(test(uniqueId(invocation2MethodAId)), finishedSuccessfully()), //
+			event(container(uniqueId(invocation2NestedClassId)), started()), //
+			event(test(uniqueId(invocation2NestedMethodBId)), started()), //
+			event(test(uniqueId(invocation2NestedMethodBId)), finishedSuccessfully()), //
+			event(container(uniqueId(invocation2NestedClassId)), finishedSuccessfully()), //
+			event(container(uniqueId(invocationId2)), finishedSuccessfully()), //
+
+			event(container(uniqueId(containerTemplateId)), finishedSuccessfully()), //
+			event(engine(), finishedSuccessfully()));
+	}
+
+	@Test
+	void executesOnlySelectedMethodsDeclaredInContainerTemplate() {
+		var results = executeTests(selectMethod(TwoInvocationsTestCase.class, "a"));
+
+		results.testEvents() //
+				.assertStatistics(stats -> stats.started(2).succeeded(2)) //
+				.assertEventsMatchLoosely(event(test(displayName("a()")), finishedSuccessfully()));
+	}
+
+	@Test
+	void executesOnlySelectedMethodsDeclaredInNestedClassOfContainerTemplate() {
+		var results = executeTests(selectNestedMethod(List.of(TwoInvocationsTestCase.class),
+			TwoInvocationsTestCase.NestedTestCase.class, "b"));
+
+		results.testEvents().assertStatistics(stats -> stats.started(2).succeeded(2)) //
+				.assertEventsMatchLoosely(event(test(displayName("b()")), finishedSuccessfully()));
+	}
+
+	@Test
+	void executesOnlyTestsPassingPostDiscoveryFilter() {
+		var results = executeTests(request -> request //
+				.selectors(selectClass(TwoInvocationsTestCase.class)) //
+				.filters(includeTags("nested")));
+
+		results.testEvents().assertStatistics(stats -> stats.started(2).succeeded(2)) //
+				.assertEventsMatchLoosely(event(test(displayName("b()")), finishedSuccessfully()));
+	}
+
+	@Test
+	void prunesEmptyNestedTestClasses() {
+		var results = executeTests(request -> request //
+				.selectors(selectClass(TwoInvocationsTestCase.class)) //
+				.filters(excludeTags("nested")));
+
+		results.containerEvents().assertThatEvents() //
+				.noneMatch(container(TwoInvocationsTestCase.NestedTestCase.class.getSimpleName())::matches);
+
+		results.testEvents().assertStatistics(stats -> stats.started(2).succeeded(2)) //
+				.assertEventsMatchLoosely(event(test(displayName("a()")), finishedSuccessfully()));
+	}
+
+	@Test
+	void executesNestedContainerTemplateClassTwiceWithClassSelectorForEnclosingClass() {
+		var engineId = UniqueId.forEngine(JupiterEngineDescriptor.ENGINE_ID);
+		var classId = engineId.append(ClassTestDescriptor.SEGMENT_TYPE,
+			NestedContainerTemplateWithTwoInvocationsTestCase.class.getName());
+		var methodAId = classId.append(TestMethodTestDescriptor.SEGMENT_TYPE, "a()");
+		var nestedContainerTemplateId = classId.append(ContainerTemplateTestDescriptor.NESTED_CLASS_SEGMENT_TYPE,
+			"NestedTestCase");
+		var invocationId1 = nestedContainerTemplateId.append(ContainerTemplateInvocationTestDescriptor.SEGMENT_TYPE,
+			"#1");
+		var invocation1NestedMethodBId = invocationId1.append(TestMethodTestDescriptor.SEGMENT_TYPE, "b()");
+		var invocationId2 = nestedContainerTemplateId.append(ContainerTemplateInvocationTestDescriptor.SEGMENT_TYPE,
+			"#2");
+		var invocation2NestedMethodBId = invocationId2.append(TestMethodTestDescriptor.SEGMENT_TYPE, "b()");
+
+		var results = executeTestsForClass(NestedContainerTemplateWithTwoInvocationsTestCase.class);
+
+		results.allEvents().assertEventsMatchExactly( //
+			event(engine(), started()), //
+			event(container(uniqueId(classId)), started()), //
+
+			event(test(uniqueId(methodAId)), started()), //
+			event(test(uniqueId(methodAId)), finishedSuccessfully()), //
+
+			event(container(uniqueId(nestedContainerTemplateId)), started()), //
+
+			event(dynamicTestRegistered(uniqueId(invocationId1)), displayName("[1] A of NestedTestCase"),
+				legacyReportingName("%s[1]".formatted(
+					NestedContainerTemplateWithTwoInvocationsTestCase.NestedTestCase.class.getName()))), //
+			event(container(uniqueId(invocationId1)), started()), //
+			event(dynamicTestRegistered(uniqueId(invocation1NestedMethodBId))), //
+			event(test(uniqueId(invocation1NestedMethodBId)), started()), //
+			event(test(uniqueId(invocation1NestedMethodBId)), finishedSuccessfully()), //
+			event(container(uniqueId(invocationId1)), finishedSuccessfully()), //
+
+			event(dynamicTestRegistered(uniqueId(invocationId2)), displayName("[2] B of NestedTestCase"),
+				legacyReportingName("%s[2]".formatted(
+					NestedContainerTemplateWithTwoInvocationsTestCase.NestedTestCase.class.getName()))), //
+			event(container(uniqueId(invocationId2)), started()), //
+			event(dynamicTestRegistered(uniqueId(invocation2NestedMethodBId))), //
+			event(test(uniqueId(invocation2NestedMethodBId)), started()), //
+			event(test(uniqueId(invocation2NestedMethodBId)), finishedSuccessfully()), //
+			event(container(uniqueId(invocationId2)), finishedSuccessfully()), //
+
+			event(container(uniqueId(nestedContainerTemplateId)), finishedSuccessfully()), //
+
+			event(container(uniqueId(classId)), finishedSuccessfully()), //
+			event(engine(), finishedSuccessfully()));
+	}
+
+	@Test
+	void executesNestedContainerTemplateClassTwiceWithNestedClassSelector() {
+		var engineId = UniqueId.forEngine(JupiterEngineDescriptor.ENGINE_ID);
+		var classId = engineId.append(ClassTestDescriptor.SEGMENT_TYPE,
+			NestedContainerTemplateWithTwoInvocationsTestCase.class.getName());
+		var nestedContainerTemplateId = classId.append(ContainerTemplateTestDescriptor.NESTED_CLASS_SEGMENT_TYPE,
+			"NestedTestCase");
+		var invocationId1 = nestedContainerTemplateId.append(ContainerTemplateInvocationTestDescriptor.SEGMENT_TYPE,
+			"#1");
+		var invocation1NestedMethodBId = invocationId1.append(TestMethodTestDescriptor.SEGMENT_TYPE, "b()");
+		var invocationId2 = nestedContainerTemplateId.append(ContainerTemplateInvocationTestDescriptor.SEGMENT_TYPE,
+			"#2");
+		var invocation2NestedMethodBId = invocationId2.append(TestMethodTestDescriptor.SEGMENT_TYPE, "b()");
+
+		var results = executeTestsForClass(NestedContainerTemplateWithTwoInvocationsTestCase.NestedTestCase.class);
+
+		results.allEvents().assertEventsMatchExactly( //
+			event(engine(), started()), //
+			event(container(uniqueId(classId)), started()), //
+
+			event(container(uniqueId(nestedContainerTemplateId)), started()), //
+
+			event(dynamicTestRegistered(uniqueId(invocationId1)), displayName("[1] A of NestedTestCase")), //
+			event(container(uniqueId(invocationId1)), started()), //
+			event(dynamicTestRegistered(uniqueId(invocation1NestedMethodBId))), //
+			event(test(uniqueId(invocation1NestedMethodBId)), started()), //
+			event(test(uniqueId(invocation1NestedMethodBId)), finishedSuccessfully()), //
+			event(container(uniqueId(invocationId1)), finishedSuccessfully()), //
+
+			event(dynamicTestRegistered(uniqueId(invocationId2)), displayName("[2] B of NestedTestCase")), //
+			event(container(uniqueId(invocationId2)), started()), //
+			event(dynamicTestRegistered(uniqueId(invocation2NestedMethodBId))), //
+			event(test(uniqueId(invocation2NestedMethodBId)), started()), //
+			event(test(uniqueId(invocation2NestedMethodBId)), finishedSuccessfully()), //
+			event(container(uniqueId(invocationId2)), finishedSuccessfully()), //
+
+			event(container(uniqueId(nestedContainerTemplateId)), finishedSuccessfully()), //
+
+			event(container(uniqueId(classId)), finishedSuccessfully()), //
+			event(engine(), finishedSuccessfully()));
+	}
+
+	@Test
+	void executesNestedContainerTemplatesTwiceEach() {
+		var engineId = UniqueId.forEngine(JupiterEngineDescriptor.ENGINE_ID);
+		var outerContainerTemplateId = engineId.append(ContainerTemplateTestDescriptor.STATIC_CLASS_SEGMENT_TYPE,
+			TwoTimesTwoInvocationsTestCase.class.getName());
+
+		var outerInvocation1Id = outerContainerTemplateId.append(ContainerTemplateInvocationTestDescriptor.SEGMENT_TYPE,
+			"#1");
+		var outerInvocation1NestedContainerTemplateId = outerInvocation1Id.append(
+			ContainerTemplateTestDescriptor.NESTED_CLASS_SEGMENT_TYPE, "NestedTestCase");
+		var outerInvocation1InnerInvocation1Id = outerInvocation1NestedContainerTemplateId.append(
+			ContainerTemplateInvocationTestDescriptor.SEGMENT_TYPE, "#1");
+		var outerInvocation1InnerInvocation1NestedMethodId = outerInvocation1InnerInvocation1Id.append(
+			TestMethodTestDescriptor.SEGMENT_TYPE, "test()");
+		var outerInvocation1InnerInvocation2Id = outerInvocation1NestedContainerTemplateId.append(
+			ContainerTemplateInvocationTestDescriptor.SEGMENT_TYPE, "#2");
+		var outerInvocation1InnerInvocation2NestedMethodId = outerInvocation1InnerInvocation2Id.append(
+			TestMethodTestDescriptor.SEGMENT_TYPE, "test()");
+
+		var outerInvocation2Id = outerContainerTemplateId.append(ContainerTemplateInvocationTestDescriptor.SEGMENT_TYPE,
+			"#2");
+		var outerInvocation2NestedContainerTemplateId = outerInvocation2Id.append(
+			ContainerTemplateTestDescriptor.NESTED_CLASS_SEGMENT_TYPE, "NestedTestCase");
+		var outerInvocation2InnerInvocation1Id = outerInvocation2NestedContainerTemplateId.append(
+			ContainerTemplateInvocationTestDescriptor.SEGMENT_TYPE, "#1");
+		var outerInvocation2InnerInvocation1NestedMethodId = outerInvocation2InnerInvocation1Id.append(
+			TestMethodTestDescriptor.SEGMENT_TYPE, "test()");
+		var outerInvocation2InnerInvocation2Id = outerInvocation2NestedContainerTemplateId.append(
+			ContainerTemplateInvocationTestDescriptor.SEGMENT_TYPE, "#2");
+		var outerInvocation2InnerInvocation2NestedMethodId = outerInvocation2InnerInvocation2Id.append(
+			TestMethodTestDescriptor.SEGMENT_TYPE, "test()");
+
+		var results = executeTestsForClass(TwoTimesTwoInvocationsTestCase.class);
+
+		results.allEvents().assertEventsMatchExactly( //
+			event(engine(), started()), //
+			event(container(uniqueId(outerContainerTemplateId)), started()), //
+
+			event(dynamicTestRegistered(uniqueId(outerInvocation1Id)),
+				displayName("[1] A of TwoTimesTwoInvocationsTestCase")), //
+			event(container(uniqueId(outerInvocation1Id)), started()), //
+			event(dynamicTestRegistered(uniqueId(outerInvocation1NestedContainerTemplateId))), //
+			event(container(uniqueId(outerInvocation1NestedContainerTemplateId)), started()), //
+
+			event(dynamicTestRegistered(uniqueId(outerInvocation1InnerInvocation1Id)),
+				displayName("[1] A of NestedTestCase")), //
+			event(container(uniqueId(outerInvocation1InnerInvocation1Id)), started()), //
+			event(dynamicTestRegistered(uniqueId(outerInvocation1InnerInvocation1NestedMethodId))), //
+			event(test(uniqueId(outerInvocation1InnerInvocation1NestedMethodId)), started()), //
+			event(test(uniqueId(outerInvocation1InnerInvocation1NestedMethodId)), finishedSuccessfully()), //
+			event(container(uniqueId(outerInvocation1InnerInvocation1Id)), finishedSuccessfully()), //
+
+			event(dynamicTestRegistered(uniqueId(outerInvocation1InnerInvocation2Id)),
+				displayName("[2] B of NestedTestCase")), //
+			event(container(uniqueId(outerInvocation1InnerInvocation2Id)), started()), //
+			event(dynamicTestRegistered(uniqueId(outerInvocation1InnerInvocation2NestedMethodId))), //
+			event(test(uniqueId(outerInvocation1InnerInvocation2NestedMethodId)), started()), //
+			event(test(uniqueId(outerInvocation1InnerInvocation2NestedMethodId)), finishedSuccessfully()), //
+			event(container(uniqueId(outerInvocation1InnerInvocation2Id)), finishedSuccessfully()), //
+
+			event(container(uniqueId(outerInvocation1NestedContainerTemplateId)), finishedSuccessfully()), //
+			event(container(uniqueId(outerInvocation1Id)), finishedSuccessfully()), //
+
+			event(dynamicTestRegistered(uniqueId(outerInvocation2Id)),
+				displayName("[2] B of TwoTimesTwoInvocationsTestCase")), //
+			event(container(uniqueId(outerInvocation2Id)), started()), //
+			event(dynamicTestRegistered(uniqueId(outerInvocation2NestedContainerTemplateId))), //
+			event(container(uniqueId(outerInvocation2NestedContainerTemplateId)), started()), //
+
+			event(dynamicTestRegistered(uniqueId(outerInvocation2InnerInvocation1Id)),
+				displayName("[1] A of NestedTestCase")), //
+			event(container(uniqueId(outerInvocation2InnerInvocation1Id)), started()), //
+			event(dynamicTestRegistered(uniqueId(outerInvocation2InnerInvocation1NestedMethodId))), //
+			event(test(uniqueId(outerInvocation2InnerInvocation1NestedMethodId)), started()), //
+			event(test(uniqueId(outerInvocation2InnerInvocation1NestedMethodId)), finishedSuccessfully()), //
+			event(container(uniqueId(outerInvocation2InnerInvocation1Id)), finishedSuccessfully()), //
+
+			event(dynamicTestRegistered(uniqueId(outerInvocation2InnerInvocation2Id)),
+				displayName("[2] B of NestedTestCase")), //
+			event(container(uniqueId(outerInvocation2InnerInvocation2Id)), started()), //
+			event(dynamicTestRegistered(uniqueId(outerInvocation2InnerInvocation2NestedMethodId))), //
+			event(test(uniqueId(outerInvocation2InnerInvocation2NestedMethodId)), started()), //
+			event(test(uniqueId(outerInvocation2InnerInvocation2NestedMethodId)), finishedSuccessfully()), //
+			event(container(uniqueId(outerInvocation2InnerInvocation2Id)), finishedSuccessfully()), //
+
+			event(container(uniqueId(outerInvocation2NestedContainerTemplateId)), finishedSuccessfully()), //
+			event(container(uniqueId(outerInvocation2Id)), finishedSuccessfully()), //
+
+			event(container(uniqueId(outerContainerTemplateId)), finishedSuccessfully()), //
+			event(engine(), finishedSuccessfully()));
+	}
+
+	@Test
+	void invocationContextProviderCanRegisterAdditionalExtensions() {
+		var results = executeTestsForClass(AdditionalExtensionRegistrationTestCase.class);
+
+		results.testEvents().assertStatistics(stats -> stats.started(2).succeeded(2));
+	}
+
+	@Test
+	void eachInvocationHasSeparateExtensionContext() {
+		var results = executeTestsForClass(SeparateExtensionContextTestCase.class);
+
+		results.testEvents().assertStatistics(stats -> stats.started(2).succeeded(2));
+	}
+
+	@Test
+	void supportsTestTemplateMethodsInsideContainerTemplateClasses() {
+		var engineId = UniqueId.forEngine(JupiterEngineDescriptor.ENGINE_ID);
+		var containerTemplateId = engineId.append(ContainerTemplateTestDescriptor.STATIC_CLASS_SEGMENT_TYPE,
+			CombinationWithTestTemplateTestCase.class.getName());
+		var invocationId1 = containerTemplateId.append(ContainerTemplateInvocationTestDescriptor.SEGMENT_TYPE, "#1");
+		var testTemplateId1 = invocationId1.append(TestTemplateTestDescriptor.SEGMENT_TYPE, "test(int)");
+		var testTemplate1InvocationId1 = testTemplateId1.append(TestTemplateInvocationTestDescriptor.SEGMENT_TYPE,
+			"#1");
+		var testTemplate1InvocationId2 = testTemplateId1.append(TestTemplateInvocationTestDescriptor.SEGMENT_TYPE,
+			"#2");
+		var invocationId2 = containerTemplateId.append(ContainerTemplateInvocationTestDescriptor.SEGMENT_TYPE, "#2");
+		var testTemplateId2 = invocationId2.append(TestTemplateTestDescriptor.SEGMENT_TYPE, "test(int)");
+		var testTemplate2InvocationId1 = testTemplateId2.append(TestTemplateInvocationTestDescriptor.SEGMENT_TYPE,
+			"#1");
+		var testTemplate2InvocationId2 = testTemplateId2.append(TestTemplateInvocationTestDescriptor.SEGMENT_TYPE,
+			"#2");
+
+		var results = executeTestsForClass(CombinationWithTestTemplateTestCase.class);
+
+		results.allEvents().assertEventsMatchExactly( //
+			event(engine(), started()), //
+			event(container(uniqueId(containerTemplateId)), started()), //
+
+			event(dynamicTestRegistered(uniqueId(invocationId1)),
+				displayName("[1] A of CombinationWithTestTemplateTestCase")), //
+			event(container(uniqueId(invocationId1)), started()), //
+			event(dynamicTestRegistered(uniqueId(testTemplateId1))), //
+			event(container(uniqueId(testTemplateId1)), started()), //
+			event(dynamicTestRegistered(uniqueId(testTemplate1InvocationId1))), //
+			event(test(uniqueId(testTemplate1InvocationId1)), started()), //
+			event(test(uniqueId(testTemplate1InvocationId1)), finishedSuccessfully()), //
+			event(dynamicTestRegistered(uniqueId(testTemplate1InvocationId2))), //
+			event(test(uniqueId(testTemplate1InvocationId2)), started()), //
+			event(test(uniqueId(testTemplate1InvocationId2)), finishedSuccessfully()), //
+			event(container(uniqueId(testTemplateId1)), finishedSuccessfully()), //
+			event(container(uniqueId(invocationId1)), finishedSuccessfully()), //
+
+			event(dynamicTestRegistered(uniqueId(invocationId2)),
+				displayName("[2] B of CombinationWithTestTemplateTestCase")), //
+			event(container(uniqueId(invocationId2)), started()), //
+			event(dynamicTestRegistered(uniqueId(testTemplateId2))), //
+			event(container(uniqueId(testTemplateId2)), started()), //
+			event(dynamicTestRegistered(uniqueId(testTemplate2InvocationId1))), //
+			event(test(uniqueId(testTemplate2InvocationId1)), started()), //
+			event(test(uniqueId(testTemplate2InvocationId1)), finishedSuccessfully()), //
+			event(dynamicTestRegistered(uniqueId(testTemplate2InvocationId2))), //
+			event(test(uniqueId(testTemplate2InvocationId2)), started()), //
+			event(test(uniqueId(testTemplate2InvocationId2)), finishedSuccessfully()), //
+			event(container(uniqueId(testTemplateId2)), finishedSuccessfully()), //
+			event(container(uniqueId(invocationId2)), finishedSuccessfully()), //
+
+			event(container(uniqueId(containerTemplateId)), finishedSuccessfully()), //
+			event(engine(), finishedSuccessfully()));
+	}
+
+	@Test
+	void testTemplateInvocationInsideContainerTemplateClassCanBeSelectedByUniqueId() {
+		var engineId = UniqueId.forEngine(JupiterEngineDescriptor.ENGINE_ID);
+		var containerTemplateId = engineId.append(ContainerTemplateTestDescriptor.STATIC_CLASS_SEGMENT_TYPE,
+			CombinationWithTestTemplateTestCase.class.getName());
+		var invocationId2 = containerTemplateId.append(ContainerTemplateInvocationTestDescriptor.SEGMENT_TYPE, "#2");
+		var testTemplateId2 = invocationId2.append(TestTemplateTestDescriptor.SEGMENT_TYPE, "test(int)");
+		var testTemplate2InvocationId2 = testTemplateId2.append(TestTemplateInvocationTestDescriptor.SEGMENT_TYPE,
+			"#2");
+
+		var results = executeTests(selectUniqueId(testTemplate2InvocationId2));
+
+		results.allEvents().assertEventsMatchExactly( //
+			event(engine(), started()), //
+			event(container(uniqueId(containerTemplateId)), started()), //
+
+			event(dynamicTestRegistered(uniqueId(invocationId2)),
+				displayName("[2] B of CombinationWithTestTemplateTestCase")), //
+			event(container(uniqueId(invocationId2)), started()), //
+			event(dynamicTestRegistered(uniqueId(testTemplateId2))), //
+			event(container(uniqueId(testTemplateId2)), started()), //
+			event(dynamicTestRegistered(uniqueId(testTemplate2InvocationId2))), //
+			event(test(uniqueId(testTemplate2InvocationId2)), started()), //
+			event(test(uniqueId(testTemplate2InvocationId2)), finishedSuccessfully()), //
+			event(container(uniqueId(testTemplateId2)), finishedSuccessfully()), //
+			event(container(uniqueId(invocationId2)), finishedSuccessfully()), //
+
+			event(container(uniqueId(containerTemplateId)), finishedSuccessfully()), //
+			event(engine(), finishedSuccessfully()));
+	}
+
+	@Test
+	void supportsTestFactoryMethodsInsideContainerTemplateClasses() {
+		var engineId = UniqueId.forEngine(JupiterEngineDescriptor.ENGINE_ID);
+		var containerTemplateId = engineId.append(ContainerTemplateTestDescriptor.STATIC_CLASS_SEGMENT_TYPE,
+			CombinationWithTestFactoryTestCase.class.getName());
+		var invocationId1 = containerTemplateId.append(ContainerTemplateInvocationTestDescriptor.SEGMENT_TYPE, "#1");
+		var testFactoryId1 = invocationId1.append(TestFactoryTestDescriptor.SEGMENT_TYPE, "test()");
+		var testFactory1DynamicTestId1 = testFactoryId1.append(TestFactoryTestDescriptor.DYNAMIC_TEST_SEGMENT_TYPE,
+			"#1");
+		var testFactory1DynamicTestId2 = testFactoryId1.append(TestFactoryTestDescriptor.DYNAMIC_TEST_SEGMENT_TYPE,
+			"#2");
+		var invocationId2 = containerTemplateId.append(ContainerTemplateInvocationTestDescriptor.SEGMENT_TYPE, "#2");
+		var testFactoryId2 = invocationId2.append(TestFactoryTestDescriptor.SEGMENT_TYPE, "test()");
+		var testFactory2DynamicTestId1 = testFactoryId2.append(TestFactoryTestDescriptor.DYNAMIC_TEST_SEGMENT_TYPE,
+			"#1");
+		var testFactory2DynamicTestId2 = testFactoryId2.append(TestFactoryTestDescriptor.DYNAMIC_TEST_SEGMENT_TYPE,
+			"#2");
+
+		var results = executeTestsForClass(CombinationWithTestFactoryTestCase.class);
+
+		results.allEvents().assertEventsMatchExactly( //
+			event(engine(), started()), //
+			event(container(uniqueId(containerTemplateId)), started()), //
+
+			event(dynamicTestRegistered(uniqueId(invocationId1)),
+				displayName("[1] A of CombinationWithTestFactoryTestCase")), //
+			event(container(uniqueId(invocationId1)), started()), //
+			event(dynamicTestRegistered(uniqueId(testFactoryId1))), //
+			event(container(uniqueId(testFactoryId1)), started()), //
+			event(dynamicTestRegistered(uniqueId(testFactory1DynamicTestId1))), //
+			event(test(uniqueId(testFactory1DynamicTestId1)), started()), //
+			event(test(uniqueId(testFactory1DynamicTestId1)), finishedSuccessfully()), //
+			event(dynamicTestRegistered(uniqueId(testFactory1DynamicTestId2))), //
+			event(test(uniqueId(testFactory1DynamicTestId2)), started()), //
+			event(test(uniqueId(testFactory1DynamicTestId2)), finishedSuccessfully()), //
+			event(container(uniqueId(testFactoryId1)), finishedSuccessfully()), //
+			event(container(uniqueId(invocationId1)), finishedSuccessfully()), //
+
+			event(dynamicTestRegistered(uniqueId(invocationId2)),
+				displayName("[2] B of CombinationWithTestFactoryTestCase")), //
+			event(container(uniqueId(invocationId2)), started()), //
+			event(dynamicTestRegistered(uniqueId(testFactoryId2))), //
+			event(container(uniqueId(testFactoryId2)), started()), //
+			event(dynamicTestRegistered(uniqueId(testFactory2DynamicTestId1))), //
+			event(test(uniqueId(testFactory2DynamicTestId1)), started()), //
+			event(test(uniqueId(testFactory2DynamicTestId1)), finishedSuccessfully()), //
+			event(dynamicTestRegistered(uniqueId(testFactory2DynamicTestId2))), //
+			event(test(uniqueId(testFactory2DynamicTestId2)), started()), //
+			event(test(uniqueId(testFactory2DynamicTestId2)), finishedSuccessfully()), //
+			event(container(uniqueId(testFactoryId2)), finishedSuccessfully()), //
+			event(container(uniqueId(invocationId2)), finishedSuccessfully()), //
+
+			event(container(uniqueId(containerTemplateId)), finishedSuccessfully()), //
+			event(engine(), finishedSuccessfully()));
+	}
+
+	@Test
+	void specificDynamicTestInsideContainerTemplateClassCanBeSelectedByUniqueId() {
+		var engineId = UniqueId.forEngine(JupiterEngineDescriptor.ENGINE_ID);
+		var containerTemplateId = engineId.append(ContainerTemplateTestDescriptor.STATIC_CLASS_SEGMENT_TYPE,
+			CombinationWithTestFactoryTestCase.class.getName());
+		var invocationId2 = containerTemplateId.append(ContainerTemplateInvocationTestDescriptor.SEGMENT_TYPE, "#2");
+		var testFactoryId2 = invocationId2.append(TestFactoryTestDescriptor.SEGMENT_TYPE, "test()");
+		var testFactory2DynamicTestId2 = testFactoryId2.append(TestFactoryTestDescriptor.DYNAMIC_TEST_SEGMENT_TYPE,
+			"#2");
+
+		var results = executeTests(selectUniqueId(testFactory2DynamicTestId2));
+
+		results.allEvents().assertEventsMatchExactly( //
+			event(engine(), started()), //
+			event(container(uniqueId(containerTemplateId)), started()), //
+
+			event(dynamicTestRegistered(uniqueId(invocationId2)),
+				displayName("[2] B of CombinationWithTestFactoryTestCase")), //
+			event(container(uniqueId(invocationId2)), started()), //
+			event(dynamicTestRegistered(uniqueId(testFactoryId2))), //
+			event(container(uniqueId(testFactoryId2)), started()), //
+			event(dynamicTestRegistered(uniqueId(testFactory2DynamicTestId2))), //
+			event(test(uniqueId(testFactory2DynamicTestId2)), started()), //
+			event(test(uniqueId(testFactory2DynamicTestId2)), finishedSuccessfully()), //
+			event(container(uniqueId(testFactoryId2)), finishedSuccessfully()), //
+			event(container(uniqueId(invocationId2)), finishedSuccessfully()), //
+
+			event(container(uniqueId(containerTemplateId)), finishedSuccessfully()), //
+			event(engine(), finishedSuccessfully()));
+	}
+
+	@Test
+	void failsIfProviderReturnsZeroInvocationContextWithoutOptIn() {
+		var results = executeTestsForClass(InvalidZeroInvocationTestCase.class);
+
+		results.allEvents().assertEventsMatchExactly( //
+			event(engine(), started()), //
+			event(container(InvalidZeroInvocationTestCase.class), started()), //
+			event(container(InvalidZeroInvocationTestCase.class),
+				finishedWithFailure(
+					message("Provider [Ext] did not provide any invocation contexts, but was expected to do so. "
+							+ "You may override mayReturnZeroContainerTemplateInvocationContexts() to allow this."))), //
+			event(engine(), finishedSuccessfully()));
+	}
+
+	@Test
+	void succeedsIfProviderReturnsZeroInvocationContextWithOptIn() {
+		var results = executeTestsForClass(ValidZeroInvocationTestCase.class);
+
+		results.allEvents().assertEventsMatchExactly( //
+			event(engine(), started()), //
+			event(container(ValidZeroInvocationTestCase.class), started()), //
+			event(container(ValidZeroInvocationTestCase.class), finishedSuccessfully()), //
+			event(engine(), finishedSuccessfully()));
+	}
+
+	@ParameterizedTest
+	@ValueSource(classes = { NoProviderRegisteredTestCase.class, NoSupportingProviderRegisteredTestCase.class })
+	void failsIfNoSupportingProviderIsRegistered(Class<?> testClass) {
+		var results = executeTestsForClass(testClass);
+
+		results.allEvents().assertEventsMatchExactly( //
+			event(engine(), started()), //
+			event(container(testClass), started()), //
+			event(container(testClass),
+				finishedWithFailure(
+					message("You must register at least one ContainerTemplateInvocationContextProvider that supports "
+							+ "@ContainerTemplate class [" + testClass.getName() + "]"))), //
+			event(engine(), finishedSuccessfully()));
+	}
+
+	@Test
+	void containerTemplateInvocationCanBeSelectedByUniqueId() {
+		var engineId = UniqueId.forEngine(JupiterEngineDescriptor.ENGINE_ID);
+		var containerTemplateId = engineId.append(ContainerTemplateTestDescriptor.STATIC_CLASS_SEGMENT_TYPE,
+			TwoInvocationsTestCase.class.getName());
+		var invocationId2 = containerTemplateId.append(ContainerTemplateInvocationTestDescriptor.SEGMENT_TYPE, "#2");
+		var methodAId = invocationId2.append(TestMethodTestDescriptor.SEGMENT_TYPE, "a()");
+		var nestedClassId = invocationId2.append(NestedClassTestDescriptor.SEGMENT_TYPE, "NestedTestCase");
+		var nestedMethodBId = nestedClassId.append(TestMethodTestDescriptor.SEGMENT_TYPE, "b()");
+
+		var results = executeTests(selectUniqueId(invocationId2));
+
+		results.allEvents().assertEventsMatchExactly( //
+			event(engine(), started()), //
+			event(container(uniqueId(containerTemplateId)), started()), //
+
+			event(dynamicTestRegistered(uniqueId(invocationId2)), displayName("[2] B of TwoInvocationsTestCase")), //
+			event(container(uniqueId(invocationId2)), started()), //
+			event(dynamicTestRegistered(uniqueId(methodAId))), //
+			event(dynamicTestRegistered(uniqueId(nestedClassId))), //
+			event(dynamicTestRegistered(uniqueId(nestedMethodBId))), //
+			event(test(uniqueId(methodAId)), started()), //
+			event(test(uniqueId(methodAId)), finishedSuccessfully()), //
+			event(container(uniqueId(nestedClassId)), started()), //
+			event(test(uniqueId(nestedMethodBId)), started()), //
+			event(test(uniqueId(nestedMethodBId)), finishedSuccessfully()), //
+			event(container(uniqueId(nestedClassId)), finishedSuccessfully()), //
+			event(container(uniqueId(invocationId2)), finishedSuccessfully()), //
+
+			event(container(uniqueId(containerTemplateId)), finishedSuccessfully()), //
+			event(engine(), finishedSuccessfully()));
+	}
+
+	@Test
+	void containerTemplateInvocationCanBeSelectedByIteration() {
+		var engineId = UniqueId.forEngine(JupiterEngineDescriptor.ENGINE_ID);
+		var containerTemplateId = engineId.append(ContainerTemplateTestDescriptor.STATIC_CLASS_SEGMENT_TYPE,
+			TwoInvocationsTestCase.class.getName());
+		var invocationId2 = containerTemplateId.append(ContainerTemplateInvocationTestDescriptor.SEGMENT_TYPE, "#2");
+		var methodAId = invocationId2.append(TestMethodTestDescriptor.SEGMENT_TYPE, "a()");
+		var nestedClassId = invocationId2.append(NestedClassTestDescriptor.SEGMENT_TYPE, "NestedTestCase");
+		var nestedMethodBId = nestedClassId.append(TestMethodTestDescriptor.SEGMENT_TYPE, "b()");
+
+		var results = executeTests(selectIteration(selectClass(TwoInvocationsTestCase.class), 1));
+
+		results.allEvents().assertEventsMatchExactly( //
+			event(engine(), started()), //
+			event(container(uniqueId(containerTemplateId)), started()), //
+
+			event(dynamicTestRegistered(uniqueId(invocationId2)), displayName("[2] B of TwoInvocationsTestCase")), //
+			event(container(uniqueId(invocationId2)), started()), //
+			event(dynamicTestRegistered(uniqueId(methodAId))), //
+			event(dynamicTestRegistered(uniqueId(nestedClassId))), //
+			event(dynamicTestRegistered(uniqueId(nestedMethodBId))), //
+			event(test(uniqueId(methodAId)), started()), //
+			event(test(uniqueId(methodAId)), finishedSuccessfully()), //
+			event(container(uniqueId(nestedClassId)), started()), //
+			event(test(uniqueId(nestedMethodBId)), started()), //
+			event(test(uniqueId(nestedMethodBId)), finishedSuccessfully()), //
+			event(container(uniqueId(nestedClassId)), finishedSuccessfully()), //
+			event(container(uniqueId(invocationId2)), finishedSuccessfully()), //
+
+			event(container(uniqueId(containerTemplateId)), finishedSuccessfully()), //
+			event(engine(), finishedSuccessfully()));
+	}
+
+	@ParameterizedTest
+	@ValueSource(strings = { //
+			"class:org.junit.jupiter.engine.ContainerTemplateInvocationTests$TwoInvocationsTestCase", //
+			"uid:[engine:junit-jupiter]/[container-template:org.junit.jupiter.engine.ContainerTemplateInvocationTests$TwoInvocationsTestCase]" //
+	})
+	void executesAllInvocationsForRedundantSelectors(String containerTemplateSelectorIdentifier) {
+		var engineId = UniqueId.forEngine(JupiterEngineDescriptor.ENGINE_ID);
+		var containerTemplateId = engineId.append(ContainerTemplateTestDescriptor.STATIC_CLASS_SEGMENT_TYPE,
+			TwoInvocationsTestCase.class.getName());
+		var invocationId2 = containerTemplateId.append(ContainerTemplateInvocationTestDescriptor.SEGMENT_TYPE, "#2");
+
+		var results = executeTests(selectUniqueId(invocationId2),
+			DiscoverySelectors.parse(containerTemplateSelectorIdentifier).orElseThrow());
+
+		results.testEvents().assertStatistics(stats -> stats.started(4).succeeded(4));
+	}
+
+	@Test
+	void methodInContainerTemplateInvocationCanBeSelectedByUniqueId() {
+		var engineId = UniqueId.forEngine(JupiterEngineDescriptor.ENGINE_ID);
+		var containerTemplateId = engineId.append(ContainerTemplateTestDescriptor.STATIC_CLASS_SEGMENT_TYPE,
+			TwoInvocationsTestCase.class.getName());
+		var invocationId2 = containerTemplateId.append(ContainerTemplateInvocationTestDescriptor.SEGMENT_TYPE, "#2");
+		var methodAId = invocationId2.append(TestMethodTestDescriptor.SEGMENT_TYPE, "a()");
+
+		var results = executeTests(selectUniqueId(methodAId));
+
+		results.allEvents().assertEventsMatchExactly( //
+			event(engine(), started()), //
+			event(container(uniqueId(containerTemplateId)), started()), //
+
+			event(dynamicTestRegistered(uniqueId(invocationId2)), displayName("[2] B of TwoInvocationsTestCase")), //
+			event(container(uniqueId(invocationId2)), started()), //
+			event(dynamicTestRegistered(uniqueId(methodAId))), //
+			event(test(uniqueId(methodAId)), started()), //
+			event(test(uniqueId(methodAId)), finishedSuccessfully()), //
+			event(container(uniqueId(invocationId2)), finishedSuccessfully()), //
+
+			event(container(uniqueId(containerTemplateId)), finishedSuccessfully()), //
+			event(engine(), finishedSuccessfully()));
+	}
+
+	@Test
+	void nestedMethodInContainerTemplateInvocationCanBeSelectedByUniqueId() {
+		var engineId = UniqueId.forEngine(JupiterEngineDescriptor.ENGINE_ID);
+		var containerTemplateId = engineId.append(ContainerTemplateTestDescriptor.STATIC_CLASS_SEGMENT_TYPE,
+			TwoInvocationsTestCase.class.getName());
+		var invocationId2 = containerTemplateId.append(ContainerTemplateInvocationTestDescriptor.SEGMENT_TYPE, "#2");
+		var nestedClassId = invocationId2.append(NestedClassTestDescriptor.SEGMENT_TYPE, "NestedTestCase");
+		var nestedMethodBId = nestedClassId.append(TestMethodTestDescriptor.SEGMENT_TYPE, "b()");
+
+		var results = executeTests(selectUniqueId(nestedMethodBId));
+
+		results.allEvents().assertEventsMatchExactly( //
+			event(engine(), started()), //
+			event(container(uniqueId(containerTemplateId)), started()), //
+
+			event(dynamicTestRegistered(uniqueId(invocationId2)), displayName("[2] B of TwoInvocationsTestCase")), //
+			event(container(uniqueId(invocationId2)), started()), //
+			event(dynamicTestRegistered(uniqueId(nestedClassId))), //
+			event(dynamicTestRegistered(uniqueId(nestedMethodBId))), //
+			event(container(uniqueId(nestedClassId)), started()), //
+			event(test(uniqueId(nestedMethodBId)), started()), //
+			event(test(uniqueId(nestedMethodBId)), finishedSuccessfully()), //
+			event(container(uniqueId(nestedClassId)), finishedSuccessfully()), //
+			event(container(uniqueId(invocationId2)), finishedSuccessfully()), //
+
+			event(container(uniqueId(containerTemplateId)), finishedSuccessfully()), //
+			event(engine(), finishedSuccessfully()));
+	}
+
+	@Test
+	void nestedContainerTemplateInvocationCanBeSelectedByUniqueId() {
+		var engineId = UniqueId.forEngine(JupiterEngineDescriptor.ENGINE_ID);
+		var outerContainerTemplateId = engineId.append(ContainerTemplateTestDescriptor.STATIC_CLASS_SEGMENT_TYPE,
+			TwoTimesTwoInvocationsWithMultipleMethodsTestCase.class.getName());
+		var outerInvocation2Id = outerContainerTemplateId.append(ContainerTemplateInvocationTestDescriptor.SEGMENT_TYPE,
+			"#2");
+		var outerInvocation2NestedContainerTemplateId = outerInvocation2Id.append(
+			ContainerTemplateTestDescriptor.NESTED_CLASS_SEGMENT_TYPE, "NestedTestCase");
+		var outerInvocation2InnerInvocation2Id = outerInvocation2NestedContainerTemplateId.append(
+			ContainerTemplateInvocationTestDescriptor.SEGMENT_TYPE, "#2");
+		var outerInvocation2InnerInvocation2NestedMethodId = outerInvocation2InnerInvocation2Id.append(
+			TestMethodTestDescriptor.SEGMENT_TYPE, "b()");
+
+		var results = executeTests(selectUniqueId(outerInvocation2InnerInvocation2NestedMethodId));
+
+		results.allEvents().assertEventsMatchExactly( //
+			event(engine(), started()), //
+			event(container(uniqueId(outerContainerTemplateId)), started()), //
+
+			event(dynamicTestRegistered(uniqueId(outerInvocation2Id)),
+				displayName("[2] B of TwoTimesTwoInvocationsWithMultipleMethodsTestCase")), //
+			event(container(uniqueId(outerInvocation2Id)), started()), //
+			event(dynamicTestRegistered(uniqueId(outerInvocation2NestedContainerTemplateId))), //
+			event(container(uniqueId(outerInvocation2NestedContainerTemplateId)), started()), //
+
+			event(dynamicTestRegistered(uniqueId(outerInvocation2InnerInvocation2Id)),
+				displayName("[2] B of NestedTestCase")), //
+			event(container(uniqueId(outerInvocation2InnerInvocation2Id)), started()), //
+			event(dynamicTestRegistered(uniqueId(outerInvocation2InnerInvocation2NestedMethodId))), //
+			event(test(uniqueId(outerInvocation2InnerInvocation2NestedMethodId)), started()), //
+			event(test(uniqueId(outerInvocation2InnerInvocation2NestedMethodId)), finishedSuccessfully()), //
+			event(container(uniqueId(outerInvocation2InnerInvocation2Id)), finishedSuccessfully()), //
+
+			event(container(uniqueId(outerInvocation2NestedContainerTemplateId)), finishedSuccessfully()), //
+			event(container(uniqueId(outerInvocation2Id)), finishedSuccessfully()), //
+
+			event(container(uniqueId(outerContainerTemplateId)), finishedSuccessfully()), //
+			event(engine(), finishedSuccessfully()));
+	}
+
+	@Test
+	void nestedContainerTemplateInvocationCanBeSelectedByIteration() {
+		var engineId = UniqueId.forEngine(JupiterEngineDescriptor.ENGINE_ID);
+		var outerContainerTemplateId = engineId.append(ContainerTemplateTestDescriptor.STATIC_CLASS_SEGMENT_TYPE,
+			TwoTimesTwoInvocationsTestCase.class.getName());
+		var outerInvocation1Id = outerContainerTemplateId.append(ContainerTemplateInvocationTestDescriptor.SEGMENT_TYPE,
+			"#1");
+		var outerInvocation1NestedContainerTemplateId = outerInvocation1Id.append(
+			ContainerTemplateTestDescriptor.NESTED_CLASS_SEGMENT_TYPE, "NestedTestCase");
+		var outerInvocation1InnerInvocation2Id = outerInvocation1NestedContainerTemplateId.append(
+			ContainerTemplateInvocationTestDescriptor.SEGMENT_TYPE, "#2");
+		var outerInvocation1InnerInvocation2NestedMethodId = outerInvocation1InnerInvocation2Id.append(
+			TestMethodTestDescriptor.SEGMENT_TYPE, "test()");
+		var outerInvocation2Id = outerContainerTemplateId.append(ContainerTemplateInvocationTestDescriptor.SEGMENT_TYPE,
+			"#2");
+		var outerInvocation2NestedContainerTemplateId = outerInvocation2Id.append(
+			ContainerTemplateTestDescriptor.NESTED_CLASS_SEGMENT_TYPE, "NestedTestCase");
+		var outerInvocation2InnerInvocation2Id = outerInvocation2NestedContainerTemplateId.append(
+			ContainerTemplateInvocationTestDescriptor.SEGMENT_TYPE, "#2");
+		var outerInvocation2InnerInvocation2NestedMethodId = outerInvocation2InnerInvocation2Id.append(
+			TestMethodTestDescriptor.SEGMENT_TYPE, "test()");
+
+		var results = executeTests(selectIteration(selectNestedClass(List.of(TwoTimesTwoInvocationsTestCase.class),
+			TwoTimesTwoInvocationsTestCase.NestedTestCase.class), 1));
+
+		results.allEvents().assertEventsMatchExactly( //
+			event(engine(), started()), //
+			event(container(uniqueId(outerContainerTemplateId)), started()), //
+
+			event(dynamicTestRegistered(uniqueId(outerInvocation1Id)),
+				displayName("[1] A of TwoTimesTwoInvocationsTestCase")), //
+			event(container(uniqueId(outerInvocation1Id)), started()), //
+			event(dynamicTestRegistered(uniqueId(outerInvocation1NestedContainerTemplateId))), //
+			event(container(uniqueId(outerInvocation1NestedContainerTemplateId)), started()), //
+
+			event(dynamicTestRegistered(uniqueId(outerInvocation1InnerInvocation2Id)),
+				displayName("[2] B of NestedTestCase")), //
+			event(container(uniqueId(outerInvocation1InnerInvocation2Id)), started()), //
+			event(dynamicTestRegistered(uniqueId(outerInvocation1InnerInvocation2NestedMethodId))), //
+			event(test(uniqueId(outerInvocation1InnerInvocation2NestedMethodId)), started()), //
+			event(test(uniqueId(outerInvocation1InnerInvocation2NestedMethodId)), finishedSuccessfully()), //
+			event(container(uniqueId(outerInvocation1InnerInvocation2Id)), finishedSuccessfully()), //
+
+			event(container(uniqueId(outerInvocation1NestedContainerTemplateId)), finishedSuccessfully()), //
+			event(container(uniqueId(outerInvocation1Id)), finishedSuccessfully()), //
+
+			event(dynamicTestRegistered(uniqueId(outerInvocation2Id)),
+				displayName("[2] B of TwoTimesTwoInvocationsTestCase")), //
+			event(container(uniqueId(outerInvocation2Id)), started()), //
+			event(dynamicTestRegistered(uniqueId(outerInvocation2NestedContainerTemplateId))), //
+			event(container(uniqueId(outerInvocation2NestedContainerTemplateId)), started()), //
+
+			event(dynamicTestRegistered(uniqueId(outerInvocation2InnerInvocation2Id)),
+				displayName("[2] B of NestedTestCase")), //
+			event(container(uniqueId(outerInvocation2InnerInvocation2Id)), started()), //
+			event(dynamicTestRegistered(uniqueId(outerInvocation2InnerInvocation2NestedMethodId))), //
+			event(test(uniqueId(outerInvocation2InnerInvocation2NestedMethodId)), started()), //
+			event(test(uniqueId(outerInvocation2InnerInvocation2NestedMethodId)), finishedSuccessfully()), //
+			event(container(uniqueId(outerInvocation2InnerInvocation2Id)), finishedSuccessfully()), //
+
+			event(container(uniqueId(outerInvocation2NestedContainerTemplateId)), finishedSuccessfully()), //
+			event(container(uniqueId(outerInvocation2Id)), finishedSuccessfully()), //
+
+			event(container(uniqueId(outerContainerTemplateId)), finishedSuccessfully()), //
+			event(engine(), finishedSuccessfully()));
+	}
+
+	@Test
+	void executesLifecycleCallbackMethodsInNestedContainerTemplates() {
+		var results = executeTestsForClass(TwoTimesTwoInvocationsWithLifecycleCallbacksTestCase.class);
+
+		results.containerEvents().assertStatistics(stats -> stats.started(10).succeeded(10));
+		results.testEvents().assertStatistics(stats -> stats.started(4).succeeded(4));
+
+		var callSequence = results.allEvents().reportingEntryPublished() //
+				.map(event -> event.getRequiredPayload(ReportEntry.class)) //
+				.map(ReportEntry::getKeyValuePairs) //
+				.map(Map::values) //
+				.flatMap(Collection::stream);
+		// @formatter:off
+		assertThat(callSequence).containsExactly(
+			"beforeAll: TwoTimesTwoInvocationsWithLifecycleCallbacksTestCase",
+				"beforeAll: NestedTestCase",
+					"beforeEach: test [TwoTimesTwoInvocationsWithLifecycleCallbacksTestCase]",
+						"beforeEach: test [NestedTestCase]",
+							"test",
+						"afterEach: test [NestedTestCase]",
+					"afterEach: test [TwoTimesTwoInvocationsWithLifecycleCallbacksTestCase]",
+					"beforeEach: test [TwoTimesTwoInvocationsWithLifecycleCallbacksTestCase]",
+						"beforeEach: test [NestedTestCase]",
+							"test",
+						"afterEach: test [NestedTestCase]",
+					"afterEach: test [TwoTimesTwoInvocationsWithLifecycleCallbacksTestCase]",
+				"afterAll: NestedTestCase",
+				"beforeAll: NestedTestCase",
+					"beforeEach: test [TwoTimesTwoInvocationsWithLifecycleCallbacksTestCase]",
+						"beforeEach: test [NestedTestCase]",
+							"test",
+						"afterEach: test [NestedTestCase]",
+					"afterEach: test [TwoTimesTwoInvocationsWithLifecycleCallbacksTestCase]",
+					"beforeEach: test [TwoTimesTwoInvocationsWithLifecycleCallbacksTestCase]",
+						"beforeEach: test [NestedTestCase]",
+							"test",
+						"afterEach: test [NestedTestCase]",
+					"afterEach: test [TwoTimesTwoInvocationsWithLifecycleCallbacksTestCase]",
+				"afterAll: NestedTestCase",
+			"afterAll: TwoTimesTwoInvocationsWithLifecycleCallbacksTestCase"
+		);
+		// @formatter:on
+	}
+
+	// -------------------------------------------------------------------
+
+	@SuppressWarnings("JUnitMalformedDeclaration")
+	@ContainerTemplate
+	@ExtendWith(TwoInvocationsContainerTemplateInvocationContextProvider.class)
+	static class TwoInvocationsTestCase {
+		@Test
+		void a() {
+		}
+
+		@Nested
+		class NestedTestCase {
+			@Test
+			@Tag("nested")
+			void b() {
+			}
+		}
+	}
+
+	@SuppressWarnings("JUnitMalformedDeclaration")
+	static class NestedContainerTemplateWithTwoInvocationsTestCase {
+		@Test
+		void a() {
+		}
+
+		@Nested
+		@ContainerTemplate
+		@ExtendWith(TwoInvocationsContainerTemplateInvocationContextProvider.class)
+		class NestedTestCase {
+			@Test
+			void b() {
+			}
+		}
+	}
+
+	@ExtendWith(TwoInvocationsContainerTemplateInvocationContextProvider.class)
+	@ContainerTemplate
+	static class TwoTimesTwoInvocationsTestCase {
+		@Nested
+		@ContainerTemplate
+		class NestedTestCase {
+			@Test
+			void test() {
+			}
+		}
+	}
+
+	@SuppressWarnings("JUnitMalformedDeclaration")
+	@ContainerTemplate
+	@ExtendWith(TwoInvocationsContainerTemplateInvocationContextProvider.class)
+	static class TwoInvocationsWithExtensionTestCase {
+		@Test
+		void a() {
+		}
+
+		@Nested
+		class NestedTestCase {
+			@Test
+			@Tag("nested")
+			void b() {
+			}
+		}
+	}
+
+	static class TwoInvocationsContainerTemplateInvocationContextProvider
+			implements ContainerTemplateInvocationContextProvider {
+
+		@Override
+		public boolean supportsContainerTemplate(ExtensionContext context) {
+			return true;
+		}
+
+		@Override
+		public Stream<Ctx> provideContainerTemplateInvocationContexts(ExtensionContext context) {
+			var suffix = " of %s".formatted(context.getRequiredTestClass().getSimpleName());
+			return Stream.of(new Ctx("A" + suffix), new Ctx("B" + suffix));
+		}
+
+		record Ctx(String displayName) implements ContainerTemplateInvocationContext {
+			@Override
+			public String getDisplayName(int invocationIndex) {
+				var defaultDisplayName = ContainerTemplateInvocationContext.super.getDisplayName(invocationIndex);
+				return "%s %s".formatted(defaultDisplayName, displayName);
+			}
+		}
+	}
+
+	@SuppressWarnings("JUnitMalformedDeclaration")
+	@ContainerTemplate
+	@ExtendWith(AdditionalExtensionRegistrationTestCase.Ext.class)
+	static class AdditionalExtensionRegistrationTestCase {
+
+		@Test
+		void test(Data data) {
+			assertNotNull(data);
+			assertNotNull(data.value());
+		}
+
+		static class Ext implements ContainerTemplateInvocationContextProvider {
+			@Override
+			public boolean supportsContainerTemplate(ExtensionContext context) {
+				return true;
+			}
+
+			@Override
+			public Stream<Ctx> provideContainerTemplateInvocationContexts(ExtensionContext context) {
+				return Stream.of(new Data("A"), new Data("B")).map(Ctx::new);
+			}
+		}
+
+		record Ctx(Data data) implements ContainerTemplateInvocationContext {
+			@Override
+			public String getDisplayName(int invocationIndex) {
+				return this.data.value();
+			}
+
+			@Override
+			public List<Extension> getAdditionalExtensions() {
+				return List.of(new ParameterResolver() {
+					@Override
+					public boolean supportsParameter(ParameterContext parameterContext,
+							ExtensionContext extensionContext) throws ParameterResolutionException {
+						return Data.class.equals(parameterContext.getParameter().getType());
+					}
+
+					@Override
+					public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext)
+							throws ParameterResolutionException {
+						return Ctx.this.data;
+					}
+				});
+			}
+		}
+
+		record Data(String value) {
+		}
+	}
+
+	@SuppressWarnings("JUnitMalformedDeclaration")
+	@ContainerTemplate
+	@ExtendWith(TwoInvocationsContainerTemplateInvocationContextProvider.class)
+	@ExtendWith(SeparateExtensionContextTestCase.SomeResourceExtension.class)
+	static class SeparateExtensionContextTestCase {
+
+		@Test
+		void test(SomeResource someResource) {
+			assertFalse(someResource.closed);
+		}
+
+		static class SomeResourceExtension implements BeforeAllCallback, ParameterResolver {
+
+			@Override
+			public void beforeAll(ExtensionContext context) throws Exception {
+				context.getStore(ExtensionContext.Namespace.GLOBAL).put("someResource", new SomeResource());
+			}
+
+			@Override
+			public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext)
+					throws ParameterResolutionException {
+				var parentContext = extensionContext.getParent().orElseThrow();
+				assertAll( //
+					() -> assertEquals(SeparateExtensionContextTestCase.class, parentContext.getRequiredTestClass()), //
+					() -> assertEquals(SeparateExtensionContextTestCase.class,
+						parentContext.getElement().orElseThrow()), //
+					() -> assertEquals(TestInstance.Lifecycle.PER_METHOD,
+						parentContext.getTestInstanceLifecycle().orElseThrow()) //
+				);
+				return SomeResource.class.equals(parameterContext.getParameter().getType());
+			}
+
+			@Override
+			public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext)
+					throws ParameterResolutionException {
+				return extensionContext.getStore(ExtensionContext.Namespace.GLOBAL).get("someResource");
+			}
+		}
+
+		static class SomeResource implements CloseableResource {
+			private boolean closed;
+
+			@Override
+			public void close() {
+				this.closed = true;
+			}
+		}
+	}
+
+	@ContainerTemplate
+	@ExtendWith(TwoInvocationsContainerTemplateInvocationContextProvider.class)
+	static class CombinationWithTestTemplateTestCase {
+
+		@ParameterizedTest
+		@ValueSource(ints = { 1, 2 })
+		void test(int i) {
+			assertNotEquals(0, i);
+		}
+	}
+
+	@ContainerTemplate
+	@ExtendWith(TwoInvocationsContainerTemplateInvocationContextProvider.class)
+	static class CombinationWithTestFactoryTestCase {
+
+		@TestFactory
+		Stream<DynamicTest> test() {
+			return IntStream.of(1, 2) //
+					.mapToObj(i -> dynamicTest("test" + i, () -> assertNotEquals(0, i)));
+		}
+	}
+
+	@SuppressWarnings("JUnitMalformedDeclaration")
+	@ContainerTemplate
+	@ExtendWith(InvalidZeroInvocationTestCase.Ext.class)
+	static class InvalidZeroInvocationTestCase {
+
+		@Test
+		void test() {
+			fail("should not be called");
+		}
+
+		static class Ext implements ContainerTemplateInvocationContextProvider {
+
+			@Override
+			public boolean supportsContainerTemplate(ExtensionContext context) {
+				return true;
+			}
+
+			@Override
+			public Stream<ContainerTemplateInvocationContext> provideContainerTemplateInvocationContexts(
+					ExtensionContext context) {
+				return Stream.empty();
+			}
+		}
+	}
+
+	@SuppressWarnings("JUnitMalformedDeclaration")
+	@ContainerTemplate
+	@ExtendWith(ValidZeroInvocationTestCase.Ext.class)
+	static class ValidZeroInvocationTestCase {
+
+		@Test
+		void test() {
+			fail("should not be called");
+		}
+
+		static class Ext implements ContainerTemplateInvocationContextProvider {
+
+			@Override
+			public boolean supportsContainerTemplate(ExtensionContext context) {
+				return true;
+			}
+
+			@Override
+			public Stream<ContainerTemplateInvocationContext> provideContainerTemplateInvocationContexts(
+					ExtensionContext context) {
+				return Stream.empty();
+			}
+
+			@Override
+			public boolean mayReturnZeroContainerTemplateInvocationContexts(ExtensionContext context) {
+				return true;
+			}
+		}
+	}
+
+	@SuppressWarnings("JUnitMalformedDeclaration")
+	@ContainerTemplate
+	static class NoProviderRegisteredTestCase {
+
+		@Test
+		void test() {
+			fail("should not be called");
+		}
+	}
+
+	@SuppressWarnings("JUnitMalformedDeclaration")
+	@ContainerTemplate
+	@ExtendWith(NoSupportingProviderRegisteredTestCase.Ext.class)
+	static class NoSupportingProviderRegisteredTestCase {
+
+		@Test
+		void test() {
+			fail("should not be called");
+		}
+
+		static class Ext implements ContainerTemplateInvocationContextProvider {
+
+			@Override
+			public boolean supportsContainerTemplate(ExtensionContext context) {
+				return false;
+			}
+
+			@Override
+			public Stream<ContainerTemplateInvocationContext> provideContainerTemplateInvocationContexts(
+					ExtensionContext context) {
+				throw new RuntimeException("should not be called");
+			}
+		}
+	}
+
+	@SuppressWarnings("JUnitMalformedDeclaration")
+	@ExtendWith(TwoInvocationsContainerTemplateInvocationContextProvider.class)
+	@ContainerTemplate
+	static class TwoTimesTwoInvocationsWithMultipleMethodsTestCase {
+
+		@Test
+		void test() {
+		}
+
+		@Nested
+		@ContainerTemplate
+		class NestedTestCase {
+			@Test
+			void a() {
+			}
+
+			@Test
+			void b() {
+			}
+		}
+
+		@Nested
+		@ContainerTemplate
+		class AnotherNestedTestCase {
+			@Test
+			void test() {
+			}
+		}
+	}
+
+	@ExtendWith(TwoInvocationsContainerTemplateInvocationContextProvider.class)
+	@ContainerTemplate
+	static class TwoTimesTwoInvocationsWithLifecycleCallbacksTestCase extends LifecycleCallbacks {
+		@Nested
+		@ContainerTemplate
+		class NestedTestCase extends LifecycleCallbacks {
+			@Test
+			@DisplayName("test")
+			void test(TestReporter testReporter) {
+				testReporter.publishEntry("test");
+			}
+		}
+	}
+
+	@SuppressWarnings("JUnitMalformedDeclaration")
+	static class LifecycleCallbacks {
+		@BeforeAll
+		static void beforeAll(TestReporter testReporter, TestInfo testInfo) {
+			testReporter.publishEntry("beforeAll: " + testInfo.getTestClass().orElseThrow().getSimpleName());
+		}
+
+		@BeforeEach
+		void beforeEach(TestReporter testReporter, TestInfo testInfo) {
+			testReporter.publishEntry(
+				"beforeEach: " + testInfo.getDisplayName() + " [" + getClass().getSimpleName() + "]");
+		}
+
+		@AfterEach
+		void afterEach(TestReporter testReporter, TestInfo testInfo) {
+			testReporter.publishEntry(
+				"afterEach: " + testInfo.getDisplayName() + " [" + getClass().getSimpleName() + "]");
+		}
+
+		@AfterAll
+		static void afterAll(TestReporter testReporter, TestInfo testInfo) {
+			testReporter.publishEntry("afterAll: " + testInfo.getTestClass().orElseThrow().getSimpleName());
+		}
+	}
+}
diff --git a/jupiter-tests/src/test/java/org/junit/jupiter/engine/TestInstanceLifecycleTests.java b/jupiter-tests/src/test/java/org/junit/jupiter/engine/TestInstanceLifecycleTests.java
index 91676086d..784df0e19 100644
--- a/jupiter-tests/src/test/java/org/junit/jupiter/engine/TestInstanceLifecycleTests.java
+++ b/jupiter-tests/src/test/java/org/junit/jupiter/engine/TestInstanceLifecycleTests.java
@@ -20,6 +20,7 @@ import static org.junit.jupiter.api.Assertions.assertNotSame;
 import static org.junit.jupiter.api.Assertions.assertNull;
 import static org.junit.jupiter.api.Assertions.assertSame;
 import static org.junit.platform.commons.support.AnnotationSupport.isAnnotated;
+import static org.junit.platform.engine.discovery.DiscoverySelectors.selectClass;
 
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
@@ -30,12 +31,14 @@ import java.util.ArrayList;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Objects;
 import java.util.stream.Stream;
 
 import org.junit.jupiter.api.AfterAll;
 import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.BeforeAll;
 import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.ContainerTemplate;
 import org.junit.jupiter.api.Nested;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.TestInfo;
@@ -47,6 +50,8 @@ import org.junit.jupiter.api.extension.AfterEachCallback;
 import org.junit.jupiter.api.extension.BeforeAllCallback;
 import org.junit.jupiter.api.extension.BeforeEachCallback;
 import org.junit.jupiter.api.extension.ConditionEvaluationResult;
+import org.junit.jupiter.api.extension.ContainerTemplateInvocationContext;
+import org.junit.jupiter.api.extension.ContainerTemplateInvocationContextProvider;
 import org.junit.jupiter.api.extension.ExecutionCondition;
 import org.junit.jupiter.api.extension.ExtendWith;
 import org.junit.jupiter.api.extension.ExtensionContext;
@@ -56,6 +61,8 @@ import org.junit.jupiter.api.extension.TestInstances;
 import org.junit.jupiter.api.extension.TestTemplateInvocationContext;
 import org.junit.jupiter.api.extension.TestTemplateInvocationContextProvider;
 import org.junit.jupiter.engine.execution.DefaultTestInstances;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.EnumSource;
 import org.junit.platform.testkit.engine.EngineExecutionResults;
 
 /**
@@ -601,6 +608,44 @@ class TestInstanceLifecycleTests extends AbstractJupiterTestEngineTests {
 		assertThat(lifecyclesMap.get(nestedTestClass).stream()).allMatch(Lifecycle.PER_CLASS::equals);
 	}
 
+	@ParameterizedTest
+	@EnumSource(Lifecycle.class)
+	void containerTemplate(Lifecycle lifecycle) {
+		var containerTemplate = ContainerTemplateWithDefaultLifecycleTestCase.class;
+
+		var results = executeTests(r -> r //
+				.selectors(selectClass(containerTemplate)) //
+				.configurationParameter(Constants.DEFAULT_TEST_INSTANCE_LIFECYCLE_PROPERTY_NAME, lifecycle.name()));
+
+		results.allEvents().assertStatistics(stats -> stats.failed(0));
+		results.testEvents().assertStatistics(stats -> stats.succeeded(4));
+
+		assertThat(instanceCount).containsExactly(entry(containerTemplate, lifecycle == Lifecycle.PER_CLASS ? 1 : 4));
+		assertThat(lifecyclesMap.keySet()).containsExactly(containerTemplate);
+		assertThat(lifecyclesMap.get(containerTemplate)).filteredOn(Objects::nonNull).containsOnly(lifecycle);
+	}
+
+	@ParameterizedTest
+	@EnumSource(Lifecycle.class)
+	void containerTemplateWithNestedClass(Lifecycle lifecycle) {
+		var containerTemplate = ContainerTemplateWithDefaultLifecycleAndNestedClassTestCase.class;
+		var nestedClass = ContainerTemplateWithDefaultLifecycleAndNestedClassTestCase.InnerTestCase.class;
+
+		var results = executeTests(r -> r //
+				.selectors(selectClass(containerTemplate)) //
+				.configurationParameter(Constants.DEFAULT_TEST_INSTANCE_LIFECYCLE_PROPERTY_NAME, lifecycle.name()));
+
+		results.allEvents().assertStatistics(stats -> stats.failed(0));
+		results.testEvents().assertStatistics(stats -> stats.succeeded(4));
+
+		assertThat(instanceCount).containsExactly( //
+			entry(containerTemplate, lifecycle == Lifecycle.PER_CLASS ? 1 : 4), //
+			entry(nestedClass, lifecycle == Lifecycle.PER_CLASS ? 2 : 4));
+		assertThat(lifecyclesMap.keySet()).containsExactlyInAnyOrder(containerTemplate, nestedClass);
+		assertThat(lifecyclesMap.get(containerTemplate)).filteredOn(Objects::nonNull).containsOnly(lifecycle);
+		assertThat(lifecyclesMap.get(nestedClass)).filteredOn(Objects::nonNull).containsOnly(lifecycle);
+	}
+
 	private void performAssertions(Class<?> testClass, int numContainers, int numTests,
 			Map.Entry<Class<?>, Integer>[] instanceCountEntries, int allMethods, int eachMethods) {
 
@@ -623,7 +668,7 @@ class TestInstanceLifecycleTests extends AbstractJupiterTestEngineTests {
 
 	@SafeVarargs
 	@SuppressWarnings("varargs")
-	private final Map.Entry<Class<?>, Integer>[] instanceCounts(Map.Entry<Class<?>, Integer>... entries) {
+	private Map.Entry<Class<?>, Integer>[] instanceCounts(Map.Entry<Class<?>, Integer>... entries) {
 		return entries;
 	}
 
@@ -983,7 +1028,9 @@ class TestInstanceLifecycleTests extends AbstractJupiterTestEngineTests {
 			String testMethod = context.getTestMethod().map(Method::getName).orElse(null);
 			if (testMethod == null) {
 				assertThat(context.getTestInstance()).isNotPresent();
-				assertThat(instanceCount.getOrDefault(context.getRequiredTestClass(), 0)).isEqualTo(0);
+				if (!isAnnotated(context.getRequiredTestClass().getEnclosingClass(), ContainerTemplate.class)) {
+					assertThat(instanceCount.getOrDefault(context.getRequiredTestClass(), 0)).isEqualTo(0);
+				}
 			}
 			instanceMap.put(executionConditionKey(context.getRequiredTestClass(), testMethod),
 				context.getTestInstances().orElse(null));
@@ -1067,4 +1114,66 @@ class TestInstanceLifecycleTests extends AbstractJupiterTestEngineTests {
 	@interface SingletonTest {
 	}
 
+	@SuppressWarnings("JUnitMalformedDeclaration")
+	@ContainerTemplate
+	@ExtendWith(Twice.class)
+	@ExtendWith(InstanceTrackingExtension.class)
+	static class ContainerTemplateWithDefaultLifecycleTestCase {
+
+		ContainerTemplateWithDefaultLifecycleTestCase() {
+			incrementInstanceCount(ContainerTemplateWithDefaultLifecycleTestCase.class);
+		}
+
+		@Test
+		void test1() {
+		}
+
+		@Test
+		void test2() {
+		}
+	}
+
+	@ContainerTemplate
+	@ExtendWith(Twice.class)
+	@ExtendWith(InstanceTrackingExtension.class)
+	static class ContainerTemplateWithDefaultLifecycleAndNestedClassTestCase {
+
+		ContainerTemplateWithDefaultLifecycleAndNestedClassTestCase() {
+			incrementInstanceCount(ContainerTemplateWithDefaultLifecycleAndNestedClassTestCase.class);
+		}
+
+		@Nested
+		class InnerTestCase {
+
+			public InnerTestCase() {
+				incrementInstanceCount(InnerTestCase.class);
+			}
+
+			@Test
+			void test1() {
+			}
+
+			@Test
+			void test2() {
+			}
+		}
+	}
+
+	private static class Twice implements ContainerTemplateInvocationContextProvider {
+
+		@Override
+		public boolean supportsContainerTemplate(ExtensionContext context) {
+			return true;
+		}
+
+		@Override
+		public Stream<ContainerTemplateInvocationContext> provideContainerTemplateInvocationContexts(
+				ExtensionContext context) {
+			return Stream.of(new Ctx(), new Ctx());
+		}
+
+		private record Ctx() implements ContainerTemplateInvocationContext {
+		}
+	}
+
 }
diff --git a/jupiter-tests/src/test/java/org/junit/jupiter/engine/descriptor/ExtensionContextTests.java b/jupiter-tests/src/test/java/org/junit/jupiter/engine/descriptor/ExtensionContextTests.java
index 48682ff17..11b50f5df 100644
--- a/jupiter-tests/src/test/java/org/junit/jupiter/engine/descriptor/ExtensionContextTests.java
+++ b/jupiter-tests/src/test/java/org/junit/jupiter/engine/descriptor/ExtensionContextTests.java
@@ -18,6 +18,7 @@ import static org.junit.jupiter.api.Assertions.assertNull;
 import static org.junit.jupiter.api.Assertions.assertThrows;
 import static org.junit.jupiter.api.Assertions.fail;
 import static org.junit.jupiter.api.Named.named;
+import static org.junit.jupiter.api.TestInstance.Lifecycle.PER_METHOD;
 import static org.junit.platform.launcher.core.OutputDirectoryProviders.dummyOutputDirectoryProvider;
 import static org.junit.platform.launcher.core.OutputDirectoryProviders.hierarchicalOutputDirectoryProvider;
 import static org.mockito.ArgumentMatchers.eq;
@@ -116,8 +117,8 @@ public class ExtensionContextTests {
 		var nestedClassDescriptor = nestedClassDescriptor();
 		var outerClassDescriptor = outerClassDescriptor(nestedClassDescriptor);
 
-		var outerExtensionContext = new ClassExtensionContext(null, null, outerClassDescriptor, configuration,
-			extensionRegistry, null);
+		var outerExtensionContext = new ClassExtensionContext(null, null, outerClassDescriptor, PER_METHOD,
+			configuration, extensionRegistry, null);
 
 		// @formatter:off
 		assertAll("outerContext",
@@ -136,15 +137,15 @@ public class ExtensionContextTests {
 		// @formatter:on
 
 		var nestedExtensionContext = new ClassExtensionContext(outerExtensionContext, null, nestedClassDescriptor,
-			configuration, extensionRegistry, null);
+			PER_METHOD, configuration, extensionRegistry, null);
 		assertThat(nestedExtensionContext.getParent()).containsSame(outerExtensionContext);
 	}
 
 	@Test
 	void ExtensionContext_With_ExtensionRegistry_getExtensions() {
 		var classTestDescriptor = nestedClassDescriptor();
-		try (var ctx = new ClassExtensionContext(null, null, classTestDescriptor, configuration, extensionRegistry,
-			null)) {
+		try (var ctx = new ClassExtensionContext(null, null, classTestDescriptor, PER_METHOD, configuration,
+			extensionRegistry, null)) {
 
 			Extension ext = mock();
 			when(extensionRegistry.getExtensions(Extension.class)).thenReturn(List.of(ext));
@@ -161,14 +162,14 @@ public class ExtensionContextTests {
 		var methodTestDescriptor = methodDescriptor();
 		outerClassDescriptor.addChild(methodTestDescriptor);
 
-		var outerExtensionContext = new ClassExtensionContext(null, null, outerClassDescriptor, configuration,
-			extensionRegistry, null);
+		var outerExtensionContext = new ClassExtensionContext(null, null, outerClassDescriptor, PER_METHOD,
+			configuration, extensionRegistry, null);
 
 		assertThat(outerExtensionContext.getTags()).containsExactly("outer-tag");
 		assertThat(outerExtensionContext.getRoot()).isSameAs(outerExtensionContext);
 
 		var nestedExtensionContext = new ClassExtensionContext(outerExtensionContext, null, nestedClassDescriptor,
-			configuration, extensionRegistry, null);
+			PER_METHOD, configuration, extensionRegistry, null);
 		assertThat(nestedExtensionContext.getTags()).containsExactlyInAnyOrder("outer-tag", "nested-tag");
 		assertThat(nestedExtensionContext.getRoot()).isSameAs(outerExtensionContext);
 
@@ -193,7 +194,7 @@ public class ExtensionContextTests {
 		var engineExtensionContext = new JupiterEngineExtensionContext(null, engineDescriptor, configuration,
 			extensionRegistry);
 		var classExtensionContext = new ClassExtensionContext(engineExtensionContext, null, classTestDescriptor,
-			configuration, extensionRegistry, null);
+			PER_METHOD, configuration, extensionRegistry, null);
 		var methodExtensionContext = new MethodExtensionContext(classExtensionContext, null, methodTestDescriptor,
 			configuration, extensionRegistry, new OpenTest4JAwareThrowableCollector());
 		methodExtensionContext.setTestInstances(DefaultTestInstances.of(testInstance));
@@ -221,7 +222,7 @@ public class ExtensionContextTests {
 		var classTestDescriptor = outerClassDescriptor(null);
 		var engineExecutionListener = spy(EngineExecutionListener.class);
 		ExtensionContext extensionContext = new ClassExtensionContext(null, engineExecutionListener,
-			classTestDescriptor, configuration, extensionRegistry, null);
+			classTestDescriptor, PER_METHOD, configuration, extensionRegistry, null);
 
 		var map1 = Collections.singletonMap("key", "value");
 		var map2 = Collections.singletonMap("other key", "other value");
@@ -346,7 +347,7 @@ public class ExtensionContextTests {
 			EngineExecutionListener engineExecutionListener, ClassTestDescriptor classTestDescriptor) {
 		when(configuration.getOutputDirectoryProvider()) //
 				.thenReturn(hierarchicalOutputDirectoryProvider(tempDir));
-		return new ClassExtensionContext(null, engineExecutionListener, classTestDescriptor, configuration,
+		return new ClassExtensionContext(null, engineExecutionListener, classTestDescriptor, PER_METHOD, configuration,
 			extensionRegistry, null);
 	}
 
@@ -355,8 +356,8 @@ public class ExtensionContextTests {
 	void usingStore() {
 		var methodTestDescriptor = methodDescriptor();
 		var classTestDescriptor = outerClassDescriptor(methodTestDescriptor);
-		ExtensionContext parentContext = new ClassExtensionContext(null, null, classTestDescriptor, configuration,
-			extensionRegistry, null);
+		ExtensionContext parentContext = new ClassExtensionContext(null, null, classTestDescriptor, PER_METHOD,
+			configuration, extensionRegistry, null);
 		var childContext = new MethodExtensionContext(parentContext, null, methodTestDescriptor, configuration,
 			extensionRegistry, new OpenTest4JAwareThrowableCollector());
 		childContext.setTestInstances(DefaultTestInstances.of(new OuterClass()));
@@ -415,8 +416,8 @@ public class ExtensionContextTests {
 			named("class", (JupiterConfiguration configuration) -> {
 				var classUniqueId = UniqueId.parse("[engine:junit-jupiter]/[class:MyClass]");
 				var classTestDescriptor = new ClassTestDescriptor(classUniqueId, testClass, configuration);
-				return new ClassExtensionContext(null, null, classTestDescriptor, configuration, extensionRegistry,
-					null);
+				return new ClassExtensionContext(null, null, classTestDescriptor, PER_METHOD, configuration,
+					extensionRegistry, null);
 			}), //
 			named("method", (JupiterConfiguration configuration) -> {
 				var method = ReflectionSupport.findMethod(testClass, "extensionContextFactories").orElseThrow();
diff --git a/jupiter-tests/src/test/java/org/junit/jupiter/engine/descriptor/TestFactoryTestDescriptorTests.java b/jupiter-tests/src/test/java/org/junit/jupiter/engine/descriptor/TestFactoryTestDescriptorTests.java
index 6ad584b72..ad1ef49fc 100644
--- a/jupiter-tests/src/test/java/org/junit/jupiter/engine/descriptor/TestFactoryTestDescriptorTests.java
+++ b/jupiter-tests/src/test/java/org/junit/jupiter/engine/descriptor/TestFactoryTestDescriptorTests.java
@@ -48,6 +48,31 @@ import org.junit.platform.engine.support.hierarchical.OpenTest4JAwareThrowableCo
  */
 class TestFactoryTestDescriptorTests {
 
+	@Test
+	void copyIncludesTransformedDynamicDescendantFilter() throws Exception {
+		var rootUniqueId = UniqueId.forEngine("engine");
+		var parentUniqueId = rootUniqueId.append("class", "myClass");
+		var originalUniqueId = parentUniqueId.append("old", "testFactory()");
+
+		var configuration = mock(JupiterConfiguration.class);
+		when(configuration.getDefaultDisplayNameGenerator()).thenReturn(new CustomDisplayNameGenerator());
+		Method testMethod = CustomStreamTestCase.class.getDeclaredMethod("customStream");
+		var original = new TestFactoryTestDescriptor(originalUniqueId, CustomStreamTestCase.class, testMethod, List::of,
+			configuration);
+
+		original.getDynamicDescendantFilter().allowUniqueIdPrefix(originalUniqueId.append("foo", "bar"));
+		original.getDynamicDescendantFilter().allowIndex(42);
+
+		var newUniqueId = parentUniqueId.append("new", "testFactory()");
+
+		var copy = original.withUniqueId(new UniqueIdPrefixTransformer(originalUniqueId, newUniqueId));
+
+		assertThat(copy.getUniqueId()).isEqualTo(newUniqueId);
+		assertThat(copy.getDynamicDescendantFilter().test(newUniqueId, 0)).isTrue();
+		assertThat(copy.getDynamicDescendantFilter().test(newUniqueId, 42)).isTrue();
+		assertThat(copy.getDynamicDescendantFilter().test(originalUniqueId, 1)).isFalse();
+	}
+
 	/**
 	 * @since 5.3
 	 */
diff --git a/jupiter-tests/src/test/java/org/junit/jupiter/engine/descriptor/TestTemplateTestDescriptorTests.java b/jupiter-tests/src/test/java/org/junit/jupiter/engine/descriptor/TestTemplateTestDescriptorTests.java
index c0dab4d6a..59a5ec415 100644
--- a/jupiter-tests/src/test/java/org/junit/jupiter/engine/descriptor/TestTemplateTestDescriptorTests.java
+++ b/jupiter-tests/src/test/java/org/junit/jupiter/engine/descriptor/TestTemplateTestDescriptorTests.java
@@ -18,6 +18,7 @@ import static org.mockito.Mockito.when;
 import java.util.List;
 import java.util.Set;
 
+import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.DisplayNameGenerator;
 import org.junit.jupiter.api.Tag;
 import org.junit.jupiter.api.Test;
@@ -33,20 +34,22 @@ import org.junit.platform.engine.support.descriptor.AbstractTestDescriptor;
  * @since 5.0
  */
 class TestTemplateTestDescriptorTests {
+
 	private JupiterConfiguration jupiterConfiguration = mock();
 
+	@BeforeEach
+	void prepareJupiterConfiguration() {
+		when(jupiterConfiguration.getDefaultDisplayNameGenerator()).thenReturn(new DisplayNameGenerator.Standard());
+	}
+
 	@Test
 	void inheritsTagsFromParent() throws Exception {
-		UniqueId rootUniqueId = UniqueId.root("segment", "template");
-		UniqueId parentUniqueId = rootUniqueId.append("class", "myClass");
-		AbstractTestDescriptor parent = containerTestDescriptorWithTags(parentUniqueId,
-			singleton(TestTag.create("foo")));
-
-		when(jupiterConfiguration.getDefaultDisplayNameGenerator()).thenReturn(new DisplayNameGenerator.Standard());
+		var rootUniqueId = UniqueId.root("segment", "template");
+		var parentUniqueId = rootUniqueId.append("class", "myClass");
+		var parent = containerTestDescriptorWithTags(parentUniqueId, singleton(TestTag.create("foo")));
 
-		TestTemplateTestDescriptor testDescriptor = new TestTemplateTestDescriptor(
-			parentUniqueId.append("tmp", "testTemplate()"), MyTestCase.class,
-			MyTestCase.class.getDeclaredMethod("testTemplate"), List::of, jupiterConfiguration);
+		var testDescriptor = new TestTemplateTestDescriptor(parentUniqueId.append("tmp", "testTemplate()"),
+			MyTestCase.class, MyTestCase.class.getDeclaredMethod("testTemplate"), List::of, jupiterConfiguration);
 		parent.addChild(testDescriptor);
 
 		assertThat(testDescriptor.getTags()).containsExactlyInAnyOrder(TestTag.create("foo"), TestTag.create("bar"),
@@ -55,16 +58,14 @@ class TestTemplateTestDescriptorTests {
 
 	@Test
 	void shouldUseCustomDisplayNameGeneratorIfPresentFromConfiguration() throws Exception {
-		UniqueId rootUniqueId = UniqueId.root("segment", "template");
-		UniqueId parentUniqueId = rootUniqueId.append("class", "myClass");
-		AbstractTestDescriptor parent = containerTestDescriptorWithTags(parentUniqueId,
-			singleton(TestTag.create("foo")));
+		var rootUniqueId = UniqueId.root("segment", "template");
+		var parentUniqueId = rootUniqueId.append("class", "myClass");
+		var parent = containerTestDescriptorWithTags(parentUniqueId, singleton(TestTag.create("foo")));
 
 		when(jupiterConfiguration.getDefaultDisplayNameGenerator()).thenReturn(new CustomDisplayNameGenerator());
 
-		TestTemplateTestDescriptor testDescriptor = new TestTemplateTestDescriptor(
-			parentUniqueId.append("tmp", "testTemplate()"), MyTestCase.class,
-			MyTestCase.class.getDeclaredMethod("testTemplate"), List::of, jupiterConfiguration);
+		var testDescriptor = new TestTemplateTestDescriptor(parentUniqueId.append("tmp", "testTemplate()"),
+			MyTestCase.class, MyTestCase.class.getDeclaredMethod("testTemplate"), List::of, jupiterConfiguration);
 		parent.addChild(testDescriptor);
 
 		assertThat(testDescriptor.getDisplayName()).isEqualTo("method-display-name");
@@ -72,21 +73,39 @@ class TestTemplateTestDescriptorTests {
 
 	@Test
 	void shouldUseStandardDisplayNameGeneratorIfConfigurationNotPresent() throws Exception {
-		UniqueId rootUniqueId = UniqueId.root("segment", "template");
-		UniqueId parentUniqueId = rootUniqueId.append("class", "myClass");
-		AbstractTestDescriptor parent = containerTestDescriptorWithTags(parentUniqueId,
-			singleton(TestTag.create("foo")));
-
-		when(jupiterConfiguration.getDefaultDisplayNameGenerator()).thenReturn(new DisplayNameGenerator.Standard());
+		var rootUniqueId = UniqueId.root("segment", "template");
+		var parentUniqueId = rootUniqueId.append("class", "myClass");
+		var parent = containerTestDescriptorWithTags(parentUniqueId, singleton(TestTag.create("foo")));
 
-		TestTemplateTestDescriptor testDescriptor = new TestTemplateTestDescriptor(
-			parentUniqueId.append("tmp", "testTemplate()"), MyTestCase.class,
-			MyTestCase.class.getDeclaredMethod("testTemplate"), List::of, jupiterConfiguration);
+		var testDescriptor = new TestTemplateTestDescriptor(parentUniqueId.append("tmp", "testTemplate()"),
+			MyTestCase.class, MyTestCase.class.getDeclaredMethod("testTemplate"), List::of, jupiterConfiguration);
 		parent.addChild(testDescriptor);
 
 		assertThat(testDescriptor.getDisplayName()).isEqualTo("testTemplate()");
 	}
 
+	@Test
+	void copyIncludesTransformedDynamicDescendantFilter() throws Exception {
+		var rootUniqueId = UniqueId.root("segment", "template");
+		var parentUniqueId = rootUniqueId.append("class", "myClass");
+		var originalUniqueId = parentUniqueId.append("old", "testTemplate()");
+
+		var original = new TestTemplateTestDescriptor(originalUniqueId, MyTestCase.class,
+			MyTestCase.class.getDeclaredMethod("testTemplate"), List::of, jupiterConfiguration);
+
+		original.getDynamicDescendantFilter().allowUniqueIdPrefix(originalUniqueId.append("foo", "bar"));
+		original.getDynamicDescendantFilter().allowIndex(42);
+
+		var newUniqueId = parentUniqueId.append("new", "testTemplate()");
+
+		var copy = original.withUniqueId(new UniqueIdPrefixTransformer(originalUniqueId, newUniqueId));
+
+		assertThat(copy.getUniqueId()).isEqualTo(newUniqueId);
+		assertThat(copy.getDynamicDescendantFilter().test(newUniqueId, 0)).isTrue();
+		assertThat(copy.getDynamicDescendantFilter().test(newUniqueId, 42)).isTrue();
+		assertThat(copy.getDynamicDescendantFilter().test(originalUniqueId, 1)).isFalse();
+	}
+
 	private AbstractTestDescriptor containerTestDescriptorWithTags(UniqueId uniqueId, Set<TestTag> tags) {
 		return new AbstractTestDescriptor(uniqueId, "testDescriptor with tags") {
 
diff --git a/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/DiscoverySelectorResolverTests.java b/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/DiscoverySelectorResolverTests.java
index 6c74b09db..8af8e24cb 100644
--- a/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/DiscoverySelectorResolverTests.java
+++ b/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/DiscoverySelectorResolverTests.java
@@ -17,12 +17,13 @@ import static org.junit.jupiter.api.Assertions.assertSame;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 import static org.junit.jupiter.engine.descriptor.TestFactoryTestDescriptor.DYNAMIC_CONTAINER_SEGMENT_TYPE;
 import static org.junit.jupiter.engine.descriptor.TestFactoryTestDescriptor.DYNAMIC_TEST_SEGMENT_TYPE;
+import static org.junit.jupiter.engine.discovery.JupiterUniqueIdBuilder.appendContainerTemplateInvocationSegment;
 import static org.junit.jupiter.engine.discovery.JupiterUniqueIdBuilder.engineId;
 import static org.junit.jupiter.engine.discovery.JupiterUniqueIdBuilder.uniqueIdForClass;
 import static org.junit.jupiter.engine.discovery.JupiterUniqueIdBuilder.uniqueIdForMethod;
+import static org.junit.jupiter.engine.discovery.JupiterUniqueIdBuilder.uniqueIdForStaticClass;
 import static org.junit.jupiter.engine.discovery.JupiterUniqueIdBuilder.uniqueIdForTestFactoryMethod;
 import static org.junit.jupiter.engine.discovery.JupiterUniqueIdBuilder.uniqueIdForTestTemplateMethod;
-import static org.junit.jupiter.engine.discovery.JupiterUniqueIdBuilder.uniqueIdForTopLevelClass;
 import static org.junit.platform.commons.util.CollectionUtils.getOnlyElement;
 import static org.junit.platform.engine.SelectorResolutionResult.Status.FAILED;
 import static org.junit.platform.engine.SelectorResolutionResult.Status.RESOLVED;
@@ -53,6 +54,7 @@ import java.util.function.Predicate;
 import java.util.stream.Stream;
 
 import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.ContainerTemplate;
 import org.junit.jupiter.api.DisplayNameGenerator;
 import org.junit.jupiter.api.DynamicTest;
 import org.junit.jupiter.api.Nested;
@@ -192,6 +194,49 @@ class DiscoverySelectorResolverTests {
 		assertThat(uniqueIds).contains(uniqueIdForMethod(OtherTestClass.NestedTestClass.class, "test6()"));
 	}
 
+	@Test
+	void classResolutionOfContainerTemplate() {
+		var selector = selectClass(ContainerTemplateTestCase.class);
+
+		resolve(request().selectors(selector));
+
+		assertThat(engineDescriptor.getChildren()).hasSize(1);
+
+		TestDescriptor containerTemplateDescriptor = getOnlyElement(engineDescriptor.getChildren());
+		assertThat(containerTemplateDescriptor.mayRegisterTests()).isFalse();
+		assertThat(containerTemplateDescriptor.getDescendants()).hasSize(1);
+
+		var containerTemplateSegment = containerTemplateDescriptor.getUniqueId().getLastSegment();
+		assertThat(containerTemplateSegment.getType()).isEqualTo("container-template");
+		assertThat(containerTemplateSegment.getValue()).isEqualTo(ContainerTemplateTestCase.class.getName());
+
+		containerTemplateDescriptor.prune();
+		assertThat(containerTemplateDescriptor.mayRegisterTests()).isTrue();
+		assertThat(containerTemplateDescriptor.getDescendants()).isEmpty();
+	}
+
+	@Test
+	void uniqueIdResolutionOfContainerTemplateInvocation() {
+		var selector = selectUniqueId(
+			appendContainerTemplateInvocationSegment(uniqueIdForClass(ContainerTemplateTestCase.class), 1));
+
+		resolve(request().selectors(selector));
+
+		assertThat(engineDescriptor.getChildren()).hasSize(1);
+
+		TestDescriptor containerTemplateDescriptor = getOnlyElement(engineDescriptor.getChildren());
+
+		containerTemplateDescriptor.prune();
+		assertThat(engineDescriptor.getChildren()).hasSize(1);
+		assertThat(containerTemplateDescriptor.mayRegisterTests()).isTrue();
+		assertThat(containerTemplateDescriptor.getDescendants()).isEmpty();
+
+		containerTemplateDescriptor.prune();
+		assertThat(engineDescriptor.getChildren()).hasSize(1);
+		assertThat(containerTemplateDescriptor.mayRegisterTests()).isTrue();
+		assertThat(containerTemplateDescriptor.getDescendants()).isEmpty();
+	}
+
 	@Test
 	void methodResolution() throws NoSuchMethodException {
 		Method test1 = MyTestClass.class.getDeclaredMethod("test1");
@@ -502,8 +547,8 @@ class DiscoverySelectorResolverTests {
 			resolve(request().selectors(selectors));
 
 			assertThat(uniqueIds()) //
-					.contains(uniqueIdForTopLevelClass("com.example.project.FirstTest")) //
-					.contains(uniqueIdForTopLevelClass("com.example.project.SecondTest"));
+					.contains(uniqueIdForStaticClass("com.example.project.FirstTest")) //
+					.contains(uniqueIdForStaticClass("com.example.project.SecondTest"));
 		}
 		finally {
 			Thread.currentThread().setContextClassLoader(originalClassLoader);
@@ -899,3 +944,10 @@ class OtherClass {
 	void test() {
 	}
 }
+
+@ContainerTemplate
+class ContainerTemplateTestCase {
+	@Test
+	void test() {
+	}
+}
diff --git a/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/OrderedClassTests.java b/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/OrderedClassTests.java
index ff8560830..42af0d90d 100644
--- a/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/OrderedClassTests.java
+++ b/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/OrderedClassTests.java
@@ -20,16 +20,22 @@ import java.util.Collections;
 import java.util.List;
 import java.util.logging.Level;
 import java.util.logging.LogRecord;
+import java.util.stream.Stream;
 
 import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.ClassOrderer;
+import org.junit.jupiter.api.ContainerTemplate;
 import org.junit.jupiter.api.DisplayName;
 import org.junit.jupiter.api.Nested;
 import org.junit.jupiter.api.Order;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.TestClassOrder;
 import org.junit.jupiter.api.TestInfo;
+import org.junit.jupiter.api.extension.ContainerTemplateInvocationContext;
+import org.junit.jupiter.api.extension.ContainerTemplateInvocationContextProvider;
+import org.junit.jupiter.api.extension.ExtendWith;
+import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.api.fixtures.TrackLogRecords;
 import org.junit.platform.commons.logging.LogRecordListener;
 import org.junit.platform.engine.DiscoverySelector;
@@ -128,6 +134,42 @@ class OrderedClassTests {
 				.assertStatistics(stats -> stats.succeeded(callSequence.size()));
 	}
 
+	@Test
+	void containerTemplateWithLocalConfig() {
+		var containerTemplate = ContainerTemplateWithLocalConfigTestCase.class;
+		var inner0 = ContainerTemplateWithLocalConfigTestCase.Inner0.class;
+		var inner1 = ContainerTemplateWithLocalConfigTestCase.Inner1.class;
+		var inner1Inner1 = ContainerTemplateWithLocalConfigTestCase.Inner1.Inner1Inner1.class;
+		var inner1Inner0 = ContainerTemplateWithLocalConfigTestCase.Inner1.Inner1Inner0.class;
+
+		executeTests(ClassOrderer.Random.class, selectClass(containerTemplate))//
+				.assertStatistics(stats -> stats.succeeded(callSequence.size()));
+
+		var inner1InvocationCallSequence = Stream.of(inner1, inner1Inner1, inner1Inner0, inner1Inner0).toList();
+		var inner1CallSequence = twice(inner1InvocationCallSequence).toList();
+		var outerCallSequence = Stream.concat(Stream.of(containerTemplate),
+			Stream.concat(inner1CallSequence.stream(), Stream.of(inner0))).toList();
+		var expectedCallSequence = twice(outerCallSequence).map(Class::getSimpleName).toList();
+
+		assertThat(callSequence).containsExactlyElementsOf(expectedCallSequence);
+	}
+
+	private static <T> Stream<T> twice(List<T> values) {
+		return Stream.concat(values.stream(), values.stream());
+	}
+
+	@Test
+	void containerTemplateWithGlobalConfig() {
+		var containerTemplate = ContainerTemplateWithLocalConfigTestCase.class;
+		var otherClass = A_TestCase.class;
+
+		executeTests(ClassOrderer.OrderAnnotation.class, selectClass(otherClass), selectClass(containerTemplate))//
+				.assertStatistics(stats -> stats.succeeded(callSequence.size()));
+
+		assertThat(callSequence)//
+				.containsSubsequence(containerTemplate.getSimpleName(), otherClass.getSimpleName());
+	}
+
 	private Events executeTests(Class<? extends ClassOrderer> classOrderer) {
 		return executeTests(classOrderer, selectClass(A_TestCase.class), selectClass(B_TestCase.class),
 			selectClass(C_TestCase.class));
@@ -266,4 +308,73 @@ class OrderedClassTests {
 		}
 	}
 
+	@SuppressWarnings("JUnitMalformedDeclaration")
+	@Order(1)
+	@TestClassOrder(ClassOrderer.OrderAnnotation.class)
+	@ContainerTemplate
+	@ExtendWith(ContainerTemplateWithLocalConfigTestCase.Twice.class)
+	static class ContainerTemplateWithLocalConfigTestCase {
+
+		@Test
+		void test() {
+			callSequence.add(ContainerTemplateWithLocalConfigTestCase.class.getSimpleName());
+		}
+
+		@Nested
+		@Order(1)
+		class Inner0 {
+			@Test
+			void test() {
+				callSequence.add(getClass().getSimpleName());
+			}
+		}
+
+		@Nested
+		@ContainerTemplate
+		@Order(0)
+		class Inner1 {
+
+			@Test
+			void test() {
+				callSequence.add(getClass().getSimpleName());
+			}
+
+			@Nested
+			@ContainerTemplate
+			@Order(2)
+			class Inner1Inner0 {
+				@Test
+				void test() {
+					callSequence.add(getClass().getSimpleName());
+				}
+			}
+
+			@Nested
+			@Order(1)
+			class Inner1Inner1 {
+				@Test
+				void test() {
+					callSequence.add(getClass().getSimpleName());
+				}
+			}
+		}
+
+		private static class Twice implements ContainerTemplateInvocationContextProvider {
+
+			@Override
+			public boolean supportsContainerTemplate(ExtensionContext context) {
+				return true;
+			}
+
+			@Override
+			public Stream<ContainerTemplateInvocationContext> provideContainerTemplateInvocationContexts(
+					ExtensionContext context) {
+				return Stream.of(new Ctx(), new Ctx());
+			}
+
+			private record Ctx() implements ContainerTemplateInvocationContext {
+			}
+		}
+	}
+
 }
diff --git a/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/OrderedMethodTests.java b/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/OrderedMethodTests.java
index 0e245db1a..3d555d44f 100644
--- a/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/OrderedMethodTests.java
+++ b/jupiter-tests/src/test/java/org/junit/jupiter/engine/extension/OrderedMethodTests.java
@@ -52,6 +52,8 @@ import org.junit.jupiter.api.TestMethodOrder;
 import org.junit.jupiter.api.TestReporter;
 import org.junit.jupiter.api.fixtures.TrackLogRecords;
 import org.junit.jupiter.engine.JupiterTestEngine;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.ValueSource;
 import org.junit.platform.commons.logging.LogRecordListener;
 import org.junit.platform.commons.util.ClassUtils;
 import org.junit.platform.testkit.engine.EngineTestKit;
@@ -173,9 +175,10 @@ class OrderedMethodTests {
 		assertThat(threadNames).hasSize(1);
 	}
 
-	@Test
-	void defaultOrderer() {
-		var tests = executeTestsInParallel(WithoutTestMethodOrderTestCase.class, OrderAnnotation.class);
+	@ParameterizedTest
+	@ValueSource(classes = { WithoutTestMethodOrderTestCase.class, ContainerTemplateTestCase.class })
+	void defaultOrderer(Class<?> testClass) {
+		var tests = executeTestsInParallel(testClass, OrderAnnotation.class);
 
 		tests.assertStatistics(stats -> stats.succeeded(callSequence.size()));
 
@@ -845,4 +848,7 @@ class OrderedMethodTests {
 
 	}
 
+	static class ContainerTemplateTestCase extends WithoutTestMethodOrderTestCase {
+	}
+
 }
diff --git a/platform-tooling-support-tests/projects/jupiter-starter/src/test/java/com/example/project/CalculatorContainerTemplateTests.java b/platform-tooling-support-tests/projects/jupiter-starter/src/test/java/com/example/project/CalculatorContainerTemplateTests.java
new file mode 100644
index 000000000..00b58cce6
--- /dev/null
+++ b/platform-tooling-support-tests/projects/jupiter-starter/src/test/java/com/example/project/CalculatorContainerTemplateTests.java
@@ -0,0 +1,59 @@
+/*
+ * Copyright 2015-2025 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package com.example.project;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+
+import java.util.stream.Stream;
+
+import org.junit.jupiter.api.ContainerTemplate;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ContainerTemplateInvocationContext;
+import org.junit.jupiter.api.extension.ContainerTemplateInvocationContextProvider;
+import org.junit.jupiter.api.extension.ExtendWith;
+import org.junit.jupiter.api.extension.ExtensionContext;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.ValueSource;
+
+@ContainerTemplate
+@ExtendWith(CalculatorContainerTemplateTests.Twice.class)
+class CalculatorContainerTemplateTests {
+
+	@Test
+	void regularTest() {
+		Calculator calculator = new Calculator();
+		assertEquals(2, calculator.add(1, 1), "1 + 1 should equal 2");
+	}
+
+	@ParameterizedTest
+	@ValueSource(ints = { 1, 2 })
+	void parameterizedTest(int i) {
+		Calculator calculator = new Calculator();
+		assertEquals(i, calculator.add(i, 0));
+	}
+
+	static class Twice implements ContainerTemplateInvocationContextProvider {
+
+		@Override
+		public boolean supportsContainerTemplate(ExtensionContext context) {
+			return true;
+		}
+
+		@Override
+		public Stream<ContainerTemplateInvocationContext> provideContainerTemplateInvocationContexts(
+				ExtensionContext context) {
+			return Stream.of(new Ctx(), new Ctx());
+		}
+
+		static class Ctx implements ContainerTemplateInvocationContext {
+		}
+	}
+}
diff --git a/platform-tooling-support-tests/projects/jupiter-starter/src/test/resources/junit-platform.properties b/platform-tooling-support-tests/projects/jupiter-starter/src/test/resources/junit-platform.properties
new file mode 100644
index 000000000..daf7418ff
--- /dev/null
+++ b/platform-tooling-support-tests/projects/jupiter-starter/src/test/resources/junit-platform.properties
@@ -0,0 +1,2 @@
+junit.jupiter.testclass.order.default = \
+  org.junit.jupiter.api.ClassOrderer$ClassName
diff --git a/platform-tooling-support-tests/src/test/java/platform/tooling/support/tests/AntStarterTests.java b/platform-tooling-support-tests/src/test/java/platform/tooling/support/tests/AntStarterTests.java
index 171548801..084cdcb89 100644
--- a/platform-tooling-support-tests/src/test/java/platform/tooling/support/tests/AntStarterTests.java
+++ b/platform-tooling-support-tests/src/test/java/platform/tooling/support/tests/AntStarterTests.java
@@ -51,13 +51,15 @@ class AntStarterTests {
 		assertLinesMatch(List.of(">> HEAD >>", //
 			"test.junit.launcher:", //
 			">>>>", //
+			"\\[junitlauncher\\] Tests run: 6, Failures: 0, Aborted: 0, Skipped: 0, Time elapsed: .+ sec", //
+			"\\[junitlauncher\\] Running com.example.project.CalculatorTests", //
 			"\\[junitlauncher\\] Tests run: 5, Failures: 0, Aborted: 0, Skipped: 0, Time elapsed: .+ sec", //
 			">>>>", //
 			"test.console.launcher:", //
 			">>>>", //
 			"     \\[java\\] Test run finished after [\\d]+ ms", //
 			">>>>", //
-			"     \\[java\\] \\[         5 tests successful      \\]", //
+			"     \\[java\\] \\[        11 tests successful      \\]", //
 			"     \\[java\\] \\[         0 tests failed          \\]", //
 			">> TAIL >>"), //
 			result.stdOutLines());
diff --git a/platform-tooling-support-tests/src/test/java/platform/tooling/support/tests/GradleStarterTests.java b/platform-tooling-support-tests/src/test/java/platform/tooling/support/tests/GradleStarterTests.java
index b25ca6589..07756177e 100644
--- a/platform-tooling-support-tests/src/test/java/platform/tooling/support/tests/GradleStarterTests.java
+++ b/platform-tooling-support-tests/src/test/java/platform/tooling/support/tests/GradleStarterTests.java
@@ -21,9 +21,11 @@ import java.nio.file.Path;
 import de.skuzzle.test.snapshots.Snapshot;
 import de.skuzzle.test.snapshots.junit5.EnableSnapshotTests;
 
+import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.io.TempDir;
 import org.junit.platform.tests.process.OutputFiles;
+import org.junit.platform.tests.process.ProcessResult;
 import org.opentest4j.TestAbortedException;
 
 import platform.tooling.support.Helper;
@@ -36,23 +38,71 @@ import platform.tooling.support.ProcessStarters;
 @EnableSnapshotTests
 class GradleStarterTests {
 
+	@TempDir
+	Path workspace;
+
+	@BeforeEach
+	void prepareWorkspace() throws Exception {
+		copyToWorkspace(Projects.JUPITER_STARTER, workspace);
+	}
+
 	@Test
-	void gradle_wrapper(@TempDir Path workspace, @FilePrefix("gradle") OutputFiles outputFiles, Snapshot snapshot)
-			throws Exception {
+	void buildJupiterStarterProject(@FilePrefix("gradle") OutputFiles outputFiles, Snapshot snapshot) throws Exception {
+
+		var result = runGradle(outputFiles, "build");
+
+		assertThat(result.stdOut()) //
+				.contains( //
+					"CalculatorContainerTemplateTests > [1] > regularTest() PASSED", //
+					"CalculatorContainerTemplateTests > [2] > regularTest() PASSED", //
+					"CalculatorContainerTemplateTests > [1] > parameterizedTest(int)", //
+					"CalculatorContainerTemplateTests > [2] > parameterizedTest(int)", //
+					"Using Java version: 1.8", //
+					"CalculatorTests > 1 + 1 = 2 PASSED", //
+					"CalculatorTests > add(int, int, int) > 0 + 1 = 1 PASSED", //
+					"CalculatorTests > add(int, int, int) > 1 + 2 = 3 PASSED", //
+					"CalculatorTests > add(int, int, int) > 49 + 51 = 100 PASSED", //
+					"CalculatorTests > add(int, int, int) > 1 + 100 = 101 PASSED" //
+				);
 
+		var testResultsDir = workspace.resolve("build/test-results/test");
+		verifyContainsExpectedStartedOpenTestReport(testResultsDir, snapshot);
+	}
+
+	@Test
+	void runOnlyOneMethodInContainerTemplate(@FilePrefix("gradle") OutputFiles outputFiles) throws Exception {
+
+		var result = runGradle(outputFiles, "test", "--tests", "CalculatorContainer*.regular*");
+
+		assertThat(result.stdOut()) //
+				.contains( //
+					"CalculatorContainerTemplateTests > [1] > regularTest() PASSED", //
+					"CalculatorContainerTemplateTests > [2] > regularTest() PASSED" //
+				) //
+				.doesNotContain("parameterizedTest(int)", "CalculatorTests");
+
+		result = runGradle(outputFiles, "test", "--tests", "*ContainerTemplateTests.parameterized*");
+
+		assertThat(result.stdOut()) //
+				.contains( //
+					"CalculatorContainerTemplateTests > [1] > parameterizedTest(int)", //
+					"CalculatorContainerTemplateTests > [2] > parameterizedTest(int)" //
+				) //
+				.doesNotContain("regularTest()", "CalculatorTests");
+	}
+
+	private ProcessResult runGradle(OutputFiles outputFiles, String... extraArgs) throws InterruptedException {
 		var result = ProcessStarters.gradlew() //
-				.workingDir(copyToWorkspace(Projects.JUPITER_STARTER, workspace)) //
+				.workingDir(workspace) //
 				.addArguments("-Dmaven.repo=" + MavenRepo.dir()) //
-				.addArguments("build", "--no-daemon", "--stacktrace", "--no-build-cache", "--warning-mode=fail") //
-				.putEnvironment("JDK8", Helper.getJavaHome("8").orElseThrow(TestAbortedException::new).toString()) //
+				.addArguments("--stacktrace", "--no-build-cache", "--warning-mode=fail") //
+				.addArguments(extraArgs).putEnvironment("JDK8",
+					Helper.getJavaHome("8").orElseThrow(TestAbortedException::new).toString()) //
 				.redirectOutput(outputFiles) //
 				.startAndWait();
 
 		assertEquals(0, result.exitCode());
 		assertTrue(result.stdOut().lines().anyMatch(line -> line.contains("BUILD SUCCESSFUL")));
-		assertThat(result.stdOut()).contains("Using Java version: 1.8");
-
-		var testResultsDir = workspace.resolve("build/test-results/test");
-		verifyContainsExpectedStartedOpenTestReport(testResultsDir, snapshot);
+		return result;
 	}
 }
diff --git a/platform-tooling-support-tests/src/test/java/platform/tooling/support/tests/MavenStarterTests.java b/platform-tooling-support-tests/src/test/java/platform/tooling/support/tests/MavenStarterTests.java
index 11ef756bd..cece033b4 100644
--- a/platform-tooling-support-tests/src/test/java/platform/tooling/support/tests/MavenStarterTests.java
+++ b/platform-tooling-support-tests/src/test/java/platform/tooling/support/tests/MavenStarterTests.java
@@ -12,7 +12,6 @@ package platform.tooling.support.tests;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.jupiter.api.Assertions.assertEquals;
-import static org.junit.jupiter.api.Assertions.assertTrue;
 import static platform.tooling.support.tests.Projects.copyToWorkspace;
 import static platform.tooling.support.tests.XmlAssertions.verifyContainsExpectedStartedOpenTestReport;
 
@@ -21,9 +20,11 @@ import java.nio.file.Path;
 import de.skuzzle.test.snapshots.Snapshot;
 import de.skuzzle.test.snapshots.junit5.EnableSnapshotTests;
 
+import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.io.TempDir;
 import org.junit.platform.tests.process.OutputFiles;
+import org.junit.platform.tests.process.ProcessResult;
 import org.opentest4j.TestAbortedException;
 
 import platform.tooling.support.Helper;
@@ -42,25 +43,54 @@ class MavenStarterTests {
 	@ManagedResource
 	MavenRepoProxy mavenRepoProxy;
 
+	@TempDir
+	Path workspace;
+
+	@BeforeEach
+	void prepareWorkspace() throws Exception {
+		copyToWorkspace(Projects.JUPITER_STARTER, workspace);
+	}
+
 	@Test
-	void verifyJupiterStarterProject(@TempDir Path workspace, @FilePrefix("maven") OutputFiles outputFiles,
-			Snapshot snapshot) throws Exception {
+	void verifyJupiterStarterProject(@FilePrefix("maven") OutputFiles outputFiles, Snapshot snapshot) throws Exception {
+
+		var result = runMaven(outputFiles, "verify");
+
+		assertThat(result.stdOutLines()).contains("[INFO] Tests run: 11, Failures: 0, Errors: 0, Skipped: 0");
+		assertThat(result.stdOut()).contains("Using Java version: 1.8");
 
+		var testResultsDir = workspace.resolve("target/surefire-reports");
+		verifyContainsExpectedStartedOpenTestReport(testResultsDir, snapshot);
+	}
+
+	@Test
+	void runOnlyOneMethodInContainerTemplate(@FilePrefix("maven") OutputFiles outputFiles) throws Exception {
+
+		var result = runMaven(outputFiles, "test", "-Dtest=CalculatorContainerTemplateTests#regularTest");
+
+		assertThat(result.stdOutLines()) //
+				.doesNotContain("CalculatorTests") //
+				.contains("[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0");
+
+		result = runMaven(outputFiles, "test", "-Dtest=CalculatorContainerTemplateTests#parameterizedTest");
+
+		assertThat(result.stdOutLines()) //
+				.doesNotContain("CalculatorTests") //
+				.contains("[INFO] Tests run: 4, Failures: 0, Errors: 0, Skipped: 0");
+	}
+
+	private ProcessResult runMaven(OutputFiles outputFiles, String... extraArgs) throws InterruptedException {
 		var result = ProcessStarters.maven(Helper.getJavaHome("8").orElseThrow(TestAbortedException::new)) //
-				.workingDir(copyToWorkspace(Projects.JUPITER_STARTER, workspace)) //
+				.workingDir(workspace) //
 				.addArguments(localMavenRepo.toCliArgument(), "-Dmaven.repo=" + MavenRepo.dir()) //
 				.addArguments("-Dsnapshot.repo.url=" + mavenRepoProxy.getBaseUri()) //
-				.addArguments("--update-snapshots", "--batch-mode", "verify") //
-				.redirectOutput(outputFiles) //
+				.addArguments("--update-snapshots", "--batch-mode") //
+				.addArguments(extraArgs).redirectOutput(outputFiles) //
 				.startAndWait();
 
 		assertEquals(0, result.exitCode());
 		assertEquals("", result.stdErr());
-		assertTrue(result.stdOutLines().contains("[INFO] BUILD SUCCESS"));
-		assertTrue(result.stdOutLines().contains("[INFO] Tests run: 5, Failures: 0, Errors: 0, Skipped: 0"));
-		assertThat(result.stdOut()).contains("Using Java version: 1.8");
-
-		var testResultsDir = workspace.resolve("target/surefire-reports");
-		verifyContainsExpectedStartedOpenTestReport(testResultsDir, snapshot);
+		assertThat(result.stdOutLines()).contains("[INFO] BUILD SUCCESS");
+		return result;
 	}
 }
diff --git a/platform-tooling-support-tests/src/test/java/platform/tooling/support/tests/UnalignedClasspathTests.java b/platform-tooling-support-tests/src/test/java/platform/tooling/support/tests/UnalignedClasspathTests.java
index 80028afeb..6ce670bc5 100644
--- a/platform-tooling-support-tests/src/test/java/platform/tooling/support/tests/UnalignedClasspathTests.java
+++ b/platform-tooling-support-tests/src/test/java/platform/tooling/support/tests/UnalignedClasspathTests.java
@@ -12,7 +12,6 @@ package platform.tooling.support.tests;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.jupiter.api.Assertions.assertEquals;
-import static org.junit.jupiter.api.Assertions.assertTrue;
 import static org.junit.jupiter.api.parallel.ExecutionMode.SAME_THREAD;
 import static platform.tooling.support.ProcessStarters.currentJdkHome;
 import static platform.tooling.support.tests.Projects.copyToWorkspace;
@@ -60,7 +59,7 @@ class UnalignedClasspathTests {
 
 		assertEquals(1, result.exitCode());
 		assertEquals("", result.stdErr());
-		assertTrue(result.stdOutLines().contains("[INFO] BUILD FAILURE"));
+		assertThat(result.stdOutLines()).contains("[INFO] BUILD FAILURE");
 		assertThat(result.stdOut()) //
 				.contains("The wrapped NoClassDefFoundError is likely caused by the versions of JUnit jars "
 						+ "on the classpath/module path not being properly aligned");
diff --git a/platform-tooling-support-tests/src/test/resources/platform/tooling/support/tests/AntStarterTests_snapshots/open-test-report.xml.snapshot b/platform-tooling-support-tests/src/test/resources/platform/tooling/support/tests/AntStarterTests_snapshots/open-test-report.xml.snapshot
index a947aa10f..7144e4830 100644
--- a/platform-tooling-support-tests/src/test/resources/platform/tooling/support/tests/AntStarterTests_snapshots/open-test-report.xml.snapshot
+++ b/platform-tooling-support-tests/src/test/resources/platform/tooling/support/tests/AntStarterTests_snapshots/open-test-report.xml.snapshot
@@ -21,7 +21,7 @@ test-method: ant_starter
     <java:heapSize max="16642998272"/>
   </infrastructure>
   
-  <e:started id="1" name="JUnit Jupiter" time="2025-02-11T13:40:07.062496112Z">
+  <e:started id="1" name="JUnit Jupiter" time="2025-02-11T15:17:55.722799994Z">
     <metadata>
       <junit:uniqueId>[engine:junit-jupiter]</junit:uniqueId>
       <junit:legacyReportingName>JUnit Jupiter</junit:legacyReportingName>
@@ -29,7 +29,172 @@ test-method: ant_starter
     </metadata>
   </e:started>
   
-  <e:started id="2" name="CalculatorTests" parentId="1" time="2025-02-11T13:40:07.073780457Z">
+  <e:started id="2" name="CalculatorContainerTemplateTests" parentId="1" time="2025-02-11T15:17:55.736290155Z">
+    <metadata>
+      <junit:uniqueId>[engine:junit-jupiter]/[container-template:com.example.project.CalculatorContainerTemplateTests]</junit:uniqueId>
+      <junit:legacyReportingName>com.example.project.CalculatorContainerTemplateTests</junit:legacyReportingName>
+      <junit:type>CONTAINER</junit:type>
+    </metadata>
+    <sources>
+      <java:classSource className="com.example.project.CalculatorContainerTemplateTests"/>
+    </sources>
+  </e:started>
+  
+  <e:started id="3" name="[1]" parentId="2" time="2025-02-11T15:17:55.749858693Z">
+    <metadata>
+      <junit:uniqueId>[engine:junit-jupiter]/[container-template:com.example.project.CalculatorContainerTemplateTests]/[container-template-invocation:#1]</junit:uniqueId>
+      <junit:legacyReportingName>com.example.project.CalculatorContainerTemplateTests[1]</junit:legacyReportingName>
+      <junit:type>CONTAINER</junit:type>
+    </metadata>
+    <sources>
+      <java:classSource className="com.example.project.CalculatorContainerTemplateTests"/>
+    </sources>
+  </e:started>
+  
+  <e:started id="4" name="regularTest()" parentId="3" time="2025-02-11T15:17:55.757293693Z">
+    <metadata>
+      <junit:uniqueId>[engine:junit-jupiter]/[container-template:com.example.project.CalculatorContainerTemplateTests]/[container-template-invocation:#1]/[method:regularTest()]</junit:uniqueId>
+      <junit:legacyReportingName>regularTest()</junit:legacyReportingName>
+      <junit:type>TEST</junit:type>
+    </metadata>
+    <sources>
+      <java:methodSource className="com.example.project.CalculatorContainerTemplateTests" methodName="regularTest" methodParameterTypes=""/>
+    </sources>
+  </e:started>
+  
+  <e:finished id="4" time="2025-02-11T15:17:55.774744441Z">
+    <result status="SUCCESSFUL"/>
+  </e:finished>
+  
+  <e:started id="5" name="parameterizedTest(int)" parentId="3" time="2025-02-11T15:17:55.778266513Z">
+    <metadata>
+      <junit:uniqueId>[engine:junit-jupiter]/[container-template:com.example.project.CalculatorContainerTemplateTests]/[container-template-invocation:#1]/[test-template:parameterizedTest(int)]</junit:uniqueId>
+      <junit:legacyReportingName>parameterizedTest(int)</junit:legacyReportingName>
+      <junit:type>CONTAINER</junit:type>
+    </metadata>
+    <sources>
+      <java:methodSource className="com.example.project.CalculatorContainerTemplateTests" methodName="parameterizedTest" methodParameterTypes="int"/>
+    </sources>
+  </e:started>
+  
+  <e:started id="6" name="[1] 1" parentId="5" time="2025-02-11T15:17:55.799925745Z">
+    <metadata>
+      <junit:uniqueId>[engine:junit-jupiter]/[container-template:com.example.project.CalculatorContainerTemplateTests]/[container-template-invocation:#1]/[test-template:parameterizedTest(int)]/[test-template-invocation:#1]</junit:uniqueId>
+      <junit:legacyReportingName>parameterizedTest(int)[1]</junit:legacyReportingName>
+      <junit:type>TEST</junit:type>
+    </metadata>
+    <sources>
+      <java:methodSource className="com.example.project.CalculatorContainerTemplateTests" methodName="parameterizedTest" methodParameterTypes="int"/>
+    </sources>
+  </e:started>
+  
+  <e:finished id="6" time="2025-02-11T15:17:55.809020901Z">
+    <result status="SUCCESSFUL"/>
+  </e:finished>
+  
+  <e:started id="7" name="[2] 2" parentId="5" time="2025-02-11T15:17:55.810555070Z">
+    <metadata>
+      <junit:uniqueId>[engine:junit-jupiter]/[container-template:com.example.project.CalculatorContainerTemplateTests]/[container-template-invocation:#1]/[test-template:parameterizedTest(int)]/[test-template-invocation:#2]</junit:uniqueId>
+      <junit:legacyReportingName>parameterizedTest(int)[2]</junit:legacyReportingName>
+      <junit:type>TEST</junit:type>
+    </metadata>
+    <sources>
+      <java:methodSource className="com.example.project.CalculatorContainerTemplateTests" methodName="parameterizedTest" methodParameterTypes="int"/>
+    </sources>
+  </e:started>
+  
+  <e:finished id="7" time="2025-02-11T15:17:55.812661726Z">
+    <result status="SUCCESSFUL"/>
+  </e:finished>
+  
+  <e:finished id="5" time="2025-02-11T15:17:55.813359400Z">
+    <result status="SUCCESSFUL"/>
+  </e:finished>
+  
+  <e:finished id="3" time="2025-02-11T15:17:55.813845555Z">
+    <result status="SUCCESSFUL"/>
+  </e:finished>
+  
+  <e:started id="8" name="[2]" parentId="2" time="2025-02-11T15:17:55.814534462Z">
+    <metadata>
+      <junit:uniqueId>[engine:junit-jupiter]/[container-template:com.example.project.CalculatorContainerTemplateTests]/[container-template-invocation:#2]</junit:uniqueId>
+      <junit:legacyReportingName>com.example.project.CalculatorContainerTemplateTests[2]</junit:legacyReportingName>
+      <junit:type>CONTAINER</junit:type>
+    </metadata>
+    <sources>
+      <java:classSource className="com.example.project.CalculatorContainerTemplateTests"/>
+    </sources>
+  </e:started>
+  
+  <e:started id="9" name="regularTest()" parentId="8" time="2025-02-11T15:17:55.815674329Z">
+    <metadata>
+      <junit:uniqueId>[engine:junit-jupiter]/[container-template:com.example.project.CalculatorContainerTemplateTests]/[container-template-invocation:#2]/[method:regularTest()]</junit:uniqueId>
+      <junit:legacyReportingName>regularTest()</junit:legacyReportingName>
+      <junit:type>TEST</junit:type>
+    </metadata>
+    <sources>
+      <java:methodSource className="com.example.project.CalculatorContainerTemplateTests" methodName="regularTest" methodParameterTypes=""/>
+    </sources>
+  </e:started>
+  
+  <e:finished id="9" time="2025-02-11T15:17:55.817132474Z">
+    <result status="SUCCESSFUL"/>
+  </e:finished>
+  
+  <e:started id="10" name="parameterizedTest(int)" parentId="8" time="2025-02-11T15:17:55.817933793Z">
+    <metadata>
+      <junit:uniqueId>[engine:junit-jupiter]/[container-template:com.example.project.CalculatorContainerTemplateTests]/[container-template-invocation:#2]/[test-template:parameterizedTest(int)]</junit:uniqueId>
+      <junit:legacyReportingName>parameterizedTest(int)</junit:legacyReportingName>
+      <junit:type>CONTAINER</junit:type>
+    </metadata>
+    <sources>
+      <java:methodSource className="com.example.project.CalculatorContainerTemplateTests" methodName="parameterizedTest" methodParameterTypes="int"/>
+    </sources>
+  </e:started>
+  
+  <e:started id="11" name="[1] 1" parentId="10" time="2025-02-11T15:17:55.820727974Z">
+    <metadata>
+      <junit:uniqueId>[engine:junit-jupiter]/[container-template:com.example.project.CalculatorContainerTemplateTests]/[container-template-invocation:#2]/[test-template:parameterizedTest(int)]/[test-template-invocation:#1]</junit:uniqueId>
+      <junit:legacyReportingName>parameterizedTest(int)[1]</junit:legacyReportingName>
+      <junit:type>TEST</junit:type>
+    </metadata>
+    <sources>
+      <java:methodSource className="com.example.project.CalculatorContainerTemplateTests" methodName="parameterizedTest" methodParameterTypes="int"/>
+    </sources>
+  </e:started>
+  
+  <e:finished id="11" time="2025-02-11T15:17:55.822693225Z">
+    <result status="SUCCESSFUL"/>
+  </e:finished>
+  
+  <e:started id="12" name="[2] 2" parentId="10" time="2025-02-11T15:17:55.824127846Z">
+    <metadata>
+      <junit:uniqueId>[engine:junit-jupiter]/[container-template:com.example.project.CalculatorContainerTemplateTests]/[container-template-invocation:#2]/[test-template:parameterizedTest(int)]/[test-template-invocation:#2]</junit:uniqueId>
+      <junit:legacyReportingName>parameterizedTest(int)[2]</junit:legacyReportingName>
+      <junit:type>TEST</junit:type>
+    </metadata>
+    <sources>
+      <java:methodSource className="com.example.project.CalculatorContainerTemplateTests" methodName="parameterizedTest" methodParameterTypes="int"/>
+    </sources>
+  </e:started>
+  
+  <e:finished id="12" time="2025-02-11T15:17:55.826439789Z">
+    <result status="SUCCESSFUL"/>
+  </e:finished>
+  
+  <e:finished id="10" time="2025-02-11T15:17:55.827165636Z">
+    <result status="SUCCESSFUL"/>
+  </e:finished>
+  
+  <e:finished id="8" time="2025-02-11T15:17:55.827943911Z">
+    <result status="SUCCESSFUL"/>
+  </e:finished>
+  
+  <e:finished id="2" time="2025-02-11T15:17:55.831425978Z">
+    <result status="SUCCESSFUL"/>
+  </e:finished>
+  
+  <e:started id="13" name="CalculatorTests" parentId="1" time="2025-02-11T15:17:55.834122535Z">
     <metadata>
       <junit:uniqueId>[engine:junit-jupiter]/[class:com.example.project.CalculatorTests]</junit:uniqueId>
       <junit:legacyReportingName>com.example.project.CalculatorTests</junit:legacyReportingName>
@@ -40,7 +205,7 @@ test-method: ant_starter
     </sources>
   </e:started>
   
-  <e:started id="3" name="1 + 1 = 2" parentId="2" time="2025-02-11T13:40:07.085669511Z">
+  <e:started id="14" name="1 + 1 = 2" parentId="13" time="2025-02-11T15:17:55.837715270Z">
     <metadata>
       <junit:uniqueId>[engine:junit-jupiter]/[class:com.example.project.CalculatorTests]/[method:addsTwoNumbers()]</junit:uniqueId>
       <junit:legacyReportingName>addsTwoNumbers()</junit:legacyReportingName>
@@ -51,11 +216,11 @@ test-method: ant_starter
     </sources>
   </e:started>
   
-  <e:finished id="3" time="2025-02-11T13:40:07.097640921Z">
+  <e:finished id="14" time="2025-02-11T15:17:55.839874596Z">
     <result status="SUCCESSFUL"/>
   </e:finished>
   
-  <e:started id="4" name="add(int, int, int)" parentId="2" time="2025-02-11T13:40:07.100627944Z">
+  <e:started id="15" name="add(int, int, int)" parentId="13" time="2025-02-11T15:17:55.840794307Z">
     <metadata>
       <junit:uniqueId>[engine:junit-jupiter]/[class:com.example.project.CalculatorTests]/[test-template:add(int, int, int)]</junit:uniqueId>
       <junit:legacyReportingName>add(int, int, int)</junit:legacyReportingName>
@@ -66,7 +231,7 @@ test-method: ant_starter
     </sources>
   </e:started>
   
-  <e:started id="5" name="0 + 1 = 1" parentId="4" time="2025-02-11T13:40:07.126338320Z">
+  <e:started id="16" name="0 + 1 = 1" parentId="15" time="2025-02-11T15:17:55.854098628Z">
     <metadata>
       <junit:uniqueId>[engine:junit-jupiter]/[class:com.example.project.CalculatorTests]/[test-template:add(int, int, int)]/[test-template-invocation:#1]</junit:uniqueId>
       <junit:legacyReportingName>add(int, int, int)[1]</junit:legacyReportingName>
@@ -77,11 +242,11 @@ test-method: ant_starter
     </sources>
   </e:started>
   
-  <e:finished id="5" time="2025-02-11T13:40:07.136620739Z">
+  <e:finished id="16" time="2025-02-11T15:17:55.868722283Z">
     <result status="SUCCESSFUL"/>
   </e:finished>
   
-  <e:started id="6" name="1 + 2 = 3" parentId="4" time="2025-02-11T13:40:07.138368039Z">
+  <e:started id="17" name="1 + 2 = 3" parentId="15" time="2025-02-11T15:17:55.870101811Z">
     <metadata>
       <junit:uniqueId>[engine:junit-jupiter]/[class:com.example.project.CalculatorTests]/[test-template:add(int, int, int)]/[test-template-invocation:#2]</junit:uniqueId>
       <junit:legacyReportingName>add(int, int, int)[2]</junit:legacyReportingName>
@@ -92,11 +257,11 @@ test-method: ant_starter
     </sources>
   </e:started>
   
-  <e:finished id="6" time="2025-02-11T13:40:07.139838798Z">
+  <e:finished id="17" time="2025-02-11T15:17:55.872144137Z">
     <result status="SUCCESSFUL"/>
   </e:finished>
   
-  <e:started id="7" name="49 + 51 = 100" parentId="4" time="2025-02-11T13:40:07.141924325Z">
+  <e:started id="18" name="49 + 51 = 100" parentId="15" time="2025-02-11T15:17:55.873465124Z">
     <metadata>
       <junit:uniqueId>[engine:junit-jupiter]/[class:com.example.project.CalculatorTests]/[test-template:add(int, int, int)]/[test-template-invocation:#3]</junit:uniqueId>
       <junit:legacyReportingName>add(int, int, int)[3]</junit:legacyReportingName>
@@ -107,11 +272,11 @@ test-method: ant_starter
     </sources>
   </e:started>
   
-  <e:finished id="7" time="2025-02-11T13:40:07.145834226Z">
+  <e:finished id="18" time="2025-02-11T15:17:55.875292845Z">
     <result status="SUCCESSFUL"/>
   </e:finished>
   
-  <e:started id="8" name="1 + 100 = 101" parentId="4" time="2025-02-11T13:40:07.148382474Z">
+  <e:started id="19" name="1 + 100 = 101" parentId="15" time="2025-02-11T15:17:55.876370184Z">
     <metadata>
       <junit:uniqueId>[engine:junit-jupiter]/[class:com.example.project.CalculatorTests]/[test-template:add(int, int, int)]/[test-template-invocation:#4]</junit:uniqueId>
       <junit:legacyReportingName>add(int, int, int)[4]</junit:legacyReportingName>
@@ -122,19 +287,19 @@ test-method: ant_starter
     </sources>
   </e:started>
   
-  <e:finished id="8" time="2025-02-11T13:40:07.150067857Z">
+  <e:finished id="19" time="2025-02-11T15:17:55.878435783Z">
     <result status="SUCCESSFUL"/>
   </e:finished>
   
-  <e:finished id="4" time="2025-02-11T13:40:07.150595540Z">
+  <e:finished id="15" time="2025-02-11T15:17:55.879124410Z">
     <result status="SUCCESSFUL"/>
   </e:finished>
   
-  <e:finished id="2" time="2025-02-11T13:40:07.151726269Z">
+  <e:finished id="13" time="2025-02-11T15:17:55.879657674Z">
     <result status="SUCCESSFUL"/>
   </e:finished>
   
-  <e:finished id="1" time="2025-02-11T13:40:07.168385454Z">
+  <e:finished id="1" time="2025-02-11T15:17:55.904957231Z">
     <result status="SUCCESSFUL"/>
   </e:finished>
   
diff --git a/platform-tooling-support-tests/src/test/resources/platform/tooling/support/tests/GradleStarterTests_snapshots/open-test-report.xml.snapshot b/platform-tooling-support-tests/src/test/resources/platform/tooling/support/tests/GradleStarterTests_snapshots/open-test-report.xml.snapshot
index 3be1b286c..020b5160c 100644
--- a/platform-tooling-support-tests/src/test/resources/platform/tooling/support/tests/GradleStarterTests_snapshots/open-test-report.xml.snapshot
+++ b/platform-tooling-support-tests/src/test/resources/platform/tooling/support/tests/GradleStarterTests_snapshots/open-test-report.xml.snapshot
@@ -2,7 +2,7 @@ dynamic-directory: false
 snapshot-name: open-test-report.xml
 snapshot-number: 0
 test-class: platform.tooling.support.tests.GradleStarterTests
-test-method: gradle_wrapper
+test-method: buildJupiterStarterProject
 
 <?xml version="1.0" encoding="UTF-8"?>
 <e:events xmlns:e="https://schemas.opentest4j.org/reporting/events/0.2.0" xmlns="https://schemas.opentest4j.org/reporting/core/0.2.0"
@@ -21,7 +21,7 @@ test-method: gradle_wrapper
     <java:heapSize max="514850816"/>
   </infrastructure>
   
-  <e:started id="1" name="JUnit Jupiter" time="2025-02-11T13:40:40.710Z">
+  <e:started id="1" name="JUnit Jupiter" time="2025-02-11T15:17:59.959Z">
     <metadata>
       <junit:uniqueId>[engine:junit-jupiter]</junit:uniqueId>
       <junit:legacyReportingName>JUnit Jupiter</junit:legacyReportingName>
@@ -29,7 +29,172 @@ test-method: gradle_wrapper
     </metadata>
   </e:started>
   
-  <e:started id="2" name="CalculatorTests" parentId="1" time="2025-02-11T13:40:40.729Z">
+  <e:started id="2" name="CalculatorContainerTemplateTests" parentId="1" time="2025-02-11T15:17:59.978Z">
+    <metadata>
+      <junit:uniqueId>[engine:junit-jupiter]/[container-template:com.example.project.CalculatorContainerTemplateTests]</junit:uniqueId>
+      <junit:legacyReportingName>com.example.project.CalculatorContainerTemplateTests</junit:legacyReportingName>
+      <junit:type>CONTAINER</junit:type>
+    </metadata>
+    <sources>
+      <java:classSource className="com.example.project.CalculatorContainerTemplateTests"/>
+    </sources>
+  </e:started>
+  
+  <e:started id="3" name="[1]" parentId="2" time="2025-02-11T15:17:59.989Z">
+    <metadata>
+      <junit:uniqueId>[engine:junit-jupiter]/[container-template:com.example.project.CalculatorContainerTemplateTests]/[container-template-invocation:#1]</junit:uniqueId>
+      <junit:legacyReportingName>com.example.project.CalculatorContainerTemplateTests[1]</junit:legacyReportingName>
+      <junit:type>CONTAINER</junit:type>
+    </metadata>
+    <sources>
+      <java:classSource className="com.example.project.CalculatorContainerTemplateTests"/>
+    </sources>
+  </e:started>
+  
+  <e:started id="4" name="regularTest()" parentId="3" time="2025-02-11T15:17:59.996Z">
+    <metadata>
+      <junit:uniqueId>[engine:junit-jupiter]/[container-template:com.example.project.CalculatorContainerTemplateTests]/[container-template-invocation:#1]/[method:regularTest()]</junit:uniqueId>
+      <junit:legacyReportingName>regularTest()</junit:legacyReportingName>
+      <junit:type>TEST</junit:type>
+    </metadata>
+    <sources>
+      <java:methodSource className="com.example.project.CalculatorContainerTemplateTests" methodName="regularTest" methodParameterTypes=""/>
+    </sources>
+  </e:started>
+  
+  <e:finished id="4" time="2025-02-11T15:18:00.011Z">
+    <result status="SUCCESSFUL"/>
+  </e:finished>
+  
+  <e:started id="5" name="parameterizedTest(int)" parentId="3" time="2025-02-11T15:18:00.015Z">
+    <metadata>
+      <junit:uniqueId>[engine:junit-jupiter]/[container-template:com.example.project.CalculatorContainerTemplateTests]/[container-template-invocation:#1]/[test-template:parameterizedTest(int)]</junit:uniqueId>
+      <junit:legacyReportingName>parameterizedTest(int)</junit:legacyReportingName>
+      <junit:type>CONTAINER</junit:type>
+    </metadata>
+    <sources>
+      <java:methodSource className="com.example.project.CalculatorContainerTemplateTests" methodName="parameterizedTest" methodParameterTypes="int"/>
+    </sources>
+  </e:started>
+  
+  <e:started id="6" name="[1] 1" parentId="5" time="2025-02-11T15:18:00.032Z">
+    <metadata>
+      <junit:uniqueId>[engine:junit-jupiter]/[container-template:com.example.project.CalculatorContainerTemplateTests]/[container-template-invocation:#1]/[test-template:parameterizedTest(int)]/[test-template-invocation:#1]</junit:uniqueId>
+      <junit:legacyReportingName>parameterizedTest(int)[1]</junit:legacyReportingName>
+      <junit:type>TEST</junit:type>
+    </metadata>
+    <sources>
+      <java:methodSource className="com.example.project.CalculatorContainerTemplateTests" methodName="parameterizedTest" methodParameterTypes="int"/>
+    </sources>
+  </e:started>
+  
+  <e:finished id="6" time="2025-02-11T15:18:00.038Z">
+    <result status="SUCCESSFUL"/>
+  </e:finished>
+  
+  <e:started id="7" name="[2] 2" parentId="5" time="2025-02-11T15:18:00.040Z">
+    <metadata>
+      <junit:uniqueId>[engine:junit-jupiter]/[container-template:com.example.project.CalculatorContainerTemplateTests]/[container-template-invocation:#1]/[test-template:parameterizedTest(int)]/[test-template-invocation:#2]</junit:uniqueId>
+      <junit:legacyReportingName>parameterizedTest(int)[2]</junit:legacyReportingName>
+      <junit:type>TEST</junit:type>
+    </metadata>
+    <sources>
+      <java:methodSource className="com.example.project.CalculatorContainerTemplateTests" methodName="parameterizedTest" methodParameterTypes="int"/>
+    </sources>
+  </e:started>
+  
+  <e:finished id="7" time="2025-02-11T15:18:00.042Z">
+    <result status="SUCCESSFUL"/>
+  </e:finished>
+  
+  <e:finished id="5" time="2025-02-11T15:18:00.043Z">
+    <result status="SUCCESSFUL"/>
+  </e:finished>
+  
+  <e:finished id="3" time="2025-02-11T15:18:00.043Z">
+    <result status="SUCCESSFUL"/>
+  </e:finished>
+  
+  <e:started id="8" name="[2]" parentId="2" time="2025-02-11T15:18:00.044Z">
+    <metadata>
+      <junit:uniqueId>[engine:junit-jupiter]/[container-template:com.example.project.CalculatorContainerTemplateTests]/[container-template-invocation:#2]</junit:uniqueId>
+      <junit:legacyReportingName>com.example.project.CalculatorContainerTemplateTests[2]</junit:legacyReportingName>
+      <junit:type>CONTAINER</junit:type>
+    </metadata>
+    <sources>
+      <java:classSource className="com.example.project.CalculatorContainerTemplateTests"/>
+    </sources>
+  </e:started>
+  
+  <e:started id="9" name="regularTest()" parentId="8" time="2025-02-11T15:18:00.045Z">
+    <metadata>
+      <junit:uniqueId>[engine:junit-jupiter]/[container-template:com.example.project.CalculatorContainerTemplateTests]/[container-template-invocation:#2]/[method:regularTest()]</junit:uniqueId>
+      <junit:legacyReportingName>regularTest()</junit:legacyReportingName>
+      <junit:type>TEST</junit:type>
+    </metadata>
+    <sources>
+      <java:methodSource className="com.example.project.CalculatorContainerTemplateTests" methodName="regularTest" methodParameterTypes=""/>
+    </sources>
+  </e:started>
+  
+  <e:finished id="9" time="2025-02-11T15:18:00.046Z">
+    <result status="SUCCESSFUL"/>
+  </e:finished>
+  
+  <e:started id="10" name="parameterizedTest(int)" parentId="8" time="2025-02-11T15:18:00.047Z">
+    <metadata>
+      <junit:uniqueId>[engine:junit-jupiter]/[container-template:com.example.project.CalculatorContainerTemplateTests]/[container-template-invocation:#2]/[test-template:parameterizedTest(int)]</junit:uniqueId>
+      <junit:legacyReportingName>parameterizedTest(int)</junit:legacyReportingName>
+      <junit:type>CONTAINER</junit:type>
+    </metadata>
+    <sources>
+      <java:methodSource className="com.example.project.CalculatorContainerTemplateTests" methodName="parameterizedTest" methodParameterTypes="int"/>
+    </sources>
+  </e:started>
+  
+  <e:started id="11" name="[1] 1" parentId="10" time="2025-02-11T15:18:00.049Z">
+    <metadata>
+      <junit:uniqueId>[engine:junit-jupiter]/[container-template:com.example.project.CalculatorContainerTemplateTests]/[container-template-invocation:#2]/[test-template:parameterizedTest(int)]/[test-template-invocation:#1]</junit:uniqueId>
+      <junit:legacyReportingName>parameterizedTest(int)[1]</junit:legacyReportingName>
+      <junit:type>TEST</junit:type>
+    </metadata>
+    <sources>
+      <java:methodSource className="com.example.project.CalculatorContainerTemplateTests" methodName="parameterizedTest" methodParameterTypes="int"/>
+    </sources>
+  </e:started>
+  
+  <e:finished id="11" time="2025-02-11T15:18:00.050Z">
+    <result status="SUCCESSFUL"/>
+  </e:finished>
+  
+  <e:started id="12" name="[2] 2" parentId="10" time="2025-02-11T15:18:00.051Z">
+    <metadata>
+      <junit:uniqueId>[engine:junit-jupiter]/[container-template:com.example.project.CalculatorContainerTemplateTests]/[container-template-invocation:#2]/[test-template:parameterizedTest(int)]/[test-template-invocation:#2]</junit:uniqueId>
+      <junit:legacyReportingName>parameterizedTest(int)[2]</junit:legacyReportingName>
+      <junit:type>TEST</junit:type>
+    </metadata>
+    <sources>
+      <java:methodSource className="com.example.project.CalculatorContainerTemplateTests" methodName="parameterizedTest" methodParameterTypes="int"/>
+    </sources>
+  </e:started>
+  
+  <e:finished id="12" time="2025-02-11T15:18:00.052Z">
+    <result status="SUCCESSFUL"/>
+  </e:finished>
+  
+  <e:finished id="10" time="2025-02-11T15:18:00.053Z">
+    <result status="SUCCESSFUL"/>
+  </e:finished>
+  
+  <e:finished id="8" time="2025-02-11T15:18:00.053Z">
+    <result status="SUCCESSFUL"/>
+  </e:finished>
+  
+  <e:finished id="2" time="2025-02-11T15:18:00.054Z">
+    <result status="SUCCESSFUL"/>
+  </e:finished>
+  
+  <e:started id="13" name="CalculatorTests" parentId="1" time="2025-02-11T15:18:00.055Z">
     <metadata>
       <junit:uniqueId>[engine:junit-jupiter]/[class:com.example.project.CalculatorTests]</junit:uniqueId>
       <junit:legacyReportingName>com.example.project.CalculatorTests</junit:legacyReportingName>
@@ -40,7 +205,7 @@ test-method: gradle_wrapper
     </sources>
   </e:started>
   
-  <e:started id="3" name="1 + 1 = 2" parentId="2" time="2025-02-11T13:40:40.745Z">
+  <e:started id="14" name="1 + 1 = 2" parentId="13" time="2025-02-11T15:18:00.058Z">
     <metadata>
       <junit:uniqueId>[engine:junit-jupiter]/[class:com.example.project.CalculatorTests]/[method:addsTwoNumbers()]</junit:uniqueId>
       <junit:legacyReportingName>addsTwoNumbers()</junit:legacyReportingName>
@@ -51,11 +216,11 @@ test-method: gradle_wrapper
     </sources>
   </e:started>
   
-  <e:finished id="3" time="2025-02-11T13:40:40.755Z">
+  <e:finished id="14" time="2025-02-11T15:18:00.060Z">
     <result status="SUCCESSFUL"/>
   </e:finished>
   
-  <e:started id="4" name="add(int, int, int)" parentId="2" time="2025-02-11T13:40:40.758Z">
+  <e:started id="15" name="add(int, int, int)" parentId="13" time="2025-02-11T15:18:00.060Z">
     <metadata>
       <junit:uniqueId>[engine:junit-jupiter]/[class:com.example.project.CalculatorTests]/[test-template:add(int, int, int)]</junit:uniqueId>
       <junit:legacyReportingName>add(int, int, int)</junit:legacyReportingName>
@@ -66,7 +231,7 @@ test-method: gradle_wrapper
     </sources>
   </e:started>
   
-  <e:started id="5" name="0 + 1 = 1" parentId="4" time="2025-02-11T13:40:40.784Z">
+  <e:started id="16" name="0 + 1 = 1" parentId="15" time="2025-02-11T15:18:00.073Z">
     <metadata>
       <junit:uniqueId>[engine:junit-jupiter]/[class:com.example.project.CalculatorTests]/[test-template:add(int, int, int)]/[test-template-invocation:#1]</junit:uniqueId>
       <junit:legacyReportingName>add(int, int, int)[1]</junit:legacyReportingName>
@@ -77,11 +242,11 @@ test-method: gradle_wrapper
     </sources>
   </e:started>
   
-  <e:finished id="5" time="2025-02-11T13:40:40.794Z">
+  <e:finished id="16" time="2025-02-11T15:18:00.082Z">
     <result status="SUCCESSFUL"/>
   </e:finished>
   
-  <e:started id="6" name="1 + 2 = 3" parentId="4" time="2025-02-11T13:40:40.797Z">
+  <e:started id="17" name="1 + 2 = 3" parentId="15" time="2025-02-11T15:18:00.083Z">
     <metadata>
       <junit:uniqueId>[engine:junit-jupiter]/[class:com.example.project.CalculatorTests]/[test-template:add(int, int, int)]/[test-template-invocation:#2]</junit:uniqueId>
       <junit:legacyReportingName>add(int, int, int)[2]</junit:legacyReportingName>
@@ -92,11 +257,11 @@ test-method: gradle_wrapper
     </sources>
   </e:started>
   
-  <e:finished id="6" time="2025-02-11T13:40:40.798Z">
+  <e:finished id="17" time="2025-02-11T15:18:00.085Z">
     <result status="SUCCESSFUL"/>
   </e:finished>
   
-  <e:started id="7" name="49 + 51 = 100" parentId="4" time="2025-02-11T13:40:40.799Z">
+  <e:started id="18" name="49 + 51 = 100" parentId="15" time="2025-02-11T15:18:00.086Z">
     <metadata>
       <junit:uniqueId>[engine:junit-jupiter]/[class:com.example.project.CalculatorTests]/[test-template:add(int, int, int)]/[test-template-invocation:#3]</junit:uniqueId>
       <junit:legacyReportingName>add(int, int, int)[3]</junit:legacyReportingName>
@@ -107,11 +272,11 @@ test-method: gradle_wrapper
     </sources>
   </e:started>
   
-  <e:finished id="7" time="2025-02-11T13:40:40.800Z">
+  <e:finished id="18" time="2025-02-11T15:18:00.088Z">
     <result status="SUCCESSFUL"/>
   </e:finished>
   
-  <e:started id="8" name="1 + 100 = 101" parentId="4" time="2025-02-11T13:40:40.801Z">
+  <e:started id="19" name="1 + 100 = 101" parentId="15" time="2025-02-11T15:18:00.089Z">
     <metadata>
       <junit:uniqueId>[engine:junit-jupiter]/[class:com.example.project.CalculatorTests]/[test-template:add(int, int, int)]/[test-template-invocation:#4]</junit:uniqueId>
       <junit:legacyReportingName>add(int, int, int)[4]</junit:legacyReportingName>
@@ -122,19 +287,19 @@ test-method: gradle_wrapper
     </sources>
   </e:started>
   
-  <e:finished id="8" time="2025-02-11T13:40:40.802Z">
+  <e:finished id="19" time="2025-02-11T15:18:00.090Z">
     <result status="SUCCESSFUL"/>
   </e:finished>
   
-  <e:finished id="4" time="2025-02-11T13:40:40.803Z">
+  <e:finished id="15" time="2025-02-11T15:18:00.090Z">
     <result status="SUCCESSFUL"/>
   </e:finished>
   
-  <e:finished id="2" time="2025-02-11T13:40:40.804Z">
+  <e:finished id="13" time="2025-02-11T15:18:00.091Z">
     <result status="SUCCESSFUL"/>
   </e:finished>
   
-  <e:finished id="1" time="2025-02-11T13:40:40.804Z">
+  <e:finished id="1" time="2025-02-11T15:18:00.091Z">
     <result status="SUCCESSFUL"/>
   </e:finished>
   
diff --git a/platform-tooling-support-tests/src/test/resources/platform/tooling/support/tests/MavenStarterTests_snapshots/open-test-report.xml.snapshot b/platform-tooling-support-tests/src/test/resources/platform/tooling/support/tests/MavenStarterTests_snapshots/open-test-report.xml.snapshot
index 385bb5aff..4c7776b69 100644
--- a/platform-tooling-support-tests/src/test/resources/platform/tooling/support/tests/MavenStarterTests_snapshots/open-test-report.xml.snapshot
+++ b/platform-tooling-support-tests/src/test/resources/platform/tooling/support/tests/MavenStarterTests_snapshots/open-test-report.xml.snapshot
@@ -21,7 +21,7 @@ test-method: verifyJupiterStarterProject
     <java:heapSize max="14793834496"/>
   </infrastructure>
   
-  <e:started id="1" name="JUnit Jupiter" time="2025-02-11T13:40:25.540Z">
+  <e:started id="1" name="JUnit Jupiter" time="2025-02-11T15:18:00.346Z">
     <metadata>
       <junit:uniqueId>[engine:junit-jupiter]</junit:uniqueId>
       <junit:legacyReportingName>JUnit Jupiter</junit:legacyReportingName>
@@ -29,7 +29,172 @@ test-method: verifyJupiterStarterProject
     </metadata>
   </e:started>
   
-  <e:started id="2" name="CalculatorTests" parentId="1" time="2025-02-11T13:40:25.557Z">
+  <e:started id="2" name="CalculatorContainerTemplateTests" parentId="1" time="2025-02-11T15:18:00.368Z">
+    <metadata>
+      <junit:uniqueId>[engine:junit-jupiter]/[container-template:com.example.project.CalculatorContainerTemplateTests]</junit:uniqueId>
+      <junit:legacyReportingName>com.example.project.CalculatorContainerTemplateTests</junit:legacyReportingName>
+      <junit:type>CONTAINER</junit:type>
+    </metadata>
+    <sources>
+      <java:classSource className="com.example.project.CalculatorContainerTemplateTests"/>
+    </sources>
+  </e:started>
+  
+  <e:started id="3" name="[1]" parentId="2" time="2025-02-11T15:18:00.382Z">
+    <metadata>
+      <junit:uniqueId>[engine:junit-jupiter]/[container-template:com.example.project.CalculatorContainerTemplateTests]/[container-template-invocation:#1]</junit:uniqueId>
+      <junit:legacyReportingName>com.example.project.CalculatorContainerTemplateTests[1]</junit:legacyReportingName>
+      <junit:type>CONTAINER</junit:type>
+    </metadata>
+    <sources>
+      <java:classSource className="com.example.project.CalculatorContainerTemplateTests"/>
+    </sources>
+  </e:started>
+  
+  <e:started id="4" name="regularTest()" parentId="3" time="2025-02-11T15:18:00.388Z">
+    <metadata>
+      <junit:uniqueId>[engine:junit-jupiter]/[container-template:com.example.project.CalculatorContainerTemplateTests]/[container-template-invocation:#1]/[method:regularTest()]</junit:uniqueId>
+      <junit:legacyReportingName>regularTest()</junit:legacyReportingName>
+      <junit:type>TEST</junit:type>
+    </metadata>
+    <sources>
+      <java:methodSource className="com.example.project.CalculatorContainerTemplateTests" methodName="regularTest" methodParameterTypes=""/>
+    </sources>
+  </e:started>
+  
+  <e:finished id="4" time="2025-02-11T15:18:00.405Z">
+    <result status="SUCCESSFUL"/>
+  </e:finished>
+  
+  <e:started id="5" name="parameterizedTest(int)" parentId="3" time="2025-02-11T15:18:00.409Z">
+    <metadata>
+      <junit:uniqueId>[engine:junit-jupiter]/[container-template:com.example.project.CalculatorContainerTemplateTests]/[container-template-invocation:#1]/[test-template:parameterizedTest(int)]</junit:uniqueId>
+      <junit:legacyReportingName>parameterizedTest(int)</junit:legacyReportingName>
+      <junit:type>CONTAINER</junit:type>
+    </metadata>
+    <sources>
+      <java:methodSource className="com.example.project.CalculatorContainerTemplateTests" methodName="parameterizedTest" methodParameterTypes="int"/>
+    </sources>
+  </e:started>
+  
+  <e:started id="6" name="[1] 1" parentId="5" time="2025-02-11T15:18:00.426Z">
+    <metadata>
+      <junit:uniqueId>[engine:junit-jupiter]/[container-template:com.example.project.CalculatorContainerTemplateTests]/[container-template-invocation:#1]/[test-template:parameterizedTest(int)]/[test-template-invocation:#1]</junit:uniqueId>
+      <junit:legacyReportingName>parameterizedTest(int)[1]</junit:legacyReportingName>
+      <junit:type>TEST</junit:type>
+    </metadata>
+    <sources>
+      <java:methodSource className="com.example.project.CalculatorContainerTemplateTests" methodName="parameterizedTest" methodParameterTypes="int"/>
+    </sources>
+  </e:started>
+  
+  <e:finished id="6" time="2025-02-11T15:18:00.431Z">
+    <result status="SUCCESSFUL"/>
+  </e:finished>
+  
+  <e:started id="7" name="[2] 2" parentId="5" time="2025-02-11T15:18:00.433Z">
+    <metadata>
+      <junit:uniqueId>[engine:junit-jupiter]/[container-template:com.example.project.CalculatorContainerTemplateTests]/[container-template-invocation:#1]/[test-template:parameterizedTest(int)]/[test-template-invocation:#2]</junit:uniqueId>
+      <junit:legacyReportingName>parameterizedTest(int)[2]</junit:legacyReportingName>
+      <junit:type>TEST</junit:type>
+    </metadata>
+    <sources>
+      <java:methodSource className="com.example.project.CalculatorContainerTemplateTests" methodName="parameterizedTest" methodParameterTypes="int"/>
+    </sources>
+  </e:started>
+  
+  <e:finished id="7" time="2025-02-11T15:18:00.435Z">
+    <result status="SUCCESSFUL"/>
+  </e:finished>
+  
+  <e:finished id="5" time="2025-02-11T15:18:00.436Z">
+    <result status="SUCCESSFUL"/>
+  </e:finished>
+  
+  <e:finished id="3" time="2025-02-11T15:18:00.438Z">
+    <result status="SUCCESSFUL"/>
+  </e:finished>
+  
+  <e:started id="8" name="[2]" parentId="2" time="2025-02-11T15:18:00.439Z">
+    <metadata>
+      <junit:uniqueId>[engine:junit-jupiter]/[container-template:com.example.project.CalculatorContainerTemplateTests]/[container-template-invocation:#2]</junit:uniqueId>
+      <junit:legacyReportingName>com.example.project.CalculatorContainerTemplateTests[2]</junit:legacyReportingName>
+      <junit:type>CONTAINER</junit:type>
+    </metadata>
+    <sources>
+      <java:classSource className="com.example.project.CalculatorContainerTemplateTests"/>
+    </sources>
+  </e:started>
+  
+  <e:started id="9" name="regularTest()" parentId="8" time="2025-02-11T15:18:00.440Z">
+    <metadata>
+      <junit:uniqueId>[engine:junit-jupiter]/[container-template:com.example.project.CalculatorContainerTemplateTests]/[container-template-invocation:#2]/[method:regularTest()]</junit:uniqueId>
+      <junit:legacyReportingName>regularTest()</junit:legacyReportingName>
+      <junit:type>TEST</junit:type>
+    </metadata>
+    <sources>
+      <java:methodSource className="com.example.project.CalculatorContainerTemplateTests" methodName="regularTest" methodParameterTypes=""/>
+    </sources>
+  </e:started>
+  
+  <e:finished id="9" time="2025-02-11T15:18:00.441Z">
+    <result status="SUCCESSFUL"/>
+  </e:finished>
+  
+  <e:started id="10" name="parameterizedTest(int)" parentId="8" time="2025-02-11T15:18:00.442Z">
+    <metadata>
+      <junit:uniqueId>[engine:junit-jupiter]/[container-template:com.example.project.CalculatorContainerTemplateTests]/[container-template-invocation:#2]/[test-template:parameterizedTest(int)]</junit:uniqueId>
+      <junit:legacyReportingName>parameterizedTest(int)</junit:legacyReportingName>
+      <junit:type>CONTAINER</junit:type>
+    </metadata>
+    <sources>
+      <java:methodSource className="com.example.project.CalculatorContainerTemplateTests" methodName="parameterizedTest" methodParameterTypes="int"/>
+    </sources>
+  </e:started>
+  
+  <e:started id="11" name="[1] 1" parentId="10" time="2025-02-11T15:18:00.444Z">
+    <metadata>
+      <junit:uniqueId>[engine:junit-jupiter]/[container-template:com.example.project.CalculatorContainerTemplateTests]/[container-template-invocation:#2]/[test-template:parameterizedTest(int)]/[test-template-invocation:#1]</junit:uniqueId>
+      <junit:legacyReportingName>parameterizedTest(int)[1]</junit:legacyReportingName>
+      <junit:type>TEST</junit:type>
+    </metadata>
+    <sources>
+      <java:methodSource className="com.example.project.CalculatorContainerTemplateTests" methodName="parameterizedTest" methodParameterTypes="int"/>
+    </sources>
+  </e:started>
+  
+  <e:finished id="11" time="2025-02-11T15:18:00.446Z">
+    <result status="SUCCESSFUL"/>
+  </e:finished>
+  
+  <e:started id="12" name="[2] 2" parentId="10" time="2025-02-11T15:18:00.447Z">
+    <metadata>
+      <junit:uniqueId>[engine:junit-jupiter]/[container-template:com.example.project.CalculatorContainerTemplateTests]/[container-template-invocation:#2]/[test-template:parameterizedTest(int)]/[test-template-invocation:#2]</junit:uniqueId>
+      <junit:legacyReportingName>parameterizedTest(int)[2]</junit:legacyReportingName>
+      <junit:type>TEST</junit:type>
+    </metadata>
+    <sources>
+      <java:methodSource className="com.example.project.CalculatorContainerTemplateTests" methodName="parameterizedTest" methodParameterTypes="int"/>
+    </sources>
+  </e:started>
+  
+  <e:finished id="12" time="2025-02-11T15:18:00.449Z">
+    <result status="SUCCESSFUL"/>
+  </e:finished>
+  
+  <e:finished id="10" time="2025-02-11T15:18:00.450Z">
+    <result status="SUCCESSFUL"/>
+  </e:finished>
+  
+  <e:finished id="8" time="2025-02-11T15:18:00.451Z">
+    <result status="SUCCESSFUL"/>
+  </e:finished>
+  
+  <e:finished id="2" time="2025-02-11T15:18:00.453Z">
+    <result status="SUCCESSFUL"/>
+  </e:finished>
+  
+  <e:started id="13" name="CalculatorTests" parentId="1" time="2025-02-11T15:18:00.455Z">
     <metadata>
       <junit:uniqueId>[engine:junit-jupiter]/[class:com.example.project.CalculatorTests]</junit:uniqueId>
       <junit:legacyReportingName>com.example.project.CalculatorTests</junit:legacyReportingName>
@@ -40,7 +205,7 @@ test-method: verifyJupiterStarterProject
     </sources>
   </e:started>
   
-  <e:started id="3" name="1 + 1 = 2" parentId="2" time="2025-02-11T13:40:25.574Z">
+  <e:started id="14" name="1 + 1 = 2" parentId="13" time="2025-02-11T15:18:00.457Z">
     <metadata>
       <junit:uniqueId>[engine:junit-jupiter]/[class:com.example.project.CalculatorTests]/[method:addsTwoNumbers()]</junit:uniqueId>
       <junit:legacyReportingName>addsTwoNumbers()</junit:legacyReportingName>
@@ -51,11 +216,11 @@ test-method: verifyJupiterStarterProject
     </sources>
   </e:started>
   
-  <e:finished id="3" time="2025-02-11T13:40:25.585Z">
+  <e:finished id="14" time="2025-02-11T15:18:00.459Z">
     <result status="SUCCESSFUL"/>
   </e:finished>
   
-  <e:started id="4" name="add(int, int, int)" parentId="2" time="2025-02-11T13:40:25.588Z">
+  <e:started id="15" name="add(int, int, int)" parentId="13" time="2025-02-11T15:18:00.459Z">
     <metadata>
       <junit:uniqueId>[engine:junit-jupiter]/[class:com.example.project.CalculatorTests]/[test-template:add(int, int, int)]</junit:uniqueId>
       <junit:legacyReportingName>add(int, int, int)</junit:legacyReportingName>
@@ -66,7 +231,7 @@ test-method: verifyJupiterStarterProject
     </sources>
   </e:started>
   
-  <e:started id="5" name="0 + 1 = 1" parentId="4" time="2025-02-11T13:40:25.611Z">
+  <e:started id="16" name="0 + 1 = 1" parentId="15" time="2025-02-11T15:18:00.474Z">
     <metadata>
       <junit:uniqueId>[engine:junit-jupiter]/[class:com.example.project.CalculatorTests]/[test-template:add(int, int, int)]/[test-template-invocation:#1]</junit:uniqueId>
       <junit:legacyReportingName>add(int, int, int)[1]</junit:legacyReportingName>
@@ -77,11 +242,11 @@ test-method: verifyJupiterStarterProject
     </sources>
   </e:started>
   
-  <e:finished id="5" time="2025-02-11T13:40:25.622Z">
+  <e:finished id="16" time="2025-02-11T15:18:00.483Z">
     <result status="SUCCESSFUL"/>
   </e:finished>
   
-  <e:started id="6" name="1 + 2 = 3" parentId="4" time="2025-02-11T13:40:25.624Z">
+  <e:started id="17" name="1 + 2 = 3" parentId="15" time="2025-02-11T15:18:00.484Z">
     <metadata>
       <junit:uniqueId>[engine:junit-jupiter]/[class:com.example.project.CalculatorTests]/[test-template:add(int, int, int)]/[test-template-invocation:#2]</junit:uniqueId>
       <junit:legacyReportingName>add(int, int, int)[2]</junit:legacyReportingName>
@@ -92,11 +257,11 @@ test-method: verifyJupiterStarterProject
     </sources>
   </e:started>
   
-  <e:finished id="6" time="2025-02-11T13:40:25.626Z">
+  <e:finished id="17" time="2025-02-11T15:18:00.486Z">
     <result status="SUCCESSFUL"/>
   </e:finished>
   
-  <e:started id="7" name="49 + 51 = 100" parentId="4" time="2025-02-11T13:40:25.627Z">
+  <e:started id="18" name="49 + 51 = 100" parentId="15" time="2025-02-11T15:18:00.487Z">
     <metadata>
       <junit:uniqueId>[engine:junit-jupiter]/[class:com.example.project.CalculatorTests]/[test-template:add(int, int, int)]/[test-template-invocation:#3]</junit:uniqueId>
       <junit:legacyReportingName>add(int, int, int)[3]</junit:legacyReportingName>
@@ -107,11 +272,11 @@ test-method: verifyJupiterStarterProject
     </sources>
   </e:started>
   
-  <e:finished id="7" time="2025-02-11T13:40:25.628Z">
+  <e:finished id="18" time="2025-02-11T15:18:00.488Z">
     <result status="SUCCESSFUL"/>
   </e:finished>
   
-  <e:started id="8" name="1 + 100 = 101" parentId="4" time="2025-02-11T13:40:25.629Z">
+  <e:started id="19" name="1 + 100 = 101" parentId="15" time="2025-02-11T15:18:00.489Z">
     <metadata>
       <junit:uniqueId>[engine:junit-jupiter]/[class:com.example.project.CalculatorTests]/[test-template:add(int, int, int)]/[test-template-invocation:#4]</junit:uniqueId>
       <junit:legacyReportingName>add(int, int, int)[4]</junit:legacyReportingName>
@@ -122,19 +287,19 @@ test-method: verifyJupiterStarterProject
     </sources>
   </e:started>
   
-  <e:finished id="8" time="2025-02-11T13:40:25.631Z">
+  <e:finished id="19" time="2025-02-11T15:18:00.490Z">
     <result status="SUCCESSFUL"/>
   </e:finished>
   
-  <e:finished id="4" time="2025-02-11T13:40:25.631Z">
+  <e:finished id="15" time="2025-02-11T15:18:00.490Z">
     <result status="SUCCESSFUL"/>
   </e:finished>
   
-  <e:finished id="2" time="2025-02-11T13:40:25.634Z">
+  <e:finished id="13" time="2025-02-11T15:18:00.491Z">
     <result status="SUCCESSFUL"/>
   </e:finished>
   
-  <e:finished id="1" time="2025-02-11T13:40:25.635Z">
+  <e:finished id="1" time="2025-02-11T15:18:00.492Z">
     <result status="SUCCESSFUL"/>
   </e:finished>
   
