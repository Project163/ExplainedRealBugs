diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.3.1.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.3.1.adoc
index 248172c9e..09ae73b36 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.3.1.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.3.1.adoc
@@ -20,6 +20,9 @@ repository on GitHub.
     (such as the Jupiter and Vintage test engines) no longer retains references to
     contextual state after a node has completed execution. This allows state such as
     instances of test classes to be properly garbage collected by the JVM.
+  - Previously, a `NodeTestTask` instance was created for each `TestDescriptor` before
+    starting execution. Now they are created on the fly and can be garbage collected by
+    the JVM after the enclosing container has finished.
 
 
 [[release-notes-5.3.1-junit-jupiter]]
diff --git a/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/HierarchicalTestExecutor.java b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/HierarchicalTestExecutor.java
index 2b8f8bdbe..fb9b9e94f 100644
--- a/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/HierarchicalTestExecutor.java
+++ b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/HierarchicalTestExecutor.java
@@ -47,18 +47,14 @@ class HierarchicalTestExecutor<C extends EngineExecutionContext> {
 	}
 
 	Future<Void> execute() {
-		NodeTestTask<C> rootTestTask = prepareNodeTestTaskTree();
-		rootTestTask.setParentContext(this.rootContext);
-		return this.executorService.submit(rootTestTask);
-	}
-
-	NodeTestTask<C> prepareNodeTestTaskTree() {
 		TestDescriptor rootTestDescriptor = this.request.getRootTestDescriptor();
 		EngineExecutionListener executionListener = this.request.getEngineExecutionListener();
-		NodeTestTask<C> rootTestTask = new NodeTestTask<>(rootTestDescriptor, executionListener, this.executorService,
-			this.throwableCollectorFactory);
-		new NodeTestTaskWalker().walk(rootTestTask);
-		return rootTestTask;
+		NodeExecutionAdvisor executionAdvisor = new NodeTreeWalker().walk(rootTestDescriptor);
+		NodeTestTaskContext taskContext = new NodeTestTaskContext(executionListener, this.executorService,
+			this.throwableCollectorFactory, executionAdvisor);
+		NodeTestTask<C> rootTestTask = new NodeTestTask<>(taskContext, rootTestDescriptor);
+		rootTestTask.setParentContext(this.rootContext);
+		return this.executorService.submit(rootTestTask);
 	}
 
 }
diff --git a/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/NodeExecutionAdvisor.java b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/NodeExecutionAdvisor.java
new file mode 100644
index 000000000..6919a2b34
--- /dev/null
+++ b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/NodeExecutionAdvisor.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2015-2018 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * http://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.platform.engine.support.hierarchical;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Optional;
+
+import org.junit.platform.engine.TestDescriptor;
+import org.junit.platform.engine.support.hierarchical.Node.ExecutionMode;
+
+/**
+ * @since 1.3.1
+ */
+class NodeExecutionAdvisor {
+
+	private final Map<TestDescriptor, ExecutionMode> forcedExecutionModeByTestDescriptor = new HashMap<>();
+	private final Map<TestDescriptor, ResourceLock> resourceLocksByTestDescriptor = new HashMap<>();
+
+	void forceExecutionMode(TestDescriptor testDescriptor, ExecutionMode executionMode) {
+		forcedExecutionModeByTestDescriptor.put(testDescriptor, executionMode);
+	}
+
+	void useResourceLock(TestDescriptor testDescriptor, ResourceLock resourceLock) {
+		resourceLocksByTestDescriptor.put(testDescriptor, resourceLock);
+	}
+
+	Optional<ExecutionMode> getForcedExecutionMode(TestDescriptor testDescriptor) {
+		return Optional.ofNullable(forcedExecutionModeByTestDescriptor.get(testDescriptor));
+	}
+
+	ResourceLock getResourceLock(TestDescriptor testDescriptor) {
+		return resourceLocksByTestDescriptor.getOrDefault(testDescriptor, NopLock.INSTANCE);
+	}
+}
diff --git a/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/NodeTestTask.java b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/NodeTestTask.java
index a380f9241..5cc28e27b 100644
--- a/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/NodeTestTask.java
+++ b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/NodeTestTask.java
@@ -15,12 +15,10 @@ import static org.junit.platform.engine.TestExecutionResult.failed;
 
 import java.util.ArrayList;
 import java.util.List;
-import java.util.Optional;
 import java.util.Set;
 import java.util.concurrent.Future;
 
 import org.junit.platform.commons.JUnitException;
-import org.junit.platform.engine.EngineExecutionListener;
 import org.junit.platform.engine.TestDescriptor;
 import org.junit.platform.engine.support.hierarchical.HierarchicalTestExecutorService.TestTask;
 import org.junit.platform.engine.support.hierarchical.Node.ExecutionMode;
@@ -31,17 +29,9 @@ import org.junit.platform.engine.support.hierarchical.Node.SkipResult;
  */
 class NodeTestTask<C extends EngineExecutionContext> implements TestTask {
 
+	private final NodeTestTaskContext taskContext;
 	private final TestDescriptor testDescriptor;
-	private final EngineExecutionListener listener;
-	private final HierarchicalTestExecutorService executorService;
-	private final ThrowableCollector.Factory throwableCollectorFactory;
 	private final Node<C> node;
-	private final ExecutionMode executionMode;
-	private final Set<ExclusiveResource> exclusiveResources;
-	private final List<NodeTestTask<C>> children;
-
-	private ResourceLock resourceLock = NopLock.INSTANCE;
-	private Optional<ExecutionMode> forcedExecutionMode = Optional.empty();
 
 	private C parentContext;
 	private C context;
@@ -50,55 +40,29 @@ class NodeTestTask<C extends EngineExecutionContext> implements TestTask {
 	private boolean started;
 	private ThrowableCollector throwableCollector;
 
-	NodeTestTask(TestDescriptor testDescriptor, EngineExecutionListener listener,
-			HierarchicalTestExecutorService executorService, ThrowableCollector.Factory throwableCollectorFactory) {
+	NodeTestTask(NodeTestTaskContext taskContext, TestDescriptor testDescriptor) {
+		this.taskContext = taskContext;
 		this.testDescriptor = testDescriptor;
-		this.listener = listener;
-		this.executorService = executorService;
-		this.throwableCollectorFactory = throwableCollectorFactory;
-		node = asNode(testDescriptor);
-		executionMode = node.getExecutionMode();
-		exclusiveResources = node.getExclusiveResources();
-		// @formatter:off
-		children = testDescriptor.getChildren().stream()
-				.map(descriptor -> new NodeTestTask<C>(descriptor, listener, executorService, throwableCollectorFactory))
-				.collect(toCollection(ArrayList::new));
-		// @formatter:on
-	}
-
-	public Set<ExclusiveResource> getExclusiveResources() {
-		return exclusiveResources;
-	}
-
-	public List<NodeTestTask<C>> getChildren() {
-		return children;
+		this.node = NodeUtils.asNode(testDescriptor);
 	}
 
 	@Override
 	public ResourceLock getResourceLock() {
-		return resourceLock;
-	}
-
-	public void setResourceLock(ResourceLock resourceLock) {
-		this.resourceLock = resourceLock;
+		return taskContext.getExecutionAdvisor().getResourceLock(testDescriptor);
 	}
 
 	@Override
 	public ExecutionMode getExecutionMode() {
-		return forcedExecutionMode.orElse(executionMode);
+		return taskContext.getExecutionAdvisor().getForcedExecutionMode(testDescriptor).orElse(node.getExecutionMode());
 	}
 
-	public void setForcedExecutionMode(ExecutionMode forcedExecutionMode) {
-		this.forcedExecutionMode = Optional.of(forcedExecutionMode);
-	}
-
-	public void setParentContext(C parentContext) {
+	void setParentContext(C parentContext) {
 		this.parentContext = parentContext;
 	}
 
 	@Override
 	public void execute() {
-		throwableCollector = throwableCollectorFactory.create();
+		throwableCollector = taskContext.getThrowableCollectorFactory().create();
 		prepare();
 		if (throwableCollector.isEmpty()) {
 			checkWhetherSkipped();
@@ -125,10 +89,16 @@ class NodeTestTask<C extends EngineExecutionContext> implements TestTask {
 	}
 
 	private void executeRecursively() {
-		listener.executionStarted(testDescriptor);
+		taskContext.getListener().executionStarted(testDescriptor);
 		started = true;
 
 		throwableCollector.execute(() -> {
+			// @formatter:off
+			List<NodeTestTask<C>> children = testDescriptor.getChildren().stream()
+					.map(descriptor -> new NodeTestTask<C>(taskContext, descriptor))
+					.collect(toCollection(ArrayList::new));
+			// @formatter:on
+
 			context = node.before(context);
 
 			List<Future<?>> futures = new ArrayList<>();
@@ -137,7 +107,7 @@ class NodeTestTask<C extends EngineExecutionContext> implements TestTask {
 
 			if (!children.isEmpty()) {
 				children.forEach(child -> child.setParentContext(context));
-				executorService.invokeAll(children);
+				taskContext.getExecutorService().invokeAll(children);
 			}
 
 			// using a for loop for the sake for ForkJoinPool's work stealing
@@ -150,18 +120,17 @@ class NodeTestTask<C extends EngineExecutionContext> implements TestTask {
 	}
 
 	private void executeDynamicTest(TestDescriptor dynamicTestDescriptor, List<Future<?>> futures) {
-		listener.dynamicTestRegistered(dynamicTestDescriptor);
-		NodeTestTask<C> nodeTestTask = new NodeTestTask<>(dynamicTestDescriptor, listener, executorService,
-			throwableCollectorFactory);
-		Set<ExclusiveResource> exclusiveResources = nodeTestTask.getExclusiveResources();
+		taskContext.getListener().dynamicTestRegistered(dynamicTestDescriptor);
+		Set<ExclusiveResource> exclusiveResources = NodeUtils.asNode(dynamicTestDescriptor).getExclusiveResources();
 		if (!exclusiveResources.isEmpty()) {
-			listener.executionStarted(dynamicTestDescriptor);
+			taskContext.getListener().executionStarted(dynamicTestDescriptor);
 			String message = "Dynamic test descriptors must not declare exclusive resources: " + exclusiveResources;
-			listener.executionFinished(dynamicTestDescriptor, failed(new JUnitException(message)));
+			taskContext.getListener().executionFinished(dynamicTestDescriptor, failed(new JUnitException(message)));
 		}
 		else {
+			NodeTestTask<C> nodeTestTask = new NodeTestTask<>(taskContext, dynamicTestDescriptor);
 			nodeTestTask.setParentContext(context);
-			futures.add(executorService.submit(nodeTestTask));
+			futures.add(taskContext.getExecutorService().submit(nodeTestTask));
 		}
 	}
 
@@ -175,24 +144,15 @@ class NodeTestTask<C extends EngineExecutionContext> implements TestTask {
 
 	private void reportCompletion() {
 		if (throwableCollector.isEmpty() && skipResult.isSkipped()) {
-			listener.executionSkipped(testDescriptor, skipResult.getReason().orElse("<unknown>"));
+			taskContext.getListener().executionSkipped(testDescriptor, skipResult.getReason().orElse("<unknown>"));
 			return;
 		}
 		if (!started) {
 			// Call executionStarted first to comply with the contract of EngineExecutionListener.
-			listener.executionStarted(testDescriptor);
+			taskContext.getListener().executionStarted(testDescriptor);
 		}
-		listener.executionFinished(testDescriptor, throwableCollector.toTestExecutionResult());
+		taskContext.getListener().executionFinished(testDescriptor, throwableCollector.toTestExecutionResult());
 		throwableCollector = null;
 	}
 
-	@SuppressWarnings("unchecked")
-	private Node<C> asNode(TestDescriptor testDescriptor) {
-		return (testDescriptor instanceof Node ? (Node<C>) testDescriptor : noOpNode);
-	}
-
-	@SuppressWarnings("rawtypes")
-	private static final Node noOpNode = new Node() {
-	};
-
 }
diff --git a/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/NodeTestTaskContext.java b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/NodeTestTaskContext.java
new file mode 100644
index 000000000..26f78a291
--- /dev/null
+++ b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/NodeTestTaskContext.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2015-2018 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * http://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.platform.engine.support.hierarchical;
+
+import org.junit.platform.engine.EngineExecutionListener;
+
+/**
+ * @since 1.3.1
+ */
+class NodeTestTaskContext {
+
+	private final EngineExecutionListener listener;
+	private final HierarchicalTestExecutorService executorService;
+	private final ThrowableCollector.Factory throwableCollectorFactory;
+	private final NodeExecutionAdvisor executionAdvisor;
+
+	public NodeTestTaskContext(EngineExecutionListener listener, HierarchicalTestExecutorService executorService,
+			ThrowableCollector.Factory throwableCollectorFactory, NodeExecutionAdvisor executionAdvisor) {
+		this.listener = listener;
+		this.executorService = executorService;
+		this.throwableCollectorFactory = throwableCollectorFactory;
+		this.executionAdvisor = executionAdvisor;
+	}
+
+	EngineExecutionListener getListener() {
+		return listener;
+	}
+
+	HierarchicalTestExecutorService getExecutorService() {
+		return executorService;
+	}
+
+	ThrowableCollector.Factory getThrowableCollectorFactory() {
+		return throwableCollectorFactory;
+	}
+
+	NodeExecutionAdvisor getExecutionAdvisor() {
+		return executionAdvisor;
+	}
+}
diff --git a/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/NodeTestTaskWalker.java b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/NodeTestTaskWalker.java
deleted file mode 100644
index da5895a4e..000000000
--- a/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/NodeTestTaskWalker.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright 2015-2018 the original author or authors.
- *
- * All rights reserved. This program and the accompanying materials are
- * made available under the terms of the Eclipse Public License v2.0 which
- * accompanies this distribution and is available at
- *
- * http://www.eclipse.org/legal/epl-v20.html
- */
-
-package org.junit.platform.engine.support.hierarchical;
-
-import static org.junit.platform.engine.support.hierarchical.Node.ExecutionMode.SAME_THREAD;
-
-import java.util.HashSet;
-import java.util.Set;
-import java.util.function.Consumer;
-
-/**
- * @since 1.3
- */
-class NodeTestTaskWalker {
-
-	private final LockManager lockManager = new LockManager();
-
-	void walk(NodeTestTask<?> nodeTestTask) {
-		if (nodeTestTask.getExclusiveResources().isEmpty()) {
-			nodeTestTask.getChildren().forEach(this::walk);
-		}
-		else {
-			Set<ExclusiveResource> allResources = new HashSet<>(nodeTestTask.getExclusiveResources());
-			doForChildrenRecursively(nodeTestTask, child -> {
-				allResources.addAll(child.getExclusiveResources());
-				child.setForcedExecutionMode(SAME_THREAD);
-			});
-			nodeTestTask.setResourceLock(lockManager.getLockForResources(allResources));
-		}
-	}
-
-	private void doForChildrenRecursively(NodeTestTask<?> parent, Consumer<NodeTestTask<?>> consumer) {
-		parent.getChildren().forEach(child -> {
-			consumer.accept(child);
-			doForChildrenRecursively(child, consumer);
-		});
-	}
-
-}
diff --git a/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/NodeTreeWalker.java b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/NodeTreeWalker.java
new file mode 100644
index 000000000..628dbb52d
--- /dev/null
+++ b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/NodeTreeWalker.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright 2015-2018 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * http://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.platform.engine.support.hierarchical;
+
+import static org.junit.platform.engine.support.hierarchical.Node.ExecutionMode.SAME_THREAD;
+
+import java.util.HashSet;
+import java.util.Set;
+import java.util.function.Consumer;
+
+import org.junit.platform.engine.TestDescriptor;
+
+/**
+ * @since 1.3
+ */
+class NodeTreeWalker {
+
+	private final LockManager lockManager = new LockManager();
+
+	NodeExecutionAdvisor walk(TestDescriptor testDescriptor) {
+		NodeExecutionAdvisor advisor = new NodeExecutionAdvisor();
+		walk(testDescriptor, advisor);
+		return advisor;
+	}
+
+	private void walk(TestDescriptor testDescriptor, NodeExecutionAdvisor advisor) {
+		Set<ExclusiveResource> exclusiveResources = getExclusiveResources(testDescriptor);
+		if (exclusiveResources.isEmpty()) {
+			testDescriptor.getChildren().forEach(child -> walk(child, advisor));
+		}
+		else {
+			Set<ExclusiveResource> allResources = new HashSet<>(exclusiveResources);
+			doForChildrenRecursively(testDescriptor, child -> {
+				allResources.addAll(getExclusiveResources(child));
+				advisor.forceExecutionMode(child, SAME_THREAD);
+			});
+			advisor.useResourceLock(testDescriptor, lockManager.getLockForResources(allResources));
+		}
+	}
+
+	private Set<ExclusiveResource> getExclusiveResources(TestDescriptor testDescriptor) {
+		return NodeUtils.asNode(testDescriptor).getExclusiveResources();
+	}
+
+	private void doForChildrenRecursively(TestDescriptor parent, Consumer<TestDescriptor> consumer) {
+		parent.getChildren().forEach(child -> {
+			consumer.accept(child);
+			doForChildrenRecursively(child, consumer);
+		});
+	}
+
+}
diff --git a/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/NodeUtils.java b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/NodeUtils.java
new file mode 100644
index 000000000..1c442a603
--- /dev/null
+++ b/junit-platform-engine/src/main/java/org/junit/platform/engine/support/hierarchical/NodeUtils.java
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2015-2018 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * http://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.platform.engine.support.hierarchical;
+
+import org.junit.platform.engine.TestDescriptor;
+
+/**
+ * @since 1.3.1
+ */
+final class NodeUtils {
+
+	private NodeUtils() {
+		/* no-op */
+	}
+
+	@SuppressWarnings("unchecked")
+	static <C extends EngineExecutionContext> Node<C> asNode(TestDescriptor testDescriptor) {
+		return (testDescriptor instanceof Node ? (Node<C>) testDescriptor : noOpNode);
+	}
+
+	@SuppressWarnings("rawtypes")
+	private static final Node noOpNode = new Node() {
+	};
+
+}
diff --git a/platform-tests/src/test/java/org/junit/platform/engine/support/hierarchical/NodeTestTaskWalkerIntegrationTests.java b/platform-tests/src/test/java/org/junit/platform/engine/support/hierarchical/NodeTestTaskWalkerIntegrationTests.java
deleted file mode 100644
index 96e975e7c..000000000
--- a/platform-tests/src/test/java/org/junit/platform/engine/support/hierarchical/NodeTestTaskWalkerIntegrationTests.java
+++ /dev/null
@@ -1,104 +0,0 @@
-/*
- * Copyright 2015-2018 the original author or authors.
- *
- * All rights reserved. This program and the accompanying materials are
- * made available under the terms of the Eclipse Public License v2.0 which
- * accompanies this distribution and is available at
- *
- * http://www.eclipse.org/legal/epl-v20.html
- */
-
-package org.junit.platform.engine.support.hierarchical;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.platform.engine.discovery.DiscoverySelectors.selectClass;
-import static org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder.request;
-
-import org.junit.jupiter.api.Nested;
-import org.junit.jupiter.api.Test;
-import org.junit.jupiter.api.parallel.ResourceLock;
-import org.junit.jupiter.engine.JupiterTestEngine;
-import org.junit.platform.engine.ExecutionRequest;
-import org.junit.platform.engine.TestDescriptor;
-import org.junit.platform.engine.UniqueId;
-import org.junit.platform.engine.support.hierarchical.Node.ExecutionMode;
-import org.junit.platform.launcher.LauncherDiscoveryRequest;
-
-/**
- * @since 1.3
- */
-class NodeTestTaskWalkerIntegrationTests {
-
-	@Test
-	void pullUpExclusiveChildResourcesToTestClass() {
-		NodeTestTask<?> engineNodeTestTask = prepareNodeTestTaskTree(TestCaseWithResourceLock.class);
-
-		assertThat(engineNodeTestTask.getChildren()).hasSize(1);
-		NodeTestTask<?> testClassExecutor = engineNodeTestTask.getChildren().get(0);
-		assertThat(testClassExecutor.getResourceLock()).isInstanceOf(CompositeLock.class);
-		assertThat(testClassExecutor.getExecutionMode()).isEqualTo(ExecutionMode.CONCURRENT);
-
-		assertThat(testClassExecutor.getChildren()).hasSize(1);
-		NodeTestTask<?> testMethodExecutor = testClassExecutor.getChildren().get(0);
-		assertThat(testMethodExecutor.getResourceLock()).isInstanceOf(NopLock.class);
-		assertThat(testMethodExecutor.getExecutionMode()).isEqualTo(ExecutionMode.SAME_THREAD);
-	}
-
-	@Test
-	void leavesResourceLockOnTestMethodWhenClassDoesNotUseResource() {
-		NodeTestTask<?> engineNodeTestTask = prepareNodeTestTaskTree(TestCaseWithoutResourceLock.class);
-
-		assertThat(engineNodeTestTask.getChildren()).hasSize(1);
-		NodeTestTask<?> testClassExecutor = engineNodeTestTask.getChildren().get(0);
-		assertThat(testClassExecutor.getResourceLock()).isInstanceOf(NopLock.class);
-		assertThat(testClassExecutor.getExecutionMode()).isEqualTo(ExecutionMode.CONCURRENT);
-
-		assertThat(testClassExecutor.getChildren()).hasSize(2);
-		NodeTestTask<?> testMethodExecutor = testClassExecutor.getChildren().get(0);
-		assertThat(testMethodExecutor.getResourceLock()).isInstanceOf(SingleLock.class);
-		assertThat(testMethodExecutor.getExecutionMode()).isEqualTo(ExecutionMode.CONCURRENT);
-
-		NodeTestTask<?> nestedTestClassExecutor = testClassExecutor.getChildren().get(1);
-		assertThat(nestedTestClassExecutor.getResourceLock()).isInstanceOf(CompositeLock.class);
-		assertThat(nestedTestClassExecutor.getExecutionMode()).isEqualTo(ExecutionMode.CONCURRENT);
-
-		assertThat(nestedTestClassExecutor.getChildren()).hasSize(1);
-		NodeTestTask<?> nestedTestMethodExecutor = nestedTestClassExecutor.getChildren().get(0);
-		assertThat(nestedTestMethodExecutor.getResourceLock()).isInstanceOf(NopLock.class);
-		assertThat(nestedTestMethodExecutor.getExecutionMode()).isEqualTo(ExecutionMode.SAME_THREAD);
-	}
-
-	private NodeTestTask<?> prepareNodeTestTaskTree(Class<?> testClass) {
-		LauncherDiscoveryRequest discoveryRequest = request().selectors(selectClass(testClass)).build();
-		TestDescriptor testDescriptor = new JupiterTestEngine().discover(discoveryRequest,
-			UniqueId.forEngine("junit-jupiter"));
-		ExecutionRequest executionRequest = new ExecutionRequest(testDescriptor, null, null);
-		HierarchicalTestExecutor<?> executor = new HierarchicalTestExecutor<>(executionRequest, null, null,
-			() -> new ThrowableCollector(t -> false));
-		return executor.prepareNodeTestTaskTree();
-	}
-
-	@ResourceLock("a")
-	static class TestCaseWithResourceLock {
-		@Test
-		@ResourceLock("b")
-		void test() {
-		}
-	}
-
-	static class TestCaseWithoutResourceLock {
-		@Test
-		@ResourceLock("a")
-		void test() {
-		}
-
-		@Nested
-		@ResourceLock("c")
-		class NestedTestCaseWithResourceLock {
-			@Test
-			@ResourceLock("b")
-			void test() {
-			}
-		}
-	}
-}
diff --git a/platform-tests/src/test/java/org/junit/platform/engine/support/hierarchical/NodeTreeWalkerIntegrationTests.java b/platform-tests/src/test/java/org/junit/platform/engine/support/hierarchical/NodeTreeWalkerIntegrationTests.java
new file mode 100644
index 000000000..79989000e
--- /dev/null
+++ b/platform-tests/src/test/java/org/junit/platform/engine/support/hierarchical/NodeTreeWalkerIntegrationTests.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright 2015-2018 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * http://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.platform.engine.support.hierarchical;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.platform.commons.util.CollectionUtils.getOnlyElement;
+import static org.junit.platform.engine.discovery.DiscoverySelectors.selectClass;
+import static org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder.request;
+
+import java.util.Iterator;
+
+import org.junit.jupiter.api.Nested;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.parallel.ResourceLock;
+import org.junit.jupiter.engine.JupiterTestEngine;
+import org.junit.platform.engine.TestDescriptor;
+import org.junit.platform.engine.UniqueId;
+import org.junit.platform.engine.support.hierarchical.Node.ExecutionMode;
+import org.junit.platform.launcher.LauncherDiscoveryRequest;
+
+/**
+ * @since 1.3
+ */
+class NodeTreeWalkerIntegrationTests {
+
+	@Test
+	void pullUpExclusiveChildResourcesToTestClass() {
+		TestDescriptor engineDescriptor = discover(TestCaseWithResourceLock.class);
+		NodeExecutionAdvisor advisor = new NodeTreeWalker().walk(engineDescriptor);
+
+		TestDescriptor testClassDescriptor = getOnlyElement(engineDescriptor.getChildren());
+		assertThat(advisor.getResourceLock(testClassDescriptor)).isInstanceOf(CompositeLock.class);
+		assertThat(advisor.getForcedExecutionMode(testClassDescriptor)).isEmpty();
+
+		TestDescriptor testMethodDescriptor = getOnlyElement(testClassDescriptor.getChildren());
+		assertThat(advisor.getResourceLock(testMethodDescriptor)).isInstanceOf(NopLock.class);
+		assertThat(advisor.getForcedExecutionMode(testMethodDescriptor)).contains(ExecutionMode.SAME_THREAD);
+	}
+
+	@Test
+	void leavesResourceLockOnTestMethodWhenClassDoesNotUseResource() {
+		TestDescriptor engineDescriptor = discover(TestCaseWithoutResourceLock.class);
+		NodeExecutionAdvisor advisor = new NodeTreeWalker().walk(engineDescriptor);
+
+		TestDescriptor testClassDescriptor = getOnlyElement(engineDescriptor.getChildren());
+		assertThat(advisor.getResourceLock(testClassDescriptor)).isInstanceOf(NopLock.class);
+		assertThat(advisor.getForcedExecutionMode(testClassDescriptor)).isEmpty();
+
+		assertThat(testClassDescriptor.getChildren()).hasSize(2);
+		Iterator<? extends TestDescriptor> children = testClassDescriptor.getChildren().iterator();
+		TestDescriptor testMethodDescriptor = children.next();
+		assertThat(advisor.getResourceLock(testMethodDescriptor)).isInstanceOf(SingleLock.class);
+		assertThat(advisor.getForcedExecutionMode(testMethodDescriptor)).isEmpty();
+
+		TestDescriptor nestedTestClassDescriptor = children.next();
+		assertThat(advisor.getResourceLock(nestedTestClassDescriptor)).isInstanceOf(CompositeLock.class);
+		assertThat(advisor.getForcedExecutionMode(nestedTestClassDescriptor)).isEmpty();
+
+		TestDescriptor nestedTestMethodDescriptor = getOnlyElement(nestedTestClassDescriptor.getChildren());
+		assertThat(advisor.getResourceLock(nestedTestMethodDescriptor)).isInstanceOf(NopLock.class);
+		assertThat(advisor.getForcedExecutionMode(nestedTestMethodDescriptor)).contains(ExecutionMode.SAME_THREAD);
+	}
+
+	private TestDescriptor discover(Class<?> testClass) {
+		LauncherDiscoveryRequest discoveryRequest = request().selectors(selectClass(testClass)).build();
+		return new JupiterTestEngine().discover(discoveryRequest, UniqueId.forEngine("junit-jupiter"));
+	}
+
+	@ResourceLock("a")
+	static class TestCaseWithResourceLock {
+		@Test
+		@ResourceLock("b")
+		void test() {
+		}
+	}
+
+	static class TestCaseWithoutResourceLock {
+		@Test
+		@ResourceLock("a")
+		void test() {
+		}
+
+		@Nested
+		@ResourceLock("c")
+		class NestedTestCaseWithResourceLock {
+			@Test
+			@ResourceLock("b")
+			void test() {
+			}
+		}
+	}
+}
