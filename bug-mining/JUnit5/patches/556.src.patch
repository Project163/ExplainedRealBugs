diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.10.0-RC1.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.10.0-RC1.adoc
index 39b36c843..42f1352f5 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.10.0-RC1.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.10.0-RC1.adoc
@@ -21,6 +21,9 @@ JUnit repository on GitHub.
 
 * The `getMethodParameterTypes()` methods in `MethodSelector` and `NestedMethodSelector`
   have been deprecated and replaced by `getParameterTypeNames()` for greater clarity.
+* Methods in `DiscoverySelectors` that accept a `ClassLoader` now declare the
+  `ClassLoader` as the first parameter. This is only a breaking change for code that
+  relies on the new methods introduced in JUnit Platform 1.10 M1.
 
 ==== New Features and Improvements
 
diff --git a/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/ClassSelector.java b/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/ClassSelector.java
index 70937471e..284c1ed4f 100644
--- a/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/ClassSelector.java
+++ b/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/ClassSelector.java
@@ -44,12 +44,12 @@ import org.junit.platform.engine.DiscoverySelector;
 @API(status = STABLE, since = "1.0")
 public class ClassSelector implements DiscoverySelector {
 
-	private final String className;
 	private final ClassLoader classLoader;
+	private final String className;
 
 	private Class<?> javaClass;
 
-	ClassSelector(String className, ClassLoader classLoader) {
+	ClassSelector(ClassLoader classLoader, String className) {
 		this.className = className;
 		this.classLoader = classLoader;
 	}
@@ -60,15 +60,10 @@ public class ClassSelector implements DiscoverySelector {
 		this.javaClass = javaClass;
 	}
 
-	/**
-	 * Get the selected class name.
-	 */
-	public String getClassName() {
-		return this.className;
-	}
-
 	/**
 	 * Get the {@link ClassLoader} used to load the selected class.
+	 *
+	 * @return the {@code ClassLoader}; potentially {@code null}
 	 * @since 1.10
 	 */
 	@API(status = EXPERIMENTAL, since = "1.10")
@@ -76,6 +71,13 @@ public class ClassSelector implements DiscoverySelector {
 		return this.classLoader;
 	}
 
+	/**
+	 * Get the selected class name.
+	 */
+	public String getClassName() {
+		return this.className;
+	}
+
 	/**
 	 * Get the selected {@link Class}.
 	 *
diff --git a/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectors.java b/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectors.java
index 2774eb424..322c8c0cc 100644
--- a/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectors.java
+++ b/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectors.java
@@ -389,23 +389,23 @@ public final class DiscoverySelectors {
 	 * @see ClassSelector
 	 */
 	public static ClassSelector selectClass(String className) {
-		return selectClass(className, (ClassLoader) null);
+		return selectClass((ClassLoader) null, className);
 	}
 
 	/**
 	 * Create a {@code ClassSelector} for the supplied class name and class loader.
 	 *
-	 * @param className the fully qualified name of the class to select; never
-	 * {@code null} or blank
 	 * @param classLoader the class loader to use to load the class, or {@code null}
 	 * to signal that the default {@code ClassLoader} should be used
+	 * @param className the fully qualified name of the class to select; never
+	 * {@code null} or blank
 	 * @since 1.10
 	 * @see ClassSelector
 	 */
 	@API(status = EXPERIMENTAL, since = "1.10")
-	public static ClassSelector selectClass(String className, ClassLoader classLoader) {
+	public static ClassSelector selectClass(ClassLoader classLoader, String className) {
 		Preconditions.notBlank(className, "Class name must not be null or blank");
-		return new ClassSelector(className, classLoader);
+		return new ClassSelector(classLoader, className);
 	}
 
 	/**
@@ -451,7 +451,7 @@ public final class DiscoverySelectors {
 	 * @see MethodSelector
 	 */
 	public static MethodSelector selectMethod(String fullyQualifiedMethodName) throws PreconditionViolationException {
-		return selectMethod(fullyQualifiedMethodName, (ClassLoader) null);
+		return selectMethod((ClassLoader) null, fullyQualifiedMethodName);
 	}
 
 	/**
@@ -461,20 +461,20 @@ public final class DiscoverySelectors {
 	 * <p>See {@link #selectMethod(String)} for the supported formats for a
 	 * fully qualified method name.
 	 *
-	 * @param fullyQualifiedMethodName the fully qualified name of the method to
-	 * select; never {@code null} or blank
 	 * @param classLoader the class loader to use to load the method's declaring
 	 * class, or {@code null} to signal that the default {@code ClassLoader}
 	 * should be used
+	 * @param fullyQualifiedMethodName the fully qualified name of the method to
+	 * select; never {@code null} or blank
 	 * @since 1.10
 	 * @see #selectMethod(String)
 	 * @see MethodSelector
 	 */
 	@API(status = EXPERIMENTAL, since = "1.10")
-	public static MethodSelector selectMethod(String fullyQualifiedMethodName, ClassLoader classLoader)
+	public static MethodSelector selectMethod(ClassLoader classLoader, String fullyQualifiedMethodName)
 			throws PreconditionViolationException {
 		String[] methodParts = ReflectionUtils.parseFullyQualifiedMethodName(fullyQualifiedMethodName);
-		return selectMethod(methodParts[0], methodParts[1], methodParts[2], classLoader);
+		return selectMethod(classLoader, methodParts[0], methodParts[1], methodParts[2]);
 	}
 
 	/**
@@ -487,26 +487,26 @@ public final class DiscoverySelectors {
 	 * @see MethodSelector
 	 */
 	public static MethodSelector selectMethod(String className, String methodName) {
-		return selectMethod(className, methodName, (ClassLoader) null);
+		return selectMethod((ClassLoader) null, className, methodName);
 	}
 
 	/**
 	 * Create a {@code MethodSelector} for the supplied class name, method name,
 	 * and class loader.
 	 *
+	 * @param classLoader the class loader to use to load the class, or {@code null}
+	 * to signal that the default {@code ClassLoader} should be used
 	 * @param className the fully qualified name of the class in which the method
 	 * is declared, or a subclass thereof; never {@code null} or blank
 	 * @param methodName the name of the method to select; never {@code null} or blank
-	 * @param classLoader the class loader to use to load the class, or {@code null}
-	 * to signal that the default {@code ClassLoader} should be used
 	 * @since 1.10
 	 * @see MethodSelector
 	 */
 	@API(status = EXPERIMENTAL, since = "1.10")
-	public static MethodSelector selectMethod(String className, String methodName, ClassLoader classLoader) {
+	public static MethodSelector selectMethod(ClassLoader classLoader, String className, String methodName) {
 		Preconditions.notBlank(className, "Class name must not be null or blank");
 		Preconditions.notBlank(methodName, "Method name must not be null or blank");
-		return new MethodSelector(className, methodName, "", classLoader);
+		return new MethodSelector(classLoader, className, methodName, "");
 	}
 
 	/**
@@ -526,7 +526,7 @@ public final class DiscoverySelectors {
 	 * @see MethodSelector
 	 */
 	public static MethodSelector selectMethod(String className, String methodName, String parameterTypeNames) {
-		return selectMethod(className, methodName, parameterTypeNames, (ClassLoader) null);
+		return selectMethod((ClassLoader) null, className, methodName, parameterTypeNames);
 	}
 
 	/**
@@ -537,24 +537,24 @@ public final class DiscoverySelectors {
 	 * list of atomic types, fully qualified class names, or array types; however,
 	 * the exact syntax depends on the underlying test engine.
 	 *
+	 * @param classLoader the class loader to use to load the class, or {@code null}
+	 * to signal that the default {@code ClassLoader} should be used
 	 * @param className the fully qualified name of the class in which the method
 	 * is declared, or a subclass thereof; never {@code null} or blank
 	 * @param methodName the name of the method to select; never {@code null} or blank
 	 * @param parameterTypeNames the parameter type names as a single string; never
 	 * {@code null} though potentially an empty string if the method does not declare
 	 * any parameters
-	 * @param classLoader the class loader to use to load the class, or {@code null}
-	 * to signal that the default {@code ClassLoader} should be used
 	 * @since 1.10
 	 * @see MethodSelector
 	 */
 	@API(status = EXPERIMENTAL, since = "1.10")
-	public static MethodSelector selectMethod(String className, String methodName, String parameterTypeNames,
-			ClassLoader classLoader) {
+	public static MethodSelector selectMethod(ClassLoader classLoader, String className, String methodName,
+			String parameterTypeNames) {
 		Preconditions.notBlank(className, "Class name must not be null or blank");
 		Preconditions.notBlank(methodName, "Method name must not be null or blank");
 		Preconditions.notNull(parameterTypeNames, "Parameter type names must not be null");
-		return new MethodSelector(className, methodName, parameterTypeNames.trim(), classLoader);
+		return new MethodSelector(classLoader, className, methodName, parameterTypeNames.trim());
 	}
 
 	/**
@@ -633,26 +633,26 @@ public final class DiscoverySelectors {
 	 */
 	@API(status = STABLE, since = "1.6")
 	public static NestedClassSelector selectNestedClass(List<String> enclosingClassNames, String nestedClassName) {
-		return selectNestedClass(enclosingClassNames, nestedClassName, (ClassLoader) null);
+		return selectNestedClass((ClassLoader) null, enclosingClassNames, nestedClassName);
 	}
 
 	/**
 	 * Create a {@code NestedClassSelector} for the supplied class name, its enclosing
 	 * classes' names, and class loader.
 	 *
-	 * @param enclosingClassNames the names of the enclosing classes; never {@code null} or empty
-	 * @param nestedClassName the name of the nested class to select; never {@code null} or blank
 	 * @param classLoader the class loader to use to load the enclosing and nested classes, or
 	 * {@code null} to signal that the default {@code ClassLoader} should be used
+	 * @param enclosingClassNames the names of the enclosing classes; never {@code null} or empty
+	 * @param nestedClassName the name of the nested class to select; never {@code null} or blank
 	 * @since 1.10
 	 * @see NestedClassSelector
 	 */
 	@API(status = EXPERIMENTAL, since = "1.10")
-	public static NestedClassSelector selectNestedClass(List<String> enclosingClassNames, String nestedClassName,
-			ClassLoader classLoader) {
+	public static NestedClassSelector selectNestedClass(ClassLoader classLoader, List<String> enclosingClassNames,
+			String nestedClassName) {
 		Preconditions.notEmpty(enclosingClassNames, "Enclosing class names must not be null or empty");
 		Preconditions.notBlank(nestedClassName, "Nested class name must not be null or blank");
-		return new NestedClassSelector(enclosingClassNames, nestedClassName, classLoader);
+		return new NestedClassSelector(classLoader, enclosingClassNames, nestedClassName);
 	}
 
 	/**
@@ -667,25 +667,25 @@ public final class DiscoverySelectors {
 	@API(status = STABLE, since = "1.6")
 	public static NestedMethodSelector selectNestedMethod(List<String> enclosingClassNames, String nestedClassName,
 			String methodName) {
-		return selectNestedMethod(enclosingClassNames, nestedClassName, methodName, (ClassLoader) null);
+		return selectNestedMethod((ClassLoader) null, enclosingClassNames, nestedClassName, methodName);
 	}
 
 	/**
 	 * Create a {@code NestedMethodSelector} for the supplied nested class name, method name,
 	 * and class loader.
 	 *
-	 * @param enclosingClassNames the names of the enclosing classes; never {@code null} or empty
-	 * @param nestedClassName the name of the nested class to select; never {@code null} or blank
-	 * @param methodName the name of the method to select; never {@code null} or blank
 	 * @param classLoader the class loader to use to load the method's declaring
 	 * class, or {@code null} to signal that the default {@code ClassLoader}
 	 * should be used
+	 * @param enclosingClassNames the names of the enclosing classes; never {@code null} or empty
+	 * @param nestedClassName the name of the nested class to select; never {@code null} or blank
+	 * @param methodName the name of the method to select; never {@code null} or blank
 	 * @since 1.10
 	 * @see NestedMethodSelector
 	 */
 	@API(status = EXPERIMENTAL, since = "1.10")
-	public static NestedMethodSelector selectNestedMethod(List<String> enclosingClassNames, String nestedClassName,
-			String methodName, ClassLoader classLoader) throws PreconditionViolationException {
+	public static NestedMethodSelector selectNestedMethod(ClassLoader classLoader, List<String> enclosingClassNames,
+			String nestedClassName, String methodName) throws PreconditionViolationException {
 		Preconditions.notEmpty(enclosingClassNames, "Enclosing class names must not be null or empty");
 		Preconditions.notBlank(nestedClassName, "Nested class name must not be null or blank");
 		Preconditions.notBlank(methodName, "Method name must not be null or blank");
@@ -712,28 +712,29 @@ public final class DiscoverySelectors {
 	@API(status = STABLE, since = "1.6")
 	public static NestedMethodSelector selectNestedMethod(List<String> enclosingClassNames, String nestedClassName,
 			String methodName, String parameterTypeNames) {
-		return selectNestedMethod(enclosingClassNames, nestedClassName, methodName, parameterTypeNames, null);
+		return selectNestedMethod((ClassLoader) null, enclosingClassNames, nestedClassName, methodName,
+			parameterTypeNames);
 	}
 
 	/**
 	 * Create a {@code NestedMethodSelector} for the supplied nested class name, method name,
 	 * parameter type names, and class loader.
 	 *
+	 * @param classLoader the class loader to use to load the method's declaring
+	 * class, or {@code null} to signal that the default {@code ClassLoader}
+	 * should be used
 	 * @param enclosingClassNames the names of the enclosing classes; never {@code null} or empty
 	 * @param nestedClassName the name of the nested class to select; never {@code null} or blank
 	 * @param methodName the name of the method to select; never {@code null} or blank
 	 * @param parameterTypeNames the parameter type names as a single string; never
 	 * {@code null} though potentially an empty string if the method does not declare
 	 * parameters
-	 * @param classLoader the class loader to use to load the method's declaring
-	 * class, or {@code null} to signal that the default {@code ClassLoader}
-	 * should be used
 	 * @since 1.10
 	 * @see #selectNestedMethod(List, String, String, String)
 	 */
 	@API(status = EXPERIMENTAL, since = "1.10")
-	public static NestedMethodSelector selectNestedMethod(List<String> enclosingClassNames, String nestedClassName,
-			String methodName, String parameterTypeNames, ClassLoader classLoader) {
+	public static NestedMethodSelector selectNestedMethod(ClassLoader classLoader, List<String> enclosingClassNames,
+			String nestedClassName, String methodName, String parameterTypeNames) {
 
 		Preconditions.notEmpty(enclosingClassNames, "Enclosing class names must not be null or empty");
 		Preconditions.notBlank(nestedClassName, "Nested class name must not be null or blank");
diff --git a/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/MethodSelector.java b/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/MethodSelector.java
index 58bd420bf..293b65eee 100644
--- a/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/MethodSelector.java
+++ b/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/MethodSelector.java
@@ -67,7 +67,7 @@ public class MethodSelector implements DiscoverySelector {
 	/**
 	 * @since 1.10
 	 */
-	MethodSelector(String className, String methodName, String parameterTypeNames, ClassLoader classLoader) {
+	MethodSelector(ClassLoader classLoader, String className, String methodName, String parameterTypeNames) {
 		this.classLoader = classLoader;
 		this.className = className;
 		this.methodName = methodName;
@@ -93,6 +93,7 @@ public class MethodSelector implements DiscoverySelector {
 
 	/**
 	 * Get the {@link ClassLoader} used to load the specified class.
+	 *
 	 * @return the {@code ClassLoader}; potentially {@code null}
 	 * @since 1.10
 	 */
diff --git a/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/NestedClassSelector.java b/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/NestedClassSelector.java
index 877ed2820..154f74179 100644
--- a/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/NestedClassSelector.java
+++ b/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/NestedClassSelector.java
@@ -48,26 +48,28 @@ import org.junit.platform.engine.DiscoverySelector;
 @API(status = STABLE, since = "1.6")
 public class NestedClassSelector implements DiscoverySelector {
 
+	private final ClassLoader classLoader;
 	private final List<ClassSelector> enclosingClassSelectors;
 	private final ClassSelector nestedClassSelector;
-	private final ClassLoader classLoader;
 
-	NestedClassSelector(List<String> enclosingClassNames, String nestedClassName, ClassLoader classLoader) {
+	NestedClassSelector(ClassLoader classLoader, List<String> enclosingClassNames, String nestedClassName) {
+		this.classLoader = classLoader;
 		this.enclosingClassSelectors = enclosingClassNames.stream() //
-				.map(className -> new ClassSelector(className, classLoader)) //
+				.map(className -> new ClassSelector(classLoader, className)) //
 				.collect(toUnmodifiableList());
-		this.nestedClassSelector = new ClassSelector(nestedClassName, classLoader);
-		this.classLoader = classLoader;
+		this.nestedClassSelector = new ClassSelector(classLoader, nestedClassName);
 	}
 
 	NestedClassSelector(List<Class<?>> enclosingClasses, Class<?> nestedClass) {
+		this.classLoader = nestedClass.getClassLoader();
 		this.enclosingClassSelectors = enclosingClasses.stream().map(ClassSelector::new).collect(toList());
 		this.nestedClassSelector = new ClassSelector(nestedClass);
-		this.classLoader = nestedClass.getClassLoader();
 	}
 
 	/**
 	 * Get the {@link ClassLoader} used to load the selected nested class.
+	 *
+	 * @return the {@code ClassLoader}; potentially {@code null}
 	 * @since 1.10
 	 */
 	@API(status = EXPERIMENTAL, since = "1.10")
diff --git a/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/NestedMethodSelector.java b/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/NestedMethodSelector.java
index aeb6f28fa..215b44792 100644
--- a/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/NestedMethodSelector.java
+++ b/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/NestedMethodSelector.java
@@ -59,8 +59,8 @@ public class NestedMethodSelector implements DiscoverySelector {
 
 	NestedMethodSelector(List<String> enclosingClassNames, String nestedClassName, String methodName,
 			String parameterTypeNames, ClassLoader classLoader) {
-		this.nestedClassSelector = new NestedClassSelector(enclosingClassNames, nestedClassName, classLoader);
-		this.methodSelector = new MethodSelector(nestedClassName, methodName, parameterTypeNames, classLoader);
+		this.nestedClassSelector = new NestedClassSelector(classLoader, enclosingClassNames, nestedClassName);
+		this.methodSelector = new MethodSelector(classLoader, nestedClassName, methodName, parameterTypeNames);
 	}
 
 	NestedMethodSelector(List<Class<?>> enclosingClasses, Class<?> nestedClass, String methodName) {
diff --git a/platform-tests/src/test/java/org/junit/platform/engine/discovery/ClassSelectorTests.java b/platform-tests/src/test/java/org/junit/platform/engine/discovery/ClassSelectorTests.java
index 16a0215f2..2280fa817 100644
--- a/platform-tests/src/test/java/org/junit/platform/engine/discovery/ClassSelectorTests.java
+++ b/platform-tests/src/test/java/org/junit/platform/engine/discovery/ClassSelectorTests.java
@@ -27,16 +27,16 @@ class ClassSelectorTests extends AbstractEqualsAndHashCodeTests {
 
 	@Test
 	void equalsAndHashCode() {
-		var selector1 = new ClassSelector("org.example.TestClass", null);
-		var selector2 = new ClassSelector("org.example.TestClass", null);
-		var selector3 = new ClassSelector("org.example.X", null);
+		var selector1 = new ClassSelector(null, "org.example.TestClass");
+		var selector2 = new ClassSelector(null, "org.example.TestClass");
+		var selector3 = new ClassSelector(null, "org.example.X");
 
 		assertEqualsAndHashCode(selector1, selector2, selector3);
 	}
 
 	@Test
 	void preservesOriginalExceptionWhenTryingToLoadClass() {
-		var selector = new ClassSelector("org.example.TestClass", null);
+		var selector = new ClassSelector(null, "org.example.TestClass");
 
 		var e = assertThrows(PreconditionViolationException.class, selector::getJavaClass);
 
diff --git a/platform-tests/src/test/java/org/junit/platform/engine/discovery/DiscoverySelectorsTests.java b/platform-tests/src/test/java/org/junit/platform/engine/discovery/DiscoverySelectorsTests.java
index 205e16d7c..a2e4af211 100644
--- a/platform-tests/src/test/java/org/junit/platform/engine/discovery/DiscoverySelectorsTests.java
+++ b/platform-tests/src/test/java/org/junit/platform/engine/discovery/DiscoverySelectorsTests.java
@@ -316,7 +316,7 @@ class DiscoverySelectorsTests {
 		@Test
 		void selectClassByNameAndClassLoader() throws Exception {
 			try (var testClassLoader = TestClassLoader.forClasses(getClass())) {
-				var selector = selectClass(getClass().getName(), testClassLoader);
+				var selector = selectClass(testClassLoader, getClass().getName());
 
 				assertThat(selector.getJavaClass().getName()).isEqualTo(getClass().getName());
 				assertThat(selector.getJavaClass()).isNotEqualTo(getClass());
@@ -419,7 +419,7 @@ class DiscoverySelectorsTests {
 				assertThat(clazz).isNotEqualTo(testClass());
 
 				var method = clazz.getDeclaredMethod("myTest");
-				var selector = selectMethod(testClass().getName(), "myTest", testClassLoader);
+				var selector = selectMethod(testClassLoader, testClass().getName(), "myTest");
 				assertThat(selector.getJavaMethod()).isEqualTo(method);
 				assertThat(selector.getJavaClass()).isEqualTo(clazz);
 				assertThat(selector.getClassName()).isEqualTo(clazz.getName());
@@ -755,7 +755,7 @@ class DiscoverySelectorsTests {
 				AbstractClassWithNestedInnerClass.NestedClass.class);
 
 			try (var testClassLoader = TestClassLoader.forClasses(testClasses)) {
-				var selector = selectNestedClass(List.of(enclosingClassName), nestedClassName, testClassLoader);
+				var selector = selectNestedClass(testClassLoader, List.of(enclosingClassName), nestedClassName);
 
 				assertThat(selector.getEnclosingClasses()).doesNotContain(ClassWithNestedInnerClass.class);
 				assertThat(selector.getEnclosingClasses()).extracting(Class::getName).containsOnly(enclosingClassName);
@@ -810,8 +810,8 @@ class DiscoverySelectorsTests {
 				AbstractClassWithNestedInnerClass.NestedClass.class);
 
 			try (var testClassLoader = TestClassLoader.forClasses(testClasses)) {
-				var selector = selectNestedMethod(List.of(enclosingClassName), nestedClassName, methodName,
-					testClassLoader);
+				var selector = selectNestedMethod(testClassLoader, List.of(enclosingClassName), nestedClassName,
+					methodName);
 
 				assertThat(selector.getEnclosingClasses()).doesNotContain(ClassWithNestedInnerClass.class);
 				assertThat(selector.getEnclosingClasses()).extracting(Class::getName).containsOnly(enclosingClassName);
@@ -862,8 +862,8 @@ class DiscoverySelectorsTests {
 				AbstractClassWithNestedInnerClass.NestedClass.class);
 
 			try (var testClassLoader = TestClassLoader.forClasses(testClasses.toArray(Class[]::new))) {
-				var selector = selectNestedMethod(List.of(enclosingClassName), nestedClassName, methodName,
-					String.class.getName(), testClassLoader);
+				var selector = selectNestedMethod(testClassLoader, List.of(enclosingClassName), nestedClassName,
+					methodName, String.class.getName());
 
 				assertThat(selector.getEnclosingClasses()).doesNotContain(ClassWithNestedInnerClass.class);
 				assertThat(selector.getEnclosingClasses()).extracting(Class::getName).containsOnly(enclosingClassName);
diff --git a/platform-tests/src/test/java/org/junit/platform/engine/discovery/MethodSelectorTests.java b/platform-tests/src/test/java/org/junit/platform/engine/discovery/MethodSelectorTests.java
index 6d67ecf1c..9f314ef7d 100644
--- a/platform-tests/src/test/java/org/junit/platform/engine/discovery/MethodSelectorTests.java
+++ b/platform-tests/src/test/java/org/junit/platform/engine/discovery/MethodSelectorTests.java
@@ -32,25 +32,25 @@ class MethodSelectorTests extends AbstractEqualsAndHashCodeTests {
 
 	@Test
 	void equalsAndHashCode() {
-		var selector1 = new MethodSelector(TEST_CASE_NAME, "method", "int, boolean", null);
-		var selector2 = new MethodSelector(TEST_CASE_NAME, "method", "int, boolean", null);
+		var selector1 = new MethodSelector(null, TEST_CASE_NAME, "method", "int, boolean");
+		var selector2 = new MethodSelector(null, TEST_CASE_NAME, "method", "int, boolean");
 		var selector3 = new MethodSelector(TestCase.class, "method", "int, boolean");
 
 		Stream.of(selector2, selector3).forEach(selector -> {
-			assertEqualsAndHashCode(selector1, selector, new MethodSelector(TEST_CASE_NAME, "method", "int", null));
+			assertEqualsAndHashCode(selector1, selector, new MethodSelector(null, TEST_CASE_NAME, "method", "int"));
 			assertEqualsAndHashCode(selector1, selector,
-				new MethodSelector(TEST_CASE_NAME, "method", "", (ClassLoader) null));
-			assertEqualsAndHashCode(selector1, selector, new MethodSelector(TEST_CASE_NAME, "X", "int, boolean", null));
+				new MethodSelector((ClassLoader) null, TEST_CASE_NAME, "method", ""));
+			assertEqualsAndHashCode(selector1, selector, new MethodSelector(null, TEST_CASE_NAME, "X", "int, boolean"));
 			assertEqualsAndHashCode(selector1, selector,
-				new MethodSelector(TEST_CASE_NAME, "X", "", (ClassLoader) null));
-			assertEqualsAndHashCode(selector1, selector, new MethodSelector("X", "method", "int, boolean", null));
-			assertEqualsAndHashCode(selector1, selector, new MethodSelector("X", "method", "", (ClassLoader) null));
+				new MethodSelector((ClassLoader) null, TEST_CASE_NAME, "X", ""));
+			assertEqualsAndHashCode(selector1, selector, new MethodSelector(null, "X", "method", "int, boolean"));
+			assertEqualsAndHashCode(selector1, selector, new MethodSelector((ClassLoader) null, "X", "method", ""));
 		});
 	}
 
 	@Test
 	void preservesOriginalExceptionWhenTryingToLoadJavaClass() {
-		var selector = new MethodSelector("org.example.BogusClass", "method", "int, boolean", (ClassLoader) null);
+		var selector = new MethodSelector((ClassLoader) null, "org.example.BogusClass", "method", "int, boolean");
 
 		assertThat(selector.getClassName()).isEqualTo("org.example.BogusClass");
 		assertThat(selector.getMethodName()).isEqualTo("method");
@@ -64,7 +64,7 @@ class MethodSelectorTests extends AbstractEqualsAndHashCodeTests {
 
 	@Test
 	void preservesOriginalExceptionWhenTryingToLoadClassForParameterType() {
-		var selector = new MethodSelector(TEST_CASE_NAME, "method", "int[], org.example.Bogus", (ClassLoader) null);
+		var selector = new MethodSelector((ClassLoader) null, TEST_CASE_NAME, "method", "int[], org.example.Bogus");
 
 		assertThat(selector.getClassName()).isEqualTo(TEST_CASE_NAME);
 		assertThat(selector.getMethodName()).isEqualTo("method");
diff --git a/platform-tests/src/test/java/org/junit/platform/engine/discovery/NestedClassSelectorTests.java b/platform-tests/src/test/java/org/junit/platform/engine/discovery/NestedClassSelectorTests.java
index 7d80b25e5..93fe50b6f 100644
--- a/platform-tests/src/test/java/org/junit/platform/engine/discovery/NestedClassSelectorTests.java
+++ b/platform-tests/src/test/java/org/junit/platform/engine/discovery/NestedClassSelectorTests.java
@@ -29,19 +29,19 @@ class NestedClassSelectorTests extends AbstractEqualsAndHashCodeTests {
 
 	@Test
 	void equalsAndHashCode() {
-		var selector1 = new NestedClassSelector(List.of("org.example.EnclosingTestClass"),
-			"org.example.NestedTestClass", null);
-		var selector2 = new NestedClassSelector(List.of("org.example.EnclosingTestClass"),
-			"org.example.NestedTestClass", null);
-		var selector3 = new NestedClassSelector(List.of("org.example.X"), "org.example.Y", null);
+		var selector1 = new NestedClassSelector(null, List.of("org.example.EnclosingTestClass"),
+			"org.example.NestedTestClass");
+		var selector2 = new NestedClassSelector(null, List.of("org.example.EnclosingTestClass"),
+			"org.example.NestedTestClass");
+		var selector3 = new NestedClassSelector(null, List.of("org.example.X"), "org.example.Y");
 
 		assertEqualsAndHashCode(selector1, selector2, selector3);
 	}
 
 	@Test
 	void preservesOriginalExceptionWhenTryingToLoadEnclosingClasses() {
-		var selector = new NestedClassSelector(List.of("org.example.EnclosingTestClass"), "org.example.NestedTestClass",
-			null);
+		var selector = new NestedClassSelector(null, List.of("org.example.EnclosingTestClass"),
+			"org.example.NestedTestClass");
 
 		var exception = assertThrows(PreconditionViolationException.class, selector::getEnclosingClasses);
 
@@ -51,8 +51,8 @@ class NestedClassSelectorTests extends AbstractEqualsAndHashCodeTests {
 
 	@Test
 	void preservesOriginalExceptionWhenTryingToLoadNestedClass() {
-		var selector = new NestedClassSelector(List.of("org.example.EnclosingTestClass"), "org.example.NestedTestClass",
-			null);
+		var selector = new NestedClassSelector(null, List.of("org.example.EnclosingTestClass"),
+			"org.example.NestedTestClass");
 
 		var exception = assertThrows(PreconditionViolationException.class, selector::getNestedClass);
 
