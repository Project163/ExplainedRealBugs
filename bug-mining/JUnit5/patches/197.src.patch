diff --git a/junit-platform-console/src/main/java/org/junit/platform/console/tasks/TreeNode.java b/junit-platform-console/src/main/java/org/junit/platform/console/tasks/TreeNode.java
index cb67423cf..a0e5ae574 100644
--- a/junit-platform-console/src/main/java/org/junit/platform/console/tasks/TreeNode.java
+++ b/junit-platform-console/src/main/java/org/junit/platform/console/tasks/TreeNode.java
@@ -10,10 +10,9 @@
 
 package org.junit.platform.console.tasks;
 
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
 import java.util.Optional;
+import java.util.Queue;
+import java.util.concurrent.ConcurrentLinkedQueue;
 
 import org.junit.platform.engine.TestExecutionResult;
 import org.junit.platform.engine.reporting.ReportEntry;
@@ -30,8 +29,8 @@ class TreeNode {
 	private String reason;
 	private TestIdentifier identifier;
 	private TestExecutionResult result;
-	List<ReportEntry> reports = Collections.emptyList();
-	List<TreeNode> children = Collections.emptyList();
+	final Queue<ReportEntry> reports = new ConcurrentLinkedQueue<>();
+	final Queue<TreeNode> children = new ConcurrentLinkedQueue<>();
 	boolean visible;
 
 	TreeNode(String caption) {
@@ -52,17 +51,11 @@ class TreeNode {
 	}
 
 	TreeNode addChild(TreeNode node) {
-		if (children == Collections.EMPTY_LIST) {
-			children = new ArrayList<>();
-		}
 		children.add(node);
 		return this;
 	}
 
 	TreeNode addReportEntry(ReportEntry reportEntry) {
-		if (reports == Collections.EMPTY_LIST) {
-			reports = new ArrayList<>();
-		}
 		reports.add(reportEntry);
 		return this;
 	}
diff --git a/platform-tests/src/test/java/org/junit/platform/console/tasks/TreeNodeTests.java b/platform-tests/src/test/java/org/junit/platform/console/tasks/TreeNodeTests.java
new file mode 100644
index 000000000..04f9c294e
--- /dev/null
+++ b/platform-tests/src/test/java/org/junit/platform/console/tasks/TreeNodeTests.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright 2015-2018 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * http://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.platform.console.tasks;
+
+import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+import java.util.concurrent.ArrayBlockingQueue;
+import java.util.concurrent.CyclicBarrier;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.ThreadPoolExecutor;
+
+import org.junit.jupiter.api.Test;
+import org.junit.platform.engine.reporting.ReportEntry;
+
+class TreeNodeTests {
+
+	private static final int NUM_THREADS = 2;
+	private static final int ITEMS_PER_THREAD = 1000;
+
+	@Test
+	void childrenCanBeAddedConcurrently() throws Exception {
+		TreeNode treeNode = new TreeNode("root");
+
+		runConcurrently(() -> {
+			for (long i = 0; i < ITEMS_PER_THREAD; i++) {
+				treeNode.addChild(new TreeNode(String.valueOf(i)));
+			}
+		});
+
+		assertThat(treeNode.children.size()).isEqualTo(NUM_THREADS * ITEMS_PER_THREAD);
+	}
+
+	@Test
+	void reportEntriesCanBeAddedConcurrently() throws Exception {
+		TreeNode treeNode = new TreeNode("root");
+
+		runConcurrently(() -> {
+			for (long i = 0; i < ITEMS_PER_THREAD; i++) {
+				treeNode.addReportEntry(ReportEntry.from("index", String.valueOf(i)));
+			}
+		});
+
+		assertThat(treeNode.reports.size()).isEqualTo(NUM_THREADS * ITEMS_PER_THREAD);
+	}
+
+	private void runConcurrently(Runnable action) throws InterruptedException {
+		ExecutorService executor = new ThreadPoolExecutor(NUM_THREADS, NUM_THREADS, 10, SECONDS,
+			new ArrayBlockingQueue<>(NUM_THREADS));
+		try {
+			CyclicBarrier barrier = new CyclicBarrier(NUM_THREADS);
+			for (long i = 0; i < NUM_THREADS; i++) {
+				executor.submit(() -> {
+					await(barrier);
+					action.run();
+				});
+			}
+		}
+		finally {
+			executor.shutdown();
+			boolean terminated = executor.awaitTermination(10, SECONDS);
+			assertTrue(terminated, "Executor was not terminated");
+		}
+	}
+
+	private void await(CyclicBarrier barrier) {
+		try {
+			barrier.await();
+		}
+		catch (Exception e) {
+			throw new RuntimeException(e);
+		}
+	}
+}
