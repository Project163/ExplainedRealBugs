diff --git a/documentation/src/docs/asciidoc/link-attributes.adoc b/documentation/src/docs/asciidoc/link-attributes.adoc
index e02c578cf..de75ec74c 100644
--- a/documentation/src/docs/asciidoc/link-attributes.adoc
+++ b/documentation/src/docs/asciidoc/link-attributes.adoc
@@ -80,6 +80,7 @@ endif::[]
 :ExtendWith:                                 {javadoc-root}/org/junit/jupiter/api/extension/ExtendWith.html[@ExtendWith]
 :ExtensionContext:                           {javadoc-root}/org/junit/jupiter/api/extension/ExtensionContext.html[ExtensionContext]
 :ExtensionContext_Store:                     {javadoc-root}/org/junit/jupiter/api/extension/ExtensionContext.Store.html[Store]
+:InvocationInterceptor:                      {javadoc-root}/org/junit/jupiter/api/extension/InvocationInterceptor.html[InvocationInterceptor]
 :ParameterResolver:                          {javadoc-root}/org/junit/jupiter/api/extension/ParameterResolver.html[ParameterResolver]
 :RegisterExtension:                          {javadoc-root}/org/junit/jupiter/api/extension/RegisterExtension.html[@RegisterExtension]
 :TestExecutionExceptionHandler:              {javadoc-root}/org/junit/jupiter/api/extension/TestExecutionExceptionHandler.html[TestExecutionExceptionHandler]
diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.5.0-M2.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.5.0-M2.adoc
index b950b5d61..ddaae25ff 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.5.0-M2.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.5.0-M2.adoc
@@ -47,6 +47,9 @@ on GitHub.
 * New `emptyValue` attribute in `@CsvFileSource` and `@CsvSource`.
 * All methods in the `TestWatcher` API are now interface `default` methods with empty
   implementations.
+* New `InvocationInterceptor` extension API (see
+  <<../user-guide/index.adoc#extensions-intercepting-invocations, User Guide>> for
+  details)
 
 
 [[release-notes-5.5.0-M2-junit-vintage]]
diff --git a/documentation/src/docs/asciidoc/user-guide/extensions.adoc b/documentation/src/docs/asciidoc/user-guide/extensions.adoc
index 7859a4e49..3b6160c01 100644
--- a/documentation/src/docs/asciidoc/user-guide/extensions.adoc
+++ b/documentation/src/docs/asciidoc/user-guide/extensions.adoc
@@ -445,6 +445,21 @@ but rethrow any other type of exception.
 include::{testDir}/example/exception/IgnoreIOExceptionExtension.java[tags=user_guide]
 ----
 
+[[extensions-intercepting-invocations]]
+=== Intercepting Invocations
+
+`{InvocationInterceptor}` defines the API for `Extensions` that wish to intercept calls to
+test code.
+
+The following example shows an extension that executes all test methods in Swing's Event
+Dispatch Thread.
+
+[source,java,indent=0]
+.An extension that executes tests in a user-defined thread
+----
+include::{testDir}/example/interceptor/SwingEdtInterceptor.java[tags=user_guide]
+----
+
 [[extensions-test-templates]]
 === Providing Invocation Contexts for Test Templates
 
@@ -631,6 +646,9 @@ steps are optional depending on the presence of user code or extension support f
 corresponding lifecycle callback. For further details on the various lifecycle callbacks
 please consult the respective Javadoc for each annotation and extension.
 
+All invocations of user code methods in the above table can additionally be intercepted
+by implementing <<extensions-intercepting-invocations, `InvocationInterceptor`>>.
+
 [[extensions-execution-order-wrapping-behavior]]
 ==== Wrapping Behavior of Callbacks
 
diff --git a/documentation/src/test/java/example/interceptor/SwingEdtInterceptor.java b/documentation/src/test/java/example/interceptor/SwingEdtInterceptor.java
new file mode 100644
index 000000000..001b1ce18
--- /dev/null
+++ b/documentation/src/test/java/example/interceptor/SwingEdtInterceptor.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2015-2019 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package example.interceptor;
+
+import java.lang.reflect.Method;
+import java.util.concurrent.atomic.AtomicReference;
+
+import javax.swing.SwingUtilities;
+
+import org.junit.jupiter.api.extension.ExtensionContext;
+import org.junit.jupiter.api.extension.InvocationInterceptor;
+import org.junit.jupiter.api.extension.ReflectiveInvocationContext;
+
+// @formatter:off
+// tag::user_guide[]
+public class SwingEdtInterceptor implements InvocationInterceptor {
+
+	@Override
+	public void interceptTestMethod(Invocation<Void> invocation,
+			ReflectiveInvocationContext<Method> invocationContext,
+			ExtensionContext extensionContext) throws Throwable {
+		AtomicReference<Throwable> throwable = new AtomicReference<>();
+		SwingUtilities.invokeAndWait(() -> {
+			try {
+				invocation.proceed();
+			}
+			catch (Throwable t) {
+				throwable.set(t);
+			}
+		});
+		Throwable t = throwable.get();
+		if (t != null) {
+			throw t;
+		}
+	}
+}
+// end::user_guide[]
+// @formatter:on
diff --git a/gradle/testing.gradle.kts b/gradle/testing.gradle.kts
index c2208fe78..476d63058 100644
--- a/gradle/testing.gradle.kts
+++ b/gradle/testing.gradle.kts
@@ -14,15 +14,14 @@ tasks.named<Test>("test").configure {
 }
 
 dependencies {
+	"testImplementation"(project(":junit-jupiter-api"))
+	"testImplementation"(project(":junit-jupiter-params"))
 	"testImplementation"("org.assertj:assertj-core:${Versions.assertJ}")
 	"testImplementation"("org.mockito:mockito-junit-jupiter:${Versions.mockito}") {
 		exclude(module = "junit-jupiter-engine")
 	}
 
 	if (project.name != "junit-jupiter-engine") {
-		"testImplementation"(project(":junit-jupiter-api"))
-		"testImplementation"(project(":junit-jupiter-params"))
-
 		"testRuntimeOnly"(project(":junit-jupiter-engine"))
 	}
 
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/InvocationInterceptor.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/InvocationInterceptor.java
new file mode 100644
index 000000000..1a2ca8914
--- /dev/null
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/InvocationInterceptor.java
@@ -0,0 +1,212 @@
+/*
+ * Copyright 2015-2019 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.api.extension;
+
+import static org.apiguardian.api.API.Status.EXPERIMENTAL;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Method;
+
+import org.apiguardian.api.API;
+import org.junit.jupiter.api.AfterAll;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.DynamicTest;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.TestFactory;
+import org.junit.jupiter.api.TestTemplate;
+
+/**
+ * {@code InvocationInterceptor} defines the API for {@link Extension
+ * Extensions} that wish to intercept calls to test code.
+ *
+ * <h3>Invocation Contract</h3>
+ *
+ * <p>Each method in this class must execute the supplied {@linkplain Invocation
+ * invocation} exactly once. Otherwise, the enclosing test or container will be
+ * reported as failed.
+ *
+ * <p>The default implementation simply calls {@link Invocation#proceed()
+ * proceed()} on the supplied {@linkplain Invocation invocation}.
+ *
+ * <h3>Constructor Requirements</h3>
+ *
+ * <p>Consult the documentation in {@link Extension} for details on
+ * constructor requirements.
+ *
+ * @since 5.5
+ * @see Invocation
+ * @see ReflectiveInvocationContext
+ * @see ExtensionContext
+ */
+@API(status = EXPERIMENTAL, since = "5.5")
+public interface InvocationInterceptor extends Extension {
+
+	/**
+	 * Intercept the invocation of a test class constructor.
+	 *
+	 * @param invocation the invocation that is being intercepted; never
+	 * {@code null}
+	 * @param invocationContext the context of the invocation that is being
+	 * intercepted; never {@code null}
+	 * @param extensionContext the current extension context; never {@code null}
+	 * @param <T> the result type
+	 * @return the result of the invocation; never {@code null}
+	 * @throws Throwable in case of failure
+	 */
+	default <T> T interceptTestClassConstructor(Invocation<T> invocation,
+			ReflectiveInvocationContext<Constructor<T>> invocationContext, ExtensionContext extensionContext)
+			throws Throwable {
+		return invocation.proceed();
+	}
+
+	/**
+	 * Intercept the invocation of a {@link BeforeAll @BeforeAll} method.
+	 *
+	 * @param invocation the invocation that is being intercepted; never
+	 * {@code null}
+	 * @param invocationContext the context of the invocation that is being
+	 * intercepted; never {@code null}
+	 * @param extensionContext the current extension context; never {@code null}
+	 * @throws Throwable in case of failures
+	 */
+	default void interceptBeforeAllMethod(Invocation<Void> invocation,
+			ReflectiveInvocationContext<Method> invocationContext, ExtensionContext extensionContext) throws Throwable {
+		invocation.proceed();
+	}
+
+	/**
+	 * Intercept the invocation of a {@link BeforeEach @BeforeEach} method.
+	 *
+	 * @param invocation the invocation that is being intercepted; never
+	 * {@code null}
+	 * @param invocationContext the context of the invocation that is being
+	 * intercepted; never {@code null}
+	 * @param extensionContext the current extension context; never {@code null}
+	 * @throws Throwable in case of failures
+	 */
+	default void interceptBeforeEachMethod(Invocation<Void> invocation,
+			ReflectiveInvocationContext<Method> invocationContext, ExtensionContext extensionContext) throws Throwable {
+		invocation.proceed();
+	}
+
+	/**
+	 * Intercept the invocation of a {@link Test @Test} method.
+	 *
+	 * @param invocation the invocation that is being intercepted; never
+	 * {@code null}
+	 * @param invocationContext the context of the invocation that is being
+	 * intercepted; never {@code null}
+	 * @param extensionContext the current extension context; never {@code null}
+	 * @throws Throwable in case of failures
+	 */
+	default void interceptTestMethod(Invocation<Void> invocation, ReflectiveInvocationContext<Method> invocationContext,
+			ExtensionContext extensionContext) throws Throwable {
+		invocation.proceed();
+	}
+
+	/**
+	 * Intercept the invocation of a {@link TestFactory @TestFactory} method.
+	 *
+	 * @param invocation the invocation that is being intercepted; never
+	 * {@code null}
+	 * @param invocationContext the context of the invocation that is being
+	 * intercepted; never {@code null}
+	 * @param extensionContext the current extension context; never {@code null}
+	 * @param <T> the result type
+	 * @return the result of the invocation; potentially {@code null}
+	 * @throws Throwable in case of failures
+	 */
+	default <T> T interceptTestFactoryMethod(Invocation<T> invocation,
+			ReflectiveInvocationContext<Method> invocationContext, ExtensionContext extensionContext) throws Throwable {
+		return invocation.proceed();
+	}
+
+	/**
+	 * Intercept the invocation of a {@link TestTemplate @TestTemplate} method.
+	 *
+	 * @param invocation the invocation that is being intercepted; never
+	 * {@code null}
+	 * @param invocationContext the context of the invocation that is being
+	 * intercepted; never {@code null}
+	 * @param extensionContext the current extension context; never {@code null}
+	 * @throws Throwable in case of failures
+	 */
+	default void interceptTestTemplateMethod(Invocation<Void> invocation,
+			ReflectiveInvocationContext<Method> invocationContext, ExtensionContext extensionContext) throws Throwable {
+		invocation.proceed();
+	}
+
+	/**
+	 * Intercept the invocation of a {@link DynamicTest}.
+	 *
+	 * @param invocation the invocation that is being intercepted; never
+	 * {@code null}
+	 * @param extensionContext the current extension context; never {@code null}
+	 * @throws Throwable in case of failures
+	 */
+	default void interceptDynamicTest(Invocation<Void> invocation, ExtensionContext extensionContext) throws Throwable {
+		invocation.proceed();
+	}
+
+	/**
+	 * Intercept the invocation of an {@link AfterEach @AfterEach} method.
+	 *
+	 * @param invocation the invocation that is being intercepted; never
+	 * {@code null}
+	 * @param invocationContext the context of the invocation that is being
+	 * intercepted; never {@code null}
+	 * @param extensionContext the current extension context; never {@code null}
+	 * @throws Throwable in case of failures
+	 */
+	default void interceptAfterEachMethod(Invocation<Void> invocation,
+			ReflectiveInvocationContext<Method> invocationContext, ExtensionContext extensionContext) throws Throwable {
+		invocation.proceed();
+	}
+
+	/**
+	 * Intercept the invocation of an {@link AfterAll @AfterAll} method.
+	 *
+	 * @param invocation the invocation that is being intercepted; never
+	 * {@code null}
+	 * @param invocationContext the context of the invocation that is being
+	 * intercepted; never {@code null}
+	 * @param extensionContext the current extension context; never {@code null}
+	 * @throws Throwable in case of failures
+	 */
+	default void interceptAfterAllMethod(Invocation<Void> invocation,
+			ReflectiveInvocationContext<Method> invocationContext, ExtensionContext extensionContext) throws Throwable {
+		invocation.proceed();
+	}
+
+	/**
+	 * An invocation that returns a result and may throw a {@link Throwable}.
+	 *
+	 * <p>This interface is not intended to be implemented by clients.
+	 *
+	 * @param <T> the result type
+	 * @since 5.5
+	 */
+	@API(status = EXPERIMENTAL, since = "5.5")
+	interface Invocation<T> {
+
+		/**
+		 * Proceed with this invocation.
+		 *
+		 * @return the result of this invocation; potentially {@code null}.
+		 * @throws Throwable in case the invocation failed
+		 */
+		T proceed() throws Throwable;
+
+	}
+
+}
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ReflectiveInvocationContext.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ReflectiveInvocationContext.java
new file mode 100644
index 000000000..327d4d78a
--- /dev/null
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ReflectiveInvocationContext.java
@@ -0,0 +1,74 @@
+/*
+ * Copyright 2015-2019 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.api.extension;
+
+import static org.apiguardian.api.API.Status.EXPERIMENTAL;
+
+import java.lang.reflect.Executable;
+import java.util.List;
+import java.util.Optional;
+
+import org.apiguardian.api.API;
+
+/**
+ * {@code ReflectiveInvocationContext} encapsulates the <em>context</em> of
+ * a reflective invocation of an executable (method or constructor).
+ *
+ * <p>This interface is not intended to be implemented by clients.
+ *
+ * @since 5.5
+ */
+@API(status = EXPERIMENTAL, since = "5.5")
+public interface ReflectiveInvocationContext<T extends Executable> {
+
+	/**
+	 * Get the target class of this invocation context.
+	 *
+	 * <p>If this invocation context represents an instance method, this
+	 * method returns the class of the object the method will be invoked on,
+	 * not the class it is declared in. Otherwise, if this invocation
+	 * represents a static method or constructor, this method returns the
+	 * class the method or constructor is declared in.
+	 *
+	 * @return the target class of this invocation context; never
+	 * {@code null}
+	 */
+	Class<?> getTargetClass();
+
+	/**
+	 * Get the method or constructor of this invocation context.
+	 *
+	 * @return the executable of this invocation context; never {@code null}
+	 */
+	T getExecutable();
+
+	/**
+	 * Get the arguments of the executable in this invocation context.
+	 *
+	 * @return the arguments of the executable in this invocation context;
+	 * immutable and never {@code null}
+	 */
+	List<Object> getArguments();
+
+	/**
+	 * Get the target object of this invocation context, if available.
+	 *
+	 * <p>If this invocation context represents an instance method, this
+	 * method returns the object the method will be invoked on. Otherwise,
+	 * if this invocation context represents a static method or
+	 * constructor, this method returns {@link Optional#empty() empty()}.
+	 *
+	 * @return the target of the executable of this invocation context; never
+	 * {@code null} but potentially empty
+	 */
+	Optional<Object> getTarget();
+
+}
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTestDescriptor.java
index f1ff5b10b..1a65e3638 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTestDescriptor.java
@@ -40,20 +40,25 @@ import org.junit.jupiter.api.extension.BeforeAllCallback;
 import org.junit.jupiter.api.extension.Extension;
 import org.junit.jupiter.api.extension.ExtensionConfigurationException;
 import org.junit.jupiter.api.extension.ExtensionContext;
+import org.junit.jupiter.api.extension.InvocationInterceptor;
 import org.junit.jupiter.api.extension.TestInstanceFactory;
 import org.junit.jupiter.api.extension.TestInstancePostProcessor;
 import org.junit.jupiter.api.extension.TestInstances;
 import org.junit.jupiter.api.extension.TestInstantiationException;
+import org.junit.jupiter.api.function.Executable;
 import org.junit.jupiter.engine.config.JupiterConfiguration;
 import org.junit.jupiter.engine.execution.AfterEachMethodAdapter;
 import org.junit.jupiter.engine.execution.BeforeEachMethodAdapter;
 import org.junit.jupiter.engine.execution.DefaultTestInstances;
 import org.junit.jupiter.engine.execution.ExecutableInvoker;
+import org.junit.jupiter.engine.execution.ExecutableInvoker.ReflectiveInterceptorCall;
+import org.junit.jupiter.engine.execution.ExecutableInvoker.ReflectiveInterceptorCall.VoidMethodInterceptorCall;
 import org.junit.jupiter.engine.execution.JupiterEngineExecutionContext;
 import org.junit.jupiter.engine.execution.TestInstancesProvider;
 import org.junit.jupiter.engine.extension.ExtensionRegistry;
 import org.junit.platform.commons.JUnitException;
 import org.junit.platform.commons.util.BlacklistedExceptions;
+import org.junit.platform.commons.util.ExceptionUtils;
 import org.junit.platform.commons.util.ReflectionUtils;
 import org.junit.platform.commons.util.StringUtils;
 import org.junit.platform.engine.TestDescriptor;
@@ -341,9 +346,8 @@ public class ClassTestDescriptor extends JupiterTestDescriptor {
 			ExtensionContext extensionContext) {
 
 		Constructor<?> constructor = ReflectionUtils.getDeclaredConstructor(this.testClass);
-		return outerInstance.isPresent() //
-				? executableInvoker.invoke(constructor, outerInstance.get(), extensionContext, registry) //
-				: executableInvoker.invoke(constructor, extensionContext, registry);
+		return executableInvoker.invoke(constructor, outerInstance, extensionContext, registry,
+			InvocationInterceptor::interceptTestClassConstructor);
 	}
 
 	private void invokeTestInstancePostProcessors(Object instance, ExtensionRegistry registry,
@@ -353,6 +357,15 @@ public class ClassTestDescriptor extends JupiterTestDescriptor {
 			extension -> executeAndMaskThrowable(() -> extension.postProcessTestInstance(instance, context)));
 	}
 
+	private void executeAndMaskThrowable(Executable executable) {
+		try {
+			executable.execute();
+		}
+		catch (Throwable throwable) {
+			ExceptionUtils.throwAsUncheckedException(throwable);
+		}
+	}
+
 	private void invokeBeforeAllCallbacks(JupiterEngineExecutionContext context) {
 		ExtensionRegistry registry = context.getExtensionRegistry();
 		ExtensionContext extensionContext = context.getExtensionContext();
@@ -373,8 +386,8 @@ public class ClassTestDescriptor extends JupiterTestDescriptor {
 		Object testInstance = extensionContext.getTestInstance().orElse(null);
 
 		for (Method method : this.beforeAllMethods) {
-			throwableCollector.execute(
-				() -> executableInvoker.invoke(method, testInstance, extensionContext, registry));
+			throwableCollector.execute(() -> executableInvoker.invoke(method, testInstance, extensionContext, registry,
+				ReflectiveInterceptorCall.ofVoidMethod(InvocationInterceptor::interceptBeforeAllMethod)));
 			if (throwableCollector.isNotEmpty()) {
 				break;
 			}
@@ -387,8 +400,9 @@ public class ClassTestDescriptor extends JupiterTestDescriptor {
 		ThrowableCollector throwableCollector = context.getThrowableCollector();
 		Object testInstance = extensionContext.getTestInstance().orElse(null);
 
-		this.afterAllMethods.forEach(method -> throwableCollector.execute(
-			() -> executableInvoker.invoke(method, testInstance, extensionContext, registry)));
+		this.afterAllMethods.forEach(
+			method -> throwableCollector.execute(() -> executableInvoker.invoke(method, testInstance, extensionContext,
+				registry, ReflectiveInterceptorCall.ofVoidMethod(InvocationInterceptor::interceptAfterAllMethod))));
 	}
 
 	private void invokeAfterAllCallbacks(JupiterEngineExecutionContext context) {
@@ -425,19 +439,23 @@ public class ClassTestDescriptor extends JupiterTestDescriptor {
 	}
 
 	private BeforeEachMethodAdapter synthesizeBeforeEachMethodAdapter(Method method) {
-		return (extensionContext, registry) -> invokeMethodInExtensionContext(method, extensionContext, registry);
+		return (extensionContext, registry) -> invokeMethodInExtensionContext(method, extensionContext, registry,
+			InvocationInterceptor::interceptBeforeEachMethod);
 	}
 
 	private AfterEachMethodAdapter synthesizeAfterEachMethodAdapter(Method method) {
-		return (extensionContext, registry) -> invokeMethodInExtensionContext(method, extensionContext, registry);
+		return (extensionContext, registry) -> invokeMethodInExtensionContext(method, extensionContext, registry,
+			InvocationInterceptor::interceptAfterEachMethod);
 	}
 
-	private void invokeMethodInExtensionContext(Method method, ExtensionContext context, ExtensionRegistry registry) {
+	private void invokeMethodInExtensionContext(Method method, ExtensionContext context, ExtensionRegistry registry,
+			VoidMethodInterceptorCall interceptorCall) {
 		TestInstances testInstances = context.getRequiredTestInstances();
 		Object target = testInstances.findInstance(method.getDeclaringClass()).orElseThrow(
 			() -> new JUnitException("Failed to find instance for method: " + method.toGenericString()));
 
-		executableInvoker.invoke(method, target, context, registry);
+		executableInvoker.invoke(method, target, context, registry,
+			ReflectiveInterceptorCall.ofVoidMethod(interceptorCall));
 	}
 
 }
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DynamicExtensionContext.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DynamicExtensionContext.java
new file mode 100644
index 000000000..f3e71da47
--- /dev/null
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DynamicExtensionContext.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright 2015-2019 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.engine.descriptor;
+
+import java.lang.reflect.AnnotatedElement;
+import java.lang.reflect.Method;
+import java.util.Optional;
+
+import org.junit.jupiter.api.TestInstance;
+import org.junit.jupiter.api.extension.ExtensionContext;
+import org.junit.jupiter.api.extension.TestInstances;
+import org.junit.jupiter.engine.config.JupiterConfiguration;
+import org.junit.platform.engine.EngineExecutionListener;
+
+public class DynamicExtensionContext extends AbstractExtensionContext<DynamicNodeTestDescriptor> {
+
+	DynamicExtensionContext(ExtensionContext parent, EngineExecutionListener engineExecutionListener,
+			DynamicNodeTestDescriptor testDescriptor, JupiterConfiguration configuration) {
+		super(parent, engineExecutionListener, testDescriptor, configuration);
+	}
+
+	@Override
+	public Optional<AnnotatedElement> getElement() {
+		return Optional.empty();
+	}
+
+	@Override
+	public Optional<Class<?>> getTestClass() {
+		return Optional.empty();
+	}
+
+	@Override
+	public Optional<TestInstance.Lifecycle> getTestInstanceLifecycle() {
+		return Optional.empty();
+	}
+
+	@Override
+	public Optional<Object> getTestInstance() {
+		return Optional.empty();
+	}
+
+	@Override
+	public Optional<TestInstances> getTestInstances() {
+		return Optional.empty();
+	}
+
+	@Override
+	public Optional<Method> getTestMethod() {
+		return Optional.empty();
+	}
+
+	@Override
+	public Optional<Throwable> getExecutionException() {
+		return Optional.empty();
+	}
+}
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DynamicNodeTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DynamicNodeTestDescriptor.java
index 9c9aa1eb4..77270d257 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DynamicNodeTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DynamicNodeTestDescriptor.java
@@ -43,12 +43,18 @@ abstract class DynamicNodeTestDescriptor extends JupiterTestDescriptor {
 	}
 
 	@Override
-	public JupiterEngineExecutionContext prepare(JupiterEngineExecutionContext context) throws Exception {
-		return context.extend().withExtensionContext(null).build();
+	public JupiterEngineExecutionContext prepare(JupiterEngineExecutionContext context) {
+		DynamicExtensionContext extensionContext = new DynamicExtensionContext(context.getExtensionContext(),
+			context.getExecutionListener(), this, context.getConfiguration());
+		// @formatter:off
+		return context.extend()
+				.withExtensionContext(extensionContext)
+				.build();
+		// @formatter:on
 	}
 
 	@Override
-	public SkipResult shouldBeSkipped(JupiterEngineExecutionContext context) throws Exception {
+	public SkipResult shouldBeSkipped(JupiterEngineExecutionContext context) {
 		return SkipResult.doNotSkip();
 	}
 
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DynamicTestTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DynamicTestTestDescriptor.java
index b524dafbd..03ce45f1d 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DynamicTestTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DynamicTestTestDescriptor.java
@@ -11,8 +11,13 @@
 package org.junit.jupiter.engine.descriptor;
 
 import org.junit.jupiter.api.DynamicTest;
+import org.junit.jupiter.api.extension.ExtensionContext;
+import org.junit.jupiter.api.extension.InvocationInterceptor;
 import org.junit.jupiter.engine.config.JupiterConfiguration;
+import org.junit.jupiter.engine.execution.InvocationInterceptorChain;
+import org.junit.jupiter.engine.execution.InvocationInterceptorChain.InterceptorCall;
 import org.junit.jupiter.engine.execution.JupiterEngineExecutionContext;
+import org.junit.jupiter.engine.extension.ExtensionRegistry;
 import org.junit.platform.engine.TestDescriptor;
 import org.junit.platform.engine.TestSource;
 import org.junit.platform.engine.UniqueId;
@@ -24,6 +29,7 @@ import org.junit.platform.engine.UniqueId;
  */
 class DynamicTestTestDescriptor extends DynamicNodeTestDescriptor {
 
+	private static final InvocationInterceptorChain interceptorChain = new InvocationInterceptorChain();
 	private final DynamicTest dynamicTest;
 
 	DynamicTestTestDescriptor(UniqueId uniqueId, int index, DynamicTest dynamicTest, TestSource source,
@@ -39,8 +45,15 @@ class DynamicTestTestDescriptor extends DynamicNodeTestDescriptor {
 
 	@Override
 	public JupiterEngineExecutionContext execute(JupiterEngineExecutionContext context,
-			DynamicTestExecutor dynamicTestExecutor) throws Exception {
-		executeAndMaskThrowable(dynamicTest.getExecutable());
+			DynamicTestExecutor dynamicTestExecutor) {
+		InvocationInterceptor.Invocation<Void> invocation = () -> {
+			dynamicTest.getExecutable().execute();
+			return null;
+		};
+		ExtensionContext extensionContext = context.getExtensionContext();
+		ExtensionRegistry extensionRegistry = context.getExtensionRegistry();
+		interceptorChain.invoke(invocation, extensionRegistry, InterceptorCall.ofVoid(
+			(interceptor, wrappedInvocation) -> interceptor.interceptDynamicTest(wrappedInvocation, extensionContext)));
 		return context;
 	}
 
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/JupiterTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/JupiterTestDescriptor.java
index af895985a..dc04b05f7 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/JupiterTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/JupiterTestDescriptor.java
@@ -28,7 +28,6 @@ import java.util.function.Supplier;
 import org.apiguardian.api.API;
 import org.junit.jupiter.api.Tag;
 import org.junit.jupiter.api.extension.ConditionEvaluationResult;
-import org.junit.jupiter.api.function.Executable;
 import org.junit.jupiter.api.parallel.Execution;
 import org.junit.jupiter.api.parallel.ResourceAccessMode;
 import org.junit.jupiter.api.parallel.ResourceLock;
@@ -38,7 +37,6 @@ import org.junit.jupiter.engine.execution.JupiterEngineExecutionContext;
 import org.junit.platform.commons.JUnitException;
 import org.junit.platform.commons.logging.Logger;
 import org.junit.platform.commons.logging.LoggerFactory;
-import org.junit.platform.commons.util.ExceptionUtils;
 import org.junit.platform.engine.TestDescriptor;
 import org.junit.platform.engine.TestSource;
 import org.junit.platform.engine.TestTag;
@@ -191,21 +189,4 @@ public abstract class JupiterTestDescriptor extends AbstractTestDescriptor
 		context.close();
 	}
 
-	/**
-	 * Execute the supplied {@link Executable} and
-	 * {@linkplain ExceptionUtils#throwAsUncheckedException mask} any
-	 * exception thrown as an unchecked exception.
-	 *
-	 * @param executable the {@code Executable} to execute
-	 * @see ExceptionUtils#throwAsUncheckedException(Throwable)
-	 */
-	protected void executeAndMaskThrowable(Executable executable) {
-		try {
-			executable.execute();
-		}
-		catch (Throwable throwable) {
-			ExceptionUtils.throwAsUncheckedException(throwable);
-		}
-	}
-
 }
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestFactoryTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestFactoryTestDescriptor.java
index 8df14f8ea..1cc80604a 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestFactoryTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestFactoryTestDescriptor.java
@@ -25,8 +25,10 @@ import org.junit.jupiter.api.DynamicContainer;
 import org.junit.jupiter.api.DynamicNode;
 import org.junit.jupiter.api.DynamicTest;
 import org.junit.jupiter.api.extension.ExtensionContext;
+import org.junit.jupiter.api.extension.InvocationInterceptor;
 import org.junit.jupiter.engine.config.JupiterConfiguration;
 import org.junit.jupiter.engine.execution.ExecutableInvoker;
+import org.junit.jupiter.engine.execution.ExecutableInvoker.ReflectiveInterceptorCall;
 import org.junit.jupiter.engine.execution.JupiterEngineExecutionContext;
 import org.junit.platform.commons.JUnitException;
 import org.junit.platform.commons.util.CollectionUtils;
@@ -52,6 +54,7 @@ public class TestFactoryTestDescriptor extends TestMethodTestDescriptor implemen
 	public static final String DYNAMIC_CONTAINER_SEGMENT_TYPE = "dynamic-container";
 	public static final String DYNAMIC_TEST_SEGMENT_TYPE = "dynamic-test";
 
+	private static final ReflectiveInterceptorCall<Method, Object> interceptorCall = InvocationInterceptor::interceptTestFactoryMethod;
 	private static final ExecutableInvoker executableInvoker = new ExecutableInvoker();
 
 	private final DynamicDescendantFilter dynamicDescendantFilter = new DynamicDescendantFilter();
@@ -89,7 +92,7 @@ public class TestFactoryTestDescriptor extends TestMethodTestDescriptor implemen
 		context.getThrowableCollector().execute(() -> {
 			Object instance = extensionContext.getRequiredTestInstance();
 			Object testFactoryMethodResult = executableInvoker.invoke(getTestMethod(), instance, extensionContext,
-				context.getExtensionRegistry());
+				context.getExtensionRegistry(), interceptorCall);
 			TestSource defaultTestSource = getSource().orElseThrow(
 				() -> new JUnitException("Illegal state: TestSource must be present"));
 			try (Stream<DynamicNode> dynamicNodeStream = toDynamicNodeStream(testFactoryMethodResult)) {
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestMethodTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestMethodTestDescriptor.java
index d6019198f..19526d7a4 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestMethodTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestMethodTestDescriptor.java
@@ -27,6 +27,7 @@ import org.junit.jupiter.api.extension.BeforeEachCallback;
 import org.junit.jupiter.api.extension.BeforeTestExecutionCallback;
 import org.junit.jupiter.api.extension.Extension;
 import org.junit.jupiter.api.extension.ExtensionContext;
+import org.junit.jupiter.api.extension.InvocationInterceptor;
 import org.junit.jupiter.api.extension.TestExecutionExceptionHandler;
 import org.junit.jupiter.api.extension.TestInstances;
 import org.junit.jupiter.api.extension.TestWatcher;
@@ -34,6 +35,7 @@ import org.junit.jupiter.engine.config.JupiterConfiguration;
 import org.junit.jupiter.engine.execution.AfterEachMethodAdapter;
 import org.junit.jupiter.engine.execution.BeforeEachMethodAdapter;
 import org.junit.jupiter.engine.execution.ExecutableInvoker;
+import org.junit.jupiter.engine.execution.ExecutableInvoker.ReflectiveInterceptorCall;
 import org.junit.jupiter.engine.execution.JupiterEngineExecutionContext;
 import org.junit.jupiter.engine.extension.ExtensionRegistry;
 import org.junit.platform.commons.logging.Logger;
@@ -71,15 +73,21 @@ public class TestMethodTestDescriptor extends MethodBasedTestDescriptor {
 	public static final String SEGMENT_TYPE = "method";
 	private static final ExecutableInvoker executableInvoker = new ExecutableInvoker();
 	private static final Logger logger = LoggerFactory.getLogger(TestMethodTestDescriptor.class);
+	private static final ReflectiveInterceptorCall<Method, Void> defaultInterceptorCall = ReflectiveInterceptorCall.ofVoidMethod(
+		InvocationInterceptor::interceptTestMethod);
+
+	private final ReflectiveInterceptorCall<Method, Void> interceptorCall;
 
 	public TestMethodTestDescriptor(UniqueId uniqueId, Class<?> testClass, Method testMethod,
 			JupiterConfiguration configuration) {
 		super(uniqueId, testClass, testMethod, configuration);
+		this.interceptorCall = defaultInterceptorCall;
 	}
 
 	TestMethodTestDescriptor(UniqueId uniqueId, String displayName, Class<?> testClass, Method testMethod,
-			JupiterConfiguration configuration) {
+			JupiterConfiguration configuration, ReflectiveInterceptorCall<Method, Void> interceptorCall) {
 		super(uniqueId, displayName, testClass, testMethod, configuration);
+		this.interceptorCall = interceptorCall;
 	}
 
 	@Override
@@ -182,7 +190,8 @@ public class TestMethodTestDescriptor extends MethodBasedTestDescriptor {
 			try {
 				Method testMethod = getTestMethod();
 				Object instance = extensionContext.getRequiredTestInstance();
-				executableInvoker.invoke(testMethod, instance, extensionContext, context.getExtensionRegistry());
+				executableInvoker.invoke(testMethod, instance, extensionContext, context.getExtensionRegistry(),
+					interceptorCall);
 			}
 			catch (Throwable throwable) {
 				BlacklistedExceptions.rethrowIfBlacklisted(throwable);
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestTemplateInvocationTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestTemplateInvocationTestDescriptor.java
index 443e8ef40..01d129c53 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestTemplateInvocationTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestTemplateInvocationTestDescriptor.java
@@ -17,8 +17,10 @@ import java.lang.reflect.Method;
 import java.util.Set;
 
 import org.apiguardian.api.API;
+import org.junit.jupiter.api.extension.InvocationInterceptor;
 import org.junit.jupiter.api.extension.TestTemplateInvocationContext;
 import org.junit.jupiter.engine.config.JupiterConfiguration;
+import org.junit.jupiter.engine.execution.ExecutableInvoker.ReflectiveInterceptorCall;
 import org.junit.jupiter.engine.execution.JupiterEngineExecutionContext;
 import org.junit.jupiter.engine.extension.ExtensionRegistry;
 import org.junit.platform.engine.TestDescriptor;
@@ -35,13 +37,16 @@ import org.junit.platform.engine.support.hierarchical.ExclusiveResource;
 public class TestTemplateInvocationTestDescriptor extends TestMethodTestDescriptor {
 
 	public static final String SEGMENT_TYPE = "test-template-invocation";
+	private static final ReflectiveInterceptorCall<Method, Void> interceptorCall = ReflectiveInterceptorCall.ofVoidMethod(
+		InvocationInterceptor::interceptTestTemplateMethod);
 
 	private TestTemplateInvocationContext invocationContext;
 	private final int index;
 
 	TestTemplateInvocationTestDescriptor(UniqueId uniqueId, Class<?> testClass, Method templateMethod,
 			TestTemplateInvocationContext invocationContext, int index, JupiterConfiguration configuration) {
-		super(uniqueId, invocationContext.getDisplayName(index), testClass, templateMethod, configuration);
+		super(uniqueId, invocationContext.getDisplayName(index), testClass, templateMethod, configuration,
+			interceptorCall);
 		this.invocationContext = invocationContext;
 		this.index = index;
 	}
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/ConstructorInvocation.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/ConstructorInvocation.java
new file mode 100644
index 000000000..4a2308c97
--- /dev/null
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/ConstructorInvocation.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2015-2019 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.engine.execution;
+
+import static java.util.Collections.unmodifiableList;
+
+import java.lang.reflect.Constructor;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Optional;
+
+import org.junit.jupiter.api.extension.InvocationInterceptor.Invocation;
+import org.junit.jupiter.api.extension.ReflectiveInvocationContext;
+import org.junit.platform.commons.util.ReflectionUtils;
+
+class ConstructorInvocation<T> implements Invocation<T>, ReflectiveInvocationContext<Constructor<T>> {
+
+	private final Constructor<T> constructor;
+	private final Object[] arguments;
+
+	ConstructorInvocation(Constructor<T> constructor, Object[] arguments) {
+		this.constructor = constructor;
+		this.arguments = arguments;
+	}
+
+	@Override
+	public Class<?> getTargetClass() {
+		return constructor.getDeclaringClass();
+	}
+
+	@Override
+	public Constructor<T> getExecutable() {
+		return constructor;
+	}
+
+	@Override
+	public List<Object> getArguments() {
+		return unmodifiableList(Arrays.asList(arguments));
+	}
+
+	@Override
+	public Optional<Object> getTarget() {
+		return Optional.empty();
+	}
+
+	@Override
+	public T proceed() {
+		return ReflectionUtils.newInstance(constructor, arguments);
+	}
+}
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/ExecutableInvoker.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/ExecutableInvoker.java
index fe0e880e8..e84da0c36 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/ExecutableInvoker.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/ExecutableInvoker.java
@@ -24,15 +24,17 @@ import java.util.Optional;
 
 import org.apiguardian.api.API;
 import org.junit.jupiter.api.extension.ExtensionContext;
+import org.junit.jupiter.api.extension.InvocationInterceptor;
+import org.junit.jupiter.api.extension.InvocationInterceptor.Invocation;
 import org.junit.jupiter.api.extension.ParameterContext;
 import org.junit.jupiter.api.extension.ParameterResolutionException;
 import org.junit.jupiter.api.extension.ParameterResolver;
+import org.junit.jupiter.api.extension.ReflectiveInvocationContext;
 import org.junit.jupiter.engine.extension.ExtensionRegistry;
 import org.junit.platform.commons.logging.Logger;
 import org.junit.platform.commons.logging.LoggerFactory;
 import org.junit.platform.commons.util.BlacklistedExceptions;
 import org.junit.platform.commons.util.Preconditions;
-import org.junit.platform.commons.util.ReflectionUtils;
 import org.junit.platform.commons.util.StringUtils;
 
 /**
@@ -47,21 +49,7 @@ import org.junit.platform.commons.util.StringUtils;
 public class ExecutableInvoker {
 
 	private static final Logger logger = LoggerFactory.getLogger(ExecutableInvoker.class);
-
-	/**
-	 * Invoke the supplied constructor with dynamic parameter resolution.
-	 *
-	 * @param constructor the constructor to invoke and resolve parameters for
-	 * @param extensionContext the current {@code ExtensionContext}
-	 * @param extensionRegistry the {@code ExtensionRegistry} to retrieve
-	 * {@code ParameterResolvers} from
-	 */
-	public <T> T invoke(Constructor<T> constructor, ExtensionContext extensionContext,
-			ExtensionRegistry extensionRegistry) {
-
-		return ReflectionUtils.newInstance(constructor,
-			resolveParameters(constructor, Optional.empty(), extensionContext, extensionRegistry));
-	}
+	private static final InvocationInterceptorChain interceptorChain = new InvocationInterceptorChain();
 
 	/**
 	 * Invoke the supplied constructor with the supplied outer instance and
@@ -72,16 +60,21 @@ public class ExecutableInvoker {
 	 *
 	 * @param constructor the constructor to invoke and resolve parameters for
 	 * @param outerInstance the outer instance to supply as the first argument
-	 * to the constructor
+	 * to the constructor; empty, for top-level classes
 	 * @param extensionContext the current {@code ExtensionContext}
 	 * @param extensionRegistry the {@code ExtensionRegistry} to retrieve
 	 * {@code ParameterResolvers} from
+	 * @param interceptorCall the call for intercepting this constructor
+	 * invocation via all registered {@linkplain InvocationInterceptor
+	 * interceptors}
 	 */
-	public <T> T invoke(Constructor<T> constructor, Object outerInstance, ExtensionContext extensionContext,
-			ExtensionRegistry extensionRegistry) {
+	public <T> T invoke(Constructor<T> constructor, Optional<Object> outerInstance, ExtensionContext extensionContext,
+			ExtensionRegistry extensionRegistry, ReflectiveInterceptorCall<Constructor<T>, T> interceptorCall) {
 
-		return ReflectionUtils.newInstance(constructor,
-			resolveParameters(constructor, Optional.empty(), outerInstance, extensionContext, extensionRegistry));
+		Object[] arguments = resolveParameters(constructor, Optional.empty(), outerInstance, extensionContext,
+			extensionRegistry);
+		ConstructorInvocation<T> invocation = new ConstructorInvocation<>(constructor, arguments);
+		return invoke(invocation, invocation, extensionContext, extensionRegistry, interceptorCall);
 	}
 
 	/**
@@ -91,37 +84,51 @@ public class ExecutableInvoker {
 	 * @param extensionContext the current {@code ExtensionContext}
 	 * @param extensionRegistry the {@code ExtensionRegistry} to retrieve
 	 * {@code ParameterResolvers} from
+	 * @param interceptorCall the call for intercepting this method invocation
+	 * via all registered {@linkplain InvocationInterceptor interceptors}
 	 */
-	public Object invoke(Method method, ExtensionContext extensionContext, ExtensionRegistry extensionRegistry) {
-		return ReflectionUtils.invokeMethod(method, null,
-			resolveParameters(method, Optional.empty(), extensionContext, extensionRegistry));
-	}
-
-	/**
-	 * Invoke the supplied method on the supplied target object with dynamic parameter
-	 * resolution.
-	 *
-	 * @param method the method to invoke and resolve parameters for
-	 * @param target the object on which the method will be invoked; should be
-	 * {@code null} for static methods
-	 * @param extensionContext the current {@code ExtensionContext}
-	 * @param extensionRegistry the {@code ExtensionRegistry} to retrieve
-	 * {@code ParameterResolvers} from
-	 */
-	public Object invoke(Method method, Object target, ExtensionContext extensionContext,
-			ExtensionRegistry extensionRegistry) {
+	public <T> T invoke(Method method, Object target, ExtensionContext extensionContext,
+			ExtensionRegistry extensionRegistry, ReflectiveInterceptorCall<Method, T> interceptorCall) {
 
 		@SuppressWarnings("unchecked")
 		Optional<Object> optionalTarget = (target instanceof Optional ? (Optional<Object>) target
 				: Optional.ofNullable(target));
-		return ReflectionUtils.invokeMethod(method, target,
-			resolveParameters(method, optionalTarget, extensionContext, extensionRegistry));
+		Object[] arguments = resolveParameters(method, optionalTarget, extensionContext, extensionRegistry);
+		MethodInvocation<T> invocation = new MethodInvocation<>(method, optionalTarget, arguments);
+		return invoke(invocation, invocation, extensionContext, extensionRegistry, interceptorCall);
+	}
+
+	private <E extends Executable, T> T invoke(Invocation<T> originalInvocation,
+			ReflectiveInvocationContext<E> invocationContext, ExtensionContext extensionContext,
+			ExtensionRegistry extensionRegistry, ReflectiveInterceptorCall<E, T> call) {
+		return interceptorChain.invoke(originalInvocation, extensionRegistry, (interceptor,
+				wrappedInvocation) -> call.apply(interceptor, wrappedInvocation, invocationContext, extensionContext));
+	}
+
+	public interface ReflectiveInterceptorCall<E extends Executable, T> {
+
+		T apply(InvocationInterceptor interceptor, Invocation<T> invocation,
+				ReflectiveInvocationContext<E> invocationContext, ExtensionContext extensionContext) throws Throwable;
+
+		static ReflectiveInterceptorCall<Method, Void> ofVoidMethod(VoidMethodInterceptorCall call) {
+			return ((interceptorChain, invocation, invocationContext, extensionContext) -> {
+				call.apply(interceptorChain, invocation, invocationContext, extensionContext);
+				return null;
+			});
+		}
+
+		interface VoidMethodInterceptorCall {
+			void apply(InvocationInterceptor interceptor, Invocation<Void> invocation,
+					ReflectiveInvocationContext<Method> invocationContext, ExtensionContext extensionContext)
+					throws Throwable;
+		}
+
 	}
 
 	/**
-	 * Resolve the array of parameters for the supplied executable and target.
+	 * Resolve the array of parameters for the supplied method and target.
 	 *
-	 * @param executable the executable for which to resolve parameters
+	 * @param method the method for which to resolve parameters
 	 * @param target an {@code Optional} containing the target on which the
 	 * executable will be invoked; never {@code null} but should be empty for
 	 * static methods and constructors
@@ -131,10 +138,10 @@ public class ExecutableInvoker {
 	 * @return the array of Objects to be used as parameters in the executable
 	 * invocation; never {@code null} though potentially empty
 	 */
-	private Object[] resolveParameters(Executable executable, Optional<Object> target,
-			ExtensionContext extensionContext, ExtensionRegistry extensionRegistry) {
+	private Object[] resolveParameters(Method method, Optional<Object> target, ExtensionContext extensionContext,
+			ExtensionRegistry extensionRegistry) {
 
-		return resolveParameters(executable, target, null, extensionContext, extensionRegistry);
+		return resolveParameters(method, target, Optional.empty(), extensionContext, extensionRegistry);
 	}
 
 	/**
@@ -154,7 +161,7 @@ public class ExecutableInvoker {
 	 * @return the array of Objects to be used as parameters in the executable
 	 * invocation; never {@code null} though potentially empty
 	 */
-	private Object[] resolveParameters(Executable executable, Optional<Object> target, Object outerInstance,
+	private Object[] resolveParameters(Executable executable, Optional<Object> target, Optional<Object> outerInstance,
 			ExtensionContext extensionContext, ExtensionRegistry extensionRegistry) {
 
 		Preconditions.notNull(target, "target must not be null");
@@ -165,8 +172,8 @@ public class ExecutableInvoker {
 
 		// Ensure that the outer instance is resolved as the first parameter if
 		// the executable is a constructor for an inner class.
-		if (outerInstance != null) {
-			values[0] = outerInstance;
+		if (outerInstance.isPresent()) {
+			values[0] = outerInstance.get();
 			start = 1;
 		}
 
@@ -263,5 +270,4 @@ public class ExecutableInvoker {
 	private static String asLabel(Executable executable) {
 		return executable instanceof Constructor ? "constructor" : "method";
 	}
-
 }
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/InvocationInterceptorChain.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/InvocationInterceptorChain.java
new file mode 100644
index 000000000..9b69f603c
--- /dev/null
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/InvocationInterceptorChain.java
@@ -0,0 +1,142 @@
+/*
+ * Copyright 2015-2019 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.engine.execution;
+
+import static java.util.stream.Collectors.joining;
+import static org.apiguardian.api.API.Status.INTERNAL;
+
+import java.lang.reflect.Executable;
+import java.util.List;
+import java.util.ListIterator;
+import java.util.concurrent.atomic.AtomicBoolean;
+
+import org.apiguardian.api.API;
+import org.junit.jupiter.api.extension.InvocationInterceptor;
+import org.junit.jupiter.api.extension.InvocationInterceptor.Invocation;
+import org.junit.jupiter.engine.extension.ExtensionRegistry;
+import org.junit.platform.commons.JUnitException;
+import org.junit.platform.commons.util.ExceptionUtils;
+
+@API(status = INTERNAL, since = "5.5")
+public class InvocationInterceptorChain {
+
+	public <E extends Executable, T> T invoke(Invocation<T> invocation, ExtensionRegistry extensionRegistry,
+			InterceptorCall<T> call) {
+		List<InvocationInterceptor> interceptors = extensionRegistry.getExtensions(InvocationInterceptor.class);
+		if (interceptors.isEmpty()) {
+			return proceed(invocation);
+		}
+		return chainAndInvoke(invocation, call, interceptors);
+	}
+
+	private <E extends Executable, T> T chainAndInvoke(Invocation<T> invocation, InterceptorCall<T> call,
+			List<InvocationInterceptor> interceptors) {
+		ValidatingInvocation<T> validatingInvocation = new ValidatingInvocation<>(invocation, interceptors);
+		Invocation<T> chainedInvocation = chainInterceptors(validatingInvocation, call, interceptors);
+		T result = proceed(chainedInvocation);
+		validatingInvocation.verifyInvokedAtLeastOnce();
+		return result;
+	}
+
+	private <E extends Executable, T> Invocation<T> chainInterceptors(Invocation<T> invocation, InterceptorCall<T> call,
+			List<InvocationInterceptor> interceptors) {
+		Invocation<T> result = invocation;
+		ListIterator<InvocationInterceptor> iterator = interceptors.listIterator(interceptors.size());
+		while (iterator.hasPrevious()) {
+			InvocationInterceptor interceptor = iterator.previous();
+			result = new InterceptedInvocation<>(result, call, interceptor);
+		}
+		return result;
+	}
+
+	private <T> T proceed(Invocation<T> invocation) {
+		try {
+			return invocation.proceed();
+		}
+		catch (Throwable t) {
+			throw ExceptionUtils.throwAsUncheckedException(t);
+		}
+	}
+
+	@FunctionalInterface
+	public interface InterceptorCall<T> {
+
+		T apply(InvocationInterceptor interceptor, Invocation<T> invocation) throws Throwable;
+
+		static <E extends Executable> InterceptorCall<Void> ofVoid(VoidInterceptorCall call) {
+			return ((interceptorChain, invocation) -> {
+				call.apply(interceptorChain, invocation);
+				return null;
+			});
+		}
+
+	}
+
+	@FunctionalInterface
+	public interface VoidInterceptorCall {
+
+		void apply(InvocationInterceptor interceptor, Invocation<Void> invocation) throws Throwable;
+
+	}
+
+	private static class InterceptedInvocation<T> implements Invocation<T> {
+
+		private final Invocation<T> invocation;
+		private final InterceptorCall<T> call;
+		private final InvocationInterceptor interceptor;
+
+		InterceptedInvocation(Invocation<T> invocation, InterceptorCall<T> call, InvocationInterceptor interceptor) {
+			this.invocation = invocation;
+			this.call = call;
+			this.interceptor = interceptor;
+		}
+
+		@Override
+		public T proceed() throws Throwable {
+			return call.apply(interceptor, invocation);
+		}
+
+	}
+
+	private static class ValidatingInvocation<T> implements Invocation<T> {
+
+		private final AtomicBoolean invoked = new AtomicBoolean();
+		private final Invocation<T> delegate;
+		private final List<InvocationInterceptor> interceptors;
+
+		ValidatingInvocation(Invocation<T> delegate, List<InvocationInterceptor> interceptors) {
+			this.delegate = delegate;
+			this.interceptors = interceptors;
+		}
+
+		@Override
+		public T proceed() throws Throwable {
+			if (!invoked.compareAndSet(false, true)) {
+				fail("Chain of InvocationInterceptors called invocation multiple times instead of just once");
+			}
+			return delegate.proceed();
+		}
+
+		void verifyInvokedAtLeastOnce() {
+			if (!invoked.get()) {
+				fail("Chain of InvocationInterceptors never called invocation");
+			}
+		}
+
+		private void fail(String prefix) {
+			String commaSeparatedInterceptorClasses = interceptors.stream().map(Object::getClass).map(
+				Class::getName).collect(joining(", "));
+			throw new JUnitException(prefix + ": " + commaSeparatedInterceptorClasses);
+		}
+
+	}
+
+}
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/MethodInvocation.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/MethodInvocation.java
new file mode 100644
index 000000000..cab28ba4a
--- /dev/null
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/execution/MethodInvocation.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright 2015-2019 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.engine.execution;
+
+import static java.util.Collections.unmodifiableList;
+
+import java.lang.reflect.Method;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Optional;
+
+import org.junit.jupiter.api.extension.InvocationInterceptor.Invocation;
+import org.junit.jupiter.api.extension.ReflectiveInvocationContext;
+import org.junit.platform.commons.util.ReflectionUtils;
+
+class MethodInvocation<T> implements Invocation<T>, ReflectiveInvocationContext<Method> {
+
+	protected final Method method;
+	protected final Optional<Object> target;
+	protected final Object[] arguments;
+
+	MethodInvocation(Method method, Optional<Object> target, Object[] arguments) {
+		this.method = method;
+		this.target = target;
+		this.arguments = arguments;
+	}
+
+	@Override
+	public Class<?> getTargetClass() {
+		return target.<Class<?>> map(Object::getClass).orElseGet(method::getDeclaringClass);
+	}
+
+	@Override
+	@SuppressWarnings("unchecked")
+	public Optional<Object> getTarget() {
+		return target;
+	}
+
+	@Override
+	public Method getExecutable() {
+		return method;
+	}
+
+	@Override
+	public List<Object> getArguments() {
+		return unmodifiableList(Arrays.asList(arguments));
+	}
+
+	@Override
+	@SuppressWarnings("unchecked")
+	public T proceed() {
+		return (T) ReflectionUtils.invokeMethod(method, target.orElse(null), arguments);
+	}
+
+}
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/extension/KitchenSinkExtension.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/extension/KitchenSinkExtension.java
index 0a255f9c5..4c4d773ed 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/extension/KitchenSinkExtension.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/extension/KitchenSinkExtension.java
@@ -52,7 +52,8 @@ public class KitchenSinkExtension implements
 	TestTemplateInvocationContextProvider,
 
 	// Miscellaneous
-	TestWatcher
+	TestWatcher,
+	InvocationInterceptor
 
 // @formatter:on
 {
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/descriptor/TestFactoryTestDescriptorTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/descriptor/TestFactoryTestDescriptorTests.java
index 01ec57a04..d0a0b4b28 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/descriptor/TestFactoryTestDescriptorTests.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/descriptor/TestFactoryTestDescriptorTests.java
@@ -29,6 +29,7 @@ import org.junit.jupiter.api.TestFactory;
 import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.engine.config.JupiterConfiguration;
 import org.junit.jupiter.engine.execution.JupiterEngineExecutionContext;
+import org.junit.jupiter.engine.extension.ExtensionRegistry;
 import org.junit.platform.engine.TestSource;
 import org.junit.platform.engine.UniqueId;
 import org.junit.platform.engine.support.descriptor.ClasspathResourceSource;
@@ -121,8 +122,12 @@ class TestFactoryTestDescriptorTests {
 			extensionContext = mock(ExtensionContext.class);
 			isClosed = false;
 
-			context = new JupiterEngineExecutionContext(null, null).extend().withThrowableCollector(
-				new OpenTest4JAwareThrowableCollector()).withExtensionContext(extensionContext).build();
+			context = new JupiterEngineExecutionContext(null, null) //
+					.extend() //
+					.withThrowableCollector(new OpenTest4JAwareThrowableCollector()) //
+					.withExtensionContext(extensionContext) //
+					.withExtensionRegistry(mock(ExtensionRegistry.class)) //
+					.build();
 
 			Method testMethod = CustomStreamTestCase.class.getDeclaredMethod("customStream");
 			descriptor = new TestFactoryTestDescriptor(UniqueId.forEngine("engine"), CustomStreamTestCase.class,
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/execution/ExecutableInvokerTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/execution/ExecutableInvokerTests.java
index e650387be..a815594b9 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/execution/ExecutableInvokerTests.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/execution/ExecutableInvokerTests.java
@@ -19,8 +19,10 @@ import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 
 import java.lang.reflect.Constructor;
+import java.lang.reflect.Executable;
 import java.lang.reflect.Method;
 import java.math.BigDecimal;
+import java.util.Optional;
 import java.util.function.Function;
 import java.util.function.Predicate;
 import java.util.regex.Pattern;
@@ -31,6 +33,7 @@ import org.junit.jupiter.api.extension.ParameterContext;
 import org.junit.jupiter.api.extension.ParameterResolutionException;
 import org.junit.jupiter.api.extension.ParameterResolver;
 import org.junit.jupiter.engine.config.JupiterConfiguration;
+import org.junit.jupiter.engine.execution.ExecutableInvoker.ReflectiveInterceptorCall;
 import org.junit.jupiter.engine.extension.ExtensionRegistry;
 import org.junit.platform.commons.util.ReflectionUtils;
 
@@ -58,7 +61,8 @@ class ExecutableInvokerTests {
 
 		Class<ConstructorInjectionTestCase> outerClass = ConstructorInjectionTestCase.class;
 		Constructor<ConstructorInjectionTestCase> constructor = ReflectionUtils.getDeclaredConstructor(outerClass);
-		ConstructorInjectionTestCase outer = newInvoker().invoke(constructor, extensionContext, extensionRegistry);
+		ConstructorInjectionTestCase outer = newInvoker().invoke(constructor, Optional.empty(), extensionContext,
+			extensionRegistry, passthroughInterceptor());
 
 		assertNotNull(outer);
 		assertEquals(ENIGMA, outer.str);
@@ -66,8 +70,8 @@ class ExecutableInvokerTests {
 		Class<ConstructorInjectionTestCase.NestedTestCase> innerClass = ConstructorInjectionTestCase.NestedTestCase.class;
 		Constructor<ConstructorInjectionTestCase.NestedTestCase> innerConstructor = ReflectionUtils.getDeclaredConstructor(
 			innerClass);
-		ConstructorInjectionTestCase.NestedTestCase inner = newInvoker().invoke(innerConstructor, outer,
-			extensionContext, extensionRegistry);
+		ConstructorInjectionTestCase.NestedTestCase inner = newInvoker().invoke(innerConstructor, Optional.of(outer),
+			extensionContext, extensionRegistry, passthroughInterceptor());
 
 		assertNotNull(inner);
 		assertEquals(42, inner.num);
@@ -78,8 +82,8 @@ class ExecutableInvokerTests {
 		Constructor<ConstructorInjectionTestCase> constructor = ReflectionUtils.getDeclaredConstructor(
 			ConstructorInjectionTestCase.class);
 
-		Exception exception = assertThrows(ParameterResolutionException.class,
-			() -> newInvoker().invoke(constructor, extensionContext, extensionRegistry));
+		Exception exception = assertThrows(ParameterResolutionException.class, () -> newInvoker().invoke(constructor,
+			Optional.empty(), extensionContext, extensionRegistry, passthroughInterceptor()));
 
 		assertThat(exception.getMessage())//
 				.contains("No ParameterResolver registered for parameter [java.lang.String")//
@@ -88,9 +92,9 @@ class ExecutableInvokerTests {
 	}
 
 	@Test
-	void invokingMethodsWithoutParameterDoesNotDependOnExtensions() {
+	void invokingMethodsWithoutParameterDoesNotDependOnParameterResolvers() {
 		testMethodWithNoParameters();
-		extensionRegistry = null;
+		throwDuringParameterResolution(new RuntimeException("boom!"));
 
 		invokeMethod();
 
@@ -315,7 +319,12 @@ class ExecutableInvokerTests {
 	}
 
 	private void invokeMethod() {
-		newInvoker().invoke(this.method, this.instance, this.extensionContext, this.extensionRegistry);
+		newInvoker().invoke(this.method, this.instance, this.extensionContext, this.extensionRegistry,
+			passthroughInterceptor());
+	}
+
+	static <E extends Executable, T> ReflectiveInterceptorCall<E, T> passthroughInterceptor() {
+		return (interceptor, invocation, invocationContext, extensionContext) -> invocation.proceed();
 	}
 
 	// -------------------------------------------------------------------------
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/InvocationInterceptorTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/InvocationInterceptorTests.java
new file mode 100644
index 000000000..7d8a0c21f
--- /dev/null
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/InvocationInterceptorTests.java
@@ -0,0 +1,331 @@
+/*
+ * Copyright 2015-2019 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.engine.extension;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.DynamicTest.dynamicTest;
+import static org.junit.platform.testkit.engine.EventConditions.event;
+import static org.junit.platform.testkit.engine.EventConditions.finishedWithFailure;
+import static org.junit.platform.testkit.engine.EventConditions.test;
+import static org.junit.platform.testkit.engine.TestExecutionResultConditions.instanceOf;
+import static org.junit.platform.testkit.engine.TestExecutionResultConditions.message;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Method;
+import java.util.EnumSet;
+import java.util.stream.Stream;
+
+import org.junit.jupiter.api.AfterAll;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.DynamicTest;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.TestFactory;
+import org.junit.jupiter.api.TestReporter;
+import org.junit.jupiter.api.extension.ExtendWith;
+import org.junit.jupiter.api.extension.Extension;
+import org.junit.jupiter.api.extension.ExtensionContext;
+import org.junit.jupiter.api.extension.InvocationInterceptor;
+import org.junit.jupiter.api.extension.ReflectiveInvocationContext;
+import org.junit.jupiter.api.extension.RegisterExtension;
+import org.junit.jupiter.engine.AbstractJupiterTestEngineTests;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.EnumSource;
+import org.junit.jupiter.params.provider.ValueSource;
+import org.junit.platform.commons.JUnitException;
+import org.junit.platform.engine.reporting.ReportEntry;
+import org.junit.platform.testkit.engine.EngineExecutionResults;
+
+class InvocationInterceptorTests extends AbstractJupiterTestEngineTests {
+
+	@Test
+	void failsTestWhenInterceptorChainDoesNotCallInvocation() {
+		var results = executeTestsForClass(InvocationIgnoringInterceptorTestCase.class);
+
+		var tests = results.tests().assertStatistics(stats -> stats.failed(1).succeeded(0));
+		tests.failed().assertEventsMatchExactly(
+			event(test("test"), finishedWithFailure(instanceOf(JUnitException.class),
+				message(it -> it.startsWith("Chain of InvocationInterceptors never called invocation")))));
+	}
+
+	static class InvocationIgnoringInterceptorTestCase {
+		@RegisterExtension
+		Extension interceptor = new InvocationInterceptor() {
+			@Override
+			public void interceptTestMethod(Invocation<Void> invocation,
+					ReflectiveInvocationContext<Method> invocationContext, ExtensionContext extensionContext) {
+				// do nothing
+			}
+		};
+
+		@Test
+		void test() {
+			// never called
+		}
+	}
+
+	@Test
+	void failsTestWhenInterceptorChainCallsInvocationMoreThanOnce() {
+		var results = executeTestsForClass(DoubleInvocationInterceptorTestCase.class);
+
+		var tests = results.tests().assertStatistics(stats -> stats.failed(1).succeeded(0));
+		tests.failed().assertEventsMatchExactly(
+			event(test("test"), finishedWithFailure(instanceOf(JUnitException.class), message(it -> it.startsWith(
+				"Chain of InvocationInterceptors called invocation multiple times instead of just once")))));
+	}
+
+	static class DoubleInvocationInterceptorTestCase {
+		@RegisterExtension
+		Extension interceptor = new InvocationInterceptor() {
+			@Override
+			public void interceptTestMethod(Invocation<Void> invocation,
+					ReflectiveInvocationContext<Method> invocationContext, ExtensionContext extensionContext)
+					throws Throwable {
+				invocation.proceed();
+				invocation.proceed();
+			}
+		};
+
+		@Test
+		void test() {
+			// called twice
+		}
+	}
+
+	@ParameterizedTest
+	@EnumSource(InvocationType.class)
+	void callsInterceptors(InvocationType invocationType) {
+		var results = executeTestsForClass(TestCaseWithThreeInterceptors.class);
+
+		results.tests().assertStatistics(stats -> stats.failed(0).succeeded(4));
+		assertThat(getEvents(results, EnumSet.of(invocationType)).distinct()) //
+				.containsExactly("before:foo", "before:bar", "before:baz", "test", "after:baz", "after:bar",
+					"after:foo");
+	}
+
+	private Stream<String> getEvents(EngineExecutionResults results, EnumSet<InvocationType> types) {
+		return results.all().reportingEntryPublished() //
+				.map(event -> event.getPayload(ReportEntry.class).orElseThrow()) //
+				.map(ReportEntry::getKeyValuePairs) //
+				.filter(map -> map.keySet().stream().map(InvocationType::valueOf).anyMatch(types::contains)) //
+				.flatMap(map -> map.values().stream());
+	}
+
+	@ExtendWith({ FooInvocationInterceptor.class, BarInvocationInterceptor.class, BazInvocationInterceptor.class })
+	static class TestCaseWithThreeInterceptors {
+
+		public TestCaseWithThreeInterceptors(TestReporter reporter) {
+			publish(reporter, InvocationType.CONSTRUCTOR);
+		}
+
+		@BeforeAll
+		static void beforeAll(TestReporter reporter) {
+			publish(reporter, InvocationType.BEFORE_ALL);
+		}
+
+		@BeforeEach
+		void beforeEach(TestReporter reporter) {
+			publish(reporter, InvocationType.BEFORE_EACH);
+		}
+
+		@Test
+		void test(TestReporter reporter) {
+			publish(reporter, InvocationType.TEST_METHOD);
+		}
+
+		@ParameterizedTest
+		@ValueSource(ints = { 0, 1 })
+		void testTemplate(int i, TestReporter reporter) {
+			publish(reporter, InvocationType.TEST_TEMPLATE_METHOD);
+		}
+
+		@TestFactory
+		DynamicTest testFactory(TestReporter reporter) {
+			publish(reporter, InvocationType.TEST_FACTORY_METHOD);
+			return dynamicTest("dynamicTest", () -> {
+				publish(reporter, InvocationType.DYNAMIC_TEST);
+			});
+		}
+
+		@AfterEach
+		void afterEach(TestReporter reporter) {
+			publish(reporter, InvocationType.AFTER_EACH);
+		}
+
+		@AfterAll
+		static void afterAll(TestReporter reporter) {
+			publish(reporter, InvocationType.AFTER_ALL);
+		}
+
+		static void publish(TestReporter reporter, InvocationType type) {
+			reporter.publishEntry(type.name(), "test");
+		}
+
+	}
+
+	enum InvocationType {
+		BEFORE_ALL,
+		CONSTRUCTOR,
+		BEFORE_EACH,
+		TEST_METHOD,
+		TEST_TEMPLATE_METHOD,
+		TEST_FACTORY_METHOD,
+		DYNAMIC_TEST,
+		AFTER_EACH,
+		AFTER_ALL
+	}
+
+	abstract static class ReportingInvocationInterceptor implements InvocationInterceptor {
+		private final Class<TestCaseWithThreeInterceptors> testClass = TestCaseWithThreeInterceptors.class;
+		private final String name;
+
+		ReportingInvocationInterceptor(String name) {
+			this.name = name;
+		}
+
+		@Override
+		public void interceptBeforeAllMethod(Invocation<Void> invocation,
+				ReflectiveInvocationContext<Method> invocationContext, ExtensionContext extensionContext)
+				throws Throwable {
+			assertEquals(testClass, invocationContext.getTargetClass());
+			assertThat(invocationContext.getTarget()).isEmpty();
+			assertEquals(testClass.getDeclaredMethod("beforeAll", TestReporter.class),
+				invocationContext.getExecutable());
+			assertThat(invocationContext.getArguments()).hasSize(1).hasOnlyElementsOfType(TestReporter.class);
+			reportAndProceed(invocation, extensionContext, InvocationType.BEFORE_ALL);
+		}
+
+		@Override
+		public <T> T interceptTestClassConstructor(Invocation<T> invocation,
+				ReflectiveInvocationContext<Constructor<T>> invocationContext, ExtensionContext extensionContext)
+				throws Throwable {
+			assertEquals(testClass, invocationContext.getTargetClass());
+			assertEquals(testClass.getDeclaredConstructor(TestReporter.class), invocationContext.getExecutable());
+			assertThat(invocationContext.getArguments()).hasSize(1).hasOnlyElementsOfType(TestReporter.class);
+			return reportAndProceed(invocation, extensionContext, InvocationType.CONSTRUCTOR);
+		}
+
+		@Override
+		public void interceptBeforeEachMethod(Invocation<Void> invocation,
+				ReflectiveInvocationContext<Method> invocationContext, ExtensionContext extensionContext)
+				throws Throwable {
+			assertEquals(testClass, invocationContext.getTargetClass());
+			assertThat(invocationContext.getTarget()).containsInstanceOf(testClass);
+			assertEquals(testClass.getDeclaredMethod("beforeEach", TestReporter.class),
+				invocationContext.getExecutable());
+			assertThat(invocationContext.getArguments()).hasSize(1).hasOnlyElementsOfType(TestReporter.class);
+			reportAndProceed(invocation, extensionContext, InvocationType.BEFORE_EACH);
+		}
+
+		@Override
+		public void interceptTestMethod(Invocation<Void> invocation,
+				ReflectiveInvocationContext<Method> invocationContext, ExtensionContext extensionContext)
+				throws Throwable {
+			assertEquals(testClass, invocationContext.getTargetClass());
+			assertThat(invocationContext.getTarget()).containsInstanceOf(testClass);
+			assertEquals(testClass.getDeclaredMethod("test", TestReporter.class), invocationContext.getExecutable());
+			assertThat(invocationContext.getArguments()).hasSize(1).hasOnlyElementsOfType(TestReporter.class);
+			reportAndProceed(invocation, extensionContext, InvocationType.TEST_METHOD);
+		}
+
+		@Override
+		public void interceptTestTemplateMethod(Invocation<Void> invocation,
+				ReflectiveInvocationContext<Method> invocationContext, ExtensionContext extensionContext)
+				throws Throwable {
+			assertEquals(testClass, invocationContext.getTargetClass());
+			assertThat(invocationContext.getTarget()).containsInstanceOf(testClass);
+			assertEquals(testClass.getDeclaredMethod("testTemplate", Integer.TYPE, TestReporter.class),
+				invocationContext.getExecutable());
+			assertThat(invocationContext.getArguments()).hasSize(2);
+			assertThat(invocationContext.getArguments().get(0)).isInstanceOf(Integer.class);
+			assertThat(invocationContext.getArguments().get(1)).isInstanceOf(TestReporter.class);
+			reportAndProceed(invocation, extensionContext, InvocationType.TEST_TEMPLATE_METHOD);
+		}
+
+		@Override
+		public <T> T interceptTestFactoryMethod(Invocation<T> invocation,
+				ReflectiveInvocationContext<Method> invocationContext, ExtensionContext extensionContext)
+				throws Throwable {
+			assertEquals(testClass, invocationContext.getTargetClass());
+			assertThat(invocationContext.getTarget()).containsInstanceOf(testClass);
+			assertEquals(testClass.getDeclaredMethod("testFactory", TestReporter.class),
+				invocationContext.getExecutable());
+			assertThat(invocationContext.getArguments()).hasSize(1).hasOnlyElementsOfType(TestReporter.class);
+			return reportAndProceed(invocation, extensionContext, InvocationType.TEST_FACTORY_METHOD);
+		}
+
+		@Override
+		public void interceptDynamicTest(Invocation<Void> invocation, ExtensionContext extensionContext)
+				throws Throwable {
+			assertThat(extensionContext.getUniqueId()).isNotBlank();
+			assertThat(extensionContext.getElement()).isEmpty();
+			assertThat(extensionContext.getParent().flatMap(ExtensionContext::getTestMethod)).contains(
+				testClass.getDeclaredMethod("testFactory", TestReporter.class));
+			reportAndProceed(invocation, extensionContext, InvocationType.DYNAMIC_TEST);
+		}
+
+		@Override
+		public void interceptAfterEachMethod(Invocation<Void> invocation,
+				ReflectiveInvocationContext<Method> invocationContext, ExtensionContext extensionContext)
+				throws Throwable {
+			assertEquals(testClass, invocationContext.getTargetClass());
+			assertThat(invocationContext.getTarget()).containsInstanceOf(testClass);
+			assertEquals(testClass.getDeclaredMethod("afterEach", TestReporter.class),
+				invocationContext.getExecutable());
+			assertThat(invocationContext.getArguments()).hasSize(1).hasOnlyElementsOfType(TestReporter.class);
+			reportAndProceed(invocation, extensionContext, InvocationType.AFTER_EACH);
+		}
+
+		@Override
+		public void interceptAfterAllMethod(Invocation<Void> invocation,
+				ReflectiveInvocationContext<Method> invocationContext, ExtensionContext extensionContext)
+				throws Throwable {
+			assertEquals(testClass, invocationContext.getTargetClass());
+			assertThat(invocationContext.getTarget()).isEmpty();
+			assertEquals(testClass.getDeclaredMethod("afterAll", TestReporter.class),
+				invocationContext.getExecutable());
+			assertThat(invocationContext.getArguments()).hasSize(1).hasOnlyElementsOfType(TestReporter.class);
+			reportAndProceed(invocation, extensionContext, InvocationType.AFTER_ALL);
+		}
+
+		private <T> T reportAndProceed(Invocation<T> invocation, ExtensionContext extensionContext, InvocationType type)
+				throws Throwable {
+			extensionContext.publishReportEntry(type.name(), "before:" + name);
+			try {
+				return invocation.proceed();
+			}
+			finally {
+				extensionContext.publishReportEntry(type.name(), "after:" + name);
+			}
+		}
+	}
+
+	static class FooInvocationInterceptor extends ReportingInvocationInterceptor {
+		FooInvocationInterceptor() {
+			super("foo");
+		}
+	}
+
+	static class BarInvocationInterceptor extends ReportingInvocationInterceptor {
+		BarInvocationInterceptor() {
+			super("bar");
+		}
+	}
+
+	static class BazInvocationInterceptor extends ReportingInvocationInterceptor {
+		BazInvocationInterceptor() {
+			super("baz");
+		}
+	}
+
+}
