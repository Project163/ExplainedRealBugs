diff --git a/documentation/src/docs/asciidoc/link-attributes.adoc b/documentation/src/docs/asciidoc/link-attributes.adoc
index f5185bbba..cd4857eac 100644
--- a/documentation/src/docs/asciidoc/link-attributes.adoc
+++ b/documentation/src/docs/asciidoc/link-attributes.adoc
@@ -89,6 +89,7 @@ endif::[]
 :TestExecutionExceptionHandler:              {javadoc-root}/org/junit/jupiter/api/extension/TestExecutionExceptionHandler.html[TestExecutionExceptionHandler]
 :TestInstanceFactory:                        {javadoc-root}/org/junit/jupiter/api/extension/TestInstanceFactory.html[TestInstanceFactory]
 :TestInstancePostProcessor:                  {javadoc-root}/org/junit/jupiter/api/extension/TestInstancePostProcessor.html[TestInstancePostProcessor]
+:TestInstancePreDestroyCallback:             {javadoc-root}/org/junit/jupiter/api/extension/TestInstancePreDestroyCallback.html[TestInstancePreDestroyCallback]
 :TestTemplateInvocationContext:              {javadoc-root}/org/junit/jupiter/api/extension/TestTemplateInvocationContext.html[TestTemplateInvocationContext]
 :TestTemplateInvocationContextProvider:      {javadoc-root}/org/junit/jupiter/api/extension/TestTemplateInvocationContextProvider.html[TestTemplateInvocationContextProvider]
 :TestWatcher:                                {javadoc-root}/org/junit/jupiter/api/extension/TestWatcher.html[TestWatcher]
diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.6.0-M2.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.6.0-M2.adoc
index 19ecd8891..df4bc0da9 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.6.0-M2.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.6.0-M2.adoc
@@ -46,6 +46,9 @@ on GitHub.
   `@EnabledIfSystemProperty`, and `@DisabledIfSystemProperty` may now be used as
   _repeatable_ annotations. In other words, it is now possible to declare each of those
   annotations multiple times on a test interface, test class, or test method.
+* New `TestInstancePreDestroyCallback` interface that defines the API for `Extension`
+  that wish to process test instances *after* they have been used in tests and *before*
+  they are destroyed.
 * `InvocationInterceptor` extensions may now explicitly `skip()` an intercepted
   invocation. This allows executing it by other means, e.g. in a forked JVM.
 
diff --git a/documentation/src/docs/asciidoc/user-guide/extensions.adoc b/documentation/src/docs/asciidoc/user-guide/extensions.adoc
index b0e00a11d..2df5c2cee 100644
--- a/documentation/src/docs/asciidoc/user-guide/extensions.adoc
+++ b/documentation/src/docs/asciidoc/user-guide/extensions.adoc
@@ -122,9 +122,9 @@ If a `@RegisterExtension` field is `static`, the extension will be registered af
 extensions that are registered at the class level via `@ExtendWith`. Such _static
 extensions_ are not limited in which extension APIs they can implement. Extensions
 registered via static fields may therefore implement class-level and instance-level
-extension APIs such as `BeforeAllCallback`, `AfterAllCallback`, and
-`TestInstancePostProcessor` as well as method-level extension APIs such as
-`BeforeEachCallback`, etc.
+extension APIs such as `BeforeAllCallback`, `AfterAllCallback`,
+`TestInstancePostProcessor`, and `TestInstancePreDestroyCallback` as well as method-level
+extension APIs such as `BeforeEachCallback`, etc.
 
 In the following example, the `server` field in the test class is initialized
 programmatically by using a builder pattern supported by the `WebServerExtension`. The
@@ -324,6 +324,15 @@ initialization methods on the test instance, etc.
 For a concrete example, consult the source code for the `{MockitoExtension}` and the
 `{SpringExtension}`.
 
+[[extensions-test-instance-pre-destroy-callback]]
+=== Test Instance Pre-destroy Callback
+
+`{TestInstancePreDestroyCallback}` defines the API for `Extensions` that wish to process
+test instances _after_ they have been used in tests and _before_ they are destroyed.
+
+Common use cases include cleaning dependencies that have been injected into the
+test instance, invoking custom de-initialization methods on the test instance, etc.
+
 [[extensions-parameter-resolution]]
 === Parameter Resolution
 
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ExtendWith.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ExtendWith.java
index bfa0f289e..6799db47d 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ExtendWith.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ExtendWith.java
@@ -39,6 +39,7 @@ import org.apiguardian.api.API;
  * <li>{@link AfterTestExecutionCallback}</li>
  * <li>{@link TestInstanceFactory}</li>
  * <li>{@link TestInstancePostProcessor}</li>
+ * <li>{@link TestInstancePreDestroyCallback}</li>
  * <li>{@link ParameterResolver}</li>
  * <li>{@link TestExecutionExceptionHandler}</li>
  * <li>{@link TestTemplateInvocationContextProvider}</li>
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ParameterResolver.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ParameterResolver.java
index b006d2bac..109dfcdf0 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ParameterResolver.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/ParameterResolver.java
@@ -41,6 +41,7 @@ import org.apiguardian.api.API;
  * @see ParameterContext
  * @see TestInstanceFactory
  * @see TestInstancePostProcessor
+ * @see TestInstancePreDestroyCallback
  */
 @API(status = STABLE, since = "5.0")
 public interface ParameterResolver extends Extension {
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/RegisterExtension.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/RegisterExtension.java
index 80ff02c45..f9ade6a23 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/RegisterExtension.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/RegisterExtension.java
@@ -41,8 +41,9 @@ import org.apiguardian.api.API;
  * which extension APIs they can implement. Extensions registered via static
  * fields may therefore implement class-level and instance-level extension APIs
  * such as {@link BeforeAllCallback}, {@link AfterAllCallback},
- * {@link TestInstanceFactory}, and {@link TestInstancePostProcessor} as well as
- * method-level extension APIs such as {@link BeforeEachCallback}, etc.
+ * {@link TestInstanceFactory}, {@link TestInstancePostProcessor} and
+ * {@link TestInstancePreDestroyCallback} as well as method-level extension APIs
+ * such as {@link BeforeEachCallback}, etc.
  *
  * <h3>Instance Fields</h3>
  *
@@ -121,6 +122,7 @@ import org.apiguardian.api.API;
  * <li>{@link AfterTestExecutionCallback}</li>
  * <li>{@link TestInstanceFactory}</li>
  * <li>{@link TestInstancePostProcessor}</li>
+ * <li>{@link TestInstancePreDestroyCallback}</li>
  * <li>{@link ParameterResolver}</li>
  * <li>{@link TestExecutionExceptionHandler}</li>
  * <li>{@link TestTemplateInvocationContextProvider}</li>
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/TestInstanceFactory.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/TestInstanceFactory.java
index c9d1c3612..038344c7e 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/TestInstanceFactory.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/TestInstanceFactory.java
@@ -46,6 +46,7 @@ import org.apiguardian.api.API;
  * @see #createTestInstance(TestInstanceFactoryContext, ExtensionContext)
  * @see TestInstanceFactoryContext
  * @see TestInstancePostProcessor
+ * @see TestInstancePreDestroyCallback
  * @see ParameterResolver
  */
 @FunctionalInterface
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/TestInstancePreDestroyCallback.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/TestInstancePreDestroyCallback.java
new file mode 100644
index 000000000..c3b987751
--- /dev/null
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/extension/TestInstancePreDestroyCallback.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2015-2019 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.api.extension;
+
+import static org.apiguardian.api.API.Status.EXPERIMENTAL;
+
+import org.apiguardian.api.API;
+
+/**
+ * {@code TestInstancePreDestroyCallback} defines the API for {@link Extension
+ * Extensions} that wish to process test instances <em>after</em> they have been
+ * used in tests and <em>before</em> they are destroyed.
+ *
+ * <p>Common use cases include cleaning dependencies that have been injected
+ * into the test instance, invoking custom de-initialization methods on the test
+ * instance, etc.
+ *
+ * <p>Extensions that implement {@code TestInstancePreDestroyCallback} must be
+ * registered at the class level.
+ *
+ * <h3>Constructor Requirements</h3>
+ *
+ * <p>Consult the documentation in {@link Extension} for details on constructor
+ * requirements.
+ *
+ * @since 5.6
+ * @see #preDestroyTestInstance(ExtensionContext)
+ * @see TestInstanceFactory
+ * @see ParameterResolver
+ */
+@FunctionalInterface
+@API(status = EXPERIMENTAL, since = "5.6")
+public interface TestInstancePreDestroyCallback extends Extension {
+
+	/**
+	 * Callback for processing a test instance before it is destroyed.
+	 *
+	 * @param context the current extension context; never {@code null}
+	 * @see ExtensionContext#getTestInstance()
+	 * @see ExtensionContext#getRequiredTestInstance()
+	 */
+	void preDestroyTestInstance(ExtensionContext context) throws Exception;
+}
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassBasedTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassBasedTestDescriptor.java
index b123ca262..e61a9f586 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassBasedTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassBasedTestDescriptor.java
@@ -42,6 +42,7 @@ import org.junit.jupiter.api.extension.InvocationInterceptor;
 import org.junit.jupiter.api.extension.LifecycleMethodExecutionExceptionHandler;
 import org.junit.jupiter.api.extension.TestInstanceFactory;
 import org.junit.jupiter.api.extension.TestInstancePostProcessor;
+import org.junit.jupiter.api.extension.TestInstancePreDestroyCallback;
 import org.junit.jupiter.api.extension.TestInstances;
 import org.junit.jupiter.api.extension.TestInstantiationException;
 import org.junit.jupiter.api.function.Executable;
@@ -175,8 +176,7 @@ public abstract class ClassBasedTestDescriptor extends JupiterTestDescriptor {
 	public JupiterEngineExecutionContext before(JupiterEngineExecutionContext context) {
 		ThrowableCollector throwableCollector = context.getThrowableCollector();
 
-		Lifecycle lifecycle = context.getExtensionContext().getTestInstanceLifecycle().orElse(Lifecycle.PER_METHOD);
-		if (lifecycle == Lifecycle.PER_CLASS) {
+		if (isPerClassLifecycle(context)) {
 			// Eagerly load test instance for BeforeAllCallbacks, if necessary,
 			// and store the instance in the ExtensionContext.
 			ClassExtensionContext extensionContext = (ClassExtensionContext) context.getExtensionContext();
@@ -213,6 +213,10 @@ public abstract class ClassBasedTestDescriptor extends JupiterTestDescriptor {
 			invokeAfterAllCallbacks(context);
 		}
 
+		if (isPerClassLifecycle(context)) {
+			invokeTestInstancePreDestroyCallback(context);
+		}
+
 		// If the previous Throwable was not null when this method was called,
 		// that means an exception was already thrown either before or during
 		// the execution of this Node. If an exception was already thrown, any
@@ -421,6 +425,19 @@ public abstract class ClassBasedTestDescriptor extends JupiterTestDescriptor {
 				.forEach(extension -> throwableCollector.execute(() -> extension.afterAll(extensionContext)));
 	}
 
+	private void invokeTestInstancePreDestroyCallback(JupiterEngineExecutionContext context) {
+		ExtensionContext extensionContext = context.getExtensionContext();
+		ThrowableCollector throwableCollector = context.getThrowableCollector();
+
+		context.getExtensionRegistry().stream(TestInstancePreDestroyCallback.class).forEach(
+			extension -> throwableCollector.execute(() -> extension.preDestroyTestInstance(extensionContext)));
+	}
+
+	private boolean isPerClassLifecycle(JupiterEngineExecutionContext context) {
+		return context.getExtensionContext().getTestInstanceLifecycle().orElse(
+			Lifecycle.PER_METHOD) == Lifecycle.PER_CLASS;
+	}
+
 	private void registerBeforeEachMethodAdapters(ExtensionRegistrar registrar) {
 		List<Method> beforeEachMethods = findBeforeEachMethods(this.testClass);
 		registerMethodsAsExtensions(beforeEachMethods, registrar, this::synthesizeBeforeEachMethodAdapter);
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestMethodTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestMethodTestDescriptor.java
index 3a0dacc2f..54f68e282 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestMethodTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestMethodTestDescriptor.java
@@ -20,6 +20,7 @@ import java.util.Optional;
 import java.util.function.Consumer;
 
 import org.apiguardian.api.API;
+import org.junit.jupiter.api.TestInstance;
 import org.junit.jupiter.api.extension.AfterEachCallback;
 import org.junit.jupiter.api.extension.AfterTestExecutionCallback;
 import org.junit.jupiter.api.extension.BeforeEachCallback;
@@ -29,6 +30,7 @@ import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.api.extension.InvocationInterceptor;
 import org.junit.jupiter.api.extension.LifecycleMethodExecutionExceptionHandler;
 import org.junit.jupiter.api.extension.TestExecutionExceptionHandler;
+import org.junit.jupiter.api.extension.TestInstancePreDestroyCallback;
 import org.junit.jupiter.api.extension.TestInstances;
 import org.junit.jupiter.api.extension.TestWatcher;
 import org.junit.jupiter.engine.config.JupiterConfiguration;
@@ -139,6 +141,7 @@ public class TestMethodTestDescriptor extends MethodBasedTestDescriptor {
 				invokeAfterEachMethods(context);
 			}
 		invokeAfterEachCallbacks(context);
+		invokeTestInstancePreDestroyCallback(context);
 		// @formatter:on
 
 		throwableCollector.assertEmpty();
@@ -245,6 +248,15 @@ public class TestMethodTestDescriptor extends MethodBasedTestDescriptor {
 			(callback, extensionContext) -> callback.afterEach(extensionContext));
 	}
 
+	private void invokeTestInstancePreDestroyCallback(JupiterEngineExecutionContext context) {
+		context.getExtensionContext().getTestInstanceLifecycle().ifPresent(lifecycle -> {
+			if (TestInstance.Lifecycle.PER_METHOD == lifecycle) {
+				invokeAllAfterMethodsOrCallbacks(TestInstancePreDestroyCallback.class, context,
+					TestInstancePreDestroyCallback::preDestroyTestInstance);
+			}
+		});
+	}
+
 	private <T extends Extension> void invokeAllAfterMethodsOrCallbacks(Class<T> type,
 			JupiterEngineExecutionContext context, CallbackInvoker<T> callbackInvoker) {
 
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/extension/KitchenSinkExtension.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/extension/KitchenSinkExtension.java
index 8e9592aea..52db4a55f 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/extension/KitchenSinkExtension.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/api/extension/KitchenSinkExtension.java
@@ -46,6 +46,7 @@ public class KitchenSinkExtension implements
 	// Dependency Injection
 	TestInstanceFactory,
 	TestInstancePostProcessor,
+	TestInstancePreDestroyCallback,
 	ParameterResolver,
 
 	// Conditional Test Execution
@@ -120,6 +121,10 @@ public class KitchenSinkExtension implements
 	public void postProcessTestInstance(Object testInstance, ExtensionContext context) {
 	}
 
+	@Override
+	public void preDestroyTestInstance(ExtensionContext context) {
+	}
+
 	@Override
 	public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
 		return false;
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/TestInstanceLifecycleTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/TestInstanceLifecycleTests.java
index ffb3f8df7..da03cca3d 100644
--- a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/TestInstanceLifecycleTests.java
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/TestInstanceLifecycleTests.java
@@ -51,6 +51,7 @@ import org.junit.jupiter.api.extension.ExecutionCondition;
 import org.junit.jupiter.api.extension.ExtendWith;
 import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.api.extension.TestInstancePostProcessor;
+import org.junit.jupiter.api.extension.TestInstancePreDestroyCallback;
 import org.junit.jupiter.api.extension.TestInstances;
 import org.junit.jupiter.api.extension.TestTemplateInvocationContext;
 import org.junit.jupiter.api.extension.TestTemplateInvocationContextProvider;
@@ -101,6 +102,7 @@ class TestInstanceLifecycleTests extends AbstractJupiterTestEngineTests {
 
 		String containerExecutionConditionKey = executionConditionKey(testClass, null);
 		String postProcessTestInstanceKey = postProcessTestInstanceKey(testClass);
+		String preDestroyCallbackTestInstanceKey = preDestroyCallbackTestInstanceKey(testClass);
 		String beforeAllCallbackKey = beforeAllCallbackKey(testClass);
 		String afterAllCallbackKey = afterAllCallbackKey(testClass);
 		String testTemplateKey = testTemplateKey(testClass, "singletonTest");
@@ -119,6 +121,7 @@ class TestInstanceLifecycleTests extends AbstractJupiterTestEngineTests {
 				containerExecutionConditionKey,
 				beforeAllCallbackKey,
 				postProcessTestInstanceKey,
+				preDestroyCallbackTestInstanceKey,
 				testTemplateKey,
 				testExecutionConditionKey1,
 				beforeEachCallbackKey1,
@@ -153,6 +156,8 @@ class TestInstanceLifecycleTests extends AbstractJupiterTestEngineTests {
 		assertSame(testInstances, instanceMap.get(testExecutionConditionKey3));
 		assertSame(testInstances.getInnermostInstance(),
 			instanceMap.get(postProcessTestInstanceKey).getInnermostInstance());
+		assertSame(testInstances.getInnermostInstance(),
+			instanceMap.get(preDestroyCallbackTestInstanceKey).getInnermostInstance());
 
 		assertThat(lifecyclesMap.keySet()).containsExactly(testClass);
 		assertThat(lifecyclesMap.get(testClass).stream()).allMatch(Lifecycle.PER_METHOD::equals);
@@ -180,6 +185,7 @@ class TestInstanceLifecycleTests extends AbstractJupiterTestEngineTests {
 		String containerExecutionConditionKey = executionConditionKey(testClass, null);
 		String testTemplateKey = testTemplateKey(testClass, "singletonTest");
 		String postProcessTestInstanceKey = postProcessTestInstanceKey(testClass);
+		String preDestroyCallbackTestInstanceKey = preDestroyCallbackTestInstanceKey(testClass);
 		String beforeAllCallbackKey = beforeAllCallbackKey(testClass);
 		String afterAllCallbackKey = afterAllCallbackKey(testClass);
 		String testExecutionConditionKey1 = executionConditionKey(testClass, testsInvoked.get(0));
@@ -195,6 +201,7 @@ class TestInstanceLifecycleTests extends AbstractJupiterTestEngineTests {
 		// @formatter:off
 		assertThat(instanceMap.keySet()).containsExactlyInAnyOrder(
 				postProcessTestInstanceKey,
+				preDestroyCallbackTestInstanceKey,
 				containerExecutionConditionKey,
 				beforeAllCallbackKey,
 				testTemplateKey,
@@ -225,6 +232,9 @@ class TestInstanceLifecycleTests extends AbstractJupiterTestEngineTests {
 		assertSame(testInstances, instanceMap.get(afterEachCallbackKey3));
 		assertSame(testInstances.getInnermostInstance(),
 			instanceMap.get(postProcessTestInstanceKey).getInnermostInstance());
+		assertSame(testInstances.getInnermostInstance(),
+			instanceMap.get(preDestroyCallbackTestInstanceKey).getInnermostInstance());
+
 		assertNull(instanceMap.get(containerExecutionConditionKey));
 
 		assertThat(lifecyclesMap.keySet()).containsExactly(testClass);
@@ -248,6 +258,8 @@ class TestInstanceLifecycleTests extends AbstractJupiterTestEngineTests {
 		String nestedTestTemplateKey = testTemplateKey(nestedTestClass, "singletonTest");
 		String postProcessTestInstanceKey = postProcessTestInstanceKey(testClass);
 		String nestedPostProcessTestInstanceKey = postProcessTestInstanceKey(nestedTestClass);
+		String preDestroyCallbackTestInstanceKey = preDestroyCallbackTestInstanceKey(testClass);
+		String nestedPreDestroyCallbackTestInstanceKey = preDestroyCallbackTestInstanceKey(nestedTestClass);
 		String beforeAllCallbackKey = beforeAllCallbackKey(testClass);
 		String afterAllCallbackKey = afterAllCallbackKey(testClass);
 		String outerTestExecutionConditionKey = executionConditionKey(testClass, "outerTest");
@@ -272,6 +284,8 @@ class TestInstanceLifecycleTests extends AbstractJupiterTestEngineTests {
 				nestedContainerExecutionConditionKey,
 				postProcessTestInstanceKey,
 				nestedPostProcessTestInstanceKey,
+				preDestroyCallbackTestInstanceKey,
+				nestedPreDestroyCallbackTestInstanceKey,
 				beforeAllCallbackKey,
 				afterAllCallbackKey,
 				outerTestExecutionConditionKey,
@@ -324,6 +338,8 @@ class TestInstanceLifecycleTests extends AbstractJupiterTestEngineTests {
 			instanceMap.get(nestedAfterEachCallbackKey3).getInnermostInstance());
 		assertSame(nestedInstances3.getInnermostInstance(),
 			instanceMap.get(nestedExecutionConditionKey3).getInnermostInstance());
+		assertSame(nestedInstances3.getInnermostInstance(),
+			instanceMap.get(nestedPreDestroyCallbackTestInstanceKey).getInnermostInstance());
 
 		Object outerInstance1 = instanceMap.get(nestedExecutionConditionKey1).findInstance(testClass).get();
 		Object outerInstance2 = instanceMap.get(nestedExecutionConditionKey2).findInstance(testClass).get();
@@ -364,6 +380,8 @@ class TestInstanceLifecycleTests extends AbstractJupiterTestEngineTests {
 		String nestedTestTemplateKey = testTemplateKey(nestedTestClass, "singletonTest");
 		String postProcessTestInstanceKey = postProcessTestInstanceKey(testClass);
 		String nestedPostProcessTestInstanceKey = postProcessTestInstanceKey(nestedTestClass);
+		String preDestroyCallbackTestInstanceKey = preDestroyCallbackTestInstanceKey(testClass);
+		String nestedPreDestroyCallbackTestInstanceKey = preDestroyCallbackTestInstanceKey(nestedTestClass);
 		String beforeAllCallbackKey = beforeAllCallbackKey(testClass);
 		String afterAllCallbackKey = afterAllCallbackKey(testClass);
 		String outerTestExecutionConditionKey = executionConditionKey(testClass, "outerTest");
@@ -388,6 +406,8 @@ class TestInstanceLifecycleTests extends AbstractJupiterTestEngineTests {
 				nestedContainerExecutionConditionKey,
 				postProcessTestInstanceKey,
 				nestedPostProcessTestInstanceKey,
+				preDestroyCallbackTestInstanceKey,
+				nestedPreDestroyCallbackTestInstanceKey,
 				beforeAllCallbackKey,
 				afterAllCallbackKey,
 				outerTestExecutionConditionKey,
@@ -415,6 +435,7 @@ class TestInstanceLifecycleTests extends AbstractJupiterTestEngineTests {
 		assertSame(instance, instanceMap.get(outerTestExecutionConditionKey).getInnermostInstance());
 		assertSame(instance, instanceMap.get(beforeEachCallbackKey).getInnermostInstance());
 		assertSame(instance, instanceMap.get(afterEachCallbackKey).getInnermostInstance());
+		assertSame(instance, instanceMap.get(preDestroyCallbackTestInstanceKey).getInnermostInstance());
 
 		Object nestedInstance = instanceMap.get(nestedPostProcessTestInstanceKey).getInnermostInstance();
 		assertNotNull(nestedInstance);
@@ -431,9 +452,12 @@ class TestInstanceLifecycleTests extends AbstractJupiterTestEngineTests {
 		assertSame(nestedInstance, instanceMap.get(nestedExecutionConditionKey3).getInnermostInstance());
 		assertSame(nestedInstance, instanceMap.get(nestedBeforeEachCallbackKey3).getInnermostInstance());
 		assertSame(nestedInstance, instanceMap.get(nestedAfterEachCallbackKey3).getInnermostInstance());
+		assertSame(nestedInstance, instanceMap.get(nestedPreDestroyCallbackTestInstanceKey).getInnermostInstance());
 
 		Object outerInstance = instanceMap.get(nestedExecutionConditionKey1).findInstance(testClass).get();
 		assertSame(outerInstance, instanceMap.get(postProcessTestInstanceKey).getInnermostInstance());
+		assertSame(outerInstance, instanceMap.get(preDestroyCallbackTestInstanceKey).getInnermostInstance());
+
 		assertThat(instanceMap.get(nestedExecutionConditionKey1).getAllInstances()).containsExactly(outerInstance,
 			nestedInstance);
 		assertThat(instanceMap.get(nestedBeforeEachCallbackKey1).getAllInstances()).containsExactly(outerInstance,
@@ -475,6 +499,8 @@ class TestInstanceLifecycleTests extends AbstractJupiterTestEngineTests {
 		String nestedTestTemplateKey = testTemplateKey(nestedTestClass, "singletonTest");
 		String postProcessTestInstanceKey = postProcessTestInstanceKey(testClass);
 		String nestedPostProcessTestInstanceKey = postProcessTestInstanceKey(nestedTestClass);
+		String preDestroyCallbackTestInstanceKey = preDestroyCallbackTestInstanceKey(testClass);
+		String nestedPreDestroyCallbackTestInstanceKey = preDestroyCallbackTestInstanceKey(nestedTestClass);
 		String beforeAllCallbackKey = beforeAllCallbackKey(testClass);
 		String afterAllCallbackKey = afterAllCallbackKey(testClass);
 		String outerTestExecutionConditionKey = executionConditionKey(testClass, "outerTest");
@@ -499,6 +525,8 @@ class TestInstanceLifecycleTests extends AbstractJupiterTestEngineTests {
 				nestedContainerExecutionConditionKey,
 				postProcessTestInstanceKey,
 				nestedPostProcessTestInstanceKey,
+				preDestroyCallbackTestInstanceKey,
+				nestedPreDestroyCallbackTestInstanceKey,
 				beforeAllCallbackKey,
 				afterAllCallbackKey,
 				outerTestExecutionConditionKey,
@@ -541,6 +569,7 @@ class TestInstanceLifecycleTests extends AbstractJupiterTestEngineTests {
 		assertSame(nestedInstance, instanceMap.get(nestedExecutionConditionKey3).getInnermostInstance());
 		assertSame(nestedInstance, instanceMap.get(nestedBeforeEachCallbackKey3).getInnermostInstance());
 		assertSame(nestedInstance, instanceMap.get(nestedAfterEachCallbackKey3).getInnermostInstance());
+		assertSame(nestedInstance, instanceMap.get(nestedPreDestroyCallbackTestInstanceKey).getInnermostInstance());
 
 		// The last tracked instance stored under postProcessTestInstanceKey
 		// is only created in order to instantiate the nested test class.
@@ -609,6 +638,10 @@ class TestInstanceLifecycleTests extends AbstractJupiterTestEngineTests {
 		return concat(TestInstancePostProcessor.class, testClass);
 	}
 
+	private static String preDestroyCallbackTestInstanceKey(Class<?> testClass) {
+		return concat(TestInstancePreDestroyCallback.class, testClass);
+	}
+
 	private static String beforeAllCallbackKey(Class<?> testClass) {
 		return concat(BeforeAllCallback.class, testClass);
 	}
@@ -935,7 +968,8 @@ class TestInstanceLifecycleTests extends AbstractJupiterTestEngineTests {
 	// Intentionally not implementing BeforeTestExecutionCallback, AfterTestExecutionCallback,
 	// and TestExecutionExceptionHandler, since they are analogous to BeforeEachCallback and
 	// AfterEachCallback with regard to instance scope and Lifecycle.
-	static class InstanceTrackingExtension implements ExecutionCondition, TestInstancePostProcessor, BeforeAllCallback,
+	static class InstanceTrackingExtension
+			implements ExecutionCondition, TestInstancePostProcessor, TestInstancePreDestroyCallback, BeforeAllCallback,
 			AfterAllCallback, BeforeEachCallback, AfterEachCallback, TestTemplateInvocationContextProvider {
 
 		@Override
@@ -961,6 +995,14 @@ class TestInstanceLifecycleTests extends AbstractJupiterTestEngineTests {
 				DefaultTestInstances.of(testInstance));
 		}
 
+		@Override
+		public void preDestroyTestInstance(ExtensionContext context) {
+			trackLifecycle(context);
+			assertThat(context.getTestInstance()).isPresent();
+			instanceMap.put(preDestroyCallbackTestInstanceKey(context.getRequiredTestClass()),
+				DefaultTestInstances.of(context.getTestInstance().get()));
+		}
+
 		@Override
 		public void beforeAll(ExtensionContext context) {
 			trackLifecycle(context);
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TestInstancePostProcessorAndPreDestroyCallbackTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TestInstancePostProcessorAndPreDestroyCallbackTests.java
new file mode 100644
index 000000000..ad34f9221
--- /dev/null
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TestInstancePostProcessorAndPreDestroyCallbackTests.java
@@ -0,0 +1,241 @@
+/*
+ * Copyright 2015-2019 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.engine.extension;
+
+import static java.util.Arrays.asList;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
+import org.junit.jupiter.api.extension.ExtensionContext;
+import org.junit.jupiter.api.extension.TestInstancePostProcessor;
+import org.junit.jupiter.api.extension.TestInstancePreDestroyCallback;
+import org.junit.jupiter.engine.AbstractJupiterTestEngineTests;
+import org.junit.jupiter.engine.JupiterTestEngine;
+
+/**
+ * Integration tests that verify support for {@link TestInstancePostProcessor}
+ * and {@link TestInstancePreDestroyCallback} in the {@link JupiterTestEngine}.
+ *
+ * @since 5.6
+ */
+class TestInstancePostProcessorAndPreDestroyCallbackTests extends AbstractJupiterTestEngineTests {
+
+	private static final List<String> callSequence = new ArrayList<>();
+
+	@Test
+	void postProcessorAndPreDestroyCallbacks() {
+		// @formatter:off
+		assertPostProcessorAndPreDestroyCallbacks(TopLevelTestCase.class,
+			"fooPostProcessTestInstance",
+			"barPostProcessTestInstance",
+				"test-1",
+			"barPreDestroyTestInstance",
+			"fooPreDestroyTestInstance"
+		);
+		// @formatter:on
+	}
+
+	@Test
+	void postProcessorAndPreDestroyCallbacksInSubclass() {
+		// @formatter:off
+		assertPostProcessorAndPreDestroyCallbacks(SecondLevelTestCase.class,
+			"fooPostProcessTestInstance",
+			"barPostProcessTestInstance",
+				"bazPostProcessTestInstance",
+					"test-2",
+				"bazPreDestroyTestInstance",
+			"barPreDestroyTestInstance",
+			"fooPreDestroyTestInstance"
+		);
+		// @formatter:on
+	}
+
+	@Test
+	void postProcessorAndPreDestroyCallbacksInSubSubclass() {
+		// @formatter:off
+		assertPostProcessorAndPreDestroyCallbacks(ThirdLevelTestCase.class,
+			"fooPostProcessTestInstance",
+			"barPostProcessTestInstance",
+				"bazPostProcessTestInstance",
+					"quuxPostProcessTestInstance",
+						"test-3",
+					"quuxPreDestroyTestInstance",
+				"bazPreDestroyTestInstance",
+			"barPreDestroyTestInstance",
+			"fooPreDestroyTestInstance"
+		);
+		// @formatter:on
+	}
+
+	@Test
+	void preDestroyTestInstanceMethodThrowsAnException() {
+		// @formatter:off
+		assertPostProcessorAndPreDestroyCallbacks(ExceptionInTestInstancePreDestroyCallbackTestCase.class, 0,
+			"fooPostProcessTestInstance",
+				"test",
+			"exceptionThrowingTestInstancePreDestroyCallback"
+		);
+		// @formatter:on
+	}
+
+	@Test
+	void postProcessTestInstanceMethodThrowsAnException() {
+		// @formatter:off
+		assertPostProcessorAndPreDestroyCallbacks(ExceptionInTestInstancePostProcessorTestCase.class, 0,
+			"exceptionThrowingTestInstancePostProcessor"
+		);
+		// @formatter:on
+	}
+
+	private void assertPostProcessorAndPreDestroyCallbacks(Class<?> testClass, String... expectedCalls) {
+		assertPostProcessorAndPreDestroyCallbacks(testClass, 1, expectedCalls);
+	}
+
+	private void assertPostProcessorAndPreDestroyCallbacks(Class<?> testClass, int testsSuccessful,
+			String... expectedCalls) {
+
+		callSequence.clear();
+
+		executeTestsForClass(testClass).testEvents()//
+				.assertStatistics(stats -> stats.started(1).succeeded(testsSuccessful));
+
+		assertEquals(asList(expectedCalls), callSequence, () -> "wrong call sequence for " + testClass.getName());
+	}
+
+	// -------------------------------------------------------------------------
+
+	// Must NOT be private; otherwise, the @Test method gets discovered but never executed.
+	@ExtendWith({ FooTestInstanceCallbacks.class, BarTestInstanceCallbacks.class })
+	static class TopLevelTestCase {
+
+		@Test
+		void test() {
+			callSequence.add("test-1");
+		}
+	}
+
+	// Must NOT be private; otherwise, the @Test method gets discovered but never executed.
+	@ExtendWith(BazTestInstanceCallbacks.class)
+	static class SecondLevelTestCase extends TopLevelTestCase {
+
+		@Test
+		@Override
+		void test() {
+			callSequence.add("test-2");
+		}
+	}
+
+	@ExtendWith(QuuxTestInstanceCallbacks.class)
+	static class ThirdLevelTestCase extends SecondLevelTestCase {
+
+		@Test
+		@Override
+		void test() {
+			callSequence.add("test-3");
+		}
+	}
+
+	@ExtendWith(ExceptionThrowingTestInstancePreDestroyCallback.class)
+	static class ExceptionInTestInstancePreDestroyCallbackTestCase {
+		@Test
+		void test() {
+			callSequence.add("test");
+		}
+	}
+
+	@ExtendWith(ExceptionThrowingTestInstancePostProcessor.class)
+	static class ExceptionInTestInstancePostProcessorTestCase {
+		@Test
+		void test() {
+			callSequence.add("test");
+		}
+	}
+
+	// -------------------------------------------------------------------------
+
+	static class FooTestInstanceCallbacks extends AbstractTestInstanceCallbacks {
+
+		protected FooTestInstanceCallbacks() {
+			super("foo");
+		}
+	}
+
+	static class BarTestInstanceCallbacks extends AbstractTestInstanceCallbacks {
+
+		protected BarTestInstanceCallbacks() {
+			super("bar");
+		}
+	}
+
+	static class BazTestInstanceCallbacks extends AbstractTestInstanceCallbacks {
+
+		protected BazTestInstanceCallbacks() {
+			super("baz");
+		}
+	}
+
+	static class QuuxTestInstanceCallbacks extends AbstractTestInstanceCallbacks {
+
+		protected QuuxTestInstanceCallbacks() {
+			super("quux");
+		}
+	}
+
+	static class ExceptionThrowingTestInstancePreDestroyCallback extends AbstractTestInstanceCallbacks {
+
+		protected ExceptionThrowingTestInstancePreDestroyCallback() {
+			super("foo");
+		}
+
+		@Override
+		public void preDestroyTestInstance(ExtensionContext context) {
+			callSequence.add("exceptionThrowingTestInstancePreDestroyCallback");
+			throw new EnigmaException("preDestroyTestInstance");
+		}
+	}
+
+	static class ExceptionThrowingTestInstancePostProcessor extends AbstractTestInstanceCallbacks {
+
+		protected ExceptionThrowingTestInstancePostProcessor() {
+			super("exception");
+		}
+
+		@Override
+		public void postProcessTestInstance(Object testInstance, ExtensionContext context) {
+			callSequence.add("exceptionThrowingTestInstancePostProcessor");
+			throw new EnigmaException("postProcessTestInstance");
+		}
+	}
+
+	private static abstract class AbstractTestInstanceCallbacks
+			implements TestInstancePostProcessor, TestInstancePreDestroyCallback {
+
+		private final String name;
+
+		AbstractTestInstanceCallbacks(String name) {
+			this.name = name;
+		}
+
+		@Override
+		public void postProcessTestInstance(Object testInstance, ExtensionContext context) {
+			callSequence.add(name + "PostProcessTestInstance");
+		}
+
+		@Override
+		public void preDestroyTestInstance(ExtensionContext context) {
+			callSequence.add(name + "PreDestroyTestInstance");
+		}
+	}
+}
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TestInstancePreDestroyCallbackTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TestInstancePreDestroyCallbackTests.java
new file mode 100644
index 000000000..0a6aa83ac
--- /dev/null
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/extension/TestInstancePreDestroyCallbackTests.java
@@ -0,0 +1,206 @@
+/*
+ * Copyright 2015-2019 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.engine.extension;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Nested;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.TestInstance;
+import org.junit.jupiter.api.extension.ExtendWith;
+import org.junit.jupiter.api.extension.ExtensionContext;
+import org.junit.jupiter.api.extension.TestInstancePreDestroyCallback;
+import org.junit.jupiter.engine.AbstractJupiterTestEngineTests;
+
+/**
+ * Integration tests that verify support for {@link TestInstancePreDestroyCallback}.
+ *
+ * @since 5.6
+ */
+class TestInstancePreDestroyCallbackTests extends AbstractJupiterTestEngineTests {
+
+	private static final List<String> callSequence = new ArrayList<>();
+
+	@BeforeEach
+	void resetCallSequence() {
+		callSequence.clear();
+	}
+
+	@Test
+	void instancePreDestroyCallbacksInNestedClasses() {
+		executeTestsForClass(OuterTestCase.class).testEvents().assertStatistics(stats -> stats.started(2).succeeded(2));
+
+		// @formatter:off
+		assertThat(callSequence).containsExactly(
+
+			// OuterTestCase
+			"beforeOuterMethod",
+				"testOuter",
+			"fooPreDestroyCallbackTestInstance:OuterTestCase",
+
+			// InnerTestCase
+			"beforeOuterMethod",
+				"beforeInnerMethod",
+					"testInner",
+				"barPreDestroyCallbackTestInstance:InnerTestCase",
+
+			"fooPreDestroyCallbackTestInstance:InnerTestCase"
+		);
+		// @formatter:on
+	}
+
+	@Test
+	void testSpecificTestInstancePreDestroyCallbackIsCalled() {
+		executeTestsForClass(
+			TestCaseWithTestSpecificTestInstancePreDestroyCallback.class).testEvents().assertStatistics(
+				stats -> stats.started(1).succeeded(1));
+
+		// @formatter:off
+		assertThat(callSequence).containsExactly(
+			"beforeEachMethod",
+				"test",
+			"fooPreDestroyCallbackTestInstance:TestCaseWithTestSpecificTestInstancePreDestroyCallback"
+		);
+		// @formatter:on
+	}
+
+	@Test
+	void classLifecyclePreDestroyCallbacks() {
+		executeTestsForClass(PerClassLifecyclePreDestroyCallbackWithTwoTestMethods.class).testEvents().assertStatistics(
+			stats -> stats.started(2).succeeded(2));
+
+		// @formatter:off
+		assertThat(callSequence).containsExactly(
+			"beforeEachMethod",
+				"test1",
+			"beforeEachMethod",
+				"test2",
+			"fooPreDestroyCallbackTestInstance:PerClassLifecyclePreDestroyCallbackWithTwoTestMethods"
+		);
+		// @formatter:on
+	}
+
+	// -------------------------------------------------------------------
+
+	@ExtendWith(FooInstancePreDestroyCallback.class)
+	static class OuterTestCase extends Destroyable {
+
+		@BeforeEach
+		void beforeOuterMethod() {
+			callSequence.add("beforeOuterMethod");
+		}
+
+		@Test
+		void testOuter() {
+			assertFalse(isDestroyed);
+			callSequence.add("testOuter");
+		}
+
+		@Nested
+		@ExtendWith(BarInstancePreDestroyCallback.class)
+		class InnerTestCase extends Destroyable {
+
+			@BeforeEach
+			void beforeInnerMethod() {
+				assertFalse(isDestroyed);
+				callSequence.add("beforeInnerMethod");
+			}
+
+			@Test
+			void testInner() {
+				callSequence.add("testInner");
+			}
+		}
+	}
+
+	static class TestCaseWithTestSpecificTestInstancePreDestroyCallback extends Destroyable {
+
+		@BeforeEach
+		void beforeEachMethod() {
+			assertFalse(isDestroyed);
+			callSequence.add("beforeEachMethod");
+		}
+
+		@ExtendWith(FooInstancePreDestroyCallback.class)
+		@Test
+		void test() {
+			callSequence.add("test");
+		}
+	}
+
+	@TestInstance(TestInstance.Lifecycle.PER_CLASS)
+	@ExtendWith(FooInstancePreDestroyCallback.class)
+	static class PerClassLifecyclePreDestroyCallbackWithTwoTestMethods extends Destroyable {
+
+		@BeforeEach
+		void beforeEachMethod() {
+			callSequence.add("beforeEachMethod");
+		}
+
+		@Test
+		void test1() {
+			callSequence.add("test1");
+		}
+
+		@Test
+		void test2() {
+			callSequence.add("test2");
+		}
+	}
+
+	static class FooInstancePreDestroyCallback extends AbstractInstancePreDestroyCallback {
+
+		protected FooInstancePreDestroyCallback() {
+			super("foo");
+		}
+	}
+
+	static class BarInstancePreDestroyCallback extends AbstractInstancePreDestroyCallback {
+
+		protected BarInstancePreDestroyCallback() {
+			super("bar");
+		}
+	}
+
+	static abstract class AbstractInstancePreDestroyCallback implements TestInstancePreDestroyCallback {
+
+		private final String name;
+
+		AbstractInstancePreDestroyCallback(String name) {
+			this.name = name;
+		}
+
+		@Override
+		public void preDestroyTestInstance(ExtensionContext context) {
+			assertTrue(context.getTestInstance().isPresent());
+			Object testInstance = context.getTestInstance().get();
+			if (testInstance instanceof Destroyable) {
+				((Destroyable) testInstance).setDestroyed();
+			}
+			callSequence.add(name + "PreDestroyCallbackTestInstance:" + testInstance.getClass().getSimpleName());
+		}
+	}
+
+	private abstract static class Destroyable {
+
+		boolean isDestroyed;
+
+		void setDestroyed() {
+			isDestroyed = true;
+		}
+	}
+}
