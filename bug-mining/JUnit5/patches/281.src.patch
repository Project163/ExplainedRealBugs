diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.5.0-M2.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.5.0-M2.adoc
index 97d595085..31f5a02d8 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.5.0-M2.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.5.0-M2.adoc
@@ -29,6 +29,8 @@ on GitHub.
   meta-annotations on other repeatable annotations.
 * New `AnnotationSupport.findRepeatableAnnotations()` variant that accepts a
   `java.util.Optional<? extends AnnotatedElement>` argument.
+* Exceptions thrown by `TestExecutionListeners` no longer cause test execution to abort.
+  Instead, they will be logged as warnings now.
 
 
 [[release-notes-5.5.0-M2-junit-jupiter]]
diff --git a/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/TestExecutionListenerRegistry.java b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/TestExecutionListenerRegistry.java
index 1b4d9c8fa..97b2b0bd7 100644
--- a/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/TestExecutionListenerRegistry.java
+++ b/junit-platform-launcher/src/main/java/org/junit/platform/launcher/core/TestExecutionListenerRegistry.java
@@ -15,7 +15,11 @@ import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 import java.util.function.Consumer;
+import java.util.function.Supplier;
 
+import org.junit.platform.commons.logging.Logger;
+import org.junit.platform.commons.logging.LoggerFactory;
+import org.junit.platform.commons.util.BlacklistedExceptions;
 import org.junit.platform.engine.TestExecutionResult;
 import org.junit.platform.engine.reporting.ReportEntry;
 import org.junit.platform.launcher.TestExecutionListener;
@@ -26,6 +30,7 @@ import org.junit.platform.launcher.TestPlan;
  * @since 1.0
  */
 class TestExecutionListenerRegistry {
+	private static final Logger logger = LoggerFactory.getLogger(TestExecutionListenerRegistry.class);
 
 	private final List<TestExecutionListener> testExecutionListeners = new ArrayList<>();
 	private final List<EagerTestExecutionListener> eagerTestExecutionListeners = new ArrayList<>();
@@ -55,12 +60,18 @@ class TestExecutionListenerRegistry {
 		// @formatter:on
 	}
 
-	private void notifyTestExecutionListeners(Consumer<TestExecutionListener> consumer) {
-		this.testExecutionListeners.forEach(consumer);
-	}
-
-	private void notifyEagerTestExecutionListeners(Consumer<EagerTestExecutionListener> consumer) {
-		this.eagerTestExecutionListeners.forEach(consumer);
+	private <T extends TestExecutionListener> void notifyEach(List<T> listeners, Consumer<T> consumer,
+			Supplier<String> description) {
+		listeners.forEach(listener -> {
+			try {
+				consumer.accept(listener);
+			}
+			catch (Throwable throwable) {
+				BlacklistedExceptions.rethrowIfBlacklisted(throwable);
+				logger.warn(throwable, () -> String.format("TestExecutionListener [%s] threw exception for method: %s",
+					listener.getClass().getName(), description.get()));
+			}
+		});
 	}
 
 	TestExecutionListener getCompositeTestExecutionListener() {
@@ -71,40 +82,50 @@ class TestExecutionListenerRegistry {
 
 		@Override
 		public void dynamicTestRegistered(TestIdentifier testIdentifier) {
-			notifyTestExecutionListeners(listener -> listener.dynamicTestRegistered(testIdentifier));
+			notifyEach(testExecutionListeners, listener -> listener.dynamicTestRegistered(testIdentifier),
+				() -> "dynamicTestRegistered(" + testIdentifier + ")");
 		}
 
 		@Override
 		public void executionSkipped(TestIdentifier testIdentifier, String reason) {
-			notifyTestExecutionListeners(listener -> listener.executionSkipped(testIdentifier, reason));
+			notifyEach(testExecutionListeners, listener -> listener.executionSkipped(testIdentifier, reason),
+				() -> "executionSkipped(" + testIdentifier + ", " + reason + ")");
 		}
 
 		@Override
 		public void executionStarted(TestIdentifier testIdentifier) {
-			notifyEagerTestExecutionListeners(listener -> listener.executionJustStarted(testIdentifier));
-			notifyTestExecutionListeners(listener -> listener.executionStarted(testIdentifier));
+			notifyEach(eagerTestExecutionListeners, listener -> listener.executionJustStarted(testIdentifier),
+				() -> "executionJustStarted(" + testIdentifier + ")");
+			notifyEach(testExecutionListeners, listener -> listener.executionStarted(testIdentifier),
+				() -> "executionStarted(" + testIdentifier + ")");
 		}
 
 		@Override
 		public void executionFinished(TestIdentifier testIdentifier, TestExecutionResult testExecutionResult) {
-			notifyEagerTestExecutionListeners(
-				listener -> listener.executionJustFinished(testIdentifier, testExecutionResult));
-			notifyTestExecutionListeners(listener -> listener.executionFinished(testIdentifier, testExecutionResult));
+			notifyEach(eagerTestExecutionListeners,
+				listener -> listener.executionJustFinished(testIdentifier, testExecutionResult),
+				() -> "executionJustFinished(" + testIdentifier + ", " + testExecutionResult + ")");
+			notifyEach(testExecutionListeners,
+				listener -> listener.executionFinished(testIdentifier, testExecutionResult),
+				() -> "executionFinished(" + testIdentifier + ", " + testExecutionResult + ")");
 		}
 
 		@Override
 		public void testPlanExecutionStarted(TestPlan testPlan) {
-			notifyTestExecutionListeners(listener -> listener.testPlanExecutionStarted(testPlan));
+			notifyEach(testExecutionListeners, listener -> listener.testPlanExecutionStarted(testPlan),
+				() -> "testPlanExecutionStarted(" + testPlan + ")");
 		}
 
 		@Override
 		public void testPlanExecutionFinished(TestPlan testPlan) {
-			notifyTestExecutionListeners(listener -> listener.testPlanExecutionFinished(testPlan));
+			notifyEach(testExecutionListeners, listener -> listener.testPlanExecutionFinished(testPlan),
+				() -> "testPlanExecutionFinished(" + testPlan + ")");
 		}
 
 		@Override
 		public void reportingEntryPublished(TestIdentifier testIdentifier, ReportEntry entry) {
-			notifyTestExecutionListeners(listener -> listener.reportingEntryPublished(testIdentifier, entry));
+			notifyEach(testExecutionListeners, listener -> listener.reportingEntryPublished(testIdentifier, entry),
+				() -> "reportingEntryPublished(" + testIdentifier + ", " + entry + ")");
 		}
 
 	}
diff --git a/platform-tests/src/test/java/org/junit/platform/launcher/core/TestExecutionListenerRegistryTests.java b/platform-tests/src/test/java/org/junit/platform/launcher/core/TestExecutionListenerRegistryTests.java
new file mode 100644
index 000000000..8f789cad9
--- /dev/null
+++ b/platform-tests/src/test/java/org/junit/platform/launcher/core/TestExecutionListenerRegistryTests.java
@@ -0,0 +1,251 @@
+/*
+ * Copyright 2015-2019 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.platform.launcher.core;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+import static org.mockito.Mockito.mock;
+
+import java.lang.reflect.Method;
+import java.util.Collections;
+import java.util.logging.Level;
+import java.util.logging.LogRecord;
+
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.engine.TrackLogRecords;
+import org.junit.platform.commons.logging.LogRecordListener;
+import org.junit.platform.commons.util.ReflectionUtils;
+import org.junit.platform.engine.TestExecutionResult;
+import org.junit.platform.engine.UniqueId;
+import org.junit.platform.engine.reporting.ReportEntry;
+import org.junit.platform.engine.support.descriptor.DemoMethodTestDescriptor;
+import org.junit.platform.launcher.TestExecutionListener;
+import org.junit.platform.launcher.TestIdentifier;
+import org.junit.platform.launcher.TestPlan;
+
+@TrackLogRecords
+class TestExecutionListenerRegistryTests {
+
+	private TestExecutionListenerRegistry registry = new TestExecutionListenerRegistry();
+	private TestExecutionListener compositeTestExecutionListener;
+
+	@BeforeEach
+	void setUp() {
+		registry.registerListeners(new ThrowingTestExecutionListener());
+		compositeTestExecutionListener = registry.getCompositeTestExecutionListener();
+	}
+
+	@Test
+	void shouldNotThrowExceptionButLogIfDynamicTestRegisteredListenerMethodFails(LogRecordListener logRecordListener) {
+		TestIdentifier testIdentifier = getSampleMethodTestIdentifier();
+
+		compositeTestExecutionListener.dynamicTestRegistered(testIdentifier);
+
+		assertThatTestListenerErrorLogged(logRecordListener, ThrowingTestExecutionListener.class,
+			"dynamicTestRegistered");
+	}
+
+	@Test
+	void shouldNotThrowExceptionButLogIfExecutionStartedListenerMethodFails(LogRecordListener logRecordListener) {
+		TestIdentifier testIdentifier = getSampleMethodTestIdentifier();
+
+		compositeTestExecutionListener.executionStarted(testIdentifier);
+
+		assertThatTestListenerErrorLogged(logRecordListener, ThrowingTestExecutionListener.class, "executionStarted");
+	}
+
+	@Test
+	void shouldNotThrowExceptionButLogIfExecutionSkippedListenerMethodFails(LogRecordListener logRecordListener) {
+		TestIdentifier testIdentifier = getSampleMethodTestIdentifier();
+
+		compositeTestExecutionListener.executionSkipped(testIdentifier, "deliberately skipped container");
+
+		assertThatTestListenerErrorLogged(logRecordListener, ThrowingTestExecutionListener.class, "executionSkipped");
+	}
+
+	@Test
+	void shouldNotThrowExceptionButLogIfExecutionFinishedListenerMethodFails(LogRecordListener logRecordListener) {
+		TestIdentifier testIdentifier = getSampleMethodTestIdentifier();
+
+		compositeTestExecutionListener.executionFinished(testIdentifier, mock(TestExecutionResult.class));
+
+		assertThatTestListenerErrorLogged(logRecordListener, ThrowingTestExecutionListener.class, "executionFinished");
+	}
+
+	@Test
+	void shouldNotThrowExceptionButLogIfReportingEntryPublishedListenerMethodFails(
+			LogRecordListener logRecordListener) {
+		TestIdentifier testIdentifier = getSampleMethodTestIdentifier();
+
+		compositeTestExecutionListener.reportingEntryPublished(testIdentifier, ReportEntry.from("one", "two"));
+
+		assertThatTestListenerErrorLogged(logRecordListener, ThrowingTestExecutionListener.class,
+			"reportingEntryPublished");
+	}
+
+	@Test
+	void shouldNotThrowExceptionButLogIfTesPlanExecutionStartedListenerMethodFails(
+			LogRecordListener logRecordListener) {
+		DemoMethodTestDescriptor testDescriptor = getDemoMethodTestDescriptor();
+
+		compositeTestExecutionListener.testPlanExecutionStarted(TestPlan.from(Collections.singleton(testDescriptor)));
+
+		assertThatTestListenerErrorLogged(logRecordListener, ThrowingTestExecutionListener.class,
+			"testPlanExecutionStarted");
+	}
+
+	@Test
+	void shouldNotThrowExceptionButLogIfTesPlanExecutionFinishedListenerMethodFails(
+			LogRecordListener logRecordListener) {
+		DemoMethodTestDescriptor testDescriptor = getDemoMethodTestDescriptor();
+
+		compositeTestExecutionListener.testPlanExecutionFinished(TestPlan.from(Collections.singleton(testDescriptor)));
+
+		assertThatTestListenerErrorLogged(logRecordListener, ThrowingTestExecutionListener.class,
+			"testPlanExecutionFinished");
+	}
+
+	@Test
+	void shouldNotThrowExceptionButLogIfExecutionJustStartedEagerTestListenerMethodFails(
+			LogRecordListener logRecordListener) {
+		registry.registerListeners(new ThrowingEagerTestExecutionListener());
+
+		TestIdentifier testIdentifier = getSampleMethodTestIdentifier();
+		compositeTestExecutionListener.executionStarted(testIdentifier);
+
+		assertThatTestListenerErrorLogged(logRecordListener, ThrowingEagerTestExecutionListener.class,
+			"executionJustStarted");
+	}
+
+	@Test
+	void shouldNotThrowExceptionButLogIfExecutionJustFinishedEagerTestListenerMethodFails(
+			LogRecordListener logRecordListener) {
+		registry.registerListeners(new ThrowingEagerTestExecutionListener());
+
+		TestIdentifier testIdentifier = getSampleMethodTestIdentifier();
+		compositeTestExecutionListener.executionFinished(testIdentifier, mock(TestExecutionResult.class));
+
+		assertThatTestListenerErrorLogged(logRecordListener, ThrowingEagerTestExecutionListener.class,
+			"executionJustFinished");
+	}
+
+	@Test
+	void shouldThrowOutOfMemoryExceptionAndStopListenerWithoutLog(LogRecordListener logRecordListener) {
+		TestExecutionListenerRegistry registry = new TestExecutionListenerRegistry();
+		registry.registerListeners(new TestExecutionListener() {
+			@Override
+			public void executionStarted(TestIdentifier testIdentifier) {
+				throw new OutOfMemoryError();
+			}
+		});
+		TestIdentifier testIdentifier = getSampleMethodTestIdentifier();
+		assertThatThrownBy(
+			() -> registry.getCompositeTestExecutionListener().executionStarted(testIdentifier)).isInstanceOf(
+				OutOfMemoryError.class);
+
+		assertNotLogs(logRecordListener);
+	}
+
+	@Test
+	void shouldThrowOutOfMemoryExceptionAndStopEagerListenerWithoutLog(LogRecordListener logRecordListener) {
+		TestExecutionListenerRegistry registry = new TestExecutionListenerRegistry();
+		registry.registerListeners(new TestExecutionListenerRegistry.EagerTestExecutionListener() {
+			@Override
+			public void executionJustStarted(TestIdentifier testIdentifier) {
+				throw new OutOfMemoryError();
+			}
+		});
+		TestIdentifier testIdentifier = getSampleMethodTestIdentifier();
+		assertThatThrownBy(
+			() -> registry.getCompositeTestExecutionListener().executionStarted(testIdentifier)).isInstanceOf(
+				OutOfMemoryError.class);
+
+		assertNotLogs(logRecordListener);
+	}
+
+	private LogRecord firstWarnLogRecord(LogRecordListener logRecordListener) throws AssertionError {
+		return logRecordListener.stream(TestExecutionListenerRegistry.class, Level.WARNING).findFirst().orElseThrow(
+			() -> new AssertionError("Failed to find error log record"));
+	}
+
+	private void assertNotLogs(LogRecordListener logRecordListener) throws AssertionError {
+		assertThat(logRecordListener.stream(TestExecutionListenerRegistry.class, Level.WARNING).count()).isZero();
+	}
+
+	private TestIdentifier getSampleMethodTestIdentifier() {
+		DemoMethodTestDescriptor demoMethodTestDescriptor = getDemoMethodTestDescriptor();
+		return TestIdentifier.from(demoMethodTestDescriptor);
+	}
+
+	private void assertThatTestListenerErrorLogged(LogRecordListener logRecordListener, Class<?> listenerClass,
+			String methodName) {
+		assertThat(firstWarnLogRecord(logRecordListener).getMessage()).startsWith(
+			"TestExecutionListener [" + listenerClass.getName() + "] threw exception for method: " + methodName);
+	}
+
+	private DemoMethodTestDescriptor getDemoMethodTestDescriptor() {
+		Method method = ReflectionUtils.findMethod(this.getClass(), "getDemoMethodTestDescriptor",
+			new Class<?>[0]).orElseThrow();
+		return new DemoMethodTestDescriptor(UniqueId.root("method", "unique_id"), this.getClass(), method);
+	}
+
+	private static class ThrowingEagerTestExecutionListener extends ThrowingTestExecutionListener
+			implements TestExecutionListenerRegistry.EagerTestExecutionListener {
+		@Override
+		public void executionJustStarted(TestIdentifier testIdentifier) {
+			throw new RuntimeException("failed to invoke listener");
+		}
+
+		@Override
+		public void executionJustFinished(TestIdentifier testIdentifier, TestExecutionResult testExecutionResult) {
+			throw new RuntimeException("failed to invoke listener");
+		}
+	}
+
+	private static class ThrowingTestExecutionListener implements TestExecutionListener {
+		@Override
+		public void testPlanExecutionStarted(TestPlan testPlan) {
+			throw new RuntimeException("failed to invoke listener");
+		}
+
+		@Override
+		public void testPlanExecutionFinished(TestPlan testPlan) {
+			throw new RuntimeException("failed to invoke listener");
+		}
+
+		@Override
+		public void dynamicTestRegistered(TestIdentifier testIdentifier) {
+			throw new RuntimeException("failed to invoke listener");
+		}
+
+		@Override
+		public void executionStarted(TestIdentifier testIdentifier) {
+			throw new RuntimeException("failed to invoke listener");
+		}
+
+		@Override
+		public void executionSkipped(TestIdentifier testIdentifier, String reason) {
+			throw new RuntimeException("failed to invoke listener");
+		}
+
+		@Override
+		public void executionFinished(TestIdentifier testIdentifier, TestExecutionResult testExecutionResult) {
+			throw new RuntimeException("failed to invoke listener");
+		}
+
+		@Override
+		public void reportingEntryPublished(TestIdentifier testIdentifier, ReportEntry entry) {
+			throw new RuntimeException("failed to invoke listener");
+		}
+	}
+
+}
diff --git a/platform-tests/src/test/resources/log4j2-test.xml b/platform-tests/src/test/resources/log4j2-test.xml
index 57e317c4d..ec5fed0b3 100644
--- a/platform-tests/src/test/resources/log4j2-test.xml
+++ b/platform-tests/src/test/resources/log4j2-test.xml
@@ -11,6 +11,7 @@
 		<Logger name="org.junit.platform.engine.support.descriptor.DemoClassTestDescriptor" level="error" />
 		<Logger name="org.junit.platform.launcher.core.DefaultLauncher" level="error" />
 		<Logger name="org.junit.platform.launcher.core.InternalTestPlan" level="error" />
+		<Logger name="org.junit.platform.launcher.core.TestExecutionListenerRegistry" level="error" />
 		<Logger name="org.junit.ApiReportGenerator" level="error" />
 		<Logger name="org.junit.vintage.engine" level="error" />
 		<Logger name="org.junit.jupiter.engine" level="error" />
