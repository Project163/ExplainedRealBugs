diff --git a/documentation/src/docs/asciidoc/writing-tests.adoc b/documentation/src/docs/asciidoc/writing-tests.adoc
index 833b2c67f..d7e1e8beb 100644
--- a/documentation/src/docs/asciidoc/writing-tests.adoc
+++ b/documentation/src/docs/asciidoc/writing-tests.adoc
@@ -394,6 +394,9 @@ Technically speaking, a `@TestFactory` method must return a `Stream`,
 These `DynamicTest` instances will then be executed lazily,
 enabling dynamic and even non-deterministic generation of test cases.
 
+Any `Stream` returned by a `@TestFactory` will be properly closed by calling `stream.close()`,
+making it safe to use a resource such as `Files.lines()`.
+
 As with `@Test` methods, `@TestFactory` methods must not be `private` or `static`
 and may optionally declare parameters to be resolved by `ParameterResolvers`.
 
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/TestFactory.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/TestFactory.java
index 35968f874..51f00a9f9 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/TestFactory.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/TestFactory.java
@@ -34,6 +34,10 @@ import org.junit.platform.commons.meta.API;
  * will then be executed lazily, enabling dynamic and even non-deterministic
  * generation of test cases.
  *
+ * <p>Any {@code Stream} returned by a {@code @TestFactory} will be properly
+ * closed by calling {@code stream.close()}, making it safe to use a resource
+ * such as {@code Files.lines()}.
+ *
  * <p>{@code @TestFactory} methods may optionally declare parameters to be
  * resolved by {@link org.junit.jupiter.api.extension.ParameterResolver
  * ParameterResolvers}.
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestFactoryTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestFactoryTestDescriptor.java
index 6cd1ccb68..3c6040fb4 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestFactoryTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/TestFactoryTestDescriptor.java
@@ -81,9 +81,10 @@ public class TestFactoryTestDescriptor extends MethodTestDescriptor {
 			Object testFactoryMethodResult = executableInvoker.invoke(method, instance, testExtensionContext,
 				context.getExtensionRegistry());
 
-			try {
+			try (Stream<DynamicTest> dynamicTestStream = toDynamicTestStream(testExtensionContext,
+				testFactoryMethodResult)) {
 				AtomicInteger index = new AtomicInteger();
-				toDynamicTestStream(testExtensionContext, testFactoryMethodResult).forEach(
+				dynamicTestStream.forEach(
 					dynamicTest -> registerAndExecute(dynamicTest, index.incrementAndGet(), dynamicTestExecutor));
 			}
 			catch (ClassCastException ex) {
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/descriptor/DynamicTestStreamClosedTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/descriptor/DynamicTestStreamClosedTests.java
new file mode 100644
index 000000000..6ff6f2518
--- /dev/null
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/descriptor/DynamicTestStreamClosedTests.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright 2015-2017 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v1.0 which
+ * accompanies this distribution and is available at
+ *
+ * http://www.eclipse.org/legal/epl-v10.html
+ */
+
+package org.junit.jupiter.engine.descriptor;
+
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import java.lang.reflect.Method;
+import java.util.Optional;
+import java.util.stream.Stream;
+
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.DynamicTest;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.TestFactory;
+import org.junit.jupiter.api.extension.TestExtensionContext;
+import org.junit.jupiter.engine.execution.JupiterEngineExecutionContext;
+import org.junit.jupiter.engine.execution.ThrowableCollector;
+import org.junit.platform.engine.UniqueId;
+import org.junit.platform.engine.support.hierarchical.Node;
+
+class DynamicTestStreamClosedTests {
+	private JupiterEngineExecutionContext context;
+	private Method testMethod;
+	private TestExtensionContext testExtensionContext;
+	private boolean isClosed;
+
+	@BeforeEach
+	void before() {
+		testExtensionContext = mock(TestExtensionContext.class);
+		isClosed = false;
+
+		context = new JupiterEngineExecutionContext(null, null).extend().withThrowableCollector(
+			new ThrowableCollector()).withExtensionContext(testExtensionContext).build();
+	}
+
+	@Test
+	void streamsFromTestFactoriesShouldBeClosed() throws NoSuchMethodException {
+		testMethod = DynamicCloseHookedStreamTest.class.getMethod("customStream");
+		when(testExtensionContext.getTestMethod()).thenReturn(Optional.of(testMethod));
+
+		Stream<DynamicTest> stream = Stream.empty();
+		Stream<DynamicTest> onCloseStream = stream.onClose(() -> isClosed = true);
+		when(testExtensionContext.getTestInstance()).thenReturn(new DynamicCloseHookedStreamTest(onCloseStream));
+
+		TestFactoryTestDescriptor descriptor = new TestFactoryTestDescriptor(UniqueId.forEngine("engine"),
+			DynamicCloseHookedStreamTest.class, testMethod);
+
+		descriptor.invokeTestMethod(context, mock(Node.DynamicTestExecutor.class));
+		assertTrue(isClosed);
+	}
+
+	@Test
+	void streamsFromTestFactoriesShouldBeClosedWhenTheyThrow() throws NoSuchMethodException {
+		testMethod = StreamOfIntClosedTest.class.getMethod("customStream");
+		when(testExtensionContext.getTestMethod()).thenReturn(Optional.of(testMethod));
+
+		Stream<Integer> mockStream = Stream.of(1, 2).onClose(() -> isClosed = true);
+		when(testExtensionContext.getTestInstance()).thenReturn(new StreamOfIntClosedTest(mockStream));
+
+		TestFactoryTestDescriptor descriptor = new TestFactoryTestDescriptor(UniqueId.forEngine("engine"),
+			StreamOfIntClosedTest.class, testMethod);
+		descriptor.invokeTestMethod(context, mock(Node.DynamicTestExecutor.class));
+
+		assertTrue(isClosed);
+	}
+
+	private static class DynamicCloseHookedStreamTest {
+		private Stream<DynamicTest> mockStream;
+
+		DynamicCloseHookedStreamTest(Stream<DynamicTest> mockStream) {
+			this.mockStream = mockStream;
+		}
+
+		@TestFactory
+		public Stream<DynamicTest> customStream() {
+			return mockStream;
+		}
+	}
+
+	private static class StreamOfIntClosedTest {
+		private Stream<Integer> mockStream;
+
+		StreamOfIntClosedTest(Stream<Integer> mockStream) {
+			this.mockStream = mockStream;
+		}
+
+		@TestFactory
+		public Stream<Integer> customStream() {
+			return mockStream;
+		}
+	}
+}
