diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.8.2.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.8.2.adoc
index dfed4d1ea..cd31ac980 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.8.2.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.8.2.adoc
@@ -3,7 +3,10 @@
 
 *Date of Release:* ❓
 
-*Scope:* ❓
+*Scope:*
+
+* Text blocks in `@CsvSource` are treated as CSV files
+* Custom quote character support in `@CsvSource`
 
 For a complete list of all _closed_ issues and pull requests for this release, consult the
 link:{junit5-repo}+/milestone/60?closed=1+[5.8.2] milestone page in the JUnit repository on
@@ -39,6 +42,11 @@ GitHub.
 
 ==== New Features and Improvements
 
+* Text blocks in `@CsvSource` are now treated as complete CSV files, including support for
+  comments beginning with a `+++#+++` symbol as well as support for new lines within
+  quoted strings. See the
+  <<../user-guide/index.adoc#writing-tests-parameterized-tests-sources-CsvSource, User
+  Guide>> for details and examples.
 * The quote character for _quoted strings_ in `@CsvSource` is now configurable via the new
   `quoteCharacter` attribute, which defaults to a single quote (`'`) for backward
   compatibility.
diff --git a/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc b/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
index a2e26e863..0bc94d85b 100644
--- a/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
+++ b/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
@@ -1332,32 +1332,13 @@ include::{testDir}/example/ExternalMethodSourceDemo.java[tags=external_MethodSou
 
 `@CsvSource` allows you to express argument lists as comma-separated values (i.e., CSV
 `String` literals). Each string provided via the `value` attribute in `@CsvSource`
-represents a CSV line and results in one invocation of the parameterized test.
+represents a CSV record and results in one invocation of the parameterized test.
 
 [source,java,indent=0]
 ----
 include::{testDir}/example/ParameterizedTestDemo.java[tags=CsvSource_example]
 ----
 
-If the programming language you are using supports _text blocks_ -- for example, Java SE
-15 or higher -- you can alternatively use the `textBlock` attribute of `@CsvSource`. Each
-line within a text block represents a CSV line and results in one invocation of the
-parameterized test. Using a text block, the previous example can be implemented as follows.
-
-[source,java,indent=0]
-----
-@ParameterizedTest
-@CsvSource(textBlock = """
-	apple,         1
-	banana,        2
-	'lemon, lime', 0xF1
-	strawberry,    700_000
-""")
-void testWithCsvSource(String fruit, int rank) {
-	// ...
-}
-----
-
 The default delimiter is a comma (`,`), but you can use another character by setting the
 `delimiter` attribute. Alternatively, the `delimiterString` attribute allows you to use a
 `String` delimiter instead of a single character. However, both delimiter attributes
@@ -1391,11 +1372,69 @@ by default. This behavior can be changed by setting the
 | `@CsvSource(value = { " apple , banana" }, ignoreLeadingAndTrailingWhitespace = false)` | `" apple "`, `" banana"`
 |===
 
+If the programming language you are using supports _text blocks_ -- for example, Java SE
+15 or higher -- you can alternatively use the `textBlock` attribute of `@CsvSource`. Each
+record within a text block represents a CSV record and results in one invocation of the
+parameterized test. Using a text block, the previous example can be implemented as follows.
+
+[source,java,indent=0]
+----
+@ParameterizedTest
+@CsvSource(textBlock = """
+	apple,         1
+	banana,        2
+	'lemon, lime', 0xF1
+	strawberry,    700_000
+	""")
+void testWithCsvSource(String fruit, int rank) {
+	// ...
+}
+----
+
+In contrast to CSV records supplied via the `value` attribute, a text block can contain
+comments. Any line beginning with a `+++#+++` symbol will be treated as a comment and
+ignored. Note, however, that the `+++#+++` symbol must be the first character on the line
+without any leading whitespace. It is therefore recommended that the closing text block
+delimiter `"""` be placed either at the end of the last line of input or on the following
+line, left aligned with the rest of the input (as can be seen in the example below which
+demonstrates formatting similar to a table).
+
+[source,java,indent=0]
+----
+@ParameterizedTest
+@CsvSource(delimiter = '|', quoteCharacter = '"', textBlock = """
+	#-----------------------------
+	#    FRUIT     |     RANK
+	#-----------------------------
+	     apple     |      1
+	#-----------------------------
+	     banana    |      2
+	#-----------------------------
+	  "lemon lime" |     0xF1
+	#-----------------------------
+	   strawberry  |    700_000
+	#-----------------------------
+	""")
+void testWithCsvSource(String fruit, int rank) {
+	// ...
+}
+----
+
+[NOTE]
+====
+Java's https://docs.oracle.com/en/java/javase/15/text-blocks/index.html[text block]
+feature automatically removes _incidental whitespace_ when the code is compiled.
+However other JVM languages such as Groovy and Kotlin do not. Thus, if you are using a
+programming language other than Java and your text block contains comments or new lines
+within quoted strings, you will need to ensure that there is no leading whitespace within
+your text block.
+====
+
 [[writing-tests-parameterized-tests-sources-CsvFileSource]]
 ===== @CsvFileSource
 
 `@CsvFileSource` lets you use comma-separated value (CSV) files from the classpath or the
-local file system. Each line from a CSV file results in one invocation of the
+local file system. Each record from a CSV file results in one invocation of the
 parameterized test.
 
 The default delimiter is a comma (`,`), but you can use another character by setting the
@@ -1404,8 +1443,8 @@ The default delimiter is a comma (`,`), but you can use another character by set
 cannot be set simultaneously.
 
 .Comments in CSV files
-NOTE: Any line beginning with a `#` symbol will be interpreted as a comment and will be
-ignored.
+NOTE: Any line beginning with a `+++#+++` symbol will be interpreted as a comment and will
+be ignored.
 
 [source,java,indent=0]
 ----
@@ -1418,13 +1457,13 @@ include::{testDir}/example/ParameterizedTestDemo.java[tags=CsvFileSource_example
 include::{testResourcesDir}/two-column.csv[]
 ----
 
-In contrast to the syntax used in `@CsvSource`, `@CsvFileSource` uses a double quote `"`
-as the quote character. See the `"United States of America"` value in the example above.
-An empty, quoted value `""` results in an empty `String` unless the `emptyValue` attribute
-is set; whereas, an entirely _empty_ value is interpreted as a `null` reference. By
-specifying one or more `nullValues`, a custom value can be interpreted as a `null`
-reference. An `ArgumentConversionException` is thrown if the target type of a `null`
-reference is a primitive type.
+In contrast to the default syntax used in `@CsvSource`, `@CsvFileSource` uses a double
+quote `"` as the quote character. See the `"United States of America"` value in the
+example above. An empty, quoted value `""` results in an empty `String` unless the
+`emptyValue` attribute is set; whereas, an entirely _empty_ value is interpreted as a
+`null` reference. By specifying one or more `nullValues`, a custom value can be
+interpreted as a `null` reference. An `ArgumentConversionException` is thrown if the
+target type of a `null` reference is a primitive type.
 
 NOTE: An _unquoted_ empty value will always be converted to a `null` reference regardless
 of any custom values configured via the `nullValues` attribute.
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvArgumentsProvider.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvArgumentsProvider.java
index 1bbf4f637..a218d1f02 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvArgumentsProvider.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvArgumentsProvider.java
@@ -13,11 +13,12 @@ package org.junit.jupiter.params.provider;
 import static org.junit.jupiter.params.provider.CsvParserFactory.createParserFor;
 import static org.junit.platform.commons.util.CollectionUtils.toSet;
 
+import java.io.StringReader;
 import java.lang.annotation.Annotation;
 import java.util.Arrays;
+import java.util.List;
 import java.util.Set;
 import java.util.concurrent.atomic.AtomicInteger;
-import java.util.regex.Pattern;
 import java.util.stream.Stream;
 
 import com.univocity.parsers.csv.CsvParser;
@@ -33,8 +34,6 @@ import org.junit.platform.commons.util.UnrecoverableExceptions;
  */
 class CsvArgumentsProvider implements ArgumentsProvider, AnnotationConsumer<CsvSource> {
 
-	private static final Pattern NEW_LINE_REGEX = Pattern.compile("\\n");
-
 	private static final String LINE_SEPARATOR = "\n";
 
 	private CsvSource annotation;
@@ -54,22 +53,35 @@ class CsvArgumentsProvider implements ArgumentsProvider, AnnotationConsumer<CsvS
 		Preconditions.condition(this.annotation.value().length > 0 ^ textBlockDeclared,
 			() -> "@CsvSource must be declared with either `value` or `textBlock` but not both");
 
-		String[] lines;
 		if (textBlockDeclared) {
-			lines = NEW_LINE_REGEX.split(this.annotation.textBlock(), 0);
-		}
-		else {
-			lines = this.annotation.value();
+			return parseTextBlock(this.annotation.textBlock()).stream().map(Arguments::of);
 		}
 
-		AtomicInteger index = new AtomicInteger(1);
+		AtomicInteger index = new AtomicInteger(0);
 		// @formatter:off
-		return Arrays.stream(lines)
-				.map(line -> parseLine(line, index.getAndIncrement()))
+		return Arrays.stream(this.annotation.value())
+				.map(line -> parseLine(line, index.incrementAndGet()))
 				.map(Arguments::of);
 		// @formatter:on
 	}
 
+	private List<String[]> parseTextBlock(String textBlock) {
+		try {
+			AtomicInteger index = new AtomicInteger(0);
+			List<String[]> csvRecords = this.csvParser.parseAll(new StringReader(textBlock));
+			for (String[] csvRecord : csvRecords) {
+				index.incrementAndGet();
+				Preconditions.notNull(csvRecord,
+					() -> "Line at index " + index.get() + " contains invalid CSV: \"\"\"\n" + textBlock + "\n\"\"\"");
+				processNullValues(csvRecord, this.nullValues);
+			}
+			return csvRecords;
+		}
+		catch (Throwable throwable) {
+			throw handleCsvException(throwable, this.annotation);
+		}
+	}
+
 	private String[] parseLine(String line, int index) {
 		try {
 			String[] csvRecord = this.csvParser.parseLine(line + LINE_SEPARATOR);
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvFileSource.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvFileSource.java
index 4749e8de3..1c582b2ea 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvFileSource.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvFileSource.java
@@ -23,19 +23,19 @@ import org.apiguardian.api.API;
 
 /**
  * {@code @CsvFileSource} is an {@link ArgumentsSource} which is used to load
- * comma-separated value (CSV) files from one or more classpath {@link #resources
- * resources} or {@link #files}.
+ * comma-separated value (CSV) files from one or more classpath {@link #resources}
+ * or {@link #files}.
  *
- * <p>The lines of these CSV files will be provided as arguments to the annotated
- * {@code @ParameterizedTest} method.
+ * <p>The CSV records parsed from these resources and files will be provided as
+ * arguments to the annotated {@code @ParameterizedTest} method.
  *
  * <p>Any line beginning with a {@code #} symbol will be interpreted as a comment
  * and will be ignored.
  *
- * <p>The column delimiter (defaults to comma) can be customized with either
- * {@link #delimiter} or {@link #delimiterString}.
+ * <p>The column delimiter (which defaults to a comma ({@code ,})) can be customized
+ * via either {@link #delimiter} or {@link #delimiterString}.
  *
- * <p>In contrast to the syntax used in {@code @CsvSource}, {@code @CsvFileSource}
+ * <p>In contrast to the default syntax used in {@code @CsvSource}, {@code @CsvFileSource}
  * uses a double quote ({@code "}) as its quote character (see the User Guide for
  * examples). An empty, quoted value ({@code ""}) results in an empty {@link String}
  * unless the {@link #emptyValue} attribute is set; whereas, an entirely <em>empty</em>
@@ -89,7 +89,7 @@ public @interface CsvFileSource {
 
 	/**
 	 * The line separator to use when reading the CSV files; must consist of 1
-	 * or 2 characters.
+	 * or 2 characters, typically {@code "\r"}, {@code "\n"}, or {@code "\r\n"}.
 	 *
 	 * <p>Defaults to {@code "\n"}.
 	 */
@@ -159,7 +159,7 @@ public @interface CsvFileSource {
 	String[] nullValues() default {};
 
 	/**
-	 * The maximum characters of per CSV column allowed.
+	 * The maximum number of characters allowed per CSV column.
 	 *
 	 * <p>Must be a positive number.
 	 *
@@ -171,8 +171,8 @@ public @interface CsvFileSource {
 	int maxCharsPerColumn() default 4096;
 
 	/**
-	 * Identifies whether leading and trailing whitespace characters of
-	 * unquoted CSV columns should be ignored.
+	 * Controls whether leading and trailing whitespace characters of unquoted
+	 * CSV columns should be ignored.
 	 *
 	 * <p>Defaults to {@code true}.
 	 *
@@ -180,4 +180,5 @@ public @interface CsvFileSource {
 	 */
 	@API(status = EXPERIMENTAL, since = "5.8")
 	boolean ignoreLeadingAndTrailingWhitespace() default true;
+
 }
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvParserFactory.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvParserFactory.java
index 59517d357..c55a88e1f 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvParserFactory.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvParserFactory.java
@@ -26,14 +26,13 @@ class CsvParserFactory {
 	private static final String LINE_SEPARATOR = "\n";
 	private static final char DOUBLE_QUOTE = '"';
 	private static final char EMPTY_CHAR = '\0';
-	private static final boolean COMMENT_PROCESSING_FOR_CSV_SOURCE = false;
 	private static final boolean COMMENT_PROCESSING_FOR_CSV_FILE_SOURCE = true;
 
 	static CsvParser createParserFor(CsvSource annotation) {
 		String delimiter = selectDelimiter(annotation, annotation.delimiter(), annotation.delimiterString());
+		boolean commentProcessingEnabled = !annotation.textBlock().isEmpty();
 		return createParser(delimiter, LINE_SEPARATOR, annotation.quoteCharacter(), annotation.emptyValue(),
-			annotation.maxCharsPerColumn(), COMMENT_PROCESSING_FOR_CSV_SOURCE,
-			annotation.ignoreLeadingAndTrailingWhitespace());
+			annotation.maxCharsPerColumn(), commentProcessingEnabled, annotation.ignoreLeadingAndTrailingWhitespace());
 	}
 
 	static CsvParser createParserFor(CsvFileSource annotation) {
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvSource.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvSource.java
index 01958dd02..40c3ec3d0 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvSource.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvSource.java
@@ -23,14 +23,14 @@ import org.apiguardian.api.API;
 
 /**
  * {@code @CsvSource} is an {@link ArgumentsSource} which reads comma-separated
- * values (CSV) from one or more CSV lines supplied via the {@link #value}
+ * values (CSV) from one or more CSV records supplied via the {@link #value}
  * attribute or {@link #textBlock} attribute.
  *
  * <p>The supplied values will be provided as arguments to the annotated
  * {@code @ParameterizedTest} method.
  *
- * <p>The column delimiter (defaults to comma) can be customized with either
- * {@link #delimiter} or {@link #delimiterString}.
+ * <p>The column delimiter (which defaults to a comma ({@code ,})) can be customized
+ * via either {@link #delimiter} or {@link #delimiterString}.
  *
  * <p>By default, {@code @CsvSource} uses a single quote ({@code '}) as its quote
  * character, but this can be changed via {@link #quoteCharacter}. See the
@@ -52,6 +52,12 @@ import org.apiguardian.api.API;
  * column is trimmed by default. This behavior can be changed by setting the
  * {@link #ignoreLeadingAndTrailingWhitespace} attribute to {@code true}.
  *
+ * <p>In general, CSV records should not contain explicit newlines ({@code \n})
+ * unless they are placed within quoted strings. Note that CSV records supplied
+ * via {@link #textBlock} will implicitly contain newlines at the end of each
+ * physical line within the text block. Thus, if a CSV column wraps across a
+ * new line in a text block, the column must be a quoted string.
+ *
  * @since 5.0
  * @see CsvFileSource
  * @see org.junit.jupiter.params.provider.ArgumentsSource
@@ -65,14 +71,14 @@ import org.apiguardian.api.API;
 public @interface CsvSource {
 
 	/**
-	 * The CSV lines to use as the source of arguments; must not be empty.
-	 *
-	 * <p>Each value corresponds to a line in a CSV file and will be split using
-	 * the specified {@link #delimiter} or {@link #delimiterString}.
+	 * The CSV records to use as the source of arguments; must not be empty.
 	 *
 	 * <p>Defaults to an empty array. You therefore must supply CSV content
 	 * via this attribute or the {@link #textBlock} attribute.
 	 *
+	 * <p>Each value corresponds to a record in a CSV file and will be split using
+	 * the specified {@link #delimiter} or {@link #delimiterString}.
+	 *
 	 * <p>If <em>text block</em> syntax is supported by your programming language,
 	 * you may find it more convenient to declare your CSV content via the
 	 * {@link #textBlock} attribute.
@@ -95,12 +101,9 @@ public @interface CsvSource {
 	String[] value() default {};
 
 	/**
-	 * The CSV lines to use as the source of arguments, supplied as a single
+	 * The CSV records to use as the source of arguments, supplied as a single
 	 * <em>text block</em>; must not be empty.
 	 *
-	 * <p>Each line in the text block corresponds to a line in a CSV file and will
-	 * be split using the specified {@link #delimiter} or {@link #delimiterString}.
-	 *
 	 * <p>Defaults to an empty string. You therefore must supply CSV content
 	 * via this attribute or the {@link #value} attribute.
 	 *
@@ -108,13 +111,33 @@ public @interface CsvSource {
 	 * including Java SE 15 or higher. If text blocks are not supported, you
 	 * should declare your CSV content via the {@link #value} attribute.
 	 *
+	 * <p>Each record in the text block corresponds to a record in a CSV file and will
+	 * be split using the specified {@link #delimiter} or {@link #delimiterString}.
+	 *
+	 * <p>In contrast to CSV records supplied via {@link #value}, a text block
+	 * can contain comments. Any line beginning with a hash tag ({@code #}) will
+	 * be treated as a comment and ignored. Note, however, that the {@code #}
+	 * symbol must be the first character on the line without any leading
+	 * whitespace. It is therefore recommended that the closing text block
+	 * delimiter {@code """} be placed either at the end of the last line of
+	 * input or on the following line, vertically aligned with the rest of the
+	 * input (as can be seen in the example below).
+	 *
+	 * <p>Java's <a href="https://docs.oracle.com/en/java/javase/15/text-blocks/index.html">text block</a>
+	 * feature automatically removes <em>incidental whitespace</em> when the code
+	 * is compiled. However other JVM languages such as Groovy and Kotlin do not.
+	 * Thus, if you are using a programming language other than Java and your text
+	 * block contains comments or new lines within quoted strings, you will need
+	 * to ensure that there is no leading whitespace within your text block.
+	 *
 	 * <h4>Example</h4>
 	 * <pre class="code">
 	 * {@literal @}ParameterizedTest
-	 * {@literal @}CsvSource(textBlock = """
+	 * {@literal @}CsvSource(quoteCharacter = '"', textBlock = """
+	 *     # FRUIT,       RANK
 	 *     apple,         1
 	 *     banana,        2
-	 *     'lemon, lime', 0xF1
+	 *     "lemon, lime", 0xF1
 	 *     strawberry,    700_000
 	 *     """)
 	 * void test(String fruit, int rank) {
@@ -123,6 +146,7 @@ public @interface CsvSource {
 	 *
 	 * @since 5.8.1
 	 * @see #value
+	 * @see #quoteCharacter
 	 */
 	@API(status = EXPERIMENTAL, since = "5.8.1")
 	String textBlock() default "";
@@ -143,7 +167,7 @@ public @interface CsvSource {
 	char quoteCharacter() default '\'';
 
 	/**
-	 * The column delimiter character to use when reading the {@linkplain #value lines}.
+	 * The column delimiter character to use when reading the {@linkplain #value records}.
 	 *
 	 * <p>This is an alternative to {@link #delimiterString} and cannot be
 	 * used in conjunction with {@link #delimiterString}.
@@ -154,7 +178,7 @@ public @interface CsvSource {
 	char delimiter() default '\0';
 
 	/**
-	 * The column delimiter string to use when reading the {@linkplain #value lines}.
+	 * The column delimiter string to use when reading the {@linkplain #value records}.
 	 *
 	 * <p>This is an alternative to {@link #delimiter} and cannot be used in
 	 * conjunction with {@link #delimiter}.
@@ -167,7 +191,7 @@ public @interface CsvSource {
 	String delimiterString() default "";
 
 	/**
-	 * The empty value to use when reading the {@linkplain #value lines}.
+	 * The empty value to use when reading the {@linkplain #value records}.
 	 *
 	 * <p>This value replaces quoted empty strings read from the input.
 	 *
@@ -195,7 +219,7 @@ public @interface CsvSource {
 	String[] nullValues() default {};
 
 	/**
-	 * The maximum characters of per CSV column allowed.
+	 * The maximum number of characters allowed per CSV column.
 	 *
 	 * <p>Must be a positive number.
 	 *
@@ -207,8 +231,8 @@ public @interface CsvSource {
 	int maxCharsPerColumn() default 4096;
 
 	/**
-	 * Identifies whether leading and trailing whitespace characters of
-	 * unquoted CSV columns should be ignored.
+	 * Controls whether leading and trailing whitespace characters of unquoted
+	 * CSV columns should be ignored.
 	 *
 	 * <p>Defaults to {@code true}.
 	 *
diff --git a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestIntegrationTests.java b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestIntegrationTests.java
index 5a3ab2c81..9bd67544c 100644
--- a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestIntegrationTests.java
+++ b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestIntegrationTests.java
@@ -92,10 +92,21 @@ class ParameterizedTestIntegrationTests {
 
 	@ParameterizedTest
 	@CsvSource(quoteCharacter = '"', textBlock = """
-				apple,         1
-				banana,        2
-				"lemon, lime", 0xF1
-				strawberry,    700_000
+
+
+			# This is a comment preceded by multiple opening blank lines.
+			apple,         1
+			banana,        2
+			# This is a comment pointing out that the next line contains multiple explicit newlines in quoted text.
+			"lemon  \s
+
+
+			\s  lime",         0xF1
+			# The next line is a blank line in the middle of the CSV rows.
+
+			strawberry,    700_000
+			# This is a comment followed by 2 closing blank line.
+
 			""")
 	void executesLinesFromTextBlock(String fruit, int rank) {
 		switch (fruit) {
@@ -105,7 +116,40 @@ class ParameterizedTestIntegrationTests {
 			case "banana":
 				assertThat(rank).isEqualTo(2);
 				break;
-			case "lemon, lime":
+			case "lemon   \n\n\n   lime":
+				assertThat(rank).isEqualTo(241);
+				break;
+			case "strawberry":
+				assertThat(rank).isEqualTo(700_000);
+				break;
+			default:
+				fail("Unexpected fruit : " + fruit);
+		}
+	}
+
+	@ParameterizedTest
+	@CsvSource(delimiter = '|', quoteCharacter = '"', textBlock = """
+			#-----------------------------
+			#    FRUIT     |     RANK
+			#-----------------------------
+			     apple     |      1
+			#-----------------------------
+			     banana    |      2
+			#-----------------------------
+			  "lemon lime" |     0xF1
+			#-----------------------------
+			   strawberry  |    700_000
+			#-----------------------------
+			""")
+	void executesLinesFromTextBlockUsingPseudoTableFormat(String fruit, int rank) {
+		switch (fruit) {
+			case "apple":
+				assertThat(rank).isEqualTo(1);
+				break;
+			case "banana":
+				assertThat(rank).isEqualTo(2);
+				break;
+			case "lemon lime":
 				assertThat(rank).isEqualTo(241);
 				break;
 			case "strawberry":
diff --git a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/provider/CsvArgumentsProviderTests.java b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/provider/CsvArgumentsProviderTests.java
index 5fd80cfed..32fd519ba 100644
--- a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/provider/CsvArgumentsProviderTests.java
+++ b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/provider/CsvArgumentsProviderTests.java
@@ -324,17 +324,16 @@ class CsvArgumentsProviderTests {
 	}
 
 	@Test
-	// TODO Update expectations once https://github.com/junit-team/junit5/issues/2734 has been implemented.
-	void ignoresCommentCharacterWhenUsingTextBlockAttribute() {
+	void honorsCommentCharacterWhenUsingTextBlockAttribute() {
 		var annotation = csvSource().textBlock("""
-					#foo
-					bar, #baz
-					'#bar', baz
+				#foo
+				bar, #baz
+				'#bar', baz
 				""").build();
 
 		var arguments = provideArguments(annotation);
 
-		assertThat(arguments).containsExactly(array("#foo"), array("bar", "#baz"), array("#bar", "baz"));
+		assertThat(arguments).containsExactly(array("bar", "#baz"), array("#bar", "baz"));
 	}
 
 	private Stream<Object[]> provideArguments(CsvSource annotation) {
