diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.9.1.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.9.1.adoc
index d4e13d291..f0fb4b21c 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.9.1.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.9.1.adoc
@@ -35,9 +35,9 @@ on GitHub.
   references a factory method inherited from multiple interfaces no longer fails with an
   exception stating that multiple factory methods with the same name were found.
 * A `@ParameterizedTest` method configured with a `@MethodSource` annotation that
-  references a factory method whose name is the same as other test methods in the same
-  class no longer fails with an exception stating that multiple factory methods with the
-  same name were found.
+  references a factory method whose name is the same as other non-factory methods in the
+  same class no longer fails with an exception stating that multiple factory methods with
+  the same name were found.
 
 ==== Deprecations and Breaking Changes
 
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/MethodArgumentsProvider.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/MethodArgumentsProvider.java
index 885ad510a..a4696a273 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/MethodArgumentsProvider.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/MethodArgumentsProvider.java
@@ -11,8 +11,10 @@
 package org.junit.jupiter.params.provider;
 
 import static java.lang.String.format;
+import static java.util.stream.Collectors.toList;
 import static org.junit.jupiter.params.provider.Arguments.arguments;
 import static org.junit.platform.commons.util.AnnotationUtils.isAnnotated;
+import static org.junit.platform.commons.util.CollectionUtils.isConvertibleToStream;
 
 import java.lang.reflect.Method;
 import java.util.Arrays;
@@ -78,20 +80,34 @@ class MethodArgumentsProvider implements ArgumentsProvider, AnnotationConsumer<M
 	}
 
 	/**
-	 * Find all methods in the given {@code testClass} with the desired {@code factoryMethodName},
-	 * ignoring the {@code testMethod} itself as well as any {@code @Test}, {@code @TestTemplate},
+	 * Find all methods in the given {@code testClass} with the desired {@code factoryMethodName}
+	 * which have return types that can be converted to a {@link Stream}, ignoring the
+	 * {@code testMethod} itself as well as any {@code @Test}, {@code @TestTemplate},
 	 * or {@code @TestFactory} methods with the same name.
 	 */
 	private Method getFactoryMethodBySimpleName(Class<?> testClass, Method testMethod, String factoryMethodName) {
-		Predicate<Method> isFactoryMethod = candidate -> factoryMethodName.equals(candidate.getName())
-				&& !(testMethod.equals(candidate) || isTestMethod(candidate));
-		List<Method> methods = ReflectionUtils.findMethods(testClass, isFactoryMethod);
-		Preconditions.condition(methods.size() > 0,
-			() -> format("Could not find factory method [%s] in class [%s]", factoryMethodName, testClass.getName()));
-		Preconditions.condition(methods.size() == 1,
-			() -> format("%d factory methods named [%s] were found in class [%s]: %s", methods.size(),
-				factoryMethodName, testClass.getName(), methods));
-		return methods.get(0);
+		Predicate<Method> isCandidate = candidate -> factoryMethodName.equals(candidate.getName())
+				&& !testMethod.equals(candidate);
+		List<Method> candidates = ReflectionUtils.findMethods(testClass, isCandidate);
+		Predicate<Method> isFactoryMethod = method -> isConvertibleToStream(method.getReturnType())
+				&& !isTestMethod(method);
+		List<Method> factoryMethods = candidates.stream().filter(isFactoryMethod).collect(toList());
+		Preconditions.condition(factoryMethods.size() > 0, () -> {
+			// If we didn't find the factory method using the isFactoryMethod Predicate, perhaps
+			// the specified factory method has an invalid return type or is a test method.
+			// In that case, we report the invalid candidates that were found.
+			if (candidates.size() > 0) {
+				return format(
+					"Could not find valid factory method [%s] in class [%s] but found the following invalid candidates: %s",
+					factoryMethodName, testClass.getName(), candidates);
+			}
+			// Otherwise, report that we didn't find anything.
+			return format("Could not find factory method [%s] in class [%s]", factoryMethodName, testClass.getName());
+		});
+		Preconditions.condition(factoryMethods.size() == 1,
+			() -> format("%d factory methods named [%s] were found in class [%s]: %s", factoryMethods.size(),
+				factoryMethodName, testClass.getName(), factoryMethods));
+		return factoryMethods.get(0);
 	}
 
 	private boolean isTestMethod(Method candidate) {
diff --git a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestIntegrationTests.java b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestIntegrationTests.java
index 4682db419..56f353292 100644
--- a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestIntegrationTests.java
+++ b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestIntegrationTests.java
@@ -1283,13 +1283,13 @@ class ParameterizedTestIntegrationTests {
 		@ParameterizedTest
 		@MethodSource
 		void test(String value) {
-			assertEquals(1, value.length());
+			test(1, value);
 		}
 
 		@ParameterizedTest
 		@MethodSource("test")
 		void anotherTest(String value) {
-			assertEquals(1, value.length());
+			assertTrue(test(value, 1));
 		}
 
 		@RepeatedTest(2)
@@ -1299,9 +1299,22 @@ class ParameterizedTestIntegrationTests {
 
 		@TestFactory
 		Stream<DynamicTest> test(TestInfo testInfo) {
-			return test().map(value -> dynamicTest(value, () -> assertEquals(1, value.length())));
+			return test().map(value -> dynamicTest(value, () -> test(1, value)));
 		}
 
+		// neither a test method nor a factory method.
+		// intentionally void.
+		private void test(int expectedLength, String value) {
+			assertEquals(expectedLength, value.length());
+		}
+
+		// neither a test method nor a factory method.
+		// intentionally non-void and also not convertible to a Stream.
+		private boolean test(String value, int expectedLength) {
+			return (value.length() == expectedLength);
+		}
+
+		// legitimate factory method.
 		private static Stream<String> test() {
 			return Stream.of("a", "b");
 		}
diff --git a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/provider/MethodArgumentsProviderTests.java b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/provider/MethodArgumentsProviderTests.java
index 27450a474..21f14662e 100644
--- a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/provider/MethodArgumentsProviderTests.java
+++ b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/provider/MethodArgumentsProviderTests.java
@@ -48,12 +48,24 @@ class MethodArgumentsProviderTests {
 
 	private MutableExtensionRegistry extensionRegistry;
 
+	@Test
+	void throwsExceptionWhenFactoryMethodDoesNotExist() {
+		var exception = assertThrows(JUnitException.class, () -> provideArguments("unknownMethod").toArray());
+
+		assertThat(exception.getMessage()).isEqualTo(
+			"Could not find factory method [unknownMethod] in class [" + TestCase.class.getName() + "]");
+	}
+
 	@Test
 	void throwsExceptionForIllegalReturnType() {
 		var exception = assertThrows(PreconditionViolationException.class,
 			() -> provideArguments("providerWithIllegalReturnType").toArray());
 
-		assertThat(exception).hasMessageContaining("Cannot convert instance of java.lang.Integer into a Stream");
+		assertThat(exception.getMessage())//
+				.containsSubsequence("Could not find valid factory method [providerWithIllegalReturnType] in class [",
+					TestCase.class.getName() + "]", //
+					"but found the following invalid candidates: ", //
+					"[static java.lang.Object org.junit.jupiter.params.provider.MethodArgumentsProviderTests$TestCase.providerWithIllegalReturnType()]");
 	}
 
 	@Test
@@ -194,14 +206,6 @@ class MethodArgumentsProviderTests {
 		assertThat(arguments).containsExactly(array("foo"), array("bar"));
 	}
 
-	@Test
-	void throwsExceptionWhenFactoryMethodDoesNotExist() {
-		var exception = assertThrows(JUnitException.class, () -> provideArguments("unknownMethod").toArray());
-
-		assertThat(exception.getMessage()).contains("Could not find factory method [unknownMethod] in class [",
-			TestCase.class.getName());
-	}
-
 	@Test
 	void providesArgumentsUsingDefaultFactoryMethodName() throws Exception {
 		Class<?> testClass = DefaultFactoryMethodNameTestCase.class;
