diff --git a/documentation/src/docs/asciidoc/release-notes-5.0.0-M4.adoc b/documentation/src/docs/asciidoc/release-notes-5.0.0-M4.adoc
index 4edba4fa8..62ec75b9e 100644
--- a/documentation/src/docs/asciidoc/release-notes-5.0.0-M4.adoc
+++ b/documentation/src/docs/asciidoc/release-notes-5.0.0-M4.adoc
@@ -19,6 +19,7 @@ on GitHub.
 * The JUnit Platform Gradle plugin now adds its dependencies with a fixed version (same as plugin
   version) instead of a dynamic versioning scheme (was `1.+`) by default to ensure reproducible
   builds.
+* All `findMethods()` implementations in `ReflectionUtils` no longer return bridge methods.
 
 ===== Deprecations and Breaking Changes
 
@@ -66,6 +67,9 @@ on GitHub.
 ===== Bug Fixes
 
 * Fix bug that prevented discovery of two or more methods of the same class.
+* Enforce correct execution order of overridden `@BeforeEach`/`@AfterEach` methods when declared
+  at multiple class hierarchy levels. It's now always `super.before`, `this.before`, `this.test`,
+  `this.after` and `super.after`, even when the compiler added bridge methods.
 
 ===== Deprecations and Breaking Changes
 
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/bridge/BridgeTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/bridge/BridgeTests.java
new file mode 100644
index 000000000..6af1fc139
--- /dev/null
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/bridge/BridgeTests.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright 2015-2017 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v1.0 which
+ * accompanies this distribution and is available at
+ *
+ * http://www.eclipse.org/legal/epl-v10.html
+ */
+
+package org.junit.jupiter.engine.bridge;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.engine.AbstractJupiterTestEngineTests;
+import org.junit.platform.engine.test.event.ExecutionEventRecorder;
+
+public class BridgeTests extends AbstractJupiterTestEngineTests {
+
+	@Test
+	void childHasBridgeMethods() throws Exception {
+		assertFalse(ChildWithBridges.class.getMethod("anotherBeforeEach").isBridge());
+		assertFalse(ChildWithBridges.class.getMethod("anotherAfterEach").isBridge());
+		assertTrue(ChildWithBridges.class.getMethod("beforeEach").isBridge());
+		assertTrue(ChildWithBridges.class.getMethod("afterEach").isBridge());
+	}
+
+	@Test
+	void childHasNoBridgeMethods() throws Exception {
+		assertFalse(ChildWithoutBridges.class.getMethod("anotherBeforeEach").isBridge());
+		assertFalse(ChildWithoutBridges.class.getMethod("anotherAfterEach").isBridge());
+		assertFalse(ChildWithoutBridges.class.getMethod("beforeEach").isBridge());
+		assertFalse(ChildWithoutBridges.class.getMethod("afterEach").isBridge());
+	}
+
+	@Test
+	void compareMethodExecutionSequenceOrder() {
+		String withoutBridges = execute(ChildWithoutBridges.class);
+		String withBridges = execute(ChildWithBridges.class);
+		assertEquals(withoutBridges, withBridges);
+	}
+
+	private String execute(Class<?> testClass) {
+		PackagePrivateParent.bridgeMethodSequence.clear();
+		ExecutionEventRecorder recorder = executeTestsForClass(testClass);
+		assertEquals(1, recorder.getTestFinishedCount());
+		return PackagePrivateParent.bridgeMethodSequence.toString();
+	}
+}
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/bridge/ChildWithBridges.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/bridge/ChildWithBridges.java
new file mode 100644
index 000000000..9154dcad9
--- /dev/null
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/bridge/ChildWithBridges.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2015-2017 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v1.0 which
+ * accompanies this distribution and is available at
+ *
+ * http://www.eclipse.org/legal/epl-v10.html
+ */
+
+package org.junit.jupiter.engine.bridge;
+
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+// modifier "public" is necessary for creating bridge methods by the compiler
+public class ChildWithBridges extends PackagePrivateParent {
+
+	@BeforeEach
+	public void anotherBeforeEach() {
+		bridgeMethodSequence.add("child.anotherBeforeEach()");
+	}
+
+	@Test
+	public void test() {
+		bridgeMethodSequence.add("child.test()");
+	}
+
+	@AfterEach
+	public void anotherAfterEach() {
+		bridgeMethodSequence.add("child.anotherAfterEach()");
+	}
+}
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/bridge/ChildWithoutBridges.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/bridge/ChildWithoutBridges.java
new file mode 100644
index 000000000..f66d5f819
--- /dev/null
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/bridge/ChildWithoutBridges.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2015-2017 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v1.0 which
+ * accompanies this distribution and is available at
+ *
+ * http://www.eclipse.org/legal/epl-v10.html
+ */
+
+package org.junit.jupiter.engine.bridge;
+
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+// modifier "public" is *not* present for not creating bridge methods by the compiler
+class ChildWithoutBridges extends PackagePrivateParent {
+
+	@BeforeEach
+	public void anotherBeforeEach() {
+		bridgeMethodSequence.add("child.anotherBeforeEach()");
+	}
+
+	@Test
+	public void test() {
+		bridgeMethodSequence.add("child.test()");
+	}
+
+	@AfterEach
+	public void anotherAfterEach() {
+		bridgeMethodSequence.add("child.anotherAfterEach()");
+	}
+}
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/bridge/PackagePrivateParent.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/bridge/PackagePrivateParent.java
new file mode 100644
index 000000000..6f6be6639
--- /dev/null
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/bridge/PackagePrivateParent.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2015-2017 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v1.0 which
+ * accompanies this distribution and is available at
+ *
+ * http://www.eclipse.org/legal/epl-v10.html
+ */
+
+package org.junit.jupiter.engine.bridge;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.junit.jupiter.api.AfterAll;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.BeforeEach;
+
+class PackagePrivateParent {
+
+	static List<String> bridgeMethodSequence = new ArrayList<>();
+
+	@BeforeAll
+	static void beforeAll() {
+		bridgeMethodSequence.add("static parent.beforeAll()");
+	}
+
+	@AfterAll
+	static void afterAll() {
+		bridgeMethodSequence.add("static parent.afterAll()");
+	}
+
+	@BeforeEach
+	public void beforeEach() {
+		bridgeMethodSequence.add("parent.beforeEach()");
+	}
+
+	@AfterEach
+	public void afterEach() {
+		bridgeMethodSequence.add("parent.afterEach()");
+	}
+}
diff --git a/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java b/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java
index bbf4dfd16..41b87b3cf 100644
--- a/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java
+++ b/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java
@@ -573,9 +573,11 @@ public final class ReflectionUtils {
 		Preconditions.notNull(clazz, "Class must not be null");
 		Preconditions.notNull(sortOrder, "MethodSortOrder must not be null");
 
-		// TODO [#333] Determine if we need to support bridged methods.
-
-		List<Method> localMethods = Arrays.asList(clazz.getDeclaredMethods());
+		// @formatter:off
+		List<Method> localMethods = Arrays.stream(clazz.getDeclaredMethods())
+				.filter(method -> !method.isBridge()) // [#333] don't collect bridge methods
+				.collect(toList());
+		// @formatter:on
 
 		// @formatter:off
 		List<Method> superclassMethods = getSuperclassMethods(clazz, sortOrder).stream()
diff --git a/platform-tests/src/test/java/org/junit/platform/commons/util/ReflectionUtilsTests.java b/platform-tests/src/test/java/org/junit/platform/commons/util/ReflectionUtilsTests.java
index 891834578..4a99979a0 100644
--- a/platform-tests/src/test/java/org/junit/platform/commons/util/ReflectionUtilsTests.java
+++ b/platform-tests/src/test/java/org/junit/platform/commons/util/ReflectionUtilsTests.java
@@ -10,6 +10,7 @@
 
 package org.junit.platform.commons.util;
 
+import static java.util.stream.Collectors.toList;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.jupiter.api.Assertions.assertAll;
 import static org.junit.jupiter.api.Assertions.assertEquals;
@@ -27,6 +28,7 @@ import java.io.IOException;
 import java.io.OutputStream;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.util.List;
@@ -651,6 +653,19 @@ public class ReflectionUtilsTests {
 			MethodShadowingChild.class.getMethod("method5", Long.class));
 	}
 
+	@Test
+	void findMethodsIgnoresBridgeMethods() throws Exception {
+		assertFalse(Modifier.isPublic(PublicChildClass.class.getSuperclass().getModifiers()));
+		assertTrue(Modifier.isPublic(PublicChildClass.class.getModifiers()));
+		assertTrue(PublicChildClass.class.getDeclaredMethod("method1").isBridge());
+		assertTrue(PublicChildClass.class.getDeclaredMethod("method3").isBridge());
+
+		List<Method> methods = ReflectionUtils.findMethods(PublicChildClass.class, method -> true);
+		List<String> names = methods.stream().map(Method::getName).collect(toList());
+		assertThat(names).containsOnly("method1", "method2", "method3", "otherMethod1", "otherMethod2");
+		assertTrue(methods.stream().filter(Method::isBridge).count() == 0);
+	}
+
 	private static void createDirectories(Path... paths) throws IOException {
 		for (Path path : paths) {
 			Files.createDirectory(path);
@@ -882,6 +897,18 @@ public class ReflectionUtilsTests {
 		}
 	}
 
+	// "public" modifier is necessary here, the compiler creates a bridge method
+	public static class PublicChildClass extends ParentClass {
+
+		@Override
+		public void otherMethod1() {
+		}
+
+		@Override
+		public void otherMethod2() {
+		}
+	}
+
 	@SuppressWarnings("unused")
 	private static class ClassWithOneCustomConstructor {
 
