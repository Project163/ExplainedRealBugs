diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.6.0-M2.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.6.0-M2.adoc
index df4bc0da9..c85699f8b 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.6.0-M2.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.6.0-M2.adoc
@@ -51,7 +51,9 @@ on GitHub.
   they are destroyed.
 * `InvocationInterceptor` extensions may now explicitly `skip()` an intercepted
   invocation. This allows executing it by other means, e.g. in a forked JVM.
-
+* Parameter names are now included in the default display name of a `@ParameterizedTest`
+  invocation (if they are present in the bytecode). The `{argumentsWithNames}` pattern
+  can also be used in custom names.
 
 [[release-notes-5.6.0-M2️-junit-vintage]]
 === JUnit Vintage
diff --git a/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc b/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
index 5b1294f9e..34b98e83e 100644
--- a/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
+++ b/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
@@ -924,9 +924,9 @@ following.
 
 ....
 palindromes(String) ✔
-├─ [1] racecar ✔
-├─ [2] radar ✔
-└─ [3] able was I ere I saw elba ✔
+├─ [1] candidate=racecar ✔
+├─ [2] candidate=radar ✔
+└─ [3] candidate=able was I ere I saw elba ✔
 ....
 
 WARNING: Parameterized tests are currently an _experimental_ feature. Consult the table
@@ -1452,6 +1452,10 @@ include::{testDir}/example/ParameterizedTestDemo.java[tags=ArgumentsAggregator_w
 
 By default, the display name of a parameterized test invocation contains the invocation
 index and the `String` representation of all arguments for that specific invocation.
+Each of them is preceded by the parameter name (unless the argument is only available via
+an `ArgumentsAccessor` or `ArgumentAggregator`), if present in the bytecode (for Java,
+test code must be compiled with the `-parameters` compiler flag).
+
 However, you can customize invocation display names via the `name` attribute of the
 `@ParameterizedTest` annotation like in the following example.
 
@@ -1465,20 +1469,22 @@ the following.
 
 ....
 Display name of container ✔
-├─ 1 ==> fruit='apple', rank=1 ✔
-├─ 2 ==> fruit='banana', rank=2 ✔
-└─ 3 ==> fruit='lemon, lime', rank=3 ✔
+├─ 1 ==> the rank of 'apple' is 1 ✔
+├─ 2 ==> the rank of 'banana' is 2 ✔
+└─ 3 ==> the rank of 'lemon, lime' is 3 ✔
 ....
 
 The following placeholders are supported within custom display names.
 
 [cols="20,80"]
 |===
-| Placeholder       | Description
+| Placeholder              | Description
 
-| `{index}`         | the current invocation index (1-based)
-| `{arguments}`     | the complete, comma-separated arguments list
-| `{0}`, `{1}`, ... | an individual argument
+| `{displayName}`          | the display name of the method
+| `{index}`                | the current invocation index (1-based)
+| `{arguments}`            | the complete, comma-separated arguments list
+| `{argumentsWithNames}`   | the complete, comma-separated arguments list with parameter names
+| `{0}`, `{1}`, ...        | an individual argument
 |===
 
 
diff --git a/documentation/src/test/java/example/ParameterizedTestDemo.java b/documentation/src/test/java/example/ParameterizedTestDemo.java
index 71abceb5a..ca73fd043 100644
--- a/documentation/src/test/java/example/ParameterizedTestDemo.java
+++ b/documentation/src/test/java/example/ParameterizedTestDemo.java
@@ -411,7 +411,7 @@ class ParameterizedTestDemo {
 
 	// tag::custom_display_names[]
 	@DisplayName("Display name of container")
-	@ParameterizedTest(name = "{index} ==> fruit=''{0}'', rank={1}")
+	@ParameterizedTest(name = "{index} ==> the rank of ''{0}'' is {1}")
 	@CsvSource({ "apple, 1", "banana, 2", "'lemon, lime', 3" })
 	void testWithCustomDisplayNames(String fruit, int rank) {
 	}
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTest.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTest.java
index 2915ee157..e00f3671b 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTest.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTest.java
@@ -155,6 +155,17 @@ public @interface ParameterizedTest {
 	@API(status = EXPERIMENTAL, since = "5.3")
 	String ARGUMENTS_PLACEHOLDER = "{arguments}";
 
+	/**
+	 * Placeholder for the complete, comma-separated named arguments list
+	 * of the current invocation of a {@code @ParameterizedTest} method:
+	 * <code>{argumentsWithNames}</code>
+	 *
+	 * @see #name
+	 * @since 5.6
+	 */
+	@API(status = EXPERIMENTAL, since = "5.6")
+	String ARGUMENTS_WITH_NAMES_PLACEHOLDER = "{argumentsWithNames}";
+
 	/**
 	 * Default display name pattern for the current invocation of a
 	 * {@code @ParameterizedTest} method: {@value}
@@ -166,11 +177,11 @@ public @interface ParameterizedTest {
 	 * @see #name
 	 * @see #DISPLAY_NAME_PLACEHOLDER
 	 * @see #INDEX_PLACEHOLDER
-	 * @see #ARGUMENTS_PLACEHOLDER
+	 * @see #ARGUMENTS_WITH_NAMES_PLACEHOLDER
 	 * @since 5.3
 	 */
 	@API(status = EXPERIMENTAL, since = "5.3")
-	String DEFAULT_DISPLAY_NAME = "[" + INDEX_PLACEHOLDER + "] " + ARGUMENTS_PLACEHOLDER;
+	String DEFAULT_DISPLAY_NAME = "[" + INDEX_PLACEHOLDER + "] " + ARGUMENTS_WITH_NAMES_PLACEHOLDER;
 
 	/**
 	 * The display name to be used for individual invocations of the
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestExtension.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestExtension.java
index fa171ca2e..6cf507ac8 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestExtension.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestExtension.java
@@ -72,7 +72,7 @@ class ParameterizedTestExtension implements TestTemplateInvocationContextProvide
 		String displayName = extensionContext.getDisplayName();
 		ParameterizedTestMethodContext methodContext = getStore(extensionContext)//
 				.get(METHOD_CONTEXT_KEY, ParameterizedTestMethodContext.class);
-		ParameterizedTestNameFormatter formatter = createNameFormatter(templateMethod, displayName);
+		ParameterizedTestNameFormatter formatter = createNameFormatter(templateMethod, methodContext, displayName);
 		AtomicLong invocationCount = new AtomicLong(0);
 
 		// @formatter:off
@@ -118,13 +118,14 @@ class ParameterizedTestExtension implements TestTemplateInvocationContextProvide
 		return new ParameterizedTestInvocationContext(formatter, methodContext, arguments);
 	}
 
-	private ParameterizedTestNameFormatter createNameFormatter(Method templateMethod, String displayName) {
+	private ParameterizedTestNameFormatter createNameFormatter(Method templateMethod,
+			ParameterizedTestMethodContext methodContext, String displayName) {
 		ParameterizedTest parameterizedTest = findAnnotation(templateMethod, ParameterizedTest.class).get();
 		String pattern = Preconditions.notBlank(parameterizedTest.name().trim(),
 			() -> String.format(
 				"Configuration error: @ParameterizedTest on method [%s] must be declared with a non-empty name.",
 				templateMethod));
-		return new ParameterizedTestNameFormatter(pattern, displayName);
+		return new ParameterizedTestNameFormatter(pattern, displayName, methodContext);
 	}
 
 	protected static Stream<? extends Arguments> arguments(ArgumentsProvider provider, ExtensionContext context) {
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestMethodContext.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestMethodContext.java
index 7e7f9e3db..f2615b3f9 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestMethodContext.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestMethodContext.java
@@ -18,6 +18,7 @@ import java.lang.reflect.Method;
 import java.lang.reflect.Parameter;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Optional;
 
 import org.junit.jupiter.api.extension.ParameterContext;
 import org.junit.jupiter.api.extension.ParameterResolutionException;
@@ -42,14 +43,15 @@ import org.junit.platform.commons.util.StringUtils;
  */
 class ParameterizedTestMethodContext {
 
-	private final List<ResolverType> resolverTypes;
+	private final Parameter[] parameters;
 	private final Resolver[] resolvers;
+	private final List<ResolverType> resolverTypes;
 
 	ParameterizedTestMethodContext(Method testMethod) {
-		Parameter[] parameters = testMethod.getParameters();
-		this.resolverTypes = new ArrayList<>(parameters.length);
-		this.resolvers = new Resolver[parameters.length];
-		for (Parameter parameter : parameters) {
+		this.parameters = testMethod.getParameters();
+		this.resolvers = new Resolver[this.parameters.length];
+		this.resolverTypes = new ArrayList<>(this.parameters.length);
+		for (Parameter parameter : this.parameters) {
 			this.resolverTypes.add(isAggregator(parameter) ? AGGREGATOR : CONVERTER);
 		}
 	}
@@ -100,7 +102,27 @@ class ParameterizedTestMethodContext {
 	 * context.
 	 */
 	int getParameterCount() {
-		return resolvers.length;
+		return parameters.length;
+	}
+
+	/**
+	 * Get the name of the {@link Parameter} with the supplied index, if
+	 * it is present and declared before the aggregators.
+	 *
+	 * @return an {@code Optional} containing the name of the parameter
+	 */
+	Optional<String> getParameterName(int parameterIndex) {
+		if (parameterIndex >= getParameterCount()) {
+			return Optional.empty();
+		}
+		Parameter parameter = this.parameters[parameterIndex];
+		if (!parameter.isNamePresent()) {
+			return Optional.empty();
+		}
+		if (hasAggregator() && parameterIndex >= indexOfFirstAggregator()) {
+			return Optional.empty();
+		}
+		return Optional.of(parameter.getName());
 	}
 
 	/**
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestNameFormatter.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestNameFormatter.java
index e94300ad6..6e6653a26 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestNameFormatter.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestNameFormatter.java
@@ -12,6 +12,7 @@ package org.junit.jupiter.params;
 
 import static java.util.stream.Collectors.joining;
 import static org.junit.jupiter.params.ParameterizedTest.ARGUMENTS_PLACEHOLDER;
+import static org.junit.jupiter.params.ParameterizedTest.ARGUMENTS_WITH_NAMES_PLACEHOLDER;
 import static org.junit.jupiter.params.ParameterizedTest.DISPLAY_NAME_PLACEHOLDER;
 import static org.junit.jupiter.params.ParameterizedTest.INDEX_PLACEHOLDER;
 
@@ -30,10 +31,12 @@ class ParameterizedTestNameFormatter {
 
 	private final String pattern;
 	private final String displayName;
+	private final ParameterizedTestMethodContext methodContext;
 
-	ParameterizedTestNameFormatter(String pattern, String displayName) {
+	ParameterizedTestNameFormatter(String pattern, String displayName, ParameterizedTestMethodContext methodContext) {
 		this.pattern = pattern;
 		this.displayName = displayName;
+		this.methodContext = methodContext;
 	}
 
 	String format(int invocationIndex, Object... arguments) {
@@ -59,18 +62,30 @@ class ParameterizedTestNameFormatter {
 				.replace(DISPLAY_NAME_PLACEHOLDER, this.displayName)//
 				.replace(INDEX_PLACEHOLDER, String.valueOf(invocationIndex));
 
+		if (result.contains(ARGUMENTS_WITH_NAMES_PLACEHOLDER)) {
+			result = result.replace(ARGUMENTS_WITH_NAMES_PLACEHOLDER, argumentsWithNamesPattern(arguments));
+		}
+
 		if (result.contains(ARGUMENTS_PLACEHOLDER)) {
-			// @formatter:off
-			String replacement = IntStream.range(0, arguments.length)
-					.mapToObj(index -> "{" + index + "}")
-					.collect(joining(", "));
-			// @formatter:on
-			result = result.replace(ARGUMENTS_PLACEHOLDER, replacement);
+			result = result.replace(ARGUMENTS_PLACEHOLDER, argumentsPattern(arguments));
 		}
 
 		return result;
 	}
 
+	private String argumentsWithNamesPattern(Object[] arguments) {
+		return IntStream.range(0, arguments.length) //
+				.mapToObj(index -> methodContext.getParameterName(index).map(name -> name + "=").orElse("") + "{"
+						+ index + "}") //
+				.collect(joining(", "));
+	}
+
+	private String argumentsPattern(Object[] arguments) {
+		return IntStream.range(0, arguments.length) //
+				.mapToObj(index -> "{" + index + "}") //
+				.collect(joining(", "));
+	}
+
 	private Object[] makeReadable(MessageFormat format, Object[] arguments) {
 		Format[] formats = format.getFormatsByArgumentIndex();
 		Object[] result = Arrays.copyOf(arguments, Math.min(arguments.length, formats.length), Object[].class);
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestParameterResolver.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestParameterResolver.java
index 2626198ee..6315c18ac 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestParameterResolver.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/ParameterizedTestParameterResolver.java
@@ -35,6 +35,7 @@ class ParameterizedTestParameterResolver implements ParameterResolver {
 	public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
 		Executable declaringExecutable = parameterContext.getDeclaringExecutable();
 		Method testMethod = extensionContext.getTestMethod().orElse(null);
+		int parameterIndex = parameterContext.getIndex();
 
 		// Not a @ParameterizedTest method?
 		if (!declaringExecutable.equals(testMethod)) {
@@ -42,18 +43,18 @@ class ParameterizedTestParameterResolver implements ParameterResolver {
 		}
 
 		// Current parameter is an aggregator?
-		if (this.methodContext.isAggregator(parameterContext.getIndex())) {
+		if (this.methodContext.isAggregator(parameterIndex)) {
 			return true;
 		}
 
 		// Ensure that the current parameter is declared before aggregators.
 		// Otherwise, a different ParameterResolver should handle it.
-		if (this.methodContext.indexOfFirstAggregator() != -1) {
-			return parameterContext.getIndex() < this.methodContext.indexOfFirstAggregator();
+		if (this.methodContext.hasAggregator()) {
+			return parameterIndex < this.methodContext.indexOfFirstAggregator();
 		}
 
 		// Else fallback to behavior for parameterized test methods without aggregators.
-		return parameterContext.getIndex() < this.arguments.length;
+		return parameterIndex < this.arguments.length;
 	}
 
 	@Override
diff --git a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestIntegrationTests.java b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestIntegrationTests.java
index 7a527e4d4..ee9ce3040 100644
--- a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestIntegrationTests.java
+++ b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestIntegrationTests.java
@@ -54,6 +54,10 @@ import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.api.extension.ParameterContext;
 import org.junit.jupiter.api.extension.ParameterResolutionException;
 import org.junit.jupiter.engine.JupiterTestEngine;
+import org.junit.jupiter.params.aggregator.AggregateWith;
+import org.junit.jupiter.params.aggregator.ArgumentsAccessor;
+import org.junit.jupiter.params.aggregator.ArgumentsAggregationException;
+import org.junit.jupiter.params.aggregator.ArgumentsAggregator;
 import org.junit.jupiter.params.converter.ArgumentConversionException;
 import org.junit.jupiter.params.converter.ArgumentConverter;
 import org.junit.jupiter.params.converter.ConvertWith;
@@ -85,16 +89,16 @@ class ParameterizedTestIntegrationTests {
 	void executesWithSingleArgumentsProviderWithMultipleInvocations() {
 		var results = execute("testWithTwoSingleStringArgumentsProvider", String.class);
 		results.allEvents().assertThatEvents() //
-				.haveExactly(1, event(test(), displayName("[1] foo"), finishedWithFailure(message("foo")))) //
-				.haveExactly(1, event(test(), displayName("[2] bar"), finishedWithFailure(message("bar"))));
+				.haveExactly(1, event(test(), displayName("[1] argument=foo"), finishedWithFailure(message("foo")))) //
+				.haveExactly(1, event(test(), displayName("[2] argument=bar"), finishedWithFailure(message("bar"))));
 	}
 
 	@Test
 	void executesWithCsvSource() {
 		var results = execute("testWithCsvSource", String.class);
 		results.allEvents().assertThatEvents() //
-				.haveExactly(1, event(test(), displayName("[1] foo"), finishedWithFailure(message("foo")))) //
-				.haveExactly(1, event(test(), displayName("[2] bar"), finishedWithFailure(message("bar"))));
+				.haveExactly(1, event(test(), displayName("[1] argument=foo"), finishedWithFailure(message("foo")))) //
+				.haveExactly(1, event(test(), displayName("[2] argument=bar"), finishedWithFailure(message("bar"))));
 	}
 
 	@Test
@@ -112,8 +116,8 @@ class ParameterizedTestIntegrationTests {
 	void executesWithPrimitiveWideningConversion() {
 		var results = execute("testWithPrimitiveWideningConversion", double.class);
 		results.allEvents().assertThatEvents() //
-				.haveExactly(1, event(test(), displayName("[1] 1"), finishedWithFailure(message("num: 1.0")))) //
-				.haveExactly(1, event(test(), displayName("[2] 2"), finishedWithFailure(message("num: 2.0"))));
+				.haveExactly(1, event(test(), displayName("[1] num=1"), finishedWithFailure(message("num: 1.0")))) //
+				.haveExactly(1, event(test(), displayName("[2] num=2"), finishedWithFailure(message("num: 2.0"))));
 	}
 
 	/**
@@ -123,8 +127,8 @@ class ParameterizedTestIntegrationTests {
 	void executesWithImplicitGenericConverter() {
 		var results = execute("testWithImplicitGenericConverter", Book.class);
 		results.allEvents().assertThatEvents() //
-				.haveExactly(1, event(test(), displayName("[1] book 1"), finishedWithFailure(message("book 1")))) //
-				.haveExactly(1, event(test(), displayName("[2] book 2"), finishedWithFailure(message("book 2"))));
+				.haveExactly(1, event(test(), displayName("[1] book=book 1"), finishedWithFailure(message("book 1")))) //
+				.haveExactly(1, event(test(), displayName("[2] book=book 2"), finishedWithFailure(message("book 2"))));
 	}
 
 	@Test
@@ -144,8 +148,19 @@ class ParameterizedTestIntegrationTests {
 	void executesWithExplicitConverter() {
 		var results = execute("testWithExplicitConverter", int.class);
 		results.allEvents().assertThatEvents() //
-				.haveExactly(1, event(test(), displayName("[1] O"), finishedWithFailure(message("length: 1")))) //
-				.haveExactly(1, event(test(), displayName("[2] XXX"), finishedWithFailure(message("length: 3"))));
+				.haveExactly(1, event(test(), displayName("[1] length=O"), finishedWithFailure(message("length: 1")))) //
+				.haveExactly(1,
+					event(test(), displayName("[2] length=XXX"), finishedWithFailure(message("length: 3"))));
+	}
+
+	@Test
+	void executesWithAggregator() {
+		var results = execute("testWithAggregator", String.class);
+		results.allEvents().assertThatEvents() //
+				.haveExactly(1,
+					event(test(), displayName("[1] ab, cd"), finishedWithFailure(message("concatenation: abcd")))) //
+				.haveExactly(1,
+					event(test(), displayName("[2] ef, gh"), finishedWithFailure(message("concatenation: efgh"))));
 	}
 
 	@Test
@@ -172,8 +187,10 @@ class ParameterizedTestIntegrationTests {
 
 		var results = execute(selectClass(LifecycleTestCase.class));
 		results.allEvents().assertThatEvents() //
-				.haveExactly(1, event(test("test1"), displayName("[1] foo"), finishedWithFailure(message("foo")))) //
-				.haveExactly(1, event(test("test1"), displayName("[2] bar"), finishedWithFailure(message("bar"))));
+				.haveExactly(1,
+					event(test("test1"), displayName("[1] argument=foo"), finishedWithFailure(message("foo")))) //
+				.haveExactly(1,
+					event(test("test1"), displayName("[2] argument=bar"), finishedWithFailure(message("bar"))));
 
 		List<String> testMethods = new ArrayList<>(LifecycleTestCase.testMethods);
 
@@ -182,22 +199,22 @@ class ParameterizedTestIntegrationTests {
 			"beforeAll:ParameterizedTestIntegrationTests$LifecycleTestCase",
 				"providerMethod",
 					"constructor:ParameterizedTestIntegrationTests$LifecycleTestCase",
-					"beforeEach:[1] foo",
-						testMethods.get(0) + ":[1] foo",
-					"afterEach:[1] foo",
+					"beforeEach:[1] argument=foo",
+						testMethods.get(0) + ":[1] argument=foo",
+					"afterEach:[1] argument=foo",
 					"constructor:ParameterizedTestIntegrationTests$LifecycleTestCase",
-					"beforeEach:[2] bar",
-						testMethods.get(0) + ":[2] bar",
-					"afterEach:[2] bar",
+					"beforeEach:[2] argument=bar",
+						testMethods.get(0) + ":[2] argument=bar",
+					"afterEach:[2] argument=bar",
 				"providerMethod",
 					"constructor:ParameterizedTestIntegrationTests$LifecycleTestCase",
-					"beforeEach:[1] foo",
-						testMethods.get(1) + ":[1] foo",
-					"afterEach:[1] foo",
+					"beforeEach:[1] argument=foo",
+						testMethods.get(1) + ":[1] argument=foo",
+					"afterEach:[1] argument=foo",
 					"constructor:ParameterizedTestIntegrationTests$LifecycleTestCase",
-					"beforeEach:[2] bar",
-						testMethods.get(1) + ":[2] bar",
-					"afterEach:[2] bar",
+					"beforeEach:[2] argument=bar",
+						testMethods.get(1) + ":[2] argument=bar",
+					"afterEach:[2] argument=bar",
 			"afterAll:ParameterizedTestIntegrationTests$LifecycleTestCase");
 		// @formatter:on
 	}
@@ -224,21 +241,21 @@ class ParameterizedTestIntegrationTests {
 		void executesWithNullSourceForString() {
 			var results = execute("testWithNullSourceForString", String.class);
 			results.testEvents().failed().assertEventsMatchExactly(
-				event(test(), displayName("[1] null"), finishedWithFailure(message("null"))));
+				event(test(), displayName("[1] argument=null"), finishedWithFailure(message("null"))));
 		}
 
 		@Test
 		void executesWithNullSourceForStringAndTestInfo() {
 			var results = execute("testWithNullSourceForStringAndTestInfo", String.class, TestInfo.class);
 			results.testEvents().failed().assertEventsMatchExactly(
-				event(test(), displayName("[1] null"), finishedWithFailure(message("null"))));
+				event(test(), displayName("[1] argument=null"), finishedWithFailure(message("null"))));
 		}
 
 		@Test
 		void executesWithNullSourceForNumber() {
 			var results = execute("testWithNullSourceForNumber", Number.class);
 			results.testEvents().failed().assertEventsMatchExactly(
-				event(test(), displayName("[1] null"), finishedWithFailure(message("null"))));
+				event(test(), displayName("[1] argument=null"), finishedWithFailure(message("null"))));
 		}
 
 		@Test
@@ -255,7 +272,7 @@ class ParameterizedTestIntegrationTests {
 		@Test
 		void failsWithNullSourceForPrimitive() {
 			var results = execute("testWithNullSourceForPrimitive", int.class);
-			results.testEvents().failed().assertEventsMatchExactly(event(test(), displayName("[1] null"),
+			results.testEvents().failed().assertEventsMatchExactly(event(test(), displayName("[1] argument=null"),
 				finishedWithFailure(instanceOf(ParameterResolutionException.class), message(
 					"Error converting parameter at index 0: Cannot convert null to primitive value of type int"))));
 		}
@@ -276,55 +293,55 @@ class ParameterizedTestIntegrationTests {
 		@Test
 		void executesWithEmptySourceForString() {
 			var results = execute("testWithEmptySourceForString", String.class);
-			results.testEvents().succeeded().assertEventsMatchExactly(event(test(), displayName("[1] ")));
+			results.testEvents().succeeded().assertEventsMatchExactly(event(test(), displayName("[1] argument=")));
 		}
 
 		@Test
 		void executesWithEmptySourceForStringAndTestInfo() {
 			var results = execute("testWithEmptySourceForStringAndTestInfo", String.class, TestInfo.class);
-			results.testEvents().succeeded().assertEventsMatchExactly(event(test(), displayName("[1] ")));
+			results.testEvents().succeeded().assertEventsMatchExactly(event(test(), displayName("[1] argument=")));
 		}
 
 		@Test
 		void executesWithEmptySourceForList() {
 			var results = execute("testWithEmptySourceForList", List.class);
-			results.testEvents().succeeded().assertEventsMatchExactly(event(test(), displayName("[1] []")));
+			results.testEvents().succeeded().assertEventsMatchExactly(event(test(), displayName("[1] argument=[]")));
 		}
 
 		@Test
 		void executesWithEmptySourceForSet() {
 			var results = execute("testWithEmptySourceForSet", Set.class);
-			results.testEvents().succeeded().assertEventsMatchExactly(event(test(), displayName("[1] []")));
+			results.testEvents().succeeded().assertEventsMatchExactly(event(test(), displayName("[1] argument=[]")));
 		}
 
 		@Test
 		void executesWithEmptySourceForMap() {
 			var results = execute("testWithEmptySourceForMap", Map.class);
-			results.testEvents().succeeded().assertEventsMatchExactly(event(test(), displayName("[1] {}")));
+			results.testEvents().succeeded().assertEventsMatchExactly(event(test(), displayName("[1] argument={}")));
 		}
 
 		@Test
 		void executesWithEmptySourceForOneDimensionalPrimitiveArray() {
 			var results = execute("testWithEmptySourceForOneDimensionalPrimitiveArray", int[].class);
-			results.testEvents().succeeded().assertEventsMatchExactly(event(test(), displayName("[1] []")));
+			results.testEvents().succeeded().assertEventsMatchExactly(event(test(), displayName("[1] argument=[]")));
 		}
 
 		@Test
 		void executesWithEmptySourceForOneDimensionalStringArray() {
 			var results = execute("testWithEmptySourceForOneDimensionalStringArray", String[].class);
-			results.testEvents().succeeded().assertEventsMatchExactly(event(test(), displayName("[1] []")));
+			results.testEvents().succeeded().assertEventsMatchExactly(event(test(), displayName("[1] argument=[]")));
 		}
 
 		@Test
 		void executesWithEmptySourceForTwoDimensionalPrimitiveArray() {
 			var results = execute("testWithEmptySourceForTwoDimensionalPrimitiveArray", int[][].class);
-			results.testEvents().succeeded().assertEventsMatchExactly(event(test(), displayName("[1] []")));
+			results.testEvents().succeeded().assertEventsMatchExactly(event(test(), displayName("[1] argument=[]")));
 		}
 
 		@Test
 		void executesWithEmptySourceForTwoDimensionalStringArray() {
 			var results = execute("testWithEmptySourceForTwoDimensionalStringArray", String[][].class);
-			results.testEvents().succeeded().assertEventsMatchExactly(event(test(), displayName("[1] []")));
+			results.testEvents().succeeded().assertEventsMatchExactly(event(test(), displayName("[1] argument=[]")));
 		}
 
 		@Test
@@ -406,15 +423,15 @@ class ParameterizedTestIntegrationTests {
 
 		private void assertNullAndEmptyString(EngineExecutionResults results) {
 			results.testEvents().succeeded().assertEventsMatchExactly(//
-				event(test(), displayName("[1] null")), //
-				event(test(), displayName("[2] "))//
+				event(test(), displayName("[1] argument=null")), //
+				event(test(), displayName("[2] argument="))//
 			);
 		}
 
 		private void assertNullAndEmpty(EngineExecutionResults results) {
 			results.testEvents().succeeded().assertEventsMatchExactly(//
-				event(test(), displayName("[1] null")), //
-				event(test(), displayName("[2] []"))//
+				event(test(), displayName("[1] argument=null")), //
+				event(test(), displayName("[2] argument=[]"))//
 			);
 		}
 
@@ -569,32 +586,36 @@ class ParameterizedTestIntegrationTests {
 		void executesWithArgumentsSourceProvidingUnusedArguments() {
 			var results = execute("testWithTwoUnusedStringArgumentsProvider", String.class);
 			results.allEvents().assertThatEvents() //
-					.haveExactly(1, event(test(), displayName("[1] foo"), finishedWithFailure(message("foo")))) //
-					.haveExactly(1, event(test(), displayName("[2] bar"), finishedWithFailure(message("bar"))));
+					.haveExactly(1, event(test(), displayName("[1] argument=foo"), finishedWithFailure(message("foo")))) //
+					.haveExactly(1,
+						event(test(), displayName("[2] argument=bar"), finishedWithFailure(message("bar"))));
 		}
 
 		@Test
 		void executesWithCsvSourceContainingUnusedArguments() {
 			var results = execute("testWithCsvSourceContainingUnusedArguments", String.class);
 			results.allEvents().assertThatEvents() //
-					.haveExactly(1, event(test(), displayName("[1] foo"), finishedWithFailure(message("foo")))) //
-					.haveExactly(1, event(test(), displayName("[2] bar"), finishedWithFailure(message("bar"))));
+					.haveExactly(1, event(test(), displayName("[1] argument=foo"), finishedWithFailure(message("foo")))) //
+					.haveExactly(1,
+						event(test(), displayName("[2] argument=bar"), finishedWithFailure(message("bar"))));
 		}
 
 		@Test
 		void executesWithCsvFileSourceContainingUnusedArguments() {
 			var results = execute("testWithCsvFileSourceContainingUnusedArguments", String.class);
 			results.allEvents().assertThatEvents() //
-					.haveExactly(1, event(test(), displayName("[1] foo"), finishedWithFailure(message("foo")))) //
-					.haveExactly(1, event(test(), displayName("[2] bar"), finishedWithFailure(message("bar"))));
+					.haveExactly(1, event(test(), displayName("[1] argument=foo"), finishedWithFailure(message("foo")))) //
+					.haveExactly(1,
+						event(test(), displayName("[2] argument=bar"), finishedWithFailure(message("bar"))));
 		}
 
 		@Test
 		void executesWithMethodSourceProvidingUnusedArguments() {
 			var results = execute("testWithMethodSourceProvidingUnusedArguments", String.class);
 			results.allEvents().assertThatEvents() //
-					.haveExactly(1, event(test(), displayName("[1] foo"), finishedWithFailure(message("foo")))) //
-					.haveExactly(1, event(test(), displayName("[2] bar"), finishedWithFailure(message("bar"))));
+					.haveExactly(1, event(test(), displayName("[1] argument=foo"), finishedWithFailure(message("foo")))) //
+					.haveExactly(1,
+						event(test(), displayName("[2] argument=bar"), finishedWithFailure(message("bar"))));
 		}
 
 		private EngineExecutionResults execute(String methodName, Class<?>... methodParameterTypes) {
@@ -656,6 +677,12 @@ class ParameterizedTestIntegrationTests {
 			fail("this should never be called");
 		}
 
+		@ParameterizedTest
+		@CsvSource({ "ab, cd", "ef, gh" })
+		void testWithAggregator(@AggregateWith(StringAggregator.class) String concatenation) {
+			fail("concatenation: " + concatenation);
+		}
+
 	}
 
 	static class NullSourceTestCase {
@@ -1091,6 +1118,15 @@ class ParameterizedTestIntegrationTests {
 		}
 	}
 
+	private static class StringAggregator implements ArgumentsAggregator {
+
+		@Override
+		public Object aggregateArguments(ArgumentsAccessor accessor, ParameterContext context)
+				throws ArgumentsAggregationException {
+			return accessor.getString(0) + accessor.getString(1);
+		}
+	}
+
 	private static class ErroneousConverter implements ArgumentConverter {
 
 		@Override
diff --git a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestNameFormatterTests.java b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestNameFormatterTests.java
index a97c7aeef..3e5f8f2b5 100644
--- a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestNameFormatterTests.java
+++ b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/ParameterizedTestNameFormatterTests.java
@@ -16,10 +16,12 @@ import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertNotNull;
 import static org.junit.jupiter.api.Assertions.assertThrows;
 import static org.junit.jupiter.params.ParameterizedTest.ARGUMENTS_PLACEHOLDER;
-import static org.junit.jupiter.params.ParameterizedTest.DEFAULT_DISPLAY_NAME;
+import static org.junit.jupiter.params.ParameterizedTest.ARGUMENTS_WITH_NAMES_PLACEHOLDER;
 import static org.junit.jupiter.params.ParameterizedTest.DISPLAY_NAME_PLACEHOLDER;
 import static org.junit.jupiter.params.ParameterizedTest.INDEX_PLACEHOLDER;
+import static org.mockito.Mockito.mock;
 
+import java.lang.reflect.Method;
 import java.math.BigDecimal;
 import java.sql.Date;
 import java.time.LocalDate;
@@ -30,8 +32,14 @@ import java.util.Locale;
 
 import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ParameterContext;
+import org.junit.jupiter.params.aggregator.AggregateWith;
+import org.junit.jupiter.params.aggregator.ArgumentsAccessor;
+import org.junit.jupiter.params.aggregator.ArgumentsAggregationException;
+import org.junit.jupiter.params.aggregator.ArgumentsAggregator;
 import org.junit.jupiter.params.provider.CsvSource;
 import org.junit.platform.commons.JUnitException;
+import org.junit.platform.commons.util.ReflectionUtils;
 
 /**
  * @since 5.0
@@ -47,8 +55,7 @@ class ParameterizedTestNameFormatterTests {
 
 	@Test
 	void formatsDisplayName() {
-		ParameterizedTestNameFormatter formatter = new ParameterizedTestNameFormatter(DISPLAY_NAME_PLACEHOLDER,
-			"enigma");
+		ParameterizedTestNameFormatter formatter = formatter(DISPLAY_NAME_PLACEHOLDER, "enigma");
 
 		assertEquals("enigma", formatter.format(1));
 		assertEquals("enigma", formatter.format(2));
@@ -56,7 +63,7 @@ class ParameterizedTestNameFormatterTests {
 
 	@Test
 	void formatsInvocationIndex() {
-		ParameterizedTestNameFormatter formatter = new ParameterizedTestNameFormatter(INDEX_PLACEHOLDER, "enigma");
+		ParameterizedTestNameFormatter formatter = formatter(INDEX_PLACEHOLDER, "enigma");
 
 		assertEquals("1", formatter.format(1));
 		assertEquals("2", formatter.format(2));
@@ -64,14 +71,14 @@ class ParameterizedTestNameFormatterTests {
 
 	@Test
 	void formatsIndividualArguments() {
-		ParameterizedTestNameFormatter formatter = new ParameterizedTestNameFormatter("{0} -> {1}", "enigma");
+		ParameterizedTestNameFormatter formatter = formatter("{0} -> {1}", "enigma");
 
 		assertEquals("foo -> 42", formatter.format(1, "foo", 42));
 	}
 
 	@Test
 	void formatsCompleteArgumentsList() {
-		ParameterizedTestNameFormatter formatter = new ParameterizedTestNameFormatter(ARGUMENTS_PLACEHOLDER, "enigma");
+		ParameterizedTestNameFormatter formatter = formatter(ARGUMENTS_PLACEHOLDER, "enigma");
 
 		// @formatter:off
 		assertEquals("42, 99, enigma, null, [1, 2, 3], [foo, bar], [[2, 4], [3, 9]]",
@@ -88,27 +95,48 @@ class ParameterizedTestNameFormatterTests {
 	}
 
 	@Test
-	void formatsInvocationIndexAndCompleteArgumentsListUsingDefaultPattern() {
-		ParameterizedTestNameFormatter formatter = new ParameterizedTestNameFormatter(DEFAULT_DISPLAY_NAME, "enigma");
+	void formatsCompleteArgumentsListWithNames() {
+		Method testMethod = ParameterizedTestCases.getMethod("parameterizedTest", int.class, String.class,
+			Object[].class);
+		ParameterizedTestNameFormatter formatter = formatter(ARGUMENTS_WITH_NAMES_PLACEHOLDER, "enigma", testMethod);
+
+		String formattedName = formatter.format(1, 42, "enigma", new Object[] { "foo", 1 });
+		assertEquals("someNumber=42, someString=enigma, someArray=[foo, 1]", formattedName);
+	}
+
+	@Test
+	void formatsCompleteArgumentsListWithoutNamesForAggregators() {
+		Method testMethod = ParameterizedTestCases.getMethod("parameterizedTestWithAggregator", int.class,
+			String.class);
+		ParameterizedTestNameFormatter formatter = formatter(ARGUMENTS_WITH_NAMES_PLACEHOLDER, "enigma", testMethod);
+
+		String formattedName = formatter.format(1, 42, "foo", "bar");
+		assertEquals("someNumber=42, foo, bar", formattedName);
+	}
+
+	@Test
+	void formatsCompleteArgumentsListWithArrays() {
+		ParameterizedTestNameFormatter formatter = formatter(ARGUMENTS_PLACEHOLDER, "enigma");
 
 		// Explicit test for https://github.com/junit-team/junit5/issues/814
-		assertEquals("[1] [foo, bar]", formatter.format(1, (Object) new String[] { "foo", "bar" }));
+		assertEquals("[foo, bar]", formatter.format(1, (Object) new String[] { "foo", "bar" }));
 
-		assertEquals("[1] [foo, bar], 42, true", formatter.format(1, new String[] { "foo", "bar" }, 42, true));
+		assertEquals("[foo, bar], 42, true", formatter.format(1, new String[] { "foo", "bar" }, 42, true));
 	}
 
 	@Test
 	void formatsEverythingUsingCustomPattern() {
-		String pattern = DISPLAY_NAME_PLACEHOLDER + " :: " + DEFAULT_DISPLAY_NAME + " :: {1}";
-		ParameterizedTestNameFormatter formatter = new ParameterizedTestNameFormatter(pattern, "enigma");
+		String pattern = DISPLAY_NAME_PLACEHOLDER + " " + INDEX_PLACEHOLDER + " :: " + ARGUMENTS_PLACEHOLDER
+				+ " :: {1}";
+		ParameterizedTestNameFormatter formatter = formatter(pattern, "enigma");
 
-		assertEquals("enigma :: [1] foo, bar :: bar", formatter.format(1, "foo", "bar"));
-		assertEquals("enigma :: [2] foo, 42 :: 42", formatter.format(2, "foo", 42));
+		assertEquals("enigma 1 :: foo, bar :: bar", formatter.format(1, "foo", "bar"));
+		assertEquals("enigma 2 :: foo, 42 :: 42", formatter.format(2, "foo", 42));
 	}
 
 	@Test
 	void formatDoesNotAlterArgumentsArray() {
-		ParameterizedTestNameFormatter formatter = new ParameterizedTestNameFormatter(ARGUMENTS_PLACEHOLDER, "enigma");
+		ParameterizedTestNameFormatter formatter = formatter(ARGUMENTS_PLACEHOLDER, "enigma");
 		Object[] actual = { 1, "two", Byte.valueOf("-128"), new Integer[][] { { 2, 4 }, { 3, 9 } } };
 		Object[] expected = Arrays.copyOf(actual, actual.length);
 		assertEquals("1, two, -128, [[2, 4], [3, 9]]", formatter.format(1, actual));
@@ -117,7 +145,7 @@ class ParameterizedTestNameFormatterTests {
 
 	@Test
 	void formatDoesNotRaiseAnArrayStoreException() {
-		ParameterizedTestNameFormatter formatter = new ParameterizedTestNameFormatter("{0} -> {1}", "enigma");
+		ParameterizedTestNameFormatter formatter = formatter("{0} -> {1}", "enigma");
 
 		Object[] arguments = new Number[] { 1, 2 };
 		assertEquals("1 -> 2", formatter.format(1, arguments));
@@ -125,7 +153,7 @@ class ParameterizedTestNameFormatterTests {
 
 	@Test
 	void throwsReadableExceptionForInvalidPattern() {
-		ParameterizedTestNameFormatter formatter = new ParameterizedTestNameFormatter("{index", "enigma");
+		ParameterizedTestNameFormatter formatter = formatter("{index", "enigma");
 
 		JUnitException exception = assertThrows(JUnitException.class, () -> formatter.format(1));
 		assertNotNull(exception.getCause());
@@ -134,11 +162,11 @@ class ParameterizedTestNameFormatterTests {
 
 	@Test
 	void formattingDoesNotFailIfArgumentToStringImplementationThrowsAnException() {
-		ParameterizedTestNameFormatter formatter = new ParameterizedTestNameFormatter(DEFAULT_DISPLAY_NAME, "enigma");
+		ParameterizedTestNameFormatter formatter = formatter(ARGUMENTS_PLACEHOLDER, "enigma");
 
 		String formattedName = formatter.format(1, new Object[] { new ToStringThrowsException(), "foo" });
 
-		assertThat(formattedName).startsWith("[1] " + ToStringThrowsException.class.getName() + "@");
+		assertThat(formattedName).startsWith(ToStringThrowsException.class.getName() + "@");
 		assertThat(formattedName).endsWith("foo");
 	}
 
@@ -147,7 +175,7 @@ class ParameterizedTestNameFormatterTests {
 			"DE | 42,23 is positive on 13.01.2019 at 12:34:56" })
 	void customFormattingExpressionsAreSupported(Locale locale, String expectedValue) {
 		var pattern = "[{index}] {1,number,#.##} is {1,choice,0<positive} on {0,date} at {0,time} even though {2}";
-		ParameterizedTestNameFormatter formatter = new ParameterizedTestNameFormatter(pattern, "enigma");
+		ParameterizedTestNameFormatter formatter = formatter(pattern, "enigma");
 		Locale.setDefault(Locale.US);
 
 		var date = Date.from(
@@ -161,7 +189,7 @@ class ParameterizedTestNameFormatterTests {
 
 	@Test
 	void ignoresExcessPlaceholders() {
-		ParameterizedTestNameFormatter formatter = new ParameterizedTestNameFormatter("{0}, {1}", "enigma");
+		ParameterizedTestNameFormatter formatter = formatter("{0}, {1}", "enigma");
 
 		String formattedName = formatter.format(1, "foo");
 
@@ -170,7 +198,7 @@ class ParameterizedTestNameFormatterTests {
 
 	@Test
 	void placeholdersCanBeOmitted() {
-		ParameterizedTestNameFormatter formatter = new ParameterizedTestNameFormatter("{0}", "enigma");
+		ParameterizedTestNameFormatter formatter = formatter("{0}", "enigma");
 
 		String formattedName = formatter.format(1, "foo", "bar");
 
@@ -179,13 +207,23 @@ class ParameterizedTestNameFormatterTests {
 
 	@Test
 	void placeholdersCanBeSkipped() {
-		ParameterizedTestNameFormatter formatter = new ParameterizedTestNameFormatter("{0}, {2}", "enigma");
+		ParameterizedTestNameFormatter formatter = formatter("{0}, {2}", "enigma");
 
 		String formattedName = formatter.format(1, "foo", "bar", "baz");
 
 		assertThat(formattedName).isEqualTo("foo, baz");
 	}
 
+	private static ParameterizedTestNameFormatter formatter(String pattern, String displayName) {
+		return new ParameterizedTestNameFormatter(pattern, displayName, mock(ParameterizedTestMethodContext.class));
+	}
+
+	private static ParameterizedTestNameFormatter formatter(String pattern, String displayName, Method method) {
+		return new ParameterizedTestNameFormatter(pattern, displayName, new ParameterizedTestMethodContext(method));
+	}
+
+	// -------------------------------------------------------------------
+
 	private static class ToStringThrowsException {
 
 		@Override
@@ -194,4 +232,28 @@ class ParameterizedTestNameFormatterTests {
 		}
 	}
 
+	private static class ParameterizedTestCases {
+
+		static Method getMethod(String methodName, Class<?>... parameterTypes) {
+			return ReflectionUtils.findMethod(ParameterizedTestCases.class, methodName, parameterTypes).get();
+		}
+
+		void parameterizedTest(int someNumber, String someString, Object[] someArray) {
+
+		}
+
+		void parameterizedTestWithAggregator(int someNumber,
+				@AggregateWith(CustomAggregator.class) String someAggregatedString) {
+
+		}
+
+		private static class CustomAggregator implements ArgumentsAggregator {
+			@Override
+			public Object aggregateArguments(ArgumentsAccessor accessor, ParameterContext context)
+					throws ArgumentsAggregationException {
+				return accessor.get(0);
+			}
+		}
+	}
+
 }
