diff --git a/documentation/src/docs/asciidoc/release-notes-5.0.0-M5.adoc b/documentation/src/docs/asciidoc/release-notes-5.0.0-M5.adoc
index b0aa65486..e29755366 100644
--- a/documentation/src/docs/asciidoc/release-notes-5.0.0-M5.adoc
+++ b/documentation/src/docs/asciidoc/release-notes-5.0.0-M5.adoc
@@ -50,6 +50,10 @@ is placed on the Java 9 module path.
   by falling back to printing throwable's `toString()` representation.
 * `DefaultLauncher` now catches and warns about exceptions generated by an engine in its
   discovery and execution phases. Other engines are processed normally.
+* `UniqueId.Segment` type and value strings are now partially URL encoded when the
+  string representation of an unique id is generated. All characters reserved by the
+  active `UniqueIdFormat` syntax (defaults to `[`, `:`, `]` and `/`) are encoded. The
+  default parser is updated to decode such encoded segments.
 
 ===== Deprecations and Breaking Changes
 
diff --git a/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/execution/ArrayTests.java b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/execution/ArrayTests.java
new file mode 100644
index 000000000..84b133e42
--- /dev/null
+++ b/junit-jupiter-engine/src/test/java/org/junit/jupiter/engine/execution/ArrayTests.java
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2015-2017 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v1.0 which
+ * accompanies this distribution and is available at
+ *
+ * http://www.eclipse.org/legal/epl-v10.html
+ */
+
+package org.junit.jupiter.engine.execution;
+
+import static org.junit.jupiter.api.Assertions.assertArrayEquals;
+import static org.junit.jupiter.api.Assertions.assertEquals;
+
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
+import org.junit.jupiter.engine.AbstractJupiterTestEngineTests;
+import org.junit.jupiter.engine.execution.injection.sample.PrimitiveArrayParameterResolver;
+import org.junit.platform.engine.TestDescriptor;
+import org.junit.platform.engine.UniqueId;
+import org.junit.platform.engine.test.event.ExecutionEvent;
+import org.junit.platform.engine.test.event.ExecutionEventRecorder;
+
+/**
+ * Unit tests for UniqueId.parse for methods with array type parameters.
+ *
+ * @see <a href="https://github.com/junit-team/junit5/issues/810">#810</a>
+ *
+ * @since 5.0
+ */
+class ArrayTests extends AbstractJupiterTestEngineTests {
+
+	@Test
+	void executeTestsForPrimitiveArrayMethodInjectionCases() {
+		ExecutionEventRecorder eventRecorder = executeTestsForClass(PrimitiveArrayMethodInjectionTestCase.class);
+
+		assertEquals(1, eventRecorder.getTestStartedCount(), "# tests started");
+		assertEquals(1, eventRecorder.getTestSuccessfulCount(), "# tests succeeded");
+		assertEquals(0, eventRecorder.getTestFailedCount(), "# tests failed");
+
+		// @formatter:off
+		eventRecorder.getExecutionEvents().stream()
+				.map(ExecutionEvent::getTestDescriptor)
+				.distinct()
+				.skip(2)
+				.map(TestDescriptor::getUniqueId)
+				.map(UniqueId::toString)
+				.forEach(UniqueId::parse);
+		// @formatter:on
+	}
+
+	@ExtendWith(PrimitiveArrayParameterResolver.class)
+	private static class PrimitiveArrayMethodInjectionTestCase {
+
+		@Test
+		void primitiveArray(int... ints) {
+			assertArrayEquals(new int[] { 1, 2, 3 }, ints);
+		}
+	}
+
+}
diff --git a/junit-platform-engine/src/main/java/org/junit/platform/engine/UniqueIdFormat.java b/junit-platform-engine/src/main/java/org/junit/platform/engine/UniqueIdFormat.java
index d82f2ad91..8db11616d 100644
--- a/junit-platform-engine/src/main/java/org/junit/platform/engine/UniqueIdFormat.java
+++ b/junit-platform-engine/src/main/java/org/junit/platform/engine/UniqueIdFormat.java
@@ -14,8 +14,13 @@ import static java.util.stream.Collectors.joining;
 import static java.util.stream.Collectors.toList;
 
 import java.io.Serializable;
+import java.io.UnsupportedEncodingException;
+import java.net.URLDecoder;
+import java.net.URLEncoder;
 import java.util.Arrays;
 import java.util.List;
+import java.util.Map;
+import java.util.TreeMap;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
@@ -44,6 +49,7 @@ class UniqueIdFormat implements Serializable {
 	private final char segmentDelimiter;
 	private final char typeValueSeparator;
 	private final Pattern segmentPattern;
+	private final Map<Character, String> encodedCharacterMap = new TreeMap<>();
 
 	UniqueIdFormat(char openSegment, char typeValueSeparator, char closeSegment, char segmentDelimiter) {
 		this.openSegment = openSegment;
@@ -51,7 +57,15 @@ class UniqueIdFormat implements Serializable {
 		this.closeSegment = closeSegment;
 		this.segmentDelimiter = segmentDelimiter;
 		this.segmentPattern = Pattern.compile(
-			String.format("%s(.+)%s(.+)%s", quote(openSegment), quote(typeValueSeparator), quote(closeSegment)));
+			String.format("%s(.+)%s(.+)%s", quote(openSegment), quote(typeValueSeparator), quote(closeSegment)),
+			Pattern.DOTALL);
+		// compute "forbidden" character encoding map
+		encodedCharacterMap.computeIfAbsent('%', UniqueIdFormat::encode);
+		encodedCharacterMap.computeIfAbsent('+', UniqueIdFormat::encode);
+		encodedCharacterMap.computeIfAbsent(openSegment, UniqueIdFormat::encode);
+		encodedCharacterMap.computeIfAbsent(typeValueSeparator, UniqueIdFormat::encode);
+		encodedCharacterMap.computeIfAbsent(closeSegment, UniqueIdFormat::encode);
+		encodedCharacterMap.computeIfAbsent(segmentDelimiter, UniqueIdFormat::encode);
 	}
 
 	/**
@@ -71,8 +85,8 @@ class UniqueIdFormat implements Serializable {
 		if (!segmentMatcher.matches()) {
 			throw new JUnitException(String.format("'%s' is not a well-formed UniqueId segment", segmentString));
 		}
-		String type = checkAllowed(segmentMatcher.group(1));
-		String value = checkAllowed(segmentMatcher.group(2));
+		String type = decode(checkAllowed(segmentMatcher.group(1)));
+		String value = decode(checkAllowed(segmentMatcher.group(2)));
 		return new Segment(type, value);
 	}
 
@@ -101,12 +115,42 @@ class UniqueIdFormat implements Serializable {
 	}
 
 	private String describe(Segment segment) {
-		return String.format("%s%s%s%s%s", this.openSegment, segment.getType(), this.typeValueSeparator,
-			segment.getValue(), this.closeSegment);
+		String body = encode(segment.getType()) + typeValueSeparator + encode(segment.getValue());
+		return openSegment + body + closeSegment;
 	}
 
 	private static String quote(char c) {
 		return Pattern.quote(String.valueOf(c));
 	}
 
+	private static String encode(char c) {
+		try {
+			return URLEncoder.encode(String.valueOf(c), "UTF-8");
+		}
+		catch (UnsupportedEncodingException e) {
+			throw new AssertionError("UTF-8 should be supported", e);
+		}
+	}
+
+	private String encode(String s) {
+		StringBuilder builder = new StringBuilder();
+		for (char c : s.toCharArray()) {
+			String value = encodedCharacterMap.get(c);
+			if (value == null) {
+				builder.append(c);
+				continue;
+			}
+			builder.append(value);
+		}
+		return builder.toString();
+	}
+
+	private String decode(String s) {
+		try {
+			return URLDecoder.decode(s, "UTF-8");
+		}
+		catch (UnsupportedEncodingException e) {
+			throw new JUnitException("UTF-8 should be supported", e);
+		}
+	}
 }
diff --git a/junit-platform-engine/src/test/java/org/junit/platform/engine/test/event/ExecutionEventConditions.java b/junit-platform-engine/src/test/java/org/junit/platform/engine/test/event/ExecutionEventConditions.java
index f3fe66df2..44514c628 100644
--- a/junit-platform-engine/src/test/java/org/junit/platform/engine/test/event/ExecutionEventConditions.java
+++ b/junit-platform-engine/src/test/java/org/junit/platform/engine/test/event/ExecutionEventConditions.java
@@ -29,6 +29,7 @@ import static org.junit.platform.engine.test.event.TestExecutionResultConditions
 import static org.junit.platform.engine.test.event.TestExecutionResultConditions.status;
 
 import java.util.List;
+import java.util.function.Predicate;
 
 import org.assertj.core.api.Assertions;
 import org.assertj.core.api.Condition;
@@ -36,6 +37,7 @@ import org.assertj.core.api.SoftAssertions;
 import org.junit.platform.engine.TestDescriptor;
 import org.junit.platform.engine.TestExecutionResult;
 import org.junit.platform.engine.TestExecutionResult.Status;
+import org.junit.platform.engine.UniqueId;
 import org.junit.platform.engine.support.descriptor.EngineDescriptor;
 import org.junit.platform.engine.test.event.ExecutionEvent.Type;
 
@@ -96,9 +98,13 @@ public class ExecutionEventConditions {
 	}
 
 	public static Condition<ExecutionEvent> uniqueIdSubstring(String uniqueIdSubstring) {
+		Predicate<UniqueId.Segment> predicate = segment -> {
+			String text = segment.getType() + ":" + segment.getValue();
+			return text.contains(uniqueIdSubstring);
+		};
 		return new Condition<>(
-			byTestDescriptor(where(testDescriptor -> testDescriptor.getUniqueId().toString(),
-				uniqueId -> uniqueId.contains(uniqueIdSubstring))),
+			byTestDescriptor(
+				where(TestDescriptor::getUniqueId, uniqueId -> uniqueId.getSegments().stream().anyMatch(predicate))),
 			"descriptor with uniqueId substring \"%s\"", uniqueIdSubstring);
 	}
 
diff --git a/platform-tests/src/test/java/org/junit/platform/engine/UniqueIdTests.java b/platform-tests/src/test/java/org/junit/platform/engine/UniqueIdTests.java
index 26b2a0010..e61799076 100644
--- a/platform-tests/src/test/java/org/junit/platform/engine/UniqueIdTests.java
+++ b/platform-tests/src/test/java/org/junit/platform/engine/UniqueIdTests.java
@@ -17,6 +17,8 @@ import java.util.Optional;
 import org.junit.jupiter.api.Assertions;
 import org.junit.jupiter.api.Nested;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.ValueSource;
 import org.junit.platform.engine.UniqueId.Segment;
 
 /**
@@ -113,6 +115,29 @@ class UniqueIdTests {
 			UniqueId parsedDirectly = UniqueId.parse("[engine:junit-jupiter]/[class:MyClass]/[method:myMethod]");
 			assertEquals("[engine:junit-jupiter]/[class:MyClass]/[method:myMethod]", parsedDirectly.toString());
 		}
+
+		@Test
+		void ensureDefaultUniqueIdFormatDecodingEncodedSegmentParts() {
+			UniqueId.Segment segment = UniqueId.parse("[%5B+%25+%5D):(%3A+%2B+%2F]").getSegments().get(0);
+			assertEquals("[ % ])", segment.getType());
+			assertEquals("(: + /", segment.getValue());
+		}
+
+		@Test
+		void ensureDefaultUniqueIdFormatCanHandleAllCharacters() {
+			for (char c = 0; c < Character.MAX_VALUE; c++) {
+				String value = "foo " + String.valueOf(c) + " bar";
+				UniqueId uniqueId = UniqueId.parse(UniqueId.root("type", value).toString());
+				Segment segment = uniqueId.getSegments().get(0);
+				assertEquals(value, segment.getValue());
+			}
+		}
+
+		@ParameterizedTest
+		@ValueSource(strings = { "[a:b]", "[a:b]/[a:b]", "[a$b:b()]", "[a:b(%5BI)]", "[%5B%5D:%3A%2F]" })
+		void ensureDefaultToStringAndParsingIsIdempotent(String expected) {
+			assertEquals(expected, UniqueId.parse(expected).toString());
+		}
 	}
 
 	@Nested
