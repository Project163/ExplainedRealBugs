diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.7.0-M2.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.7.0-M2.adoc
index 80f891a44..dd345c618 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.7.0-M2.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.7.0-M2.adoc
@@ -54,6 +54,8 @@ on GitHub.
   container might be disabled.
 * New `assertLinesMatch` method overloads added to class `Assertions` that accept
   two `Stream<String>` instances for comparison.
+* `@CsvFileSource` now allows to specify file paths as an alternative to classpath
+  resources.
 
 [[release-notes-5.7.0-M2-junit-vintage]]
 === JUnit Vintage
diff --git a/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc b/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
index 13a986eb1..a36e2481c 100644
--- a/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
+++ b/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
@@ -1220,8 +1220,8 @@ of any custom values configured via the `nullValues` attribute.
 [[writing-tests-parameterized-tests-sources-CsvFileSource]]
 ===== @CsvFileSource
 
-`@CsvFileSource` lets you use CSV files from the classpath. Each line from a CSV file
-results in one invocation of the parameterized test.
+`@CsvFileSource` lets you use CSV files from the classpath or the local file system. Each
+line from a CSV file results in one invocation of the parameterized test.
 
 The default delimiter is a comma (`,`), but you can use another character by setting the
 `delimiter` attribute. Alternatively, the `delimiterString` attribute allows you to use a
diff --git a/documentation/src/test/java/example/ParameterizedTestDemo.java b/documentation/src/test/java/example/ParameterizedTestDemo.java
index 5dd7204be..eb5b940ad 100644
--- a/documentation/src/test/java/example/ParameterizedTestDemo.java
+++ b/documentation/src/test/java/example/ParameterizedTestDemo.java
@@ -221,7 +221,14 @@ class ParameterizedTestDemo {
 	// tag::CsvFileSource_example[]
 	@ParameterizedTest
 	@CsvFileSource(resources = "/two-column.csv", numLinesToSkip = 1)
-	void testWithCsvFileSource(String country, int reference) {
+	void testWithCsvFileSourceFromClasspath(String country, int reference) {
+		assertNotNull(country);
+		assertNotEquals(0, reference);
+	}
+
+	@ParameterizedTest
+	@CsvFileSource(files = "src/test/resources/two-column.csv", numLinesToSkip = 1)
+	void testWithCsvFileSourceFromFile(String country, int reference) {
 		assertNotNull(country);
 		assertNotEquals(0, reference);
 	}
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvFileArgumentsProvider.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvFileArgumentsProvider.java
index 675c1f133..eb52ed594 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvFileArgumentsProvider.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvFileArgumentsProvider.java
@@ -11,25 +11,30 @@
 package org.junit.jupiter.params.provider;
 
 import static java.util.Spliterators.spliteratorUnknownSize;
+import static java.util.stream.Collectors.toList;
 import static java.util.stream.StreamSupport.stream;
 import static org.junit.jupiter.params.provider.Arguments.arguments;
 import static org.junit.jupiter.params.provider.CsvArgumentsProvider.handleCsvException;
 import static org.junit.jupiter.params.provider.CsvParserFactory.createParserFor;
 import static org.junit.platform.commons.util.CollectionUtils.toSet;
 
+import java.io.IOException;
 import java.io.InputStream;
 import java.nio.charset.Charset;
+import java.nio.file.Files;
+import java.nio.file.Paths;
 import java.util.Arrays;
 import java.util.Iterator;
+import java.util.List;
 import java.util.Set;
 import java.util.Spliterator;
-import java.util.function.BiFunction;
 import java.util.stream.Stream;
 
 import com.univocity.parsers.csv.CsvParser;
 
 import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.params.support.AnnotationConsumer;
+import org.junit.platform.commons.JUnitException;
 import org.junit.platform.commons.PreconditionViolationException;
 import org.junit.platform.commons.util.Preconditions;
 
@@ -38,26 +43,28 @@ import org.junit.platform.commons.util.Preconditions;
  */
 class CsvFileArgumentsProvider implements ArgumentsProvider, AnnotationConsumer<CsvFileSource> {
 
-	private final BiFunction<Class<?>, String, InputStream> inputStreamProvider;
+	private final InputStreamProvider inputStreamProvider;
 
 	private CsvFileSource annotation;
-	private String[] resources;
+	private List<Source> sources;
 	private Charset charset;
 	private int numLinesToSkip;
 	private CsvParser csvParser;
 
 	CsvFileArgumentsProvider() {
-		this(Class::getResourceAsStream);
+		this(DefaultInputStreamProvider.INSTANCE);
 	}
 
-	CsvFileArgumentsProvider(BiFunction<Class<?>, String, InputStream> inputStreamProvider) {
+	CsvFileArgumentsProvider(InputStreamProvider inputStreamProvider) {
 		this.inputStreamProvider = inputStreamProvider;
 	}
 
 	@Override
 	public void accept(CsvFileSource annotation) {
 		this.annotation = annotation;
-		this.resources = annotation.resources();
+		Stream<Source> resources = Arrays.stream(annotation.resources()).map(inputStreamProvider::classpathResource);
+		Stream<Source> files = Arrays.stream(annotation.files()).map(inputStreamProvider::file);
+		this.sources = Stream.concat(resources, files).collect(toList());
 		this.charset = getCharsetFrom(annotation);
 		this.numLinesToSkip = annotation.numLinesToSkip();
 		this.csvParser = createParserFor(annotation);
@@ -75,20 +82,14 @@ class CsvFileArgumentsProvider implements ArgumentsProvider, AnnotationConsumer<
 	@Override
 	public Stream<? extends Arguments> provideArguments(ExtensionContext context) {
 		// @formatter:off
-		return Arrays.stream(this.resources)
-				.map(resource -> openInputStream(context, resource))
+		return Preconditions.notEmpty(this.sources, "Resources or files must not be empty")
+				.stream()
+				.map(source -> source.open(context))
 				.map(this::beginParsing)
 				.flatMap(this::toStream);
 		// @formatter:on
 	}
 
-	private InputStream openInputStream(ExtensionContext context, String resource) {
-		Preconditions.notBlank(resource, "Classpath resource [" + resource + "] must not be null or blank");
-		Class<?> testClass = context.getRequiredTestClass();
-		return Preconditions.notNull(inputStreamProvider.apply(testClass, resource),
-			() -> "Classpath resource [" + resource + "] does not exist");
-	}
-
 	private CsvParser beginParsing(InputStream inputStream) {
 		try {
 			this.csvParser.beginParsing(inputStream, this.charset);
@@ -160,4 +161,50 @@ class CsvFileArgumentsProvider implements ArgumentsProvider, AnnotationConsumer<
 
 	}
 
+	private interface Source {
+
+		InputStream open(ExtensionContext context);
+
+	}
+
+	interface InputStreamProvider {
+
+		InputStream openClasspathResource(Class<?> baseClass, String path);
+
+		InputStream openFile(String path);
+
+		default Source classpathResource(String path) {
+			return context -> openClasspathResource(context.getRequiredTestClass(), path);
+		}
+
+		default Source file(String path) {
+			return context -> openFile(path);
+		}
+
+	}
+
+	private static class DefaultInputStreamProvider implements InputStreamProvider {
+
+		private static final DefaultInputStreamProvider INSTANCE = new DefaultInputStreamProvider();
+
+		@Override
+		public InputStream openClasspathResource(Class<?> baseClass, String path) {
+			Preconditions.notBlank(path, () -> "Classpath resource [" + path + "] must not be null or blank");
+			InputStream inputStream = baseClass.getResourceAsStream(path);
+			return Preconditions.notNull(inputStream, () -> "Classpath resource [" + path + "] does not exist");
+		}
+
+		@Override
+		public InputStream openFile(String path) {
+			Preconditions.notBlank(path, () -> "File [" + path + "] must not be null or blank");
+			try {
+				return Files.newInputStream(Paths.get(path));
+			}
+			catch (IOException e) {
+				throw new JUnitException("File [" + path + "] could not be read", e);
+			}
+		}
+
+	}
+
 }
diff --git a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvFileSource.java b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvFileSource.java
index ff3028c66..1deda32fb 100644
--- a/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvFileSource.java
+++ b/junit-jupiter-params/src/main/java/org/junit/jupiter/params/provider/CsvFileSource.java
@@ -23,7 +23,7 @@ import org.apiguardian.api.API;
 /**
  * {@code @CsvFileSource} is an {@link ArgumentsSource} which is used to load
  * comma-separated value (CSV) files from one or more classpath {@link #resources
- * resources}.
+ * resources} or {@link #files}.
  *
  * <p>The lines of these CSV files will be provided as arguments to the
  * annotated {@code @ParameterizedTest} method. Any line beginning with a
@@ -42,10 +42,16 @@ import org.apiguardian.api.API;
 public @interface CsvFileSource {
 
 	/**
-	 * The CSV classpath resources to use as the sources of arguments; must not be
-	 * empty.
+	 * The CSV classpath resources to use as the sources of arguments; must not
+	 * be empty unless {@link #files} is non-empty.
 	 */
-	String[] resources();
+	String[] resources() default {};
+
+	/**
+	 * The CSV files to use as the sources of arguments; must not be empty
+	 * unless {@link #resources} is non-empty.
+	 */
+	String[] files() default {};
 
 	/**
 	 * The encoding to use when reading the CSV files; must be a valid charset.
diff --git a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/provider/CsvFileArgumentsProviderTests.java b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/provider/CsvFileArgumentsProviderTests.java
index ade6b5afd..9dbe2d472 100644
--- a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/provider/CsvFileArgumentsProviderTests.java
+++ b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/provider/CsvFileArgumentsProviderTests.java
@@ -19,13 +19,19 @@ import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
 import java.io.ByteArrayInputStream;
+import java.io.IOException;
 import java.io.InputStream;
+import java.nio.file.Files;
+import java.nio.file.Path;
 import java.util.Optional;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.stream.Stream;
 
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.extension.ExtensionContext;
+import org.junit.jupiter.api.io.TempDir;
+import org.junit.jupiter.params.provider.CsvFileArgumentsProvider.InputStreamProvider;
+import org.junit.platform.commons.JUnitException;
 import org.junit.platform.commons.PreconditionViolationException;
 
 /**
@@ -36,6 +42,7 @@ class CsvFileArgumentsProviderTests {
 	@Test
 	void providesArgumentsForNewlineAndComma() {
 		CsvFileSource annotation = csvFileSource()//
+				.resources("test.csv")//
 				.lineSeparator("\n")//
 				.delimiter(',')//
 				.build();
@@ -48,6 +55,7 @@ class CsvFileArgumentsProviderTests {
 	@Test
 	void providesArgumentsForCarriageReturnAndSemicolon() {
 		CsvFileSource annotation = csvFileSource()//
+				.resources("test.csv")//
 				.lineSeparator("\r")//
 				.delimiter(';')//
 				.build();
@@ -60,6 +68,7 @@ class CsvFileArgumentsProviderTests {
 	@Test
 	void providesArgumentsWithStringDelimiter() {
 		CsvFileSource annotation = csvFileSource()//
+				.resources("test.csv")//
 				.delimiterString(",")//
 				.build();
 
@@ -71,6 +80,7 @@ class CsvFileArgumentsProviderTests {
 	@Test
 	void throwsExceptionIfBothDelimitersAreSimultaneouslySet() {
 		CsvFileSource annotation = csvFileSource()//
+				.resources("test.csv")//
 				.delimiter(',')//
 				.delimiterString(";")//
 				.build();
@@ -86,6 +96,7 @@ class CsvFileArgumentsProviderTests {
 	@Test
 	void ignoresCommentedOutEntries() {
 		CsvFileSource annotation = csvFileSource()//
+				.resources("test.csv")//
 				.delimiter(',')//
 				.build();
 
@@ -95,7 +106,7 @@ class CsvFileArgumentsProviderTests {
 	}
 
 	@Test
-	void closesInputStream() {
+	void closesInputStreamForClasspathResource() {
 		AtomicBoolean closed = new AtomicBoolean(false);
 		InputStream inputStream = new ByteArrayInputStream("foo".getBytes()) {
 
@@ -104,8 +115,28 @@ class CsvFileArgumentsProviderTests {
 				closed.set(true);
 			}
 		};
+		CsvFileSource annotation = csvFileSource().resources("test.csv").build();
 
-		Stream<Object[]> arguments = provideArguments(inputStream, csvFileSource().build());
+		Stream<Object[]> arguments = provideArguments(inputStream, annotation);
+
+		assertThat(arguments.count()).isEqualTo(1);
+		assertThat(closed.get()).describedAs("closed").isTrue();
+	}
+
+	@Test
+	void closesInputStreamForFile(@TempDir Path tempDir) {
+		AtomicBoolean closed = new AtomicBoolean(false);
+		InputStream inputStream = new ByteArrayInputStream("foo".getBytes()) {
+
+			@Override
+			public void close() {
+				closed.set(true);
+			}
+		};
+		CsvFileSource annotation = csvFileSource().files(
+			tempDir.resolve("test.csv").toAbsolutePath().toString()).build();
+
+		Stream<Object[]> arguments = provideArguments(inputStream, annotation);
 
 		assertThat(arguments.count()).isEqualTo(1);
 		assertThat(closed.get()).describedAs("closed").isTrue();
@@ -123,6 +154,51 @@ class CsvFileArgumentsProviderTests {
 		assertThat(arguments).containsExactly(array("foo"), array("bar"), array("baz"), array("qux"), array(""));
 	}
 
+	@Test
+	void readsFromSingleFileWithAbsolutePath(@TempDir Path tempDir) throws Exception {
+		Path csvFile = writeClasspathResourceToFile("/single-column.csv", tempDir.resolve("single-column.csv"));
+		CsvFileSource annotation = csvFileSource()//
+				.encoding("ISO-8859-1")//
+				.files(csvFile.toAbsolutePath().toString())//
+				.build();
+
+		Stream<Object[]> arguments = provideArguments(new CsvFileArgumentsProvider(), annotation);
+
+		assertThat(arguments).containsExactly(array("foo"), array("bar"), array("baz"), array("qux"), array(""));
+	}
+
+	@Test
+	void readsFromClasspathResourcesAndFiles(@TempDir Path tempDir) throws Exception {
+		Path csvFile = writeClasspathResourceToFile("/single-column.csv", tempDir.resolve("single-column.csv"));
+		CsvFileSource annotation = csvFileSource()//
+				.encoding("ISO-8859-1")//
+				.resources("/single-column.csv")//
+				.files(csvFile.toAbsolutePath().toString())//
+				.build();
+
+		Stream<Object[]> arguments = provideArguments(new CsvFileArgumentsProvider(), annotation);
+
+		assertThat(arguments).hasSize(2 * 5);
+	}
+
+	@Test
+	void readsFromSingleFileWithRelativePath() throws Exception {
+		Path csvFile = writeClasspathResourceToFile("/single-column.csv", Path.of("single-column.csv"));
+		try {
+			CsvFileSource annotation = csvFileSource()//
+					.encoding("ISO-8859-1")//
+					.files(csvFile.getFileName().toString())//
+					.build();
+
+			Stream<Object[]> arguments = provideArguments(new CsvFileArgumentsProvider(), annotation);
+
+			assertThat(arguments).containsExactly(array("foo"), array("bar"), array("baz"), array("qux"), array(""));
+		}
+		finally {
+			Files.delete(csvFile);
+		}
+	}
+
 	@Test
 	void readsFromSingleClasspathResourceWithCustomEmptyValue() {
 		CsvFileSource annotation = csvFileSource()//
@@ -212,6 +288,43 @@ class CsvFileArgumentsProviderTests {
 		assertThat(exception).hasMessageContaining("Classpath resource [    ] must not be null or blank");
 	}
 
+	@Test
+	void throwsExceptionForMissingFile() {
+		CsvFileSource annotation = csvFileSource()//
+				.files("does-not-exist.csv")//
+				.build();
+
+		JUnitException exception = assertThrows(JUnitException.class,
+			() -> provideArguments(new CsvFileArgumentsProvider(), annotation).toArray());
+
+		assertThat(exception).hasMessageContaining("File [does-not-exist.csv] could not be read");
+	}
+
+	@Test
+	void throwsExceptionForBlankFile() {
+		CsvFileSource annotation = csvFileSource()//
+				.files("    ")//
+				.build();
+
+		PreconditionViolationException exception = assertThrows(PreconditionViolationException.class,
+			() -> provideArguments(new CsvFileArgumentsProvider(), annotation).toArray());
+
+		assertThat(exception).hasMessageContaining("File [    ] must not be null or blank");
+	}
+
+	@Test
+	void throwsExceptionIfResourcesAndFilesAreEmpty() {
+		CsvFileSource annotation = csvFileSource()//
+				.resources()//
+				.files()//
+				.build();
+
+		PreconditionViolationException exception = assertThrows(PreconditionViolationException.class,
+			() -> provideArguments(new CsvFileArgumentsProvider(), annotation).toArray());
+
+		assertThat(exception).hasMessageContaining("Resources or files must not be empty");
+	}
+
 	@Test
 	void throwsExceptionForInvalidCharset() {
 		CsvFileSource annotation = csvFileSource()//
@@ -244,6 +357,7 @@ class CsvFileArgumentsProviderTests {
 	@Test
 	void emptyValueIsAnEmptyWithCustomNullValueString() {
 		CsvFileSource annotation = csvFileSource()//
+				.resources("test.csv")//
 				.lineSeparator("\n")//
 				.delimiter(',')//
 				.nullValues("NIL")//
@@ -259,11 +373,18 @@ class CsvFileArgumentsProviderTests {
 	}
 
 	private Stream<Object[]> provideArguments(InputStream inputStream, CsvFileSource annotation) {
-		String expectedResource = annotation.resources()[0];
+		CsvFileArgumentsProvider provider = new CsvFileArgumentsProvider(new InputStreamProvider() {
+			@Override
+			public InputStream openClasspathResource(Class<?> baseClass, String path) {
+				assertThat(path).isEqualTo(annotation.resources()[0]);
+				return inputStream;
+			}
 
-		CsvFileArgumentsProvider provider = new CsvFileArgumentsProvider((testClass, resource) -> {
-			assertThat(resource).isEqualTo(expectedResource);
-			return inputStream;
+			@Override
+			public InputStream openFile(String path) {
+				assertThat(path).isEqualTo(annotation.files()[0]);
+				return inputStream;
+			}
 		});
 		return provideArguments(provider, annotation);
 	}
@@ -281,4 +402,11 @@ class CsvFileArgumentsProviderTests {
 		return elements;
 	}
 
+	private static Path writeClasspathResourceToFile(String name, Path target) throws IOException {
+		try (var in = CsvFileArgumentsProviderTests.class.getResourceAsStream(name)) {
+			Files.copy(in, target);
+		}
+		return target;
+	}
+
 }
diff --git a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/provider/MockCsvAnnotationBuilder.java b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/provider/MockCsvAnnotationBuilder.java
index 15285a453..bd6c1886a 100644
--- a/junit-jupiter-params/src/test/java/org/junit/jupiter/params/provider/MockCsvAnnotationBuilder.java
+++ b/junit-jupiter-params/src/test/java/org/junit/jupiter/params/provider/MockCsvAnnotationBuilder.java
@@ -102,7 +102,8 @@ abstract class MockCsvAnnotationBuilder<A extends Annotation, B extends MockCsvA
 
 	static class MockCsvFileSourceBuilder extends MockCsvAnnotationBuilder<CsvFileSource, MockCsvFileSourceBuilder> {
 
-		private String[] resources = { "test.csv" };
+		private String[] resources = {};
+		private String[] files = {};
 		private String encoding = "UTF-8";
 		private String lineSeparator = "\n";
 		private int numLinesToSkip = 0;
@@ -112,14 +113,16 @@ abstract class MockCsvAnnotationBuilder<A extends Annotation, B extends MockCsvA
 			return this;
 		}
 
-		/**
-		 * Defaults to "test.csv".
-		 */
 		MockCsvFileSourceBuilder resources(String... resources) {
 			this.resources = resources;
 			return this;
 		}
 
+		MockCsvFileSourceBuilder files(String... files) {
+			this.files = files;
+			return this;
+		}
+
 		MockCsvFileSourceBuilder encoding(String encoding) {
 			this.encoding = encoding;
 			return this;
@@ -147,6 +150,7 @@ abstract class MockCsvAnnotationBuilder<A extends Annotation, B extends MockCsvA
 
 			// @CsvFileSource
 			when(annotation.resources()).thenReturn(this.resources);
+			when(annotation.files()).thenReturn(this.files);
 			when(annotation.encoding()).thenReturn(this.encoding);
 			when(annotation.lineSeparator()).thenReturn(this.lineSeparator);
 			when(annotation.numLinesToSkip()).thenReturn(this.numLinesToSkip);
diff --git a/platform-tooling-support-tests/src/test/java/platform/tooling/support/tests/ModularUserGuideTests.java b/platform-tooling-support-tests/src/test/java/platform/tooling/support/tests/ModularUserGuideTests.java
index 514500626..54e78aee1 100644
--- a/platform-tooling-support-tests/src/test/java/platform/tooling/support/tests/ModularUserGuideTests.java
+++ b/platform-tooling-support-tests/src/test/java/platform/tooling/support/tests/ModularUserGuideTests.java
@@ -105,6 +105,7 @@ class ModularUserGuideTests {
 
 	private static List<String> junit(Path temp, Writer out, Writer err) throws Exception {
 		var command = new ArrayList<String>();
+		var projectDir = Path.of("../documentation");
 		command.add(Path.of(System.getProperty("java.home"), "bin", "java").toString());
 
 		command.add("--show-version");
@@ -122,7 +123,7 @@ class ModularUserGuideTests {
 		// TODO This `patch-module` should work! Why doesn't it?
 		// command.add("--patch-module");
 		// command.add("documentation=../documentation/src/test/resources/");
-		Files.copy(Path.of("../documentation/src/test/resources/two-column.csv"),
+		Files.copy(projectDir.resolve("src/test/resources/two-column.csv"),
 			temp.resolve("destination/documentation/two-column.csv"));
 
 		command.add("--module");
@@ -141,7 +142,7 @@ class ModularUserGuideTests {
 		// System.out.println("______________");
 		// command.forEach(System.out::println);
 
-		var builder = new ProcessBuilder(command).directory(temp.toFile());
+		var builder = new ProcessBuilder(command).directory(projectDir.toFile());
 		var java = builder.start();
 		ProcessGroovyMethods.waitForProcessOutput(java, out, err);
 		var code = java.exitValue();
