diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.1.0-M2.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.1.0-M2.adoc
index 53a8b6ecb..c1f988022 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.1.0-M2.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.1.0-M2.adoc
@@ -152,4 +152,10 @@ _@API Guardian_ JAR _mandatory_ again.
 [[release-notes-5.1.0-M2-junit-vintage]]
 === JUnit Vintage
 
-No changes.
+==== Bug Fixes
+
+* When using a tag filter to include/exclude a tag that represents a JUnit 4 category,
+  e.g. `"com.example.Integration"`, the Vintage Engine no longer mistakenly executes all
+  test methods of test classes that contain at least one included test method, e.g. one
+  that is annotated with `@Category(com.example.Integration.class)`, regardless whether
+  they belong to the same category.
diff --git a/junit-platform-commons/src/main/java/org/junit/platform/commons/logging/LogRecordListener.java b/junit-platform-commons/src/main/java/org/junit/platform/commons/logging/LogRecordListener.java
index e75f6b146..3c9957c24 100644
--- a/junit-platform-commons/src/main/java/org/junit/platform/commons/logging/LogRecordListener.java
+++ b/junit-platform-commons/src/main/java/org/junit/platform/commons/logging/LogRecordListener.java
@@ -98,4 +98,12 @@ public class LogRecordListener {
 		return stream(clazz).filter(logRecord -> logRecord.getLevel() == level);
 	}
 
+	/**
+	 * Clear all existing {@link LogRecord log records} that have been
+	 * {@linkplain #logRecordSubmitted submitted} to this listener.
+	 */
+	public void clear() {
+		this.logRecords.clear();
+	}
+
 }
diff --git a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/descriptor/RunnerTestDescriptor.java b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/descriptor/RunnerTestDescriptor.java
index 1a4baf147..78a5c6812 100644
--- a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/descriptor/RunnerTestDescriptor.java
+++ b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/descriptor/RunnerTestDescriptor.java
@@ -10,13 +10,23 @@
 
 package org.junit.vintage.engine.descriptor;
 
+import static java.util.Collections.singletonList;
 import static org.apiguardian.api.API.Status.INTERNAL;
 
+import java.util.HashSet;
+import java.util.Set;
+
 import org.apiguardian.api.API;
+import org.junit.platform.commons.logging.Logger;
+import org.junit.platform.commons.logging.LoggerFactory;
 import org.junit.platform.engine.UniqueId;
 import org.junit.platform.engine.support.descriptor.ClassSource;
+import org.junit.runner.Description;
 import org.junit.runner.Request;
 import org.junit.runner.Runner;
+import org.junit.runner.manipulation.Filter;
+import org.junit.runner.manipulation.Filterable;
+import org.junit.runner.manipulation.NoTestsRemainException;
 
 /**
  * @since 4.12
@@ -24,7 +34,11 @@ import org.junit.runner.Runner;
 @API(status = INTERNAL, since = "4.12")
 public class RunnerTestDescriptor extends VintageTestDescriptor {
 
+	private static final Logger logger = LoggerFactory.getLogger(RunnerTestDescriptor.class);
+
 	private final Runner runner;
+	private final Set<Description> rejectedExclusions = new HashSet<>();
+	private boolean wasFiltered;
 
 	public RunnerTestDescriptor(UniqueId uniqueId, Class<?> testClass, Runner runner) {
 		super(uniqueId, runner.getDescription(), testClass.getName(), ClassSource.from(testClass));
@@ -35,4 +49,95 @@ public class RunnerTestDescriptor extends VintageTestDescriptor {
 		return new RunnerRequest(this.runner);
 	}
 
+	@Override
+	protected boolean tryToExcludeFromRunner(Description description) {
+		boolean excluded = tryToFilterRunner(description);
+		if (excluded) {
+			wasFiltered = true;
+		}
+		else {
+			rejectedExclusions.add(description);
+		}
+		return excluded;
+	}
+
+	private boolean tryToFilterRunner(Description description) {
+		if (runner instanceof Filterable) {
+			ExcludeDescriptionFilter filter = new ExcludeDescriptionFilter(description);
+			try {
+				((Filterable) runner).filter(filter);
+			}
+			catch (NoTestsRemainException ignore) {
+				// it's safe to ignore this exception because childless TestDescriptors will get pruned
+			}
+			return filter.wasSuccessful();
+		}
+		return false;
+	}
+
+	@Override
+	protected boolean canBeRemovedFromHierarchy() {
+		return true;
+	}
+
+	@Override
+	public void prune() {
+		if (wasFiltered) {
+			// filtering the runner may render intermediate Descriptions obsolete
+			// (e.g. test classes without any remaining children in a suite)
+			pruneDescriptorsForObsoleteDescriptions(singletonList(runner.getDescription()));
+		}
+		if (rejectedExclusions.isEmpty()) {
+			super.prune();
+		}
+		else if (rejectedExclusions.containsAll(getDescription().getChildren())) {
+			// since the Runner was asked to remove all of its direct children,
+			// it's safe to remove it entirely
+			removeFromHierarchy();
+		}
+		else {
+			logIncompleteFiltering();
+		}
+	}
+
+	private void logIncompleteFiltering() {
+		if (runner instanceof Filterable) {
+			logger.warn(() -> "Runner " + runner.getClass().getName() //
+					+ " (used on " + getDescription().getTestClass()
+					+ ") was not able to satisfy all filter requests.");
+		}
+		else {
+			logger.warn(() -> "Runner " + runner.getClass().getName() //
+					+ " (used on " + getDescription().getTestClass() + ") does not support filtering" //
+					+ " and will therefore be run completely.");
+		}
+	}
+
+	private static class ExcludeDescriptionFilter extends Filter {
+
+		private final Description description;
+		private boolean successful;
+
+		ExcludeDescriptionFilter(Description description) {
+			this.description = description;
+		}
+
+		@Override
+		public boolean shouldRun(Description description) {
+			if (this.description.equals(description)) {
+				successful = true;
+				return false;
+			}
+			return true;
+		}
+
+		@Override
+		public String describe() {
+			return "exclude " + description;
+		}
+
+		boolean wasSuccessful() {
+			return successful;
+		}
+	}
 }
diff --git a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/descriptor/VintageTestDescriptor.java b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/descriptor/VintageTestDescriptor.java
index 09ab5eb55..c0ae6e811 100644
--- a/junit-vintage-engine/src/main/java/org/junit/vintage/engine/descriptor/VintageTestDescriptor.java
+++ b/junit-vintage-engine/src/main/java/org/junit/vintage/engine/descriptor/VintageTestDescriptor.java
@@ -18,9 +18,11 @@ import static org.junit.platform.commons.util.FunctionUtils.where;
 import static org.junit.platform.commons.util.ReflectionUtils.findMethods;
 
 import java.lang.reflect.Method;
+import java.util.ArrayList;
 import java.util.Collection;
 import java.util.LinkedHashSet;
 import java.util.List;
+import java.util.Optional;
 import java.util.Set;
 
 import org.apiguardian.api.API;
@@ -78,6 +80,37 @@ public class VintageTestDescriptor extends AbstractTestDescriptor {
 		return tags;
 	}
 
+	@Override
+	public void removeFromHierarchy() {
+		if (canBeRemovedFromHierarchy()) {
+			super.removeFromHierarchy();
+		}
+	}
+
+	protected boolean canBeRemovedFromHierarchy() {
+		return tryToExcludeFromRunner(this.description);
+	}
+
+	protected boolean tryToExcludeFromRunner(Description description) {
+		// @formatter:off
+		return getParent().map(VintageTestDescriptor.class::cast)
+				.map(parent -> parent.tryToExcludeFromRunner(description))
+				.orElse(false);
+		// @formatter:on
+	}
+
+	void pruneDescriptorsForObsoleteDescriptions(List<Description> newSiblingDescriptions) {
+		Optional<Description> newDescription = newSiblingDescriptions.stream().filter(isEqual(description)).findAny();
+		if (newDescription.isPresent()) {
+			List<Description> newChildren = newDescription.get().getChildren();
+			new ArrayList<>(children).stream().map(VintageTestDescriptor.class::cast).forEach(
+				childDescriptor -> childDescriptor.pruneDescriptorsForObsoleteDescriptions(newChildren));
+		}
+		else {
+			super.removeFromHierarchy();
+		}
+	}
+
 	private void addTagsFromParent(Set<TestTag> tags) {
 		getParent().map(TestDescriptor::getTags).ifPresent(tags::addAll);
 	}
diff --git a/junit-vintage-engine/src/test/java/org/junit/vintage/engine/VintageLauncherIntegrationTests.java b/junit-vintage-engine/src/test/java/org/junit/vintage/engine/VintageLauncherIntegrationTests.java
new file mode 100644
index 000000000..31243cdf2
--- /dev/null
+++ b/junit-vintage-engine/src/test/java/org/junit/vintage/engine/VintageLauncherIntegrationTests.java
@@ -0,0 +1,247 @@
+/*
+ * Copyright 2015-2018 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * http://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.vintage.engine;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.platform.commons.util.CollectionUtils.getOnlyElement;
+import static org.junit.platform.engine.FilterResult.includedIf;
+import static org.junit.platform.engine.discovery.DiscoverySelectors.selectClass;
+import static org.junit.platform.launcher.EngineFilter.includeEngines;
+import static org.junit.platform.launcher.TagFilter.excludeTags;
+import static org.junit.platform.launcher.TagFilter.includeTags;
+import static org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder.request;
+import static org.junit.vintage.engine.descriptor.VintageTestDescriptor.ENGINE_ID;
+
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.logging.Level;
+import java.util.logging.LogRecord;
+
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.engine.TrackLogRecords;
+import org.junit.platform.commons.logging.LogRecordListener;
+import org.junit.platform.engine.TestExecutionResult;
+import org.junit.platform.launcher.Launcher;
+import org.junit.platform.launcher.LauncherDiscoveryRequest;
+import org.junit.platform.launcher.PostDiscoveryFilter;
+import org.junit.platform.launcher.TestExecutionListener;
+import org.junit.platform.launcher.TestIdentifier;
+import org.junit.platform.launcher.TestPlan;
+import org.junit.platform.launcher.core.LauncherDiscoveryRequestBuilder;
+import org.junit.platform.launcher.core.LauncherFactory;
+import org.junit.runners.Suite;
+import org.junit.vintage.engine.descriptor.RunnerTestDescriptor;
+import org.junit.vintage.engine.samples.junit4.Categories;
+import org.junit.vintage.engine.samples.junit4.EnclosedJUnit4TestCase;
+import org.junit.vintage.engine.samples.junit4.JUnit4SuiteOfSuiteWithFilterableChildRunner;
+import org.junit.vintage.engine.samples.junit4.JUnit4SuiteWithTwoTestCases;
+import org.junit.vintage.engine.samples.junit4.JUnit4TestCaseWithNotFilterableRunner;
+import org.junit.vintage.engine.samples.junit4.NotFilterableRunner;
+import org.junit.vintage.engine.samples.junit4.PlainJUnit4TestCaseWithFiveTestMethods;
+import org.junit.vintage.engine.samples.junit4.PlainJUnit4TestCaseWithTwoTestMethods;
+
+/**
+ * @since 5.1
+ */
+class VintageLauncherIntegrationTests {
+
+	@Test
+	void executesOnlyTaggedMethodOfRegularTestClass() {
+		Class<?> testClass = PlainJUnit4TestCaseWithFiveTestMethods.class;
+		LauncherDiscoveryRequestBuilder request = request() //
+				.selectors(selectClass(testClass)) //
+				.filters(includeTags(Categories.Failing.class.getName()));
+
+		TestPlan testPlan = discover(request);
+		assertThat(testPlan.getDescendants(getOnlyElement(testPlan.getRoots()))).hasSize(2);
+
+		Map<TestIdentifier, TestExecutionResult> results = execute(request);
+		assertThat(results.keySet().stream().map(TestIdentifier::getDisplayName)) //
+				.containsExactlyInAnyOrder("JUnit Vintage", testClass.getName(), "failingTest");
+	}
+
+	@Test
+	void executesIncludedTaggedMethodOfNestedTestClass() {
+		Class<?> testClass = EnclosedJUnit4TestCase.class;
+		Class<?> nestedTestClass = EnclosedJUnit4TestCase.NestedClass.class;
+		LauncherDiscoveryRequestBuilder request = request() //
+				.selectors(selectClass(testClass)) //
+				.filters(includeTags(Categories.Failing.class.getName()));
+
+		TestPlan testPlan = discover(request);
+		assertThat(testPlan.getDescendants(getOnlyElement(testPlan.getRoots()))).hasSize(3);
+
+		Map<TestIdentifier, TestExecutionResult> results = execute(request);
+		assertThat(results.keySet().stream().map(TestIdentifier::getDisplayName)) //
+				.containsExactlyInAnyOrder("JUnit Vintage", testClass.getName(), nestedTestClass.getName(),
+					"failingTest");
+	}
+
+	@Test
+	void executesOnlyNotExcludedTaggedMethodOfNestedTestClass() {
+		Class<?> testClass = EnclosedJUnit4TestCase.class;
+		Class<?> nestedTestClass = EnclosedJUnit4TestCase.NestedClass.class;
+		LauncherDiscoveryRequestBuilder request = request() //
+				.selectors(selectClass(testClass)) //
+				.filters(excludeTags(Categories.Failing.class.getName()));
+
+		TestPlan testPlan = discover(request);
+		assertThat(testPlan.getDescendants(getOnlyElement(testPlan.getRoots()))).hasSize(3);
+
+		Map<TestIdentifier, TestExecutionResult> results = execute(request);
+		assertThat(results.keySet().stream().map(TestIdentifier::getDisplayName)) //
+				.containsExactlyInAnyOrder("JUnit Vintage", testClass.getName(), nestedTestClass.getName(),
+					"successfulTest");
+	}
+
+	@Test
+	void removesWholeSubtree() {
+		Class<?> testClass = EnclosedJUnit4TestCase.class;
+		LauncherDiscoveryRequestBuilder request = request() //
+				.selectors(selectClass(testClass)) //
+				.filters(excludeTags(Categories.Plain.class.getName()));
+
+		TestPlan testPlan = discover(request);
+		assertThat(testPlan.getDescendants(getOnlyElement(testPlan.getRoots()))).isEmpty();
+
+		Map<TestIdentifier, TestExecutionResult> results = execute(request);
+		assertThat(results.keySet().stream().map(TestIdentifier::getDisplayName)) //
+				.containsExactlyInAnyOrder("JUnit Vintage");
+	}
+
+	@Test
+	void removesCompleteClassIfNoMethodHasMatchingTags() {
+		Class<?> testClass = PlainJUnit4TestCaseWithFiveTestMethods.class;
+		LauncherDiscoveryRequestBuilder request = request() //
+				.selectors(selectClass(testClass)) //
+				.filters(includeTags("wrong-tag"));
+
+		TestPlan testPlan = discover(request);
+		assertThat(testPlan.getDescendants(getOnlyElement(testPlan.getRoots()))).isEmpty();
+
+		Map<TestIdentifier, TestExecutionResult> results = execute(request);
+		assertThat(results.keySet().stream().map(TestIdentifier::getDisplayName)) //
+				.containsExactly("JUnit Vintage");
+	}
+
+	@Test
+	void removesCompleteClassIfItHasExcludedTag() {
+		Class<?> testClass = PlainJUnit4TestCaseWithFiveTestMethods.class;
+		LauncherDiscoveryRequestBuilder request = request() //
+				.selectors(selectClass(testClass)) //
+				.filters(excludeTags(Categories.Plain.class.getName()));
+
+		TestPlan testPlan = discover(request);
+		assertThat(testPlan.getDescendants(getOnlyElement(testPlan.getRoots()))).isEmpty();
+
+		Map<TestIdentifier, TestExecutionResult> results = execute(request);
+		assertThat(results.keySet().stream().map(TestIdentifier::getDisplayName)) //
+				.containsExactly("JUnit Vintage");
+	}
+
+	@TrackLogRecords
+	@Test
+	void executesAllTestsForNotFilterableRunner(LogRecordListener logRecordListener) {
+		Class<?> testClass = JUnit4TestCaseWithNotFilterableRunner.class;
+		LauncherDiscoveryRequestBuilder request = request() //
+				.selectors(selectClass(testClass)) //
+				.filters((PostDiscoveryFilter) descriptor -> includedIf(descriptor.getDisplayName().contains("#1")));
+
+		TestPlan testPlan = discover(request);
+		logRecordListener.clear();
+		assertThat(testPlan.getDescendants(getOnlyElement(testPlan.getRoots()))).hasSize(3);
+
+		Map<TestIdentifier, TestExecutionResult> results = execute(request);
+		assertThat(results.keySet().stream().map(TestIdentifier::getDisplayName)) //
+				.containsExactlyInAnyOrder("JUnit Vintage", testClass.getName(), "Test #0", "Test #1");
+		assertThat(logRecordListener.stream(RunnerTestDescriptor.class, Level.WARNING).map(LogRecord::getMessage)) //
+				.containsExactly(
+					"Runner " + NotFilterableRunner.class.getName() + " (used on class " + testClass.getName() + ")" //
+							+ " does not support filtering and will therefore be run completely.");
+	}
+
+	@TrackLogRecords
+	@Test
+	void executesAllTestsForNotFilterableChildRunnerOfSuite(LogRecordListener logRecordListener) {
+		Class<?> suiteClass = JUnit4SuiteOfSuiteWithFilterableChildRunner.class;
+		Class<?> testClass = JUnit4TestCaseWithNotFilterableRunner.class;
+		LauncherDiscoveryRequestBuilder request = request() //
+				.selectors(selectClass(suiteClass)) //
+				.filters((PostDiscoveryFilter) descriptor -> includedIf(descriptor.getDisplayName().contains("#1")));
+
+		TestPlan testPlan = discover(request);
+		logRecordListener.clear();
+		assertThat(testPlan.getDescendants(getOnlyElement(testPlan.getRoots()))).hasSize(4);
+
+		Map<TestIdentifier, TestExecutionResult> results = execute(request);
+		assertThat(results.keySet().stream().map(TestIdentifier::getDisplayName)) //
+				.containsExactlyInAnyOrder("JUnit Vintage", suiteClass.getName(), testClass.getName(), "Test #0",
+					"Test #1");
+		assertThat(logRecordListener.stream(RunnerTestDescriptor.class, Level.WARNING).map(LogRecord::getMessage)) //
+				.containsExactly("Runner " + Suite.class.getName() + " (used on class " + suiteClass.getName() + ")" //
+						+ " was not able to satisfy all filter requests.");
+	}
+
+	@Test
+	void executesOnlyTaggedMethodsForSuite() {
+		Class<?> suiteClass = JUnit4SuiteWithTwoTestCases.class;
+		Class<?> testClass = PlainJUnit4TestCaseWithTwoTestMethods.class;
+		LauncherDiscoveryRequestBuilder request = request() //
+				.selectors(selectClass(suiteClass)) //
+				.filters(includeTags(Categories.Successful.class.getName()));
+
+		TestPlan testPlan = discover(request);
+		assertThat(testPlan.getDescendants(getOnlyElement(testPlan.getRoots()))).hasSize(3);
+
+		Map<TestIdentifier, TestExecutionResult> results = execute(request);
+		assertThat(results.keySet().stream().map(TestIdentifier::getDisplayName)) //
+				.containsExactlyInAnyOrder("JUnit Vintage", suiteClass.getName(), testClass.getName(),
+					"successfulTest");
+	}
+
+	@Test
+	void removesCompleteClassWithNotFilterableRunnerIfItHasExcludedTag() {
+		Class<?> testClass = JUnit4TestCaseWithNotFilterableRunner.class;
+		LauncherDiscoveryRequestBuilder request = request() //
+				.selectors(selectClass(testClass)) //
+				.filters(excludeTags(Categories.Successful.class.getName()));
+
+		TestPlan testPlan = discover(request);
+		assertThat(testPlan.getDescendants(getOnlyElement(testPlan.getRoots()))).isEmpty();
+
+		Map<TestIdentifier, TestExecutionResult> results = execute(request);
+		assertThat(results.keySet().stream().map(TestIdentifier::getDisplayName)) //
+				.containsExactly("JUnit Vintage");
+	}
+
+	private TestPlan discover(LauncherDiscoveryRequestBuilder requestBuilder) {
+		Launcher launcher = LauncherFactory.create();
+		return launcher.discover(toRequest(requestBuilder));
+	}
+
+	private Map<TestIdentifier, TestExecutionResult> execute(LauncherDiscoveryRequestBuilder requestBuilder) {
+		Map<TestIdentifier, TestExecutionResult> results = new LinkedHashMap<>();
+		LauncherDiscoveryRequest request = toRequest(requestBuilder);
+		Launcher launcher = LauncherFactory.create();
+		launcher.execute(request, new TestExecutionListener() {
+			@Override
+			public void executionFinished(TestIdentifier testIdentifier, TestExecutionResult testExecutionResult) {
+				results.put(testIdentifier, testExecutionResult);
+			}
+		});
+		return results;
+	}
+
+	private LauncherDiscoveryRequest toRequest(LauncherDiscoveryRequestBuilder requestBuilder) {
+		return requestBuilder.filters(includeEngines(ENGINE_ID)).build();
+	}
+
+}
diff --git a/junit-vintage-engine/src/test/java/org/junit/vintage/engine/VintageTestEngineExecutionTests.java b/junit-vintage-engine/src/test/java/org/junit/vintage/engine/VintageTestEngineExecutionTests.java
index acffaa9c8..6fe8ebd13 100644
--- a/junit-vintage-engine/src/test/java/org/junit/vintage/engine/VintageTestEngineExecutionTests.java
+++ b/junit-vintage-engine/src/test/java/org/junit/vintage/engine/VintageTestEngineExecutionTests.java
@@ -143,6 +143,8 @@ class VintageTestEngineExecutionTests {
 			event(engine(), started()), //
 			event(container(testClass), started()), //
 			event(container(nestedClass), started()), //
+			event(test("successfulTest"), started()), //
+			event(test("successfulTest"), finishedSuccessfully()), //
 			event(test("failingTest"), started()), //
 			event(test("failingTest"),
 				finishedWithFailure(allOf(isA(AssertionError.class), message("this test should fail")))), //
diff --git a/junit-vintage-engine/src/test/java/org/junit/vintage/engine/samples/junit4/Categories.java b/junit-vintage-engine/src/test/java/org/junit/vintage/engine/samples/junit4/Categories.java
index c6ffc1d31..834f6e4c0 100644
--- a/junit-vintage-engine/src/test/java/org/junit/vintage/engine/samples/junit4/Categories.java
+++ b/junit-vintage-engine/src/test/java/org/junit/vintage/engine/samples/junit4/Categories.java
@@ -27,4 +27,6 @@ public class Categories {
 	public interface SkippedWithReason extends Skipped {
 	}
 
+	public interface Successful {
+	}
 }
diff --git a/junit-vintage-engine/src/test/java/org/junit/vintage/engine/samples/junit4/ConfigurableRunner.java b/junit-vintage-engine/src/test/java/org/junit/vintage/engine/samples/junit4/ConfigurableRunner.java
new file mode 100644
index 000000000..78ca47c10
--- /dev/null
+++ b/junit-vintage-engine/src/test/java/org/junit/vintage/engine/samples/junit4/ConfigurableRunner.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2015-2018 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * http://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.vintage.engine.samples.junit4;
+
+import static java.util.stream.IntStream.range;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+import java.util.Optional;
+
+import org.junit.runner.Description;
+import org.junit.runner.Runner;
+
+/**
+ * @since 5.1
+ */
+abstract class ConfigurableRunner extends Runner {
+
+	@Retention(RetentionPolicy.RUNTIME)
+	@Target(ElementType.TYPE)
+	public @interface ChildCount {
+
+		int value();
+
+	}
+
+	protected final Class<?> testClass;
+
+	ConfigurableRunner(Class<?> testClass) {
+		this.testClass = testClass;
+	}
+
+	@Override
+	public Description getDescription() {
+		Description suiteDescription = Description.createSuiteDescription(testClass);
+		ChildCount childCountAnnotation = testClass.getAnnotation(ChildCount.class);
+		int childCount = Optional.ofNullable(childCountAnnotation).map(ChildCount::value).orElse(0);
+		// @formatter:off
+		range(0, childCount)
+			.mapToObj(index -> Description.createTestDescription(testClass, "Test #" + index))
+			.forEach(suiteDescription::addChild);
+		// @formatter:on
+		return suiteDescription;
+	}
+}
diff --git a/junit-vintage-engine/src/test/java/org/junit/vintage/engine/samples/junit4/EnclosedJUnit4TestCase.java b/junit-vintage-engine/src/test/java/org/junit/vintage/engine/samples/junit4/EnclosedJUnit4TestCase.java
index aeab05eb0..aaf813906 100644
--- a/junit-vintage-engine/src/test/java/org/junit/vintage/engine/samples/junit4/EnclosedJUnit4TestCase.java
+++ b/junit-vintage-engine/src/test/java/org/junit/vintage/engine/samples/junit4/EnclosedJUnit4TestCase.java
@@ -10,9 +10,11 @@
 
 package org.junit.vintage.engine.samples.junit4;
 
+import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
 import org.junit.Test;
+import org.junit.experimental.categories.Category;
 import org.junit.experimental.runners.Enclosed;
 import org.junit.runner.RunWith;
 
@@ -22,12 +24,19 @@ import org.junit.runner.RunWith;
 @RunWith(Enclosed.class)
 public class EnclosedJUnit4TestCase {
 
+	@Category(Categories.Plain.class)
 	public static class NestedClass {
 
 		@Test
+		@Category(Categories.Failing.class)
 		public void failingTest() {
 			fail("this test should fail");
 		}
+
+		@Test
+		public void successfulTest() {
+			assertEquals(3, 1 + 2);
+		}
 	}
 
 }
diff --git a/junit-vintage-engine/src/test/java/org/junit/vintage/engine/samples/junit4/ExceptionThrowingRunner.java b/junit-vintage-engine/src/test/java/org/junit/vintage/engine/samples/junit4/ExceptionThrowingRunner.java
index 9cc750abe..bd606d6ff 100644
--- a/junit-vintage-engine/src/test/java/org/junit/vintage/engine/samples/junit4/ExceptionThrowingRunner.java
+++ b/junit-vintage-engine/src/test/java/org/junit/vintage/engine/samples/junit4/ExceptionThrowingRunner.java
@@ -10,48 +10,15 @@
 
 package org.junit.vintage.engine.samples.junit4;
 
-import static java.util.stream.IntStream.range;
-
-import java.lang.annotation.ElementType;
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-import java.lang.annotation.Target;
-import java.util.Optional;
-
-import org.junit.runner.Description;
-import org.junit.runner.Runner;
 import org.junit.runner.notification.RunNotifier;
 
 /**
  * @since 4.12
  */
-public class ExceptionThrowingRunner extends Runner {
-
-	@Retention(RetentionPolicy.RUNTIME)
-	@Target(ElementType.TYPE)
-	public @interface ChildCount {
-
-		int value();
-
-	}
-
-	private final Class<?> testClass;
+public class ExceptionThrowingRunner extends ConfigurableRunner {
 
 	public ExceptionThrowingRunner(Class<?> testClass) {
-		this.testClass = testClass;
-	}
-
-	@Override
-	public Description getDescription() {
-		Description suiteDescription = Description.createSuiteDescription(testClass);
-		ChildCount childCountAnnotation = testClass.getAnnotation(ChildCount.class);
-		int childCount = Optional.ofNullable(childCountAnnotation).map(ChildCount::value).orElse(0);
-		// @formatter:off
-		range(0, childCount)
-			.mapToObj(index -> Description.createTestDescription(testClass, "Test #" + index))
-			.forEach(suiteDescription::addChild);
-		// @formatter:on
-		return suiteDescription;
+		super(testClass);
 	}
 
 	@Override
diff --git a/junit-vintage-engine/src/test/java/org/junit/vintage/engine/samples/junit4/JUnit4SuiteOfSuiteWithFilterableChildRunner.java b/junit-vintage-engine/src/test/java/org/junit/vintage/engine/samples/junit4/JUnit4SuiteOfSuiteWithFilterableChildRunner.java
new file mode 100644
index 000000000..8871af354
--- /dev/null
+++ b/junit-vintage-engine/src/test/java/org/junit/vintage/engine/samples/junit4/JUnit4SuiteOfSuiteWithFilterableChildRunner.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright 2015-2018 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * http://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.vintage.engine.samples.junit4;
+
+import org.junit.runner.RunWith;
+import org.junit.runners.Suite;
+import org.junit.runners.Suite.SuiteClasses;
+
+/**
+ * @since 5.1
+ */
+@RunWith(Suite.class)
+@SuiteClasses(JUnit4TestCaseWithNotFilterableRunner.class)
+public class JUnit4SuiteOfSuiteWithFilterableChildRunner {
+}
diff --git a/junit-vintage-engine/src/test/java/org/junit/vintage/engine/samples/junit4/JUnit4SuiteWithExceptionThrowingRunner.java b/junit-vintage-engine/src/test/java/org/junit/vintage/engine/samples/junit4/JUnit4SuiteWithExceptionThrowingRunner.java
index e4c2c3713..1bc300b7f 100644
--- a/junit-vintage-engine/src/test/java/org/junit/vintage/engine/samples/junit4/JUnit4SuiteWithExceptionThrowingRunner.java
+++ b/junit-vintage-engine/src/test/java/org/junit/vintage/engine/samples/junit4/JUnit4SuiteWithExceptionThrowingRunner.java
@@ -11,7 +11,7 @@
 package org.junit.vintage.engine.samples.junit4;
 
 import org.junit.runner.RunWith;
-import org.junit.vintage.engine.samples.junit4.ExceptionThrowingRunner.ChildCount;
+import org.junit.vintage.engine.samples.junit4.ConfigurableRunner.ChildCount;
 
 /**
  * @since 4.12
diff --git a/junit-vintage-engine/src/test/java/org/junit/vintage/engine/samples/junit4/JUnit4TestCaseWithExceptionThrowingRunner.java b/junit-vintage-engine/src/test/java/org/junit/vintage/engine/samples/junit4/JUnit4TestCaseWithExceptionThrowingRunner.java
index a6a146d85..c2aaefec6 100644
--- a/junit-vintage-engine/src/test/java/org/junit/vintage/engine/samples/junit4/JUnit4TestCaseWithExceptionThrowingRunner.java
+++ b/junit-vintage-engine/src/test/java/org/junit/vintage/engine/samples/junit4/JUnit4TestCaseWithExceptionThrowingRunner.java
@@ -11,7 +11,7 @@
 package org.junit.vintage.engine.samples.junit4;
 
 import org.junit.runner.RunWith;
-import org.junit.vintage.engine.samples.junit4.ExceptionThrowingRunner.ChildCount;
+import org.junit.vintage.engine.samples.junit4.ConfigurableRunner.ChildCount;
 
 /**
  * @since 4.12
diff --git a/junit-vintage-engine/src/test/java/org/junit/vintage/engine/samples/junit4/JUnit4TestCaseWithNotFilterableRunner.java b/junit-vintage-engine/src/test/java/org/junit/vintage/engine/samples/junit4/JUnit4TestCaseWithNotFilterableRunner.java
new file mode 100644
index 000000000..ae25c51f2
--- /dev/null
+++ b/junit-vintage-engine/src/test/java/org/junit/vintage/engine/samples/junit4/JUnit4TestCaseWithNotFilterableRunner.java
@@ -0,0 +1,24 @@
+/*
+ * Copyright 2015-2018 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * http://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.vintage.engine.samples.junit4;
+
+import org.junit.experimental.categories.Category;
+import org.junit.runner.RunWith;
+import org.junit.vintage.engine.samples.junit4.ConfigurableRunner.ChildCount;
+
+/**
+ * @since 5.1
+ */
+@RunWith(NotFilterableRunner.class)
+@ChildCount(2)
+@Category(Categories.Successful.class)
+public class JUnit4TestCaseWithNotFilterableRunner {
+}
diff --git a/junit-vintage-engine/src/test/java/org/junit/vintage/engine/samples/junit4/NotFilterableRunner.java b/junit-vintage-engine/src/test/java/org/junit/vintage/engine/samples/junit4/NotFilterableRunner.java
new file mode 100644
index 000000000..58553ba5b
--- /dev/null
+++ b/junit-vintage-engine/src/test/java/org/junit/vintage/engine/samples/junit4/NotFilterableRunner.java
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2015-2018 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * http://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.vintage.engine.samples.junit4;
+
+import org.junit.runner.notification.RunNotifier;
+
+/**
+ * @since 5.1
+ */
+public class NotFilterableRunner extends ConfigurableRunner {
+
+	public NotFilterableRunner(Class<?> testClass) {
+		super(testClass);
+	}
+
+	@Override
+	public void run(RunNotifier notifier) {
+		getDescription().getChildren().forEach(child -> {
+			notifier.fireTestStarted(child);
+			notifier.fireTestFinished(child);
+		});
+	}
+
+}
diff --git a/junit-vintage-engine/src/test/java/org/junit/vintage/engine/samples/junit4/PlainJUnit4TestCaseWithTwoTestMethods.java b/junit-vintage-engine/src/test/java/org/junit/vintage/engine/samples/junit4/PlainJUnit4TestCaseWithTwoTestMethods.java
index c31ba5072..aa2569d0c 100644
--- a/junit-vintage-engine/src/test/java/org/junit/vintage/engine/samples/junit4/PlainJUnit4TestCaseWithTwoTestMethods.java
+++ b/junit-vintage-engine/src/test/java/org/junit/vintage/engine/samples/junit4/PlainJUnit4TestCaseWithTwoTestMethods.java
@@ -16,6 +16,7 @@ import static org.junit.runners.MethodSorters.NAME_ASCENDING;
 
 import org.junit.FixMethodOrder;
 import org.junit.Test;
+import org.junit.experimental.categories.Category;
 
 /**
  * @since 4.12
@@ -29,6 +30,7 @@ public class PlainJUnit4TestCaseWithTwoTestMethods {
 	}
 
 	@Test
+	@Category(Categories.Successful.class)
 	public void successfulTest() {
 		assertEquals(3, 1 + 2);
 	}
