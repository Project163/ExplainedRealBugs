diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.13.2.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.13.2.adoc
index f319a96db..d2cd0900d 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.13.2.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.13.2.adoc
@@ -35,7 +35,8 @@ repository on GitHub.
 [[release-notes-5.13.2-junit-jupiter-bug-fixes]]
 ==== Bug Fixes
 
-* ‚ùì
+* Stop reporting discovery issues for cyclic inner class hierarchies not annotated with
+  `@Nested`.
 
 [[release-notes-5.13.2-junit-jupiter-deprecations-and-breaking-changes]]
 ==== Deprecations and Breaking Changes
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/ClassSelectorResolver.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/ClassSelectorResolver.java
index 4470da5a5..7495b1414 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/ClassSelectorResolver.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/ClassSelectorResolver.java
@@ -17,9 +17,9 @@ import static java.util.stream.Collectors.toSet;
 import static org.junit.jupiter.engine.descriptor.NestedClassTestDescriptor.getEnclosingTestClasses;
 import static org.junit.platform.commons.support.HierarchyTraversalMode.TOP_DOWN;
 import static org.junit.platform.commons.support.ReflectionSupport.findMethods;
-import static org.junit.platform.commons.support.ReflectionSupport.streamNestedClasses;
 import static org.junit.platform.commons.util.FunctionUtils.where;
 import static org.junit.platform.commons.util.ReflectionUtils.isInnerClass;
+import static org.junit.platform.commons.util.ReflectionUtils.streamNestedClasses;
 import static org.junit.platform.engine.discovery.DiscoverySelectors.selectUniqueId;
 import static org.junit.platform.engine.support.discovery.SelectorResolver.Resolution.unresolved;
 
@@ -46,6 +46,7 @@ import org.junit.jupiter.engine.descriptor.TestClassAware;
 import org.junit.jupiter.engine.discovery.predicates.TestClassPredicates;
 import org.junit.platform.commons.support.ReflectionSupport;
 import org.junit.platform.commons.util.ReflectionUtils;
+import org.junit.platform.commons.util.ReflectionUtils.CycleErrorHandling;
 import org.junit.platform.engine.DiscoveryIssue;
 import org.junit.platform.engine.DiscoveryIssue.Severity;
 import org.junit.platform.engine.DiscoverySelector;
@@ -289,9 +290,13 @@ class ClassSelectorResolver implements SelectorResolver {
 			Stream<DiscoverySelector> methods = findMethods(testClass,
 				this.predicates.isTestOrTestFactoryOrTestTemplateMethod, TOP_DOWN).stream() //
 						.map(method -> selectMethod(testClasses, method));
-			Stream<NestedClassSelector> nestedClasses = streamNestedClasses(testClass,
-				this.predicates.isAnnotatedWithNested.or(ReflectionUtils::isInnerClass)) //
-						.map(nestedClass -> DiscoverySelectors.selectNestedClass(testClasses, nestedClass));
+			Stream<Class<?>> annotatedNestedClasses = streamNestedClasses(testClass,
+				this.predicates.isAnnotatedWithNested);
+			Stream<Class<?>> notAnnotatedInnerClasses = streamNestedClasses(testClass,
+				this.predicates.isAnnotatedWithNested.negate().and(ReflectionUtils::isInnerClass),
+				CycleErrorHandling.ABORT_VISIT);
+			var nestedClasses = Stream.concat(annotatedNestedClasses, notAnnotatedInnerClasses) //
+					.map(nestedClass -> DiscoverySelectors.selectNestedClass(testClasses, nestedClass));
 			return Stream.concat(methods, nestedClasses).collect(
 				toCollection((Supplier<Set<DiscoverySelector>>) LinkedHashSet::new));
 		};
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/TestClassPredicates.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/TestClassPredicates.java
index 521930f0e..c9ee44d5b 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/TestClassPredicates.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/discovery/predicates/TestClassPredicates.java
@@ -28,6 +28,7 @@ import org.apiguardian.api.API;
 import org.junit.jupiter.api.ClassTemplate;
 import org.junit.jupiter.api.Nested;
 import org.junit.platform.commons.util.ReflectionUtils;
+import org.junit.platform.commons.util.ReflectionUtils.CycleErrorHandling;
 import org.junit.platform.engine.DiscoveryIssue;
 import org.junit.platform.engine.support.descriptor.ClassSource;
 import org.junit.platform.engine.support.discovery.DiscoveryIssueReporter;
@@ -94,14 +95,16 @@ public class TestClassPredicates {
 	}
 
 	private boolean hasNestedTests(Class<?> candidate, Set<Class<?>> seen) {
+		var hasAnnotatedClass = isNestedClassPresent(candidate, this.isAnnotatedWithNested,
+			CycleErrorHandling.THROW_EXCEPTION);
+		if (hasAnnotatedClass) {
+			return true;
+		}
 		return isNestedClassPresent( //
 			candidate, //
-			isNotSame(candidate).and(
-				this.isAnnotatedWithNested.or(it -> isInnerClass(it) && looksLikeIntendedTestClass(it, seen))));
-	}
-
-	private static Predicate<Class<?>> isNotSame(Class<?> candidate) {
-		return clazz -> candidate != clazz;
+			it -> isInnerClass(it) && looksLikeIntendedTestClass(it, seen), //
+			CycleErrorHandling.ABORT_VISIT //
+		);
 	}
 
 	private static Condition<Class<?>> isNotPrivateUnlessAbstract(String prefix, DiscoveryIssueReporter issueReporter) {
diff --git a/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java b/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java
index 3836d2369..d9bd8e4b4 100644
--- a/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java
+++ b/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java
@@ -130,7 +130,7 @@ public final class ReflectionUtils {
 	 * <p>This serves as a cache to avoid repeated cycle detection for classes
 	 * that have already been checked.
 	 * @since 1.6
-	 * @see #detectInnerClassCycle(Class)
+	 * @see #detectInnerClassCycle(Class, CycleErrorHandling)
 	 */
 	private static final Set<String> noCyclesDetectedCache = ConcurrentHashMap.newKeySet();
 
@@ -1117,11 +1117,17 @@ public final class ReflectionUtils {
 	 * @see org.junit.platform.commons.support.ReflectionSupport#findNestedClasses(Class, Predicate)
 	 */
 	public static List<Class<?>> findNestedClasses(Class<?> clazz, Predicate<Class<?>> predicate) {
+		return findNestedClasses(clazz, predicate, CycleErrorHandling.THROW_EXCEPTION);
+	}
+
+	@API(status = INTERNAL, since = "5.13.2")
+	public static List<Class<?>> findNestedClasses(Class<?> clazz, Predicate<Class<?>> predicate,
+			CycleErrorHandling errorHandling) {
 		Preconditions.notNull(clazz, "Class must not be null");
 		Preconditions.notNull(predicate, "Predicate must not be null");
 
 		Set<Class<?>> candidates = new LinkedHashSet<>();
-		visitAllNestedClasses(clazz, predicate, candidates::add);
+		visitAllNestedClasses(clazz, predicate, candidates::add, errorHandling);
 		return List.copyOf(candidates);
 	}
 
@@ -1144,13 +1150,15 @@ public final class ReflectionUtils {
 	 * @return {@code true} if such a nested class is present
 	 * @throws JUnitException if a cycle is detected within an inner class hierarchy
 	 */
-	@API(status = INTERNAL, since = "1.13")
-	public static boolean isNestedClassPresent(Class<?> clazz, Predicate<Class<?>> predicate) {
+	@API(status = INTERNAL, since = "1.13.2")
+	public static boolean isNestedClassPresent(Class<?> clazz, Predicate<Class<?>> predicate,
+			CycleErrorHandling errorHandling) {
 		Preconditions.notNull(clazz, "Class must not be null");
 		Preconditions.notNull(predicate, "Predicate must not be null");
+		Preconditions.notNull(errorHandling, "CycleErrorHandling must not be null");
 
 		AtomicBoolean foundNestedClass = new AtomicBoolean(false);
-		visitAllNestedClasses(clazz, predicate, __ -> foundNestedClass.setPlain(true));
+		visitAllNestedClasses(clazz, predicate, __ -> foundNestedClass.setPlain(true), errorHandling);
 		return foundNestedClass.getPlain();
 	}
 
@@ -1162,27 +1170,37 @@ public final class ReflectionUtils {
 		return findNestedClasses(clazz, predicate).stream();
 	}
 
+	@API(status = INTERNAL, since = "5.13.2")
+	public static Stream<Class<?>> streamNestedClasses(Class<?> clazz, Predicate<Class<?>> predicate,
+			CycleErrorHandling errorHandling) {
+		return findNestedClasses(clazz, predicate, errorHandling).stream();
+	}
+
 	/**
 	 * Visit <em>all</em> nested classes without support for short-circuiting
 	 * in order to ensure all of them are checked for class cycles.
 	 */
 	private static void visitAllNestedClasses(Class<?> clazz, Predicate<Class<?>> predicate,
-			Consumer<Class<?>> consumer) {
+			Consumer<Class<?>> consumer, CycleErrorHandling errorHandling) {
 
 		if (!isSearchable(clazz)) {
 			return;
 		}
 
 		if (isInnerClass(clazz) && predicate.test(clazz)) {
-			detectInnerClassCycle(clazz);
+			if (detectInnerClassCycle(clazz, errorHandling)) {
+				return;
+			}
 		}
 
 		try {
 			// Candidates in current class
 			for (Class<?> nestedClass : clazz.getDeclaredClasses()) {
 				if (predicate.test(nestedClass)) {
-					detectInnerClassCycle(nestedClass);
 					consumer.accept(nestedClass);
+					if (detectInnerClassCycle(nestedClass, errorHandling)) {
+						return;
+					}
 				}
 			}
 		}
@@ -1191,11 +1209,11 @@ public final class ReflectionUtils {
 		}
 
 		// Search class hierarchy
-		visitAllNestedClasses(clazz.getSuperclass(), predicate, consumer);
+		visitAllNestedClasses(clazz.getSuperclass(), predicate, consumer, errorHandling);
 
 		// Search interface hierarchy
 		for (Class<?> ifc : clazz.getInterfaces()) {
-			visitAllNestedClasses(ifc, predicate, consumer);
+			visitAllNestedClasses(ifc, predicate, consumer, errorHandling);
 		}
 	}
 
@@ -1203,10 +1221,8 @@ public final class ReflectionUtils {
 	 * Detect a cycle in the inner class hierarchy in which the supplied class
 	 * resides &mdash; from the supplied class up to the outermost enclosing class
 	 * &mdash; and throw a {@link JUnitException} if a cycle is detected.
-	 *
 	 * <p>This method does <strong>not</strong> detect cycles within inner class
 	 * hierarchies <em>below</em> the supplied class.
-	 *
 	 * <p>If the supplied class is not an inner class and does not have a
 	 * searchable superclass, this method is effectively a no-op.
 	 *
@@ -1214,25 +1230,26 @@ public final class ReflectionUtils {
 	 * @see #isInnerClass(Class)
 	 * @see #isSearchable(Class)
 	 */
-	private static void detectInnerClassCycle(Class<?> clazz) {
+	private static boolean detectInnerClassCycle(Class<?> clazz, CycleErrorHandling errorHandling) {
 		Preconditions.notNull(clazz, "Class must not be null");
 		String className = clazz.getName();
 
 		if (noCyclesDetectedCache.contains(className)) {
-			return;
+			return false;
 		}
 
 		Class<?> superclass = clazz.getSuperclass();
 		if (isInnerClass(clazz) && isSearchable(superclass)) {
 			for (Class<?> enclosing = clazz.getEnclosingClass(); enclosing != null; enclosing = enclosing.getEnclosingClass()) {
 				if (superclass.equals(enclosing)) {
-					throw new JUnitException(String.format("Detected cycle in inner class hierarchy between %s and %s",
-						className, enclosing.getName()));
+					errorHandling.handle(clazz, enclosing);
+					return true;
 				}
 			}
 		}
 
 		noCyclesDetectedCache.add(className);
+		return false;
 	}
 
 	/**
@@ -1936,4 +1953,25 @@ public final class ReflectionUtils {
 		return t;
 	}
 
+	@API(status = INTERNAL, since = "5.13.2")
+	public enum CycleErrorHandling {
+
+		THROW_EXCEPTION {
+			@Override
+			void handle(Class<?> clazz, Class<?> enclosing) {
+				throw new JUnitException(String.format("Detected cycle in inner class hierarchy between %s and %s",
+					clazz.getName(), enclosing.getName()));
+			}
+		},
+
+		ABORT_VISIT {
+			@Override
+			void handle(Class<?> clazz, Class<?> enclosing) {
+				// ignore
+			}
+		};
+
+		abstract void handle(Class<?> clazz, Class<?> enclosing);
+	}
+
 }
diff --git a/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/DiscoveryTests.java b/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/DiscoveryTests.java
index 53890464e..395d47c27 100644
--- a/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/DiscoveryTests.java
+++ b/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/DiscoveryTests.java
@@ -48,6 +48,7 @@ import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.Arguments;
 import org.junit.jupiter.params.provider.MethodSource;
 import org.junit.platform.engine.DiscoveryIssue;
+import org.junit.platform.engine.DiscoveryIssue.Severity;
 import org.junit.platform.engine.TestDescriptor;
 import org.junit.platform.engine.support.descriptor.ClassSource;
 import org.junit.platform.launcher.LauncherDiscoveryRequest;
@@ -296,7 +297,28 @@ class DiscoveryTests extends AbstractJupiterTestEngineTests {
 	}
 
 	@Test
-	void reportsWarningsForInvalidTags() throws NoSuchMethodException {
+	void ignoresRecursiveNonTestHierarchyCycles() {
+		var results = discoverTestsForClass(NonTestRecursiveHierarchyTestCase.class);
+
+		assertThat(results.getDiscoveryIssues()).isEmpty();
+	}
+
+	@Test
+	void reportsMissingNestedAnnotationOnRecursiveHierarchy() {
+		var results = discoverTestsForClass(RecursiveHierarchyWithoutNestedTestCase.class);
+
+		var discoveryIssues = results.getDiscoveryIssues();
+		assertThat(discoveryIssues).hasSize(1);
+		assertThat(discoveryIssues.getFirst().severity()) //
+				.isEqualTo(Severity.WARNING);
+		assertThat(discoveryIssues.getFirst().message()) //
+				.isEqualTo(
+					"Inner class '%s' looks like it was intended to be a test class but will not be executed. It must be static or annotated with @Nested.",
+					RecursiveHierarchyWithoutNestedTestCase.Inner.class.getName());
+	}
+
+	@Test
+	void reportsWarningsForInvalidTags() throws Exception {
 
 		var results = discoverTestsForClass(InvalidTagsTestCase.class);
 
@@ -318,7 +340,7 @@ class DiscoveryTests extends AbstractJupiterTestEngineTests {
 	}
 
 	@Test
-	void reportsWarningsForBlankDisplayNames() throws NoSuchMethodException {
+	void reportsWarningsForBlankDisplayNames() throws Exception {
 
 		var results = discoverTestsForClass(BlankDisplayNamesTestCase.class);
 
@@ -462,6 +484,25 @@ class DiscoveryTests extends AbstractJupiterTestEngineTests {
 		}
 	}
 
+	@SuppressWarnings("JUnitMalformedDeclaration")
+	static class RecursiveHierarchyWithoutNestedTestCase {
+
+		@Test
+		void test() {
+		}
+
+		@SuppressWarnings({ "InnerClassMayBeStatic", "unused" })
+		class Inner extends RecursiveHierarchyWithoutNestedTestCase {
+		}
+	}
+
+	@SuppressWarnings("unused")
+	static class NonTestRecursiveHierarchyTestCase {
+		@SuppressWarnings("InnerClassMayBeStatic")
+		class Inner extends NonTestRecursiveHierarchyTestCase {
+		}
+	}
+
 	@SuppressWarnings("JUnitMalformedDeclaration")
 	@Tag("")
 	static class InvalidTagsTestCase {
diff --git a/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/TestClassPredicatesTests.java b/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/TestClassPredicatesTests.java
index 378ed8450..bacd663d3 100644
--- a/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/TestClassPredicatesTests.java
+++ b/jupiter-tests/src/test/java/org/junit/jupiter/engine/discovery/predicates/TestClassPredicatesTests.java
@@ -11,7 +11,6 @@
 package org.junit.jupiter.engine.discovery.predicates;
 
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
 import static org.junit.jupiter.api.Assertions.assertFalse;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
@@ -24,7 +23,6 @@ import org.junit.jupiter.api.Nested;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.TestFactory;
 import org.junit.jupiter.api.TestTemplate;
-import org.junit.platform.commons.JUnitException;
 import org.junit.platform.engine.DiscoveryIssue;
 import org.junit.platform.engine.DiscoveryIssue.Severity;
 import org.junit.platform.engine.support.descriptor.ClassSource;
@@ -218,11 +216,7 @@ public class TestClassPredicatesTests {
 		 */
 		@Test
 		void recursiveHierarchies() {
-			assertThatExceptionOfType(JUnitException.class)//
-					.isThrownBy(() -> predicates.looksLikeIntendedTestClass(TestCases.OuterClass.class))//
-					.withMessage("Detected cycle in inner class hierarchy between %s and %s",
-						TestCases.OuterClass.RecursiveInnerClass.class.getName(), TestCases.OuterClass.class.getName());
-
+			assertTrue(predicates.looksLikeIntendedTestClass(TestCases.OuterClass.class));
 			assertTrue(predicates.isValidStandaloneTestClass(TestCases.OuterClass.class));
 			assertThat(discoveryIssues).isEmpty();
 
diff --git a/platform-tests/src/test/java/org/junit/platform/commons/util/ReflectionUtilsTests.java b/platform-tests/src/test/java/org/junit/platform/commons/util/ReflectionUtilsTests.java
index d2dd75977..22022c758 100644
--- a/platform-tests/src/test/java/org/junit/platform/commons/util/ReflectionUtilsTests.java
+++ b/platform-tests/src/test/java/org/junit/platform/commons/util/ReflectionUtilsTests.java
@@ -71,6 +71,7 @@ import org.junit.platform.commons.PreconditionViolationException;
 import org.junit.platform.commons.logging.LogRecordListener;
 import org.junit.platform.commons.support.Resource;
 import org.junit.platform.commons.test.TestClassLoader;
+import org.junit.platform.commons.util.ReflectionUtils.CycleErrorHandling;
 import org.junit.platform.commons.util.ReflectionUtilsTests.NestedClassTests.ClassWithNestedClasses.Nested1;
 import org.junit.platform.commons.util.ReflectionUtilsTests.NestedClassTests.ClassWithNestedClasses.Nested2;
 import org.junit.platform.commons.util.ReflectionUtilsTests.NestedClassTests.ClassWithNestedClasses.Nested3;
@@ -1054,9 +1055,10 @@ class ReflectionUtilsTests {
 		@Test
 		void isNestedClassPresentPreconditions() {
 			// @formatter:off
-			assertThrows(PreconditionViolationException.class, () -> ReflectionUtils.isNestedClassPresent(null, null));
-			assertThrows(PreconditionViolationException.class, () -> ReflectionUtils.isNestedClassPresent(null, clazz -> true));
-			assertThrows(PreconditionViolationException.class, () -> ReflectionUtils.isNestedClassPresent(getClass(), null));
+			assertThrows(PreconditionViolationException.class, () -> ReflectionUtils.isNestedClassPresent(null, null, null));
+			assertThrows(PreconditionViolationException.class, () -> ReflectionUtils.isNestedClassPresent(null, clazz -> true, CycleErrorHandling.THROW_EXCEPTION));
+			assertThrows(PreconditionViolationException.class, () -> ReflectionUtils.isNestedClassPresent(getClass(), null, CycleErrorHandling.ABORT_VISIT));
+			assertThrows(PreconditionViolationException.class, () -> ReflectionUtils.isNestedClassPresent(getClass(), clazz -> true, null));
 			// @formatter:on
 		}
 
@@ -1073,12 +1075,12 @@ class ReflectionUtilsTests {
 
 			assertThat(ReflectionUtils.findNestedClasses(ClassWithNestedClasses.class, clazz -> clazz.getName().contains("1")))
 					.containsExactly(Nested1.class);
-			assertThat(ReflectionUtils.isNestedClassPresent(ClassWithNestedClasses.class, clazz -> clazz.getName().contains("1")))
+			assertThat(ReflectionUtils.isNestedClassPresent(ClassWithNestedClasses.class, clazz -> clazz.getName().contains("1"), CycleErrorHandling.THROW_EXCEPTION))
 					.isTrue();
 
 			assertThat(ReflectionUtils.findNestedClasses(ClassWithNestedClasses.class, ReflectionUtils::isStatic))
 					.containsExactly(Nested3.class);
-			assertThat(ReflectionUtils.isNestedClassPresent(ClassWithNestedClasses.class, ReflectionUtils::isStatic))
+			assertThat(ReflectionUtils.isNestedClassPresent(ClassWithNestedClasses.class, ReflectionUtils::isStatic, CycleErrorHandling.THROW_EXCEPTION))
 					.isTrue();
 
 			assertThat(findNestedClasses(ClassExtendingClassWithNestedClasses.class))
@@ -1105,12 +1107,14 @@ class ReflectionUtilsTests {
 			// predicate should prevent cycle detection.
 			// See https://github.com/junit-team/junit-framework/issues/2249
 			assertThat(ReflectionUtils.findNestedClasses(OuterClass.class, clazz -> false)).isEmpty();
-			assertThat(ReflectionUtils.isNestedClassPresent(OuterClass.class, clazz -> false)).isFalse();
+			assertThat(ReflectionUtils.isNestedClassPresent(OuterClass.class, clazz -> false,
+				CycleErrorHandling.THROW_EXCEPTION)).isFalse();
 
 			// RecursiveInnerInnerClass is part of a recursive hierarchy, but the non-matching
 			// predicate should prevent cycle detection.
 			assertThat(ReflectionUtils.findNestedClasses(RecursiveInnerInnerClass.class, clazz -> false)).isEmpty();
-			assertThat(ReflectionUtils.isNestedClassPresent(RecursiveInnerInnerClass.class, clazz -> false)).isFalse();
+			assertThat(ReflectionUtils.isNestedClassPresent(RecursiveInnerInnerClass.class, clazz -> false,
+				CycleErrorHandling.THROW_EXCEPTION)).isFalse();
 
 			// Sibling types don't actually result in cycles.
 			assertThat(findNestedClasses(StaticNestedSiblingClass.class))//
@@ -1153,7 +1157,7 @@ class ReflectionUtilsTests {
 		}
 
 		private static boolean isNestedClassPresent(Class<?> clazz) {
-			return ReflectionUtils.isNestedClassPresent(clazz, c -> true);
+			return ReflectionUtils.isNestedClassPresent(clazz, c -> true, CycleErrorHandling.THROW_EXCEPTION);
 		}
 
 		private void assertNestedCycle(Class<?> from, Class<?> to) {
