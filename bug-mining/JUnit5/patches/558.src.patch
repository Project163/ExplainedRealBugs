diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-5.10.0-RC1.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-5.10.0-RC1.adoc
index 53db2d882..0fc96c603 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-5.10.0-RC1.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-5.10.0-RC1.adoc
@@ -28,8 +28,11 @@ JUnit repository on GitHub.
 ==== New Features and Improvements
 
 * New `@SelectMethod` selector support in the `@Suite` test engine.
-* Classes may now be selected by fully-qualified name via new the `names` attribute in
+* Classes may now be selected by fully-qualified name via the `names` attribute in
   `@SelectClasses`.
+* New `selectMethod()` and `selectNestedMethod()` variants in `DiscoverySelectors` that
+  accept a `Class<?>...` argument of parameter types as a type-safe alternative to
+  providing the names of parameter types as a comma-delimited string.
 
 
 [[release-notes-5.10.0-RC1-junit-jupiter]]
diff --git a/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java b/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java
index 74be92f77..816b7fadd 100644
--- a/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java
+++ b/junit-platform-commons/src/main/java/org/junit/platform/commons/util/ReflectionUtils.java
@@ -1361,7 +1361,8 @@ public final class ReflectionUtils {
 		return findMethod(clazz, methodName, resolveParameterTypes(clazz, methodName, parameterTypeNames));
 	}
 
-	private static Class<?>[] resolveParameterTypes(Class<?> clazz, String methodName, String parameterTypeNames) {
+	@API(status = INTERNAL, since = "1.10")
+	public static Class<?>[] resolveParameterTypes(Class<?> clazz, String methodName, String parameterTypeNames) {
 		if (StringUtils.isBlank(parameterTypeNames)) {
 			return EMPTY_CLASS_ARRAY;
 		}
diff --git a/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectors.java b/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectors.java
index 42553214d..3439d20d4 100644
--- a/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectors.java
+++ b/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/DiscoverySelectors.java
@@ -504,9 +504,7 @@ public final class DiscoverySelectors {
 	 */
 	@API(status = EXPERIMENTAL, since = "1.10")
 	public static MethodSelector selectMethod(ClassLoader classLoader, String className, String methodName) {
-		Preconditions.notBlank(className, "Class name must not be null or blank");
-		Preconditions.notBlank(methodName, "Method name must not be null or blank");
-		return new MethodSelector(classLoader, className, methodName, "");
+		return selectMethod(classLoader, className, methodName, "");
 	}
 
 	/**
@@ -592,6 +590,48 @@ public final class DiscoverySelectors {
 		return new MethodSelector(javaClass, methodName, parameterTypeNames.trim());
 	}
 
+	/**
+	 * Create a {@code MethodSelector} for the supplied class name, method name,
+	 * and parameter types.
+	 *
+	 * @param className the fully qualified name of the class in which the method
+	 * is declared, or a subclass thereof; never {@code null} or blank
+	 * @param methodName the name of the method to select; never {@code null} or blank
+	 * @param parameterTypes the formal parameter types of the method; never
+	 * {@code null} though potentially empty if the method does not declare parameters
+	 * @since 1.10
+	 * @see MethodSelector
+	 */
+	@API(status = EXPERIMENTAL, since = "1.10")
+	public static MethodSelector selectMethod(String className, String methodName, Class<?>... parameterTypes) {
+		Preconditions.notBlank(className, "Class name must not be null or blank");
+		Preconditions.notBlank(methodName, "Method name must not be null or blank");
+		Preconditions.notNull(parameterTypes, "Parameter types array must not be null");
+		Preconditions.containsNoNullElements(parameterTypes, "Parameter types array must not contain null elements");
+		return new MethodSelector((ClassLoader) null, className, methodName, parameterTypes);
+	}
+
+	/**
+	 * Create a {@code MethodSelector} for the supplied {@link Class}, method name,
+	 * and parameter types.
+	 *
+	 * @param javaClass the class in which the method is declared, or a subclass thereof;
+	 * never {@code null}
+	 * @param methodName the name of the method to select; never {@code null} or blank
+	 * @param parameterTypes the formal parameter types of the method; never
+	 * {@code null} though potentially empty if the method does not declare parameters
+	 * @since 1.10
+	 * @see MethodSelector
+	 */
+	@API(status = EXPERIMENTAL, since = "1.10")
+	public static MethodSelector selectMethod(Class<?> javaClass, String methodName, Class<?>... parameterTypes) {
+		Preconditions.notNull(javaClass, "Class must not be null");
+		Preconditions.notBlank(methodName, "Method name must not be null or blank");
+		Preconditions.notNull(parameterTypes, "Parameter types array must not be null");
+		Preconditions.containsNoNullElements(parameterTypes, "Parameter types array must not contain null elements");
+		return new MethodSelector(javaClass, methodName, parameterTypes);
+	}
+
 	/**
 	 * Create a {@code MethodSelector} for the supplied {@link Class} and {@link Method}.
 	 *
@@ -744,6 +784,33 @@ public final class DiscoverySelectors {
 			parameterTypeNames.trim());
 	}
 
+	/**
+	 * Create a {@code NestedMethodSelector} for the supplied enclosing class names,
+	 * nested class name, method name, and parameter types.
+	 *
+	 * @param enclosingClassNames the names of the enclosing classes; never {@code null}
+	 * or empty
+	 * @param nestedClassName the name of the nested class to select; never {@code null}
+	 * or blank
+	 * @param methodName the name of the method to select; never {@code null} or blank
+	 * @param parameterTypes the formal parameter types of the method; never {@code null}
+	 * though potentially empty if the method does not declare parameters
+	 * @since 1.10
+	 * @see NestedMethodSelector
+	 */
+	@API(status = EXPERIMENTAL, since = "1.10")
+	public static NestedMethodSelector selectNestedMethod(List<String> enclosingClassNames, String nestedClassName,
+			String methodName, Class<?>... parameterTypes) {
+
+		Preconditions.notEmpty(enclosingClassNames, "Enclosing class names must not be null or empty");
+		Preconditions.notBlank(nestedClassName, "Nested class name must not be null or blank");
+		Preconditions.notBlank(methodName, "Method name must not be null or blank");
+		Preconditions.notNull(parameterTypes, "Parameter types array must not be null");
+		Preconditions.containsNoNullElements(parameterTypes, "Parameter types array must not contain null elements");
+		return new NestedMethodSelector((ClassLoader) null, enclosingClassNames, nestedClassName, methodName,
+			parameterTypes);
+	}
+
 	/**
 	 * Create a {@code NestedMethodSelector} for the supplied nested {@link Class} and method name.
 	 *
@@ -788,6 +855,31 @@ public final class DiscoverySelectors {
 		return new NestedMethodSelector(enclosingClasses, nestedClass, methodName, parameterTypeNames.trim());
 	}
 
+	/**
+	 * Create a {@code NestedMethodSelector} for the supplied enclosing classes,
+	 * nested class, method name, and parameter types.
+	 *
+	 * @param enclosingClasses the path to the nested class to select; never {@code null}
+	 * or empty
+	 * @param nestedClass the nested class to select; never {@code null}
+	 * @param methodName the name of the method to select; never {@code null} or blank
+	 * @param parameterTypes the formal parameter types of the method; never {@code null}
+	 * though potentially empty if the method does not declare parameters
+	 * @since 1.10
+	 * @see NestedMethodSelector
+	 */
+	@API(status = EXPERIMENTAL, since = "1.10")
+	public static NestedMethodSelector selectNestedMethod(List<Class<?>> enclosingClasses, Class<?> nestedClass,
+			String methodName, Class<?>... parameterTypes) {
+
+		Preconditions.notEmpty(enclosingClasses, "Enclosing classes must not be null or empty");
+		Preconditions.notNull(nestedClass, "Nested class must not be null");
+		Preconditions.notBlank(methodName, "Method name must not be null or blank");
+		Preconditions.notNull(parameterTypes, "Parameter types array must not be null");
+		Preconditions.containsNoNullElements(parameterTypes, "Parameter types array must not contain null elements");
+		return new NestedMethodSelector(enclosingClasses, nestedClass, methodName, parameterTypes);
+	}
+
 	/**
 	 * Create a {@code NestedMethodSelector} for the supplied nested {@link Class} and {@link Method}.
 	 *
diff --git a/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/MethodSelector.java b/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/MethodSelector.java
index c1d9ad28d..c1055f68b 100644
--- a/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/MethodSelector.java
+++ b/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/MethodSelector.java
@@ -18,11 +18,11 @@ import java.lang.reflect.Method;
 import java.util.Objects;
 
 import org.apiguardian.api.API;
+import org.junit.platform.commons.JUnitException;
 import org.junit.platform.commons.PreconditionViolationException;
 import org.junit.platform.commons.function.Try;
 import org.junit.platform.commons.util.ClassUtils;
 import org.junit.platform.commons.util.ReflectionUtils;
-import org.junit.platform.commons.util.StringUtils;
 import org.junit.platform.commons.util.ToStringBuilder;
 import org.junit.platform.engine.DiscoverySelector;
 
@@ -36,9 +36,9 @@ import org.junit.platform.engine.DiscoverySelector;
  * {@linkplain #getJavaMethod() method} and its method name, class name, and
  * parameter types accordingly. If a {@link Class} and method name, a class name
  * and method name, or a <em>fully qualified method name</em> is provided,
- * this selector will only attempt to lazily load the {@link Class} or
- * {@link Method} if {@link #getJavaClass()} or {@link #getJavaMethod()} is
- * invoked.
+ * this selector will only attempt to lazily load the class, method, or parameter
+ * types if {@link #getJavaClass()}, {@link #getJavaMethod()}, or
+ * {@link #getParameterTypes()} is invoked.
  *
  * <p>In this context, a Java {@code Method} means anything that can be referenced
  * as a {@link Method} on the JVM &mdash; for example, methods from Java classes
@@ -63,6 +63,7 @@ public class MethodSelector implements DiscoverySelector {
 
 	private volatile Class<?> javaClass;
 	private volatile Method javaMethod;
+	private volatile Class<?>[] parameterTypes;
 
 	/**
 	 * @since 1.10
@@ -82,13 +83,37 @@ public class MethodSelector implements DiscoverySelector {
 		this.parameterTypeNames = parameterTypeNames;
 	}
 
+	/**
+	 * @since 1.10
+	 */
+	MethodSelector(ClassLoader classLoader, String className, String methodName, Class<?>... parameterTypes) {
+		this.classLoader = classLoader;
+		this.className = className;
+		this.methodName = methodName;
+		this.parameterTypes = parameterTypes.clone();
+		this.parameterTypeNames = ClassUtils.nullSafeToString(Class::getTypeName, this.parameterTypes);
+	}
+
+	/**
+	 * @since 1.10
+	 */
+	MethodSelector(Class<?> javaClass, String methodName, Class<?>... parameterTypes) {
+		this.classLoader = javaClass.getClassLoader();
+		this.javaClass = javaClass;
+		this.className = javaClass.getName();
+		this.methodName = methodName;
+		this.parameterTypes = parameterTypes.clone();
+		this.parameterTypeNames = ClassUtils.nullSafeToString(Class::getTypeName, this.parameterTypes);
+	}
+
 	MethodSelector(Class<?> javaClass, Method method) {
 		this.classLoader = javaClass.getClassLoader();
 		this.javaClass = javaClass;
 		this.className = javaClass.getName();
 		this.javaMethod = method;
 		this.methodName = method.getName();
-		this.parameterTypeNames = ClassUtils.nullSafeToString(method.getParameterTypes());
+		this.parameterTypes = method.getParameterTypes();
+		this.parameterTypeNames = ClassUtils.nullSafeToString(Class::getTypeName, this.parameterTypes);
 	}
 
 	/**
@@ -121,10 +146,10 @@ public class MethodSelector implements DiscoverySelector {
 	 *
 	 * <p>See {@link #getParameterTypeNames()} for details.
 	 *
-	 * @return the names of parameter types supplied to this {@code MethodSelector}
-	 * via a constructor or deduced from a {@code Method} or parameter types supplied
-	 * via a constructor; never {@code null} but potentially an empty string
+	 * @return the names of parameter types
 	 * @since 1.0
+	 * @see #getParameterTypeNames()
+	 * @see #getParameterTypes()
 	 * @deprecated since 1.10 in favor of {@link #getParameterTypeNames()}
 	 */
 	@Deprecated
@@ -144,9 +169,10 @@ public class MethodSelector implements DiscoverySelector {
 	 * the caller of this method to determine how to parse the returned string.
 	 *
 	 * @return the names of parameter types supplied to this {@code MethodSelector}
-	 * via a constructor or deduced from a {@code Method} supplied via a constructor;
-	 * never {@code null} but potentially an empty string
+	 * via a constructor or deduced from a {@code Method} or parameter types supplied
+	 * via a constructor; never {@code null} but potentially an empty string
 	 * @since 1.10
+	 * @see #getParameterTypes()
 	 */
 	@API(status = STABLE, since = "1.10")
 	public String getParameterTypeNames() {
@@ -182,6 +208,27 @@ public class MethodSelector implements DiscoverySelector {
 		return this.javaMethod;
 	}
 
+	/**
+	 * Get the parameter types for the selected method.
+	 *
+	 * <p>If the parameter types were not provided as {@link Class} references
+	 * (or could not be deduced as {@code Class} references in the constructor),
+	 * this method attempts to lazily load the class reference for each parameter
+	 * type based on its name and throws a {@link JUnitException} if the class
+	 * cannot be loaded.
+	 *
+	 * @return the method's parameter types; never {@code null} but potentially
+	 * an empty array if the selected method does not declare parameters
+	 * @since 1.10
+	 * @see #getParameterTypeNames()
+	 * @see Method#getParameterTypes()
+	 */
+	@API(status = EXPERIMENTAL, since = "1.10")
+	public Class<?>[] getParameterTypes() {
+		lazyLoadParameterTypes();
+		return this.parameterTypes.clone();
+	}
+
 	private void lazyLoadJavaClass() {
 		// @formatter:off
 		if (this.javaClass == null) {
@@ -197,9 +244,10 @@ public class MethodSelector implements DiscoverySelector {
 	private void lazyLoadJavaMethod() {
 		if (this.javaMethod == null) {
 			lazyLoadJavaClass();
-			if (StringUtils.isNotBlank(this.parameterTypeNames)) {
+			lazyLoadParameterTypes();
+			if (this.parameterTypes.length > 0) {
 				this.javaMethod = ReflectionUtils.findMethod(this.javaClass, this.methodName,
-					this.parameterTypeNames).orElseThrow(
+					this.parameterTypes).orElseThrow(
 						() -> new PreconditionViolationException(String.format(
 							"Could not find method with name [%s] and parameter types [%s] in class [%s].",
 							this.methodName, this.parameterTypeNames, this.javaClass.getName())));
@@ -213,6 +261,14 @@ public class MethodSelector implements DiscoverySelector {
 		}
 	}
 
+	private void lazyLoadParameterTypes() {
+		if (this.parameterTypes == null) {
+			lazyLoadJavaClass();
+			this.parameterTypes = ReflectionUtils.resolveParameterTypes(this.javaClass, this.methodName,
+				this.parameterTypeNames);
+		}
+	}
+
 	/**
 	 * @since 1.3
 	 */
diff --git a/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/NestedMethodSelector.java b/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/NestedMethodSelector.java
index 0d4ebb51a..22e1ffdef 100644
--- a/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/NestedMethodSelector.java
+++ b/junit-platform-engine/src/main/java/org/junit/platform/engine/discovery/NestedMethodSelector.java
@@ -33,9 +33,9 @@ import org.junit.platform.engine.DiscoverySelector;
  * <p>If a Java {@link Method} is provided, the selector will return that
  * {@linkplain #getMethod() method} and its method name, class name, enclosing
  * classes names, and parameter types accordingly. If class names or method names
- * are provided, this selector will only attempt to lazily load the {@link Class}
- * or {@link Method} if {@link #getEnclosingClasses()},
- * {@link #getNestedClass()}, or {@link #getMethod()} is invoked.
+ * are provided, this selector will only attempt to lazily load a class or method
+ * if {@link #getEnclosingClasses()}, {@link #getNestedClass()},
+ * {@link #getMethod()}, or {@link #getParameterTypes()} is invoked.
  *
  * <p>In this context, a Java {@code Method} means anything that can be referenced
  * as a {@link Method} on the JVM &mdash; for example, methods from Java classes
@@ -63,12 +63,30 @@ public class NestedMethodSelector implements DiscoverySelector {
 		this.methodSelector = new MethodSelector(classLoader, nestedClassName, methodName, parameterTypeNames);
 	}
 
+	/**
+	 * @since 1.10
+	 */
+	NestedMethodSelector(ClassLoader classLoader, List<String> enclosingClassNames, String nestedClassName,
+			String methodName, Class<?>... parameterTypes) {
+		this.nestedClassSelector = new NestedClassSelector(classLoader, enclosingClassNames, nestedClassName);
+		this.methodSelector = new MethodSelector(classLoader, nestedClassName, methodName, parameterTypes);
+	}
+
 	NestedMethodSelector(List<Class<?>> enclosingClasses, Class<?> nestedClass, String methodName,
 			String parameterTypeNames) {
 		this.nestedClassSelector = new NestedClassSelector(enclosingClasses, nestedClass);
 		this.methodSelector = new MethodSelector(nestedClass, methodName, parameterTypeNames);
 	}
 
+	/**
+	 * @since 1.10
+	 */
+	NestedMethodSelector(List<Class<?>> enclosingClasses, Class<?> nestedClass, String methodName,
+			Class<?>... parameterTypes) {
+		this.nestedClassSelector = new NestedClassSelector(enclosingClasses, nestedClass);
+		this.methodSelector = new MethodSelector(nestedClass, methodName, parameterTypes);
+	}
+
 	NestedMethodSelector(List<Class<?>> enclosingClasses, Class<?> nestedClass, Method method) {
 		this.nestedClassSelector = new NestedClassSelector(enclosingClasses, nestedClass);
 		this.methodSelector = new MethodSelector(nestedClass, method);
@@ -147,10 +165,10 @@ public class NestedMethodSelector implements DiscoverySelector {
 	 *
 	 * <p>See {@link #getParameterTypeNames()} for details.
 	 *
-	 * @return the names of parameter types supplied to this {@code NestedMethodSelector}
-	 * via a constructor or deduced from a {@code Method} supplied via a constructor;
-	 * never {@code null} but potentially an empty string
+	 * @return the names of parameter types
 	 * @since 1.6
+	 * @see #getParameterTypeNames()
+	 * @see #getParameterTypes()
 	 * @deprecated since 1.10 in favor or {@link #getParameterTypeNames()}
 	 */
 	@Deprecated
@@ -160,25 +178,38 @@ public class NestedMethodSelector implements DiscoverySelector {
 	}
 
 	/**
-	 * Get the names of parameter types for the selected method as a {@link String},
-	 * typically a comma-separated list of primitive types, fully qualified
-	 * class names, or array types.
+	 * Get the names of parameter types for the selected method as a {@link String}.
 	 *
-	 * <p>Note: the names of parameter types are provided as a single string instead
-	 * of a collection in order to allow this selector to be used in a generic
-	 * fashion by various test engines. It is therefore the responsibility of
-	 * the caller of this method to determine how to parse the returned string.
+	 * <p>See {@link MethodSelector#getParameterTypeNames()} for details.
 	 *
 	 * @return the names of parameter types supplied to this {@code NestedMethodSelector}
-	 * via a constructor or deduced from a {@code Method} supplied via a constructor;
-	 * never {@code null} but potentially an empty string
+	 * via a constructor or deduced from a {@code Method} or parameter types supplied
+	 * via a constructor; never {@code null} but potentially an empty string
 	 * @since 1.10
+	 * @see MethodSelector#getParameterTypeNames()
+	 *
 	 */
 	@API(status = STABLE, since = "1.10")
 	public String getParameterTypeNames() {
 		return this.methodSelector.getParameterTypeNames();
 	}
 
+	/**
+	 * Get the parameter types for the selected method.
+	 *
+	 * <p>See {@link MethodSelector#getParameterTypes()} for details.
+	 *
+	 * @return the method's parameter types; never {@code null} but potentially
+	 * an empty array if the selected method does not declare parameters
+	 * @since 1.10
+	 * @see #getParameterTypeNames()
+	 * @see MethodSelector#getParameterTypes()
+	 */
+	@API(status = EXPERIMENTAL, since = "1.10")
+	public Class<?>[] getParameterTypes() {
+		return this.methodSelector.getParameterTypes();
+	}
+
 	@Override
 	public boolean equals(Object o) {
 		if (this == o) {
diff --git a/platform-tests/src/test/java/org/junit/platform/engine/discovery/DiscoverySelectorsTests.java b/platform-tests/src/test/java/org/junit/platform/engine/discovery/DiscoverySelectorsTests.java
index a2e4af211..dfb967afd 100644
--- a/platform-tests/src/test/java/org/junit/platform/engine/discovery/DiscoverySelectorsTests.java
+++ b/platform-tests/src/test/java/org/junit/platform/engine/discovery/DiscoverySelectorsTests.java
@@ -314,7 +314,7 @@ class DiscoverySelectorsTests {
 		}
 
 		@Test
-		void selectClassByNameAndClassLoader() throws Exception {
+		void selectClassByNameWithExplicitClassLoader() throws Exception {
 			try (var testClassLoader = TestClassLoader.forClasses(getClass())) {
 				var selector = selectClass(testClassLoader, getClass().getName());
 
@@ -353,6 +353,19 @@ class DiscoverySelectorsTests {
 			assertViolatesPrecondition(() -> selectMethod("TestClass", "method", (String) null));
 		}
 
+		@Test
+		@DisplayName("Preconditions: selectMethod(className, methodName, parameterTypes)")
+		void selectMethodByClassNameMethodNameAndParameterTypesPreconditions() {
+			assertViolatesPrecondition(() -> selectMethod("TestClass", null, int.class));
+			assertViolatesPrecondition(() -> selectMethod("TestClass", "", int.class));
+			assertViolatesPrecondition(() -> selectMethod("TestClass", "  ", int.class));
+			assertViolatesPrecondition(() -> selectMethod((String) null, "method", int.class));
+			assertViolatesPrecondition(() -> selectMethod("", "method", int.class));
+			assertViolatesPrecondition(() -> selectMethod("   ", "method", int.class));
+			assertViolatesPrecondition(() -> selectMethod("TestClass", "method", (Class<?>) null));
+			assertViolatesPrecondition(() -> selectMethod("TestClass", "method", new Class<?>[] { int.class, null }));
+		}
+
 		@Test
 		@DisplayName("Preconditions: selectMethod(class, methodName)")
 		void selectMethodByClassAndMethodNamePreconditions() {
@@ -413,7 +426,7 @@ class DiscoverySelectorsTests {
 		}
 
 		@Test
-		void selectMethodByFullyQualifiedNameAndClassLoader() throws Exception {
+		void selectMethodByFullyQualifiedNameWithExplicitClassLoader() throws Exception {
 			try (var testClassLoader = TestClassLoader.forClasses(testClass())) {
 				var clazz = testClassLoader.loadClass(testClass().getName());
 				assertThat(clazz).isNotEqualTo(testClass());
@@ -690,6 +703,58 @@ class DiscoverySelectorsTests {
 			assertThat(selector.getMethodName()).isEqualTo("myTest");
 			assertThat(selector.getJavaMethod()).isEqualTo(method);
 			assertThat(selector.getParameterTypeNames()).isEqualTo("java.lang.String, boolean[]");
+			assertThat(selector.getParameterTypes()).containsExactly(String.class, boolean[].class);
+		}
+
+		@Test
+		void selectMethodByClassNameMethodNameAndParameterTypes() throws Exception {
+			var testClass = testClass();
+			var method = testClass.getDeclaredMethod("myTest", String.class, boolean[].class);
+
+			var selector = selectMethod(testClass.getName(), "myTest", String.class, boolean[].class);
+
+			assertThat(selector.getClassName()).isEqualTo(testClass.getName());
+			assertThat(selector.getJavaClass()).isEqualTo(testClass);
+			assertThat(selector.getMethodName()).isEqualTo("myTest");
+			assertThat(selector.getJavaMethod()).isEqualTo(method);
+			assertThat(selector.getParameterTypeNames()).isEqualTo("java.lang.String, boolean[]");
+			assertThat(selector.getParameterTypes()).containsExactly(String.class, boolean[].class);
+		}
+
+		@Test
+		void selectMethodByClassNameMethodNameAndParameterTypeNamesWithExplicitClassLoader() throws Exception {
+			var testClass = testClass();
+
+			try (var testClassLoader = TestClassLoader.forClasses(testClass)) {
+				var clazz = testClassLoader.loadClass(testClass.getName());
+				assertThat(clazz).isNotEqualTo(testClass);
+
+				var method = clazz.getDeclaredMethod("myTest", String.class, boolean[].class);
+				var selector = selectMethod(testClassLoader, testClass.getName(), "myTest",
+					"java.lang.String, boolean[]");
+
+				assertThat(selector.getClassName()).isEqualTo(clazz.getName());
+				assertThat(selector.getJavaClass()).isEqualTo(clazz);
+				assertThat(selector.getMethodName()).isEqualTo(method.getName());
+				assertThat(selector.getJavaMethod()).isEqualTo(method);
+				assertThat(selector.getParameterTypeNames()).isEqualTo("java.lang.String, boolean[]");
+				assertThat(selector.getParameterTypes()).containsExactly(String.class, boolean[].class);
+			}
+		}
+
+		@Test
+		void selectMethodByClassMethodNameAndParameterTypes() throws Exception {
+			var testClass = testClass();
+			var method = testClass.getDeclaredMethod("myTest", String.class, boolean[].class);
+
+			var selector = selectMethod(testClass, "myTest", String.class, boolean[].class);
+
+			assertThat(selector.getClassName()).isEqualTo(testClass.getName());
+			assertThat(selector.getJavaClass()).isEqualTo(testClass);
+			assertThat(selector.getMethodName()).isEqualTo("myTest");
+			assertThat(selector.getJavaMethod()).isEqualTo(method);
+			assertThat(selector.getParameterTypeNames()).isEqualTo("java.lang.String, boolean[]");
+			assertThat(selector.getParameterTypes()).containsExactly(String.class, boolean[].class);
 		}
 
 		@Test
@@ -703,7 +768,8 @@ class DiscoverySelectorsTests {
 			assertThat(selector.getJavaClass()).isEqualTo(testClass);
 			assertThat(selector.getMethodName()).isEqualTo("myTest");
 			assertThat(selector.getJavaMethod()).isEqualTo(method);
-			assertThat(selector.getParameterTypeNames()).isEqualTo("java.lang.String, [Z");
+			assertThat(selector.getParameterTypeNames()).isEqualTo("java.lang.String, boolean[]");
+			assertThat(selector.getParameterTypes()).containsExactly(String.class, boolean[].class);
 		}
 
 		@Test
@@ -734,7 +800,7 @@ class DiscoverySelectorsTests {
 	class SelectNestedClassAndSelectNestedMethodTests {
 
 		private final String enclosingClassName = getClass().getName() + "$ClassWithNestedInnerClass";
-		private final String nestedClassName = getClass().getName() + "$AbstractClassWithNestedInnerClass$NestedClass";
+		private final String nestedClassName = getClass().getName() + "$ClassWithNestedInnerClass$NestedClass";
 		private final String doubleNestedClassName = nestedClassName + "$DoubleNestedClass";
 		private final String methodName = "nestedTest";
 
@@ -743,23 +809,22 @@ class DiscoverySelectorsTests {
 			var selector = selectNestedClass(List.of(enclosingClassName), nestedClassName);
 
 			assertThat(selector.getEnclosingClasses()).containsOnly(ClassWithNestedInnerClass.class);
-			assertThat(selector.getNestedClass()).isEqualTo(AbstractClassWithNestedInnerClass.NestedClass.class);
+			assertThat(selector.getNestedClass()).isEqualTo(ClassWithNestedInnerClass.NestedClass.class);
 
 			assertThat(selector.getEnclosingClassNames()).containsOnly(enclosingClassName);
 			assertThat(selector.getNestedClassName()).isEqualTo(nestedClassName);
 		}
 
 		@Test
-		void selectNestedClassByClassNamesAndClassLoader() throws Exception {
-			var testClasses = List.of(AbstractClassWithNestedInnerClass.class, ClassWithNestedInnerClass.class,
-				AbstractClassWithNestedInnerClass.NestedClass.class);
+		void selectNestedClassByClassNamesWithExplicitClassLoader() throws Exception {
+			var testClasses = List.of(ClassWithNestedInnerClass.class, ClassWithNestedInnerClass.NestedClass.class);
 
 			try (var testClassLoader = TestClassLoader.forClasses(testClasses)) {
 				var selector = selectNestedClass(testClassLoader, List.of(enclosingClassName), nestedClassName);
 
 				assertThat(selector.getEnclosingClasses()).doesNotContain(ClassWithNestedInnerClass.class);
 				assertThat(selector.getEnclosingClasses()).extracting(Class::getName).containsOnly(enclosingClassName);
-				assertThat(selector.getNestedClass()).isNotEqualTo(AbstractClassWithNestedInnerClass.NestedClass.class);
+				assertThat(selector.getNestedClass()).isNotEqualTo(ClassWithNestedInnerClass.NestedClass.class);
 				assertThat(selector.getNestedClass().getName()).isEqualTo(nestedClassName);
 
 				assertThat(selector.getClassLoader()).isSameAs(testClassLoader);
@@ -774,9 +839,9 @@ class DiscoverySelectorsTests {
 			var selector = selectNestedClass(List.of(enclosingClassName, nestedClassName), doubleNestedClassName);
 
 			assertThat(selector.getEnclosingClasses()).containsExactly(ClassWithNestedInnerClass.class,
-				AbstractClassWithNestedInnerClass.NestedClass.class);
+				ClassWithNestedInnerClass.NestedClass.class);
 			assertThat(selector.getNestedClass()).isEqualTo(
-				AbstractClassWithNestedInnerClass.NestedClass.DoubleNestedClass.class);
+				ClassWithNestedInnerClass.NestedClass.DoubleNestedClass.class);
 
 			assertThat(selector.getEnclosingClassNames()).containsExactly(enclosingClassName, nestedClassName);
 			assertThat(selector.getNestedClassName()).isEqualTo(doubleNestedClassName);
@@ -796,7 +861,7 @@ class DiscoverySelectorsTests {
 			var selector = selectNestedMethod(List.of(enclosingClassName), nestedClassName, methodName);
 
 			assertThat(selector.getEnclosingClasses()).containsOnly(ClassWithNestedInnerClass.class);
-			assertThat(selector.getNestedClass()).isEqualTo(AbstractClassWithNestedInnerClass.NestedClass.class);
+			assertThat(selector.getNestedClass()).isEqualTo(ClassWithNestedInnerClass.NestedClass.class);
 			assertThat(selector.getMethod()).isEqualTo(selector.getNestedClass().getDeclaredMethod(methodName));
 
 			assertThat(selector.getEnclosingClassNames()).containsOnly(enclosingClassName);
@@ -805,9 +870,8 @@ class DiscoverySelectorsTests {
 		}
 
 		@Test
-		void selectNestedMethodByEnclosingClassNamesAndMethodNameAndClassLoader() throws Exception {
-			var testClasses = List.of(AbstractClassWithNestedInnerClass.class, ClassWithNestedInnerClass.class,
-				AbstractClassWithNestedInnerClass.NestedClass.class);
+		void selectNestedMethodByEnclosingClassNamesAndMethodNameWithExplicitClassLoader() throws Exception {
+			var testClasses = List.of(ClassWithNestedInnerClass.class, ClassWithNestedInnerClass.NestedClass.class);
 
 			try (var testClassLoader = TestClassLoader.forClasses(testClasses)) {
 				var selector = selectNestedMethod(testClassLoader, List.of(enclosingClassName), nestedClassName,
@@ -815,7 +879,7 @@ class DiscoverySelectorsTests {
 
 				assertThat(selector.getEnclosingClasses()).doesNotContain(ClassWithNestedInnerClass.class);
 				assertThat(selector.getEnclosingClasses()).extracting(Class::getName).containsOnly(enclosingClassName);
-				assertThat(selector.getNestedClass()).isNotEqualTo(AbstractClassWithNestedInnerClass.NestedClass.class);
+				assertThat(selector.getNestedClass()).isNotEqualTo(ClassWithNestedInnerClass.NestedClass.class);
 				assertThat(selector.getNestedClass().getName()).isEqualTo(nestedClassName);
 
 				assertThat(selector.getClassLoader()).isSameAs(testClassLoader);
@@ -830,10 +894,10 @@ class DiscoverySelectorsTests {
 		@Test
 		void selectNestedMethodByEnclosingClassesAndMethodName() throws Exception {
 			var selector = selectNestedMethod(List.of(ClassWithNestedInnerClass.class),
-				AbstractClassWithNestedInnerClass.NestedClass.class, methodName);
+				ClassWithNestedInnerClass.NestedClass.class, methodName);
 
 			assertThat(selector.getEnclosingClasses()).containsOnly(ClassWithNestedInnerClass.class);
-			assertThat(selector.getNestedClass()).isEqualTo(AbstractClassWithNestedInnerClass.NestedClass.class);
+			assertThat(selector.getNestedClass()).isEqualTo(ClassWithNestedInnerClass.NestedClass.class);
 			assertThat(selector.getMethod()).isEqualTo(selector.getNestedClass().getDeclaredMethod(methodName));
 
 			assertThat(selector.getEnclosingClassNames()).containsOnly(enclosingClassName);
@@ -842,12 +906,12 @@ class DiscoverySelectorsTests {
 		}
 
 		@Test
-		void selectNestedMethodByEnclosingClassNamesAndMethodNameWithParameterTypes() throws Exception {
+		void selectNestedMethodByEnclosingClassNamesMethodNameAndParameterTypeNames() throws Exception {
 			var selector = selectNestedMethod(List.of(enclosingClassName), nestedClassName, methodName,
 				String.class.getName());
 
 			assertThat(selector.getEnclosingClasses()).containsOnly(ClassWithNestedInnerClass.class);
-			assertThat(selector.getNestedClass()).isEqualTo(AbstractClassWithNestedInnerClass.NestedClass.class);
+			assertThat(selector.getNestedClass()).isEqualTo(ClassWithNestedInnerClass.NestedClass.class);
 			assertThat(selector.getMethod()).isEqualTo(
 				selector.getNestedClass().getDeclaredMethod(methodName, String.class));
 
@@ -856,18 +920,42 @@ class DiscoverySelectorsTests {
 			assertThat(selector.getMethodName()).isEqualTo(methodName);
 		}
 
+		/**
+		 * @since 1.0
+		 */
 		@Test
-		void selectNestedMethodByEnclosingClassNamesAndMethodNameWithParameterTypesAndClassLoader() throws Exception {
-			var testClasses = List.of(AbstractClassWithNestedInnerClass.class, ClassWithNestedInnerClass.class,
-				AbstractClassWithNestedInnerClass.NestedClass.class);
+		void selectNestedMethodByEnclosingClassNamesMethodNameAndParameterTypes() throws Exception {
+			var selector = selectNestedMethod(List.of(enclosingClassName), nestedClassName, methodName, String.class);
 
-			try (var testClassLoader = TestClassLoader.forClasses(testClasses.toArray(Class[]::new))) {
+			assertThat(selector.getEnclosingClasses()).containsOnly(ClassWithNestedInnerClass.class);
+			assertThat(selector.getNestedClass()).isEqualTo(ClassWithNestedInnerClass.NestedClass.class);
+			assertThat(selector.getMethod()).isEqualTo(
+				selector.getNestedClass().getDeclaredMethod(methodName, String.class));
+			assertThat(selector.getParameterTypes()).containsExactly(String.class);
+
+			assertThat(selector.getEnclosingClassNames()).containsOnly(enclosingClassName);
+			assertThat(selector.getNestedClassName()).isEqualTo(nestedClassName);
+			assertThat(selector.getMethodName()).isEqualTo(methodName);
+			assertThat(selector.getParameterTypeNames()).isEqualTo("java.lang.String");
+		}
+
+		/**
+		 * @since 1.10
+		 */
+		@Test
+		void selectNestedMethodByEnclosingClassNamesMethodNameAndParameterTypeNamesWithExplicitClassLoader()
+				throws Exception {
+
+			var enclosingClass = ClassWithNestedInnerClass.class;
+			var nestedClass = ClassWithNestedInnerClass.NestedClass.class;
+
+			try (var testClassLoader = TestClassLoader.forClasses(enclosingClass, nestedClass)) {
 				var selector = selectNestedMethod(testClassLoader, List.of(enclosingClassName), nestedClassName,
 					methodName, String.class.getName());
 
-				assertThat(selector.getEnclosingClasses()).doesNotContain(ClassWithNestedInnerClass.class);
+				assertThat(selector.getEnclosingClasses()).doesNotContain(enclosingClass);
 				assertThat(selector.getEnclosingClasses()).extracting(Class::getName).containsOnly(enclosingClassName);
-				assertThat(selector.getNestedClass()).isNotEqualTo(AbstractClassWithNestedInnerClass.NestedClass.class);
+				assertThat(selector.getNestedClass()).isNotEqualTo(nestedClass);
 				assertThat(selector.getNestedClass().getName()).isEqualTo(nestedClassName);
 
 				assertThat(selector.getClassLoader()).isSameAs(testClassLoader);
@@ -880,6 +968,26 @@ class DiscoverySelectorsTests {
 			}
 		}
 
+		/**
+		 * @since 1.10
+		 */
+		@Test
+		void selectNestedMethodByEnclosingClassesMethodNameAndParameterTypes() throws Exception {
+			var selector = selectNestedMethod(List.of(ClassWithNestedInnerClass.class),
+				ClassWithNestedInnerClass.NestedClass.class, methodName, String.class);
+
+			assertThat(selector.getEnclosingClasses()).containsOnly(ClassWithNestedInnerClass.class);
+			assertThat(selector.getNestedClass()).isEqualTo(ClassWithNestedInnerClass.NestedClass.class);
+			assertThat(selector.getMethod()).isEqualTo(
+				selector.getNestedClass().getDeclaredMethod(methodName, String.class));
+			assertThat(selector.getParameterTypes()).containsExactly(String.class);
+
+			assertThat(selector.getEnclosingClassNames()).containsOnly(enclosingClassName);
+			assertThat(selector.getNestedClassName()).isEqualTo(nestedClassName);
+			assertThat(selector.getMethodName()).isEqualTo(methodName);
+			assertThat(selector.getParameterTypeNames()).isEqualTo("java.lang.String");
+		}
+
 		@Test
 		void selectDoubleNestedMethodByEnclosingClassNamesAndMethodName() throws Exception {
 			var doubleNestedMethodName = "doubleNestedTest";
@@ -887,9 +995,9 @@ class DiscoverySelectorsTests {
 				doubleNestedMethodName);
 
 			assertThat(selector.getEnclosingClasses()).containsExactly(ClassWithNestedInnerClass.class,
-				AbstractClassWithNestedInnerClass.NestedClass.class);
+				ClassWithNestedInnerClass.NestedClass.class);
 			assertThat(selector.getNestedClass()).isEqualTo(
-				AbstractClassWithNestedInnerClass.NestedClass.DoubleNestedClass.class);
+				ClassWithNestedInnerClass.NestedClass.DoubleNestedClass.class);
 			assertThat(selector.getMethod()).isEqualTo(
 				selector.getNestedClass().getDeclaredMethod(doubleNestedMethodName));
 
@@ -899,53 +1007,88 @@ class DiscoverySelectorsTests {
 		}
 
 		@Test
-		void selectNestedMethodPreconditions() {
+		@DisplayName("Preconditions: selectNestedMethod(enclosingClassNames, nestedClassName, methodName)")
+		void selectNestedMethodByEnclosingClassNamesAndMethodNamePreconditions() {
 			assertViolatesPrecondition(() -> selectNestedMethod(null, "ClassName", "methodName"));
-			assertViolatesPrecondition(() -> selectNestedMethod(null, "ClassName", "methodName", "int"));
 			assertViolatesPrecondition(() -> selectNestedMethod(List.of(), "ClassName", "methodName"));
-			assertViolatesPrecondition(() -> selectNestedMethod(List.of(), "ClassName", "methodName", "int"));
 			assertViolatesPrecondition(() -> selectNestedMethod(List.of("ClassName"), null, "methodName"));
-			assertViolatesPrecondition(() -> selectNestedMethod(List.of("ClassName"), null, "methodName", "int"));
 			assertViolatesPrecondition(() -> selectNestedMethod(List.of("ClassName"), " ", "methodName"));
-			assertViolatesPrecondition(() -> selectNestedMethod(List.of("ClassName"), " ", "methodName", "int"));
 			assertViolatesPrecondition(() -> selectNestedMethod(List.of("ClassName"), "ClassName", null));
-			assertViolatesPrecondition(() -> selectNestedMethod(List.of("ClassName"), "ClassName", null, "int"));
 			assertViolatesPrecondition(() -> selectNestedMethod(List.of("ClassName"), "ClassName", " "));
+		}
+
+		@Test
+		@DisplayName("Preconditions: selectNestedMethod(enclosingClassNames, nestedClassName, methodName, parameterTypeNames)")
+		void selectNestedMethodByEnclosingClassNamesMethodNameAndParameterTypeNamesPreconditions() {
+			assertViolatesPrecondition(() -> selectNestedMethod(null, "ClassName", "methodName", "int"));
+			assertViolatesPrecondition(() -> selectNestedMethod(List.of(), "ClassName", "methodName", "int"));
+			assertViolatesPrecondition(() -> selectNestedMethod(List.of("ClassName"), null, "methodName", "int"));
+			assertViolatesPrecondition(() -> selectNestedMethod(List.of("ClassName"), " ", "methodName", "int"));
+			assertViolatesPrecondition(() -> selectNestedMethod(List.of("ClassName"), "ClassName", null, "int"));
 			assertViolatesPrecondition(() -> selectNestedMethod(List.of("ClassName"), "ClassName", " ", "int"));
 			assertViolatesPrecondition(
 				() -> selectNestedMethod(List.of("ClassName"), "ClassName", "methodName", (String) null));
 		}
 
-		abstract class AbstractClassWithNestedInnerClass {
+		/**
+		 * @since 1.10
+		 */
+		@Test
+		@DisplayName("Preconditions: selectNestedMethod(enclosingClassNames, nestedClassName, methodName, parameterTypes)")
+		void selectNestedMethodByEnclosingClassNamesMethodNameAndParameterTypesPreconditions() {
+			assertViolatesPrecondition(() -> selectNestedMethod(null, "ClassName", "methodName", int.class));
+			assertViolatesPrecondition(() -> selectNestedMethod(List.of(), "ClassName", "methodName", int.class));
+			assertViolatesPrecondition(() -> selectNestedMethod(List.of("ClassName"), null, "methodName", int.class));
+			assertViolatesPrecondition(() -> selectNestedMethod(List.of("ClassName"), " ", "methodName", int.class));
+			assertViolatesPrecondition(() -> selectNestedMethod(List.of("ClassName"), "ClassName", null, int.class));
+			assertViolatesPrecondition(() -> selectNestedMethod(List.of("ClassName"), "ClassName", " ", int.class));
+			assertViolatesPrecondition(
+				() -> selectNestedMethod(List.of("ClassName"), "ClassName", "methodName", (Class<?>) null));
+			assertViolatesPrecondition(() -> selectNestedMethod(List.of("ClassName"), "ClassName", "methodName",
+				new Class<?>[] { int.class, null }));
+		}
+
+		/**
+		 * @since 1.10
+		 */
+		@Test
+		@DisplayName("Preconditions: selectNestedMethod(enclosingClasses, nestedClass, methodName, parameterTypes)")
+		void selectNestedMethodByEnclosingClassesClassMethodNameAndParameterTypesPreconditions() {
+			List<Class<?>> enclosingClassList = List.of(ClassWithNestedInnerClass.class);
+			Class<?> nestedClass = ClassWithNestedInnerClass.NestedClass.class;
+
+			assertViolatesPrecondition(() -> selectNestedMethod(null, nestedClass, "methodName", int.class));
+			assertViolatesPrecondition(() -> selectNestedMethod(List.of(), nestedClass, "methodName", int.class));
+			assertViolatesPrecondition(() -> selectNestedMethod(enclosingClassList, null, "methodName", int.class));
+			assertViolatesPrecondition(() -> selectNestedMethod(enclosingClassList, nestedClass, null, int.class));
+			assertViolatesPrecondition(() -> selectNestedMethod(enclosingClassList, nestedClass, " ", int.class));
+			assertViolatesPrecondition(
+				() -> selectNestedMethod(enclosingClassList, nestedClass, "methodName", (Class<?>) null));
+			assertViolatesPrecondition(() -> selectNestedMethod(enclosingClassList, nestedClass, "methodName",
+				new Class<?>[] { int.class, null }));
+		}
+
+		static class ClassWithNestedInnerClass {
 
-			@Nested
+			// @Nested
 			class NestedClass {
 
-				@Test
+				// @Test
 				void nestedTest() {
 				}
 
-				@Test
+				// @Test
 				void nestedTest(String parameter) {
 				}
 
-				@Nested
+				// @Nested
 				class DoubleNestedClass {
 
-					@Test
+					// @Test
 					void doubleNestedTest() {
 					}
-
 				}
-
 			}
-
-		}
-
-		class ClassWithNestedInnerClass extends AbstractClassWithNestedInnerClass {
-		}
-
-		class OtherClassWithNestedInnerClass extends AbstractClassWithNestedInnerClass {
 		}
 
 	}
diff --git a/platform-tests/src/test/java/org/junit/platform/engine/discovery/MethodSelectorTests.java b/platform-tests/src/test/java/org/junit/platform/engine/discovery/MethodSelectorTests.java
index 9f314ef7d..b6d890ba0 100644
--- a/platform-tests/src/test/java/org/junit/platform/engine/discovery/MethodSelectorTests.java
+++ b/platform-tests/src/test/java/org/junit/platform/engine/discovery/MethodSelectorTests.java
@@ -35,8 +35,9 @@ class MethodSelectorTests extends AbstractEqualsAndHashCodeTests {
 		var selector1 = new MethodSelector(null, TEST_CASE_NAME, "method", "int, boolean");
 		var selector2 = new MethodSelector(null, TEST_CASE_NAME, "method", "int, boolean");
 		var selector3 = new MethodSelector(TestCase.class, "method", "int, boolean");
+		var selector4 = new MethodSelector(TestCase.class, "method", int.class, boolean.class);
 
-		Stream.of(selector2, selector3).forEach(selector -> {
+		Stream.of(selector2, selector3, selector4).forEach(selector -> {
 			assertEqualsAndHashCode(selector1, selector, new MethodSelector(null, TEST_CASE_NAME, "method", "int"));
 			assertEqualsAndHashCode(selector1, selector,
 				new MethodSelector((ClassLoader) null, TEST_CASE_NAME, "method", ""));
