diff --git a/documentation/src/docs/asciidoc/release-notes/release-notes-6.1.0-M1.adoc b/documentation/src/docs/asciidoc/release-notes/release-notes-6.1.0-M1.adoc
index d255eb410..f22f682ab 100644
--- a/documentation/src/docs/asciidoc/release-notes/release-notes-6.1.0-M1.adoc
+++ b/documentation/src/docs/asciidoc/release-notes/release-notes-6.1.0-M1.adoc
@@ -45,7 +45,12 @@ repository on GitHub.
 [[release-notes-6.1.0-M1-junit-jupiter-new-features-and-improvements]]
 ==== New Features and Improvements
 
-* ‚ùì
+* Introduce new `dynamicTest(Consumer<? super Configuration>)` factory method for dynamic
+  tests. It allows configuring the `ExecutionMode` of the dynamic test in addition to its
+  display name, test source URI, and executable.
+* Introduce new `dynamicContainer(Consumer<? super Configuration>)` factory method for
+  dynamic containers. It allows configuring the `ExecutionMode` of the dynamic container
+  and/or its children in addition to its display name, test source URI, and children.
 
 
 [[release-notes-6.1.0-M1-junit-vintage]]
diff --git a/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc b/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
index 828c740cd..ebb3c1af7 100644
--- a/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
+++ b/documentation/src/docs/asciidoc/user-guide/writing-tests.adoc
@@ -3106,6 +3106,29 @@ implementations.
 `UriSource` ::
   If none of the above `TestSource` implementations are applicable.
 
+[[writing-tests-dynamic-tests-parallel-execution]]
+==== Parallel Execution
+
+Dynamic tests and containers support
+<<writing-tests-parallel-execution, parallel execution>>. You can configure their
+`ExecutionMode` by using the `dynamicTest(Consumer)` and `dynamicContainer(Consumer)`
+factory methods as illustrated by the following example.
+
+[source,java,indent=0]
+----
+include::{testDir}/example/DynamicTestsDemo.java[tags=execution_mode]
+----
+
+Executing the above test factory method results in the following test tree and execution
+modes:
+
+* dynamicTestsWithConfiguredExecutionMode() -- `CONCURRENT` (from `@Execution` annotation)
+** Container A -- `CONCURRENT` (from `@Execution` annotation)
+*** not null -- `SAME_THREAD` (from `executionMode(...)` call)
+*** properties -- `CONCURRENT` (from `@Execution` annotation)
+**** length > 0 -- `CONCURRENT` (from `executionMode(...)` call)
+**** not empty -- `SAME_THREAD` (from `childExecutionMode(...)` call)
+** ... (same for "Container B" and "Container C")
 
 [[writing-tests-declarative-timeouts]]
 === Timeouts
diff --git a/documentation/src/test/java/example/DynamicTestsDemo.java b/documentation/src/test/java/example/DynamicTestsDemo.java
index 547a3e122..d9c341b17 100644
--- a/documentation/src/test/java/example/DynamicTestsDemo.java
+++ b/documentation/src/test/java/example/DynamicTestsDemo.java
@@ -18,6 +18,8 @@ import static org.junit.jupiter.api.Assertions.assertNotNull;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 import static org.junit.jupiter.api.DynamicContainer.dynamicContainer;
 import static org.junit.jupiter.api.DynamicTest.dynamicTest;
+import static org.junit.jupiter.api.parallel.ExecutionMode.CONCURRENT;
+import static org.junit.jupiter.api.parallel.ExecutionMode.SAME_THREAD;
 
 import java.util.Arrays;
 import java.util.Collection;
@@ -35,6 +37,7 @@ import org.junit.jupiter.api.DynamicTest;
 import org.junit.jupiter.api.Tag;
 import org.junit.jupiter.api.TestFactory;
 import org.junit.jupiter.api.function.ThrowingConsumer;
+import org.junit.jupiter.api.parallel.Execution;
 
 // end::user_guide[]
 // @formatter:off
@@ -163,6 +166,44 @@ class DynamicTestsDemo {
 			)));
 	}
 
+	// end::user_guide[]
+	// tag::execution_mode[]
+	@TestFactory
+	@Execution(CONCURRENT) // <1>
+	Stream<DynamicNode> dynamicTestsWithConfiguredExecutionMode() {
+		return Stream.of("A", "B", "C")
+				.map(input ->
+					dynamicContainer(outer -> outer
+						.displayName("Container " + input)
+						.children(
+							dynamicTest(config -> config
+								.displayName("not null")
+								.executionMode(SAME_THREAD) // <2>
+								.executable(() -> assertNotNull(input))
+							),
+							dynamicContainer(inner -> inner
+								.displayName("properties")
+								.executionMode(CONCURRENT) // <3>
+								.childExecutionMode(SAME_THREAD) // <4>
+								.children(
+									dynamicTest(config -> config
+										.displayName("length > 0")
+										.executionMode(CONCURRENT) // <5>
+										.executable(() -> assertTrue(input.length() > 0))
+									),
+									dynamicTest(config -> config
+										.displayName("not empty")
+										.executable(() -> assertFalse(input.isEmpty()))
+									)
+								)
+							)
+						)
+					)
+				);
+	}
+	// end::execution_mode[]
+
+	// tag::user_guide[]
 	@TestFactory
 	DynamicNode dynamicNodeSingleTest() {
 		return dynamicTest("'pop' is a palindrome", () -> assertTrue(isPalindrome("pop")));
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DynamicContainer.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DynamicContainer.java
index 2bdf44fda..998cc868c 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DynamicContainer.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DynamicContainer.java
@@ -10,14 +10,19 @@
 
 package org.junit.jupiter.api;
 
+import static org.apiguardian.api.API.Status.EXPERIMENTAL;
 import static org.apiguardian.api.API.Status.MAINTAINED;
 
 import java.net.URI;
+import java.util.List;
+import java.util.Optional;
+import java.util.function.Consumer;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
 
 import org.apiguardian.api.API;
 import org.jspecify.annotations.Nullable;
+import org.junit.jupiter.api.parallel.ExecutionMode;
 import org.junit.platform.commons.util.Preconditions;
 
 /**
@@ -38,6 +43,8 @@ import org.junit.platform.commons.util.Preconditions;
 @API(status = MAINTAINED, since = "5.3")
 public class DynamicContainer extends DynamicNode {
 
+	private final @Nullable ExecutionMode childExecutionMode;
+
 	/**
 	 * Factory for creating a new {@code DynamicContainer} for the supplied display
 	 * name and collection of dynamic nodes.
@@ -51,7 +58,7 @@ public class DynamicContainer extends DynamicNode {
 	 * @see #dynamicContainer(String, Stream)
 	 */
 	public static DynamicContainer dynamicContainer(String displayName, Iterable<? extends DynamicNode> dynamicNodes) {
-		return dynamicContainer(displayName, null, StreamSupport.stream(dynamicNodes.spliterator(), false));
+		return dynamicContainer(config -> config.displayName(displayName).children(dynamicNodes));
 	}
 
 	/**
@@ -67,7 +74,7 @@ public class DynamicContainer extends DynamicNode {
 	 * @see #dynamicContainer(String, Iterable)
 	 */
 	public static DynamicContainer dynamicContainer(String displayName, Stream<? extends DynamicNode> dynamicNodes) {
-		return dynamicContainer(displayName, null, dynamicNodes);
+		return dynamicContainer(config -> config.displayName(displayName).children(dynamicNodes));
 	}
 
 	/**
@@ -88,15 +95,32 @@ public class DynamicContainer extends DynamicNode {
 	public static DynamicContainer dynamicContainer(String displayName, @Nullable URI testSourceUri,
 			Stream<? extends DynamicNode> dynamicNodes) {
 
-		return new DynamicContainer(displayName, testSourceUri, dynamicNodes);
+		return dynamicContainer(
+			config -> config.displayName(displayName).testSourceUri(testSourceUri).children(dynamicNodes));
+	}
+
+	/**
+	 * Factory for creating a new {@code DynamicTest} that is configured via the
+	 * supplied {@link Consumer} of {@link DynamicTest.Configuration}.
+	 *
+	 * @param configurer callback for configuring the resulting
+	 * {@code DynamicTest}; never {@code null}.
+	 *
+	 * @since 6.1
+	 */
+	@API(status = EXPERIMENTAL, since = "6.1")
+	public static DynamicContainer dynamicContainer(Consumer<? super Configuration> configurer) {
+		var configuration = new DefaultConfiguration();
+		configurer.accept(configuration);
+		return new DynamicContainer(configuration);
 	}
 
 	private final Stream<? extends DynamicNode> children;
 
-	private DynamicContainer(String displayName, @Nullable URI testSourceUri, Stream<? extends DynamicNode> children) {
-		super(displayName, testSourceUri);
-		Preconditions.notNull(children, "children must not be null");
-		this.children = children;
+	private DynamicContainer(DefaultConfiguration configuration) {
+		super(configuration);
+		this.children = Preconditions.notNull(configuration.children, "children must not be null");
+		this.childExecutionMode = configuration.childExecutionMode;
 	}
 
 	/**
@@ -107,4 +131,105 @@ public class DynamicContainer extends DynamicNode {
 		return children;
 	}
 
+	/**
+	 * {@return the {@link ExecutionMode} for
+	 * {@linkplain #getChildren() children} of this {@code DynamicContainer}
+	 * that is used unless they are
+	 * {@linkplain DynamicTest#getExecutionMode() configured} differently}.
+	 *
+	 * @since 6.1
+	 * @see DynamicTest#getExecutionMode()
+	 */
+	@API(status = EXPERIMENTAL, since = "6.1")
+	public Optional<ExecutionMode> getChildExecutionMode() {
+		return Optional.ofNullable(childExecutionMode);
+	}
+
+	/**
+	 * {@code Configuration} of a {@link DynamicContainer}.
+	 *
+	 * @since 6.1
+	 * @see DynamicContainer#dynamicContainer(Consumer)
+	 */
+	@API(status = EXPERIMENTAL, since = "6.1")
+	public sealed interface Configuration extends DynamicNode.Configuration<Configuration> {
+
+		/**
+		 * Set the
+		 * {@linkplain DynamicContainer#getChildExecutionMode() child execution mode}
+		 * to use for the configured {@link DynamicContainer}.
+		 *
+		 * @return this configuration for method chaining
+		 */
+		Configuration childExecutionMode(ExecutionMode executionMode);
+
+		/**
+		 * Set the {@linkplain DynamicContainer#getChildren() children} of the
+		 * configured {@link DynamicContainer}.
+		 *
+		 * <p>Any previously configured value is overridden.
+		 *
+		 * @param children the children; never {@code null} or containing
+		 * {@code null} elements
+		 * @return this configuration for method chaining
+		 */
+		default Configuration children(Iterable<? extends DynamicNode> children) {
+			Preconditions.notNull(children, "children must not be null");
+			return children(StreamSupport.stream(children.spliterator(), false));
+		}
+
+		/**
+		 * Set the {@linkplain DynamicContainer#getChildren() children} of the
+		 * configured {@link DynamicContainer}.
+		 *
+		 * <p>Any previously configured value is overridden.
+		 *
+		 * @param children the children; never {@code null} or containing
+		 * {@code null} elements
+		 * @return this configuration for method chaining
+		 */
+		default Configuration children(DynamicNode... children) {
+			Preconditions.notNull(children, "children must not be null");
+			Preconditions.containsNoNullElements(children, "children must not contain null elements");
+			return children(List.of(children));
+		}
+
+		/**
+		 * Set the {@linkplain DynamicContainer#getChildren() children} of the
+		 * configured {@link DynamicContainer}.
+		 *
+		 * <p>Any previously configured value is overridden.
+		 *
+		 * @param children the children; never {@code null} or containing
+		 * {@code null} elements
+		 * @return this configuration for method chaining
+		 */
+		Configuration children(Stream<? extends DynamicNode> children);
+
+	}
+
+	static final class DefaultConfiguration extends AbstractConfiguration<Configuration> implements Configuration {
+
+		private @Nullable Stream<? extends DynamicNode> children;
+		private @Nullable ExecutionMode childExecutionMode;
+
+		@Override
+		public Configuration childExecutionMode(ExecutionMode executionMode) {
+			this.childExecutionMode = Preconditions.notNull(executionMode, "executionMode must not be null");
+			return this;
+		}
+
+		@Override
+		public Configuration children(Stream<? extends DynamicNode> children) {
+			Preconditions.notNull(children, "children must not be null");
+			Preconditions.condition(this.children == null, "children can only be set once");
+			this.children = children;
+			return this;
+		}
+
+		@Override
+		protected Configuration self() {
+			return this;
+		}
+	}
 }
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DynamicNode.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DynamicNode.java
index 0f4d66c5b..8879d35fc 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DynamicNode.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DynamicNode.java
@@ -10,6 +10,7 @@
 
 package org.junit.jupiter.api;
 
+import static org.apiguardian.api.API.Status.EXPERIMENTAL;
 import static org.apiguardian.api.API.Status.MAINTAINED;
 
 import java.net.URI;
@@ -17,6 +18,7 @@ import java.util.Optional;
 
 import org.apiguardian.api.API;
 import org.jspecify.annotations.Nullable;
+import org.junit.jupiter.api.parallel.ExecutionMode;
 import org.junit.platform.commons.util.Preconditions;
 import org.junit.platform.commons.util.ToStringBuilder;
 
@@ -36,9 +38,12 @@ public abstract class DynamicNode {
 	/** Custom test source {@link URI} associated with this node; potentially {@code null}. */
 	private final @Nullable URI testSourceUri;
 
-	DynamicNode(String displayName, @Nullable URI testSourceUri) {
-		this.displayName = Preconditions.notBlank(displayName, "displayName must not be null or blank");
-		this.testSourceUri = testSourceUri;
+	private final @Nullable ExecutionMode executionMode;
+
+	DynamicNode(AbstractConfiguration<?> configuration) {
+		this.displayName = Preconditions.notBlank(configuration.displayName, "displayName must not be null or blank");
+		this.testSourceUri = configuration.testSourceUri;
+		this.executionMode = configuration.executionMode;
 	}
 
 	/**
@@ -61,6 +66,17 @@ public abstract class DynamicNode {
 		return Optional.ofNullable(testSourceUri);
 	}
 
+	/**
+	 * {@return the {@link ExecutionMode} of this {@code DynamicNode}}
+	 *
+	 * @since 6.1
+	 * @see DynamicContainer#getChildExecutionMode()
+	 */
+	@API(status = EXPERIMENTAL, since = "6.1")
+	public Optional<ExecutionMode> getExecutionMode() {
+		return Optional.ofNullable(executionMode);
+	}
+
 	@Override
 	public String toString() {
 		return new ToStringBuilder(this) //
@@ -69,4 +85,73 @@ public abstract class DynamicNode {
 				.toString();
 	}
 
+	/**
+	 * {@code Configuration} of a {@link DynamicNode} or one of its
+	 * subinterfaces.
+	 *
+	 * @since 6.1
+	 * @see DynamicTest.Configuration
+	 * @see DynamicContainer.Configuration
+	 */
+	@API(status = EXPERIMENTAL, since = "6.1")
+	public sealed interface Configuration<T extends Configuration<T>>
+			permits DynamicTest.Configuration, DynamicContainer.Configuration, AbstractConfiguration {
+
+		/**
+		 * Set the {@linkplain DynamicNode#getDisplayName() display name} to use
+		 * for the configured {@link DynamicNode}.
+		 *
+		 * @param displayName the display name; never {@code null} or blank
+		 * @return this configuration for method chaining
+		 */
+		T displayName(String displayName);
+
+		/**
+		 * Set the {@linkplain DynamicNode#getTestSourceUri() test source URI}
+		 * to use for the configured {@link DynamicNode}.
+		 *
+		 * @param testSourceUri the test source URI; may be {@code null}
+		 * @return this configuration for method chaining
+		 */
+		T testSourceUri(@Nullable URI testSourceUri);
+
+		/**
+		 * Set the {@linkplain DynamicNode#getExecutionMode() execution mode} to
+		 * use for the configured {@link DynamicNode}.
+		 *
+		 * @param executionMode the execution mode; never {@code null}
+		 * @return this configuration for method chaining
+		 */
+		T executionMode(ExecutionMode executionMode);
+
+	}
+
+	abstract static sealed class AbstractConfiguration<T extends Configuration<T>> implements Configuration<T>
+			permits DynamicTest.DefaultConfiguration, DynamicContainer.DefaultConfiguration {
+
+		private @Nullable String displayName;
+		private @Nullable URI testSourceUri;
+		private @Nullable ExecutionMode executionMode;
+
+		@Override
+		public T displayName(String displayName) {
+			this.displayName = Preconditions.notBlank(displayName, "displayName must not be null or blank");
+			return self();
+		}
+
+		@Override
+		public T testSourceUri(@Nullable URI testSourceUri) {
+			this.testSourceUri = testSourceUri;
+			return self();
+		}
+
+		@Override
+		public T executionMode(ExecutionMode executionMode) {
+			this.executionMode = Preconditions.notNull(executionMode, "executionMode must not be null");
+			return self();
+		}
+
+		protected abstract T self();
+	}
+
 }
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DynamicTest.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DynamicTest.java
index 54b8fdc3a..7021ed70d 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DynamicTest.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DynamicTest.java
@@ -12,10 +12,12 @@ package org.junit.jupiter.api;
 
 import static java.util.Spliterator.ORDERED;
 import static java.util.Spliterators.spliteratorUnknownSize;
+import static org.apiguardian.api.API.Status.EXPERIMENTAL;
 import static org.apiguardian.api.API.Status.MAINTAINED;
 
 import java.net.URI;
 import java.util.Iterator;
+import java.util.function.Consumer;
 import java.util.function.Function;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
@@ -61,7 +63,7 @@ public class DynamicTest extends DynamicNode {
 	 * @see #stream(Iterator, Function, ThrowingConsumer)
 	 */
 	public static DynamicTest dynamicTest(String displayName, Executable executable) {
-		return new DynamicTest(displayName, null, executable);
+		return dynamicTest(config -> config.displayName(displayName).executable(executable));
 	}
 
 	/**
@@ -79,7 +81,24 @@ public class DynamicTest extends DynamicNode {
 	 * @see #stream(Iterator, Function, ThrowingConsumer)
 	 */
 	public static DynamicTest dynamicTest(String displayName, @Nullable URI testSourceUri, Executable executable) {
-		return new DynamicTest(displayName, testSourceUri, executable);
+		return dynamicTest(
+			config -> config.displayName(displayName).testSourceUri(testSourceUri).executable(executable));
+	}
+
+	/**
+	 * Factory for creating a new {@code DynamicTest} that is configured via the
+	 * supplied {@link Consumer} of {@link Configuration}.
+	 *
+	 * @param configurer callback for configuring the resulting
+	 * {@code DynamicTest}; never {@code null}.
+	 *
+	 * @since 6.1
+	 */
+	@API(status = EXPERIMENTAL, since = "6.1")
+	public static DynamicTest dynamicTest(Consumer<? super Configuration> configurer) {
+		var configuration = new DefaultConfiguration();
+		configurer.accept(configuration);
+		return new DynamicTest(configuration);
 	}
 
 	/**
@@ -290,9 +309,9 @@ public class DynamicTest extends DynamicNode {
 
 	private final Executable executable;
 
-	private DynamicTest(String displayName, @Nullable URI testSourceUri, Executable executable) {
-		super(displayName, testSourceUri);
-		this.executable = Preconditions.notNull(executable, "executable must not be null");
+	private DynamicTest(DefaultConfiguration configuration) {
+		super(configuration);
+		this.executable = Preconditions.notNull(configuration.executable, "executable must not be null");
 	}
 
 	/**
@@ -302,4 +321,40 @@ public class DynamicTest extends DynamicNode {
 		return this.executable;
 	}
 
+	/**
+	 * {@code Configuration} of a {@link DynamicTest}.
+	 *
+	 * @since 6.1
+	 * @see DynamicTest#dynamicTest(Consumer)
+	 */
+	@API(status = EXPERIMENTAL, since = "6.1")
+	public sealed interface Configuration extends DynamicNode.Configuration<Configuration> {
+
+		/**
+		 * Set the {@linkplain DynamicTest#getExecutable() executable} to use
+		 * for the configured {@link DynamicTest}.
+		 *
+		 * @param executable the executable; never {@code null} or blank
+		 * @return this configuration for method chaining
+		 */
+		Configuration executable(Executable executable);
+
+	}
+
+	static final class DefaultConfiguration extends AbstractConfiguration<Configuration> implements Configuration {
+
+		private @Nullable Executable executable;
+
+		@Override
+		public Configuration executable(Executable executable) {
+			this.executable = Preconditions.notNull(executable, "executable must not be null");
+			return this;
+		}
+
+		@Override
+		protected Configuration self() {
+			return this;
+		}
+	}
+
 }
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTestDescriptor.java
index 6cd75e33e..8997975b5 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/ClassTestDescriptor.java
@@ -83,9 +83,8 @@ public class ClassTestDescriptor extends ClassBasedTestDescriptor {
 	// --- Node ----------------------------------------------------------------
 
 	@Override
-	public ExecutionMode getExecutionMode() {
-		return getExplicitExecutionMode().orElseGet(
-			() -> JupiterTestDescriptor.toExecutionMode(configuration.getDefaultClassesExecutionMode()));
+	ExecutionMode getDefaultExecutionMode() {
+		return toExecutionMode(configuration.getDefaultClassesExecutionMode());
 	}
 
 	// --- ClassBasedTestDescriptor --------------------------------------------
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DynamicContainerTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DynamicContainerTestDescriptor.java
index c5ade6601..28d9021ca 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DynamicContainerTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DynamicContainerTestDescriptor.java
@@ -58,6 +58,11 @@ class DynamicContainerTestDescriptor extends DynamicNodeTestDescriptor {
 		return Type.CONTAINER;
 	}
 
+	@Override
+	Optional<ExecutionMode> getExplicitChildExecutionMode() {
+		return this.dynamicContainer.getChildExecutionMode().map(JupiterTestDescriptor::toExecutionMode);
+	}
+
 	@Override
 	public JupiterEngineExecutionContext execute(JupiterEngineExecutionContext context,
 			DynamicTestExecutor dynamicTestExecutor) throws Exception {
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DynamicNodeTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DynamicNodeTestDescriptor.java
index f68c98b48..2a84f4757 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DynamicNodeTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/DynamicNodeTestDescriptor.java
@@ -10,6 +10,8 @@
 
 package org.junit.jupiter.engine.descriptor;
 
+import java.util.Optional;
+
 import org.jspecify.annotations.Nullable;
 import org.junit.jupiter.api.DynamicNode;
 import org.junit.jupiter.api.extension.ExtensionContext;
@@ -27,11 +29,18 @@ import org.junit.platform.engine.UniqueId;
 abstract class DynamicNodeTestDescriptor extends JupiterTestDescriptor {
 
 	protected final int index;
+	private final Optional<ExecutionMode> executionMode;
 
 	DynamicNodeTestDescriptor(UniqueId uniqueId, int index, DynamicNode dynamicNode, @Nullable TestSource testSource,
 			JupiterConfiguration configuration) {
 		super(uniqueId, dynamicNode.getDisplayName(), testSource, configuration);
 		this.index = index;
+		this.executionMode = dynamicNode.getExecutionMode().map(JupiterTestDescriptor::toExecutionMode);
+	}
+
+	@Override
+	Optional<ExecutionMode> getExplicitExecutionMode() {
+		return executionMode;
 	}
 
 	@Override
diff --git a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/JupiterTestDescriptor.java b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/JupiterTestDescriptor.java
index 8bd1c7941..dd0a612b7 100644
--- a/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/JupiterTestDescriptor.java
+++ b/junit-jupiter-engine/src/main/java/org/junit/jupiter/engine/descriptor/JupiterTestDescriptor.java
@@ -29,6 +29,7 @@ import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.Consumer;
 import java.util.function.Supplier;
 import java.util.function.UnaryOperator;
+import java.util.stream.Stream;
 
 import org.apiguardian.api.API;
 import org.jspecify.annotations.Nullable;
@@ -132,24 +133,32 @@ public abstract class JupiterTestDescriptor extends AbstractTestDescriptor
 	// --- Node ----------------------------------------------------------------
 
 	@Override
-	public ExecutionMode getExecutionMode() {
-		Optional<ExecutionMode> executionMode = getExplicitExecutionMode();
-		if (executionMode.isPresent()) {
-			return executionMode.get();
-		}
-		Optional<TestDescriptor> parent = getParent();
-		while (parent.isPresent() && parent.get() instanceof JupiterTestDescriptor jupiterParent) {
-			executionMode = jupiterParent.getExplicitExecutionMode();
-			if (executionMode.isPresent()) {
-				return executionMode.get();
-			}
-			executionMode = jupiterParent.getDefaultChildExecutionMode();
-			if (executionMode.isPresent()) {
-				return executionMode.get();
-			}
-			parent = jupiterParent.getParent();
-		}
-		return toExecutionMode(configuration.getDefaultExecutionMode());
+	public final ExecutionMode getExecutionMode() {
+		return getExplicitExecutionMode() //
+				.or(this::determineExecutionModeFromAncestors) //
+				.orElseGet(this::getDefaultExecutionMode);
+	}
+
+	private Optional<ExecutionMode> determineExecutionModeFromAncestors() {
+		return ancestors() //
+				.takeWhile(it -> it instanceof JupiterTestDescriptor) //
+				.flatMap(ancestor -> determineExecutionModeFromAncestor((JupiterTestDescriptor) ancestor).stream()) //
+				.findFirst();
+	}
+
+	private static Optional<ExecutionMode> determineExecutionModeFromAncestor(JupiterTestDescriptor ancestor) {
+		return ancestor.getExplicitChildExecutionMode() //
+				.or(ancestor::getExplicitExecutionMode) //
+				.or(ancestor::getDefaultChildExecutionMode);
+	}
+
+	Stream<TestDescriptor> ancestors() {
+		return Stream.iterate(getParent(), Optional::isPresent, it -> it.flatMap(TestDescriptor::getParent)) //
+				.map(Optional::orElseThrow);
+	}
+
+	Optional<ExecutionMode> getExplicitChildExecutionMode() {
+		return Optional.empty();
 	}
 
 	Optional<ExecutionMode> getExplicitExecutionMode() {
@@ -157,7 +166,11 @@ public abstract class JupiterTestDescriptor extends AbstractTestDescriptor
 	}
 
 	Optional<ExecutionMode> getDefaultChildExecutionMode() {
-		return Optional.empty();
+		return getExplicitChildExecutionMode();
+	}
+
+	ExecutionMode getDefaultExecutionMode() {
+		return toExecutionMode(configuration.getDefaultExecutionMode());
 	}
 
 	Optional<ExecutionMode> getExecutionModeFromAnnotation(AnnotatedElement element) {
diff --git a/jupiter-tests/src/test/java/org/junit/jupiter/api/DynamicContainerTests.java b/jupiter-tests/src/test/java/org/junit/jupiter/api/DynamicContainerTests.java
new file mode 100644
index 000000000..0e6a9ba75
--- /dev/null
+++ b/jupiter-tests/src/test/java/org/junit/jupiter/api/DynamicContainerTests.java
@@ -0,0 +1,97 @@
+/*
+ * Copyright 2015-2025 the original author or authors.
+ *
+ * All rights reserved. This program and the accompanying materials are
+ * made available under the terms of the Eclipse Public License v2.0 which
+ * accompanies this distribution and is available at
+ *
+ * https://www.eclipse.org/legal/epl-v20.html
+ */
+
+package org.junit.jupiter.api;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.jupiter.api.DynamicContainer.dynamicContainer;
+import static org.junit.jupiter.api.DynamicTest.dynamicTest;
+import static org.junit.jupiter.api.parallel.ExecutionMode.CONCURRENT;
+import static org.junit.jupiter.api.parallel.ExecutionMode.SAME_THREAD;
+import static org.junit.platform.commons.test.PreconditionAssertions.assertPreconditionViolationFor;
+import static org.junit.platform.commons.test.PreconditionAssertions.assertPreconditionViolationNotNullFor;
+import static org.junit.platform.commons.test.PreconditionAssertions.assertPreconditionViolationNotNullOrBlankFor;
+
+import java.net.URI;
+import java.util.Collection;
+import java.util.List;
+import java.util.stream.Stream;
+
+/**
+ * @since 6.1
+ */
+class DynamicContainerTests {
+
+	@Test
+	void appliesConfiguration() {
+		var child = dynamicTest("Test", Assertions::fail);
+
+		var container = dynamicContainer(config -> config //
+				.displayName("Container") //
+				.testSourceUri(URI.create("https://junit.org")) //
+				.executionMode(CONCURRENT) //
+				.childExecutionMode(SAME_THREAD) //
+				.children(child));
+
+		assertThat(container.getDisplayName()).isEqualTo("Container");
+		assertThat(container.getTestSourceUri()).contains(URI.create("https://junit.org"));
+		assertThat(container.getExecutionMode()).contains(CONCURRENT);
+		assertThat(container.getChildExecutionMode()).contains(SAME_THREAD);
+		assertThat(container.getChildren().map(DynamicNode.class::cast)).containsExactly(child);
+	}
+
+	@Test
+	void displayNameMustNotBeBlank() {
+		assertPreconditionViolationNotNullOrBlankFor("displayName", () -> dynamicContainer(__ -> {
+		}));
+		assertPreconditionViolationNotNullOrBlankFor("displayName",
+			() -> dynamicContainer(config -> config.displayName("")));
+	}
+
+	@SuppressWarnings("DataFlowIssue")
+	@Test
+	void executionModeMustNotBeNull() {
+		assertPreconditionViolationNotNullFor("executionMode",
+			() -> dynamicContainer(config -> config.executionMode(null)));
+	}
+
+	@SuppressWarnings("DataFlowIssue")
+	@Test
+	void childExecutionModeMustNotBeNull() {
+		assertPreconditionViolationNotNullFor("executionMode",
+			() -> dynamicContainer(config -> config.childExecutionMode(null)));
+	}
+
+	@SuppressWarnings("DataFlowIssue")
+	@Test
+	void childrenMustBeConfigured() {
+		assertPreconditionViolationNotNullFor("children",
+			() -> dynamicContainer(config -> config.children((DynamicNode[]) null)));
+		assertPreconditionViolationNotNullFor("children",
+			() -> dynamicContainer(config -> config.children((Stream<? extends DynamicNode>) null)));
+		assertPreconditionViolationNotNullFor("children",
+			() -> dynamicContainer(config -> config.children((Collection<? extends DynamicNode>) null)));
+		assertPreconditionViolationNotNullFor("children",
+			() -> dynamicContainer(config -> config.displayName("container")));
+		assertPreconditionViolationFor(() -> dynamicContainer(config -> config.children((DynamicNode) null))) //
+				.withMessage("children must not contain null elements");
+	}
+
+	@Test
+	void childrenMustNotBeConfiguredMoreThanOnce() {
+		assertPreconditionViolationFor(() -> dynamicContainer(config -> config.children().children())) //
+				.withMessage("children can only be set once");
+		assertPreconditionViolationFor(() -> dynamicContainer(config -> config.children().children(Stream.empty()))) //
+				.withMessage("children can only be set once");
+		assertPreconditionViolationFor(() -> dynamicContainer(config -> config.children().children(List.of()))) //
+				.withMessage("children can only be set once");
+	}
+
+}
diff --git a/jupiter-tests/src/test/java/org/junit/jupiter/api/DynamicTestTests.java b/jupiter-tests/src/test/java/org/junit/jupiter/api/DynamicTestTests.java
index d45427ed1..7c29b4fdb 100644
--- a/jupiter-tests/src/test/java/org/junit/jupiter/api/DynamicTestTests.java
+++ b/jupiter-tests/src/test/java/org/junit/jupiter/api/DynamicTestTests.java
@@ -15,7 +15,10 @@ import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.jupiter.api.Assertions.assertThrows;
 import static org.junit.jupiter.api.DynamicContainer.dynamicContainer;
 import static org.junit.jupiter.api.DynamicTest.dynamicTest;
+import static org.junit.jupiter.api.parallel.ExecutionMode.CONCURRENT;
 import static org.junit.platform.commons.test.PreconditionAssertions.assertPreconditionViolationFor;
+import static org.junit.platform.commons.test.PreconditionAssertions.assertPreconditionViolationNotNullFor;
+import static org.junit.platform.commons.test.PreconditionAssertions.assertPreconditionViolationNotNullOrBlankFor;
 
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
@@ -217,6 +220,42 @@ class DynamicTestTests {
 			"DynamicContainer [displayName = 'bar', testSourceUri = other://container]");
 	}
 
+	@Test
+	void appliesConfiguration() {
+		Executable executable = Assertions::fail;
+
+		var test = dynamicTest(config -> config //
+				.displayName("Container") //
+				.testSourceUri(URI.create("https://junit.org")) //
+				.executionMode(CONCURRENT).executable(executable));
+
+		assertThat(test.getDisplayName()).isEqualTo("Container");
+		assertThat(test.getTestSourceUri()).contains(URI.create("https://junit.org"));
+		assertThat(test.getExecutionMode()).contains(CONCURRENT);
+		assertThat(test.getExecutable()).isSameAs(executable);
+	}
+
+	@Test
+	void displayNameMustNotBeBlank() {
+		assertPreconditionViolationNotNullOrBlankFor("displayName", () -> dynamicTest(__ -> {
+		}));
+		assertPreconditionViolationNotNullOrBlankFor("displayName",
+			() -> dynamicTest(config -> config.displayName("")));
+	}
+
+	@SuppressWarnings("DataFlowIssue")
+	@Test
+	void executionModeMustNotBeNull() {
+		assertPreconditionViolationNotNullFor("executionMode", () -> dynamicTest(config -> config.executionMode(null)));
+	}
+
+	@SuppressWarnings("DataFlowIssue")
+	@Test
+	void executableModeMustNotBeNull() {
+		assertPreconditionViolationNotNullFor("executable", () -> dynamicTest(config -> config.displayName("test")));
+		assertPreconditionViolationNotNullFor("executable", () -> dynamicTest(config -> config.executable(null)));
+	}
+
 	private void assert1Equals48Directly() {
 		Assertions.assertEquals(1, 48);
 	}
diff --git a/jupiter-tests/src/test/java/org/junit/jupiter/engine/descriptor/JupiterTestDescriptorTests.java b/jupiter-tests/src/test/java/org/junit/jupiter/engine/descriptor/JupiterTestDescriptorTests.java
index 053d03498..d33b3d0a8 100644
--- a/jupiter-tests/src/test/java/org/junit/jupiter/engine/descriptor/JupiterTestDescriptorTests.java
+++ b/jupiter-tests/src/test/java/org/junit/jupiter/engine/descriptor/JupiterTestDescriptorTests.java
@@ -278,6 +278,32 @@ class JupiterTestDescriptorTests {
 		assertThat(nestedDescriptor.getEnclosingTestClasses()).containsExactly(StaticTestCase.class);
 	}
 
+	@Test
+	void ancestorsAreConsistent() throws Exception {
+		ClassBasedTestDescriptor parentDescriptor = new ClassTestDescriptor(uniqueId, StaticTestCase.class,
+			configuration);
+
+		ClassBasedTestDescriptor nestedDescriptor = new NestedClassTestDescriptor(uniqueId, NestedTestCase.class,
+			List::of, configuration);
+		parentDescriptor.addChild(nestedDescriptor);
+
+		TestMethodTestDescriptor methodDescriptor = new TestMethodTestDescriptor(uniqueId, TestCase.class,
+			NestedTestCase.class.getDeclaredMethod("test"), List::of, configuration);
+		nestedDescriptor.addChild(methodDescriptor);
+
+		assertThat(methodDescriptor.ancestors()) //
+				.containsExactlyElementsOf(methodDescriptor.getAncestors()) //
+				.containsExactly(nestedDescriptor, parentDescriptor);
+
+		assertThat(nestedDescriptor.ancestors()) //
+				.containsExactlyElementsOf(nestedDescriptor.getAncestors()) //
+				.containsExactly(parentDescriptor);
+
+		assertThat(parentDescriptor.ancestors()) //
+				.containsExactlyElementsOf(parentDescriptor.getAncestors()) //
+				.isEmpty();
+	}
+
 	// -------------------------------------------------------------------------
 
 	@Test
@@ -392,6 +418,10 @@ class JupiterTestDescriptorTests {
 
 	@Nested
 	class NestedTestCase {
+
+		@Test
+		void test() {
+		}
 	}
 
 	static class StaticTestCase {
diff --git a/platform-tests/src/test/java/org/junit/platform/engine/support/hierarchical/ParallelExecutionIntegrationTests.java b/platform-tests/src/test/java/org/junit/platform/engine/support/hierarchical/ParallelExecutionIntegrationTests.java
index 624bd58d4..ddeaaf294 100644
--- a/platform-tests/src/test/java/org/junit/platform/engine/support/hierarchical/ParallelExecutionIntegrationTests.java
+++ b/platform-tests/src/test/java/org/junit/platform/engine/support/hierarchical/ParallelExecutionIntegrationTests.java
@@ -14,6 +14,7 @@ import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.junit.jupiter.api.DynamicContainer.dynamicContainer;
 import static org.junit.jupiter.api.DynamicTest.dynamicTest;
 import static org.junit.jupiter.api.parallel.ExecutionMode.CONCURRENT;
 import static org.junit.jupiter.api.parallel.ExecutionMode.SAME_THREAD;
@@ -26,6 +27,7 @@ import static org.junit.jupiter.engine.Constants.PARALLEL_CONFIG_STRATEGY_PROPER
 import static org.junit.jupiter.engine.Constants.PARALLEL_EXECUTION_ENABLED_PROPERTY_NAME;
 import static org.junit.platform.commons.util.CollectionUtils.getOnlyElement;
 import static org.junit.platform.engine.discovery.DiscoverySelectors.selectClasses;
+import static org.junit.platform.engine.discovery.DiscoverySelectors.selectMethod;
 import static org.junit.platform.engine.support.hierarchical.ExclusiveResource.GLOBAL_KEY;
 import static org.junit.platform.testkit.engine.EventConditions.container;
 import static org.junit.platform.testkit.engine.EventConditions.event;
@@ -46,12 +48,16 @@ import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.CyclicBarrier;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.locks.ReentrantLock;
+import java.util.function.UnaryOperator;
 import java.util.stream.IntStream;
 import java.util.stream.Stream;
 
 import org.assertj.core.api.Condition;
+import org.jspecify.annotations.NullMarked;
+import org.jspecify.annotations.Nullable;
 import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.DynamicContainer;
 import org.junit.jupiter.api.DynamicTest;
 import org.junit.jupiter.api.MethodOrderer.MethodName;
 import org.junit.jupiter.api.Nested;
@@ -61,13 +67,16 @@ import org.junit.jupiter.api.TestFactory;
 import org.junit.jupiter.api.TestMethodOrder;
 import org.junit.jupiter.api.TestReporter;
 import org.junit.jupiter.api.extension.AfterTestExecutionCallback;
+import org.junit.jupiter.api.extension.DynamicTestInvocationContext;
 import org.junit.jupiter.api.extension.ExtendWith;
 import org.junit.jupiter.api.extension.ExtensionContext;
+import org.junit.jupiter.api.extension.InvocationInterceptor;
 import org.junit.jupiter.api.parallel.Execution;
 import org.junit.jupiter.api.parallel.Isolated;
 import org.junit.jupiter.api.parallel.ResourceLock;
 import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.ValueSource;
+import org.junit.platform.engine.DiscoverySelector;
 import org.junit.platform.engine.TestDescriptor;
 import org.junit.platform.engine.reporting.ReportEntry;
 import org.junit.platform.engine.support.descriptor.MethodSource;
@@ -286,6 +295,19 @@ class ParallelExecutionIntegrationTests {
 		assertThat(ThreadReporter.getThreadNames(events)).hasSize(1);
 	}
 
+	@ParameterizedTest
+	@ValueSource(strings = { "testFactoryImplicitContainerAndExplicitChildExecutionMode",
+			"testFactoryExplicitContainerAndExplicitChildExecutionModeOnContainer",
+			"testFactoryExplicitContainerAndExplicitChildExecutionModeOnEachChild" })
+	void allowsToControlExecutionModeOfDynamicTestsAndContainers(String methodName) {
+
+		var results = executeWithFixedParallelism(3, Map.of(),
+			List.of(selectMethod(ConcurrentDynamicContainerTestCase.class, methodName)));
+
+		results.testEvents().assertStatistics(it -> it.succeeded(4));
+		assertThat(ThreadReporter.getThreadNames(results.testEvents().list())).hasSize(2);
+	}
+
 	@Isolated("testing")
 	static class IsolatedTestCase {
 		static AtomicInteger sharedResource;
@@ -554,8 +576,13 @@ class ParallelExecutionIntegrationTests {
 
 	private EngineExecutionResults executeWithFixedParallelism(int parallelism, Map<String, String> configParams,
 			Class<?>... testClasses) {
+		return executeWithFixedParallelism(parallelism, configParams, selectClasses(testClasses));
+	}
+
+	private static EngineExecutionResults executeWithFixedParallelism(int parallelism, Map<String, String> configParams,
+			List<? extends DiscoverySelector> selectors) {
 		return EngineTestKit.engine("junit-jupiter") //
-				.selectors(selectClasses(testClasses)) //
+				.selectors(selectors) //
 				.configurationParameter(PARALLEL_EXECUTION_ENABLED_PROPERTY_NAME, String.valueOf(true)) //
 				.configurationParameter(PARALLEL_CONFIG_STRATEGY_PROPERTY_NAME, "fixed") //
 				.configurationParameter(PARALLEL_CONFIG_FIXED_PARALLELISM_PROPERTY_NAME, String.valueOf(parallelism)) //
@@ -941,6 +968,63 @@ class ParallelExecutionIntegrationTests {
 	static class ParallelMethodsTestCaseC extends ParallelMethodsTestCase {
 	}
 
+	@ExtendWith(ThreadReporter.class)
+	static class ConcurrentDynamicContainerTestCase {
+
+		@TestFactory
+		@Execution(CONCURRENT)
+		Stream<DynamicContainer> testFactoryImplicitContainerAndExplicitChildExecutionMode() {
+			return testFactory(container -> container.childExecutionMode(SAME_THREAD), UnaryOperator.identity());
+		}
+
+		@TestFactory
+		Stream<DynamicContainer> testFactoryExplicitContainerAndExplicitChildExecutionModeOnContainer() {
+			return testFactory(container -> container.executionMode(CONCURRENT).childExecutionMode(SAME_THREAD),
+				UnaryOperator.identity());
+		}
+
+		@TestFactory
+		Stream<DynamicContainer> testFactoryExplicitContainerAndExplicitChildExecutionModeOnEachChild() {
+			return testFactory(container -> container.executionMode(CONCURRENT),
+				test -> test.executionMode(SAME_THREAD));
+		}
+
+		private Stream<DynamicContainer> testFactory(UnaryOperator<DynamicContainer.Configuration> containerConfigurer,
+				UnaryOperator<DynamicTest.Configuration> testsConfigurer) {
+
+			var sharedResource1 = new AtomicInteger();
+			var latch1 = new CountDownLatch(2);
+
+			var sharedResource2 = new AtomicInteger();
+			var latch2 = new CountDownLatch(2);
+
+			var tests1 = Stream.of( //
+				dynamicTest(config -> testsConfigurer.apply(config) //
+						.displayName("test1") //
+						.executable(() -> incrementAndBlock(sharedResource1, latch1))), //
+				dynamicTest(config -> testsConfigurer.apply(config) //
+						.displayName("test2") //
+						.executable(() -> incrementAndBlock(sharedResource2, latch2))));
+
+			var tests2 = Stream.of( //
+				dynamicTest(config -> testsConfigurer.apply(config) //
+						.displayName("test3") //
+						.executable(() -> incrementAndBlock(sharedResource1, latch1))), //
+				dynamicTest(config -> testsConfigurer.apply(config) //
+						.displayName("test4") //
+						.executable(() -> incrementAndBlock(sharedResource2, latch2))));
+
+			return Stream.of( //
+				dynamicContainer(config -> containerConfigurer.apply(config) //
+						.displayName("suite1") //
+						.children(tests1)), //
+				dynamicContainer(config -> containerConfigurer.apply(config) //
+						.displayName("suite2") //
+						.children(tests2)));
+		}
+
+	}
+
 	private static void incrementBlockAndCheck(AtomicInteger sharedResource, CountDownLatch countDownLatch)
 			throws InterruptedException {
 		var value = incrementAndBlock(sharedResource, countDownLatch);
@@ -980,7 +1064,8 @@ class ParallelExecutionIntegrationTests {
 		return runningInCi ? 1000 : 100;
 	}
 
-	static class ThreadReporter implements AfterTestExecutionCallback {
+	@NullMarked
+	static class ThreadReporter implements AfterTestExecutionCallback, InvocationInterceptor {
 
 		private static Stream<String> getLoaderNames(List<Event> events) {
 			return getValues(events, "loader");
@@ -1004,6 +1089,22 @@ class ParallelExecutionIntegrationTests {
 
 		@Override
 		public void afterTestExecution(ExtensionContext context) {
+			publishReportEntries(context);
+		}
+
+		@Override
+		public void interceptDynamicTest(Invocation<@Nullable Void> invocation,
+				DynamicTestInvocationContext invocationContext, ExtensionContext extensionContext) throws Throwable {
+
+			try {
+				invocation.proceed();
+			}
+			finally {
+				publishReportEntries(extensionContext);
+			}
+		}
+
+		private static void publishReportEntries(ExtensionContext context) {
 			context.publishReportEntry("thread", Thread.currentThread().getName());
 			context.publishReportEntry("loader", Thread.currentThread().getContextClassLoader().getName());
 		}
