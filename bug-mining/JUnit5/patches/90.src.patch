diff --git a/documentation/src/docs/asciidoc/release-notes-5.0.0-M5.adoc b/documentation/src/docs/asciidoc/release-notes-5.0.0-M5.adoc
index 446d09996..b0aa65486 100644
--- a/documentation/src/docs/asciidoc/release-notes-5.0.0-M5.adoc
+++ b/documentation/src/docs/asciidoc/release-notes-5.0.0-M5.adoc
@@ -132,7 +132,8 @@ is placed on the Java 9 module path.
   newly introduced engine-level `ExtensionContext`.
 * Argument providing methods referenced using `@MethodSource` may now return instances of
   `DoubleStream`, `IntStream`, and `LongStream` directly.
-
+* `@TestFactory` now supports arbitrarily nested dynamic containers. See `DynamicContainer`
+  and abstract base class `DynamicNode` for details.
 
 [[release-notes-5.0.0-m5-junit-vintage]]
 ==== JUnit Vintage
diff --git a/documentation/src/docs/asciidoc/writing-tests.adoc b/documentation/src/docs/asciidoc/writing-tests.adoc
index e1ddf0ead..45abaf6bc 100644
--- a/documentation/src/docs/asciidoc/writing-tests.adoc
+++ b/documentation/src/docs/asciidoc/writing-tests.adoc
@@ -785,8 +785,11 @@ that is annotated with `@TestFactory`.
 In contrast to `@Test` methods, a `@TestFactory` method is not itself a test case but rather a factory for test cases.
 Thus, a dynamic test is the product of a factory.
 Technically speaking, a `@TestFactory` method must return a `Stream`,
-`Collection`, `Iterable`, or `Iterator` of `DynamicTest` instances.
-These `DynamicTest` instances will then be executed lazily,
+`Collection`, `Iterable`, or `Iterator` of `DynamicNode` instances.
+Instantiable subclasses of `DynamicNode` are `DynamicContainer` and `DynamicTest`.
+`DynamicContainer` instances are composed of a _display name_ and a list of dynamic child nodes,
+enabling the creation of arbitrarily nested hierarchies of dynamic nodes.
+`DynamicTest` instances will then be executed lazily,
 enabling dynamic and even non-deterministic generation of test cases.
 
 Any `Stream` returned by a `@TestFactory` will be properly closed by calling `stream.close()`,
@@ -828,13 +831,15 @@ but merely demonstrate the supported return types in principle.
 However, `dynamicTestsFromStream()` and `dynamicTestsFromIntStream()` demonstrate how
 easy it is to generate dynamic tests for a given set of strings or a range of input numbers.
 
-The last method is truly dynamic in nature.
+The next method is truly dynamic in nature.
 `generateRandomNumberOfTests()` implements an `Iterator` that generates random numbers, a
 display name generator, and a test executor and then provides all three to `DynamicTest.stream()`.
 Although the non-deterministic behavior of `generateRandomNumberOfTests()` is of course in conflict with
 test repeatability and should thus be used with care, it serves to demonstrate the expressiveness
 and power of dynamic tests.
 
+The last method generates a nested hierarchy of dynamic tests utilizing `DynamicContainer`.
+
 [source,java]
 ----
 include::{testDir}/example/DynamicTestsDemo.java[tags=user_guide]
diff --git a/documentation/src/test/java/example/DynamicTestsDemo.java b/documentation/src/test/java/example/DynamicTestsDemo.java
index 088c89707..5fd779616 100644
--- a/documentation/src/test/java/example/DynamicTestsDemo.java
+++ b/documentation/src/test/java/example/DynamicTestsDemo.java
@@ -44,24 +44,6 @@ class DynamicTestsDemo {
 		return Arrays.asList("Hello");
 	}
 
-	@TestFactory
-	Stream<DynamicNode> dynamicTestsWithContainers() {
-		// end::user_guide[]
-		// @formatter:off
-		// tag::user_guide[]
-		return Stream.of("A", "B", "C")
-			.map(input -> dynamicContainer("Container " + input, Stream.of(
-				dynamicTest("not null", () -> assertNotNull(input)),
-				dynamicContainer("properties", Stream.of(
-					dynamicTest("length > 0", () -> assertTrue(input.length() > 0)),
-					dynamicTest("not empty", () -> assertFalse(input.isEmpty()))
-				))
-			)));
-		// end::user_guide[]
-		// @formatter:on
-		// tag::user_guide[]
-	}
-
 	@TestFactory
 	Collection<DynamicTest> dynamicTestsFromCollection() {
 		// end::user_guide[]
@@ -167,5 +149,25 @@ class DynamicTestsDemo {
 		return DynamicTest.stream(inputGenerator, displayNameGenerator, testExecutor);
 	}
 
+	@TestFactory
+	Stream<DynamicNode> dynamicTestsWithContainers() {
+		// end::user_guide[]
+		// @formatter:off
+		// tag::user_guide[]
+		return Stream.of("A", "B", "C")
+			.map(input -> dynamicContainer("Container " + input,
+				Stream.of(
+				dynamicTest("not null", () -> assertNotNull(input)),
+				dynamicContainer("properties",
+					Stream.of(
+					dynamicTest("length > 0", () -> assertTrue(input.length() > 0)),
+					dynamicTest("not empty", () -> assertFalse(input.isEmpty()))
+				))
+			)));
+		// end::user_guide[]
+		// @formatter:on
+		// tag::user_guide[]
+	}
+
 }
 // end::user_guide[]
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DynamicContainer.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DynamicContainer.java
index f5ccfac84..89cc9dbf1 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DynamicContainer.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/DynamicContainer.java
@@ -23,15 +23,43 @@ import org.junit.platform.commons.util.Preconditions;
 /**
  * A {@code DynamicContainer} is a container generated at runtime.
  *
+ * <p>It is composed of a {@linkplain #getDisplayName display name} and an
+ * iterable of {@link DynamicNode}s.
+ *
+ * <p>Instances of {@code DynamicContainer} must be generated by factory methods
+ * annotated with {@link TestFactory @TestFactory}.
+ *
  * @since 5.0
  */
 @API(Experimental)
 public class DynamicContainer extends DynamicNode {
 
+	/**
+	 * Factory for creating a new {@code DynamicContainer} for the supplied display
+	 * name and a collection of dynamic nodes.
+	 *
+	 * <p>The collection of dynamic nodes must not contain {@code null} elements.
+	 *
+	 * @param displayName the display name for the dynamic container; never
+	 * {@code null} or blank
+	 * @param dynamicNodes collection of dynamic nodes to execute;
+	 * never {@code null}
+	 */
 	public static DynamicContainer dynamicContainer(String displayName, Iterable<? extends DynamicNode> dynamicNodes) {
 		return new DynamicContainer(displayName, StreamSupport.stream(dynamicNodes.spliterator(), false));
 	}
 
+	/**
+	 * Factory for creating a new {@code DynamicContainer} for the supplied display
+	 * name and a stream of dynamic nodes.
+	 *
+	 * <p>The stream of dynamic nodes must not contain {@code null} elements.
+	 *
+	 * @param displayName the display name for the dynamic container; never
+	 * {@code null} or blank
+	 * @param dynamicNodes stream of dynamic nodes to execute;
+	 * never {@code null}
+	 */
 	public static DynamicContainer dynamicContainer(String displayName, Stream<? extends DynamicNode> dynamicNodes) {
 		return new DynamicContainer(displayName, dynamicNodes);
 	}
@@ -45,6 +73,9 @@ public class DynamicContainer extends DynamicNode {
 		Preconditions.containsNoNullElements(this.dynamicNodes, "individual dynamic node must not be null");
 	}
 
+	/**
+	 * Get the collection of {@code DynamicNode}s associated with this {@code DynamicContainer}.
+	 */
 	public Iterable<DynamicNode> getDynamicNodes() {
 		return dynamicNodes;
 	}
diff --git a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/TestFactory.java b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/TestFactory.java
index 51f00a9f9..a9b96f274 100644
--- a/junit-jupiter-api/src/main/java/org/junit/jupiter/api/TestFactory.java
+++ b/junit-jupiter-api/src/main/java/org/junit/jupiter/api/TestFactory.java
@@ -30,9 +30,10 @@ import org.junit.platform.commons.meta.API;
  *
  * <p>{@code @TestFactory} methods must not be {@code private} or {@code static}
  * and must return a {@code Stream}, {@code Collection}, {@code Iterable}, or
- * {@code Iterator} of {@link DynamicTest} instances. These {@code DynamicTests}
- * will then be executed lazily, enabling dynamic and even non-deterministic
- * generation of test cases.
+ * {@code Iterator} of {@link DynamicNode} instances. Valid, instantiable
+ * subclasses of {@code DynamicNode} are {@link DynamicContainer} and
+ * {@link DynamicTest}. These {@code DynamicTest}s  will then be executed lazily,
+ * enabling dynamic and even non-deterministic generation of test cases.
  *
  * <p>Any {@code Stream} returned by a {@code @TestFactory} will be properly
  * closed by calling {@code stream.close()}, making it safe to use a resource
@@ -44,7 +45,9 @@ import org.junit.platform.commons.meta.API;
  *
  * @since 5.0
  * @see Test
+ * @see DynamicNode
  * @see DynamicTest
+ * @see DynamicContainer
  */
 @Target({ ElementType.ANNOTATION_TYPE, ElementType.METHOD })
 @Retention(RetentionPolicy.RUNTIME)
